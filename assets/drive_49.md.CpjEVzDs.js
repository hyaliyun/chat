import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},A={class:"review-content"};function N(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const E=c(k,[["render",N],["__scopeId","data-v-63ddf599"]]),S=JSON.parse('[{"question":"You are provided with the implementation of a singly linked list and two functions, `remove_dups` and `remove_dups_without_set`, for removing duplicate elements from the list. Your task is to build upon this functionality to solve the following problem: # Task: Implement a function `remove_dups_from_unsorted_list(head, use_set=True)` that removes duplicates from an unsorted linked list. The function should use `remove_dups` if `use_set` is True, and `remove_dups_without_set` otherwise. # Function Signature: ```python def remove_dups_from_unsorted_list(head: Node, use_set: bool = True) -> Node: pass ``` # Input: * `head`: A pointer/reference to the head of the singly linked list. * `use_set`: A boolean value that indicates which removal method to use - `True` for `remove_dups` and `False` for `remove_dups_without_set`. # Output: * The head of the modified linked list with duplicates removed. # Example: ```python # Input list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g new_head = remove_dups_from_unsorted_list(a1, use_set=True) print_linked_list(new_head) # Expected Output: A -> B -> C -> D -> F -> G ``` # Constraints: * The linked list contains at most 10^4 elements. * Node values are unique strings with lengths between 1 and 100. # Notes: * The function should handle all edge cases efficiently. * Ensure proper memory management and pointer updates to maintain the structural integrity of the linked list.","solution":"class Node: def __init__(self, value): self.value = value self.next = None def remove_dups(head): if not head: return head node_set = set() current = head node_set.add(current.value) while current.next: if current.next.value in node_set: current.next = current.next.next else: node_set.add(current.next.value) current = current.next return head def remove_dups_without_set(head): if not head: return head current = head while current: runner = current while runner.next: if runner.next.value == current.value: runner.next = runner.next.next else: runner = runner.next current = current.next return head def remove_dups_from_unsorted_list(head: Node, use_set: bool = True) -> Node: if use_set: return remove_dups(head) else: return remove_dups_without_set(head)"},{"question":"Implement a Binary Search Tree (BST) to support the following operations: * Insert a value into the BST. * Search for a value in the BST. * Delete a value from the BST. * Check if the BST is balanced. # Constraints * Nodes will only contain integer values. * The BST should not allow duplicate values. Functions to Implement ```python class BST: def __init__(self): # Initialize an empty BST pass def insert(self, val: int) -> None: # Insert val into the BST. If val already exists, it should not be inserted again. pass def search(self, val: int) -> bool: # Search for val in the BST and return True if found, otherwise False. pass def delete(self, val: int) -> None: # Delete val from the BST. If val does not exist, do nothing. pass def is_balanced(self) -> bool: # Return True if the BST is balanced, otherwise False. # A balanced tree is defined here as a tree where the height of two subtrees of every node never differs by more than 1. pass ``` # Example ```python # Example Usage: bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) assert bst.search(10) == True assert bst.search(6) == False bst.delete(10) assert bst.search(10) == False assert bst.is_balanced() == True ``` **Performance Requirements**: * Your solution should aim to maintain average case time complexity of O(log n) for insert, search, and delete operations. Ensure the `is_balanced` operation runs efficiently. # Additional Notes * Focus on correctly managing pointers and edge cases. * Thoroughly test with balanced and unbalanced tree scenarios.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) elif val > node.val: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if not node: return False if node.val == val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left temp = self._find_min(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _find_min(self, node): while node.left: node = node.left return node def is_balanced(self) -> bool: def height_and_balance(node): if not node: return 0, True left_height, left_balanced = height_and_balance(node.left) right_height, right_balanced = height_and_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, is_bal = height_and_balance(self.root) return is_bal"},{"question":"Next Prime Number Generator Context Given the fundamental concept of checking for a prime number, let\'s extend this concept to generate the next prime number after a given integer `m`. Task Write a function `next_prime_after(m)` that takes an integer `m` and returns the smallest prime number greater than `m`. Input and Output Formats - Input: - An integer `m` (1 ≤ m ≤ 10^6) - Output: - An integer representing the next prime number after `m` Function Signature ```python def next_prime_after(m: int) -> int: pass ``` Constraints - Your function should be efficient and capable of handling the upper limits within a reasonable time frame. Example ```python print(next_prime_after(10)) # Output: 11 print(next_prime_after(14)) # Output: 17 ``` Make sure to handle edge cases efficiently and avoid unnecessary computations.","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def next_prime_after(m: int) -> int: num = m + 1 while not is_prime(num): num += 1 return num"},{"question":"Scenario You are developing a software for a new programming language that supports base conversion of numbers. To ease the developers, you must provide functions that can convert an integer to any base between 2 and 36, and vice versa. Problem Statement Implement two functions: 1. `convert_to_base(num, base)`: - **Input**: An integer `num` and a base `base` (2 <= base <= 36). - **Output**: A string representing the number in the given base. 2. `convert_from_base(str_num, base)`: - **Input**: A string `str_num` representing a number in a certain base, and a base `base` (2 <= base <= 36). - **Output**: An integer representing the decimal equivalent of the given number. Function Signatures ```python def convert_to_base(num: int, base: int) -> str: pass def convert_from_base(str_num: str, base: int) -> int: pass ``` Example Usage ```python print(convert_to_base(5, 2)) # Output: \'101\' print(convert_to_base(-27, 16)) # Output: \'-1B\' print(convert_from_base(\'101\', 2)) # Output: 5 print(convert_from_base(\'1B\', 16)) # Output: 27 ``` Constraints and Considerations * The base `base` will always be between 2 and 36 inclusive. * The functions should handle edge cases such as converting zero. * The `convert_to_base` function should manage negative numbers correctly. * Performance should be optimized for large numbers.","solution":"def convert_to_base(num: int, base: int) -> str: Converts an integer \'num\' to its string representation in a specified \'base\'. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36.\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num = num // base if is_negative: result.append(\'-\') result.reverse() return \'\'.join(result) def convert_from_base(str_num: str, base: int) -> int: Converts a string representation of a number \'str_num\' in a specified \'base\' to its decimal (base-10) integer equivalent. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_num = str_num.upper().strip() is_negative = str_num[0] == \'-\' if is_negative: str_num = str_num[1:] num = 0 for char in str_num: num = num * base + digits.index(char) return -num if is_negative else num"},{"question":"# Decoding Encoded Strings Given an encoded string, decode it according to the following rule: `k[encoded_string]`, where `k` is a positive integer, and `encoded_string` inside the square brackets is repeated exactly `k` times. Nested encodings are possible. Implement a function `decode_string` to perform this decoding. **Function Signature**: ```python def decode_string(s: str) -> str: ``` **Input**: - `s` (string): The encoded string. The string is non-empty and consists of digits, letters, and square brackets, adhering to the given format. **Output**: - `str`: The decoded string. **Constraints**: - The encoded string is valid; no extra white spaces, and square brackets are well-formed. - The input does not contain any digits outside of repetition counts. **Examples**: ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` Your task is to implement the function by considering potential edge cases and ensuring efficient processing under the given constraints.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append(current_string) stack.append(current_num) current_string = \\"\\" current_num = 0 elif char == \']\': num = stack.pop() prev_string = stack.pop() current_string = prev_string + num * current_string else: current_string += char return current_string"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Insertion Sort * **Type**: Sorting Algorithm * **Main Purpose**: To sort a list of elements in ascending order. Complexity * **Time Complexity**: * Best Case: (O(n)) - When the array is already sorted. * Average Case: (O(n^2)) - When the array elements are in random order. * Worst Case: (O(n^2)) - When the array is sorted in reverse order. * **Space Complexity**: (O(1)) - Uses a constant amount of additional space. Principles Insertion Sort builds the sorted array one element at a time by repeatedly taking the next element and inserting it into the correct position among the previously sorted elements. It compares the current element with the elements in the sorted portion and shifts those elements if necessary to make space for the current element. Characteristics & Applications * **Properties**: * Stable: It maintains the relative order of records with equal keys. * In-place: Requires a constant amount of additional memory. * **Common Use Cases**: * Effective for small datasets. * Useful when the array is nearly sorted, as it can handle this efficiently. * **Strengths/Limitations**: * Strengths: Simple implementation, effective on small or nearly sorted arrays. * Limitations: Inefficient on large datasets due to its (O(n^2)) time complexity. Implementation Challenges * **Edge Cases**: * Empty array. * Arrays with identical elements. * Very small arrays (size 1 or 2). * **Performance Bottlenecks**: * The inner while loop can slow down execution when many elements need to be shifted. * **Error Scenarios**: * If index bounds are not managed correctly, it could result in an IndexError. * **Optimization Points**: * For larger datasets, consider using more efficient sorting algorithms like Merge Sort or Quick Sort. * Avoid unnecessary comparisons or swapping. <|Analysis End|> <|Question Begin|> # Coding Assessment Question Problem Statement You are given a list of integers that represent the lengths of various ropes. A renown rope manufacturer wants to test the quality of their machine\'s output by sorting these lengths in ascending order. Implement a function `sort_rope_lengths` using the Insertion Sort algorithm to accomplish this task. Additionally, the company wants to visualize each iteration of the sorting process to analyze the performance of their machine. Function Signature ```python def sort_rope_lengths(rope_lengths: List[int], simulation: bool = False) -> List[int]: ``` Input * `rope_lengths`: A list of integers representing the lengths of ropes. (1 ≤ len(rope_lengths) ≤ 1000; 0 ≤ rope_length ≤ 10000) * `simulation`: A boolean flag (default is False). If True, print the list after each iteration of sorting. Output * The function should return a list of integers sorted in ascending order. Constraints * Do not use Python\'s built-in sorting functions (`sorted()`, `.sort()`, etc.). * The solution should be implemented using the Insertion Sort algorithm. * Time Complexity: O(n^2) * Space Complexity: O(1) Example ```python rope_lengths = [5, 3, 8, 4, 2] result = sort_rope_lengths(rope_lengths) print(result) # Output: [2, 3, 4, 5, 8] ``` If `simulation` is set to True, the function should also print: ``` iteration 0 : [5, 3, 8, 4, 2] iteration 1 : [3, 5, 8, 4, 2] iteration 2 : [3, 5, 8, 4, 2] iteration 3 : [3, 4, 5, 8, 2] iteration 4 : [2, 3, 4, 5, 8] ``` Note * Ensure edge cases such as an empty list or a single element list are handled correctly. * Pay attention to maintaining the iterative visual output when `simulation` is True.","solution":"from typing import List def sort_rope_lengths(rope_lengths: List[int], simulation: bool = False) -> List[int]: Sorts a list of rope lengths using the Insertion Sort algorithm. If simulation is True, prints the list after each iteration of sorting. Parameters: rope_lengths (List[int]): List of integers representing the lengths of ropes. simulation (bool): Flag indicating whether to print each iteration of sorting. Returns: List[int]: Sorted list of rope lengths. # Traverse through 1 to len(rope_lengths) for i in range(1, len(rope_lengths)): key = rope_lengths[i] j = i - 1 # Move elements of rope_lengths[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and key < rope_lengths[j]: rope_lengths[j + 1] = rope_lengths[j] j -= 1 rope_lengths[j + 1] = key # Print the current state of the list if simulation is True if simulation: print(f\'iteration {i} : {rope_lengths}\') return rope_lengths"},{"question":"Scenario You are tasked with helping an online quiz application manage user input validation. Specifically, you need to implement a function that checks if user-provided words can be typed using letters located only on one specific row of an American keyboard. This measure ensures data uniformity and simplifies input handling. Task Implement the function `find_keyboard_row` which takes an input list of words and returns a list of words that can be typed using letters only from one row of an American keyboard. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: pass ``` Input * `words`: List of strings, where each string has at least one alphabetical character and can be of arbitrary length. The list can be empty. Output * Returns a list of strings that match the criterion described. Example ```python # Example 1 input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] output: [\\"Alaska\\", \\"Dad\\"] # Example 2 input: [\\"Typical\\", \\"Quiz\\", \\"words\\"] output: [] ``` Constraints * Words consist of alphabetical characters [a-z, A-Z] only. * Case does not matter while determining the row but original case should be preserved in the output. * You should aim for an efficient solution in both time and space. Notes 1. Assume a standard American keyboard for reference. 2. Handle all input cases gracefully. Good luck!","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def can_be_typed_with_one_row(word): lower_word = set(word.lower()) return lower_word <= row1 or lower_word <= row2 or lower_word <= row3 return [word for word in words if can_be_typed_with_one_row(word)]"},{"question":"Scenario You are tasked with implementing a priority queue for a scheduler to manage tasks based on their priority levels. The priority queue should function such that the task with the highest priority (lowest integer) should be addressed first. To accomplish this, you will implement a min-heap, ensuring all operations (insert and remove) maintain the min-heap property. Task Implement the `BinaryHeap` class to include the following methods: 1. **insert(val: int) -> None**: Insert a new integer value representing a task priority into the heap. 2. **remove_min() -> int**: Remove and return the highest priority (minimum value) element from the heap. The min-heap must always maintain its property after each insertion or deletion. Input and Output Formats * **Insert Method Input**: Takes a single integer `val` representing the task priority. * **Remove Min Method Output**: Returns a single integer, which is the task with the highest priority in the heap. Constraints * The heap can store a maximum of 10^5 integers. * The integer values for priority will range between 1 and 10^9. Example Input and Output ```python # Time complexity constraints must be adhered to: # - Insert must be O(log N). # - Remove Min must be O(log N). # Examples heap = BinaryHeap() heap.insert(10) heap.insert(4) heap.insert(5) heap.insert(2) print(heap.remove_min()) # Output: 2 print(heap.remove_min()) # Output: 4 heap.insert(1) print(heap.remove_min()) # Output: 1 print(heap.remove_min()) # Output: 5 ``` Implement the `BinaryHeap` class methods `insert` and `remove_min` ensuring they meet the requirements and maintain the min-heap property at all times.","solution":"class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: self.heap.append(val) self._sift_up(len(self.heap) - 1) def remove_min(self) -> int: if len(self.heap) == 0: raise IndexError(\\"remove_min() called on empty heap\\") smallest = self.heap[0] last_element = self.heap.pop() if len(self.heap) > 0: self.heap[0] = last_element self._sift_down(0) return smallest def _sift_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._sift_up(parent_index) def _sift_down(self, index): smallest = index left = 2 * index + 1 right = 2 * index + 2 if left < len(self.heap) and self.heap[left] < self.heap[smallest]: smallest = left if right < len(self.heap) and self.heap[right] < self.heap[smallest]: smallest = right if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._sift_down(smallest)"},{"question":"# Permutation Algorithm Assessment You are required to demonstrate your understanding of generating permutations of a list of distinct numbers by implementing an optimized permutation function. **Objective**: Your task is to write a Python function that generates all possible permutations of a given list of distinct integers using an optimized algorithm that minimizes space and/or time complexity where possible. **Function Signature**: ```python def generate_permutations(nums: List[int]) -> List[List[int]]: pass ``` **Input**: - `nums` (List[int]): A list of distinct integers. **Output**: - List[List[int]]: A list containing all possible permutations of the input list. # Constraints: - The input list `nums` will contain distinct integers. - The length of `nums` will be between 0 and 10 (0 <= len(nums) <= 10). # Example: ```python # Example 1 nums = [1, 2, 3] output = generate_permutations(nums) print(output) # Expected output: [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] # Example 2 nums = [] output = generate_permutations(nums) print(output) # Expected output: [ # [] # ] ``` # Requirements: 1. Implement the function `generate_permutations` to achieve the specified functionality. 2. Ensure the solution handles the edge cases effectively (e.g., an empty list, single-element list). 3. Optimize for time and space where feasible. 4. Do not use any external libraries; use core Python functionalities.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: def permute(prefix, remaining): if not remaining: result.append(prefix) return for i in range(len(remaining)): permute(prefix + [remaining[i]], remaining[:i] + remaining[i+1:]) result = [] permute([], nums) return result"},{"question":"Background You are building a calculator that supports a variety of arithmetic operations. As part of this project, you need to implement some fundamental algorithms related to number theory. Specifically, you will need to calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) of two given integers using efficient algorithms. Task Implement a function that, given two integers, computes their GCD using the bitwise GCD algorithm described in the provided code snippets. Additionally, implement the function to compute the LCM using the GCD calculated by your function. Function Signatures ```python def gcd_bit(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass ``` Input 1. Two non-negative integers, `a` and `b` where `0 <= a, b <= 10^9`. Output 1. `gcd_bit`: The greatest common divisor of `a` and `b`. 2. `lcm`: The least common multiple of `a` and `b`. Constraints - If both `a` and `b` are zero, your function should return GCD as `0` and handle this input gracefully. - Do not use external libraries for GCD and LCM calculations. Examples # Example 1 ```python # Input a = 12 b = 18 # GCD Output gcd_bit(a, b) # Returns: 6 # LCM Output lcm(a, b) # Returns: 36 ``` # Example 2 ```python # Input a = 0 b = 0 # GCD Output gcd_bit(a, b) # Returns: 0 # LCM Output lcm(a, b) # Returns: 0 ``` Explanation 1. In the first example, the bitwise GCD of 12 and 18 is 6, and the LCM is calculated as (12 * 18) // 6 = 36. 2. In the second example, both inputs are zero, so both GCD and LCM return zero as there\'s no valid common multiple or divisor. Ensure that your implementation efficiently handles edge cases such as zero inputs and large numbers.","solution":"def gcd_bit(a: int, b: int) -> int: if a == 0: return b if b == 0: return a shift = 0 # Reduce a and b by finding the common factors of 2 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a return a << shift def lcm(a: int, b: int) -> int: if a == 0 and b == 0: return 0 gcd = gcd_bit(a, b) return abs(a * b) // gcd"},{"question":"# Given a class `BSTIterator` that is used to perform in-order traversal of a binary search tree (BST) with the following methods: * `__init__(root)`: Initializes an object of the `BSTIterator` class, with the root of the BST. * `has_next()`: Returns `True` if there are more nodes to be visited in the BST. * `next()`: Returns the next node’s value in in-order sequence. # You are required to implement the following extensions: Additional Function: 1. `prev()`: This method should return the previous node’s value in the in-order traversal. It should allow reversing the iteration one step back. # Constraints: * Assume tree node structure is as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` * Tree is guaranteed to have unique values. * Avoid using recursive methods for traversal. Detailed Steps: 1. **Input**: - The root node of a binary search tree when initializing the iterator. - Calls to `has_next()` and `next()` without additional inputs. 2. **Output**: - `next()` should return the next in-order value. - `prev()` should return the previous in-order value. - `has_prev()` method should also be implemented to check if `prev()` can be called. Example Scenario: ```python root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) it = BSTIterator(root) it.next() # returns 3 it.next() # returns 7 it.prev() # returns 3 it.has_next() # returns True it.has_prev() # returns False (as prev() only called once) it.next() # returns 7 it.has_prev() # returns True (as prev() called after next() again) ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class BSTIterator: def __init__(self, root): self.stack = [] self.inorder = [] self.index = -1 self._inorder_traversal(root) def _inorder_traversal(self, root): if root is None: return stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() self.inorder.append(current.val) current = current.right def has_next(self): return self.index < len(self.inorder) - 1 def next(self): if self.has_next(): self.index += 1 return self.inorder[self.index] raise Exception(\\"No more elements in the BST Iterator.\\") def has_prev(self): return self.index > 0 def prev(self): if self.has_prev(): self.index -= 1 return self.inorder[self.index] raise Exception(\\"No previous elements in the BST Iterator.\\")"},{"question":"You are given the task to implement the `bucket_sort` algorithm which efficiently sorts an array of floating-point numbers in the range [0, 1). To achieve optimal performance, you are also required to optimize the bucket sorting process. Implement the function: ```python def bucket_sort(arr: List[float]) -> List[float]: pass ``` # **Expected Input and Output** - **Input**: A list of floating-point numbers `arr` where (0 leq text{arr}[i] < 1) and (0 leq text{len(arr)} leq 10^6). - **Output**: A list of floating-point numbers sorted in non-decreasing order. # **Example** ```python assert bucket_sort([0.25, 0.36, 0.58, 0.41, 0.90, 0.20, 0.02, 0.99]) == [0.02, 0.20, 0.25, 0.36, 0.41, 0.58, 0.90, 0.99] ``` # **Constraints** - The list `arr` contains real numbers in the range [0, 1). - The length of `arr` will not exceed (10^6). # **Performance Requirements** Ensure that your implementation can handle the maximum constraints efficiently. Consider both time and space complexity in your design. # **Edge Cases to Handle** - The array may contain duplicate values. - The array may be empty or contain only one element. - Consider the threshold when choosing an appropriate algorithm for sorting the contents of individual buckets. # **Optimization Consideration** - Instead of `insertion_sort`, consider using `quick_sort` or another preferred efficient sorting algorithm for sorting within buckets.","solution":"from typing import List def bucket_sort(arr: List[float]) -> List[float]: if not arr: return [] n = len(arr) buckets = [[] for _ in range(n)] for num in arr: bucket_idx = int(n * num) buckets[bucket_idx].append(num) for i in range(n): buckets[i].sort() sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"Context You are given a sorted array of integers and a target integer. Your task is to implement a highly efficient search algorithm to determine the index of the target integer in the array. Problem Statement Implement the `ternary_search` function that takes four parameters: two integers `left` and `right` representing the search interval, an integer `key` representing the target value, and a list of integers `arr` representing the sorted array. The function should perform a ternary search on the array and return the index of the target value if it is present, or -1 if it is not found. Your implementation should consider edge cases and have an efficient search mechanism. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` Input * `left`: An integer representing the starting index of the search interval (0 <= left < len(arr)). * `right`: An integer representing the ending index of the search interval (0 <= right < len(arr)). * `key`: An integer representing the target value to search for. * `arr`: A list of sorted integers. Output * Returns an integer representing the index of the target value if found, or -1 if the target value is not present in the array. Constraints * The array `arr` is sorted in non-decreasing order. * 1 <= len(arr) <= 10^6 * -10^6 <= key, arr[i] <= 10^6 Example ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] left = 0 right = len(arr) - 1 key = 5 print(ternary_search(left, right, key, arr)) # Expected output: 4 key = 11 print(ternary_search(left, right, key, arr)) # Expected output: -1 ```","solution":"def ternary_search(left, right, key, arr): Perform a ternary search on the array and return the index of the target value if found. If the target value is not present in the array, return -1. :param left: Starting index of the search interval. :param right: Ending index of the search interval. :param key: Target value to search for. :param arr: Sorted list of integers. :return: Index of the target value if found, otherwise -1. while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: # key is between mid1 and mid2 left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"**Problem Statement**: Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Implement the `is_palindrome_stack` function using the stack approach defined below. Afterwards, optimize the function to reduce space complexity without sacrificing clarity or correctness. **Function Signature**: ```python def is_palindrome_stack(s: str) -> bool: pass ``` **Detailed Requirements**: 1. Strip out non-alphanumeric characters and convert the remaining characters to lowercase. 2. Use a stack to store the latter half of the cleaned string. 3. Compare the characters from the beginning of the string to the characters popped from the stack. 4. Optimize the space complexity afterwards to O(1). **Input and Output**: - **Input**: A single string `s` (0 ≤ |s| ≤ 10<sup>5</sup>). - **Output**: A boolean value indicating whether `s` is a palindrome. **Constraints**: - The function should handle edge cases like empty strings, strings with only non-alphanumeric characters, and strings of large length efficiently. **Example**: ```python # Example 1 s = \\"A man, a plan, a canal: Panama\\" print(is_palindrome_stack(s)) # Output: True # Example 2 s = \\"race a car\\" print(is_palindrome_stack(s)) # Output: False # Example 3 s = \\"\\" print(is_palindrome_stack(s)) # Output: True ``` **Scenario Context**: You are working on a text processing application where you need to handle user inputs and check if they form palindromic statements. Efficient real-time checking is crucial since the application deals with a large volume of inputs. **Performance Requirements**: - Ensure that the optimized version runs efficiently even for the largest strings within the constraints. **Notes**: - Avoid unnecessary use of other data structures when optimizing. - Ensure your function remains clear and the logic is easy to follow in both unoptimized and optimized implementations.","solution":"def is_palindrome_stack(s: str) -> bool: Determines if a string is a palindrome, considering only alphanumeric characters and ignoring cases. This function uses the stack approach. # Clean the string: remove non-alphanumeric characters and convert to lowercase cleaned = \'\'.join(char.lower() for char in s if char.isalnum()) # Use a stack to store the characters from the first half of the cleaned string stack = [] length = len(cleaned) for i in range(length // 2): stack.append(cleaned[i]) # Index to start checking the second half start_index = (length // 2) + (length % 2) # Compare the second half of the string to the characters popped from the stack for i in range(start_index, length): if stack.pop() != cleaned[i]: return False return True def is_palindrome_optimized(s: str) -> bool: Determines if a string is a palindrome, considering only alphanumeric characters and ignoring cases. This function optimizes space complexity to O(1). # Clean the string: remove non-alphanumeric characters and convert to lowercase cleaned = \'\'.join(char.lower() for char in s if char.isalnum()) # Use two-pointer approach to check for palindrome left, right = 0, len(cleaned) - 1 while left < right: if cleaned[left] != cleaned[right]: return False left += 1 right -= 1 return True"},{"question":"# Interpolation Search in Practice As a junior developer at a financial technology firm, you are working on a historical stock price analyzer. Your task is to implement an interpolation search algorithm to quickly locate specific dates\' stock prices in a sorted list of stock prices. Problem Given a list of tuples where each tuple contains a date (as a string in \'YYYY-MM-DD\' format) and an associated stock price (as a float), implement the interpolation search algorithm to find the index of a given stock price. Input 1. A list `stock_data` of tuples, where each tuple contains a date and a price, sorted in increasing order of prices. 2. A float `target_price` representing the stock price to be searched. Output - Return the 1-based index of the target price if found, otherwise return -1. Function Signature ```python def find_stock_price_index(stock_data: List[tuple], target_price: float) -> int: ``` Constraints 1. The list `stock_data` will have at most 1000 entries. 2. Each price in `stock_data` will be unique. 3. You may assume that the date is always in \'YYYY-MM-DD\' format. 4. The prices are sorted in increasing order. Requirements - Implement the function without using any built-in search functions except for array slicing. - The search should handle edge cases such as price not found and invalid search ranges gracefully. Example ```python stock_data = [(\'2023-01-01\', 100.5), (\'2023-01-02\', 101.0), (\'2023-01-03\', 101.5), (\'2023-01-04\', 102.0)] target_price = 101.5 print(find_stock_price_index(stock_data, target_price)) # Output: 3 ``` In this example, the target price 101.5 is found at the 3rd position (1-based index) in the list. Use your knowledge of interpolation search to solve this problem efficiently.","solution":"def find_stock_price_index(stock_data, target_price): Performs interpolation search to find the target_price in the stock_data. Parameters: stock_data (List[tuple]): List of tuples containing date and price, sorted by price. target_price (float): The price to be searched for. Returns: int: 1-based index of the target_price if found, otherwise -1. low = 0 high = len(stock_data) - 1 while low <= high and target_price >= stock_data[low][1] and target_price <= stock_data[high][1]: if low == high: if stock_data[low][1] == target_price: return low + 1 return -1 pos = low + int(((float(high - low) / (stock_data[high][1] - stock_data[low][1])) * (target_price - stock_data[low][1]))) if stock_data[pos][1] == target_price: return pos + 1 if stock_data[pos][1] < target_price: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question Composition **Context**: You are asked to sort an array of integers using the Quick Sort algorithm. Your task is to implement the core sorting function, ensuring it handles all common edge cases and performs optimally under various conditions. # Question Write a function `quick_sort(arr)` that takes a list of integers `arr` and returns the sorted list. Implement the Quick Sort algorithm. You are required to ensure the following: 1. Implement the partitioning and recursive sorting functionalities. 2. Optimize the choice of pivot to avoid worst-case time complexity. 3. Handle arrays with duplicate values efficiently. # Function Signature: ```python def quick_sort(arr) -> list: # Your code here pass ``` # Input: - `arr`: A list of integers. The size of the list can vary from 0 to 10^4 elements. Each integer can range between -10^6 and 10^6. # Output: - A list of integers sorted in ascending order. # Constraints: - The function must handle empty lists. - The function should efficiently manage large lists and avoid recursion limit issues. - Maintain in-place sorting to optimize space usage. # Examples: ```python # Example 1 quick_sort([3, 6, 8, 10, 1, 2, 1]) # Output: [1, 1, 2, 3, 6, 8, 10] # Example 2 quick_sort([]) # Output: [] # Example 3 quick_sort([-2, -8, 3, 7, 0, -5]) # Output: [-8, -5, -2, 0, 3, 7] ``` # Additional Requirements: - Include comments explaining the key steps of your implementation. - Optimize your solution ensuring performance on large datasets.","solution":"import random def quick_sort(arr): Sorts a list of integers in ascending order using the Quick Sort algorithm. def partition(low, high): pivot_index = random.randint(low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def quick_sort_recursive(low, high): if low < high: pivot_index = partition(low, high) quick_sort_recursive(low, pivot_index - 1) quick_sort_recursive(pivot_index + 1, high) # Call the recursive quicksort function quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"Context You are working on a project that involves analyzing data from a large grid-based dataset, such as images or geographical maps. One of the required tasks is to compute the sum of values in specific sub-regions of this grid to identify areas of interest. Problem Statement You are given a square matrix of size `n x n` containing integers and an integer `k`. Your task is to efficiently compute the sum of all k x k sub-squares within this n x n matrix. Function Signature ```python def sum_sub_squares(matrix: List[List[int]], k: int) -> List[List[int]]: ``` Input - `matrix`: A 2D list of integers representing the n x n matrix. - `k`: An integer representing the size of the sub-squares to sum. Output - A 2D list where each element corresponds to the sum of a k x k sub-square in the original matrix. Constraints - 1 <= n <= 100 - 1 <= k <= n - Elements of the matrix are integers. Performance Requirements - The solution should be optimized to handle large values of `n` and `k` efficiently, ideally using cumulative sum techniques. Example ```python matrix = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] k = 2 # Expected Output: # [ # [4, 4, 4], # [4, 4, 4], # [4, 4, 4] # ] ``` Additional Notes 1. If `k` is greater than `n`, return an empty list as no valid sub-square can be formed. 2. Utilize cumulative sum (prefix sum) optimizations to reduce the overall time complexity. Design and implement an efficient solution to solve the problem, and include edge cases in your test scenarios to ensure robustness.","solution":"from typing import List def sum_sub_squares(matrix: List[List[int]], k: int) -> List[List[int]]: n = len(matrix) if k > n or k <= 0: return [] # Create auxiliary matrix for storing prefix sums prefix_sum = [[0] * (n+1) for _ in range(n+1)] # Compute prefix sums for i in range(1, n+1): for j in range(1, n+1): prefix_sum[i][j] = (matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) # Compute sum of k x k sub-squares result = [] for i in range(n-k+1): row = [] for j in range(n-k+1): total = (prefix_sum[i+k][j+k] - prefix_sum[i+k][j] - prefix_sum[i][j+k] + prefix_sum[i][j]) row.append(total) result.append(row) return result"},{"question":"**Power of Two Validation** Given a positive integer ( n ), write a function to determine if it is a power of two. Your function should be efficient in both time and space. Input Format * A single integer ( n ) where ( 1 leq n leq 2^{31} - 1 ). Output Format * Return `True` if ( n ) is a power of two, otherwise return `False`. Function Signature ```python def is_power_of_two(n: int) -> bool: pass ``` Constraints * The input integer ( n ) is in the range ( 1 leq n leq 2^{31} - 1 ). Example ```python assert is_power_of_two(1) == True # 2^0 assert is_power_of_two(16) == True # 2^4 assert is_power_of_two(3) == False # Not a power of two assert is_power_of_two(1024) == True # 2^10 assert is_power_of_two(0) == False # 0 is not a power of two ```","solution":"def is_power_of_two(n: int) -> bool: Determines if the given number n is a power of two. Args: - n: A positive integer. Returns: - True if n is a power of two, otherwise False. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# Problem: Optimized Comb Sort Implementation Context Comb Sort algorithm is a hybrid sorting algorithm that aims to improve on Bubble Sort. It reduces the gap between compared elements using a shrink factor, which makes it faster at removing small elements near the end of the list. Task Write a function `optimized_comb_sort` that sorts an array using an optimized version of the Comb Sort algorithm. In this optimized version, you will adjust the shrink factor and incorporate a few enhancements to handle different common edge cases more efficiently. Function Signature ```python def optimized_comb_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: List of integers, which can contain up to 10^5 elements, and each element can be in the range [-10^9, 10^9]. Output * Return the sorted list. Constraints * The algorithm should handle arrays of up to 10^5 elements efficiently. * Minimize the number of comparisons and swaps to achieve optimal performance. Examples 1. Input: `[34, 12, 25, 16, 6]` Output: `[6, 12, 16, 25, 34]` 2. Input: `[1, 2, 3, 4, 5]` Output: `[1, 2, 3, 4, 5]` 3. Input: `[5, 1, 4, 2, 8]` Output: `[1, 2, 4, 5, 8]` Explanation Your function should optimize the Comb Sort by: * Adjusting the shrink factor if required for better performance. * Efficiently handling edge cases such as already sorted arrays, and arrays sorted in reverse order. * Minimizing the number of passes when the array is close to being sorted. Make sure your implementation is optimized to handle large arrays within a reasonable time frame.","solution":"from typing import List def optimized_comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): # Shrink gap by shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question You are given a sorted array of integers `arr`, and two integers `lo` and `hi` that define a range of interest. Your task is to write a function `missing_ranges(arr, lo, hi)` that returns a list of ranges (tuples) representing the missing numbers in the provided range `[lo, hi]` that do not appear in the array `arr`. Function Signature ```python def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: pass ``` Input Format - `arr`: A sorted list of unique integers. - `lo`: An integer representing the lower bound of the range. - `hi`: An integer representing the upper bound of the range. Output Format - A list of tuples. Each tuple `(a, b)` represents a missing range from `a` to `b`. Constraints - The elements in `arr` and the values of `lo` and `hi` will fit in the range of 32-bit signed integers. - `1 <= len(arr) <= 10^5` - `lo <= hi` (at least implies non-overlapping bounds). Example ```python assert missing_ranges([3, 5], 1, 10) == [(1, 2), (4, 4), (6, 10)] assert missing_ranges([], 1, 10) == [(1, 10)] assert missing_ranges([1, 2, 3, 4, 5], 1, 5) == [] assert missing_ranges([0, 1, 3, 50, 75], 0, 99) == [(2, 2), (4, 49), (51, 74), (76, 99)] ```","solution":"from typing import List, Tuple def missing_ranges(arr: List[int], lo: int, hi: int) -> List[Tuple[int, int]]: ranges = [] prev = lo - 1 for num in arr + [hi + 1]: if num == prev + 2: ranges.append((prev + 1, prev + 1)) elif num > prev + 2: ranges.append((prev + 1, num - 1)) prev = num return ranges"},{"question":"# Regular Expression Matching In this problem, you need to implement a function that checks if an input string matches a given pattern using regular expressions with support for the special characters \'.\' and \'*\'. The function should return `True` if the entire string matches the pattern and `False` otherwise. - \'.\' Matches any single character. - \'*\' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Function Signature ```python def is_match(s: str, p: str) -> bool: pass ``` Input - `s` (1 ≤ |s| ≤ 1000): A string consisting of lowercase letters. - `p` (1 ≤ |p| ≤ 1000): A pattern string consisting of lowercase letters and the special characters \'.\' and \'*\'. Output - A boolean value representing whether the input string `s` matches the pattern `p`. Examples ```python assert is_match(\\"aa\\",\\"a\\") == False assert is_match(\\"aa\\",\\"aa\\") == True assert is_match(\\"aaa\\",\\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Constraints - You must solve it using dynamic programming to ensure efficiency. - Consider edge cases such as empty strings and edge patterns that involve repetitive characters. Performance Constraints - Time Complexity: Your solution should run in O(n * m) time. - Space Complexity: Use at most O(n * m) space, where n is the length of the string `s` and m is the length of the pattern `p`. You are required to implement the `is_match` function based on the outlined considerations.","solution":"def is_match(s: str, p: str) -> bool: Returns whether the input string `s` matches the pattern `p`. Pattern can include \'.\' which matches any single character and \'*\' which matches zero or more of the preceding character. # Create a DP table with dimensions (len(s) + 1) x (len(p) + 1) # dp[i][j] will be True if s[0:i] matches p[0:j] dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # An empty string matches an empty pattern dp[0][0] = True # Handle patterns with \'*\' at the beginning for j in range(2, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] # Fill the table iteratively for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == \'*\' and j > 1: # \'*\' can either match zero or more of the preceding element dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == \'.\')) else: # Match single character if p[j-1] == \'.\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] return dp[len(s)][len(p)]"},{"question":"# Problem: Bitwise Manipulations for IPv4 Subnet Mask Verification You are tasked to write a function that verifies whether an integer represents a valid IPv4 subnet mask using bitwise manipulation principles. Scenario In computer networking, a subnet mask is a 32-bit number that masks an IP address and divides the IP address into network address and host address. A valid subnet mask contains a series of contiguous 1\'s followed by contiguous 0\'s in its binary form. For example, `255.255.255.0` (binary: `11111111.11111111.11111111.00000000`) is a valid subnet mask. Requirements 1. **Function Signature** ```python def is_valid_subnet_mask(mask: int) -> bool: ``` - **Input**: An integer `mask` (32-bit). - **Output**: Returns `True` if `mask` is a valid IPv4 subnet mask, otherwise `False`. 2. **Constraints**: - The input integer will be in the range of 32-bit unsigned integers (0 to 4294967295). 3. **Performance**: - The function should be efficient, preferably operating in O(1) time complexity. Example ```plaintext Input: 4294967040 (Binary: 11111111.11111111.11111111.00000000) Output: True Input: 4294902015 (Binary: 11111111.11111110.10101010.11111111) Output: False ``` Explanation The first mask is valid as all `1`s are contiguous, followed by all `0`s. The second mask is invalid as it breaks the contiguous rule.","solution":"def is_valid_subnet_mask(mask: int) -> bool: Check whether a given integer represents a valid IPv4 subnet mask. A valid subnet mask contains a series of contiguous 1\'s followed by contiguous 0\'s in its binary form. :param mask: An integer representing a 32-bit subnet mask :return: True if the mask is valid, False otherwise # if mask is zero or all ones, it is invalid if mask == 0 or mask == 0xFFFFFFFF: return False # Convert mask to 32-bit binary string and split at the first zero binary_mask = f\'{mask:032b}\' # The last occurrence of \'1\' must be followed only by \'0\'s first_zero_index = binary_mask.find(\'0\') if first_zero_index == -1: return False # If \'0\' isn\'t present, it\'s a fully 1 mask which is invalid return \'1\' not in binary_mask[first_zero_index:]"},{"question":"# Depth First Search for Path Finding in a Directed Graph Context You are part of a software engineering team tasked with developing a function that determines if there exists a path between two nodes in a directed graph. The company works on complex data systems where checking the reachability of nodes quickly and accurately is crucial. Problem Given a directed graph represented as an adjacency list, implement a method to check if there exists a path between two given nodes using Depth First Search (DFS). Function Signature ```python def is_path(graph: Dict[int, List[int]], source: int, target: int) -> bool: Determines if there is a path between source and target nodes in the given graph. :param graph: A dictionary where keys are node identifiers and values are lists of target nodes. :param source: The node from which to start the search. :param target: The node to which to find the path. :return: True if a path exists from source to target, otherwise False. ``` Inputs * `graph`: A dictionary `graph` where keys are node identifiers (integers) and values are lists of integers representing directed edges from the key node to other nodes. * `graph` is guaranteed to have unique nodes and valid edges. * `source`: An integer representing the start node. * `target`: An integer representing the end node. Outputs * Return `True` if there is a path from `source` to `target`, otherwise return `False`. Constraints * The number of vertices in the graph will be at most 10^4. * There can be cycles in the graph. * Assume all node identifiers are in the range [0, 10^4). Example ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [1] } print(is_path(graph, 0, 3)) # Output: True print(is_path(graph, 3, 0)) # Output: False ``` Requirements * The solution should be efficient in terms of time complexity. * Consider optimizing memory usage where possible. * Provide meaningful variable names and comments in your solution for clarity.","solution":"def is_path(graph, source, target): Determines if there is a path between source and target nodes in the given graph. :param graph: A dictionary where keys are node identifiers and values are lists of target nodes. :param source: The node from which to start the search. :param target: The node to which to find the path. :return: True if a path exists from source to target, otherwise False. visited = set() def dfs(node): if node == target: return True if node in visited: return False visited.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True return False return dfs(source)"},{"question":"# Question: Atbash Cipher Function Implementation Objective You need to implement a function that encrypts a given string using the Atbash Cipher. This function should translate each letter to its reversed alphabetical position while retaining the case for uppercase and lowercase letters. Non-alphabet characters should remain unchanged. Input and Output Formats - **Input**: A single string `s` consisting of alphabetic and/or non-alphabetic characters. - **Output**: A single string representing the Atbash cipher transformation of the input string `s`. Constraints - The input string `s` will have length in the range [0, 1000]. Performance Requirements - The implementation should handle the maximum constraint of the input length efficiently within O(n) time complexity. Example **Input**: \\"Attack at Dawn\\" **Output**: \\"Zggzxp zg Wzdm\\" **Input**: \\"Hello World!\\" **Output**: \\"Svool Dliow!\\" Scenario/Context Suppose you are developing a simple encryption feature for an application that uses the Atbash cipher to encode messages for fun. Your job is to ensure the correct transformation according to the cipher\'s rules. Function Signature ```python def atbash(s: str) -> str: pass ``` Write your function implementation below.","solution":"def atbash(s: str) -> str: Encrypts the input string using the Atbash cipher. Args: s (str): The input string to be encrypted. Returns: str: The encrypted string using the Atbash cipher. def atbash_char(c): if \'a\' <= c <= \'z\': return chr(219 - ord(c)) elif \'A\' <= c <= \'Z\': return chr(155 - ord(c)) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"# Scenario You are working on a search engine optimization tool that analyzes user queries to determine which sections of a website are most frequently accessed. Given a sorted array of timestamps that represent user visits to a specific section, write a function to find the last time a user accessed that section within a timestamp array. # Task Implement a function `last_occurrence` that takes in: - `array` (a sorted list of integers): Timestamps (in seconds) of user accesses. - `query` (an integer): The specific timestamp you are searching for. The function should return: - The index of the last occurrence of the given query timestamp in the array. - If the timestamp is not found, the function should return `-1`. # Constraints - The array is sorted in increasing order. - The elements in the array are integers, where `1 <= len(array) <= 10^5` and `1 <= query <= 10^9`. # Example ```python def last_occurrence(array, query): Implement the function here pass # Example use print(last_occurrence([1, 2, 2, 2, 4, 5, 5], 2)) # Output: 3 print(last_occurrence([1, 2, 2, 2, 4, 5, 5], 5)) # Output: 6 print(last_occurrence([1, 2, 2, 2, 4, 5, 5], 6)) # Output: -1 ``` # Performance Requirements Your function should run in O(log n) time complexity.","solution":"def last_occurrence(array, query): This function finds the last occurrence of the query timestamp in the array. Parameters: array (list): Sorted list of timestamps. query (int): The specific timestamp being searched for. Returns: int: The index of the last occurrence of the query timestamp or -1 if not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Programming Assessment: Finding Primitive Roots Efficiently Context An encrypted communication system relies on primitive roots to generate secure keys. As part of the system upgrade, you are required to write an efficient function to identify all primitive roots for given integers. Your implementation will be evaluated based on correctness and efficiency. Function Specification Implement the following function: ```python def find_primitive_root(n): Returns a list of all primitive roots of n. Parameters: - n (int): Positive integer for which to find the primitive roots. Returns: - List[int]: List of primitive roots of n. ``` Input - A single integer `n` where `1 <= n <= 10^6`. Output - A list of integers that are the primitive roots of `n`. The list should be empty if no primitive roots exist. Constraints - If `n` equals 1, the only primitive root is 0. - Handle edge cases where `n` results in no primitive roots or extensive calculations. Performance Requirements - Your solution should handle large values of `n` within reasonable time constraints, leveraging efficient number-theoretic functions. Examples ```python print(find_primitive_root(1)) # Output: [0] print(find_primitive_root(10)) # Output: [3, 7] print(find_primitive_root(13)) # Output: [2, 6, 7, 11] print(find_primitive_root(23)) # Output: [5, 7, 10, 11, 14, 15, 17, 19, 20, 21] ``` Notes - Ensure the implementation handles non-coprime candidates gracefully. - Optimize the solution to avoid unnecessary computations where possible.","solution":"def gcd(a, b): while b: a, b = b, a % b return a def euler_totient(n): if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result import math def all_prime_factors(n): prime_factors = set() while n % 2 == 0: prime_factors.add(2) n //= 2 for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: prime_factors.add(i) n //= i if n > 2: prime_factors.add(n) return prime_factors def is_primitive_root(r, n, phi, prime_factors): for pf in prime_factors: if pow(r, phi // pf, n) == 1: return False return True def find_primitive_root(n): if n == 1: return [0] phi = euler_totient(n) primes = all_prime_factors(phi) primitive_roots = [] for r in range(2, n): if gcd(r, n) == 1 and is_primitive_root(r, n, phi, primes): primitive_roots.append(r) return primitive_roots"},{"question":"# Objective: Implement a function to determine if a string matches a given regular expression pattern where: - `.` matches any single character. - `*` matches zero or more of the preceding element. # Function Signature: ```python def is_match(s: str, p: str) -> bool: ``` # Input: - `s` (str): the text string to be matched. - `p` (str): the regular expression pattern. # Output: - Returns a boolean value (True or False) indicating whether `s` matches the entire pattern `p`. # Constraints: - 0 <= len(s) <= 1000 - 0 <= len(p) <= 1000 - `s` and `p` contain only lowercase English letters and characters `.` and `*`. # Examples: 1. `is_match(\\"aa\\",\\"a\\")` → `False` 2. `is_match(\\"aa\\",\\"aa\\")` → `True` 3. `is_match(\\"aa\\", \\"a*\\")` → `True` 4. `is_match(\\"aab\\", \\"c*a*b\\")` → `True` 5. `is_match(\\"mississippi\\", \\"mis*is*p*.\\")` → `False` # Scenario: Given the examples above, you need to ensure your solution addresses: - Patterns with single characters and multiple characters. - Patterns containing combinations of `*` and `.`. - Edge cases such as empty patterns or strings. Your solution should: - Efficiently handle patterns and strings up to the maximum length constraints. - Consider both time and space complexities. - Handle cases where patterns contain complex repetitions and optional characters. Implement the function in a way that ensures correctness according to the specified constraints and edge cases.","solution":"def is_match(s: str, p: str) -> bool: Determines if the string s matches the given pattern p. A \'.\' matches any single character. A \'*\' matches zero or more of the preceding character. # Create a DP table where dp[i][j] will be True if s[0..i-1] matches p[0..j-1] dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Both s and p are empty # Handle patterns with \'*\' for j in range(1, len(p) + 1): if p[j - 1] == \'*\' and j > 1: dp[0][j] = dp[0][j - 2] # Fill the DP table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\' and j > 1: if dp[i][j - 2]: dp[i][j] = True elif (p[j - 2] == s[i - 1] or p[j - 2] == \'.\') and dp[i - 1][j]: dp[i][j] = True return dp[len(s)][len(p)]"},{"question":"Implementing Optimized Bucket Sort Scenario You are an engineer working on a large-scale data analysis platform that processes millions of data points daily. One of your tasks is to implement an efficient sorting mechanism for a dataset that contains uniformly distributed real numbers between 0 and 1. You decide to use the Bucket Sort algorithm to achieve this. Task Write a function `bucket_sort(arr)` that sorts a list of floating-point numbers between 0 and 1 using the Bucket Sort algorithm. Use Merge Sort as the secondary sorting algorithm within each bucket to ensure better performance for larger datasets. Constraints * The elements of `arr` are floating-point values between 0 and 1. * The length of `arr` is at least 2 and at most 10^6. Input * A list of floating-point numbers, `arr`, where each element is between 0 and 1. Output * A list of sorted floating-point numbers in ascending order. Example ```python assert bucket_sort([0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]) == [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] assert bucket_sort([0.56, 0.32, 0.22, 0.84, 0.76]) == [0.22, 0.32, 0.56, 0.76, 0.84] ``` Hints 1. Create a sufficient number of empty buckets. 2. Distribute the elements from `arr` into the buckets. 3. Sort each bucket using Merge Sort. 4. Concatenate the sorted buckets to form the final output. Bucket Sort & Merge Sort Implementation You can refer to the following functions for implementation: ```python def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 return arr def bucket_sort(arr): # Implement your optimized bucket sort here using merge_sort pass ```","solution":"def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 return arr def bucket_sort(arr): num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] for value in arr: bucket_index = int(num_buckets * value) buckets[bucket_index].append(value) sorted_arr = [] for bucket in buckets: merge_sort(bucket) sorted_arr.extend(bucket) return sorted_arr"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: - **Algorithm**: Sparse Matrix Multiplication. - **Type**: Matrix multiplication optimization. - **Main Purpose**: Efficiently compute the multiplication of two sparse matrices. **Complexity**: - **Time Complexity**: O(m * n * l), where m is the number of rows in A, n is the number of columns in A (and rows in B), and l is the number of columns in B. Although, it varies with the sparsity level of matrices. - **Space Complexity**: The space complexity is also O(m * l) for the result matrix, plus the space needed for storage of table_a and table_b in the optimized approaches. **Principles**: - Multiplying two matrices involves taking the dot product of rows of the first matrix (A) with the columns of the second matrix (B). Sparse matrix optimizations leverage the fact that many elements are zero, avoiding unnecessary multiplications. **Properties**: - Efficient handling of sparse matrices minimizes computational overhead. - Sparse matrices contain a lot more zero elements relative to non-zero elements. **Common Use Cases**: - Coordinate calculations in graphics. - Scientific computations involving large data sets. - Network analysis with adjacency matrices. - Data representation in machine learning, especially with sparse feature vectors. **Strengths/Limitations**: - **Strengths**: Efficient storage and computation with sparse data, saving time and space. - **Limitations**: Spends more time on overhead if matrices are not sparse; harder to implement and debug compared to dense matrix multiplication. **Implementation Challenges**: - **Edge Cases**: - Handling empty matrices. - Handling non-square matrices where the number of columns in A must equal the number of rows in B. - Matrices filled entirely with zeros. - **Performance Bottlenecks**: - The optimization may not yield performance gains if matrices aren’t sparse enough. - **Error Scenarios**: - Incorrect dimension matches between A and B can lead to runtime errors. - Incorrect handling of zero elements. - **Optimization Points**: - Preprocessing the matrices to store only non-zero values in hash tables (as shown in the implementations). - Parallelizing independent multiplications for further optimization using concurrent programming. <|Analysis End|> <|Question Begin|> # Sparse Matrix Multiplication Challenge You are required to implement a function that multiplies two sparse matrices. Given two matrices, A and B, return the result of multiplying A by B (i.e., AB). The matrices are represented as 2D lists, and you can assume that A\'s column number is equal to B\'s row number. Your solution should take advantage of the sparsity of the matrices to improve efficiency. Function Signature ```python def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` Parameters: - **A**: A 2D list where each element `A[i][j]` is an integer representing the value at row `i` and column `j` of the matrix A. - **B**: A 2D list where each element `B[i][j]` is an integer representing the value at row `i` and column `j` of the matrix B. Returns: - A 2D list where each element represents the resultant matrix after multiplying A by B. Constraints: - `1 <= len(A), len(B) <= 100` - `1 <= len(A[0]), len(B[0]) <= 100` - Elements of A and B are integers ranging from `-1000` to `1000`. Example: ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] # The result of AB is: result = [ [7, 0, 0], [-7, 0, 3] ] ``` Explanation: For the provided matrices A and B: - The dot product of the first row of A and the first column of B results in the first element of the result matrix. - Please ensure that zero elements in A and B do not significantly contribute to the computation time. - Consider pre-storing only the non-zero elements of both matrices for optimization. **Note**: Your solution should be efficient and able to handle the sparsity of the matrices effectively. Optimize to reduce unnecessary computations.","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B: return [] m, n, l = len(A), len(A[0]), len(B[0]) C = [[0] * l for _ in range(m)] # Precompute the non-zero values in A and B table_A = {} table_B = {} for i in range(m): for k in range(n): if A[i][k] != 0: if i not in table_A: table_A[i] = {} table_A[i][k] = A[i][k] for k in range(n): for j in range(l): if B[k][j] != 0: if k not in table_B: table_B[k] = {} table_B[k][j] = B[k][j] # Perform multiplication using the precomputed non-zero values for i in table_A: for k in table_A[i]: if k in table_B: for j in table_B[k]: C[i][j] += table_A[i][k] * table_B[k][j] return C"},{"question":"# Question You need to implement a function that uses the Knuth-Morris-Pratt algorithm to find all starting indices where a pattern string matches within a given text string. Implement the function `find_pattern_occurrences(text: str, pattern: str) -> List[int]`. Function Signature ```python def find_pattern_occurrences(text: str, pattern: str) -> List[int]: pass ``` # Input - `text (str)`: The text in which to search for the pattern. - `pattern (str)`: The pattern to search for within the text. # Output - A list of integers where each integer represents a starting index in `text` where the `pattern` was found. # Constraints - Both `text` and `pattern` consist of lower-case English letters. - 0 <= len(pattern) <= 1000 - 0 <= len(text) <= 100000 # Example ```python assert find_pattern_occurrences(\\"abracadabra\\", \\"abra\\") == [0, 7] assert find_pattern_occurrences(\\"aaaaa\\", \\"aa\\") == [0, 1, 2, 3] assert find_pattern_occurrences(\\"hello there hero!\\", \\"he\\") == [0, 7, 12] assert find_pattern_occurrences(\\"\\", \\"abc\\") == [] assert find_pattern_occurrences(\\"abc\\", \\"\\") == [] ``` # Explanation - The function should first preprocess the pattern to generate the partial match table (pi array). - Then, it uses this table to efficiently search through the text for the pattern. - The function should handle edge cases, such as an empty pattern or text gracefully. **Note**: Students should focus on implementing an efficient solution with respect to both time and space complexity, leveraging the principles of the KMP algorithm.","solution":"from typing import List def compute_prefix_function(pattern: str) -> List[int]: Computes the prefix function (partial match table) for the KMP algorithm. m = len(pattern) pi = [0] * m j = 0 for i in range(1, m): while j > 0 and pattern[i] != pattern[j]: j = pi[j - 1] if pattern[i] == pattern[j]: j += 1 pi[i] = j else: pi[i] = 0 return pi def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Finds all occurrences of the pattern in the text using the KMP algorithm. if not pattern or not text: return [] n = len(text) m = len(pattern) pi = compute_prefix_function(pattern) result = [] j = 0 for i in range(n): while j > 0 and text[i] != pattern[j]: j = pi[j - 1] if text[i] == pattern[j]: if j == m - 1: result.append(i - m + 1) j = pi[j] else: j += 1 return result"},{"question":"Scenario You are tasked with implementing a filtering mechanism to preprocess numerical data for an analytics platform. The data contains various metrics, and you need to ensure that only values within a certain range are considered for analysis to remove outliers and irrelevant data points. Problem Statement Write a function `filter_range` that filters the elements of an array, returning only those values that fall within a specified minimum and maximum limit. Function Signature ```python def filter_range(arr: list, min_lim: float = None, max_lim: float = None) -> list: pass ``` Input * `arr` (list): A list of numerical values (integers or floats). * `min_lim` (float, optional): The minimum limit (inclusive). If `None`, it defaults to the minimum value in the array. * `max_lim` (float, optional): The maximum limit (inclusive). If `None`, it defaults to the maximum value in the array. Output * Returns a list of numerical values from `arr` that are within the range `[min_lim, max_lim]`. Constraints * The array will contain at most 10^6 elements. * Each element in the array is a numerical value (int or float). * The array may be empty. Performance Requirements * The solution should have a linear time complexity, O(n). Example ```python assert filter_range([1.5, 3.2, 5.8, 7.9], min_lim=3.0, max_lim=6.0) == [3.2, 5.8] assert filter_range([10, 15, 20, 25, 30], min_lim=None, max_lim=25) == [10, 15, 20, 25] assert filter_range([0, 5, 10, 15, 20], min_lim=10, max_lim=None) == [10, 15, 20] assert filter_range([], min_lim=0, max_lim=100) == [] ``` Edge Cases 1. An empty array should return an empty array. 2. If all elements fall outside the specified range, the function should return an empty array. 3. If `min_lim` or `max_lim` is `None`, it should correctly default to the minimum or maximum value in the array accordingly. Provide a thorough implementation that correctly handles all specified requirements, ensuring optimal performance for large datasets.","solution":"def filter_range(arr, min_lim=None, max_lim=None): if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question Given an array of integers `nums` where exactly two elements appear only once and all the other elements appear exactly twice, write a function `find_unique_elements(nums)` that finds the two elements that appear only once. The function should have a time complexity of O(N) and space complexity of O(1). Input - A list of integers `nums` where 2 <= len(nums) <= 10^7. - All integers in the array where exactly two elements appear only once and all the other elements appear exactly twice. Output - A list containing the two unique integers. Order of elements in the output list does not matter. Constraints - Your algorithm should have O(N) time complexity. - Your algorithm should have O(1) extra space complexity (excluding input and output). Example ```python >>> find_unique_elements([1, 2, 1, 3, 2, 5]) [3, 5] ``` > Note: Order of the result is not important. So in the above example, `[5, 3]` is also correct. Additional Example ```python >>> find_unique_elements([2, 4, 3, 6, 3, 4, 5, 6]) [2, 5] ``` Solution Template ```python def find_unique_elements(nums): :type nums: List[int] :rtype: List[int] # Step 1: Isolate a^b from pairs using XOR ab = 0 for n in nums: ab ^= n # Step 2: Isolate right most bit from a^b right_most = ab & (-ab) # Step 3: Isolate a and b from a^b a, b = 0, 0 for n in nums: if n & right_most: a ^= n else: b ^= n return [a, b] ```","solution":"def find_unique_elements(nums): Find the two unique elements in the list where all others appear exactly twice. :type nums: List[int] :rtype: List[int] # Step 1: Calculate XOR of all elements. Result will be a^b because all others cancel out. xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find any set bit in the xor_result. We use the rightmost set bit. rightmost_set_bit = xor_result & (-xor_result) # Step 3: Divide elements into two groups based on the rightmost set bit and XOR within each group unique1, unique2 = 0, 0 for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"**Scenario**: You have been hired by a company that is creating a new word game. In this game, players need to determine if one word is an anagram of another word. You have to implement the core functionality of this game by writing a function to check if two given words are anagrams. **Problem Statement**: Write a function `is_anagram(s: str, t: str) -> bool` that takes two strings `s` and `t`, and returns `True` if `t` is an anagram of `s`, and `False` otherwise. **Input and Output format**: - **Input**: Two strings `s` and `t` consisting of only lowercase alphabetical characters. - **Output**: A boolean value (`True` or `False`). **Constraints**: - The length of both strings `s` and `t` will be at most 10^5. **Performance Requirements**: - Your solution should have a time complexity of O(n), where n is the length of the strings. - The space complexity should take into consideration efficient storage and retrieval of character counts. **Function Signature**: ```python def is_anagram(s: str, t: str) -> bool: pass ``` **Examples**: ```python # Example 1: s = \\"anagram\\" t = \\"nagaram\\" print(is_anagram(s, t)) # Output: True # Example 2: s = \\"rat\\" t = \\"car\\" print(is_anagram(s, t)) # Output: False ``` **Hints**: - Think about using dictionaries to store the count of characters in each string. - You can compare these dictionaries to determine if both strings are anagrams.","solution":"def is_anagram(s: str, t: str) -> bool: from collections import Counter if len(s) != len(t): return False return Counter(s) == Counter(t)"},{"question":"# Cycle Sort Implementation In this exercise, your task is to implement the Cycle Sort algorithm which minimizes the number of memory writes. Input * A list of integers `arr` to be sorted. Output * The sorted list in ascending order. Constraints * The provided list will contain integers, not exceeding size 1000. Performance Requirements * Implement the sorting function which operates in O(N^2) time complexity and O(1) space complexity. Scenario You\'re working on a device with a flash memory where each write operation decreases the lifespan of the memory. Hence, you need to use the Cycle Sort algorithm to minimize the number of writes to the memory while sorting data. Write a function `cycle_sort(arr: List[int]) -> List[int]` that accomplishes this task. Function Signature The function signature should be: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Example ```python # Example 1 input: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2 input: [1, 2, 3, 4, 5] output: [1, 2, 3, 4, 5] # Example 3 input: [3, 2, 1] output: [1, 2, 3] ``` Implement the `cycle_sort` function as per the above requirements.","solution":"def cycle_sort(arr): writes = 0 for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find where to put the item pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"You are tasked with implementing functions that convert integers to byte arrays and vice versa, supporting both big-endian and little-endian formats. Additionally, you will need to handle some edge cases and optimize the solution for efficiency. Implement the following functions: 1. `int_to_bytes_big_endian(num: int) -> bytes`: Converts an integer to its byte array representation in big-endian order. 2. `int_to_bytes_little_endian(num: int) -> bytes`: Converts an integer to its byte array representation in little-endian order. 3. `bytes_big_endian_to_int(bytestr: bytes) -> int`: Converts a byte array in big-endian order to its integer representation. 4. `bytes_little_endian_to_int(bytestr: bytes) -> int`: Converts a byte array in little-endian order to its integer representation. # Input and Output Formats - **int_to_bytes_big_endian** - **Input**: A non-negative integer `num` - **Output**: A byte array in big-endian order representing the integer. - **int_to_bytes_little_endian** - **Input**: A non-negative integer `num` - **Output**: A byte array in little-endian order representing the integer. - **bytes_big_endian_to_int** - **Input**: A byte array `bytestr` in big-endian order. - **Output**: An integer representing the byte array. - **bytes_little_endian_to_int** - **Input**: A byte array `bytestr` in little-endian order. - **Output**: An integer representing the byte array. # Constraints - The integer `num` will be in the range `[0, 2**64 - 1]`. - The byte array length will not exceed 8 bytes. - You must handle edge cases such as `num` equal to 0 and empty byte arrays gracefully. # Examples Example 1 ```python num = 305419896 int_to_bytes_big_endian(num) ``` **Output**: ```python b\'x12x34x56x78\' ``` Example 2 ```python num = 305419896 int_to_bytes_little_endian(num) ``` **Output**: ```python b\'xV4x12\' ``` Example 3 ```python bytestr = b\'x12x34x56x78\' bytes_big_endian_to_int(bytestr) ``` **Output**: ```python 305419896 ``` Example 4 ```python bytestr = b\'xV4x12\' bytes_little_endian_to_int(bytestr) ``` **Output**: ```python 305419896 ``` # Additional Notes - Focus on optimizing the functions for both readability and performance. - Consider edge cases such as handling zero and empty byte arrays properly. - Ensure the code adheres to Python standards and is well-documented.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to its byte array representation in big-endian order. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'big\') def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to its byte array representation in little-endian order. return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'little\') def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a byte array in big-endian order to its integer representation. return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a byte array in little-endian order to its integer representation. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Unique Subsets with Condition You are given a collection of integers where elements might contain duplicates. Your task is to write a function that returns all unique subsets of the provided numbers. **Function Signature**: ```python def unique_subsets(nums: List[int], target: int) -> List[List[int]]: pass ``` **Additional Requirement**: Each subset generated must have a sum of elements that is less than or equal to a given target value. **Input**: - `nums`: List of integers (can contain duplicates). - `target`: An integer, representing the maximum allowable sum for any subset. **Output**: - A list of lists, where each inner list represents a unique subset with a sum less than or equal to the target value. **Constraints**: - Each subset should be sorted in ascending order. - The returned list of subsets should also be sorted, based on the lengths of subsets first and the lexicographical order next. - All input lists have lengths within the range [0, 20]. **Examples**: ```python unique_subsets([1, 2, 2], 5) # Expected Output: # [ # [], [1], [1, 2], [1, 2, 2], [2], [2, 2] # ] unique_subsets([2, 3, 6, 7], 7) # Expected Output: # [ # [], [2], [3], [2, 3], [6], [7] # ] ``` **Explanation**: - Each subset should now also meet the sum constraint imposed by the parameter `target`. - Ensure to handle the input duplicates correctly to avoid repeated subsets. - Consider edge cases such as an empty list, list with only one unique element, and large numbers.","solution":"from typing import List def unique_subsets(nums: List[int], target: int) -> List[List[int]]: def backtrack(start, subset): total = sum(subset) if total <= target: output.append(subset[:]) else: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue subset.append(nums[i]) backtrack(i + 1, subset) subset.pop() nums.sort() output = [] backtrack(0, []) output.sort(key=lambda x: (len(x), x)) return output"},{"question":"You are given a one-dimensional numerical array representing daily temperature changes in a city. Your goal is to implement a function that identifies the maximum increase in temperature over any contiguous sequence of days. This will help meteorologists better understand periods of significant temperature increase. Write a function `max_temperature_increase` that takes as input an array of integers and returns the maximum sum of a contiguous subarray (which represents the maximum temperature increase over a series of consecutive days). # Function Signature ```python def max_temperature_increase(temps: List[int]) -> int: ``` # Input * `temps` (List[int]): A list of integers representing the daily temperature changes. The list will have at least one element. # Output * `int`: The maximum sum of a contiguous subarray. # Constraints * The list will contain at least one integer and could contain negative integers, positive integers, and zeros. * You should aim to solve this problem with O(n) time complexity and O(1) space complexity. # Example ```python # Example 1 temps = [1, 2, -3, 4, 5, -7, 23] print(max_temperature_increase(temps)) # Output: 25 (from subarray [4, 5, -7, 23]) # Example 2 temps = [-2, -3, 4, -1, -2, 1, 5, -3] print(max_temperature_increase(temps)) # Output: 7 (from subarray [4, -1, -2, 1, 5]) ``` # Notes * If the array contains only one element, the function should return that element as the maximum sum. * Handle edge cases such as arrays with all negative numbers by the same approach, as the maximum subarray sum in such cases will be the least negative number. Your implementation should utilize the principles of Kadane\'s Algorithm, ensuring optimal performance.","solution":"from typing import List def max_temperature_increase(temps: List[int]) -> int: This function returns the maximum sum of a contiguous subarray from a list of integers representing daily temperature changes. max_current = max_global = temps[0] for temp in temps[1:]: max_current = max(temp, max_current + temp) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Priority Queue Implementation using a Min-Heap The current implementation of the priority queue using a linear array has a performance bottleneck due to its O(n) insertion complexity. For better efficiency, implement a priority queue using a min-heap data structure. **Requirements:** 1. Implement a class `MinHeapPriorityQueue`. 2. The priority queue should be able to handle duplicate priorities. 3. Provide the following methods with the specified functionality: - `insert(item, priority)`: Inserts an item with the given priority into the priority queue. - `extract_min()`: Removes and returns the item with the lowest priority. - `peek_min()`: Returns the item with the lowest priority without removing it. - `is_empty()`: Returns `True` if the priority queue is empty, `False` otherwise. - `size()`: Returns the current number of elements in the priority queue. **Input/Output Specifications:** - `insert(item, priority)`: No output. - `extract_min()`: Returns the item with the lowest priority, raising an error if the queue is empty. - `peek_min()`: Returns the item with the lowest priority, raising an error if the queue is empty. - `is_empty()`: Returns a Boolean value, `True` or `False`. - `size()`: Returns an integer representing the number of elements. **Constraints:** * Priorities can be any integer value (positive, negative, zero). * The queue can have up to 10,000 elements. Implement the solution in Python. ```python class MinHeapPriorityQueue: def __init__(self): # Initialize the heap and track number of elements pass def insert(self, item, priority): # Insert item with given priority pass def extract_min(self): # Remove and return the element with the lowest priority pass def peek_min(self): # Return the element with the lowest priority without removing it pass def is_empty(self): # Check if the priority queue is empty pass def size(self): # Return the number of elements in the priority queue pass ``` Provide your implementation and ensure that you handle the edge cases and performance requirements. **Example:** ```python pq = MinHeapPriorityQueue() pq.insert(\\"task1\\", 5) pq.insert(\\"task2\\", 1) print(pq.peek_min()) # Output: task2 print(pq.extract_min()) # Output: task2 print(pq.size()) # Output: 1 print(pq.is_empty()) # Output: False ```","solution":"import heapq class MinHeapPriorityQueue: def __init__(self): self.heap = [] self.count = 0 def insert(self, item, priority): heapq.heappush(self.heap, (priority, self.count, item)) self.count += 1 def extract_min(self): if self.is_empty(): raise IndexError(\\"Priority queue is empty\\") return heapq.heappop(self.heap)[2] def peek_min(self): if self.is_empty(): raise IndexError(\\"Priority queue is empty\\") return self.heap[0][2] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap)"},{"question":"# Anagram Validation with Constraints Given two strings `s` and `t`, write a function `is_anagram(s, t)` to determine if `t` is an anagram of `s`. The function should adhere to certain constraints for effective performance. # Requirements: 1. **Function Signature**: `def is_anagram(s: str, t: str) -> bool` 2. **Input**: * `s`: a string containing only lowercase English alphabets (1 ≤ len(s) ≤ 10^5) * `t`: a string containing only lowercase English alphabets (1 ≤ len(t) ≤ 10^5) 3. **Output**: Boolean `True` if `t` is an anagram of `s`, otherwise `False`. # Performance Constraints: * Time complexity must be linear, O(n). * Space complexity must be constant, O(1). # Examples: 1. Input: `s = \\"listen\\"`, `t = \\"silent\\"` Output: `True` 2. Input: `s = \\"hello\\"`, `t = \\"bello\\"` Output: `False` 3. Input: `s = \\"\\"`, `t = \\"\\"` Output: `True` # Implementation Considerations: 1. Use a single HashMap or array to enhance space efficiency. 2. Leverage the fixed property of the alphabetic range for optimized constant space use. # Edge Cases: 1. Strings longer than the input constraints. 2. Different lengths of `s` and `t`. 3. Completely disjoint character sets within the bounds of input constraints. Implement a function considering the performance and edge case constraints. Design your solution to be both time and space-efficient.","solution":"def is_anagram(s: str, t: str) -> bool: Determines if t is an anagram of s. if len(s) != len(t): return False # Use a fixed-size array for alphabetic characters (26 letters) char_count = [0] * 26 # Point `a` to 0, `b` to 1, ..., `z` to 25 base = ord(\'a\') # Count frequencies for ch in s: char_count[ord(ch) - base] += 1 for ch in t: char_count[ord(ch) - base] -= 1 # If all counts return to zero, s and t are anagrams for count in char_count: if count != 0: return False return True"},{"question":"Scenario You are working on an optimization problem to allocate minimal resources for coverages, such as installing the fewest number of routers to ensure full Wi-Fi coverage in a building. Task Using the given universe `U` of elements and a collection of subsets `S` with associated costs, implement a function `greedy_set_cover` that approximates the minimum cost subcollection of `S` that covers all elements in `U`. Function Signature ```python def greedy_set_cover(universe: set, subsets: dict, costs: dict) -> tuple: This function returns a tuple consisting of the selected set identifiers that cover the entire universe and the total cost of this selection. Parameters: universe (set): The universe of elements to be covered. subsets (dict): A dictionary where keys are subset identifiers and values are sets representing the subset elements. costs (dict): A dictionary mapping subset identifiers to their respective costs. Returns: tuple: A tuple consisting of the list of selected subset identifiers and their total cost. ``` Input * `universe`: A set of integers representing the universe of elements. * `subsets`: A dictionary where keys are subset identifiers and values are sets containing elements they cover. * `costs`: A dictionary where keys are subset identifiers and values are integers representing the cost of each subset. Output * A tuple containing: * A list of identifiers for the selected subsets that cover the universe. * The total cost of these selected subsets. Constraints * All elements in the subsets must be present in the universe. * Each subset must have a positive cost. Example Input: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} ``` Output: ```python ([\'S3\', \'S2\'], 13) ``` Instructions 1. Implement the `greedy_set_cover` function. 2. Ensure your implementation handles large input sizes efficiently. 3. Verify the correctness by checking that the result covers the entire universe and the cost is minimized as much as possible using a greedy approach.","solution":"def greedy_set_cover(universe, subsets, costs): Returns a tuple consisting of the selected set identifiers that cover the entire universe and the total cost of this selection. Parameters: universe (set): The universe of elements to be covered. subsets (dict): A dictionary where keys are subset identifiers and values are sets representing the subset elements. costs (dict): A dictionary mapping subset identifiers to their respective costs. Returns: tuple: A tuple consisting of the list of selected subset identifiers and their total cost. # Initializations covered = set() selected_subsets = [] total_cost = 0 # Loop until all elements in the universe are covered while covered != universe: best_subset = None best_cost_effectiveness = float(\'inf\') # Find the best subset to select next for subset_id, subset_elements in subsets.items(): # Calculate elements from this subset that are not yet covered new_elements = subset_elements - covered if new_elements: cost_effectiveness = costs[subset_id] / len(new_elements) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset_id # Add best subset\'s elements to covered set and update cost and selections covered |= subsets[best_subset] selected_subsets.append(best_subset) total_cost += costs[best_subset] return selected_subsets, total_cost"},{"question":"# Matrix Multiplication Problem **Context**: You are working on a scientific computing project that involves complex numerical simulations. One of your tasks is to implement and optimize matrix multiplication essential for various computation steps. **Problem Statement**: Write a function `multiply_matrices` that takes two compatible two-dimensional matrices `(matrix_a and matrix_b)` and returns their product as a new matrix. If the matrices are incompatible for multiplication, the function should raise a ValueError. **Function Signature**: ```python def multiply_matrices(matrix_a: list, matrix_b: list) -> list: pass ``` **Inputs**: - `matrix_a`: A list of lists of integers representing the first matrix. - `matrix_b`: A list of lists of integers representing the second matrix. **Output**: - Returns a list of lists of integers representing the product of `matrix_a` and `matrix_b`. **Constraints**: - Assume that all elements of matrices are integers. - The dimensions of matrix_a are `m x n`. - The dimensions of matrix_b are `n x p`. - 0 <= m, n, p <= 100. # Example Considerations: 1. **Example 1**: ```python matrix_a = [ [1, 2], [3, 4] ] matrix_b = [ [2, 0], [1, 2] ] result = multiply_matrices(matrix_a, matrix_b) ``` Output: ```python [ [4, 4], [10, 8] ] ``` 2. **Example 2**: ```python matrix_a = [ [1, 0, 2], [-1, 3, 1] ] matrix_b = [ [3, 1], [2, 1], [1, 0] ] result = multiply_matrices(matrix_a, matrix_b) ``` Output: ```python [ [5, 1], [4, 2] ] ``` 3. **Example 3**: ```python matrix_a = [[1, 2, 3]] matrix_b = [[4], [5], [6]] result = multiply_matrices(matrix_a, matrix_b) ``` Output: ```python [[32]] ``` **Performance Requirements**: - The function must handle up to the maximum constraints efficiently. # Implementation Reminder: - Ensure to handle incompatible matrices gracefully by raising a ValueError. - Consider edge cases, such as empty matrices or matrices with zero dimensions.","solution":"def multiply_matrices(matrix_a, matrix_b): Multiplies two matrices and returns the resulting matrix. Args: matrix_a (list of list of int): The first matrix. matrix_b (list of list of int): The second matrix. Returns: list of list of int: The product of the two matrices. Raises: ValueError: If the number of columns in matrix_a is not equal to the number of rows in matrix_b # Validate if matrices can be multiplied if not matrix_a or not matrix_b or len(matrix_a[0]) != len(matrix_b): raise ValueError(\\"Matrices are incompatible for multiplication.\\") # Dimensions of matrices m = len(matrix_a) # number of rows in matrix_a n = len(matrix_a[0]) # number of columns in matrix_a and rows in matrix_b p = len(matrix_b[0]) # number of columns in matrix_b # Initialize result matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Rod Cutting Problem with Constraints Your task is to implement a function to find the maximum obtainable price from a rod of a given length `n` with given prices for different lengths of rod pieces. However, this time, you will need to handle additional constraints for maximum cuts and total price obtained. Function Signature ```python def cut_rod_constrained(price: List[int], max_length: int, max_cuts: int) -> int: pass ``` Input * `price`: A list of integers where `price[i]` represents the price of a rod of length `i+1`. * `max_length`: An integer representing the maximum length of the rod. * `max_cuts`: An integer representing the maximum number of cuts allowed. Output * Return an integer representing the maximum obtainable price under the given constraints. Constraints * `1 <= len(price) <= 1000` * `1 <= max_length <= 1000` * `0 <= price[i] <= 1000` * `1 <= max_cuts <= 1000` Example ```python prices = [1, 5, 8, 9, 10, 17, 17, 20] max_length = 8 max_cuts = 3 result = cut_rod_constrained(prices, max_length, max_cuts) print(result) # Expected output: 22, obtained by cutting the rod into lengths 3, 3, and 2 with prices 8 + 8 + 6. ``` Note Your implementation should consider edge cases like an empty price list, a rod of length 0, invalid cuts or lengths, and ensure no more than `max_cuts` cuts are made.","solution":"def cut_rod_constrained(price, max_length, max_cuts): Function to find the maximum obtainable price from a rod of a given length with given prices for different lengths of rod pieces under constraints of max_length and max_cuts. # Initialize a DP array to store the maximum price obtainable for each length and cut dp = [[0] * (max_cuts + 1) for _ in range(max_length + 1)] # Iterate through all lengths from 1 to max_length for length in range(1, max_length + 1): # Iterate through all possible cuts from 1 to max_cuts for cuts in range(1, max_cuts + 1): # Iterate through all possible piece lengths from 1 to length for piece_length in range(1, length + 1): if piece_length <= len(price): dp[length][cuts] = max(dp[length][cuts], price[piece_length - 1] + dp[length - piece_length][cuts - 1]) return dp[max_length][max_cuts]"},{"question":"You are tasked with writing a function to compute the square root of a given positive integer, accurate to a specified precision. This task leverages the Newton\'s method (also known as Heron\'s method) for root finding. # Function Signature ```python def precise_square_root(n: int, epsilon: float = 0.001) -> float: Return square root of n, with maximum absolute error epsilon. ``` # Input - An integer `n` (1 ≤ n ≤ 10^12): The number for which the square root is to be found. - A floating point number `epsilon` (1e-12 ≤ epsilon ≤ 1): The desired precision. # Output - A floating-point number representing the square root of `n`, accurate to within `epsilon`. # Constraints - The function should run efficiently for large values of `n`. - Precision must be taken into account; the result must be accurate within `epsilon` of the true square root. # Example ```python precise_square_root(5, 0.001) # Output example: 2.236 precise_square_root(10, 0.01) # Output example: 3.16 ``` # Additional Information You should account for edge cases like: - Very large `n` values to test computational efficiency. - Small and large values for `epsilon` to test precision handling. - Special values like `n = 1` should be handled correctly. **HINT**: An efficient initial guess for the square root of `n` could help speed up convergence. Good luck, and happy coding!","solution":"def precise_square_root(n: int, epsilon: float = 0.001) -> float: Return square root of n, with maximum absolute error epsilon using Newton\'s method. if n == 1: return 1.0 guess = n / 2.0 # Initial guess while True: new_guess = (guess + n / guess) / 2.0 if abs(new_guess - guess) < epsilon: return new_guess guess = new_guess"},{"question":"# Fibonacci Number Calculation Write a function that computes the n-th Fibonacci number. You are required to implement the solution using an efficient approach to ensure optimum performance for larger values of n. Avoid using a simple recursive implementation due to its inefficiency for large inputs. Function Signature ```python def fibonacci(n: int) -> int: pass ``` Input - An integer `n` (0 <= n <= 10^5) representing the index of the Fibonacci sequence. Output - An integer representing the n-th Fibonacci number. Constraints - Do not use a naïve recursive approach due to performance limitations. - Your function should handle large values of `n` efficiently. - Consider time and space complexity in your solution. Examples: 1. **Input:** n = 0 | **Output:** 0 2. **Input:** n = 1 | **Output:** 1 3. **Input:** n = 10 | **Output:** 55 4. **Input:** n = 100 | **Output:** 354224848179261915075 Additional Context: Fibonacci numbers are instrumental in various fields, such as computer algorithms (like recursive algorithms and dynamic programming), as well as in statistical models and natural phenomena. Implement an optimal solution considering both time and space efficiency.","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number. Efficiently computes the Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are given an incomplete implementation of an AVL tree in Python. Your task is to complete the key functionalities required to maintain the AVL tree\'s balance during insertion operations. Specifically, you need to implement the functions for performing left and right rotations, updating heights and balances, and rebalancing after insertions. # Task Description: 1. **Function to Insert a Node**: - Implement the `insert` method to insert a key into the AVL tree and ensure the tree remains balanced. 2. **Function to Rotate Left**: - Implement the `rotate_left` method, which performs a left rotation around a given node. 3. **Function to Rotate Right**: - Implement the `rotate_right` method, which performs a right rotation around a given node. 4. **Function to Update Heights**: - Implement the `update_heights` method to update the height of each node in the subtree. 5. **Function to Update Balances**: - Implement the `update_balances` method to update the balance factor for each node in the subtree. 6. **Function to Rebalance**: - Implement the `re_balance` method to ensure the AVL properties are maintained after each insertion. # Expected Input and Output: - **Input**: A series of integer keys to be inserted into the AVL tree. - **Output**: A list representing the in-order traversal of the AVL tree after all insertions. # Constraints: - Duplicate keys are not allowed in the AVL tree. - The keys will be integers within the range of -10^5 to 10^5. - The number of keys (n) will be within the range of 1 to 10^4. # Example: ```python avl_tree = AvlTree() keys = [10, 20, 30, 40, 50, 25] for key in keys: avl_tree.insert(key) print(avl_tree.in_order_traverse()) ``` **Output**: ``` [10, 20, 25, 30, 40, 50] ``` Your solution should ensure that the AVL tree maintains its balance properties at all times and outputs the correct in-order traversal of the tree after all insertions.","solution":"class TreeNode: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) self.update_heights(node) self.update_balances(node) return self.re_balance(node) def rotate_left(self, z): y = z.right z.right = y.left y.left = z self.update_heights(z) self.update_heights(y) return y def rotate_right(self, z): y = z.left z.left = y.right y.right = z self.update_heights(z) self.update_heights(y) return y def update_heights(self, node): if node: node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) def update_balances(self, node): if node: node.balance = self.get_height(node.left) - self.get_height(node.right) def get_height(self, node): if not node: return 0 return node.height def re_balance(self, node): if node.balance > 1: # Left heavy if node.left.balance < 0: # Left-Right case node.left = self.rotate_left(node.left) return self.rotate_right(node) if node.balance < -1: # Right heavy if node.right.balance > 0: # Right-Left case node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"Stooge Sort Implementation Objective: Implement a function based on the principles of Stooge Sort, a recursive sorting algorithm. You are to sort an array of integers into ascending order using this specific algorithm. Function Signature: ```python def stooge_sort(arr: List[int], l: int, h: int) -> None: # sorting logic here ``` Input: * `arr`: A list of integers, `arr`, where `1 <= len(arr) <= 1000` and `-10^6 <= arr[i] <= 10^6`. * `l`: The starting index of the list segment to sort. * `h`: The ending index of the list segment to sort. Output: * The function should modify the list `arr` in-place to be sorted in ascending order. Constraints: * The sort should strictly follow the principles of Stooge Sort. * You must implement the sorting directly; no library sort calls are allowed. Example: ```python arr = [2, 4, 5, 3, 1] n = len(arr) stooge_sort(arr, 0, n-1) print(arr) # Output: [1, 2, 3, 4, 5] ``` Guidelines: 1. **Recursive Sorting**: Ensure your solution implements the recursive sorting strategy outlined in the Stooge Sort algorithm. 2. **Swaps and Recursions**: Pay attention to conditional swaps and recursive calls as per the stooge sort mechanism. 3. **Edge Handling**: Consider the simplest cases (e.g., arrays of length 1 or 2). 4. **Debugging**: Be mindful of potential recursion depth issues especially for larger arrays. Ready to get started? Craft your implementation of Stooge Sort and ensure it aligns with the algorithm\'s unique recursive sorting strategy.","solution":"def stooge_sort(arr, l, h): Implements the Stooge Sort algorithm to sort the array in ascending order. if l >= h: return # If the element at the start is greater than the element at the end, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: # Calculate the one third length t = (h - l + 1) // 3 # Recursively sort the first two-thirds of the array stooge_sort(arr, l, h - t) # Recursively sort the last two-thirds of the array stooge_sort(arr, l + t, h) # Recursively sort the first two-thirds of the array again stooge_sort(arr, l, h - t) # Example for testing the function arr = [2, 4, 5, 3, 1] stooge_sort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5]"},{"question":"Implementing and Simulating a Markov Chain Scenario You are tasked to model a basic weather simulation system using a Markov Chain. The states of weather are \'Sunny\', \'Rainy\', and \'Cloudy\'. The system transitions between these states based on defined probability rules. Task Implement a function to simulate the weather for a given number of days using a Markov Chain. The function should: * Initialize with a provided initial weather state. * Transition daily based on the given Markov Chain probabilities. * Output the sequence of weather states for the given number of days. Function Signature ```python def simulate_weather(markov_chain: dict, initial_state: str, days: int) -> list: \'\'\' Args: markov_chain (dict): A dictionary representing the Markov Chain probabilities. initial_state (str): The initial weather state. days (int): The number of days to simulate. Returns: list: A list of weather states over the given number of days. \'\'\' ``` Example Input ```python markov_chain = { \'Sunny\': {\'Sunny\': 0.7, \'Rainy\': 0.2, \'Cloudy\': 0.1}, \'Rainy\': {\'Sunny\': 0.3, \'Rainy\': 0.5, \'Cloudy\': 0.2}, \'Cloudy\': {\'Sunny\': 0.4, \'Rainy\': 0.4, \'Cloudy\': 0.2}, } initial_state = \'Sunny\' days = 5 ``` Example Output ```python [\'Sunny\', \'Sunny\', \'Rainy\', \'Sunny\', \'Cloudy\'] ``` Constraints * The sum of probabilities for each state in `markov_chain` will always equal 1. * Valid states are \'Sunny\', \'Rainy\', and \'Cloudy\'. Requirements * The function should be efficient, with emphasis on minimizing time complexity where possible. * Handle edge cases such as zero days and initial state that does not exist in the chain.","solution":"import random def simulate_weather(markov_chain, initial_state, days): \'\'\' Args: markov_chain (dict): A dictionary representing the Markov Chain probabilities. initial_state (str): The initial weather state. days (int): The number of days to simulate. Returns: list: A list of weather states over the given number of days. \'\'\' if initial_state not in markov_chain: raise ValueError(\\"Initial state not in Markov Chain\\") if days < 0: raise ValueError(\\"Number of days should be non-negative\\") weather_sequence = [initial_state] current_state = initial_state for _ in range(days - 1): next_state = random.choices( list(markov_chain[current_state].keys()), list(markov_chain[current_state].values()) )[0] weather_sequence.append(next_state) current_state = next_state return weather_sequence"},{"question":"**Question: Array Filtering by Value** As part of a data preprocessing library, you are tasked with writing a function that filters values in an array based on specified minimum and maximum boundaries. Your function should handle edge cases and maintain efficient performance. **Function Signature:** ```python def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: pass ``` # Input - `arr`: A list of integers. `0 <= len(arr) <= 10^5` - `min_lim`: An integer that specifies the minimum boundary. If `None`, only the `max_lim` will be considered. - `max_lim`: An integer that specifies the maximum boundary. If `None`, only the `min_lim` will be considered. # Output - A list containing elements from the input list `arr` that satisfy the following condition: `min_lim <= element <= max_lim`. # Constraints - If both `min_lim` and `max_lim` are provided: - `min_lim` should be less than or equal to `max_lim`. - If an empty list is provided as input, the function should return an empty list. - If `min_lim` is `None`, consider it as the smallest integer value in `arr`. - If `max_lim` is `None`, consider it as the largest integer value in `arr`. # Example ```python # Example 1 arr = [1, 2, 3, 4, 5] min_lim = None max_lim = 3 print(limit(arr, min_lim, max_lim)) # Output: [1, 2, 3] # Example 2 arr = [10, 20, 30, 40, 50, 60] min_lim = 25 max_lim = 45 print(limit(arr, min_lim, max_lim)) # Output: [30, 40] # Example 3 arr = [5, 10, 15, 20, 25] min_lim = 10 max_lim = None print(limit(arr, min_lim, max_lim)) # Output: [10, 15, 20, 25] # Example 4 arr = [] min_lim = 1 max_lim = 10 print(limit(arr, min_lim, max_lim)) # Output: [] ``` # Note Consider edge cases such as: - Empty `arr`. - `min_lim` is greater than `max_lim`. - Arrays with negative values. Your implementation should efficiently handle these cases while adhering to the expected performance requirements.","solution":"def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: Filters values in an array based on specified minimum and maximum boundaries. if min_lim is None: min_lim = min(arr) if arr else float(\'-inf\') if max_lim is None: max_lim = max(arr) if arr else float(\'inf\') # Ensure min_lim <= max_lim if min_lim > max_lim: return [] return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question: Roman Numeral Validator and Converter In certain historical and computer science contexts, you might need to convert Roman numerals to integers. Given a string representing a Roman numeral, your task is to create a function that not only converts the Roman numeral to an integer but also validates the input. The Roman numeral system employs combinations of the following symbols: ``` Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 ``` In addition to direct sums, a smaller numeral before a larger numeral indicates subtraction. For example: * IV represents 4 * IX represents 9 **Requirements:** - Your function should convert a valid Roman numeral to an integer. - Your function should return -1 for invalid Roman numeral strings. - Valid Roman numerals are within the range from 1 to 3999 inclusive. **Function Signature:** ```python def roman_to_int(s: str) -> int: ``` **Input:** - `s`: A string representing a Roman numeral. **Output:** - An integer representing the numeral\'s value if it is valid, otherwise -1. **Constraints:** - The input string `s` will have a length of at least 1 and at most 15 characters. **Examples:** 1. Input: `\\"III\\"` Output: `3` 2. Input: `\\"IV\\"` Output: `4` 3. Input: `\\"IX\\"` Output: `9` 4. Input: `\\"LVIII\\"` Output: `58` 5. Input: `\\"MCMXCIV\\"` Output: `1994` 6. Input: `\\"MMCMM\\"` Output: `-1` (invalid numeral) Design your function focusing on ensuring it is efficient and correctly handles both valid and invalid inputs.","solution":"def roman_to_int(s: str) -> int: Converts a Roman numeral to an integer and validates the input. Args: s (str): A string representing a Roman numeral. Returns: int: The integer value of the Roman numeral if valid, otherwise -1. # Define Roman numeral values roman_numerals = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Invalid combinations invalid_combinations = [\'IIII\', \'VV\', \'XXXX\', \'LL\', \'CCCC\', \'DD\', \'MMMM\', \'IL\', \'IC\', \'ID\', \'IM\', \'VX\', \'VL\', \'VC\', \'VD\', \'VM\', \'XD\', \'XM\', \'LC\', \'LD\', \'LM\', \'DM\'] # If any invalid combination in s, return -1 for combo in invalid_combinations: if combo in s: return -1 integer_value = 0 prev_value = 0 for char in reversed(s): if char not in roman_numerals: return -1 # If invalid character is found current_value = roman_numerals[char] if current_value >= prev_value: integer_value += current_value else: integer_value -= current_value prev_value = current_value # Validate calculated integer value if integer_value < 1 or integer_value > 3999: return -1 # Check proper Roman numeral formation formed_roman = int_to_roman(integer_value) if formed_roman != s: return -1 return integer_value def int_to_roman(value): val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = \'\' i = 0 while value > 0: for _ in range(value // val[i]): roman_num += syb[i] value -= val[i] i += 1 return roman_num"},{"question":"Scenario You are tasked with designing a function to reverse the order of words in a given string. The input string contains multiple words separated by single spaces. Your solution should maintain the integrity of the words while reversing their order. Write a function `reverseWordsInSentence` that takes a single string as input and returns a new string where the order of the words is reversed. Your function should adhere to the following constraints and handle edge cases gracefully. Function Signature ```python def reverseWordsInSentence(string: str) -> str: ``` Inputs - `string`: A single string `string` comprising words separated by single spaces. The string can have leading or trailing spaces, and potentially multiple spaces between words. Outputs - Returns a new string with the words in reverse order, preserving single spaces between words. Constraints - The input string `string` will have a maximum length of 10^5 characters. - Words are sequences of characters separated by single spaces. - Your implementation should be efficient, aiming for O(n) time complexity. Example ```python assert reverseWordsInSentence(\\"I am keon kim and I like pizza\\") == \\"pizza like I and kim keon am I\\" assert reverseWordsInSentence(\\" keon\\") == \\"keon\\" assert reverseWordsInSentence(\\" \\") == \\"\\" assert reverseWordsInSentence(\\" keon kim \\") == \\"kim keon\\" ```","solution":"def reverseWordsInSentence(string: str) -> str: Reverses the order of words in a given string. Parameters: - string: input string containing words separated by single spaces. The string might have leading, trailing, or multiple spaces between words. Returns: - A new string with words in reverse order, with single spaces between words. # Split the string by spaces to get the list of words. words = string.split() # Reverse the list of words. reversed_words = words[::-1] # Join the reversed list of words with a single space. return \' \'.join(reversed_words)"},{"question":"You are required to implement a function that reverses a given string using different methods. To ensure your understanding of various techniques, implement the following three variations: 1. `reverse_iterative(s: str) -> str`: Using an iterative two-pointer approach. 2. `reverse_recursive(s: str) -> str`: Using a recursive approach. 3. `reverse_pythonic(s: str) -> str`: Using Python\'s slicing feature. # Requirements - **Input**: A string `s` with length constraints `1 <= len(s) <= 10^5`. - **Output**: A reversed string. # Constraints - Handle edge cases like an empty string or single character. - Ensure that the recursive method handles large strings efficiently without exceeding maximum recursion depth. # Examples ```python # Example 1 Input: \\"hello\\" Output (from all methods): \\"olleh\\" # Example 2 Input: \\"A man a plan a canal Panama\\" Output (from all methods): \\"amanaP lanac a nalp a nam A\\" ``` # Function Signatures - `def reverse_iterative(s: str) -> str:` - `def reverse_recursive(s: str) -> str:` - `def reverse_pythonic(s: str) -> str:` **Note**: - The function `reverse_recursive` should avoid excessive depth of recursion for large strings to prevent hitting Python\'s recursion limit. Ensure your solutions are optimized and provide detailed comments explaining the code.","solution":"def reverse_iterative(s: str) -> str: Reverses the given string using an iterative two-pointer approach. char_list = list(s) left, right = 0, len(char_list) - 1 while left < right: char_list[left], char_list[right] = char_list[right], char_list[left] left += 1 right -= 1 return \'\'.join(char_list) def reverse_recursive(s: str) -> str: Reverses the given string using a recursive approach. # Base case: if the string is empty or of length 1, return it as is if len(s) <= 1: return s # Recursive case: reverse the substring from the second character onwards return reverse_recursive(s[1:]) + s[0] def reverse_pythonic(s: str) -> str: Reverses the given string using Python\'s slicing feature. return s[::-1]"},{"question":"Rabin-Miller Primality Test **Problem Statement:** Implement the Rabin-Miller Primality Test to determine whether a given number `n` (where `n >= 5`) is probably prime or definitely composite. Your implementation should take two parameters: the integer `n` and an integer `k` which represents the number of iterations (higher `k` means a more reliable probabilistic result). # Function Signature ```python def rabin_miller_is_prime(n: int, k: int) -> bool: pass ``` # Input * `n` (int): The number to test for primality (`n >= 5`). * `k` (int): The number of iterations for increased accuracy (`k > 0`). # Output * Returns `True` if `n` is probably prime, and `False` if `n` is definitely composite. # Constraints * 5 ≤ `n` ≤ 10^12 * 1 ≤ `k` ≤ 100 # Performance Requirements * Aim for a time complexity of O(k * log^3(n)) and space complexity of O(1). # Example ```python # Example 1 print(rabin_miller_is_prime(97, 5)) # Output: True # Example 2 print(rabin_miller_is_prime(45, 5)) # Output: False ``` # Notes 1. Use the provided definition of `pow2_factor` and adapt the `valid_witness` function within your solution. 2. Ensure you consider edge cases, particularly values of `n` that are on the lower bounds of the constraints. # Evaluation Criteria - Correctness: Accurate implementation of the Rabin-Miller test. - Performance: Efficient handling of large numbers. - Edge Case Handling: Proper results for small primes and composites just above the minimum `n` value.","solution":"import random def rabin_miller_is_prime(n: int, k: int) -> bool: Determine if n is a probable prime using the Rabin-Miller primality test. Higher value of k increases the accuracy of the result. :param n: The number to test for primality (n >= 5). :param k: The number of iterations for increased accuracy. :return: True if n is probably prime, False if n is definitely composite. if n <= 4: return n in (2, 3) if n % 2 == 0: return False # Decompose (n-1) into (2^r) * d r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True for _ in range(k): a = random.randint(2, n - 2) if is_composite(a): return False return True"},{"question":"Objective: Write a function to process a list of words by identifying the longest matching substring within each word based on a given list of symbols and surrounding the matched substrings with square brackets. Description: You are provided with two lists: 1. A list of words. 2. A list of symbols. Your task is to find the longest matching symbol in each word and surround it with square brackets. If a word matches more than one symbol, always choose the longest matching symbol. If no symbols match a word, the word should remain unchanged. For instance: ``` words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` The expected output should be: ``` [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Constraints: 1. All words contain only lowercase and uppercase English letters. 2. There are no duplicate symbols in the provided symbols list. 3. No symbol is a proper prefix of another symbol. Function Signature: ```python def process_words(words, symbols): # Your implementation here ``` Input: * `words`: List of strings representing the words. * `symbols`: List of strings representing the symbols. Output: * List of strings with processed words where the longest matching symbol in each word is surrounded by square brackets. Requirements: * Ensure the function is efficient, with a preferable time complexity of O(n + m), where n is the total number of characters in all words, and m is the total number of characters in all symbols. * Handle edge cases such as no matching symbols, multiple matches in a word where the longest symbol should be chosen, and words that remain unchanged if no matches are found. Example: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] process_words(words, symbols) # returns [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Assessment Criteria: * Correctness and completeness of the implemented solution. * Efficiency and optimization of the algorithm. * Handling of all specified edge cases and constraints. * Cleanliness, readability, and organization of the code. Make sure to include test cases to validate your solution.","solution":"def process_words(words, symbols): Process a list of words by identifying the longest matching substring within each word based on a given list of symbols and surrounding the matched substrings with square brackets. def find_longest_match(word, symbols): longest_match = \'\' for symbol in symbols: if symbol in word and len(symbol) > len(longest_match): longest_match = symbol return longest_match processed_words = [] for word in words: longest_match = find_longest_match(word, symbols) if longest_match: word = word.replace(longest_match, f\'[{longest_match}]\') processed_words.append(word) return processed_words # Example usage words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] print(process_words(words, symbols)) # Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\']"},{"question":"# Scenario You have been given the task of sorting the results of a mini-marathon race. The participants and their respective times are stored in a list, and it is crucial that the list is sorted in ascending order based on the participants\' finishing times. You are required to implement a sorting algorithm to accomplish this. # Task Implement the `cocktail_shaker_sort` function that sorts a given list of participants\' finishing times in ascending order. # Function Signature ```python def cocktail_shaker_sort(arr: list) -> list: Sorts the input list \'arr\' using the cocktail shaker sort algorithm and returns the sorted list. Parameters: arr (list): A list of numeric values representing participants\' finishing times. Returns: list: A sorted list in ascending order. ``` # Input * The input `arr` is a list of numeric values (can be integers or floats) representing participants\' finishing times. # Output * The function should return the list sorted in ascending order. # Constraints * The list will contain at most 10,000 elements. * The elements in the list are unique and between 0 and 10,000. # Example 1. Input: `[5.4, 3.2, 6.1, 2.9, 4.7]` Output: `[2.9, 3.2, 4.7, 5.4, 6.1]` 2. Input: `[15, 10, 25, 5, 20]` Output: `[5, 10, 15, 20, 25]` 3. Input: `[]` Output: `[]` 4. Input: `[7]` Output: `[7]` The function should be efficient and handle all edge cases properly.","solution":"def cocktail_shaker_sort(arr: list) -> list: Sorts the input list \'arr\' using the cocktail shaker sort algorithm and returns the sorted list. Parameters: arr (list): A list of numeric values representing participants\' finishing times. Returns: list: A sorted list in ascending order. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 while start < end: # Forward pass new_end = start for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] new_end = i end = new_end # Backward pass new_start = end for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] new_start = i start = new_start return arr"},{"question":"Improved Selection Sort Objective Implement an optimized version of the Selection Sort algorithm that reduces the number of swaps. The function should demonstrate your understanding of the algorithm\'s core principles and edge cases while attempting to improve its efficiency. Problem Statement You need to write a function `optimized_selection_sort` that sorts an array using an improved Selection Sort, reducing unnecessary swaps. The function should also account for various edge cases and avoid performance bottlenecks where possible. Function Signature ```python def optimized_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input * `arr` (List[int]): A list of integers to be sorted. * `simulation` (bool, optional): If True, print the state of the array after each iteration. Output * List[int]: The sorted list of integers. Constraints * The array length `n` will be in the range [0, 1000]. * Each integer `arr[i]` should be in the range [-10^5, 10^5]. Performance Requirements * Aim to minimize the number of swaps compared to the standard implementation. * Ensure the function runs efficiently within the provided constraints. Sample Input and Output *Example 1* ```python arr = [64, 25, 12, 22, 11] optimized_selection_sort(arr) # Output: [11, 12, 22, 25, 64] ``` *Example 2* ```python arr = [1, 2, 3, 4, 5] optimized_selection_sort(arr, simulation=True) # Output: # iteration 0 : 1 2 3 4 5 # iteration 1 : 1 2 3 4 5 # iteration 2 : 1 2 3 4 5 # iteration 3 : 1 2 3 4 5 # iteration 4 : 1 2 3 4 5 # [1, 2, 3, 4, 5] ``` Notes * Ensure your function handles edge cases appropriately. * Provide detailed comments and simulation output for each iteration if simulation is enabled.","solution":"from typing import List def optimized_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Sort the array using an optimized version of the selection sort algorithm to minimize swaps. Parameters: arr (List[int]): The list of integers to sort. simulation (bool, optional): If True, print the state of the array after each iteration. Returns: List[int]: The sorted list of integers. n = len(arr) for i in range(n): # Find the index of the minimum element in the remaining unsorted portion of the array min_index = i for j in range(i + 1, n): if arr[j] < arr[min_index]: min_index = j # Only swap if the found minimum is not already at the current position if min_index != i: arr[i], arr[min_index] = arr[min_index], arr[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") return arr"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: This is an algorithm for identifying numbers with a special property within a given range. It could be categorized under number theory. * **Complexity**: - **Time Complexity**: O(n * m), where \'n\' is the number of integers in the range and \'m\' is the number of digits in each integer. The exponentiation operation adds some additional cost but it is generally considered constant time in complexity analysis. - **Space Complexity**: O(1) for extra space not accounting for input and output storage. * **Principles**: - Iterate through each number in the given range. - Convert the number to its string representation to extract individual digits. - Raise each digit to consecutive powers starting from 1. - Sum these values and check if the result equals the original number. - If they are equal, add the number to the result list. Characteristics & Applications * **Properties**: - Checks for a special property in numbers within a given range where each digit raised consecutively sums up to the number itself. - This is not a sorting or searching algorithm but rather a filtering algorithm based on a numerical property. * **Common Use Cases**: - Problems related to number theory. - Mathematical puzzles. - Educational tools for learning digit manipulation and exponentiation. * **Strengths/Limitations**: - **Strengths**: Simple to understand and implement. - **Limitations**: Can become slow for very large ranges due to iterating through all numbers and digits, which involves multiple exponentiation sums. Implementation Challenges * **Edge Cases**: - Handling ranges where `low` is greater than `high`. - Ensuring numbers like 0 and 1 are correctly processed. - Integer overflow for very large digit sums (though Python handles arbitrary large integers). * **Performance Bottlenecks**: - Iterating and processing each digit of all numbers in the range. - Repeated conversion and parsing of integers to strings and back. * **Error Scenarios**: - Incorrect sums due to wrong computations or off-by-one errors in exponentiation order. * **Optimization Points**: - Can skip some obvious numbers like all zeros which will never qualify. - Precompute powers if the range is fixed and reuse them. <|Analysis End|> <|Question Begin|> # Coding Challenge: Digit Power Sum Numbers Problem Statement The number 89 is the first integer with more than one digit where the sum of its digits, each raised to consecutive powers starting from 1, equals the number itself. The next such number after 89 is 135 (because 1^1 + 3^2 + 5^3 = 135). Given a range of numbers `[low, high]`, write a function `digit_power_sum_numbers(low, high)` that identifies all numbers in this range that possess the above-described property. Input - **low**: An integer representing the lower bound of the range (inclusive). - **high**: An integer representing the upper bound of the range (inclusive). Output - A list of integers containing all numbers within the given range `[low, high]` that satisfy the digit power sum property. Constraints - Assume `1 <= low <= high <= 10^6`. Examples ```python def digit_power_sum_numbers(low, high): result = [] for number in range(low, high + 1): digits = list(map(int, str(number))) summation = sum(digit ** (index + 1) for index, digit in enumerate(digits)) if summation == number: result.append(number) return result # Example usage print(digit_power_sum_numbers(1, 10)) # [1, 2, 3, 4, 5, 6, 7, 8, 9] print(digit_power_sum_numbers(1, 150)) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135] ``` Special Notes - Ensure that your solution handles the given constraints efficiently. - You are not required to handle invalid input ranges where `low > high`. Good luck!","solution":"def digit_power_sum_numbers(low, high): Function to find all numbers in the range [low, high] where the sum of the digits, each raised to consecutive powers starting from 1, equals the number itself. result = [] for number in range(low, high + 1): digits = list(map(int, str(number))) summation = sum(digit ** (index + 1) for index, digit in enumerate(digits)) if summation == number: result.append(number) return result"},{"question":"# Question: Implement a Modified Rabin-Karp String Search Algorithm You are tasked with implementing a modified version of the Rabin-Karp algorithm to handle not only lowercase letters \'a\' to \'z\' but also consider special characters. The special characters can be \'#\' and \'*\'. You need to write a function `enhanced_rabin_karp(pattern, text)`: Function Specification: - **Input**: - `pattern` (string): The pattern to search for in the text. It can include lowercase letters \'a\' to \'z\', \'#\' and \'*\'. - `text` (string): The text to search within. It can include lowercase letters \'a\' to \'z\', \'#\' and \'*\'. - **Output**: - `int`: The starting index of the first occurrence of the `pattern` in `text` using the modified Rabin-Karp algorithm. Return `-1` if the pattern is not found in the text. Constraints: - The algorithm should work efficiently even for larger texts (up to 10^5 characters). - Perform string hash comparisons correctly by accommodating the special characters. - Your solution should handle all edge cases correctly. Examples: Example 1: ```python pattern = \\"abc\\" text = \\"abcabc\\" print(enhanced_rabin_karp(pattern, text)) # Output: 0 ``` Example 2: ```python pattern = \\"#ab\\" text = \\"a#abc\\" print(enhanced_rabin_karp(pattern, text)) # Output: 1 ``` Example 3: ```python pattern = \\"***\\" text = \\"#*#*\\" print(enhanced_rabin_karp(pattern, text)) # Output: -1 ``` Performance Requirements: Ensure that your implementation leverages hashing efficiently to perform average-case O(n + m) time complexity operation in order to deal with larger input sizes effectively. Consider any scenarios where hashing might fail and how you would address these within the constraints of the problem. Aim to also ensure your solution is easy to understand with well-commented code.","solution":"def enhanced_rabin_karp(pattern, text): def hash_value(s, length): h = 0 for i in range(length): h = (h * base + ord(s[i])) % mod return h mod = 10**9 + 7 base = 257 m = len(pattern) n = len(text) if m > n: return -1 pattern_hash = hash_value(pattern, m) current_hash = hash_value(text, m) if current_hash == pattern_hash and text[:m] == pattern: return 0 base_m = pow(base, m, mod) for i in range(1, n - m + 1): current_hash = (current_hash * base - ord(text[i - 1]) * base_m + ord(text[i + m - 1])) % mod if current_hash == pattern_hash and text[i:i + m] == pattern: return i return -1"},{"question":"# 1-Sparse Stream Recovery Algorithm Implementation You are given a stream of tuples, where each tuple contains a number and a sign denoting an addition or a subtraction. Your task is to implement an algorithm to determine if the stream is 1-sparse, which means that, considering the signs, there is exactly one unique number left uncanceled in the end. INPUT A list of tuples `array`, where each tuple contains: * An integer `val` (0 <= val <= 2^31 - 1) * A character `sign (\'+\' or \'-\')` ```python array: List[Tuple[int, str]] ``` OUTPUT Return the integer value if the stream is 1-sparse, otherwise return `None`. ```python def one_sparse(array: List[Tuple[int, str]]) -> int: # Your code goes here pass # Helper function: validate the internals of your algorithm. def _check_every_number_in_bitsum(bitsum: List[int], sum_signs: int) -> bool: # Your code goes here pass # Helper function: manipulate the internal bit-wise representation. def _get_bit_sum(bitsum: List[int], val: int, sign: str): # Your code goes here pass ``` PERFORMANCE REQUIREMENTS * The solution should be in O(n) time complexity with respect to the number of tuples in the input stream. * The space complexity should be O(1), using a fixed-size array and an integer sum. CONSTRAINTS 1. Each tuple will have an integer `val` (0 <= val <= 2^31 - 1) and a sign \'+’ or ‘-\'. 2. The input list will contain at least one tuple. EXAMPLES **Example 1:** ```python Input: [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] Output: 4 ``` **Example 2:** ```python Input: [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] Output: 2 ``` **Example 3:** ```python Input: [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] Output: None ```","solution":"def one_sparse(array): Determines if the stream is 1-sparse. If it is, returns the unique number left uncanceled. value_sum = 0 sum_signs = 0 bitsum = [0] * 32 for val, sign in array: if sign == \'+\': value_sum += val sum_signs += 1 else: value_sum -= val sum_signs -= 1 _get_bit_sum(bitsum, val, sign) if value_sum == 0 or sum_signs == 0: return None candidate_value = abs(value_sum) // abs(sum_signs) if candidate_value * abs(sum_signs) != abs(value_sum): return None if _check_every_number_in_bitsum(bitsum, sum_signs): return candidate_value return None def _check_every_number_in_bitsum(bitsum, sum_signs): Validate the internal bit sum array for bit in bitsum: if bit % sum_signs != 0: return False return True def _get_bit_sum(bitsum, val, sign): Update the internal bit sum array for i in range(32): if val >> i & 1: if sign == \'+\': bitsum[i] += 1 else: bitsum[i] -= 1"},{"question":"# Scenario You are tasked with analyzing a binary tree structure in a software application for networking devices. Your goal is to determine the longest communication path between any two devices, which directly translates to finding the maximum depth of the binary tree representing the network topology. # Task Write a function `max_depth` that calculates the maximum depth of a binary tree. # Input - A binary tree `root`, where each node is an instance of `TreeNode`. # Output - An integer representing the maximum depth of the tree. # Constraints - The binary tree can have a maximum of 10,000 nodes. - Each node in the binary tree has a unique integer value. - Standard tree definitions apply: each node can have up to two children, left and right. # Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example Tree: # 10 # / # 12 15 # / / # 25 30 36 # # 100 tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) tree.left.left.right = TreeNode(100) print(max_depth(tree)) # Output should be 4 ``` # Notes - Your implementation should work for both balanced and unbalanced trees. - Consider both depth-first and breadth-first approaches but use the iterative approach as outlined above.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root): Return the maximum depth of the binary tree. if root is None: return 0 # Use DFS (Depth First Search) left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Coding Challenge: Implement a MinStack Context A MinStack is a special type of stack that, in addition to the basic stack operations (push, pop, peek, is_empty), supports retrieving the minimum element in constant time. It is useful in scenarios where you need to access the minimum value frequently without compromising the stack\'s LIFO properties. Task Your task is to implement a class `MinStack` that extends the `AbstractStack` and includes the following methods: - `push(value)`: Pushes an element onto the stack. - `pop()`: Removes and returns the element from the top of the stack. - `peek()`: Returns the top element without removing it. - `is_empty()`: Checks if the stack is empty. - `get_min()`: Retrieves the minimum element in the stack in constant time. Requirements 1. Your solution should use either an array-based or linked-list-based approach for the stack implementation. 2. Ensure that all operations (including `get_min`) are performed in constant time, O(1). Input Format - `push(value)`: A single integer value to be pushed onto the stack. - `pop()`: No input. - `peek()`: No input. - `is_empty()`: No input. - `get_min()`: No input. Output Format - `pop()`: Returns the top value from the stack. - `peek()`: Returns the top value without removing it. - `is_empty()`: Returns `True` if the stack is empty, otherwise `False`. - `get_min()`: Returns the current minimum value in the stack. Constraints - All stack operations must be O(1) in time complexity. - The stack will only contain integer values. - You may assume that `get_min` will only be called on non-empty stacks. Example ```python min_stack = MinStack() min_stack.push(5) min_stack.push(2) min_stack.push(4) print(min_stack.get_min()) # Output: 2 print(min_stack.pop()) # Output: 4 print(min_stack.peek()) # Output: 2 print(min_stack.get_min()) # Output: 2 min_stack.push(1) print(min_stack.get_min()) # Output: 1 ```","solution":"class MinStack: def __init__(self): Initialize the stack and the stack to keep track of the minimum values. self.stack = [] self.min_stack = [] def push(self, value): Pushes an element onto the stack and updates the min value stack. self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self): Removes and returns the element from the top of the stack. If the element being removed is the minimum element, also pop from the min stack. if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() return self.stack.pop() def peek(self): Returns the top element without removing it from the stack. if self.stack: return self.stack[-1] def is_empty(self): Checks if the stack is empty. return len(self.stack) == 0 def get_min(self): Retrieves the minimum element in the stack in constant time. if self.min_stack: return self.min_stack[-1]"},{"question":"# Question: Cocktail Shaker Sort Implementation and Optimization You are required to implement and optimize the Cocktail Shaker Sort for a list of integers. Your task involves completing the function to sort the given list. Additionally, you should address edge cases and propose minor optimizations. Specifications * **Function Signature**: `def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]:` * **Input**: A list of integers `arr` where `1 <= len(arr) <= 10^4` * **Output**: The sorted list of integers in ascending order. * **Constraints**: * Your implementation should handle empty lists and lists with unique or duplicate elements. * Aim to optimize the bidirectional traversal loop by avoiding already sorted regions on each pass. Example ```python >>> optimized_cocktail_shaker_sort([4, 3, 1, 2]) [1, 2, 3, 4] >>> optimized_cocktail_shaker_sort([5, 1, 4, 2, 8, 0, 2]) [0, 1, 2, 2, 4, 5, 8] >>> optimized_cocktail_shaker_sort([]) [] ``` Steps 1. Implement a function `optimized_cocktail_shaker_sort` that sorts using the optimized Cocktail Shaker Sort algorithm. 2. Ensure your implementation considers edge cases. 3. Add an optimization that reduces the inner loop\'s range each time the sorted elements grow.","solution":"def optimized_cocktail_shaker_sort(arr): Sorts a list of integers using the optimized Cocktail Shaker Sort algorithm. if len(arr) <= 1: return arr start = 0 end = len(arr) - 1 swapped = True while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing is swapped, the array is sorted if not swapped: break swapped = False # Reduce the end boundary end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i - 1] > arr[i]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Increase the start boundary start += 1 return arr"},{"question":"# Interpolation Search Enhanced # Problem Statement Implement an enhanced version of an interpolation search algorithm to better handle scenarios where the array may not be uniformly distributed. Your enhanced method should still aim to perform efficiently by interpolating possible search positions but add mechanisms to prevent performance degradation. # Function Signature ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: ``` # Input * `array` (List of integers): a non-empty sorted list in increasing order. * `search_key` (Integer): the value to be searched in the array. # Output * Return the index of `search_key` if found in the array; otherwise, return `-1`. # Examples ```python assert enhanced_interpolation_search([0, 2, 4, 6, 10, 12], 6) == 3 assert enhanced_interpolation_search([1, 3, 5, 7, 9, 11], 9) == 4 assert enhanced_interpolation_search([1, 2, 3, 4, 5, 6], -1) == -1 assert enhanced_interpolation_search([10, 20, 30, 40, 50], 55) == -1 ``` # Constraints and Requirements 1. Assume the array is non-empty and sorted in ascending order. 2. Optimize for uniformly distributed elements but account for edge cases. 3. Avoid large overhead from floating-point operations when possible. 4. Minimize the worst-case performance impact. 5. Your function should run in ( O(log log n) ) time for well-distributed arrays and in ( O(n) ) time in the worst case. # Hints 1. Consider cases where the formula may not supply an appropriate `pos` and make necessary adjustments. 2. Handle arrays with repeating elements appropriately to avoid division by zero and ensure that it doesn\'t lead to infinite loops.","solution":"def enhanced_interpolation_search(array, search_key): Perform a search for search_key in a sorted array using an enhanced interpolation search algorithm. Returns the index of search_key if found, otherwise returns -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # To prevent division by zero if array[high] == array[low]: pos = low else: # Probing the position with keeping uniform distribution in mind pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Condition of target found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"# Scenario: Right-Angled Triangle Calculation In a geometric application, you are given the task of developing a function that computes the length of an unknown side of a right-angled triangle. The sides of the triangle are represented by the `opposite`, `adjacent`, and `hypotenuse`. # Task: Write a Python function, `find_third_side(opposite, adjacent, hypotenuse)`, that: 1. Takes the lengths of two known sides and a placeholder \\"?\\" for the unknown side. 2. Uses the Pythagorean theorem to calculate the length of the unknown side. 3. Returns a tuple where the first element is the name of the calculated side (`\\"Opposite\\"`, `\\"Adjacent\\"`, or `\\"Hypotenuse\\"`) and the second element is the computed length as a float. # Function Signature ```python def find_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> Tuple[str, float]: ``` # Input: * `opposite` (float or str): Length of the opposite side or \\"?\\" if unknown. * `adjacent` (float or str): Length of the adjacent side or \\"?\\" if unknown. * `hypotenuse` (float or str): Length of the hypotenuse or \\"?\\" if unknown. # Output: * A tuple (`str`, `float`): The name of the calculated side and its length. # Constraints: - Only one of the inputs will be \\"?\\". - The inputs will always represent a valid right-angled triangle when a \\"?\\" is included. - `opposite`, `adjacent`, and `hypotenuse` must be positive numbers, and `hypotenuse` must be the longest side in the right-angled triangle. # Examples: ```python assert find_third_side(\'?\', 4, 5) == (\'Opposite\', 3.0) assert find_third_side(3, \'?\', 5) == (\'Adjacent\', 4.0) assert find_third_side(3, 4, \'?\') == (\'Hypotenuse\', 5.0) ``` # Notes: * Raise a `ValueError` if the inputs are invalid (non-numeric or do not form a right-angled triangle). * Use the Pythagorean theorem to compute the unknown side.","solution":"from typing import Union, Tuple import math def find_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> Tuple[str, float]: Returns the name of the calculated side of a right-angled triangle and its length. Parameters: opposite (float or str): Length of the opposite side or \\"?\\" if unknown. adjacent (float or str): Length of the adjacent side or \\"?\\" if unknown. hypotenuse (float or str): Length of the hypotenuse or \\"?\\" if unknown. Returns: Tuple[str, float]: The name of the calculated side and its length. if opposite == \\"?\\": opposite = math.sqrt(hypotenuse**2 - adjacent**2) return (\\"Opposite\\", opposite) if adjacent == \\"?\\": adjacent = math.sqrt(hypotenuse**2 - opposite**2) return (\\"Adjacent\\", adjacent) if hypotenuse == \\"?\\": hypotenuse = math.sqrt(opposite**2 + adjacent**2) return (\\"Hypotenuse\\", hypotenuse) raise ValueError(\\"One side must be represented as \'?\'.\\")"},{"question":"Context Martina is a Computer Science student who recently learned about the Radix Sort algorithm. She decides to implement the algorithm to understand it better and identify any potential limitations it has. Your task is to help her enhance the radix sort implementation. Task Write a function `optimized_radix_sort` that efficiently performs radix sort on a list of non-negative integers while addressing common performance bottlenecks and ensuring optimal usage of space. # Function Signature ```python def optimized_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * **arr**: A list of non-negative integers. * **simulation**: A boolean flag to print the state of the list after each iteration (default is False). # Output * Returns the list sorted in non-decreasing order. # Constraints * 1 <= len(arr) <= 10^6 * 0 <= arr[i] <= 10^9 # Performance Requirements * Implement an optimized version with respect to time (O(nk)) and space (O(n + k)) complexities. * Your solution should effectively handle edge cases such as empty arrays, large integers, and lists with uniform elements. # Sample Input & Output * **Input**: `[170, 45, 75, 90, 802, 24, 2, 66]` * **Output**: `[2, 24, 45, 66, 75, 90, 170, 802]` * **Input**: `[5, 3, 8, 5, 2, 1]` * **Output**: `[1, 2, 3, 5, 5, 8]` # Notes * Focus on optimizing both computational efficiency and memory usage. * Ensure the function can handle edge cases effectively. * Use the `simulation` flag to optionally print the array state at each iteration.","solution":"from typing import List def optimized_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: Radix Sort to sort a list of non-negative integers. :param arr: List of non-negative integers to sort. :param simulation: Boolean flag to print the state of the list after each iteration. :return: Sorted list in non-decreasing order. if len(arr) == 0: return arr def counting_sort(exp): n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that it contains the actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[], so that arr[] now contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] if simulation: print(f\\"After sorting with exp={exp}: {arr}\\") # Find the maximum number to know number of digits max_num = max(arr) # Do counting sort for every digit. Note that instead of passing the number of digits, we pass exp. # exp is 10^i where i is the current digit number exp = 1 while max_num // exp > 0: counting_sort(exp) exp *= 10 return arr"},{"question":"You are given a binary tree and asked to determine if it is symmetric around its center. A binary tree is symmetric if the left and right subtrees are mirror images of each other. Implement two functions: 1. `is_symmetric(root)`: A recursive approach to determine if the tree is symmetric. 2. `is_symmetric_iterative(root)`: An iterative approach using a stack to determine if the tree is symmetric. # Input and Output * Input: A `TreeNode` object representing the root of the binary tree. * Output: A boolean value (`True` or `False`). Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * Node values are integers in the range `[-1000, 1000]`. # Example ```python def is_symmetric(root): # your code here def is_symmetric_iterative(root): # your code here # Example inputs class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(2) tree.left.left = TreeNode(3) tree.left.right = TreeNode(4) tree.right.left = TreeNode(4) tree.right.right = TreeNode(3) print(is_symmetric(tree)) # Output: True print(is_symmetric_iterative(tree)) # Output: True ``` # Additional Notes * Handle edge cases like an empty tree (`None` should return `True`). * Ensure both solutions consider the time complexity of O(n) and space complexity based on the tree\'s height (O(log n) for balanced trees). * Provide comments and explain your approach clearly for both solutions.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_symmetric(root): Recursive approach to check if the binary tree is symmetric. if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.val == right.val and is_mirror(left.left, right.right) and is_mirror(left.right, right.left)) return is_mirror(root.left, root.right) def is_symmetric_iterative(root): Iterative approach to check if the binary tree is symmetric using a stack. if not root: return True stack = [(root.left, root.right)] while stack: left, right = stack.pop() if not left and not right: continue if not left or not right: return False if left.val != right.val: return False stack.append((left.left, right.right)) stack.append((left.right, right.left)) return True"},{"question":"# Matrix Transformation Assessment Given the following matrix transformation tasks, implement efficient functions to perform these operations. Your task is to create functions that rotate the matrix clockwise, rotate the matrix counterclockwise, invert along the top-left to bottom-right diagonal, and invert along the bottom-left to top-right diagonal. # Input: * A 2D list `matrix` representing an m x n matrix (m rows, n columns). # Output: * The transformed 2D list as specified by the operation being performed. # Constraints: - The matrix can be empty or contain only one element. - The matrix can be non-square (i.e., the number of rows is not equal to the number of columns). - The matrix may contain any data type (integers, floats, strings, etc.). # Examples: rotate_clockwise(matrix): ```python input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] output_matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] ``` rotate_counterclockwise(matrix): ```python input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] output_matrix = [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] ``` top_left_invert(matrix): ```python input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] output_matrix = [ [1, 4, 7], [2, 5, 8], [3, 6, 9], ] ``` bottom_left_invert(matrix): ```python input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] output_matrix = [ [9, 6, 3], [8, 5, 2], [7, 4, 1], ] ``` # Function Signatures: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: pass def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Guidelines: 1. Ensure your solutions work efficiently for both square and non-square matrices. 2. Handle edge cases gracefully (e.g., empty matrices). 3. Avoid redundant computations for better performance.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return matrix num_rows, num_cols = len(matrix), len(matrix[0]) return [[matrix[num_rows - 1 - row][col] for row in range(num_rows)] for col in range(num_cols)] def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return matrix num_rows, num_cols = len(matrix), len(matrix[0]) return [[matrix[row][num_cols - 1 - col] for row in range(num_rows)] for col in range(num_cols)] def top_left_invert(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return matrix return list(map(list, zip(*matrix))) def bottom_left_invert(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return matrix num_rows, num_cols = len(matrix), len(matrix[0]) return [[matrix[num_rows - 1 - r][num_cols - 1 - c] for r in range(num_rows)] for c in range(num_cols)]"},{"question":"**Scenario**: You are a software developer working on a project that requires implementing a specialized stack data structure. This stack needs to maintain its elements in a sorted order such that the highest value is always on the top, and the lowest value is at the bottom. Your task is to modify the existing OrderedStack class to improve its efficiency using a more sophisticated data structure. **Task**: Implement an optimized OrderedStack class that maintains element order while improving the efficiency of insertion. You can use any suitable data structure to achieve this goal. # Requirements: 1. **push(item)**: Place an element into the stack maintaining the order. 2. **pop()**: Remove and return the top element from the stack. 3. **peek()**: Return the top element without removing it from the stack. 4. **is_empty()**: Check whether the stack is empty. 5. **size()**: Return the number of elements in the stack. # Expected Input and Output * The `push` and `pop` methods do not return values (they modify the stack). * The `peek` method returns the top element. * The `is_empty` method returns a boolean. * The `size` method returns an integer representing the number of elements. # Constraints: * You can assume that all input elements are integers. * No need to handle multi-threading. # Performance Requirements: * Aim to improve the push operation to better than O(n) complexity (for example, O(log n) if using balanced trees or heaps). ```python # Sample skeleton of the optimized class class OrderedStack: def __init__(self): # Initialization with a suitable data structure pass def is_empty(self): # Check if the stack is empty pass def push(self, item): # Add an item while maintaining the order pass def pop(self): # Remove and return the top item pass def peek(self): # Return the top item without removing it pass def size(self): # Return the current size of the stack pass # Example usage: # stack = OrderedStack() # stack.push(3) # stack.push(5) # stack.push(1) # top_item = stack.peek() # should return 5 # print(top_item) ```","solution":"import bisect class OrderedStack: def __init__(self): self.elements = [] def is_empty(self): return len(self.elements) == 0 def push(self, item): bisect.insort(self.elements, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.elements.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.elements[-1] def size(self): return len(self.elements)"},{"question":"You are given a list of integers which may contain duplicates. Your task is to write a function `permute_unique` that returns all possible unique permutations of the input list. # Requirements - **Function Signature**: ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` - **Input/Output Example**: - Input: `[1, 1, 2]` - Output: `[[1, 1, 2], [1, 2, 1], [2, 1, 1]]` - The permutations in the output list can be in any order. # Constraints - The number of elements in the input list will not exceed 8. - The elements in the input list are integers and each element can be positive or negative. - Duplicates in the input list should not result in duplicated permutations in the output. # Performance Requirement - The solution should be optimized for both time and space complexity as much as possible. # Edge Cases to Consider - An empty input list should result in a list containing an empty list: `[[]]` - All elements in the list being the same should result in a single permutation. # Scenario Suppose you are developing a combinatorial game where you need to generate all possible unique board states given an initial set of numbers. To achieve this, you need to account for scenarios where some starting numbers are identical, yet ensure each resulting board state is unique. # Your Task Implement the function `permute_unique` by filling in the function header below. Ensure your implementation is efficient in avoiding duplicate permutations and adhere to the constraints and requirements provided.","solution":"from typing import List def permute_unique(nums: List[int]) -> List[List[int]]: def backtrack(first=0): # If all integers are used up (i.e., at the end of the list) if first == n: # Add a copy of the current permutation to the results res.append(nums[:]) # This set is used to avoid duplicate results seen = set() for i in range(first, n): if nums[i] not in seen: seen.add(nums[i]) # Swap the current element with the first element nums[first], nums[i] = nums[i], nums[first] # Use recursion to generate the permutations for the subarray backtrack(first + 1) # Backtrack (i.e., undo the swap) nums[first], nums[i] = nums[i], nums[first] n = len(nums) res = [] backtrack() return res"},{"question":"# OrderedStack Implementation and Its Extended Usage Given the `OrderedStack` class, implement an additional method within the class to merge with another ordered stack efficiently, maintaining the order in both stacks. Method Signature: ```python def merge_with(self, other: \'OrderedStack\') -> None: ``` The method should take another `OrderedStack` object `other` and merge its elements into the current stack (`self`), ensuring that the merged stack retains its order. Utilize the properties and operations of stacks efficiently to accomplish this. Input: * An instance of `OrderedStack`. Output: * Modify the current instance of `OrderedStack` to include elements from both stacks, maintaining the sorted order. Constraints: * Merging two `OrderedStack` should be operated optimally in terms of space and time, preferably better than O(n^2). Example: ```python os1 = OrderedStack() os2 = OrderedStack() for item in [1, 3, 5, 7]: os1.push(item) for item in [2, 4, 6, 8]: os2.push(item) os1.merge_with(os2) # After merging, os1 should contain [1, 2, 3, 4, 5, 6, 7, 8] print(os1.items) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ``` Explanation: 1. The method merges the elements from `other` into `self`. 2. Maintains the order in `self` post merging. # Note: Ensure the merge operation is efficient and does not exceed O(n + m), where n and m are the sizes of the two stacks.","solution":"class OrderedStack: def __init__(self): self.items = [] def push(self, item): self.items.append(item) self.items.sort() def pop(self): if not self.is_empty(): return self.items.pop() return None def peek(self): if not self.is_empty(): return self.items[-1] return None def is_empty(self): return len(self.items) == 0 def size(self): return len(self.items) def merge_with(self, other: \'OrderedStack\') -> None: # Merging the two ordered stacks using a sorted merge technique merged_items = [] i, j = 0, 0 while i < len(self.items) and j < len(other.items): if self.items[i] <= other.items[j]: merged_items.append(self.items[i]) i += 1 else: merged_items.append(other.items[j]) j += 1 while i < len(self.items): merged_items.append(self.items[i]) i += 1 while j < len(other.items): merged_items.append(other.items[j]) j += 1 self.items = merged_items other.items.clear()"},{"question":"**Context**: You are given a binary tree, where each node contains a unique value. Two nodes, `p` and `q`, are also given. Implement a function to determine the lowest common ancestor of the given nodes `p` and `q`. The lowest common ancestor of two nodes `p` and `q` is the lowest (i.e., deepest) node that has both `p` and `q` as descendants (we allow a node to be a descendant of itself). **Function Signature**: ```python def find_lowest_common_ancestor(root, p, q): :param root: TreeNode - The root of the binary tree. :param p: TreeNode - The first node. :param q: TreeNode - The second node. :return: TreeNode - The lowest common ancestor of nodes `p` and `q`. ``` **Input**: - `root`: The root node of a binary tree (Node class provided below). - `p`: The first node whose lowest common ancestor needs to be found. - `q`: The second node whose lowest common ancestor needs to be found. **Output**: - Return the lowest common ancestor node of the two given nodes. **Constraints**: 1. The number of nodes in the tree will be in the range `[2, 10^5]`. 2. Value of nodes is unique and would be integers. 3. Both nodes `p` and `q` are guaranteed to be different and present in the binary tree. **Node Class**: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` **Example**: Consider the following binary tree: ``` _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 ``` 1. If `p` = 5 and `q` = 1, the lowest common ancestor is 3. 2. If `p` = 5 and `q` = 4, the lowest common ancestor is 5. Implement the `find_lowest_common_ancestor` function to solve this problem.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def find_lowest_common_ancestor(root, p, q): Finds the lowest common ancestor of two nodes in a binary tree. :param root: TreeNode - The root of the binary tree. :param p: TreeNode - The first node. :param q: TreeNode - The second node. :returns: TreeNode - The lowest common ancestor of nodes p and q. # Base case: if the root is None or if we\'ve reached either p or q. if not root or root == p or root == q: return root # Recursively find the LCA in the left subtree. left = find_lowest_common_ancestor(root.left, p, q) # Recursively find the LCA in the right subtree. right = find_lowest_common_ancestor(root.right, p, q) # If both left and right are non-empty, root is the LCA. if left and right: return root # If one of the sides is non-empty, return the non-empty side. return left if left else right"},{"question":"# Question Problem Statement: You are provided a `pattern` and a `word`, and you need to determine if the word follows the same pattern where there is a one-to-one mapping between the characters in the pattern and non-empty substrings in the word. Write a function `pattern_match` that returns `True` if the word follows the given pattern and `False` otherwise. Function Signature: ```python def pattern_match(pattern: str, word: str) -> bool: pass ``` Input: - `pattern`: A string consisting of lowercase letters (1 ≤ len(pattern) ≤ 15). - `word`: A string consisting of lowercase letters (1 ≤ len(word) ≤ 50). Output: - Return `True` if there exists a bijection between characters in the pattern and non-empty substrings in the word such that the word follows the pattern. - Return `False` otherwise. Example: ```python pattern = \\"abab\\" word = \\"redblueredblue\\" # Returns: True (pattern \'a\' maps to \'red\' and \'b\' maps to \'blue\') pattern = \\"aaaa\\" word = \\"asdasdasdasd\\" # Returns: True (pattern \'a\' maps to \'asd\') pattern = \\"aabb\\" word = \\"xyzabcxzyabc\\" # Returns: False (No valid mapping exists) ``` Constraints: - You may assume both pattern and word contain only lowercase letters.","solution":"def pattern_match(pattern: str, word: str) -> bool: def is_match(pattern, word, pattern_to_word, word_to_pattern): if not pattern and not word: return True if not pattern or not word: return False current_pattern_char = pattern[0] for i in range(1, len(word) - len(pattern) + 2): current_word_substr = word[:i] if current_pattern_char not in pattern_to_word and current_word_substr not in word_to_pattern: pattern_to_word[current_pattern_char] = current_word_substr word_to_pattern[current_word_substr] = current_pattern_char if is_match(pattern[1:], word[i:], pattern_to_word, word_to_pattern): return True del pattern_to_word[current_pattern_char] del word_to_pattern[current_word_substr] elif current_pattern_char in pattern_to_word and pattern_to_word[current_pattern_char] == current_word_substr: if is_match(pattern[1:], word[i:], pattern_to_word, word_to_pattern): return True return False return is_match(pattern, word, {}, {})"},{"question":"# Matrix Manipulation Given the functions that transform a matrix (2D list), you need to implement a function that generalizes these transformations. Specifically, write a function capable of rotating the matrix either 90 degrees clockwise, 90 degrees counterclockwise, or inverting the matrix from the top left to the bottom right or the bottom left to the top right. Your function should be able to handle square and non-square matrices, and handle empty matrices gracefully. Function Signature ```python def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: Transforms the input matrix based on the given operation. Parameters: - matrix (List[List[int]]): The matrix to be transformed. - operation (str): The type of operation (\\"rotate_clockwise\\", \\"rotate_counterclockwise\\", \\"top_left_invert\\", \\"bottom_left_invert\\"). Returns: - List[List[int]]: The transformed matrix. pass ``` Input - `matrix`: A 2D list of integers, not necessarily square. - `operation`: A string indicating the type of operation (`\\"rotate_clockwise\\"`, `\\"rotate_counterclockwise\\"`, `\\"top_left_invert\\"`, `\\"bottom_left_invert\\"`). Output - A 2D list of integers resulting from the specified transformation on the input matrix. Constraints - The matrix will always consist of integers. - The matrix can be empty. - The `operation` string will always be one of the specified types. Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] print(transform_matrix(matrix, \\"rotate_clockwise\\")) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(transform_matrix(matrix, \\"rotate_counterclockwise\\")) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(transform_matrix(matrix, \\"_top_left_invert\\")) # Output: # [ # [3, 2, 1], # [6, 5, 4], # [9, 8, 7] # ] print(transform_matrix(matrix, \\"bottom_left_invert\\")) # Output: # [ # [9, 8, 7], # [6, 5, 4], # [3, 2, 1] # ] ```","solution":"from typing import List def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: Transforms the input matrix based on the given operation. if len(matrix) == 0 or len(matrix[0]) == 0: return matrix def rotate_clockwise(matrix): return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): return [row[::-1] for row in matrix] def bottom_left_invert(matrix): return top_left_invert(matrix[::-1]) if operation == \\"rotate_clockwise\\": return rotate_clockwise(matrix) elif operation == \\"rotate_counterclockwise\\": return rotate_counterclockwise(matrix) elif operation == \\"top_left_invert\\": return top_left_invert(matrix) elif operation == \\"bottom_left_invert\\": return bottom_left_invert(matrix) else: raise ValueError(f\\"Unsupported operation: {operation}\\")"},{"question":"Task You are required to implement an enhanced pigeonhole sort algorithm that can handle cases with a sparse distribution of key values, thereby optimizing memory usage. The enhanced function should use a dictionary instead of a list for the holes, where each key in the dictionary represents a distinct integer value in the input array. Requirements: 1. **Input Format**: - A list of integers `arr` where 1 <= len(arr) <= 10^5. - The range of integers in `arr` is from -10^9 to 10^9. 2. **Output Format**: - A list of integers sorted in non-decreasing order. 3. **Constraints**: - Your function should handle up to 10^5 integers within the specified range efficiently in terms of both time and space. - The solution should aim to use memory optimally, leveraging a dictionary to store the holes. Function Signature: ```python def enhanced_pigeonhole_sort(arr: list) -> list: pass ``` # Scenario Suppose you are given an array of integers, and the range of elements is extensive. A traditional pigeonhole sort would be inefficient due to excessive memory usage. Implement the enhanced version that optimizes space while ensuring the array is sorted correctly. **Examples**: ```python # Example 1 input: [8, 3, 2, 7, 4, 6, 8] output: [2, 3, 4, 6, 7, 8, 8] # Example 2 input: [-10, -5, 0, 5, 10] output: [-10, -5, 0, 5, 10] ``` Note: Any inbuilt sorting functions are not allowed.","solution":"def enhanced_pigeonhole_sort(arr: list) -> list: Sorts a list of integers using an enhanced pigeonhole sort algorithm optimized for sparse distributions. if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Create a dictionary to serve as the pigeonholes pigeonholes = {} # Populate the pigeonholes dictionary for num in arr: if num not in pigeonholes: pigeonholes[num] = 0 pigeonholes[num] += 1 # Reconstruct the sorted array from the pigeonholes sorted_arr = [] for key in sorted(pigeonholes): sorted_arr.extend([key] * pigeonholes[key]) return sorted_arr"},{"question":"You are given a graph represented as an adjacency matrix and an integer `source` representing the starting vertex. Implement the function `shortest_paths(graph, source)` that returns a list where each element at index `i` is the shortest distance from the `source` to vertex `i`. # Input: - `graph`: A list of lists representing the adjacency matrix of the graph where `graph[i][j]` denotes the weight of the edge from vertex `i` to vertex `j`. If no edge exists, the weight is 0 or a positive number. - `source`: An integer representing the source vertex. # Output: - A list of integers where each integer at index `i` is the shortest distance from the `source` to the vertex `i`. # Constraints: - The graph is a directed weighted graph with `V` vertices. - All edge weights are non-negative. - The number of vertices `V` (0 <= V <= 1000). # Performance Requirements: - The implementation should aim for efficient execution given the constraints. Consider optimizing the choice of data structures used to improve performance where practical. # Example: ```python graph = [ [0, 10, 0, 30, 100], [10, 0, 50, 0, 0], [0, 50, 0, 20, 10], [30, 0, 20, 0, 60], [100, 0, 10, 60, 0] ] source = 0 # Result should be the shortest path from vertex 0 to all other vertices print(shortest_paths(graph, source)) # Output: [0, 10, 50, 30, 60] ``` # Notes: - Carefully handle the edge case where there are no edges connecting the source to other vertices. - Ensure your implementation does not modify the input graph. Implement the function `shortest_paths(graph, source)` below: ```python def shortest_paths(graph, source): # Your code here ```","solution":"import heapq def shortest_paths(graph, source): Returns the shortest distances from the source to all vertices in the given graph. Using Dijkstra\'s algorithm. Parameters: graph (list of list of int): The adjacency matrix representing the graph. source (int): The starting vertex. Returns: list of int: Shortest distances from the source to each vertex. V = len(graph) distances = [float(\'inf\')] * V distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in enumerate(graph[current_vertex]): if weight > 0: # Only consider edges with a positive weight distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Objective Design a function that efficiently calculates the factorial of a given non-negative integer `n`, optionally modulo another integer `mod`. # Function Signature ```python def efficient_factorial(n: int, mod: int = None) -> int: Calculates the factorial of n. If mod is provided, return the factorial modulo mod. If mod is not provided, return the factorial of n. Parameters: - n: non-negative integer - mod: positive integer (optional) Returns: - int: factorial of n or factorial of n modulo mod (if provided) Raises: - ValueError: if n is negative, if n is not an integer, or if mod is not a positive integer ``` # Constraints - `n` is a non-negative integer (0 ≤ n ≤ 10^6). - `mod` is an optional integer parameter, if provided, it is a positive integer (1 ≤ mod ≤ 10^9). # Performance Requirements - The function should run in O(n) time complexity. - The function should strive for optimal space complexity. # Scenario In scenarios requiring large computations, such as combinatorial problems or algorithms involving large datasets, efficient calculation through modulus operations can prevent overflow and maintain performance. # Example Input and Output 1. **Example 1** ```python efficient_factorial(5) ``` *Output*: `120` 2. **Example 2** ```python efficient_factorial(5, 3) ``` *Output*: `0` (since 5! % 3 = 120 % 3 = 0) 3. **Example 3** ```python efficient_factorial(0) ``` *Output*: `1` 4. **Example 4** ```python efficient_factorial(10, 1000000007) ``` *Output*: `3628800` Your function should be robust, handling a variety of inputs and potential edge cases, as well as being efficient in both computation and memory usage.","solution":"def efficient_factorial(n: int, mod: int = None) -> int: Calculates the factorial of n. If mod is provided, return the factorial modulo mod. If mod is not provided, return the factorial of n. Parameters: - n: non-negative integer - mod: positive integer (optional) Returns: - int: factorial of n or factorial of n modulo mod (if provided) Raises: - ValueError: if n is negative, if n is not an integer, or if mod is not a positive integer if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer if provided\\") result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result"},{"question":"# Hailstone Path Transformation Context Consider the hailstone sequence (also known as Collatz sequence) starting from an integer `n`. Each term of the sequence is generated by applying the following transformations: * If `n` is 1, the sequence ends. * If `n` is even, divide it by 2. * If `n` is odd, multiply it by 3 and add 1. The sequence ultimately reaches 1 regardless of the starting value and can exhibit interesting patterns and lengths. Problem Statement Implement a function `hailstone(n)` that generates and returns the hailstone sequence starting from `n`. Function Signature ```python def hailstone(n: int) -> List[int]: ``` Input * `n` (1 <= n <= 10^6) - The starting integer of the sequence. Output * A list of integers representing the hailstone sequence starting from `n` to 1. Constraints * You should handle large sequences efficiently. Performance Requirements * Aim to keep the time complexity within reasonable limits for large values (up to around a million steps). This ensures that your implementation can handle the upper bounds without significant delays. Examples 1. Input: `n = 5` Output: `[5, 16, 8, 4, 2, 1]` 2. Input: `n = 1` Output: `[1]` 3. Input: `n = 7` Output: `[7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]` Additional Notes If the input is invalid (e.g., non-integer or outside the required range), raise an appropriate exception with a descriptive error message.","solution":"from typing import List def hailstone(n: int) -> List[int]: Generates and returns the hailstone sequence starting from `n`. Parameters: n (int): The starting integer of the sequence. Returns: List[int]: A list of integers representing the hailstone sequence from `n` to 1. if not isinstance(n, int) or n < 1 or n > 10**6: raise ValueError(\\"Input must be an integer between 1 and 10^6 inclusive.\\") sequence = [n] while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(n) return sequence"},{"question":"# Set Cover Optimization Problem Scenario You are working on a project that involves resource allocation. Given a set of resources and different groups that contain subsets of these resources, you need to find the minimum cost combination of these groups such that all resources are covered. Task You need to implement two functions to solve this problem: 1. `optimal_set_cover` using an exact algorithm. 2. `greedy_set_cover` using an approximate greedy algorithm. Functions to Implement ```python def optimal_set_cover(universe, subsets, costs): Args: universe (set): A set of elements representing the universe. subsets (dict): A dictionary where keys are subset names and values are sets representing the elements in the subsets. costs (dict): A dictionary where keys are subset names and values are the costs associated with those subsets. Returns: list: A list containing the names of the subsets that form the optimal set cover with the minimum cost. pass def greedy_set_cover(universe, subsets, costs): Args: universe (set): A set of elements representing the universe. subsets (dict): A dictionary where keys are subset names and values are sets representing the elements in the subsets. costs (dict): A dictionary where keys are subset names and values are the costs associated with those subsets. Returns: list: A list containing the names of the subsets that form the approximate set cover with a reasonable cost. pass ``` Input - `universe`: A set `U` of `n` elements. - `subsets`: A dictionary `S` containing `m` subsets, where the keys are subset names and the values are sets of elements. - `costs`: A dictionary containing the costs for each subset, where the keys are subset names and the values are integers representing the cost of the subset. Output - For `optimal_set_cover`, a list of subset names that form the optimal set cover with the minimum cost. - For `greedy_set_cover`, a list of subset names that form a near-optimal set cover with a reasonable cost. Constraints - All subsets might not necessarily be needed to cover the universe. - Each subset has a non-negative cost. - Aim for efficiency within the constraints of the algorithm\'s definition. Example ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} # Optimal covering (minimum cost) optimal_cover = optimal_set_cover(universe, subsets, costs) print(optimal_cover) # Expected Output: [\'S2\', \'S3\'] # Greedy covering (approximate minimum cost) greedy_cover = greedy_set_cover(universe, subsets, costs) print(greedy_cover) # Expected Output: [\'S3\'] or similar near-optimal result ``` Both the optimal and greedy functions should be implemented and tested with the above example and other similar test cases to ensure correctness and efficiency.","solution":"from itertools import combinations def optimal_set_cover(universe, subsets, costs): Find the exact optimal set cover using a brute force approach. subsets_list = list(subsets.keys()) n = len(subsets_list) # Generate all possible combinations of subsets and check which ones cover the universe min_cost = float(\'inf\') best_cover = None for r in range(1, n + 1): for combo in combinations(subsets_list, r): covered = set() cost = 0 for subset in combo: covered |= subsets[subset] cost += costs[subset] if covered == universe and cost < min_cost: min_cost = cost best_cover = list(combo) return best_cover def greedy_set_cover(universe, subsets, costs): Find an approximate set cover using a greedy algorithm. remaining_universe = set(universe) cover = [] while remaining_universe: best_subset = None best_subset_cost_effectiveness = float(\'inf\') for subset, elements in subsets.items(): covered_elements = elements & remaining_universe if covered_elements: # Cost-effectiveness is cost per newly covered element cost_effectiveness = costs[subset] / len(covered_elements) if cost_effectiveness < best_subset_cost_effectiveness: best_subset_cost_effectiveness = cost_effectiveness best_subset = subset if best_subset is None: return None # If no subset can cover any remaining element (should not happen) cover.append(best_subset) remaining_universe -= subsets[best_subset] return cover"},{"question":"# RSA Key Generation Algorithm Implementation You are given the task of implementing a function that generates a pair of RSA keys (public and private keys). You are required to modify the existing code to improve the performance of the key generation process, specifically focusing on prime number generation and modular inverse calculation. # Problem Statement Write a Python function `generate_key(k, seed=None)` that generates an RSA key pair (n, e, d) with the following constraints: 1. `k` is the number of bits in the modulus `n`. 2. Use a more efficient algorithm to generate the large prime numbers `p` and `q`. 3. Implement a more efficient method for calculating the modular multiplicative inverse. # Function Signature ```python def generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: ``` # Input 1. `k` (int): Number of bits in the modulus `n`. 2. `seed` (Optional[int]): Optional seed for the random number generator. # Output 1. Returns a tuple `(n, e, d)`: - `n` (int): Modulus for the public and private keys. - `e` (int): Public exponent for the public key. - `d` (int): Private exponent for the private key. # Constraints - Handle edge cases where suitable `p` and `q` must be found such that `gcd(e, φ(n)) = 1`. # Example ```python n, e, d = generate_key(16) print(n, e, d) ``` # Expected Improvements - Use an efficient primality test (e.g., Miller-Rabin). - Implement fast modular inverse computation (using Extended Euclidean Algorithm). # Hints - You can use the built-in `pow` function for fast modular exponentiation. - Ensure the prime numbers generated are indeed prime to avoid security issues.","solution":"import random from typing import Optional, Tuple def is_prime(n: int, k: int = 40) -> bool: Use Miller-Rabin primality test to check if a number is prime if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write n as d*2^r + 1 with d odd (by factoring out powers of 2 from n - 1) r, d = 0, n - 1 while d % 2 == 0: d //= 2 r += 1 def miller_rabin_test(a): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_rabin_test(a): return False return True def generate_large_prime(bits: int) -> int: Generate a large prime number of given bits using Miller-Rabin Test while True: prime_candidate = random.getrandbits(bits) if is_prime(prime_candidate): return prime_candidate def gcd(a: int, b: int) -> int: Compute the greatest common divisor using Euclid\'s algorithm while b != 0: a, b = b, a % b return a def egcd(a: int, b: int) -> Tuple[int, int, int]: Extended Euclidean Algorithm to find the multiplicative inverse if a == 0: return (b, 0, 1) g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a: int, m: int) -> int: Compute the modular multiplicative inverse of a under modulo m g, x, _ = egcd(a, m) if g != 1: raise Exception(\'Modular inverse does not exist\') return x % m def generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: Generate RSA public and private key pair if seed: random.seed(seed) e = 65537 # Common choice for e while True: p = generate_large_prime(k // 2) q = generate_large_prime(k // 2) if p != q: n = p * q phi_n = (p - 1) * (q - 1) if gcd(e, phi_n) == 1: d = modinv(e, phi_n) return (n, e, d)"},{"question":"# Question: Binary Tree In-Order Traversal with Depth Tracker Background In-order traversal of a binary tree is a common method to visit all nodes. This traversal is particularly useful in Binary Search Trees (BSTs) as it processes nodes in ascending order. To extend this concept, your task is to implement an in-order traversal that additionally tracks the depth of each node. The depth of a node is defined as the number of edges from the node to the tree\'s root. Task Write a function `inorder_with_depth(root)` that performs an in-order traversal of the binary tree and returns a list of tuples. Each tuple should contain the node\'s value and its depth. Function Signature ```python def inorder_with_depth(root: Node) -> List[Tuple[int, int]]: pass ``` Input * `root`: The root node of the binary tree (type `Node`). Output * A list of tuples, where each tuple contains: 1. An integer representing the node\'s value. 2. An integer representing the node\'s depth. Constraints * The tree can have up to 10,000 nodes. * The values of the nodes are unique. Example ```python # Constructing the binary tree: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_with_depth(n1) == [(25, 2), (50, 1), (75, 2), (100, 0), (125, 2), (150, 1), (175, 2)] ``` Notes * Ensure that your function can handle trees of varying shapes and sizes. * Consider edge cases, such as an empty tree or a tree with only one node.","solution":"from typing import List, Tuple class Node: def __init__(self, value: int, left: \'Node\' = None, right: \'Node\' = None): self.value = value self.left = left self.right = right def inorder_with_depth(root: Node) -> List[Tuple[int, int]]: Perform an in-order traversal of the binary tree and return a list of tuples (node\'s value, depth). def dfs(node, depth): if node is None: return [] return dfs(node.left, depth + 1) + [(node.value, depth)] + dfs(node.right, depth + 1) return dfs(root, 0)"},{"question":"# Binary Search Implementation Challenge You are given a sorted array of integers in ascending order. Your task is to implement both iterative and recursive versions of the binary search algorithm to find the position of a target value within the array. # Input * An array of integers sorted in ascending order. * A target integer value to search for in the array. # Output * The position (index) of the target value in the array if it exists, otherwise `-1` indicating that the value is not present. # Constraints * The array can contain up to 10^5 integers. * Each integer in the array is between -10^9 and 10^9. * The target value is also an integer between -10^9 and 10^9. # Requirements 1. Implement `binary_search_iterative(array, query)` for the iterative version. 2. Implement `binary_search_recursive(array, low, high, query)` for the recursive version. # Example ```python # Example Input array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] query = 7 # Iterative Version Output result = binary_search_iterative(array, query) # Output: 6 # Recursive Version Output result = binary_search_recursive(array, 0, len(array) - 1, query) # Output: 6 ``` # Additional Information * Ensure that your implementation handles edge cases properly, such as when the target value is not present or when the array is empty. * Consider the performance implications and aim for an optimized solution with minimal space complexity.","solution":"def binary_search_iterative(array, query): Iterative binary search function to find the index of a target value within a sorted array. :param array: List of sorted integers :param query: Target integer value to search for :return: The position (index) of the target value in the array if it exists, otherwise -1 low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array, low, high, query): Recursive binary search function to find the index of a target value within a sorted array. :param array: List of sorted integers :param low: The lower bound index for the search :param high: The upper bound index for the search :param query: Target integer value to search for :return: The position (index) of the target value in the array if it exists, otherwise -1 if low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: return binary_search_recursive(array, mid + 1, high, query) else: return binary_search_recursive(array, low, mid - 1, query) return -1"},{"question":"Given a pattern and a string, implement a function to determine if the string follows the same pattern. The function should check if there is a consistent bijection between characters in the pattern and non-empty words in the string. # Function Specification ```python def is_pattern_matching(pattern: str, str: str) -> bool: Determine if the string follows the same pattern. Parameters: - pattern (str): A string containing only lowercase letters representing the pattern. - str (str): A string containing words separated by single spaces. Returns: - bool: True if the string follows the pattern, False otherwise. ``` # Input * `pattern`: A non-empty string containing only lowercase letters. * `str`: A string containing lowercase words separated by single spaces. # Output * `True` if the string follows the given pattern. * `False` otherwise. # Constraints 1. The pattern string contains only lowercase English letters. 2. The input string words are separated by single spaces. 3. Both the pattern and the string are non-empty. # Performance Requirements * The solution should aim for a linear time complexity of O(n). * Space complexity should be minimized, with an optimal complexity of O(k) corresponding to the distinct elements. # Example Cases Example 1 * Input: `pattern = \\"abba\\"`, `str = \\"dog cat cat dog\\"` * Output: `True` Example 2 * Input: `pattern = \\"abba\\"`, `str = \\"dog cat cat fish\\"` * Output: `False` Example 3 * Input: `pattern = \\"aaaa\\"`, `str = \\"dog cat cat dog\\"` * Output: `False` Example 4 * Input: `pattern = \\"abba\\"`, `str = \\"dog dog dog dog\\"` * Output: `False` # Notes Consider edge cases such as differing lengths of pattern and string, as well as scenarios where words or pattern characters are not uniquely mapped.","solution":"def is_pattern_matching(pattern: str, s: str) -> bool: words = s.split() # If the length of pattern and words are different, return False immediately if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for ch, word in zip(pattern, words): if ch in char_to_word: if char_to_word[ch] != word: return False else: char_to_word[ch] = word if word in word_to_char: if word_to_char[word] != ch: return False else: word_to_char[word] = ch return True"},{"question":"You are given an implementation of an `OrderedStack` data structure that maintains elements in ascending order. Your task is to extend its functionality by implementing an `OrderedQueue` class using two `OrderedStack` instances. This will combine both stack properties and queue order of operations (FIFO - First In, First Out). 1. **class OrderedStack** has already been provided. 2. Create a new class `OrderedQueue` with the following methods: - `enqueue(self, item)`: Add an item to the queue while maintaining ascending order. - `dequeue(self)`: Remove and return the front item from the queue. - `front(self)`: Return the front item without removing it. - `is_empty(self)`: Check if the queue is empty. - `size(self)`: Return the size of the queue. # Constraints * All elements are integers. * There can be a maximum of 1000 operations. # Input Format * Calls to class methods `enqueue`, `dequeue`, `front`, `is_empty`, and `size`. # Output Format * Outputs for `dequeue`, `front`, `is_empty`, and `size` operations. # Example ```python # Example usage of OrderedQueue oq = OrderedQueue() oq.enqueue(5) oq.enqueue(1) oq.enqueue(3) print(oq.front()) # Should print 1 print(oq.dequeue()) # Should print 1 print(oq.front()) # Should print 3 print(oq.is_empty()) # Should print False print(oq.size()) # Should print 2 ``` # Requirements Write the complete code for the `OrderedQueue` class. Make sure your implementation correctly handles edge cases, such as dequeueing from an empty queue, maintaining order during enqueue, and maintaining proper size.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) self.stack.sort() def pop(self): if not self.is_empty(): return self.stack.pop(0) def top(self): if not self.is_empty(): return self.stack[0] def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack) class OrderedQueue: def __init__(self): self.stack1 = OrderedStack() self.stack2 = OrderedStack() def enqueue(self, item): self.stack1.push(item) def dequeue(self): while not self.stack1.is_empty(): self.stack2.push(self.stack1.pop()) deq_item = self.stack2.pop() while not self.stack2.is_empty(): self.stack1.push(self.stack2.pop()) return deq_item def front(self): while not self.stack1.is_empty(): self.stack2.push(self.stack1.pop()) front_item = self.stack2.top() while not self.stack2.is_empty(): self.stack1.push(self.stack2.pop()) return front_item def is_empty(self): return self.stack1.is_empty() def size(self): return self.stack1.size()"},{"question":"# Array Filtering by Value Range You are given an array of integers and two optional integer limits, `min_lim` and `max_lim`. Your task is to write a function that filters this array and returns a new list containing only the elements that fall between the given limits (inclusive). If `min_lim` is not provided, consider it as the minimum value in the array. Similarly, if `max_lim` is not provided, consider it as the maximum value in the array. Input Format - An array `arr` of integers (1 <= len(arr) <= 10^5). - An integer `min_lim` (optional). - An integer `max_lim` (optional). Output Format - A list of integers that fall within the specified range `[min_lim, max_lim]` inclusive. Constraints - The array will contain at least one element. - All elements will be integers. - The function must handle large arrays efficiently within O(n) time complexity. Example ```python assert limit([2, 7, 5, 3, 9], min_lim=3, max_lim=7) == [7, 5, 3] assert limit([1, 10, 25, 40], min_lim=None, max_lim=25) == [1, 10, 25] assert limit([-5, -1, 0, 6], min_lim=0, max_lim=None) == [0, 6] assert limit([1, 5, 7, 10], min_lim=2, max_lim=9) == [5, 7] assert limit([20, 30, 40], min_lim=10, max_lim=50) == [20, 30, 40] ```","solution":"def limit(arr, min_lim=None, max_lim=None): Filters the array `arr` and returns a new list containing only the elements that fall between the given limits `min_lim` and `max_lim` (inclusive). If `min_lim` is not provided, it is considered as the minimum value in the array. If `max_lim` is not provided, it is considered as the maximum value in the array. if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Question Context You are working on data preprocessing where one of the tasks is to remove duplicate elements from datasets before further analysis. You are tasked with creating an efficient algorithm that not only removes duplicates but also maintains the order of their first occurrences in the input array. Task Write a function `remove_duplicates(array)` that removes all duplicate elements from the given array while maintaining the order of their first occurrences. Input and Output * **Input**: `array` - A Python list that can contain elements of any hashable type (integers, strings, Booleans, etc.). * **Output**: A new Python list containing only the unique elements from `array`, in the order they appeared originally. Constraints * The array can contain mixed data types as long as they are hashable. * The algorithm should efficiently handle arrays with up to 10^6 elements. * Aim to optimize the algorithm with respect to both time and space complexities. Example ```python # Example 1 input_array = [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] output = remove_duplicates(input_array) print(output) # Output: [1, 2, 3, 4, \'hey\', \'hello\', True] # Example 2 input_array = [5, 5, 4, 3, 2, 1, 1] output = remove_duplicates(input_array) print(output) # Output: [5, 4, 3, 2, 1] # Example 3 input_array = [] output = remove_duplicates(input_array) print(output) # Output: [] ``` Notes 1. Elements should appear in the output list in the order of their first presence in the input list. 2. The solution should minimize time complexity while handling large datasets efficiently.","solution":"def remove_duplicates(array): Removes duplicate elements from the array while maintaining the order of their first occurrences. Args: array (list): Input list containing hashable elements. Returns: list: A new list with unique elements in the order they appeared in the input list. seen = set() unique_list = [] for item in array: if item not in seen: seen.add(item) unique_list.append(item) return unique_list"},{"question":"**Programming Task**: Implement a custom filtering function for list data in Python. **Objective**: Write a function `filter_range(arr, min_lim=None, max_lim=None)` that takes a list of integers `arr` and two optional parameters `min_lim` and `max_lim`. The function should return a new list containing elements that are greater than or equal to `min_lim` and less than or equal to `max_lim`. **Function Signature**: ```python def filter_range(arr, min_lim=None, max_lim=None): # your code here ``` # Input - `arr`: A list of integers. (0 ≤ len(arr) ≤ 10^6, -10^9 ≤ arr[i] ≤ 10^9) - `min_lim`: An integer, the lower inclusive bound. It could be None. - `max_lim`: An integer, the upper inclusive bound. It could be None. # Output - Returns a new list of integers, containing only the elements from `arr` that are within the specified range. # Constraints - If `min_lim` is None, there should be no lower limit applied. - If `max_lim` is None, there should be no upper limit applied. - Handle empty input lists by returning an empty list. # Examples ```python # Example 1 result = filter_range([1, 2, 3, 4, 5], min_lim=2, max_lim=4) print(result) # Output: [2, 3, 4] # Example 2 result = filter_range([10, 20, 30, 40, 50], min_lim=None, max_lim=25) print(result) # Output: [10, 20] # Example 3 result = filter_range([5, -1, 8, 12, 3], min_lim=0, max_lim=None) print(result) # Output: [5, 8, 12, 3] # Example 4 result = filter_range([], min_lim=10, max_lim=20) print(result) # Output: [] ``` # Performance Requirements - The function should run in O(n) time complexity and use O(n) extra space, where n is the length of the input list `arr`. # Additional Notes - Ensure the function handles edge cases like unsorted lists, negative numbers, and large datasets efficiently. - Do not use any built-in sorting functions; sorting is not needed for this problem. Make sure your function passes the provided examples and is robust enough to handle other similar test cases.","solution":"def filter_range(arr, min_lim=None, max_lim=None): Filters the given list of integers and returns a new list containing elements that are greater than or equal to min_lim and less than or equal to max_lim. :param arr: List of integers :param min_lim: Minimum limit (inclusive), can be None :param max_lim: Maximum limit (inclusive), can be None :return: New list of integers within the specified range result = [] for num in arr: if (min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim): result.append(num) return result"},{"question":"**Scenario**: You are tasked with managing a system that requires frequent bitwise operations on unsigned integers. One of the necessity is to frequently determine the number of set bits (1s) in the binary representations of integers for analytic purposes. **Problem Statement**: Write a function `count_set_bits(n: int) -> int` in Python that takes an unsigned integer `n` and returns the number of \'1\' bits it has (also known as the Hamming weight). You are provided with two approaches: an iterative version and a recursive version. Implement both functions and justify any optimizations or choices you make. **Function Definition**: ```python def count_set_bits_iter(n: int) -> int: # Implementation here def count_set_bits_recur(n: int) -> int: # Implementation here ``` **Constraint**: - `0 <= n <= 2^32 - 1` (unsigned 32-bit integer) **Examples**: 1. `n = 11` (binary `00000000000000000000000000001011`) => Output: `3` 2. `n = 128` (binary `00000000000000000000000010000000`) => Output: `1` 3. `n = 4294967295` (binary `11111111111111111111111111111111`) => Output: `32` **Implementation Details**: - Use Brian Kernighan\'s Algorithm to implement the solution. - Ensure the solution is optimal in terms of time complexity. - For the recursive approach, consider the impact on stack space and handle potential issues. **Additional Notes**: - Include appropriate error checking and edge case handling. - Justify your choice of approach in a comment or separate explanation.","solution":"def count_set_bits_iter(n: int) -> int: Returns the number of \'1\' bits (Hamming weight) in the binary representation of an unsigned integer n using an iterative approach. count = 0 while n: n &= n - 1 # This operation reduces the number of set bits by 1 count += 1 return count def count_set_bits_recur(n: int, count: int = 0) -> int: Returns the number of \'1\' bits (Hamming weight) in the binary representation of an unsigned integer n using a recursive approach. if n == 0: return count else: return count_set_bits_recur(n & (n - 1), count + 1)"},{"question":"# Task Description You are provided with an implementation of the Exchange Sort algorithm, which is a simplistic comparison-based sorting algorithm with a time complexity of O(n^2). This algorithmis straightforward but inefficient for large datasets. Your task is to implement a more efficient sorting algorithm based on the principles mentioned and compare its performance with Exchange Sort. # Problem Statement Implement the QuickSort algorithm and then compare its performance with the provided Exchange Sort implementation. Your QuickSort implementation should: 1. Use the Lomuto partition scheme. 2. Handle arrays of varying sizes. 3. Perform well on large datasets compared to Exchange Sort. # Input - A list of integers `arr` where 1 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9. # Output - A list of integers sorted in ascending order. # Constraints - Focus on optimizing the time complexity to O(n log n) average case. - Ensure in-place sorting to keep space complexity O(log n) due to recursion stack. # Example ```python Input: [3, 6, 8, 10, 1, 2, 1] Output: [1, 1, 2, 3, 6, 8, 10] ``` # Performance - Test your implementation with arrays of increasing sizes (e.g., 10, 100, 1000, ...) and compare execution times with the provided Exchange Sort method. # Requirements 1. **QuickSort Implementation**: * `quick_sort(arr: List[int]) -> List[int]`: Sorting function using QuickSort algorithm. 2. **Performance Comparison**: * Execute both `exchange_sort` and your `quick_sort` on identical arrays and measure their execution time. * Provide a brief report on performance differences.","solution":"def quick_sort(arr): QuickSort algorithm using Lomuto partition scheme. Parameters: arr (list): The list of integers to sort. Returns: list: The sorted list of integers. def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(low, high): if low < high: pi = partition(low, high) quick_sort_recursive(low, pi - 1) quick_sort_recursive(pi + 1, high) quick_sort_recursive(0, len(arr) - 1) return arr def exchange_sort(arr): Exchange Sort algorithm. Parameters: arr (list): The list of integers to sort. Returns: list: The sorted list of integers. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Matrix Transformations You are given a square matrix (2D list) of integers. Implement two functions: `rotate_clockwise(matrix)` and `reflect_diagonally(matrix)` based on the following scenarios: rotate_clockwise(matrix) Rotate the matrix 90 degrees clockwise. reflect_diagonally(matrix) Reflect the matrix across its main diagonal (top-left to bottom-right). **Function Signatures**: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: pass def reflect_diagonally(matrix: List[List[int]]) -> List[List[int]]: pass ``` **Input**: * `matrix`: A square matrix (list of lists) where each sublist is a row of the matrix. **Output**: * A new matrix that represents the rotated or reflected form of the input. **Constraints**: * The matrix is guaranteed to be square with dimensions `n x n`, where `1 <= n <= 100`. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # After rotate_clockwise(matrix) # The output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # After reflect_diagonally(matrix) # The output should be: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` # Requirements: 1. Implement the `rotate_clockwise` function to rotate the matrix by 90 degrees clockwise. 2. Implement the `reflect_diagonally` function to reflect the matrix along its main diagonal from top-left to bottom-right. 3. Ensure your implementation is efficient and handles edge cases effectively. # Constraints: - You are expected to complete the transformations within an acceptable time complexity. - You may not use any additional libraries beyond the standard Python libraries.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate the given square matrix 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated def reflect_diagonally(matrix: List[List[int]]) -> List[List[int]]: Reflect the given square matrix across its main diagonal (top-left to bottom-right). n = len(matrix) reflected = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): reflected[j][i] = matrix[i][j] return reflected"},{"question":"# Rotating an Array Function Implementation Context You are tasked with implementing a function that rotates an array of integers to the right by a specified number of steps. Rotating means that elements are shifted in a circular manner to the end of the array, and elements displaced past the array length wrap around to the beginning. Requirements 1. Implement a function `rotate_array(array, k)` that performs the array rotation efficiently. 2. The function should return the modified array after rotating it `k` steps to the right. 3. Aim for optimal time complexity, avoiding excessive looping and redundant operations. Input and Output Formats - **Input**: - `array` (List[int]): A list of integers to be rotated. - `k` (int): An integer representing the number of positions to rotate the array. - **Output**: - Returns a list of integers representing the rotated array. Constraints 1. The length of `array` (`n`) is between 0 and 10^5. 2. `k` is a non-negative integer. Examples Example 1: ```python Input: array = [1, 2, 3, 4, 5, 6, 7], k = 3 Output: [5, 6, 7, 1, 2, 3, 4] ``` Example 2: ```python Input: array = [-1, -100, 3, 99], k = 2 Output: [3, 99, -1, -100] ``` Example 3: ```python Input: array = [1, 2, 3, 4, 5, 6, 7], k = 10 Output: [5, 6, 7, 1, 2, 3, 4] # because 10 % 7 = 3 ``` Implementation Provide your optimal implementation for the function `rotate_array(array, k)`.","solution":"def rotate_array(array, k): Rotates the elements of the array to the right by k steps. Parameters: array (List[int]): The list of integers to be rotated. k (int): The number of steps to rotate the array. Returns: List[int]: The rotated array. if not array: return array n = len(array) k = k % n # handle cases where k > n return array[-k:] + array[:-k]"},{"question":"# Question Scenario You are developing a software module for a linear algebra library in Python. One of the critical functionalities is to compute the inverse of an n x n matrix, which is pivotal in numerous applications including solving systems of linear equations and computer graphics transformations. Task Write a Python function `invert_matrix(m)` that computes the inverse of a given n x n matrix. Requirements 1. The function should receive a square matrix (a list of lists) `m` as input. 2. It should return another matrix which is the inverse of `m`. Constraints 1. The function should handle matrices of size ( n ge 2 ). 2. The function should return a special error matrix with `[-1]` if the input is not a valid matrix, `[-2]` if the input matrix is not square, `[-3]` if the dimension is less than 2x2, and `[-4]` if the matrix is singular (determinant is 0). 3. You can assume the input matrix will contain only rational numbers (integers and fractions). Function signature ```python def invert_matrix(m: List[List[Union[int, fractions.Fraction]]]) -> List[List[Union[int, float, fractions.Fraction]]]: ``` Example ```python # Example matrix matrix = [ [4, 7], [2, 6] ] inverse = invert_matrix(matrix) # Example output print(inverse) # Output: # [[0.6, -0.7], # [-0.2, 0.4]] ``` Performance Your solution should aim to be as efficient as possible, utilizing any appropriate mathematical optimizations to limit computational complexity. # Notes 1. You may utilize the `fractions` module for precise rational number calculations. 2. Validate the input matrix before executing the inversion logic and return the appropriate error matrix in case of validation failures. 3. Focus on handling edge cases such as singular matrices and invalid inputs efficiently.","solution":"from typing import List, Union from fractions import Fraction import copy def invert_matrix(m: List[List[Union[int, Fraction]]]) -> List[List[Union[int, float, Fraction]]]: n = len(m) # Validate matrix if not all(isinstance(row, list) for row in m): return [-1] if not all(len(row) == n for row in m): return [-2] if n < 2: return [-3] # Helper function to compute the determinant def determinant(matrix): if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1)**c) * matrix[0][c] * determinant(minor(matrix, 0, c)) return det # Helper function to get the minor of a matrix def minor(matrix, row, col): return [row[:col] + row[col+1:] for row in (matrix[:row] + matrix[row+1:])] # Main Gauss-Jordan elimination for matrix inversion A = copy.deepcopy(m) n = len(A) I = [[Fraction(int(i == j)) for i in range(n)] for j in range(n)] for i in range(n): if A[i][i] == 0: for j in range(i+1, n): if A[j][i] != 0: A[i], A[j] = A[j], A[i] I[i], I[j] = I[j], I[i] break else: return [-4] for i in range(n): factor = A[i][i] if factor == 0: return [-4] for j in range(n): A[i][j] = A[i][j] / factor I[i][j] = I[i][j] / factor for k in range(n): if k != i: factor = A[k][i] for j in range(n): A[k][j] -= factor * A[i][j] I[k][j] -= factor * I[i][j] return [[float(I[i][j]) for j in range(n)] for i in range(n)]"},{"question":"You are given two strings **s** and **t**. Write a function `is_anagram(s, t)` that determines whether **t** is an anagram of **s**. Your goal is to verify if one string can be rearranged to form the other using a hash table-based frequency comparison approach. # Requirements * **Function Signature**: `def is_anagram(s: str, t: str) -> bool:` * **Input**: * `s`: A string containing only lowercase alphabets (1 <= len(s) <= 10^5) * `t`: A string containing only lowercase alphabets (1 <= len(t) <= 10^5) * **Output**: * Returns `True` if `t` is an anagram of `s`. * Returns `False` otherwise. * **Constraints**: * Both strings **s** and **t** will only contain lowercase alphabets. # Examples ```python # Example 1: s = \\"anagram\\" t = \\"nagaram\\" # Output: True # Example 2: s = \\"rat\\" t = \\"car\\" # Output: False ``` # Instructions 1. Implement the function based on the provided requirements. 2. Optimize your implementation to have O(n) time complexity and O(1) space complexity, considering the constraints. 3. Handle edge cases such as strings of different lengths, and ensure your code runs efficiently for the maximum input sizes.","solution":"def is_anagram(s: str, t: str) -> bool: Determines whether t is an anagram of s. Both input strings consist of lowercase alphabets. if len(s) != len(t): return False char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in t: if char not in char_count: return False char_count[char] -= 1 if char_count[char] < 0: return False return True"},{"question":"Optimized Primitive Root Finder You are tasked to write an optimized version of the primitive root finder algorithms provided. Specifically, implement the following functions: Function Signature: ```python def find_order(a: int, n: int) -> int: pass def euler_totient(n: int) -> int: pass def find_primitive_root(n: int) -> List[int]: pass ``` Function Descriptions: 1. **find_order(a: int, n: int) -> int**: - *Objective*: Calculate the order of integer ( a ) modulo ( n ), where the order ( k ) is the smallest positive integer such that ( a^k equiv 1 (text{mod} n) ). - *Input*: Two integers, ( a ) and ( n ). - *Output*: The order ( k ) or -1 if it doesn\'t exist. - *Constraints*: ( 1 leq a, n leq 10^6 ). 2. **euler_totient(n: int) -> int**: - *Objective*: Calculate Euler’s totient function ( phi(n) ), which counts numbers up to ( n ) that are coprime with ( n ). - *Input*: One integer, ( n ). - *Output*: The totient ( phi(n) ). - *Constraints*: ( 1 leq n leq 10^6 ). 3. **find_primitive_root(n: int) -> List[int]**: - *Objective*: Find all primitive roots of ( n ) using the previously defined functions. - *Input*: One integer, ( n ). - *Output*: List of all primitive roots of ( n ). If no primitive roots are found, return an empty list. - *Constraints*: ( 1 leq n leq 10^6 ). Constraints: * Ensure that your implementation is optimized for performance, particularly with attention to: * Efficient computation of the order and Euler\'s totient function. * Minimization of redundant calculations. * Optimization points are crucial, as input size can be large. Performance: * Your code should handle large values up to ( 10^6 ) efficiently. * Aim for a complexity that closely matches or improves upon the provided algorithms, where possible. Example: ```python print(find_order(2, 5)) # Output: 4 print(euler_totient(9)) # Output: 6 print(find_primitive_root(10)) # Output: [3, 7] ``` **Note:** Your code will be evaluated based on correctness, efficiency, edge case handling, and adherence to constraints.","solution":"from typing import List def find_order(a: int, n: int) -> int: Calculates the order of `a` modulo `n`, the smallest k such that a^k ≡ 1 (mod n). if (a % n == 0): return -1 order = 1 value = a % n while value != 1: value = (value * a) % n order += 1 if order > n: return -1 return order def euler_totient(n: int) -> int: Calculates Euler\'s totient function φ(n), the count of integers up to n that are coprime with n. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(n: int) -> List[int]: Finds all primitive roots of `n`. if n == 1: return [0] roots = [] phi = euler_totient(n) for candidate in range(1, n): if gcd(candidate, n) == 1 and find_order(candidate, n) == phi: roots.append(candidate) return roots def gcd(a: int, b: int) -> int: Finds the greatest common divisor of a and b. while b: a, b = b, a % b return a"},{"question":"# Context You are tasked with enhancing a tree traversal module that provides various ways to traverse a binary tree. One traversal you need to implement is the postorder traversal, which processes each node\'s left child first, then the right child, and finally the node itself. # Problem Statement Write a function `postorder_traversal` that performs a postorder traversal on a binary tree and returns the result as a list of values. # Requirements - You are required to implement both iterative and recursive versions of the postorder traversal. - Ensure your solution handles edge cases efficiently. # Input - `root`: The root of the binary tree (Node). # Output - A list of integer values representing the node values in postorder sequence. # Constraints - The value of each node is unique. - There can be up to 10^4 nodes in the tree. # Example Consider the following binary tree: ``` 1 / 2 3 / 4 5 ``` For this tree, the postorder traversal sequence should be: [4, 5, 2, 3, 1]. # Implementation - Function Signature: ```python def postorder_traversal(root: Node) -> List[int]: pass ``` # Additional Notes - You may use the `Node` class provided in the snippets within your solution. - Use efficient data structures to manage intermediate values.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def postorder_traversal_recursive(root): def traverse(node): if not node: return [] return traverse(node.left) + traverse(node.right) + [node.value] return traverse(root) def postorder_traversal_iterative(root): if not root: return [] stack, result = [root], [] while stack: node = stack.pop() result.append(node.value) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return result[::-1]"},{"question":"# Task Implement a `ResizableHashTable` class inspired by the provided `ResizableHashTable` and `HashTable` implementations. The new class should include the following functionalities: * A method to shrink the hash table size by half if the number of key-value pairs falls below a third of the current size (like Python’s dictionary). # Requirements: * Implement a `put` method to add new key-value pairs: * If the table is more than two-thirds full, it should double its size. * If the table is less than one-third full and greater than the minimum size, it should halve its size. * Implement a `del` method to delete key-value pairs. * If the table falls below one-third of the capacity, it should dynamically halve its size. * Ensure that the overall complexity remains close to O(1) for most operations. # Input and Output * **Input**: The sequence of operations `put`, `get`, and `del` along with the corresponding keys and values. * **Output**: For `put` and `del`, no output. For `get`, return the corresponding value or `None` if the key is not found. # Method Signatures ```python class ResizableHashTable: def __init__(self): pass def put(self, key, value): pass def get(self, key): pass def del_(self, key): pass ``` # Constraints * Key values will be integers. * Handle dynamic resizing within reasonable limits (both growth and shrink). # Example ```python hashtable = ResizableHashTable() hashtable.put(1, \'A\') hashtable.put(2, \'B\') print(hashtable.get(1)) # Output: \'A\' hashtable.del_(1) print(hashtable.get(1)) # Output: None ```","solution":"class ResizableHashTable: def __init__(self, init_size=4): self.size = init_size self.load_factor = 0 self.table = [None] * self.size self.count = 0 def _hash(self, key): return key % self.size def _resize(self, new_size): old_table = self.table self.size = new_size self.table = [None] * self.size for entry in old_table: if entry is not None: new_hash = self._hash(entry[0]) while self.table[new_hash] is not None: new_hash = (new_hash + 1) % self.size self.table[new_hash] = entry def put(self, key, value): if self.count > 2 * self.size / 3: self._resize(self.size * 2) index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.size self.table[index] = (key, value) self.count += 1 self.load_factor = self.count / self.size def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size return None def del_(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 self.load_factor = self.count / self.size if self.count < self.size / 3 and self.size > 4: self._resize(self.size // 2) return index = (index + 1) % self.size"},{"question":"A non-negative integer is represented as an array of digits, with the most significant digit at the head of the list. Your task is to write a function `increment_digits(digits)` that increments the number by one and returns the result as the updated list of digits. Function Signature ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` # Input Format * `digits`: A list of integers `[d1, d2, ..., dn]` where each integer `0 <= di <= 9` and 1 <= len(digits) <= 1000. # Output Format * A list of integers representing the incremented number. # Constraints * The list should handle various lengths of input efficiently. * The implementation should be able to deal with cases where the digits are all 9s. * Optimize for both time and space wherever feasible. # Examples 1. **Input**: `digits = [1, 2, 3]` * **Output**: `[1, 2, 4]` 2. **Input**: `digits = [9, 9, 9]` * **Output**: `[1, 0, 0, 0]` # Scenario Consider a digital counter represented by the digits of a large number. When the counter is incremented by one, the entire number must be adjusted accordingly. Write a clear and efficient function to achieve the required transformation.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: Increment a number represented by a list of digits by 1. Args: digits (List[int]): List of digits representing a non-negative integer. Returns: List[int]: List of digits representing the incremented number. n = len(digits) # Traverse the digits array starting from the last digit for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If all the digits are 9, the result should be 1 followed by all 0s return [1] + [0] * n"},{"question":"# Task You are given a hierarchical tree structure stored as a dictionary, where keys represent nodes and the associated lists can contain mixed data types, including further nested lists. Your task is to enhance the provided `tree_print` function to handle the following additional requirements: 1. Print nested lists with proper indentation that visually represents their hierarchy. 2. Handle cases where non-string elements are present by adding proper indentations to differentiate them. 3. Cache intermediate lookups to improve performance. # Expected Function Signature ```python def enhanced_tree_print(tree: dict) -> None: ``` # Input The input is a single dictionary `tree` that could have numeric or string keys and values. Each key maps to a list of mixed types (strings, numbers, or further lists). # Output The function should print the tree structure in a clear, hierarchical manner with proper indentations. Each key and its associated values should be printed on separate lines, with nested values indented to show their level of hierarchy. # Constraints 1. The tree will have at most 10^5 nodes. 2. The depth of the nested lists will not exceed 10. 3. String values will not exceed 100 characters in length. 4. Numbers are integers within the range -10^6 to 10^6. # Examples Example 1 **Input:** ```python tree = { \'a\': [\'Adam\', [\'Book\', 4]], \'b\': [\'Bill\', [\'Computer\', 5], \'TV\', 6], \'c\': [\'Bill\', [\'Sports\', 3]], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` **Output:** ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 TV -> 6 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 TV -> 2 f -> Adam -> Computer -> 7 ``` # Notes 1. Ensure that each level of the hierarchy is correctly indented. 2. Minimize unnecessary lookups to avoid performance degradation. 3. Be careful with mixed data types within lists for proper printing.","solution":"def enhanced_tree_print(tree: dict) -> None: Print the hierarchical tree structure stored as a dictionary with proper indentation to represent the hierarchy. def print_helper(item, indent_level): Helper function to recursively print each item in the tree with proper indentation. indent = \' \' * indent_level if isinstance(item, list): for sub_item in item: print_helper(sub_item, indent_level + 1) else: print(f\\"{indent}{item}\\") for key, value in tree.items(): print(f\\"{key} ->\\") print_helper(value, 1)"},{"question":"As a part of network security algorithms, the Euler\'s Totient function is frequently used. Your task is to implement the function for a given integer `n` and handle multiple test cases efficiently. Scenario In an encryption system, the totient function φ(n) plays a crucial role. You are required to develop a function that will be used to compute φ(n) for various values of `n`. Requirements * Write a function `compute_totients(numbers)` that accepts a list of integers `numbers` and returns a list of totient values for each integer in the input list. * Implement the function such that it efficiently computes the totient values even for relatively large input values up to 10^6. Function Signature ```python def compute_totients(numbers: List[int]) -> List[int]: pass ``` Input & Output Formats * **Input**: * `numbers`: A list of integers, 1 ≤ len(numbers) ≤ 1000, 1 ≤ numbers[i] ≤ 10^6 * **Output**: * Return a list of integers where each element corresponds to the totient of the respective integer in the input list. Constraints * Ensure the solution is optimized to handle large values of `n`. Examples ```python numbers = [1, 2, 3, 4, 5, 10, 12, 1000000] # The expected output: [1, 1, 2, 2, 4, 4, 4, 400000] result = compute_totients(numbers) print(result) # Output: [1, 1, 2, 2, 4, 4, 4, 400000] ``` Additional Requirements * Your implementation should handle edge cases, such as prime numbers and perfect squares. * You might consider preprocessing strategies to optimize for large input sizes.","solution":"from typing import List def compute_totients(numbers: List[int]) -> List[int]: max_n = max(numbers) phi = list(range(max_n + 1)) # Initialize list for totient values for i in range(2, max_n + 1): if phi[i] == i: # i is a prime number for j in range(i, max_n + 1, i): phi[j] = phi[j] * (i - 1) // i result = [phi[num] for num in numbers] return result"},{"question":"Context You need to design a function for a system where users frequently request the next possible number using the exact set of digits they input. This functionality is crucial to ensure seamless user experience in number permutation-related features. Problem Statement Write a function `next_bigger(num)` that takes an integer `num` and returns the next higher number that has the exact same set of digits as the original number. If no such number exists, return -1. Implementation Details 1. **Input**: - An integer `num` (0 ≤ `num` ≤ 10^9). 2. **Output**: - An integer representing the next higher number using the same digits, or -1 if no such number exists. 3. **Constraints**: - The input integer will fit into a standard 32-bit signed integer. - The input integer has no leading zeros except for zero itself. 4. **Example**: ```python next_bigger(38276) -> 38627 next_bigger(99999) -> -1 ``` Requirements * Implement the function using optimal time and space complexity. * Handle edge cases like single-digit numbers, descending sequences, and identical digits. * Ensure your function is robust and can be tested with various inputs. # Sample Unit Tests ```python import unittest class TestSuite(unittest.TestCase): def test_next_bigger(self): self.assertEqual(next_bigger(38276), 38627) self.assertEqual(next_bigger(12345), 12354) self.assertEqual(next_bigger(1528452), 1528524) self.assertEqual(next_bigger(138654), 143568) self.assertEqual(next_bigger(54321), -1) self.assertEqual(next_bigger(999), -1) self.assertEqual(next_bigger(5), -1) if __name__ == \'__main__\': unittest.main() ```","solution":"def next_bigger(num): Returns the next higher number that has the exact same set of digits as num. If no such number exists, return -1. num_list = list(str(num)) length = len(num_list) # Find the first digit (from the end) that is smaller than the digit next to it for i in range(length - 2, -1, -1): if num_list[i] < num_list[i + 1]: break else: # If no such digit is found, it means the digits are in descending order return -1 # Find the smallest digit on the right side of the found digit that is larger than the found digit for j in range(length - 1, i, -1): if num_list[j] > num_list[i]: break # Swap these two digits num_list[i], num_list[j] = num_list[j], num_list[i] # Reverse the digits after the found digit num_list = num_list[:i + 1] + num_list[i + 1:][::-1] return int(\\"\\".join(num_list))"},{"question":"# Practical Coding Question: URL and File Path Joiner Problem Statement You are implementing a file management system that needs to construct valid paths by joining directory paths with filenames, and a URL generator that constructs full URLs by concatenating a base URL with a relative path. Create a function `join_paths(base: str, suffix: str) -> str` that reliably combines these parts using the following rules: 1. There should be exactly one `/` separating the base and suffix. 2. Any leading slashes on the suffix and trailing slashes on the base should be removed before joining. 3. Trailing whitespaces in the suffix should be discarded. **Function Signature**: ```python def join_paths(base: str, suffix: str) -> str: pass ``` Input * `base` (str): The base URL or directory path. * `suffix` (str): The relative path or filename. Output * (str): A combined path string formed by joining base and suffix with a single `/` in between. Constraints * All inputs will be valid strings containing alphanumeric characters or common URL/path separators. * The length of each string will be between 1 and 10,000 characters. Example ```python assert join_paths(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert join_paths(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert join_paths(\\"http://example.com/\\", \\"/part\\") == \\"http://example.com/part\\" assert join_paths(\\"http://example.com\\", \\"part\\") == \\"http://example.com/part\\" assert join_paths(\\"path\\", \\"file/\\") == \\"path/file\\" assert join_paths(\\"path/\\", \\"/file \\") == \\"path/file\\" ``` Notes 1. Consider edge cases such as when either string is empty, or contains only separators. 2. The solution should be efficient given the constraints on input size. 3. Do not use any libraries or modules except for string methods.","solution":"def join_paths(base: str, suffix: str) -> str: Joins the base and suffix with exactly one \'/\' in between, removing any trailing slashes in the base and leading slashes and trailing whitespaces in the suffix. Parameters: - base (str): The base URL or directory path. - suffix (str): The relative path or filename. Returns: - str: The combined path string. base = base.rstrip(\'/\') suffix = suffix.lstrip(\'/\').rstrip() return f\\"{base}/{suffix}\\""},{"question":"Given a doubly linked list, implement a function to reverse the list. # Function Signature # ```python def reverse_doubly_linked_list(head: DoublyLinkedListNode) -> DoublyLinkedListNode: pass ``` # Input # * `head` : The head node of the doubly linked list. If the list is empty, head will be None. # Output # * Return the new head of the reversed list. # Constraints # * You must perform the reversal in place. * The function should handle lists with multiple nodes, one node, and an empty list. * Your solution should complete in O(n) time where n is the number of nodes in the list. # Example # ```python # Example demonstration node1 = DoublyLinkedListNode(1) node2 = DoublyLinkedListNode(2) node3 = DoublyLinkedListNode(3) node1.next = node2 node2.prev = node1 node2.next = node3 node3.prev = node2 # Reverse the list new_head = reverse_doubly_linked_list(node1) # [3, 2, 1] ``` # Scenario # Imagine you\'re designing an undo feature for a word processor. Each state is recorded in a doubly linked list node, and you need to reverse this list efficiently when the user opts to revert to an earlier version.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None def reverse_doubly_linked_list(head: DoublyLinkedListNode) -> DoublyLinkedListNode: if not head: return None current = head new_head = None while current: new_head = current current.next, current.prev = current.prev, current.next current = current.prev return new_head"},{"question":"Find \'k\' Closest Points to the Origin **Context:** You are working on a location-based service and need to find the `k` closest locations to a central meeting point or an origin. This can be applied, for example, to finding the closest delivery points or the nearest public facilities. **Task:** Write a Python function that, given a list of 2D points and an integer `k`, returns the `k` closest points to the origin `(0,0)` using a max-heap approach. **Function Signature:** ```python def k_closest(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]: ``` **Input:** - `points`: A list of tuples where each tuple `(x, y)` represents a point in a 2D plane. - `k`: An integer representing the number of closest points to return. **Output:** - A list of `k` tuples, each representing a point that is closest to the origin `(0, 0)`. **Constraints:** - Each point will have an integer coordinate `(x, y)`. - `1 <= len(points) <= 10^4` - `1 <= k <= len(points)` **Performance Requirements:** - Time Complexity: Should be within `O(n log k)`. - Space Complexity: Should be within `O(k)`. # Example **Input:** ```python points = [(1, 3), (3, 4), (2, -1)] k = 2 ``` **Output:** ```python [(1, 3), (2, -1)] ``` **Important Notes:** - In the case of ties (points with the same distance), any set of correct points is acceptable. - Consider edge cases such as `k` equal to the length of the points list or if multiple points have the same distance from the origin. **Additional Instructions:** - Ensure your code handles validation for improper `k` values gracefully. - Provide comments within your solution to explain the logic where necessary.","solution":"import heapq from typing import List, Tuple def k_closest(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]: Finds the k closest points to the origin (0,0) using a max-heap approach. Args: points (List[Tuple[int, int]]): A list of tuples representing points in a 2D plane. k (int): The number of closest points to return. Returns: List[Tuple[int, int]]: A list of k tuples representing the closest points to the origin. # Max-heap to maintain the k closest points max_heap = [] # Create a max-heap of the first k points with their squared distance as the key for i in range(k): x, y = points[i] dist = -(x**2 + y**2) # Negative distance for max-heap behavior using heapq heapq.heappush(max_heap, (dist, (x, y))) # Process the remaining points for i in range(k, len(points)): x, y = points[i] dist = -(x**2 + y**2) if dist > max_heap[0][0]: # If this point is closer than the farthest in the heap, replace the farthest heapq.heappop(max_heap) heapq.heappush(max_heap, (dist, (x, y))) # Extract the points from the heap return [point for (_, point) in max_heap]"},{"question":"# Coding Task: Extended Factorial Calculation Context and Description You are helping a research team to perform combinatorial calculations, and they require a function to compute the factorial of a number with the possibility of returning the result modulo a given value. You are provided a function that computes the factorial iteratively and recursively. Extend the functionality by implementing a function `extended_factorial` that supports both iterative and recursive strategies while handling large inputs efficiently using modular arithmetic. Objective Implement a function `extended_factorial` that computes the factorial using the specified strategy (`iterative` or `recursive`) and allows for large number handling via modular arithmetic. Function Signature ```python def extended_factorial(n: int, mod: int = None, strategy: str = \'iterative\') -> int: Compute the factorial of a non-negative integer n optionally modulo mod using the specified strategy. Parameters: n (int): A non-negative integer whose factorial is to be computed. mod (int, optional): A positive integer for modulo operation. Defaults to None. strategy (str, optional): A string specifying the strategy to use, \'iterative\' or \'recursive\'. Defaults to \'iterative\'. Returns: int: The factorial of n, optionally modulo mod. Raises: ValueError: If n is not a non-negative integer or if mod is not a positive integer (when provided). ValueError: If strategy is not \'iterative\' or \'recursive\'. ``` Input - `n`: A non-negative integer. - `mod` (optional): A positive integer. If provided, the factorial should be calculated modulo this value. - `strategy` (optional): A string specifying which method to use for calculation, either \'iterative\' or \'recursive\'. Defaults to \'iterative\'. Output - An integer representing `n!` or `(n! % mod)` based on the provided parameters. Constraints - `0 <= n <= 10^6` - `1 <= mod <= 10^9` (if provided) - `strategy` should be either \'iterative\' or \'recursive\' Performance Requirements - The solution must efficiently handle large values of `n` and provide results using modular arithmetic to avoid overflow issues. Example Usage 1. `extended_factorial(5)` should return `120` 2. `extended_factorial(5, 3)` should return `0` (as 120 % 3 = 0) 3. `extended_factorial(5, strategy=\'recursive\')` should return `120` 4. `extended_factorial(5, 7, \'recursive\')` should return `1` (as 120 % 7 = 1)","solution":"def extended_factorial(n, mod=None, strategy=\'iterative\'): Compute the factorial of a non-negative integer n optionally modulo mod using the specified strategy. Parameters: n (int): A non-negative integer whose factorial is to be computed. mod (int, optional): A positive integer for modulo operation. Defaults to None. strategy (str, optional): A string specifying the strategy to use, \'iterative\' or \'recursive\'. Defaults to \'iterative\'. Returns: int: The factorial of n, optionally modulo mod. Raises: ValueError: If n is not a non-negative integer or if mod is not a positive integer (when provided). ValueError: If strategy is not \'iterative\' or \'recursive\'. if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer\\") if strategy not in [\'iterative\', \'recursive\']: raise ValueError(\\"strategy must be \'iterative\' or \'recursive\'\\") if strategy == \'iterative\': return factorial_iterative(n, mod) elif strategy == \'recursive\': return factorial_recursive(n, mod) def factorial_iterative(n, mod): result = 1 for i in range(2, n+1): result *= i if mod: result %= mod return result def factorial_recursive(n, mod, intermediate_result=1): if n == 0 or n == 1: return intermediate_result if mod: intermediate_result = (intermediate_result * n) % mod else: intermediate_result *= n return factorial_recursive(n-1, mod, intermediate_result)"},{"question":"Interpolation Search Extension You are given a sorted array `array` of integers and a list `search_keys` containing multiple search keys. Implement a function `batch_interpolation_search` that searches for each key in `search_keys` within the `array` using the Interpolation Search algorithm. Your function should return a list of integers, where each integer corresponds to the index of the search key in the array if found, or `-1` if the search key is not found. Function Signature ```python from typing import List def batch_interpolation_search(array: List[int], search_keys: List[int]) -> List[int]: pass ``` Input Format - `array`: a sorted list of integers (e.g., `[-25, -12, -1, 10, 12, 15, 20, 41, 55]`) - `search_keys`: a list of integers to search in the array (e.g., `[-1, 55, -5]`) Output Format - A list of integers representing the indices of the search keys in the array or `-1` for each search key not found. Constraints - All elements in `array` are unique. - The array will contain at least 1 element and at most (10^5) elements. - The search_keys list will contain at most (10^5) elements. - The elements in the array and search_keys will be in the range (-10^6) to (10^6). Example ```python array = [-25, -12, -1, 10, 12, 15, 20, 41, 55] search_keys = [-1, 55, -5] print(batch_interpolation_search(array, search_keys)) # Output: [2, 8, -1] ``` Performance Requirements - Ensure your function runs efficiently for up to (10^5) elements.","solution":"from typing import List def interpolation_search(array: List[int], key: int) -> int: Perform an interpolation search for a given key in the array. Parameters: array (List[int]): A sorted list of unique integers. key (int): The integer value to search in the array. Returns: int: The index of the key in the array if found, otherwise -1. low, high = 0, len(array) - 1 while low <= high and key >= array[low] and key <= array[high]: if low == high: if array[low] == key: return low return -1 pos = low + ((key - array[low]) * (high - low) // (array[high] - array[low])) if array[pos] == key: return pos if array[pos] < key: low = pos + 1 else: high = pos - 1 return -1 def batch_interpolation_search(array: List[int], search_keys: List[int]) -> List[int]: Perform a batch interpolation search for multiple keys in the array. Parameters: array (List[int]): A sorted list of unique integers. search_keys (List[int]): A list of integers to search in the array. Returns: List[int]: A list of integers representing the indices of the search keys in the array or -1 for each search key not found. result = [] for key in search_keys: result.append(interpolation_search(array, key)) return result"},{"question":"# Bit Manipulation Challenge Scenario Imagine you are developing a system that performs low-level integer manipulations. As part of this project, you need to work with binary representations of integers extensively, ensuring specific bits can be read, set, cleared, or updated efficiently. Task Implement a function `manipulate_bits` that takes an integer `num` and a list of operations to perform on its bits. Each operation will be a tuple where the first element is a string indicating the operation (\'get\', \'set\', \'clear\', \'update\') and subsequent elements are the required parameters (e.g., index for \'get\', \'set\', \'clear\', and index plus bit value for \'update\'). Function Signature ```python def manipulate_bits(num: int, operations: List[Tuple[str, int, Optional[int]]]) -> List[Union[int, None]]: ``` Input - `num` (int): The integer on which to perform bitwise operations. - `operations` (List[Tuple[str, int, Optional[int]]]): A list of operations. Each operation is a tuple: - \'get\' operation: (\'get\', i) -> returns the value of the bit at index `i`. - \'set\' operation: (\'set\', i) -> sets the bit at index `i` to 1. - \'clear\' operation: (\'clear\', i) -> clears the bit at index `i` (sets to 0). - \'update\' operation: (\'update\', i, bit) -> sets the bit at index `i` to `bit` (0 or 1). Output - List[Union[int, None]]: - Each \'get\' operation returns an integer (0 or 1). - All other operations return `None`. Constraints - 0 ≤ num < 2^31 - 0 ≤ i < 31 - `bit` for \'update\' operation is always either 0 or 1. Example ```python operations = [(\'get\', 1), (\'set\', 1), (\'get\', 1), (\'clear\', 1), (\'get\', 1), (\'update\', 3, 1), (\'get\', 3)] num = 8 # binary: 1000 print(manipulate_bits(num, operations)) # Output: [0, None, 1, None, 0, None, 1] ``` Notes - Assume valid inputs as specified above. - Do not print anything; just return the list of results.","solution":"from typing import List, Tuple, Optional, Union def manipulate_bits(num: int, operations: List[Tuple[str, int, Optional[int]]]) -> List[Union[int, None]]: results = [] for operation in operations: if operation[0] == \'get\': index = operation[1] bit_val = (num >> index) & 1 results.append(bit_val) elif operation[0] == \'set\': index = operation[1] num |= (1 << index) results.append(None) elif operation[0] == \'clear\': index = operation[1] num &= ~(1 << index) results.append(None) elif operation[0] == \'update\': index = operation[1] bit_val = operation[2] if bit_val: num |= (1 << index) else: num &= ~(1 << index) results.append(None) return results"},{"question":"# Scenario You work as a software engineer for a company that ensures secure communication between its clients. To achieve robust security, you are tasked with implementing a basic version of an RSA encryption algorithm provided to you in pseudocode. You\'ve decided to complete the RSA key generation, encryption, and decryption features as part of your implementation. # Task Implement an RSA encryption and decryption system in Python. Your system should be capable of generating public and private keys of specified bit-lengths, encrypting plaintext messages with public keys, and decrypting ciphertext messages with private keys. # Function Specifications You need to implement the following functions: 1. **generate_key(k: int, seed: int = None) -> (int, int, int)** - Generates an RSA key with a modulus of bit-length `k`. - Parameters: - `k`: Bit-length of the RSA modulus `n`. - `seed`: Optional parameter to seed the random number generator. - Returns: A tuple with the three integers `(n, e, d)` which are the modulus, the encryption exponent, and the decryption exponent. 2. **encrypt(data: int, e: int, n: int) -> int** - Encrypts an integer message using the public key components. - Parameters: - `data`: The plaintext integer message to encrypt. - `e`: The encryption exponent. - `n`: The modulus. - Returns: The encrypted message as an integer. 3. **decrypt(data: int, d: int, n: int) -> int** - Decrypts an integer message using the private key components. - Parameters: - `data`: The ciphertext integer message to decrypt. - `d`: The decryption exponent. - `n`: The modulus. - Returns: The decrypted message as an integer. # Requirements and Constraints 1. The bit-length of the modulus `k` must be at least 16 bits. 2. Ensure that the generated primes `p` and `q` are appropriately random. 3. Handle edge cases such as invalid inputs gracefully. 4. The encryption and decryption functions must handle arbitrary large integers. # Example ```python # Generate RSA keys n, e, d = generate_key(16) # Encrypt and Decrypt a message data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) print(\\"Original:\\", data) print(\\"Encrypted:\\", encrypted) print(\\"Decrypted:\\", decrypted) # Output should be: # Original: 20 # Encrypted: <some integer> # Decrypted: 20 ``` Note: Ensure that your code is efficient and avoids unnecessary computations, particularly in the prime generation and modular inverse calculations.","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(bits): Generates an odd integer randomly. p = random.getrandbits(bits) # Apply a mask to set MSB and LSB to 1 to ensure proper bit length. p |= (1 << bits - 1) | 1 return p def generate_prime(bits): Generate a prime number of \'bits\' bit length. p = generate_prime_candidate(bits) while not isprime(p): p = generate_prime_candidate(bits) return p def generate_key(k, seed=None): if k < 16: raise ValueError(\\"Bit-length of the modulus \'k\' must be at least 16 bits.\\") if seed is not None: random.seed(seed) # Generate two distinct primes p and q p = generate_prime(k // 2) q = generate_prime(k // 2) while p == q: q = generate_prime(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Common choice for e d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): if data < 0 or data >= n: raise ValueError(\\"The data must be a non-negative integer less than n.\\") return pow(data, e, n) def decrypt(data, d, n): if data < 0 or data >= n: raise ValueError(\\"The data must be a non-negative integer less than n.\\") return pow(data, d, n)"},{"question":"Question: You have been tasked to write a function that detects cycles in a directed graph. The graph will be represented as an adjacency list, where the keys are node labels and the values are lists of nodes that the key node points to. # Function Signature: ```python def contains_cycle(graph: dict) -> bool: # your code here ``` # Input: - `graph`: A dictionary representing the directed graph, with nodes as keys and lists of nodes as values (adjacency list). # Output: - Returns `True` if the graph contains a cycle, `False` otherwise. # Constraints: - The graph contains no more than 10^3 nodes and 10^4 edges. - Node labels are unique and are strings. - The graph may be disconnected. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } assert contains_cycle(graph) == True graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } assert contains_cycle(graph) == False ``` # Scenario: You are working on a system that visualizes and analyzes dependencies among various software modules. Each software module may depend directly on others, forming a directed graph. To prevent issues of circular dependencies, your task is to determine if the dependency graph (directed graph) contains any cycles, which can cause infinite loops or deadlocks. Your solution should effectively and efficiently detect such cycles.","solution":"def contains_cycle(graph: dict) -> bool: Detects if a directed graph contains any cycles. Parameters: graph (dict): A dictionary representing the directed graph as an adjacency list. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visiting = set() visited = set() for node in graph.keys(): if dfs(node): return True return False"},{"question":"Assessing Understanding of the Dutch National Flag Problem ***Context***: You have been tasked with organizing an array that holds three distinct values (representing the colors red, white, and blue) such that all values of the same type are grouped together. ***Problem Description***: Given an array of integers `nums` where each integer represents a color (0 for red, 1 for white, and 2 for blue), write a function `sort_three_colors(nums: List[int]) -> None` that sorts the array in-place so that the integers of the same color are adjacent and in the order red, white, and blue. # Instructions 1. You are not allowed to use any sorting libraries or built-in sort functions. 2. You should aim for a time complexity of O(n) and space complexity of O(1). # Input - A list `nums` of length `n` containing only the integers `0`, `1`, and `2` in any order. # Output - The function should modify the input list `nums` in-place to achieve the required ordering. # Constraints - `1 <= n <= 300` - `nums[i]` is `0`, `1`, or `2`. # Example ```python >>> nums = [2, 0, 2, 1, 1, 0] >>> sort_three_colors(nums) >>> print(nums) [0, 0, 1, 1, 2, 2] >>> nums = [2, 0, 1] >>> sort_three_colors(nums) >>> print(nums) [0, 1, 2] ``` # Implementation Details - Create three pointers `i`, `j`, and `k` to dynamically track positions for \'0\'s, \'1\'s, and \'2\'s. - Traverse the list and use conditional checks and pointer management to place elements in their correct positions.","solution":"def sort_three_colors(nums): Sort the array so that all 0s are at the beginning, followed by all 1s, then followed by all 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"Context: You are tasked with implementing a portion of a data handling system utilizing B-Trees to ensure efficient data storage and retrieval. Your objective is to complete the implementation of the B-Tree\'s removal functionality, ensuring optimal performance and correctness. Problem Description: Implement the missing methods in the BTree class for deleting keys, specifically the \'_remove_from_nonleaf_node\' and \'_remove_key\' methods, ensuring that all properties of the B-Tree are maintained. # Function Signature: Define your core function signatures as follows: ```python def _remove_key(self, node: Node, key: int) -> bool: pass def _remove_from_nonleaf_node(self, node: Node, key_index: int): pass ``` # Input Format: - **Input to `_remove_key`:** - `node` of type `Node`: The node from which a key is to be removed. - `key` of type `int`: The key to be removed. - **Input to `_remove_from_nonleaf_node`:** - `node` of type `Node`: Non-leaf node where the key removal is initiated. - `key_index` of type `int`: Index of the key to be removed from the non-leaf node. # Output Format: Both methods do not return values. Modify the `BTree` instance and its `Node` objects directly to reflect key removals: - Implement the methods that remove the correct key in accordance with B-Tree properties. - Maintain the structure and ordering requirements inherent to B-Trees. - Ensure all nodes in the modified tree meet the B-tree properties. # Constraints: - Only integer keys are allowed. - Ensure the tree remains balanced post-deletion. - Conduct recursive or iterative operations as needed while maintaining the B-Tree invariants. # Example: ```python tree = BTree(t_val=2) keys = [10, 20, 5, 6, 12, 30, 7, 17] for key in keys: tree.insert_key(key) tree.remove_key(6) tree.traverse_tree() # Expected traversal output: [5, 7, 10, 12, 17, 20, 30] ``` Additional Notes: - You may add helper functions or modify existing functions if necessary to complete this task. - Your solution should handle cases where nodes need to rebalance or merge during key deletions.","solution":"class Node: def __init__(self, t, leaf=False): self.t = t # Minimum degree self.leaf = leaf # True if leaf node self.keys = [] # Keys in this node self.children = [] # Child nodes class BTree: def __init__(self, t): self.root = Node(t, True) self.t = t def traverse_tree(self): return self._traverse(self.root) def _traverse(self, node): nodes = [] for i in range(len(node.keys)): if not node.leaf: nodes.extend(self._traverse(node.children[i])) nodes.append(node.keys[i]) if not node.leaf: nodes.extend(self._traverse(node.children[-1])) return nodes def insert_key(self, key): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = Node(self.t) self.root = temp temp.children.insert(0, root) self._split_child(temp, 0) self._insert_non_full(temp, key) else: self._insert_non_full(root, key) def _split_child(self, parent, i): t = self.t node = parent.children[i] new_node = Node(t, node.leaf) parent.children.insert(i + 1, new_node) parent.keys.insert(i, node.keys[t - 1]) new_node.keys = node.keys[t:(2*t-1)] node.keys = node.keys[0:(t-1)] if not node.leaf: new_node.children = node.children[t:(2*t)] node.children = node.children[0:(t)] def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def remove_key(self, key): self._remove_key(self.root, key) if len(self.root.keys) == 0: if self.root.leaf: self.root = Node(self.t, True) # Empty tree case else: self.root = self.root.children[0] def _remove_key(self, node, key): t = self.t idx = self._find_key(node, key) if idx < len(node.keys) and node.keys[idx] == key: if node.leaf: node.keys.pop(idx) else: self._remove_from_nonleaf_node(node, idx) else: if node.leaf: return flag = (idx == len(node.keys)) if len(node.children[idx].keys) < t: self._fill(node, idx) if flag and idx > len(node.keys): self._remove_key(node.children[idx - 1], key) else: self._remove_key(node.children[idx], key) def _remove_from_nonleaf_node(self, node, idx): t = self.t key = node.keys[idx] if len(node.children[idx].keys) >= t: pred_key = self._get_pred(node, idx) node.keys[idx] = pred_key self._remove_key(node.children[idx], pred_key) elif len(node.children[idx + 1].keys) >= t: succ_key = self._get_succ(node, idx) node.keys[idx] = succ_key self._remove_key(node.children[idx + 1], succ_key) else: self._merge(node, idx) self._remove_key(node.children[idx], key) def _find_key(self, node, key): idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 return idx def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop(-1)) node.keys[idx - 1] = sibling.keys.pop(-1) def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): t = self.t child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(idx + 1) node.keys.pop(idx) def _get_pred(self, node, idx): cur = node.children[idx] while not cur.leaf: cur = cur.children[-1] return cur.keys[-1] def _get_succ(self, node, idx): cur = node.children[idx + 1] while not cur.leaf: cur = cur.children[0] return cur.keys[0]"},{"question":"# Trie Implementation Challenge **Objective**: Implement the Trie data structure with efficient add, search, and prefix search functionalities. Function Signatures ```python class TrieNode: def __init__(self): pass class Trie: def __init__(self): pass def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass ``` Requirements 1. **Insert**: Create a new Trie node for each character in the word if it doesn\'t exist. Mark the end node as a word. 2. **Search**: Returns `True` if the word is found in the Trie, otherwise returns `False`. 3. **startsWith**: Returns `True` if there is any word in the Trie that starts with the given prefix, otherwise returns `False`. You are required to implement the class methods to: 1. Insert words efficiently. 2. Search for whole words. 3. Search for prefixes. Input & Output - `insert(word: str) -> None`: Takes a string `word` to insert into the Trie. - `search(word: str) -> bool`: Takes a string `word` and returns `True` if the word is in the Trie, `False` otherwise. - `starts_with(prefix: str) -> bool`: Takes a string `prefix` and returns `True` if there is any word in the Trie that starts with that prefix, `False` otherwise. Constraints - All inputs consist of lowercase English letters `a-z`. - You may assume that no input word is empty. Example ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns False print(trie.starts_with(\\"app\\")) # Returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Returns True ``` Performance Your implementation should handle insert and search operations efficiently, with expected time complexities of O(m) per operation, where m is the length of the word or prefix.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for ch in word: if ch not in node.children: node.children[ch] = TrieNode() node = node.children[ch] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for ch in word: if ch not in node.children: return False node = node.children[ch] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for ch in prefix: if ch not in node.children: return False node = node.children[ch] return True"},{"question":"Scenario: You are working for a software company that deals with hierarchical organizational data. Your task is to implement a function that prints the hierarchical structure of employees in a clear format. Each employee may have several sub-elements representing their direct reports or the departments they manage. Given a nested dictionary representing the hierarchical structure, you need to implement a function `pretty_print_tree(tree: dict)` that prints the structure in a human-readable format. Function Signature: ```python def pretty_print_tree(tree: dict) -> None: ``` Input: - A dictionary `tree` where each key is a string (an employee name) and its value is a list of sub-elements. Each sub-element can be a string, integer, or another dictionary. Output: - The function should print the hierarchical structure of the tree to the console. Constraints: - The tree will have at most 1000 elements. - Strings in the tree will have a maximum length of 50 characters. - Tree depth will be no deeper than 10 levels. Example: ```python tree = { \\"Adam\\": [\\"Book\\", \\"Computer\\", {\\"Bill\\": [\\"TV\\"]}], \\"Bill\\": [\\"Computer\\", \\"TV\\"], \\"Jill\\": [\\"Sports\\"], \\"Quin\\": [\\"Book\\", {\\"TV\\": [\\"Sports\\"]}] } pretty_print_tree(tree) ``` Expected Output: ``` Adam -> Book -> Computer -> Bill -> TV Bill -> Computer -> TV Jill -> Sports Quin -> Book -> TV -> Sports ``` Requirements: - Handle varying depths of nested elements. - Maintain a clear and consistent indentation for each level of the hierarchy. - Handle edge cases like empty dictionaries. Notes: - Ensure that the function does not crash for unexpected input types. - Optimize the function for efficiency, considering both time and space complexity.","solution":"def pretty_print_tree(tree, indent=0): Prints the hierarchical structure of the tree in a human-readable format. for key, value in tree.items(): print(\\" \\" * indent + str(key)) if isinstance(value, list): for item in value: if isinstance(item, dict): pretty_print_tree(item, indent + 4) else: print(\\" \\" * (indent + 4) + str(item))"},{"question":"You\'ve been given the task to create a function for a file system manager which needs to parse and robustly handle various file paths and URLs. Your function should not only split these paths into directory and file parts but also handle edge cases gracefully. Task: Write a Python function `robust_split(path: str) -> List[str]` that takes a string representing a file path or URL and returns a list of two elements: 1. The directory path (or domain and directory in case of a URL). 2. The file name. The function should handle the following: 1. Paths ending with a `/`. 2. Paths containing consecutive slashes. 3. Paths with no slashes. The use of `os` library\'s `rpartition` method is restricted. Instead, perform the splitting using basic string operations. Input: * `path` (str): A non-empty string representing the file path or URL (e.g., \\"https://example.com/dir/subdir/file.txt\\" or \\"dir/subdir/file.txt\\"). Output: * Returns a list of two strings: * The directory path or domain/directory. * The file name. Constraints: * Assume that all inputs are valid strings. * The function must return both directory and file parts even if one of them is empty. Example: ```python assert robust_split(\\"https://algorithms/unix/test.py\\") == [\\"https://algorithms/unix\\", \\"test.py\\"] assert robust_split(\\"algorithms/unix/test.py\\") == [\\"algorithms/unix\\", \\"test.py\\"] assert robust_split(\\"file.py\\") == [\\"\\", \\"file.py\\"] assert robust_split(\\"algorithms/unix/\\") == [\\"algorithms/unix\\", \\"\\"] assert robust_split(\\"algorithms//unix/test.py\\") == [\\"algorithms//unix\\", \\"test.py\\"] ``` Write your function below: ```python def robust_split(path): # Your implementation here ```","solution":"def robust_split(path): Splits the given file path or URL into directory and file parts. if not path: return [\'\', \'\'] # Remove trailing slash if exists if path.endswith(\'/\'): return [path.rstrip(\'/\'), \'\'] # Handle consecutive slashes parts = path.split(\'/\') file_part = parts.pop() # The file name dir_part = \'/\'.join(parts) # The remaining directory part return [dir_part, file_part]"},{"question":"Scenario You are developing a URL management tool that needs to clean URLs by removing duplicate query string parameters and optionally any unwanted parameters provided by the user. Task Write a function `clean_url(url: str, params_to_remove: list = []) -> str` that takes a URL as a string and an optional list of query parameters to remove. The function should return the cleaned URL with all duplicates removed and specified parameters excluded. Input and Output - **Input**: - `url` (str): The URL string that needs cleaning. - `params_to_remove` (list): List of parameter keys to remove from the URL. - **Output**: - (str): The cleaned URL. Constraints - All relevant portions of the URL must be preserved (protocol, domain, path, etc, except for the query parameters to be cleaned). - Only the first occurrence of any duplicate query parameter should be kept. - Implement the solution with a time complexity of O(n) and space complexity of O(n). Examples: 1. `clean_url(\\"www.example.com?a=1&b=2&a=2\\")` should return `\\"www.example.com?a=1&b=2\\"` 2. `clean_url(\\"www.example.com?a=1&b=2&c=3\\", [\\"a\\", \\"b\\"])` should return `\\"www.example.com?c=3\\"` 3. `clean_url(\\"www.example.com?a=1&b=2&b=3&a=5\\", [\\"a\\"])` should return `\\"www.example.com?b=2\\"` 4. `clean_url(\\"www.example.com\\")` should return `\\"www.example.com\\"` Notes: - Handle edge cases where the URL may not contain any query parameters. - Ensure your function handles empty `params_to_remove` gracefully.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def clean_url(url: str, params_to_remove: list = []) -> str: Cleans the URL by removing duplicate query parameters and unwanted parameters. Args: - url (str): The URL string to be cleaned. - params_to_remove (list): List of parameter keys to remove from the URL. Returns: - str: The cleaned URL. # Parse the URL parsed_url = urlparse(url) # Parse the query string into a list of (key, value) pairs query_params = parse_qsl(parsed_url.query) # Use an OrderedDict to maintain the insertion order and deduplicate parameters unique_params = {} for key, value in query_params: if key not in unique_params and key not in params_to_remove: unique_params[key] = value # Construct the cleaned query string cleaned_query = urlencode(unique_params) # Reconstruct the full URL with the cleaned query string cleaned_url = urlunparse(( parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params, cleaned_query, parsed_url.fragment )) return cleaned_url"},{"question":"# Jump Search Implementation Challenge Scenario: You are tasked with designing a search functionality for a large database that stores sorted records. To ensure efficient search operations, you need to implement the Jump Search algorithm. This algorithm will help reduce the time complexity compared to a simple linear search, especially on very large datasets. Problem Statement: Write a function `jump_search` that takes a sorted list `arr` and an integer `target` as inputs, and returns the index of `target` in `arr` if it is present, or -1 otherwise. Function Signature: ```python def jump_search(arr: List[int], target: int) -> int: ``` Input: * `arr` (List[int]): A list of integers sorted in ascending order. * `target` (int): The integer value to search for in `arr`. Output: * Returns the index of `target` if it is found within `arr`, otherwise returns -1. Example: ```python arr = [1, 3, 4, 5, 7, 9, 12, 15, 18, 20] target = 9 result = jump_search(arr, target) print(result) # Output: 5 target = 6 result = jump_search(arr, target) print(result) # Output: -1 ``` Constraints: * The list `arr` will have at most 10^6 elements. * Each element in `arr` will be an integer within the range [-10^9, 10^9]. * The list `arr` is guaranteed to be sorted in ascending order. * Try to optimize the performance of your implementation. Points to Consider: * Handle edge cases like an empty list, or the target value being at the start or near the end of the list. * Ensure that your implementation efficiently handles large inputs within the given constraints. Good luck and happy coding!","solution":"import math from typing import List def jump_search(arr: List[int], target: int) -> int: Perform a jump search on a sorted array to find the target element. Parameters: arr (List[int]): A sorted list of integers. target (int): The integer to be searched within the array. Returns: int: The index of the target element if found, otherwise -1. n = len(arr) if n == 0: return -1 # Finding the block size to be jumped step = int(math.sqrt(n)) # Finding the block where the element is present prev = 0 while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in block beginning with prev for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"**Context**: You are given the task of designing a network flow system that can handle water distribution in a city. The city has different junctions (nodes) and pipes (edges) with varying capacities. **Problem**: Implement a function to compute the maximum amount of water that can be pushed from the source node to the sink node in the city\'s pipeline system, represented using an adjacency matrix. **Function Signature**: ```python def compute_maximum_water_flow(adj_matrix: List[List[int]]) -> int: pass ``` # Input * `adj_matrix` (List of List of int): A 2D list representing the capacities of the pipes between junctions. `adj_matrix[i][j]` represents the capacity from junction `i` to junction `j`. It is guaranteed that the matrix is non-negative and `adj_matrix[i][j]` = 0 means no direct pipe exists between these junctions. # Output * `int`: The maximum amount of water flow from the source node (index 0) to the sink node (last index). # Constraints * The number of junctions (nodes) will be between 2 and 100. * The capacities will be non-negative integers between 0 and 10,000. # Example ```python # Example adjacency matrix adj_matrix = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] # Expected output: 23 print(compute_maximum_water_flow(adj_matrix)) ``` # Notes 1. Use the Breadth-First Search (BFS) method to find augmenting paths in the network. 2. Adjust the capacities along each found path and keep accumulating the flow until no more augmenting paths exist. 3. Aim to write clean, efficient, and well-documented code.","solution":"from collections import deque from typing import List def bfs(residual_graph, source, sink, parent): visited = [False] * len(residual_graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for ind, val in enumerate(residual_graph[u]): if not visited[ind] and val > 0: queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: return True return False def compute_maximum_water_flow(adj_matrix: List[List[int]]) -> int: source = 0 sink = len(adj_matrix) - 1 residual_graph = [list(row) for row in adj_matrix] parent = [-1] * len(adj_matrix) max_flow = 0 while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] return max_flow"},{"question":"# Question: Implement Custom Power Function with Modulo You are hired by a company developing a new cryptographic software. The developers need an efficient implementation to compute large powers of integers for their encryption tasks, specifically requiring modular exponentiation. To ensure optimal performance, the iterative approach should be used. Problem Statement Write a function `custom_power(a: int, n: int, mod: int = None) -> int` that computes (a^n) using the binary exponentiation algorithm. If `mod` is provided, the function should return the result modulo `mod`. Input Format - `a` (1 <= a <= 10^9): The base integer. - `n` (0 <= n <= 10^9): The exponent integer. - `mod` (Optional, 1 <= mod <= 10^9): The modulo value. Output Format - Return an integer representing (a^n). - If `mod` is specified, return (a^n mod text{mod}). Constraints - The solution must have a time complexity of O(log n). - The solution must have a space complexity of O(1). Examples 1. `custom_power(2, 10)` returns `1024` 2. `custom_power(2, 10, 1000)` returns `24` Notes - Ensure edge cases are handled, especially (n = 0) which should return 1. - If `mod` is specified, ensure calculations do not result in overflow. ```python def custom_power(a: int, n: int, mod: int = None) -> int: # Your code here pass # Example Usage print(custom_power(2, 10)) # Output: 1024 print(custom_power(2, 10, 1000)) # Output: 24 ``` Additional Information - Do not use the built-in pow() function or the ** operator. - Pay special attention to modular arithmetic to avoid overflow issues.","solution":"def custom_power(a: int, n: int, mod: int = None) -> int: Calculate a^n using binary exponentiation. If mod is specified, return (a^n) % mod. result = 1 base = a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result % mod if mod else result # Example Usage # print(custom_power(2, 10)) # Output: 1024 # print(custom_power(2, 10, 1000)) # Output: 24"},{"question":"# Question: String List Encoder/Decoder You are tasked with implementing an encoder and a decoder for transmitting a list of strings over a network. The encoding mechanism should convert a list of strings to a single string, and the decoding mechanism should convert this single string back to the original list of strings. Implement the following two functions: 1. `encode(strs: List[str]) -> str` - This function encodes a list of strings to a single string. - **Input**: A list of strings (`strs`), where `strs` is a list of length `n` with each `str` possibly empty. - **Output**: A single encoded string that can be decoded back to the original list of strings. 2. `decode(s: str) -> List[str]` - This function decodes a single encoded string back to a list of strings. - **Input**: A single encoded string (`s`). - **Output**: The original list of strings. # Example: ```python # Example 1: # Original list of strings strs = [\\"apple\\", \\"banana\\", \\"cherry\\"] # Encode the list of strings encoded_string = encode(strs) print(encoded_string) # Example output: \\"5:apple6:banana6:cherry\\" # Decode the string back to list of strings decoded_list = decode(encoded_string) print(decoded_list) # Example output: [\\"apple\\", \\"banana\\", \\"cherry\\"] # Example 2: # Original list of strings strs = [\\"\\", \\"foo\\", \\"bar\\"] # Encode the list of strings encoded_string = encode(strs) print(encoded_string) # Example output: \\"0:3:foo3:bar\\" # Decode the string back to list of strings decoded_list = decode(encoded_string) print(decoded_list) # Example output: [\\"\\", \\"foo\\", \\"bar\\"] ``` # Constraints: - The length of each string in `strs` is at most 10^4. - The total length of the strings in the input list does not exceed 10^5. Ensure your algorithm is efficient in both time and space complexity to handle the upper constraint.","solution":"from typing import List def encode(strs: List[str]) -> str: encoded_str = \'\' for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s: str) -> List[str]: decoded_list = [] i = 0 while i < len(s): j = i while s[j] != \':\': j += 1 length = int(s[i:j]) decoded_list.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_list"},{"question":"# FizzBuzz Assessment Objective Write a function to generate a list of strings and/or integers based on the classic FizzBuzz algorithm. Your implementation must return the correct results for any valid input, handle edge cases, and avoid excess resource utilization. Ensure your solution is correct, efficient, and follows good coding practices. Requirements 1. **Function Signature**: `def fizz_buzz(N: int) -> List[Union[int, str]]:` 2. **Input**: - `N` (int): a positive integer (1 ≤ N ≤ 10^5). 3. **Output**: - Returns a list of length `N` where elements follow these rules: - \\"Fizz\\" for multiples of 3. - \\"Buzz\\" for multiples of 5. - \\"FizzBuzz\\" for multiples of both 3 and 5. - The number itself if none of the above conditions are met. Constraints - Function must handle `N` up to 100,000 efficiently. - Must include validation for the input `N` to ensure it\'s an integer greater than zero. Example ```python >>> fizz_buzz(15) [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] ``` Additional Notes: - You may divide your code into helper functions as needed. - Critical evaluation of edge cases is encouraged.","solution":"from typing import List, Union def fizz_buzz(N: int) -> List[Union[int, str]]: if not isinstance(N, int) or N <= 0: raise ValueError(\\"N must be a positive integer.\\") result = [] for i in range(1, N + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"# Description You are tasked with implementing a function that calculates the factorial of a non-negative integer. Additionally, you will need to handle modular arithmetic to ensure the result remains manageable. # Requirements: 1. **Function Name**: `calculate_factorial` 2. **Parameters**: - `n`: A non-negative integer representing the number for which the factorial is to be calculated. - `mod`: An optional positive integer for modular arithmetic. 3. **Returns**: The factorial of the number `n`. If `mod` is provided, return the factorial modulo `mod`. # Constraints: - `0 <= n <= 10^6` - If `mod` is provided, `1 <= mod <= 10^9` # Edge Cases to Handle: - `n = 0` should return `1`. - Invalid input (negative integers, non-integer types) should raise a `ValueError`. - Ensure efficiency to handle large values of `n` up to 10^6. # Example Usage: ```python assert calculate_factorial(5) == 120 assert calculate_factorial(5, mod=100) == 20 assert calculate_factorial(0) == 1 assert calculate_factorial(10, mod=1000) == 800 ``` # Task Implement the function `calculate_factorial` to ensure it meets the above specifications.","solution":"def calculate_factorial(n, mod=None): Returns the factorial of a non-negative integer n. If mod is provided, returns the factorial modulo mod. Parameters: - n: A non-negative integer representing the number for which the factorial is to be calculated. - mod: An optional positive integer for modular arithmetic. Returns: - The factorial of n, or the factorial of n modulo mod if mod is provided. Raises: - ValueError: If n is negative or not an integer, or if mod is not a positive integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None: if not isinstance(mod, int) or mod <= 0: raise ValueError(\\"mod must be a positive integer.\\") factorial = 1 for i in range(1, n + 1): factorial *= i if mod is not None: factorial %= mod return factorial"},{"question":"# Matrix Multiplication You are tasked with implementing a function to multiply two matrices and return the resultant matrix. Your function should handle general edge cases associated with matrix multiplication and ensure an optimal approach to large datasets. Implement the function `matrix_multiplication(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]` that performs the following steps: 1. Validate that the matrices can be multiplied (i.e., the number of columns in the first matrix equals the number of rows in the second matrix). 2. Compute the product of the two matrices using an efficient nested loop approach. 3. Return the resultant matrix. # Input/Output Formats * **Input**: * Two matrices in list-of-lists format, where each list represents a row. * **Output**: * The resulting matrix in list-of-lists format. # Constraints * Matrices will contain only integer values. * It is guaranteed that matrices contain at least one element. * you may assume that all rows in a single matrix have the same length. * Do not use any external libraries or advanced built-in functions. # Example ```python # Example 1 multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] output = [ [58, 64], [139, 154] ] assert matrix_multiplication(multiplicand, multiplier) == output # Example 2 multiplicand = [ [1, 4], [2, 5], [3, 6] ] multiplier = [ [7, 8], [9, 10] ] output = [ [43, 48], [59, 66], [75, 84] ] assert matrix_multiplication(multiplicand, multiplier) == output ```","solution":"from typing import List def matrix_multiplication(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: # Validate dimensions for matrix multiplication if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Number of columns in multiplicand must be equal to the number of rows in multiplier.\\") # Initialize the result matrix with zeros result = [[0] * len(multiplier[0]) for _ in range(len(multiplicand))] # Perform matrix multiplication for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"You have been tasked with completing the implementation of the insertion sort algorithm using the provided helper method `search_insert`. The goal is to sort a given list of integers in non-decreasing order efficiently. # Function Signature ```python def insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers, where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9` # Output - Return a sorted list of integers in non-decreasing order. # Constraints - The algorithm should maintain a time complexity of O(n^2) in the worst case, with considerations of the binary search being incorporated. # Example ```python assert insertion_sort([3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] assert insertion_sort([0, -1, 2, -3, 5, 6, -7]) == [-7, -3, -1, 0, 2, 5, 6] assert insertion_sort([10, 20, 30, 10, 5]) == [5, 10, 10, 20, 30] assert insertion_sort([]) == [] assert insertion_sort([10]) == [10] ``` # Detailed Instructions 1. Implement the `insertion_sort` function to sort the array using insertion sort. 2. Utilize the `search_insert` function to find the correct position to insert elements. 3. Ensure that your implementation handles edge cases appropriately, such as inserting at the start or end of the array and managing duplicates. 4. Maintain the constraints on performance and correctness throughout your implementation.","solution":"from typing import List def search_insert(arr: List[int], num: int) -> int: Uses binary search to find the index where \'num\' should be inserted in \'arr\' to maintain sorted order. low, high = 0, len(arr) while low < high: mid = (low + high) // 2 if arr[mid] < num: low = mid + 1 else: high = mid return low def insertion_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using insertion sort and binary search for insertion position. sorted_arr = [] for num in arr: pos = search_insert(sorted_arr, num) sorted_arr.insert(pos, num) return sorted_arr"},{"question":"# Question: Single Occurrence Finder Using Bitwise Operations Given an array of integers where every element appears exactly three times except for one element which appears exactly once, write a function `single_occurrence(nums)` that finds and returns the element that appears only once. Your solution should have a linear runtime complexity and should not use extra memory. Input * `nums` (list of int): The array of integers where every element appears three times except for one. Output * `int`: The single element that appears exactly once. Constraints * The length of the array, `len(nums)`, is greater than 0. * Each element of the array is a 32-bit integer. Performance requirements * Time Complexity: O(n) * Space Complexity: O(1) Example ```python assert single_occurrence([2, 2, 3, 2]) == 3 assert single_occurrence([0, 1, 0, 1, 0, 1, 99]) == 99 assert single_occurrence([30000, 500, 100, 30000, 100, 30000, 100]) == 500 ``` Use bitwise operations to solve the problem. Explain your approach briefly before coding.","solution":"def single_occurrence(nums): Given an array of integers where every element appears exactly three times except for one element which appears exactly once, finds and returns the element that appears only once. ones, twos = 0, 0 for num in nums: # Update `twos` with the value of bits set in `ones` & current `num` twos |= ones & num # Update `ones` with the value of current `num` ones ^= num # Calculate `threes` which has bits that appeared three times threes = ones & twos # Remove the bits from `ones` and `twos` that appeared three times ones &= ~threes twos &= ~threes return ones"},{"question":"# Randomized Set with Minimum Retrieval You are required to extend the functionality of the `RandomizedSet` data structure to also include the ability to retrieve the smallest element currently in the set. All operations, including insert, remove, random_element and the new retrieval operation (`get_min`) should work in average O(1) time complexity. **Function Signature:** ```python class RandomizedSet: def __init__(self): Initializes an empty RandomizedSet pass def insert(self, val: int) -> bool: Inserts a value to the set if not already present. :param val: The value to be inserted. :return: True if the element was inserted, False if it was already present. pass def remove(self, val: int) -> bool: Removes a value from the set if present. :param val: The value to be removed. :return: True if the element was removed, False if it was not present. pass def random_element(self) -> int: Returns a random element from the current set of elements. Each element must have the same probability of being returned. :return: A random element from the set. pass def get_min(self) -> int: Retrieves the smallest element in the set. :return: The smallest element in the set. pass ``` **Constraints:** * Assume all inputs are valid integers. * The maximum number of elements in the set is 10^6. * Values inserted into the set are within the range [-10^6, 10^6]. **Example:** ```python rset = RandomizedSet() assert rset.insert(3) == True assert rset.insert(1) == True assert rset.insert(2) == True assert rset.insert(3) == False assert rset.get_min() == 1 assert rset.remove(1) == True assert rset.get_min() == 2 assert rset.remove(4) == False ``` **Detailed Task:** - Implement the `RandomizedSet` class as described and ensure that all operations (`insert`, `remove`, `random_element`, `get_min`) perform in average O(1) time. - Pay special attention to maintaining the correct minimum element even after insertions and deletions.","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] self.min_val = None def insert(self, val: int) -> bool: if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) if self.min_val is None or val < self.min_val: self.min_val = val return True def remove(self, val: int) -> bool: if val not in self.dict: return False idx, last_element = self.dict[val], self.list[-1] self.list[idx], self.dict[last_element] = last_element, idx self.list.pop() del self.dict[val] if self.min_val == val: self.min_val = min(self.list) if self.list else None return True def random_element(self) -> int: return random.choice(self.list) def get_min(self) -> int: if self.min_val is None: raise ValueError(\\"Set is empty\\") return self.min_val"},{"question":"# Question: Context: You have been hired to work on a project where you are expected to enhance and visualize some classic algorithms. Your first task is related to the Selection Sort algorithm. You need to implement and extend the provided Selection Sort implementation to include a feature that handles various edge cases more efficiently and visualizes the sorting progress. Task: Implement a function named `enhanced_selection_sort` that follows the principles of the Selection Sort algorithm. Your implementation should: 1. Handle edge cases explicitly: * Empty array. * Array with one element. * Array where all elements are the same. 2. Incorporate a flag for simulation that visualizes each iteration of the array sorting process (similar to the initial code snippet). 3. Minimize swaps by only performing a swap when the minimum value selected isn\'t already in its correct position. Signature: ```python def enhanced_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Parameters: * `arr` - A list of integers to be sorted. * `simulation` - A boolean flag that indicates whether to print the progress of the sorting at each iteration. Returns: * The sorted list of integers. Example: ```python # Input arr = [64, 25, 12, 22, 11] simulation = True # Output # Iteration 0 : [64, 25, 12, 22, 11] # Iteration 1 : [11, 25, 12, 22, 64] # Iteration 2 : [11, 12, 25, 22, 64] # Iteration 3 : [11, 12, 22, 25, 64] # Iteration 4 : [11, 12, 22, 25, 64] [11, 12, 22, 25, 64] ``` Constraint: * The input list can contain up to 1000 elements and each element can be any integer value.","solution":"from typing import List def enhanced_selection_sort(arr: List[int], simulation: bool = False) -> List[int]: Implementation of an enhanced selection sort algorithm that handles edge cases explicitly and visualizes sorting progress if the simulation flag is set to True. Parameters: arr (List[int]): A list of integers to be sorted. simulation (bool): A flag to indicate whether to print the progress of sorting. Returns: List[int]: The sorted list of integers. n = len(arr) if n <= 1: return arr for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"Iteration {i} : {arr}\\") return arr"},{"question":"# Problem: Ways to Decode You are provided with an encoded message containing only digits. Each digit maps to a letter (\'A\' to \'Z\') where \'A\' maps to \'1\', \'B\' to \'2\', ..., and \'Z\' to \'26\'. You need to write a function that determines the total number of ways to decode this message. # Function Signature: ```python def num_decodings(s: str) -> int: pass ``` # Input: * **s**: a string containing only digits (0-9). The length of `s` ranges from 1 to 100. # Output: * **int**: the total number of ways to decode the string. # Constraints: * The input string will not be empty. * The input string won’t have leading zeros unless the entire string is exactly \\"0\\". # Examples: 1. Input: s = \\"12\\" Output: 2 Explanation: It could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). 2. Input: s = \\"226\\" Output: 3 Explanation: It could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). 3. Input: s = \\"0\\" Output: 0 Explanation: There\'s no way to decode \'0\'. 4. Input: s = \\"06\\" Output: 0 Explanation: \'06\' cannot be mapped to any characters. # Scenario: Consider a scenario where you need to decode secret messages. For example, someone might have encoded the message to keep information secure. Your task is to accurately decode the given string using the above mapping rules. # Required Knowledge: To solve this problem, you need to understand: * Dynamic programming principles. * String manipulation and validation. Implement the function `num_decodings(s: str) -> int` that effectively counts all possible decodings for an encoded message string.","solution":"def num_decodings(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) # Base cases dp[0] = 1 dp[1] = 1 if s[0] != \'0\' else 0 for i in range(2, n + 1): one_digit = int(s[i - 1:i]) two_digits = int(s[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"Scenario You are developing a text editor with an advanced \\"text expansion\\" feature. The expansion should duplicate words when a certain condition is met. Before implementing this in the editor, you need to prototype the core functionality using a stack-based approach. Problem Statement Given a stack of integers, implement a function `compress_stutter(stack)` that performs a compress stutter operation using one queue as auxiliary storage such that every group of consecutive same integers is replaced by a single integer. For example: - Input stack (from bottom to top): `[4, 4, 7, 7, 7, 2, 2, 10, 10, 10, 10]` - Output stack (from bottom to top): `[4, 7, 2, 10]` This function demonstrates understanding of stack operations and auxiliary storage utilization. Input The function takes the following parameter: - `stack` (list): A list representing a stack of integers (bottom to top). Output The function should return a list representing the final stack (bottom to top). Constraints - The function should perform in `O(n)` time complexity. - The input stack size should not exceed `10^6`. Implementation Details - Use a queue from the `collections` module as auxiliary storage. - Do not use any additional external libraries apart from `collections`. Example ```python from collections import deque def compress_stutter(stack): q = deque() temp_stack = [] if not stack: return stack while stack: top = stack.pop() if not stack or stack[-1] != top: temp_stack.append(top) else: while stack and stack[-1] == top: stack.pop() while temp_stack: stack.append(temp_stack.pop()) return stack # Example Usage input_stack = [4, 4, 7, 7, 7, 2, 2, 10, 10, 10, 10] output_stack = compress_stutter(input_stack) print(output_stack) # Output: [4, 7, 2, 10] ``` Write the `compress_stutter` function based on the provided parameters and expected output.","solution":"from collections import deque def compress_stutter(stack): q = deque() result_stack = [] if not stack: return stack # Traverse the stack from bottom to top while stack: top = stack.pop() if not stack or stack[-1] != top: q.appendleft(top) # store in queue # Rebuild the final stack from queue while q: result_stack.append(q.popleft()) return result_stack"},{"question":"Scenario A library is building a catalog system that needs to sort the books based on their ISBN numbers. The system currently employs a simple but inefficient sorting method. Your task is to implement a more efficient sorting algorithm known as Cocktail Shaker Sort to ensure the book catalog is accurately sorted. Task Write a function, `cocktail_shaker_sort`, that takes a list of integers corresponding to ISBN numbers of books and sorts them in non-decreasing order using the Cocktail Shaker Sort algorithm. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` Input * A list `arr` of integers where `1 <= len(arr) <= 1000` and each integer `0 <= arr[i] <= 10^6` representing ISBN numbers. Output * A list of integers sorted in non-decreasing order. Constraints * The function should handle empty lists and lists with a single element gracefully. * The function should operate in-place, modifying the input list. * The function should minimize swaps to improve performance as much as possible. Example ```python assert cocktail_shaker_sort([3, 6, 2, 9, 1]) == [1, 2, 3, 6, 9] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([7]) == [7] assert cocktail_shaker_sort([1, 2, 2, 3, 3, 6, 6]) == [1, 2, 2, 3, 3, 6, 6] assert cocktail_shaker_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] ``` Notes * Ensure your solution prioritizes clarity and efficiency. * Document any assumptions or special considerations in your code comments.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts the input list of integers in non-decreasing order using the cocktail shaker sort algorithm. :param arr: List of integers, each integer where 0 <= arr[i] <= 10^6 :returns: List of integers sorted in non-decreasing order Notes: - The function operates in-place, modifying the input list. - Handles empty lists and lists with a single element gracefully. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 while start <= end: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break end -= 1 swapped = False for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break start += 1 return arr"},{"question":"You are given a collection of integer elements in an array. Your task is to implement the Pigeonhole Sort to sort this array in ascending order. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr`: A list of integers, where `len(arr) <= 10^5` and `-10^3 <= arr[i] <= 10^3`. # Output - The function should return a list of integers sorted in ascending order. # Constraints - The range of values in the array may vary, but the most efficient use of Pigeonhole Sort is when the possible range (Max-Min) is comparable to the number of elements. # Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4, 6, 8]) == [2, 3, 4, 6, 7, 8, 8] assert pigeonhole_sort([1, -4, 3, 0, 2, -7]) == [-7, -4, 0, 1, 2, 3] ``` # Notes - Handle the edge cases, such as when the array is empty or contains single elements. - Ensure that the solution efficiently handles the expected input size and constraints. - No built-in sorting functions should be used. # Context This assessment is designed to test your understanding of non-comparison-based sorting algorithms. An optimal solution should demonstrate your ability to translate the sorting technique principles into code, while also considering edge cases and performance constraints.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 # Create pigeonholes holes = [0] * size # Populate the pigeonholes for number in arr: holes[number - min_val] += 1 # Create the sorted output sorted_arr = [] for index in range(size): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"Problem: You are given a directed graph with `n` vertices labeled from `0` to `n-1`. Your task is to implement a function `is_path_exists(n, edges, source, target)` that determines if there is a path between the given source and target vertex. Function Signature: ```python def is_path_exists(n: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: ``` Input: * `n` (integer): The number of vertices in the graph (1 ≤ n ≤ 10^5). * `edges` (list of tuples): Each tuple represents a directed edge from node u to node v, where 0 ≤ u, v < n. * `source` (integer): The starting vertex for the search. * `target` (integer): The destination vertex for the search. Output: * Returns `True` if there is a path from `source` to `target`, otherwise returns `False`. Constraints: * The graph may contain cycles. * There can be multiple edges between nodes. * The function should handle large graphs efficiently. * Avoid stack overflow when the graph is large and deeply nested. Example: ```python # Example 1: n = 4 edges = [(0, 1), (1, 2), (2, 3)] source = 0 target = 3 print(is_path_exists(n, edges, source, target)) # True # Example 2: n = 4 edges = [(0, 1), (1, 2), (2, 3)] source = 0 target = 4 print(is_path_exists(n, edges, source, target)) # False ``` Notes: * Carefully manage the visited nodes to avoid infinite loops with cycles. * You may choose to implement an iterative solution using a stack to avoid recursion depth limits.","solution":"from typing import List, Tuple from collections import deque def is_path_exists(n: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: Determines if there is a path between the given source and target vertex. if source == target: return True adjacency_list = [[] for _ in range(n)] for u, v in edges: adjacency_list[u].append(v) visited = [False] * n queue = deque([source]) while queue: node = queue.popleft() if node == target: return True if not visited[node]: visited[node] = True for neighbor in adjacency_list[node]: if not visited[neighbor]: queue.append(neighbor) return False"},{"question":"**Problem Title: Implement an Enhanced Josephus Problem Solver** # Problem Description You are required to implement a function that solves the Josephus problem but in a more efficient way. Given a list of integers representing people sitting in a circular fashion and a skip value, print every k-th member while removing them until all members are exhausted. Your function must handle edge cases efficiently. # Input and Output Expectations * **Input**: * A list of integers `int_list` representing individuals in their seating order. * An integer `skip` which represents the step count after which a member is removed from the circle. Sample Input: ```python int_list = [1, 2, 3, 4, 5, 6, 7, 8, 9] skip = 3 ``` * **Output**: * A list of integers in the order they were removed. Sample Output: ```python [3, 6, 9, 4, 8, 5, 2, 7, 1] ``` # Constraints * The list will have at least one member and at most 10^6 members. * The skip value will be a positive integer. # Performance Requirements Your implementation should be optimized as much as possible for large lists (up to 10^6 members). # Function Signature ```python def enhanced_josephus(int_list: List[int], skip: int) -> List[int]: pass ``` # Notes * You must handle the circular nature of the problem efficiently. * Consider using data structures that provide efficient removal operations to ensure the function runs within reasonable time limits. # Example Scenario Consider a scenario where teachers are sitting in a circle during a meeting. Every 3rd teacher gets a chance to speak and then they leave the circle until all have spoken. Your task is to determine the order in which teachers get to speak using the `enhanced_josephus` function.","solution":"from typing import List from collections import deque def enhanced_josephus(int_list: List[int], skip: int) -> List[int]: Solve the Josephus Problem in an efficient manner using a deque. Parameters: int_list (List[int]): List of integers representing people in their seating order. skip (int): An integer representing the step count after which a member is removed from the circle. Returns: List[int]: The order in which people were removed. result = [] q = deque(int_list) while q: q.rotate(-(skip - 1)) # Rotate counter-clockwise by (skip - 1) steps result.append(q.popleft()) # Remove the member and add to the result list return result"},{"question":"Longest Common Subsequence Scenario Imagine that you are developing a diff tool to compare the contents of two files. One aspect of this is to find the longest common subsequence between two lines of text, which will help in determining how similar the two files are. Task Write a function `longest_common_subsequence` that takes two strings containing lowercase English alphabets and returns the length of their longest common subsequence. Function Signature ```python def longest_common_subsequence(s_1: str, s_2: str) -> int: :param s_1: First input string :param s_2: Second input string :return: Length of the Longest Common Subsequence ``` Input * Two strings `s_1` and `s_2` where (1 ≤ len(s_1), len(s_2) ≤ 1000). Output * An integer representing the length of the longest common subsequence. Constraints * The function should perform efficiently with time complexity O(M * N) and space complexity O(M * N). * Consider edge cases such as: * Strings with no characters in common. * Completely identical strings. * One of the strings being empty. Example 1. **Input**: `s_1 = \\"abcdgh\\"`, `s_2 = \\"aedfhr\\"` **Output**: `3` **Explanation**: The longest common subsequence is \\"adh\\" with length 3. 2. **Input**: `s_1 = \\"abc\\"`, `s_2 = \\"abc\\"` **Output**: `3` **Explanation**: The longest common subsequence is \\"abc\\" with length 3. Implement the function in Python, ensuring to handle all specified edge cases effectively and maintaining the constraints.","solution":"def longest_common_subsequence(s_1: str, s_2: str) -> int: Returns the length of the longest common subsequence between s_1 and s_2. m = len(s_1) n = len(s_2) # Create a 2D array to store lengths of LCS dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up for i in range(1, m + 1): for j in range(1, n + 1): if s_1[i - 1] == s_2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Problem Context You are working on a system that uses big-endian arrays of digits to represent non-negative whole numbers. You need to implement a function that adds one to these numbers. As an additional requirement, the function should handle large arrays efficiently and maintain an optimal time complexity. # Functional Requirements Implement a Python function `increment_digit_list(digits)` with the following specification: * **Input**: A list of integers `digits` representing a non-negative number in big-endian order. * **Output**: A list of integers representing the incremented number in the same big-endian order. # Constraints * The input list will only contain digits (0-9). * The number represented does not have any leading zeros, except for the number `0` itself. # Example ```python # Example 1 assert increment_digit_list([1, 2, 3]) == [1, 2, 4] # Example 2 assert increment_digit_list([9, 9, 9]) == [1, 0, 0, 0] # Example 3 assert increment_digit_list([0]) == [1] ``` # Detailed Requirements 1. Start by incrementing the last digit in the array. 2. Propagate any carry produced to the left, iterating through the array. 3. If all digits are `9`, a single `1` is prepended to the result, and all digits turn to `0`.","solution":"def increment_digit_list(digits): Increment a list of digits representing a non-negative number in big-endian order. :param digits: List[int], list of digits representing a number :return: List[int], list of digits representing the incremented number n = len(digits) for i in range(n-1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits return [1] + [0] * n"},{"question":"You are tasked with developing a function to manage a collection of unique integer values using a Binary Search Tree (BST). Implement the core operations of a BST: insertion, deletion, and lookup. Additionally, provide a method to return the values of the BST sorted in ascending order (i.e., an in-order traversal). # Requirements 1. **Insertion**: * Function Signature: `def insert(root: Optional[TreeNode], val: int) -> TreeNode:` * Input: `root` (the root node of the BST, can be `None` for an empty tree), `val` (an integer to insert). * Output: The root of the BST after insertion. 2. **Deletion**: * Function Signature: `def delete(root: Optional[TreeNode], val: int) -> Optional[TreeNode]:` * Input: `root` (the root node of the BST), `val` (an integer to delete). * Output: The root of the BST after deletion. 3. **Lookup**: * Function Signature: `def lookup(root: Optional[TreeNode], val: int) -> bool:` * Input: `root` (the root node of the BST), `val` (an integer to find). * Output: `True` if the value exists in the BST, `False` otherwise. 4. **In-order Traversal**: * Function Signature: `def inorder_traversal(root: Optional[TreeNode]) -> List[int]:` * Input: `root` (the root node of the BST). * Output: A list of integers representing the BST values in ascending order. # Constraints * All integer values are unique. * The `delete` function should handle the case where the value to be deleted does not exist in the tree gracefully. * The BST should remain valid after each operation. # Function Definitions ```python from typing import Optional, List class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert(root: Optional[TreeNode], val: int) -> TreeNode: # Implement insertion here pass def delete(root: Optional[TreeNode], val: int) -> Optional[TreeNode]: # Implement deletion here pass def lookup(root: Optional[TreeNode], val: int) -> bool: # Implement lookup here pass def inorder_traversal(root: Optional[TreeNode]) -> List[int]: # Implement in-order traversal here pass ``` # Example ```python # Initial setup root = None root = insert(root, 5) root = insert(root, 3) root = insert(root, 7) # Lookup print(lookup(root, 3)) # True print(lookup(root, 6)) # False # In-order Traversal print(inorder_traversal(root)) # [3, 5, 7] # Deletion root = delete(root, 3) print(inorder_traversal(root)) # [5, 7] ```","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def insert(root: Optional[TreeNode], val: int) -> TreeNode: if root is None: return TreeNode(val) if val < root.val: root.left = insert(root.left, val) elif val > root.val: root.right = insert(root.right, val) return root def min_value_node(node: TreeNode) -> TreeNode: current = node while current.left: current = current.left return current def delete(root: Optional[TreeNode], val: int) -> Optional[TreeNode]: if root is None: return root if val < root.val: root.left = delete(root.left, val) elif val > root.val: root.right = delete(root.right, val) else: # Node with only one child or no child if root.left is None: return root.right elif root.right is None: return root.left # Node with two children: Get the inorder successor (smallest in the right subtree) temp = min_value_node(root.right) root.val = temp.val root.right = delete(root.right, temp.val) return root def lookup(root: Optional[TreeNode], val: int) -> bool: if root is None: return False if root.val == val: return True elif val < root.val: return lookup(root.left, val) else: return lookup(root.right, val) def inorder_traversal(root: Optional[TreeNode]) -> List[int]: return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else []"},{"question":"# Linked List Partitioning You are given a singly linked list and an integer `x`. Your task is to partition the linked list such that all nodes with values less than `x` come before nodes with values greater than or equal to `x`. The partitioning should maintain the original relative order of the nodes in each partition. # Input * The linked list represented by its head node. * An integer `x`. # Output * The head node of the rearranged linked list. # Function Signature ```python def partition_linked_list(head: Node, x: int) -> Node: pass ``` # Constraints * The linked list contains at most `10^5` nodes. * The value of each node and `x` are integers within the range `[-10^6, 10^6]`. * You may assume that the linked list is non-circular and does not have cycles. # Example Given the linked list, where each node\'s value is shown, and `x = 5`: ``` 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 ``` After partitioning around `5`, the linked list should be rearranged to: ``` 3 -> 2 -> 1 -> 5 -> 8 -> 5 -> 10 ``` # Testing The provided function should implement the reordering and pass the test cases where: * The linked list is empty. * All nodes have values less than `x`. * All nodes have values greater than or equal to `x`. * Various combinations of values with distinct patterns (e.g., alternating less/greater values). # Important Points * Do not create a new list or modify the existing node\'s values. * Ensure you handle edge cases gracefully.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def partition_linked_list(head: Node, x: int) -> Node: less_head = less_tail = Node(0) # Dummy head for list with nodes less than x greater_head = greater_tail = Node(0) # Dummy head for list with nodes greater or equal to x current = head while current: if current.value < x: less_tail.next = current less_tail = less_tail.next else: greater_tail.next = current greater_tail = greater_tail.next current = current.next # Connect the two lists less_tail.next = greater_head.next greater_tail.next = None # End the list return less_head.next"},{"question":"You are given a singly linked list which may contain duplicate elements. Your task is to write a function that removes duplicates from the linked list. You must implement two versions of this function: 1. One that utilizes extra space (such as a hash set). 2. One that does not utilize extra space but has a higher time complexity. **Function Signatures:** ```python def remove_duplicates_with_set(head: \'Node\') -> None: ``` ```python def remove_duplicates_without_set(head: \'Node\') -> None: ``` **Node Class Definition:** ```python class Node(): def __init__(self, val = None): self.val = val self.next = None ``` **Input:** * `head` : A `Node` object representing the head of a linked list. **Output:** * The function should modify the linked list in place and do not return anything. **Constraints:** * You can assume that the list contains at least one node. * The values in the list nodes will be strings. **Performance Requirements:** * For `remove_duplicates_with_set`, the performance should be O(N) in time and O(N) in space. * For `remove_duplicates_without_set`, the performance should be O(N^2) in time and O(1) in space. **Example:** ```python # Constructing the linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates using extra space remove_duplicates_with_set(a1) # Print updated list: A -> B -> C -> D -> F -> G # Reconstructing the same linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Remove duplicates without using extra space remove_duplicates_without_set(a1) # Print updated list: A -> B -> C -> D -> F -> G ``` **Note:** Your implementation should correctly handle edge cases, such as an empty list which can be represented by setting the head node to `None`.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: \'Node\') -> None: if head is None: return seen = set() current = head seen.add(current.val) while current.next is not None: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_duplicates_without_set(head: \'Node\') -> None: if head is None: return current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Segment Tree Range Product Query # Context: You are working on a system to handle efficient range product queries on an array of integers. Given an array of integers, you need to support fast computation of the product of numbers in a specific subrange of the array. # Task: Your task is to implement a Segment Tree that efficiently handles product queries in the given range. # Function Signature: ```python class SegmentTree: def __init__(self, arr): Initialize the Segment Tree with the given array. :param arr: List[int] - The input array of integers pass def product_query(self, L, R): Query the product of the numbers in the range [L, R]. :param L: int - Start index of the range (inclusive) :param R: int - End index of the range (inclusive) :return: int - The product of the numbers in the range pass ``` # Input: - `arr`: A list of integers `arr` (1 ≤ len(arr) ≤ 10^5, -10^4 ≤ arr[i] ≤ 10^4). - `L`, `R`: Start and end indices of the query range (0 ≤ L ≤ R < len(arr)). # Output: - The product of the integers within the range [L, R] of the array, modulo 10^9 + 7 to avoid overflow. # Constraints: - Handle negative numbers in the array. - If the product becomes zero within any range, your final result should be zero (0). # Example: ```python # Example Array: [1, -2, 3, 4, -5] # Initialize your segment tree. segment_tree = SegmentTree([1, -2, 3, 4, -5]) # Sample Query print(segment_tree.product_query(1, 3)) # Output should be -24 ``` # Notes: - Pay attention to edge cases such as querying the full array, single element, or subranges that contain negative numbers or include zero. - Make sure to handle large product values using modular arithmetic to avoid overflow.","solution":"class SegmentTree: MOD = 10**9 + 7 def __init__(self, arr): Initialize the Segment Tree with the given array. :param arr: List[int] - The input array of integers self.n = len(arr) self.tree = [1] * (2 * self.n) # Build the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = (self.tree[2 * i] * self.tree[2 * i + 1]) % self.MOD def product_query(self, L, R): Query the product of the numbers in the range [L, R]. :param L: int - Start index of the range (inclusive) :param R: int - End index of the range (inclusive) :return: int - The product of the numbers in the range L += self.n R += self.n + 1 result = 1 while L < R: if L % 2 == 1: result = (result * self.tree[L]) % self.MOD L += 1 if R % 2 == 1: R -= 1 result = (result * self.tree[R]) % self.MOD L //= 2 R //= 2 return result"},{"question":"Context You have been hired as a software engineer to develop a feature for a word game where players need to find and group all anagrams from a list of words. Your task is to implement the core part of this feature that groups the provided words based on whether they are anagrams. Task Write a function `group_anagrams(words)` that takes a list of strings (`words`) and returns a list of lists, where each sub-list contains words that are anagrams of each other. Each sub-list should be sorted based on the input order. Input - `words` - a list of strings (1 <= len(words) <= 10^4, 1 <= len(words[i]) <= 100) Output - A list of lists, where each list contains strings which are anagrams of each other. Constraints - All strings consist of lowercase English letters. Example ```python words = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] group_anagrams(words) ``` Expected Output ```python [ [\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"] ] ``` # Notes - The order of output in the main list does not matter, but the order within each sublist should follow the input order. - Consider case sensitivity if required, though the problem constraints specify lowercase only. Performance Requirements - Ensure your solution efficiently handles the upper limits of input sizes. Hint - Consider using a dictionary to map sorted versions of the strings to lists of their anagrams.","solution":"def group_anagrams(words): Groups words based on anagrams. Args: words : list of str : List of words to be grouped Returns: list of list of str : List containing groups of anagram words from collections import defaultdict anagram_dict = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values())"},{"question":"# Coding Challenge: Implement a Robust Iterative Square Root Function Context: You are a software engineer tasked with implementing a function to calculate the square root of a given positive integer (N) using an iterative method. The function must ensure the result is within a specified precision (P). This functionality is crucial for scientific computations in your application, where accurate square root values are necessary. Problem Description: Implement a function `robust_square_root(n: int, epsilon: float) -> float` that computes the square root of (n) to within an absolute error of (epsilon). The function must handle edge cases gracefully, including cases where (n) is zero or very large. Input: - (n) (int): A positive integer whose square root needs to be calculated. (1 ≤ (n) ≤ (10^9)) - (epsilon) (float): The precision factor, which is a small positive number (0 < (epsilon) < 1) Output: - A float that is the square root of (n) with an absolute error less than (epsilon). Constraints: - The initial guess should be (n / 2). - The function should raise a `ValueError` for any negative input (n). - The function must work efficiently for large values of (n) up to (10^9). Example: ```python >>> robust_square_root(5, 0.001) 2.236 >>> robust_square_root(100, 0.0001) 10.0000 >>> robust_square_root(0, 0.001) 0.0 >>> robust_square_root(-4, 0.001) ValueError: Input must be a positive integer ``` Notes: - Students should take care of the epsilon convergence and ensure the function does not run into an infinite loop. - They should also aim to handle floating-point arithmetic issues effectively.","solution":"def robust_square_root(n: int, epsilon: float) -> float: if n < 0: raise ValueError(\\"Input must be a positive integer\\") if n == 0: return 0.0 guess = n / 2.0 while abs(guess * guess - n) > epsilon: guess = (guess + n / guess) / 2.0 return guess"},{"question":"# Flatten Nested Arrays Objective Implement a function to flatten a deeply nested array into a single-level array. Problem Description You are given a potentially deeply nested array (i.e., an array that can contain arrays, which in turn can contain other arrays, and so on). Your task is to write a function `flatten_array` that takes this nested array as input and returns a new array with all the values flattened to a single level. Function Signature ```python def flatten_array(input_array: list) -> list: pass ``` Input - A list `input_array` which can contain multiple nested lists of integers. Output - A single-level list containing all the values from `input_array` flattened. Constraints - The input array can be deeply nested. - Elements in the array are integers or lists of integers. - Returned list must maintain the order of items as they appear in the original nested lists. Example ```python assert flatten_array([1, [2, [3, 4], 5], 6, [[7]], 8, [[[[9]]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert flatten_array([[], [[[]]], [[[[]]]]]) == [] assert flatten_array([1, [2, 3], [4, [5, [6, 7], 8]], 9]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` Guidelines - **Performance**: Ensure your solution handles deep nesting efficiently. - **Edge Cases**: Handle cases like empty arrays and arrays with all elements being nested properly. - **Recursion Limit**: Consider the interaction of deeply nested arrays with Python’s recursion limit. Good luck!","solution":"def flatten_array(input_array): def flatten(arr): for item in arr: if isinstance(item, list): yield from flatten(item) else: yield item return list(flatten(input_array))"},{"question":"**New Markov Chain Feature Implementation** You are provided with a basic implementation of a Markov Chain. However, the current implementation does not support absorbing states. An absorbing state is a state that, once entered, cannot be left. # Task Enhance the given Markov Chain implementation to account for absorbing states and provide a mechanic to identify such states. Specifically, write a function `markov_has_absorbing_states(chain)` that returns a boolean indicating whether the provided Markov chain contains any absorbing states. # Function Signature ```python def markov_has_absorbing_states(chain: dict) -> bool: ``` # Input - `chain`: A dictionary representing the Markov chain. The keys are states, and the values are dictionaries describing the transition probabilities to other states. # Output - A boolean indicating whether the Markov chain contains absorbing states. # Constraints - State and probability maps are guaranteed to be valid: probabilities for each state sum up to 1. - The chain may have cycles or dead ends. - Performance should be efficient enough to handle large state maps. # Example ```python chain = { \'A\': {\'A\': 0.1, \'B\': 0.6, \'C\': 0.3}, \'B\': {\'B\': 1.0}, \'C\': {\'A\': 0.7, \'C\': 0.3} } markov_has_absorbing_states(chain) # Returns True, because \'B\' is an absorbing state. chain2 = { \'A\': {\'B\': 0.5, \'C\': 0.5}, \'B\': {\'A\': 0.5, \'C\': 0.5}, \'C\': {\'A\': 0.5, \'B\': 0.5} } markov_has_absorbing_states(chain2) # Returns False, no absorbing state. ``` Perform thorough testing with various edge cases like: - States that lead to each other. - States with no outgoing transitions. Explain your solution, addressing any potential performance concerns and how they are handled.","solution":"def markov_has_absorbing_states(chain: dict) -> bool: Determines if the Markov chain contains any absorbing states. An absorbing state is defined as a state where the transition probability to remain in the state itself is 1. :param chain: A dictionary representing the Markov chain. The keys are states, and the values are dictionaries describing the transition probabilities to other states. :return: True if there is at least one absorbing state, False otherwise for state, transitions in chain.items(): if state in transitions and transitions[state] == 1: return True return False"},{"question":"# Kruskal’s Algorithm for Minimum Spanning Tree Given an undirected, connected, and weighted graph, your task is to find the sum of the weights of the edges in its minimum spanning tree using Kruskal’s algorithm. You will need to implement functions to handle the edge list, apply union-find operations, and determine the MST. Input * The first line contains two integers, `n` (the number of vertices) and `m` (the number of edges). * The next `m` lines each contain three integers, `u`, `v`, and `w`, representing an edge between vertex `u` and vertex `v` with weight `w`. Output * A single integer, the sum of the weights of the edges in the minimum spanning tree. Constraints * `1 <= n <= 1000` * `0 <= m <= 10000` * `1 <= w <= 10000` Example # Input: ``` 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 ``` # Output: ``` 14 ``` # Explanation: The minimum spanning tree includes the edges with weights: 2, 3, 4, and 5 which sums up to 14. Instructions 1. Implement the `Edge` class. 2. Implement the `DisjointSet` class with `find_set` and `merge_set` methods. 3. Implement the `kruskal` function to find the sum of the minimum spanning tree. 4. Write a `main` function to read input, process the graph, and print the MST sum.","solution":"class Edge: def __init__(self, u, v, w): self.u = u self.v = v self.w = w class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find_set(self, u): if self.parent[u] != u: self.parent[u] = self.find_set(self.parent[u]) return self.parent[u] def merge_set(self, u, v): root_u = self.find_set(u) root_v = self.find_set(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal(n, edges): edges.sort(key=lambda edge: edge.w) disjoint_set = DisjointSet(n) mst_weight_sum = 0 edge_count = 0 for edge in edges: if disjoint_set.find_set(edge.u) != disjoint_set.find_set(edge.v): disjoint_set.merge_set(edge.u, edge.v) mst_weight_sum += edge.w edge_count += 1 if edge_count == n - 1: break return mst_weight_sum def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 w = int(data[index + 2]) edges.append(Edge(u, v, w)) index += 3 print(kruskal(n, edges))"},{"question":"You are tasked with implementing a solution to determine the satisfiability of a given 2-CNF formula in conjunctive normal form. Each clause in the formula involves exactly two literals, which could either be a variable or its negation. Your implementation should: 1. Construct the implication graph derived from the formula. 2. Determine if there exists a way to assign True or False values to all variables satisfying all the given clauses. # Function Specification Implement the function `solve_2SAT(formula)` that takes a list of tuples representing the 2-CNF formula and returns a dictionary with variable assignments or `None` if no satisfying assignment exists. Input - `formula`: List of tuples, where each tuple represents a clause with two literals. Each literal is a tuple `(variable, is_neg)` where `variable` is a string and `is_neg` is a boolean indicating if the literal is negated. Output - The function should return a dictionary with variable names as keys and their boolean assignments as values. Return `None` if the formula has no satisfying assignment. Constraints - The number of variables (N) and clauses (M) are such that (1 leq N, M leq 1000). # Example ```python def solve_2SAT(formula): # Your implementation here # Example usage formula = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True))] result = solve_2SAT(formula) if result: for variable, assign in result.items(): print(f\\"{variable}: {assign}\\") else: print(\\"No satisfying assignment exists.\\") ``` # Explanation 1. For the example formula, the `solve_2SAT` function should determine an assignment such as: ``` x: True y: False a: True b: True c: False ``` This assignment satisfies all clauses in the formula. If no such assignment exists, the function should return `None`.","solution":"def solve_2SAT(formula): from collections import defaultdict # Helper function to perform DFS def dfs(graph, node, visited, stack=None): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: dfs(graph, neighbor, visited, stack) if stack is not None: stack.append(node) # Helper function to get the variable name and negation state def get_var(literal): return literal[0], literal[1] # Build the implication graph implication_graph = defaultdict(list) variables = set() for (a, b) in formula: var_a, neg_a = get_var(a) var_b, neg_b = get_var(b) # Add implication (not a -> b) & (not b -> a) implication_graph[(var_a, not neg_a)].append((var_b, neg_b)) implication_graph[(var_b, not neg_b)].append((var_a, neg_a)) variables.add(var_a) variables.add(var_b) # Kosaraju\'s Algorithm to find strongly connected components visited = set() finish_stack = [] # Step 1: Order nodes by finish time in the original graph for var in variables: for state in [True, False]: if (var, state) not in visited: dfs(implication_graph, (var, state), visited, finish_stack) # Step 2: Transpose the graph transposed_graph = defaultdict(list) for node in implication_graph: for neighbor in implication_graph[node]: transposed_graph[neighbor].append(node) # Step 3: Process the nodes in reverse finish time order visited.clear() assignment = {} while finish_stack: node = finish_stack.pop() if node not in visited: scc_stack = [] dfs(transposed_graph, node, visited, scc_stack) # Checking strongly connected components for contradictions scc_set = set(scc_stack) for (var, state) in scc_set: if (var, not state) in scc_set: return None # Unsatisfiable if var not in assignment: assignment[var] = not state return assignment"},{"question":"You are given a list of integers and a number (N). You need to create a new list that contains each number from the original list at most (N) times, while preserving the order of their first occurrences. Write a function `delete_nth(array, n)` that takes as input: - `array`: List[int] - a list of integers. - `n`: int - a threshold count. The function should output a list that conforms to the constraints mentioned above. # Input - `array`: List[int], where (1 leq len(array) leq 10^5) - `n`: int, where (1 leq n leq 10^3) # Output - List[int] that contains elements from the original list, respecting the maximum occurrence threshold. # Example ```python >>> delete_nth([1, 2, 3, 1, 2, 1, 2, 3], 2) [1, 2, 3, 1, 2, 3] >>> delete_nth([20, 37, 20, 21], 1) [20, 37, 21] ``` # Constraints - The solution should run in (O(n)) time complexity. - The input list can have both positive and negative numbers, including zero. - Order of the resultant list should be the same as the first appearance order in the input list. # Implementation Note - Utilize a hash table to keep track of the occurrence count of elements. - Iterate once through the list, checking and updating counts as you build the new list. ```python # Your code here def delete_nth(array, n): import collections result = [] counts = collections.defaultdict(int) # Keep track of occurrences for num in array: if counts[num] < n: result.append(num) counts[num] += 1 return result ```","solution":"def delete_nth(array, n): import collections result = [] counts = collections.defaultdict(int) # Keep track of occurrences for num in array: if counts[num] < n: result.append(num) counts[num] += 1 return result"},{"question":"# Polynomial Differentiation You are tasked with implementing a method to symbolically differentiate a given polynomial. Symbolic differentiation involves applying differentiation rules to each monomial term in the polynomial and combining the results. In particular, for a given monomial ( ax^n ), the derivative is ( nax^{n-1} ). Task Implement the method `differentiate` in the class `Polynomial` that returns the derivative of the polynomial as a new `Polynomial` instance. Input The input will be an instance of the `Polynomial` class. Output The output should be a new instance of the `Polynomial` class representing the differentiated polynomial. Method Signature ```python class Polynomial: def differentiate(self) -> Polynomial: # implementation ``` Example 1. **Polynomial**: ( P = 3x^2 + 4x + 1 ) - **Differentiated Polynomial**: ( P\' = 6x + 4 ) 2. **Polynomial**: ( Q = 5x^3 - 2x^2 + 7x - 5 ) - **Differentiated Polynomial**: ( Q\' = 15x^2 - 4x + 7 ) 3. **Polynomial**: ( R = 7 ) - **Differentiated Polynomial**: ( R\' = 0 ) Constraints - The polynomial may contain any number of terms. - Variables in the polynomial are denoted as (x_i) where (i) is the variable\'s index (e.g., (x_1, x_2, ldots)). - Only single-variable differentiation is required (usually with respect to (x_1)). Notes - The polynomial terms are based on the provided `Monomial` and `Polynomial` classes. - Each `Monomial` in the `Polynomial` object may contain multiple variables with respective exponents.","solution":"class Monomial: def __init__(self, coefficient, exponent): self.coefficient = coefficient self.exponent = exponent def differentiate(self): if self.exponent == 0: return Monomial(0, 0) return Monomial(self.coefficient * self.exponent, self.exponent - 1) def __repr__(self): return f\\"{self.coefficient}x^{self.exponent}\\" class Polynomial: def __init__(self, monomials): self.monomials = monomials def differentiate(self): differentiated_monomials = [monomial.differentiate() for monomial in self.monomials] return Polynomial(differentiated_monomials) def __repr__(self): return \\" + \\".join([str(monomial) for monomial in self.monomials])"},{"question":"**Coding Challenge: Efficiently Detecting Prime Numbers** **Scenario**: You are a software engineer working for a company that needs to identify prime numbers for cryptographic applications. Given the impracticality of brute-force checking due to performance constraints, your task is to write an efficient function to determine if a number is prime. **Function Signature**: ```python def is_prime(n: int) -> bool: pass ``` **Input and Output**: - **Input**: An integer ( n geq 0 ). - **Output**: Return a boolean indicating whether the number is prime (`True` for prime, `False` for non-prime). **Constraints**: - For the sake of this challenge, ( n ) can be as large as ( 10^6 ). - Performance: The function should have a worst-case time complexity better than ( O(n) ). **Performance Requirements**: - The function should complete within a reasonable time for large values, fulfilling cryptographic needs, ensuring the use of optimal checking mechanisms. **Hints**: - Consider utilizing mathematical properties and optimizations beyond the basic division method. - Recall that a number cannot be prime if it is divisible by any number up to its square root. **Example**: ```python assert is_prime(11) == True assert is_prime(15) == False assert is_prime(2) == True assert is_prime(1) == False assert is_prime(0) == False ```","solution":"import math def is_prime(n: int) -> bool: Determines if the given integer n is a prime number. Args: n (int): The number to check. Returns: bool: True if n is prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"**Coding Assessment Question** # Context You are tasked with improving an ancient sorting machine lying in the archives of your comp-sci department—an archaic Bogo Sort machine. While it\'s understood that Bogo Sort is impractical for large datasets, your goal is to enhance its efficiency to a degree that it can handle moderately sized lists with better predictability by integrating an improved shuffle method using a \\"guided shuffle\\" technique. # Problem Statement Implement a function `guided_bogo_sort(arr)` that sorts an array with a twist on the traditional Bogo Sort method: 1. Instead of purely random shuffling, introduce a guided shuffle that aims to reduce some level of randomness by leveraging partial order knowledge. 2. The guided shuffle should attempt to maintain already sorted subsequences by swapping only adjacent elements randomly. # Function Signature ```python def guided_bogo_sort(arr: list) -> list: ``` # Input Format - A list of integers `arr` with each element in range: `-10^6 <= arr[i] <= 10^6`. - The number of elements in `arr` is denoted by n where `1 <= n <= 10^2`. # Output Format - Return the sorted version of the input list in ascending order. # Constraints - Do not use built-in sorting functions or libraries. - Attempt to make the guided shuffle more predictable than pure random shuffling. # Performance Requirements - Your function should be optimized in such a way that it handles an array of size up to 100 within an acceptable time frame. # Examples ```python print(guided_bogo_sort([3, 1, 2])) # Output: [1, 2, 3] print(guided_bogo_sort([10, -10, 10])) # Output: [-10, 10, 10] print(guided_bogo_sort([1])) # Output: [1] ``` # Notes - Your algorithm still needs to use randomness for shuffling but in a controlled manner to show improvement over traditional Bogo Sort. - Handle edge cases effectively.","solution":"import random def is_sorted(arr): Checks if the array is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def guided_shuffle(arr): Performs a guided shuffle by randomly swapping adjacent elements. n = len(arr) for i in range(n - 1): if random.random() > 0.5: # 50% chance to swap adjacent elements arr[i], arr[i + 1] = arr[i + 1], arr[i] def guided_bogo_sort(arr): Sorts an array using a guided bogo sort mechanism. while not is_sorted(arr): guided_shuffle(arr) return arr"},{"question":"# Matrix Multiplication with Constraints and Edge Cases Context: Matrix multiplication is a fundamental operation in various fields of computer science and engineering, such as graphics processing, machine learning, and scientific computing. The organizational structure of matrix multiplication often requires handling of edge cases and ensuring efficient computation especially when dealing with large datasets. Problem Statement: Implement a function `matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]` that multiplies two compatible matrices and returns their product. The function should validate the input dimensions and handle edge cases appropriately. Input: * `multiplicand`: A list of lists where each inner list represents a row of the multiplicand matrix. * `multiplier`: A list of lists where each inner list represents a row of the multiplier matrix. Output: * A list of lists representing the product matrix. Constraints: * Assume that the input matrices (multiplicand and multiplier) contain only integers. * The dimensions of input matrices should be such that the number of columns of the multiplicand equals the number of rows of the multiplier. * If the input matrices are not compatible for multiplication, the function should raise a `ValueError` with a suitable error message. * The result matrix should be correctly sized and correctly computed even for boundary cases (e.g., 1x1 matrices, large matrices). Example: ```python matrix_multiply( multiplicand=[[1, 2, 3], [4, 5, 6]], multiplier=[[7, 8], [9, 10], [11, 12]] ) # Should return: # [[58, 64], [139, 154]] ``` Guidelines: * Validate input dimensions and raise `ValueError` if matrices are incompatible. * Provide correct handling for edge cases. * Optimize where possible for performance but keep the algorithm simple and clear. Implement the function `matrix_multiply` according to the described specifications.","solution":"from typing import List def matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: Multiplies two matrices and returns the result. # Validate dimensions if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"The number of columns in the multiplicand must equal the number of rows in the multiplier.\\") # Initialize the result matrix with zeros result_rows = len(multiplicand) result_columns = len(multiplier[0]) result = [[0]*result_columns for _ in range(result_rows)] # Perform matrix multiplication for i in range(result_rows): for j in range(result_columns): for k in range(len(multiplier)): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Shortest Path and Negative Cycle Detection Background You are working with a logistics company that has a network of routes with varying travel costs. Costs can be negative due to discounts or incentives. To optimize route planning, you need to determine the shortest path from a logistics hub to all other locations and check if any route cycle offers an infinite reduction in travel cost. Your task is to implement a function that determines if a shortest path exists from a given source to all vertices. If there\'s a route with a negative-weight cycle reachable from the source, the function should return `False`. Task Write a function `detect_shortest_path(graph, source)` that determines whether a graph contains any negative-weight cycles accessible from the given source vertex. Function Signature ```python def detect_shortest_path(graph, source): Determines if the shortest path exists (returns True) or detects a negative-weight cycle (returns False). Parameters: graph (dict): A dictionary representing the weighted graph. source (str): The source vertex. Returns: bool: True if there is no negative-weight cycle, False otherwise. ``` Input and Output * **Input**: * `graph`: A dictionary where the keys are vertices and the values are dictionaries of adjacent vertices with their corresponding edge weights. * `source`: A string representing the vertex from which to start. Examples Input: ```python graph = { \'a\': {\'b\': 6, \'e\': 7}, \'b\': {\'c\': 5, \'d\': -4, \'e\': 8}, \'c\': {\'b\': -2}, \'d\': {\'a\': 2, \'c\': 7}, \'e\': {\'b\': -3} } source = \'a\' ``` * **Output**: * A boolean indicating whether there is no negative-weight cycle (`True`) or if such a cycle exists (`False`). Example Output: ```python True # indicates there is no negative-weight cycle ``` Constraints 1. The graph can have up to 1000 vertices. 2. Edge weights are integers and can be negative. 3. The source vertex is guaranteed to be in the graph. 4. No self-loops (edges that join a vertex to itself). Performance Ensure that the implemented algorithm maintains an efficiency of O(V * E) time complexity and O(V) space complexity.","solution":"def detect_shortest_path(graph, source): Determines if the shortest path exists (returns True) or detects a negative-weight cycle (returns False). Uses the Bellman-Ford algorithm. Parameters: graph (dict): A dictionary representing the weighted graph. source (str): The source vertex. Returns: bool: True if there is no negative-weight cycle, False otherwise. # Step 1: Initialize the distances distances = {vertex: float(\'inf\') for vertex in graph} distances[source] = 0 # Step 2: Relax edges |V| - 1 times for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distances[u] + graph[u][v] < distances[v]: distances[v] = distances[u] + graph[u][v] # Step 3: Check for negative-weight cycles for u in graph: for v in graph[u]: if distances[u] + graph[u][v] < distances[v]: return False # Negative-weight cycle found return True # No negative-weight cycle found"},{"question":"# Question: Incrementing a Large Number as an Array Given a non-negative number represented as an array of digits, increment the number by one. Write a function `increment_array` that takes a list of integers and returns the list representing the incremented number. Function Signature ```python def increment_array(digits: List[int]) -> List[int]: ``` Input - `digits` (List[int]): A list of integers where each integer is a digit of the number (0 ≤ digit ≤ 9). Output - Returns a list of integers representing the incremented number. Constraints - The list will not contain leading zeroes, except when the list itself is `[0]`. - The function should handle large numbers, so the solution must cater to the limits of typical integer arrays. Examples - `increment_array([1, 2, 3])` -> `[1, 2, 4]` - `increment_array([4, 3, 2, 1])` -> `[4, 3, 2, 2]` - `increment_array([9, 9, 9])` -> `[1, 0, 0, 0]` - `increment_array([0])` -> `[1]` - `increment_array([8, 9, 9, 9])` -> `[9, 0, 0, 0]` Notes 1. Your solution should be efficient in terms of both time and space complexity. 2. Consider edge cases around the handling of cascading carries, especially with sequences of 9s. 3. The function should be free from side effects, not modifying the input array.","solution":"def increment_array(digits): Increment the number represented by the list of digits by one. :param digits: List[int] -- List of integers where each integer is a digit. :return: List[int] -- List of integers representing the incremented number. n = len(digits) carry = 1 # Start with the carry since we are incrementing by one. for i in range(n - 1, -1, -1): new_digit = digits[i] + carry if new_digit == 10: digits[i] = 0 carry = 1 else: digits[i] = new_digit return digits # If carry is still 1, that means we have a new significant digit. return [1] + digits"},{"question":"# Problem Scenario You are tasked with designing a function to compute the number of possible combinations that add up to a given target using a set of positive integers. Each number in the array can be used multiple times in a combination, and the order of numbers matters. # Function Signature ```python def count_combinations(nums: List[int], target: int) -> int: ``` # Input - `nums` : A list of positive integers, all distinct. - `target`: A positive integer representing the target sum. # Output - Returns an integer representing the number of possible combinations that add up to the target. # Constraints * All elements in `nums` are positive integers and unique. * `target` is a positive integer. * The integer values in `nums` will be within the range `[1, 1000]`. * The `target` will be within the range `[1, 1000]`. # Example ```python nums = [1, 2, 3] target = 4 print(count_combinations(nums, target)) # Output: 7 ``` # Explanation There are 7 possible combinations: - (1, 1, 1, 1) - (1, 1, 2) - (1, 2, 1) - (1, 3) - (2, 1, 1) - (2, 2) - (3, 1) # Additional Considerations - Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation should we add to the question to allow negative numbers? # Notes - Consider using both top-down dynamic programming with memoization and bottom-up dynamic programming approaches to find the optimal solution. - Ensure edge cases such as an empty nums list or a zero target are handled gracefully.","solution":"from typing import List def count_combinations(nums: List[int], target: int) -> int: Computes the number of possible combinations that add up to a given target using the given set of positive integers. Each number in the set can be used multiple times and the order of numbers matters. Arguments: nums : List[int] -- A list of positive integers, all distinct. target : int -- A positive integer representing the target sum. Returns: int -- The number of possible combinations. # Create a DP array with (target + 1) elements initialized to 0 dp = [0] * (target + 1) # There\'s one way to make the target 0: use no elements dp[0] = 1 # Traverse each amount from 1 to the target for t in range(1, target + 1): for num in nums: if t >= num: dp[t] += dp[t - num] return dp[target]"},{"question":"# Problem: Optimized Least Common Multiple Calculation with Edge Case Handling You are provided with two functions that compute the greatest common divisor (gcd) using different approaches and a function to compute the least common multiple (lcm) using the gcd. Your task is to optimize and enhance the current implementation of `lcm(a, b)` to handle edge cases and improve its robustness. Your task: 1. Analyze and adapt the `gcd_bit` function to handle more edge cases more gracefully. 2. Optimize the `lcm` function using the improved `gcd_bit`. # Function Specifications gcd_bit Enhanced ```python def gcd_bit_enhanced(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two non-negative integers a and b using bitwise operations. This function should also handle edge cases effectively. Parameters: a (int): First non-negative integer b (int): Second non-negative integer Returns: int: The greatest common divisor of a and b Constraints: - a and b are non-negative integers. - 0 <= a, b <= 10^18 # Your implementation here ``` Optimized LCM ```python def lcm_optimized(a: int, b: int) -> int: Computes the least common multiple (LCM) of two non-negative integers a and b using an enhanced version of the gcd function. Parameters: a (int): First non-negative integer b (int): Second non-negative integer Returns: int: The least common multiple of a and b Constraints: - a and b are non-negative integers. - 1 <= a, b <= 10^18 # Your implementation here ``` # Example ```python print(gcd_bit_enhanced(48, 18)) # Output: 6 print(lcm_optimized(21, 6)) # Output: 42 ``` # Performance Requirements Ensure that: - Your gcd function runs in O(log(min(a, b))) time complexity. - Your lcm function runs efficiently using the enhanced gcd.","solution":"def gcd_bit_enhanced(a, b): Computes the greatest common divisor (GCD) of two non-negative integers a and b using bitwise operations. This function should also handle edge cases effectively. if a == 0: return b if b == 0: return a # Reduce any common factors of 2 shift = 0 while (((a | b) & 1) == 0): a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def lcm_optimized(a, b): Computes the least common multiple (LCM) of two non-negative integers a and b using an enhanced version of the gcd function. if a == 0 or b == 0: return 0 return abs(a // gcd_bit_enhanced(a, b) * b)"},{"question":"**Question**: Implement a function in the Red-Black Tree (RBT) to check if the tree is a valid RBT. **Context**: The provided Red-Black Tree implementation includes functionality for insertion, deletion, and rotations to maintain the tree\'s properties. Your task is to write a function `is_valid_rbt` that verifies whether the tree maintains all the necessary RBT properties at any instance. This function should ensure that the tree\'s properties are always valid after any sequence of operations. # Requirements: - **Input**: Instance of the `RBTree` class. - **Output**: Boolean value (True if the tree is valid, False otherwise). # Constraints: 1. The tree should comply with all RBT properties. 2. The function should efficiently traverse and verify the tree properties. 3. Consider all edge cases where properties might be violated. # Example: Assume an RBT instance `rb_tree` is created and populated using the provided code. Your function `is_valid_rbt(rb_tree)` should return `True` if `rb_tree` maintains all Red-Black properties, otherwise `False`. ```python def is_valid_rbt(tree: RBTree) -> bool: # Your implementation here ``` # Hints: 1. Ensure `root` is always black. 2. Verify there are no consecutive red nodes. 3. Check that all paths from the root to the leaves contain the same number of black nodes (`black-height`). **Note**: The provided implementation does not have a method to check the validity of the Red-Black Tree properties. Your task is to write this verification function from scratch.","solution":"class Node: def __init__(self, value, color): self.value = value self.color = color # \'R\' for red, \'B\' for black self.left = None self.right = None self.parent = None class RBTree: def __init__(self): self.NIL_LEAF = Node(None, \'B\') # Sentinel NIL leaf node self.root = self.NIL_LEAF def is_valid_rbt(self): def check_red_black_properties(node): if node is None or node == self.NIL_LEAF: return 1 # Base case: An empty tree or NIL leaf is a valid RBT with black height 1 if node.color == \'R\': # Red node should not have red children if (node.left and node.left.color == \'R\') or (node.right and node.right.color == \'R\'): return False left_black_height = check_red_black_properties(node.left) right_black_height = check_red_black_properties(node.right) if left_black_height == False or right_black_height == False or left_black_height != right_black_height: return False return left_black_height + (1 if node.color == \'B\' else 0) # Check if the root is black if self.root.color != \'B\': return False # Check recursively if the rest of the tree satisfies red-black properties return check_red_black_properties(self.root) != False"},{"question":"Scenario You are given a list of integers where every element appears twice except for one element which appears exactly once. You need to identify this unique element. Function Definition Write a function `find_unique_number` that takes a list of integers `nums` and returns the single unique integer. If all numbers appear in pairs and there is no such unique number, the function should return 0. Input * A list of integers `nums`, with `1 <= len(nums) <= 10^5` and `-10^6 <= nums[i] <= 10^6`. Output * A single integer representing the unique number if one exists, or 0 if all numbers appear in pairs. Constraints * The function must run in linear time, O(n). * The function must use constant space, O(1). Examples 1. `find_unique_number([2, 2, 1])` should return `1` 2. `find_unique_number([4, 1, 2, 1, 2])` should return `4` 3. `find_unique_number([1])` should return `1` 4. `find_unique_number([])` should return `0` Function Signature ```python def find_unique_number(nums: List[int]) -> int: # Implement your solution here pass ```","solution":"def find_unique_number(nums): Returns the unique number in a list where every element appears twice except for one element which appears exactly once. unique = 0 for num in nums: unique ^= num return unique"},{"question":"# Scenario You are a software engineer tasked with creating a mapping system that can analyze satellite imagery data to detect landmasses. One key functionality is detecting isolated land areas within the imagery, represented as a 2D grid. A \'1\' denotes land, and a \'0\' denotes water. # Task Write a function `detect_islands(grid)` that determines the number of distinct islands in the given 2D grid. # Function Signature ```python def detect_islands(grid: List[List[int]]) -> int: pass ``` # Input * `grid` - A 2D list of integers representing the map, with \'1\' for land and \'0\' for water. The grid dimensions are M x N, where 1 <= M, N <= 300. # Output * Returns an integer representing the number of islands (groups of connected \'1\'s). # Constraints * Islands are connected either horizontally or vertically, but not diagonally. * Assume all edges of the grid are surrounded by water. # Examples ```python assert detect_islands([ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ]) == 1 assert detect_islands([ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ]) == 3 ``` # Performance Requirements * The solution should handle large grids (up to 90,000 elements) efficiently with a time complexity of O(M * N). Use an approach that minimizes space usage, potentially converting the grid in-place. # Notes * An iterative approach using a stack can be implemented as an alternative to recursion to handle high depth scenarios efficiently.","solution":"from typing import List def detect_islands(grid: List[List[int]]) -> int: def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() if 0 <= cx < rows and 0 <= cy < cols and grid[cx][cy] == 1: grid[cx][cy] = 0 # Mark as visited stack.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)]) if not grid: return 0 rows, cols = len(grid), len(grid[0]) island_count = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: dfs(i, j) island_count += 1 return island_count"},{"question":"You are given an `n x n` 2D matrix representing an image. Write a function that rotates the matrix by 90 degrees (clockwise). Your implementation must perform the rotation in-place with O(1) extra space. # Input: * `mat`: A list of lists of integers representing an `n x n` matrix (2 <= n <= 1000). # Output: * The function should modify the `mat` in-place to represent the matrix rotated by 90 degrees clockwise. # Constraints: * The matrix will always be non-empty and square. # Example: ```python mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] rotate(mat) print(mat) # Expected Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` # Function Signature: ```python def rotate(mat: list[list[int]]) -> None: # Your code here ``` Implement the function `rotate`. # Hints: 1. Think about how you can reverse the rows of the matrix. 2. Consider how you can swap the elements symmetrically post-reversal to achieve the desired rotation effect in-place.","solution":"def rotate(mat): Rotates the given n x n matrix by 90 degrees clockwise in place. n = len(mat) # First step: Transpose the matrix for i in range(n): for j in range(i+1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Second step: Reverse each row for i in range(n): mat[i].reverse()"},{"question":"# Background You are running a network splitting task where you need to determine the maximum possible data flow from the source node to the target node in a given network. The network is represented by an n*n adjacency matrix where the entry at row i and column j indicates the capacity from node i to node j. # Problem Statement Write a function `calculate_max_flow(graph: List[List[int]]) -> int` that implements the maximum flow algorithm using Depth-First Search (DFS) to determine the maximum flow from the source node to the sink node. # Function Signature ```python def calculate_max_flow(graph: List[List[int]]) -> int: pass ``` # Input * `graph`: A List of Lists, representing an n*n adjacency matrix of non-negative integers. # Output * An integer representing the maximum flow from the source (0th node) to the sink (n-1 node). # Constraints * The adjacency matrix will have dimensions n*n where 2 <= n <= 100. * All capacities in the graph are between 0 and 1000. # Requirements 1. Use Depth First Search (DFS) for finding paths within the graph. 2. Handle large graphs efficiently within provided constraints. 3. Ensure correctness even with multiple possible routes and varying capacities. # Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert calculate_max_flow(graph) == 23 ``` # Notes - Ensure your code handles edge cases such as disconnected nodes, zero capacity edges, and large graphs efficiently. - Optimize for readability and maintainability, while ensuring the efficiency of the solution.","solution":"from typing import List def calculate_max_flow(graph: List[List[int]]) -> int: def dfs(rGraph, source, sink, parent): visited = [False] * len(rGraph) stack = [source] visited[source] = True while stack: u = stack.pop() for v in range(len(rGraph)): if not visited[v] and rGraph[u][v] > 0: stack.append(v) visited[v] = True parent[v] = u if v == sink: return True return False # Initial values source, sink = 0, len(graph) - 1 rGraph = [row[:] for row in graph] # residual graph parent = [-1] * len(graph) max_flow = 0 # Loop while there is a path from source to sink while dfs(rGraph, source, sink, parent): # Find the maximum flow through the path found. path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, rGraph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] rGraph[u][v] -= path_flow rGraph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"Implement a **Doubly Linked List** with the following operations: 1. **add_node(value)**: Add a node with the specified value at the end of the list. 2. **remove_node(value)**: Remove the first occurrence of a node with the specified value. 3. **find_node(value)**: Return the node with the specified value, or `None` if the node doesn\'t exist. 4. **print_list(forward=True)**: Print the list elements from head to tail if `forward` is `True`; otherwise, print from tail to head. Implementing these functions will test your understanding of linked list operations and your ability to manage node references appropriately. Constraints and Requirements * Assume `value` is always an integer. * Do not use any built-in Python list or related functions for list manipulation. * Maintain proper updates of the node pointers (`next` and `prev`) for the doubly linked list. Input and Output 1. **add_node(value)**: * Input: `int` * Output: None (modifies the list) 2. **remove_node(value)**: * Input: `int` * Output: None (modifies the list) 3. **find_node(value)**: * Input: `int` * Output: `DoublyLinkedListNode` (if found) or `None` (if not found) 4. **print_list(forward=True)**: * Input: `bool` * Output: Prints the list elements Begin your implementation after the given class structure: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_node(self, value): # Your implementation here def remove_node(self, value): # Your implementation here def find_node(self, value): # Your implementation here def print_list(self, forward=True): # Your implementation here ``` Test your implementation with a series of operations to ensure correctness and edge case handling.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_node(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove_node(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def find_node(self, value): current = self.head while current: if current.value == value: return current current = current.next return None def print_list(self, forward=True): if forward: current = self.head while current: print(current.value, end=\\" \\") current = current.next else: current = self.tail while current: print(current.value, end=\\" \\") current = current.prev print()"},{"question":"# Coding Challenge: Determine Isomorphism of Two Strings **Context**: Two strings are considered isomorphic if the characters in the first string (`s`) can be replaced to get the second string (`t`). The mapping should be one-to-one, meaning no two characters from `s` should map to the same character in `t`, while preserving the order of characters. **Objective**: Write a function `is_isomorphic(s: str, t: str) -> bool` to determine if two given strings `s` and `t` are isomorphic. **Input**: - `s`: A string containing only lowercase alphabetical characters (1 <= len(s) <= 1000). - `t`: A string containing only lowercase alphabetical characters (1 <= len(t) <= 1000). **Output**: - Return `True` if the strings are isomorphic, otherwise return `False`. **Examples**: 1. `s = \\"egg\\"`, `t = \\"add\\"` -> Output: `True` 2. `s = \\"foo\\"`, `t = \\"bar\\"` -> Output: `False` 3. `s = \\"paper\\"`, `t = \\"title\\"` -> Output: `True` **Constraints**: - The function should handle strings up to 1000 characters efficiently. - The code should check for all edge cases, such as different string lengths and empty strings. **Note**: - Ensure your solution has a time complexity of (O(n)) and a space complexity of (O(n)), where (n) is the length of the strings. Write your function below: ```python def is_isomorphic(s: str, t: str) -> bool: # Your implementation here ```","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False mapping_s_t = {} mapping_t_s = {} for char_s, char_t in zip(s, t): if char_s not in mapping_s_t: mapping_s_t[char_s] = char_t if char_t not in mapping_t_s: mapping_t_s[char_t] = char_s if mapping_s_t[char_s] != char_t or mapping_t_s[char_t] != char_s: return False return True"},{"question":"# Coding Challenge: Consecutive Powers Sum Property Problem Description Given a range of numbers `[low, high]`, write a function `sum_dig_pow(low, high)` that returns a list of all numbers within this range that satisfy the following property: Each digit `d` of the number when raised to an incremental power starting from 1 (i.e., `d^1`, `d^2`, `d^3`, ..., `d^k` where `k` is the position of the digit) and summed equals the number itself. For example: * The number 89 satisfies this condition because `8^1 + 9^2 = 89`. * The number 135 satisfies this condition because `1^1 + 3^2 + 5^3 = 135`. Function Signature ```python def sum_dig_pow(low: int, high: int) -> list: ``` Input * `low`: An integer, the start of the range (inclusive). * `high`: An integer, the end of the range (inclusive). Output * A list of integers, containing all the numbers in the range `[low, high]` with the described property. Constraints 1. `1 <= low <= high <= 10^6` 2. The range will consist of natural numbers only. Performance Requirements * The function should efficiently handle ranges up to a million elements. Example ```python assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] ```","solution":"def sum_dig_pow(low: int, high: int) -> list: Returns a list of numbers within the range [low, high] that satisfy the given property: each digit d of the number, when raised to the power of its position (starting from 1), sums to the number itself. result = [] for num in range(low, high + 1): str_num = str(num) if num == sum(int(digit) ** (index + 1) for index, digit in enumerate(str_num)): result.append(num) return result"},{"question":"**Question: Optimized Quick Sort with Randomized Pivot** You are tasked with implementing an optimized version of the Quick Sort algorithm. This optimized version must address the performance bottleneck of selecting a bad pivot by using a randomized pivot. Additionally, to minimize the recursion overhead for small sub-arrays, use insertion sort when the size of the sub-array falls below a given threshold. **Function Signature:** ```python def optimized_quick_sort(arr: List[int], threshold: int) -> List[int]: pass ``` **Input:** - `arr`: A list of integers that you need to sort. - `threshold`: An integer indicating the size below which you should switch to insertion sort. **Output:** - A list of integers sorted in ascending order. **Constraints:** - `0 <= len(arr) <= 10^5` - `-10^5 <= arr[i] <= 10^5` - `1 <= threshold <= len(arr)` **Requirements:** - Time complexity should be optimized for average-case performance. - Handle edge cases such as empty arrays, arrays with one element, arrays with all identical elements, and already sorted arrays. - Implement an in-place sort to minimize space usage. **Example Usage:** ```python assert optimized_quick_sort([3, 6, 8, 10, 1, 2, 1], 10) == [1, 1, 2, 3, 6, 8, 10] assert optimized_quick_sort([10], 5) == [10] assert optimized_quick_sort([], 5) == [] ``` **Hint:** - Use the built-in `random` module to select pivots randomly. - Implement an efficient insertion sort for handling small sub-arrays.","solution":"from typing import List import random def insertion_sort(arr: List[int], left: int, right: int) -> None: for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def partition(arr: List[int], low: int, high: int) -> int: pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort(arr: List[int], low: int, high: int, threshold: int) -> None: if high - low + 1 <= threshold: insertion_sort(arr, low, high) elif low < high: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1, threshold) quick_sort(arr, pi + 1, high, threshold) def optimized_quick_sort(arr: List[int], threshold: int) -> List[int]: if arr: quick_sort(arr, 0, len(arr) - 1, threshold) return arr"},{"question":"You are provided with a function that computes the histogram of a list of numerical values. Your task is to extend this implementation to handle non-numerical input lists, align with input constraints, and optimize its performance for large datasets. Task: Implement a function `get_advanced_histogram(input_list: list) -> dict` that computes the histogram of a list of arbitrary hashable types. Additionally: 1. The function should ignore `None` type values in the input list. 2. In case of an empty input list, the function should return an empty dictionary. 3. Optimize the function to handle large lists efficiently. Input: - `input_list`: A list of arbitrary hashable types (integers, strings, tuples, etc.) Output: - A dictionary representing the histogram of the input list. It should ignore `None` values. Constraints: - Elements in `input_list` can be of any hashable type. - The input list can contain up to 1,000,000 elements. Example: ```python input_list = [\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"orange\\", None, \\"banana\\"] # Expected Output: {\\"apple\\": 3, \\"banana\\": 2, \\"orange\\": 1} input_list = [1, (2,3), 3.5, 1, (2,3), None, 1, 3.5] # Expected Output: {1: 3, (2,3): 2, 3.5: 2} input_list = [] # Expected Output: {} ``` Performance Requirements: Your implementation should be efficient and handle the upper limit of input size within a reasonable execution time.","solution":"def get_advanced_histogram(input_list): Computes the histogram of a list of arbitrary hashable types, ignoring `None` values. Args: input_list: List of arbitrary hashable types. Returns: dict: A dictionary representing the histogram of the input list. histogram = {} for item in input_list: if item is not None: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"You are given a singly linked list data structure where some elements may appear more than once. Your task is to implement a function to remove duplicates from the linked list using two different methods: 1. Using an auxiliary data structure. 2. Without using any extra data structure. # Requirements - Implement both `remove_dups` and `remove_dups_without_set` functions. - The function signatures should be: ```python def remove_dups(head: Node) -> None: pass def remove_dups_without_set(head: Node) -> None: pass ``` - A Node is defined as: ```python class Node: def __init__(self, val: Optional[int] = None): self.val = val self.next = None ``` # Example Given the list: A -> A -> B -> C -> D -> C -> F -> G After `remove_dups`: Result: A -> B -> C -> D -> F -> G After `remove_dups_without_set`: Result: A -> B -> C -> D -> F -> G # Constraints - The linked list will contain at most 10^5 nodes. - Node values are integers that can be positive, negative, or zero. # Performance Requirements - The function `remove_dups` should run in O(N) time. - The function `remove_dups_without_set` should be implemented without using extra space beyond the input linked list and should run in O(N^2) time. Ensure your solution considers edge cases such as: - An empty linked list. - A linked list with only one element. - All elements in the linked list being duplicates. # Submission Provide both functions in a single script. Document any edge cases you handle inside the comments.","solution":"class Node: def __init__(self, val: int = None): self.val = val self.next = None def remove_dups(head: Node) -> None: Remove duplicates from a linked list using an auxiliary data structure. if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Remove duplicates from a linked list without using any extra data structure. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"You are assigned to implement a utility function that converts a given file path to a full absolute path, ensuring that any user shortcuts (like “~” for the home directory) are expanded properly. This utility helps in standardizing file paths for file operations in various applications. # Function Specification ```python def get_full_file_path(path: str) -> str: Given a file path string, return the full absolute path. Parameters: path (str): The input file path. Returns: str: The full absolute path. ``` # Input * A string `path` representing the file path which may be relative or contain user directory shortcut. # Output * A string representing the absolute path. # Constraints * The `path` will always be a valid string. * You should handle any valid path string correctly, making no assumptions about whether the file exists. # Example Usage ```python print(get_full_file_path(\\"~/Documents/file.txt\\")) # Should return the absolute path, for instance on a POSIX system: # /home/username/Documents/file.txt print(get_full_file_path(\\"file.txt\\")) # Should return the absolute path of the current directory appended with file.txt: # /current/directory/file.txt ``` # Notes * Only basic string operations and file handling libraries like `os` should be used. * Consider edge cases and ensure that your solution is efficient and concise.","solution":"import os def get_full_file_path(path: str) -> str: Given a file path string, return the full absolute path. Parameters: path (str): The input file path. Returns: str: The full absolute path. return os.path.abspath(os.path.expanduser(path))"},{"question":"You have been given multiple implementations to reverse a string. Now, utilizing the knowledge of various string reversal algorithms, implement a function that can determine the shortest reversed sequence of a given input string using strictly in-place operations. Write a function `shortest_reversal_in_place` that takes a string `s` as input and returns its shortest reversed form while performing in-place operations. Function Signature: ```python def shortest_reversal_in_place(s: str) -> str: pass ``` Input: - A string `s` of length `n` (0 <= n <= 10^5). Output: - A reversed string achieved through in-place operations. Constraints: - Do not use any built-in Python functions like `reversed()` or slicing (`[::-1]`). - The function should perform in-place string reversal operations. Example: ```python assert shortest_reversal_in_place(\\"hello\\") == \\"olleh\\" assert shortest_reversal_in_place(\\"A man a plan a canal Panama\\") == \\"amanaP lanac a nalp a nam A\\" ``` **Note**: Ensure your implementation is efficient, handling edge cases such as empty strings and strings with varying characters.","solution":"def shortest_reversal_in_place(s: str) -> str: s_list = list(s) left, right = 0, len(s_list) - 1 while left < right: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return \'\'.join(s_list)"},{"question":"# Sorting the Student Scores You are tasked with implementing a sorting algorithm to organize student scores in ascending order. The scores list is large, and memory overhead must be minimal. Given the following `comb_sort` algorithm, adapt it to ensure that any issues with edge cases right at the end of the processing are handled by switching to a more efficient final phase if necessary. Function Signature: ```python def optimized_comb_sort(scores: List[int]) -> List[int]: pass ``` # Input: - `scores`: List of integers representing the student scores (0 <= scores[i] <= 100000). # Output: - A list of sorted integers in ascending order. # Constraints: - Ensure your solution can handle up to 10^6 scores efficiently. - You should avoid any solutions that do not run in under O(n log n) time for average cases. # Example: ```python optimized_comb_sort([91, 82, 73, 65, 57, 42]) # Output: [42, 57, 65, 73, 82, 91] optimized_comb_sort([42, 57, 65, 73, 82, 100]) # Output: [42, 57, 65, 73, 82, 100] ``` # Edge Cases to Consider: 1. An empty list should return an empty list. 2. A list with a single element should return the same list. 3. Identical elements should not affect stability but must maintain order. # Performance Requirements: - The solution must use a minimal memory overhead, maintaining an in-place sort. - Your algorithm should use an optimized approach to handle near-sorted lists effectively and switch to an appropriate final sorting phase when the gap is minimal.","solution":"def optimized_comb_sort(scores): Function to sort a list of student scores in ascending order using an optimized comb sort. def comb_sort(scores): gap = len(scores) shrink_factor = 1.3 sorted = False while gap > 1 or not sorted: # Update the gap for the next comb gap = max(1, int(gap / shrink_factor)) sorted = True # Assume the array is sorted for i in range(len(scores) - gap): if scores[i] > scores[i + gap]: scores[i], scores[i + gap] = scores[i + gap], scores[i] sorted = False # We found a swap, so it\'s not sorted yet return scores return comb_sort(scores)"},{"question":"# Question: Find Missing Ranges Context You are working on a data integrity project where you need to identify gaps in customer ID registrations within a specified range. Given an array of registered customer IDs and a lower and upper bound, your task is to find and return all ranges of customers IDs that are missing. Task Implement a function `missing_ranges` that takes an array of integers representing registered IDs (`arr`), and two integers representing the lower bound (`lo`) and the upper bound (`hi`). The function should return a list of tuples, each representing a missing range of IDs. Function Signature ```python def missing_ranges(arr: list, lo: int, hi: int) -> list: ``` Input * `arr`: List of integers (registered IDs), sorted in ascending order. * `lo`: Integer, lower bound of the range. * `hi`: Integer, upper bound of the range. Output * List of tuples, each representing a range of missing IDs (inclusive). Constraints * Elements of `arr` are distinct. * `lo <= hi` Example ```python missing_ranges([3, 5], 1, 10) # Output: [(1, 2), (4, 4), (6, 10)] missing_ranges([], 1, 5) # Output: [(1, 5)] missing_ranges([1, 2, 3, 4, 5], 1, 5) # Output: [] missing_ranges([2], 1, 3) # Output: [(1, 1), (3, 3)] ``` Guidelines 1. Ensure scalability by handling large range values efficiently. 2. Handle possible edge cases (e.g., empty arrays, full ranges, etc.). 3. Give clear logical variable names to improve code readability. 4. Avoid using additional libraries, focus on native Python.","solution":"def missing_ranges(arr, lo, hi): Given a sorted array of integers and a range [lo, hi], returns a list of tuples representing the missing ranges within the bounds. if not arr: return [(lo, hi)] result = [] # Check the range before the first element if lo < arr[0]: result.append((lo, arr[0] - 1)) # Check the ranges between the array elements for i in range(1, len(arr)): if arr[i] > arr[i-1] + 1: result.append((arr[i-1] + 1, arr[i] - 1)) # Check the range after the last element if hi > arr[-1]: result.append((arr[-1] + 1, hi)) return result"},{"question":"Scenario You are working on a project that processes linked list structures. One of your tasks is to write a function that swaps every two adjacent nodes in a singly linked list. You must ensure that the values within the nodes remain unchanged, and only the nodes themselves get repositioned. The reordering should be done in place with constant extra space. Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: pass ``` Input - `head`: a reference to the head node of a singly linked list. Output - Returns the head node of the linked list after swapping every two adjacent nodes. Constraints - You may not modify the values inside nodes; only nodes themselves may be changed. - Use only constant extra space. Example 1. **Input**: `1 -> 2 -> 3 -> 4` - **Output**: `2 -> 1 -> 4 -> 3` 2. **Input**: `1 -> 2 -> 3` - **Output**: `2 -> 1 -> 3` 3. **Input**: `1` - **Output**: `1` 4. **Input**: `None` - **Output**: `None` Additional Notes - Your solution should traverse the list as few times as possible. - Ensure that your function handles lists with different lengths, including empty lists and single-node lists. - Consider edge cases like lists with odd lengths where the last node is not paired. Implement the function `swap_pairs` to fulfill the requirements above.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def swap_pairs(head: Node) -> Node: if not head or not head.next: return head dummy = Node(0) dummy.next = head prev = dummy while prev.next and prev.next.next: first = prev.next second = prev.next.next # Swapping nodes first.next = second.next second.next = first prev.next = second # Move prev two nodes ahead prev = first return dummy.next"},{"question":"Description You are provided with the implementation of the Knuth-Morris-Pratt (KMP) algorithm, which efficiently finds all the start indices of a pattern within a given text. The algorithm constructs a partial match table (pi table) to perform the search in linear time. Your task is to implement a function that uses the KMP algorithm to find repeated subsequences in a given text. Task Write a function `find_repeated_subsequences` that takes a string `text` and an integer `length` as input and returns a list of all unique subsequences of the given length that appear more than once in the text. Input * `text` (str): The input string in which to search for repeated subsequences. * `length` (int): The length of the subsequences to search for. Output * List[str]: A list of all unique subsequences of the specified length that appear more than once in the text. Constraints * The input text will contain only lowercase alphabets. * `1 <= length <= len(text) <= 10^5` Requirements * Your solution must be efficient with a time complexity of O(N * length), where N is the length of the text. Example ```python def find_repeated_subsequences(text: str, length: int) -> List[str]: # Your code here # Test case assert find_repeated_subsequences(\\"banana\\", 2) == [\\"an\\", \\"na\\"] assert find_repeated_subsequences(\\"abracadabra\\", 3) == [\\"abr\\", \\"bra\\"] assert find_repeated_subsequences(\\"aabbcc\\", 1) == [\\"a\\", \\"b\\", \\"c\\"] ``` Implementation Details 1. **Generate all subsequences**: Generate all possible subsequences of the given length from the text. 2. **Use KMP algorithm**: For each unique subsequence, use the KMP algorithm to find all occurrences and identify subsequences that appear more than once. 3. **Store Results**: Return a list of unique subsequences that have multiple occurrences.","solution":"from typing import List from collections import defaultdict def find_repeated_subsequences(text: str, length: int) -> List[str]: if length > len(text): return [] # Dictionary to store the count of each subsequence subseq_count = defaultdict(int) # Generate all possible subsequences of the given length for i in range(len(text) - length + 1): subseq = text[i:i + length] subseq_count[subseq] += 1 # Collect all subsequences that appear more than once result = [subseq for subseq, count in subseq_count.items() if count > 1] return result"},{"question":"# Reversing Strings with Multiple Approaches **Context**: Imagine you are preparing a toolkit for text transformation that frequently involves reversing strings. You want to compare different methods of reversing strings to decide the most efficient one for your toolkit. **Task**: Implement various methods of string reversal discussed in the analysis, including the recursive, iterative, pythonic, and ultra-pythonic approaches. Your implementations should handle edge cases efficiently and conform to the time and space complexities described. **Requirements**: 1. Implement each reversal method as a standalone function. 2. Each function should take a single string as input and return the reversed string. 3. Ensure each function handles edge cases like empty strings and single-character strings efficiently. **Function Signatures**: ```python # Method 1: Recursive Reversal def reverse_recursive(s: str) -> str: # Implement the recursive string reversal here # Method 2: Iterative Reversal def reverse_iterative(s: str) -> str: # Implement the iterative string reversal here # Method 3: Pythonic Reversal def reverse_pythonic(s: str) -> str: # Implement the pythonic string reversal here # Method 4: Ultra Pythonic Reversal def reverse_ultra_pythonic(s: str) -> str: # Implement the ultra pythonic string reversal here ``` **Constraints**: - String length `len(s)` should be between `0` and `10^5`. **Evaluation**: 1. **Correctness**: Ensure each method correctly reverses the strings. 2. **Efficiency**: Compare the time and space complexity for provided input sizes. 3. **Readability & Maintainability**: Use clear and concise code with comments where necessary. **Example**: ```python input_string = \\"hello\\" print(reverse_recursive(input_string)) # Output: \\"olleh\\" print(reverse_iterative(input_string)) # Output: \\"olleh\\" print(reverse_pythonic(input_string)) # Output: \\"olleh\\" print(reverse_ultra_pythonic(input_string)) # Output: \\"olleh\\" ```","solution":"def reverse_recursive(s: str) -> str: Recursively reverses a string. if len(s) == 0: return s else: return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Iteratively reverses a string. reversed_str = \'\' for char in s: reversed_str = char + reversed_str return reversed_str def reverse_pythonic(s: str) -> str: Pythonic way to reverse a string using slicing. return s[::-1] def reverse_ultra_pythonic(s: str) -> str: Ultra-pythonic way to reverse a string using the built-in reversed function. return \'\'.join(reversed(s))"},{"question":"Compute the n-th Fibonacci Number Using Matrix Exponentiation Objective: You are required to implement a function to compute the n-th Fibonacci number using matrix exponentiation. Scenario: Fibonacci numbers have applications in different areas such as algorithms involving dynamic programming, computational theory, and even biology. You are required to write a function that efficiently computes the n-th Fibonacci number using matrix exponentiation to achieve a logarithmic time complexity. Function Signature: ```python def fib_matrix(n: int) -> int: Computes the n-th Fibonacci number using matrix exponentiation. Parameters: n (int): The position in the Fibonacci sequence to compute. Returns: int: The n-th Fibonacci number. ``` # Input: * `n` (integer): A non-negative integer where (0 leq n leq 10^9). # Output: * Returns the n-th Fibonacci number (integer). # Constraints: * The function should be efficient and capable of handling values up to ( n = 10^9 ) within a reasonable time frame. * Performance requirements are strict: the time complexity should not exceed ( O(log n) ). # Example: ```python print(fib_matrix(10)) #=> 55 print(fib_matrix(100)) #=> 354224848179261915075 ``` # Instructions: 1. Implement the function `fib_matrix` that computes the n-th Fibonacci number using matrix exponentiation. 2. Make use of matrix exponentiation techniques to achieve logarithmic time complexity. 3. You may use helper functions if necessary, and you are allowed to use Python’s built-in functions. 4. Ensure that your solution handles edge cases and is optimized for performance. Note: Matrix exponentiation is a fundamental algorithmic technique for solving linear recurrence relations in logarithmic time, making it well-suited for computing large Fibonacci numbers efficiently.","solution":"def multiply_matrices(A, B): return [ [ A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1], ], [ A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1], ], ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result def fib_matrix(n): Computes the n-th Fibonacci number using matrix exponentiation. Parameters: n (int): The position in the Fibonacci sequence to compute. Returns: int: The n-th Fibonacci number. if n == 0: return 0 if n == 1: return 1 F = [[1, 1], [1, 0]] result = matrix_power(F, n - 1) return result[0][0]"},{"question":"Context: You are developing a file management system where it\'s crucial to work with absolute paths to avoid issues from relative path ambiguity. The system needs to handle paths user inputs in various formats and ensure they are always absolute paths. Task: Implement a function `resolve_absolute_path` that takes a list of file path strings as input. This function will return a list of the corresponding absolute paths, ensuring all user directory (`~`) relative paths are expanded correctly. Input: * List of file path strings, `paths` (1 ≤ len(paths) ≤ 10^4). Each path is a string with the maximum length of 300 characters. Output: * List of absolute path strings corresponding to each input path. Constraints: * The function should handle typical edge cases like nested directories, user home shortcuts (`~`), and relative paths. * The paths should be valid file paths that the operating system recognizes. Example: ```python def resolve_absolute_path(paths): import os absolute_paths = [] for file in paths: absolute_paths.append(os.path.abspath(os.path.expanduser(file))) return absolute_paths # Example usage print(resolve_absolute_path([\\"~/documents/file.txt\\", \\"../file2.txt\\", \\"/var/log/syslog\\"])) # Output might look like: # [\'/home/user/documents/file.txt\', \'/home/user/file2.txt\', \'/var/log/syslog\'] ``` Ensure your function handles the following scenarios correctly: 1. User directory paths. 2. Relative paths involving `..` to denote parent directories. 3. Already absolute paths.","solution":"def resolve_absolute_path(paths): import os absolute_paths = [] for file in paths: absolute_paths.append(os.path.abspath(os.path.expanduser(file))) return absolute_paths"},{"question":"# Graph Traversal Problem **Scenario**: You are given a social network graph represented as an adjacency list, where each node represents a person and the edges represent friendships between people. You want to find all people that are reachable starting from a certain person. **Objective**: Implement functions to traverse the graph using Depth First Search (DFS) and Breadth First Search (BFS). **Requirements**: 1. **Function Implementation**: - `dfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]`: Traverse the graph using Depth First Search and return a set of all reachable nodes. - `bfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]`: Traverse the graph using Breadth First Search and return a set of all reachable nodes. 2. **Input and Output Formats**: - `graph`: A dictionary where the keys are integers representing nodes, and the values are lists of integers representing the neighbors of the nodes. - `start`: An integer representing the starting node from which traversal begins. - Both functions should return a set of integers representing all reachable nodes from the starting node. 3. **Constraints**: - The graph is a simple graph with undirected edges. - Nodes in the graph are numbered from `0` to `n-1` where `n` is the number of nodes. - The graph can have disconnected components. 4. **Performance Requirement**: - Your solution should handle graphs with up to 10^4 nodes efficiently. **Example**: ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2] } start_node = 0 # Expected Output: # dfs_traverse(graph, start_node) => {0, 1, 2, 3, 4} # bfs_traverse(graph, start_node) => {0, 1, 2, 3, 4} ``` # Edge Cases to Consider: - A graph with a single node and no edges. - A graph with multiple disconnected components. - A graph where the start node has no neighbors. - A graph containing cycles. **Guidelines**: - Write clean, efficient, and well-documented code. - Make sure to handle all edge cases appropriately. - Ensure that your implementation works within the given constraints and performance requirements.","solution":"from typing import Dict, List, Set from collections import deque def dfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]: Traverse the graph using Depth First Search (DFS) and return a set of all reachable nodes. visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: stack.append(neighbor) return visited def bfs_traverse(graph: Dict[int, List[int]], start: int) -> Set[int]: Traverse the graph using Breadth First Search (BFS) and return a set of all reachable nodes. visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return visited"},{"question":"# Nearest Neighbor Search Algorithm Background You are tasked with implementing a crucial component of a recommendation system that quickly identifies the most similar historical data point to a newly incoming data point. This function is a simplified version of the nearest neighbor search algorithm. Task Write a function `optimized_nearest_neighbor(x, tSet)` that implements an optimized version of the nearest neighbor algorithm given the constraints and inputs specified below. Input - `x`: A tuple representing the target vector (x). - `tSet`: A dictionary where keys are tuples representing the training set vectors and values are some associated data (e.g., labels). Output - Return the value associated with the training set vector which is nearest to the target vector (x). Constraints - The vectors will be non-empty and contain numeric values. - The training set will contain at least one vector. - You cannot use libraries specifically designed for nearest neighbor search (like Scikit-Learn\'s `KNeighborsClassifier`). Example Input: ```python x = (2, 3) tSet = { (1, 2): \\"A\\", (4, 5): \\"B\\", (1, 3): \\"C\\" } ``` Output: ``` \\"A\\" ``` Requirements * Implement efficient distance calculation. * Ensure the algorithm works within the given constraints. * Handle edge cases properly (e.g., fine-tune performance by avoiding unnecessary computations). ```python import math def optimized_nearest_neighbor(x, tSet): # Your code here pass ```","solution":"import math def euclidean_distance(a, b): Calculate the Euclidean distance between two vectors a and b. return math.sqrt(sum((a_i - b_i) ** 2 for a_i, b_i in zip(a, b))) def optimized_nearest_neighbor(x, tSet): Find the value associated with the nearest neighbor to vector x in tSet. if not tSet: raise ValueError(\\"The training set cannot be empty\\") nearest_vector = None min_distance = float(\'inf\') for vector in tSet: distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_vector = vector return tSet[nearest_vector]"},{"question":"# Programming Task: Implementing Enhanced Radix Sort Scenario Radix Sort is especially useful for sorting large datasets of non-negative integers. You\'ve been assigned to improve the radix sort implementation for an even distribution of numbers and ensure it handles the edge cases correctly. Problem Statement Create a function `enhanced_radix_sort` to sort a list of non-negative integers. Your task is to ensure the algorithm properly handles the maximum digit range while maintaining a balance between time and space complexity. Function Signature ```python def enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input Format - `arr`: A list of non-negative integers `0 <= arr[i] <= 10^6`. - `simulation` (optional): A boolean flag. If true, print the array state at each significant digit iteration. Default is `False`. Output Format - Return a sorted list of integers. Constraints - Handle lists with a potential wide variance in integer lengths gracefully. - Optimize space usage by reusing queues where possible. - Ensure the implementation is stable. - Time Complexity: O(nk), Space Complexity: O(n + k). Edge Cases - Empty list. - Single element list. - List with duplicated numbers. - Lists with large and small ranges of integers. Example ```python # Example Input arr = [170, 45, 75, 90, 802, 24, 2, 66] # Function Call print(enhanced_radix_sort(arr)) # Expected Output [2, 24, 45, 66, 75, 90, 170, 802] ```","solution":"from typing import List def enhanced_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return [] max_num = max(arr) exp = 1 base = 10 while max_num // exp > 0: arr = counting_sort_by_digit(arr, exp, base) if simulation: print(f\\"After sorting with exp {exp}: {arr}\\") exp *= base return arr def counting_sort_by_digit(arr: List[int], exp: int, base: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * base for num in arr: index = (num // exp) % base count[index] += 1 for i in range(1, base): count[i] += count[i - 1] for num in reversed(arr): index = (num // exp) % base output[count[index] - 1] = num count[index] -= 1 return output"},{"question":"You are tasked with implementing a function that checks if a given directed graph contains a cycle. A cycle in a directed graph is a path that starts and ends at the same node with at least one edge. Given the `DirectedGraph` class definition provided, you need to implement the method `has_cycle` that checks for the presence of a cycle in the graph. # Function Signature ```python def has_cycle(graph: DirectedGraph) -> bool: Determine if the directed graph contains any cycles. :param graph: An instance of DirectedGraph class. :return: True if there\'s at least one cycle in the graph, otherwise False. ``` # Inputs - An instance of `DirectedGraph` containing nodes and directed edges. # Outputs - Return `True` if there is at least one cycle in the graph, otherwise `False`. # Constraints - The graph will have at most `10^4` nodes and `10^5` edges. - Node names are unique strings. # Example ```python # Create graph with cycles graph_with_cycle = DirectedGraph({ \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] }) print(has_cycle(graph_with_cycle)) # Output: True # Create graph without cycles graph_without_cycle = DirectedGraph({ \'A\': [\'B\'], \'B\': [\'C\'] }) print(has_cycle(graph_without_cycle)) # Output: False ``` # Hints - Consider utilizing depth-first search (DFS) to detect back edges indicating cycles. - Track visited nodes and the recursion stack to keep track of the path being explored.","solution":"class DirectedGraph: def __init__(self, adjacency_list=None): if adjacency_list is None: adjacency_list = {} self.adjacency_list = adjacency_list def has_cycle(graph: DirectedGraph) -> bool: Determine if the directed graph contains any cycles. :param graph: An instance of DirectedGraph class. :return: True if there\'s at least one cycle in the graph, otherwise False. def dfs(node, visited, rec_stack): visited.add(node) rec_stack.add(node) for neighbor in graph.adjacency_list.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph.adjacency_list: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"Implementing Advanced Operations on a Red-Black Tree You have been provided a partial implementation of a Red-Black Tree, a self-balancing binary search tree. The tree ensures balance through its color properties and rotations. The provided implementation already contains basic insertion and deletion logic, rotation operations, and a method to do inorder traversal. Your task involves extending this implementation to include additional functionalities, and fixing potential bugs encountered in the provided methods. Your Task 1. **Implement the `find` method**: Write a function called `find` to locate a node by its value within the Red-Black Tree. This function should return the node if found, otherwise None. 2. **Implement tree balancing rules**: Verify and correct any potential violations of the Red-Black tree properties in the given insertion, deletion, or rotation operations. 3. **Inorder Traversal Output**: Enhance the `inorder` function to return a list of node values where each node value maintains an association with its color (red/black). Function Signature ```python class RBTree: ... def find(self, value: int) -> Optional[RBNode]: ... ... def balanced_insert(self, value: int) -> None: Implement the Red-Black Tree insertion logic with necessary balancing rules. ... def balanced_delete(self, value: int) -> None: Implement the Red-Black Tree deletion logic with necessary balancing rules. ... ... def enhanced_inorder(self) -> List[Dict[str, Union[int, str]]]: Implement an enhanced inorder traversal returning a list of node values and their colors ... ``` Constraints - Your implementation must maintain the Red-Black Tree properties. - You should be prepared to handle all edge cases such as inserting into an empty tree, deleting nodes with one or two children, and maintaining tree balance post-insertion/deletion. Example Given the RBT with nodes inserted in the following order: [11, 2, 14, 1, 7, 15, 5, 8, 4] - Calling `find(7)` should return the node with value `7`. - Calling `balanced_delete(7)` followed by `enhanced_inorder()` should return an in-order list of nodes with their values and colors after balancing. This exercise will test your understanding of maintaining and balancing self-balancing binary search trees, as well as implementing complex rotations and color property fixes efficiently.","solution":"class RBNode: def __init__(self, value, color=\\"red\\"): self.value = value self.color = color self.left = None self.right = None self.parent = None def __repr__(self): return f\\"{self.value}({self.color})\\" class RBTree: def __init__(self): self.NIL_LEAF = RBNode(value=None, color=\\"black\\") self.root = self.NIL_LEAF def find(self, value): current = self.root while current != self.NIL_LEAF: if value == current.value: return current elif value < current.value: current = current.left else: current = current.right return None def left_rotate(self, node): right_child = node.right node.right = right_child.left if right_child.left != self.NIL_LEAF: right_child.left.parent = node right_child.parent = node.parent if node.parent is None: self.root = right_child elif node == node.parent.left: node.parent.left = right_child else: node.parent.right = right_child right_child.left = node node.parent = right_child def right_rotate(self, node): left_child = node.left node.left = left_child.right if left_child.right != self.NIL_LEAF: left_child.right.parent = node left_child.parent = node.parent if node.parent is None: self.root = left_child elif node == node.parent.right: node.parent.right = left_child else: node.parent.left = left_child left_child.right = node node.parent = left_child def balanced_insert(self, value): new_node = RBNode(value) new_node.left = self.NIL_LEAF new_node.right = self.NIL_LEAF parent = None current = self.root while current != self.NIL_LEAF: parent = current if new_node.value < current.value: current = current.left else: current = current.right new_node.parent = parent if parent is None: self.root = new_node elif new_node.value < parent.value: parent.left = new_node else: parent.right = new_node new_node.color = \\"red\\" self.fix_insert(new_node) def fix_insert(self, node): while node != self.root and node.parent.color == \\"red\\": if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color == \\"red\\": node.parent.color = \\"black\\" uncle.color = \\"black\\" node.parent.parent.color = \\"red\\" node = node.parent.parent else: if node == node.parent.right: node = node.parent self.left_rotate(node) node.parent.color = \\"black\\" node.parent.parent.color = \\"red\\" self.right_rotate(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color == \\"red\\": node.parent.color = \\"black\\" uncle.color = \\"black\\" node.parent.parent.color = \\"red\\" node = node.parent.parent else: if node == node.parent.left: node = node.parent self.right_rotate(node) node.parent.color = \\"black\\" node.parent.parent.color = \\"red\\" self.left_rotate(node.parent.parent) self.root.color = \\"black\\" def transplant(self, u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent def balanced_delete(self, value): z = self.find(value) if z is None: return y = z y_original_color = y.color if z.left == self.NIL_LEAF: x = z.right self.transplant(z, z.right) elif z.right == self.NIL_LEAF: x = z.left self.transplant(z, z.left) else: y = self.minimum(z.right) y_original_color = y.color x = y.right if y.parent == z: x.parent = y else: self.transplant(y, y.right) y.right = z.right y.right.parent = y self.transplant(z, y) y.left = z.left y.left.parent = y y.color = z.color if y_original_color == \\"black\\": self.fix_delete(x) def fix_delete(self, x): while x != self.root and x.color == \\"black\\": if x == x.parent.left: w = x.parent.right if w.color == \\"red\\": w.color = \\"black\\" x.parent.color = \\"red\\" self.left_rotate(x.parent) w = x.parent.right if w.left.color == \\"black\\" and w.right.color == \\"black\\": w.color = \\"red\\" x = x.parent else: if w.right.color == \\"black\\": w.left.color = \\"black\\" w.color = \\"red\\" self.right_rotate(w) w = x.parent.right w.color = x.parent.color x.parent.color = \\"black\\" w.right.color = \\"black\\" self.left_rotate(x.parent) x = self.root else: w = x.parent.left if w.color == \\"red\\": w.color = \\"black\\" x.parent.color = \\"red\\" self.right_rotate(x.parent) w = x.parent.left if w.right.color == \\"black\\" and w.left.color == \\"black\\": w.color = \\"red\\" x = x.parent else: if w.left.color == \\"black\\": w.right.color = \\"black\\" w.color = \\"red\\" self.left_rotate(w) w = x.parent.left w.color = x.parent.color x.parent.color = \\"black\\" w.left.color = \\"black\\" self.right_rotate(x.parent) x = self.root x.color = \\"black\\" def minimum(self, node): while node.left != self.NIL_LEAF: node = node.left return node def enhanced_inorder(self): res = [] self._inorder_helper(self.root, res) return res def _inorder_helper(self, node, res): if node != self.NIL_LEAF: self._inorder_helper(node.left, res) res.append({\\"value\\": node.value, \\"color\\": node.color}) self._inorder_helper(node.right, res)"},{"question":"# Separate Chaining Hash Table Implementation You are tasked with implementing a \'SeparateChainingHashTable\' class using the separate chaining method for collision resolution. The hash table will use linked lists to manage collisions. **Functional Requirements**: 1. `put(key: Any, value: Any) -> None`: Insert a key-value pair into the hash table. If the key already exists, update the corresponding value. 2. `get(key: Any) -> Any` : Retrieve the value associated with the key, or return `None` if the key does not exist. 3. `del_(key: Any) -> None`: Remove the key-value pair from the hash table if it exists. 4. `hash(key: Any) -> int`: Compute and return the hash of the key. 5. `__len__() -> int`: Return the number of key-value pairs in the hash table. **Implementation Details**: - Use an initial table size of 11. - Implement linked lists for the buckets to handle collisions. - Allow custom resizing function to resize the table when the load factor exceeds a threshold. **Constraints**: - Keys are assumed to be hashable and unique. - Values can be any type. - The load factor threshold for resizing should be set to a maximum of 0.75. - The new table size after resizing should be the next prime number greater than twice the current table size. **Performance Requirements**: - Average time complexity for put, get, del operations should be O(1). **Input and Output**: - `put` does not return anything. - `get` returns the value associated with the key or `None`. - `del_` removes the key-value pair and does not return anything. - `__len__` returns an integer. **Example Usage**: ```python table = SeparateChainingHashTable() table.put(\'name\', \'Alice\') assert table.get(\'name\') == \'Alice\' assert len(table) == 1 table.put(\'name\', \'Bob\') assert table.get(\'name\') == \'Bob\' table.del_(\'name\') assert table.get(\'name\') is None assert len(table) == 0 ```","solution":"class SeparateChainingHashTable: def __init__(self): self.initial_size = 11 self.table = [[] for _ in range(self.initial_size)] self.size = 0 self.load_factor_threshold = 0.75 def hash(self, key): return hash(key) % len(self.table) def put(self, key, value): index = self.hash(key) for pair in self.table[index]: if pair[0] == key: pair[1] = value return self.table[index].append([key, value]) self.size += 1 if self.size / len(self.table) > self.load_factor_threshold: self._resize() def get(self, key): index = self.hash(key) for pair in self.table[index]: if pair[0] == key: return pair[1] return None def del_(self, key): index = self.hash(key) for i, pair in enumerate(self.table[index]): if pair[0] == key: del self.table[index][i] self.size -= 1 return def __len__(self): return self.size def _resize(self): new_size = self._next_prime(2 * len(self.table)) new_table = [[] for _ in range(new_size)] old_table = self.table self.table = new_table self.size = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) @staticmethod def _next_prime(n): def is_prime(num): if num < 2: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True while not is_prime(n): n += 1 return n"},{"question":"# Scenario You are developing a logistics application that manages the shipment of packages. One critical feature is the ability to sort packages by weight for efficient loading and priority processing. # Task Implement a function `sorted_weights(packages: List[int]) -> List[int]` that sorts a list of package weights using an adaptation of the Counting Sort algorithm. This function must handle both negative and positive weights, as well as weights that might lie in a large range. # Input - `packages`: A list of integers representing package weights. The list can contain both negative and positive integers. # Output - A sorted list of integers in ascending order. # Constraints - The length of `packages` will not exceed (10^5). - Package weights will be between (-10^4) and (10^4). # Requirements - Your implementation should handle negative weights correctly. - Use an efficient algorithm with time complexity O(n + k). # Example ```python assert sorted_weights([4, -1, 2, -3, 0]) == [-3, -1, 0, 2, 4] assert sorted_weights([]) == [] assert sorted_weights([3, 3, 3]) == [3, 3, 3] ``` # Edge Cases to Consider - The function should correctly sort arrays with a mix of negative and positive weights. - Ensure that it handles empty arrays gracefully. - Test with arrays having all identical elements.","solution":"from typing import List def sorted_weights(packages: List[int]) -> List[int]: Sorts a list of integers representing package weights using an adaptation of the Counting Sort algorithm. Handles both negative and positive weights correctly. if not packages: return [] max_val = max(packages) min_val = min(packages) range_of_elements = max_val - min_val + 1 # Initialize count array count = [0] * range_of_elements output = [0] * len(packages) # Store the count of each element for num in packages: count[num - min_val] += 1 # Store the cumulative count of each count array element for i in range(1, len(count)): count[i] += count[i - 1] # Place the elements in output array in sorted order for num in reversed(packages): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# Coding Task: Implement Euler\'s Totient Function Enhanced **Objective:** You are required to implement an enhanced version of Euler\'s Totient function such that it minimizes repeated calculations and can more effectively handle large numbers. **Problem Statement:** Given an integer ( n ), efficiently compute the Euler\'s Totient Function ( phi(n) ). Extend your function to memoize results for reused sub-computations and reduce computation time significantly. **Function Signature:** ```python def memoized_euler_totient(n: int, cache: dict) -> int: Compute Euler\'s Totient function with memoization. :param n: The integer for which the function value is to be computed. :param cache: A dictionary to store previously computed values. :return: The value of Euler\'s Totient function for n. pass ``` **Input:** - An integer ( n ) such that ( 1 leq n leq 10^6 ). - A dictionary `cache` that holds precomputed totient values. **Output:** - Returns the value of Euler\'s Totient function ( phi(n) ). **Constraints:** - Precompute and store frequently used results to handle up to ( 10^6 ) efficiently. - Optimize the function to achieve a significant performance gain over ( O(sqrt{n}) ) complexity by leveraging memoization. **Example:** ```python cache = {} print(memoized_euler_totient(10, cache)) # Output: 4 print(memoized_euler_totient(20, cache)) # Output: 8 print(memoized_euler_totient(30, cache)) # Output: 8 ``` **Requirements:** - Your solution should handle large values of ( n ) efficiently. - You need to ensure that previously computed values are reused from the cache effectively. - Discuss the observed performance improvements over the non-memoized version. **Hints:** - Identify the applicable subproblems that can be stored in the cache. - Utilize dictionary lookups to quickly access precomputed results.","solution":"def memoized_euler_totient(n: int, cache: dict) -> int: Compute Euler\'s Totient function with memoization. :param n: The integer for which the function value is to be computed. :param cache: A dictionary to store previously computed values. :return: The value of Euler\'s Totient function for n. if n in cache: return cache[n] result = n p = 2 original_n = n while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n cache[original_n] = result return result"},{"question":"Context: As a part of a text processing module, you need to develop a function to help spell-check words by comparing them against a dictionary. One key task is determining how close a given word is to words in the dictionary based on the minimum number of single-character edits (insertions, deletions, or substitutions) necessary to match the dictionary word. Problem Statement: Given two strings, `word_a` and `word_b`, write a function to compute their edit distance using a dynamic programming approach. Function Specification: * **Function Name**: `compute_edit_distance` * **Input**: - `word_a` (a string of length `n` where 1 ≤ length ≤ 1000) - `word_b` (a string of length `m` where 1 ≤ length ≤ 1000) * **Output**: - An integer representing the minimum number of operations required to transform `word_a` into `word_b`. Constraints: - The function should have a time complexity of O(n * m) where n and m are the lengths of `word_a` and `word_b`. - The function should have a space complexity of O(n * m). - Keep in mind that both input strings can contain lowercase letters a-z. Performance Requirements: - The implementation should be efficient and handle the maximum input sizes within reasonable time limits. Example: ```python compute_edit_distance(\\"kitten\\", \\"sitting\\") # Returns 3 compute_edit_distance(\\"flaw\\", \\"lawn\\") # Returns 2 compute_edit_distance(\\"intention\\", \\"execution\\") # Returns 5 ``` Additional Notes: - Consider edge cases such as one or both strings being empty.","solution":"def compute_edit_distance(word_a, word_b): Compute the edit distance between two strings using dynamic programming. Edit distance is the minimum number of single-character edits needed to transform one string to the other. Parameters: word_a (str): The first string. word_b (str): The second string. Returns: int: The edit distance between the two strings. n, m = len(word_a), len(word_b) # Create DP table with dimensions (n+1) x (m+1) dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize DP table for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Populate DP table with edit distances for i in range(1, n + 1): for j in range(1, m + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[n][m]"},{"question":"You are given a function `find_nth_digit(n)` that efficiently finds the nth digit in the sequence of all positive integers concatenated together (i.e., 123456789101112... and so on). Your task is to implement this function with a focus on clarity, efficiency, and handling edge cases appropriately. # Function Signature `def find_nth_digit(n: int) -> int:` # Input - `n (int)`: Represents the position of the digit in the infinite integer sequence (1-indexed). (1 leq n leq 2^{31} - 1). # Output - `int`: The nth digit in the sequence. # Constraints - The value of `n` will always be a valid integer within the range of 1 to (2^{31} - 1). - Ensure the method handles large values of `n` efficiently. # Example 1. `find_nth_digit(3)` should return `3`, because the sequence starts as 123. 2. `find_nth_digit(10)` should return `1`, because the sequence starts as 12345678910. 3. `find_nth_digit(15)` should return `2`, because the sequence starts as 123456789101112... # Detailed Explanation Given the requirement, thoroughly evaluate: 1. The length of numbers at the position n resides. 2. The specific number in that segment. 3. The exact digit within that number. Test your implementation against corner cases like: - Small positions: `n = 1`. - Positions across different length transitions: around `n = 9, 10, 99, 100`.","solution":"def find_nth_digit(n: int) -> int: Finds the nth digit in the sequence of all positive integers concatenated together. # Initialize the length of the digit, the first number at that length, and the count of digits length = 1 count = 9 start = 1 # Determine the range in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number and the digit within it start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"In-Place Node Deletion in a Singly Linked List Problem Statement: You are given a node (not the tail) in a singly linked list, and you need to delete this node. The input is directly a reference to the node that needs to be deleted, and you do not have access to the head of the list. Your task is to modify the given node such that it resembles the node being deleted from the linked list. # Function Signature: ```python def delete_node(node: Node) -> None: ``` Input: - `node` (Node): A reference to a node in a singly linked list that needs to be deleted. Output: - `None`: The function should perform in-place deletion without returning anything. Constraints: - The given node is guaranteed not to be the tail node. Examples: Consider the linked list: `1 -> 2 -> 3 -> 4` 1. If provided node is `node 3`, after calling `delete_node(node3)`, the linked list should become `1 -> 2 -> 4`. Additional Requirements: 1. Consider common edge cases where the input might be `None` or an attempt to delete the tail node to ensure your function handles these properly. 2. Ensure that your solution has a time complexity of O(1) and a space complexity of O(1). You can use the following code to test your implementation: ```python class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: if node is None or node.next is None: raise ValueError(\\"Cannot delete this node.\\") node.val = node.next.val node.next = node.next.next import unittest class TestSuite(unittest.TestCase): def test_delete_node(self): head = Node(1) curr = head for i in range(2, 6): curr.next = Node(i) curr = curr.next node3 = head.next.next delete_node(node3) curr = head self.assertEqual(1, curr.val) curr = curr.next self.assertEqual(2, curr.val) curr = curr.next self.assertEqual(4, curr.val) curr = curr.next self.assertEqual(5, curr.val) tail = curr self.assertIsNone(tail.next) self.assertRaises(ValueError, delete_node, tail) self.assertRaises(ValueError, delete_node, tail.next) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node: Node) -> None: if node is None or node.next is None: raise ValueError(\\"Cannot delete this node.\\") node.val = node.next.val node.next = node.next.next"},{"question":"# Problem: Max Flow in An Augmented Flow Network As a network engineer, you are given a task to determine the maximum flow of data that can be pushed from a source server to a target server in a data center. The network architecture can be represented as a directed graph, where each node represents a server and edges represent data routes with specific capacities. Your task is to implement an algorithm that computes the maximum possible data flow from the source server to the target server using the principles of the Breadth-First Search (BFS) based solution described earlier. # Function Signature ```python def compute_max_flow(network: list[list[int]]) -> int: Calculates the maximum flow of data from the source (0) to the target (last node) in a flow network. :param network: A 2D list of integers representing the adjacency matrix of the flow network. network[i][j] is the capacity of the edge from node i to node j. :return: An integer value representing the maximum flow from source to sink. ``` # Input * `network`: A 2D list (n x n) where `network[i][j]` is an integer representing the capacity of the edge from server `i` to server `j`. The source server is server `0` and the target/server is the last server (`n-1`). # Output * An integer representing the maximum flow from the source server to the target server. # Constraints * The number of servers `n` is 1 ≤ n ≤ 500. * The capacity of each edge is a non-negative integer within the range [0, 1000]. # Example ```python # Example 1 network = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] print(compute_max_flow(network)) # Output: 23 # Example 2 network = [ [0, 10, 10, 0], [0, 0, 5, 10], [0, 4, 0, 10], [0, 0, 0, 0] ] print(compute_max_flow(network)) # Output: 14 ``` # Notes * The function needs to handle edge cases like no available paths, zero capacity edges, and disconnected nodes. * Optimize the function to handle larger networks efficiently.","solution":"from collections import deque def bfs(rGraph, s, t, parent): visited = [False] * len(rGraph) queue = deque([s]) visited[s] = True while queue: u = queue.popleft() for v, capacity in enumerate(rGraph[u]): if not visited[v] and capacity > 0: # Not yet visited and there\'s capacity queue.append(v) visited[v] = True parent[v] = u if v == t: return True return False def compute_max_flow(network): n = len(network) source = 0 sink = n - 1 # Create a residual graph and fill it with given capacities in the original graph rGraph = [row[:] for row in network] parent = [-1] * n # This array is filled by BFS and to store path max_flow = 0 # There is no flow initially # Augment the flow while there is a path from source to sink while bfs(rGraph, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, rGraph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] rGraph[u][v] -= path_flow rGraph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Question: Subset Sums Given an input list of distinct integers, write a function `subset_sums` that returns a list of all distinct sums that can be obtained by adding up the elements of any subset (including the empty subset which sums to 0). Expected Input and Output - **Input**: A list of distinct integers `nums`. - **Output**: A list of integers representing all distinct subset sums in sorted order. Constraints - The length of `nums` will not exceed 20. - The elements of `nums` are distinct and between `-100` and `100`. Example ```python # Example 1 input_nums = [1, 2, 3] output_sums = [0, 1, 2, 3, 4, 5, 6] # Example 2 input_nums = [-1, -2, 3] output_sums = [-3, -2, -1, 0, 1, 2, 3] ``` # Scenario Imagine you are a research scientist trying to determine all possible total weights you can get by combining different quantities of several distinct chemicals. Each chemical\'s weight is known and you can use each chemical in a combination or not. You need to determine which total weights are possible to achieve. This problem can be solved by generating all possible subset sums from a given list of chemical weights. # Implementation Implement the function `subset_sums(nums: List[int]) -> List[int]` that leverages the core concept of generating subsets and calculates their corresponding sums. ```python from typing import List def subset_sums(nums: List[int]) -> List[int]: n = len(nums) total = 1 << n sums = set() for i in range(total): subset_sum = sum(nums[j] for j in range(n) if i & 1 << j) sums.add(subset_sum) return sorted(sums) # Test cases assert subset_sums([1, 2, 3]) == [0, 1, 2, 3, 4, 5, 6] assert subset_sums([-1, -2, 3]) == [-3, -2, -1, 0, 1, 2, 3] ``` # Performance Requirements The implementation should be efficient enough to handle the upper constraint where `nums` contains up to 20 elements, resulting in up to (2^{20} = 1,048,576) possible subsets.","solution":"from typing import List def subset_sums(nums: List[int]) -> List[int]: Returns a list of all distinct subset sums that can be formed from the input list of distinct integers. n = len(nums) total = 1 << n sums = set() for i in range(total): subset_sum = sum(nums[j] for j in range(n) if i & 1 << j) sums.add(subset_sum) return sorted(sums)"},{"question":"**Matrix Multiplication Assignment** # Problem Statement You are given two compatible two-dimensional matrices `multiplicand` and `multiplier`. You need to write a function that multiplies these two matrices and returns their product. # Function Signature ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: ``` # Input * `multiplicand` (List[List[int]]): A 2-dimensional list representing the multiplicand matrix with dimensions m x n. * `multiplier` (List[List[int]]): A 2-dimensional list representing the multiplier matrix with dimensions n x p. # Output * Returns a 2-dimensional list representing the product matrix with dimensions m x p. # Constraints * The number of columns in the `multiplicand` matrix must equal the number of rows in the `multiplier` matrix. You should raise an exception if this condition is not met. * Assume all integer values in the matrices will not cause integer overflow. * You should consider edge cases such as empty matrices. # Example 1 ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] result = matrix_multiply(multiplicand, multiplier) # Expected result: [[19, 22], [43, 50]] ``` # Example 2 ```python multiplicand = [ [1, 0, 2], [-1, 3, 1] ] multiplier = [ [3, 1], [2, 1], [1, 0] ] result = matrix_multiply(multiplicand, multiplier) # Expected result: [[5, 1], [4, 2]] ``` # Detailed Explanation * Perform the multiplication matrix operation as described: * The element in the ith row and jth column of the result matrix is the dot product of the ith row of the multiplicand and the jth column of the multiplier. * Ensure to raise an exception if the number of columns in `multiplicand` does not match the number of rows in `multiplier`.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices and returns the resultant matrix. Args: multiplicand (list of list of int): The first matrix with dimensions m x n. multiplier (list of list of int): The second matrix with dimensions n x p. Returns: list of list of int: The product matrix with dimensions m x p. # Dimensions of the input matrices m = len(multiplicand) n = len(multiplicand[0]) if multiplicand else 0 p = len(multiplier[0]) if multiplier else 0 # Check if matrices are compatible for multiplication if n != len(multiplier): raise ValueError(\\"Number of columns in multiplicand must equal number of rows in multiplier.\\") # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Balanced Binary Tree Validator **Context:** In computer science, a balanced binary tree is essential to ensure that operations such as search, insertion, and deletion can be performed efficiently. A binary tree is considered balanced if the height difference between any two subtrees of any node in the tree is no more than one. Your task is to implement a function to verify if a given binary tree is balanced. **Task:** Write a function `is_balanced_binary_tree(root)` that takes the root of a binary tree and returns `True` if the tree is balanced and `False` otherwise. **Function Signature:** ```python def is_balanced_binary_tree(root: TreeNode) -> bool: pass ``` **Input:** * `root` (TreeNode): The root node of the binary tree. `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output:** * `bool`: Return `True` if the binary tree is balanced, otherwise return `False`. **Constraints:** * The number of nodes in the tree is in the range [0, 10^4]. * The tree node values are of type integer and can be highly varied. **Performance Requirements:** The solution should run in (O(N)) time complexity and handle the recursion stack space efficiently. **Example:** ```python # Example binary tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert is_balanced_binary_tree(root) == True # Example of an unbalanced tree: # 1 # / # 2 # / # 3 root_unbalanced = TreeNode(1) root_unbalanced.left = TreeNode(2) root_unbalanced.left.left = TreeNode(3) assert is_balanced_binary_tree(root_unbalanced) == False ``` **Additional Notes:** - The function must handle edge cases such as a null tree (should return True), single-node trees, and highly imbalanced trees efficiently. - Consider using helper functions to keep the main function clean and modular.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_binary_tree(root: TreeNode) -> bool: def check_balance_and_height(node): if node is None: return True, 0 left_balanced, left_height = check_balance_and_height(node.left) right_balanced, right_height = check_balance_and_height(node.right) current_balanced = ( left_balanced and right_balanced and abs(left_height - right_height) <= 1 ) current_height = max(left_height, right_height) + 1 return current_balanced, current_height balanced, _ = check_balance_and_height(root) return balanced"},{"question":"# Remove Duplicates from a Singly Linked List You are given a singly linked list where each node contains a character value. Your task is to implement two functions that remove duplicate elements from the list: 1. **remove_dups(head)**: This function should remove duplicates using additional space to achieve linear time complexity. 2. **remove_dups_without_set(head)**: This function should remove duplicates without using additional space, should maintain a quadratic time complexity. Function Signature: ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def remove_dups(head: Node) -> None: # Your implementation here def remove_dups_without_set(head: Node) -> None: # Your implementation here def print_linked_list(head: Node) -> None: # Helper function to print values in linked list ``` Input: * **head**: A `Node` object representing the head of the linked list where each node contains a character value (`val`). Output: * Both functions should modify the linked list in place and return `None`. Constraints: * The linked list will contain at least one node and at most (10^5) nodes. * The character values in the linked list nodes are limited to ASCII characters. # Example: ```python # Create linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Using remove_dups(head) remove_dups(a1) print_linked_list(a1) # Expected Output: \\"A -> B -> C -> D -> F -> G\\" # Using remove_dups_without_set(head) remove_dups_without_set(a1) print_linked_list(a1) # Expected Output: \\"A -> B -> C -> D -> F -> G\\" ``` Ensure your implementation handles edge cases like empty lists or lists with all identical elements.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: if not head: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head: Node) -> None: current = head while current: print(current.val, end=\\" -> \\" if current.next else \\"\\") current = current.next print()"},{"question":"# Bubble Sort with Enhanced Functionality Given an array of integers, implement a `bubble_sort` function that sorts the array in ascending order using the Bubble Sort algorithm. Additionally, enhance the function to support a mode where the sorting process is displayed step-by-step. Function Signature ```python def bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input - `arr`: A list of integers that need to be sorted. `1 <= len(arr) <= 1000`. - `simulation`: A boolean flag (default is `False`). If `True`, print the internal state of the array after every iteration where a swap is made. Output - Returns a sorted list of integers in ascending order. Constraints - The array length can be up to 1000 elements. - Performance: Your solution should have a time complexity of O(N^2) in the worst case. - Do not use any built-in sorting functions. - Optimize for early termination if possible. Example ``` python >>> arr = [64, 34, 25, 12, 22, 11, 90] >>> bubble_sort(arr) [11, 12, 22, 25, 34, 64, 90] >>> arr = [5, 1, 4, 2, 8] >>> bubble_sort(arr, True) iteration 1 : 1 5 4 2 8 iteration 2 : 1 4 5 2 8 iteration 3 : 1 4 2 5 8 iteration 4 : 1 4 2 5 8 iteration 5 : 1 2 4 5 8 [1, 2, 4, 5, 8] ``` Notes - You can assume that input arrays are provided and no input validation is required. - For the simulation flag, you should print the array\'s state after each swap operation. - Make sure the output matches the exact format as in the examples provided.","solution":"def bubble_sort(arr, simulation=False): Sort the array in ascending order using Bubble Sort algorithm. Parameters: - arr: List[int] - The list of integers to be sorted. - simulation: bool - If True, print the array state after each swap operation. Returns: - List[int] - Sorted list of integers in ascending order. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\'iteration {i*n+j//n+1}:\', \' \'.join(map(str, arr))) if not swapped: break return arr"},{"question":"# Question: Incrementing a Big-Endian Digit Array You are given a non-negative integer represented as an array of digits. Write a function `increment_digit_array` to add one to this integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. # Function Signature: ```python def increment_digit_array(digits: List[int]) -> List[int]: pass ``` # Input: - A non-empty list of integers, `digits`, where each individual integer is a single digit (0-9) and the most significant digit is `digits[0]`. # Output: - A list of integers representing the incremented number. # Constraints: - You may assume that the input list represents a non-negative integer without leading zeros. - Your solution must handle large integers efficiently. # Examples: ``` python increment_digit_array([1, 2, 3]) -> [1, 2, 4] increment_digit_array([4, 3, 2, 1]) -> [4, 3, 2, 2] increment_digit_array([9, 9, 9]) -> [1, 0, 0, 0] increment_digit_array([0]) -> [1] ``` # Edge Cases to Consider: - Arrays with all 9s should correctly produce a leading 1: `[9, 9, 9]` -> `[1, 0, 0, 0]`. - Very large arrays should be handled within reasonable time and space complexity. - Consider performance and avoid unnecessary space usage as much as possible. Implement the function ensuring correctness, optimal performance, and clarity.","solution":"from typing import List def increment_digit_array(digits: List[int]) -> List[int]: Increments the integer represented by the given list of digits by one. n = len(digits) # Iterate from the last digit backwards for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: digits[i] = 0 # If we\'ve gone through all digits and each was a 9 return [1] + [0] * n"},{"question":"# Coding Challenge: Optimized Pathfinding in Weighted Graphs Context You are tasked with modifying and optimizing pathfinding functions to work with weighted graphs and to handle large datasets more efficiently. The primary goal is leveraging Dijkstra’s algorithm to find the shortest paths in a graph with edge weights. Problem Statement Write a function `find_shortest_weighted_path` that finds the shortest path in a weighted graph using Dijkstra\'s algorithm. **Function Signature** ```python def find_shortest_weighted_path(graph: Dict[str, Dict[str, int]], start: str, end: str) -> List[str]: pass ``` **Input** - `graph`: Dictionary of dictionaries representing the weighted graph. - Example: `{ \'A\': { \'B\': 1, \'C\': 4 }, \'B\': { \'C\': 2, \'D\': 5 }, ... }` - `start`: The starting node as a string. - `end`: The ending node as a string. **Output** - List of node names representing the shortest path from `start` to `end`. If no path exists, return an empty list. **Constraints** - The graph will contain at least 2 nodes and 1 edge. - All weights are positive integers. **Performance Requirements** - Consider optimization techniques and efficient data structures. - Time complexity should be better than O(N!). Example ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } assert find_shortest_weighted_path(graph, \'A\', \'D\') == [\'A\', \'B\', \'C\', \'D\'] assert find_shortest_weighted_path(graph, \'A\', \'C\') == [\'A\', \'B\', \'C\'] assert find_shortest_weighted_path(graph, \'A\', \'E\') == [] ```","solution":"import heapq def find_shortest_weighted_path(graph, start, end): Finds the shortest path in a weighted graph from start to end using Dijkstra\'s algorithm. :param graph: Dictionary of dictionaries representing the weighted graph. :param start: The starting node as a string. :param end: The ending node as a string. :return: List of node names representing the shortest path from start to end. # Priority queue to manage exploration of nodes queue = [(0, start, [])] # Dictionary to track the shortest known distance to a node seen = {start: 0} while queue: (cost, node, path) = heapq.heappop(queue) # append the current node to the path path = path + [node] # if the end node is reached if node == end: return path # checking the neighbors of the current node for next_node, weight in graph.get(node, {}).items(): new_cost = cost + weight if next_node not in seen or seen[next_node] > new_cost: seen[next_node] = new_cost heapq.heappush(queue, (new_cost, next_node, path)) return []"},{"question":"Bi-Directional Swap Sort Using the understanding of Cocktail Shaker Sort, implement a function called `advanced_shaker_sort` that sorts an input array of integers. The array should be sorted in ascending order using an improved version of the algorithm known as an Advanced Shaker Sort. Your task is to write a Python function that enhances the basic Cocktail Shaker Sort by incorporating additional optimizations. Consider skipping unnecessary iterations if the list is already sorted or partially sorted to improve the performance. # Function Signature ```python def advanced_shaker_sort(arr: List[int]) -> List[int]: pass ``` # Input * An array `arr` of integers where (1 leq text{len(arr)} leq 10^5) * The values in the array can range between (-10^6) and (10^6) # Output * The function should return a sorted list of integers in non-decreasing order. # Constraints * Time complexity should be optimized as much as possible within the O(N^2) bound. * Space complexity should be O(1) as the sorting needs to be done in place. # Example ```python assert advanced_shaker_sort([3, 0, 2, -1, 5, 4]) == [-1, 0, 2, 3, 4, 5] assert advanced_shaker_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert advanced_shaker_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] ``` # Hint Consider ways to avoid full iterations of forward and backward passes if the list appears sorted during the early stages.","solution":"from typing import List def advanced_shaker_sort(arr: List[int]) -> List[int]: This function implements an optimized version of the cocktail shaker sort, also known as bidirectional bubble sort. It alternates between traversing the list forward and backward. if not arr or len(arr) == 1: return arr # If the list is empty or has only one element, it is already sorted n = len(arr) start = 0 end = n - 1 is_sorted = False while not is_sorted: is_sorted = True # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False # If no elements were swapped, the array is sorted if is_sorted: break # Otherwise, reset the flag for the next pass is_sorted = True # Move the end point back by one, because the last element is already in place end -= 1 # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] is_sorted = False # Move the start point forward by one, because the first element is already in place start += 1 return arr"},{"question":"# Detailed Question **Context**: You are given an array of integers and need to sort it using the Bubble Sort algorithm. To understand the inner workings of Bubble Sort better and demonstrate its process, an option is provided to simulate the sorting steps. **Task**: Implement the `bubble_sort` function which sorts an array of integers in ascending order. Your function should also have an optional parameter to print the array after each swap to show the sorting process. **Function Signature**: ```python def bubble_sort(arr: list[int], simulation: bool = False) -> list[int]: pass ``` **Input**: - `arr` (list of int): The list of integers to be sorted. The length is between 0 and 1000. - `simulation` (bool): If set to `True`, print the array after each swap to demonstrate the sorting process. **Output**: - Returns a list of integers sorted in ascending order. **Examples**: ```python # Example 1 input_arr = [64, 34, 25, 12, 22, 11, 90] print(bubble_sort(input_arr)) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2 input_arr = [5, 1, 4, 2, 8] bubble_sort(input_arr, True) # Simulation Output: # iteration 1 : 1 5 4 2 8 # iteration 2 : 1 4 5 2 8 # iteration 3 : 1 4 2 5 8 # iteration 4 : 1 4 2 5 8 # iteration 5 : 1 2 4 5 8 ``` **Constraints**: - You must handle edge cases such as empty lists or already sorted lists efficiently. - You are not allowed to use Python’s built-in sorting function. **Performance**: - Ensure the function has a time complexity in O(N^2) and space complexity in O(1). **Additional Information**: - Feel free to write any helper functions where you see necessary. - The function should handle all integer values within the standard 32-bit integer range.","solution":"def bubble_sort(arr: list[int], simulation: bool = False) -> list[int]: Sorts the list of integers using the Bubble Sort algorithm. Optionally, it can simulate the sorting process by printing the array after each swap. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if simulation: print(f\'iteration {i * n + j + 1} : {arr}\') # If no two elements were swapped by inner loop, then break if not swapped: break return arr"},{"question":"# Question: Stooge Sort Implementation and Analysis You are tasked with implementing the Stooge Sort algorithm to help understand its operational steps and performance characteristics. Stooge Sort is a comparison-based recursive sorting algorithm known for its extremely high time complexity. While it is inefficient for practical use, it serves as a useful educational tool for learning about recursive sorting techniques. Function Specification **Function Name**: `stoogesort` **Inputs**: * `arr`: a list of integers `arr` which represents the array to sort. * `l`: an integer `l`, representing the starting index of the array (initially, this will be 0). * `h`: an integer `h`, representing the ending index of the array (initially, this will be `len(arr) - 1`). **Outputs**: * The function should sort the array `arr` in-place such that all elements are in increasing order. **Constraints**: * The array length can be up to 10^5, but the actual maximum length might need to be constrained to ensure feasible operations within practical runtime limits. **Performance Requirement**: * Due to its high complexity, the implementation should include sufficient commentary to explain the steps and expected inefficiency. Edge Cases to Handle * Arrays that are already sorted. * Arrays with all identical elements. * Arrays with a single element. Example Consider the following example for better understanding: Input: ```python arr = [5, 2, 9, 1, 5, 6] l = 0 h = 5 ``` Output: The array should be modified in-place to: ```python [1, 2, 5, 5, 6, 9] ``` # Scenario You are given an unsorted list of integers. Implement the Stooge Sort algorithm to sort this list. Write a function `stoogesort` that takes in a list and modifies it to be sorted in non-decreasing order. Ensure you handle various edge cases and provide comments explaining the performance characteristics of the algorithm. Additional Task As part of your solution, include an analysis of the algorithm’s performance in terms of time complexity. Provide insights into why Stooge Sort is not suitable for most practical purposes.","solution":"def stoogesort(arr, l, h): Sorts the array arr from index l to h using the Stooge Sort algorithm. if l >= h: return # Swap if the element at l is greater than the element at h if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than two elements in the array if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) # No return statement needed as we are modifying arr in place # Performance Analysis: # Stooge Sort is known for its extremely high time complexity. # The time complexity of Stooge Sort is O(n^(log 3 / log 1.5)) ≈ O(n^2.7095) # This makes it impractical for use on large datasets. Stooge Sort is primarily # considered as a theoretical and educational algorithm to demonstrate the # possibilities and limitations of recursive sorting."},{"question":"You are given a binary tree, and you need to determine the height of this tree. The height is defined as the number of edges on the longest path from the root to a leaf node. An empty tree has a height of 0, a tree with one node has a height of 1, and so on. # Function Signature ```python def height(root: \'Node\') -> int: ``` # Input - The root node of a binary tree. - `root` can be a `Node` object or `None`. # Output - An integer representing the height of the tree. # Example ```python # Given the tree: # 9 # / # 6 12 # / / # 3 8 10 15 # # 7 18 # The height of the tree is 4 root = <build the tree as described> assert height(root) == 4 ``` # Constraints - The number of nodes in the tree is between 0 and 10,000. - Node values are unique integers. # Notes - You should handle edge cases such as an empty tree and a single-node tree. - Make sure your implementation is optimized for performance and consider recursion limits for deeply unbalanced trees. # Test Cases 1. An empty tree: ```python assert height(None) == 0 ``` 2. A single-node tree: ```python # Tree: 1 root = Node(1) assert height(root) == 1 ``` 3. A balanced tree: ```python # Tree: # 1 # / # 2 3 # / # 4 5 root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) assert height(root) == 3 ``` 4. An unbalanced tree: ```python # Tree: # 1 # # 2 # # 3 root = Node(1) root.right = Node(2) root.right.right = Node(3) assert height(root) == 3 ``` Ensure your function passes the provided test cases, and feel free to add more test cases to verify its correctness thoroughly.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def height(root): if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"You are a burglar looking to maximize your loot from a series of houses. Each house contains different amounts of money and has a different security level that affects how many houses you can rob consecutively. Design an algorithm based on the 0/1 Knapsack problem to solve the following task: * Write a function named `maximize_loot` that takes a list of tuples representing each house, where the first element in each tuple represents the amount of money in the house, and the second element represents the security level (number of houses you cannot rob consecutively after robbing this house), and an integer representing the maximum number of houses you can rob consecutively. * The function should return the maximum amount of money you can rob without exceeding the security constraints. Function Signature ```python def maximize_loot(houses: List[Tuple[int, int]], max_consecutive: int) -> int: pass ``` # Input * `houses`: A list of tuples where each tuple consists of two integers. The first integer is the amount of money in the house, and the second integer is the security level (1 <= len(houses) <= 1000, 0 <= money <= 1000, 1 <= security level <= len(houses)). * `max_consecutive`: An integer (0 <= max_consecutive <= len(houses)) denoting the maximum number of houses you can rob consecutively. # Output * Return an integer representing the maximum amount of money that can be looted without triggering the security systems. # Constraints 1. Each house can be robbed only once. 2. Security levels must be respected in the looting pattern. # Example ```python assert maximize_loot([(6, 2), (7, 1), (1, 5), (4, 3)], 2) == 13 ``` Explanation: * Robbing house 1 and house 2 yields the maximum loot of 13 without violating the security constraints. # Performance Requirements * Aim for a solution with a time complexity not exceeding (O(n cdot m)), where (n) is the total number of houses and (m) is the maximum number of consecutive houses that can be robbed.","solution":"from typing import List, Tuple def maximize_loot(houses: List[Tuple[int, int]], max_consecutive: int) -> int: n = len(houses) dp = [[0] * (max_consecutive + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(max_consecutive + 1): not_rob = dp[i-1][j] rob = 0 if j > 0: rob = houses[i-1][0] + dp[i-1][j-1] next_i = i + houses[i-1][1] if next_i <= n: dp[i][j] = max(dp[i][j], rob, not_rob) else: dp[i][j] = max(dp[i][j], rob, not_rob) else: dp[i][j] = not_rob return max(dp[n])"},{"question":"You are given a `NxM` character board and a list of words. Your task is to implement a function `find_words` that returns a list of words that can be found in the board. Each word can be constructed from letters of sequentially adjacent cells (horizontally or vertically). You may not use the same letter cell more than once for a single word. **Function Signature**: ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: ``` Input: - `board`: A list of lists of lowercase alphabets, (1 leq N, M leq 12). - `words`: A list of strings where each string has a length of at least once character and no more than 10 characters. Each string consists of lowercase alphabets. Output: - A list of strings representing the words found in the board. Constraints: - All given words are assumed to be in lowercase, and the board consists of lowercase alphabets only. Performance: - Your solution should efficiently handle the board size up to 12x12 and a word list with up to 1000 words. Example: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] # Expected Output: [\\"eat\\", \\"oath\\"] print(find_words(board, words)) ``` Hints: - Consider using a Trie for optimizing the prefix search. - Use backtracking to explore all potential word paths on the board. - Ensure you mark cells as visited appropriately to avoid revisiting during the same word search. Good luck!","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, prefix: str): node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node def find_words(board: List[List[str]], words: List[str]) -> List[str]: def dfs(node, i, j, path): if node.is_end_of_word: found_words.add(path) if not (0 <= i < len(board)) or not (0 <= j < len(board[0])): return temp = board[i][j] if temp not in node.children: return board[i][j] = \\"#\\" for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]: dfs(node.children[temp], x, y, path + temp) board[i][j] = temp trie = Trie() for word in words: trie.insert(word) found_words = set() for i in range(len(board)): for j in range(len(board[i])): if board[i][j] in trie.root.children: dfs(trie.root, i, j, \\"\\") return list(found_words)"},{"question":"**Problem Scenario**: Let\'s consider a scenario where you are attempting to implement a sorting algorithm that improves upon the classic bubble sort. Your task is to implement the `comb_sort` function, which uses a gap shrinking approach to sort a list of integers in ascending order. **Task**: Write a function `comb_sort` that sorts a list of integers using the Comb Sort algorithm. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - A list of integers `arr` with length `n` where ( 1 leq n leq 1000 ). **Output**: - Returns the same list `arr` sorted in ascending order. **Constraints**: - Do not use Python\'s built-in sort functions. - Ensure the solution has an average-case time complexity of O(N log N). - Optimize for in-place sorting. **Example**: ```python # Example 1 input: [34, 8, 64, 51, 32, 21] output: [8, 21, 32, 34, 51, 64] # Example 2 input: [5, 4, 3, 2, 1] output: [1, 2, 3, 4, 5] # Edge Case Example input: [1, 3, 2, 3, 3, 5, 1] output: [1, 1, 2, 3, 3, 3, 5] ``` **Hints**: - Utilize a shrink factor of 1.3. - Simplify the swapping logic by using a helper function. - Test on arrays that contain duplicate elements, already sorted arrays, and arrays in reverse order to ensure robustness.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor of 1.3 gap = (gap * 10) // 13 return max(int(gap), 1) # Ensure the minimum gap is 1 n = len(arr) gap = n swapped = True # Continue sort until gap reduces to 1 and no more swaps while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Scenario Imagine you are an avid hiker, constantly exploring new trails. One of your challenges is to calculate in how many distinct ways you can climb a certain number of steps on a staircase. Given that each time you can either take a single step or two steps, you want to have a program that quickly computes the number of ways to reach the top of the staircase based on the number of steps. # The Problem Write a function `distinct_ways_to_climb` that calculates the number of distinct ways to reach the top of a staircase with `n` steps. # Function Signature ```python def distinct_ways_to_climb(n: int) -> int: pass ``` # Input - `n` (integer, 1 ≤ n ≤ 10^5): The number of steps to reach the top of the staircase. # Output - Returns an integer representing the number of distinct ways to reach the top. # Constraints - You must ensure your solution runs in O(n) time. - You must optimize your space usage ideally to O(1). # Example ```python assert distinct_ways_to_climb(2) == 2 # (1+1) or (2) assert distinct_ways_to_climb(3) == 3 # (1+1+1), (1+2), or (2+1) assert distinct_ways_to_climb(5) == 8 ``` # Performance Requirements Your solution should handle inputs up to 10^5 steps efficiently in terms of both time and space complexity. # Note - The problem can be likened to calculating the n-th Fibonacci number but shifted by starting values of `fib(1) == 1` and `fib(2) == 2`.","solution":"def distinct_ways_to_climb(n: int) -> int: Returns the number of distinct ways to reach the top of a staircase with n steps, where you can either take a single step or two steps at a time. :param n: The number of steps to reach the top of the staircase :type n: int :return: The number of distinct ways to reach the top :rtype: int if n == 1: return 1 elif n == 2: return 2 a, b = 1, 2 for i in range(3, n + 1): a, b = b, a + b return b"},{"question":"# Context You are working on a text-processing application where a certain task requires you to determine how many times a pattern needs to be repeated such that another pattern becomes part of it. This is crucial in various scenarios like DNA sequence matching, file searching, and more. # Task Write a function `repeat_string` that takes two input strings A and B, and returns the minimum number of times A has to be repeated such that B becomes a substring of the repeated string A. If there is no such solution, return -1. # Input * Two strings A and B. * Both strings will have lengths between 1 and 10000. # Output * An integer representing the minimum number of repetitions of A required for B to become a substring of it. If no such solution exists, return -1. # Function Signature ```python def repeat_string(A: str, B: str) -> int: pass ``` # Constraints * Perform the solution with respect to time and space complexity considerations. * Avoid unnecessary concatenation to improve performance where possible. # Example ```python # Example 1 A = \\"abcd\\" B = \\"cdabcdab\\" print(repeat_string(A, B)) # Output: 3 # Example 2 A = \\"a\\" B = \\"aa\\" print(repeat_string(A, B)) # Output: 2 # Example 3 A = \\"abc\\" B = \\"cabcabca\\" print(repeat_string(A, B)) # Output: 4 # Example 4 A = \\"xyz\\" B = \\"xyxy\\" print(repeat_string(A, B)) # Output: -1 ``` # Notes * The first example repeats \\"abcd\\" 3 times to get \\"abcdabcdabcd\\" where \\"cdabcdab\\" is a substring. * Be mindful of performance and edge cases where B is significantly longer than A.","solution":"def repeat_string(A: str, B: str) -> int: repetitions = (len(B) // len(A)) + 2 repeated_A = A * repetitions if B in repeated_A: for i in range(1, repetitions + 1): if B in A * i: return i return -1"},{"question":"# Question Implement a function that rotates a singly-linked list to the right by k places. The function should not create new nodes but modify the existing list in-place and ensure the operations are efficient. Here is an example to illustrate the desired functionality: Given a list represented as 1->2->3->4->5 and k = 2, the rotated list should be 4->5->1->2->3. Function Signature ```python class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: pass ``` Input - head (ListNode): The head of the singly-linked list. - k (int): The number of positions to rotate the list to the right. k is a non-negative integer. Output - ListNode: The head of the rotated singly-linked list. Constraints - Do not use any extra space other than a few pointers. - The list nodes should be modified in-place. Example ```python # Example 1 # Input: [1->2->3->4->5], k = 2 # Output: [4->5->1->2->3] # Example 2 # Input: [0->1->2], k = 4 # Output: [2->0->1] ``` # Notes - You need to handle edge cases such as when the list is empty, has only one element, or k is 0. - The value of k can be larger than the length of the list, and you need to account for this efficiently.","solution":"# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Compute the length of the list and locate the last node length = 1 last_node = head while last_node.next: last_node = last_node.next length += 1 # Find the effective number of rotations needed k = k % length if k == 0: return head # Find the new tail: length - k - 1 node steps_to_new_tail = length - k - 1 new_tail = head for _ in range(steps_to_new_tail): new_tail = new_tail.next # Perform the rotation new_head = new_tail.next new_tail.next = None last_node.next = head return new_head"},{"question":"# Question: Implement a More Efficient Sorting Algorithm Context: After understanding the extremely inefficient Bogo Sort algorithm, it becomes clear that practical applications need more efficient sorting solutions. One of the classic and efficient sorting algorithms is **Quicksort**. Task: Implement the Quicksort algorithm in Python. Given a list of integers, your function should sort the list in ascending order using the Quicksort algorithm. Function Signature: ```python def quicksort(arr: list) -> list: Sorts the input list using the Quicksort algorithm. Params: arr (list of int): The list of integers to be sorted. Returns: list of int: A new list containing the sorted integers. pass ``` Description: - Your function should take a list of integers as input and return a new list with the integers sorted in ascending order. - Quicksort algorithm: 1. Select a \'pivot\' element from the array. 2. Partition the other elements into two sub-arrays: one with elements less than or equal to the pivot and the other with elements greater than the pivot. 3. Recursively apply the same logic to the sub-arrays. 4. Combine the sorted sub-arrays and the pivot to form the sorted list. Input: - A list of integers containing ( n ) elements where ( 1 leq n leq 10^4 ). Output: - A new list containing the sorted integers. Constraints: - Assume the integers in the list can be both positive and negative. - The function should handle duplicate values correctly. Example: ```python print(quicksort([3, 6, 8, 10, 1, 2, 1])) # Expected output: [1, 1, 2, 3, 6, 8, 10] print(quicksort([10, 7, 8, 9, 1, 5])) # Expected output: [1, 5, 7, 8, 9, 10] ```","solution":"def quicksort(arr: list) -> list: Sorts the input list using the Quicksort algorithm. Params: arr (list of int): The list of integers to be sorted. Returns: list of int: A new list containing the sorted integers. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] lesser = [x for x in arr if x < pivot] equal = [x for x in arr if x == pivot] greater = [x for x in arr if x > pivot] return quicksort(lesser) + equal + quicksort(greater)"},{"question":"# Matrix Exponentiation by Squaring # Context Matrix exponentiation is an important technique with various applications in algorithms, such as in graph theory and cryptography. Implementing it efficiently can save a significant amount of computational resources. # Task You are required to implement a function that calculates the power of a given square matrix using the technique of repeated squaring. Your implementation should focus on optimizing both time and space complexity. # Function Signature ```python def matrix_power(mat: list, power: int) -> list: Raises the square matrix `mat` to the power `power`. Parameters: mat (list of list of int): A square matrix of dimensions d x d. power (int): The exponent to which the matrix should be raised. Returns: list of list of int: The matrix mat raised to the power `power`. Constraints: - The matrix `mat` will be of dimensions d x d where 1 <= d <= 20. - The exponent `power` will be a non-negative integer such that 0 <= power <= 10^9. ``` # Input - A square matrix `mat` of dimensions `d x d`. - An integer `power` representing the exponent. # Output - The matrix `mat` raised to the power `power`. # Constraints - The matrix `mat` will be of dimensions `1 <= d <= 20`. - The exponent `power` will be a non-negative integer such that `0 <= power <= 10^9`. # Example ```python mat = [ [1, 2], [3, 4] ] power = 2 # Example function call result = matrix_power(mat, power) print(result) # Expected Output: # [ # [7, 10], # [15, 22] # ] ``` # Notes - Carefully handle edge cases such as raising a matrix to the power of zero. - Ensure your solution is optimized for large values of `power`.","solution":"def matrix_multiply(A, B): Multiplies two square matrices A and B. n = len(A) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[i][j] = sum(A[i][k] * B[k][j] for k in range(n)) return result def matrix_power(mat, power): Raises the square matrix `mat` to the power `power` using exponentiation by squaring. n = len(mat) # Identity matrix of size n def identity_matrix(n): return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def power_helper(mat, power): if power == 0: return identity_matrix(n) elif power == 1: return mat else: half = power_helper(mat, power // 2) half_square = matrix_multiply(half, half) return matrix_multiply(half_square, mat) if power % 2 else half_square return power_helper(mat, power)"},{"question":"**Context:** You are part of a team developing a system that takes in stacks of data and ensures that they adhere to a specified order for correctness in further data processing tasks. One of the critical functionalities within this system is the requirement to validate whether a given stack of numerical data is sorted in ascending order from the bottom to the top. **Task:** Write a function `is_sorted(stack)` that takes a stack (a list in Python representing a stack where the end of the list is the top of the stack) as an input and returns `True` if the elements in the stack are sorted in ascending order from bottom (beginning of the list) to top (end of the list), and `False` otherwise. # Input: * A stack of integers `stack` where the bottom of the stack is the beginning of the list, and the top of the stack is the end of the list. # Output: * A boolean `True` if the stack elements are in ascending order from bottom to top, otherwise `False`. # Example: ```python stack1 = [1, 2, 3, 4, 5, 6] print(is_sorted(stack1)) # Output: True stack2 = [6, 3, 5, 1, 2, 4] print(is_sorted(stack2)) # Output: False ``` # Constraints: * The stack can contain zero or more elements. * The elements in the stack are integers and can be both positive and negative. * The implementation should be efficient in terms of time and space complexity. # Performance Requirements: * Optimize for O(n) time complexity and minimal auxiliary space. **Requirements:** * Ensure that the stack remains unaltered after the function execution. * Consider edge cases such as an empty stack, stack with one element, and stacks with duplicates.","solution":"def is_sorted(stack): Checks if the given stack is sorted in ascending order from bottom to top. :param stack: List of integers representing a stack. :return: True if the stack is sorted in ascending order, False otherwise. for i in range(1, len(stack)): if stack[i-1] > stack[i]: return False return True"},{"question":"Context You have been tasked with sorting a list of integers using a simple sorting algorithm for educational purposes. Your goal is to compare and swap elements to ensure the list is sorted in ascending order. Objective Using the Exchange Sort algorithm, implement a function that sorts a given list of integers in ascending order. Function Signature ```python def sort_integers(arr: List[int]) -> List[int]: ``` Input - `arr` (List[int]): A list of integers that needs to be sorted. Output - A sorted list of integers in ascending order. Constraints - 1 <= len(arr) <= 1000 (The length of the list will not exceed 1000). - -10^9 <= arr[i] <= 10^9 (Each integer in the list will range between -10^9 and 10^9). # Performance Requirements - Your implementation should have a time complexity of O(n^2) due to the nature of Exchange Sort. - Attempt to reduce unnecessary comparisons where possible. # Example ```python assert sort_integers([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert sort_integers([3, -1, -14, 17, 90]) == [-14, -1, 3, 17, 90] assert sort_integers([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] ``` # Important Considerations - Consider all edge cases mentioned in the analysis. - Ensure your function doesn\'t produce errors with edge cases like an already sorted list or a list with all identical elements. - Keep in mind that Exchange Sort is not stable, but that shouldn\'t affect the output for this task.","solution":"from typing import List def sort_integers(arr: List[int]) -> List[int]: Sort a list of integers in ascending order using the Exchange Sort algorithm. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[j] < arr[i]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Prime Number Range Finder Background In various applications, such as cryptography and numerical analysis, determining the prime numbers within a given range is essential. You\'ve identified that having an efficient algorithm that can verify the primality of a number is a crucial component of such tasks. Problem Statement Write a function `find_primes_in_range(start, end)` that takes two integers `start` and `end` inclusive, and returns a list of all prime numbers within that range. Function Signature ```python def find_primes_in_range(start: int, end: int) -> List[int]: pass ``` Input * `start` (integer): The beginning of the range. * `end` (integer): The end of the range. Output * List of integers representing the prime numbers in the given range `[start, end]`. Constraints * `1 <= start <= end <= 10^6` Performance Requirements The function should efficiently handle the upper constraint limits within reasonable time frames. Consider optimizing primality testing within the given range. Example ```python assert find_primes_in_range(10, 30) == [11, 13, 17, 19, 23, 29] assert find_primes_in_range(1, 10) == [2, 3, 5, 7] ``` **Note:** The provided prime checking function `prime_check(n)` can be an effective helper function for your implementation. Ensure your solution handles the edge cases effectively and optimizes for performance where possible.","solution":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primes_in_range(start: int, end: int) -> List[int]: Find all prime numbers in the given range [start, end]. primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) return primes"},{"question":"ZigZag Iterator for Three Lists You are required to implement a ZigZag Iterator for three lists. The iterator should alternate elements from the three lists until all elements are exhausted. If one list is exhausted, it should continue to alternate between the remaining lists. # Implementation Details Implement the `ZigZagIteratorThree` class with the following methods: * `__init__(self, v1: List[int], v2: List[int], v3: List[int]) -> None`: This initializes the iterator with three lists. * `next(self) -> int`: This returns the next element in the iteration. * `has_next(self) -> bool`: This returns `True` if there are still elements available to iterator; otherwise, returns `False`. # Constraints 1. All input lists will be lists of integers. 2. The input lists can be of different lengths, including one or more potentially being empty. # Example: ```python l1 = [1, 2, 3] l2 = [4, 5, 6, 7] l3 = [8, 9] it = ZigZagIteratorThree(l1, l2, l3) result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Deliverables 1. A complete implementation of the `ZigZagIteratorThree` class. 2. Code that passes the example and additional test cases demonstrating the iterator\'s correct behavior under various scenarios.","solution":"from collections import deque from typing import List, Optional class ZigZagIteratorThree: def __init__(self, v1: List[int], v2: List[int], v3: List[int]) -> None: self.queue = deque() if v1: self.queue.append(deque(v1)) if v2: self.queue.append(deque(v2)) if v3: self.queue.append(deque(v3)) def next(self) -> int: if self.has_next(): curr_list = self.queue.popleft() next_val = curr_list.popleft() if curr_list: self.queue.append(curr_list) return next_val else: raise StopIteration(\\"No more elements to iterate over\\") def has_next(self) -> bool: return bool(self.queue)"},{"question":"Huffman Coding Challenge Huffman Coding is a popular algorithm used for lossless data compression. Your task is to implement both the encoding and decoding functions for Huffman Coding. Given a file, your function should be able to read the file, compress it using the Huffman Coding algorithm, and save the compressed data to a new file. Similarly, it should be able to read a compressed file, decode it, and save the original data to a new file. # Input Format - **Function `encode_file(file_in_name: str, file_out_name: str)`:** - `file_in_name` - Name of the input file to be encoded. - `file_out_name` - Name of the output file where encoded data will be saved. - **Function `decode_file(file_in_name: str, file_out_name: str)`:** - `file_in_name` - Name of the input file to be decoded. - `file_out_name` - Name of the output file where decoded data will be saved. # Output Format - The encoded and decoded files should be saved with appropriate names provided as arguments. # Constraints - The input files contain binary data. - The output files should correctly represent the encoded/decoded binary data. - Efficiently handle large files. # Scenario You are working on a project where you need to compress and decompress large archives of multimedia files. Implement the Huffman Coding to achieve this and ensure that the resulting compression is efficient and lossless. # Example ```python # To encode a file encode_file(\'input_file.txt\', \'encoded_file.txt\') # To decode the file decode_file(\'encoded_file.txt\', \'decoded_file.txt\') ``` The student should write the required functions to perform the Huffman Coding for both encoding and decoding of files.","solution":"import heapq from collections import defaultdict, Counter class HuffmanNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def build_huffman_tree(text): frequency = Counter(text) priority_queue = [HuffmanNode(char, freq) for char, freq in frequency.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: node1 = heapq.heappop(priority_queue) node2 = heapq.heappop(priority_queue) merged = HuffmanNode(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(priority_queue, merged) return priority_queue[0] def build_codes(node, prefix=\\"\\", code_map={}): if node is None: return if node.char is not None: code_map[node.char] = prefix else: build_codes(node.left, prefix + \\"0\\", code_map) build_codes(node.right, prefix + \\"1\\", code_map) return code_map def huffman_encode(text): tree = build_huffman_tree(text) huffman_codes = build_codes(tree) encoded_text = \'\'.join([huffman_codes[char] for char in text]) return encoded_text, tree def huffman_decode(encoded_text, tree): decoded_text = [] node = tree for bit in encoded_text: if bit == \'0\': node = node.left else: node = node.right if node.char is not None: decoded_text.append(node.char) node = tree return \'\'.join(decoded_text) def encode_file(file_in_name, file_out_name): with open(file_in_name, \'r\') as file: text = file.read() encoded_text, tree = huffman_encode(text) with open(file_out_name, \'w\') as file: file.write(encoded_text) return tree def decode_file(file_in_name, file_out_name, tree): with open(file_in_name, \'r\') as file: encoded_text = file.read() decoded_text = huffman_decode(encoded_text, tree) with open(file_out_name, \'w\') as file: file.write(decoded_text)"},{"question":"# Problem: Find the Unique Element You have been given an array of integers where each integer appears an even number of times, except for one integer that appears an odd number of times. Your task is to implement a function that finds that single odd-occurrenace integer. The solution should be efficient and use no extra memory aside from a few variables. Please implement the function `find_unique_number(nums)` that satisfies the following requirements: Requirements: 1. **Function Signature**: `def find_unique_number(nums: List[int]) -> int:` 2. **Input**: - A list of integers `nums` containing n elements. - Constraints: `1 <= n <= 10^5` 3. **Output**: - An integer representing the single number that appears an odd number of times in the array. If there is no odd-appearance number, you may assume the return value to be 0. 4. **Performance**: - Time Complexity: The solution should run in O(n). - Space Complexity: The solution should use O(1) additional space. Example: ```python nums = [2, 2, 1, 1, 4] assert find_unique_number(nums) == 4 nums = [4, 3, 4, 2, 2, 3, 5] assert find_unique_number(nums) == 5 nums = [7, 7, 8, 8] assert find_unique_number(nums) == 0 # no single appearing number ``` Notes: - **Edge Cases**: - Consider an empty array. - Consider arrays where every element appears exactly twice, hence no single appearance. - **Assumption**: - The array will contain at most one integer appearing an odd number of times. Your task is to ensure you pass these edge cases and constraints efficiently.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: Finds the single number that appears an odd number of times in the array. If no such number exists, returns 0. unique = 0 for num in nums: unique ^= num return unique"},{"question":"Context: You are designing a code editor\'s new feature that highlights syntax errors in real-time. One essential part of this feature ensures all brackets (parentheses, square brackets, and braces) in the code are correctly matched and nested. As part of the validation process, you need to write a function that determines the validity of a sequence of brackets. Problem Statement: Write a function `is_valid_sequence(s: str) -> bool` that takes a string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and returns a boolean value indicating whether the input string is a valid sequence of brackets. Input: - A single string `s` containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Output: - A boolean value: - `True` if the string is a valid bracket sequence (all brackets are closed correctly and in the correct order). - `False` otherwise. Constraints: - The length of the input string is in the range [0, 10^4]. Examples: 1. `is_valid_sequence(\\"()\\")` should return `True`. 2. `is_valid_sequence(\\"()[]{}\\")` should return `True`. 3. `is_valid_sequence(\\"(]\\")` should return `False`. 4. `is_valid_sequence(\\"([)]\\")` should return `False`. 5. `is_valid_sequence(\\"{[]}\\")` should return `True`. # Task: Implement the function `is_valid_sequence` in Python. Ensure your solution is efficient and handles all edge cases. Note: - You are not allowed to use any import statements. - You should not use any built-in string functions that solve the problem directly.","solution":"def is_valid_sequence(s: str) -> bool: Determines if the input string is a valid sequence of brackets. :param s: str - input string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' :return: bool - True if the string is a valid bracket sequence, False otherwise stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map.values(): # if it\'s an opening bracket stack.append(char) elif char in bracket_map: # if it\'s a closing bracket if stack and stack[-1] == bracket_map[char]: stack.pop() else: return False else: # In case the input contains characters other than the specified brackets return False return not stack"},{"question":"# **Min Heap Implementation Challenge** Urban City is implementing a priority-based task scheduling system using a min-heap structure to always execute the minimum priority task first. You have been asked to implement this system using a min-heap by creating a class `MinHeap` with the methods specified. **Requirements** 1. **Class Definition**: Implement the `MinHeap` class. 2. **Methods**: - `insert(self, val: int)`: - Inserts `val` into the heap. - Time Complexity: O(log N). - `remove_min(self) -> int`: - Removes and returns the minimum element from the heap. - Time Complexity: O(log N). **Function Signatures** ```python class MinHeap: def __init__(self): self.heap = [0] def insert(self, val: int): # Implement insert method here def remove_min(self) -> int: # Implement remove_min method here def _perc_up(self, i: int): # Helper method for insert def _perc_down(self, i: int): # Helper method for remove_min def _min_child(self, i: int) -> int: # Helper method to get index of min child ``` # **Constraints/Notes** - The heap should be maintained using a list. - The class should start with an empty heap `[0]`. - Ensure that the heap property is maintained at all times. **Example Usage** ```python heap = MinHeap() heap.insert(10) heap.insert(5) heap.insert(30) print(heap.remove_min()) # Expected output: 5 print(heap.remove_min()) # Expected output: 10 heap.insert(2) print(heap.remove_min()) # Expected output: 2 ``` Use the methods `insert`, `remove_min`, `_perc_up`, `_perc_down`, and `_min_child` to maintain the heap properties as described. **Scenario**: Imagine you are managing a city\'s tasks where each task has a priority number. Lower priority numbers are more urgent. The `MinHeap` implementation will help you always find and execute the most urgent task efficiently. Good luck!","solution":"class MinHeap: def __init__(self): self.heap = [0] def insert(self, val: int): self.heap.append(val) self._perc_up(len(self.heap) - 1) def remove_min(self) -> int: if len(self.heap) == 1: return None # No elements in heap root = self.heap[1] self.heap[1] = self.heap[-1] self.heap.pop() if len(self.heap) > 1: self._perc_down(1) return root def _perc_up(self, i: int): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def _perc_down(self, i: int): while (i * 2) < len(self.heap): min_child = self._min_child(i) if self.heap[i] > self.heap[min_child]: self.heap[i], self.heap[min_child] = self.heap[min_child], self.heap[i] i = min_child def _min_child(self, i: int) -> int: if (i * 2 + 1) > (len(self.heap) - 1): return i * 2 else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1"},{"question":"# Bogo Sort Analysis and Enhancement As a novice algorithm designer, you are tasked with analyzing the Bogo Sort algorithm provided and suggesting enhancements for practical use. Although the Bogo Sort algorithm is theoretically interesting, it is impractical for any substantial application due to its inefficiency. Your task is to write a program that: 1. Evaluates the effectiveness of the Bogo Sort algorithm on different array sizes. 2. Enhances the given Bogo Sort code to cede control to a more efficient sorting algorithm after a certain number of failed attempts or iterations. # Function Signature ```python def enhanced_bogo_sort(arr: list, max_attempts: int) -> list: Sorts the given array using Bogo Sort to a limited extent, switching to another sorting algorithm if max_attempts is exhausted. Parameters: arr (list): List of integers to be sorted. max_attempts (int): Maximum number of shuffling attempts before switching to a fallback sorting algorithm. Returns: list: Sorted list of integers. ``` # Input * A list `arr` of integers (1 <= len(arr) <= 1000). Each integer is within the range -10^6 <= arr[i] <= 10^6. * An integer `max_attempts` (1 <= max_attempts <= 1000) representing the number of shuffling attempts before switching to a more efficient sorting algorithm. # Output * A sorted list of integers in ascending order. # Constraints * Consider performance when choosing the fallback sorting algorithm. The use of Python\'s built-in `sorted()` function is allowed. # Example ```python print(enhanced_bogo_sort([3, 2, 1], 10)) # Output: [1, 2, 3] print(enhanced_bogo_sort([3, 2, 1], 1)) # Output: [1, 2, 3] ``` # Explanation 1. Implement the Bogo Sort algorithm up to `max_attempts` iterations. 2. If the array is not sorted within `max_attempts` iterations, switch to an alternate efficient sorting algorithm to complete the task. # Requirements 1. Ensure your code properly switches to a more efficient sorting algorithm after the specified number of attempts. 2. Clearly document your code, explaining your design decisions. # Note The goal is to demonstrate understanding of algorithm efficiency constraints and the necessity of algorithm selection in practical scenarios.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def bogo_sort(arr): Performs a single attempt of Bogo Sort by shuffling. random.shuffle(arr) return arr def enhanced_bogo_sort(arr, max_attempts): Sorts the given array using Bogo Sort up to a limited extent, switching to another sorting algorithm if max_attempts is exhausted. Parameters: arr (list): List of integers to be sorted. max_attempts (int): Maximum number of shuffling attempts before switching to a fallback sorting algorithm. Returns: list: Sorted list of integers. attempts = 0 while not is_sorted(arr) and attempts < max_attempts: arr = bogo_sort(arr) attempts += 1 if is_sorted(arr): return arr else: # Switch to a more efficient sorting algorithm. return sorted(arr)"},{"question":"You are given the definition of a binary tree node and an in-order traversal implementation (both iterative and recursive). Your task is to extend the provided in-order traversal functionality with a post-order traversal method in both iterative and recursive manners. # Detailed Requirements 1. **Node Definition**: Do not modify the given `Node` class. 2. **Post-order Traversal (Recursive)**: - Implement the function `postorder_rec(root, res=None)`. - **Input**: The root of a binary tree (Node). - **Output**: A list of node values in post-order traversal. 3. **Post-order Traversal (Iterative)**: - Implement the function `postorder(root)`. - **Input**: The root of a binary tree (Node). - **Output**: A list of node values in post-order traversal. 4. Write your solution as complete functions without the need to include additional import statements. # Function Signatures ```python def postorder_rec(root: Node, res: list = None) -> list: pass def postorder(root: Node) -> list: pass ``` **Example Input** ```python n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 ``` **Example Output** ``` postorder_rec(n1) should return [25, 75, 50, 125, 175, 150, 100] postorder(n1) should return the same list [25, 75, 50, 125, 175, 150, 100] ``` # Constraints 1. Ensure your solution handles edge cases like empty trees and single-node trees. 2. Optimize where possible to avoid excessive space usage. 3. The tree nodes values are distinct integers.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def postorder_rec(root, res=None): if res is None: res = [] if root: postorder_rec(root.left, res) postorder_rec(root.right, res) res.append(root.val) return res def postorder(root): if root is None: return [] result = [] stack = [(root, False)] while stack: node, visited = stack.pop() if node: if visited: result.append(node.val) else: stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return result"},{"question":"Run-Length Encoding and Decoding # Scenario You are working as a software developer in a data storage company. Your task is to enhance the company\'s storage efficiency by implementing a Run-Length Encoding (RLE) algorithm, which is a form of lossless data compression. With RLE, you convert data streams into a sequence of counts and values, allowing redundancy to be minimized. # Question Implement a Python function `rle_operations(operation, data)` that applies Run-Length Encoding or Decoding based on the specified operation. The function should: * `operation` (string): Mode of operation. It can be either \\"encode\\" or \\"decode\\". * `data` (string): The data to be encoded or decoded based on the operation specified. # Function Signature ```python def rle_operations(operation: str, data: str) -> str: # Your code here ``` # Input Constraints - `operation` will always be a string and one of [\\"encode\\", \\"decode\\"]. - `data` is a string of any printable ASCII characters. # Expected Output - If `operation` is \\"encode\\", return the RLE encoded version of `data`. - If `operation` is \\"decode\\", return the RLE decoded version of `data`. # Example ```python assert rle_operations(\\"encode\\", \\"aaabbccaaa\\") == \\"3a2b2c3a\\" assert rle_operations(\\"decode\\", \\"3a2b2c3a\\") == \\"aaabbccaaa\\" assert rle_operations(\\"encode\\", \\"\\") == \\"\\" assert rle_operations(\\"decode\\", \\"\\") == \\"\\" ``` # Performance Requirements - The function should be able to handle strings of length up to 10^6 efficiently.","solution":"def rle_operations(operation: str, data: str) -> str: if operation == \\"encode\\": return rle_encode(data) elif operation == \\"decode\\": return rle_decode(data) else: raise ValueError(\\"Unknown operation. Use \'encode\' or \'decode\'.\\") def rle_encode(data: str) -> str: if not data: return \\"\\" encoded_str = [] count = 1 prev_char = data[0] for char in data[1:]: if char == prev_char: count += 1 else: encoded_str.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char encoded_str.append(f\\"{count}{prev_char}\\") return \'\'.join(encoded_str) def rle_decode(data: str) -> str: if not data: return \\"\\" decoded_str = [] count = \'\' for char in data: if char.isdigit(): count += char else: decoded_str.append(char * int(count)) count = \'\' return \'\'.join(decoded_str)"},{"question":"# Words Filtering by Symbols You are given two lists: `words` and `symbols`. Your task is to transform the given words by surrounding any substring that matches a symbol with square brackets. If a word matches more than one symbol, choose the one with the longest length. If there are multiple symbols of the same length, choose any. # Input - `words`: A list of strings containing the words. - `symbols`: A list of strings containing the symbols. # Output - Return a list of transformed words. # Constraints - The length of `words` will not exceed 1000. - The length of `symbols` will not exceed 100. - The length of each word and symbol will not exceed 100. - All words and symbols are lowercase English letters. # Example ```python words = [\'amazon\', \'microsoft\', \'google\'] symbols = [\'i\', \'am\', \'cro\', \'na\', \'le\', \'abc\'] Output: [\'[am]azon\', \'mi[cro]soft\', \'goog[le]\'] ``` # Requirements 1. Design an efficient algorithm that makes use of an appropriate data structure to handle the following: - Avoid unnecessary re-computation. - Ensure the longest matching symbol is chosen. 2. Implement the algorithm in Python. 3. Ensure your solution handles edge cases such as no matches and multiple matches correctly. # Function Signature ```python def filter_words_by_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Notes - Consider using advanced data structures such as Trie to optimize the search process. - Pay attention to edge cases and test your implementation thoroughly.","solution":"def filter_words_by_symbols(words, symbols): def find_longest_match(word, symbols): longest_symbol = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(longest_symbol): longest_symbol = symbol return longest_symbol transformed_words = [] for word in words: longest_symbol = find_longest_match(word, symbols) if longest_symbol: word = word.replace(longest_symbol, f\\"[{longest_symbol}]\\") transformed_words.append(word) return transformed_words"},{"question":"In number theory, a self-descriptive power sum number is a number in which the sum of its digits raised to consecutive powers equals the number itself. For example, 89 is a self-descriptive power sum number because (8^1 + 9^2 = 89), and 135 is another such number since (1^1 + 3^2 + 5^3 = 135). Your task is to implement a function `find_self_descriptive_numbers` that takes two integers, `low` and `high`, as input and returns a list of all self-descriptive power sum numbers within that inclusive range. # Function Signature ```python def find_self_descriptive_numbers(low: int, high: int) -> List[int]: pass ``` # Input * `low` (1 ≤ `low` ≤ 10^6): An integer representing the lower bound of the range. * `high` (`low` ≤ `high` ≤ 10^6): An integer representing the upper bound of the range. # Output * A list of integers representing self-descriptive power sum numbers within the provided range `[low, high]`. # Performance Requirements * Ensure that your implementation is efficient enough to handle the given constraints within a reasonable time frame. # Example ```python assert find_self_descriptive_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_self_descriptive_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert find_self_descriptive_numbers(50, 150) == [89, 135] ``` # Constraints * The function should handle numbers within the range `[1, 10^6]`. * The function should be optimized for performance.","solution":"from typing import List def is_self_descriptive_number(n: int) -> bool: Checks if a number is a self-descriptive power sum number. digits = [int(d) for d in str(n)] power_sum = sum(digit ** (i + 1) for i, digit in enumerate(digits)) return power_sum == n def find_self_descriptive_numbers(low: int, high: int) -> List[int]: Returns a list of self-descriptive power sum numbers in the range [low, high]. return [num for num in range(low, high + 1) if is_self_descriptive_number(num)]"},{"question":"# Question: Implement Pancake Sort in Python Description: You are given an array of integers, and you need to sort it using the Pancake Sort algorithm. The Pancake Sort uses a combination of array reversals to sort the array. Here\'s how the algorithm works: 1. Find the maximum element in the unsorted portion of the array. 2. Reverse array elements from the start to this maximum element index. 3. Reverse the entire unsorted portion to move the maximum element to its correct position. 4. Reduce the unsorted portion and repeat until the entire array is sorted. Input: * A list of integers `arr`, where `1 <= len(arr) <= 1000` and `-10^6 <= arr[i] <= 10^6`. Output: * The sorted list of integers. Example: ```python # Example 1 Input: [3, 2, 4, 1] Output: [1, 2, 3, 4] # Example 2 Input: [8, 5, 7, 3, 2, 0, 1] Output: [0, 1, 2, 3, 5, 7, 8] ``` Constraints: * You must implement this sort using only array reversals. * You cannot use any built-in sorting functions. Implementation: Implement the function `pancake_sort(arr: List[int]) -> List[int]`: ```python def pancake_sort(arr): Function to sort the array using Pancake Sort. len_arr = len(arr) if len_arr <= 1: return arr for cur in range(len(arr), 1, -1): # Finding index of maximum number in arr index_max = arr.index(max(arr[0:cur])) if index_max + 1 != cur: # Needs moving if index_max != 0: # Reverse from 0 to index_max arr[:index_max + 1] = reversed(arr[:index_max + 1]) # Reverse list arr[:cur] = reversed(arr[:cur]) return arr ``` Test your function with the provided examples and edge cases such as empty arrays or arrays with one element.","solution":"def pancake_sort(arr): Function to sort the array using Pancake Sort. len_arr = len(arr) if len_arr <= 1: return arr # Perform the pancake sorting algorithm for cur in range(len(arr), 1, -1): # Find the index of the maximum element in the current range (unsorted part) index_max = arr.index(max(arr[0:cur])) if index_max + 1 != cur: # Move the maximum element to the beginning of the array if it\'s not already there if index_max != 0: arr[:index_max + 1] = reversed(arr[:index_max + 1]) # Move the maximum element to its final position arr[:cur] = reversed(arr[:cur]) return arr"},{"question":"# Coding Challenge Your task is to demonstrate understanding of stack manipulation by implementing a function that doubles each value in a provided stack. This problem involves using an auxiliary data structure to handle the elements while ensuring that each value in the stack appears twice in the same top-to-bottom order. Function Signature Implement the following function: ```python def stutter_stack(stack: list[int]) -> list[int]: pass ``` Input * **stack**: A list of integers representing a stack. It follows the stack property: the last element of the list is considered the top of the stack. Output * **A modified stack** with each element appearing twice in the same order from bottom to top. Constraints * Each integer in the stack can have values in the range [-10^6, 10^6]. * The number of elements, n, in the stack can be in the range [0, 10^5]. * The target implementation should have O(n) time and O(n) space complexity. Example *Input*: ``` stack = [3, 7, 1, 14, 9] ``` *Output*: ``` [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Additional Challenge Try to implement the function using both methods discussed: 1. Using an auxiliary stack 2. Using an auxiliary queue Tips: 1. Pay attention to handling empty or single-element stacks correctly. 2. Ensure that your solution efficiently handles the stack so that the operations are linear in time and space.","solution":"def stutter_stack(stack: list[int]) -> list[int]: if not stack: return [] aux_stack = [] final_stack = [] while stack: top = stack.pop() aux_stack.append(top) aux_stack.append(top) while aux_stack: final_stack.append(aux_stack.pop()) return final_stack"},{"question":"You are working as a software developer for an embedded systems company. Your latest project involves optimizing arithmetic operations on a hardware platform that lacks support for standard arithmetic operators. To accomplish this, you need to implement fundamental arithmetic operations using alternative methods. Specifically, you are required to implement a function that adds two positive integers without using the `+` operator, leveraging bitwise operations instead. # Function Specification **Function Name**: `bitwise_addition` **Input**: - Two non-negative integers, `a` and `b`. **Output**: - A single integer, the sum of `a` and `b` using bitwise operations. # Constraints - `0 <= a, b <= 10^9` # Performance Requirements - The function should be optimal in terms of time and space complexity for the given constraints. # Examples *Example 1*: ```python Input: a = 2, b = 3 Output: 5 ``` *Example 2*: ```python Input: a = 0, b = 7 Output: 7 ``` # Implementation Notes - Ensure the solution correctly handles edge cases such as one of the numbers being zero. - Take into consideration the performance implications for large integer inputs. - No external libraries are allowed. # Testing Provide additional tests to verify the robustness of your solution, particularly focusing on edge cases and performance for upper bounds of input size.","solution":"def bitwise_addition(a, b): while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"Given a 2D binary grid (`m x n`) filled with 0\'s (representing water) and 1\'s (representing land), an island is a maximal group of 1\'s connected in all four possible directions (horizontal and vertical). The border of the grid is always water. Implement the `countIslands` function which takes in a grid and counts the number of islands using Union-Find. # Function Signature ```python def countIslands(grid: List[List[int]]) -> int: pass ``` # Input - `grid`: A list of lists representing the 2D grid of size `m x n` where `1 <= m, n <= 1000`. # Output - Returns the number of islands in the grid. # Example **Input**: ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 1, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 0] ] ``` **Output**: 2 # Constraints - You can assume that at least one land cell exists in the grid. - The solution should have an optimized time complexity. # Requirements - Implement the Union-Find data structure within the solution. - Your Union-Find class should support the `find` and `union` operations with path compression and union by rank/size. - Ensure efficient handling of edge cases and performance bottlenecks. - The solution should avoid unnecessary computation and memory usage. # Additional Context Consider this practical scenario: You\'re given a piece of land that needs to be analyzed to determine the number of distinct landmasses. This is important for geographical surveys and urban planning where terrain segmentation impacts infrastructure developments and resource allocation.","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: # Union by rank if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 def countIslands(grid): if not grid: return 0 rows, cols = len(grid), len(grid[0]) uf = UnionFind(rows * cols) def index(r, c): return r * cols + c directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for r in range(rows): for c in range(cols): if grid[r][c] == 1: for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: uf.union(index(r, c), index(nr, nc)) # Count unique root parents root_set = set() for r in range(rows): for c in range(cols): if grid[r][c] == 1: root_set.add(uf.find(index(r, c))) return len(root_set)"},{"question":"Bit Manipulation to Minimize Bit Flips Scenario You are given two integers, and you need to determine the minimal number of bits you would need to flip to convert the first integer to the second. This requires you to identify the bit positions at which the two numbers differ and then count those positions. Task Implement a function `count_flips_to_convert(a: int, b: int) -> int`. This function should compute the minimal number of bit flips required to transform integer `a` into integer `b`. Constraints - The input integers `a` and `b` are guaranteed to be non-negative and within the range of standard 32-bit signed integers. - You should ensure the function runs within a time complexity of O(n), where n is the number of bits in the integers. Input - `a`: An integer (0 ≤ a ≤ 2^31 - 1) - `b`: An integer (0 ≤ b ≤ 2^31 - 1) Output - Returns an integer representing the number of bits to flip to convert from `a` to `b`. Example ```python # Example 1: # Input: 29 (binary: 11101), 15 (binary: 01111) # Output: 2 # Explanation: Bit positions which differ are 2nd and 4th positions (0-indexed). count_flips_to_convert(29, 15) # Expected output: 2 # Example 2: # Input: 1, 2 # Output: 2 # Explanation: Bit positions which differ are 0th and 1st positions (0-indexed). count_flips_to_convert(1, 2) # Expected output: 2 ``` Implementation Notes: - Make use of bitwise XOR to identify differing bits. - Use efficient techniques to count set bits in an integer.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the minimal number of bit flips required to transform integer a into integer b. # XOR a and b to get the differing bits xor_result = a ^ b # Count number of 1\'s in the XOR result, which corresponds to differing bit positions count = 0 while xor_result: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"# Problem: Detecting Cycles in a Directed Graph Context: Imagine you are working on a project that involves project management software, and you need to ensure project tasks (nodes) do not have cyclic dependencies. A cyclic dependency happens when a task is indirectly dependent on itself. Task: Write a function `detect_cycle_in_directed_graph(graph: DirectedGraph) -> bool` that determines if there are any cycles in the given directed graph. Function Signature: ```python def detect_cycle_in_directed_graph(graph: DirectedGraph) -> bool: ``` Input: - `graph`: An instance of `DirectedGraph`. Output: - The function should return `True` if there is at least one cycle in the graph, otherwise `False`. Constraints: - Nodes in the graph have unique names. - Edge cases like an empty graph should return `False`. - The graph can have any number of nodes and edges. Example: ```python # Example graph with a cycle: A -> B -> C -> A load_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\"] } graph = DirectedGraph(load_dict) output = detect_cycle_in_directed_graph(graph) print(output) # Should print True, as there is a cycle A -> B -> C -> A # Example graph without a cycle: A -> B -> C load_dict = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": [] } graph = DirectedGraph(load_dict) output = detect_cycle_in_directed_graph(graph) print(output) # Should print False, as there is no cycle ``` Explanation: To solve this problem, implement cycle detection using Depth-First Search (DFS) where you maintain a set of visited nodes and a recursion stack. If during the DFS traversal a node is encountered that is already on the recursion stack, a cycle is detected.","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.adjacency_list = adjacency_list def detect_cycle_in_directed_graph(graph): visited = set() rec_stack = set() def dfs(node): if node in rec_stack: return True if node in visited: return False visited.add(node) rec_stack.add(node) for neighbor in graph.adjacency_list.get(node, []): if dfs(neighbor): return True rec_stack.remove(node) return False for node in graph.adjacency_list: if node not in visited: if dfs(node): return True return False"},{"question":"Question: Cholesky Decomposition Extended # Background You are given a Hermitian positive-definite matrix ( A ) and are tasked to perform Cholesky decomposition on it. The Cholesky decomposition factors the matrix ( A ) into the product of a lower triangular matrix ( L ) and its conjugate transpose ( L^T ). # Objectives Your task is to implement the decomposition and also extend it to validate whether a given matrix is Hermitian positive-definite or not. If the matrix is not Hermitian positive-definite, your function should return an appropriate message. # Function Signature ```python def validate_and_decompose(A: List[List[float]]) -> Union[List[List[float]], str]: pass ``` # Input * `A`: A square matrix (List of Lists), where each element is a float. # Output * If the matrix can be decomposed, return the lower triangular matrix ( L ) as a List of Lists. * If the matrix cannot be decomposed, return a string message `\\"Matrix is not Hermitian positive-definite\\"`. # Constraints * The input matrix ( A ) will have dimensions n x n where ( 1 leq n leq 100 ). # Examples ```python matrix = [ [4, 12, -16], [12, 37, -43], [-16, -43, 98] ] assert validate_and_decompose(matrix) == [ [2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0] ] invalid_matrix = [ [1, 2], [2, 1] ] assert validate_and_decompose(invalid_matrix) == \\"Matrix is not Hermitian positive-definite\\" ``` # Performance Requirements * The solution must run efficiently for matrices up to size 100x100. # Edge Cases to Consider * Matrices that are not square should not be provided as input as per the given constraints. * Consider how you would handle matrices on the edge of not being positive-definite. # Hints 1. Remember that a matrix is Hermitian if it is equal to its own conjugate transpose. 2. Ensure you check for positive-definiteness throughout the decomposition steps.","solution":"from typing import List, Union import numpy as np def validate_and_decompose(A: List[List[float]]) -> Union[List[List[float]], str]: Validates if the matrix A is Hermitian positive-definite and performs Cholesky decomposition if it is. Returns the lower triangular matrix L or an error message if the matrix is not Hermitian positive-definite. # Convert input list to numpy array A = np.array(A, dtype=float) # Check if A is a square matrix n, m = A.shape if n != m: return \\"Matrix is not Hermitian positive-definite\\" # Check if A is Hermitian (Since A is a real matrix, Hermitian is equivalent to symmetric) if not np.allclose(A, A.T): return \\"Matrix is not Hermitian positive-definite\\" # Try to perform Cholesky decomposition try: L = np.linalg.cholesky(A) return L.tolist() except np.linalg.LinAlgError: return \\"Matrix is not Hermitian positive-definite\\""},{"question":"# Combination Calculation (nCr) with Memoization **Context**: In combinatorics, calculating the number of ways to choose (r) items from (n) distinct items (not considering the order) is a common problem known as computing combinations (nCr). This is mathematically represented and can be computationally intensive without optimization techniques. # Task: Implement a function `combination_memo(n, r)` that computes the combination (nCr) efficiently using memoization where: - (nCr) = the number of ways to choose (r) items from (n) items. - Uses the recursive property that (nCr = (n-1)C(r-1) + (n-1)Cr). - Memoization is used to store computed values of subproblems to avoid redundant calculations. **Function Signature**: ```python def combination_memo(n: int, r: int) -> int: ``` # Input: * Integer (n) representing the total number of items. * Integer (r) representing the number of items to choose. # Output: * Return an integer which is the value of (nCr). # Constraints: * (0 leq r leq n leq 500) * If (r > n), return 0. * Combinations (nCr) are always non-negative integers. # Examples: ```python assert combination_memo(5, 3) == 10 assert combination_memo(10, 0) == 1 assert combination_memo(6, 6) == 1 assert combination_memo(10, 5) == 252 assert combination_memo(7, 8) == 0 ``` # Edge Cases to Consider: 1. (r = 0): Should always return 1 because any number (n) choose 0 is 1. 2. (r = n): Should always return 1 because (n) choose (n) is 1. 3. (n = 0): Should handle gracefully, where (r = 0) should return 1 otherwise 0. 4. (r > n): Should return 0 as choosing more elements than present is not possible. # Explanation: 1. A recursive approach with memoization should be used. 2. Memoization can be implemented using a dictionary to store results of subproblems.","solution":"def combination_memo(n: int, r: int, memo=None) -> int: Calculate the combination nCr using memoization. :param n: Total number of items :param r: Number of items to choose :param memo: Dictionary for memoizing results :return: Combination nCr value if r < 0 or r > n: return 0 if r == 0 or r == n: return 1 if memo is None: memo = {} if (n, r) in memo: return memo[(n, r)] result = combination_memo(n-1, r-1, memo) + combination_memo(n-1, r, memo) memo[(n, r)] = result return result"},{"question":"Optimized Binary Search Function Context You are provided with a sorted array of integers. You need to implement a binary search algorithm to find the position of a given target value within the array. Your task is to write an efficient function that can handle both large datasets and edge cases gracefully. Task Write a function `optimized_binary_search(array: List[int], value: int) -> int`. This function should take a sorted list of integers `array` and an integer `value`, and return the index of `value` in the array. If the value is not found, the function should return `-1`. **Function Signature:** ```python def optimized_binary_search(array: List[int], value: int) -> int: pass ``` Input/Output Format * **Input**: * `array`: List[int], a list of integers sorted in ascending order. * `value`: int, the target value to search for. * **Output**: * Return an integer representing the index of the target value in the list. If the target value is not found, return `-1`. Constraints and Requirements * Your solution should have a time complexity of O(log(n)) where n is the length of the array. * Consider edge cases such as: * An empty array. * Array with one element. * Target value not present in the array. Example Scenarios 1. **Example 1:** ```python array = [1, 2, 3, 4, 5, 6, 7, 8, 9] value = 4 optimized_binary_search(array, value) # Output: 3 ``` 2. **Example 2:** ```python array = [1, 2, 3, 4, 5, 6, 7, 8, 9] value = 10 optimized_binary_search(array, value) # Output: -1 ``` 3. **Example 3:** ```python array = [] value = 4 optimized_binary_search(array, value) # Output: -1 ``` **Note:** Ensure your solution handles edge cases and avoids common pitfalls such as array bounds errors or inefficient search strategies.","solution":"from typing import List def optimized_binary_search(array: List[int], value: int) -> int: Perform a binary search on a sorted array to find the index of a given value. Parameters: array (List[int]): A sorted list of integers. value (int): The target value to search for. Returns: int: The index of the target value if found, otherwise -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == value: return mid elif array[mid] < value: low = mid + 1 else: high = mid - 1 return -1"},{"question":"You are required to implement the continuation of the `create_linked_list` and `to_list` functions as specified below and complete the `remove_range` function that removes a given range of elements from the provided singly linked list. Detailed Function Description: 1. **Function to Implement**: `remove_range(list, start, end)` - **Input**: * `head` (ListNode): The head node of a singly linked list. * `start` (int): The starting index of the range to remove. * `end` (int): The ending index of the range to remove (inclusive). - **Output**: * The head of the modified linked list after removing specified nodes. - **Constraints**: * 0 ≤ start ≤ end < number of nodes in the list. 2. **Helper Functions**: a. `create_linked_list(arr)`: Creates a linked list from a Python list. * **Input**: * `arr` (List[int]): Python list of integers. * **Output**: * The head of the linked list created. b. `to_list(head)`: Converts a linked list back into Python list. * **Input**: * `head` (ListNode): The head node of a singly linked list. * **Output**: * Python list of integers representing the linked list\'s current state. 3. **Example**: ```python input_list = [8, 13, 17, 4, 9, 12, 98, 41, 7, 23, 0, 92] head = create_linked_list(input_list) head = remove_range(head, 3, 8) result = to_list(head) print(result) # Expected Output: [8, 13, 17, 23, 0, 92] ``` Scenarios/Context: An online platform could utilize this function for managing and editing user data sequences quickly. For example, removing tasks from a bucket list within specific indices due to completion or other criteria.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def create_linked_list(arr): Creates a linked list from a Python list. if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head def to_list(head): Converts a linked list back into a Python list. result = [] current = head while current: result.append(current.value) current = current.next return result def remove_range(head, start, end): Removes nodes from start to end (inclusive) in the linked list. if not head: return None dummy = ListNode(0) dummy.next = head prev = dummy current = head index = 0 # Move to the start of the range while index < start: prev = current current = current.next index += 1 # Move current to the end of the range while index <= end and current: current = current.next index += 1 # Connect the previous node to the node after the end of the range prev.next = current return dummy.next"},{"question":"# Scenario You are working on a symbolic algebra system for a mathematics software that needs advanced manipulation of algebraic expressions. The components of the system include **Monomial** and **Polynomial** classes. # Task Implement a new feature for this system that allows the symbolic differentiation of polynomials with respect to a given variable. # Requirements 1. Implement a method `differentiate(variable: int) -> Polynomial` in the `Polynomial` class. 2. The `differentiate` method should compute the derivative of the polynomial with respect to the variable specified and return a new `Polynomial` object. 3. The derivative of a monomial is found by applying the power rule: ( frac{d}{dx}(a_n cdot x^n) = a_n cdot n cdot x^{n-1} ). # Expected Input and Output Formats * **Input**: An instance of `Polynomial` and an integer representing the variable with respect to which differentiation will be performed. * **Output**: A new `Polynomial` instance representing the derivative. # Constraints 1. Handle variables indexed by non-negative integers. 2. Assume all coefficients are rationalizable as `Fraction`. 3. Focus on the correctness and efficiency of the differentiation process. # Examples 1. Differentiating ( 2a_1^3 + 3a_2^2 ) with respect to ( a_1 ): * Input: ```python p = Polynomial([Monomial({1: 3}, 2), Monomial({2: 2}, 3)]) derivative = p.differentiate(1) ``` * Output: ```python 6(a_1)^2 ``` 2. Differentiating ( 2a_1^3 - a_2 + 5 ) with respect to ( a_2 ): * Input: ```python p = Polynomial([Monomial({1: 3}, 2), Monomial({2: 1}, -1), Monomial({}, 5)]) derivative = p.differentiate(2) ``` * Output: ```python -1 ```","solution":"from fractions import Fraction from collections import defaultdict class Monomial: def __init__(self, variables, coefficient): Initializes a Monomial. :param variables: A dictionary where keys are variable indices and values are their powers (e.g., {1: 3} for x1^3). :param coefficient: The coefficient of the monomial. self.variables = variables self.coefficient = Fraction(coefficient) def differentiate(self, variable): Differentiates the monomial with respect to the given variable. :param variable: The variable index with respect to which differentiation is performed. :return: A new differentiated Monomial, or None if the derivative is zero. if variable in self.variables: exponent = self.variables[variable] new_coefficient = self.coefficient * exponent new_variables = self.variables.copy() if exponent - 1 == 0: del new_variables[variable] else: new_variables[variable] = exponent - 1 return Monomial(new_variables, new_coefficient) else: return None # Derivative is zero if the variable is not in the monomial def __repr__(self): return f\\"{self.coefficient} * {\' \'.join([f\'a_{var}^{exp}\' for var, exp in self.variables.items()]) or \'1\'}\\" class Polynomial: def __init__(self, monomials): Initializes a Polynomial. :param monomials: A list of Monomials. self.monomials = monomials def differentiate(self, variable): Differentiates the polynomial with respect to the given variable. :param variable: The variable index with respect to which differentiation is performed. :return: A new Polynomial that is the derivative of the current polynomial. differentiated_monomials = [] for monomial in self.monomials: differentiated = monomial.differentiate(variable) if differentiated: differentiated_monomials.append(differentiated) return Polynomial(differentiated_monomials) def __repr__(self): return \\" + \\".join([str(monomial) for monomial in self.monomials]) or \\"0\\""},{"question":"# Context: You are given a 2D grid initially filled with water. Some positions on this grid will be set to land over a series of operations. Your task is to determine the number of islands at each step. An island is defined as a group of horizontally or vertically connected land cells. Implement the following function: ```python def count_islands(n, m, positions): Count the number of islands after each addLand operation in an n x m grid. Parameters: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - positions (List[List[int]]): List of [row, col] positions where land is added. Returns: - List[int]: Number of islands after each addLand operation. pass ``` # Input: - `n`: Number of rows (integer). - `m`: Number of columns (integer). - `positions`: A list of pairs of integers, each pair representing the row and column of a cell to be converted from water to land. # Output: - A list of integers where the i-th integer is the number of islands after the i-th addLand operation. # Constraints: - `1 <= n, m <= 1000` - `0 <= positions[i][0] < n` - `0 <= positions[i][1] < m` # Performance Requirements: - time complexity should be efficient enough to handle up to 1000 operations on a 1000 x 1000 grid. # Example: ```python positions = [[0, 0], [0,1], [1,2], [2,1]] n = 3 m = 3 print(count_islands(n, m, positions)) # Output: [1, 1, 2, 3] ``` # Notes: * Initially, the entire grid is filled with water (represented by `0`). * Land cells are represented by `1`. Hints: * Use the Union-Find data structure to dynamically manage and query the connected land components. * Be cautious with edge cases, such as adding land to a cell that is already land.","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def count_islands(n, m, positions): def getIndex(r, c): return r * m + c uf = UnionFind(n * m) grid = [[0 for _ in range(m)] for _ in range(n)] result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for r, c in positions: if grid[r][c] == 1: result.append(uf.count) continue grid[r][c] = 1 uf.count += 1 index = getIndex(r, c) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 1: neighborIndex = getIndex(nr, nc) uf.union(index, neighborIndex) result.append(uf.count) return result"},{"question":"# Fibonacci Sequence Implementation **Objective**: Your task is to write a function that computes the nth Fibonacci number. The Fibonacci sequence follows the rule: F(n) = F(n-1) + F(n-2), with the initial terms F(0) = 0 and F(1) = 1. Requirements: - Implement the function using an iterative approach. - Ensure the function handles large values of `n` efficiently, avoiding excessive memory use. (`n` can be as large as 10^6) **Input Format**: - A single integer `n` (0 <= n <= 10^6) **Output Format**: - A single integer representing the nth Fibonacci number. **Constraints**: - The function should complete execution in a reasonable time for large values of `n`. - Handle edge cases (like `n=0` and `n=1`) effectively. Example *Example 1:* ```plaintext Input: 10 Output: 55 ``` *Example 2:* ```plaintext Input: 20 Output: 6765 ``` **Function Signature**: ```python def fibonacci(n: int) -> int: pass ```","solution":"def fibonacci(n: int) -> int: Compute the nth Fibonacci number iteratively. Args: n (int): the position in the Fibonacci sequence (0-indexed) Returns: int: the nth Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"You are tasked with implementing a function to find all root-to-leaf paths in a binary tree where each path\'s sum equals a given target sum. The function should efficiently handle both deep and wide trees and consider different traversal strategies. # Function Signature ```python def find_path_sums(root: TreeNode, target_sum: int) -> List[List[int]]: pass ``` # Input - `root`: TreeNode, representing the root of the binary tree. `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - `target_sum`: int, the target sum for the paths. # Output - A list of lists, where each sub-list contains the values of a root-to-leaf path that sum up to `target_sum`. # Constraints - The number of nodes in the tree is in the range [0, 5000]. - `-1000 <= Node.val <= 1000` - `-1000 <= target_sum <= 1000` # Performance Requirements - Your function should have a time complexity of O(N) and a space complexity of O(H) where N is the number of nodes and H is the height of the tree. # Example ```python # Example Tree: # 5 # / # 4 8 # / / # 11 13 4 # / / # 7 2 5 1 input: root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.left = TreeNode(5) root.right.right.right = TreeNode(1) target_sum = 22 output: [ [5, 4, 11, 2], [5, 8, 4, 5] ] ``` # Guidelines - Implement DFS using recursion. - Handle edge cases such as empty trees and nodes with negative values. - Avoid deep recursion issues with suitable handling.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_path_sums(root: TreeNode, target_sum: int) -> List[List[int]]: def dfs(node, current_path, remaining_sum): if not node: return current_path.append(node.val) if not node.left and not node.right and node.val == remaining_sum: result.append(list(current_path)) else: dfs(node.left, current_path, remaining_sum - node.val) dfs(node.right, current_path, remaining_sum - node.val) current_path.pop() result = [] dfs(root, [], target_sum) return result"},{"question":"# Scenario You are tasked with designing a ticketing system for a concert. Tickets are handled in a FIFO order. To manage the ticket queue, you\'ll implement a queue data structure to ensure fans get their tickets in the proper order. The queue should be able to handle millions of tickets, so your implementation should be efficient in both time and space. # Task Implement a `ResizingArrayQueue` class that extends the `AbstractQueue` provided. This class should use a dynamic array to handle the queue operations and efficiently resize when necessary. Below are the required methods: 1. `enqueue(value)`: Adds a new item to the rear of the queue. 2. `dequeue()`: Removes the front item from the queue. 3. `peek()`: Returns the front element of the queue. 4. `is_empty()`: Checks if the queue is empty. 5. `__len__()`: Returns the number of items in the queue. # Requirements * Start with an initial capacity of 10 for the array. * Implement an efficient resizing strategy to handle capacity changes. * Ensure all queue operations are as efficient as possible. # Constraints * The solution should handle up to (10^6) elements efficiently. * Minimize the overhead when growing the queue\'s capacity. # Input/Output * `enqueue(value)`: `value` can be any data type. * `dequeue()`: Returns the removed element, raises `IndexError` if queue is empty. * `peek()`: Returns the front element, raises `IndexError` if queue is empty. * `is_empty()`: Returns `True` if queue is empty, `False` otherwise. * `__len__()`: Returns the number of items in the queue as an integer. # Example Usage ```python queue = ResizingArrayQueue() queue.enqueue(\'ticket1\') queue.enqueue(\'ticket2\') print(queue.peek()) # Output: \'ticket1\' print(len(queue)) # Output: 2 print(queue.dequeue()) # Output: \'ticket1\' print(queue.is_empty()) # Output: False print(queue.dequeue()) # Output: \'ticket2\' print(queue.is_empty()) # Output: True ``` Implement the `ResizingArrayQueue` class below: ```python class ResizingArrayQueue(AbstractQueue): def __init__(self): super().__init__() self._array = [None] * 10 self._front = 0 self._rear = 0 def __iter__(self): probe = self._front while probe != self._rear: yield self._array[probe] probe = (probe + 1) % len(self._array) def enqueue(self, value): if (self._rear + 1) % len(self._array) == self._front: self._expand() self._array[self._rear] = value self._rear = (self._rear + 1) % len(self._array) self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % len(self._array) self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def _expand(self): new_capacity = 2 * len(self._array) new_array = [None] * new_capacity j = 0 for i in range(self._front, self._rear): new_array[j] = self._array[i % len(self._array)] j += 1 self._array = new_array self._front = 0 self._rear = self._size ```","solution":"class ResizingArrayQueue: def __init__(self): self._array = [None] * 10 self._front = 0 self._rear = 0 self._size = 0 def enqueue(self, value): if self._size == len(self._array): self._expand() self._array[self._rear] = value self._rear = (self._rear + 1) % len(self._array) self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % len(self._array) self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def is_empty(self): return self._size == 0 def __len__(self): return self._size def _expand(self): new_capacity = 2 * len(self._array) new_array = [None] * new_capacity for i in range(self._size): new_array[i] = self._array[(self._front + i) % len(self._array)] self._array = new_array self._front = 0 self._rear = self._size"},{"question":"# Problem Description: You are given an array of integers. Your task is to implement a sorting function that will arrange the elements of the array in ascending order using a sorting algorithm. You need to ensure that your implementation aligns with the principles of in-place sorting and performs all element exchanges manually. # Function Signature: ```python def custom_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr`: A list of integers (1 <= len(arr) <= 10^3, -10^3 <= arr[i] <= 10^3). # Output: * Returns a list of integers sorted in ascending order. # Example: ```python custom_sort([4, 2, 3, 1]) ``` Output: ```python [1, 2, 3, 4] ``` # Constraints: * The array can contain negative, positive, and zero values. * The solution should be implemented without using built-in sort functions. * Implement in-place sorting technique with a time complexity no better than O(n^2). # Notes: * Consider and handle edge cases such as an empty array or an array with a single element. * Your implementation should manually perform the swaps of the elements. * Ensure the function is optimized enough to handle arrays of length up to 1000 efficiently as per the constraints given.","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using bubble sort. The sort is performed in-place. :param arr: List[int] - A list of integers to be sorted :return: List[int] - The sorted list of integers n = len(arr) for i in range(n-1): # Boolean to check if any swapping happened swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: # Perform the swap arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # If no two elements were swapped by inner loop, then the array is sorted if not swapped: break return arr"},{"question":"# Pancake Sorting with Error Handling **Context**: You are developing a feature for a bakery’s inventory management system. The bakery wants to organize the pancakes by size, from the smallest on top to the largest at the bottom, using a series of pancake flips. **Problem**: Implement a function `enhanced_pancake_sort(arr)` that sorts a given list of integers (representing pancake sizes) using the pancake sort algorithm. Additionally, the function should handle certain error scenarios (detailed in the requirements below). **Function Signature**: ```python def enhanced_pancake_sort(arr: List[int]) -> List[int]: ``` **Input**: * `arr` - a list of integers representing the sizes of pancakes. (1 ≤ len(arr) ≤ 10^4, -10^9 ≤ arr[i] ≤ 10^9) **Output**: * A new list of integers sorted in non-decreasing order. **Requirements**: 1. If the input list is empty or has one element, return it as is. 2. The function should raise a `ValueError` if any element is not an integer. 3. Optimize the search for the maximum element by using auxiliary functions if necessary. **Complexity**: * Ensure the solution performs within O(N^2) time complexity constraints. **Example**: ```python assert enhanced_pancake_sort([3, 6, 2, 5, 8]) == [2, 3, 5, 6, 8] assert enhanced_pancake_sort([1]) == [1] assert enhanced_pancake_sort([]) == [] assert enhanced_pancake_sort([1, 2, 3, \\"4\\"]) # Should raise ValueError ``` **Notes**: * Ensure your implementation properly raises exceptions for invalid inputs. * You do not need to check for input other than integers, such as strings or floats.","solution":"from typing import List def flip(arr: List[int], k: int) -> None: Function to reverse the first k elements of the array arr[:k] = arr[:k][::-1] def find_max_index(arr: List[int], n: int) -> int: Function to find the index of the maximum element in arr[0:n] max_index = 0 for i in range(1, n): if arr[i] > arr[max_index]: max_index = i return max_index def enhanced_pancake_sort(arr: List[int]) -> List[int]: Sorts the array using pancake sort and handles specific error scenarios. # Handle empty list or single element list if len(arr) <= 1: return arr # Check for non-integer elements for element in arr: if not isinstance(element, int): raise ValueError(\\"All elements must be integers\\") n = len(arr) for curr_size in range(n, 1, -1): # Find the index of the maximum element in arr[0:curr_size] max_index = find_max_index(arr, curr_size) # If the max element is not at its place, move it to the end of current array if max_index != curr_size - 1: # Flip the max element to the first position flip(arr, max_index + 1) # Flip it to the last position of the current size flip(arr, curr_size) return arr"},{"question":"# Combination Calculation (nCr) Scenario You are required to calculate the number of ways to choose `r` items from a collection of `n` distinct items. This is typically known as computing combinations, represented as `nCr`. Task Write a function `combination_optimized(n, r)` that calculates the number of combinations using the most optimized approach discussed (dynamic programming with memoization). # Input * Integers `n` and `r` where `0 <= r <= n` # Output * An integer representing the number of ways to choose `r` items from `n` items. # Constraints * 0 <= n <= 1000 * 0 <= r <= n # Examples Example 1 Input: ```python combination_optimized(5, 2) ``` Output: ```python 10 ``` Explanation: There are 10 ways to choose 2 items from 5 items. Example 2 Input: ```python combination_optimized(6, 3) ``` Output: ```python 20 ``` Explanation: There are 20 ways to choose 3 items from 6 items. # Notes * Consider using iterative dynamic programming to handle large input sizes more efficiently. * Return 0 if r > n or if n < 0 or r < 0.","solution":"def combination_optimized(n, r): Returns the number of combinations (nCr) using dynamic programming. if r > n or n < 0 or r < 0: return 0 # Create a 2D array to store the results of subproblems dp = [[0 for _ in range(r + 1)] for _ in range(n + 1)] # Calculate nCr using bottom-up approach for i in range(n + 1): for j in range(min(i, r) + 1): if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][r]"},{"question":"RSA Encryption Key Calculation RSA encryption heavily relies on the modular inverse operation. Given two prime numbers ( p ) and ( q ), you can generate the public and private keys for RSA encryption by following specific steps. **Scenario**: You are to write a function that, given two prime numbers ( p ) and ( q ), generates the public and private keys for RSA encryption using the modular inverse function provided above. # Constraints: 1. Input primes ( p ) and ( q ) will be distinct and greater than 3. 2. You need to compute ( n = p times q ). 3. Compute the totient ( phi(n) = (p-1) times (q-1) ). 4. Select a public exponent ( e ). Usually, 65537 is used. Ensure ( e ) and ( phi(n) ) are coprime. 5. Compute the private exponent ( d ) as the modular inverse of ( e ) modulo ( phi(n) ). # Function Signature Implement the function `generate_rsa_keys(p: int, q: int) -> (int, int, int, int, int)` where: - `p` (int): A prime number. - `q` (int): Another prime number distinct from ( p ). **Returns**: - A tuple `(n, phi(n), e, d, text{max}(p, q))`: - `n`: The RSA modulus. - `phi(n)`: The totient of ( n ). - `e`: The public exponent. - `d`: The private exponent. - The greater of the two primes ( p ) and ( q ). ```python def generate_rsa_keys(p: int, q: int) -> (int, int, int, int, int): # Step 1: Compute n = p * q n = p * q # Step 2: Compute phi(n) = (p - 1) * (q - 1) phi_n = (p - 1) * (q - 1) # Step 3: Choose a public exponent e (commonly 65537) e = 65537 # Step 4: Ensure e and phi(n) are coprime, otherwise select another e while extended_gcd(e, phi_n)[2] != 1: e += 2 # Step 5: Compute the modular inverse to find the private exponent d d = modular_inverse(e, phi_n) # Return n, phi(n), e, d, max(p, q) return n, phi_n, e, d, max(p, q) ```","solution":"import math def extended_gcd(a, b): Extended Euclidean Algorithm: Given two integers a and b, return a tuple (g, x, y), where g is gcd(a, b) and x,y are such that ax + by = g. if a == 0: return (b, 0, 1) g, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return (g, x, y) def modular_inverse(a, m): Compute the modular inverse of a modulo m using the Extended Euclidean Algorithm. g, x, y = extended_gcd(a, m) if g != 1: raise Exception(\'Modular inverse does not exist\') else: return x % m def generate_rsa_keys(p, q): Given two prime numbers p and q, generates the public and private keys for RSA encryption. Args: - p (int): A prime number. - q (int): Another prime number distinct from p. Returns: A tuple (n, phi_n, e, d, max_pq) where: - n: The RSA modulus. - phi_n: The totient of n. - e: The public exponent. - d: The private exponent. - max_pq: The greater of the two primes p and q. # Step 1: Compute n = p * q n = p * q # Step 2: Compute φ(n) = (p - 1) * (q - 1) phi_n = (p - 1) * (q - 1) # Step 3: Choose a public exponent e (commonly 65537) e = 65537 # Step 4: Ensure e and φ(n) are coprime g, _, _ = extended_gcd(e, phi_n) while g != 1: e += 2 g, _, _ = extended_gcd(e, phi_n) # Step 5: Compute the modular inverse to find the private exponent d d = modular_inverse(e, phi_n) # Return n, φ(n), e, d, max(p, q) return n, phi_n, e, d, max(p, q)"},{"question":"Scenario You are tasked with creating a custom file compression system using Huffman Coding. The files to be compressed consist of plain text files which may contain any dictionary-based language text input. Requirements The goal is to implement a function `perform_huffman_encoding` that takes an input string and returns its Huffman encoded string as well as the corresponding Huffman Tree. Function Specification ```python def perform_huffman_encoding(input_str: str) -> (str, Node): Encodes the given input string using Huffman Coding. :param input_str: A non-empty string that needs to be encoded. :return: A tuple where the first element is the encoded string and the second element is the Huffman Tree. Example: given input_str = \\"hello world\\" encoded_str, huffman_tree = perform_huffman_encoding(input_str) ``` Constraints 1. `input_str` length will range from 1 to 10^6 characters. 2. Input can contain any printable ASCII characters. Example ```python # Example Input input_str = \\"this is an example for huffman encoding\\" # Example Output encoded_str = \\"110100101110...\\" # This is just an illustrative example and not the exact output. huffman_tree = Node(...) # The constructed Huffman Tree root node. ``` Performance Requirements * The function should efficiently handle input sizes up to 10^6 characters. * Aim to minimize both the time and space complexity within practical constraints. Additional Information * Provide the `Node` class used in the Huffman Tree and ensure compatibility in your implementation. * Ensure to check edge cases like all characters having the same frequency and handle them gracefully. Good luck with implementing this crucial piece of your custom file compression system!","solution":"import heapq from collections import defaultdict, Counter from typing import Any, Dict, List, Tuple class Node: def __init__(self, char: str, freq: int): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def build_huffman_tree(freq_map: Dict[str, int]) -> Node: heap = [Node(char, freq) for char, freq in freq_map.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = Node(None, left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(heap, merged) return heap[0] if heap else None def generate_huffman_codes(node: Node, prefix: str = \'\', code_map: Dict[str, str] = None) -> Dict[str, str]: if code_map is None: code_map = {} if node is not None: if node.char is not None: code_map[node.char] = prefix generate_huffman_codes(node.left, prefix + \'0\', code_map) generate_huffman_codes(node.right, prefix + \'1\', code_map) return code_map def perform_huffman_encoding(input_str: str) -> Tuple[str, Node]: if not input_str: return \\"\\", None freq_map = Counter(input_str) huffman_tree = build_huffman_tree(freq_map) huffman_codes = generate_huffman_codes(huffman_tree) encoded_str = \'\'.join(huffman_codes[char] for char in input_str) return encoded_str, huffman_tree"},{"question":"You are tasked with developing an efficient function to compute the number of \'1\' bits (also known as Hamming weight) for a given unsigned integer. To achieve this, you will implement two functions using Brian Kernighan’s Algorithm: 1. **Recursive Approach**: A function that counts the number of \'1\' bits using recursion. 2. **Iterative Approach**: A function that counts the number of \'1\' bits using iteration. # Function Specifications Implement the following functions: Function `count_ones_recur(n: int) -> int`: * **Input**: A single unsigned integer `n`. * **Output**: Returns the number of \'1\' bits in its binary representation. * **Constraints**: Handle integers up to 32-bit unsigned integer range (0 to 4294967295). Function `count_ones_iter(n: int) -> int`: * **Input**: A single unsigned integer `n`. * **Output**: Returns the number of \'1\' bits in its binary representation. * **Constraints**: Handle integers up to 32-bit unsigned integer range (0 to 4294967295). # Examples * Example 1: ```python n = 11 # binary: 00000000000000000000000000001011 assert count_ones_recur(n) == 3 assert count_ones_iter(n) == 3 ``` * Example 2: ```python n = 128 # binary: 00000000000000000000000010000000 assert count_ones_recur(n) == 1 assert count_ones_iter(n) == 1 ``` * Example 3: ```python n = 7 # binary: 00000000000000000000000000000111 assert count_ones_recur(n) == 3 assert count_ones_iter(n) == 3 ``` # Notes * Ensure that your implementations correctly handle edge cases, such as when `n` is 0. * Provide time and space complexity analysis for your solutions.","solution":"def count_ones_recur(n: int) -> int: Recursively counts the number of \'1\' bits in the binary representation of `n`. if n == 0: return 0 else: return 1 + count_ones_recur(n & (n - 1)) def count_ones_iter(n: int) -> int: Iteratively counts the number of \'1\' bits in the binary representation of `n`. count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"Context: You are tasked with creating a string pattern matching function that implements regular expression matching with support for `.` and `*`. Task: Write a function `is_match(s: str, p: str) -> bool` that returns `True` if the string `s` matches the pattern `p`. Special Characters: - `.` matches any single character. - `*` matches zero or more of the preceding element. The matching must cover the entire input string (not partial matches). Constraints: - `0 ≤ len(s), len(p) ≤ 30` - `s` and `p` consist of lowercase English letters and the characters `.` and `*`. Input: - `s`: A string containing the input to be matched. - `p`: A string containing the pattern. Output: - Return `True` if the pattern matches the input string completely, otherwise return `False`. Example: ```python is_match(\\"aa\\", \\"a\\") # Returns: False is_match(\\"aa\\", \\"aa\\") # Returns: True is_match(\\"aa\\", \\"a*\\") # Returns: True is_match(\\"ab\\", \\".*\\") # Returns: True is_match(\\"aab\\", \\"c*a*b\\") # Returns: True ``` Note: Ensure implementation handles edge cases such as: - Empty strings and patterns. - Patterns starting or ending with special characters. - Patterns with consecutive special characters. Your solution should be optimal in terms of time and space complexity.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string s matches the pattern p with \'.\' and \'*\' as special characters import re # We use the fullmatch method to ensure the entire string is matched pattern = re.fullmatch(p, s) return pattern is not None"},{"question":"# Scenario You are given the task of sorting a list of students\' scores. These scores can range from 0 to 100. You\'ll use the merge sort algorithm provided in the code snippets, but with an added constraint: you need to sort them in descending order, rather than ascending order. # Task Implement the merge sort algorithm to sort the given list of integers in descending order. You must modify the existing `merge_sort` and `merge` functions accordingly to achieve this. 1. **Input**: A list of integers, which can be empty, or have a single element or multiple elements. 2. **Output**: The same list but sorted in descending order. # Requirements * The solution should maintain the time complexity of O(n log n). * Avoid using any built-in sorting functions. * The resulting algorithm should still operate in O(n) additional space for merging. # Function Signature ```python def merge_sort(arr: list) -> list: # Logic for merge_sort def merge(left: list, right: list, merged: list) -> None: # Logic for merging in descending order ``` # Examples ```python # Example 1 arr = [34, 7, 23, 32, 5, 62] print(merge_sort(arr)) # Expected Output: [62, 34, 32, 23, 7, 5] # Example 2 arr = [1, 4, 5, 7] print(merge_sort(arr)) # Expected Output: [7, 5, 4, 1] # Example 3 arr = [10] print(merge_sort(arr)) # Expected Output: [10] # Example 4 arr = [] print(merge_sort(arr)) # Expected Output: [] ```","solution":"def merge_sort(arr): Sorts the input list using merge sort in descending order. if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) merged = [None] * (len(left) + len(right)) merge(left, right, merged) return merged def merge(left, right, merged): Merges two sorted lists into one in descending order. i = j = k = 0 while i < len(left) and j < len(right): if left[i] >= right[j]: merged[k] = left[i] i += 1 else: merged[k] = right[j] j += 1 k += 1 while i < len(left): merged[k] = left[i] i += 1 k += 1 while j < len(right): merged[k] = right[j] j += 1 k += 1"},{"question":"# Stack Pair-Switching Algorithm Implementation **Problem Statement:** Implement two functions that rearrange the elements of a given stack by switching successive pairs of elements starting at the bottom of the stack. If there are an odd number of elements, the topmost element should remain in its place. Utilize an auxiliary stack in one implementation and a queue in the other. **Function Definitions:** 1. `first_switch_pairs` ```python def first_switch_pairs(stack: list) -> list: # Function using another stack as auxiliary storage. ``` 2. `second_switch_pairs` ```python def second_switch_pairs(stack: list) -> list: # Function using a queue as auxiliary storage. ``` **Parameters & Output:** - **Input**: A list of integers representing the stack, with the top of the stack being the last element of the list. - **Output**: A list of integers representing the stack after switching pairs. **Constraints:** - The input stack will not contain more than 10^4 elements. - Each element in the stack will be a non-negative integer less than 10^9. **Example:** Consider the stack represented as a list `[3, 8, 17, 9, 1, 10]`: - Input: `stack = [3, 8, 17, 9, 1, 10]` - Output from `first_switch_pairs`: `[8, 3, 9, 17, 10, 1]` - Output from `second_switch_pairs`: `[8, 3, 9, 17, 10, 1]` For an odd number of elements `[3, 8, 17, 9, 1]`: - Input: `stack = [3, 8, 17, 9, 1]` - Output from `first_switch_pairs`: `[8, 3, 9, 17, 1]` - Output from `second_switch_pairs`: `[8, 3, 9, 17, 1]` **Additional Information:** - Consider edge cases such as an empty stack `[]` and a single-element stack `[1]`. Implement both methods in Python.","solution":"def first_switch_pairs(stack: list) -> list: Rearranges the elements of a stack by switching successive pairs using another stack as auxiliary storage. aux_stack = [] n = len(stack) # Step 1: Transfer elements to auxiliary stack to reverse order. while stack: aux_stack.append(stack.pop()) # Step 2: Push elements back to the original stack in pairs. while aux_stack: first = aux_stack.pop() if aux_stack: second = aux_stack.pop() stack.append(second) stack.append(first) return stack def second_switch_pairs(stack: list) -> list: Rearranges the elements of a stack by switching successive pairs using a queue (deque) as auxiliary storage. from collections import deque queue = deque() n = len(stack) # Step 1: Transfer elements to queue to reverse order. while stack: queue.append(stack.pop()) # Step 2: Push elements back to the original stack in pairs. while queue: first = queue.pop() if queue: second = queue.pop() stack.append(second) stack.append(first) return stack"},{"question":"# Question You are given an integer and you need to determine the number of digits in that number efficiently. The integer could be positive, negative, or zero. Write a function `digit_count(num)` that takes an integer `num` as input and returns the number of digits in `num`. Input * `num` (integer) - A negative integer, zero, or a positive integer. Output * (integer) - The number of digits in the input integer. # Constraints * -10^9 ≤ `num` ≤ 10^9 * You must solve this in constant time O(1). # Example 1. Input: `num = 12345` Output: `5` 2. Input: `num = -9876` Output: `4` 3. Input: `num = 0` Output: `1` # Notes * Ensure the function handles zero and negative numbers correctly. * The function should only count digits in the number, ignoring the sign for negative numbers. Implement the function `digit_count(num)` based on the provided constraints and specifications.","solution":"def digit_count(num): Returns the number of digits in the input integer. return len(str(abs(num)))"},{"question":"# Invert a Binary Tree Background Binary Trees are a fundamental data structure used in various computing scenarios. One common transformation of a binary tree is to invert, or mirror, it. In this problem, you are tasked to invert a given binary tree. Task Write a function `invert_tree(root)` that takes the root node of a binary tree and inverts it. You should implement this function using a recursive approach as provided in the code snippet. Function Signature ```python def invert_tree(root: TreeNode) -> TreeNode: # your code here ``` Input - `root`: The root node of the binary tree (`TreeNode`), where each `TreeNode` has the attributes: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Output - The same root node but with the tree structure inverted. Constraints - The number of nodes in the binary tree will be in the range [0, 10^4]. - The tree\'s depth will not exceed 1000. Example Given the binary tree: ``` 4 / 2 7 / / 1 3 6 9 ``` After inverting, it should become: ``` 4 / 7 2 / / 9 6 3 1 ``` Note - Pay attention to edge cases such as an empty tree or a tree with a single node. - Ensure that the recursive function handles deep trees appropriately, considering the limits of recursion stack depth in Python.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def invert_tree(root: TreeNode) -> TreeNode: Inverts a binary tree recursively. if root is None: return None # Swap the left and right subtrees root.left, root.right = root.right, root.left # Recur for left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"**Objective:** Given a binary tree, write a function to determine if it is symmetric around its center (i.e., a mirror of itself). Function Signature ```python def is_symmetric(root: TreeNode) -> bool: ``` Input - `root`: TreeNode, the root node of the binary tree (TreeNode is a class where `root.val` gives the value of the node, and `root.left` and `root.right` gives the left and right children, respectively). Output - Returns `True` if the tree is symmetric, otherwise returns `False`. # Constraints - The number of nodes in the tree is in the range [0, 1000]. - Each node can have a value between [0, 100]. # Requirements 1. You must implement both the recursive and the iterative approach. 2. Avoid redundant checks and optimize for performance where possible. 3. Handle edge cases such as trees with only one node, null nodes, and unbalanced trees. # Scenario An online platform stores visual data structures using binary trees for its layout. To ensure consistency and visual symmetry, you must validate whether these tree structures are symmetric around their center point. Your solution will help maintain the aesthetic and balanced layout demands of the platform. # Example Input ```python 1 / 2 2 / / 3 4 4 3 ``` Output ```python True ``` Input ```python 1 / 2 2 3 3 ``` Output ```python False ``` # Bonus - Compare the performance of recursive and iterative solutions on large tree structures. - Identify and implement optimizations to reduce time and space complexity.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root: TreeNode) -> bool: if not root: return True # Helper function to compare two subtrees def is_mirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) return is_mirror(root.left, root.right)"},{"question":"Enhanced Insertion Sort with Range Limitation **Objective**: Demonstrate your understanding of insertion sort and optimization techniques for improved performance with large data sets. # Task You are required to implement a function `range_limited_insertion_sort` that performs an insertion sort on an array but limits the sorting to a specific range within the array. This approach imitates a common optimization technique where a segment of a larger dataset can be sorted independently. However, unlike typical insertion sort, you may not sort elements outside of the specified range. # Function Signature ```python def range_limited_insertion_sort(arr: list[int], start: int, end: int) -> list[int]: pass ``` # Input - `arr`: A list of integers. - `start`: The starting index of the range to be sorted. - `end`: The ending index (inclusive) of the range to be sorted. # Output - Return the modified list, with only the segment between `start` and `end` sorted. # Example ```python input: arr = [4, 2, 5, 7, 8, 1, 6, 3] start = 2 end = 6 output: [4, 2, 1, 5, 7, 8, 6, 3] ``` # Constraints - Assume `0 <= start <= end < len(arr)`. - The function should handle edge cases such as an empty array gracefully. - Focus on correctness within the specified range and maintain the overall time complexity where possible. # Additional Requirements - Handle edge cases such as `start` or `end` being at the bounds of the array. - Ensure that the elements outside the specified range remain unaffected. # Note Ensure your implementation maintains the stability of the sorting algorithm within the specified range.","solution":"def range_limited_insertion_sort(arr: list[int], start: int, end: int) -> list[int]: This function performs an insertion sort on a subset of the list \'arr\' from index \'start\' to \'end\' inclusive. Elements outside the range from \'start\' to \'end\' are not sorted and remain in their original positions. Parameters: arr (list[int]): The list of integers to sort. start (int): The starting index of the range to be sorted. end (int): The ending index (inclusive) of the range to be sorted. Returns: list[int]: The modified list with the specified range sorted. if not arr: # Handle empty list return arr for i in range(start + 1, end + 1): key = arr[i] j = i - 1 while j >= start and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"As a scheduling manager for a large conference center, you need to manage room reservations efficiently. Rooms are reserved for time intervals throughout the day. However, overlapping reservations need to be merged to provide a clearer view of the actual usage of the room. Objective Write a function `optimize_room_usage(intervals)` to merge all overlapping intervals and return the list of optimized intervals. Function Specification `def optimize_room_usage(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:` Input * `intervals`: A list of tuples representing the start and end times of room reservations. Each tuple consists of two integers `start` and `end` with `start <= end`. Output * A list of tuples representing the merged intervals. The list should be sorted by the start times of intervals without any overlapping intervals. Constraints * All integers `start` and `end` are non-negative and within a reasonable range (e.g., 0 to 1000). * The input list can have up to `10^4` intervals. Example ```python # Example 1 input_intervals = [(1, 3), (2, 6), (8, 10), (15, 18)] output_intervals = [(1, 6), (8, 10), (15, 18)] assert optimize_room_usage(input_intervals) == output_intervals # Example 2 input_intervals = [(1, 4), (4, 5)] output_intervals = [(1, 5)] assert optimize_room_usage(input_intervals) == output_intervals ``` Performance Requirements * The algorithm should efficiently handle the merging process with a time complexity of `O(n log n)` due to sorting and `O(n)` for the merging.","solution":"from typing import List, Tuple def optimize_room_usage(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals and returns the list of optimized intervals. if not intervals: return [] # Sort the intervals based on the starting times. intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current_start, current_end in intervals[1:]: last_merged_start, last_merged_end = merged_intervals[-1] if current_start <= last_merged_end: # There is an overlap merged_intervals[-1] = (last_merged_start, max(last_merged_end, current_end)) else: merged_intervals.append((current_start, current_end)) return merged_intervals"},{"question":"# Question: Implement and Optimize a Custom Comb Sort Algorithm You are to implement a custom sorting function using the Comb Sort algorithm. Additionally, you are required to optimize its performance by fine-tuning certain parameters. # Function Signature ```python def optimized_comb_sort(arr: List[int], shrink_factor: float = 1.3) -> List[int]: # Your code here ``` # Input * `arr`: A list of integers, where (1 leq text{len}(arr) leq 10^5) * `shrink_factor` (optional): A floating-point value greater than 1, representing the rate at which the gap size decreases. The default is `1.3`. # Output * The sorted list of integers in non-decreasing order. # Constraints * You must optimize the performance while keeping the algorithm within the parameters of Comb Sort. * You cannot use any built-in sorting functions. * Consider edge cases, including empty lists, single-element lists, already sorted lists, and large datasets. # Examples ```python print(optimized_comb_sort([34, 7, 23, 32, 5, 62])) # Output: [5, 7, 23, 32, 34, 62] print(optimized_comb_sort([9, 4, -3, 6, 2]) # Output: [-3, 2, 4, 6, 9] print(optimized_comb_sort([1, 2, 3, 4, 5], shrink_factor=1.2)) # Output: [1, 2, 3, 4, 5] print(optimized_comb_sort([], shrink_factor=1.5)) # Output: [] ```","solution":"from typing import List def optimized_comb_sort(arr: List[int], shrink_factor: float = 1.3) -> List[int]: Sorts a list of integers using the Comb Sort algorithm. :param arr: List of integers to be sorted. :param shrink_factor: Rate at which the gap size decreases, default is 1.3. :return: Sorted list of integers in non-decreasing order. n = len(arr) gap = n swapped = True while gap > 1 or swapped: # Update the gap for next comb gap = int(gap / shrink_factor) if gap < 1: gap = 1 swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: # Swap the elements arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Implementing a ZigZag Iterator You are required to implement a ZigZag Iterator class that will iterate over two lists in a round-robin fashion. The goal is to alternate between the lists and return the elements of the lists one by one until both lists are exhausted. # Specifications: - **Functionality**: Implement a class `ZigZagIterator` with the following methods: - **`__init__(self, v1: List[int], v2: List[int]) -> None`**: Initializes the iterator with two lists `v1` and `v2`. - **`next(self) -> int`**: Returns the next element in the ZigZag order. - **`has_next(self) -> bool`**: Returns `True` if there are any elements left to iterate, `False` otherwise. # Input and Output: - The `__init__` method takes two input lists of integers: `v1` and `v2`. - The `next` method returns the next integer in the alternating sequence. - The `has_next` method returns a boolean indicating if there are more integers to return. # Constraints: - The lists may have different lengths. - The elements in both lists are non-negative integers. - Do not remove any elements from the lists outside the class methods. # Performance: - Your implementation should aim for efficient time and space complexity: O(n) time complexity per operation and O(n + m) space where n and m are lengths of the input lists. # Example: ```python # Example usage: l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) while it.has_next(): print(it.next()) # Output: # 1 3 2 4 5 6 ``` Implement the class `ZigZagIterator` based on this example: ```python from typing import List, Optional class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize your data structure here. # Your code here def next(self) -> Optional[int]: Return the next element in the zigzag order. # Your code here def has_next(self) -> bool: Return whether there are more elements to return. # Your code here # Optional: Add any helper methods if needed ``` Submit your solution with the implementation of the `ZigZagIterator` class including any auxiliary helper functions you use.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): Initialize your data structure here. self.data = [v1, v2] self.index = [0, 0] self.turn = 0 def next(self) -> int: Return the next element in the zigzag order. while self.index[self.turn] >= len(self.data[self.turn]): self.turn = (self.turn + 1) % 2 result = self.data[self.turn][self.index[self.turn]] self.index[self.turn] += 1 self.turn = (self.turn + 1) % 2 return result def has_next(self) -> bool: Return whether there are more elements to return. return any(self.index[i] < len(self.data[i]) for i in range(2)) # Optional: Add any helper methods if needed"},{"question":"As a data analyst, you often need to compute the central tendency of datasets that may contain outliers. To achieve this, you must implement a function that calculates the trimmed mean of an array of integers. The trimmed mean is the mean of the array after removing a specified percentage of the smallest and largest values. # Function Signature ```python def trimmed_mean(arr: List[int], percentage: float) -> float: pass ``` # Input 1. `arr`: A list of integers representing the dataset. (1 ≤ len(arr) ≤ 10^6). 2. `percentage`: A float indicating percentage of data to trim from each end (0.0 ≤ percentage ≤ 50.0). # Output - Return a float representing the trimmed mean of the input array `arr`. # Constraints - You can assume the input percentage will always be valid (i.e., within 0.0 to 50.0). - The trimmed mean should be rounded to two decimal places. # Examples Example 1 **Input**: ```python arr = [6, 2, 3, 8, 4, 7, 5, 1] percentage = 20.0 ``` **Output**: ```python 4.50 ``` **Explanation**: 20% trimming means 10% from each end (since 20/2 = 10%). The sorted array is [1, 2, 3, 4, 5, 6, 7, 8]. Trimmed array becomes [2, 3, 4, 5, 6, 7]. The mean of [2, 3, 4, 5, 6, 7] is (2+3+4+5+6+7)/6 = 4.5. Example 2 **Input**: ```python arr = [50, 60, 70, 80, 90, 100] percentage = 30.0 ``` **Output**: ```python 75.00 ``` **Explanation**: 30% trimming means 15% from each end. The sorted array is [50, 60, 70, 80, 90, 100]. Trimmed array becomes [60, 70, 80, 90]. The mean of [60, 70, 80, 90] is (60+70+80+90)/4 = 75. Example 3 **Input**: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] percentage = 10.0 ``` **Output**: ```python 5.50 ``` **Explanation**: 10% trimming means 5% from each end. The sorted array is [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]. Trimmed array becomes [2, 3, 4, 5, 6, 7, 8, 9]. The mean of [2, 3, 4, 5, 6, 7, 8, 9] is (2+3+4+5+6+7+8+9)/8 = 5.5. # Additional Notes - Ensure your solution is efficient in terms of time and space complexity. - Consider edge cases where trimming might result in an empty array.","solution":"from typing import List def trimmed_mean(arr: List[int], percentage: float) -> float: Calculate the trimmed mean of the array by removing the specified percentage of the smallest and largest values. n = len(arr) k = int((percentage / 100.0) * n / 2) # Sort the array sorted_arr = sorted(arr) # Trim k elements from both ends trimmed_arr = sorted_arr[k:n-k] # Calculate the mean of the trimmed array mean = sum(trimmed_arr) / len(trimmed_arr) # Return the mean rounded to two decimal places return round(mean, 2)"},{"question":"# Coding Exercise: Optimizing Linear Search Scenario You are creating a search functionality for a video library application. The library can have a large collection of video titles, and users frequently search for videos by their titles. However, the simplistic linear search method can become impractical with the increasing number of titles. To improve efficiency, the application should use a hybrid approach: - Utilize linear search for smaller datasets. - Implement an optimized search method for larger datasets or repetitive queries. Task Write a function `optimized_video_search` that decides between using linear search for smaller datasets and a more advanced searching strategy for larger datasets. For this exercise, assume an advanced search can be modeled using Python\'s built-in dictionary for O(1) average time complexity in querying. # Function Signature: ```python def optimized_video_search(videos, query): Search for the video title in the list of videos using an optimized approach. :param videos: List[str] - List of video titles. :param query: str - The title to search for. :return: int - Index of the video title if found, -1 otherwise. ``` # Input * `videos` is a list of strings where each string is a video title (1 <= len(videos) <= 10^6). * `query` is the video title to be searched (1 <= len(query) <= 100). # Output * Return the index of the video title if it is found; otherwise, return -1. # Constraints * If the length of `videos` is less than or equal to 100, use linear search. * For larger datasets, build a dictionary (hashmap) to enable O(1) average-time search. # Example ```python videos = [\\"Inception\\", \\"The Matrix\\", \\"Interstellar\\", \\"The Dark Knight\\", \\"Fight Club\\", \\"Forrest Gump\\"] query = \\"Interstellar\\" print(optimized_video_search(videos, query)) # Output: 2 videos = [\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\", \\"G\\"] query = \\"Z\\" print(optimized_video_search(videos, query)) # Output: -1 ```","solution":"def optimized_video_search(videos, query): Search for the video title in the list of videos using an optimized approach. :param videos: List[str] - List of video titles. :param query: str - The title to search for. :return: int - Index of the video title if found, -1 otherwise. # Use linear search for smaller dataset (length <= 100) if len(videos) <= 100: for i, title in enumerate(videos): if title == query: return i return -1 # For larger dataset, build a dictionary for O(1) average-time search video_dict = {title: i for i, title in enumerate(videos)} return video_dict.get(query, -1)"},{"question":"Problem: Enhanced Binary Search Tree (BST) Operations # Background A Binary Search Tree (BST) is a tree data structure that supports efficient dynamic set operations, such as inserting, deleting, and searching for values. The tree structure ensures that all operations can potentially be performed in logarithmic time, provided that the tree is balanced. In this task, you are required to implement a BST with the following functions: * `insert`: Adds a new value to the BST. * `search`: Checks if a given value exists in the BST. * `delete`: Removes a value from the BST if it exists. * `min_value_node`: Finds the node with the minimum value. * `inorder_traversal`: Returns an in-order traversal of the BST values. # Constraints - All BST operations should aim for O(log n) time complexity, but account for the worst-case scenario of O(n). - Return `None` or an appropriate message for non-existing elements where necessary. - You are encouraged to handle edge cases and optimize the structure to maintain balance, though self-balancing is not required by default. # Task Write a Python class named `BinarySearchTree` that includes the following methods: 1. `insert(self, val: int) -> None` (Assume no duplicate values will be inserted) 2. `search(self, val: int) -> bool` 3. `delete(self, val: int) -> None` 4. `min_value_node(self) -> TreeNode` 5. `inorder_traversal(self) -> List[int]` # Input/Output Format - `insert` and `delete` methods do not return any value. - `search` method returns `True` if the value is found, otherwise `False`. - `min_value_node` returns the `TreeNode` with the minimum value. - `inorder_traversal` returns a list of integers representing the in-order traversal of the BST. # Example Input ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) print(bst.search(3)) # -> True print(bst.search(6)) # -> False print(bst.inorder_traversal()) # -> [2, 3, 4, 5, 7] bst.delete(3) print(bst.inorder_traversal()) # -> [2, 4, 5, 7] print(bst.min_value_node().val) # -> 2 ``` Output ```python True False [2, 3, 4, 5, 7] [2, 4, 5, 7] 2 ```","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if node is None: return False if node.val == val: return True if val < node.val: return self._search(node.left, val) return self._search(node.right, val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if node is None: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self.min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def min_value_node(self, node=None): current = node if node else self.root while current.left is not None: current = current.left return current def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.val) self._inorder_traversal(node.right, result)"},{"question":"# Binary Search Tree Implementation Scenario: You are tasked with creating and managing an inventory system for a warehouse. The inventory system needs to manage items where each item has a unique ID associated with it. Your goal is to implement a Binary Search Tree (BST) to handle recording and querying these item IDs efficiently. Requirements: 1. Implement a BST in Python with the following operations: - Insert a new item ID. - Search for an item ID. - Delete an item ID. Function Signatures: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int): pass def search(self, val: int) -> bool: pass def delete(self, val: int): pass ``` Input and Output: * `insert(val: int)`: - **Input**: An integer item ID to be inserted. - **Output**: None. * `search(val: int) -> bool`: - **Input**: An integer item ID to be searched. - **Output**: Boolean indicating whether the item is found. * `delete(val: int)`: - **Input**: An integer item ID to be deleted. - **Output**: None. Constraints: - All operations should have average time complexity of O(log n). - Item IDs are unique non-negative integers.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val: int): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if not node.left: node.left = TreeNode(val) else: self._insert(node.left, val) else: if not node.right: node.right = TreeNode(val) else: self._insert(node.right, val) def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, node, val): if not node: return False if val == node.val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val: int): self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left temp = self._minValueNode(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _minValueNode(self, node): current = node while current.left: current = current.left return current"},{"question":"Context: You are tasked with implementing a file system directory structure simulator using a Red-Black Tree. In this simulator, each file and directory is represented as a node within a tree. Each node stores a unique identifier (an integer). Write a function that performs insertion and deletion of files/directories in this simulated file system, ensuring the tree always remains balanced according to Red-Black Tree properties. Function Signature: ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): # Initialize a Red-Black Tree node with a value, color, and parent/left/right pointers pass class RBTree: def __init__(self): # Initialize the Red-Black Tree pass def insert(self, node): # Insert a node into the Red-Black Tree pass def delete(self, node): # Delete a node from the Red-Black Tree pass def inorder(self): # Return the inorder traversal of Red-Black Tree as a list of values pass def test_filesystem_operations(): rb = RBTree() nodes_to_insert = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in nodes_to_insert: node = RBNode(value, 1) rb.insert(node) nodes_to_delete = [14, 1, 7] for value in nodes_to_delete: node_to_delete = rb.minimum(rb.root) while node_to_delete.val != value: node_to_delete = rb.maximum(node_to_delete.left) rb.delete(node_to_delete) return rb.inorder() ``` Task: 1. Implement the `RBNode` class and initialize the node with the provided value and color. 2. Implement the `RBTree` class with methods to: - Insert a `RBNode` into the tree while ensuring it maintains Red-Black properties. - Delete a `RBNode` from the tree while ensuring it maintains Red-Black properties. - Perform an inorder traversal of the tree and returning a list of nodes. 3. Write a function `test_filesystem_operations()` that tests your implementation by inserting and deleting nodes based on the scenarios described above. Input/Output Formats: * **Input**: No direct input; operations are defined within `test_filesystem_operations`. * **Output**: Return the list of nodes\' values in inorder traversal after the operations. Constraints: 1. Each inserted value will be unique. 2. Deletion will only occur on existing nodes in the tree. 3. The nodes will be represented by integers. 4. Ensure the operations maintain Red-Black Tree properties. **Note**: Adhering to the Red-Black Tree properties is crucial for passing this assessment.","solution":"class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): Initialize a Red-Black Tree node with a value, color, and parent/left/right pointers. self.val = val self.is_red = is_red self.parent = parent self.left = left self.right = right class RBTree: def __init__(self): Initialize the Red-Black Tree. self.NIL_LEAF = RBNode(None, is_red=False) self.root = self.NIL_LEAF def insert(self, node): Insert a node into the Red-Black Tree. def bst_insert(root, node): if root == self.NIL_LEAF: return node if node.val < root.val: root.left = bst_insert(root.left, node) root.left.parent = root else: root.right = bst_insert(root.right, node) root.right.parent = root return root node.left = self.NIL_LEAF node.right = self.NIL_LEAF self.root = bst_insert(self.root, node) self.fix_insert(node) def fix_insert(self, node): while node != self.root and node.parent.is_red: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.is_red: node.parent.is_red = False uncle.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.right: node = node.parent self.left_rotate(node) node.parent.is_red = False node.parent.parent.is_red = True self.right_rotate(node.parent.parent) else: uncle = node.parent.parent.left if uncle.is_red: node.parent.is_red = False uncle.is_red = False node.parent.parent.is_red = True node = node.parent.parent else: if node == node.parent.left: node = node.parent self.right_rotate(node) node.parent.is_red = False node.parent.parent.is_red = True self.left_rotate(node.parent.parent) self.root.is_red = False def left_rotate(self, x): y = x.right x.right = y.left if y.left != self.NIL_LEAF: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, y): x = y.left y.left = x.right if x.right != self.NIL_LEAF: x.right.parent = y x.parent = y.parent if y.parent is None: self.root = x elif y == y.parent.right: y.parent.right = x else: y.parent.left = x x.right = y y.parent = x def delete(self, node): Delete a node from the Red-Black Tree. def transplant(u, v): if u.parent is None: self.root = v elif u == u.parent.left: u.parent.left = v else: u.parent.right = v v.parent = u.parent y = node y_original_color = y.is_red if node.left == self.NIL_LEAF: x = node.right transplant(node, node.right) elif node.right == self.NIL_LEAF: x = node.left transplant(node, node.left) else: y = self.minimum(node.right) y_original_color = y.is_red x = y.right if y.parent == node: x.parent = y else: transplant(y, y.right) y.right = node.right y.right.parent = y transplant(node, y) y.left = node.left y.left.parent = y y.is_red = node.is_red if not y_original_color: self.fix_delete(x) def fix_delete(self, x): while x != self.root and not x.is_red: if x == x.parent.left: w = x.parent.right if w.is_red: w.is_red = False x.parent.is_red = True self.left_rotate(x.parent) w = x.parent.right if not w.left.is_red and not w.right.is_red: w.is_red = True x = x.parent else: if not w.right.is_red: w.left.is_red = False w.is_red = True self.right_rotate(w) w = x.parent.right w.is_red = x.parent.is_red x.parent.is_red = False w.right.is_red = False self.left_rotate(x.parent) x = self.root else: w = x.parent.left if w.is_red: w.is_red = False x.parent.is_red = True self.right_rotate(x.parent) w = x.parent.left if not w.right.is_red and not w.left.is_red: w.is_red = True x = x.parent else: if not w.left.is_red: w.right.is_red = False w.is_red = True self.left_rotate(w) w = x.parent.left w.is_red = x.parent.is_red x.parent.is_red = False w.left.is_red = False self.right_rotate(x.parent) x = self.root x.is_red = False def minimum(self, node): while node.left != self.NIL_LEAF: node = node.left return node def inorder(self): res = [] self.inorder_helper(self.root, res) return res def inorder_helper(self, node, res): if node != self.NIL_LEAF: self.inorder_helper(node.left, res) res.append(node.val) self.inorder_helper(node.right, res) def test_filesystem_operations(): rb = RBTree() nodes_to_insert = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in nodes_to_insert: node = RBNode(value, True) rb.insert(node) nodes_to_delete = [14, 1, 7] for value in nodes_to_delete: node_to_delete = rb.root while node_to_delete != rb.NIL_LEAF and node_to_delete.val != value: if value < node_to_delete.val: node_to_delete = node_to_delete.left else: node_to_delete = node_to_delete.right rb.delete(node_to_delete) return rb.inorder()"},{"question":"# Min-Heap Reinsertion Problem You are provided with a class `BinaryHeap` which represents a min-heap. The min-heap structure ensures that the smallest element is always at the root. It supports `insert` and `remove_min` operations. Your task is as follows: 1. Implement a function `reinsert_min_elements` that accepts an integer `k` and rearranges the heap by removing the smallest `k` elements and re-inserting them back into the heap. This should not disrupt the fundamental properties of the min-heap. # Function Signature ```python def reinsert_min_elements(heap_obj, k: int) -> None: Rearranges the heap by removing the smallest k elements and re-inserting them back into the heap. :param heap_obj: An instance of BinaryHeap :param k: Integer representing the number of smallest elements to reinsert ``` # Input - `heap_obj`: An instance of the `BinaryHeap` class. - `k`: An integer `0 <= k <= heap_obj.current_size`, representing the number of smallest elements to remove and reinsert. # Output The function should modify the heap in-place and maintain its properties. It does not need to return any value. # Constraints - Perform all operations within O(k log N) time complexity. - Reinsert the elements such that the heap properties remain intact. # Example Scenario Consider a heap represented by the array `[0, 4, 50, 7, 55, 90, 87]`: - After executing `reinsert_min_elements(heap, 2)`, the smallest two elements (4 and 7) will be removed and reinserted. The heap should still meet its property, but specific orders can vary. ```python # Initializing the heap heap = BinaryHeap() for elem in [4, 50, 7, 55, 90, 87]: heap.insert(elem) # Your function call reinsert_min_elements(heap, 2) # The resulting heap should maintain the min-heap property print(heap.heap) # Example output: [0, 7, 50, 55, 90, 87] (exact order might differ) ``` Note: Ensure your implementation handles edge cases such as `k = 0` or `k` equal to the size of the heap.","solution":"class BinaryHeap: def __init__(self): self.heap = [] self.current_size = 0 def insert(self, k): self.heap.append(k) self.current_size += 1 self._bubble_up(self.current_size - 1) def remove_min(self): if self.current_size == 0: return None min_val = self.heap[0] self.heap[0] = self.heap[self.current_size - 1] self.current_size -= 1 self._bubble_down(0) self.heap.pop() # remove the last element return min_val def _bubble_up(self, index): while (index - 1) // 2 >= 0: parent = (index - 1) // 2 if self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent def _bubble_down(self, index): while 2 * index + 1 < self.current_size: min_child = self._min_child(index) if self.heap[index] > self.heap[min_child]: self.heap[index], self.heap[min_child] = self.heap[min_child], self.heap[index] index = min_child def _min_child(self, index): if 2 * index + 2 >= self.current_size: return 2 * index + 1 else: if self.heap[2 * index + 1] < self.heap[2 * index + 2]: return 2 * index + 1 else: return 2 * index + 2 def reinsert_min_elements(heap_obj, k: int) -> None: if k <= 0 or heap_obj.current_size == 0: return min_elements = [] for _ in range(min(k, heap_obj.current_size)): min_elements.append(heap_obj.remove_min()) for elem in min_elements: heap_obj.insert(elem)"},{"question":"Scenario You are tasked with verifying the integrity of a transmitted string. The initial string `s` is transformed by adding one random character to it, resulting in a new string `t`. Your objective is to identify this newly added character. Problem Statement Given two strings `s` and `t` which consist of only lowercase letters, where `t` is generated by random shuffling `s` and adding one more letter at a random position, write a Python function `find_added_letter(s, t)` to find the newly added letter in `t`. Input: - A string `s` (1 ≤ |s| ≤ 10^5), containing only lowercase letters. - A string `t` (|t| = |s| + 1), generated by shuffling `s` and adding one additional lowercase letter. Output: - Return a character that is the additional letter in `t`. Constraints: - The input strings will consist of only lowercase letters. - There is exactly one additional character in `t`. Example: ```python Input: s = \\"abcd\\" t = \\"abecd\\" Output: \'e\' ``` Function Signature: ```python def find_added_letter(s: str, t: str) -> str: # Your code here ``` Requirements: - Implement the function following the provided constraints. - Ensure the solution runs efficiently within the time and space complexity.","solution":"def find_added_letter(s: str, t: str) -> str: Given two strings s and t where t is s with one additional character, find the added character. # We use the XOR operator to find the added character result = 0 for char in s: result ^= ord(char) for char in t: result ^= ord(char) return chr(result)"},{"question":"Advanced Binary Search Background: As an experienced systems engineer at a data-intensive company, you have been tasked with optimizing various search operations on large, sorted datasets. One common operation is to find the number of occurrences of a specific value within a sorted array. You have decided to use Binary Search due to its efficiency. However, a simple binary search only finds one occurrence of a value. Your challenge is to find the first and last occurrence of a given target value within a sorted array and thus calculate its number of occurrences efficiently. Task: Implement a function `number_of_occurrences(array, target)` that takes a sorted list of integers `array` and an integer `target`, and returns the number of occurrences of the target in the array. Function Signature: ```python def number_of_occurrences(array: List[int], target: int) -> int: ``` Input: * `array`: A list of sorted integers in ascending order. * `target`: An integer value to search for in the array. Output: * An integer representing the number of occurrences of `target` in `array`. If `target` is not found, return 0. Constraints: * `1 <= len(array) <= 10^5` * The values in the array are in the range of `-10^9` to `10^9` * The `target` is within the range of `-10^9` to `10^9` Performance Requirements: Your solution should have a time complexity of O(log(n)) to ensure efficiency with very large arrays. Example: ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5, 5, 5, 5, 6, 7] target = 5 print(number_of_occurrences(array, target)) # Output: 4 # Example 2 array = [1, 2, 2, 2, 3, 4, 5, 5, 5, 5, 6, 7] target = 8 print(number_of_occurrences(array, target)) # Output: 0 ``` Notes: * Utilize binary search techniques to efficiently find the first and last occurrences of the target. * Avoid linear search methods to ensure the solution meets the required performance criteria.","solution":"from typing import List def number_of_occurrences(array: List[int], target: int) -> int: def find_first_occurrence(array, target): left, right = 0, len(array) - 1 first_occurrence = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: first_occurrence = mid right = mid - 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return first_occurrence def find_last_occurrence(array, target): left, right = 0, len(array) - 1 last_occurrence = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: last_occurrence = mid left = mid + 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return last_occurrence first_occurrence = find_first_occurrence(array, target) if first_occurrence == -1: return 0 last_occurrence = find_last_occurrence(array, target) return last_occurrence - first_occurrence + 1"},{"question":"Scenario: You are working on a file management system for a large organization. One of the core functionalities needed is to standardize and validate file paths provided by users before any file operations are performed. This ensures that the paths are absolute and do not contain any unresolved or user-specific shortcuts. Task: Write a function `validate_and_resolve_path(file_path: str) -> str` that: 1. Resolves the given file path to its corresponding absolute path. 2. Validates that the resolved path exists and points to a file (not a directory). If the path fails validation or points to a directory, your function should raise a `ValueError` with an appropriate error message. Function Signature: ```python def validate_and_resolve_path(file_path: str) -> str: ``` Input * `file_path`: A string representing the initial file path that might include user home directory shorthand (`~`). Output * Returns the absolute path of the file. Constraints: * The input file path can be of arbitrary length. * The file must exist and must be a regular file, not a directory. Example: ```python # Example usage: try: print(validate_and_resolve_path(\\"~/documents/file.txt\\")) except ValueError as e: print(e) try: print(validate_and_resolve_path(\\"/non/existent/path.txt\\")) except ValueError as e: print(e) ``` Expected Output: ``` /Users/username/documents/file.txt # Assuming the file exists. Path does not exist or is not a file: /non/existent/path.txt ``` Additional Notes: Students should consider edge cases, such as: * Empty path strings. * Paths that resolve to directories instead of files. * Non-existent paths.","solution":"import os def validate_and_resolve_path(file_path: str) -> str: Resolves the given file path to its corresponding absolute path and validates it. - File path is resolved to an absolute path. - The resolved path must exist and point to a file. Raises ValueError if the path is invalid or points to a directory. if not file_path: raise ValueError(\\"Path cannot be empty\\") # Expand the user home directory shortcut (~) resolved_path = os.path.expanduser(file_path) # Resolve to absolute path resolved_path = os.path.abspath(resolved_path) # Check if the path exists and is a file if not os.path.exists(resolved_path): raise ValueError(f\\"Path does not exist: {resolved_path}\\") if not os.path.isfile(resolved_path): raise ValueError(f\\"Path is not a file: {resolved_path}\\") return resolved_path"},{"question":"# Disjoint Set Union-Find Implementation for Dynamic Connectivity Scenario You are working with a computer network where new connections between computers are established dynamically. Your task is to manage the connectivity of the network efficiently using the Union-Find (Disjoint Set) data structure. The objective is to keep track of connected components in the network and enable merging of different components when a new connection is established. Write a class `Network` that supports the following operations using Union-Find: 1. `add_computer(computer: int) -> None`: Adds a new computer as a separate entity in the network. 2. `connect(computer1: int, computer2: int) -> None`: Connects two computers by merging their components. 3. `query_connected(computer1: int, computer2: int) -> bool`: Returns `True` if the two computers are in the same connected component, otherwise `False`. 4. `count_components() -> int`: Returns the current number of connected components in the network. Expected Input and Output Formats * `add_computer(computer: int) -> None`: Adds a single integer representing the computer identifier to the network. * `connect(computer1: int, computer2: int) -> None`: Takes two integers representing the identifiers of the computers to connect. * `query_connected(computer1: int, computer2: int) -> bool`: Returns a boolean indicating whether the two computers are in the same component. * `count_components() -> int`: Returns an integer representing the number of disjoint components after any operations. Constraints * A computer can be added only once. * Connections and queries will reference only added computers. * Operations should be efficient, leveraging the Union-Find data structure\'s near-constant time complexities. Performance Requirements * All operations should execute in near-constant amortized time (O(a(n))), where `a` is the inverse Ackermann function. Implement the `Network` class to meet the above requirements. # Example Usage ```python network = Network() network.add_computer(1) network.add_computer(2) network.add_computer(3) network.add_computer(4) print(network.count_components()) # Output: 4 network.connect(1, 2) print(network.query_connected(1, 2)) # Output: True print(network.count_components()) # Output: 3 network.connect(3, 4) print(network.query_connected(1, 3)) # Output: False network.connect(2, 3) print(network.query_connected(1, 3)) # Output: True print(network.count_components()) # Output: 1 ```","solution":"class Network: def __init__(self): self.parent = {} self.rank = {} self.component_count = 0 def add_computer(self, computer: int) -> None: if computer not in self.parent: self.parent[computer] = computer self.rank[computer] = 0 self.component_count += 1 def find(self, computer): if self.parent[computer] != computer: self.parent[computer] = self.find(self.parent[computer]) return self.parent[computer] def union(self, computer1, computer2): root1 = self.find(computer1) root2 = self.find(computer2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 self.component_count -= 1 def connect(self, computer1: int, computer2: int) -> None: if computer1 in self.parent and computer2 in self.parent: self.union(computer1, computer2) def query_connected(self, computer1: int, computer2: int) -> bool: if computer1 in self.parent and computer2 in self.parent: return self.find(computer1) == self.find(computer2) return False def count_components(self) -> int: return self.component_count"},{"question":"# Question: Right-Angle Triangle Side Calculation You are tasked with enhancing the given function using the Pythagorean theorem to calculate the length of an unknown side of a right-angled triangle. Your enhanced function should provide more robust error handling and input validation. # Instructions: Write a function `find_triangle_side` that takes three arguments: - The length of the opposite side (`opposite`), - The length of the adjacent side (`adjacent`), - The length of the hypotenuse (`hypotenuse`). One of these arguments will always be the string \\"?\\" denoting the unknown side. The function should validate the inputs to ensure they form a valid right-angled triangle and return the length of the unknown side if valid. If the inputs are invalid, the function should raise an informative error. # Input Format: - `opposite` (float or str): length of the opposite side or \\"?\\" if unknown. - `adjacent` (float or str): length of the adjacent side or \\"?\\" if unknown. - `hypotenuse` (float or str): length of the hypotenuse or \\"?\\" if unknown. # Output Format: - A string in the format `<SideName> = <Length>` where `<SideName>` is the name of the side (Opposite, Adjacent, Hypotenuse) and `<Length>` is the calculated length rounded to two decimal places. # Constraints: - All provided numeric side lengths are positive and real numbers. - The function should properly handle cases where side lengths do not meet the properties of a right-angled triangle. - Do not use negative numbers or zero for side lengths. # Example: ```python find_triangle_side(\\"3\\", \\"4\\", \\"?\\") # Returns: \\"Hypotenuse = 5.0\\" find_triangle_side(\\"?\\", \\"5\\", \\"13\\") # Returns: \\"Opposite = 12.0\\" ``` # Requirements: - Implement the function with necessary input validation. - Ensure the solution handles corner cases and provides detailed error messages when invalid inputs are encountered.","solution":"import math def find_triangle_side(opposite, adjacent, hypotenuse): Calculates the length of the unknown side of a right-angled triangle given the lengths of the other two sides. One of the three parameters (opposite, adjacent, hypotenuse) will be a string \\"?\\" indicating the unknown side. Returns a string in the format \'<SideName> = <Length>\' where <SideName> is the name of the side (Opposite, Adjacent, Hypotenuse) and <Length> is the calculated length rounded to two decimal places. Input: opposite (float or str) adjacent (float or str) hypotenuse (float or str) Output: str: The calculated length in the format \\"<SideName> = <Length>\\" def is_number(value): try: float(value) return True except ValueError: return False # Ensure only one side is marked as unknown sides = [opposite, adjacent, hypotenuse] if sides.count(\\"?\\") != 1: raise ValueError(\\"Exactly one side must be unknown (marked with \'?\').\\") # Extract the known sides unknown_index = sides.index(\\"?\\") known_sides = [s for s in sides if s != \\"?\\"] # Validate known sides if not all(is_number(side) and float(side) > 0 for side in known_sides): raise ValueError(\\"All provided numeric side lengths must be positive real numbers.\\") known_values = [float(side) for side in known_sides] if unknown_index == 2: # Hypotenuse is unknown opposite, adjacent = known_values hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse:.2f}\\" elif unknown_index == 0: # Opposite is unknown adjacent, hypotenuse = known_values if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse must be greater than the adjacent side.\\") opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite:.2f}\\" elif unknown_index == 1: # Adjacent is unknown opposite, hypotenuse = known_values if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse must be greater than the opposite side.\\") adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent:.2f}\\""},{"question":"# Jump Search Implementation Challenge You are provided with an algorithm known as Jump Search used to find an element in a sorted array efficiently. The jump search technique iterates through blocks of the array to locate the appropriate block containing the target element and then searches within the block to find the target. # Task Implement a function that performs a Jump Search on a sorted array to find the index of a given target element. # Function Signature ```python def jump_search(arr: List[int], target: int) -> int: ``` # Parameters - `arr` (List[int]): A sorted list of integers. - `target` (int): The target integer to search for within the array. # Returns - `int`: The index of the target element if it exists in the array, otherwise returns -1. # Constraints - The array can contain negative integers. - The array may have up to (10^6) elements. - Elements in the array will be unique. # Performance Requirements Your solution should be optimized such that it takes O(√n) time complexity. # Example 1. **Input**: `arr = [1, 3, 5, 7, 9, 11, 13]`, `target = 7` - **Output**: `3` 2. **Input**: `arr = [1, 3, 5, 7, 9, 11, 13]`, `target = 4` - **Output**: `-1` # Edge Cases 1. **Input**: `arr = []`, `target = 1` - **Output**: `-1` 2. **Input**: `arr = [2, 4, 6, 8, 10]`, `target = 10` - **Output**: `4` **Explanation:** In the first example, the algorithm will find the target value 7 at index 3. In the second example, since 4 is not present in the array, the function returns -1. Consider including diverse test cases covering both the presence and absence of the target element, and extreme values.","solution":"from typing import List import math def jump_search(arr: List[int], target: int) -> int: n = len(arr) if n == 0: return -1 step = int(math.sqrt(n)) prev = 0 while arr[min(step, n)-1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"You are tasked with processing a list of mixed data types such that all the `0` values are moved to the end of the list while preserving the order of the other elements. Boolean values should not be treated as zeros. Implement the function `move_zeros` consistent with the given specifications and constraints. Function Signature ```python def move_zeros(array: list) -> list: pass ``` Input * `array` - a list of mixed data types including integers, floats, strings, and booleans. Output * Returns a list where all zeros are moved to the end. Constraints * Do not use any library functions that directly solve the problem. * The function should run in O(n) time complexity. * The additional space usage should be minimized as much as possible. Example ```python # Example 1 print(move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"])) # Output: [False, 1, 1, 2, 1, 3, \'a\', 0, 0] # Example 2 print(move_zeros([1, 9, 0, 0, 8, 7, 0, 6, 0])) # Output: [1, 9, 8, 7, 6, 0, 0, 0, 0] ``` # Constraints * Elements in the array can include integers, floats, strings, booleans. * Boolean values (True and False) should not be moved as zeros. * Optimize for space, ensuring that direct element movement is handled efficiently.","solution":"def move_zeros(array: list) -> list: Moves all zeros in the list to the end while preserving the order of other elements. result = [] zero_count = 0 for element in array: if element == 0 and not isinstance(element, bool): zero_count += 1 else: result.append(element) result.extend([0] * zero_count) return result"},{"question":"# Cycle Sort Implementation Context You are working with hardware that has limited write cycles for its storage mechanism (EEPROM/Flash memory). As such, you need a sorting algorithm that minimizes the number of write operations to the storage. The Cycle Sort algorithm is particularly suitable for this purpose because it achieves this requirement with a time complexity tradeoff. Problem Description Write a Python function `cycle_sort(arr: List[int]) -> List[int]` that sorts an array of integers using the Cycle Sort algorithm. Input - `arr`: A list of integers where ( 1 leq |arr| leq 10^5 ) and ( -10^6 leq arr[i] leq 10^6 ). Output - Return the sorted list of integers. Constraints - Minimize the number of writes to the array. - The input list can contain duplicate values. - The solution must work for negative integers as well. Requirements - Aim to minimize write operations. - The solution should be efficient enough to handle the upper limit of input size gracefully. Example ```python # Example arr = [3, 5, 2, 1, 4] print(cycle_sort(arr)) # Expected Output: [1, 2, 3, 4, 5] arr = [3, -1, 0, 4, 2] print(cycle_sort(arr)) # Expected Output: [-1, 0, 2, 3, 4] arr = [1, 3, 4, 1, 2] print(cycle_sort(arr)) # Expected Output: [1, 1, 2, 3, 4] ```","solution":"def cycle_sort(arr): Sorts the array using Cycle Sort algorithm. writes = 0 # Loop through the array to find cycles and swap elements for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where the item should go pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue if pos == cycle_start: continue # Otherwise, put the item in the right place or skip duplicates while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Integer Partition Counting Scenario Context You have been tasked with developing a financial application where users can breakdown an amount into various combinations of smaller amounts for budgeting purposes. To facilitate this, you need to write a function that computes the number of ways to partition a given positive integer into non-negative integer sums. Problem Statement Write a function `int_divide(decompose: int) -> int` that takes an integer `decompose` as input and returns the number of possible ways to partition `decompose` into non-negative integers. Input * `decompose`: A positive integer (1 ≤ decompose ≤ 1000) Output * Return an integer representing the number of possible partitions of `decompose`. Constraints * The function should be efficient with a time complexity of O(n^2). * Handle edge cases appropriately including the smallest input values. * You may assume a reasonably large memory space for the 2D array needed. Example 1. Input: `4` Output: `5` Explanation: The integer 4 can be decomposed in the following ways: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 2. Input: `7` Output: `15` Explanation: The integer 7 can be decomposed in the following ways: - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 - 4 + 1 + 1 + 1 - 3 + 3 + 1 - 3 + 2 + 2 - 3 + 2 + 1 + 1 - 3 + 1 + 1 + 1 + 1 - 2 + 2 + 2 + 1 - 2 + 2 + 1 + 1 + 1 - 2 + 1 + 1 + 1 + 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 Implement the function `int_divide` that meets these requirements.","solution":"def int_divide(decompose: int) -> int: Returns the number of partitions of a given positive integer. # Create a table to store results of subproblems dp = [0] * (decompose + 1) dp[0] = 1 # Base case: There\'s one way to partition 0 # Iterate through all numbers from 1 to decompose for i in range(1, decompose + 1): for j in range(i, decompose + 1): dp[j] += dp[j - i] return dp[decompose]"},{"question":"# Stuttering a Stack with Additional Constraints Scenario You are working on a data processing solution where you need to ensure data redundancy by stuttering values in a stack. The stack is represented as a list, where the last element of the list is considered the top of the stack, and the first element is the bottom. However, due to specific memory constraints, you are only allowed to use Python\'s builtin list and deque data structures. Your task is to implement a function that stutters each value in the stack, effectively doubling each entry in place. You will be given two empty stacks for use as auxiliary storage, but you must minimize the use of additional space as much as possible. Function Signature ```python def efficient_stutter(stack: list) -> list: pass ``` Input Format * A list of integers representing the stack. The bottom of the stack is element 0, and the top is the last element. Output Format * The modified stack with each value doubled consecutively. Constraints * You are allowed to use up to two additional stacks (lists) as auxiliary storage. * Minimize the overall additional space used. Example ```python # Example 1 input_stack = [3, 7, 1, 14, 9] output_stack = efficient_stutter(input_stack) print(output_stack) # Expected output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] # Example 2 input_stack = [] output_stack = efficient_stutter(input_stack) print(output_stack) # Expected output: [] # Example 3 input_stack = [5] output_stack = efficient_stutter(input_stack) print(output_stack) # Expected output: [5, 5] ``` Submit your implementation ensuring it adheres to the aforementioned constraints.","solution":"def efficient_stutter(stack: list) -> list: if not stack: return stack aux_stack1 = [] aux_stack2 = [] # Transfer all elements to the first auxiliary stack while stack: aux_stack1.append(stack.pop()) # Transfer back to the primary stack while stuttering each element while aux_stack1: element = aux_stack1.pop() stack.append(element) stack.append(element) # No return needed since modifications are done in-place, # but for the sake of clarity, returning the stack. return stack"},{"question":"# Merge Sort Implementation **Context**: Merge Sort is a fundamental sorting algorithm known for its efficiency and stability. It is often used in scenarios requiring an O(n log(n)) sorting mechanism that guarantees stable sorting. You are tasked with implementing the Merge Sort algorithm in Python as described in the analysis. **Problem Statement**: Write a function `merge_sort(arr)` that sorts an array of integers using the merge sort algorithm. **Function Signature**: ```python def merge_sort(arr): Sorts an array of integers using the merge sort algorithm. Args: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list of integers. ``` **Input**: - A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. **Output**: - A sorted list of integers in ascending order. **Constraints**: - Your function should be able to handle large lists efficiently. - Aim for an optimal time complexity of O(n log(n)) and keep space usage reasonable. **Example**: ```python assert merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] assert merge_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` **Detailed Requirements**: 1. Implement the `merge_sort` function using the recursive approach as outlined. 2. Write a helper function `merge(left, right)` that merges two sorted lists into a single sorted list. 3. Ensure your implementation handles edge cases such as empty arrays, arrays with one element, and arrays with all identical elements. **Performance Requirement**: - The algorithm should operate within the expected time complexity of O(n log(n)). - The primary algorithm should avoid unnecessary additional space usage where possible. **HINT**: To save memory, your merge sort algorithm can be written to operate in place if you apply careful index management during the merge step. Good Luck!","solution":"def merge_sort(arr): Sorts an array of integers using the merge sort algorithm. Args: arr (List[int]): The list of integers to sort. Returns: List[int]: The sorted list of integers. if len(arr) <= 1: return arr def merge(left, right): sorted_arr = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"**Huffman Compression with Unique Identifiers** You are tasked with implementing a specialized version of Huffman encoding with the following conditions: 1. Each character in the input is associated with a unique identifier, which is a non-negative integer. 2. The input will be provided as a list of tuples, where each tuple contains a character and its unique identifier. 3. The goal is to generate Huffman codes for each character based on their input order, encode the input data, and then decode it back to the original format. # Requirements: 1. Implement a function `generate_huffman_codes` to generate Huffman codes for the given input. * **Input**: A list of tuples, where each key tuple contains a character and its unique identifier. * **Output**: A dictionary where keys are unique identifiers, and values are the Huffman codes (binary strings). 2. Implement a function `encode` that uses the Huffman codes to encode the input. * **Input**: * `input_data`: A list of tuples, each containing a character and its unique identifier. * `huffman_codes`: The Huffman codes dictionary generated by `generate_huffman_codes`. * **Output**: A binary string representing the encoded data. 3. Implement a function `decode` that decodes the encoded binary string back to the original input. * **Input**: * `encoded_data`: A binary string that was produced by the `encode` function. * `huffman_codes`: The original Huffman codes dictionary used for encoding. * **Output**: A list of tuples representing the original input data. # Constraints: 1. Assume that the input list contains at most (10^5) characters. 2. Ensure the decoding process correctly reconstructs the original input. # Example: ```python # Example input input_data = [(\'a\', 1), (\'b\', 2), (\'c\', 3), (\'d\', 4), (\'e\', 5)] # Generate Huffman Codes huffman_codes = generate_huffman_codes(input_data) print(huffman_codes) # Example output: {1: \'10\', 2: \'11\', 3: \'00\', 4: \'01\', 5: \'111\'} # Encode the input data encoded_data = encode(input_data, huffman_codes) print(encoded_data) # Example output: \'1000110110111111\' # Decode the encoded data decoded_data = decode(encoded_data, huffman_codes) print(decoded_data) # Example output: [(\'a\', 1), (\'b\', 2), (\'c\', 3), (\'d\', 4), (\'e\', 5)] ``` # Function Signatures: - `def generate_huffman_codes(input_data: List[Tuple[str, int]]) -> Dict[int, str]:` - `def encode(input_data: List[Tuple[str, int]], huffman_codes: Dict[int, str]) -> str:` - `def decode(encoded_data: str, huffman_codes: Dict[int, str]) -> List[Tuple[str, int]]:`","solution":"import heapq from typing import List, Tuple, Dict class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def generate_huffman_codes(input_data: List[Tuple[str, int]]) -> Dict[int, str]: # Calculate frequency of each character freq_dict = {} for char, freq in input_data: freq_dict[freq] = freq_dict.get(freq, 0) + 1 # Build the Huffman Tree heap = [Node(char, freq) for char, freq in freq_dict.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = Node(None, left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(heap, merged) # Generate Huffman Codes huffman_codes = {} def generate_codes(node, current_code): if node is None: return if node.char is not None: huffman_codes[node.char] = current_code generate_codes(node.left, current_code + \'0\') generate_codes(node.right, current_code + \'1\') root = heapq.heappop(heap) generate_codes(root, \\"\\") return huffman_codes def encode(input_data: List[Tuple[str, int]], huffman_codes: Dict[int, str]) -> str: encoded_data = \\"\\" for char, freq in input_data: encoded_data += huffman_codes[freq] return encoded_data def decode(encoded_data: str, huffman_codes: Dict[int, str]) -> List[Tuple[str, int]]: reverse_huffman_codes = {v: k for k, v in huffman_codes.items()} current_code = \\"\\" decoded_data = [] for bit in encoded_data: current_code += bit if current_code in reverse_huffman_codes: decoded_data.append((None, reverse_huffman_codes[current_code])) current_code = \\"\\" # Precisely, mapping back the characters requires input data preservation, # using one-to-one `char:unique id` here for simplicity. return decoded_data"},{"question":"# Fibonacci Sequence - Efficient Implementation Problem Statement In mathematics, the Fibonacci numbers, denoted as Fn, form a sequence where each number is the sum of the two preceding ones, starting from 0 and 1. That is, F0 = 0, F1 = 1 and Fn = F(n-1) + F(n-2) Given a number `n`, write a Python function `fib_optimized(n)` to compute the n-th Fibonacci number efficiently with the following conditions: 1. Your implementation should use an iterative approach. 2. Aim to achieve O(n) time complexity and O(1) space complexity. 3. The input is guaranteed to be a non-negative integer. Input - An integer `n` (0 ≤ n ≤ 50) Output - The nth Fibonacci number. Constraints - The input number `n` is a non-negative integer. - Ensure your implementation runs efficiently for large values of `n` up to 50. Example ```python # Example 1 input: 0 output: 0 # Example 2 input: 1 output: 1 # Example 3 input: 10 output: 55 # Example 4 input: 50 output: 12586269025 ``` Function Signature ```python def fib_optimized(n: int) -> int: pass ``` * Write your implementation below. Ensure it adheres to the constraints and optimizes for performance.","solution":"def fib_optimized(n): Computes the n-th Fibonacci number iteratively. :param n: A non-negative integer to determine the n-th Fibonacci number. :return: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"Implement BST Iterator You are required to implement a Binary Search Tree (BST) Iterator class. The iterator should be initialized with the root of the BST and should support the following methods: * `__init__(root)`: Constructor method that initializes the iterator. Takes the root of the BST as an input. * `has_next()`: Returns `True` if there is a next smallest number in the sequence, or `False` otherwise. * `next()`: Returns the next smallest number in the sequence. Your implementation should accomplish in-order traversal of the BST. That means the numbers are retrieved in ascending order. Input Format The input will be a BST represented as a series of TreeNode objects. Each TreeNode has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output Format For every call to `next()`, return the next smallest number in the BST. Constraints * The number of nodes in the tree is in the range `[1, 10^4]`. * `-10^5 <= Node.val <= 10^5`. # Example ```python # Assume the TreeNode class is already defined # Example to build BST # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Initialize BST iterator iterator = BSTIterator(root) # Expected traversal output print(iterator.next()) # returns 3 print(iterator.next()) # returns 7 print(iterator.has_next()) # returns True print(iterator.next()) # returns 9 print(iterator.has_next()) # returns True print(iterator.next()) # returns 15 print(iterator.has_next()) # returns True print(iterator.next()) # returns 20 print(iterator.has_next()) # returns False ``` Remember to test your implementation with edge cases such as an empty tree or a tree with only one node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._push_left_nodes(root) def _push_left_nodes(self, node: TreeNode): while node: self.stack.append(node) node = node.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: node = self.stack.pop() if node.right: self._push_left_nodes(node.right) return node.val"},{"question":"# Scenario You are developing a recommendation system for a movie streaming service. Given a user\'s preference profile - represented as a vector of features (like genres, language, release year, etc.), you need to suggest a movie that best matches the user\'s profile from a collection of movies, each represented by its own feature vector. # Task Write a function `recommend_movie(user_profile, movies)` that: * **Input**: * A tuple `user_profile` of floats, representing the user\'s preferences. * A dictionary `movies` where each key is a tuple representing the feature vector of a movie, and its value is the movie\'s title (a string). * **Output**: * Returns the title of the movie that is nearest to the user profile based on Euclidean distance. # Constraints 1. User profiles and movie feature vectors are of the same length. 2. The number of movies will not exceed 10,000. 3. The length of the feature vectors will not exceed 100. 4. Avoid using libraries specialized for nearest neighbor search (e.g., scikit-learn). # Example ```python def recommend_movie(user_profile, movies): pass # your code here # Example user_profile = (1.2, 3.4, 5.6) movies = { (1.0, 3.0, 5.0): \\"Movie A\\", (2.0, 3.5, 6.0): \\"Movie B\\", (1.3, 3.2, 5.5): \\"Movie C\\" } print(recommend_movie(user_profile, movies)) # Expected output: \\"Movie C\\" ``` # Notes * Make sure to handle assertions on the input types and lengths appropriately. * Your function should efficiently compute the nearest movie based on the user\'s profile.","solution":"import math def euclidean_distance(x, y): Computes the Euclidean distance between two vectors. :param x: tuple of floats :param y: tuple of floats :return: float representing the Euclidean distance return math.sqrt(sum((xi - yi) * (xi - yi) for xi, yi in zip(x, y))) def recommend_movie(user_profile, movies): Recommends the movie that is nearest to the user profile based on Euclidean distance. :param user_profile: tuple, represents the user\'s preferences as a vector of floats :param movies: dict, where keys are tuples representing movie feature vectors, and values are movie titles :return: str, title of the recommended movie if not isinstance(user_profile, tuple) or not isinstance(movies, dict): raise TypeError(\\"Invalid input types.\\") if not movies: return None nearest_movie = None nearest_distance = float(\'inf\') for movie_features, movie_title in movies.items(): if not isinstance(movie_features, tuple) or not isinstance(movie_title, str): raise TypeError(\\"Invalid movie features or title.\\") if len(movie_features) != len(user_profile): raise ValueError(\\"Feature vector lengths do not match.\\") distance = euclidean_distance(user_profile, movie_features) if distance < nearest_distance: nearest_distance = distance nearest_movie = movie_title return nearest_movie"},{"question":"# Scenario Given an array of integers, you need to sort the array using the Bucket Sort algorithm. The elements may vary within a certain range, and the performance of your solution should aim to leverage the properties of Bucket Sort effectively. # Task Implement a function `bucket_sort(arr)` that sorts an input array `arr` of integers using the Bucket Sort algorithm. Utilize an auxiliary sorting method suited for sorting segments (buckets) of the main array. # Requirements - Function signature: `def bucket_sort(arr: List[int]) -> List[int]:` - Input: A list of integers `arr`. - Output: A sorted list of integers. # Constraints 1. All integers are within the range [0, 1000]. 2. The length of the array `n` is such that (1 leq n leq 10000). # Performance - Your solution should aim for (O(n+k)) average time complexity. - Provide an optimal number of buckets and an efficient mechanism for distributing elements into these buckets. # Example ```python assert bucket_sort([3, 6, 9, 1, 4, 7]) == [1, 3, 4, 6, 7, 9] assert bucket_sort([0, 1000, 500, 250]) == [0, 250, 500, 1000] ``` # Notes 1. Consider edge cases such as arrays with identical elements. 2. Ensure the auxiliary sorting algorithm used within buckets is efficient. 3. Optimize the number of buckets and their ranges to achieve better performance.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Bucket Sort algorithm. if len(arr) == 0: return arr # Number of buckets n = len(arr) max_value = max(arr) # Creating buckets buckets = [[] for _ in range(n)] # Distributing elements into buckets for number in arr: index = number * n // (max_value + 1) buckets[index].append(number) # Sorting each bucket and merging the result sorted_array = [] for bucket in buckets: sorted_array.extend(sorted(bucket)) return sorted_array"},{"question":"# Decoding an Encoded Message Given an encoded message containing digits, determine the total number of ways to decode it based on the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` For example, the encoded message \\"12\\" could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). Therefore, the number of ways to decode \\"12\\" is 2. # Task: Write a function `num_decodings` that calculates the number of ways to decode a given encoded message. Function Signature: ```python def num_decodings(enc_mes: str) -> int: pass ``` Input: * `enc_mes` (string): A string containing only digits. Output: * (integer): The total number of ways to decode the encoded message. Constraints: * 1 <= length of enc_mes <= 100 * The input string will only contain digits and will not be empty. Example: ```python assert num_decodings(\\"12\\") == 2 assert num_decodings(\\"226\\") == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (2 2 6) assert num_decodings(\\"06\\") == 0 # Invalid since there’s no mapping for 06 ``` # Edge Cases: * If the string starts with \'0\', it is invalid and should return 0. * Sequences containing \'00\' or numbers with leading zeroes like \'01\', \'09\' are invalid. # Additional Information: Ensure your function is efficient both in terms of time and space complexity.","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 # single character string that is not \'0\' for i in range(2, n + 1): single_digit = int(enc_mes[i-1:i]) double_digit = int(enc_mes[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"You are given an array of integers sorted in ascending order, and a target integer. Write a function `optimal_two_sum`, utilizing the Two Pointers approach, that returns the indices of the two numbers such that they add up to the target. Indices should be returned as a list `[index1, index2]`, where `index1 < index2` and both indices are one-based (not zero-based). You may assume that each input has exactly one solution, and you may not use the same element twice. # Input and Output Formats * **Input**: - An integer array `numbers` sorted in ascending order. - An integer `target`, the specific sum to look for. * **Output**: - A list of integers `[index1, index2]` such that `numbers[index1 - 1] + numbers[index2 - 1] == target`. # Constraints * The array\'s length and the target can be any valid integer within practical limits (e.g., 1 ≤ numbers.length ≤ 10^4, -10^9 ≤ numbers[i] ≤ 10^9, -10^9 ≤ target ≤ 10^9). * The array is guaranteed to have exactly one solution. # Example ```python # Example 1 numbers = [2, 7, 11, 15] target = 9 # Output: [1, 2] # Example 2 numbers = [1, 2, 3, 4, 4, 9, 56, 90] target = 8 # Output: [4, 5] ``` # Additional Notes - Ensure your solution is efficient and handles large input sizes within the given constraints. - Remember the array is already sorted, so you can leverage this property for an optimized solution. - Clearly handle edge cases, and assume the function signature as `def optimal_two_sum(numbers: List[int], target: int) -> List[int]:`.","solution":"def optimal_two_sum(numbers, target): Given an array of integers \'numbers\' sorted in ascending order, and an integer \'target\', returns the indices of the two numbers such that they add up to the \'target\'. Indices are one-based and the second index is greater than the first index. left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 return [] # Example usage (this would be outside the solution code) # optimal_two_sum([2, 7, 11, 15], 9) # Output: [1, 2]"},{"question":"You have been provided with a segment tree implementation that supports efficient range queries and updates. As a recent graduate joining an analytics company, your first task involves debugging and extending this segment tree to make it flexible enough to handle a customized commutative function defined at runtime. Task 1: Fix the Segment Tree Implementation The SegmentTree implementation attached above contains a few logical errors. Identify and fix these errors to ensure that: 1. The `query` function handles the range indices correctly. 2. The segment tree structure is correctly maintained during the `update` operation. Task 2: Extend Functionality Extend the functionality of the SegmentTree class so that it can dynamically apply a user-defined function during runtime initialization. This function should be commutative and associative. Constraints: - Assume an integer array initially. - The segment tree should be able to handle arrays up to size 10^5. - The commutative function should return the same type as the elements of the array. Submission Requirements: 1. **Corrected SegmentTree Class**: - Fix bugs in the existing implementation. 2. **Enhanced Functionality**: - Adapt the SegmentTree class to accept any commutative function provided during initialization. 3. **Test Cases**: - Write unit tests covering edge cases, standard cases, and large datasets. Input Format: 1. An integer array `arr` of size `n`. 2. A commutative function `fn` taking two integers and returning an integer. Output Format: Return the result of queries and updates using the segment tree. Example: ```python class SegmentTree: def __init__(self, arr, function): Your code here def build_tree(self): Your code here def update(self, p, v): Your code here def query(self, l, r): Your code here # Define operations and test cases below: if __name__ == \\"__main__\\": mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) assert(mytree.query(0, 6) == 64) mytree.update(2, -10) assert(mytree.query(0, 6) == 52) # Add more test cases to verify the implementation ```","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.tree = [0] * (2 * self.n) self.fn = function self.build_tree(arr) def build_tree(self, arr): # Build the tree with the initial function applied for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, value): # Update value at index p and rebuild the rest of the tree correctly p += self.n self.tree[p] = value while p > 1: p //= 2 self.tree[p] = self.fn(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): # Query in the inclusive range [l, r] l += self.n r += self.n + 1 res = None while l < r: if l % 2: if res is None: res = self.tree[l] else: res = self.fn(res, self.tree[l]) l += 1 if r % 2: r -= 1 if res is None: res = self.tree[r] else: res = self.fn(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Tree Structure Printing You are provided with a tree structure represented as a dictionary in Python, where each key in the dictionary is a root node, and each corresponding value is a list containing child nodes and other sub-elements (which can be strings or integers). Your task is to implement a function `tree_print(tree: dict) -> None` that performs a formatted print of the tree structure. The output format should match the example provided below. The function should handle various data types in tree nodes and ensure proper indentation as specified. Function Signature: ```python def tree_print(tree: dict) -> None: ``` Input: - `tree`: A dictionary where keys are root node names (strings) and values are lists containing child node names (strings or integers). Output: - The function does not return anything. Instead, it prints the tree structure in a specified format. Constraints: - Tree nodes can only be of types str and int. - Avoid using recursion to prevent potential stack overflow issues with deep trees. - Maintain order of elements as provided in the input dictionary. Examples: **Example 1:** ```python tree = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6, \\"Jill\\", \\"Sports\\", 1], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } tree_print(tree) ``` **Output:** ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` **Example 2:** ```python tree = { \\"x\\": [\\"Xavier\\", 9, \\"Yellow\\"], \\"y\\": [\\"Yale\\", \\"Zebra\\", 8] } tree_print(tree) ``` **Output:** ``` x -> Xavier -> 9 -> Yellow y -> Yale -> Zebra -> 8 ``` Notes: - Pay special attention to the formatting, especially the indentations and spacing. - Ensure the function handles empty and non-empty lists. - Avoid multiple lookups in the dictionary for the same key.","solution":"def tree_print(tree: dict) -> None: Prints the tree structure in a formatted way. Parameters: tree (dict): A dictionary where keys are root node names and values are lists of child nodes. for root, children in tree.items(): children_str = \' -> \'.join(map(str, children)) print(f\\"{root} -> {children_str}\\")"},{"question":"Suppose you are given a network of various cities connected by roads with different travel times. You need to implement an algorithm to compute the shortest travel time between every pair of cities. The travel times are given in the form of an adjacency matrix where `adjacency_matrix[i][j]` represents the travel time from city `i` to city `j`. # Task Write a function `all_pairs_shortest_path(adjacency_matrix)` that computes the shortest travel time between every pair of cities using the Floyd-Warshall algorithm. # Function Signature ```python def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: # Your Code Here ``` # Input - `adjacency_matrix`: A 2D list of floats where `adjacency_matrix[i][j]` gives the travel time from city `i` to city `j`. If there is no direct road between `i` and `j`, the value will be `float(\'inf\')`. The diagonal elements (i.e., travel time from a city to itself) will always be `0`. # Output - A 2D list of floats where the element at position `[i][j]` represents the minimum travel time from city `i` to city `j`. # Constraints - The matrix is square (n x n), where `1 <= n <= 100`. - The travel times are non-negative. # Example ```python adjacency_matrix = [ [0, 3, float(\'inf\'), 7], [8, 0, 2, float(\'inf\')], [5, float(\'inf\'), 0, 1], [2, float(\'inf\'), float(\'inf\'), 0] ] result = all_pairs_shortest_path(adjacency_matrix) print(result) # Expected Output: # [ # [0, 3, 5, 6], # [5, 0, 2, 3], # [3, 6, 0, 1], # [2, 5, 7, 0] # ] ``` # Note * Use `copy.deepcopy` to avoid modifying the original matrix. * Consider edge cases, such as when there are disjoint cities or when certain roads have a travel time of zero.","solution":"from typing import List import copy def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: Computes the shortest travel time between every pair of cities using the Floyd-Warshall algorithm. n = len(adjacency_matrix) dist = copy.deepcopy(adjacency_matrix) # Implementing Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist"},{"question":"You are tasked with creating a function to reverse a string using different techniques that illustrate your understanding of algorithms and data structures. Specifically, you will implement the following methods without using any built-in Python functions like `reversed` or slicing: 1. **Recursive Approach** 2. **Iterative Approach** 3. **Hybrid Approach** Function Definitions: 1. **Recursive Approach**: ```python def reverse_recursive(s: str) -> str: # Implement this function ``` 2. **Iterative Approach**: ```python def reverse_iterative(s: str) -> str: # Implement this function ``` 3. **Hybrid Approach**: ```python def reverse_hybrid(s: str) -> str: # Implement this function ``` Constraints: - **Length of the String `s`**: 0 <= len(s) <= 10^6 - String `s` consists of only ASCII characters. Expected Output: - The functions should return the reversed version of the input string `s`. Example: ```python Input: \\"hello\\" Output: \\"olleh\\" Input: \\"world\\" Output: \\"dlrow\\" Input: \\"\\" Output: \\"\\" ``` # Guidelines * For the **recursive approach**, consider how to split the problem into smaller sub-problems recursively. * In the **iterative approach**, think about how swapping characters can help reverse the string in place. * The **hybrid approach** should use a combination of the techniques demonstrated, showcasing your ability to innovate and combine methods for efficiency or simplicity.","solution":"def reverse_recursive(s: str) -> str: Reverses a string using a recursive approach. # Base case: if the string is empty or has only one character, return it as is if len(s) <= 1: return s # Recursive case: reverse the rest of the string and add the first character at the end return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverses a string using an iterative approach. # Convert the string to a list of characters (since strings are immutable in Python) char_list = list(s) # Initialize pointers for start and end of the list start, end = 0, len(char_list) - 1 # Swap characters until the pointers meet in the middle while start < end: char_list[start], char_list[end] = char_list[end], char_list[start] start += 1 end -= 1 # Convert the list back to a string and return return \'\'.join(char_list) def reverse_hybrid(s: str) -> str: Reverses a string using a hybrid approach. Combines the simplicity of iterative approach and recursion to illustrate understanding. # Use a helper function for the recursive call def helper(start: int, end: int, char_list: list) -> list: if start >= end: return char_list # Base case: pointers have met/crossed # Swap characters and recurse char_list[start], char_list[end] = char_list[end], char_list[start] return helper(start + 1, end - 1, char_list) # Convert to list of characters for mutability char_list = list(s) # Use the helper recursive function with iterative initialization reversed_list = helper(0, len(char_list) - 1, char_list) return \'\'.join(reversed_list)"},{"question":"Find the Single Number **Objective:** You are given an array of integers such that every element appears exactly three times, except for one element, which appears exactly once. Your task is to write a function that finds and returns that single element. **Function Signature:** ```python def find_single_number(nums: List[int]) -> int: ``` **Input:** - `nums`: List[int] - A non-empty list of integers where each integer except one appears exactly three times. **Output:** - Return the integer that appears exactly once. **Constraints:** - The length of the array is guaranteed to be a multiple of 3 plus 1 (i.e., `len(nums) = 3*k + 1` for some integer `k`). - The array can contain both positive and negative integers. **Performance Requirements:** - Your solution should have a linear runtime complexity, O(n). - The solution should use constant extra space, O(1). **Example:** ```python find_single_number([2, 2, 3, 2]) # Should return 3 find_single_number([0, 1, 0, 1, 0, 1, 99]) # Should return 99 find_single_number([-2, -2, -3, -2]) # Should return -3 ``` **Note:** - You should not use any extra data structures like sets, dictionaries, or additional lists. - Think about how you can leverage bitwise operations to keep track of the counts of each bit. **Hint:** - Consider how you might track the number of times each bit appears across all numbers and use modulo operations to isolate the bits of the single number.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the single number that appears exactly once while others appear exactly three times. ones, twos = 0, 0 for num in nums: # Add current number to `ones` if it\'s not already in `ones` and `twos` ones = (ones ^ num) & ~twos # Add current number to `twos` if it\'s not already in `twos` but is in `ones` twos = (twos ^ num) & ~ones return ones"},{"question":"# Question: Frequency Distribution Analysis **Context:** You are working on a data analysis project where you need to understand the frequency distribution of different elements in various datasets. To achieve this, you need to develop a function that computes the frequency counts of elements in a given list. **Task:** Implement a function named `compute_frequency_distribution` that accepts a list of elements and returns a dictionary representing the frequency distribution of the elements in the input list. **Function Signature:** ```python def compute_frequency_distribution(input_list: list) -> dict: pass ``` **Input:** - `input_list` (list): A list of elements (integers). **Output:** - (dict): A dictionary where keys are the elements from the input list and values are their respective frequency counts. **Constraints:** 1. The input list can be empty. 2. Elements in the input list are integers. 3. The input list can have up to 10^6 elements. **Performance Requirements:** - The implementation should have a time complexity of O(n) and a space complexity of O(k), where n is the length of the input list and k is the number of unique elements. **Example:** ```python assert compute_frequency_distribution([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert compute_frequency_distribution([2, 3, 5, 5, 5, 6, 4, 3, 7]) == {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} assert compute_frequency_distribution([]) == {} assert compute_frequency_distribution([1, 1, 1, 1]) == {1: 4} assert compute_frequency_distribution([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) == {9: 1, 8: 1, 7: 1, 6: 1, 5: 1, 4: 1, 3: 1, 2: 1, 1: 1, 0: 1} ``` Remember to handle the edge cases, specifically: - When the input list is empty, the function should return an empty dictionary `{}`. - When all elements in the list are the same, the function should return a dictionary with that element and its count. - When all elements in the list are unique, the function should return a dictionary with each element and a count of `1`.","solution":"def compute_frequency_distribution(input_list): Computes the frequency distribution of elements in the input list. Args: input_list (list): List of integers. Returns: dict: A dictionary with elements as keys and their frequency counts as values. frequency_distribution = {} for element in input_list: if element in frequency_distribution: frequency_distribution[element] += 1 else: frequency_distribution[element] = 1 return frequency_distribution"},{"question":"# Question Problem Statement You are given a singly-linked list and an integer `k`. Write a function `rotate_right` to rotate the list to the right by `k` places. Modify the list in-place and return the head of the rotated list. Function Signature ```python def rotate_right(head: ListNode, k: int) -> ListNode: ``` Input - `head` (ListNode): The head node of a singly-linked list. - `k` (int): A non-negative integer representing the number of places to rotate the list. Output - Return the head node of the rotated singly-linked list. Constraints - The number of nodes in the list is within the range [0, 5000]. - `0 <= k <= 2 * 10^9`. Example ```text Given 1->2->3->4->5->NULL and k = 2, return the rotated list as 4->5->1->2->3->NULL. ``` To simplify the creation of the linked list nodes and the validation of your results, you may use the helper function provided below: ```python class ListNode: def __init__(self, x): self.val = x self.next = None def print_list(head: ListNode) -> None: current = head while current: print(current.val, end=\\"->\\") current = current.next print(\\"NULL\\") # Helper function to create a list from array def create_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for elem in arr[1:]: current.next = ListNode(elem) current = current.next return head ``` Guidelines - Implement the `rotate_right` function to process the rotation as described. - Consider edge cases and constraints given in the problem. - Ensure the function is efficient and handles large values for `k` properly.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head: ListNode, k: int) -> ListNode: if not head or k == 0: return head # Find the length and end of the list length, end = 1, head while end.next: end = end.next length += 1 # Effective rotations needed k = k % length if k == 0: return head # Find the new end after rotation new_end_position = length - k new_end = head for _ in range(new_end_position - 1): new_end = new_end.next # Split and rotate new_head = new_end.next new_end.next = None end.next = head return new_head"},{"question":"**Intersections of Linked Lists** # Description Given two singly linked lists, determine the node at which the two lists intersect. If the two lists do not intersect, return `None`. # Detailed Requirements * The function should return the actual node (by reference) where the intersection starts, not the value. * Each list is built using nodes from a custom `Node` class with the following structure: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` # Function Signature ```python def intersection(h1: Node, h2: Node) -> Node: pass ``` # Inputs * `h1` and `h2`: The heads of the two singly linked lists. # Outputs * The reference to the intersection node, or `None` if there is no intersection. # Constraints * Each list length can be between 0 to (10^5). * Each node\'s value ranges between `-10^9` to `10^9`. * Elements in the linked lists are not necessarily unique. * The linked lists do not contain cycles. # Example ```python # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) e = Node(9) f = Node(11) a2 = Node(2) b2 = Node(4) c2 = Node(6) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f assert intersection(a1, a2) == d # Node with value 7 ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def intersection(h1: Node, h2: Node) -> Node: Determine the node at which the two linked lists intersect, if any. Parameters: - h1 : Node : head of the first linked list - h2 : Node : head of the second linked list Returns: - Node : reference to the intersection node or None if no intersection exists if not h1 or not h2: return None # Get the lengths of both linked lists len1, len2 = 0, 0 current1, current2 = h1, h2 while current1: len1 += 1 current1 = current1.next while current2: len2 += 1 current2 = current2.next # Align the heads of both linked lists if they are of different lengths current1, current2 = h1, h2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next else: for _ in range(len2 - len1): current2 = current2.next # Traverse both lists together to find the intersection point while current1 and current2: if current1 == current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"# Coding Challenge: Positional Search within Sorted Data Problem Statement: You are given a sorted array of integers in non-decreasing order. Your task is to implement the Interpolation Search algorithm, which searches for a specific target value within the array as efficiently as possible. The algorithm calculates the starting position using the formula: `pos = low + [(search_key - arr[low]) * (high - low) / (arr[high] - arr[low])]` Function Signature: ```python def interpolation_search(array: List[int], search_key: int) -> int: :param array: List of integers sorted in non-decreasing order. :param search_key: An integer value to search for within the array. :returns: Index of the search_key in the array if found, otherwise -1. ``` Input: * `array`: List containing integers sorted in non-decreasing order, of size `n` where 0 ≤ `n` ≤ 10^6. * `search_key`: An integer value to be searched within the array, -10^9 ≤ `search_key` ≤ 10^9. Output: * Return the index of `search_key` in the array if it exists, otherwise return -1. Constraints: * The array should remain unchanged post function execution. * The algorithm should maintain a logarithmic or sub-logarithmic time complexity for efficiently performing the search. Examples: ```python interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) # Returns: 2 interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) # Returns: -1 interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) # Returns: -1 interpolation_search([1, 3, 4, 6, 8, 10], 8) # Returns: 4 ``` Instructions: * Ensure your implementation handles edge cases like empty arrays or non-existing elements efficiently. * Prevent and handle scenarios that might lead to division by zero or array bounds errors. * Avoid modifying the input array. * Test your solution with diverse and large inputs to ensure performance adherence.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Searches for the search_key in a sorted array using the Interpolation Search algorithm. :param array: List of integers sorted in non-decreasing order. :param search_key: An integer value to search for within the array. :returns: Index of the search_key in the array if found, otherwise -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Calculate the position using the interpolation formula pos = low + int((float(high - low) / (array[high] - array[low]) * (search_key - array[low]))) # Ensure the generated position is within bounds to prevent IndexError if pos < low or pos > high: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Fenwick Tree Implementation and Usage You have been provided with a class template for a Fenwick Tree which efficiently performs prefix sum queries and point updates on an array of integers. Your task is to complete the implementation of the `Fenwick_Tree` class to include: 1. An additional method `range_sum(left, right)` that calculates the sum of the array elements between two indices `[left, right]` inclusive. 2. A method `update(i, new_value)` that updates the value at index `i` in the original array to `new_value`. Input * A list of integers `arr` of length `n` where (1 leq n leq 10^5). Output * The `range_sum(left, right)` method should return an integer representing the sum of elements between `left` and `right` indices. * The `update(i, new_value)` method should update the value at index `i` in the original array to `new_value`. Methods to Implement ```python class Fenwick_Tree: def __init__(self, freq): self.arr = freq self.n = len(freq) self.bit_tree = self.construct() def get_sum(self, i): # Returns sum of arr[0..i] pass def update_bit(self, i, val): # Updates Binary Indexed Tree (BIT) at given index by \'val\' pass def construct(self): # Constructs and returns a Binary Indexed Tree for the given array pass def range_sum(self, left, right): # Returns sum of arr[left..right] pass def update(self, i, new_value): # Updates the value of arr[i] to new_value pass ``` Example Usage ```python # Initializing Fenwick Tree arr = [2, 1, 5, 3, 7, 2, 3] fenwick_tree = Fenwick_Tree(arr) # Query the sum from index 1 to 4 print(fenwick_tree.range_sum(1, 4)) # Output should be 16 (1+5+3+7) # Update the value at index 2 to 6 fenwick_tree.update(2, 6) # Query again after the update print(fenwick_tree.range_sum(1, 4)) # Output should be 17 (1+6+3+7) ``` Ensure your implementation is efficient and adheres to the (O(log n)) time complexity for updates and queries.","solution":"class Fenwick_Tree: def __init__(self, freq): self.arr = freq self.n = len(freq) self.bit_tree = [0] * (self.n + 1) self.construct() def get_sum(self, i): sum = 0 i += 1 while i > 0: sum += self.bit_tree[i] i -= i & (-i) return sum def update_bit(self, i, val): i += 1 while i <= self.n: self.bit_tree[i] += val i += i & (-i) def construct(self): for i in range(self.n): self.update_bit(i, self.arr[i]) def range_sum(self, left, right): return self.get_sum(right) - self.get_sum(left - 1) def update(self, i, new_value): diff = new_value - self.arr[i] self.arr[i] = new_value self.update_bit(i, diff)"},{"question":"# Context Path manipulation is a common requirement, whether one is dealing with file systems or URLs. A fundamental operation needed is to join two path segments appropriately, ensuring proper handling of slashes. This exercise helps in understanding and implementing basic string manipulation, handling edge cases, and considering constraints. # Task Implement a Python function `join_paths(base, suffix)` that combines two string paths or URLs, ensuring only one slash exists between them. # Function Signature ```python def join_paths(base: str, suffix: str) -> str: ``` # Input * `base` (string): The initial part of the path. * Example: `\'path/to/dir\'` or `\'http://algorithms.com/\'` * `suffix` (string): The part of the path to append. * Example: `\'file\'` or `\'part\'` # Output * A single string representing the combined path, with exactly one slash between `base` and `suffix`. # Constraints * Consider both `base` and `suffix` can be empty strings, and should handle such cases appropriately. * The `base` and `suffix` can contain leading/trailing slashes which should be handled to ensure exactly one slash between joined parts. * No additional packages or libraries are to be imported; your solution should be self-contained. # Examples 1. `join_paths(\\"path/to/dir/\\", \\"file\\")` should return `\\"path/to/dir/file\\"`. 2. `join_paths(\\"http://algorithms.com/\\", \\"part\\")` should return `\\"http://algorithms.com/part\\"`. 3. `join_paths(\\"http://algorithms.com/\\", \\"/part\\")` should return `\\"http://algorithms.com/part\\"`. 4. `join_paths(\\"\\", \\"part\\")` should return `\\"part\\"`. 5. `join_paths(\\"http://algorithms.com\\", \\"\\")` should return `\\"http://algorithms.com\\"`. # Testing Ensure your function correctly handles various edge cases, such as: * Empty `base` or `suffix`. * Paths that start or end with several slashes. * Paths without slashes.","solution":"def join_paths(base: str, suffix: str) -> str: Joins two paths or URLs, ensuring only one slash exists between them. if base.endswith(\'/\'): base = base.rstrip(\'/\') if suffix.startswith(\'/\'): suffix = suffix.lstrip(\'/\') if base and suffix: return f\\"{base}/{suffix}\\" elif base: return base else: return suffix"},{"question":"Coding Assessment Question # Objective Write a function that generates a sequence of numbers from 1 to N with special rules for multiples of 3, 5, and both. # Problem Statement: Implement a function `custom_fizzbuzz(n: int) -> List[Union[int, str]]` that takes an integer N and returns a list of integers and strings according to the following rules: 1. For multiples of 3, the list should contain \\"Fizz\\". 2. For multiples of 5, the list should contain \\"Buzz\\". 3. For multiples of both 3 and 5, the list should contain \\"FizzBuzz\\". 4. For all other numbers, the list should contain the number itself. # Input: - An integer N where (1 ≤ N ≤ 10^6). # Output: - A list of length N where each element is either an integer or a string (\\"Fizz\\", \\"Buzz\\", or \\"FizzBuzz\\"). # Constraints: 1. N will always be a positive integer. 2. Your solution should be efficient in terms of time and space complexity. # Examples: Example 1: **Input:** ```python custom_fizzbuzz(15) ``` **Output:** ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Guidelines: 1. Make sure your implementation handles the edge cases (e.g., smallest possible N). 2. Optimize for both time and space where possible. 3. Document any assumptions you are making.","solution":"from typing import List, Union def custom_fizzbuzz(n: int) -> List[Union[int, str]]: Generates a sequence from 1 to N, replacing multiples of 3 with \'Fizz\', multiples of 5 with \'Buzz\', and multiples of both 3 and 5 with \'FizzBuzz\'. Parameters: n (int): The length of the sequence. Returns: List[Union[int, str]]: The generated sequence with special rules applied. result = [] for i in range(1, n+1): if i % 15 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"# Exchange Sort Extension You are given an array of `n` integers. Extend the existing `exchange_sort()` function to handle the following enhancements: 1. **Early Termination**: Introduce an optimization where the sorting process stops early if the array becomes sorted before completing all passes. 2. **Support for Custom Comparator**: Allow the user to pass a custom comparator function to decide the sorting order. The comparator should take two arguments (elements from the array) and return `True` if the first argument should appear before the second one in the sorted order, otherwise `False`. Function Signature: ```python def exchange_sort(arr, comparator=None): # Your code here ``` Input: * `arr`: List of integers to be sorted. * `comparator`: (optional) A function that takes two integers and returns a boolean. Output: * Return the sorted list of integers. Constraints: * 1 <= n <= 10^3 (consider efficiency based on this constraint) * If no comparator is provided, sort in ascending order. Example: ```python # Using default ascending order print(exchange_sort([4, 3, 2, 1])) # Output: [1, 2, 3, 4] # Using custom comparator for descending order def desc_comparator(x, y): return x > y print(exchange_sort([4, 3, 2, 1], comparator=desc_comparator)) # Output: [4, 3, 2, 1] ``` Notes: * Pay attention to effectively integrating the custom comparator into the existing algorithm. * Implement the early termination optimization to enhance performance on already sorted segments.","solution":"def exchange_sort(arr, comparator=None): Sorts an array using the exchange sort algorithm with early termination and custom comparator. :param arr: List of integers to be sorted. :param comparator: A function that takes two integers and returns a boolean. Returns True if the first argument should appear before the second one. Default is None, which results in ascending order sort. :return: Sorted list of integers. if comparator is None: # Default comparator for ascending order comparator = lambda x, y: x < y n = len(arr) for i in range(n): swapped = False for j in range(n - 1): if not comparator(arr[j], arr[j + 1]): # Swap elements if they are not in the desired order arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True # If no elements were swapped, the array is already sorted if not swapped: break return arr"},{"question":"# String Reversal and Palindrome Check You are required to implement a function that checks if a given string is a palindrome. A palindrome is a string that reads the same forward and backward. Your function should utilize string reversal techniques provided in the snippets above, but you must write your own implementation without using example code directly. # Function Signature ```python def is_palindrome(s: str) -> bool: # Implement this function pass ``` # Input - A single string `s` of length `n` where ( 0 leq n leq 10^5 ). # Output - Return `True` if the string is a palindrome, and `False` otherwise. # Constraints - The solution should handle inputs up to a length of ( 10^5 ) efficiently. - Do not use Python\'s built-in `reversed` function or slicing with `[::-1]`. # Example - Input: `\\"racecar\\"` Output: `True` - Input: `\\"hello\\"` Output: `False` # Notes - Be mindful of edge cases such as empty strings and single-character strings. - Aim for an efficient implementation with minimal complexity. # Solution Template ```python def is_palindrome(s: str) -> bool: # Use one of the reversal methods to check for palindrome pass ```","solution":"def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome. Parameters: s (str): The string to check. Returns: bool: True if the string is a palindrome, False otherwise. n = len(s) for i in range(n//2): if s[i] != s[n-i-1]: return False return True"},{"question":"The Fibonacci sequence is a well-known series of numbers where each number is the sum of the two preceding ones, starting from 0 and 1. That is: ``` F(0) = 0 F(1) = 1 F(n) = F(n-1) + F(n-2) for n > 1 ``` Given a positive integer `n`, your task is to write an efficient function that returns the `n-th` Fibonacci number without exceeding memory limits. # Function Signature ```python def fibonacci(n: int) -> int: ``` # Input - An integer `n` (0 <= n <= 10^5) # Output - An integer representing the `n-th` Fibonacci number. # Constraints - Ensure your solution handles large inputs efficiently. - Any attempt to use a purely recursive approach will likely result in a stack overflow for large n. # Example Example 1: ``` Input: n = 10 Output: 55 ``` Example 2: ``` Input: n = 50 Output: 12586269025 ``` # Requirements 1. **Efficiency**: The function should handle inputs up to 100,000 efficiently. 2. **Space Optimization**: Avoid using additional space beyond what is necessary for the calculation. Note - You should consider performance aspects and aim for a solution with both optimal time and space complexity. - If using an iterative approach, ensure that it handles the constraints effectively.","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number efficiently. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Encoding and Decoding Strings Scenario You are tasked with designing an algorithm to encode a list of strings into a single string and then decode it back to the list of strings. This is a common problem in applications involving data transmission where preserving the exact information is essential. Question **Implement two functions, `encode` and `decode`:** 1. `encode(strs)`: - Takes a list of strings `strs` and encodes it to a single string. - **Input**: `strs` (List of strings, 0 <= len(strs) <= 10^4, each string\'s length 0 <= len(string) <= 10^4). - **Output**: A single encoded string. 2. `decode(s)`: - Takes the encoded string `s` and decodes it back into the list of strings. - **Input**: `s` (String, the encoded form of a list of strings). - **Output**: A list of strings. **Constraints:** - Your encoding function should handle any possible string, including strings containing the chosen delimiter. - Both functions should preserve the original list\'s order and content exactly. Example: ```python encoded_string = encode([\\"hello\\", \\"world\\"]) # \\"5:hello5:world\\" decoded_list = decode(\\"5:hello5:world\\") # [\\"hello\\", \\"world\\"] ``` **Note**: The solution should be efficient in terms of both time and space complexity to handle the maximum input limits.","solution":"def encode(strs): Encodes a list of strings to a single string. encoded_str = \\"\\" for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. decoded_list = [] i = 0 while i < len(s): j = s.find(\':\', i) length = int(s[i:j]) decoded_list.append(s[j+1:j+1+length]) i = j + 1 + length return decoded_list"},{"question":"You are given an integer `n`. A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Your task is to generate all strobogrammatic numbers of length `n` and return them in a sorted list. # Function Signature ```python def generate_strobogrammatic(n: int) -> List[str]: pass ``` # Sample Input ```python n = 2 ``` # Sample Output ```python [\\"11\\", \\"69\\", \\"88\\", \\"96\\"] ``` # Constraints 1. `n` will be a non-negative integer. 2. The output list should be sorted in ascending order. 3. Handle edge cases like `n=0` and `n=1` correctly. # Notes - Ensure no leading zeros in non-zero results. - Optimize solution for `n` as large as 14. - Your implementation should make use of efficient recursion and combinatorial generation techniques. # Example ```python assert generate_strobogrammatic(2) == [\\"11\\", \\"69\\", \\"88\\", \\"96\\"] assert generate_strobogrammatic(1) == [\\"0\\", \\"1\\", \\"8\\"] assert generate_strobogrammatic(0) == [\\"\\"] assert generate_strobogrammatic(3) == [\\"101\\", \\"111\\", \\"181\\", \\"609\\", \\"619\\", \\"689\\", \\"808\\", \\"818\\", \\"888\\", \\"906\\", \\"916\\", \\"986\\"] ``` Implement the function `generate_strobogrammatic` and ensure all edge cases and optimizations are handled correctly.","solution":"from typing import List def generate_strobogrammatic(n: int) -> List[str]: def helper(m, n): if m == 0: return [\\"\\"] if m == 1: return [\\"0\\", \\"1\\", \\"8\\"] prev = helper(m - 2, n) res = [] for num in prev: if m != n: res.append(\\"0\\" + num + \\"0\\") res.append(\\"1\\" + num + \\"1\\") res.append(\\"6\\" + num + \\"9\\") res.append(\\"8\\" + num + \\"8\\") res.append(\\"9\\" + num + \\"6\\") return res return sorted(helper(n, n))"},{"question":"# Segment Tree - Range Minimum Query Objective Implement a Segment Tree to handle range minimum queries on an array. You need to build the tree, perform queries, and update the array values efficiently. Task 1. **Build the Tree**: Construct a segment tree from the given array. 2. **Query the Tree**: Implement functionality to find the minimum value in a specified range. 3. **Update Values**: Handle updates to the array and reflect changes in the segment tree. Function Definitions 1. **`__init__(self, arr: List[int])`**: Initializes the segment tree with given array. 2. **`build(self, i: int, start: int, end: int)`**: Builds the tree by recursively partitioning the array and combining results. 3. **`query(self, L: int, R: int) -> int`**: Queries the minimum value in the range [L, R]. 4. **`update(self, idx: int, value: int)`**: Updates the value at index `idx` to `value`. Constraints * Array size `N` such that 1 <= N <= 10^5. * Array values and query indices fit within 32-bit signed integers. * Function should handle multiple queries and updates efficiently. Input/Output Formats * **Input:** * Array of integers. * Queries and updates in the form of tuples: * Query: (\'q\', L, R) * Update: (\'u\', idx, value) * **Output:** * Minimum value for each query. Example ```python class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [float(\'inf\')] * (4 * self.n) self.arr = arr self.build(0, 0, self.n - 1) def build(self, i, start, end): if start == end: self.tree[i] = self.arr[start] else: mid = (start + end) // 2 self.build(2 * i + 1, start, mid) self.build(2 * i + 2, mid + 1, end) self.tree[i] = min(self.tree[2 * i + 1], self.tree[2 * i + 2]) def query(self, L, R, i = 0, start = 0, end = None): if end is None: end = self.n - 1 if L > end or R < start: return float(\'inf\') if L <= start and R >= end: return self.tree[i] mid = (start + end) // 2 left = self.query(L, R, 2 * i + 1, start, mid) right = self.query(L, R, 2 * i + 2, mid + 1, end) return min(left, right) def update(self, idx, value, i = 0, start = 0, end = None): if end is None: end = self.n - 1 if start == end: self.arr[idx] = value self.tree[i] = value else: mid = (start + end) // 2 if start <= idx <= mid: self.update(idx, value, 2 * i + 1, start, mid) else: self.update(idx, value, 2 * i + 2, mid + 1, end) self.tree[i] = min(self.tree[2 * i + 1], self.tree[2 * i + 2]) # Example usage: arr = [2, 4, 5, 3, 4] st = SegmentTree(arr) print(st.query(1, 3)) # Output: 3 st.update(2, 1) print(st.query(1, 3)) # Output: 1 ```","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [float(\'inf\')] * (4 * self.n) self.arr = arr self.build(0, 0, self.n - 1) def build(self, i, start, end): if start == end: self.tree[i] = self.arr[start] else: mid = (start + end) // 2 self.build(2 * i + 1, start, mid) self.build(2 * i + 2, mid + 1, end) self.tree[i] = min(self.tree[2 * i + 1], self.tree[2 * i + 2]) def query(self, L, R, i = 0, start = 0, end = None): if end is None: end = self.n - 1 if L > end or R < start: return float(\'inf\') if L <= start and R >= end: return self.tree[i] mid = (start + end) // 2 left = self.query(L, R, 2 * i + 1, start, mid) right = self.query(L, R, 2 * i + 2, mid + 1, end) return min(left, right) def update(self, idx, value, i = 0, start = 0, end = None): if end is None: end = self.n - 1 if start == end: self.arr[idx] = value self.tree[i] = value else: mid = (start + end) // 2 if start <= idx <= mid: self.update(idx, value, 2 * i + 1, start, mid) else: self.update(idx, value, 2 * i + 2, mid + 1, end) self.tree[i] = min(self.tree[2 * i + 1], self.tree[2 * i + 2])"},{"question":"# Question: **Sparse Vector Dot Product Calculator** You are given two very large, sparse vectors represented as lists of floating point numbers. Your task is to efficiently store these vectors and compute their dot product. The vectors can contain a large number of zeros, so an efficient representation is crucial to save memory and computational resources. # Requirements: 1. Design a data structure to store sparse vectors efficiently. 2. Implement a function to compute the dot product of two sparse vectors stored using your data structure. # Function Signatures: ```python def vector_to_sparse_list(vector: List[float]) -> List[Tuple[int, float]]: Convert a vector to a sparse representation which is a list of tuples where each tuple contains an index and its non-zero value. :param vector: List[float] - Input vector with potentially many zeros :return: List[Tuple[int, float]] - Sparse representation of the vector ``` ```python def sparse_dot_product(sparse_vector1: List[Tuple[int, float]], sparse_vector2: List[Tuple[int, float]]) -> float: Compute the dot product of two sparse vectors represented by their sparse lists of tuples. :param sparse_vector1: List[Tuple[int, float]] - First sparse vector. :param sparse_vector2: List[Tuple[int, float]] - Second sparse vector. :return: float - The dot product of the two vectors. ``` # Input Format: - `vector_to_sparse_list` function takes a list of floats. - `sparse_dot_product` function takes two lists of tuples (index, value). # Output Format: - `vector_to_sparse_list` returns a list of tuples (index, value). - `sparse_dot_product` returns a float representing the dot product of the two vectors. # Constraints: - The length of the input vectors can be up to (10^6). - The number of non-zero elements in each vector will not exceed (10^5). # Performance Requirements: - Ensure the conversion to sparse vector and the dot product calculation are efficient in terms of time and space complexity. # Example: ```python # Example Usage vector1 = [1., 0., 0., 2., 0., 3.] vector2 = [0., 2., 0., 0., 0., 4.] sparse_vector1 = vector_to_sparse_list(vector1) sparse_vector2 = vector_to_sparse_list(vector2) print(sparse_dot_product(sparse_vector1, sparse_vector2)) # Output: 12.0 (from 3*4) ``` # Notes: * Make sure to handle edge cases such as vectors filled with zeros. * Provide a few test cases demonstrating the correctness and efficiency of your solution.","solution":"from typing import List, Tuple def vector_to_sparse_list(vector: List[float]) -> List[Tuple[int, float]]: Convert a vector to a sparse representation which is a list of tuples where each tuple contains an index and its non-zero value. :param vector: List[float] - Input vector with potentially many zeros :return: List[Tuple[int, float]] - Sparse representation of the vector return [(i, val) if val != 0 else (None, None) for i, val in enumerate(vector) if val != 0] def sparse_dot_product(sparse_vector1: List[Tuple[int, float]], sparse_vector2: List[Tuple[int, float]]) -> float: Compute the dot product of two sparse vectors represented by their sparse lists of tuples. :param sparse_vector1: List[Tuple[int, float]] - First sparse vector. :param sparse_vector2: List[Tuple[int, float]] - Second sparse vector. :return: float - The dot product of the two vectors. index_map = {index: value for index, value in sparse_vector2} return sum(value * index_map.get(index, 0) for index, value in sparse_vector1)"},{"question":"# Scenario: You are working on a project where you need to frequently remove the smallest element from a collection of tasks maintained in a stack. The stack follows a LIFO (Last In First Out) order, and your task is to implement a function that effectively removes the smallest element from this stack. # Challenge: Write a function `remove_min(stack: List[int]) -> List[int]` that accepts a stack of integers and removes the smallest element from it. The function should maintain the LIFO order of the remaining elements after removing the smallest element. # Input and Output: - **Input**: A list of integers representing the stack. - Example: `[2, 8, 3, -6, 7, 3]` with `2` being the bottom of the stack and `3` being the top. - **Output**: A list of integers representing the stack after removing the smallest element. - Example: `[2, 8, 3, 7, 3]`. # Constraints: - The input stack can have zero or more integers. - There can be multiple instances of the minimum value, but your function should remove only one instance. - The stack may contain both positive and negative integers. # Example: ```python # Example 1 stack = [2, 8, 3, -6, 7, 3] print(remove_min(stack)) # Expected output: [2, 8, 3, 7, 3] # Example 2 stack = [4, 1, 1, 3, 2] print(remove_min(stack)) # Expected output: [4, 1, 3, 2] # Example 3 stack = [] print(remove_min(stack)) # Expected output: [] # Example 4 stack = [10] print(remove_min(stack)) # Expected output: [] ``` # Notes: - Do not use built-in functions that directly perform the required task. - Aim to achieve the task with a time complexity of O(n) and a space complexity of O(n). - Consider possible edge cases and ensure the function handles them appropriately. # Performance Requirements: Ensure your implementation is efficient and performs within acceptable limits for large stacks of up to 10^5 elements.","solution":"def remove_min(stack): Removes the smallest element from the stack while maintaining LIFO order. if not stack: return stack # Step 1: Find the minimum value in the stack min_value = min(stack) # Step 2: Use another stack to temporarily hold elements temp_stack = [] # Step 3: Transfer elements from the original stack to the temporary stack min_removed = False while stack: element = stack.pop() if element == min_value and not min_removed: min_removed = True else: temp_stack.append(element) # Step 4: Transfer elements back to the original stack to restore LIFO order while temp_stack: stack.append(temp_stack.pop()) return stack"},{"question":"# Scenario As part of a usage analytics system, you are tasked to optimize a process that retrieves the in-order predecessor of a given user ID from a large dataset stored in a Binary Search Tree (BST). # Problem Statement Write a function `in_order_predecessor` that finds the in-order predecessor of a given node in a Binary Search Tree (BST). If the node does not have an in-order predecessor, the function should return `None`. # Function Signature ```python def in_order_predecessor(root, node): pass ``` # Input * `root`: The root node of the BST, represented as an object of a class `TreeNode` with attributes `val`, `left`, and `right`. * `node`: The target node, also represented as an object of the class `TreeNode`. # Output * Return the TreeNode representing the in-order predecessor. * If the in-order predecessor does not exist, return `None`. # Class Definition (Provided) ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Constraints * All node values are unique. * The BST is not necessarily balanced, but it adheres to BST properties. * The function should have an average time complexity of O(log n) and space complexity of O(1), assuming the tree is balanced. * Consider edge cases such as leaf nodes, nodes with no left or right subtrees, and nodes that are the smallest in the tree. # Example ```python # Assuming a tree is defined as follows: # 20 # / # 10 30 # / # 5 15 # / # 12 18 root = TreeNode(20, TreeNode(10, TreeNode(5), TreeNode(15, TreeNode(12), TreeNode(18))), TreeNode(30)) node = root.left.right.right # Node with value 18 result = in_order_predecessor(root, node) print(result.val if result else None) # Output: 15 ``` # Notes * Ensure your code handles cases where the node has no predecessor. * Optimize your solution to achieve the best possible performance.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def in_order_predecessor(root, node): Returns the in-order predecessor of a given node in a BST. if not root or not node: return None predecessor = None current = root while current: if node.val > current.val: predecessor = current current = current.right elif node.val < current.val: current = current.left else: # Node found, handle the left subtree case if current.left: predecessor = current.left while predecessor.right: predecessor = predecessor.right break return predecessor"},{"question":"You are given `n` distinct objects and you need to choose `r` objects from them. Write a function `optimized_combination(n, r)` to calculate the number of ways to choose `r` objects from `n` objects (denoted as nCr). # Requirements * Your function must be highly efficient and should handle large values of `n` and `r` up to 1000. * Implement your solution using dynamic programming to optimize both time and space complexities. * Avoid redundant calculations by storing intermediate results as necessary. # Input * An integer `n` (0 <= n <= 1000): Total number of distinct objects. * An integer `r` (0 <= r <= n): Number of objects to choose. # Output * Return an integer representing the number of ways to choose `r` objects from `n` objects. # Constraints * You should ensure that your solution handles edge cases such as when `r` is 0, `r` equals `n`, etc., correctly. # Example ```python >>> optimized_combination(5, 3) 10 >>> optimized_combination(6, 2) 15 >>> optimized_combination(10, 0) 1 >>> optimized_combination(1000, 1) 1000 ``` # Function Signature ```python def optimized_combination(n: int, r: int) -> int: # Your code here ``` Notes: * Use a bottom-up dynamic programming approach to build up the solution iteratively. * Avoid deep recursion to prevent stack overflow. * Ensure your implementation is efficient in terms of both time and space.","solution":"def optimized_combination(n: int, r: int) -> int: Calculate the number of ways to choose r objects from n objects (nCr). if r > n: return 0 if r == 0 or r == n: return 1 # Initialize a table to store intermediate results C = [[0 for _ in range(r+1)] for _ in range(n+1)] # Calculate binomial coefficients using bottom-up approach for i in range(n+1): for j in range(min(i, r) + 1): # Base cases if j == 0 or j == i: C[i][j] = 1 # Calculate value using previously stored values else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][r]"},{"question":"A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Given a list of numbers represented as strings, write a function `find_strobogrammatic_numbers(lst: List[str]) -> List[str]` to find all the strobogrammatic numbers in the list. # Function Signature: ```python def find_strobogrammatic_numbers(lst: List[str]) -> List[str]: pass ``` # Input: - `lst`: A list of strings representing numbers (1 ≤ length of each string ≤ 10^5, 1 ≤ number of strings ≤ 10^5). # Output: - A list of strings representing the strobogrammatic numbers from the input list. # Constraints: - The output list should maintain the order of strobogrammatic numbers found in the input list. - Each string can only contain digits (\'0\'-\'9\'). # Example: ```python # Example 1 input_list = [\\"69\\", \\"88\\", \\"818\\", \\"123\\", \\"962\\"] output = find_strobogrammatic_numbers(input_list) print(output) # Output should be [\\"69\\", \\"88\\", \\"818\\"] # Example 2 input_list = [\\"1\\", \\"2\\", \\"0\\", \\"101\\", \\"11\\"] output = find_strobogrammatic_numbers(input_list) print(output) # Output should be [\\"1\\", \\"0\\", \\"101\\", \\"11\\"] ``` # Explanation: - In Example 1, the numbers \\"69\\", \\"88\\", and \\"818\\" are strobogrammatic, while \\"123\\" and \\"962\\" are not. - In Example 2, the numbers \\"1\\", \\"0\\", \\"101\\", and \\"11\\" are strobogrammatic, while \\"2\\" is not. # Notes: - Consider edge cases like single-digit strings or strings that are not valid strobogrammatic numbers. - Optimize your function to handle large lists efficiently.","solution":"def find_strobogrammatic_numbers(lst): Returns a list of strobogrammatic numbers from the input list. A strobogrammatic number looks the same when rotated 180 degrees. strobogrammatic_set = {\'0\', \'1\', \'6\', \'8\', \'9\'} strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} def is_strobogrammatic(num_str): n = len(num_str) for i in range((n + 1) // 2): if (num_str[i] not in strobogrammatic_set or strobogrammatic_pairs[num_str[i]] != num_str[n - 1 - i]): return False return True result = [num for num in lst if is_strobogrammatic(num)] return result"},{"question":"You are required to implement a hash table with dynamic resizing capabilities. The hash table should support the following operations: `put`, `get`, `delete`, and dynamic resizing when the load factor exceeds 2/3. Function Signatures - `put(key: int, value: int) -> None`: A method to insert the key-value pair into the hash table. If the key already exists, update its value. - `get(key: int) -> Optional[int]`: A method to retrieve the value associated with the key. Return `None` if the key does not exist. - `delete(key: int) -> None`: A method to remove the key-value pair from the hash table. - `resize() -> None`: A method to resize the hash table dynamically when the load factor exceeds 2/3. Input and Output Formats * `put` takes two integers `key` and `value` as input and does not return anything. * `get` takes an integer `key` as input and returns the corresponding value if the key exists, otherwise it returns `None`. * `delete` takes an integer `key` as input and does not return anything. * `resize` does not take any input and does not return anything. Constraints * Keys are non-negative integers. * Values are integers. * The hash table should be able to handle up to `100,000` key-value pairs. * Operations should be optimized for average-case O(1) performance. # Example ```python ht = ResizableHashTable() ht.put(1, 10) ht.put(2, 20) ht.put(15, 30) assert ht.get(1) == 10 assert ht.get(2) == 20 assert ht.get(15) == 30 assert ht.get(30) == None ht.delete(1) assert ht.get(1) == None for i in range(100,000): ht.put(i, i*10) assert ht.get(50,000) == 500000 ``` Implement the `ResizableHashTable` class as specified above ensuring the dynamic resizing feature works correctly.","solution":"from typing import Optional, List, Tuple class ResizableHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.load_factor_threshold = 2 / 3 self.table: List[Optional[List[Tuple[int, int]]]] = [None] * self.capacity self.size = 0 def _hash(self, key: int) -> int: return key % self.capacity def resize(self) -> None: old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for bucket in old_table: if bucket: for key, value in bucket: self.put(key, value) def put(self, key: int, value: int) -> None: if self.size + 1 > self.capacity * self.load_factor_threshold: self.resize() index = self._hash(key) if self.table[index] is None: self.table[index] = [] for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.size += 1 def get(self, key: int) -> Optional[int]: index = self._hash(key) if self.table[index] is not None: for k, v in self.table[index]: if k == key: return v return None def delete(self, key: int) -> None: index = self._hash(key) if self.table[index] is not None: for i, (k, v) in enumerate(self.table[index]): if k == key: del self.table[index][i] self.size -= 1 if not self.table[index]: # Clean up if the bucket is empty self.table[index] = None return"},{"question":"Coding Assessment Question # Next Higher Permutation Objective: Write a function `next_higher_permutation(num: int) -> int` that takes an integer `num` as input and returns the next higher number which has the exact same set of digits as the original number. If no such number exists, return `-1`. Description: The function should implement the next permutation algorithm to find the next lexicographical permutation of the digits in the given number. 1. **Identify the largest index `i` such that the digits array[i-1] < array[i]**. * If no such index exists, return `-1`. 2. **Identify the largest index `j` such that array[j] > array[i-1]**. 3. **Swap the digits at indices `j` and `i-1`**. 4. **Reverse the subsequence of digits starting at index `i` to the end of the list**. Constraints: * The input will be a non-negative integer. * The input will not have leading zeroes. * The number can be large, but within the typical integer bounds for languages like Python. Input: * **num**: An integer representing the number whose next higher permutation is sought. Output: * Returns the next higher permutation of the number. If no such permutation exists, return `-1`. Examples: ```python assert next_higher_permutation(38276) == 38627 assert next_higher_permutation(12345) == 12354 assert next_higher_permutation(54321) == -1 assert next_higher_permutation(999) == -1 assert next_higher_permutation(5) == -1 ``` # Task: Implement the following function in Python: ```python def next_higher_permutation(num: int) -> int: # your implementation here ``` **Performance Considerations**: Ensure your implementation runs efficiently for inputs up to the upper bounds of typical integer sizes.","solution":"def next_higher_permutation(num: int) -> int: digits = list(str(num)) length = len(digits) # Step 1: Find the largest index i such that digits[i-1] < digits[i] i = length - 1 while i > 0 and digits[i - 1] >= digits[i]: i -= 1 if i == 0: # Digits are in descending order return -1 # Step 2: Find the largest index j such that digits[j] > digits[i-1] j = length - 1 while digits[j] <= digits[i - 1]: j -= 1 # Step 3: Swap digits[i-1] and digits[j] digits[i - 1], digits[j] = digits[j], digits[i - 1] # Step 4: Reverse the sequence from i to the end of the list digits = digits[:i] + digits[i:][::-1] return int(\\"\\".join(digits))"},{"question":"# Scenario You are developing a program that needs to process and display numerical information stored in a database. A specific part of your program involves displaying numbers nicely formatted based on their digit count. You decide to implement a specialized function to calculate the number of digits in an integer efficiently. # The Task Implement a function `num_digits` that returns the number of digits in a given non-fractional integer. Your function should work efficiently and handle both positive and negative integers as well as zero. # Input - An integer `n`, where `n` can be positive, negative, or zero. # Output - An integer representing the number of digits in `n`. # Constraints - The input number `n` will be a valid integer within the range of typical 32-bit signed integers (-2,147,483,648 to 2,147,483,647). - Avoid using the string conversion method for counting digits, and instead, utilize mathematical properties. # Examples 1. `num_digits(12345)` -> `5` 2. `num_digits(-6789)` -> `4` 3. `num_digits(0)` -> `1` 4. `num_digits(1000000000)` -> `10`","solution":"def num_digits(n): Returns the number of digits in a given non-fractional integer. Handles positive, negative integers, and zero. if n == 0: return 1 count = 0 n = abs(n) while n > 0: n //= 10 count += 1 return count"},{"question":"Scenario You are part of a team developing a task management system where tasks need to be processed in a first-in, first-out manner. Two types of queue implementations are provided: `ArrayQueue` and `LinkedListQueue`. However, both implementation classes are missing a critical function: **reverse_queue**. This function should reverse the order of elements in the queue. Task Implement a function within the `ArrayQueue` and `LinkedListQueue` classes that reverses the order of elements in the queue while maintaining the properties of the queue. # Function Signature: ```python def reverse_queue(self): Reverses the elements in the queue. ``` # Requirements: 1. Implement `reverse_queue` method for both `ArrayQueue` and `LinkedListQueue` classes. 2. Ensure the queue maintains its properties after reversal. # Input: - No direct input is needed as the function operates on the instance queue. # Output: - The queue modified in place without returning any value. # Constraints: - The `reverse_queue` method must not exceed O(n) time complexity. - You may utilize additional data structures if needed, but space complexity should be within O(n). # Example usage: ```python # For ArrayQueue: queue = ArrayQueue() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.reverse_queue() print(list(queue)) # Expected Output: [3, 2, 1] # For LinkedListQueue: queue = LinkedListQueue() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) queue.reverse_queue() print(list(queue)) # Expected Output: [3, 2, 1] ``` Note: To test your implementation, you may add `reverse_queue` function in provided `ArrayQueue` and `LinkedListQueue` classes and initialize queues with different elements. Verify the order after calling the `reverse_queue` function.","solution":"class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, item): self.queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") return self.queue.pop(0) def is_empty(self): return len(self.queue) == 0 def reverse_queue(self): Reverses the elements in the queue. self.queue.reverse() def __iter__(self): return iter(self.queue) class LinkedListQueue: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None self.tail = None def enqueue(self, item): new_node = self.Node(item) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") value = self.head.value self.head = self.head.next if not self.head: self.tail = None return value def is_empty(self): return self.head is None def reverse_queue(self): Reverses the elements in the queue. prev = None current = self.head self.tail = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def __iter__(self): current = self.head while current: yield current.value current = current.next"},{"question":"# Coin Change Problem with Dynamic Set You are given a set of coin denominations and a target value. Your task is to implement a function that calculates the number of different combinations of the coin denominations that add up exactly to the target value. You may assume there is an infinite supply of each coin denomination. Function Signature ```python def count_combinations(coins: List[int], value: int) -> int: ``` # Input * `coins` list of integers, representing the coin denominations. The length of the list will be between 1 and 50, inclusive. * `value` integer, representing the target value to form. It will be between 0 and 10,000, inclusive. # Output * Returns the number of ways to combine the coin denominations to sum up exactly to the target value. # Example ```python assert count_combinations([1, 2, 3], 4) == 4 assert count_combinations([2, 5, 3, 6], 10) == 5 assert count_combinations([1], 0) == 1 assert count_combinations([2], 3) == 0 ``` # Constraints * You need to solve this problem in O(n*m) time complexity, where `n` is the target value and `m` is the number of coin denominations. * Use O(n) space complexity. # Hint Consider using a dynamic programming approach to build up the solution from smaller subproblems. Focus on how to update your DP array for each coin denomination to account for all possible combinations.","solution":"from typing import List def count_combinations(coins: List[int], value: int) -> int: # Initialize a list of zeros with a length of value + 1 dp = [0] * (value + 1) # There is one way to make value 0, using no coins dp[0] = 1 # Iterate over each coin for coin in coins: # Update the dp array for all values from coin to the target value for v in range(coin, value + 1): dp[v] += dp[v - coin] return dp[value]"},{"question":"# Path Resolver You are provided with a utility function that resolves file paths to their absolute path form. Your task is to enhance this function such that, in addition to resolving the absolute path, it also: 1. Ensures the path does not exceed 255 characters once resolved (common file system limit). 2. Ensures the path contains only valid characters for your operating system environment. 3. Throws specific exceptions for empty strings or paths containing illegal characters. Function Signature ```python def enhanced_full_path(file: str) -> str: Given a file path, this function returns its absolute path, ensuring: - The resolved path does not exceed 255 characters. - The path contains only valid characters. - Raises ValueError for empty string inputs. - Raises ValueError for paths with illegal characters. :param file: str - The file path to resolve. :return: str - The resolved absolute file path. pass ``` Input * A single string `file`, representing a file path. Output * Returns a string representing the absolute path. Constraints * Paths containing illegal characters (defined for your OS, e.g., `<>:\\"|?*` for Windows) should raise a `ValueError`. * The length of the resultant path should not exceed 255 characters; otherwise, raise a `ValueError`. * Empty string paths should raise a `ValueError`. Examples ```python # In a POSIX compliant system with user home directory as /home/user enhanced_full_path(\'~/mydir/myfile.txt\') -> \'/home/user/mydir/myfile.txt\' enhanced_full_path(\'/already/absolute/path\') -> \'/already/absolute/path\' enhanced_full_path(\'relative/path\') -> \'<absolute path>/relative/path\' enhanced_full_path(\'\') # Raises ValueError enhanced_full_path(\'invalid|path\') # Raises ValueError ``` Hints 1. Use `os.path.expanduser` and `os.path.abspath` to resolve the path. 2. Limit the characters allowed in the final path based on your OS-specific constraints.","solution":"import os def enhanced_full_path(file: str) -> str: Given a file path, this function returns its absolute path, ensuring: - The resolved path does not exceed 255 characters. - The path contains only valid characters. - Raises ValueError for empty string inputs. - Raises ValueError for paths with illegal characters. :param file: str - The file path to resolve. :return: str - The resolved absolute file path. if not file: raise ValueError(\\"Empty file path provided.\\") illegal_characters = \'<>:\\"|?*\' if any(char in illegal_characters for char in file): raise ValueError(f\\"File path contains illegal characters: {illegal_characters}\\") resolved_path = os.path.abspath(os.path.expanduser(file)) if len(resolved_path) > 255: raise ValueError(\\"Resolved path exceeds 255 characters.\\") return resolved_path"},{"question":"# Linked List: Check Sorting Order You are given a linked list where each node contains an integer. Implement the function `is_sorted(head)` that checks if the linked list is in strictly increasing order and returns `True` if it is, otherwise returns `False`. An empty linked list or a single-node linked list should be considered sorted. Function Signature: ```python def is_sorted(head: Optional[ListNode]) -> bool: pass ``` Input: * `head`: The head node of a singly linked list, or `None` if the list is empty. Output: * Returns `True` if the linked list is in strictly increasing order, otherwise returns `False`. Constraints: * Do not mutate the linked list. * A linked list node is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Example: ```python # Example 1: # Input: 1 -> 2 -> 3 -> 4 # Output: True # Example 2: # Input: 1 -> 2 -> -1 -> 3 # Output: False # Example 3: # Input: None (empty list) # Output: True # Example 4: # Input: 5 # Output: True ``` Implement the `is_sorted` function to pass the given examples and any edge cases.","solution":"from typing import Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: Optional[ListNode]) -> bool: Checks if the linked list is in strictly increasing order. if head is None or head.next is None: return True current = head while current.next is not None: if current.val >= current.next.val: return False current = current.next return True"},{"question":"# Problem Context You are developing a simulation for a system that involves a large number of state transitions represented by matrices. To optimize the performance of your simulation, it is crucial to efficiently compute the exponentiation of state transition matrices. # Task Write a function `large_matrix_exponentiation(mat: list, power: int) -> list` that computes the (power^{th}) exponent of a given square matrix (mat). Use the method of repeated squaring for efficient computation. # Function Signature ```python def large_matrix_exponentiation(mat: list, power: int) -> list: pass ``` # Input * **mat (list of list of int)**: A square matrix of dimensions (d times d). * **power (int)**: A non-negative integer. # Output * **result (list of list of int)**: The matrix representing (mat^{power}). # Constraints * The dimensions (d) of the matrix (1 leq d leq 100). * ( 0 leq power leq 10^5 ). # Example ```python mat = [ [1, 1], [1, 0] ] power = 5 print(large_matrix_exponentiation(mat, power)) # Output: [ # [8, 5], # [5, 3] # ] ``` # Performance Requirements Your implementation should aim for optimal time complexity, leveraging repeated squaring to handle large power values efficiently. Ensure your solution avoids recursion depth issues for high powers.","solution":"def matrix_mult(A, B): Multiplies two square matrices A and B. size = len(A) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): result[i][j] = sum(A[i][k] * B[k][j] for k in range(size)) return result def large_matrix_exponentiation(mat, power): Computes mat^power using repeated squaring method. size = len(mat) result = [[1 if i == j else 0 for j in range(size)] for i in range(size)] # Identity matrix base = mat while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result"},{"question":"**Context**: You are tasked with sorting an array of integers that represents temperature readings from different monitoring stations on a particular day. The values are bounded between -100 and 100 degrees Celsius, as these represent possible reading values. **Problem Statement**: Implement the function `custom_pigeonhole_sort(arr)` that sorts an array of integers within the specified range of -100 to 100 degrees using the Pigeonhole Sort algorithm. Your implementation should ensure that the values are sorted in non-decreasing order. **Function Signature**: ```python def custom_pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` # Input - A list of integers `arr` where -100 <= arr[i] <= 100 and 1 <= len(arr) <= 10^6. # Output - A sorted list of integers in non-decreasing order. # Constraints - The list will only contain integers within the range of -100 to 100, inclusive. - The length of the list will be between 1 and (10^6). # Example ```python # Example 1 input = [3, -2, 4, -100, 50, 50, 0, -3] output = [-100, -3, -2, 0, 3, 4, 50, 50] # Example 2 input = [100, -100, 0] output = [-100, 0, 100] # Example 3 input = [5, -5, 0, 5, -5, 5] output = [-5, -5, 0, 5, 5, 5] ``` # Notes - Ensure your solution is efficient in both time and space. - Consider edge cases such as handling duplicate values and single-element arrays.","solution":"def custom_pigeonhole_sort(arr): Sorts the given list of integers within the range of -100 to 100 using Pigeonhole Sort. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list of integers in non-decreasing order. min_val = -100 max_val = 100 range_size = max_val - min_val + 1 # Create empty pigeonholes pigeonholes = [0] * range_size # Populate the pigeonholes for number in arr: pigeonholes[number - min_val] += 1 # Construct the sorted array sorted_arr = [] for index in range(range_size): while pigeonholes[index] > 0: sorted_arr.append(index + min_val) pigeonholes[index] -= 1 return sorted_arr"},{"question":"Longest Common Prefix Coding Challenge # Scenario: Imagine you are a software engineer at a company that develops a search engine application. One of the tasks is to implement an efficient function to find the longest common prefix among an array of strings which can be used for improving the search suggestions feature. # Problem Statement: Given an array of strings, write a Python function `longest_common_prefix(strings: List[str]) -> str` to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string `\\"\\"`. # Requirements: 1. Implement three versions of the function using different approaches: * Horizontal Scanning * Vertical Scanning * Divide and Conquer 2. Compare the performance of each version. Identify and justify which version is the most suitable for different scenarios. # Input and Output: * **Input**: Array of strings `strings` where 0 <= len(strings) <= 200 and 0 <= len(strings[i]) <= 200. * **Output**: Return a string which is the longest common prefix. # Constraints: * The array of strings can be empty. * Strings can contain lowercase English letters. * Performance requirements must be considered for large input sizes. # Examples: Example 1: ```python Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" ``` Example 2: ```python Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" Explanation: There is no common prefix among the input strings. ``` Instructions: 1. Write the function implementations for Horizontal Scanning, Vertical Scanning, and Divide and Conquer. 2. Compare their time and space complexity. 3. Test the implementations with different test cases to analyze their behavior and performance. # Constraints Summary: * The function should handle cases with no common prefix gracefully. * The function should manage edge cases such as empty arrays and empty strings.","solution":"from typing import List def longest_common_prefix_horizontal(strings: List[str]) -> str: if not strings: return \\"\\" prefix = strings[0] for s in strings[1:]: while not s.startswith(prefix): prefix = prefix[:-1] if not prefix: return \\"\\" return prefix def longest_common_prefix_vertical(strings: List[str]) -> str: if not strings: return \\"\\" for i in range(len(strings[0])): c = strings[0][i] for s in strings[1:]: if i >= len(s) or s[i] != c: return strings[0][:i] return strings[0] def longest_common_prefix_divide_and_conquer(strings: List[str]) -> str: def find_lcp(strs, l, r): if l == r: return strs[l] else: mid = (l + r) // 2 lcp_left = find_lcp(strs, l, mid) lcp_right = find_lcp(strs, mid + 1, r) return common_prefix(lcp_left, lcp_right) def common_prefix(left, right): min_len = min(len(left), len(right)) for i in range(min_len): if left[i] != right[i]: return left[:i] return left[:min_len] if not strings: return \\"\\" return find_lcp(strings, 0, len(strings) - 1)"},{"question":"You are given an array of words and an array of symbols. For each word, determine the symbol that is a substring of that word. If multiple symbols match the same word, choose the symbol with the longest length. Surround the match with square brackets and return the modified words. **Input**: - `words`: An array of strings, each representing a word. - `symbols`: An array of strings, where each string is a symbol. **Output**: - An array of strings where each word has the longest matching symbol surrounded by square brackets. If no symbol matches, return the word as is. **Constraints**: - Each word and symbol will only contain lowercase and uppercase letters. - Duplicate symbols will not exist. - Each word and symbol will be non-empty. **Example**: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` **Note**: - In the example above, \'Amazon\' matches \'Am\' and \'Na\'. \'Am\' is chosen because it is longer. - \'Microsoft\' matches \'i\' and \'cro\'. \'cro\' is chosen because it is longer. - \'Google\' matches \'le\'. \'le\' is chosen because it is the only match. Write a function `match_longest_symbols(words, symbols)` that accomplishes this task efficiently. **Function Signature**: ```python def match_longest_symbols(words, symbols): # Your code here ``` # Requirements 1. Your solution should construct a Trie for optimal symbol matching. 2. Use efficient traversal to identify and replace the longest matching symbol in each word. 3. The function should handle edge cases such as no matching symbols gracefully. 4. Provide a solution within reasonable time and space complexity constraints as discussed.","solution":"def match_longest_symbols(words, symbols): Surround the longest matching symbol in each word with square brackets. # Construct a Trie node class TrieNode: def __init__(self): self.children = {} self.is_end_of_symbol = False # Function to insert a symbol into the Trie def insert_symbol(trie_root, symbol): node = trie_root for char in symbol: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_symbol = True # Build the Trie with given symbols trie_root = TrieNode() for symbol in symbols: insert_symbol(trie_root, symbol) # Function to find the longest symbol in a word using Trie def find_longest_symbol(word): longest_match = \\"\\" for i in range(len(word)): node = trie_root j = i current_match = \\"\\" while j < len(word) and word[j] in node.children: node = node.children[word[j]] current_match += word[j] j += 1 if node.is_end_of_symbol and len(current_match) > len(longest_match): longest_match = current_match return longest_match result = [] for word in words: longest_symbol = find_longest_symbol(word) if longest_symbol: word = word.replace(longest_symbol, f\\"[{longest_symbol}]\\") result.append(word) return result"},{"question":"# LinkedList-Based Stack with Minimum Element Retrieval Stacks are a fundamental data structure used in various computational tasks. In this problem, you are required to extend the conventional stack to support an additional operation: retrieving the minimum element in constant time. Function to Implement You need to implement a `MinStack` class that supports the following operations: 1. `push(int value)`: Adds a value to the stack. 2. `pop()`: Removes and returns the value at the top of the stack. 3. `peek()`: Returns the top value of the stack without removing it. 4. `is_empty()`: Checks whether the stack is empty. 5. `get_min()`: Retrieves the minimum element in the stack in constant time. Constraints - All stack operations (`push`, `pop`, `peek`, `is_empty`, and `get_min`) must run in O(1) time. - Assume the stack will contain at least one element for `get_min` operations to be called. Example ```python min_stack = MinStack() min_stack.push(5) min_stack.push(3) print(min_stack.get_min()) # Output: 3 min_stack.push(7) print(min_stack.get_min()) # Output: 3 min_stack.pop() print(min_stack.peek()) # Output: 3 print(min_stack.get_min()) # Output: 3 min_stack.pop() print(min_stack.get_min()) # Output: 5 ``` Notes - You may use the `StackNode` class provided above. - Think through edge cases like calling `pop` or `peek` on an empty stack.","solution":"class StackNode: def __init__(self, value, next_node=None, min_value=None): self.value = value self.next_node = next_node self.min_value = min_value class MinStack: def __init__(self): self.top_node = None def push(self, value): if self.top_node is None: new_node = StackNode(value, None, value) else: new_min_value = min(value, self.top_node.min_value) new_node = StackNode(value, self.top_node, new_min_value) self.top_node = new_node def pop(self): if self.top_node is None: raise IndexError(\\"Pop from an empty stack\\") pop_value = self.top_node.value self.top_node = self.top_node.next_node return pop_value def peek(self): if self.top_node is None: raise IndexError(\\"Peek from an empty stack\\") return self.top_node.value def is_empty(self): return self.top_node is None def get_min(self): if self.top_node is None: raise IndexError(\\"Get min from an empty stack\\") return self.top_node.min_value"},{"question":"# Task You are given an array of integers. Your task is to find the maximum sum of a contiguous subsequence. The contiguous subsequence should contain at least one element. # Input Format - A single list of integers `arr` of size `n` (0 ≤ n ≤ 10^5). # Output Format - A single integer representing the maximum sum of a contiguous subsequence in the array. # Constraints - -10^6 ≤ `arr[i]` ≤ 10^6, where 0 ≤ i < n. # Performance Requirements - Your solution should have a time complexity of O(n) and a space complexity of O(1). # Scenario A financial analyst is examining the profit changes of a particular stock over a period of time. They have the changes stored in an array, where the positive numbers represent profit and the negative numbers represent loss. To assess the best period to consider for a high risk-high reward investment, they need to find the maximum sum of any contiguous subsequence of these changes. # Example Example 1 ```plaintext Input: [-2, 3, 8, -1, 4] Output: 14 Explanation: The maximum sum is obtained from the subsequence [3, 8, -1, 4]. ``` Example 2 ```plaintext Input: [-1, -3, -4] Output: -1 Explanation: The maximum sum is -1, as the best we can do is to take the least negative single element. ``` Example 3 ```plaintext Input: [] Output: 0 Explanation: The array is empty, so the maximum sum is 0. ``` # Function Signature ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` # Notes - You may assume the function will receive an array as an input. - Write your solution to adhere strictly to the performance requirements.","solution":"def max_contiguous_subsequence_sum(arr): Returns the maximum sum of a contiguous subsequence in the array. if not arr: return 0 max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Coding Exercise: Implement a General String Reversal Function Context: As part of a project to enhance text processing utilities, your task is to implement a function to reverse a given string. While there are many ways to achieve this, the goal is to demonstrate your grasp of different methodologies and their efficiencies. Task: Write a function `reverse_string(s: str) -> str` that reverses the input string `s`. Implementation Requirements: 1. **Recursive Approach**: Implement a recursive method to reverse the string. 2. **Iterative Approach**: Use an iterative method with two-pointers to reverse the string. 3. **Pythonic Approach**: Utilize Python’s built-in functionalities to reverse the string. 4. **Ultra Pythonic Approach**: Leverage Python’s slicing capability. Function Signatures: ```python def reverse_string_recursive(s: str) -> str: pass def reverse_string_iterative(s: str) -> str: pass def reverse_string_pythonic(s: str) -> str: pass def reverse_string_ultra_pythonic(s: str) -> str: pass ``` Input: * A single string `s` with length in the range of 0 to 10^5. Output: * The reversed string. Constraints: * Ensure the functions handle empty strings and provide valid outputs. * Optimize each approach to respect the constraints and performance considerations. Example: ```python s = \\"hello\\" assert reverse_string_recursive(s) == \\"olleh\\" assert reverse_string_iterative(s) == \\"olleh\\" assert reverse_string_pythonic(s) == \\"olleh\\" assert reverse_string_ultra_pythonic(s) == \\"olleh\\" ```","solution":"def reverse_string_recursive(s: str) -> str: Reverses the string using a recursive approach. if len(s) <= 1: return s else: return s[-1] + reverse_string_recursive(s[:-1]) def reverse_string_iterative(s: str) -> str: Reverses the string using an iterative approach with two-pointers method. str_list = list(s) left, right = 0, len(str_list) - 1 while left < right: str_list[left], str_list[right] = str_list[right], str_list[left] left += 1 right -= 1 return \'\'.join(str_list) def reverse_string_pythonic(s: str) -> str: Reverses the string using Python built-in functionalities. return \'\'.join(reversed(s)) def reverse_string_ultra_pythonic(s: str) -> str: Reverses the string using Python slicing capability. return s[::-1]"},{"question":"Scenario You are a software developer at a logistics company. Your company is developing an application that analyzes the reachability of delivery locations within a city. The city is modeled as a directed graph, where vertices represent locations and edges represent direct roads between them. To determine which locations can be reached from others, you need to implement the transitive closure of the graph using Depth First Search (DFS). Task Write a function `find_transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]` that computes the transitive closure matrix of a directed graph. Input * `vertices` (int): The number of vertices in the graph, denoted by `V`. Assume vertices are numbered from 0 to `V-1`. * `edges` (List[Tuple[int, int]]): A list of tuples where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. Output * A `V x V` matrix where a cell `[i][j]` contains `1` if there is a path from vertex `i` to vertex `j`, otherwise `0`. Constraints * `1 <= vertices <= 1000` * The number of edges will not exceed `(vertices * (vertices - 1))`. Example # Input ```python vertices = 4 edges = [(0, 1), (1, 2), (2, 0), (3, 2)] ``` # Output ```python [ [1, 1, 1, 0], [1, 1, 1, 0], [1, 1, 1, 0], [0, 0, 1, 1] ] ``` Implementation Note * Make use of the class `Graph` provided and adapt it into the function as needed. Ensure the transitive closure matrix is built correctly.","solution":"from typing import List, Tuple def dfs(graph, source, vertex, reachable): reachable[source][vertex] = 1 for neighbor in graph[vertex]: if not reachable[source][neighbor]: dfs(graph, source, neighbor, reachable) def find_transitive_closure(vertices: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Create the adjacency list representation of the graph graph = [[] for _ in range(vertices)] for u, v in edges: graph[u].append(v) # Initialize the transitive closure matrix with zeros reachable = [[0] * vertices for _ in range(vertices)] # For each vertex, apply DFS to mark reachable vertices for vertex in range(vertices): dfs(graph, vertex, vertex, reachable) return reachable"},{"question":"# Polynomial Class Addition with Coefficient Merging You are required to implement an effective addition operation for the `Polynomial` class such that when two polynomials are added, the resulting polynomial is simplified by merging like terms. Objective Modify the existing `__add__` function in the `Polynomial` class to ensure that the resultant polynomial automatically merges like terms, i.e., terms with the same variables should be combined into a single term. Implementation Details: - The function should handle the addition of: - Integers, floats, and fractions. - Monomials. - Other polynomials. - If a monomial\'s coefficients cancel to zero, it must be removed from the resultant polynomial. - Your implementation should take extra care to merge terms that are equivalent up to a scalar value efficiently. Example: ```python # Sample input p1 = Polynomial([ Monomial({1:1}, 2), Monomial({2:3, 1:-1}, -1), Monomial({}, 5) ]) p2 = Polynomial([ Monomial({1:1}, 1), Monomial({2:3, 1:-1}, 1) ]) # Adding p1 and p2 result = p1 + p2 # Expected output # Polynomial simplified to: # Polynomial([ # Monomial({1:1}, 3), # Monomial({}, 5) # ]) ``` # Constraints: 1. Inputs will always be valid polynomials. 2. Each monomial is defined as having only non-negative integer powers in variables. 3. Ensure your implementation efficiently handles the merging of like terms. To solve this problem, make the necessary changes to the provided `Polynomial` class code to implement the required functionality. Deliverables: 1. Implementation of the modified `__add__` method within the `Polynomial`. 2. Test the resultant polynomial for the given example and ensure it matches the expected output. Good Luck!","solution":"class Monomial: def __init__(self, variables, coefficient): self.variables = frozenset(variables.items()) self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables def __hash__(self): return hash(self.variables) class Polynomial: def __init__(self, monomials): self.monomials = monomials def __add__(self, other): # Create a dictionary to store combined monomials combined = {} # Function to add monomials to the combined dict def add_to_combined(monomial): if monomial.variables in combined: combined[monomial.variables].coefficient += monomial.coefficient else: combined[monomial.variables] = monomial # Add all monomials from self to combined for monomial in self.monomials: add_to_combined(monomial) # Add all monomials from other to combined for monomial in other.monomials: add_to_combined(monomial) # Filter out monomials with a coefficient of zero new_monomials = [m for m in combined.values() if m.coefficient != 0] return Polynomial(new_monomials) def __eq__(self, other): return set(self.monomials) == set(other.monomials) def __repr__(self): return f\\"Polynomial({self.monomials})\\""},{"question":"# Unique Number Finder Consider the numbers in a given range `[low, high]` which have a special property: they are equal to the sum of their digits each raised to a power corresponding to their position in the number. For example, the number `89` is a unique number because: [ 89 = 8^1 + 9^2 = 89 ] Another example is `135`, which satisfies: [ 135 = 1^1 + 3^2 + 5^3 = 135 ] Your task is to write a function named `unique_numbers_in_range` which takes two integers, `low` and `high`, and returns a list of all numbers in this range (inclusive) that have this special property. # Function Signature ```python def unique_numbers_in_range(low: int, high: int) -> list: pass ``` # Input - `low`: An integer, the starting number of the range. - `high`: An integer, the ending number of the range. # Output - A list of integers that satisfy the given property. # Constraints - `1 <= low <= high <= 10^4` # Performance Requirements - The solution should be optimized to handle the upper bound efficiently. # Example Input `low = 1` `high = 150` Output `[1, 2, 3, 4, 5, 6, 7, 8, 9, 89, 135]` # Notes - Ensure the function handles all edge cases such as low being equal to high. - Validate and handle any invalid inputs gracefully, ensuring the function remains robust.","solution":"def unique_numbers_in_range(low: int, high: int) -> list: Returns a list of numbers within the provided range [low, high] that are equal to the sum of their digits each raised to a power corresponding to their position in the number. def sum_of_digits_powered(n): return sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str(n))) result = [] for num in range(low, high + 1): if sum_of_digits_powered(num) == num: result.append(num) return result"},{"question":"Given a `m x n` 2D grid initialized with these three possible values: - `-1`: A wall or an obstacle. - `0`: A gate. - `INF`: Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent `INF` as you may assume that the distance to a gate is less than 2147483647. Write a function `walls_and_gates(rooms)` that fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should remain filled with `INF`. Your algorithm should be optimized for large grids. Example: Input: ``` rooms = [ [INF, -1, 0, INF], [INF, INF, INF, -1], [INF, -1, INF, -1], [0, -1, INF, INF] ] ``` Output: ``` [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` # Constraints: - The input grid will have at most 1000 rows and 1000 columns. - Space complexity should be considered particularly for large grids. Performance Requirements: - Time Complexity: O(m * n) - Space Complexity: O(m * n) Implement the function `walls_and_gates(rooms)` that fills each room with the shortest distance to the nearest gate using an optimized BFS approach.","solution":"from collections import deque def walls_and_gates(rooms): if not rooms: return rows, cols = len(rooms), len(rooms[0]) GATE = 0 INF = 2147483647 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque() for r in range(rows): for c in range(cols): if rooms[r][c] == GATE: queue.append((r, c)) while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and rooms[nr][nc] == INF: rooms[nr][nc] = rooms[r][c] + 1 queue.append((nr, nc))"},{"question":"**Question Name**: Single-Source Shortest Path with Negative Cycle Detection **Problem Statement**: You are given a weighted directed graph represented as an adjacency list where the keys are nodes and the values are dictionaries of adjacent nodes with edge weights. Your task is to determine if a valid shortest path exists from a given source node to all other nodes or if there\'s a negative weight cycle reachable from the source node. **Function Signature**: ```python def has_valid_shortest_path(graph: Dict[str, Dict[str, int]], source: str) -> bool: ``` **Input**: * `graph`: A dictionary representing the graph where `graph[u][v]` is the weight of the edge from node `u` to node `v`. * `source`: The starting node represented as a string. **Output**: * Return `True` if there is no negative weight cycle reachable from the source. Otherwise, return `False`. **Constraints**: * The graph contains at most 1000 vertices. * The total number of edges doesn’t exceed 10000. * Edge weights are integers which could be negative. **Example**: ```python graph = { \'a\': {\'b\': 4, \'h\': 8}, \'b\': {\'c\': 8, \'h\': 11}, \'c\': {\'d\': 7, \'f\': 4, \'i\': 2}, \'d\': {\'e\': 9, \'f\': 14}, \'e\': {\'f\': 10}, \'f\': {\'g\': 2}, \'g\': {\'h\': 1, \'i\': 6}, \'h\': {\'i\': 7, \'a\': -12}, # Test for Negative Cycle } source = \'a\' print(has_valid_shortest_path(graph, source)) # Output: False (Because of negative weight cycle reachable from \'a\') ``` **Scenario**: Imagine you are an astronomer using graph-based algorithms to calculate the influence of various celestial bodies within a region of space mapped out with various weights representing gravitational strengths. Unfortunately, if a system contains a gravitational anomaly (represented by a negative weight cycle), your analysis could go awry. Your task is to ensure that gravitational strengths are accurate and usable. **Solution Requirements**: - Correctly initialize weight and predecessor data structures. - Appropriately relax edges per Bellman-Ford iterative process. - Correctly identify negative weight cycles.","solution":"def has_valid_shortest_path(graph, source): # Step 1: Initialization distance = {node: float(\'inf\') for node in graph} distance[source] = 0 # Step 2: Relax edges repeatedly |V| - 1 times for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distance[u] != float(\'inf\') and distance[u] + graph[u][v] < distance[v]: distance[v] = distance[u] + graph[u][v] # Step 3: Check for negative-weight cycles for u in graph: for v in graph[u]: if distance[u] != float(\'inf\') and distance[u] + graph[u][v] < distance[v]: return False # Negative weight cycle found return True # No negative weight cycle found"},{"question":"Scenario Imagine you are developing a system that needs to interact directly with binary data for performance reasons. One of the operations your system needs to perform is bit swapping to encode and decode data. You need to implement an algorithm that swaps the odd and even bits of a given non-negative integer as efficiently as possible. Task Write a function `swap_pair(num: int) -> int` that takes a non-negative integer `num` and returns an integer with its odd and even bits swapped. You should strive to achieve this with fewest instructions possible and without using loops. Input - An integer `num` (0 ≤ num ≤ 10^9). Output - An integer with the odd and even bits swapped. Constraints - You may assume that the input integer fits within a standard 32-bit signed integer. Example - Input: `22` (in binary: `010110`) - Output: `41` (in binary: `101001`) - Input: `10` (in binary: `1010`) - Output: `5` (in binary: `0101`) Performance Requirements - The algorithm should run in constant time with O(1) time complexity. - The memory usage should also be constant, O(1). Function Signature ```python def swap_pair(num: int) -> int: pass ```","solution":"def swap_pair(num: int) -> int: Swaps odd and even bits of the given non-negative integer. The odd bits of the given integer are shifted right to even positions and the even bits are shifted left to odd positions. :param num: Non-negative integer to swap bits in :return: Integer with odd and even bits swapped # Mask for even bits (binary: 10101010...) EVEN_MASK = 0xAAAAAAAA # Mask for odd bits (binary: 01010101...) ODD_MASK = 0x55555555 # Shift right odd bits to even positions and shift left even bits to odd positions even_bits_shifted = (num & EVEN_MASK) >> 1 odd_bits_shifted = (num & ODD_MASK) << 1 # Combine the shifted bits to get the final result return even_bits_shifted | odd_bits_shifted"},{"question":"# Integer Partitioning Problem **Objective**: Write a function `int_divide(n: int) -> int` that computes the number of ways a positive integer `n` can be decomposed into sums of non-negative integers. Function Signature: ```python def int_divide(n: int) -> int: ... ``` # Input * An integer, `n` (1 ≤ n ≤ 100). # Output * An integer representing the number of different ways to decompose `n`. # Constraints * Your solution should have a time complexity of O(n^2). * You should handle edge cases carefully such as small values of `n`. # Examples ```python assert int_divide(4) == 5 assert int_divide(7) == 15 ``` # Hints 1. Use dynamic programming with a two-dimensional array where `arr[i][j]` represents the number of ways to partition `i` using integers up to `j`. 2. Initialize your array properly and iteratively compute the number of partitions using nested loops. # Detailed Scenario Imagine a situation where you need to determine the number of ways to make change for an amount of money using a given set of coin denominations. Integer partitioning can analogously help in solving this problem by decomposing the amount into sums of denominations. # Performance Requirements Your solution should efficiently compute results within the given constraints, avoiding unnecessary recalculations through dynamic programming techniques.","solution":"def int_divide(n: int) -> int: Returns the number of ways a positive integer n can be decomposed into sums of non-negative integers. dp = [0] * (n + 1) dp[0] = 1 # There\'s one way to partition 0 (using no parts) for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Scenario You are tasked with developing a software tool that aids mathematicians in investigating integer partitions. One of the critical features of this tool is calculating how many different ways a given positive integer `n` can be decomposed into the sum of non-negative integers. # Problem Statement Write a function `int_divide(decompose: int) -> int:` that takes an integer `decompose` and returns the number of different ways the integer can be decomposed as a sum of non-negative integers. # Input * A single integer `decompose` (1 <= decompose <= 100) # Output * Return an integer representing the number of ways `decompose` can be decomposed. # Constraints * Ensure that your solution efficiently handles the upper limit of the input size. * The order in which numbers are added does not matter, i.e., 3+1 is considered the same as 1+3. # Example Example 1: Input: `4` Output: `5` Explanation: 4 can be decomposed in the following ways: ``` 4=4 4=3+1 4=2+2 4=2+1+1 4=1+1+1+1 ``` Example 2: Input: `7` Output: `15` Explanation: 7 can be decomposed in the following ways: ``` 7=7 7=6+1 7=5+2 7=5+1+1 7=4+3 7=4+2+1 7=4+1+1+1 7=3+3+1 7=3+2+2 7=3+2+1+1 7=3+1+1+1+1 7=2+2+2+1 7=2+2+1+1+1 7=2+1+1+1+1+1 7=1+1+1+1+1+1+1 ``` **Note:** The order of addends in the decomposition does not matter. # Requirements * Ensure your solution efficiently handles the input size. * Avoid using any built-in functions that trivially solve the problem.","solution":"def int_divide(decompose: int) -> int: Returns the number of ways to decompose the given integer \'decompose\' into the sum of non-negative integers. # Using the dynamic programming approach dp = [0] * (decompose + 1) dp[0] = 1 # Base case: there is one way to make 0 with sum 0 for i in range(1, decompose + 1): # Consider numbers 1 to \'decompose\' for j in range(i, decompose + 1): # Consider sums including each number dp[j] += dp[j - i] return dp[decompose]"},{"question":"You are tasked to implement a function `temperature_filter` that processes temperature readings recorded throughout the day and filters them based on provided minimum and maximum temperature limits. This helps in identifying temperature readings that fall within a desirable operational range. # Function Signature ```python def temperature_filter(readings: List[int], min_temp: Optional[int] = None, max_temp: Optional[int] = None) -> List[int]: pass ``` # Input * `readings`: A list of integers representing temperature readings. * `min_temp`: An optional integer representing the minimum temperature limit. Defaults to `None`, which means no lower bound. * `max_temp`: An optional integer representing the maximum temperature limit. Defaults to `None`, which means no upper bound. # Output * Return a list of integers containing only the temperature readings that fall within the range defined by `min_temp` and `max_temp` (inclusive). # Constraints * The length of `readings` will not exceed (10^5). * Temperature readings are in the range ([-200, 200]). * If both `min_temp` and `max_temp` are `None`, return the original list. # Example ```python assert temperature_filter([4, 15, 50, 70, 21], None, 50) == [4, 15, 50, 21] assert temperature_filter([-10, 0, 5, 23, 60], -5, 25) == [0, 5, 23] assert temperature_filter([1, 2, 3, 4, 5], 3) == [3, 4, 5] assert temperature_filter([], 10, 20) == [] assert temperature_filter([15, 25, 35, 45, 55], None, None) == [15, 25, 35, 45, 55] ``` # Notes 1. Implement the function in such a way that it runs efficiently for large lists. 2. Consider handling edge cases gracefully such as empty input lists, and minimum/maximum boundaries not being provided.","solution":"from typing import List, Optional def temperature_filter(readings: List[int], min_temp: Optional[int] = None, max_temp: Optional[int] = None) -> List[int]: Filters temperature readings based on provided minimum and maximum limits. :param readings: A list of integers representing temperature readings. :param min_temp: Optional minimum temperature limit (inclusive). :param max_temp: Optional maximum temperature limit (inclusive). :return: Filtered list of readings within the specified range. if min_temp is None and max_temp is None: return readings filtered_readings = [] for reading in readings: if (min_temp is None or reading >= min_temp) and (max_temp is None or reading <= max_temp): filtered_readings.append(reading) return filtered_readings"},{"question":"Given a string as input, write a function `delete_reoccurring_characters_optimized` that removes all reoccurring characters from the string and returns a new string containing only the unique characters in the order of their first occurrence. # Function Signature: ```python def delete_reoccurring_characters_optimized(string: str) -> str: # Your code here ``` # Input: * A single string `string` of length `n` (1 ≤ n ≤ 10^6). # Output: * A new string with all duplicate characters removed, retaining only the first occurrence of each character. # Example: ```python assert delete_reoccurring_characters_optimized(\\"programming\\") == \\"progamin\\" assert delete_reoccurring_characters_optimized(\\"aabbccdd\\") == \\"abcd\\" assert delete_reoccurring_characters_optimized(\\"abcabcabc\\") == \\"abc\\" assert delete_reoccurring_characters_optimized(\\"\\") == \\"\\" assert delete_reoccurring_characters_optimized(\\"abacabadabacaba\\") == \\"abcd\\" ``` # Constraints: * The function must handle cases where the input string is empty. * Performance must be optimized to handle strings up to 1,000,000 characters efficiently. # Scenario: You are developing a text editor feature that automatically sanitizes user-entered text by deleting any repeating characters while maintaining their first occurrence order. This feature must operate efficiently even with significantly large input sizes. # Notes: * Pay attention to the trade-off between time complexity and space complexity. * Consider edge cases and ensure your solution handles them gracefully. * Optimize your code to minimize execution time for large inputs.","solution":"def delete_reoccurring_characters_optimized(string: str) -> str: Returns a new string with all duplicate characters removed, retaining only the first occurrence of each character. seen = set() result = [] for char in string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Coding Assessment: Strong Connectivity in Directed Graphs Objective Implement a function to determine if a given directed graph is strongly connected. Description A strongly connected component (SCC) of a directed graph is a subgraph where any vertex is reachable from any other vertex within the subgraph. A graph is considered strongly connected if there is a path between any pair of vertices. You are provided with a graph implementation in Python to determine if a directed graph is strongly connected using the principles of Kosaraju\'s Algorithm. Your task is to implement the `is_strongly_connected` method that completes this analysis. Function Signature ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: ``` Input * `vertex_count` (int): Number of vertices in the graph, labeled from 0 to `vertex_count`-1. * `edges` (List[Tuple[int, int]]): A list of tuples representing directed edges in the graph. Each tuple `(a, b)` indicates a directed edge from vertex `a` to vertex `b`. Output * Returns `True` if the graph is strongly connected. * Returns `False` otherwise. Example ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3), (3, 0)] print(is_strongly_connected(vertex_count, edges)) # Output: True vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] print(is_strongly_connected(vertex_count, edges)) # Output: False ``` Constraints * You must use the provided `Graph` class for your implementation. * Avoid using any additional libraries or modifying the core logic of the `Graph` class. * Aim for an efficient solution in both time and space complexity. Implementation Implement your solution within the function `is_strongly_connected`. Utilize the existing methods of the `Graph` class such as `add_edge`, `dfs`, `dfs_util` and `reverse_graph`. ```python from collections import defaultdict from typing import List, Tuple class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): self.graph[source].append(target) def dfs_util(self, source, visited): visited[source] = True for adjacent in self.graph[source]: if not visited[adjacent]: self.dfs_util(adjacent, visited) def dfs(self): visited = [False] * self.vertex_count self.dfs_util(0, visited) return visited == [True] * self.vertex_count def reverse_graph(self): reverse_graph = Graph(self.vertex_count) for source, adjacent in self.graph.items(): for target in adjacent: reverse_graph.add_edge(target, source) return reverse_graph # Complete this function def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: # Your implementation here pass ``` In this task, your implementation in `is_strongly_connected` should correctly determine if the provided graph is strongly connected by making use of the `Graph` class methods.","solution":"from collections import defaultdict from typing import List, Tuple class Graph: def __init__(self, vertex_count): self.vertex_count = vertex_count self.graph = defaultdict(list) def add_edge(self, source, target): self.graph[source].append(target) def dfs_util(self, source, visited): visited[source] = True for adjacent in self.graph[source]: if not visited[adjacent]: self.dfs_util(adjacent, visited) def dfs(self, start_vertex): visited = [False] * self.vertex_count self.dfs_util(start_vertex, visited) return visited == [True] * self.vertex_count def reverse_graph(self): reverse_graph = Graph(self.vertex_count) for source, adjacent in self.graph.items(): for target in adjacent: reverse_graph.add_edge(target, source) return reverse_graph def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: graph = Graph(vertex_count) for edge in edges: graph.add_edge(*edge) # Check if all vertices are reachable from the first vertex (vertex 0) if not graph.dfs(0): return False # Get the reversed graph reverse_graph = graph.reverse_graph() # Check if all vertices are reachable from the first vertex in the reversed graph if not reverse_graph.dfs(0): return False return True"},{"question":"You are tasked with designing a system that communicates with external hardware devices, which may use different byte order representations (endianness). Given integers and byte sequences, you need to implement functions to convert them between integer format and both big-endian and little-endian byte formats. Your task is to implement the functions adhering to the following guidelines: **Function 1: integer_to_bytes** Converts an integer to a byte representation in either big-endian or little-endian format. * **Input**: * An integer `num` (0 <= num < 2^64) * A string `endian` which can be either \\"big\\" or \\"little\\" to indicate the desired endianness. * **Output**: A byte sequence representing the integer in the specified byte order. **Function 2: bytes_to_integer** Converts a byte sequence in either big-endian or little-endian format to an integer. * **Input**: * A byte sequence `bytestr` * A string `endian` which can be either \\"big\\" or \\"little\\" to indicate the endianness of the byte sequence. * **Output**: The integer value represented by the byte sequence in the specified byte order. # Example: ```python # Big endian conversion assert integer_to_bytes(305419896, \\"big\\") == b\'x12x34x56x78\' assert bytes_to_integer(b\'x12x34x56x78\', \\"big\\") == 305419896 # Little endian conversion assert integer_to_bytes(305419896, \\"little\\") == b\'x78x56x34x12\' assert bytes_to_integer(b\'x78x56x34x12\', \\"little\\") == 305419896 ``` # Constraints: * Assume inputs are valid and within the specified ranges. * The byte sequence in \'bytes_to_integer\' has a maximum length of 8 bytes. Implement the following two functions: ```python def integer_to_bytes(num: int, endian: str) -> bytes: # Your code here def bytes_to_integer(bytestr: bytes, endian: str) -> int: # Your code here ``` Focus on handling the conversion correctly and efficiently for both endianness types. Consider edge cases and ensure the functions are robust and reliable.","solution":"def integer_to_bytes(num: int, endian: str) -> bytes: Converts an integer to a byte representation in either big-endian or little-endian format. :param num: An integer (0 <= num < 2^64) :param endian: A string which can be either \\"big\\" or \\"little\\" to indicate the desired endianness. :return: A byte sequence representing the integer in the specified byte order. if endian not in (\\"big\\", \\"little\\"): raise ValueError(\\"endian must be \'big\' or \'little\'\\") return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=endian) def bytes_to_integer(bytestr: bytes, endian: str) -> int: Converts a byte sequence in either big-endian or little-endian format to an integer. :param bytestr: A byte sequence. :param endian: A string which can be either \\"big\\" or \\"little\\" to indicate the endianness of the byte sequence. :return: The integer value represented by the byte sequence in the specified byte order. if endian not in (\\"big\\", \\"little\\"): raise ValueError(\\"endian must be \'big\' or \'little\'\\") return int.from_bytes(bytestr, byteorder=endian)"},{"question":"You are tasked with writing a function to determine the number of digits in a given integer. The function should make use of mathematical properties to achieve this in constant time. # Function Specification * **Function Name**: `num_digits` * **Input**: A single integer `n` (where -10^18 <= n <= 10^18) * **Output**: An integer representing the number of digits in `n`. # Constraints 1. The function must handle both positive and negative numbers correctly. 2. The function must handle zero as an input and return 1. 3. The solution should operate in O(1) time complexity. # Example ```python print(num_digits(0)) # Output: 1 print(num_digits(12345)) # Output: 5 print(num_digits(-12345)) # Output: 5 print(num_digits(100000)) # Output: 6 ``` # Additional Notes * You may not use string manipulation or iterative counting to determine the number of digits. * Ensure that the function handles edge cases, including very small and very large integers. * Floating-point precision issues should be considered, especially for extreme values.","solution":"import math def num_digits(n): Returns the number of digits in the given integer n. Handles both positive and negative numbers as well as zero. This function operates in O(1) time complexity by making use of logarithmic properties. :param n: int :return: int if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"Suppose you\'re given a binary tree. Your task is to write a function that returns the inorder traversal of its nodes\' values. You need to implement the inorder traversal function both iteratively and recursively. # Function Signatures ```python def inorder(root: Node) -> list[int]: # Iterative version pass def inorder_rec(root: Node) -> list[int]: # Recursive version pass ``` # Input * `root`: A Node object representing the root of a binary tree. # Output * Return a list of integers representing the inorder traversal of the tree. # Constraints * The number of nodes in the tree is in the range `[0, 10^4]`. * The value of each node is in the range `[-10^4, 10^4]`. # Requirements * Implement two functions using both recursive and iterative approaches. * Ensure that the solutions handle edge cases including empty trees and single-node trees. * Aim for the optimal time and space complexity. # Example Given the following tree: ``` 100 / 50 150 / / 25 75 125 175 ``` Calling your functions should return: ```python assert inorder(root) == [25, 50, 75, 100, 125, 150, 175] assert inorder_rec(root) == [25, 50, 75, 100, 125, 150, 175] ``` # Note Ensure that you handle cleanup of any data structures you use to not leave residual effects and avoid global state pollution.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder(root: Node) -> list[int]: Iterative inorder traversal of a binary tree. stack, result = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.value) current = current.right return result def inorder_rec(root: Node) -> list[int]: Recursive inorder traversal of a binary tree. if root is None: return [] return inorder_rec(root.left) + [root.value] + inorder_rec(root.right)"},{"question":"# Graph Traversal with Application Context Context You are a software engineer working on a social network application aimed to connect professionals. To accomplish this, your task is to analyze the network connectivity using various graph traversal algorithms. Specifically, you need to locate all professionals reachable from a starting professional. Problem Statement Implement two functions, `find_reachable_nodes_dfs(graph, start)` and `find_reachable_nodes_bfs(graph, start)`, that utilize Depth First Search (DFS) and Breadth First Search (BFS) respectively to list all vertices reachable from the starting node. The graph is represented as an adjacency list. Input * `graph`: A dictionary where the keys represent nodes and the values are lists of connected nodes. * `start`: A starting node from which the search begins. Output * Both functions should return a list of nodes that are reachable from the starting node in the order they were first encountered. * You may assume all nodes are reachable if the graph is connected. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' # For DFS find_reachable_nodes_dfs(graph, start) # Expected Output (One possible solution) # [\'A\', \'C\', \'F\', \'E\', \'B\', \'D\'] # For BFS find_reachable_nodes_bfs(graph, start) # Expected Output # [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] ``` Constraints 1. Assume no parallel edges or self-loops in the graph. 2. All vertices in the graph are unique. 3. The graph is undirected.","solution":"def find_reachable_nodes_dfs(graph, start): Perform a Depth First Search (DFS) on the graph starting from the \'start\' node and return the list of reachable nodes. visited = set() result = [] def dfs(node): if node not in visited: visited.add(node) result.append(node) for neighbor in graph[node]: dfs(neighbor) dfs(start) return result def find_reachable_nodes_bfs(graph, start): Perform a Breadth First Search (BFS) on the graph starting from the \'start\' node and return the list of reachable nodes. visited = set() queue = [start] result = [] while queue: node = queue.pop(0) if node not in visited: visited.add(node) result.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return result"},{"question":"**Character Redundancy Elimination** You are given a string, and your task is to write a function that processes this string to remove any recurring characters, retaining only the first occurrence of each character. The function should maintain the order of the first occurrences. # Function Signature ```python def remove_redundant_characters(input_string: str) -> str: ``` # Input - **input_string** (str): A string (0 ≤ |input_string| ≤ 10^5) containing any printable ASCII characters. # Output - A string with all recurring characters removed, preserving the order of first appearances. # Constraints - The input string can be empty. - Characters are case-sensitive (\'a\' is different from \'A\'). # Examples ```python assert remove_redundant_characters(\\"banana\\") == \\"ban\\" assert remove_redundant_characters(\\"programming\\") == \\"progamin\\" assert remove_redundant_characters(\\"\\") == \\"\\" assert remove_redundant_characters(\\"AaBbCc\\") == \\"AaBbCc\\" assert remove_redundant_characters(\\"aabbcc\\") == \\"abc\\" ``` # Notes - Ensure to handle edge cases such as an empty string and strings where all characters are unique or all are duplicates. - Aim for a solution with linear time and space complexity to handle the upper limit of the input size efficiently. # Performance Requirements - Your solution should have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string.","solution":"def remove_redundant_characters(input_string: str) -> str: Removes any recurring characters from the input string, retaining only the first occurrence of each character. Args: input_string (str): The original string. Returns: str: The processed string with redundant characters removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Task Implement a function `range_updater` using the Segment Tree data structure. You will be provided an array of integers and a series of operations to perform on the array. You need to support two types of operations: 1. Range query: Sum of array elements from index `l` to index `r` (both inclusive). 2. Update: Update the element at index `p` to a value `v`. # Input - A list of integers `nums` which represents the initial array. - A list of operations where each operation is represented as a tuple: - Query operation is represented as `(\\"query\\", l, r)`. - Update operation is represented as `(\\"update\\", p, v)`. # Output Return a list of results for the query operations in the order they appear. # Constraints - `1 <= len(nums) <= 10^5` - `0 <= nums[i] <= 10^9` - `0 <= l <= r < len(nums)` - `0 <= p < len(nums)` - `0 <= v <= 10^9` - Number of operations will be up to `10^4`. # Example ```python nums = [2, 4, 5, 3, 4] operations = [ (\\"query\\", 2, 4), (\\"update\\", 3, 6), (\\"query\\", 0, 3) ] # Expected Output: # [12, 17] ``` # Function Signature ```python def range_updater(nums: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: ```","solution":"from typing import List, Tuple class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self._build(data) def _build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, pos, value): pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, l, r): l += self.n r += self.n result = 0 while l <= r: if l % 2 == 1: result += self.tree[l] l += 1 if r % 2 == 0: result += self.tree[r] r -= 1 l //= 2 r //= 2 return result def range_updater(nums: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: seg_tree = SegmentTree(nums) results = [] for op in operations: if op[0] == \\"query\\": _, l, r = op results.append(seg_tree.query(l, r)) elif op[0] == \\"update\\": _, p, v = op seg_tree.update(p, v) return results"},{"question":"# Task: **Problem Statement:** You are climbing a staircase. It takes `n` number of steps to reach the top. Each time you can either climb 1 or 2 steps. Implement a function `distinct_ways_to_climb` that returns the number of distinct ways you can reach the top. **Requirements**: - You must use dynamic programming to solve this problem. - Optimize the space complexity as much as possible. **Function Signature**: `def distinct_ways_to_climb(n: int) -> int:` # Input: - An integer `n` representing the total number of steps (1 <= n <= 10^4). # Output: - An integer representing the number of distinct ways to reach the top. # Examples: 1. `distinct_ways_to_climb(2) -> 2` - Explanation: There are two ways to climb to the top: (1+1) and (2). 2. `distinct_ways_to_climb(3) -> 3` - Explanation: There are three ways to climb to the top: (1+1+1), (1+2), and (2+1). 3. `distinct_ways_to_climb(5) -> 8` # Constraints: - Your solution should be optimized in terms of both time and space complexity. - Ensure that your code handles the edge cases correctly. - Do not use additional libraries. # Performance Requirements: - Your solution should run efficiently for n up to 10^4. Additional Information: - Think carefully about how you can reduce the space complexity to O(1) without compromising on the time complexity.","solution":"def distinct_ways_to_climb(n: int) -> int: Returns the number of distinct ways to climb a staircase with n steps, where each time you can climb either 1 step or 2 steps. Args: n (int): The total number of steps. Returns: int: The number of distinct ways to reach the top. if n == 1: return 1 if n == 2: return 2 one_step_before = 2 two_steps_before = 1 all_ways = 0 for i in range(3, n + 1): all_ways = one_step_before + two_steps_before two_steps_before = one_step_before one_step_before = all_ways return all_ways"},{"question":"# Bucket Sort Implementation Problem Statement Implement the bucket sort algorithm. Your implementation should divide input data into a specific number of buckets, sort each bucket individually using insertion sort, and then concatenate the buckets to create the final sorted list. Input - A list of non-negative integers `arr` Output - A sorted list of integers Constraints - Array length (n): 1 ≤ n ≤ 1000 - Elements: 0 ≤ element ≤ 1000 Example ```python >>> bucket_sort([29, 25, 3, 49, 9, 37, 21, 43]) [3, 9, 21, 25, 29, 37, 43, 49] >>> bucket_sort([5, 2, 9, 5, 2, 9, 2, 5]) [2, 2, 2, 5, 5, 5, 9, 9] ``` Scenario/Context Imagine you are tasked with sorting the scores of participants in a game. The scores range from 0 to 1000 and can be uniformly or non-uniformly distributed. Using the bucket sort will help efficiently sort these scores. Requirements 1. Define the `bucket_sort` function. 2. Inside `bucket_sort`, create buckets and distribute elements into these buckets. 3. Sort elements inside each bucket using provided `insertion_sort`. 4. Concatenate buckets to produce the sorted list. 5. Handle edge cases like empty lists, single element lists. ```python def bucket_sort(arr): \'\'\' Bucket Sort Args: arr: List[int], a list of non-negative integers. Returns: List[int]: The sorted list of integers. \'\'\' # Your code here ``` Performance - Ensure that your implementation is efficient concerning time and space complexity.","solution":"def insertion_sort(bucket): Sorts a bucket using the insertion sort algorithm. for i in range(1, len(bucket)): key = bucket[i] j = i - 1 while j >= 0 and key < bucket[j]: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = key return bucket def bucket_sort(arr): Sorts an array of non-negative integers using the bucket sort algorithm. Args: arr: List[int], a list of non-negative integers. Returns: List[int]: The sorted list of integers. if len(arr) == 0: return arr # Create buckets bucket_count = len(arr) max_value = max(arr) buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for num in arr: index = num * bucket_count // (max_value + 1) buckets[index].append(num) # Sort individual buckets for i in range(bucket_count): buckets[i] = insertion_sort(buckets[i]) # Concatenate sorted buckets into a single list sorted_arr = [] for bucket in buckets: sorted_arr.extend(bucket) return sorted_arr"},{"question":"# Euler\'s Totient Function Enhanced Given an integer ( n ), write a function `euler_totient_enhanced(n)` that calculates Euler\'s Totient Function ( phi(n) ). Your implementation should handle large inputs efficiently and consider the optimizations and edge cases discussed. Input - An integer ( n ) (1 ≤ n ≤ ( 10^9 )). Output - The result of Euler\'s Totient Function ( phi(n) ). Requirements - Your solution should be as efficient as possible. Aim for a time complexity around ( O(sqrt{n}) ). Constraints - Ensure you handle edge cases, such as ( n = 1 ) and very large values of ( n ). Example ```python # Example 1: # Input print(euler_totient_enhanced(9)) # Output 6 # Explanation # Numbers coprime with 9 are {1, 2, 4, 5, 7, 8}. # Example 2: # Input print(euler_totient_enhanced(28)) # Output 12 # Explanation # Numbers coprime with 28 are {1, 3, 5, 9, 11, 13, 15, 17, 19, 23, 25, 27}. ``` Provide a detailed and efficient implementation of the function `euler_totient_enhanced`.","solution":"def euler_totient_enhanced(n): Calculates Euler\'s Totient Function (φ(n)) efficiently. Uses an optimized approach with a time complexity around O(sqrt(n)). if n == 1: return 1 result = n p = 2 # Check for all primes up to sqrt(n) while p * p <= n: if n % p == 0: # If p is a factor, then account for it while n % p == 0: n //= p result -= result // p p += 1 # If n is a prime number greater than sqrt(n) if n > 1: result -= result // n return result"},{"question":"You are required to implement a Trie (prefix tree) data structure for efficient storage and query of strings, specifically words composed of lowercase English letters. Implement a class `Trie` that supports the following methods: 1. **insert(word: str) -> None**: Inserts the word into the trie. 2. **search(word: str) -> bool**: Returns `True` if the word is in the trie (exact match), and `False` otherwise. 3. **starts_with(prefix: str) -> bool**: Returns `True` if there is any word in the trie that starts with the given prefix, and `False` otherwise. Constraints - All words consist of lowercase English letters (`a` to `z`). - Input strings can be of length up to `1000`. - The number of operations will be at most `5000`. # Example ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # returns True print(trie.search(\\"app\\")) # returns False print(trie.starts_with(\\"app\\")) # returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # returns True ``` # Notes - You should focus on the efficient implementation of each function. - Consider edge cases such as empty words or prefixes that do not exist in the trie. - Pay attention to optimal memory usage while ensuring the operations remain performant within the given constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"You are tasked with developing an efficient algorithm to determine the number of unique paths in an m x n matrix, given that you can only move either right or down from any cell. The algorithm should be efficient in terms of both time and space complexity. Function Specification ```python def count_paths(m: int, n: int) -> int: This function calculates the number of unique paths in an m x n matrix where movement is restricted to only rightward and downward directions. :param m: Number of rows in the matrix (integer, m >= 1) :param n: Number of columns in the matrix (integer, n >= 1) :return: An integer representing the number of unique paths from the top-left to the bottom-right corner of the matrix. ``` Input * Two integers, `m` and `n` representing the number of rows and columns of the matrix respectively. Output * Return a single integer, the number of unique paths from the top-left to the bottom-right corner of the matrix. Constraints * 1 ≤ m, n ≤ 1000 Example ```python print(count_paths(3, 3)) # Output: 6 print(count_paths(4, 1)) # Output: 1 ``` Notes * Your implementation should handle edge cases, including very small matrices (e.g., 1x1) and large matrices (e.g., 1000x1000). * Aim to optimize space complexity. Implement the function while maintaining efficient space usage and avoiding pitfalls such as integer overflow or excessive memory consumption.","solution":"def count_paths(m, n): Returns the number of unique paths in an m x n matrix where movement is restricted to only rightward and downward directions. :param m: Number of rows in the matrix (integer, m >= 1) :param n: Number of columns in the matrix (integer, n >= 1) :return: An integer representing the number of unique paths from the top-left to the bottom-right corner of the matrix. if m == 1 or n == 1: return 1 # Create a 1D array for storing the number of ways to reach each cell in the current row dp = [1] * n # Loop through rows starting from the second row for i in range(1, m): for j in range(1, n): dp[j] += dp[j - 1] return dp[-1]"},{"question":"# Question: Find the k-th to Last Node in a Singly Linked List You are given a singly linked list and an integer k. Your task is to implement an efficient solution to find the k-th to last node in the list and return its value. Function Signature: ```python def find_kth_to_last(head: \'Node\', k: int) -> \'Union[Node, None]\': ``` Input: * `head` (Node): The head node of a singly linked list. * `k` (int): The position from the end (1-based index) to find the node. Output: * `Node`: The node at the k-th to last position, or `None` if no such node exists. Constraints: * The linked list will have at most 10^5 nodes. * The integer k will be non-negative. Requirements: 1. Ensure that you handle all possible edge cases. 2. Optimize for both time and space complexity. 3. Do not modify the linked list. Example: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: \'Node\', k: int) -> \'Union[Node, None]\': # Your code here # Example linked list: A -> B -> C -> D -> E a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e # Expecting the node with value \\"C\\" (3rd to last) result = find_kth_to_last(a, 3) assert result.val == \\"C\\", f\\"Expected \'C\', but got {result.val}\\" ``` Explanation: For the linked list A -> B -> C -> D -> E, with k = 3, the k-th to last node is \\"C\\". Your function should return the node which has value \\"C\\".","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head: \'Node\', k: int) -> \'Union[Node, None]\': if not head or k < 1: return None slow = fast = head # Move fast k steps ahead for _ in range(k): if not fast: return None # k is greater than the length of the list fast = fast.next # Move fast to the end and slow to the k-th last node while fast: slow = slow.next fast = fast.next return slow"},{"question":"# Problem: Implement a MinStack **Scenario**: You\'re working on an application that frequently needs to retrieve the minimum element from a collection of numbers in addition to supporting standard stack operations (push, pop, peek). **Task**: Implement a class `MinStack` which supports the following operations: 1. `push(val)` - Pushes the element `val` onto the stack. 2. `pop()` - Removes the element on the top of the stack. 3. `top()` - Gets the top element of the stack. 4. `get_min()` - Retrieves the minimum element in the stack. **Note**: All operations must have a time complexity of O(1). Example Usage: ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) assert min_stack.get_min() == -3 # Returns -3 min_stack.pop() assert min_stack.top() == 0 # Returns 0 assert min_stack.get_min() == -2 # Returns -2 ``` Constraints: * All methods should be implemented with O(1) time complexity. * You may assume that the `pop` and `get_min` operations will always be called on non-empty stacks.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: val = self.stack.pop() if val == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def get_min(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"You are given a large non-negative integer represented as an array of digits where the most significant digit is at the head of the list. Your task is to write a function that increments the integer by one. Implement this function in three different ways to ensure robustness and efficiency. # Function Signature ```python def plus_one_v1(digits: List[int]) -> List[int]: pass def plus_one_v2(digits: List[int]) -> List[int]: pass def plus_one_v3(digits: List[int]) -> List[int]: pass ``` # Input * `digits`: A list of integers representing the digits of a non-negative number. Each digit `d` in `digits` is between 0 and 9. For example, [9,9,9]. # Output * A list of integers representing the digits of the number after incrementing it by one. # Constraints * The digits array will not be empty. * Each element in the digits array lies within the range [0, 9]. # Requirements 1. Implement three variations of the `plus_one` function as described in the coding snippets. 2. Ensure your operations handle carry-overs appropriately. 3. Optimize for time and space complexity where possible. 4. Test your implementations with the provided test cases and edge cases. # Example ```python plus_one_v1([1, 2, 3]) Output: [1, 2, 4] plus_one_v2([1, 2, 3]) Output: [1, 2, 4] plus_one_v3([9, 9, 9]) Output: [1, 0, 0, 0] plus_one_v1([0]) Output: [1] plus_one_v2([0]) Output: [1] plus_one_v3([0]) Output: [1] ```","solution":"from typing import List def plus_one_v1(digits: List[int]) -> List[int]: Increment the number represented by digits by one using straightforward iteration. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits def plus_one_v2(digits: List[int]) -> List[int]: Increment the number represented by digits by one using list reversal. digits = digits[::-1] carry = 1 for i in range(len(digits)): digits[i] += carry if digits[i] < 10: carry = 0 break else: digits[i] = 0 carry = 1 if carry: digits.append(1) return digits[::-1] def plus_one_v3(digits: List[int]) -> List[int]: Increment the number represented by digits by one using string manipulation. num_str = \'\'.join(map(str, digits)) incremented_num = str(int(num_str) + 1) return [int(digit) for digit in incremented_num]"},{"question":"# Symbol Matching and Replacement You are given an array of words and an array of symbols. Your task is to write a function that identifies the symbols within each word and surrounds the matching symbol with square brackets. If a word matches more than one symbol, select the one with the longest length. If there are overlapping symbols, prefer the longer one. Input Format - An array of `words` containing n strings, where (1 leq n leq 10^5). - An array of `symbols` containing m strings, where (1 leq m leq 10^3). Output Format - A list of strings, where each word has the longest matching symbol surrounded by square brackets. Constraints - Words and symbols contain only alphabetical characters. - Each word can match multiple symbols, but you should only use the longest one. Performance Requirements - Your solution should aim for a time complexity better than O(n * m). # Example Given the following: ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] ``` # The function should output: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Definition: ```python def match_symbol(words, symbols): # Implement your solution here ``` # Requirements: - Ensure that the longest matching symbol is surrounded by square brackets. - Focus on efficient string matching to meet time complexity constraints.","solution":"def match_symbol(words, symbols): For each word in the input list `words`, find the longest symbol from `symbols` that is a substring of the word, and surround it with square brackets. Parameters: words (list of str): The list of words to search within. symbols (list of str): The list of symbols to identify within each word. Returns: list of str: The transformed words with the longest matching symbol surrounded by square brackets. # Sort symbols by length in descending order to prefer longer matches symbols.sort(key=len, reverse=True) result = [] for word in words: longest_match = \'\' for symbol in symbols: if symbol in word: longest_match = symbol break if longest_match: word = word.replace(longest_match, f\'[{longest_match}]\', 1) result.append(word) return result"},{"question":"# Question Background You are working as a data analyst in a clothing store that sells T-shirts in three different sizes: small (S), medium (M), and large (L). These sizes are represented by the integers 0, 1, and 2, respectively. You are required to sort T-shirts stored in the warehouse so that all T-shirts of the same size are grouped together and appear in the order small, medium, and large. Task Write a Python function `sort_tshirts(sizes: List[int]) -> None` that takes in a list of integers representing T-shirt sizes and modifies it in-place so that sizes are arranged in the order: small, medium, and large. Constraints * The function should not use the built-in sort function. * The function should operate in O(n) time complexity. * The function should use O(1) additional space. Input * `sizes`: A list of integers containing only the values 0, 1, and 2. The length of the list is `n` where `1 <= n <= 1000`. Output * The function modifies the list `sizes` in place such that it is sorted according to the sizes as described. Example ```python sizes = [2, 0, 2, 1, 1, 0] sort_tshirts(sizes) print(sizes) # Output should be [0, 0, 1, 1, 2, 2] sizes = [0, 1, 2, 0, 1, 2, 1, 0] sort_tshirts(sizes) print(sizes) # Output should be [0, 0, 0, 1, 1, 1, 2, 2] ``` Additional Notes * You should ensure the implementation is optimized in runtime and space complexity. * Consider edge cases such as the smallest and largest possible lists, and lists with all elements being the same size.","solution":"from typing import List def sort_tshirts(sizes: List[int]) -> None: Sort the T-shirt sizes in place so that they are ordered as [0, 0, ..., 1, 1, ..., 2, 2, ...]. Uses the Dutch National Flag algorithm to sort the array in O(n) time and O(1) space. low, mid = 0, 0 high = len(sizes) - 1 while mid <= high: if sizes[mid] == 0: sizes[low], sizes[mid] = sizes[mid], sizes[low] low += 1 mid += 1 elif sizes[mid] == 1: mid += 1 else: # sizes[mid] == 2 sizes[high], sizes[mid] = sizes[mid], sizes[high] high -= 1"},{"question":"# Scenario You are hired as a software engineer to support the development of a database system. Your task is to create an efficient data structure to store and manage user records. The system operates with frequent insertions and lookups. Using a Binary Search Tree (BST) provides an adequate solution when managed well. # Task You are required to implement a Binary Search Tree. Your implementation should support the following operations: 1. **Insert**: Add a new record while maintaining the BST property. 2. **Search**: Look up and retrieve a record by its key. 3. **Delete**: Remove a record by its key while maintaining the BST property. 4. **In-order Traversal**: Return all records in sorted order. Your implementation should be able to handle edge cases such as inserting into an empty tree, deleting nodes with one or two children, and searching for non-existent records. # Function Signatures Implement the following methods in the class `BinarySearchTree`: * `insert(val: int) -> None` * `search(val: int) -> TreeNode` * `delete(val: int) -> None` * `inorder_traversal() -> list` # Constraints * You are only allowed to use `TreeNode` class as provided without modification. * Avoid using built-in libraries for tree operations. * You may assume unique integers are inserted each time. # Example ```python # Assume TreeNode is defined as class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None # Example Usage: tree = BinarySearchTree() # create BST instance tree.insert(5) tree.insert(3) tree.insert(7) tree.insert(2) result = tree.search(3) # Should return the node with val 3 print(result.val if result else \\"Not found\\") tree.inorder_traversal() # Should return [2, 3, 5, 7] tree.delete(3) tree.inorder_traversal() # Should return [2, 5, 7] ``` Note: Your function should provide a suitable and efficient solution given the constraints and typical use cases.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left: self._insert(node.left, val) else: node.left = TreeNode(val) else: if node.right: self._insert(node.right, val) else: node.right = TreeNode(val) def search(self, val: int) -> TreeNode: return self._search(self.root, val) def _search(self, node, val): if not node or node.val == val: return node if val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, node, val): if not node: return node if val < node.val: node.left = self._delete(node.left, val) elif val > node.val: node.right = self._delete(node.right, val) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = self._delete(node.right, temp.val) return node def _min_value_node(self, node): current = node while current.left: current = current.left return current def inorder_traversal(self) -> list: result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node: self._inorder_traversal(node.left, result) result.append(node.val) self._inorder_traversal(node.right, result)"},{"question":"# Fibonacci Number Calculation with Enhanced Efficiency **Context**: You\'ve been tasked with designing a software module that can calculate large Fibonacci numbers effectively. The Fibonacci sequence is defined as follows: - F0 = 0 - F1 = 1 - Fn = Fn-1 + Fn-2 for n > 1 We need to calculate Fibonacci numbers in an optimized manner due to potential high computational cost when dealing with large values of n. **Objective**: Implement a function `optimized_fibonacci(n: int) -> int` that computes the n-th Fibonacci number. Your implementation should be efficient in both time and space complexity. **Constraints**: - The input n will be in the range [0, 10^6]. - Ensure your function runs within acceptable time limits. **Function Signature**: ```python def optimized_fibonacci(n: int) -> int: ... ``` **Input**: - `n`: An integer representing the index in the Fibonacci sequence (0 ≤ n ≤ 10^6). **Output**: - Return the n-th Fibonacci number as an integer. **Requirements**: - Handle edge cases like n = 0 and n = 1 correctly. - Ensure you use constant space O(1). - Implement the function with linear time complexity O(n). **Example**: ```python assert optimized_fibonacci(0) == 0 assert optimized_fibonacci(1) == 1 assert optimized_fibonacci(10) == 55 assert optimized_fibonacci(100) == 354224848179261915075 ``` **Hint**: Utilize an iterative approach rather than recursion or list-based dynamic programming to manage space complexity efficiently.","solution":"def optimized_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using an optimized iterative approach. if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Longest Substring without Repeating Characters Context Given an input string, the task is to find the length of the longest substring without any repeating characters. Understanding this problem involves knowledge of sliding window techniques, hashmaps, and character tracking. Problem Statement Write a function `longest_non_repeat_substring(string)` that takes a single argument: * `string` (str): The input string for which the longest non-repeating substring needs to be found. The function should return a tuple containing: * An integer representing the length of the longest substring without repeating characters. * The longest substring itself. If there are multiple substrings of the same length, return the one that appears first in the string. Input * `string`: A string consisting of ASCII characters. The length of the string will be between 0 and 10^5. Output * A tuple containing: * `max_length` (int): The length of the longest substring without repeating characters. * `longest_substring` (str): The longest substring itself. Function Signature ```python def longest_non_repeat_substring(string: str) -> tuple: ``` Example Usage ```python assert longest_non_repeat_substring(\\"abcabcbb\\") == (3, \\"abc\\") assert longest_non_repeat_substring(\\"bbbbb\\") == (1, \\"b\\") assert longest_non_repeat_substring(\\"pwwkew\\") == (3, \\"wke\\") assert longest_non_repeat_substring(\\"\\") == (0, \\"\\") assert longest_non_repeat_substring(\\"a\\") == (1, \\"a\\") assert longest_non_repeat_substring(\\"ab\\") == (2, \\"ab\\") ``` Constraints * Handle both lowercase and uppercase letters. * Optimize for both time and space complexity considerations. * Ensure edge cases like an empty string or a string with all identical characters are taken care of. Performance Requirement * Your solution should have a time complexity of O(n) where n is the length of the string. Good luck!","solution":"def longest_non_repeat_substring(string): Returns the length of the longest substring without repeating characters and the substring itself. n = len(string) if n == 0: return (0, \\"\\") char_index_map = {} max_length = 0 start = 0 longest_substring = \\"\\" for end in range(n): if string[end] in char_index_map and char_index_map[string[end]] >= start: start = char_index_map[string[end]] + 1 char_index_map[string[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 longest_substring = string[start:end+1] return (max_length, longest_substring)"},{"question":"Context You have been tasked with optimizing a system that frequently needs to count the number of set bits in binary representations of integers. The current method is slower and needs to be revamped using a more efficient algorithm. You have identified Brian Kernighan\'s Algorithm as a prime candidate for this task. Problem Statement Write a function named `count_set_bits` using Brian Kernighan\'s Algorithm in an iterative approach. This function should take an unsigned integer `n` as input and return the number of `1` bits in its binary representation (Hamming weight). Input and Output Formats * **Input**: - An unsigned integer `n` (0 <= n <= 2^32 - 1). * **Output**: - An integer representing the count of `1` bits in the binary representation of `n`. Constraints * Your function should handle edge cases efficiently. * Performance should be optimal even for the maximum input size. # Examples 1. Input: `n = 11` Output: `3` Explanation: The binary representation of `11` is `00000000000000000000000000001011`, which has three `1` bits. 2. Input: `n = 128` Output: `1` Explanation: The binary representation of `128` is `00000000000000000000000010000000`, which has one `1` bit. 3. Input: `n = 255` Output: `8` Explanation: The binary representation of `255` is `00000000000000000000000011111111`, which has eight `1` bits. Implementation Implement the function as follows: ```python def count_set_bits(n): Count the number of \'1\' bits in the binary representation of an unsigned integer n. Args: n (int): Unsigned integer Returns: int: Number of \'1\' bits in the binary representation of n count = 0 while n: n &= (n-1) count += 1 return count ``` Remember, your implementation should follow the described algorithm and meet the performance requirements.","solution":"def count_set_bits(n): Count the number of \'1\' bits in the binary representation of an unsigned integer n. Args: n (int): Unsigned integer Returns: int: Number of \'1\' bits in the binary representation of n count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Pigeonhole Sort * **Type**: Counting-based sorting algorithm * **Main Purpose**: To sort a list of elements efficiently when the range of possible values is close to the number of elements. Complexity * **Time Complexity**: * Best-case: O(n + Range) * Worst-case: O(n + Range) * **Space Complexity**: O(Range), where \'Range\' is the difference between the maximum and minimum values in the input array. Principles * **Core Operational Steps**: 1. Determine the minimum and maximum values in the input array. 2. Create an array of \\"holes\\" (buckets) to count occurrences of each value in the range from min to max. 3. Populate the \\"holes\\" array based on the occurrences of each input element. 4. Iterate through the \\"holes\\" array and reconstruct the sorted array. # Characteristics & Applications Properties * **Sorting Stability**: It is not stable since it may not preserve the relative order of equal elements. * **Traversal Order**: It uses direct indexing for counting occurrences and then constructs the sorted array. Common Use Cases * Suitable for scenarios where: * The input array elements are within a limited range. * There are close-to-uniform distributions in the input dataset. Strengths/Limitations * **Strengths**: * Linear time complexity when the range of input values (Max - Min) is relatively small. * Simple and easy to implement. * **Limitations**: * Inefficient for large ranges of input values (i.e., Max - Min is large). * Consumes more memory relative to the range of input values. # Implementation Challenges Edge Cases * Array contains only one element. * All elements in the array are the same. * Array with both positive and negative values. Performance Bottlenecks * Large gaps between the minimum and maximum elements could result in high memory usage and inefficient use of space. Error Scenarios * If the array is empty, handling this gracefully is necessary to avoid index errors. Optimization Points * Enhancements like adjusting to only valid range slices where applicable or using an alternative sorting method if the range is excessively larger than the array size. <|Analysis End|> <|Question Begin|> # Question: Pigeonhole Sort Implementation You are tasked with implementing the Pigeonhole Sort algorithm to sort a list of integers. The algorithm should be able to handle a list containing both positive and negative integers and should work efficiently as long as the range between the maximum and minimum values in the input list is not excessively large compared to the number of elements. Requirements - **Function Name**: `pigeonhole_sort` - **Input**: A list of integers, `arr`. - **Output**: A sorted list of integers in ascending order. Constraints 1. The number of elements in the input list `arr` (denoted as n) will fall between 1 and 10^5. 2. The values in `arr` can be as large as -10^9 to 10^9. Edge Cases - The input list may contain only one element. - All elements in the input list might be the same. - The list can contain both positive and negative integers. Example Input 1: ```python arr = [8, 3, 2, 7, 4] ``` Output 1: ```python [2, 3, 4, 7, 8] ``` Input 2: ```python arr = [-5, -2, -3, -1, -4] ``` Output 2: ```python [-5, -4, -3, -2, -1] ``` Input 3: ```python arr = [3] ``` Output 3: ```python [3] ``` Implement the `pigeonhole_sort` function in Python below: ```python def pigeonhole_sort(arr): if not arr: return arr Max = max(arr) Min = min(arr) size = Max - Min + 1 holes = [0] * size for i in arr: holes[i - Min] += 1 i = 0 for count in range(size): while holes[count] > 0: holes[count] -= 1 arr[i] = count + Min i += 1 return arr ``` You are expected to ensure that the function efficiently sorts the input list and handles the given constraints and edge cases effectively.","solution":"def pigeonhole_sort(arr): if not arr: return arr Max = max(arr) Min = min(arr) size = Max - Min + 1 holes = [0] * size for num in arr: holes[num - Min] += 1 i = 0 for count in range(size): while holes[count] > 0: holes[count] -= 1 arr[i] = count + Min i += 1 return arr"},{"question":"# Question: Scenario: You are given a binary tree data structure defined with `TreeNode` class where each node has two children pointers (left and right). Your task is to implement functions to calculate the minimum depth and perform a pre-order traversal to print the values of the tree. Requirements: 1. **Function `correct_min_depth(root: TreeNode) -> int`**: * Implement this function to correctly calculate the minimum depth of the binary tree. * Use both iterative and recursive approaches if needed to verify correctness. * Avoid potential logical errors present in the following: - Ensure the calculation truly finds the minimum depth, not maximum. 2. **Function `pre_order_print(root: TreeNode) -> None`**: * Implement this function to perform and print the binary tree values in pre-order (Root, Left, Right). Constraints: * Assume that the `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * The binary tree can have at most 10^4 nodes. * The values in the nodes are unique and range from -10^5 to 10^5. Input/Output: * `correct_min_depth`: One argument of `TreeNode` type, returns an integer representing the minimum depth. * `pre_order_print`: One argument of `TreeNode` type, prints the node values in pre-order. Example: ```python tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) # Expected true minimum depth: 2 print(correct_min_depth(tree)) # Your implementation must return 2 # Expected output for pre-order traversal: 10 12 25 30 15 36 pre_order_print(tree) ``` * Write and test your implementations ensuring the functionality is correct and perform as expected.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def correct_min_depth(root: TreeNode) -> int: Calculate the minimum depth of a binary tree. if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: current, depth = queue.popleft() if not current.left and not current.right: return depth if current.left: queue.append((current.left, depth + 1)) if current.right: queue.append((current.right, depth + 1)) def pre_order_print(root: TreeNode) -> None: Print the binary tree node values in pre-order traversal (Root, Left, Right) if not root: return print(root.val, end=\' \') pre_order_print(root.left) pre_order_print(root.right)"},{"question":"# AVL Tree Insertion and In-order Traverse Objective: Implement an AVL tree with insertion and a method for in-order traversal. Requirements: - **Insert Function**: Add elements to the AVL tree while maintaining its balanced property. - **In-order Traverse**: Traverse the tree in-order and return an array of elements. Function Signatures: ```python def avl_insert(tree: AVLTree, key: int) -> None: pass def in_order_traverse(tree: AVLTree) -> List[int]: pass ``` Input: - `tree`: An instance of `AVLTree`. - `key`: Integer key to be inserted. Output: - For `avl_insert`: No return value, modify the AVL tree in-place. - For `in_order_traverse`: A list of integers in in-order traversal. Constraints: - Keys inserted will be unique. - You may assume that the AVL tree implementation is provided and you need to complete the `avl_insert` and `in_order_traverse` functions based on the described API. Example: ```python tree = AVLTree() avl_insert(tree, 10) avl_insert(tree, 20) avl_insert(tree, 30) avl_insert(tree, 40) print(in_order_traverse(tree)) # Output: [10, 20, 30, 40] avl_insert(tree, 25) print(in_order_traverse(tree)) # Output: [10, 20, 25, 30, 40] ```","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, root, key): if not root: return TreeNode(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and key < root.left.key: return self.rightRotate(root) if balance < -1 and key > root.right.key: return self.leftRotate(root) if balance > 1 and key > root.left.key: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.key: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def avl_insert(tree: AVLTree, key: int) -> None: Inserts a key into the AVL tree. if tree.root is None: tree.root = TreeNode(key) else: tree.root = tree.insert(tree.root, key) def in_order_traverse(tree: AVLTree) -> list: Performs in-order traversal of the AVL tree and returns a list of elements. res = [] def _in_order(node): if node is not None: _in_order(node.left) res.append(node.key) _in_order(node.right) _in_order(tree.root) return res"},{"question":"Scenario You are developing a flexible word search engine that can handle both literal and pattern-based searches efficiently. Your task involves implementing a `WordDictionary` using a Trie structure to support the required operations. Problem Statement Implement the `WordDictionary` class that supports the following operations: 1. **add_word(word)**: Inserts `word` into the dictionary. 2. **search(word)**: Returns `true` if the `word` (literal or containing the wildcard `.`) is in the dictionary, `false` otherwise. The `.` character can represent any letter. Requirements * Your implementation should include: * A `TrieNode` class as the node of the trie. * The `WordDictionary` class using the `TrieNode`. * You need to handle searching where the `.` character can be any letter in the alphabet. * Input and output details: * `add_word(str)`: Adds a word to the trie. * `search(str)`: Returns `true` if the word or pattern exists; otherwise, `false`. Example ```python dictionary = WordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") print(dictionary.search(\\"pad\\")) # Output: False print(dictionary.search(\\"bad\\")) # Output: True print(dictionary.search(\\".ad\\")) # Output: True print(dictionary.search(\\"b..\\")) # Output: True ``` Constraints * Words contain only lowercase English letters (`a`-`z`). * Word length will be in the range [1, 100]. * There will be at most 10^4 calls made to `add_word` and `search`.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): return self._search_helper(word, 0, self.root) def _search_helper(self, word, index, node): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_helper(word, index + 1, child): return True return False else: if char not in node.children: return False return self._search_helper(word, index + 1, node.children[char])"},{"question":"# Coding Assessment: Absolute Path Finder Objective Write a function that accepts a file path string and returns the absolute path version of that string. This function should account for user-specific paths (e.g., paths starting with `~`) and any relative path components. Function Signature ```python def absolute_path(file: str) -> str: pass ``` Input - A string representing a file path (e.g., `\'~/Documents/file.txt\'` or `\'../folder/file.txt\'`). Output - A string representing the absolute path of the given file. Constraints - The input path string will be a valid path string based on typical OS conventions. - Do not verify the existence of the file, only transform the path. Example ```python assert absolute_path(\'~/Documents/file.txt\') == \'/Users/username/Documents/file.txt\' # Output will vary based on the user and OS assert absolute_path(\'../folder/file.txt\') == \'/absolute/path/to/folder/file.txt\' # Output will depend on the current working directory ``` Performance Requirements - The function should be efficient enough to handle typical file paths encountered in day-to-day programming tasks. Notes - Use the `os` module in Python to perform the required path expansions and conversions.","solution":"import os def absolute_path(file: str) -> str: Returns the absolute path version of the given file path. return os.path.abspath(os.path.expanduser(file))"},{"question":"Implement the Pigeonhole sort algorithm for an array of integers. Your function should sort an array by distributing elements into a series of \\"pigeonholes\\" based on their values, and then reassembling the sorted array from these holes. # Guidelines * **Function Signature**: `def pigeonhole_sort(arr: List[int]) -> List[int]:` * **Input**: A list of integers `arr`. * **Output**: A list of integers sorted in non-decreasing order. * You are not allowed to use any in-built sorting function. # Constraints 1. `0 <= len(arr) <= 10^5` 2. `-10^6 <= arr[i] <= 10^6` 3. The pigeonholes should be dynamically allocated based on the range of values within the input array. # Requirements 1. Ensure the implementation handles different edge cases, including empty arrays and arrays with a single element. 2. Maintain the original order of elements with equal key values (stability). 3. Optimize for both time and space complexity. # Example ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([9, 8, 7, 2, 3, 4, 2]) == [2, 2, 3, 4, 7, 8, 9] assert pigeonhole_sort([]) == [] assert pigeonhole_sort([5]) == [5] assert pigeonhole_sort([5, -1, 3, 0, -2, 4]) == [-2, -1, 0, 3, 4, 5] ``` # Performance Notes Make sure your implementation is efficient enough to handle the provided constraints, especially considering large ranges and lengths of the input list.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_value = min(arr) max_value = max(arr) range_of_elements = max_value - min_value + 1 pigeonholes = [[] for _ in range(range_of_elements)] for num in arr: pigeonholes[num - min_value].append(num) sorted_array = [] for pigeonhole in pigeonholes: sorted_array.extend(pigeonhole) return sorted_array"},{"question":"# Context You are developing a system that requires efficient handling of aggregated data. Range queries and point updates are particularly frequent in your use case. To handle these efficiently, you have decided to implement a Segment Tree. # Task You are required to implement a Segment Tree that supports efficient range queries and updates. # Requirements 1. **Class Initialization**: - Takes an array of elements (can be numeric or tuples) and a function to aggregate them. 2. **Methods**: - **build_tree**: Construct the segment tree from the given array. - **update(p, v)**: Update the element at index `p` to `v`. - **query(l, r)**: Query the range from index `l` to `r` inclusive and return the aggregated result using the provided function. # Specifications 1. **Input**: - The initializer takes an array of length `N` (1 <= N <= 100000) and a commutative function. - `update` will take an integer index `p` (0 <= p < N) and a value `v` (same type as array elements) to update the array. - `query` takes two integers `l` and `r` (0 <= l <= r < N) and returns the aggregated value in the range. 2. **Output**: - The update method modifies the segment tree but has no return. - The query method returns the aggregated output for the specified range. # Example ```python # Example with max operation segment_tree = SegmentTree([2, 4, 5, 3, 4], max) print(segment_tree.query(2, 4)) # Output: 5 segment_tree.update(3, 6) print(segment_tree.query(0, 3)) # Output: 6 # Example with sum operation segment_tree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(segment_tree.query(0, 6)) # Output: 64 segment_tree.update(2, -10) print(segment_tree.query(0, 6)) # Output: 52 # Example with tuple sum operation segment_tree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(segment_tree.query(0, 2)) # Output: (9, 13) segment_tree.update(2, (-1, 2)) print(segment_tree.query(0, 2)) # Output: (4, 10) ``` Implement the `SegmentTree` class so it meets the above requirements.","solution":"class SegmentTree: def __init__(self, array, function): Initializes the Segment Tree with the provided array and aggregation function. :param array: The input array for which the segment tree needs to be built. :param function: The function used to aggregate the values (sum, max, etc.). self.n = len(array) self.array = array self.function = function self.tree = [None] * (2 * self.n) self.build_tree() def build_tree(self): # Initialize the leaves of the segment tree for i in range(self.n): self.tree[self.n + i] = self.array[i] # Compute the values for the internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, p, v): Update the element at index `p` in the array to `v`. :param p: Index of the element to update. :param v: The new value for the element at index `p`. pos = self.n + p self.tree[pos] = v # Update the segment tree nodes up to the root while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, l, r): Query the range from index `l` to `r` inclusive and return the aggregated result. :param l: Left index of the range. :param r: Right index of the range. :return: The aggregated output for the specified range. result = None l += self.n r += self.n + 1 while l < r: if l % 2: result = self.tree[l] if result is None else self.function(result, self.tree[l]) l += 1 if r % 2: r -= 1 result = self.tree[r] if result is None else self.function(result, self.tree[r]) l //= 2 r //= 2 return result"},{"question":"# Question: Implement the FizzBuzz Algorithm **Context**: You are tasked with writing an implementation of the classic FizzBuzz problem. This problem is often used as a first-level screening for software development positions. It tests your ability to use basic control structures, modular arithmetic, and list operations. **Objective**: Implement a function `fizzbuzz` that returns a list of strings and integers from 1 to N based on the following rules: - For multiples of 3, include \\"Fizz\\". - For multiples of 5, include \\"Buzz\\". - For multiples of both 3 and 5, include \\"FizzBuzz\\". - For other numbers, include the number itself. **Function Signature**: ```python def fizzbuzz(n: int) -> List[Union[int, str]]: pass ``` **Input**: - `n` (int): An integer value N (N ≥ 1). **Output**: - A list of strings and integers according to the FizzBuzz rules specified. **Constraints**: - 1 ≤ N ≤ 10000. **Example**: ```python # Example input n = 15 # Expected output [ 1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\" ] ``` **Additional Notes**: - You may assume `n` will always be a positive integer greater than or equal to 1. - Please handle any invalid inputs gracefully. - The function should execute efficiently for large values of `n`.","solution":"from typing import List, Union def fizzbuzz(n: int) -> List[Union[int, str]]: Returns a list of integers and strings representing the FizzBuzz sequence up to n. For multiples of 3, the value is replaced by \\"Fizz\\". For multiples of 5, the value is replaced by \\"Buzz\\". For multiples of both 3 and 5, the value is replaced by \\"FizzBuzz\\". All other values remain as integers. Args: n (int): The upper limit of the sequence (1 ≤ n ≤ 10000) Returns: List[Union[int, str]]: The FizzBuzz sequence up to n. result = [] for i in range(1, n+1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(i) return result"},{"question":"Transform a Binary Tree to a Doubly Linked List You are given a binary tree with the root node. Your task is to transform this binary tree into a doubly linked list using in-order traversal. The left pointer in the tree will act as the \'previous\' pointer in the doubly linked list, and the right pointer will act as the \'next\' pointer. Function Signature ```python def bin_tree_to_list(root: TreeNode) -> TreeNode: type root: TreeNode rtype: TreeNode ``` # Input * `root` (TreeNode): The root node of the binary tree. # Output * TreeNode: The head node of the resulting doubly linked list. # Constraints * The binary tree can be empty (`root` is None). * The binary tree can contain up to (10^5) nodes. # Scenario Consider the provided TreeNode class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Given the root of the binary tree: # Example: **Input:** ```python root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) ``` **Output**: The head of the doubly linked list corresponding to the in-order traversal: 1 ⇄ 2 ⇄ 3 ⇄ 4 ⇄ 5 # Notes: * You must do this in `O(n)` time complexity where `n` is the number of nodes in the tree. * Ensure the resulting structure is a proper doubly linked list without any breakage in pointers between nodes. * Do not alter the initial TreeNode class.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: Transform the binary tree to a doubly linked list in-place using in-order traversal. The TreeNode\'s left pointer will be used as the previous pointer and the right pointer as the next pointer. def in_order_traversal(node): nonlocal last, head if not node: return # Traverse left subtree in_order_traversal(node.left) # Process the current node if last: last.right = node node.left = last else: head = node # First node becomes the head of the linked list last = node # Move last to the current node # Traverse right subtree in_order_traversal(node.right) if not root: return None # These variables will be used to keep track of the \\"head\\" of the list and the \\"last\\" accessed node. head = last = None in_order_traversal(root) return head"},{"question":"# Prime List Generator You are given the task of implementing a function `generate_prime_list(n)` that generates a list of prime numbers up to a given integer ( n ). This function is expected to make use of a combination of the provided `prime_check` algorithm and an iterative approach to generate the list. Function Signature ```python def generate_prime_list(n: int) -> List[int]: pass ``` Input * `n`: An integer (1 <= n <= 10^6). Output * A list of integers containing all prime numbers less than or equal to ( n ), in ascending order. Constraints * The function should run efficiently, ideally within O(n * sqrt(n)) time complexity. * You may assume that the input number ( n ) is always a positive integer. Example ```python >>> generate_prime_list(10) [2, 3, 5, 7] >>> generate_prime_list(20) [2, 3, 5, 7, 11, 13, 17, 19] ``` Ensure your code handles edge cases such as: * The smallest possible value of ( n ) (e.g., 1 or 2). * Larger values within the specified constraints. Provide the necessary imports if needed, and do not use any prime-generating libraries directly for your solution.","solution":"from typing import List def generate_prime_list(n: int) -> List[int]: Generates a list of prime numbers up to a given integer n. Args: n (int): The upper limit to generate prime numbers up to. Returns: List[int]: A list of prime numbers less than or equal to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False return [num for num in range(2, n + 1) if sieve[num]]"},{"question":"You are given an undirected connected graph with unique node labels. Each node has a list of neighbors which are other nodes within the same graph. Your task is to implement a function that creates a deep copy of this graph. The new graph should have exactly the same connections and structure as the original one. # Function Signature: ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Input: - `node`: The reference to the root node of the graph which is an instance of `UndirectedGraphNode`. # Output: - Returns the root node of the cloned graph which is a deep copy of the original graph. # Constraints: - The number of nodes in the graph is in the range `[0, 100]`. - The node values are integers and unique for each node. - There may be cycles or self-loops within the graph. # Performance Requirements: - The solution should aim for O(V + E) time complexity and O(V) space complexity. # Scenario: Consider a system where you need to duplicate complex network configurations. Each node in the configuration represents a device, and its connections (edges) represent direct communication links to other devices. Duplicating such a structure can help in testing and deploying network configurations without impacting the original setup. # Example: Given the graph serialization `{0,1,2#1,2#2,2}` which can be visualized as: ``` 1 / / 0 --- 2 / _/ ``` Your function should return the cloned graph with similar visualization and structure. # Additional Information: - Avoid using any global variables. - Ensure the cloned graph is completely independent of the original graph. # Requirements: Implement the `clone_graph` function using any of the following methods as mentioned in the provided code snippets: BFS, Iterative DFS, or Recursive DFS.","solution":"class UndirectedGraphNode: def __init__(self, x: int): self.label = x self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None node_copy = UndirectedGraphNode(node.label) mapping = {node: node_copy} def dfs(original): for neighbor in original.neighbors: if neighbor not in mapping: neighbor_copy = UndirectedGraphNode(neighbor.label) mapping[neighbor] = neighbor_copy dfs(neighbor) mapping[original].neighbors.append(mapping[neighbor]) dfs(node) return node_copy"},{"question":"# Binary Tree Balance Check Context In certain computational problems, it becomes crucial to ensure that the data structure used is balanced to guarantee optimal performance. One such structure is a binary tree. Given its characteristics, the balance of a binary tree directly impacts the efficiency of operations carried out on it, such as search, insertion, and deletion. In this task, you are tasked with writing a function to determine if a binary tree is balanced. Task Write a function `is_balanced(root)` that takes the root of a binary tree as input and returns `True` if the tree is balanced and `False` otherwise. A binary tree is balanced if the depths of the two subtrees of every node never differ by more than 1. # Function Signature ```python def is_balanced(root) -> bool: pass ``` # Input - `root`: The root node of the binary tree. Each node in the binary tree has the following properties: * `val`: An integer value, * `left`: A left child node or `None`, * `right`: A right child node or `None`. # Output - A boolean value: `True` if the tree is balanced, `False` otherwise. # Constraints - The total number of nodes in the tree will be between 0 and 10^4. - The height of the tree won\'t exceed 10^4. # Example Consider the following binary trees: 1. Balanced Tree ``` 3 / 9 20 / 15 7 ``` - Input: `root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))` - Output: `True` 2. Unbalanced Tree ``` 1 / 2 2 / 3 3 / 4 4 ``` - Input: `root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(4)), TreeNode(3)), TreeNode(2))` - Output: `False` You are expected to implement a solution that operates optimally with regards to time and space complexities.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determines if a binary tree is balanced. Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is balanced, False otherwise. def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, balance = check_balance(root) return balance"},{"question":"**Question**: You are given a list of integers which may contain duplicate elements. Your task is to implement a function `gnome_sort` to sort these integers in non-decreasing order using the Gnome Sort algorithm. The function should return the sorted list. # Function Signature: ```python def gnome_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr` (List[int]): A list of integers to be sorted. The length of the list is between 0 and 1000. # Output: - A list of integers sorted in non-decreasing order. # Constraints: - The sorting must be done in-place (modify the input list directly). - No additional lists or arrays can be used. - The function should handle edge cases gracefully, including empty lists and lists with a single element. # Performance Requirements: - Ensure that the algorithm handles all provided constraints. - Given the constraints, aim to be concise but clear in implementation to minimize potential errors. # Example: ```python assert gnome_sort([34, 2, 10, -9]) == [-9, 2, 10, 34] assert gnome_sort([0, 0, 0, 0]) == [0, 0, 0, 0] assert gnome_sort([5]) == [5] assert gnome_sort([]) == [] ``` Implement the `gnome_sort` function as specified above.","solution":"def gnome_sort(arr: list[int]) -> list[int]: Sorts a given list of integers in non-decreasing order using the Gnome Sort algorithm. Parameters: arr (list of int): The list to be sorted. Returns: list of int: The sorted list. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Coding Challenge: Calculate Shortest Distance from All Buildings Background You are tasked with calculating the minimum travel distance on a grid. The grid consists of buildings (designated by \'1\'), obstacles (designated by \'2\'), and empty land (designated by \'0\'). You need to find the empty land cell that has the shortest total travel distance to all buildings. Task Implement a function `shortest_distance(grid: List[List[int]]) -> int`, which takes in a 2D grid and returns the shortest total distance from all buildings to an empty land. If such a cell does not exist, return `-1`. Function Signature ```python def shortest_distance(grid: List[List[int]]) -> int: ``` Input - `grid` (List[List[int]]): A 2D list of integers representing the grid. - 1 represents a building, - 2 represents an obstacle, - 0 represents empty land. Output - `int`: The shortest total distance from all buildings to an empty land. If there is no such cell, return `-1`. Constraints - The dimensions of the grid are between 1x1 and 50x50. - The number of buildings is between 1 and 50. Example ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] print(shortest_distance(grid)) # Output: 7 ``` Notes - You\'ll need to perform multiple BFS traversals, starting from each building. - Be sure to handle grids with no empty spaces or no buildings.","solution":"from typing import List from collections import deque def shortest_distance(grid: List[List[int]]) -> int: # Helper function to perform BFS and compute distance from each building def bfs(start): visited = [[-1] * cols for _ in range(rows)] q = deque([(start[0], start[1], 0)]) visited[start[0]][start[1]] = 0 while q: x, y, dist = q.popleft() for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and visited[nx][ny] == -1: visited[nx][ny] = dist + 1 q.append((nx, ny, dist + 1)) total_distances[nx][ny] += dist + 1 reach_counts[nx][ny] += 1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] total_distances = [[0] * cols for _ in range(rows)] reach_counts = [[0] * cols for _ in range(rows)] building_count = sum(val for line in grid for val in line if val == 1) for r in range(rows): for c in range(cols): if grid[r][c] == 1: bfs((r, c)) shortest = float(\'inf\') for r in range(rows): for c in range(cols): if grid[r][c] == 0 and reach_counts[r][c] == building_count: shortest = min(shortest, total_distances[r][c]) return -1 if shortest == float(\'inf\') else shortest"},{"question":"# In-order Binary Tree Traversal You are given a binary tree represented by its root node. Your task is to implement both iterative and recursive solutions for traversing the tree in-order. # Function Signature ```python def inorder(root: Node) -> List[int]: pass def inorder_rec(root: Node) -> List[int]: pass ``` # Input * The root node of the binary tree (`root`). The `Node` class is already defined as follows: ```python class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right ``` # Output * A list of integers representing the in-order traversal of the nodes\' values. # Constraints * The number of nodes in the tree will be between 0 and 10^4. * The node values will be between -10^4 and 10^4. # Performance Requirements * Your solution should run in O(n) time complexity. * The space complexity should be O(h) for iterative solution (with stack) and recursive solution due to call stack. # Examples ```python # Example 1: # Input tree: # 1 # # 2 # / # 3 root = Node(1, None, Node(2, Node(3))) assert inorder(root) == [1, 3, 2] assert inorder_rec(root) == [1, 3, 2] # Example 2: # Input tree: # 10 # / # 5 15 # / / # 3 7 12 17 root = Node(10, Node(5, Node(3), Node(7)), Node(15, Node(12), Node(17))) assert inorder(root) == [3, 5, 7, 10, 12, 15, 17] assert inorder_rec(root) == [3, 5, 7, 10, 12, 15, 17] ``` # Additional Notes 1. Ensure that your function handles edge cases, such as an empty tree or a single-node tree. 2. You must implement both the iterative and recursive methods for this problem.","solution":"class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def inorder(root: Node) -> list[int]: Iterative in-order traversal of a binary tree using a stack result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_rec(root: Node) -> list[int]: Recursive in-order traversal of a binary tree def traverse(node: Node, result: list[int]): if node is not None: traverse(node.left, result) result.append(node.val) traverse(node.right, result) result = [] traverse(root, result) return result"},{"question":"# Maximum Flow Calculation in a Network Graph You are tasked with implementing a function to calculate the maximum flow in a network graph from a given source to a sink using one of the provided algorithms. Function Signature ```python def calculate_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: pass ``` Input * `capacity` (List[List[int]]): A 2D list representing the capacity matrix of a directed graph. `capacity[i][j]` denotes the maximum capacity of the edge from vertex `i` to vertex `j`. If there is no edge between the vertices `i` and `j`, the value will be 0. * `source` (int): The source vertex from where the flow starts. * `sink` (int): The sink vertex where the flow should be delivered. Output * An integer representing the maximum flow from the source to the sink in the given graph. Constraints * The graph will have at most 200 vertices. * Capacities will be non-negative integers not exceeding 1,000,000. Requirements * Your implementation should handle graphs that are disconnected or contain multiple nodes without causing infinite loops or errors. * Optimize the function to handle large graphs efficiently. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 assert calculate_max_flow(capacity, source, sink) == 23 ``` In the above example, the maximum flow from vertex 0 to vertex 5 is 23. **Note**: Carefully consider edge cases and strive to implement an efficient solution that computes the maximum flow correctly and optimally.","solution":"from typing import List from collections import deque def bfs(residual_capacity, source, sink, parent): visited = [False] * len(residual_capacity) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, cap in enumerate(residual_capacity[u]): if visited[v] == False and cap > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def calculate_max_flow(capacity: List[List[int]], source: int, sink: int) -> int: residual_capacity = [row[:] for row in capacity] parent = [-1] * len(residual_capacity) max_flow = 0 while bfs(residual_capacity, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Strobogrammatic Number Verification **Context**: In certain data validation and recognition scenarios, it becomes necessary to verify whether a number is strobogrammatic, meaning it appears the same when rotated by 180 degrees. **Task**: Implement a Python function `is_strobogrammatic(num: str) -> bool` that takes a string representing a number and determines if it is a strobogrammatic number. **Input**: * `num`: A string representing the number to check. The string can contain digits from \'0\' to \'9\'. The length of `num` will be in the range [1, 10^4]. **Output**: * Returns `True` if the number is strobogrammatic, otherwise returns `False`. **Constraints**: * The function must run with a time complexity of O(n) and a space complexity of O(1). **Examples**: 1. `is_strobogrammatic(\\"69\\")` should return `True`. 2. `is_strobogrammatic(\\"88\\")` should return `True`. 3. `is_strobogrammatic(\\"962\\")` should return `False`. **Scenario**: Consider you are developing a validation module in an application where users can draw symbols using specific digits. To avoid incorrect patterns, you need to verify the drawn symbols are valid strobogrammatic numbers. ```python def is_strobogrammatic(num: str) -> bool: :type num: str :rtype: bool strobogrammatic_map = {\'0\': \'0\', \'1\': \'1\', \'8\': \'8\', \'6\': \'9\', \'9\': \'6\'} left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_map or strobogrammatic_map[num[left]] != num[right]: return False left += 1 right -= 1 return True # Sample Test Cases print(is_strobogrammatic(\\"69\\")) # True print(is_strobogrammatic(\\"88\\")) # True print(is_strobogrammatic(\\"962\\")) # False print(is_strobogrammatic(\\"1\\")) # True print(is_strobogrammatic(\\"101\\")) # True ```","solution":"def is_strobogrammatic(num: str) -> bool: Returns True if the number is strobogrammatic, otherwise False. A strobogrammatic number appears the same when rotated 180 degrees. :param num: str :return: bool strobogrammatic_map = {\'0\': \'0\', \'1\': \'1\', \'8\': \'8\', \'6\': \'9\', \'9\': \'6\'} left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_map or strobogrammatic_map[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"# Problem: Text Editor Spell Correction You are tasked with implementing a spell checker for a simple text editor. The spell checker needs to suggest corrections for misspelled words by computing the edit distance between the misspelled word and potential correct words from a dictionary. Function Signature: ```python def spell_checker(word: str, dictionary: List[str]) -> str: ``` Input: - `word` (str): The misspelled word that needs correction. - `dictionary` (List[str]): A list of strings where each string is a potential correct word. Output: - (str): The suggested correct word from the dictionary which has the minimum edit distance to the input word. If there’s a tie (multiple words with the same edit distance), return the one that appears first in the dictionary. Constraints: - Both the `word` and each word in the `dictionary` will consist only of lowercase English letters. - The dictionary will contain at least one word, and its size will not exceed 1000 words. - Each word length will be at most 100 characters. Example: ```python print(spell_checker(\\"speling\\", [\\"spelling\\", \\"spewing\\", \\"spieling\\"])) # Output: \\"spelling\\" print(spell_checker(\\"pythin\\", [\\"python\\", \\"typhon\\", \\"jython\\"])) # Output: \\"python\\" ``` Performance Requirements: - The solution should be efficient enough for solving inputs with maximum constraints.","solution":"from typing import List def edit_distance(word1: str, word2: str) -> int: Compute the edit distance between two words using dynamic programming. m, n = len(word1), len(word2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[m][n] def spell_checker(word: str, dictionary: List[str]) -> str: Suggests the correct word from the dictionary with the minimum edit distance min_distance = float(\'inf\') correct_word = \\"\\" for dict_word in dictionary: distance = edit_distance(word, dict_word) if distance < min_distance: min_distance = distance correct_word = dict_word elif distance == min_distance: # If there\'s a tie, return the word that appears first in the dictionary correct_word = correct_word if dictionary.index(correct_word) < dictionary.index(dict_word) else dict_word return correct_word"},{"question":"**Island Counter with Iterative DFS** You are tasked with implementing an iterative version of the island-counting algorithm using Depth-First Search (DFS). This algorithm processes a 2D grid map where \'1\' represents land and \'0\' represents water. The goal is to determine the number of distinct islands on the map. Islands are defined as groups of horizontally or vertically connected land cells. **Function Signature:** ```python def count_islands(grid: List[List[int]]) -> int: ``` **Parameters:** * `grid`: A 2D list of integers where each integer is either 0 (water) or 1 (land). **Returns:** * An integer representing the number of distinct islands in the grid. **Constraints:** * The grid will have at least one cell and at most 10^4 cells in total. * The grid is rectangular (all rows of the grid have the same length). **Examples:** ```python # Example 1 grid1 = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] assert count_islands(grid1) == 1 # Example 2 grid2 = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] assert count_islands(grid2) == 3 ``` **Task:** Develop the function `count_islands` which utilizes an iterative DFS approach to count and return the number of distinct islands in the given grid. Avoid stack overflow issues by using a stack to manage the DFS traversal iteratively. **Notes:** * Ensure that modifying the grid during the process is handled correctly to avoid miscounts. * Consider edge cases, such as grids with no land or entirely land-based grids. * Aim for a time complexity of O(M * N) and space complexity of O(M * N).","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: def dfs_iterative(row: int, col: int): stack = [(row, col)] while stack: r, c = stack.pop() if 0 <= r < rows and 0 <= c < cols and grid[r][c] == 1: grid[r][c] = 0 # Mark as visited stack.extend([(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)]) if not grid: return 0 rows, cols = len(grid), len(grid[0]) num_islands = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Found an island num_islands += 1 dfs_iterative(r, c) return num_islands"},{"question":"You are given an array `arr` of integers and a function `fn` representing an associative operation (like min, max, sum, etc.). Implement a class `SegmentTree` which supports the following functionalities: 1. **Initialization**: Construct the segment tree with the given array and function. 2. **Range Query**: Query a range of indices [L, R] in the array and return the result of the function applied over this range. # Input - Initialization: `SegmentTree(arr, fn)` where `arr` is a list of integers, and `fn` is a function taking two arguments and returning a value of the same type. - Query: `query(L, R)` which takes two integers `L` and `R` representing the range [L, R] inclusive. # Output - The result of applying the function `fn` over the range [L, R] of the array. # Constraints - `1 <= len(arr) <= 10^5` - `0 <= L, R < len(arr)` - `fn` is associative (i.e., `(a op b) op c = a op (b op c)` for any `a, b, c`) # Example ```python # Example 1 # Segment tree with max function arr = [2, 4, 5, 3, 4] fn = max mytree = SegmentTree(arr, fn) assert mytree.query(2, 4) == 5 assert mytree.query(0, 3) == 5 # Example 2 # Segment tree with sum function arr = [4, 5, 2, 3, 4, 43, 3] fn = sum mytree = SegmentTree(arr, fn) assert mytree.query(1, 5) == 57 # sum of elements from index 1 to 5 ``` # Implementation Tips 1. Ensure the tree is constructed once during initialization. 2. Use efficient recursive methods for querying the range. 3. Handle edge cases such as empty ranges or out-of-bound indices gracefully. # Additional Notes - Consider memoization or iterative methods if recursion depth might be a limitation. - Ensure time and space complexities are well-optimized for large inputs.","solution":"class SegmentTree: def __init__(self, arr, fn): Initialize the Segment Tree with the given array and function. self.n = len(arr) self.fn = fn # Initialize the segment tree array with None self.tree = [None] * (2 * self.n) # Build the tree self._build(arr) def _build(self, arr): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.fn(self.tree[i * 2], self.tree[i * 2 + 1]) def query(self, L, R): Query the range [L, R] and return the result of the function. # Adjust indices to the segment tree representation L += self.n R += self.n result = None while L <= R: if L % 2 == 1: # If L is a right child if result is None: result = self.tree[L] else: result = self.fn(result, self.tree[L]) L += 1 if R % 2 == 0: # If R is a left child if result is None: result = self.tree[R] else: result = self.fn(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result"},{"question":"# Priority Queue using Binary Heap A priority queue is a special type of queue in which each element is associated with a priority. Elements are served based on their priority, and not just on a first-come-first-serve basis. You are tasked with implementing a priority queue using a binary heap. The binary heap should maintain the property that the parent node is always smaller (in case of min-heap) or larger (in case of max-heap) than its child nodes. # Objectives - Implement the necessary methods to manage a priority queue using a binary heap. - Ensure that both insertion and extraction operations are optimized. # Function Signatures 1. `__init__(self) -> None`: Initializes an empty priority queue. 2. `push(self, item: int) -> None`: Inserts an item into the priority queue. 3. `pop(self) -> int`: Removes and returns the item with the highest priority (smallest value for min-heap). 4. `peek(self) -> int`: Returns the item with the highest priority without removing it. 5. `size(self) -> int`: Returns the current size of the priority queue. # Example ```python pq = PriorityQueue() pq.push(3) pq.push(1) pq.push(4) pq.push(6) pq.push(5) pq.push(2) print(pq.size()) # 6 print(pq.peek()) # 1 print(pq.pop()) # 1 print(pq.pop()) # 2 ``` # Constraints - Each `push` and `pop` operation should have a time complexity of O(log n). - The priority queue should handle at least up to `10^5` elements efficiently. # Notes - You must handle edge cases like popping from an empty priority queue appropriately. - Assume all elements pushed into the queue are unique for simplicity.","solution":"import heapq class PriorityQueue: def __init__(self): Initializes an empty priority queue. self.heap = [] def push(self, item: int) -> None: Inserts an item into the priority queue. heapq.heappush(self.heap, item) def pop(self) -> int: Removes and returns the item with the highest priority (smallest value for min-heap). if len(self.heap) == 0: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.heap) def peek(self) -> int: Returns the item with the highest priority without removing it. if len(self.heap) == 0: raise IndexError(\\"peek from an empty priority queue\\") return self.heap[0] def size(self) -> int: Returns the current size of the priority queue. return len(self.heap)"},{"question":"# Minimum Perfect Squares Sum You are the lead developer tasked with optimizing resource allocation in a software project. One of the tasks requires breaking down a given task load into the minimal number of perfect square sub-tasks. You decide to implement an efficient algorithm to compute the smallest number of perfect square numbers that sum up to a given integer, based on established mathematical theorems. Implement the function `min_perfect_squares(number)` that achieves this. Function Signature ```python def min_perfect_squares(number: int) -> int: ``` Input * `number` (int): A positive integer indicating the total task load. Output * Returns the minimal number of perfect square numbers which sum to `number`. Constraints * `1 ≤ number ≤ 10000` Example ```python print(min_perfect_squares(9)) # Output: 1 print(min_perfect_squares(10)) # Output: 2 print(min_perfect_squares(12)) # Output: 3 print(min_perfect_squares(31)) # Output: 4 ``` Explanation 1. For number 9, it can be represented as 3^2. 2. For number 10, it can be represented as 3^2 + 1^2. 3. For number 12, it can be represented as 2^2 + 2^2 + 2^2. 4. For number 31, it can be represented as 5^2 + 2^2 + 1^2 + 1^2. Your task is to write the function `min_perfect_squares` considering how the algorithm checks and reduces the number through perfect squares, ensuring to handle edge cases and optimize for performance.","solution":"import math def min_perfect_squares(number: int) -> int: Returns the minimal number of perfect square numbers which sum to the given number. if number <= 0: return 0 # The DP array holds the minimum number of perfect squares needed for each number up to `number`. dp = [float(\'inf\')] * (number + 1) dp[0] = 0 # Precompute perfect squares less than or equal to number perfect_squares = [] for i in range(1, int(math.sqrt(number)) + 1): perfect_squares.append(i * i) # Compute the minimum count of perfect squares for every number from 1 to `number` for i in range(1, number + 1): for square in perfect_squares: if i < square: break dp[i] = min(dp[i], dp[i - square] + 1) return dp[number]"},{"question":"Enhanced Bogo Sort with Simulation Counter Given the inefficiency of Bogo Sort, your task is to implement an enhanced version of Bogo Sort that includes a simulation counter to keep track of the number of shuffles performed. Additionally, your implementation should return the sorted list along with a count of how many shuffles were needed to achieve the sorted state. # Function Signature ```python def bogo_sort_enhanced(arr: list[int]) -> tuple[list[int], int]: pass ``` # Input * An unsorted list of integers `arr` with length `n` (1 ≤ n ≤ 10). # Output * A tuple containing: - A sorted list of integers. - An integer denoting the number of shuffles performed to sort the list. # Constraints * The length of the array will not exceed 10 to ensure reasonable performance. * If the array is empty or contains only one element, consider it already sorted. * `arr` may contain duplicate elements. # Examples Example 1 **Input**: `arr = [3, 2, 1]` **Output**: `([1, 2, 3], 4)` (Note: The number of shuffles can vary since it is based on randomness) Example 2 **Input**: `arr = [5, 4, 3, 2, 1]` **Output**: `([1, 2, 3, 4, 5], 120)` (Note: The number of shuffles can vary since it is based on randomness) Example 3 **Input**: `arr = [1]` **Output**: `([1], 0)` # Instructions 1. Implement the function `bogo_sort_enhanced` that meets the specifications above. 2. Use the provided `random.shuffle` function to shuffle the array. 3. Implement a helper function `is_sorted(arr)` to check if the array is sorted. 4. Include a counter to track the number of shuffles performed. 5. Ensure that all elements in the array remain intact and only the order is shuffled. 6. Return the sorted list along with the shuffle count as a tuple. # Notes Make sure your function is well-tested with various edge cases to ensure it handles all possible scenarios appropriately.","solution":"import random def is_sorted(arr): Helper function to check if the array is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort_enhanced(arr: list[int]) -> tuple[list[int], int]: Enhanced Bogo Sort that returns the sorted list and the number of shuffles performed. shuffle_count = 0 while not is_sorted(arr): random.shuffle(arr) shuffle_count += 1 return arr, shuffle_count"},{"question":"# Question: Implementing a Weighted Randomized Set Context You\'ve been tasked with designing a variant of the `RandomizedSet` data structure that not only supports all the previous operations but also allows you to associate weight with each element. The weight reflects the likelihood of each element being chosen by the `get_weighted_random` method. Requirements Implement a class `WeightedRandomizedSet` that supports the following operations: 1. `insert(val: int, weight: float) -> bool`: Inserts an item with its associated weight to the set if it is not already present. If the element is present, do not insert and return `False`. Otherwise, insert the element and return `True`. 2. `remove(val: int) -> bool`: Removes an item from the set if it is present. Returns `True` if the element is successfully removed, `False` otherwise. 3. `get_random() -> int`: Returns a random element from the current set of elements with uniform probability. 4. `get_weighted_random() -> int`: Returns a random element from the current set of elements with a probability proportional to its weight. Function Signatures ```python class WeightedRandomizedSet: def __init__(self): # Initialize your data structure here def insert(self, val: int, weight: float) -> bool: # Implement this method def remove(self, val: int) -> bool: # Implement this method def get_random(self) -> int: # Implement this method def get_weighted_random(self) -> int: # Implement this method # Example Usage: # wset = WeightedRandomizedSet() # wset.insert(1, 2.0) # wset.insert(2, 3.0) # wset.insert(3, 5.0) # wset.get_weighted_random() # Should return 3 more frequently than 1 or 2 ``` Constraints * Each element is unique within the set. * Weight values are positive floating point numbers. * Consider how to handle the weighted random selection efficiently.","solution":"import random class WeightedRandomizedSet: def __init__(self): self.val_to_weight = {} self.values = [] self.total_weight = 0 def insert(self, val: int, weight: float) -> bool: if val in self.val_to_weight: return False self.val_to_weight[val] = weight self.values.append(val) self.total_weight += weight return True def remove(self, val: int) -> bool: if val not in self.val_to_weight: return False weight = self.val_to_weight.pop(val) self.values.remove(val) self.total_weight -= weight return True def get_random(self) -> int: return random.choice(self.values) def get_weighted_random(self) -> int: threshold = random.uniform(0, self.total_weight) cumulative_weight = 0 for val in self.values: cumulative_weight += self.val_to_weight[val] if cumulative_weight >= threshold: return val"},{"question":"Context In digital communications and error detection systems, the Hamming weight (number of \'1\' bits in a binary string) is a fundamental concept. As such, it is crucial to develop efficient methods for calculating this weight. Task Write a function that takes an unsigned integer and returns the number of \'1\' bits (Hamming weight) in its binary representation. Implement this function using an iterative approach to ensure efficiency. Function Signature ```python def hamming_weight(n: int) -> int: pass ``` Expected Input and Output Formats * **Input**: * `n` (int): a non-negative integer. * **Output**: * `int`: the number of \'1\' bits in the binary representation of `n`. Constraints * The input integer ( n ) will be in the range of ( 0 leq n leq 2^{31} - 1 ). Performance Requirements * The solution should have a time complexity of O(k), where k is the number of \'1\' bits in the binary representation of `n`. Examples 1. **Input**: `n = 11` **Output**: `3` **Explanation**: `11` in binary is `00000000000000000000000000001011`, which has three \'1\' bits. 2. **Input**: `n = 128` **Output**: `1` **Explanation**: `128` in binary is `00000000000000000000000010000000`, which has one \'1\' bit. 3. **Input**: `n = 0` **Output**: `0` **Explanation**: `0` in binary is `00000000000000000000000000000000`, which has zero \'1\' bits. Implementation Guidance 1. Implement the function `hamming_weight` using Brian Kernighan\'s Algorithm. 2. Ensure the function handles the edge case where `n` is zero correctly. 3. You may write additional helper functions if necessary, but the primary solution should be efficient and follow the described approach.","solution":"def hamming_weight(n: int) -> int: Returns the number of \'1\' bits in the binary representation of `n`. count = 0 while n: n &= (n - 1) # This operation removes the rightmost \'1\' bit in `n` count += 1 return count"},{"question":"# Scenario Suppose you are tasked with creating a function for a combinatorics library that efficiently calculates the number of ways to choose `r` items from a set of `n` items. # Task Implement a function `combination_iter(n: int, r: int) -> int` that calculates the value of `nCr` using an iterative dynamic programming approach. # Requirements & Constraints - **Input**: Two integers, `n` and `r`, where ( 0 leq r leq n ). - **Output**: An integer which is the value of ( binom{n}{r} ). - **Constraints**: The function should handle values up to ( n = 1000 ) efficiently. - **Performance**: The solution should have a time complexity of O(n * r) and a space complexity of O(r). # Function Signature ```python def combination_iter(n: int, r: int) -> int: pass ``` # Example ```python assert combination_iter(5, 2) == 10 assert combination_iter(6, 3) == 20 assert combination_iter(40, 20) == 137846528820 ``` # Implementation Details To achieve the desired performance: 1. **Dynamic Programming Table**: Use a 1D array to store intermediate results to save space. 2. **Iterate from Bottom-Up**: Fill the table iteratively from smaller subproblems to build the solution to the larger problem.","solution":"def combination_iter(n: int, r: int) -> int: Calculate the number of combinations (n choose r) iteratively using dynamic programming. if r > n: return 0 if r == 0 or r == n: return 1 # Use a list to store intermediate results, initialized to 1 C = [0] * (r+1) C[0] = 1 # C(n, 0) is 1 # Calculate value of Binomial Coefficient in bottom up manner for i in range(1, n+1): # Compute next row of pascal triangle using the previous row for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j-1] return C[r]"},{"question":"Design a program to find the next higher number which has the exact same set of digits as the original number. # Description You are given a number `num` as input. Your task is to write a function to find the next higher number that can be formed using the exact same set of digits as `num`. If no such number exists, return `-1`. # Function Signature ```python def next_bigger(num: int) -> int: pass ``` # Input - An integer `num` where `1 <= num <= 10^9`. # Output - An integer representing the next higher number using the same digits of `num`. - Return `-1` if no higher permutation exists. # Constraints - The input number `num` will be a positive integer. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` # Performance Requirements - The function should run in O(n) time complexity, where n is the number of digits in `num`. - The function should utilize O(n) additional space for storing the digits. # Instructions 1. Implement the function `next_bigger` following the described algorithm and analysis. 2. Consider all edge cases, such as numbers with repeated digits and single-digit numbers. 3. Ensure the function returns `-1` if no higher permutation is possible.","solution":"def next_bigger(n: int) -> int: digits = list(str(n)) length = len(digits) # Step 1: Find the first digit from the end which is smaller than the digit next to it. i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 if i == -1: # If no such digit is found, return -1. return -1 # Step 2: Find the smallest digit on the right side of the found digit which is larger than it. j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digits. digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after the position of the first found digit. digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\'\'.join(digits))"},{"question":"You are tasked with implementing a function to sort an array consisting of integers representing colors: red (0), white (1), and blue (2). This sorting algorithm requires that the colors be sorted in the order of red, white, and blue. The goal is to sort the array in place and in linear time using constant space. You are not allowed to use the built-in sort function provided by any library. # Function Signature ```python def sort_colors(nums: List[int]) -> None ``` # Input * **nums**: A list of integers where each integer is either 0, 1, or 2. * `1 <= len(nums) <= 300` # Output * The function should modify the list in-place to sort the colors. # Constraints * You must solve this problem in O(n) time using O(1) extra space. # Example ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output should be [0, 0, 1, 1, 2, 2] ``` # Note - The input list will only contain the integers 0, 1, and 2. - The order of colors should be: red (0), white (1), blue (2). # Instructions * Implement the `sort_colors` function as per the above requirements. * Ensure that the function does not return any value but sorts the list in place. # Testing To ensure your implementation works correctly, test your function with various edge cases such as: 1. An array that is already sorted. 2. An array that contains only one type of color. 3. An array in reverse order.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sort the input list `nums` in-place so that all 0s come first, followed by all 1s, and then all 2s. The function should run in O(n) time using O(1) extra space. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# B-Tree Based Company Directory Management A large company maintains an employee directory where each entry includes employee ID and other details. Your task is to extend the implementation of the B-Tree to support efficient addition, deletion, and lookup operations for this directory. The degree of the directory\'s B-Tree is set to 3, but your implementation should work for any degree. # Requirements: 1. Implement the `BTree` class with the following methods: - `insert_key(self, key: int)`: Inserts a new employee record using the employee ID as the key. - `remove_key(self, key: int)`: Removes an existing employee record by its ID. - `find(self, key: int) -> bool`: Searches for an employee record by its ID. - `traverse_tree(self)`: Traverses the directory and prints all employee IDs in sorted order. 2. Consider the following additional constraints and requirements: - Your B-Tree should maintain balance during insertions and deletions. - The employee ID is guaranteed to be a unique integer. - The function names and signatures should follow those provided in the base code. # Input/Output Format: - **Insert Operation:** - *Input*: A non-negative integer representing the employee ID. - *Output*: None - **Delete Operation:** - *Input*: A non-negative integer representing the employee ID. - *Output*: `True` if the employee ID was found and removed, else `False`. - **Search Operation:** - *Input*: A non-negative integer representing the employee ID. - *Output*: `True` if the employee ID exists in the directory, else `False`. - **Traverse Operation:** - *Output*: List of all employee IDs in ascending order. # Performance Requirements: - Ensure that each operation (insert, delete, search) operates within O(log n) time complexity where `n` is the number of employees in the directory. # Sample Cases: ```python # Example 1 btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.traverse_tree() # Output should be a sorted list of employee IDs: [5, 10, 20] # Example 2 btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.traverse_tree() # Output should be a sorted list of employee IDs: [5, 6, 10, 12, 20, 30] # Example 3 btree.remove_key(6) btree.traverse_tree() # Output should be a sorted list of employee IDs: [5, 10, 12, 20, 30] # Example 4 print(btree.find(10)) # Output should be True print(btree.find(40)) # Output should be False ``` # Edge Cases: - Ensure proper handling of insertions when the B-Tree nodes are full. - Properly manage deletions where the node has the minimum number of keys. - Verify that the B-Tree maintains its properties after multiple operations.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys self.children = [] # List of children nodes class BTree: def __init__(self, t_val=3): self.root = BTreeNode(t_val, True) self.t = t_val def insert_key(self, key: int): root = self.root if len(root.keys) == (2 * self.t) - 1: new_root = BTreeNode(self.t, False) new_root.children.append(self.root) self._split_child(new_root, 0) self._insert_non_full(new_root, key) self.root = new_root else: self._insert_non_full(root, key) def _split_child(self, parent: BTreeNode, i: int): t = self.t child = parent.children[i] new_child = BTreeNode(t, child.leaf) parent.children.insert(i + 1, new_child) parent.keys.insert(i, child.keys[t - 1]) new_child.keys = child.keys[t:(2*t - 1)] child.keys = child.keys[0:(t - 1)] if not child.leaf: new_child.children = child.children[t:(2 * t)] child.children = child.children[0:t] def _insert_non_full(self, node: BTreeNode, key: int): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and key < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and key < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def remove_key(self, key: int) -> bool: if not self.root: return False result = self._delete(self.root, key) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = None return result def _delete(self, node: BTreeNode, key: int): t = self.t if key in node.keys: if node.leaf: node.keys.remove(key) return True else: idx = node.keys.index(key) if len(node.children[idx].keys) >= t: predecessor = self._get_predecessor(node, idx) node.keys[idx] = predecessor return self._delete(node.children[idx], predecessor) elif len(node.children[idx + 1].keys) >= t: successor = self._get_successor(node, idx) node.keys[idx] = successor return self._delete(node.children[idx + 1], successor) else: self._merge(node, idx) return self._delete(node.children[idx], key) else: if node.leaf: return False child_idx = 0 while child_idx < len(node.keys) and key > node.keys[child_idx]: child_idx += 1 if len(node.children[child_idx].keys) < t: if child_idx != 0 and len(node.children[child_idx - 1].keys) >= t: self._borrow_from_prev(node, child_idx) elif child_idx != len(node.children) - 1 and len(node.children[child_idx + 1].keys) >= t: self._borrow_from_next(node, child_idx) else: if child_idx != len(node.children) - 1: self._merge(node, child_idx) else: self._merge(node, child_idx - 1) return self._delete(node.children[child_idx], key) def _get_predecessor(self, node: BTreeNode, idx: int) -> int: current = node.children[idx] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_successor(self, node: BTreeNode, idx: int) -> int: current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _merge(self, node: BTreeNode, idx: int): child = node.children[idx] sibling = node.children[idx + 1] mid_key = node.keys[idx] child.keys.append(mid_key) child.keys.extend(sibling.keys) child.children.extend(sibling.children) node.children.pop(idx + 1) node.keys.pop(idx) def _borrow_from_prev(self, node: BTreeNode, idx: int): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node: BTreeNode, idx: int): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def find(self, key: int) -> bool: return self._find(self.root, key) def _find(self, node: BTreeNode, key: int) -> bool: idx = 0 while idx < len(node.keys) and key > node.keys[idx]: idx += 1 if idx < len(node.keys) and key == node.keys[idx]: return True if node.leaf: return False return self._find(node.children[idx], key) def traverse_tree(self): result = [] self._traverse_tree(self.root, result) return result def _traverse_tree(self, node: BTreeNode, result: list): if node: for i in range(len(node.keys)): if not node.leaf: self._traverse_tree(node.children[i], result) result.append(node.keys[i]) if not node.leaf: self._traverse_tree(node.children[len(node.keys)], result)"},{"question":"# Next Greatest Letter Search Problem Description: You are given a list `letters` of sorted characters (only lowercase letters) and a target character `target`. Your task is to implement a function that finds the smallest character in `letters` that is greater than the target. The list is circular, meaning if the target is larger than all characters in the list, the smallest character should be returned. Write a function `next_greatest_letter(letters, target)` to solve this problem. Input: - `letters`: List of lowercase alphabet characters, sorted in ascending order. Example: `[\\"c\\", \\"f\\", \\"j\\"]`. - `target`: A single lowercase alphabet character. Example: `\\"a\\"`. Output: - A single character which is the smallest character in `letters` that is greater than `target`. Constraints: - `1 <= len(letters) <= 1000` - `letters` contains only lowercase letters. - `target` is a lowercase letter from \'a\' to \'z\'. Examples: *Example 1*: ```plaintext letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" Output: \\"c\\" ``` *Example 2*: ```plaintext letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" Output: \\"f\\" ``` *Example 3*: ```plaintext letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" Output: \\"f\\" ``` Additional Information: - The `next_greatest_letter` function must run efficiently for large inputs within the given constraints. - Consider edge cases like smallest and largest target values, list wrapping and single element list. Implementation: Create the function `next_greatest_letter` with signature: ```python def next_greatest_letter(letters: List[str], target: str) -> str: # Your implementation here pass ```","solution":"def next_greatest_letter(letters, target): Finds the smallest character in letters that is greater than the target. If no such character exists (target is larger than all characters in the list), return the smallest character (circular list behavior). # Linear scan to find the result for letter in letters: if letter > target: return letter return letters[0]"},{"question":"# Ternary Search Extension with Range Queries Problem Statement You are given a sorted array of distinct integers. A ternary search function has been implemented to find the index of a given value in this array. Your task is to extend this functionality to also support range queries. Specifically, you need to implement a function `ternary_search_range` that, given a sorted array, a search key, and a range `[left, right]`, returns the index of the search key if it exists within the specified range, or -1 otherwise. Function Signature ```python def ternary_search_range(arr: List[int], left: int, right: int, key: int) -> int: ``` Input Format - `arr`: List of integers sorted in ascending order. (1 ≤ len(arr) ≤ 10^6) - `left`: An integer representing the starting index of the range. (0 ≤ left < len(arr)) - `right`: An integer representing the ending index of the range. (left < right < len(arr)) - `key`: An integer representing the value to search for in the array. Output Format - Return an integer representing the index of the key if it exists in the array within the specified range `[left, right]`. - Return -1 if the key does not exist within the specified range. Constraints - The function must run in O(log₃(N)) time complexity. - The array is always sorted in ascending order and contains distinct integers. Example ```python # Example 1 arr = [1, 3, 5, 7, 9, 11, 13, 15] left = 2 right = 6 key = 11 # Output: 5 (since arr[5] == 11) # Example 2 arr = [2, 4, 6, 8, 10, 12, 14, 16] left = 0 right = 7 key = 5 # Output: -1 (since 5 is not present within the range) ``` Implementation Notes - You should use the given `ternary_search` function as a basis for your implementation. - Ensure that the search range is handled correctly and bounds are checked to avoid running into index out-of-bounds errors.","solution":"from typing import List def ternary_search_range(arr: List[int], left: int, right: int, key: int) -> int: Performs a ternary search to find `key` in `arr` within the range [left, right]. while right >= left: mid1 = left + (right - left) // 3 mid2 = right - (right - left) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"You are given a list of elements where some elements may appear multiple times. Your task is to write a function `find_modes` that will determine the most frequently occurring element(s) in the list. If there are multiple elements with the same highest frequency, return a list of all such elements in ascending order. # Function Signature ```python def find_modes(arr: List[Any]) -> List[Any]: ``` # Input - `arr` (List[Any]): A list of elements where `1 <= len(arr) <= 10^6`. # Output - A list of elements (List[Any]) that are the most frequently occurring in the input array, sorted in ascending order. # Constraints - The input list can contain any hashable elements. - The function should handle large datasets within reasonable time (linear time complexity) and space. # Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([\'a\', \'b\', \'a\', \'c\', \'c\', \'b\']) == [\'a\', \'b\', \'c\'] assert find_modes([7, 7, 7, 1, 2, 3]) == [7] assert find_modes([]) == [] ``` # Detailed Explanation 1. Iterate through the list and create a frequency dictionary to count occurrences of each element. 2. Determine the maximum count of occurrences from the dictionary. 3. Compile a list of all elements that have this maximum count. 4. Sort the result list in ascending order before returning it. # Edge Cases - Handle empty list input by returning an empty list. - Ensure all hashable data types are treated correctly.","solution":"from collections import Counter from typing import List, Any def find_modes(arr: List[Any]) -> List[Any]: if not arr: return [] frequency = Counter(arr) max_count = max(frequency.values()) modes = [key for key, count in frequency.items() if count == max_count] return sorted(modes)"},{"question":"**ZigZag Iterator Challenge** You are given two lists, and you need to implement a ZigZag Iterator that will alternate elements from the two lists until all elements are consumed. # Requirements * Implement the following methods: * **`__init__(self, v1: List[int], v2: List[int])`**: Initialize the ZigZag Iterator with the two lists. * **`next(self) -> int`**: Returns the next element in the ZigZag order. * **`has_next(self) -> bool`**: Returns `True` if there are more elements to iterate, otherwise returns `False`. # Input and Output Formats * **`__init__(self, v1: List[int], v2: List[int])`** * **Input**: `v1` and `v2` as two lists of integers. * **Output**: None. * **`next(self) -> int`** * **Output**: An integer, the next element in the ZigZag order. * **`has_next(self) -> bool`** * **Output**: A Boolean, `True` if there are more elements to iterate, otherwise `False`. # Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` # Constraints * Both lists can have different lengths. * Lists may contain up to `10^5` elements. * Ensure your implementation is efficient and handles the edge cases appropriately. # Scenario or Context Imagine you are alternately processing items from two different sources, such as two data streams. This iterator helps you efficiently process items from both sources one by one in an alternating manner, ensuring that you do not favor one source over the other.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): self.data = [v1, v2] self.pointers = [0, 0] self.current_list = 0 def next(self) -> int: while self.pointers[self.current_list] >= len(self.data[self.current_list]): self.current_list = (self.current_list + 1) % 2 res = self.data[self.current_list][self.pointers[self.current_list]] self.pointers[self.current_list] += 1 self.current_list = (self.current_list + 1) % 2 return res def has_next(self) -> bool: return any(p < len(self.data[i]) for i, p in enumerate(self.pointers))"},{"question":"# Task Description You have been given a partially sorted array, and your objective is to implement a function to sort it completely using the Cocktail Shaker Sort algorithm. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input * A list `arr` of integers is given where `1 <= len(arr) <= 1000`. # Output * The function should return a new list that contains all the elements of `arr` sorted in non-decreasing order. # Example ```python assert cocktail_shaker_sort([3, 2, 1]) == [1, 2, 3] assert cocktail_shaker_sort([5, 1, 4, 2, 8]) == [1, 2, 4, 5, 8] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([42]) == [42] assert cocktail_shaker_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] ``` # Constraints * You must not use Python\'s built-in `sort()` function or any other library that provides direct sorting functionality. * Ensure the solution is efficient enough to handle the upper constraint limit of `arr`. Using this function, you should validate your understanding of the Cocktail Shaker Sort algorithm or any equivalent mutation.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Implements the cocktail shaker sort algorithm to sort the input list. n = len(arr) if n <= 1: return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i+1]: arr[i], arr[i+1] = arr[i+1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i-1]: arr[i], arr[i-1] = arr[i-1], arr[i] swapped = True start += 1 return arr"},{"question":"You are tasked with writing a function that implements regular expression matching with support for two special characters: 1. `\'.\'` which matches any single character. 2. `\'*\'` which matches zero or more of the preceding element. Your implementation should determine if the input string matches the given pattern entirely. # Function Signature ```python def is_match(s: str, p: str) -> bool: ``` # Input/Output Formats - **Input**: - `s` (string) - The input string containing lowercase English letters (0 <= len(s) <= 1000). - `p` (string) - The pattern string containing lowercase English letters (`a-z`) and the special characters `\'.\'` and `\'*\'` (0 <= len(p) <= 1000). - **Output**: - Return `True` if the input string matches the pattern, otherwise return `False`. # Constraints - The pattern will be properly formatted, meaning no \'*\' will appear at the beginning of the pattern. - Consecutive \'*\' characters following a single character are allowed but should be correctly handled. # Example Cases Example 1 - Input: s = \\"aa\\", p = \\"a\\" - Output: False - Explanation: The pattern does not match the input string because `a` does not match `aa`. Example 2 - Input: s = \\"aa\\", p = \\"a*\\" - Output: True - Explanation: `\'*\'` means zero or more of the preceding element, so `a*` matches `aa`. Example 3 - Input: s = \\"ab\\", p = \\".*\\" - Output: True - Explanation: `\'.\'` means any single character, and `\'*\'` means zero or more of the preceding element, so `.*` matches `ab`. Example 4 - Input: s = \\"aab\\", p = \\"c*a*b\\" - Output: True - Explanation: `c*` can be replaced with an empty string, `a*` matches `aa`, and `b` matches `b`. Kindly implement the function `is_match` following the specified constraints and ensuring optimized time and space complexity.","solution":"def is_match(s: str, p: str) -> bool: # Create a table for dynamic programming dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # Empty string matches empty pattern # Initialize table for patterns with \'*\' for j in range(2, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == \'.\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] # \'*\' can mean zero occurrence of preceding element if p[j-2] == \'.\' or p[j-2] == s[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j] return dp[len(s)][len(p)]"},{"question":"Robust Interpolation Search **Context**: You have been working for a digital library application. One of the essential functionalities is to provide a fast search mechanism for books based on their ISBN numbers. Since ISBN numbers are uniformly distributed, you decide to implement an optimized search method. **Problem Statement**: Implement a robust `interpolation_search` function to locate a given search key in a sorted array, taking edge cases and performance into account. You also need to ensure your implementation handles the potential drawbacks effectively. # Task Requirements 1. **Function Signature**: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: ``` 2. **Input**: - `array`: A list of sorted integers representing the ISBN numbers. - `search_key`: An integer representing the ISBN number to search for. 3. **Output**: - Return the index of `search_key` in the array if found. - Return `-1` if the search key is not found. 4. **Constraints**: - Your function must handle edge cases such as an empty array, search key outside the bounds of the array, and identical elements. - Aim to achieve better performance than the naive interpolation search for non-uniformly distributed data by optimizing with fallbacks where necessary. - Ensure you return correct results for all valid and edge inputs. # Example Usage ```python print(enhanced_interpolation_search([10, 12, 15, 21, 25, 32, 34], 12)) # Output: 1 print(enhanced_interpolation_search([1, 10, 15, 25, 35], 5)) # Output: -1 print(enhanced_interpolation_search([], 1)) # Output: -1 print(enhanced_interpolation_search([20, 20, 20, 20], 20)) # Output: 0 ``` **Performance Consideration**: While implementing, carefully address potential performance drawbacks specific to non-uniform distributions. Hybrid methods are encouraged.","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if array[low] == array[high]: if array[low] == search_key: return low else: return -1 pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"You are tasked with writing a function to convert instances of fractional Roman numerals, which extend beyond the standard integers, to decimals. In particular, the function should handle fractional parts by incorporating small font representations of Roman numerals (using lowercase letters). Requirements 1. The input is a fractional Roman numeral string using `{\'i\', \'v\', \'x\', \'l\', \'c\', \'d\', \'m\'}` for fractional parts, and `{\'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'}` as usual for integer parts. 2. Convert this Roman numeral string to its decimal number representation. 3. You\'re guaranteed that the integer part lies within the range 1 to 3999, and the fractional part (if present) is a valid representation. Example - `Input`: \\"MMCMXCIV.iiii\\" - `Output`: 2999.4444 (since `.iiii` indicates four \\"1/10,000\\" units) Function Signature ```python def roman_to_decimal(roman: str) -> float: pass ``` # Constraints - The input Roman numeral string will be non-empty and correctly formatted according to the expanded Roman numeral system. - You need to take care of fractional representation within 0 to 0.9999. # Implementation Details 1. Implement the function `roman_to_decimal(roman: str) -> float`. 2. The integer and fractional parts of the Roman numeral may be divided by a dot (`.`). 3. Ensure the function returns the correct floating-point number.","solution":"def roman_to_decimal(roman: str) -> float: Convert a fractional Roman numeral string to its decimal representation. # Define roman numeral values roman_values = { \'M\': 1000, \'D\': 500, \'C\': 100, \'L\': 50, \'X\': 10, \'V\': 5, \'I\': 1, \'m\': 0.001, \'d\': 0.0005, \'c\': 0.0001, \'l\': 0.00005, \'x\': 0.00001, \'v\': 0.000005, \'i\': 0.000001 } # Split the input into integer and fractional parts if \'.\' in roman: int_part, frac_part = roman.split(\'.\') else: int_part, frac_part = roman, \'\' # Helper function to convert a roman numeral string to its decimal value def convert_to_decimal(part): total = 0 prev_value = 0 for char in reversed(part): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total # Convert both parts return convert_to_decimal(int_part) + convert_to_decimal(frac_part)"},{"question":"**Bucket Sort Implementation**: Implement the bucket sort algorithm and ensure it handles a variety of cases efficiently. Function Signature ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` Input * A list `arr` with integers, where `1 <= len(arr) <= 10^5` and `0 <= arr[i] <= 10^6`. Output * A list of integers with the same elements as `arr`, but sorted in non-decreasing order. Constraints 1. The length of the list shall be between 1 and 100,000. 2. The integers in the list shall be between 0 and 1,000,000. Performance Requirements * The solution should aim to perform efficiently for large input sizes, ideally demonstrating behavior close to O(n log n) time complexity in practical scenarios. Examples 1. Input: `[3, 1, 5, 7, 2, 4, 6]` Output: `[1, 2, 3, 4, 5, 6, 7]` 2. Input: `[9, 0, 2, 8, 7, 5, 1, 3, 6, 4]` Output: `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]` 3. Input: `[10, 20, 30, 40, 50]` Output: `[10, 20, 30, 40, 50]` Edge Cases 1. An input list where all elements are the same. 2. An input list with the minimum and maximum allowed values. 3. An empty list (should be handled gracefully even though the constraint excludes an empty list). # Note - Ensure the code handles the mentioned constraints and edge cases. - Using Python\'s built-in sorting algorithms is not allowed. - You may use additional helper functions as necessary.","solution":"from typing import List def bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr # Determine the number of buckets and their respective ranges min_value = min(arr) max_value = max(arr) bucket_count = len(arr) bucket_range = (max_value - min_value) / bucket_count + 1 # Initialize buckets buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for num in arr: bucket_index = int((num - min_value) / bucket_range) buckets[bucket_index].append(num) # Sort individual buckets and concatenate results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"**Problem Statement**: Implement an extended version of Radix Sort capable of handling both positive and negative integers. Your function should correctly sort arrays containing a mix of positive and negative numbers while preserving the order for numbers with the same magnitude. # Constraints - **Input**: A list of integers (both positive and negative). - **Output**: A sorted list of integers. - You cannot use any built-in sort functions. - The function should have reasonable performance, ideally (O(nk + n)). # Input and Output Format - **Input**: list of integers, e.g., `arr = [170, -45, 75, -90, 802, 24, 2, 66]` - **Output**: list sorted in ascending order, e.g., `[-90, -45, 2, 24, 66, 75, 170, 802]` # Implementation Requirements 1. Write a function `extended_radix_sort(arr: List[int]) -> List[int]`. 2. Modify the traditional Radix Sort mechanism to handle negative numbers. 3. Ensure positional correctness for numbers of the same magnitude in your final implementation. # Example ```python def extended_radix_sort(arr): # Your code here assert extended_radix_sort([170, -45, 75, -90, 802, 24, 2, 66]) == [-90, -45, 2, 24, 66, 75, 170, 802] ``` # Note - To handle negative numbers, consider using two separate lists (or approaches for positive and negative numbers) and then merge the results. - Ensure your solution is both time and space efficient.","solution":"from typing import List def extended_radix_sort(arr: List[int]) -> List[int]: def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 # Count occurrences of digits based on the exponent value for i in range(n): index = abs(arr[i]) // exp count[(index % 10)] += 1 # Modify count array such that it contains actual position of digits in output for i in range(1, 10): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 for i in range(n): arr[i] = output[i] if len(arr) == 0: return [] # Separate positive and negative numbers positive_numbers = [num for num in arr if num >= 0] negative_numbers = [-num for num in arr if num < 0] # Find the maximum number to know maximum number of digits max_positive = max(positive_numbers) if positive_numbers else 0 max_negative = max(negative_numbers) if negative_numbers else 0 # Perform radix sort on positive numbers exp = 1 while max_positive // exp > 0: counting_sort(positive_numbers, exp) exp *= 10 # Perform radix sort on negative numbers exp = 1 while max_negative // exp > 0: counting_sort(negative_numbers, exp) exp *= 10 # Merge sorted negative numbers (in reverse order and negated) with positive numbers sorted_arr = [-num for num in reversed(negative_numbers)] + positive_numbers return sorted_arr"},{"question":"# Problem: Run-Length Encoding Enhancements You have been provided with basic run-length encoding (RLE) and decoding functions. Your task is to enhance these functions by implementing additional features to improve their robustness and flexibility. Objective Your goal is to implement two functions: 1. `enhanced_encode_rle(input: str) -> str` 2. `enhanced_decode_rle(input: str) -> str` Requirements 1. **enhanced_encode_rle** - Input: A string `input` which may contain any sequence of characters. - Output: A run-length encoded string. - Constraints: Handle edge cases like empty strings and strings without consecutive repeating characters. 2. **enhanced_decode_rle** - Input: A run-length encoded string. - Output: The original uncompressed string. - Constraints: Ensure that invalid encoded strings raise appropriate exceptions. Edge Cases to Consider 1. Empty strings should return empty strings. 2. Strings that do not have consecutive repeating characters should be encoded correctly. 3. Decoding should check for valid formatting and handle incorrect encoded inputs gracefully with error handling. Function Signatures ```python def enhanced_encode_rle(input: str) -> str: pass def enhanced_decode_rle(input: str) -> str: pass ``` Performance Both functions should operate with linear time complexity relative to the length of the input. Example Usage ```python # Encoding examples assert enhanced_encode_rle(\\"\\") == \\"\\" assert enhanced_encode_rle(\\"abc\\") == \\"1a1b1c\\" assert enhanced_encode_rle(\\"aaaabbbcca\\") == \\"4a3b2c1a\\" # Decoding examples assert enhanced_decode_rle(\\"\\") == \\"\\" assert enhanced_decode_rle(\\"1a1b1c\\") == \\"abc\\" assert enhanced_decode_rle(\\"4a3b2c1a\\") == \\"aaaabbbcca\\" # Invalid decoding example try: enhanced_decode_rle(\\"4a3b2c1x1\\") except ValueError: print(\\"Invalid encoded string\\") ``` Write your solutions inside the function bodies provided.","solution":"def enhanced_encode_rle(input: str) -> str: Returns the run-length encoded string of the input. Handle edge cases like empty strings and strings without consecutive repeating characters. if not input: return \\"\\" encoded_string = \\"\\" count = 1 for i in range(1, len(input)): if input[i] == input[i - 1]: count += 1 else: encoded_string += f\\"{count}{input[i - 1]}\\" count = 1 # Append the last group encoded_string += f\\"{count}{input[-1]}\\" return encoded_string def enhanced_decode_rle(input: str) -> str: Returns the decoded run-length encoded string. Ensure that invalid encoded strings raise appropriate exceptions. if not input: return \\"\\" decoded_string = \\"\\" count = \\"\\" for char in input: if char.isdigit(): count += char elif char.isalpha(): if count == \\"\\": raise ValueError(\\"Invalid encoded string: missing count before character\\") decoded_string += int(count) * char count = \\"\\" else: raise ValueError(\\"Invalid encoded string: contains non-alphanumeric characters\\") if count != \\"\\": raise ValueError(\\"Invalid encoded string: ends with number\\") return decoded_string"},{"question":"# Question Given an integer `n` and `k`, write a function `optimized_binomial_coefficient(n, k)` to calculate the binomial coefficient C(n, k) efficiently. Your solution should avoid deep recursion and should handle large values of `n` and `k`. # Requirements - The function should take two integers `n` and `k` as input. - Return the binomial coefficient C(n, k). - Ensure that n >= k. - Optimize for both time and space complexity. # Constraints - You can assume that the values of `n` and `k` will be non-negative integers. - For large values, consider optimizing beyond simple recursion to avoid stack overflow. # Input Format ```python n: int - the total number of items k: int - the number of items to choose ``` # Output Format ```python int - the computed binomial coefficient C(n, k) ``` # Example ```python # Example 1 print(optimized_binomial_coefficient(5, 0)) # Output: 1 # Example 2 print(optimized_binomial_coefficient(8, 2)) # Output: 28 # Example 3 print(optimized_binomial_coefficient(500, 300)) # Output: A large integer ``` # Notes - Ensure that your solution is efficient and handles very large values of n and k properly. - Avoid using a naive recursive approach that can lead to stack overflow errors.","solution":"def optimized_binomial_coefficient(n, k): Returns the binomial coefficient C(n, k) = n! / (k! * (n - k)!). This is optimized to avoid deep recursion and large space complexity. if k > n - k: k = n - k # C(n, k) = C(n, n-k) if k == 0: return 1 coeff = 1 for i in range(k): coeff *= (n - i) coeff //= (i + 1) return coeff"},{"question":"# Question: Implement Enhanced Diffie-Hellman Key Exchange with Additional Constraints **Objective**: Implement Diffie-Hellman Key Exchange algorithm with enhanced features to address additional constraints such as verifying if `p` is prime and if `a` is a valid primitive root of `p`. Scenario Alice and Bob want to communicate securely using the Diffie-Hellman key exchange. However, they must verify certain conditions to ensure the security of the exchange: 1. `p` must be a prime number. 2. `a` must be a primitive root of `p`. Write a function `secure_diffie_hellman_key_exchange` that takes the following parameters: - `a`: An integer representing the base, which should be the primitive root of `p`. - `p`: A large prime number. - `verbose`: A boolean flag. If `True`, print the private and public keys of Alice and Bob as well as their final shared key. The function should: 1. Check if `p` is prime. 2. Verify if `a` is a primitive root of `p`. 3. Perform the Diffie-Hellman key exchange if the conditions are met. 4. Return the shared key if the exchange is completed successfully, otherwise return an error message. Constraints - Assume `p` is a positive integer greater than 2. - Assume `a` is a positive integer less than `p`. Input - `a`: Integer, base for key exchange. - `p`: Integer, the large prime number. - `verbose`: Boolean, flag for detailed output. Output - The shared secret key (integer) if exchange is successful. - Error message (string) if any conditions or verifications fail. Examples 1. `secure_diffie_hellman_key_exchange(2, 11, False)` -> Returns the shared key 2. `secure_diffie_hellman_key_exchange(4, 11, True)` -> Returns \\"4 is not a primitive root of 11\\" Implement the function `secure_diffie_hellman_key_exchange` to fulfill these requirements.","solution":"import sympy import random def is_primitive_root(a, p): Check if `a` is a primitive root of `p`. required_set = set(num for num in range(1, p) if sympy.gcd(num, p) == 1) actual_set = set((a ** powers) % p for powers in range(1, p)) return required_set == actual_set def secure_diffie_hellman_key_exchange(a, p, verbose=False): Performs the Diffie-Hellman key exchange if the following conditions are met: 1. `p` is a prime number. 2. `a` is a primitive root of `p`. Returns the shared key if successful, otherwise returns an error message. if not sympy.isprime(p): return f\\"{p} is not a prime number\\" if not is_primitive_root(a, p): return f\\"{a} is not a primitive root of {p}\\" # Alice and Bob choose their private keys private_key_alice = random.randint(1, p-2) private_key_bob = random.randint(1, p-2) # Compute public keys public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) # Compute shared keys shared_key_alice = pow(public_key_bob, private_key_alice, p) shared_key_bob = pow(public_key_alice, private_key_bob, p) assert shared_key_alice == shared_key_bob if verbose: print(f\\"Alice\'s Private Key: {private_key_alice}\\") print(f\\"Bob\'s Private Key: {private_key_bob}\\") print(f\\"Alice\'s Public Key: {public_key_alice}\\") print(f\\"Bob\'s Public Key: {public_key_bob}\\") print(f\\"Shared Key: {shared_key_alice}\\") return shared_key_alice"},{"question":"# Context You are working on a software that processes data stored in stacks, and often you need to remove the minimum value from these stacks to clean outliers or adjust the range of values quickly. # Problem Statement Write a function `remove_min(stack)` that takes a stack (implemented as a list) as input and removes the smallest element from the stack. The function should return the stack with the smallest element removed. If the stack is empty, it should return the stack as-is. # Input * A list representing a stack, where the last element of the list is the top of the stack. # Output * The same list with the smallest element removed. # Constraints * Do not use any other data structures except for the provided stack and an additional storage stack. * The stack can contain both positive and negative integers. * Multiple instances of the smallest number should have all but one instance removed. # Example ```python stack = [2, 8, 3, -6, 7, 3] remove_min(stack) # Expected output: [2, 8, 3, 7, 3] ``` # Notes * The order of the other elements should remain the same. # Function Signature ```python def remove_min(stack): Removes the smallest element from the stack pass ```","solution":"def remove_min(stack): Removes the smallest element from the stack. Parameters: stack (list): The stack in which to remove the smallest element. Returns: list: The stack with the smallest element removed. if not stack: return stack # Find the minimum value in the stack min_value = min(stack) # Remove the first occurrence of the minimum value stack.remove(min_value) return stack"},{"question":"Scenario You are working on implementing a Binary Search Tree (BST) to manage an ordered dataset efficiently. This BST will support operations like insertion, deletion, and searching. To test your understanding of this data structure, you need to implement a key function that inserts a new value into the BST while maintaining its properties. Task Write a function `insert_into_bst(root, value)` that inserts a given value into the BST rooted at `root` and returns the root of the modified BST. # Function Signature ```python def insert_into_bst(root: TreeNode, value: int) -> TreeNode: # your code here ``` # Input * `root`: The root node of the BST (or `None` if the tree is empty). * `value`: An integer value to insert into the BST. # Output * The root of the modified BST with the new value inserted. # Constraints - Values in the BST nodes are unique. - The function should handle the insertion while maintaining the BST properties. - You may assume that the initial tree does not contain the value to be inserted. # Example ```python Example 1: input: root = None, value = 3 output: TreeNode with root value 3 Example 2: input: 3 / 1 4 value = 2 output: 3 / 1 4 2 ``` # Notes - The students must ensure that their solution correctly handles edge cases, such as inserting into an empty tree or adding the smallest/largest value. - The primary focus should be on maintaining the BST properties after insertion.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None def insert_into_bst(root: TreeNode, value: int) -> TreeNode: if root is None: return TreeNode(value) if value < root.value: if root.left is None: root.left = TreeNode(value) else: insert_into_bst(root.left, value) else: if root.right is None: root.right = TreeNode(value) else: insert_into_bst(root.right, value) return root"},{"question":"Alice and Bob want to securely exchange keys over an insecure network using the Diffie-Hellman Key Exchange method. Your task is to implement their key exchange process. You need to ensure that the prime number (p) and primitive root (a) are validated correctly and then perform the Diffie-Hellman key exchange. # Instructions 1. Write a function `diffie_hellman_key_exchange(a: int, p: int) -> bool` that implements the Diffie-Hellman key exchange process to verify if both Alice and Bob can compute the same shared secret key. 2. You will need the following helper functions: - `prime_check(num: int) -> bool`: To check if `num` is a prime number. - `euler_totient(n: int) -> int`: To compute Euler\'s totient function. - `find_order(a: int, n: int) -> int`: To find the order of `a` modulo `n`. - `find_primitive_root(n: int) -> list`: To find all primitive roots of `n`. 3. The shared secret key must be kept confidential and the function should return `True` if both keys match, otherwise `False`. # Function Signature ```python def diffie_hellman_key_exchange(a: int, p: int) -> bool: ``` # Input - `a` (1 <= `a` <= (10^9)) : an integer representing the primitive root. - `p` ((1 <= p <= 10^{9})) : an integer representing the large prime number. # Output - Return `True` if both Alice and Bob can compute and match the same shared secret key, otherwise `False`. # Example ```python assert diffie_hellman_key_exchange(5, 23) == True assert diffie_hellman_key_exchange(2, 20) == False # 20 is not a prime assert diffie_hellman_key_exchange(3, 7) == True ``` # Constraints - Ensure proper handling of large numbers within the given constraints. - Ensure function correctly identifies prime numbers and primitive roots within efficient runtime. - Avoid calculating sensitive keys directly. Use helper functions to maximize modular exponentiation efficiency. # Notes Alice and Bob should select their private keys randomly within the range 1 to (p-1).","solution":"import random from math import gcd def prime_check(num): Returns True if num is a prime number, else False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def euler_totient(n): Returns the value of Euler\'s Totient function for n. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_order(a, n): Returns the order of a modulo n. if gcd(a, n) != 1: return -1 phi_n = euler_totient(n) for i in range(1, phi_n + 1): if (a**i) % n == 1: return i return -1 def find_primitive_root(p): Returns a list of all primitive roots of prime p. if not prime_check(p): return [] required_set = set(num for num in range(1, p) if gcd(num, p) == 1) primitive_roots = [] for g in range(1, p): actual_set = set(pow(g, powers, p) for powers in range(1, p)) if required_set == actual_set: primitive_roots.append(g) return primitive_roots def diffie_hellman_key_exchange(a, p): Implements the Diffie-Hellman Key Exchange process. Returns True if both Alice and Bob compute the same shared secret key, else False. if not prime_check(p): return False # p must be prime primitive_roots = find_primitive_root(p) if a not in primitive_roots: return False # a must be a primitive root of p # Simulating the private keys for Alice and Bob (randomly selected) alice_private_key = random.randint(1, p-1) bob_private_key = random.randint(1, p-1) # Computing the public values alice_public = pow(a, alice_private_key, p) bob_public = pow(a, bob_private_key, p) # Computing the shared secret keys alice_shared_secret = pow(bob_public, alice_private_key, p) bob_shared_secret = pow(alice_public, bob_private_key, p) # Both shared secrets must match return alice_shared_secret == bob_shared_secret"},{"question":"You are tasked with implementing a function to calculate the combination of `n` items taken `r` at a time, denoted as nCr (or the binomial coefficient). The function must be optimized using dynamic programming techniques. # Function Signature ```python def optimized_combination(n: int, r: int) -> int: pass ``` # Input *Two integers, `n` (0 <= n <= 100) and `r` (0 <= r <= n).* # Output *Return an integer representing the number of ways to choose `r` items from `n` items.* # Constraints - The computation should be efficient for large values of `n` and `r`. - Use dynamic programming to avoid recomputation of subproblems. - Handle edge cases appropriately, where `n < r` should return `0`. # Example ```python # Example 1 print(optimized_combination(5, 2)) # Output: 10 # Explanation: There are 10 ways to choose 2 items from 5 items. # Example 2 print(optimized_combination(6, 6)) # Output: 1 # Explanation: There is exactly 1 way to choose all 6 items from 6. # Example 3 print(optimized_combination(10, 0)) # Output: 1 # Explanation: There is exactly 1 way to choose 0 items from 10. ```","solution":"def optimized_combination(n: int, r: int) -> int: Calculate the combination of `n` items taken `r` at a time (nCr) using dynamic programming. if r > n: return 0 if r == 0 or r == n: return 1 r = min(r, n - r) dp = [0] * (r + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(min(i, r), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[r]"},{"question":"# Anagram Checker for Large Character Sets Scenario: You are tasked with extending the basic anagram checker algorithm to handle a wider character set, including uppercase letters and non-alphabetic characters. The algorithm should be case insensitive and ignore spaces and punctuations. The task is to implement a function that checks if two given strings can be rearranged to form each other, considering only alphanumeric characters and treating uppercase and lowercase letters as equivalent. Function Signature: ```python def extended_anagram(s1: str, s2: str) -> bool: pass ``` Input: * `s1` (String): The first string to be compared. * `s2` (String): The second string to be compared. Output: * (Boolean): Returns `True` if the strings are anagrams considering the specified conditions, otherwise `False`. Constraints: * Strings can contain alphanumeric characters, spaces, and punctuation. * The function should be case insensitive. * Utilizes optimal performance considering the new constraints. Example: ```python assert extended_anagram(\\"A man, a plan, a canal, Panama\\", \\"Am ana plan a canal Panama\\") == True assert extended_anagram(\\"Hello, World!\\", \\"dlrow ,olleH\\") == True assert extended_anagram(\\"Test\\", \\"Sets\\") == False ``` Requirements: * Properly clean the input strings to remove non-alphanumeric characters. * Convert characters to lowercase for case insensitivity. * Implement the anagram check efficiently. **Note**: Be mindful of performance and optimize your solution for large inputs where possible.","solution":"import re from collections import Counter def extended_anagram(s1: str, s2: str) -> bool: Check if two strings are anagrams, considering only alphanumeric characters and ignoring cases. # Clean input strings: remove non-alphanumeric characters and convert to lowercase clean_s1 = re.sub(r\'[^a-zA-Z0-9]\', \'\', s1).lower() clean_s2 = re.sub(r\'[^a-zA-Z0-9]\', \'\', s2).lower() # Use Counter (from collections) to count characters and compare return Counter(clean_s1) == Counter(clean_s2)"},{"question":"Problem Statement You are given a Binary Search Tree (BST) and an integer k. Your task is to implement a function that returns the k-th smallest element in the BST. The function should follow an iterative approach using a stack for successful execution. Implement the function as follows: ```python def kth_smallest(root, k): Given a binary search tree, write a function to find the kth smallest element in it. :param root: TreeNode - the root node of the BST. :param k: int - the position (1-indexed) of the smallest element to find. :return: int - the kth smallest element in the BST. # Your code here ``` Constraints: - `The number of nodes in the BST is in the range [1, 10^4].` - `0 <= Node.val <= 10^4` - `1 <= k <= the number of nodes in the tree` Input/Output Examples: Example 1: ```plaintext Input: root = [3, 1, 4, None, 2], k = 1 Output: 1 Explanation: 3 / 1 4 2 k = 1, so the 1st smallest element is 1. ``` Example 2: ```plaintext Input: root = [5, 3, 6, 2, 4, None, None, 1], k = 3 Output: 3 Explanation: 5 / 3 6 / 2 4 / 1 k = 3, so the 3rd smallest element is 3. ``` Performance Requirements: - The solution should have a time complexity of O(N), where N is the number of nodes in the BST. - The space complexity should be optimized, ideally O(H), where H is the height of the tree. Ensure your code handles edge cases appropriately, such as when the tree is empty or when k is not within a valid range.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Given a binary search tree, write a function to find the kth smallest element in it. :param root: TreeNode - the root node of the BST. :param k: int - the position (1-indexed) of the smallest element to find. :return: int - the kth smallest element in the BST. stack = [] current = root while True: while current: stack.append(current) current = current.left current = stack.pop() k -= 1 if k == 0: return current.val current = current.right"},{"question":"# Binary Search Tree Iterator Implementation You are provided with an incomplete implementation of a `BSTIterator` class which allows in-order traversal of a binary search tree (BST) utilizing an iterative approach. This iterator should provide methods to check if there are remaining nodes to access (`has_next`) and to retrieve the next node value in the sequence (`next`). # Requirements: 1. Complete the provided `BSTIterator` class using a stack-based approach to achieve in-order traversal. # Function Definitions: `BSTIterator.__init__(self, root)` * **Input**: `root` (TreeNode) - root node of the BST. * **Output**: None. * **Function**: Initializes the iterator object, setting up the stack to include all left descendants starting from the root. `BSTIterator.has_next(self)` * **Input**: None. * **Output**: (boolean) - Returns True if there are remaining nodes to visit; otherwise, returns False. `BSTIterator.next(self)` * **Input**: None. * **Output**: (int) - Returns the next in-order value. * **Function**: Retrieves the next value using the stack by in-order traversal. # Constraints: 1. Tree nodes contain unique integer values. 2. There are no duplicate values in the BST. 3. Expected time complexity is O(1) for `has_next` and `next` calls amortized over all operations combined. # Example Usage: ```python root = TreeNode(7, TreeNode(3), TreeNode(15, TreeNode(9), TreeNode(20) ) ) iterator = BSTIterator(root) assert iterator.next() == 3 assert iterator.has_next() == True assert iterator.next() == 7 assert iterator.has_next() == True assert iterator.next() == 9 assert iterator.has_next() == True assert iterator.next() == 15 assert iterator.has_next() == True assert iterator.next() == 20 assert iterator.has_next() == False ``` # Note: - Ensure the provided class and methods correctly handle typical edge cases, such as an empty tree or a single-node tree. - Performance of the implementation should be optimal with O(h) space complexity where h is the tree height.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def has_next(self) -> bool: return len(self.stack) > 0"},{"question":"# Task Implement a function `summarize_ranges` that takes a sorted list of unique integers and returns a summary of the contiguous ranges. # Input: * `array` (List[int]): A sorted list of unique integers. # Output: * List[str]: A list of strings representing the ranges. Each range is formatted as \\"start-end\\". If the range only contains one number, it should be represented as \\"start\\". # Function Signature: ```python def summarize_ranges(array: List[int]) -> List[str]: pass ``` # Constraints: 1. 0 <= len(array) <= 10^5 2. -10^9 <= array[i] <= 10^9 3. The input array will always be sorted and contain unique elements. # Detailed Requirement: * The function should handle edge cases such as empty arrays, arrays with one element, and arrays with no contiguous elements. * The function should be efficient, targeting O(n) time complexity. # Example: ```python # Example 1 # Input: [0, 1, 2, 4, 5, 7] # Output: [\\"0-2\\", \\"4-5\\", \\"7\\"] # Example 2 # Input: [1, 3, 7, 8, 9] # Output: [\\"1\\", \\"3\\", \\"7-9\\"] # Example 3 # Input: [] # Output: [] # Example 4 # Input: [1] # Output: [\\"1\\"] ``` # Scenario: You are working on a system monitoring tool that takes a sorted list of CPU usage timestamps and compresses the data into a more human-readable format. Instead of listing every individual timestamp, you want to represent contiguous ranges of activity. Implement `summarize_ranges` that achieves this compression efficiently. # Notes: * The implementation must be efficient and handle very large lists within the problem constraints. * Pay attention to edge cases such as lists with a single element or no elements at all.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for num in array[1:]: if num == end + 1: end = num else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = num end = num # Add the last range if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Question: Hamming Weight Calculation Context You are working on a low-level programming task that involves bitwise operations and need to count the number of \'1\' bits in the binary representation of unsigned integers efficiently. This number is also known as the Hamming weight of the integer. Task Write a function that computes the Hamming weight of a given unsigned integer using Brian Kernighan\'s algorithm. You must provide both an iterative and a recursive implementation. Function Signature ```python def hamming_weight_iter(n: int) -> int: pass def hamming_weight_recur(n: int) -> int: pass ``` Input Format - A single integer `n` where 0 <= n <= 2^31 - 1. Output Format - A single integer representing the number of \'1\' bits in the binary representation of `n`. Constraints - You must use Brian Kernighan\'s algorithm for the bit counting. - The recursive method should handle base cases and stop correctly. - You should manage possible edge cases as noted in the analysis. Example ```python assert hamming_weight_iter(11) == 3 # binary: 00000000000000000000000000001011 assert hamming_weight_recur(128) == 1 # binary: 00000000000000000000000010000000 assert hamming_weight_iter(0) == 0 # binary: 00000000000000000000000000000000 assert hamming_weight_recur(255) == 8 # binary: 00000000000000000000000011111111 ```","solution":"def hamming_weight_iter(n: int) -> int: Returns the Hamming weight (number of \'1\' bits) of the given unsigned integer using an iterative approach. count = 0 while n: n &= n - 1 # Drop the lowest set bit count += 1 return count def hamming_weight_recur(n: int) -> int: Returns the Hamming weight (number of \'1\' bits) of the given unsigned integer using a recursive approach. if n == 0: return 0 return 1 + hamming_weight_recur(n & (n - 1))"},{"question":"You are working with a simple compression algorithm called Run-Length Encoding (RLE). Your task is to implement two functions that will help compress and decompress strings using this technique. # Function 1: `encode_rle(input: str) -> str` **Input**: A string `input` consisting of lowercase alphabets. **Output**: A string representing the encoded version of `input` where sequences of the same character are replaced by that character followed by the number of occurrences. **Example**: ```python assert encode_rle(\\"aaabbcc\\") == \\"3a2b2c\\" assert encode_rle(\\"abcd\\") == \\"1a1b1c1d\\" assert encode_rle(\\"\\") == \\"\\" ``` # Function 2: `decode_rle(input: str) -> str` **Input**: A string `input` that represents a valid run-length encoded string. **Output**: The original string before encoding. **Example**: ```python assert decode_rle(\\"3a2b2c\\") == \\"aaabbcc\\" assert decode_rle(\\"1a1b1c1d\\") == \\"abcd\\" assert decode_rle(\\"\\") == \\"\\" ``` # Constraints 1. The input string for encoding will only contain lowercase alphabetic characters. 2. The encoded string for decoding will follow the correct RLE format as specified above. # Requirements 1. Write both functions `encode_rle` and `decode_rle` to handle the described functionalities. 2. Ensure efficiency and clarity in your code. 3. Consider and handle edge cases properly.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 previous_char = input[0] for current_char in input[1:]: if current_char == previous_char: count += 1 else: encoded.append(f\\"{count}{previous_char}\\") previous_char = current_char count = 1 encoded.append(f\\"{count}{previous_char}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) # supporting multi-digit counts else: decoded.append(char * count) count = 0 return \\"\\".join(decoded)"},{"question":"# Coding Challenge: Duplicate Stack Elements Context and Objective: You are working on a stack-based computation task that requires duplicating each element in a stack. You need to implement a function that takes a stack as input and updates it so that each element is replaced by two occurrences of its original value. Requirements: Implement a function, `duplicate_elements(stack)`, that replaces every value in the input stack with two occurrences of that value. You must use an auxiliary data structure (`stack` or `queue`) during the process. Function Signature: ```python def duplicate_elements(stack: list) -> None: # Your code here ``` Input: - `stack`: A list of integers representing a stack where the last element denotes the top of the stack. The stack is guaranteed to be non-null but can be empty. Output: - The function does not return anything. However, it modifies the input stack in place. Constraints: - You can use any auxiliary data structure (`stack` or `queue`) for temporary storage. - Aim for a time complexity of ( O(n) ) and space complexity of ( O(n) ). Example: ```python stack = [3, 7, 1, 14, 9] duplicate_elements(stack) print(stack) # Output: [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [] duplicate_elements(stack) print(stack) # Output: [] stack = [5] duplicate_elements(stack) print(stack) # Output: [5, 5] ``` Constraints: - You cannot use any built-in stack or queue data structures directly from libraries, except lists. - Aim to maintain the order of elements as originally present in the stack.","solution":"def duplicate_elements(stack: list) -> None: Updates the input stack by duplicating each element. temp = [] # Transfer elements to temp stack duplicating each while stack: element = stack.pop() temp.append(element) temp.append(element) # Transfer elements back to original stack in reverse order while temp: stack.append(temp.pop())"},{"question":"You are given a positive integer `n`. You need to write a function `partition_count(n)` that computes the number of ways to partition `n` into the sum of positive integers, considering that the order of terms in the partition does not matter. # Input - A single integer `n` where `1 <= n <= 1000`. # Output - An integer representing the number of partitions of `n`. # Example ```python partition_count(4) # Output: 5 partition_count(7) # Output: 15 ``` # Explanation For `n = 4`, the partitions are: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 For `n = 7`, the partitions include: - 7 - 6 + 1 - 5 + 2 - 5 + 1 + 1 - 4 + 3 - 4 + 2 + 1 - 4 + 1 + 1 + 1 - 3 + 3 + 1 - 3 + 2 + 2 - 3 + 2 + 1 + 1 - 3 + 1 + 1 + 1 + 1 - 2 + 2 + 2 + 1 - 2 + 2 + 1 + 1 + 1 - 2 + 1 + 1 + 1 + 1 + 1 - 1 + 1 + 1 + 1 + 1 + 1 + 1 # Constraints - You must optimize both time and space usage to handle up to `n = 1000`. # Hints - Use dynamic programming to build up the solution iteratively. - Consider reducing the space complexity by optimizing the storage of intermediate results. # Solution Template ```python def partition_count(n): Calculate the number of ways to partition the integer n into sums of positive integers. n -- positive integer # Write your code here # Example implementation: # arr = [[0 for i in range(n + 1)] for j in range(n + 1)] # arr[1][1] = 1 # for i in range(1, n + 1): # for j in range(1, n + 1): # if i < j: # arr[i][j] = arr[i][i] # elif i == j: # arr[i][j] = 1 + arr[i][j - 1] # else: # arr[i][j] = arr[i][j - 1] + arr[i - j][j] # return arr[n][n] ```","solution":"def partition_count(n): Calculate the number of ways to partition the integer n into sums of positive integers. n -- positive integer # Initialize a list to store the number of partitions for each number up to n partitions = [0] * (n + 1) partitions[0] = 1 # There is one way to partition 0, which is to have no terms # Iterate over the integers from 1 to n as the largest number in the partition for i in range(1, n + 1): for j in range(i, n + 1): partitions[j] += partitions[j - i] return partitions[n]"},{"question":"# Jump Search Optimization for Large Data **Objective**: Implement an optimized version of the Jump Search algorithm that searches for a target value in a large sorted array. The optimized version should dynamically adjust the block size based on the array length, and use a more efficient search mechanism within each block. Ensure to handle various edge cases and optimize for performance. **Function Signature**: ```python def optimized_jump_search(arr: List[int], target: int) -> int: pass ``` **Input**: - `arr`: A list of integers sorted in ascending order. (1 <= len(arr) <= 10^6) - `target`: An integer value to find in the array. **Output**: - Return the index of the target value if found, otherwise -1. **Constraints**: - The array will always be sorted. - Optimize both time and space complexity. - Ensure the solution handles edge cases gracefully. **Performance Requirements**: - Aim to maintain a time complexity of O(√n) or better. - Space complexity should be O(1). **Example**: ```python # Example 1 arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] target = 13 # Output: 6 (since arr[6] == 13) # Example 2 arr = [4, 7, 9, 12, 16, 25, 36, 42, 56, 72, 89] target = 20 # Output: -1 (since 20 is not in arr) ``` # Notes: - Implementations can consider using binary search within blocks for a faster look-up. - The block size should dynamically adapt and not be hard-coded. Considerations for the array length (len(arr)) should influence block size calculations. - Thoroughly document code to demonstrate thought process and handling of edge cases.","solution":"import math from typing import List def optimized_jump_search(arr: List[int], target: int) -> int: Performs an optimized jump search to find the target in the sorted array. Parameters: arr (List[int]): A list of integers sorted in ascending order. target (int): The integer value to find in the array. Returns: int: The index of the target value if found, otherwise -1. n = len(arr) if n == 0: return -1 # Finding the optimal block size to be jumped step = math.isqrt(n) prev = 0 # Finding the block where element is present (if it is present) while prev < n and arr[min(step, n) - 1] < target: prev = step step += math.isqrt(n) if prev >= n: return -1 # Do a linear search for target in block beginning with prev. for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Bucket Sort Implementation # Scenario You\'ve been tasked to sort a list of floating-point numbers ranging from 0 to 1 using Bucket Sort. In this approach, take advantage of the known range to distribute the numbers into appropriate buckets. Further, ensure each bucket is sorted before combining them into the final sorted list. # Objectives - Implement the bucket sort algorithm with a focus on sorting floating-point numbers between 0 and 1. - Utilize a suitable auxiliary sorting algorithm for individual buckets. # Task 1. Implement the function `bucket_sort(arr: List[float]) -> List[float]`: - **Input**: - A list `arr` containing floating-point numbers between 0 and 1. - Example: `[0.23, 0.45, 0.12, 0.89, 0.67, 0.34]` - **Output**: - A list containing the floating-point numbers sorted in ascending order. - Example: `[0.12, 0.23, 0.34, 0.45, 0.67, 0.89]` 2. Ensure an auxiliary sorting method (like insertion sort) sorts each bucket efficiently. # Requirements - The solution should be efficient and handle edge cases gracefully. - Consider the constraints: - The length of the array n can be as large as 10^5. - The data is uniformly distributed within the range [0, 1]. # Note - Do not use Python’s built-in sorting functions to sort the array directly. You may, however, use them to sort within individual buckets. # Code Template ```python def bucket_sort(arr: List[float]) -> List[float]: # Step 1: Create buckets num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Step 2: Distribute input array elements into buckets for value in arr: index = int(value * num_buckets) buckets[index].append(value) # Step 3: Sort individual buckets def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr sorted_array = [] for bucket in buckets: sorted_array.extend(insertion_sort(bucket)) return sorted_array ``` Provide a thorough test to ensure the implementation is correct and handles all edge cases.","solution":"from typing import List def bucket_sort(arr: List[float]) -> List[float]: Sorts a list of floating-point numbers between 0 and 1 using bucket sort. Arguments: arr -- list of floating point numbers between 0 and 1 Returns: sorted list of floating point numbers if len(arr) == 0: return [] num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] # Step 1: Distribute input array elements into buckets for value in arr: index = int(value * num_buckets) # handle the edge case where value is exactly 1 if value == 1.0: index = num_buckets - 1 buckets[index].append(value) # Step 2: Sort individual buckets using insertion sort def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr sorted_array = [] # Step 3: Concatenate all sorted buckets for bucket in buckets: sorted_array.extend(insertion_sort(bucket)) return sorted_array"},{"question":"You are given a stack and asked to write a function that replaces every element in the stack with a tripled version of that element. Function Signature ```python def triple_stutter(stack: list) -> list: pass ``` # Requirements 1. The function `triple_stutter` should use only a single stack as auxiliary storage. 2. The resulting stack must retain the original order with every value replaced by three occurrences of that value. # Input * A single argument `stack`: a list of integers, where: * `len(stack) >= 0` (stack can be empty). # Output * Returns a list representing the stack after each element has been replaced by three occurrences of itself. # Example 1. Suppose the stack stores these values: ``` bottom [4, 5, 2] top ``` after calling `triple_stutter(stack)`, the stack should store: ``` bottom [4, 4, 4, 5, 5, 5, 2, 2, 2] top ``` # Constraints * Time complexity of the function should be O(n), where n is the number of elements in the stack. * The function should utilize O(n) additional space for auxiliary storage. * No built-in functions for stack operations other than list operations should be used. # Notes * Ensure that the solution maintains the original order and incorporates no extraneous behavior. * Pay attention to edge cases such as empty stacks and ensure robust handling to avoid errors or unexpected behavior.","solution":"def triple_stutter(stack: list) -> list: Replaces every element in the stack with three occurrences of it, keeping the order the same. aux_stack = [] # Step 1: Transfer elements to auxiliary stack while stack: aux_stack.append(stack.pop()) # Step 2: Transfer elements back to original stack with tripling while aux_stack: element = aux_stack.pop() stack.append(element) stack.append(element) stack.append(element) return stack"},{"question":"# Scenario You are working with a custom stack-based application where every element needs to be duplicated to enhance redundancy and error-checking mechanisms. For efficient management, you should implement this duplication process using an auxiliary stack or queue. # Problem Statement Write a Python function `duplicate_elements_stack(stack: list) -> list` that takes a stack of integers as input and returns a stack where each integer is duplicated. Implement the function using only another stack as auxiliary storage. # Input - `stack`: A list of integers representing a stack, where the last element is the top of the stack. The stack may have 0 to 1000 elements. # Output - A list of integers representing the stack with each element duplicated. # Constraints - Do not use any other data structures other than an auxiliary stack. - You must preserve the order of duplication as described. # Performance Requirements - The solution should have a time complexity of O(n). - The space complexity should be O(n). # Example Input ```python stack = [3, 7, 1, 14, 9] ``` Output ```python [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Edge Cases - If the stack is empty, return an empty list. - If the stack has one element, duplicate it. **Function Signature**: ```python def duplicate_elements_stack(stack: list) -> list: ```","solution":"def duplicate_elements_stack(stack: list) -> list: Duplicates each element in the stack. Implemented using another stack as auxiliary storage. Args: - stack: list of integers representing a stack, where last element is the top of the stack. Returns: - list of integers with each element duplicated. aux_stack = [] # Move elements from the main stack to the auxiliary stack while stack: top_element = stack.pop() aux_stack.append(top_element) # Move elements back to the main stack, duplicating them while aux_stack: top_element = aux_stack.pop() stack.append(top_element) stack.append(top_element) return stack"},{"question":"# Decoding Ways Challenge A message containing letters from A-Z is being encoded to numbers using the following mapping: \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 Given an encoded message containing digits, determine the total number of ways to decode it. # Function Signature ```python def num_decodings(enc_mes: str) -> int: :type enc_mes: str :rtype: int ``` # Input Format: - A string `enc_mes` composed of digits only, representing the encoded message (1 ≤ |enc_mes| ≤ 100). # Output Format: - An integer representing the total number of distinct decodings of the given message. # Constraints: - The encoded message will not be empty and will only contain digits from \'0\' to \'9\'. # Example: ```python assert num_decodings(\\"12\\") == 2 # can be decoded as \\"AB\\" (1 2) or \\"L\\" (12) assert num_decodings(\\"226\\") == 3 # can be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (22 6) assert num_decodings(\\"0\\") == 0 # invalid message assert num_decodings(\\"06\\") == 0 # invalid message ``` # Guidelines: 1. The function should correctly handle edge cases such as messages starting with \'0\' or containing invalid two-digit combinations involving \'0\'. 2. Strive for a solution with linear time complexity and minimal space complexity. 3. Clearly comment on your code to explain the logic and show the reasoning behind your approach.","solution":"def num_decodings(enc_mes: str) -> int: Returns the number of ways to decode an encoded message using the mapping: \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26. if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) # dp[i] will store the number of ways to decode the message up to length i dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if enc_mes[0] != \'0\' else 0 for i in range(2, n + 1): single_digit = int(enc_mes[i-1:i]) double_digit = int(enc_mes[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"You are required to implement a function for matrix inversion that handles both 2x2 matrices and larger n x n matrices using the determinant-based method. Your function should follow the general steps used in the provided code, such as computing the matrix of minors and cofactors, adjugating, and multiplying by the inverse of the determinant. # Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: # Your code here. ``` # Input - `matrix` (List[List[float]]): An n x n matrix with float or integer elements (2 ≤ n ≤ 10). # Output - Returns the inverse of the input matrix as a List[List[float]] if the matrix is invertible. - If the matrix is non-invertible or invalid, the function should: - Return `[[-1]]` for invalid matrix (not n x n or not a matrix). - Return `[[-2]]` for non-square matrices. - Return `[[-3]]` for matrices too small (0x0 or 1x1). - Return `[[-4]]` for singular matrices (determinant equals zero). # Constraints - Matrices will contain floats or integers. - No matrix will be larger than 10x10 for computational feasibility. - You must handle edge conditions such as non-square or degenerate matrices. # Example ```python matrix_2x2 = [ [4, 7], [2, 6] ] matrix_3x3 = [ [3, 0, 2], [2, 0, -2], [0, 1, 1] ] # Expected output: [[0.6, -0.7], [-0.2, 0.4]] print(invert_matrix(matrix_2x2)) # Expected output: [[0.2, 0.2, 0], [-0.2, 0.3, 1], [0.2, -0.3, 0]] print(invert_matrix(matrix_3x3)) ``` # Note - Use checks and handle small matrices first (like 2x2) for simplicity before moving on to larger matrices. - Consider using helper functions as necessary, similar to the provided code snippet, to handle determinant calculations and matrix manipulations.","solution":"from typing import List def determinant(matrix: List[List[float]]) -> float: Calculate the determinant of a matrix. n = len(matrix) if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): det += ((-1)**c) * matrix[0][c] * determinant(minor(matrix, 0, c)) return det def minor(matrix: List[List[float]], row: int, col: int) -> List[List[float]]: Return the Minor of the matrix by removing the specified row and column. return [row[:col] + row[col+1:] for row in (matrix[:row] + matrix[row+1:])] def transpose(matrix: List[List[float]]) -> List[List[float]]: Transpose the given matrix. return list(map(list, zip(*matrix))) def cofactor(matrix: List[List[float]]) -> List[List[float]]: Return the cofactor matrix of the given matrix. n = len(matrix) cofactors = [] for r in range(n): cofactor_row = [] for c in range(n): minor_det = determinant(minor(matrix, r, c)) cofactor_value = ((-1) ** (r + c)) * minor_det cofactor_row.append(cofactor_value) cofactors.append(cofactor_row) return cofactors def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: Return the inverse of the input matrix or specific codes for invalid/singular matrices. # Check if the input is a valid matrix (n x n with valid numbers/integers) if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] n = len(matrix) if n == 0 or any(len(row) != n for row in matrix): return [[-2]] if n == 1: return [[-3]] # Determinant based check for singularity det = determinant(matrix) if det == 0: return [[-4]] # Calculate inverse for 2x2 matrix if n == 2: inverse_matrix = [ [matrix[1][1] / det, -1 * matrix[0][1] / det], [-1 * matrix[1][0] / det, matrix[0][0] / det] ] return inverse_matrix # For n > 2, use the determinant and adjugate methods cofactors = cofactor(matrix) adjugate = transpose(cofactors) inverse_matrix = [[adjugate[i][j] / det for j in range(n)] for i in range(n)] return inverse_matrix"},{"question":"# Question: Determine Strongly Connected Components in a Directed Graph You are given a directed graph with `n` vertices numbered from `0` to `n-1`. Your task is to implement a function that determines whether the graph is **strongly connected**. A graph is strongly connected if there is a path from any vertex to every other vertex and vice versa. Function Signature ```python def is_strongly_connected(graph: Dict[int, List[int]], vertex_count: int) -> bool: ``` Input * `graph`: A dictionary where keys represent source vertices and values are lists of target vertices. * `vertex_count`: An integer representing the number of vertices in the graph. Output * Returns `True` if the graph is strongly connected, `False` otherwise. Constraints * `1 <= vertex_count <= 10^5` * Each list in the dictionary `graph` contains integers representing valid vertex indexes (0 to vertex_count-1). Examples ```python # Example 1: graph = { 0: [1, 2], 1: [2], 2: [0] } vertex_count = 3 print(is_strongly_connected(graph, vertex_count)) # Output: True # Example 2: graph = { 0: [1], 1: [2], 2: [3], 3: [] } vertex_count = 4 print(is_strongly_connected(graph, vertex_count)) # Output: False ``` Notes 1. You may assume there are no duplicate edges in the input graph. 2. The graph may not be explicitly connected, meaning it may have nodes with no incoming or outgoing edges. 3. Graph reversal and DFS are key to your solution. Ensure efficiency given the constraints.","solution":"def is_strongly_connected(graph: dict, vertex_count: int) -> bool: def dfs(v, visited, graph): # Depth First Search to mark the connected components stack = [v] while stack: node = stack.pop() if not visited[node]: visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: stack.append(neighbor) # Step 1: Check if all vertices are reachable from the first vertex visited = [False] * vertex_count dfs(0, visited, graph) # If any vertex is not visited, the graph is not strongly connected if not all(visited): return False # Step 2: Create the transpose of the graph transpose_graph = {i: [] for i in range(vertex_count)} for src in graph: for dest in graph[src]: transpose_graph[dest].append(src) # Step 3: Check if all vertices are reachable from the first vertex in the transposed graph visited = [False] * vertex_count dfs(0, visited, transpose_graph) # If any vertex is not visited in the transposed graph, the graph is not strongly connected return all(visited)"},{"question":"# Question **Expression Evaluation with Binary Operators** You are required to design a function that evaluates a string of digits by inserting binary operators \'+\', \'-\', or \'*\' between them to form expressions that evaluate to a given target value. You need to return all such valid expressions in a list format. Input - `num`: A string containing digits (\'0\'-\'9\') only, representing a non-empty sequence of digits. - `target`: An integer representing the target value which the expressions should evaluate to. Output - A list of strings, where each string is a valid expression that evaluates to the target value. Constraints - The length of `num` will be in the range [1, 10]. - The target value can be any integer. Performance Requirements - Your solution must efficiently handle all possible cases given the constraints. Example: 1. **Input**: `\\"123\\"`, 6 **Output**: `[\\"1+2+3\\", \\"1*2*3\\"]` 2. **Input**: `\\"232\\"`, 8 **Output**: `[\\"2*3+2\\", \\"2+3*2\\"]` 3. **Input**: `\\"105\\"`, 5 **Output**: `[\\"1*0+5\\",\\"10-5\\"]` 4. **Input**: `\\"00\\"`, 0 **Output**: `[\\"0+0\\", \\"0-0\\", \\"0*0\\"]` 5. **Input**: `\\"3456237490\\"`, 9191 **Output**: `[]` # Function Signature ```python def add_operators(num: str, target: int) -> List[str]: pass ``` You are to implement the function `add_operators()` that carries out the above specified requirements. The function should utilize efficient exploration techniques and consider possible edge cases as analyzed.","solution":"from typing import List def add_operators(num: str, target: int) -> List[str]: def backtrack(index, path, value, prev): if index == len(num): if value == target: result.append(path) return for i in range(index, len(num)): if i > index and num[index] == \'0\': break # skip numbers with leading zeroes n = num[index:i+1] curr = int(n) if index == 0: backtrack(i + 1, n, curr, curr) else: backtrack(i + 1, path + \\"+\\" + n, value + curr, curr) backtrack(i + 1, path + \\"-\\" + n, value - curr, -curr) backtrack(i + 1, path + \\"*\\" + n, value - prev + prev * curr, prev * curr) result = [] if num: backtrack(0, \\"\\", 0, 0) return result"},{"question":"You need to implement a function to simplify a polynomial. The function should combine like terms and provide the polynomial in its simplest form. Implement the function `simplify_polynomial(polynomial: Polynomial) -> Polynomial` which takes a Polynomial object and returns the simplified Polynomial object. # Function Signature: ```python def simplify_polynomial(polynomial: Polynomial) -> Polynomial: ``` # Requirements: 1. Combine all like terms in the polynomial. 2. Ensure the simplified polynomial does not contain any zero-coefficient monomials. 3. Handle various data types for coefficients (int, float, Fraction). # Input: - `polynomial` (Polynomial): A Polynomial object consisting of one or more Monomial objects. # Output: - `Polynomial`: A simplified version of the input polynomial. # Constraints: - The polynomial can have a large number of monomials. - Coefficient values might be very large or very small. # Example: ```python # Example input p = Polynomial([ Monomial({1:1}, 2), Monomial({2:3, 1:-1}, 1), Monomial({1:1}, 3), Monomial({}, 2.5) ]) # Example output simplified_p = simplify_polynomial(p) print(simplified_p) # output should be: Polynomial representation of \\"5(a_1) + (a_2)^3(a_1)^(-1) + 2.5\\" ``` # Notes: - You should not alter the structure of the existing classes. - The input polynomial and monomials can be created using the provided class definitions. - Use monomial and polynomial operations (i.e., addition, multiplication) to simplify the polynomial.","solution":"from fractions import Fraction from collections import defaultdict class Monomial: def __init__(self, variables, coefficient): self.variables = variables # dict: variable -> exponent self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __repr__(self): variables_str = \'\'.join(f\'({key}_{exp})\' for key, exp in self.variables.items()) return f\'{self.coefficient}{variables_str}\' class Polynomial: def __init__(self, monomials): self.monomials = monomials # list of Monomial objects def __eq__(self, other): if len(self.monomials) != len(other.monomials): return False for x, y in zip(self.monomials, other.monomials): if x != y: return False return True def __repr__(self): return \' + \'.join(str(m) for m in self.monomials) def simplify_polynomial(polynomial): monomial_map = defaultdict(Fraction) for monomial in polynomial.monomials: variables_key = frozenset(monomial.variables.items()) # immutable and hashable monomial_map[variables_key] += monomial.coefficient simplified_monomials = [Monomial(dict(variables_key), coeff) for variables_key, coeff in monomial_map.items() if coeff != 0] return Polynomial(simplified_monomials)"},{"question":"# Binary Search Tree Implementation and Operations Write a class `BinarySearchTree` that includes methods to insert, search, and delete nodes. Each node is represented by the provided `TreeNode` class. You are expected to implement the following methods: 1. **Insert** - **Function Signature**: `def insert(self, root: TreeNode, val: int) -> TreeNode` - **Description**: Insert a value into the BST. If the BST is empty, the value should become the root node. - **Input**: The root node of the BST (or None if the tree is empty), and the integer value to insert. - **Output**: The root node of the BST after insertion. 2. **Search** - **Function Signature**: `def search(self, root: TreeNode, val: int) -> bool` - **Description**: Search for a value in the BST. - **Input**: The root node of the BST, and the integer value to search for. - **Output**: Return True if the value exists in the BST, otherwise False. 3. **Delete** - **Function Signature**: `def deleteNode(self, root: TreeNode, val: int) -> TreeNode` - **Description**: Delete a value from the BST. Return the modified root. - **Input**: The root node of the BST, and the integer value to delete. - **Output**: The root node of the BST after the deletion. Consider the following constraints: - Values in the BST are unique. - The tree can initially be empty. Example: ```python bst = BinarySearchTree() root = None root = bst.insert(root, 10) root = bst.insert(root, 5) root = bst.insert(root, 15) assert bst.search(root, 10) == True assert bst.search(root, 7) == False root = bst.deleteNode(root, 10) assert bst.search(root, 10) == False ``` Ensure your implementation is efficient and handles edge cases appropriately.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def insert(self, root, val): if root is None: return TreeNode(val) if val < root.val: root.left = self.insert(root.left, val) else: root.right = self.insert(root.right, val) return root def search(self, root, val): if root is None: return False if root.val == val: return True elif val < root.val: return self.search(root.left, val) else: return self.search(root.right, val) def deleteNode(self, root, val): if root is None: return root if val < root.val: root.left = self.deleteNode(root.left, val) elif val > root.val: root.right = self.deleteNode(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self.findMin(root.right) root.val = temp.val root.right = self.deleteNode(root.right, temp.val) return root def findMin(self, root): current = root while current.left is not None: current = current.left return current"},{"question":"Efficient Prime Generation Task You are tasked with implementing an efficient function to generate all prime numbers less than a given integer `n` using an optimized version of the Sieve of Eratosthenes algorithm. Your function should return a list of primes below `n`. Requirements * Implement the function `generate_primes(n: int) -> List[int]` that: - Takes an integer `n` as input and returns a list of all prime numbers less than `n`. - Handles edge cases such as input values of `n <= 2` by returning an empty list. * Optimize space by not storing even numbers (apart from 2) in the sieve and directly adding 2 to the list of primes. * Ensure the function raises a `ValueError` for any negative or zero input. ```python def generate_primes(n: int) -> list: if n <= 0: raise ValueError(\\"\'n\' must be a positive integer.\\") if n <= 2: return [] sieve_size = (n // 2 - 1) if n % 2 == 0 else (n // 2) sieve = [True for _ in range(sieve_size)] primes = [2] if n > 2 else [] for i in range(sieve_size): if sieve[i]: prime = i*2 + 3 primes.append(prime) for j in range(i, sieve_size, prime): sieve[j] = False return primes ``` Input/Output * **Input**: - An integer `n` where `1 <= n <= 10^6`. * **Output**: - A list of prime numbers less than `n`. Performance Constraints * The algorithm should run in O(n log log n) time complexity. * The memory usage should be optimized to O(n) by using space-saving techniques, especially focusing on odd numbers. Testing Your Implementation Ensure that your implementation is thoroughly tested with: * Small values of `n` like 1, 2, 3, and 10. * Larger values up to 10^6 for performance assessment. * Proper handling of non-positive inputs.","solution":"def generate_primes(n: int) -> list: if n <= 0: raise ValueError(\\"\'n\' must be a positive integer.\\") if n < 2: return [] sieve_size = (n // 2) sieve = [True] * sieve_size primes = [2] if n > 2 else [] for i in range(1, sieve_size): if sieve[i]: prime = 2*i + 1 primes.append(prime) for j in range(i + prime, sieve_size, prime): sieve[j] = False return primes"},{"question":"# Question You are required to implement a function to determine if two given strings are anagrams. Two strings are considered anagrams if they can be rearranged to form one another, ignoring case and considering only alphabetic characters. Function Signature ```python def anagram(s1: str, s2: str) -> bool: pass ``` Input - `s1` (string): The first input string. - `s2` (string): The second input string. Output - Returns `True` if the two strings are anagrams, otherwise returns `False`. Constraints - The input strings will contain only printable ASCII characters. - The function should ignore casing and consider only alphabetic characters (ignoring any other characters). - Performance should be optimized with a time complexity of O(n). Requirements - You must count character frequencies and compare them. - Normalize the strings by converting them to lowercase and stripping out non-alphabet characters. # Example ```python assert anagram(\\"apple\\", \\"pleap\\") == True assert anagram(\\"apple\\", \\"cherry\\") == False assert anagram(\\"William Shakespeare\\", \\"I am a weakish speller\\") == True assert anagram(\\"Dormitory\\", \\"dirty room\\") == True assert anagram(\\"Astronomer\\", \\"Moon starer\\") == True assert anagram(\\"\\", \\"\\") == True assert anagram(\\"a\\", \\"A\\") == True assert anagram(\\"anagram\\", \\"nag a ram!\\") == True ``` # Notes - Ensure the function is case-insensitive. - Only alphabetic characters should be considered.","solution":"import collections import string def anagram(s1: str, s2: str) -> bool: Determine if two given strings are anagrams. Ignores case and non-alphabetic characters. # Normalize the strings: convert to lowercase and filter out non-alphabetic characters s1_normalized = \'\'.join(filter(str.isalpha, s1.lower())) s2_normalized = \'\'.join(filter(str.isalpha, s2.lower())) # Count character frequency for both strings counter1 = collections.Counter(s1_normalized) counter2 = collections.Counter(s2_normalized) # Compare the two frequency dictionaries return counter1 == counter2"},{"question":"# Coding Challenge: Advanced Quick Sort Implementation Scenario You are required to implement an optimized Quick Sort algorithm that improves upon the classical implementation by tackling some of its performance issues. Specifically, you should implement random pivot selection to minimize the likelihood of encountering the worst-case time complexity. Objective Write a function `optimized_quick_sort(arr)` that sorts an array of integers in ascending order using the Quick Sort algorithm with random pivot selection. Function Signature ```python def optimized_quick_sort(arr: List[int]) -> List[int]: ``` Input and Output * **Input**: A list of integers `arr` where (0 leq len(arr) leq 10^5). Each integer in `arr` will be in the range `[-10^9, 10^9]`. * **Output**: A list of integers sorted in non-decreasing order. Constraints * The function should efficiently handle large arrays up to the specified size limit. * You must use random pivot selection to reduce the chances of worst-case performance. Example ```python input: [3, 6, 8, 10, 1, 2, 1] output: [1, 1, 2, 3, 6, 8, 10] input: [1] output: [1] input: [] output: [] ``` Notes * Consider edge cases such as empty arrays, arrays with all identical elements, and already sorted arrays. * You are allowed to use the `random` library for random pivot selection. * Aim for a clear and efficient implementation.","solution":"import random from typing import List def optimized_quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def quick_sort(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort(arr, low, pi - 1) quick_sort(arr, pi + 1, high) def partition(arr, low, high): pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Context You are developing a file management script to handle paths dynamically. One of the common operations performed by your script is joining directory paths with file names. Given a directory path and a file name, your task is to construct a valid file path that joins the directory path and file name. # Task Write a function `construct_path(base, filename)` that takes in two strings: 1. `base`: a directory path that might end with a slash. 2. `filename`: a file name that might start with a slash. The function should return the correctly combined path with exactly one slash between the `base` and `filename`. # Input - `base`: a string representing the directory path (1 <= len(base) <= 1000) - `filename`: a string representing the file name (1 <= len(filename) <= 1000) # Output - A string representing the correctly combined file path. # Constraints - If `base` is empty, return `filename`. - If `filename` is empty, return `base`. - Do not allow two slashes to be present between the `base` and `filename`. - Ensure no leading or trailing slashes remain in the final path except in the combined part. # Examples 1. `construct_path(\\"path/to/dir/\\", \\"/file\\")` should return `\\"path/to/dir/file\\"` 2. `construct_path(\\"path/to/dir/\\", \\"file\\")` should return `\\"path/to/dir/file\\"` 3. `construct_path(\\"http://site.com/\\", \\"page\\")` should return `\\"http://site.com/page\\"` 4. `construct_path(\\"\\", \\"file\\")` should return `\\"file\\"` 5. `construct_path(\\"/folder\\", \\"\\")` should return `\\"/folder\\"` # Function Signature ```python def construct_path(base: str, filename: str) -> str: pass ``` # Testing Ensure your solution handles edge cases like empty strings, multiple slashes, and works correctly for both file paths and URLs.","solution":"def construct_path(base, filename): Constructs a valid file path by joining a directory path with a file name. # Strip trailing slash from base and leading slash from filename base = base.rstrip(\'/\') filename = filename.lstrip(\'/\') # Combine base and filename with a single slash between if base and filename: return f\\"{base}/{filename}\\" else: return base or filename"},{"question":"# Problem: Minimum Perfect Squares Sum **Context**: You are designing a basic budget application where users want to represent any monetary value using the least possible number of \\"square units.\\" For example, a square unit could be seen as 1, 4, 9, etc. Your task is to find out the minimum number of \\"square units\\" needed to reach a given number. **Objective**: Write a function `min_perfect_squares(number: int) -> int` that determines the minimum amount of perfect squares required to sum to the specified number. **Function Signature**: ```python def min_perfect_squares(number: int) -> int: pass ``` **Input**: * An integer `number (1 <= number <= 10^4)` representing the target number. **Output**: * An integer between 1 and 4, representing the minimal count of perfect squares that sum up to `number`. **Constraints**: 1. The input number is a positive integer. 2. Fast execution is preferred, ensuring solutions within acceptable time limits. **Performance Requirements**: * Efficient use of mathematical principles to minimize unnecessary computations is expected. * The solution must return the result within 1 second for the upper constraint limit. **Example**: ```python assert min_perfect_squares(9) == 1 # Explanation: 9 is 3^2 assert min_perfect_squares(10) == 2 # Explanation: 10 is 3^2 + 1^2 assert min_perfect_squares(12) == 3 # Explanation: 12 is 2^2 + 2^2 + 2^2 assert min_perfect_squares(31) == 4 # Explanation: 31 is 5^2 + 2^2 + 1^2 + 1^2 ``` Analyze the given problem, implement the function, and ensure to handle edge cases effectively. Do not use libraries or functions meant to solve the problem directly.","solution":"def min_perfect_squares(number: int) -> int: import math # The worst case is that the number is expressed as the sum of 1^2. dp = [float(\'inf\')] * (number + 1) dp[0] = 0 for i in range(1, number + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[number]"},{"question":"Problem Statement You are given a square matrix ( A ) of size ( n times n ). Implement a function `crout_matrix_decomposition(A)` that performs the Crout matrix decomposition on matrix ( A ). The function should return two matrices ( L ) and ( U ) such that ( L times U = A ). # Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: pass ``` # Input - A: A list of lists representing a square matrix of floats with dimensions ( n times n ) # Output - A tuple containing two lists of lists: - ( L ): The lower triangular matrix of dimensions ( n times n ) - ( U ): The upper triangular matrix of dimensions ( n times n ) # Constraints - The matrix ( A ) will have integer dimensions ( n ) in the range ( 1 leq n leq 100 ). - The elements of the matrix ( A ) will be floats and can be positive or negative. - You may assume that the matrix ( A ) can be decomposed without encountering a zero or nearly zero pivot element. # Example ```python A = [ [1.0, 2.0, 3.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0] ] L, U = crout_matrix_decomposition(A) print(\\"L:\\", L) print(\\"U:\\", U) ``` **Expected Output** ``` L: [[1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0]] U: [[1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0]] ``` # Notes - Your implementation should handle small values by substituting them with ( 0.1^{40} ) to avoid division by zero errors. - Ensure that any floating-point operations do not lose precision.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] # Initialize U to be identity matrix for i in range(n): U[i][i] = 1.0 for j in range(n): for i in range(j, n): sum_val = sum(L[i][k] * U[k][j] for k in range(j)) L[i][j] = A[i][j] - sum_val for i in range(j, n): if i == j: U[j][i] = 1.0 # Diagonal as 1 else: sum_val = sum(L[j][k] * U[k][i] for k in range(j)) if L[j][j] == 0.0: L[j][j] = 1e-40 # Substitution to avoid division by zero U[j][i] = (A[j][i] - sum_val) / L[j][j] return L, U"},{"question":"# Context You are a software developer tasked with implementing a simple text encryption technique. You decide to use the Atbash cipher, which is a simple substitution cipher. Each letter of the alphabet is mapped to its reverse counterpart, while non-alphabetic characters remain unchanged. # Problem Statement Write a function `atbash_cipher(input_string)` that takes a string `input_string` as input and returns the encrypted version using the Atbash cipher algorithm. # Function Signature ```python def atbash_cipher(input_string: str) -> str: ``` # Input * A string `input_string` (1 ≤ |input_string| ≤ 10^6), which can contain any printable ASCII characters. # Output * A string representing the Atbash ciphered text, preserving the case of each letter and leaving non-alphabetic characters unchanged. # Constraints * Non-alphabetic characters should remain unchanged in the encrypted string. * The function should efficiently handle strings up to length 10^6. # Examples ```python # Example 1 input_string = \\"Attack at dawn\\" # \\"A\\" ↔ \\"Z\\", \\"t\\" ↔ \\"g\\", \\"a\\" ↔ \\"z\\", \\"c\\" ↔ \\"x\\", \\"k\\" ↔ \\"p\\" # Result: \\"Zggzxp zg wzdm\\" print(atbash_cipher(input_string)) # \\"Zggzxp zg wzdm\\" # Example 2 input_string = \\"Hello, World!\\" # Result: \\"Svool, Dliow!\\" print(atbash_cipher(input_string)) # \\"Svool, Dliow!\\" # Example 3 input_string = \\"12345\\" # Non-alphabetic characters remain unchanged # Result: \\"12345\\" print(atbash_cipher(input_string)) # \\"12345\\" ``` Notes * Consider edge cases such as an empty string or a string with no alphabetic characters. * Ensure your solution is efficient and handles large input sizes within reasonable time constraints.","solution":"def atbash_cipher(input_string: str) -> str: def atbash_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) else: return c return \'\'.join(atbash_char(c) for c in input_string)"},{"question":"Encoding and Decoding a List of Strings **Context**: You are given a task to design an algorithm that can encode a list of strings into a single string which can then be transmitted over a network. Upon reception, it should be decoded back into the original list of strings maintaining their original order and content. Your implementation should handle special edge cases and be efficient in terms of performance. **Objective**: Implement the `encode` and `decode` functions that meet the input/output specifications below and handle the described constraints effectively. **Function Specifications**: 1. **encode()**: - **Input**: `List[str]` - A list of strings to encode. - **Output**: `str` - A single string encoding the input list. 2. **decode()**: - **Input**: `str` - A single encoded string. - **Output**: `List[str]` - The decoded list of strings. **Constraints**: - The input list of strings can contain up to (10^4) strings. - Each string can have up to (10^4) characters. - The characters in strings are ASCII characters. **Examples**: ```python # Example 1: input_strings = [\\"hello\\", \\"world\\"] encoded_string = encode(input_strings) print(encoded_string) # Output: \\"5:hello5:world\\" decoded_strings = decode(encoded_string) print(decoded_strings) # Output: [\\"hello\\", \\"world\\"] # Example 2: input_strings = [\\"abc\\", \\"defg\\", \\"\\"] encoded_string = encode(input_strings) print(encoded_string) # Output: \\"3:abc4:defg0:\\" decoded_strings = decode(encoded_string) print(decoded_strings) # Output: [\\"abc\\", \\"defg\\", \\"\\"] ``` **Performance Requirements**: - Ensure the encoding and decoding processes handle the upper limits efficiently. - Consider edge cases such as an empty list, very large strings, and presence of numerals or colons within the strings. **Task**: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your Code Here def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your Code Here ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_string = \'\' for s in strs: encoded_string += f\'{len(s)}:{s}\' return encoded_string def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_strings = [] i = 0 while i < len(s): # Find the delimiter \':\' to get the length of the next string j = s.find(\':\', i) length = int(s[i:j]) # The actual string starts after \':\' and extends `length` characters decoded_strings.append(s[j + 1:j + 1 + length]) # Move to the next encoded string part i = j + 1 + length return decoded_strings"},{"question":"You are required to implement a data structure `RandomizedCollection` that supports the following operations in average O(1) time: 1. `insert(val)`: Inserts a value `val` to the collection. Each value can appear multiple times. 2. `remove(val)`: Removes one occurrence of a value `val` from the collection if present. 3. `random_element()`: Returns a random element from the collection. Each element must have the same probability of being returned. # Input and Output - `insert(val)`: - **Input**: A value `val` to be inserted. - **Output**: True if the collection did not already contain `val`, otherwise False. - `remove(val)`: - **Input**: A value `val` to be removed. - **Output**: True if the collection contained `val`, otherwise False. - `random_element()`: - **Output**: A randomly selected element from the collection. # Constraints - Elements are non-negative integers. - Elements can be inserted multiple times. - There will be at least one call to `random_element()`. # Example Your `RandomizedCollection` class should be able to handle the following operations: ```python coll = RandomizedCollection() print(coll.insert(1)) # Output: True print(coll.insert(1)) # Output: False print(coll.insert(2)) # Output: True print(coll.remove(1)) # Output: True print(coll.random_element()) # Output: 1 or 2 print(coll.remove(1)) # Output: True print(coll.remove(2)) # Output: True print(coll.random_element()) # Output: (No elements, might raise error if empty) ``` # Function Signatures ```python class RandomizedCollection: def __init__(self): # Initialize your data structure here. # Add attributes to store elements and their indices. pass def insert(self, val: int) -> bool: # Inserts a value to the collection. Returns true if the collection # did not already contain the specified element. pass def remove(self, val: int) -> bool: # Removes a value from the collection. Returns true if the collection # contained the specified element. pass def random_element(self) -> int: # Get a random element from the collection. pass ```","solution":"import random from collections import defaultdict class RandomizedCollection: def __init__(self): self.values = [] self.indices = defaultdict(set) def insert(self, val: int) -> bool: self.indices[val].add(len(self.values)) self.values.append(val) return len(self.indices[val]) == 1 def remove(self, val: int) -> bool: if val not in self.indices or len(self.indices[val]) == 0: return False remove_index = self.indices[val].pop() last_value = self.values.pop() if remove_index != len(self.values): self.values[remove_index] = last_value self.indices[last_value].add(remove_index) self.indices[last_value].remove(len(self.values)) if len(self.indices[val]) == 0: del self.indices[val] return True def random_element(self) -> int: return random.choice(self.values)"},{"question":"Optimized Moving Average Calculation You are tasked with implementing an optimized moving average calculator for a stream of integers using a given window size. To optimize performance, especially for large window sizes, keep track of the running sum to avoid repeatedly calculating the total for the current window. # Task Implement the `OptimizedMovingAverage` class with the following features: 1. **Initialization**: - The class should be initialized with an integer `size`, representing the window size. 2. **next(val: int) -> float**: - Implement the `next` method that takes an integer `val` and returns the moving average of the last `size` elements in the stream. # Example ```python m = OptimizedMovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.67 print(m.next(5)) # Output: 6.0 ``` # Constraints - The window size `size` will be between 1 and 10000. - Elements added to the stream will be integers between (-10^4) and (10^4). - There will be at least one call to `next`. # Requirements - Your implementation should ensure (O(1)) insertion, deletion, and access times for maintaining the window and computing the moving average. - Please ensure your solution is optimized for large window sizes and high-frequency stream inputs.","solution":"from collections import deque class OptimizedMovingAverage: def __init__(self, size: int): Initialize your data structure here. self.size = size self.queue = deque() self.running_sum = 0 def next(self, val: int) -> float: self.queue.append(val) self.running_sum += val if len(self.queue) > self.size: self.running_sum -= self.queue.popleft() return self.running_sum / len(self.queue)"},{"question":"# Context Spell checkers are a common tool in text editors to help users identify and correct spelling mistakes. A critical component of a spell checker is to measure how close a given word is to the correctly spelled words in its dictionary. # Task Write a function `find_closest_word` that, given a list of correctly spelled words (dictionary) and a single misspelled word (query), returns the correctly spelled word with the minimum edit distance to the query word. # Function Signature `def find_closest_word(dictionary: List[str], query: str) -> str:` # Input - `dictionary` (List[str]): A list of n correctly spelled words. (1 <= n <= 1000, 1 <= length of any word <= 100) - `query` (str): A single misspelled word. (1 <= length of query <= 100) # Output - Returns the word from the dictionary with the smallest edit distance to the query word. # Constraints - If multiple words have the same minimum edit distance to the query, return the one that appears first in the dictionary. # Examples ```python assert find_closest_word([\\"food\\", \\"money\\", \\"mood\\", \\"hone\\"], \\"foond\\") == \\"food\\" assert find_closest_word([\\"spelling\\", \\"checker\\", \\"correct\\"], \\"cheker\\") == \\"checker\\" ``` # Requirements * Submissions must use the provided `edit_distance` function as a helper function to compute the distances. * Do not change the `edit_distance` function. * Optimize the solution for both clarity and performance. # Sample Implementation You can use the following implementation of the `edit_distance` function as provided: ```python def edit_distance(word_a, word_b): length_a, length_b = len(word_a) + 1, len(word_b) + 1 edit = [[0 for _ in range(length_b)] for _ in range(length_a)] for i in range(1, length_a): edit[i][0] = i for j in range(1, length_b): edit[0][j] = j for i in range(1, length_a): for j in range(1, length_b): cost = 0 if word_a[i - 1] == word_b[j - 1] else 1 edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost) return edit[-1][-1] ```","solution":"from typing import List def edit_distance(word_a, word_b): length_a, length_b = len(word_a) + 1, len(word_b) + 1 edit = [[0 for _ in range(length_b)] for _ in range(length_a)] for i in range(1, length_a): edit[i][0] = i for j in range(1, length_b): edit[0][j] = j for i in range(1, length_a): for j in range(1, length_b): cost = 0 if word_a[i - 1] == word_b[j - 1] else 1 edit[i][j] = min(edit[i - 1][j] + 1, edit[i][j - 1] + 1, edit[i - 1][j - 1] + cost) return edit[-1][-1] def find_closest_word(dictionary: List[str], query: str) -> str: min_distance = float(\'inf\') closest_word = \\"\\" for word in dictionary: distance = edit_distance(word, query) if distance < min_distance: min_distance = distance closest_word = word elif distance == min_distance: closest_word = closest_word if dictionary.index(closest_word) < dictionary.index(word) else word return closest_word"},{"question":"# Scenario: You are responsible for building an autocomplete feature for a search engine. You need to implement a data structure that can insert words into a dataset, search if a whole word is present in the dataset, and check if there are any words starting with a given prefix. The Trie data structure is ideal for this purpose. # Question: Implement a `class Trie` with the following methods: 1. **insert(self, word: str) -> None**: Inserts the word into the trie. 2. **search(self, word: str) -> bool**: Returns `True` if the word is in the trie, and `False` otherwise. 3. **starts_with(self, prefix: str) -> bool**: Returns `True` if there is any word in the trie that starts with the given prefix, otherwise returns `False`. # Input and Output Formats: - `insert(word: str)`: - **Input**: A single string `word` consisting of lowercase English letters `a-z`. - **Output**: None. - `search(word: str)`: - **Input**: A single string `word` consisting of lowercase English letters `a-z`. - **Output**: A boolean value `True` if the word is present in the Trie, otherwise `False`. - `starts_with(prefix: str)`: - **Input**: A single string `prefix` consisting of lowercase English letters `a-z`. - **Output**: A boolean value `True` if any word in the Trie starts with the given prefix, otherwise `False`. # Constraints: - All inputs are assumed to be valid lowercase English letters `a-z`. - Functionality does not need to handle spaces, punctuation, or upper case letters. **Performance Requirements**: - The implementation should efficiently handle insertion and search operations to allow real-time responses for a large number of inputs. ```python import collections # Complete the TrieNode class here class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False # Complete the Trie class here class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass # You can use the following lines to test your implementation. trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns False print(trie.starts_with(\\"app\\"))# Returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Returns True ```","solution":"import collections class TrieNode: def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: node = node.children[char] node.is_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Task: Synchronized Subsets Generation You have been hired as a backend developer at a company dealing with large datasets and complex combinatorial analyses. Your first task is to develop a module that generates all possible subsets of a given list of distinct integers. Your solution must avoid duplicate subsets and should handle large input sizes efficiently, within the constraints provided. Objective Write a function `generate_subsets(nums)` that takes a list of distinct integers and returns a set of all possible subsets represented as tuples. The subsets should be generated using bitwise operations. Function Signature ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int, ...]]: ``` Input * A single list of distinct integers, `nums`, where: - 0 <= len(nums) <= 20 - -10^6 <= nums[i] <= 10^6 Output * A set containing all possible subsets, each represented as a tuple of integers. Constraints * The function should run efficiently within the given constraints. * The order of subsets and elements within each subset does not matter. * You must use bitwise operations as the core mechanism for subset generation. Example *Example 1*: ```python nums = [1, 2, 3] generate_subsets(nums) ``` *Output*: ```python {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} ``` *Example 2*: ```python nums = [] generate_subsets(nums) ``` *Output*: ```python {()} ``` *Example 3*: ```python nums = [4] generate_subsets(nums) ``` *Output*: ```python {(), (4,)} ``` Performance Requirements * Ensure that the function performs within the time complexity of O(n * 2^n). * Mind the space complexity, considering the maximum input size. Note You are encouraged to validate your solution with various test cases, including edge cases.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int, ...]]: Generate all possible subsets of the given list of distinct integers using bitwise operations. Args: nums (List[int]): A list of distinct integers. Returns: Set[Tuple[int, ...]]: A set of all possible subsets represented as tuples. n = len(nums) subsets = set() # There are 2^n possible subsets for i in range(2 ** n): subset = [] for j in range(n): if i & (1 << j): subset.append(nums[j]) subsets.add(tuple(subset)) return subsets"},{"question":"You are required to implement a function that calculates the greatest common divisor (GCD) of an array of non-negative integers using two different algorithms: Euclid\'s Algorithm and Bitwise Operations. Additionally, you will need to compute the least common multiple (LCM) and the number of trailing zeroes of its binary representation. # Requirements **Function Name**: 1. `array_gcd_euclid(arr)` 2. `array_gcd_bitwise(arr)` 3. `array_lcm(arr)` 4. `trailing_zero(x)` **Input**: - `arr`: A list of non-negative integers (1 <= |arr| <= 10^6, 0 <= arr[i] <= 10^9). **Output**: - `array_gcd_euclid`: An integer representing the GCD of the array using Euclid\'s algorithm. - `array_gcd_bitwise`: An integer representing the GCD of the array using bitwise operations. - `array_lcm`: An integer representing the LCM of the array. - `trailing_zero`: An integer representing the number of trailing zeroes in the binary representation of the LCM. # Constraints - Ensure your solution is optimized for large inputs. - Handle edge cases effectively. # Example ```python arr = [24, 36, 48] # Using Euclid\'s Algorithm print(array_gcd_euclid(arr)) # Output: 12 # Using Bitwise Algorithm print(array_gcd_bitwise(arr)) # Output: 12 # LCM Calculation print(array_lcm(arr)) # Output: 144 # Trailing Zero Calculation print(trailing_zero(144)) # Output: 4 ``` # Implementation Guidelines `array_gcd_euclid(arr)` - Use Euclid\'s GCD algorithm iteratively for the entire array. `array_gcd_bitwise(arr)` - Use bitwise operations for each pair and reduce the array. `array_lcm(arr)` - Use the relationship between GCD and LCM to compute the LCM for the array. `trailing_zero(x)` - Implement the efficient bitwise method to count the trailing zeroes. # Performance Requirements - Your solution should be efficient in terms of both time and space complexity. - Ensure that the solution can handle the upper limits of the input constraints.","solution":"from functools import reduce from math import gcd def gcd_euclid(a, b): while b: a, b = b, a % b return a def gcd_bitwise(a, b): if a == 0: return b if b == 0: return a if a == b: return a if a & 1 == 0: # a is even if b & 1: # b is odd return gcd_bitwise(a >> 1, b) else: # both a and b are even return gcd_bitwise(a >> 1, b >> 1) << 1 if b & 1 == 0: # b is even, a is odd return gcd_bitwise(a, b >> 1) if a > b: return gcd_bitwise((a - b) >> 1, b) return gcd_bitwise((b - a) >> 1, a) def array_gcd_euclid(arr): return reduce(gcd_euclid, arr) def array_gcd_bitwise(arr): return reduce(gcd_bitwise, arr) def array_lcm(arr): def lcm(a, b): return (a * b) // gcd(a, b) return reduce(lcm, arr, 1) def trailing_zero(x): if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count"},{"question":"Implement and Optimize Radix Sort Context As an aspiring Data Scientist, you often deal with large datasets of numerical values, such as timestamps, customer IDs, or transaction amounts. Efficiently sorting these values is essential for tasks like data analysis, report generation, and improving search times. You are given the task to implement an optimized version of the radix sort algorithm tailored for handling large arrays of integers efficiently. Task You are required to implement the radix sort algorithm. Your implementation should handle large datasets efficiently and also account for negative integers. Additionally, it should support an optional “simulation” parameter that outputs intermediate sorting steps for educational/debugging purposes. Function Signature ```python def optimized_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts a list of integers using the radix sort algorithm. :param arr: List[int] - the list of integers to be sorted. :param simulation: bool - if set to True, intermediate steps are printed. :return: List[int] - the sorted list of integers. ``` Input - `arr`: A list of integers, which may include positive and negative values. - `simulation`: A boolean flag to indicate whether to print intermediate steps during sorting. Output - Returns the sorted list of integers. Constraints 1. The input list `arr` can contain up to (10^6) integers. 2. Each integer value can be in the range of ([-10^9, 10^9]). Performance Requirements - Your solution should run in O(nk) time where \'n\' is the number of elements and \'k\' is the number of digits in the largest absolute number. - Ensure that your solution handles negative values appropriately. Example ```python arr = [170, 45, 75, -90, 802, 24, 2, 66, -123, 45] print(optimized_radix_sort(arr, simulation=True)) # Intermediate steps should be printed if simulation=True # Output: [-123, -90, 2, 24, 45, 45, 66, 75, 170, 802] ```","solution":"from typing import List def optimized_radix_sort(arr: List[int], simulation: bool = False) -> List[int]: # Helper function to do counting sort based on the exponent value `exp` def counting_sort(arr, exp, simulation): n = len(arr) output = [0] * n count = [0] * 10 # Count occurrences of digits for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 # Update count to have the actual position of digits for i in range(1, 10): count[i] += count[i-1] # Build the output array using the count array for i in range(n-1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 # Copy the output array to arr, so that arr contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] if simulation: print(f\\"After sorting by exp {exp}: {arr}\\") # Main function to implement radix sort def radix_sort(arr, simulation): # Handle negative numbers by separating positive and negative numbers neg_arr = [-num for num in arr if num < 0] pos_arr = [num for num in arr if num >= 0] if neg_arr: max1 = max(neg_arr) exp = 1 while max1 // exp > 0: counting_sort(neg_arr, exp, simulation) exp *= 10 # Convert back to negative and reverse the sorted order neg_arr = [-num for num in neg_arr][::-1] if pos_arr: max2 = max(pos_arr) exp = 1 while max2 // exp > 0: counting_sort(pos_arr, exp, simulation) exp *= 10 # Merge negative and positive arrays arr[:] = neg_arr + pos_arr radix_sort(arr, simulation) return arr"},{"question":"Stack Sorted Check You are tasked with implementing a function that checks whether the elements of a stack are in ascending order from bottom to top. Background A stack follows a LIFO (Last In, First Out) principle. This means that the last element added to the stack will be the first one to be removed. Objective Write a function `is_sorted(stack)` that returns `True` if the elements in the stack are in strictly ascending order from bottom to top, and `False` otherwise. Function Signature ```python def is_sorted(stack): # Your code here ``` Input * `stack`: A list of integers representing the stack (you can assume it\'s not a stack data structure, but just a regular list). Output * A boolean `True` if the elements in the stack are sorted in ascending order from bottom to top, `False` otherwise. Constraints * You must use the stack operations (`pop` and `append`) in your implementation. * You cannot use any other data structures, such as lists or queues, except for a temporary stack as seen in the snippet. * You should maintain the original order of the stack after checking. Example ```python assert is_sorted([6, 3, 5, 1, 2, 4]) == False # Original stack: bottom [6, 3, 5, 1, 2, 4] top assert is_sorted([1, 2, 3, 4, 5, 6]) == True # Original stack: bottom [1, 2, 3, 4, 5, 6] top assert is_sorted([1]) == True # Single element assert is_sorted([]) == True # Empty stack assert is_sorted([1, 3, 5, 7, 2, 9]) == False # Not fully sorted ``` Performance Your solution should have a time complexity of O(n) and a space complexity of O(n), where n is the number of elements in the stack. Ensure that the original stack order is restored after the function execution. Notes Feel free to add any helper functions as needed. You may assume that the elements in the stack are all integers.","solution":"def is_sorted(stack): Determine if the stack is sorted in ascending order from bottom to top. if not stack: return True temp_stack = [] is_sorted = True # Transfer the original stack to a temporary stack and check order while stack: current = stack.pop() if temp_stack and temp_stack[-1] < current: is_sorted = False temp_stack.append(current) # Restore the original stack order while temp_stack: stack.append(temp_stack.pop()) return is_sorted"},{"question":"Context: You have been given a task to analyze and process a large set of integers. One of the required operations is to determine the number of digits of each integer in a quick and efficient manner. This information will be used in various places within the program, such as formatting output, validating input, and more. Task: Implement a function named `num_digits` that computes the number of decimal digits in the given integer number. Function Specification: ```python def num_digits(n: int) -> int: Calculate the number of decimal digits in the given integer. Parameters: n (int): The input integer (can be negative or positive). Returns: int: The number of decimal digits in the number. ``` Input: * A single integer `n` where `-10**18 ≤ n ≤ 10**18`. Output: * A single integer representing the number of decimal digits in the absolute value of the given integer. Constraints: * You cannot use string conversion methods (like `str()`), use purely mathematical operations. * Your implementation should run in O(1) time complexity. Example: ```python assert num_digits(100) == 3 assert num_digits(-4567) == 4 assert num_digits(0) == 1 assert num_digits(123456789123456789) == 18 ``` Notes: Consider potential edge cases, such as very large negative and positive numbers, as well as zero. Keep in mind performance and precision implications when dealing with floating-point operations.","solution":"def num_digits(n: int) -> int: Calculate the number of decimal digits in the given integer. Parameters: n (int): The input integer (can be negative or positive). Returns: int: The number of decimal digits in the number. if n == 0: return 1 count = 0 n = abs(n) while n > 0: n //= 10 count += 1 return count"},{"question":"Scenario: As part of a library management system, you are tasked to implement a feature that maintains a list of books. Due to frequent add and remove operations, you\'ve decided to use a doubly linked list for efficient insertions and deletions. Additionally, you need a feature to find and return a book based on its title. Task: Implement a function-based class `DoublyLinkedList` with the following methods: 1. `add_book(self, title: str) -> None`: - Adds a book with the given title to the end of the list. 2. `remove_book(self, title: str) -> bool`: - Removes the book with the given title from the list and returns `True` if the removal was successful, `False` if the book was not found. 3. `find_book(self, title: str) -> bool`: - Returns `True` if a book with the given title exists in the list, `False` otherwise. Constraints: * The title of a book will be a non-empty string of at most 100 characters. * It is guaranteed that no two books will have the same title. Example: ```python dll = DoublyLinkedList() dll.add_book(\\"The Great Gatsby\\") dll.add_book(\\"1984\\") dll.add_book(\\"To Kill a Mockingbird\\") print(dll.find_book(\\"1984\\")) # Output: True print(dll.remove_book(\\"1984\\")) # Output: True print(dll.find_book(\\"1984\\")) # Output: False ```","solution":"class DoublyLinkedList: class Node: def __init__(self, title, prev=None, next=None): self.title = title self.prev = prev self.next = next def __init__(self): self.head = None self.tail = None def add_book(self, title: str) -> None: new_node = self.Node(title) if not self.tail: # Empty list self.head = self.tail = new_node else: # Add to the end self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove_book(self, title: str) -> bool: current = self.head while current: if current.title == title: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return True current = current.next return False def find_book(self, title: str) -> bool: current = self.head while current: if current.title == title: return True current = current.next return False"},{"question":"You are tasked with optimizing and extending the functionality of a prime number checking function. The function should not only check if a given number is a prime but also return a list of all prime factors if the number is composite. This extension aims to encourage deeper comprehension of prime checking and factorization. Requirements 1. **Function Name**: `prime_check_extended` 2. **Input**: * An integer ( n ) (1 ≤ ( n ) ≤ 10^6) 3. **Output**: * If ( n ) is a prime, return a tuple with a Boolean `True` and an empty list. * If ( n ) is not a prime, return a tuple with a Boolean `False` and a list of all prime factors. 4. **Constraints**: * Your solution must be optimized to handle the upper limit efficiently. * Follow the core principles used in the given prime check algorithm. Example ```python prime_check_extended(29) # Expected Output: (True, []) prime_check_extended(30) # Expected Output: (False, [2, 3, 5]) ``` Notes - Ensure that the function runs efficiently up to the specified upper limit. - Consider edge cases like numbers less than 2 and small prime numbers.","solution":"def prime_check_extended(n): Checks if a number is prime, and if not, returns all prime factors. Args: n (int): The number to check. Returns: tuple: (is_prime (bool), prime_factors (list)) if n < 2: return (False, []) def is_prime(x): if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True def prime_factors(x): factors = [] # Take out the number of 2s that divide x while x % 2 == 0: if 2 not in factors: factors.append(2) x = x // 2 # x must be odd at this point so a skip of 2 is possible for i in range(3, int(x**0.5) + 1, 2): while x % i == 0: if i not in factors: factors.append(i) x = x // i if x > 2: factors.append(x) return factors if is_prime(n): return (True, []) else: return (False, prime_factors(n))"},{"question":"Scenario You have been tasked with writing a function to summarize ranges in an array of unique sorted integers. This function will be used to compress data for a telemetry system that periodically reads and transmits sparse data points. Your implementation will help reduce the amount of transmitted data by summarizing consecutive sequences into compact ranges. Task Write a function `summarize_ranges` that takes a list of sorted integers without duplicates and returns a list of strings summarizing consecutive ranges. Each element in the list should either represent a single number or a range in the format \\"start-end\\". Input * A sorted list of integers without duplicates (`List[int]`). Output * A list of strings summarizing consecutive ranges (`List[str]`). Function Signature ```python def summarize_ranges(array: List[int]) -> List[str]: pass ``` Constraints * The input list will have at most 10^5 elements. * Each integer will be within the range `[-10^9, 10^9]`. Example ```python assert summarize_ranges([0, 1, 2, 4, 5, 7]) == [\\"0-2\\", \\"4-5\\", \\"7\\"] assert summarize_ranges([0, 2, 3, 4, 6, 8, 9]) == [\\"0\\", \\"2-4\\", \\"6\\", \\"8-9\\"] assert summarize_ranges([]) == [] assert summarize_ranges([-1, 0, 1, 2, 6, 8, 9]) == [\\"-1-2\\", \\"6\\", \\"8-9\\"] ``` Requirements: * The function should be efficient in terms of time and space. * Handle edge cases such as single-element arrays or arrays with no consecutive elements.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] summarized = [] start = array[0] for i in range(1, len(array)): if array[i] != array[i-1] + 1: if start == array[i-1]: summarized.append(str(start)) else: summarized.append(f\\"{start}-{array[i-1]}\\") start = array[i] if start == array[-1]: summarized.append(str(start)) else: summarized.append(f\\"{start}-{array[-1]}\\") return summarized"},{"question":"**Scenario**: You are working on a geographical information system which represents the terrain as a binary tree. Each node in the tree corresponds to a specific point in the terrain, and the height of a node represents the elevation at that point. To provide important insights about the terrain, you need to compute the maximum depth of this binary tree. The maximum depth is defined as the longest path from the root node to any leaf node. **Task**: Write a Python function `max_depth(root: TreeNode) -> int` that computes the maximum depth of a binary tree. **Function Signature**: ```python def max_depth(root: TreeNode) -> int: ``` **Input**: * `root`: TreeNode - The root of the binary tree. **Output**: * `int` - The maximum depth of the binary tree. **Constraints**: * The number of nodes in the tree is in the range [0, 10^4]. * The value of each node\'s key is an integer. * The binary tree nodes are defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Example**: ```python # Example: # Given the binary tree: # 3 # / # 9 20 # / # 15 7 tree = TreeNode(3) tree.left = TreeNode(9) tree.right = TreeNode(20, TreeNode(15), TreeNode(7)) print(max_depth(tree)) # Output: 3 ``` **Explanation**: * The maximum depth is 3, as the longest path from the root to a leaf node includes nodes [3, 20, 15] or [3, 20, 7]. **Requirements**: * Implement the function efficiently to handle the upper limits of constraints. * Consider edge cases such as an empty tree (return 0) and trees with uneven branches.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Compute the maximum depth of a binary tree. if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"You are required to implement the Quick Sort algorithm to sort an array of integers. However, the provided implementation must accommodate very large inputs efficiently and avoid worst-case scenarios typically associated with poor pivot selection. # Requirements: 1. Implement an `optimized_quick_sort` function that includes random pivot selection. 2. The function should sort the array in place and return the sorted array. 3. Ensure that your implementation handles arrays with duplicate values effectively. # Constraints: - The array size can be up to 100,000 elements. - The array elements are integers within the range [-100,000, 100,000]. # Input Format: - A list `arr` containing integers. # Output Format: - A sorted list of integers. # Function Signature: ```python def optimized_quick_sort(arr: list) -> list: pass ``` # Example: ```python # Input arr = [3, 6, 8, 10, 1, 2, 1] # Expected Output [1, 1, 2, 3, 6, 8, 10] ```","solution":"import random def optimized_quick_sort(arr): Sorts an array in place using the Quick Sort algorithm with random pivot selection. Parameters: arr (list): List of integers to be sorted Returns: list: Sorted list of integers def partition(low, high): pivot_index = random.randint(low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] # move pivot to end store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] # move pivot to its final place return store_index def quick_sort_recursive(low, high): if low < high: pi = partition(low, high) quick_sort_recursive(low, pi - 1) quick_sort_recursive(pi + 1, high) quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"# Question: Implement and Enhance Stooge Sort Background Stooge Sort is an inefficient recursive sorting algorithm with very poor performance characteristics. Despite its impracticality for large data sets, it is a useful tool for educational purposes to understand recursive sorting techniques. Problem Statement You are required to implement the Stooge Sort algorithm and then modify it to improve its performance marginally by introducing certain early stopping conditions. Requirements 1. Implement the standard Stooge Sort function. 2. Enhance the function by adding early stopping conditions: * If at any point a segment of the array is already sorted, cease further recursion for that segment. * Use a helper function to check if a segment is sorted. Function Signature ```python def enhanced_stoogesort(arr: list, l: int, h: int) -> None: pass ``` Input * A list of integers `arr`. * Two integers `l` and `h` representing the start and end indices of the segment of the array to sort. Output * The function should sort the array in place and should not return any value. Constraints * The length of the input list will be between 0 and 100 inclusive. * Values in the list will be integers in the range from -10^5 to 10^5. Example ```python arr = [5, 3, 2, 4, 1] enhanced_stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5] ``` Notes * Ensure to handle edge cases such as empty arrays and single-element arrays. * Test your implementation thoroughly to confirm correctness.","solution":"def is_sorted(arr, l, h): Helper function to check if a segment of the array is sorted. for i in range(l, h): if arr[i] > arr[i + 1]: return False return True def enhanced_stoogesort(arr, l, h): Function to perform enhanced Stooge Sort on a segment of the array. if l >= h: return # Early stopping if the segment is already sorted if is_sorted(arr, l, h): return # Normal Stooge Sort algorithm if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 enhanced_stoogesort(arr, l, h - t) enhanced_stoogesort(arr, l + t, h) enhanced_stoogesort(arr, l, h - t) # Example usage arr = [5, 3, 2, 4, 1] enhanced_stoogesort(arr, 0, len(arr) - 1) print(arr) # Output: [1, 2, 3, 4, 5]"},{"question":"# Problem Scenario You are working on a software that processes DNA sequences, where one typical operation is to verify if one DNA sequence is a rotation of another. You decide to reuse your existing string rotation check function but want to extend its capabilities to improve performance for larger sequences. # Question Implement a function `is_rotation` which takes two strings `dna1` and `dna2` and determines if `dna2` is a rotation of `dna1`. Write this function with optimized time and space complexities. # Requirements - Do not use the brute force approach. - Consider non-trivial cases: empty strings, equal strings, and cases where lengths of the strings differ. - Assume input strings contain only valid DNA bases (A, C, G, T). # Function Signature ```python def is_rotation(dna1: str, dna2: str) -> bool: # Your code here pass ``` # Input - `dna1`: A string representing the first DNA sequence. (0 ≤ |dna1| ≤ 10^6) - `dna2`: A string representing the second DNA sequence. (0 ≤ |dna2| ≤ 10^6) # Output - Returns `True` if `dna2` is a rotation of `dna1`, otherwise returns `False`. # Constraints - The length of the strings could be up to 1 million characters. - Optimize for time (keep it linear if possible) and space (avoid excess memory use). # Examples ```python is_rotation(\\"ACGT\\", \\"GTAC\\") # returns True is_rotation(\\"ACGT\\", \\"TGCA\\") # returns False is_rotation(\\"GATTACA\\", \\"ACAGATT\\") # returns True is_rotation(\\"GATTACA\\", \\"ACAGTTA\\") # returns False is_rotation(\\"\\", \\"\\") # returns True is_rotation(\\"A\\", \\"\\") # returns False ``` # Explanation - Example 1: \\"GTAC\\" is a rotation of \\"ACGT\\" as it can be obtained by shifting \\"ACGT\\" by 2 places. - Example 2: \\"TGCA\\" is not a rotation of \\"ACGT\\" as no amount of shifting will match the strings. - Example 3: \\"ACAGATT\\" is a rotation of \\"GATTACA\\". - Example 4: Even though lengths match, \\"ACAGTTA\\" does not fit as any rotation of \\"GATTACA\\". - Example 5: Both empty strings trivially rotate to match. - Example 6: Rotation not possible since the lengths are different.","solution":"def is_rotation(dna1: str, dna2: str) -> bool: # Check if lengths are different if len(dna1) != len(dna2): return False # Check if both strings are empty if dna1 == \\"\\" and dna2 == \\"\\": return True # Create a new string by concatenating dna1 with itself dna1_concat = dna1 + dna1 # Check if dna2 is a substring of the concatenated string return dna2 in dna1_concat"},{"question":"# Coding Challenge **Context**: You are required to implement an efficient library for managing an ordered dataset using a B-tree to support insertion, deletion, and search operations in a way that ensures high performance, even for large datasets. This is particularly useful for scenarios such as managing a database index or filesystem directories. **Task**: Implement a `BTreeMap` class that adds key-value pairs and offers O(log n) average time complexity for search, insert, and delete operations. **Functional Requirements**: 1. **Insertion (`insert(key: int, value: any) -> None`)**: Insert the specified key-value pair into the B-tree. If the key already exists, update the value. 2. **Search (`search(key: int) -> any`)**: Search for the value associated with the key in the B-tree. Return `None` if the key is not found. 3. **Deletion (`delete(key: int) -> bool`)**: Remove the key-value pair from the B-tree. Return `True` if the key was successfully removed, `False` otherwise. **Input and Output Formats**: ```python class BTreeMap: def __init__(self, t: int): Initialize a BTreeMap with the given degree t (minimum degree must be 2). :param t: Minimum degree of the B-tree. ... def insert(self, key: int, value: any) -> None: Insert the key-value pair into the B-tree. If the key exists, update the value. :param key: The key to be inserted/updated. :param value: The value to be associated with the key. ... def search(self, key: int) -> any: Search for the value associated with the key. :param key: The key to search for. :return: The value associated with the key, or None if the key is not found. ... def delete(self, key: int) -> bool: Delete the key-value pair from the B-tree. :param key: The key to delete. :return: True if the key was successfully deleted, False otherwise. ... ``` **Constraints**: - Assume unique keys for this implementation. - You must use the given B-tree implementation as the backbone and adapt it to support key-value pairs. Write your implementation for the `BTreeMap` class.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys in the node self.children = [] # List of child nodes class BTreeMap: def __init__(self, t: int): Initialize a BTreeMap with the given degree t (minimum degree must be 2). :param t: Minimum degree of the B-tree. self.root = BTreeNode(t, True) self.t = t def search(self, key: int): Search for the value associated with the key in the B-tree. :param key: Key to be searched. :return: The value associated with the key, or None if the key is not found. return self._search(self.root, key) def _search(self, node, key): i = 0 while i < len(node.keys) and key > node.keys[i][0]: i += 1 if i < len(node.keys) and key == node.keys[i][0]: return node.keys[i][1] if node.leaf: return None return self._search(node.children[i], key) def insert(self, key: int, value: any) -> None: Insert the specified key-value pair into the B-tree. If the key already exists, update the value. :param key: Key to be inserted. :param value: Value to be associated with the key. root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t, False) temp.children.append(self.root) self._split_child(temp, 0) self._insert_non_full(temp, key, value) self.root = temp else: self._insert_non_full(root, key, value) def _insert_non_full(self, node, key, value): i = len(node.keys) - 1 if node.leaf: while i >= 0 and key < node.keys[i][0]: i -= 1 if i >= 0 and key == node.keys[i][0]: node.keys[i] = (key, value) else: node.keys.insert(i + 1, (key, value)) else: while i >= 0 and key < node.keys[i][0]: i -= 1 if i >= 0 and key == node.keys[i][0]: node.keys[i] = (key, value) else: if len(node.children[i + 1].keys) == (2 * self.t) - 1: self._split_child(node, i + 1) if key > node.keys[i + 1][0]: i += 1 self._insert_non_full(node.children[i + 1], key, value) def _split_child(self, parent, i): t = self.t node = parent.children[i] temp = BTreeNode(t, node.leaf) parent.keys.insert(i, node.keys[t - 1]) temp.keys = node.keys[t:(2 * t - 1)] node.keys = node.keys[0:(t - 1)] if not node.leaf: temp.children = node.children[t:(2 * t)] node.children = node.children[0:t] parent.children.insert(i + 1, temp) def delete(self, key: int) -> bool: Remove the key-value pair from the B-tree. Return True if the key was successfully removed, False otherwise. :param key: Key to be deleted. :return: True if key was successfully deleted, False otherwise. if self._delete(self.root, key): if len(self.root.keys) == 0: if self.root.leaf: self.root = None else: self.root = self.root.children[0] return True return False def _delete(self, node, key): t = self.t i = 0 while i < len(node.keys) and key > node.keys[i][0]: i += 1 if i < len(node.keys) and node.keys[i][0] == key: if node.leaf: node.keys.pop(i) return True else: if len(node.children[i].keys) >= t: predecessor_key, predecessor_val = self._get_predecessor(node, i) node.keys[i] = (predecessor_key, predecessor_val) return self._delete(node.children[i], predecessor_key) elif len(node.children[i + 1].keys) >= t: successor_key, successor_val = self._get_successor(node, i) node.keys[i] = (successor_key, successor_val) return self._delete(node.children[i + 1], successor_key) else: self._merge(node, i) return self._delete(node.children[i], key) elif node.leaf: return False else: if len(node.children[i].keys) == t - 1: if i != 0 and len(node.children[i - 1].keys) >= t: self._borrow_from_prev(node, i) elif i != len(node.keys) and len(node.children[i + 1].keys) >= t: self._borrow_from_next(node, i) else: if i != len(node.keys): self._merge(node, i) else: self._merge(node, i - 1) return self._delete(node.children[i], key) def _get_predecessor(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[len(current.keys)] return current.keys[len(current.keys) - 1] def _get_successor(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] for i in range(len(child.keys) - 1, -1, -1): child.keys.insert(i + 1, child.keys[i]) if not child.leaf: for i in range(len(child.children) - 1, -1, -1): child.children.insert(i + 1, child.children[i]) child.keys[0] = node.keys[idx - 1] if not child.leaf: child.children[0] = sibling.children.pop() node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) node.keys[idx] = sibling.keys.pop(0) if not sibling.leaf: child.children.append(sibling.children.pop(0)) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys.pop(idx)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(idx + 1)"},{"question":"# Ternary Search Application A popular online book retailer keeps a database of book IDs, sorted in ascending order. Customers can search for books using these unique IDs. The company currently employs a binary search algorithm, but they are interested in exploring ternary search for potential efficiency improvements. # Task Implement a function to locate the position of a given book ID in the sorted database using ternary search. If the book ID is not found, the function should return -1. # Function Signature ```python def find_book_id(book_ids: List[int], book_id: int) -> int: pass ``` # Input 1. `book_ids`: A list of integers representing the sorted book IDs (1 <= len(book_ids) <= 10^5). 2. `book_id`: An integer representing the book ID to be searched (book_id can be any integer). # Output - Return the index of the `book_id` if it exists in `book_ids`, and -1 otherwise. # Constraints - The input list `book_ids` is guaranteed to be sorted in ascending order. - Your solution must run in O(log base 3 N) time complexity. # Example ```python assert find_book_id([1, 2, 3, 4, 5, 6], 4) == 3 assert find_book_id([1, 2, 3, 4, 5, 6], 7) == -1 assert find_book_id([100, 200, 300, 400, 500], 100) == 0 assert find_book_id([100, 200, 300, 400, 500], 500) == 4 ``` # Notes - Ensure you handle edge cases where the list is empty or the book ID is not present within `book_ids`. - Take care of the indexing and avoid any off-by-one errors.","solution":"from typing import List def find_book_id(book_ids: List[int], book_id: int) -> int: Locate the position of a given book ID in the sorted database using ternary search. If the book ID is not found, return -1. def ternary_search(l, r, key, arr): if r >= l: mid1 = l + (r - l) // 3 mid2 = r - (r - l) // 3 if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: return ternary_search(l, mid1 - 1, key, arr) elif key > arr[mid2]: return ternary_search(mid2 + 1, r, key, arr) else: return ternary_search(mid1 + 1, mid2 - 1, key, arr) return -1 return ternary_search(0, len(book_ids) - 1, book_id, book_ids)"},{"question":"# Base Conversion Challenge You have been provided with two functions, `int_to_base` and `base_to_int`, that convert integers to different base representations and vice versa. Your task is to extend these functionalities with additional features and handle different edge cases. Objectives 1. Implement a function `base_converter` which combines the functionalities of both provided functions. 2. Your function should: - Convert an integer to its string representation in any given base (between 2 and 36). - Convert a base-represented string back to its decimal integer equivalent. # Implementation ```python def base_converter(value, base, convert_back=False): :type value: str or int :type base: int :type convert_back: bool :rtype: str or int pass ``` # Function Details - **Input Formats**: - `value`: - When `convert_back` is `False`: `value` is an `int` representing the decimal number to be converted to the specified `base`. - When `convert_back` is `True`: `value` is a `str` representing the base `base` number to be converted back to decimal. - `base`: An `int` representing the base (2 ≤ `base` ≤ 36). - `convert_back`: A boolean. If `True`, convert string in the base to integer. If `False`, convert integer to string in the specified base. - **Output**: - Returns a string if `convert_back` is `False`. - Returns an integer if `convert_back` is `True`. # Constraints: - Handle both negative and non-negative integers. - Ensure that the input string for conversion to integer is valid for the given base. # Examples ```python # Conversion from decimal (5) to binary assert base_converter(5, 2) == \'101\' # Conversion from binary (\'101\') to decimal assert base_converter(\'101\', 2, True) == 5 # Conversion from decimal (255) to hexadecimal assert base_converter(255, 16) == \'FF\' # Conversion from hexadecimal (\'FF\') to decimal assert base_converter(\'FF\', 16, True) == 255 ```","solution":"def int_to_base(n, base): Helper function to convert an integer to a given base. if n == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" negative = n < 0 n = abs(n) while n: result = digits[n % base] + result n //= base if negative: result = \\"-\\" + result return result def base_to_int(s, base): Helper function to convert a base string to an integer. digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" n = 0 negative = s[0] == \'-\' if negative: s = s[1:] for char in s: n = n * base + digits.index(char.upper()) return -n if negative else n def base_converter(value, base, convert_back=False): Convert an integer to its string representation in any given base (between 2 and 36). Convert a base-represented string back to its decimal integer equivalent. :type value: str or int :type base: int :type convert_back: bool :rtype: str or int if convert_back: return base_to_int(value, base) else: return int_to_base(value, base)"},{"question":"You are working on an image processing project and need to rotate square images represented by 2D matrices (n x n) by 90 degrees clockwise. Your task is to implement a function that performs this rotation. Function Signature ```python def rotate(mat: List[List[int]]) -> None: pass ``` Input * `mat` (List[List[int]]): A 2D list representing a square matrix of integers, n x n (where 1 ≤ n ≤ 1000). Output The function does not return anything; it should modify the input matrix in place. Constraints * The matrix is guaranteed to be a square (number of rows equals the number of columns). * You must perform the rotation in place with O(1) extra space. * The matrix can have any integer value, including negative numbers. Example ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate(mat) print(mat) # Output: [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` Notes * Consider edge cases where the matrix size is minimal (e.g., 1x1). * Ensure that your algorithm efficiently handles the upper constraint (n = 1000).","solution":"from typing import List def rotate(mat: List[List[int]]) -> None: Rotates a square matrix by 90 degrees clockwise in place. n = len(mat) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Step 2: Reverse each row for i in range(n): mat[i].reverse()"},{"question":"# Problem Description You are given the task to implement a Median Finder utilizing two binary heaps, a max heap, and a min heap. The goal is to efficiently add numbers and retrieve the median of the current set of numbers. # Specifications: * **Class Name**: `MedianFinder` * **Methods**: - `add_num(num: int) -> None`: Adds a number to the data structure. - `find_median() -> float`: Returns the median of the current set of numbers. # Implementation Details: 1. **Two Heaps**: - A max heap (`left_heap`) to store the smaller half of the numbers. - A min heap (`right_heap`) to store the larger half of the numbers. 2. **Balancing**: - Ensure the heaps have equal size or `left_heap` has one extra element. - If a new number is smaller than the max of `left_heap`, add to `left_heap`. Otherwise, add to `right_heap`. - Balance the heaps if their sizes differ by more than one. 3. **Finding the Median**: - If both heaps are of equal size, the median is the average of the top of both heaps. - If `left_heap` has one more element, the median is the top of `left_heap`. # Input and Output: * `add_num` will take one integer input. * `find_median` will return the median as a float. # Constraints: - You may assume `add_num` is called at most 5 * 10^4 times. - `find_median` will be called after at least one `add_num`. # Example: ```python # Example usage median_finder = MedianFinder() median_finder.add_num(1) median_finder.add_num(2) print(median_finder.find_median()) # Output: 1.5 median_finder.add_num(3) print(median_finder.find_median()) # Output: 2.0 ``` Provide the implementation of the `MedianFinder` class in Python. # Special Note: You can use Python\'s `heapq` module for maintaining the binary heaps. Remember to use negative values for `left_heap` to simulate the max heap with `heapq`.","solution":"import heapq class MedianFinder: def __init__(self): self.left_heap = [] # Max heap (simulated using negative values in a min-heap) self.right_heap = [] # Min heap def add_num(self, num: int) -> None: # Add to appropriate heap if not self.left_heap or num <= -self.left_heap[0]: heapq.heappush(self.left_heap, -num) else: heapq.heappush(self.right_heap, num) # Balance the heaps if necessary if len(self.left_heap) > len(self.right_heap) + 1: heapq.heappush(self.right_heap, -heapq.heappop(self.left_heap)) elif len(self.right_heap) > len(self.left_heap): heapq.heappush(self.left_heap, -heapq.heappop(self.right_heap)) def find_median(self) -> float: if len(self.left_heap) > len(self.right_heap): return -self.left_heap[0] else: return (-self.left_heap[0] + self.right_heap[0]) / 2.0"},{"question":"# Gnome Sort with Additional Constraints Context: You\'ve been recently hired as a software engineer and tasked to optimize a simple sorting algorithm for sorting arrays in a specialized system. You have decided to use Gnome Sort due to its simplicity and ease of implementation. However, you need to enhance it to handle certain edge cases efficiently and provide additional functionality. Problem Statement: Implement the `enhanced_gnome_sort` function that sorts an array using Gnome Sort but with the following additional constraints: 1. The function should include error handling to manage invalid input types (e.g., non-list inputs or lists with non-numeric elements). 2. The function should detect and handle sorted arrays early to optimize the performance by avoiding unnecessary comparisons and swaps. 3. The function should return an error message if the given array is too large (e.g., more than 1000 elements are not allowed due to system limitations). Function Signature: ```python def enhanced_gnome_sort(arr: list) -> list: pass ``` Input: - A list of integers, `arr`. Output: - A sorted list of integers, or an error message string if the input is invalid or the array size exceeds the limit. Constraints: - The input list may contain up to 1000 integers. - Assume integer elements fall within the range of -10000 to 10000. Example: ```python assert enhanced_gnome_sort([34, 2, 78, 1, 54]) == [1, 2, 34, 54, 78] assert enhanced_gnome_sort([]) == [] assert enhanced_gnome_sort(\'not a list\') == \\"Error: Input must be a list of integers.\\" assert enhanced_gnome_sort([5, 1, 1.5, 3]) == \\"Error: All elements must be integers.\\" assert enhanced_gnome_sort(list(range(1001))) == \\"Error: Array size exceeded limit.\\" ``` # Notes: * Your implementation should be robust to handle various edge cases mentioned. * Prioritize clarity and efficiency of your code in handling sorted arrays and input validation. * Think about the best way to detect if an array is already sorted to minimize processing time in such cases.","solution":"def enhanced_gnome_sort(arr): Sorts an array using Gnome Sort with additional constraints: 1. Handles invalid inputs. 2. Optimizes for already sorted arrays. 3. Limits the array size to 1000 elements. :param arr: list of integers :return: sorted list of integers or an error message string # Error handling for non-list input or list containing non-integer elements if not isinstance(arr, list): return \\"Error: Input must be a list of integers.\\" for element in arr: if not isinstance(element, int): return \\"Error: All elements must be integers.\\" # Check for array size limitation if len(arr) > 1000: return \\"Error: Array size exceeded limit.\\" # Early detection of sorted array is_sorted = all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) if is_sorted: return arr # Gnome Sort implementation index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Problem: Maximum Sliding Window Given an array `nums` and an integer `k`, there is a sliding window of size `k` which is moving from the beginning of the array to the end. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Write a function that returns the maximum sliding window as an array. # Function Signature ```python def max_sliding_window(nums: List[int], k: int) -> List[int]: pass ``` # Input * An integer array `nums` of length `n` where `1 <= n <= 10^5`. * An integer `k` where `1 <= k <= n`. # Output * An array of integers, representing the maximum value in each sliding window of size `k`. # Example ```python >>> max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] ``` # Constraints * The elements in the window cannot be re-ordered. * Your solution must run in O(n) time complexity. # Notes - You need to use a deque to keep track of the maximum values efficiently. - Make sure to handle edge cases, such as an empty array input or a window size of 1. # Scenario A stock market analyst needs a quick way to determine the maximum stock price in a moving window of 3 days to make timely trading decisions. This problem can be solved using your function.","solution":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: if not nums or k == 0: return [] deq = deque() result = [] for i in range(len(nums)): # Remove indexes from deque which are out of this window if deq and deq[0] == i - k: deq.popleft() # Remove indexes from deque which have smaller elements # than nums[i] because they are not useful while deq and nums[deq[-1]] < nums[i]: deq.pop() # Add current index at the back of the deque deq.append(i) # The window is valid; add the front element to result # because it\'s the maximum in the current window if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"# Problem Description You are given the head of a linked list. Write a function to determine if the linked list has a cycle in it. You must implement a cycle detection algorithm (Floyd\'s Tortoise and Hare) which requires no extra space beyond the pointers. # Implementation Details * Function Signature: `def is_cyclic(head: Node) -> bool` * Expected Input: `head` of type `Node`, representing the head node of a linked list. * Expected Output: A boolean value (`True` or `False`). # Constraints 1. The number of nodes in the list can be up to (10^4). 2. The values of nodes are arbitrary, and duplicate values are allowed. # Example Consider the following linked list where `a -> b -> c -> d -> b` (cycle to b): ``` a -> b -> c -> d ^ | |---------| ``` The function call `is_cyclic(a)` should return `True`. Another example is a list `1 -> 2 -> 3 -> 4 -> None`: The function call `is_cyclic(1)` should return `False`. # Hints - Use two pointers. - Avoid extra space usage. - Handle edge cases like empty lists and single-node linked lists.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def is_cyclic(head: Node) -> bool: Detects if a linked list has a cycle using Floyd\'s Tortoise and Hare algorithm. :param head: The head node of the linked list. :return: True if the linked list has a cycle, False otherwise. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Decompose a Positive Integer into Sums of Non-Negative Integers **Scenario** Imagine you are working on a combinatorial math problem where you need to determine the number of ways a given positive integer `n` can be decomposed into the sum of non-negative integers. This has applications in resource allocation problems, statistical partitioning, and even in understanding the structure of certain mathematical entities. **Task** Write a function `int_divide(decompose)` that takes a single positive integer `decompose` and returns the number of distinct ways this integer can be decomposed into the sum of non-negative integers. **Function Signature:** ```python def int_divide(decompose: int) -> int: ``` **Input** - `decompose` (int): A positive integer (1 ≤ decompose ≤ 200). **Output** - (int): Returns the number of distinct decompositions. **Constraints** - Ensure the function works efficiently within the given constraints. - You should handle edge cases properly, such as the smallest and largest values within the range. **Example Cases** ```python assert int_divide(4) == 5 # 4=4, 4=3+1, 4=2+2, 4=2+1+1, 4=1+1+1+1 assert int_divide(7) == 15 # 7=7, 7=6+1, 7=5+2, 7=5+1+1, 7=4+3, 7=4+2+1, etc. ``` **Explanation** - When `decompose` is 4, the possible decompositions are: {4}, {3+1}, {2+2}, {2+1+1}, {1+1+1+1}, which total 5. - When `decompose` is 7, the possible decompositions are listed in the code snippet and total 15. **Note**: Focus on dynamic programming approach to implement the solution efficiently.","solution":"def int_divide(n): Returns the number of distinct ways integer n can be decomposed into the sum of non-negative integers. dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Remove K Smallest Elements from a Stack Given a stack, write a function `remove_k_min(stack, k)` that removes the `k` smallest values from the stack. The function should modify the original stack in place and should not return a new stack. Input: * `stack`: A list of integers representing a stack. * `k`: An integer representing the number of smallest elements to remove. Output: * The modified `stack` without the `k` smallest elements. Constraints: * The stack will have a maximum of 10^4 elements. * The value of `k` will be less than or equal to the number of elements in the stack. * Each element in the stack is an integer in the range [-10^6, 10^6]. Example: ```python Example 1: Input: stack = [2, 8, 3, -6, 7, 3], k = 2 After remove_k_min(stack, k): Output: stack = [8, 7, 3] Explanation: - The 2 smallest elements (-6 and 2) are removed from the stack. - The remaining elements in the stack are [8, 3, 7, 3] initially. - After removing duplicates, the final stack is [8, 7, 3] Example 2: Input: stack = [1, 2, 3, 4, 5], k = 1 After remove_k_min(stack, k): Output: stack = [5, 4, 3, 2] Explanation: - The smallest element (1) is removed. - The remaining stack is [5, 4, 3, 2]. ``` Function signature: ```python def remove_k_min(stack, k): # Your code here ``` Notes: Think about the edge cases such as: - An empty stack - All identical elements - Multiple elements with the same value among the smallest `k`","solution":"def remove_k_min(stack, k): Removes the k smallest elements from the stack. if not stack or k <= 0: return # Find the k smallest elements sorted_stack = sorted(stack) k_smallest = sorted_stack[:k] # Remove the k smallest elements from the original stack for num in k_smallest: stack.remove(num)"},{"question":"# Invert a Matrix Introduction You are given a square matrix with n x n dimensions. Your task is to write a function to calculate the inverse of this matrix if it is invertible (i.e., has a non-zero determinant). Requirements Implement the function `invert_matrix(matrix)` that returns the inverted matrix. If the matrix is invalid or non-invertible, the function should return an appropriate error message or matrix with specific error codes. Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` Input and Output * **Input**: A list of lists where each inner list represents a row of the matrix. For example: ```python [[a11, a12, a13], [a21, a22, a23], [a31, a32, a33]] ``` * **Output**: A list of lists representing the inverted matrix, or: - `[[[-1]]]` if the input is not a matrix. - `[[[-2]]]` if the matrix is not square. - `[[[-3]]]` if the size of the matrix is less than 2. - `[[[-4]]]` if the matrix is singular (determinant = 0). Constraints * The matrix size is at least 2 x 2. * Elements of the matrix are floating-point numbers. * You should not use any external library functions for matrix inversion (e.g., from `numpy`). # Examples *Example 1:* ```python # Input matrix = [[4, 7], [2, 6]] # Expected Output [[0.6, -0.7], [-0.2, 0.4]] ``` *Example 2:* ```python # Input matrix = [[2, 3], [5, 7]] # Expected Output [[-7/1, 3/1], [5/1, -2/1]] ``` *Example 3:* ```python # Input matrix = [[0, 1], [1, 0]] # Expected Output [[0, 1], [1, 0]] ``` *Example 4: Invalid Input* ```python # Input matrix = [1, 2, 3] # Expected Output [[-1]] ``` *Example 5: Singular Matrix* ```python # Input matrix = [[1, 2], [2, 4]] # Expected Output [[-4]] ``` Notes * Consider matrix [[0, 0], [0, 0]] as singular because its determinant is zero. * For a 2x2 matrix, the inverse can be computed using a simplified cofactor method directly.","solution":"from typing import List def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: Returns the inverted matrix if invertible, or an error code matrix otherwise. Error codes: [[[-1]]] - Not a matrix [[[-2]]] - Matrix is not square [[[-3]]] - Matrix size is less than 2 [[[-4]]] - Matrix is singular (determinant = 0) # Helper function to calculate the determinant of a matrix def determinant(matrix): if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] # More complex determinant calculation for larger matrices can be added here return 0 # Placeholder for larger matrices # Helper function to find the inverse of a 2x2 matrix def inverse_2x2(matrix): det = determinant(matrix) if det == 0: return [[[-4]]] else: return [[matrix[1][1] / det, -matrix[0][1] / det], [-matrix[1][0] / det, matrix[0][0] / det]] # Check if input is a matrix (list of lists) if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[[-1]]] # Validate that the matrix is square n = len(matrix) if not all(len(row) == n for row in matrix): return [[[-2]]] # Validate matrix size (at least 2x2) if n < 2: return [[[-3]]] # Only handle 2x2 matrices for simplicity if n == 2: return inverse_2x2(matrix) # Placeholder for larger matrices inversion return None"},{"question":"You are required to implement a function to find the number of structurally unique Binary Search Trees (BSTs) that can be formed using `n` nodes labeled with integers `1` through `n`. # Function Signature ```python def num_trees(n: int) -> int: pass ``` # Input * A single integer `n` where `0 <= n <= 100`. # Output * Return the number of structurally unique BSTs that can be formed with `n` nodes. # Examples ```python # Example 1 n = 3 print(num_trees(n)) # Output: 5 # Example 2 n = 1 print(num_trees(n)) # Output: 1 # Example 3 n = 0 print(num_trees(n)) # Output: 1 ``` # Constraints * Ensure your solution efficiently handles the upper limit where `n` can be as large as 100. * Carefully handle edge cases such as `n = 0` and `n = 1`. # Hints * Use dynamic programming to avoid redundant calculations. * Follow the recurrence relationship for the Catalan number calculation tailored to this specific problem\'s context.","solution":"def num_trees(n: int) -> int: if n == 0 or n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n]"},{"question":"# Question Context Imagine you\'re working at a company managing network topology for distributed systems. One critical task involves verifying that the network does not contain any cycles, as they can cause severe routing issues. As part of this task, you need to determine if there are any cycles in the data link representing the network. Problem Statement You are given a singly linked list representing the network nodes. Each node has a unique identifier. Your task is to find the first node of the cycle if there is one. If no cycle exists, return `None`. Function Signature ```python def find_cycle_start_node(head: Node) -> Node: :param head: The head node of the linked list. :return: The node where the cycle starts, or None if there is no cycle. ``` Input * The input parameter `head` represents the head of a singly linked list. Output * The function should return the node where the cycle begins, or `None` if there is no cycle. Constraints * The list may contain up to 10^4 nodes. * The node identifiers are unique. Example ```python # Example: 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle starts at node with value 2) head = Node(1) head.next = Node(2) cycle_start = head.next head.next.next = Node(3) head.next.next.next = Node(4) head.next.next.next.next = Node(5) head.next.next.next.next.next = cycle_start assert find_cycle_start_node(head).val == 2 ``` Notes 1. Ensure that your solution detects the cycle accurately. 2. Consider edge cases such as empty lists or single-node lists without cycles. 3. Think about performance aspects to ensure your solution works within the provided constraints.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def find_cycle_start_node(head: Node) -> Node: Detects the start of the cycle in a singly linked list. :param head: The head node of the linked list. :return: The node where the cycle starts, or None if there is no cycle. if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd\'s cycle detection algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, now find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow return None"},{"question":"Enhanced Shell Sort Implementation Context Shell Sort is a generalization of insertion sort that allows the exchange of items that are far apart. The algorithm sorts elements by comparing them with each other at a certain gap and reduces this gap sequentially following a specific pattern until it reaches 1. Task Enhance the Shell Sort implementation using an improved gap sequence known for better performance. Implement the Shell Sort function using Pratt\'s sequence to efficiently sort a given list of integers. Requirements 1. **Function Signature**: ```python def pratt_shell_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: - `arr`: A list of integers, `arr`, where (2 leq text{len(arr)} leq 10^5) and (-10^9 leq text{arr}[i] leq 10^9). 3. **Output**: - The sorted list of integers. 4. **Constraints**: - Implement the shell sort using Pratt\'s sequence. - Aim for efficient sorting especially for larger sized lists. - The solution should handle edge cases where the list is already sorted, in reverse order, or contains many duplicate elements. 5. **Performance**: - Ensure the solution is optimized for time and space complexity, aiming to leverage the efficiency of Pratt\'s gap sequence. Implementation Notes - Pratt\'s sequence for gaps is defined by all products of powers of 2 and 3 (i.e., 1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 27, 32, ...). - Generate the Pratt sequence up to the maximum size of the list to use as the gap sequence. - Perform shell sort with the generated gaps. Example ```python assert pratt_shell_sort([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9] assert pratt_shell_sort([20, 35, -15, 7, 55, 1, -22]) == [-22, -15, 1, 7, 20, 35, 55] assert pratt_shell_sort([4, 3, 2, 1]) == [1, 2, 3, 4] ```","solution":"from typing import List def generate_pratt_sequence(n: int) -> List[int]: Generates Pratt\'s sequence up to the maximum value less than n. Pratt\'s gaps are all products of powers of 2 and 3. gaps = set() k = 1 while k < n: m = k while m < n: gaps.add(m) m *= 3 k *= 2 return sorted(gaps, reverse=True) def pratt_shell_sort(arr: List[int]) -> List[int]: Sorts the given list of integers using the Shell Sort algorithm with Pratt\'s gap sequence. n = len(arr) gaps = generate_pratt_sequence(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"**Question**: You are provided with a `Node` class which represents nodes in a binary tree and two functions that perform post-order traversal (left-right-root) of the tree: one using an iterative approach and the other using a recursive approach. Your task is to: 1. Implement an in-order traversal (left-root-right) function `inorder_iter` iteratively using explicit stack management. 2. Implement a pre-order traversal (root-left-right) function `preorder_rec` recursively. # Constraints - Assume the binary tree will not have duplicate values. - The number of nodes in the tree will not exceed 10^4. - Do not use global variables; maintain state within function scope. # Input/Output Specification 1. **inorder_iter**: - Input: `root` (the root node of the binary tree) - Output: A list of integers representing the values of the nodes in in-order traversal. 2. **preorder_rec**: - Input: `root` (the root node of the binary tree) - Output: A list of integers representing the values of the nodes in pre-order traversal. # Function Definitions ```python def inorder_iter(root: Node) -> List[int]: # Your code here def preorder_rec(root: Node, res: Optional[List[int]] = None) -> List[int]: # Your code here ``` # Example Consider the following Binary Tree: ``` 1 / 2 3 / 4 5 ``` - **Post-Order Traversal**: [4, 5, 2, 3, 1] - **Expected `inorder_iter(root)` Output**: [4, 2, 5, 1, 3] - **Expected `preorder_rec(root)` Output**: [1, 2, 4, 5, 3]","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_iter(root: Node): Perform an in-order traversal of the binary tree iteratively. result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.value) current = current.right return result def preorder_rec(root: Node, res=None): Perform a pre-order traversal of the binary tree recursively. if res is None: res = [] if root is not None: res.append(root.value) preorder_rec(root.left, res) preorder_rec(root.right, res) return res"},{"question":"# Digit Counting Function Problem Statement You need to implement a function that returns the number of digits in a given integer. Your task is to write a function `count_digits(n)` that accepts an integer `n` and returns the number of digits it has. Input * An integer `n` (can be positive, negative, or zero). Output * An integer representing the number of digits in `n`. Examples Example 1: ```plaintext Input: 123 Output: 3 ``` Example 2: ```plaintext Input: 0 Output: 1 ``` Example 3: ```plaintext Input: -456 Output: 3 ``` Constraints * The input integer can be any valid Python integer. * You should handle edge cases such as negative numbers and zero. * Your solution should have a time complexity of O(1). Additional Context To achieve this, you may use properties of logarithms or any other constant time operation. Consider edge cases such as very large integers that may challenge floating point precision. Function Signature ```python def count_digits(n: int) -> int: pass ```","solution":"def count_digits(n: int) -> int: Returns the number of digits in the integer n, handling positive, negative, and zero values. # Convert the number to its absolute value to handle negative numbers n = abs(n) # Count the number of digits by converting the number to a string and checking its length return len(str(n)) if n != 0 else 1"},{"question":"# RandomizedSet Data Structure Implement the modified `RandomizedSet` class to support the following operations: 1. **insert(val)**: Inserts a new item `val` to the set if not already present. Returns `True` if the item was inserted, and `False` otherwise. 2. **remove(val)**: Removes an existing item `val` from the set if present. Returns `True` if the item was removed, and `False` otherwise. 3. **get_random()**: Retrieves a random element from the current set of elements. All elements should have an equal probability of being selected. 4. **size()**: Returns the current number of elements in the set. # Constraints: - All operations should function in average O(1) time complexity. - The `size()` method should return the correct size of the elements in constant time. # Function Signature: ```python class RandomizedSet: def __init__(self): def insert(self, val: int) -> bool: def remove(self, val: int) -> bool: def get_random(self) -> int: def size(self) -> int: ``` # Example: ```python rs = RandomizedSet() print(rs.insert(1)) # Output: True print(rs.insert(2)) # Output: True print(rs.insert(1)) # Output: False print(rs.get_random()) # Output: could be either 1 or 2 print(rs.size()) # Output: 2 print(rs.remove(2)) # Output: True print(rs.size()) # Output: 1 print(rs.get_random()) # Output: 1 print(rs.remove(3)) # Output: False ``` # Points to Consider: - How would you ensure that `get_random` always operates in constant time? - Handle edge cases like inserting or removing non-existent elements properly. - Ensure that `size` reflects the accurate count of elements in constant time.","solution":"import random class RandomizedSet: def __init__(self): self.vals = [] self.val_idx = {} def insert(self, val: int) -> bool: if val in self.val_idx: return False self.val_idx[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: if val not in self.val_idx: return False index = self.val_idx[val] last_val = self.vals[-1] self.vals[index] = last_val self.val_idx[last_val] = index self.vals.pop() del self.val_idx[val] return True def get_random(self) -> int: return random.choice(self.vals) def size(self) -> int: return len(self.vals)"},{"question":"You are required to implement a function `reverse_words(string)` that takes a string as input and returns a new string with the order of the words reversed, while preserving individual words\' content. **Function Signature**: ```python def reverse_words(string: str) -> str: ``` # Input - A single string, `string`, containing a sentence (0 <= len(string) <= 10^5). # Output - Return a new string with the order of words reversed. # Constraints - The input string `string` may contain leading, trailing, or multiple spaces between words. - Words are defined as sequences of non-space characters. - Your implementation should handle edge cases gracefully (e.g., empty string, single-word string). # Example Example 1 ```python input: \\" I am keon kim and I like pizza \\" output: \\"pizza like I and kim keon am I\\" ``` Example 2 ```python input: \\"\\" output: \\"\\" ``` Example 3 ```python input: \\"Hello\\" output: \\"Hello\\" ``` # Explanation 1. String `\\" I am keon kim and I like pizza \\"` is first trimmed to `\\"I am keon kim and I like pizza\\"`. 2. It\'s split into words: `[\\"I\\", \\"am\\", \\"keon\\", \\"kim\\", \\"and\\", \\"I\\", \\"like\\", \\"pizza\\"]`. 3. Then the list of words is reversed to: `[\\"pizza\\", \\"like\\", \\"I\\", \\"and\\", \\"kim\\", \\"keon\\", \\"am\\", \\"I\\"]`. 4. Finally, the reversed list of words is joined into a string: `\\"pizza like I and kim keon am I\\"`. Make sure your solution is efficient and can handle very long strings up to 100,000 characters in length.","solution":"def reverse_words(string: str) -> str: Takes a string as input and returns a new string with the order of the words reversed, while preserving the content of individual words. # Split the string by spaces to get the words, filtering out any empty strings words = string.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space return \' \'.join(reversed_words)"},{"question":"Enhanced Exchange Sort with Custom Comparer You are given an implementation of the Exchange Sort algorithm. The algorithm has O(n^2) complexity and is used for small datasets due to its simplicity. Your task is to enhance the given Exchange Sort function to allow for custom sorting orders through a comparator function. This comparator function should dictate the order of sorting. # Requirements 1. Create a function `enhanced_exchange_sort(arr, comparator)` that sorts an array using a custom comparator function. 2. The comparator is a function that takes two arguments, `a` and `b`, and returns: - -1 if `a` should come before `b`, - 0 if `a` and `b` are equal, - 1 if `a` should come after `b`. 3. The enhanced function should maintain the O(n^2) time complexity. 4. Ensure that your function handles edge cases such as empty arrays, arrays with a single element, and arrays with all identical elements. Input * `arr`: List of elements to be sorted (0 <= len(arr) <= 10^3). * `comparator`: A function that defines the sort order. Output * The sorted list according to the custom comparator. # Constraints * The array can contain any comparable elements (integers, strings, etc.). * Duplicate values should maintain their order if the comparator declares them equal (stable sorting). # Example ```python # Define a comparator for ascending order def ascending_comparator(a, b): if a < b: return -1 elif a > b: return 1 else: return 0 # Define a comparator for descending order def descending_comparator(a, b): if a < b: return 1 elif a > b: return -1 else: return 0 arr = [4, 2, 5, 3, 1] print(enhanced_exchange_sort(arr, ascending_comparator)) # Output: [1, 2, 3, 4, 5] print(enhanced_exchange_sort(arr, descending_comparator)) # Output: [5, 4, 3, 2, 1] ``` Implement the function `enhanced_exchange_sort` based on the provided requirements and examples.","solution":"def enhanced_exchange_sort(arr, comparator): Sorts the array using a custom comparator. :param arr: List of elements to be sorted. :param comparator: Custom comparator function which defines the order. :return: Sorted list of elements. n = len(arr) for i in range(n): for j in range(i+1, n): if comparator(arr[i], arr[j]) > 0: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"**Implement a Disk-Based B-Tree** You are tasked with implementing a disk-based B-Tree to provide efficient storage and retrieval operations suited for large datasets typically found in databases or file systems. Your implementation must adhere to the B-Tree properties of balanced height and efficient insertions, deletions, and search operations. # Requirements 1. **Class Definition**: - Implement a `Node` class representing the B-Tree nodes. - Implement a `BTree` class that allows insertion, deletion, search, and traversal. 2. **Function Implementations**: - `insert_key(self, key)`: - Insert key into the B-Tree. - Handles node splitting if required. - `remove_key(self, key)`: - Remove the specified key from the B-Tree. - Handles node merging and rebalancing. - `find(self, key) -> bool`: - Return `True` if the key exists in the B-Tree, else `False`. - `traverse_tree(self)`: - Print the keys in the B-Tree in sorted order. # Input and Output Formats - **Insertion**: - Input: `BTree.insert_key(key: int)` - Output: None - **Deletion**: - Input: `BTree.remove_key(key: int)` - Output: None - **Search**: - Input: `BTree.find(key: int)` - Output: Boolean indicating the presence of the key. - **Traversal**: - Input: `BTree.traverse_tree()` - Output: Print the keys in a sorted order. # Constraints - `1 <= key <= 10^6` - The B-Tree degree (`t`) should be a configurable parameter set upon `BTree` initialization with a default of 2. # Example ```python btree = BTree(t_val=3) # Inserting keys btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) btree.traverse_tree() # Output: 5 6 7 10 12 17 20 30 # Searching keys print(btree.find(10)) # Output: True print(btree.find(15)) # Output: False # Removing keys btree.remove_key(10) btree.traverse_tree() # Output: 5 6 7 12 17 20 30 ``` Implement the `BTree` and `Node` classes to satisfy the requirements and pass the example scenarios.","solution":"class Node: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, false otherwise self.keys = [] # List of keys self.children = [] # List of child nodes class BTree: def __init__(self, t): self.t = t # Minimum degree self.root = Node(t, leaf=True) def traverse_tree(self): self._traverse(self.root) def _traverse(self, node): for i in range(len(node.keys)): if not node.leaf: self._traverse(node.children[i]) print(node.keys[i], end=\\" \\") if not node.leaf: self._traverse(node.children[len(node.keys)]) def find(self, k): return self._find(self.root, k) def _find(self, node, k): i = 0 while i < len(node.keys) and k > node.keys[i]: i += 1 if i < len(node.keys) and node.keys[i] == k: return True if node.leaf: return False return self._find(node.children[i], k) def insert_key(self, k): root = self.root if len(root.keys) == (2 * self.t) - 1: new_root = Node(self.t, leaf=False) new_root.children.append(self.root) self._split_child(new_root, 0) self.root = new_root self._insert_non_full(self.root, k) def _insert_non_full(self, node, k): i = len(node.keys) - 1 if node.leaf: node.keys.append(0) while i >= 0 and k < node.keys[i]: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = k else: while i >= 0 and k < node.keys[i]: i -= 1 i += 1 if len(node.children[i].keys) == (2 * self.t) - 1: self._split_child(node, i) if k > node.keys[i]: i += 1 self._insert_non_full(node.children[i], k) def _split_child(self, parent, i): t = self.t y = parent.children[i] z = Node(t, leaf=y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t) - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:2 * t] y.children = y.children[0:t] def remove_key(self, k): self._remove(self.root, k) if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] else: self.root = Node(self.t, leaf=True) def _remove(self, node, k): idx = self._find_key(node, k) if idx < len(node.keys) and node.keys[idx] == k: if node.leaf: node.keys.pop(idx) else: self._remove_internal_node(node, k, idx) else: if node.leaf: return flag = idx == len(node.keys) if len(node.children[idx].keys) < self.t: self._fill(node, idx) if flag and idx > len(node.keys): self._remove(node.children[idx - 1], k) else: self._remove(node.children[idx], k) def _remove_internal_node(self, node, k, idx): t = self.t if len(node.children[idx].keys) >= t: pred = self._get_predecessor(node, idx) node.keys[idx] = pred self._remove(node.children[idx], pred) elif len(node.children[idx + 1].keys) >= t: succ = self._get_successor(node, idx) node.keys[idx] = succ self._remove(node.children[idx + 1], succ) else: self._merge(node, idx) self._remove(node.children[idx], k) def _get_predecessor(self, node, idx): current = node.children[idx] while not current.leaf: current = current.children[-1] return current.keys[-1] def _get_successor(self, node, idx): current = node.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def _fill(self, node, idx): t = self.t if idx != 0 and len(node.children[idx - 1].keys) >= t: self._borrow_from_prev(node, idx) elif idx != len(node.keys) and len(node.children[idx + 1].keys) >= t: self._borrow_from_next(node, idx) else: if idx != len(node.keys): self._merge(node, idx) else: self._merge(node, idx - 1) def _borrow_from_prev(self, node, idx): child = node.children[idx] sibling = node.children[idx - 1] child.keys.insert(0, node.keys[idx - 1]) if not child.leaf: child.children.insert(0, sibling.children.pop()) node.keys[idx - 1] = sibling.keys.pop() def _borrow_from_next(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children.pop(0)) node.keys[idx] = sibling.keys.pop(0) def _merge(self, node, idx): child = node.children[idx] sibling = node.children[idx + 1] child.keys.append(node.keys.pop(idx)) child.keys.extend(sibling.keys) if not child.leaf: child.children.extend(sibling.children) node.children.pop(idx + 1) def _find_key(self, node, k): idx=0 while idx < len(node.keys) and node.keys[idx] < k: idx += 1 return idx"},{"question":"# Question **Title**: Implementing Optimized Run-Length Encoding & Decoding Context: Run-Length Encoding (RLE) has been popularly used for simple compression tasks due to its simplicity and efficiency in certain cases. Given an input stream of characters, RLE can compress the stream effectively if there are many repeated characters. Task: You are tasked to implement two functions: `encode_rle_optimized` for encoding and `decode_rle_optimized` for decoding, ensuring they handle various edge cases and performance optimizations efficiently. **Function Signatures**: ```python def encode_rle_optimized(input: str) -> str: pass def decode_rle_optimized(input: str) -> str: pass ``` Requirements: * **encode_rle_optimized**: - **Input**: A string consisting of any printable characters. - **Output**: A string representing the RLE compressed format of the input. * **decode_rle_optimized**: - **Input**: A string in valid RLE format. - **Output**: The original uncompressed string. Constraints: 1. The input strings can be very large, up to `10^6` characters. 2. The count of any character run in encoded string will not exceed `10^6`. Examples: ```python assert encode_rle_optimized(\\"aaabbbcc\\") == \\"3a3b2c\\" assert encode_rle_optimized(\\"abc\\") == \\"1a1b1c\\" assert encode_rle_optimized(\\"\\") == \\"\\" assert decode_rle_optimized(\\"3a3b2c\\") == \\"aaabbbcc\\" assert decode_rle_optimized(\\"1a1b1c\\") == \\"abc\\" assert decode_rle_optimized(\\"\\") == \\"\\" ``` Notes: * Always consider edge cases such as empty strings and strings with no repetitions. * Ensure your solution is optimized to handle large input sizes efficiently. * The encoded format for a single character `ch` appearing `k` times is \\"(k)ch\\".","solution":"def encode_rle_optimized(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 previous_char = input[0] for char in input[1:]: if char == previous_char: count += 1 else: encoded.append(f\\"{count}{previous_char}\\") previous_char = char count = 1 encoded.append(f\\"{count}{previous_char}\\") return \'\'.join(encoded) def decode_rle_optimized(input: str) -> str: if not input: return \\"\\" decoded = [] count_str = \\"\\" for char in input: if char.isdigit(): count_str += char else: count = int(count_str) decoded.append(char * count) count_str = \\"\\" return \'\'.join(decoded)"},{"question":"You are given a directed graph represented as an adjacency list. Write a function `detect_cycle` that determines if the graph contains any cycles. # Input - A dictionary `graph` where the keys are nodes and the values are lists of nodes representing directed edges from the key to nodes in the list. # Output - Return `True` if there is a cycle in the graph, `False` otherwise. # Constraints - The graph will have at most 10^3 nodes. - Each node will have at most 10^3 outgoing edges. - Nodes are represented by unique string identifiers. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle(graph)) # Output: True graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } print(detect_cycle(graph)) # Output: True graph = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] } print(detect_cycle(graph)) # Output: False ``` # Notes - Consider different edge cases, such as graphs with self-loops, disconnected components, and graphs with no vertices. - Pay attention to the time and space complexity of your solution, aiming to stay within a linear complexity boundary with respect to the number of edges and vertices.","solution":"def detect_cycle(graph): Detects if there is a cycle in a given directed graph. :param graph: A dictionary representing the adjacency list of a directed graph :return: True if there is a cycle in the graph, False otherwise visited = set() recursion_stack = set() def dfs(node): if node in recursion_stack: return True if node in visited: return False visited.add(node) recursion_stack.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True recursion_stack.remove(node) return False for node in graph: if dfs(node): return True return False"},{"question":"# AVL Tree Implementation Scenario You are hired as a software engineer to manage the database indexing of a library\'s management system. To ensure that the book records remain efficiently searchable, you adopt an AVL tree data structure. The AVL tree will maintain balance after every insertion to ensure fast search operations. # Tasks **1. Insert Operation** - Implement the `insert` function to add a new book ID into the AVL Tree, ensuring that the tree remains balanced after each insertion. **2. Rotate Right** - Implement the `rotate_right` function to perform a right rotation, which is a key operation to balance the tree. **3. Rotate Left** - Implement the `rotate_left` function to perform a left rotation, another key operation for rebalancing the tree. **4. In-order Traversal** - Implement the `in_order_traverse` function to return the list of book IDs in sorted order. # Function Definitions Insert Operation ```python def insert(self, key): Insert new key into node. key: int - The book ID to be inserted. ``` Rotate Right ```python def rotate_right(self): Right rotation of the subtree rooted at the current node. ``` Rotate Left ```python def rotate_left(self): Left rotation of the subtree rooted at the current node. ``` In-order Traversal ```python def in_order_traverse(self): Return the in-order traversal of the tree as a list of keys. Returns: List[int] - Sorted book IDs. ``` # Input/Output Examples - Inserting [45, 10, 55, 25, 50, 5]: - After each insertion, the AVL tree should remain balanced. - Performing in-order traversal after above insertions: - Expected Output: [5, 10, 25, 45, 50, 55] # Constraints 1. All book IDs are unique integers. 2. The tree should handle edge cases gracefully, such as inserting into an empty tree or balancing with only one node.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance_factor = self._get_balance(node) if balance_factor > 1: if key < node.left.key: return self._rotate_right(node) else: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance_factor < -1: if key > node.right.key: return self._rotate_left(node) else: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traverse(self): result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if not node: return self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"Context: You are tasked with implementing an algorithm to maximize the total value of items you can fit into your knapsack. Each item has a specific weight and value, and your goal is to determine the highest value combination of items without exceeding the knapsack capacity. Task: Implement the function `get_maximum_value(items: List[Item], capacity: int) -> int` to solve the knapsack problem using dynamic programming. 1. **Input**: * `items`: List of `Item` objects, where each `Item` has two attributes: * `value (int)`: The value of the item. * `weight (int)`: The weight of the item. * `capacity (int)`: An integer representing the maximum weight the knapsack can carry. 2. **Output**: * Return the maximum summarized value of the items that can be fit in the knapsack. Constraints: * `1 <= len(items) <= 1000` * `1 <= capacity <= 1000` * `0 <= value, weight <= 1000` # Example ```python class Item: def __init__(self, value, weight): self.value = value self.weight = weight items = [Item(60, 5), Item(50, 3), Item(70, 4), Item(30, 2)] capacity = 5 print(get_maximum_value(items, capacity)) # Output: 80 (items valued 50 and 30 can both be fit in the knapsack) ``` # Performance Requirements * The algorithm should have an approximate time complexity of O(n * m) and a space complexity of O(m), where n is the number of items and m is the capacity of the knapsack.","solution":"from typing import List class Item: def __init__(self, value, weight): self.value = value self.weight = weight def get_maximum_value(items: List[Item], capacity: int) -> int: # Initialize a list to keep track of the maximum value at each capacity dp = [0] * (capacity + 1) # Iterate through each item for item in items: # Iterate through all capacities from highest to lowest for w in range(capacity, item.weight - 1, -1): # Update the dp list if the current item is included dp[w] = max(dp[w], dp[w - item.weight] + item.value) return dp[capacity]"},{"question":"# Minimal Bits Flip Conversion **Scenario**: You are working on optimizing a low-level network protocol and need to determine the minimal number of bit flips required to convert one integer to another. This is particularly useful when detecting and correcting errors in data transmission over unreliable networks. **Task**: Write a function `min_bits_flip_conversion(a: int, b: int) -> int` that computes the number of bits required to flip to convert integer `a` to integer `b`. Input * `a` and `b` are non-negative integers where `0 <= a, b <= 2^31 - 1`. Output * Return a single integer which is the number of bits that need to be flipped. Constraints * Optimize your algorithm to handle large inputs efficiently. * Avoid using pre-built functions for bit counting. Example ```plaintext Input: 29, 15 Output: 2 Explanation: Binary of 29: 11101 Binary of 15: 01111 Number of different bits: 2 (positions 10 and 100) ``` Notes * Ensure your function handles the edge case where `a` and `b` are the same, which should return zero flips. * Validate that the input values meet the given constraints. * Time complexity needs to be linear relative to the size of the integer in bits.","solution":"def min_bits_flip_conversion(a: int, b: int) -> int: Computes the number of bits required to flip to convert integer a to integer b. Parameters: a (int): First integer b (int): Second integer Returns: int: Number of bits to flip xor_result = a ^ b count = 0 while xor_result: count += xor_result & 1 xor_result >>= 1 return count"},{"question":"# Problem Description You are given an array that may contain nested arrays. Your task is to write a function `flatten_array` that flattens this array into a single-dimensional array, preserving the order of elements. The function should handle nested arrays of arbitrary depth and should be implemented using recursion. # Implementation Details Function Signature ```python def flatten_array(input_arr: list) -> list: pass ``` # Expected Input and Output * **Input**: A list `input_arr` which may contain nested lists of arbitrary depth. * **Output**: A single-dimensional list containing all the elements from the nested structure, in the same order. # Constraints 1. The elements in the arrays can be of any type, but should not include Python\'s `None`. 2. Arrays may be empty. 3. Strings in the array should be treated as atomic elements (i.e., they should not be flattened). Example ```python assert flatten_array([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_array([\'a\', [\'b\', [\'c\']], [\'d\']]) == [\'a\', \'b\', \'c\', \'d\'] assert flatten_array([[], [1, [2, [3]]]]) == [1, 2, 3] assert flatten_array([10, [20], [[30]]]) == [10, 20, 30] assert flatten_array([1, \'string\', [2, [\'another\', [3, \'nested\']] ] ]) == [1, \'string\', 2, \'another\', 3, \'nested\'] ``` # Important Considerations * The recursion depth must be manageable within typical Python recursion limits. * Handle deeply nested arrays efficiently without causing stack overflow. * Strings should be handled properly and not treated as iterables for flattening.","solution":"def flatten_array(input_arr: list) -> list: Flattens an array containing nested arrays into a single-dimensional array. Parameters: - input_arr (list): The nested array to flatten. Returns: - list: A flat array with all elements from the nested structure, in same order. def flatten_helper(arr, result): for elem in arr: if isinstance(elem, list): flatten_helper(elem, result) else: result.append(elem) result = [] flatten_helper(input_arr, result) return result"},{"question":"**Objective**: Implement a matrix transformation function incorporating the core principles from the provided snippets. Your task is to write a function `transform_matrix(matrix, transformation_type)` that performs a specified transformation on a 2D matrix. The function will take a matrix and a string `transformation_type` indicating the type of transformation to perform. **Input**: * `matrix`: A 2D list of integers representing the matrix. * `transformation_type`: A string specifying one of the following transformations: * `\\"clockwise\\"` - Rotate the matrix 90 degrees clockwise. * `\\"counterclockwise\\"` - Rotate the matrix 90 degrees counterclockwise. * `\\"top_left_invert\\"` - Invert the matrix along the main diagonal. * `\\"bottom_left_invert\\"` - Invert the matrix along the anti-diagonal. **Output**: * A new 2D list of integers representing the transformed matrix. **Constraints**: * The input matrix will be a valid 2D list of integers with dimensions ( m times n ) where ( 1 leq m, n leq 100 ). # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] assert transform_matrix(matrix, \\"clockwise\\") == [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] assert transform_matrix(matrix, \\"counterclockwise\\") == [ [3, 6, 9], [2, 5, 8], [1, 4, 7], ] assert transform_matrix(matrix, \\"top_left_invert\\") == [ [1, 4, 7], [2, 5, 8], [3, 6, 9], ] assert transform_matrix(matrix, \\"bottom_left_invert\\") == [ [9, 6, 3], [8, 5, 2], [7, 4, 1], ] ``` **Function Signature**: ```python def transform_matrix(matrix, transformation_type): # Your code here ``` Implement the `transform_matrix` function to pass the above tests.","solution":"def transform_matrix(matrix, transformation_type): Transforms the given matrix based on the specified transformation type. :param matrix: A 2D list of integers representing the matrix. :param transformation_type: A string specifying the transformation type. :return: A new 2D list of integers representing the transformed matrix. if transformation_type == \\"clockwise\\": return [list(row) for row in zip(*matrix[::-1])] elif transformation_type == \\"counterclockwise\\": return [list(row) for row in zip(*matrix)][::-1] elif transformation_type == \\"top_left_invert\\": return [list(row) for row in zip(*matrix)] elif transformation_type == \\"bottom_left_invert\\": return [list(row) for row in zip(*matrix[::-1])][::-1] else: raise ValueError(\\"Invalid transformation type provided\\")"},{"question":"# Question: Postorder Traversal with Error Handling and Enhancement Context: You are given the task of enhancing and ensuring the robustness of a postorder traversal algorithm for a binary tree. The traditional postorder traversal algorithm involves visiting the left subtree, then the right subtree, and finally the root node. However, it\'s important to handle edge cases and optimize performance while ensuring the correctness of the traversal process. Task: Implement a function to perform postorder traversal on a binary tree. Your function should account for the following: * **Edge Case Handling**: Handle an empty tree and trees with only a single node. * **Performance Optimization**: Reduce memory usage while maintaining clarity. * **Error Handling**: Provide meaningful error messages if the input is invalid. Function Signature: ```python def enhanced_postorder_traversal(root: Node) -> List[int]: ``` Input: * `root`: The root node of the binary tree which is an instance of class `Node`. Output: * A list of node values in postorder traversal. Constraints: 1. Node values will be integers. 2. Tree may be unbalanced. 3. Tree can contain any number of nodes (including zero). Example: ```python # Assuming Node class is available as: # class Node: # def __init__(self, val, left=None, right=None): # self.val = val # self.left = left # self.right = right # Example Tree: # 1 # / # 2 3 # / # 4 5 root = Node(1, Node(2, Node(4), Node(5)), Node(3)) assert enhanced_postorder_traversal(root) == [4, 5, 2, 3, 1] # Edge Case: root = None assert enhanced_postorder_traversal(root) == [] ``` Performance Requirements: * Ensure the function runs in O(n) time complexity where n is the number of nodes. * Optimize to use O(h) space, where h is the height of the tree, for the iterative version.","solution":"from typing import List, Optional class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def enhanced_postorder_traversal(root: Optional[Node]) -> List[int]: Perform a postorder traversal of a binary tree. Traverse the left subtree, then the right subtree, and finally the root node. if not isinstance(root, (Node, type(None))): raise ValueError(\\"Input must be a Node or None.\\") if root is None: return [] result = [] stack = [(root, False)] while stack: node, visited = stack.pop() if node: if visited: result.append(node.val) else: stack.append((node, True)) if node.right: stack.append((node.right, False)) if node.left: stack.append((node.left, False)) return result"},{"question":"Secure Data Transmission A secure data transmission system uses a technique that involves calculating large powers of integers and then reducing the result modulo a large prime number. One key aspect of the system is computing ((base^{exponent}) mod mod) efficiently. Your task is to implement the modular exponentiation function. Function Signature ```python def modular_exponential(base: int, exponent: int, mod: int) -> int: Computes (base ^ exponent) % mod. Parameters: - base (int): The base value. - exponent (int): The exponent value, must be non-negative. - mod (int): The modulus value, must be positive. Returns: - int: The computed result. ``` Input and Output Formats * **Input**: * An integer `base`, the base of the exponentiation. * A non-negative integer `exponent`, the power to which the base is raised. * A positive integer `mod`, the modulus value. * **Output**: * Returns the result of ((base^{exponent}) mod mod). Constraints * (0 leq base leq 10^9) * (0 leq exponent leq 10^9) * (1 leq mod leq 10^9) Examples # Example 1: **Input**: ```python base = 2 exponent = 10 mod = 1000 ``` **Output**: ```python 24 ``` **Explanation**: (2^{10} = 1024 Rightarrow 1024 mod 1000 = 24) # Example 2: **Input**: ```python base = 10 exponent = 0 mod = 17 ``` **Output**: ```python 1 ``` **Explanation**: Any number to the power of 0 is 1. # Additional Notes: * Avoid using Python\'s built-in power function for this task, implement the logic from scratch. * Ensure the algorithm efficiently handles very large inputs for `base`, `exponent`, and `mod`. * Throw a `ValueError` if the provided `exponent` is negative.","solution":"def modular_exponential(base: int, exponent: int, mod: int) -> int: Computes (base ^ exponent) % mod. Parameters: - base (int): The base value. - exponent (int): The exponent value, must be non-negative. - mod (int): The modulus value, must be positive. Returns: - int: The computed result. if exponent < 0: raise ValueError(\\"Exponent must be non-negative\\") if mod <= 0: raise ValueError(\\"Modulus must be positive\\") result = 1 base = base % mod # Update base if it\'s greater than or equal to mod while exponent > 0: # If exponent is odd, multiply the base with result if exponent % 2 == 1: result = (result * base) % mod # Now exponent must be even exponent = exponent >> 1 # Divide the exponent by 2 base = (base * base) % mod # Square the base and reduce modulo mod return result"},{"question":"Context You are working on a tech project involving family trees and you need to compute all possible paths from the patriarch (root) of the family tree to each of its members (leaves), documenting these paths in a readable format. Task Write a function `binary_tree_paths` that takes the root of a binary tree and returns all paths from the root to each leaf. Requirements * Define the `TreeNode` class for binary tree structure. * Write a `dfs` (depth-first search) helper method to assist in constructing paths. * Use recursion effectively to build paths from the root to each leaf. * Collect all paths in a list of strings where each path is represented by node values separated by arrows \\"->\\". Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> List[str]: pass ``` Input * `root`: The root node of the binary tree (type: `TreeNode`). It may be `None` for an empty tree. Output * Return a list of strings, where each string represents a path from the root to a leaf. Constraints * The number of nodes in the tree is in the range [0, 100]. * -100 <= Node value <= 100 Examples ```python # Example 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) output = binary_tree_paths(root) # Output: [\\"1->2->5\\", \\"1->3\\"] # Example 2 root = TreeNode(1) output = binary_tree_paths(root) # Output: [\\"1\\"] ``` Implement the function `binary_tree_paths` to solve the problem described above.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: TreeNode): if not root: return [] paths = [] def dfs(node, path): if node: path += str(node.val) if not node.left and not node.right: # Leaf node paths.append(path) else: path += \\"->\\" if node.left: dfs(node.left, path) if node.right: dfs(node.right, path) dfs(root, \\"\\") return paths"},{"question":"Context You are developing software for a school that needs to sort student grades efficiently. Student grades range from -100 to 100. The existing sorting algorithms take too long due to the large number of students. Therefore, you have decided to implement a more efficient sorting algorithm considering the limited range of the grades. Objective Write a function `efficient_grade_sort` that takes a list of integers representing student grades, potentially including both negative and positive values, and returns a sorted list. You must use Counting Sort to achieve this. Input * A list of integers `grades` where each integer is between -100 and 100, inclusive. Output * A list of integers sorted in non-decreasing order. Constraints * The number of grades will not exceed 10^5. * Each grade is an integer within the range -100 to 100. * Aim for a time complexity of O(n) and space complexity of O(k), where n is the number of grades and k is the range of grades. Performance Requirements * The algorithm should sort the grades in linear time O(n). * The implementation should handle negative and positive grades correctly. Example ```python Input: [95, -50, 0, 64, -100, 100, 50, -20] Output: [-100, -50, -20, 0, 50, 64, 95, 100] ``` Implementation ```python def efficient_grade_sort(grades): Sort a list of student grades using counting sort. :param grades: List[int]: A list of integer grades ranging from -100 to 100. :return: List[int]: A sorted list of grades. # Initialize counting array offset = 100 # since grades are from -100 to 100 count = [0] * (201) # total range of 201 (100 - (-100) + 1) # Count each grade for grade in grades: count[grade + offset] += 1 # Generate sorted list sorted_grades = [] for i in range(201): while count[i] > 0: sorted_grades.append(i - offset) count[i] -= 1 return sorted_grades # Example usage grades = [95, -50, 0, 64, -100, 100, 50, -20] print(efficient_grade_sort(grades)) # Output: [-100, -50, -20, 0, 50, 64, 95, 100] ```","solution":"def efficient_grade_sort(grades): Sort a list of student grades using counting sort. :param grades: List[int]: A list of integer grades ranging from -100 to 100. :return: List[int]: A sorted list of grades. # Initialize counting array offset = 100 # since grades are from -100 to 100 count = [0] * (201) # total range of 201 (100 - (-100) + 1) # Count each grade for grade in grades: count[grade + offset] += 1 # Generate sorted list sorted_grades = [] for i in range(201): while count[i] > 0: sorted_grades.append(i - offset) count[i] -= 1 return sorted_grades"},{"question":"Context: You are working on an analysis tool for a social networking platform. One of the requirements is to identify mutually interconnected communities within the network. These communities can be represented as strongly connected components in a directed graph where users are nodes and their interactions (followers, friends) are directed edges. Task: Implement the `get_strongly_connected_components` function that uses Kosaraju\'s algorithm to find all strongly connected components in a directed graph. Each strongly connected component should be represented as a list of nodes. Function Signature: ```python def get_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` Input: - `V` (int): Number of vertices in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples representing directed edges between vertices. Output: - Returns a list of lists, with each inner list representing a strongly connected component containing the vertices. Constraints: - 1 ≤ V ≤ 10^4 - 0 ≤ len(edges) ≤ 10^5 - Vertices are labeled from 0 to V-1. Example: **Input:** ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] ``` **Output:** ```python [ [4, 5], [0, 1, 2, 3] ] ``` **Explanation:** The graph contains two strongly connected components: - One component is formed by vertices [4, 5]. - The other component is formed by vertices [0, 1, 2, 3]. **Note:** The order of components and the order of vertices within each component may vary, as long as the structure of the SCCs is correctly represented. Implement the function to solve the given problem effectively considering the constraints and characteristics of Kosaraju\'s algorithm.","solution":"from typing import List, Tuple def get_strongly_connected_components(V: int, edges: List[Tuple[int, int]]) -> List[List[int]]: def dfs(v, graph, visited, stack): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor, graph, visited, stack) stack.append(v) def reverse_graph(V, edges): rev_graph = [[] for _ in range(V)] for start, end in edges: rev_graph[end].append(start) return rev_graph def fill_order(V, graph, visited, stack): for i in range(V): if not visited[i]: dfs(i, graph, visited, stack) def get_sccs(V, rev_graph, visited, stack): sccs = [] while stack: v = stack.pop() if not visited[v]: scc_stack = [] dfs(v, rev_graph, visited, scc_stack) sccs.append(scc_stack) return sccs graph = [[] for _ in range(V)] for u, v in edges: graph[u].append(v) stack = [] visited = [False] * V fill_order(V, graph, visited, stack) rev_graph = reverse_graph(V, edges) visited = [False] * V return get_sccs(V, rev_graph, visited, stack)"},{"question":"# Question You are given three strings `s`, `part1`, and `part2`. Implement a function `is_interleave(s, part1, part2)` that returns `True` if `s` can be formed by interleaving `part1` and `part2` maintaining the order of characters. Otherwise, return `False`. # Function Signature ```python def is_interleave(s: str, part1: str, part2: str) -> bool: pass ``` # Input Constraints * `0 <= len(s), len(part1), len(part2) <= 100` * Each string consists of lowercase English letters only. # Output * The function should return a boolean value `True` or `False`. # Performance Requirements * Your solution should properly handle strings of up to length 100 in an efficient manner. * Aim to optimize both time and space complexities. # Examples: 1. `is_interleave(\\"codewars\\", \\"cdw\\", \\"oears\\")` should return `True`. 2. `is_interleave(\\"abc\\", \\"a\\", \\"bc\\")` should return `True`. 3. `is_interleave(\\"abcd\\", \\"abxd\\", \\"c\\")` should return `False`. # Notes: * You should consider handling edge cases such as empty strings and strings with non-overlapping characters. * Ensure the function is tested with various typical and edge case scenarios to validate its robustness.","solution":"def is_interleave(s: str, part1: str, part2: str) -> bool: if len(s) != len(part1) + len(part2): return False dp = [[False] * (len(part2) + 1) for _ in range(len(part1) + 1)] dp[0][0] = True for i in range(len(part1) + 1): for j in range(len(part2) + 1): if i > 0 and part1[i - 1] == s[i + j - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and part2[j - 1] == s[i + j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[len(part1)][len(part2)]"},{"question":"# Matrix Multiplication Challenge Given two matrices represented as 2D lists, write a function to compute their matrix product. Matrix multiplication is only possible when the number of columns of the first matrix (multiplicand) is equal to the number of rows of the second matrix (multiplier). # Function Signature ```python def multiply_matrices(multiplicand: list, multiplier: list) -> list: pass ``` # Input * `multiplicand`: A 2D list where each element is a list representing a row of the first matrix. * `multiplier`: A 2D list where each element is a list representing a row of the second matrix. **Constraints** * Each inner list (representing rows) is non-empty. * The matrices can contain both positive and negative integers. * Maximum number of rows and columns for both matrices is 1000. # Output * A 2D list representing the product matrix. # Example **Example 1** ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] Expected Output: [ [58, 64], [139, 154] ] ``` **Example 2** ```python multiplicand = [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] multiplier = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Expected Output: [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` # Instructions 1. Implement the function `multiply_matrices`. 2. Your solution should account for edge cases such as empty matrices and incompatible matrix sizes. 3. Aim for an optimal solution considering the time complexity of O(n^3).","solution":"def multiply_matrices(multiplicand: list, multiplier: list) -> list: Computes the product of two matrices. Args: multiplicand: List of lists where each sublist represents a row in the first matrix. multiplier: List of lists where each sublist represents a row in the second matrix. Returns: A list of lists representing the product matrix. if not multiplicand or not multiplier or not multiplicand[0] or not multiplier[0]: return [] m = len(multiplicand) n = len(multiplier[0]) common_dim = len(multiplicand[0]) if common_dim != len(multiplier): raise ValueError(\\"Number of columns of the first matrix must equal to the number of rows of the second matrix.\\") product = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): for k in range(common_dim): product[i][j] += multiplicand[i][k] * multiplier[k][j] return product"},{"question":"# Context In this problem, you are given two binary trees and need to determine if one tree is a subtree of the other. This requires understanding tree traversal methods and subtree comparison techniques. # Problem Statement You are tasked to write a function `is_subtree(s: TreeNode, t: TreeNode) -> bool` to determine whether tree `t` is a subtree of tree `s`. # Input Format - Two binary trees `s` and `t` represented by their root nodes. # Output Format - Return `True` if `t` is a subtree of `s`, otherwise return `False`. # Constraints - The number of nodes in both the trees will not exceed `10000`. - Both trees `s` and `t` contain integer values. # Function Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: # Your code here ``` # Example ```python # Example 1 # Input: # Tree s: # 3 # / #4 5 #/ #1 2 # Tree t: # 4 # / #1 2 # Output: # True # Example 2 # Input: # Tree s: # 3 # / # 4 5 # / # 1 2 # / # 0 # Tree t: # 4 # / # 1 2 # Output: # False ``` # Requirements - Ensure you handle edge cases properly. - Optimize the code to handle large trees efficiently.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(s: TreeNode, t: TreeNode) -> bool: def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False return s.val == t.val and is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) if not s: return False if is_same_tree(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t)"},{"question":"# Summary Ranges **Context**: You are tasked with developing a functionality for a monitoring system. This system needs to generate concise summary ranges from sorted lists of user activity logs represented by integers. The goal is to transform a sequence of integer logs into a list of ranges, making it easier to visualize periods of continuous activity. **Problem**: Write a function `summarize_ranges` that takes a sorted integer list `array` without duplicates and returns a summary of its ranges as a list of strings. **Function Signature**: ```python def summarize_ranges(array: List[int]) -> List[str]: ``` **Input**: - A sorted list of integers without duplicates. **Output**: - A list of strings where each string represents a range in the format \\"start-end\\" if there is a range and \\"single_element\\" if there\'s only one element in that position. **Constraints**: - Every element in the input list is unique and sorted in ascending order. - Elements in the integer list are non-negative. **Examples**: ```python summarize_ranges([0, 1, 2, 4, 5, 7]) # returns [\\"0-2\\", \\"4-5\\", \\"7\\"] summarize_ranges([1, 3, 5]) # returns [\\"1\\", \\"3\\", \\"5\\"] summarize_ranges([10, 11, 12, 14]) # returns [\\"10-12\\", \\"14\\"] summarize_ranges([1]) # returns [\\"1\\"] summarize_ranges([]) # returns [] ``` **Explanation**: - For an empty array, the result is an empty list. - For arrays where elements form consecutive sequences, ranges are summarized. - For single elements that do not form ranges, the element itself is returned as a string. Please ensure that your implementation has an optimal time complexity of O(n).","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] summary = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: summary.append(f\\"{start}\\") else: summary.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: summary.append(f\\"{start}\\") else: summary.append(f\\"{start}-{end}\\") return summary"},{"question":"# Problem Description # Scenario You are tasked with creating a function that searches for a smaller string (`needle`) within a larger string (`haystack`). This capability is elemental in various applications such as text editors, DNA sequence analysis, and search engines. # Objective Implement an efficient substring search function using the Knuth-Morris-Pratt (KMP) algorithm to improve the performance of finding the first occurrence of the `needle` in the `haystack`. # Function Signature ```python def kmp_strStr(haystack: str, needle: str) -> int: ``` # Input - `haystack` (str): The larger string within which to search for the `needle`. - `needle` (str): The smaller string to locate within the `haystack`. # Output - (int): The index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`. # Constraints - Length of `haystack` (n) and `needle` (m) such that (0 leq m leq n leq 10^5). - Both `haystack` and `needle` contain only lowercase English characters. # Example Example 1: - Input: `haystack = \\"hello\\"`, `needle = \\"ll\\"` - Output: 2 - Explanation: The first occurrence of `ll` in `hello` starts at index 2. Example 2: - Input: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` - Output: -1 - Explanation: The `needle` `bba` is not present in the `haystack` `aaaaa`. # Performance Requirements - Ensure that the implementation runs in O(n + m) time complexity, where `n` is the length of `haystack` and `m` is the length of `needle`. # Notes - Handling of edge cases must be properly done, especially testing with empty `needle` and longer `needle` compared to `haystack`. - A direct brute-force method is not acceptable due to inefficiency in the required constraints.","solution":"def kmp_strStr(haystack: str, needle: str) -> int: if not needle: return 0 # Compute the KMP table (also called \\"partial match\\" table) def compute_kmp_table(pattern): kmp_table = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 kmp_table[i] = length i += 1 else: if length != 0: length = kmp_table[length - 1] else: kmp_table[i] = 0 i += 1 return kmp_table kmp_table = compute_kmp_table(needle) i = 0 # index for haystack j = 0 # index for needle while i < len(haystack): if needle[j] == haystack[i]: i += 1 j += 1 if j == len(needle): return i - j elif i < len(haystack) and needle[j] != haystack[i]: if j != 0: j = kmp_table[j - 1] else: i += 1 return -1"},{"question":"# Sentence Formation Using Dictionary You have been given a string `str_piece` and a set of words `dictionaries`. Your task is to write a function `count_sentences(str_piece, dictionaries)` that computes the number of distinct sentences that can be constructed using the words from `dictionaries` such that each word in the sentence is a substring of `str_piece`. # Function Signature ```python def count_sentences(str_piece: str, dictionaries: set) -> int: pass ``` # Input * `str_piece` (str): A string of length ( n ) (1 ≤ ( n ) ≤ 100). * `dictionaries` (set): A set of strings representing the dictionary containing ( m ) words (1 ≤ ( m ) ≤ 100). Each word in the dictionary has a length between 1 to 100 and contains only lowercase English letters. # Output * Return an integer representing the number of sentences that can be formed using the `dictionaries`. # Constraints * All words must be used completely and without any breaks. * Each valid word in the sentence must be found in the `dictionaries`. # Performance Requirements * Aim to optimize your solution to avoid redundant calculations. * Utilize memoization or dynamic programming where appropriate. # Example ```python count_sentences(\\"appletablet\\", {\\"apple\\", \\"tablet\\", \\"applet\\", \\"able\\", \\"t\\"}) # Expected Output: 3 count_sentences(\\"applet\\", {\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"}) # Expected Output: 3 count_sentences(\\"thing\\", {\\"thing\\"}) # Expected Output: 1 ``` # Additional Notes * Consider all possible ways to divide the string into valid words. * You can assume that the dictionary will always contain at least one word that can match a part of `str_piece`.","solution":"def count_sentences(str_piece: str, dictionaries: set) -> int: memo = {} def helper(s): if s in memo: return memo[s] if not s: return 1 total_sentences = 0 for word in dictionaries: if s.startswith(word): total_sentences += helper(s[len(word):]) memo[s] = total_sentences return total_sentences return helper(str_piece)"},{"question":"**Context**: Help Dr. Tech restructure her library\'s digital catalog represented by linked lists. Each book is represented as a node, containing its title as a string. The linked list of book titles needs to be checked to determine if the sequence of titles is a palindrome. **Task**: Write a function `is_palindrome_linked_list(head)` that checks if a given linked list of strings is a palindrome. Use the provided snippets as inspiration but remember, your implementation should combine efficiency and clarity. **Function Signature**: ```python def is_palindrome_linked_list(head: Optional[ListNode]) -> bool: pass ``` **Input**: * `head`: The head node of the singly linked list containing book titles as strings. **Output**: * Returns `True` if the linked list of book titles is a palindrome. * Returns `False` otherwise. **Constraints**: * 0 <= length of the linked list <= 10^5 * String length in each node <= 100 **Requirements**: * Implement an efficient solution with a time complexity of O(n) and additional space complexity not exceeding O(n). **Edge Cases**: * Empty list or single node list should return `True`. * Linked list with an odd number of nodes. * Linked list with all identical strings. **Examples**: * Input: `[\\"A\\", \\"B\\", \\"B\\", \\"A\\"]` -> Output: `True` * Input: `[\\"A\\", \\"B\\", \\"C\\", \\"B\\", \\"A\\"]` -> Output: `True` * Input: `[\\"A\\", \\"B\\", \\"C\\"]` -> Output: `False` **Note**: Do not modify the original structure of the linked list. You may use additional data structures if necessary (e.g., stack, dictionary) but strive for a minimal space solution.","solution":"class ListNode: def __init__(self, value: str = None, next: \'ListNode\' = None): self.value = value self.next = next def is_palindrome_linked_list(head: ListNode) -> bool: Checks if the linked list of book titles represented by nodes is a palindrome. :param head: The head node of the singly linked list containing book titles as strings. :return: True if the linked list is a palindrome, False otherwise. if head is None or head.next is None: return True # An empty list or single node list is a palindrome # Step 1: Find the middle of the linked list using a slow and fast pointer approach slow = head fast = head stack = [] # Move slow pointer one step and fast pointer two steps at a time while fast and fast.next: stack.append(slow.value) slow = slow.next fast = fast.next.next # If the length of the list is odd, move the slow pointer one step further if fast: slow = slow.next # Step 2: Compare the second half of the list with the stack\'s contents while slow: top = stack.pop() if slow.value != top: return False slow = slow.next return True"},{"question":"# AVL Tree Implementation and Testing Objective You are given a partially implemented AVL Tree class, which ensures balanced tree properties through rotation operations upon node insertions. You need to complete the implementation and test certain functionalities to demonstrate a correct understanding of AVL Trees. Task 1. **Implement AVL Tree Height Calculation:** - Complete the `update_heights()` method to correctly calculate and update the height of nodes. 2. **Balance Factor Calculation:** - Verify or correct the `update_balances()` method to ensure efficient and accurate calculations of balance factors. 3. **Tree Traversal:** - Ensure `in_order_traverse()` method returns an in-order traversal of the AVL Tree as a list. Specifications 1. **Input/Output Format:** - Implement the following interface methods: - `insert(key: int) -> None` - `in_order_traverse() -> List[int]` - Example: - Calling `insert(30)`, `insert(20)`, `insert(40)`, `insert(10)` on the AVL Tree - `in_order_traverse()` should return `[10, 20, 30, 40]` 2. **Constraints:** - Handle unique integer keys only. - Ensure operations keep the tree balanced. 3. **Performance:** - Expected time complexity for `insert` and `in_order_traverse` should not exceed (O(log n)) and (O(n)) respectively. Code Here is the partially implemented AVL Tree class for reference. Complete and correct the necessary parts. ```python Imports TreeNodes from tree.tree import TreeNode class AvlTree(object): An avl tree. def __init__(self): # Root node of the tree. self.node = None self.height = -1 self.balance = 0 def insert(self, key): Insert new key into node # Create new node node = TreeNode(key) if not self.node: self.node = node self.node.left = AvlTree() self.node.right = AvlTree() elif key < self.node.val: self.node.left.insert(key) elif key > self.node.val: self.node.right.insert(key) self.re_balance() def re_balance(self): Re balance tree. After inserting or deleting a node, self.update_heights(recursive=False) # to be implemented. self.update_balances(recursive=False) # to be implemented. while self.balance < -1 or self.balance > 1: if self.balance > 1: if self.node.left.balance < 0: self.node.left.rotate_left() self.update_heights() self.update_balances() self.rotate_right() self.update_heights() self.update_balances() if self.balance < -1: if self.node.right.balance > 0: self.node.right.rotate_right() self.update_heights() self.update_balances() self.rotate_left() self.update_heights() self.update_balances() def update_heights(self, recursive=True): Update tree height if self.node: if recursive: if self.node.left: self.node.left.update_heights() if self.node.right: self.node.right.update_heights() self.height = 1 + max(self.node.left.height, self.node.right.height) else: self.height = -1 def update_balances(self, recursive=True): Calculate tree balance factor if self.node: if recursive: if self.node.left: self.node.left.update_balances() if self.node.right: self.node.right.update_balances() self.balance = self.node.left.height - self.node.right.height else: self.balance = 0 def rotate_right(self): Right rotation new_root = self.node.left.node new_left_sub = new_root.right.node old_root = self.node self.node = new_root old_root.left.node = new_left_sub new_root.right.node = old_root def rotate_left(self): Left rotation new_root = self.node.right.node new_left_sub = new_root.left.node old_root = self.node self.node = new_root old_root.right.node = new_left_sub new_root.left.node = old_root def in_order_traverse(self): In-order traversal of the tree result = [] if not self.node: return result result.extend(self.node.left.in_order_traverse()) result.append(self.node.key) result.extend(self.node.right.in_order_traverse()) return result ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key: int) -> None: self.root = self._insert(self.root, key) def _insert(self, node: TreeNode, key: int) -> TreeNode: if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.rotate_right(node) if balance < -1 and key > node.right.key: return self.rotate_left(node) if balance > 1 and key > node.left.key: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and key < node.right.key: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node def get_height(self, node: Optional[TreeNode]) -> int: if not node: return 0 return node.height def get_balance(self, node: Optional[TreeNode]) -> int: if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def rotate_right(self, y: TreeNode) -> TreeNode: x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) return x def rotate_left(self, x: TreeNode) -> TreeNode: y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def in_order_traverse(self) -> List[int]: result = [] self._in_order_traverse_rec(self.root, result) return result def _in_order_traverse_rec(self, node: Optional[TreeNode], result: List[int]) -> None: if node: self._in_order_traverse_rec(node.left, result) result.append(node.key) self._in_order_traverse_rec(node.right, result)"},{"question":"# Question: Implement Enhanced Diffie-Hellman Key Exchange You are tasked with implementing an enhanced version of the Diffie-Hellman key exchange algorithm. Your version needs to include additional validation checks and logging functionalities to help in debugging and understanding the flow of key generation and exchange process. Requirements: 1. **Function Signature**: ```python def enhanced_diffie_hellman(a: int, p: int) -> bool: pass ``` 2. **Input**: - `a`: A potential primitive root of `p`. - `p`: A large prime number. 3. **Output**: - Return `True` if the shared keys match, otherwise return `False`. 4. **Functionality**: - Ensure that `p` is a prime number. - Ensure that `a` is a primitive root of `p`. - Generate private keys for Alice and Bob in the range `[1, p-1]`. - Compute and log public keys for both Alice and Bob. - Derive the shared secret keys for both Alice and Bob independently. - Log intermediate values for private keys, public keys, and shared keys. - Return `True` if the shared secret keys match; otherwise, return `False`. Constraints: - Values of `p` must be large prime numbers (e.g., in thousands or more). - Both `p` and `a` should be integers. - Ensure error handling for edge cases like non-prime `p` and incorrect primitive root `a`. Example: ```python a = 5 p = 23 result = enhanced_diffie_hellman(a, p) Expected Output: Alice\'s private key: <Some Integer> Alice\'s public key: <Some Integer> Bob\'s private key: <Some Integer> Bob\'s public key: <Some Integer> Shared key calculated by Alice = <Some Integer> Shared key calculated by Bob = <Some Integer> True if shared keys match, False if not. ``` Additional Information: - You must not use any cryptographic libraries directly; implement all functions as shown in the provided code snippets. - Use the prime checking and primitive root validation given in the provided code snippets. - Focus on implementing clear logging for debugging purposes.","solution":"import random import sympy def is_prime(num): Check if the number is a prime. return sympy.isprime(num) def find_primitive_root(p): Find a primitive root modulo p. if not is_prime(p): return -1 phi = p - 1 factors = sympy.ntheory.factor_.factorint(phi) for root in range(2, p): flag = False for factor in factors: # Check if root^((p-1)/factor) mod p == 1 if pow(root, phi // factor, p) == 1: flag = True break if not flag: return root return -1 def enhanced_diffie_hellman(a: int, p: int) -> bool: Perform Diffie-Hellman Key Exchange with validation and logging. if not is_prime(p): print(\\"p is not a prime number.\\") return False if find_primitive_root(p) != a: print(\\"a is not a primitive root of p.\\") return False # Step 1: Choose private keys for Alice and Bob a_private = random.randint(1, p-1) b_private = random.randint(1, p-1) # Step 2: Compute public keys A = pow(a, a_private, p) B = pow(a, b_private, p) # Log private and public keys print(f\\"Alice\'s private key: {a_private}\\") print(f\\"Alice\'s public key: {A}\\") print(f\\"Bob\'s private key: {b_private}\\") print(f\\"Bob\'s public key: {B}\\") # Step 3: Compute shared secret shared_secret_by_alice = pow(B, a_private, p) shared_secret_by_bob = pow(A, b_private, p) # Log shared secrets print(f\\"Shared key calculated by Alice: {shared_secret_by_alice}\\") print(f\\"Shared key calculated by Bob: {shared_secret_by_bob}\\") return shared_secret_by_alice == shared_secret_by_bob"},{"question":"# Reversing a Singly Linked List Context: You are given a singly linked list. You need to reverse the linked list such that the order of the nodes is inverted. Problem Statement: Implement a function to reverse a singly linked list in two different ways: 1. **Iteratively** 2. **Recursively** Function Signatures ```python def reverse_list(head: ListNode) -> ListNode: Reverses a singly linked list iteratively. :param head: The head node of the singly linked list. :return: The head node of the reversed linked list. pass def reverse_list_recursive(head: ListNode) -> ListNode: Reverses a singly linked list recursively. :param head: The head node of the singly linked list. :return: The head node of the reversed linked list. pass ``` Input: - The head node of a singly linked list. Each node has two components: - `value`: Integer, the value of the node. - `next`: Pointer to the next node in the list or `None` if it is the last node. Output: - Return the head node of the reversed linked list. Constraints: - The number of nodes in the list can range from 0 to 10000. - The values of the nodes are integers and can be positive or negative. Example: ```python # Example usage: # Input: 1 -> 2 -> 3 -> 4 # Output: 4 -> 3 -> 2 -> 1 ``` # Considerations: - Think about edge cases, such as an empty list (head is None) or a list with only one node. - Try to ensure your code handles large linked lists efficiently without causing stack overflow issues (especially for the recursive solution).","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_list(head: ListNode) -> ListNode: prev = None current = head while current is not None: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head: ListNode) -> ListNode: if head is None or head.next is None: return head rev_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return rev_head"},{"question":"# Stooge Sort Enhancements and Implementations Context Stooge Sort is a recursively defined sorting algorithm that is primarily of academic interest due to its poor performance in practical use. However, understanding its implementation helps in grasping recursive sorting techniques and their implications on algorithm design. Task Enhance the Stooge Sort function to handle the following cases: 1. Sort in both ascending and descending order based on a provided parameter. 2. Ensure it handles edge cases such as empty arrays and single-element arrays efficiently without errors. Function Signature Write a function: ```python def enhanced_stoogesort(arr: list, ascending: bool = True) -> list: Sorts an array using Stooge Sort in ascending or descending order. Parameters: arr (list) : List of elements to sort. ascending (bool): If True, sorts in ascending order (default). If False, sorts in descending order. Returns: list: A new sorted list in the order specified. ``` Input and Output Formats - **Input Format**: - `arr`: A list of integers (can be empty or contain one element). - `ascending`: A boolean indicating sort order (default is `True` for ascending). - **Output Format**: - A new list of integers sorted in the specified order. Constraints - The function should handle lists of arbitrary size, but performance guarantees are not required. - Recursive limits must be managed within the default recursion depth of Python. Example Usage ```python print(enhanced_stoogesort([1, 3, 64, 5, 7, 8])) # Output: [1, 3, 5, 7, 8, 64] print(enhanced_stoogesort([1, 3, 64, 5, 7, 8], ascending=False)) # Output: [64, 8, 7, 5, 3, 1] print(enhanced_stoogesort([])) # Output: [] print(enhanced_stoogesort([42])) # Output: [42] ``` Performance and Complexity - Focus on correctness and handle edge cases robustly. - Ensure the function supports both ascending and descending order through parameterization. - You don\'t need to optimize time complexity beyond the original design constraints of Stooge Sort.","solution":"def enhanced_stoogesort(arr, ascending=True): Sorts an array using Stooge Sort in ascending or descending order. Parameters: arr (list) : List of elements to sort. ascending (bool): If True, sorts in ascending order (default). If False, sorts in descending order. Returns: list: A new sorted list in the order specified. def stoogesort(arr, l, h, ascending): if l >= h: return if (ascending and arr[l] > arr[h]) or (not ascending and arr[l] < arr[h]): arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t, ascending) stoogesort(arr, l + t, h, ascending) stoogesort(arr, l, h - t, ascending) if not arr: return [] # Copying the list to avoid modifying the original array sorted_arr = arr[:] stoogesort(sorted_arr, 0, len(sorted_arr) - 1, ascending) return sorted_arr"},{"question":"You are given a system that requires you to convert integer values to byte strings and back. The system can use either big-endian or little-endian formats. Implement two functions to handle these conversions efficiently. # Function Specifications: 1. `int_to_bytes(num: int, endian: str) -> bytes` - Converts an integer to a byte string. - **Parameters**: - `num`: An integer to convert. - `endian`: A string, either `\'big\'` for big-endian or `\'little\'` for little-endian. - **Returns**: A byte string representing the integer in the specified endian format. - **Constraints**: Assume `num` is a non-negative integer. 2. `bytes_to_int(bytestr: bytes, endian: str) -> int` - Converts a byte string back to an integer. - **Parameters**: - `bytestr`: Byte string to convert. - `endian`: A string, either `\'big\'` for big-endian or `\'little\'` for little-endian. - **Returns**: An integer represented by the byte string in the specified endian format. - **Constraints**: Ensure proper handling of edge cases like empty byte strings. Assume all given byte strings are valid. # Example: ```python assert int_to_bytes(305419896, \'big\') == b\'x12x34x56x78\' assert int_to_bytes(305419896, \'little\') == b\'x78x56x34x12\' assert bytes_to_int(b\'x12x34x56x78\', \'big\') == 305419896 assert bytes_to_int(b\'x78x56x34x12\', \'little\') == 305419896 ``` # Notes: - Avoid using any Python built-in features that directly perform the conversion (e.g., `int.from_bytes` or `bytes`). - Ensure your implementation is efficient and works within the constraints provided.","solution":"def int_to_bytes(num: int, endian: str) -> bytes: if num == 0: return b\'x00\' # Create an empty list to collect the byte values byte_arr = [] while num: # Collect the lowest 8 bits (one byte) byte_arr.append(num & 0xFF) # Shift right by 8 bits num = num >> 8 if endian == \'big\': byte_arr.reverse() return bytes(byte_arr) def bytes_to_int(bytestr: bytes, endian: str) -> int: # Convert bytes to integer base on the endian type int_val = 0 if endian == \'big\': for b in bytestr: int_val = (int_val << 8) | b elif endian == \'little\': for b in reversed(bytestr): int_val = (int_val << 8) | b return int_val"},{"question":"You are given an array of integers `nums` where exactly two elements appear only once, and all the other elements appear exactly twice. Your task is to find the two elements that appear only once and return them in any order. **Function Signature**: ```python def single_number3(nums: List[int]) -> List[int]: ``` # Input * `nums` (List[int]): A list of integers where exactly two elements appear only once, and all others appear exactly twice. # Output * `List[int]`: A list containing the two unique numbers. # Constraints * The input list will always contain exactly two elements that appear only once and will have an even number of elements. * All elements in the list are integers where the value of the integers can be large (both positive and negative). # Example ```python # Example 1: input: nums = [1, 2, 1, 3, 2, 5] output: [3, 5] # or [5, 3] # Example 2: input: nums = [10, 15, 10, 16, 20, 15] output: [16, 20] # or [20, 16] ``` # Explanation * In Example 1, the elements `3` and `5` appear only once while all other elements appear twice. * In Example 2, the elements `16` and `20` appear only once while all other elements appear twice. Use bitwise XOR operation to solve the problem with O(N) time complexity and O(1) space complexity.","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: Find the two elements in the list that appear only once. # First pass to get the XOR of the two unique numbers xor = 0 for num in nums: xor ^= num # Find the rightmost set bit in xor diff_bit = xor & -xor # Initialize the two single numbers to zero single1 = 0 single2 = 0 # Second pass to separate the two unique numbers based on the diff_bit for num in nums: if num & diff_bit: single1 ^= num else: single2 ^= num return [single1, single2]"},{"question":"BST Iterator Implementation You are provided with the `BSTIterator` class that represents an iterator over a binary search tree (BST). The objective is to traverse the BST in an in-order manner using this iterator. You need to complete the implementation by providing correct traversal mechanisms. Required Functions: 1. `__init__(self, root)`: This method initializes the iterator. It should push all the left children of the root onto the stack, starting from the leftmost node. 2. `has_next(self)`: This method returns `True` if there are further nodes to be visited, and `False` otherwise. 3. `next(self)`: This method returns the next smallest element in the BST. Input: - The `__init__` method receives a single argument: the `root` of a binary search tree. - The `has_next` method takes no arguments. - The `next` method takes no arguments. Output: - The `has_next` method returns a boolean value. - The `next` method returns an integer, the next smallest value in the BST. Constraints: - The number of nodes in the BST is in the range `[0, 10^4]`. - The keys of the nodes are unique. - Your solution must run in O(h) space complexity, where h is the height of the BST. Example: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) iterator = BSTIterator(root) values = [] while iterator.has_next(): values.append(iterator.next()) print(values) # Output: [3, 7, 9, 15, 20] ``` Implement the class `BSTIterator` with its respective methods to satisfy the above functionality and constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): Push all the left children of the root onto the stack. while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Return True if there\'s a next smallest element in the BST. return len(self.stack) > 0 def next(self) -> int: Return the next smallest element in the BST. # Node on top of the stack is the next smallest element topmost_node = self.stack.pop() # If the topmost node has a right child, process its leftmost children if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"A survey team conducted an opinion poll to determine the most popular options among a set of responses. You are tasked with identifying the option(s) with the highest frequency from the responses data. Implement a function `most_frequent_values(arr)` that takes an array of integers representing the survey responses and returns a list of the most frequent value(s) in the array. If multiple values have the highest frequency, return all of them in the order they first appeared in the array. Function Signature ```python def most_frequent_values(arr: List[int]) -> List[int]: ``` # Input * `arr` (1 <= len(arr) <= 10^5): a list of integers where each integer represents a survey response. # Output * A list of integers containing the most frequent value(s). If there are multiple values with the same maximum frequency, include all such values in the order they are first encountered in the array. # Constraints * The input array is non-empty. # Example ```python >>> most_frequent_values([1, 1, 2, 2, 3, 4]) [1, 2] >>> most_frequent_values([3, 3, 2, 1, 4, 3]) [3] >>> most_frequent_values([3]) [3] >>> most_frequent_values([1, 2, 2, 3, 3, 4, 4]) [2, 3, 4] ``` # Explanation 1. In the first example, both `1` and `2` appear twice, which is the maximum frequency for this array. 2. In the second example, `3` appears most frequently (three times). 3. In the third example, the single element `3` is returned as it is the only element in the array. 4. In the fourth example, `2`, `3`, and `4` all appear twice, and they should be returned in the order of their first appearance. Make sure your implementation is efficient with respect to both time and space complexity.","solution":"from typing import List from collections import Counter def most_frequent_values(arr: List[int]) -> List[int]: Returns a list of the most frequent value(s) from the input list. If multiple values have the same maximum frequency, include all such values in the order they first appeared in the array. if not arr: return [] frequency = Counter(arr) max_freq = max(frequency.values()) result = [] encountered = set() for num in arr: if num in encountered: continue if frequency[num] == max_freq: result.append(num) encountered.add(num) return result"},{"question":"# Longest Sequence of 1s After Flipping One Bit Problem Statement: You are given an integer, and you can flip exactly one bit from 0 to 1. Write a function to find the maximum length of the sequence of consecutive 1s that can be achieved by flipping exactly one bit from 0 to 1 in the binary representation of the integer. Your task is to implement the function `flip_bit_longest_seq(num: int) -> int` that returns this maximum length. Input: - An integer `num (0 <= num <= 10^9)` Output: - An integer representing the maximum length of consecutive 1s that can be obtained. Constraints: - You may assume that the input is a single integer in the range `[0, 10^9]`. Example: ```plaintext Input: 1775 (binary: 11011101111) Output: 8 Input: 0 (binary: 0) Output: 1 ``` Performance Requirements: - The implementation should run in linear time relative to the number of bits in the integer. - The implementation should use constant space. Additional Instructions: - Consider edge cases such as when the input number is 0 or already consists entirely of 1s. - You are allowed to define helper functions if necessary, but the primary function signature must be `flip_bit_longest_seq(num: int) -> int`.","solution":"def flip_bit_longest_seq(num: int) -> int: if num == 0: return 1 current_length = 0 previous_length = 0 max_length = 1 # We can always flip at least one bit while num != 0: if (num & 1) == 1: # Current bit is a 1 current_length += 1 else: # Current bit is a 0 # Update to previous_length (what is before this 0) previous_length = 0 if (num & 2) == 0 else current_length current_length = 0 max_length = max(max_length, previous_length + current_length + 1) num >>= 1 return max_length"},{"question":"**Context:** You are working on optimizing a low-level graphics rendering engine where performance and direct hardware control are paramount. At the heart of this engine is effective and efficient bit manipulation to control individual pixels\' states. **Problem Statement:** Implement a function `toggle_bit(num: int, i: int) -> int` that toggles the bit at the ith position of a given integer `num`. Toggling means that if the bit is 0, it should be changed to 1, and if it is 1, it should be changed to 0. # Function Signature: ```python def toggle_bit(num: int, i: int) -> int: pass ``` # Input: - `num`: An integer (32-bit signed integer). - `i`: An integer representing the bit position to toggle (0-indexed). # Output: - An integer resulting from toggling the ith bit of `num`. # Constraints: - 0 <= num <= (2^{31} - 1) - 0 <= i < 32 # Example: ```python assert toggle_bit(10, 1) == 8 # Binary: 1010 -> 1000 assert toggle_bit(15, 3) == 7 # Binary: 1111 -> 0111 assert toggle_bit(0, 2) == 4 # Binary: 0000 -> 0100 assert toggle_bit(4, 2) == 0 # Binary: 0100 -> 0000 ``` # Explanation: - The toggle_bit function will flip the bit at the specified position `i` in the number `num`: - To achieve the toggle operation, use the XOR bitwise operator with a mask where only the bit at position `i` is set to 1. - The XOR operation with 1 will flip the bit value (`0 XOR 1 = 1` and `1 XOR 1 = 0`).","solution":"def toggle_bit(num: int, i: int) -> int: Toggles the bit at the ith position of a given integer num. Args: num (int): The input integer. i (int): The bit position to toggle (0-indexed). Returns: int: The integer result after toggling the ith bit of num. # Create a mask with a 1 only at the ith position mask = 1 << i # Toggle the ith bit using XOR return num ^ mask"},{"question":"# Context: The Diffie-Hellman key exchange algorithm is a method for two parties to securely share a secret key over a non-encrypted communication network. It relies on the mathematical properties of one-way functions (discrete logarithms). In this task, you will be extending this concept to implement a secure exchange between Alice and Bob including additional checks and optimizations. # Task: 1. **Function Implementation**: Implement a function `enhanced_diffie_hellman_key_exchange(a: int, p: int, prime_check_optimized: bool = False, verbose: bool = False) -> bool` which performs the Diffie-Hellman key exchange with the following additional requirements: - **Optimized Prime Check**: Incorporate an optimized prime checking function if the `prime_check_optimized` parameter is `True`. - **Verbose Option**: If `verbose` is `True`, the function should print the intermediate values of Alice\'s and Bob\'s private and public keys. 2. **Utility Functions**: - Optimize the `prime_check` function to handle larger inputs effectively. - Include unit tests for each utility function and the main function. # Input and Output: - **Input**: - `a` (int): Primitive root of `p`. - `p` (int): A large prime number. - `prime_check_optimized` (bool): Flag to use optimized prime check. - `verbose` (bool): Flag to print intermediate key values. - **Output**: - (bool): `True` if the exchange was successful (both parties derived the same shared key), otherwise `False`. # Constraints: - Assume `a` and `p` are provided correctly unless proven otherwise through checks. - `a` and `p` are large integers. - Code efficiency is crucial due to possible large inputs. # Example: ```python def enhanced_diffie_hellman_key_exchange(a: int, p: int, prime_check_optimized: bool = False, verbose: bool = False) -> bool: # Implement the function according to the described requirements # Invoke with example result = enhanced_diffie_hellman_key_exchange(5, 23, prime_check_optimized=True, verbose=True) print(result) # Should print True if keys match. ``` You are tasked with correctly implementing this function according to the described requirements, ensuring every aspect of Diffie-Hellman key exchange is secure and optimized, handling large input values effectively.","solution":"import random def is_prime_basic(n): Simple but not optimal primality test. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_prime_optimized(n): Miller-Rabin primality test for optimized prime checking. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False # Write n as d*2^r + 1 r = 0 d = n - 1 while d % 2 == 0: d //= 2 r += 1 def miller_rabin_test(d, n): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == n - 1: return True if x == 1: return False return False k = 5 # Number of iterations for _ in range(k): if not miller_rabin_test(d, n): return False return True def enhanced_diffie_hellman_key_exchange(a: int, p: int, prime_check_optimized: bool = False, verbose: bool = False) -> bool: if prime_check_optimized: is_prime = is_prime_optimized else: is_prime = is_prime_basic if not is_prime(p): raise ValueError(f\\"The number {p} is not prime.\\") # Private keys for Alice and Bob alice_private = random.randint(1, p-1) bob_private = random.randint(1, p-1) # Public keys for Alice and Bob alice_public = pow(a, alice_private, p) bob_public = pow(a, bob_private, p) if verbose: print(f\\"Alice\'s private key: {alice_private}\\") print(f\\"Alice\'s public key: {alice_public}\\") print(f\\"Bob\'s private key: {bob_private}\\") print(f\\"Bob\'s public key: {bob_public}\\") # Shared secret keys alice_shared_secret = pow(bob_public, alice_private, p) bob_shared_secret = pow(alice_public, bob_private, p) if verbose: print(f\\"Alice\'s shared secret: {alice_shared_secret}\\") print(f\\"Bob\'s shared secret: {bob_shared_secret}\\") return alice_shared_secret == bob_shared_secret"},{"question":"You are tasked with managing a schedule where tasks with the smallest execution times are given the highest priority. To do this, you need to implement a min heap data structure that supports efficient insertion and removal of tasks. Implement a class `TaskScheduler` that uses a min heap to efficiently manage tasks. Your class should include the following methods: 1. `add_task(task_id, execution_time)`: Insert a new task with a given `task_id` and `execution_time`. 2. `execute_next_task()`: Remove and return the `task_id` of the next task to be executed (i.e., the task with the smallest `execution_time`). # Expected Class Signature ```python class TaskScheduler: def __init__(self): pass def add_task(self, task_id: int, execution_time: int): pass def execute_next_task(self) -> int: pass ``` # Input/Output Formats 1. `add_task(task_id, execution_time)`: - **Input**: An integer `task_id` and an integer `execution_time`. - **Output**: None. 2. `execute_next_task()`: - **Input**: None. - **Output**: An integer representing the `task_id` of the next task to be executed. # Constraints - All `task_id` values are unique. - All `execution_time` values are positive integers. - You may assume the methods will be called in a way that there will always be at least one task in the system when `execute_next_task` is called. # Example ```python scheduler = TaskScheduler() scheduler.add_task(1, 5) scheduler.add_task(2, 3) scheduler.add_task(3, 2) assert scheduler.execute_next_task() == 3 # Task with ID 3 has the smallest execution time (2) assert scheduler.execute_next_task() == 2 # Task with ID 2 has the next smallest execution time (3) assert scheduler.execute_next_task() == 1 # Task with ID 1 has the next smallest execution time (5) ```","solution":"import heapq class TaskScheduler: def __init__(self): self.min_heap = [] def add_task(self, task_id: int, execution_time: int): heapq.heappush(self.min_heap, (execution_time, task_id)) def execute_next_task(self) -> int: return heapq.heappop(self.min_heap)[1]"},{"question":"You are tasked with developing a software module for a logistics company that needs to optimize its delivery routes between multiple warehouses. The company operates a network of warehouses connected by roads of varying distances. Your job is to write a function that calculates the shortest possible distance between any two warehouses. **Function Signature:** ```python def calculate_warehouse_routes(distance_matrix: List[List[float]]) -> List[List[float]]: ``` Parameters: * `distance_matrix`: A 2D list (n x n) representing the direct distances between `n` warehouses. If there is no direct road between two warehouses, the distance is represented by `float(\'inf\')`. Returns: * A 2D list (n x n), where each element at index `[i][j]` indicates the shortest distance from warehouse `i` to warehouse `j`. Constraints: * The number of warehouses `n` is an integer such that `1 <= n <= 100`. * All road distances are non-negative and represented by floating-point numbers. * A distance of `0` between a warehouse and itself (i.e., `distance_matrix[i][i] == 0`). Example Input: ```python distance_matrix = [ [0, 3, float(\'inf\'), float(\'inf\'), 6], [3, 0, 1, float(\'inf\'), 2], [float(\'inf\'), 1, 0, 2, 3], [float(\'inf\'), float(\'inf\'), 2, 0, 4], [6, 2, 3, 4, 0] ] ``` Example Output: ```python [ [0, 3, 4, 6, 5], [3, 0, 1, 3, 2], [4, 1, 0, 2, 3], [6, 3, 2, 0, 4], [5, 2, 3, 4, 0] ] ``` Detailed Description: * Your function should use the Floyd-Warshall algorithm to calculate the shortest path. * Make sure to use a deepcopy or equivalent method to preserve the original distance matrix. * Consider edge cases such as when there is no path between certain pairs of warehouses. * You may assume that there are no negative distance values in the matrix. Implement the function `calculate_warehouse_routes` based on the above specification.","solution":"from typing import List import copy def calculate_warehouse_routes(distance_matrix: List[List[float]]) -> List[List[float]]: Calculates the shortest distance between any two warehouses using Floyd-Warshall algorithm. Parameters: distance_matrix (List[List[float]]): A 2D list representing the direct distances between warehouses. Returns: List[List[float]]: A 2D list representing the shortest distances between each pair of warehouses. n = len(distance_matrix) # Create a copy of the distance matrix to preserve the original matrix distances = copy.deepcopy(distance_matrix) for k in range(n): for i in range(n): for j in range(n): if distances[i][j] > distances[i][k] + distances[k][j]: distances[i][j] = distances[i][k] + distances[k][j] return distances"},{"question":"**Scenario**: Imagine you are helping to manage a real-time task scheduling system where tasks have different priority levels. You need to ensure that higher priority tasks are executed before lower priority tasks. Your task is to implement a priority queue that supports this functionality efficiently. **Task**: Implement a `PriorityQueue` class that supports insertion (`push`), extraction (`pop`), and a method to check the current size (`size`) of the priority queue. **Function Signatures**: ```python class PriorityQueue: def __init__(self, items=None, priorities=None): pass def size(self): pass def push(self, item, priority=None): pass def pop(self): pass ``` **Expected Behavior**: 1. `__init__(self, items=None, priorities=None)`: Initializes the priority queue, optionally with initial items and their corresponding priorities. 2. `size(self)`: Returns the number of elements in the priority queue. 3. `push(self, item, priority=None)`: Inserts an item into the priority queue with the given priority. If no priority is provided, the item\'s value is used as its priority. 4. `pop(self)`: Removes and returns the item with the highest priority (i.e., the item at the end of the sorted list). **Constraints and Performance Requirements**: - The priority queue must be implemented using a linear array (list). - The `pop` operation should be performed in O(1) time complexity. - The `push` operation should ensure that items are inserted maintaining the order of priority in O(n) time complexity. - Handle edge cases like pushing/popping from an empty queue appropriately. **Example Usage**: ```python pq = PriorityQueue() pq.push(\\"task1\\", 2) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 3) print(pq.size()) # Output: 3 print(pq.pop()) # Output: task2 (lowest priority) print(pq.pop()) # Output: task1 print(pq.size()) # Output: 1 ``` **Note**: - Ensure to handle scenarios where an item with a similar priority is pushed into the queue. - Optimize performance where possible within the constraint of using a linear array.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): self.queue = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.queue) def push(self, item, priority=None): if priority is None: priority = item self.queue.append((priority, item)) self.queue.sort(reverse=True, key=lambda x: x[0]) def pop(self): if self.size() == 0: raise IndexError(\\"pop from empty priority queue\\") return self.queue.pop()[1]"},{"question":"You are hired by a company that specializes in text analysis and document comparison. Your task is to write a function that compares the similarity between two documents, represented as frequency vectors of terms. The company uses cosine similarity as their default method to measure how close two documents are in terms of content. **Objective**: Implement the function `cosine_similarity(vec1, vec2)` that measures the cosine similarity between two vectors of equal length. **Function Definition**: - `cosine_similarity(vec1, vec2)`: Computes the cosine similarity between two equal-length vectors. **Parameters**: - `vec1` (list of int/float): The first vector. - `vec2` (list of int/float): The second vector. **Returns**: - `float`: The cosine similarity value between the two vectors. **Constraints**: - Both vectors will have the same length. - The length of each vector can range from 1 to 10^6. - The elements of the vectors are integers between -10^3 to 10^3 (both inclusive). **Example**: ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([0, 0, 0], [1, 2, 3]) # Output: 0.0 cosine_similarity([1, 2, 3], [4, 5, 6]) # Output: 0.9746318461970762 ``` # Implementation Details 1. **Vector Validation**: Check if the input vectors `vec1` and `vec2` are of the same length. Raise a ValueError if they are not. 2. **L2 Norm Calculation**: Implement a helper function `_l2_distance(vec)` to calculate the Euclidean norm of a vector. 3. **Dot Product Calculation**: Compute the dot product of `vec1` and `vec2`. 4. **Cosine Similarity**: Calculate the cosine similarity using the formula: [ text{similarity} = frac{text{dot_product}}{text{norm}_a times text{norm}_b} ] Consider edge cases such as vectors containing all zeros, which should be handled appropriately. **Note**: Please ensure that your solution handles large vectors efficiently within the constraints provided.","solution":"import math def cosine_similarity(vec1, vec2): Computes the cosine similarity between two equal-length vectors. if len(vec1) != len(vec2): raise ValueError(\\"Input vectors must be of the same length\\") def _l2_distance(vec): Calculates the Euclidean norm (L2 distance) of a vector. return math.sqrt(sum(x**2 for x in vec)) dot_product = sum(a * b for a, b in zip(vec1, vec2)) norm_a = _l2_distance(vec1) norm_b = _l2_distance(vec2) if norm_a == 0 or norm_b == 0: return 0.0 return dot_product / (norm_a * norm_b)"},{"question":"# Matrix Multiplication Coding Challenge You are given two 2D matrices `multiplicand` and `multiplier`. The goal is to write a function `matrix_multiply` that computes and returns the product of these two matrices. # Function Signature ```python def matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: ``` # Input Format - `multiplicand`: A list of lists of integers representing a matrix of size `m x n`. - `multiplier`: A list of lists of integers representing a matrix of size `n x p`. # Output Format - Return a list of lists of integers representing the resultant matrix of size `m x p`. # Constraints - Each inner list (row) in the matrices contains at least one integer. - The number of columns in `multiplicand` equals the number of rows in `multiplier`. - Integer values for elements in matrices lie between `-1000` and `1000`. # Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] result = matrix_multiply(multiplicand, multiplier) print(result) # Output: [[4, 4], [10, 8]] ``` # Explanation - Matrix A (multiplicand): 2x2 matrix - Matrix B (multiplier): 2x2 matrix - Resulting Matrix: ``` [[(1*2 + 2*1), (1*0 + 2*2)], [(3*2 + 4*1), (3*0 + 4*2)]] ``` which simplifies to: ``` [[4, 4], [10, 8]] ``` Ensure your function handles all edge cases effectively and performs under the given constraints.","solution":"from typing import List def matrix_multiply(multiplicand: List[List[int]], multiplier: List[List[int]]) -> List[List[int]]: Multiplies two matrices and returns the resulting matrix. Arguments: multiplicand -- a 2D list (matrix) of size m x n multiplier -- a 2D list (matrix) of size n x p Returns: A 2D list (matrix) of size m x p which is the product of the two matrices. m = len(multiplicand) n = len(multiplier) p = len(multiplier[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Subset Generation Challenge Problem Statement: You are given a list of distinct integers. Your task is to write a function that returns all possible subsets (the power set) of the list. The solution set must not contain duplicate subsets. Function Signature: ```python def generate_subsets(nums: List[int]) -> List[List[int]]: ``` Input: * A list of distinct integers, `nums` (0 <= len(nums) <= 20). Output: * A list of lists, where each list is a subset of the input list. The output should include the empty subset and should not contain any duplicate subsets. Constraints: * You must implement the solution using both a backtracking approach and an iterative approach. Requirements: * The time complexity should be O(2^n). * The space complexity should also be O(2^n). Example: ```python print(generate_subsets([1, 2, 3])) # Expected Output: # [ # [3], # [1], # [2], # [1, 2, 3], # [1, 3], # [2, 3], # [1, 2], # [] # ] ``` You should consider developing two separate functions within `generate_subsets` - one for backtracking and one for the iterative solution. Implement both approaches, and you can use helper functions as needed.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: def backtrack(start, path): results.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) results = [] backtrack(0, []) return results def generate_subsets_iterative(nums: List[int]) -> List[List[int]]: results = [[]] for num in nums: results += [curr + [num] for curr in results] return results"},{"question":"Context You have been tasked with creating a simple file compression tool using Run-Length Encoding (RLE) for a text-based application. Your goal is to implement functionalities to encode and decode strings to/from their RLE representations. Problem Statement You need to implement two functions: one to compress a given string using Run-Length Encoding and another to uncompress an RLE string back to its original form. Function Signature ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` Function Descriptions 1. `encode_rle(input: str) -> str`: * **Input**: A string `input` (0 <= len(input) <= 10^5) consisting of printable ASCII characters. * **Output**: A string representing the Run-Length Encoded form of the input. 2. `decode_rle(input: str) -> str`: * **Input**: A Run-Length Encoded string `input` (0 <= len(input) <= 10^5) consisting of digits followed by printable ASCII characters. * **Output**: The original uncompressed string. Example ```python # Example 1 encoding = encode_rle(\\"aaabbc\\") # encoding would be \\"3a2b1c\\" decoding = decode_rle(encoding) # decoding would be \\"aaabbc\\" # Example 2 encoding = encode_rle(\\"\\") # encoding would be an empty string decoding = decode_rle(encoding) # decoding would be an empty string ``` Constraints & Requirements * Handle edge cases where the input is empty. * Assume characters are completely printable ASCII. * The numeric portion of the encoded string will fit within standard integer range during decoding. * Both encoding and decoding should have a time complexity of O(n) where n is the length of the input.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = [] count = 1 prev_char = input[0] for char in input[1:]: if char == prev_char: count += 1 else: encoded_str.append(f\\"{count}{prev_char}\\") count = 1 prev_char = char # Append the last group encoded_str.append(f\\"{count}{prev_char}\\") return \\"\\".join(encoded_str) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded_str = [] count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_str.append(char * int(count)) count = \\"\\" return \\"\\".join(decoded_str)"},{"question":"# Question: Implement Enhanced Byte Conversion Functions Alice and Bob work on a project that involves storing large amounts of integer data in a memory-efficient format. They have some initial implementations for converting integers to byte arrays and vice versa, but they need more efficient and robust solutions. Your task is to implement optimized functions for these conversions. Specifically, you need to: 1. Optimize and improve the given functions for converting integers to byte arrays in both big-endian and little-endian formats. 2. Enhance the functions for converting byte arrays back to integers in both formats. 3. Ensure your implementations handle edge cases and are efficient in terms of time and space complexity. # Function Signature Requirements: ```python def optimized_int_to_bytes_big_endian(num: int) -> bytes: # Your implementation here pass def optimized_int_to_bytes_little_endian(num: int) -> bytes: # Your implementation here pass def optimized_bytes_big_endian_to_int(bytestr: bytes) -> int: # Your implementation here pass def optimized_bytes_little_endian_to_int(bytestr: bytes) -> int: # Your implementation here pass ``` # Input & Output Formats: 1. **`optimized_int_to_bytes_big_endian(num: int) -> bytes`** - **Input**: An integer `num` (0 <= num < 2^64). - **Output**: A `bytes` object representing the integer in big-endian format. 2. **`optimized_int_to_bytes_little_endian(num: int) -> bytes`** - **Input**: An integer `num` (0 <= num < 2^64). - **Output**: A `bytes` object representing the integer in little-endian format. 3. **`optimized_bytes_big_endian_to_int(bytestr: bytes) -> int`** - **Input**: A `bytes` object `bytestr` where the byte order is big-endian. - **Output**: An integer that the byte string represents. 4. **`optimized_bytes_little_endian_to_int(bytestr: bytes) -> int`** - **Input**: A `bytes` object `bytestr` where the byte order is little-endian. - **Output**: An integer that the byte string represents. # Constraints: - Your solutions should handle the full 64-bit integer range. - Focus on optimizing time and space complexity. - Avoid common pitfalls like inefficient list operations or unnecessary memory usage. # Performance Requirements: Your solution must efficiently handle all possible edge cases and be optimized for both time and space complexity.","solution":"def optimized_int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to a byte array in big-endian format. if num < 0 or num >= 2**64: raise ValueError(\\"Number out of the valid range (0 <= num < 2^64)\\") return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'big\') def optimized_int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to a byte array in little-endian format. if num < 0 or num >= 2**64: raise ValueError(\\"Number out of the valid range (0 <= num < 2^64)\\") return num.to_bytes((num.bit_length() + 7) // 8 or 1, byteorder=\'little\') def optimized_bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a byte array in big-endian format to an integer. return int.from_bytes(bytestr, byteorder=\'big\') def optimized_bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a byte array in little-endian format to an integer. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Scenario You are tasked with processing large, sparse vectors efficiently in a data science project. The vectors primarily contain zeros but have some significant non-zero values that are crucial for computations. Specifically, you need to perform dot product operations between these sparse vectors many times. # Problem Statement Implement a Python class `SparseVector` that stores a vector using an efficient space representation (index-value pairs) and supports dot product operations. Your class should support the following methods: - `__init__(self, vector: List[float])`: Initialize the sparse vector from a given list of floats. - `dot(self, other: SparseVector) -> float`: Calculate and return the dot product with another sparse vector. # Input and Output Formats - **Initialization**: `SparseVector` is initialized with a list of floats representing the vector. - **Dot Product**: The `dot` function takes another `SparseVector` and returns a float result of their dot product. # Constraints - The vector length is `10^6`. - The number of non-zero elements does not exceed `1000`. # Performance Requirement - Efficient space usage and average time complexity should be better than O(n) for vector size `n = 10^6`. # Implementation Requirements - Avoid storing zero values explicitly. - Optimize for performance under given constraints. # Example ```python # Initialize with sparse vectors [0.0, 1.0, 0.0, 2.0, 0.0, 0.0, 3.0] v1 = SparseVector([0.0, 1.0, 0.0, 2.0, 0.0, 0.0, 3.0]) v2 = SparseVector([1.0, 0.0, 0.0, 0.0, 2.0, 0.0, 3.0]) # Dot product should return 1*0 + 2*0 + 3*3 = 9.0 print(v1.dot(v2)) # Output: 9.0 ```","solution":"from typing import List, Dict class SparseVector: def __init__(self, vector: List[float]): Initialize the sparse vector from a given list of floats. Only non-zero elements are stored for efficiency. self.elements = {index: value for index, value in enumerate(vector) if value != 0.0} def dot(self, other: \'SparseVector\') -> float: Calculate and return the dot product with another sparse vector. result = 0.0 for index, value in self.elements.items(): if index in other.elements: result += value * other.elements[index] return result"},{"question":"Scenario Your task is to implement an algorithm that effectively finds indices of two elements in an array such that their sum equals a specified target value. This question will test your proficiency in utilizing data structures for efficient searches, as well as handling edge cases and optimal complexity. Problem Statement Write a function `find_two_sum_indices` that takes two parameters: - `array`: a list of integers. - `target`: an integer representing the target sum. Return a tuple of two indices of the elements in the `array` that add up to the `target`. You can assume that each input will have exactly one solution, and you may not use the same element twice. If no such pair exists, return `None`. Input Format * `array`: A list of integers (length between 2 and 10^5). * `target`: An integer within the range [-10^9, 10^9]. Output Format * A tuple of two integer indices or `None`. Constraints - The input array will contain at least two integers. - Exactly one pair of indices will sum to the `target`. - You must not use the same element twice in the sum. Performance Requirements - The function should have a time complexity of O(n) and a space complexity of O(n). Function Signature ```python def find_two_sum_indices(array: list[int], target: int) -> tuple[int, int]: ``` Example Input: ```python array = [2, 7, 11, 15] target = 9 ``` Output: ```python (0, 1) ``` Explanation: - Because `array[0] + array[1] = 2 + 7 = 9`, the function returns `(0, 1)`. Inclusive edge cases: ```python array = [0, -1] target = -1 ``` Output should be: ```python (0, 1) ``` Ensure your solution efficiently handles edge cases and meets the performance constraints.","solution":"def find_two_sum_indices(array, target): Returns a tuple of two indices whose elements sum to the target. seen = {} for i, num in enumerate(array): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"Implement Tree Traversals Context In this assessment, you will implement tree traversal methods on a given binary search tree (BST) to explore different orders of visiting the nodes. Problem Statement You are given a class Node that defines a node in a binary search tree and two methods `inorder` and `inorder_rec` that perform in-order traversal of the tree. Now, you need to extend this functionality to implement two additional traversal methods for pre-order (root-left-right) and post-order (left-right-root) traversal. Task Implement the following two functions: 1. **preorder(root)**: Takes the root of a binary search tree and returns a list of values representing the in-order traversal of the tree. 2. **postorder(root)**: Takes the root of a binary search tree and returns a list of values representing the in-order traversal of the tree. **Function Signatures**: ```python def preorder(root: Node) -> [int]: pass def postorder(root: Node) -> [int]: pass ``` Input and Output * **Input**: A `Node` object representing the root of a BST. * **Output**: * `preorder(root)` should return a list of node values in pre-order. * `postorder(root)` should return a list of node values in post-order. Constraints * The number of nodes in the tree will not exceed `10^4`. * Each node\'s value will be a unique integer in the range `[1, 10^5]`. Example ```python if __name__ == \'__main__\': n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert preorder(n1) == [100, 50, 25, 75, 150, 125, 175] assert postorder(n1) == [25, 75, 50, 125, 175, 150, 100] ``` You should write your implementations of `preorder` and `postorder` functions to correctly perform the specified tree traversals.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def preorder(root: Node) -> [int]: Perform preorder traversal (root-left-right) on a binary search tree. if root is None: return [] return [root.val] + preorder(root.left) + preorder(root.right) def postorder(root: Node) -> [int]: Perform postorder traversal (left-right-root) on a binary search tree. if root is None: return [] return postorder(root.left) + postorder(root.right) + [root.val]"},{"question":"BSTIterator Objective: Implement an iterator over a binary search tree (BST). Your `BSTIterator` class must be able to iterate through the nodes\' values in ascending order. Guidelines: 1. **Initialization**: Create an iterator object with the root of the BST. 2. **Methods**: Implement two methods: - `has_next()`: Returns `True` if there is a next element in the in-order traversal, otherwise returns `False`. - `next()`: Returns the next smallest element in the BST, deploying the in-order traversal. Input: - An integer array representing pre-order traversal of a BST. Output: - A sequence of integers generated from the `next()` method calls in ascending order. Constraints: - `0 <= Number of nodes <= 10^4` - Node values are unique and conform to BST properties. Performance Requirements: - Ensure that both `has_next()` and `next()` methods perform efficiently regarding time and space complexity. Example Usage: ```python # Constructing a BST from a list root = TreeNode(7, TreeNode(3, TreeNode(1), TreeNode(5)), TreeNode(15, TreeNode(9), TreeNode(20))) # Creating the Iterator iterator = BSTIterator(root) # Extracting elements in sorted order result = [] while iterator.has_next(): val = iterator.next() result.append(val) print(result) # Output should be [1, 3, 5, 7, 9, 15, 20] ``` Explanation: - Given a BST with the provided structure, the output should be a list of node values in ascending order obtained through in-order traversal. *Hint*: Utilize a stack to simulate the in-order traversal iteratively without recursion.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self): return len(self.stack) > 0 def next(self): topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"# Question: You are given a sorted array of integers. Your task is to implement two functions that utilize binary search to determine the index of a target value. 1. `binary_search(array, query)` - an iterative implementation. 2. `binary_search_recur(array, low, high, val)` - a recursive implementation. Implement these functions ensuring they correctly handle edge cases and provide the expected result. If the target value is not found in the array, the functions should return -1. Function Signature: ```python def binary_search(array: List[int], query: int) -> int: pass def binary_search_recur(array: List[int], low: int, high: int, val: int) -> int: pass ``` Input: * `array`: A list of sorted integers, `array`, where `1 <= len(array) <= 10^5`. * `query`: An integer, `query`, that represents the target value to search for. Output: * Return the index of `query` in `array` if it exists, otherwise return -1. Constraints: * The array is sorted in non-decreasing order. Examples: ```python array = [1, 3, 5, 7, 9, 11] query = 5 assert binary_search(array, query) == 2 assert binary_search_recur(array, 0, len(array) - 1, query) == 2 array = [1, 3, 5, 7, 9, 11] query = 6 assert binary_search(array, query) == -1 assert binary_search_recur(array, 0, len(array) - 1, query) == -1 array = [] query = 1 assert binary_search(array, query) == -1 assert binary_search_recur(array, 0, len(array) - 1, query) == -1 ``` Notes: * Ensure that your implementation does not cause integer overflow when calculating the middle index. * Pay attention to the base cases in your recursive solution to avoid infinite recursion.","solution":"from typing import List def binary_search(array: List[int], query: int) -> int: Perform an iterative binary search on a sorted array to find the index of the query value. If the query value is not in the array, return -1. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recur(array: List[int], low: int, high: int, val: int) -> int: Perform a recursive binary search on a sorted array to find the index of the val. If the val is not in the array, return -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: return binary_search_recur(array, mid + 1, high, val) else: return binary_search_recur(array, low, mid - 1, val)"},{"question":"Binomial Coefficient Calculation with Memoization Write a function, `binomial_coefficient(n: int, k: int) -> int`, that calculates the binomial coefficient (C(n, k)) using memoization to avoid redundant calculations and improve performance over the purely recursive solution. # Input: - ( n ) (0 ≤ ( n ) ≤ 1000): an integer representing the number of items. - ( k ) (0 ≤ ( k ) ≤ ( n )): an integer representing the number of items to choose. # Output: - Return an integer representing the binomial coefficient (C(n, k)). # Constraints: - Use a memoization technique to optimize the recursive approach. - Handle edge cases as described in the algorithm analysis. # Example: ```python def binomial_coefficient(n: int, k: int) -> int: # Your implementation here print(binomial_coefficient(5, 0)) # Output: 1 print(binomial_coefficient(8, 2)) # Output: 28 print(binomial_coefficient(500, 300)) # Output: 5054949849935535817667719165973249533761635252733275327088189563256... ``` # Explanation: - The function should use recursion combined with memoization to store intermediate results. - Make use of the properties (C(n, 0) = 1), (C(n, n) = 1), and (C(n, k) = C(n, n-k)) to optimize the computation.","solution":"def binomial_coefficient(n: int, k: int, memo=None) -> int: if memo is None: memo = {} # Base cases if k == 0 or k == n: return 1 # Check if value is already computed if (n, k) in memo: return memo[(n, k)] # Using the property C(n, k) = C(n-1, k-1) + C(n-1, k) memo[(n, k)] = binomial_coefficient(n - 1, k - 1, memo) + binomial_coefficient(n - 1, k, memo) return memo[(n, k)]"},{"question":"You are tasked with calculating the edit distance (Levenshtein distance) between two words. Your goal is to write a function `min_edit_distance(word_a, word_b)` that computes the minimum number of operations required to convert `word_a` into `word_b`. Operations allowed are insertion, deletion, or substitution of characters. # Input - `word_a`: A string (1 <= len(word_a) <= 1000) - `word_b`: A string (1 <= len(word_b) <= 1000) # Output - An integer representing the minimum number of operations required to transform `word_a` into `word_b`. # Constraints - All characters are lower-case English letters. # Example ```python assert min_edit_distance(\\"FOOD\\", \\"MONEY\\") == 4 assert min_edit_distance(\\"a\\", \\"b\\") == 1 assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert min_edit_distance(\\"\\", \\"a\\") == 1 assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 ``` # Requirements - Use dynamic programming to solve the problem. - Maintain a 2D matrix to keep track of edit distances between prefixes of the two words. - Ensure the time complexity is O(length_a * length_b). # Code Template ```python def min_edit_distance(word_a, word_b): Calculates the minimum number of operations required to convert word_a to word_b Keyword arguments: word_a -- string word_b -- string Returns: An integer representing the minimum edit distance. # Your code here ``` # Additional Notes - You should handle different edge cases like one or both strings being empty. - Consider performance optimizations to handle the upper input limits effectively.","solution":"def min_edit_distance(word_a, word_b): len_a = len(word_a) len_b = len(word_b) # Create a 2D array to store the edit distances dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize the first row and first column for i in range(1, len_a + 1): dp[i][0] = i for j in range(1, len_b + 1): dp[0][j] = j # Fill the dp table for i in range(1, len_a + 1): for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 return dp[len_a][len_b]"},{"question":"# Question: Path Splitter Function You are provided with a task to split a given file path or URL into two parts: 1. The path excluding the last part (which is generally the file name). 2. The last part itself (the file name). Implement a function `split_path(path: str) -> List[str]` that splits the given path into the desired two parts based on the last occurrence of the delimiter \'/\'. Input - A single string `path` representing the file path or URL which contains one or more \'/\' characters. - `1 <= len(path) <= 10^4` Output - A list of two strings: - The first string should be the path excluding the last part after the last `/`. - The second string should be the last part of the path following the last `/`. Example ```python Input: \\"https://algorithms/unix/test.py\\" Output: [\\"https://algorithms/unix\\", \\"test.py\\"] Input: \\"algorithms/unix/test.py\\" Output: [\\"algorithms/unix\\", \\"test.py\\"] Input: \\"folder/subfolder/\\" Output: [\\"folder/subfolder\\", \\"\\"] ``` Constraints - The path will always contain at least one \'/\' character. Instructions 1. Define the function `split_path(path: str) -> List[str]`. 2. Ensure your solution is efficient and correctly handles edge cases as described.","solution":"def split_path(path: str) -> list: Splits the given path or URL into two parts: 1. The path excluding the last part (generally the file name). 2. The last part itself (the file name). :param path: The full path as a string. :return: A list containing the path (excluding the last part) and the last part. # Find the last occurrence of \'/\' last_slash_index = path.rfind(\'/\') # Split into the two parts head = path[:last_slash_index] tail = path[last_slash_index + 1:] return [head, tail]"},{"question":"# Find Repeated Substring Pattern **Objective**: Your objective is to determine if a given string can be constructed by repeating a substring within it multiple times. **Problem Statement**: You are provided with a non-empty string. Write a function that returns `True` if the string can be constructed by taking a substring of it and appending multiple copies of the substring together. Otherwise, return `False`. **Function Signature**: ```python def repeat_substring(s: str) -> bool: pass ``` **Input**: - A single non-empty string `s` (1 <= length(s) <= 10^4), consisting of lowercase English letters only. **Output**: - Return a boolean value, `True` if the string can be constructed by repeating a substring of it multiple times, `False` otherwise. **Examples**: ```python assert repeat_substring(\\"abab\\") == True assert repeat_substring(\\"aba\\") == False assert repeat_substring(\\"abcabcabcabc\\") == True ``` **Constraints**: - The function should handle the string within the provided constraints efficiently. - Consider edge cases like single character strings and strings without any repeated patterns. **Performance Requirement**: - The solution should aim for a time complexity of O(n) and space complexity of O(n), where n is the length of the input string. **Scenario**: You are developing a data validator for a network protocol where data is sent in repeated sequences. Your role is to ensure that the data sequence does not have any form of unwanted repetition patterns which can cause data inconsistencies. **Note**: This question tests your ability to leverage string properties effectively and demonstrate understanding of linear time complexity solutions for string manipulation problems.","solution":"def repeat_substring(s: str) -> bool: Returns True if the string can be constructed by repeating a substring, otherwise False. n = len(s) for i in range(1, n//2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"# Pigeonhole Sort Evaluation Scenario: You are given a list of integers where the spread between the smallest and largest number is relatively small. Your task is to implement a sorting function based on the Pigeonhole Sort algorithm to order the elements in non-decreasing order. Function Signature: ```python def pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input: * A list of integers `arr` with length `n`, where `1 <= n <= 10^6` and `-10^6 <= arr[i] <= 10^6`. Output: * A list of integers sorted in non-decreasing order. Constraints: * The range (`Max - Min + 1`) of elements should not exceed 10^6. * Consider all possible edge conditions such as empty lists or lists with identical elements. Examples: ```python assert pigeonhole_sort([8, 3, 2, 7, 4]) == [2, 3, 4, 7, 8] assert pigeonhole_sort([9, 5, 3, 1, 7, 7, 2]) == [1, 2, 3, 5, 7, 7, 9] assert pigeonhole_sort([-5, -10, 0, 5, -1, 5, -10]) == [-10, -10, -5, -1, 0, 5, 5] assert pigeonhole_sort([]) == [] ``` Implementation: Write a `pigeonhole_sort` function that implements the pigeonhole sort algorithm as described. Ensure your code handles large inputs efficiently within the given constraints.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [[] for _ in range(size)] for num in arr: holes[num - min_val].append(num) sorted_arr = [] for hole in holes: sorted_arr.extend(hole) return sorted_arr"},{"question":"# Bitonic Sort Implementation Challenge You are tasked with implementing a variant of the Bitonic Sort algorithm that can handle arrays whose size may not be a power of two. Your goal is to write a function `custom_bitonic_sort` which sorts an array in ascending order irrespective of the array length. Function Signature: ```python def custom_bitonic_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr` - A list of integers of any length (0 <= len(arr) <= 10^5). # Output: * Returns a new list containing the elements of `arr` sorted in ascending order. # Constraints: * You need to ensure that the function can handle cases where the size of the array is not a power of two. * You are encouraged to achieve a time complexity of O(n log(n)^2) or better. * Avoid using built-in sort functions. # Examples: ```python assert custom_bitonic_sort([3, 7, 4, 8, 6, 2, 1, 5]) == [1, 2, 3, 4, 5, 6, 7, 8] assert custom_bitonic_sort([10, 20, 30, 40]) == [10, 20, 30, 40] assert custom_bitonic_sort([10, 20, -10, 0]) == [-10, 0, 10, 20] assert custom_bitonic_sort([]) == [] ``` # Notes: 1. If the input array is empty, the function should return an empty list. 2. Ensure to handle both small and large input arrays efficiently. # Hints: * Think about how you can modify the bitonic sort to handle arrays not being a power of two. One approach could be padding the array with a large value that will naturally move to the end through the sorting process and then be removed. * Focus on creating a bitonic sequence irrespective of array size first, then implement the merging function.","solution":"def custom_bitonic_sort(arr): def compare_and_swap(arr, i, j, direction): if (direction == 1 and arr[i] > arr[j]) or (direction == 0 and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, count, direction): if count > 1: mid = count // 2 for i in range(low, low + mid): compare_and_swap(arr, i, i + mid, direction) bitonic_merge(arr, low, mid, direction) bitonic_merge(arr, low + mid, mid, direction) def bitonic_sort(arr, low, count, direction): if count > 1: mid = count // 2 bitonic_sort(arr, low, mid, 1) # Sort in ascending order bitonic_sort(arr, low + mid, mid, 0) # Sort in descending order bitonic_merge(arr, low, count, direction) # Pad the array to the next power of two n = len(arr) if n == 0: return [] power_of_two = 1 while power_of_two < n: power_of_two <<= 1 padded_arr = arr + [float(\'inf\')] * (power_of_two - n) bitonic_sort(padded_arr, 0, power_of_two, 1) return padded_arr[:n]"},{"question":"You are given very large sparse vectors, which contain a lot of zeros, and you need to design a data structure to effectively store these vectors and to compute the dot product of two sparse vectors efficiently. # Requirements 1. Implement a class `SparseVector` that supports storing and computing the dot product of sparse vectors. 2. Your implementation should include the following methods: * `__init__(self, vector: List[float])`: Initialize the `SparseVector` with the given dense vector. * `dot_product(self, other: \'SparseVector\') -> float`: Calculate the dot product of this sparse vector with another `SparseVector`. 3. Assume the input vector has a fixed size of `n`, where `1 <= n <= 10^7`, and most of the elements are zero. # Constraints * You cannot store the entire dense vector in memory due to size constraints. * The method to calculate the dot product should run in linear time relative to the number of non-zero elements in the vectors. # Example ```python class SparseVector: def __init__(self, vector: List[float]): pass def dot_product(self, other: \'SparseVector\') -> float: pass # Example Usage vector1 = [1.0, 2.0, 0.0, 3.0, 0.0] vector2 = [0.0, 2.0, 2.0, 0.0, 1.0] sv1 = SparseVector(vector1) sv2 = SparseVector(vector2) result = sv1.dot_product(sv2) print(result) # Output should be 4.0 ``` # Explanation In this example: * The first vector contains non-zero elements at indices 0, 1, and 3. * The second vector contains non-zero elements at indices 1, 2, and 4. * The dot product calculation involves only the matching indices: [ text{dot_product} = (2.0 * 2.0) = 4.0 ] # Notes * Ensure your implementation handles cases where there are no common non-zero indices. * Carefully consider the edge cases and performance requirements. * Write efficient code as the vectors can be very large.","solution":"from typing import List, Dict class SparseVector: def __init__(self, vector: List[float]): Initialize the SparseVector with the given dense vector. We only store the non-zero elements with their indices. self.vector = {i: val for i, val in enumerate(vector) if val != 0} def dot_product(self, other: \'SparseVector\') -> float: Calculate the dot product of this sparse vector with another SparseVector. result = 0.0 for i, val in self.vector.items(): if i in other.vector: result += val * other.vector[i] return result"},{"question":"# Task You are to implement a function that takes a single unsigned integer as input and returns another integer that results from swapping each pair of bits in the binary representation of the input number. # Function Signature ```python def swap_pair(num: int) -> int: # your code here ``` # Input * An unsigned integer `num`, where `0 <= num <= 2^32 - 1`. # Output * An unsigned integer resulting from the bit-swapping of the input integer. # Example ```python swap_pair(22) == 41 swap_pair(10) == 5 swap_pair(0b10101010101010101010101010101010) == 0b01010101010101010101010101010101 swap_pair(0) == 0 ``` # Description * Each bit pair in the integer should be swapped. * For example: * The number `22` in binary is `010110`. Swapping each pair of bits results in `101001`, which is `41` in decimal. * The number `10` in binary is `1010`. Swapping each pair of bits results in `0101`, which is `5` in decimal. # Constraints * The solution must execute in constant time O(1). * You cannot use a loop to iterate through individual bits. # Notes * Use fixed constants for the bitwise masks `(0xAAAAAAAA, 0x55555555)` which respectively isolate the odd and even bits.","solution":"def swap_pair(num: int) -> int: Swap each pair of bits in the binary representation of the input number. even_bits = num & 0xAAAAAAAA # Mask even bits using 0xAAAAAAAA odd_bits = num & 0x55555555 # Mask odd bits using 0x55555555 even_bits_shifted = even_bits >> 1 # Shift even bits right odd_bits_shifted = odd_bits << 1 # Shift odd bits left return even_bits_shifted | odd_bits_shifted # Combine shifted bits # Examples print(swap_pair(22)) # Should return 41 print(swap_pair(10)) # Should return 5 print(swap_pair(0xAAAAAAAA)) # Should return 0x55555555 print(swap_pair(0)) # Should return 0"},{"question":"You are tasked with improving the provided `ResizableHashTable` to optimize its performance and make it more robust. Your goal is to modify the resizing mechanism to use a prime number size for the hash table that ensures better distribution and reduces collisions. You also need to improve the rehashing strategy from linear probing to double hashing. # Requirements 1. **Resizing**: Implement resizing such that the table size is always a prime number. You may use a helper function `next_prime(n)` that takes an integer `n` and returns the next prime number greater than `n`. 2. **Collision Resolution**: Use double hashing for collision resolution. Modify the `_rehash` method to implement double hashing. Make use of a second hash function. 3. **Helper Function**: Implement a helper function to calculate the next prime number. # Implementation Details * **Input and Output**: There\'s no direct input/output function beyond key-value operations provided in the base class. * **Constraints**: The solution should manage the table size dynamically without causing significant degradation in performance. * **Hint for `next_prime` function**: ```python def next_prime(n): def is_prime(num): if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True next_ = n while True: next_ += 1 if is_prime(next_): return next_ ``` # Objective Complete the implementation of `ResizableHashTable` as described. Consider testing with various scenarios of inserting, deleting, and resizing to validate the robustness and efficiency of your implementation. # Notes * You do not need to consider deletion of the table itself or managed memory beyond default Python operations. * Validate edge cases where resizing might occur repeatedly. * Assume table sizes can grow up to the limit of standard integer ranges.","solution":"class ResizableHashTable: def __init__(self): self.initial_size = 11 self.table = [None] * self.initial_size self.count = 0 def _hash1(self, key): return hash(key) % len(self.table) def _hash2(self, key): return 1 + (hash(key) % (len(self.table) - 2)) def _rehash(self, first_hash, second_hash, i): return (first_hash + i * second_hash) % len(self.table) def next_prime(self, n): def is_prime(num): if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True next_ = n while True: next_ += 1 if is_prime(next_): return next_ def _resize(self): new_size = self.next_prime(len(self.table) * 2) old_table = self.table self.table = [None] * new_size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def put(self, key, value): if self.count / len(self.table) > 0.5: self._resize() first_hash = self._hash1(key) second_hash = self._hash2(key) i = 0 while self.table[first_hash] is not None and self.table[first_hash][0] != key: i += 1 first_hash = self._rehash(first_hash, second_hash, i) if self.table[first_hash] is None: self.count += 1 self.table[first_hash] = (key, value) def get(self, key): first_hash = self._hash1(key) second_hash = self._hash2(key) i = 0 while self.table[first_hash] is not None: if self.table[first_hash][0] == key: return self.table[first_hash][1] i += 1 first_hash = self._rehash(first_hash, second_hash, i) return None"},{"question":"You are given a list of integers sorted in ascending order and a target sum. Your task is to write a Python function `optimal_two_sum(numbers: List[int], target: int) -> List[int]` that returns the indices of the two numbers in the list that add up to the target sum. The returned indices should be 1-based (non-zero based), and you may assume that there is exactly one unique solution. # Implementation Details 1. **Function Signature**: ```python def optimal_two_sum(numbers: List[int], target: int) -> List[int]: ``` 2. **Input**: * `numbers`: A list of integers sorted in ascending order. * `target`: An integer representing the target sum. 3. **Output**: * A list containing two integers, representing the 1-based indices of the two numbers that add up to the target. 4. **Constraints**: * The length of input list `numbers` will be in the range `[2, 10^5]`. * Each element in `numbers` is in the range `[-10^3, 10^3]`. * There will be exactly one solution, and you may not use the same element twice. # Performance Requirements Your solution should have a time complexity of O(n) and space complexity of O(1) to handle large input sizes efficiently. # Function Example ```python def test_optimal_two_sum(): assert optimal_two_sum([2, 7, 11, 15], 9) == [1, 2], \\"Test case 1 failed\\" assert optimal_two_sum([-3, 3, 4, 90], 0) == [1, 2], \\"Test case 2 failed\\" assert optimal_two_sum([1, 2, 3, 4, 4, 9], 8) == [4, 5], \\"Test case 3 failed\\" print(\\"All test cases pass\\") test_optimal_two_sum() ``` Utilize the two pointers approach for optimal performance. Ensure your implementation correctly handles all edge cases and validates the constraints specified.","solution":"from typing import List def optimal_two_sum(numbers: List[int], target: int) -> List[int]: This function returns the 1-based indices of two numbers in the sorted list that add up to the target sum. left = 0 right = len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] elif current_sum < target: left += 1 else: right -= 1 # There is guaranteed to be exactly one solution according to the problem statement. return []"},{"question":"Segment Tree Implementation and Modification # Objective You are to implement a segment tree with functionality for range sum queries and single element updates. This will assess your understanding of segment trees and your ability to manipulate them for efficient queries and updates. # Task 1. Implement the segment tree to handle queries efficiently. 2. Add an update function to modify elements and adjust the tree accordingly. # Function Specifications Class: `AdvancedSegmentTree` 1. **__init__(self, arr)**: - Initializes the segment tree with a given list of numbers. - Constructs the tree for range sum queries. - Parameters: `arr` (List[int]): A list of integers. 2. **query(self, L, R)**: - Perform a range sum query from index `L` to `R`. - Returns: An integer representing the sum of the values in the interval. - Constraints: 0 <= L <= R < len(arr) 3. **update(self, index, value)**: - Updates the value at the given index and adjusts the segment tree. - Parameters: index (int): The index to update. value (int): New value at specified index. - Constraints: 0 <= index < len(arr) # Example ```python # Example usage of the AdvancedSegmentTree # Initialize the tree ast = AdvancedSegmentTree([1, 3, 5, 7, 9, 11]) # Range sum query from index 1 to 3 print(ast.query(1, 3)) # Output: 15 (3 + 5 + 7) # Update the value at index 3 to 10 ast.update(3, 10) # Range sum query from index 1 to 3 again print(ast.query(1, 3)) # Output: 18 (3 + 5 + 10) ``` # Constraints - The length of the array will be between 1 and 10^4. - The values in the array will be between -10^4 and 10^4. - Assume the input to `query` and `update` functions will always be within valid range. # Note Do not use inbuilt libraries for segment tree functionalities. Implement the data structure and operations from scratch.","solution":"class AdvancedSegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, index, value): # Change the index to the leaf node pos = self.n + index # Update the value at the position self.tree[pos] = value # Move upward and update parents while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def query(self, L, R): # Change the indices to the leaf nodes L += self.n R += self.n + 1 result = 0 while L < R: if L % 2 == 1: result += self.tree[L] L += 1 if R % 2 == 1: R -= 1 result += self.tree[R] L //= 2 R //= 2 return result"},{"question":"**Context**: You are working on a Natural Language Processing (NLP) project where you need to break down a given string into valid words according to a dictionary. Write a function to compute the total number of ways to segment the string into valid words present in the dictionary. **Task**: Implement a function `count_sentences(s: str, dictionary: set) -> int` that takes a string `s` and a set `dictionary` of words, and returns the total number of ways to segment the string into valid words as present in the dictionary. **Function Signature**: ```python def count_sentences(s: str, dictionary: set) -> int: ``` **Input**: 1. A string `s` (1 <= len(s) <= 1000). 2. A set `dictionary` containing unique words (1 <= len(word) for word in dictionary <= 100). **Output**: - An integer representing the total number of ways to segment the string into valid words present in the dictionary. **Constraints**: - The function should efficiently handle input strings up to 1000 characters. - The dictionary contains words that have a maximum length of 100. **Example**: ```python assert count_sentences(\\"appletablet\\", {\\"apple\\", \\"tablet\\", \\"app\\", \\"let\\", \\"applet\\", \\"able\\", \\"t\\"}) == 4 assert count_sentences(\\"thing\\", {\\"thing\\"}) == 1 ``` **Requirements**: 1. Optimize the solution to handle performance efficiently. 2. Avoid using global variables for counting. 3. Consider edge-cases such as empty string or no valid words scenario.","solution":"def count_sentences(s: str, dictionary: set) -> int: Returns the total number of ways to segment the string into valid words present in the dictionary. # Initialize an array to hold the computed results (dp array) dp = [0] * (len(s) + 1) dp[0] = 1 # There\'s exactly one way to segment an empty substring for i in range(1, len(s) + 1): for j in range(i): if s[j:i] in dictionary: dp[i] += dp[j] return dp[len(s)]"},{"question":"Scenario: You are working on a navigation system that uses a grid-based map where each cell represents a height at a specific coordinate. The height data of the grid is provided as a matrix where each row and column are sorted in non-decreasing order. You need to implement a function to search for a specific height in this matrix efficiently. Task: Design and implement a function `search_in_sorted_matrix` to find the position of a given key in a row-wise and column-wise sorted matrix. The function should return the zero-based row and column indices of the key if it is found, otherwise, return `-1, -1`. Function Signature: ```python def search_in_sorted_matrix(mat: List[List[int]], key: int) -> Tuple[int, int]: ``` Input: - `mat`: A 2D list of integers representing the matrix, where each row and column is non-decreasing order. - `key`: An integer representing the value to be searched. Output: - A tuple `(row, col)` where `row` and `col` are the zero-based positions of the `key` in the matrix. - Return `(-1, -1)` if the `key` is not found in the matrix. Constraints: - The matrix is non-empty and contains at least one row and one column. - The number of rows and columns does not exceed 500. Example: ```python matrix = [ [1, 2, 3, 4], [2, 4, 8, 10], [5, 6, 12, 15], [6, 8, 16, 18] ] key = 12 assert search_in_sorted_matrix(matrix, key) == (2, 2) key = 7 assert search_in_sorted_matrix(matrix, key) == (-1, -1) ```","solution":"from typing import List, Tuple def search_in_sorted_matrix(mat: List[List[int]], key: int) -> Tuple[int, int]: rows = len(mat) cols = len(mat[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if mat[row][col] == key: return (row, col) elif mat[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"Scenario You are implementing a text editor which has a feature to dynamically sort and insert words into a dictionary that stays in alphabetical order. The words are inserted one by one, and every new word needs to find its correct position in the sorted order quickly. Your task is to implement the helper function that identifies the correct position for each word. Task Write a function `find_insert_position` that takes a sorted list of words `dictionary` and a single `word` to be inserted. The function should return the index where the `word` should be inserted to keep the dictionary in alphabetical order. Function Signature ```python def find_insert_position(dictionary: List[str], word: str) -> int: pass ``` Input * `dictionary`: A sorted list of strings containing the dictionary words. * Constraints: 1 <= len(dictionary) <= 10^4 * `word`: A string representing the word to be inserted. * Constraints: 1 <= len(word) <= 100 Output * Return an integer index where the `word` should be inserted in the sorted list `dictionary`. Example *Example 1:* ```python find_insert_position([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"apricot\\") ``` Output: ``` 1 ``` *Example 2:* ```python find_insert_position([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"banana\\") ``` Output: ``` 1 ``` Constraints * The input list is always sorted in alphabetical order. * Duplicates are allowed. * You cannot use any external libraries for sorting or searching. * The solution should have O(log n) time complexity. Additional Notes * Consider edge cases such as inserting a word smaller or larger than all existing words in the list. * Ensure to handle insertion in an empty list appropriately.","solution":"from typing import List def find_insert_position(dictionary: List[str], word: str) -> int: This function returns the index at which the word should be inserted in the sorted list to maintain order. left, right = 0, len(dictionary) while left < right: mid = (left + right) // 2 if dictionary[mid] < word: left = mid + 1 else: right = mid return left"},{"question":"# Task: Pathfinding in Weighted Graphs You are given a weighted directed acyclic graph (DAG) represented as an adjacency list, where each edge has a weight. The graph is represented as a dictionary where the keys are nodes, and the values are lists of tuples. Each tuple consists of a neighbor node and an edge weight. Write a function to find the shortest path from a given start node to an end node in the weighted graph. Your function `find_shortest_path_weighted` should return a list of node visits representing the shortest path and the total weight of that path. Function Signature ```python def find_shortest_path_weighted(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> Tuple[List[str], int]: ``` Input * `graph`: A dictionary with nodes as keys and lists of tuples as values. Each tuple contains a neighbor and the edge weight. * `start`: The starting node (string). * `end`: The destination node (string). Output * A tuple containing: * A list of nodes representing the shortest path. * An integer representing the total weight of the path. Constraints * All edge weights are non-negative integers. * The graph is acyclic. * There will always be a valid path from `start` to `end`. Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' assert find_shortest_path_weighted(graph, start, end) == ([\'A\', \'B\', \'C\', \'D\'], 4) ``` Notes * You should use Dijkstra\'s Algorithm efficiently to ensure the optimal path is found since the graph is weighted. * Define any helper functions within your main function if necessary. * Do not use any libraries like NetworkX; your solution should be self-contained.","solution":"import heapq from typing import Dict, List, Tuple def find_shortest_path_weighted(graph: Dict[str, List[Tuple[str, int]]], start: str, end: str) -> Tuple[List[str], int]: Returns the shortest path and its weight from start node to end node in a weighted directed acyclic graph. def dijkstra(graph, start, end): # Priority queue to store (weight, node, path) queue = [(0, start, [start])] # Distances dictionary to store the minimum distance to each node distances = {node: float(\'inf\') for node in graph} distances[start] = 0 while queue: current_weight, current_node, path = heapq.heappop(queue) # If we reach the end node, return the path and its total weight if current_node == end: return (path, current_weight) # Process each neighbor for neighbor, weight in graph[current_node]: distance = current_weight + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor, path + [neighbor])) return ([], 0) # In case there is no path, return an empty path and 0 weight return dijkstra(graph, start, end)"},{"question":"Problem Statement You are given a graph represented by nodes connected to their neighboring nodes, which is serialized in a specific format. Implement a function `clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\'` that clones an input undirected graph. Your function should return a deep copy of the graph starting from the given node. # Input - `node` (UndirectedGraphNode): A node in the undirected graph. Each node has a `label` and a list of its `neighbors`. # Output - The function should return the first node from the cloned graph which is a deep copy of the original graph. # Constraints - The number of nodes in the graph is between 0 and 100. - Node labels are integers and unique. - The graph might contain cycles (including self-loops). # Examples Example 1: ``` Input: node = 0 0\'s neighbors: [1, 2] 1\'s neighbors: [2] 2\'s neighbors: [2] Output: A new graph with the same structure, starting with the node labeled 0. Visualization of Input: 1 / / 0 --- 2 / _/ Visualization of Output: 1 / / 0 --- 2 / _/ ``` # Notes: 1. Ensure your cloning considers all possible graph structures including cycles. 2. Do not mutate the original graph. 3. Handle the case where the input node is null by returning None. **Hint:** Consider using a visited nodes dictionary to track already cloned nodes to avoid cyclic references and ensure correct relinking of nodes.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None node_copy = {} def dfs(current_node): if current_node in node_copy: return node_copy[current_node] new_node = UndirectedGraphNode(current_node.label) node_copy[current_node] = new_node for neighbor in current_node.neighbors: new_node.neighbors.append(dfs(neighbor)) return new_node return dfs(node)"},{"question":"You are developing a system that sorts large datasets. One potential sorting approach is the Bucket Sort algorithm. However, the provided algorithm needs modification for robustness and efficiency. Your task is to implement a more optimized and flexible version of the Bucket Sort algorithm. # Requirements 1. Implement the function `bucket_sort(arr, num_buckets, sorting_algorithm)` that sorts an array `arr` using `num_buckets` buckets and a specified auxiliary sorting algorithm within each bucket. 2. The function should be designed to handle both uniform and non-uniform data distributions. 3. Customize the auxiliary sorting algorithm. You can start with Insertion Sort but should be able to accommodate any other chosen internal sorting. # Function Signature ```python def bucket_sort(arr: List[int], num_buckets: int, sorting_algorithm: Callable[[List[int]], List[int]]) -> List[int]: ``` # Input - `arr`: List of integers to be sorted. - `num_buckets`: An integer representing the number of buckets to use. - `sorting_algorithm`: A callable function that sorts a list of integers and returns the sorted list. # Output - A sorted list of integers. # Constraints - ( 1 leq text{len(arr)} leq 10^6 ) - ( 1 leq text{num_buckets} leq min(1000, text{len(arr)}) ) - Array elements will be non-negative integers. # Example ```python def insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): j = i - 1 key = arr[i] while arr[j] > key and j >= 0: arr[j+1] = arr[j] j = j - 1 arr[j+1] = key return arr arr = [29, 25, 3, 49, 9, 37, 21, 43] num_buckets = 4 print(bucket_sort(arr, num_buckets, insertion_sort)) # Output: [3, 9, 21, 25, 29, 37, 43, 49] ``` # Explanation - Distribute elements into `num_buckets` buckets based on their values. - Sort each bucket individually using the provided `sorting_algorithm`. - Collect sorted elements from all buckets to produce the final sorted array.","solution":"from typing import List, Callable def bucket_sort(arr: List[int], num_buckets: int, sorting_algorithm: Callable[[List[int]], List[int]]) -> List[int]: if len(arr) == 0: return arr # Find the minimum and maximum values in the array min_value = min(arr) max_value = max(arr) # Range for each bucket bucket_range = (max_value - min_value) / num_buckets + 1 # Create empty buckets buckets = [[] for _ in range(num_buckets)] # Distribute elements into buckets for num in arr: # Finding appropriate bucket for the element index = int((num - min_value) / bucket_range) buckets[index].append(num) # Sort each bucket using the provided sorting algorithm sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorting_algorithm(bucket)) return sorted_arr # Example of an auxiliary sorting algorithm: Insertion Sort def insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Question: Implement a Circular Array-based and Linked List-based Queue Your task is to implement two versions of the Queue data structure: one using a circular dynamic array and another using linked lists. Each version must extend an abstract queue class that supports typical queue operations such as enqueue, dequeue, is_empty, size, and peek. Circular Array-based Queue A circular array-based queue allows for efficient use of space by treating the array as a circular buffer. This reduces the need for shifting elements after dequeue operations. Linked List-based Queue A linked list-based queue uses a singly linked list to manage the queue, providing dynamic resizing and consistent O(1) time complex operations for enqueue and dequeue. Implementation Guidelines 1. **Class Definitions**: * Implement the `CircularArrayQueue` class. * Implement the `LinkedListQueue` class. 2. **Queue Operations**: * `enqueue(item)`: Insert an item at the rear of the queue. * `dequeue()`: Remove and return the item at the front of the queue. * `is_empty()`: Check if the queue is empty. * `size()`: Return the number of elements in the queue. * `peek()`: Return the front item without removing it. Constraints * Assume the item to be enqueued can be any type of data. * Handle edge cases such as attempting to dequeue or peek from an empty queue. * Optimize the array-based implementation to expand and contract dynamically as needed. # Function Signature ```python class AbstractQueue(metaclass=ABCMeta): def __init__(self): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass def size(self): pass class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass def size(self): pass class LinkedListQueue(AbstractQueue): def __init__(self): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass def is_empty(self): pass def size(self): pass ``` # Example ```python # Example usage of CircularArrayQueue cq = CircularArrayQueue(5) cq.enqueue(10) cq.enqueue(20) print(cq.peek()) # Output: 10 print(cq.dequeue()) # Output: 10 print(cq.is_empty()) # Output: False # Example usage of LinkedListQueue lq = LinkedListQueue() lq.enqueue(10) lq.enqueue(20) print(lq.peek()) # Output: 10 print(lq.dequeue()) # Output: 10 print(lq.is_empty()) # Output: False ``` # Requirements * Ensure your classes handle edge cases and are optimized for performance. * Provide proper error handling for invalid operations.","solution":"from abc import ABCMeta, abstractmethod class AbstractQueue(metaclass=ABCMeta): @abstractmethod def enqueue(self, value): pass @abstractmethod def dequeue(self): pass @abstractmethod def peek(self): pass @abstractmethod def is_empty(self): pass @abstractmethod def size(self): pass class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): self.capacity = capacity self.queue = [None] * capacity self.front = -1 self.rear = -1 self.count = 0 def enqueue(self, value): if self.size() == self.capacity: self._resize() if self.front == -1: self.front = 0 self.rear = (self.rear + 1) % self.capacity self.queue[self.rear] = value self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 if self.is_empty(): self.front = -1 self.rear = -1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.queue[self.front] def is_empty(self): return self.count == 0 def size(self): return self.count def _resize(self): new_capacity = self.capacity * 2 new_queue = [None] * new_capacity for i in range(self.capacity): new_queue[i] = self.queue[(self.front + i) % self.capacity] self.front = 0 self.rear = self.capacity - 1 self.capacity = new_capacity self.queue = new_queue class LinkedListQueue(AbstractQueue): class Node: def __init__(self, data): self.data = data self.next = None def __init__(self): self.front = None self.rear = None self.count = 0 def enqueue(self, value): new_node = self.Node(value) if self.rear: self.rear.next = new_node self.rear = new_node if self.front is None: self.front = new_node self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") value = self.front.data self.front = self.front.next if self.front is None: self.rear = None self.count -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty queue\\") return self.front.data def is_empty(self): return self.front is None def size(self): return self.count"},{"question":"# Context You are working on a navigation system that needs to compute all possible paths from a starting point to various destinations. In the context of a binary tree, each node represents a location, and each path from the root to a leaf node represents a viable navigation route. # Task Write a function `all_paths_in_binary_tree` that generates all possible paths from the root to the leaf nodes of a given binary tree. Each path should be represented as a string with node values separated by \'->\'. # Input - A `TreeNode` object `root`, representing the root of the binary tree. # Output - A list of strings, where each string is a path from the root to a leaf node. # Constraints - The number of nodes in the tree is between 0 and 10,000. - The node values range between -10,000 and 10,000. - The tree structure, if deep, should be managed to avoid exceeding maximum recursion depth. # Example Input ``` 1 / 2 3 5 ``` Output ``` [\\"1->2->5\\", \\"1->3\\"] ``` # Function Signature ```python def all_paths_in_binary_tree(root: TreeNode) -> List[str]: pass ```","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def all_paths_in_binary_tree(root: Optional[TreeNode]) -> List[str]: def dfs(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if reach a leaf paths.append(path) else: path += \'->\' dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \'\', paths) return paths"},{"question":"# Task: Clone an Undirected Graph You are given code snippets implementing various algorithms to clone an undirected graph using Breadth-First Search (BFS), iterative Depth-First Search (DFS), and recursive DFS. Now, apply your understanding of these algorithms to write a function that identifies if two given graphs are identical or not. # Scenario Detecting identical graphs is a fundamental problem in checking if two graphs, regardless of their node numbers, have the exact same structure and neighbor relationships. You need to ensure that both graphs have the same node labels and connections. # Function Signature ```python def are_graphs_identical(node1: UndirectedGraphNode, node2: UndirectedGraphNode) -> bool: pass ``` # Input * `node1` and `node2`: Instances of `UndirectedGraphNode`, representing the starting nodes of two undirected graphs. # Output * Returns `True` if the graphs are identical. * Returns `False` otherwise. # Constraints * Node labels are unique. * The graphs may contain cycles or self-loops. * You can assume the environment provides the definition of `UndirectedGraphNode` and the associated methods. # Performance Requirements * Time Complexity: O(V + E) * Space Complexity: O(V) # Example ```python # Define nodes for graph 1 node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) # Establish neighbors for graph 1 node0.add_neighbor(node1) node0.add_neighbor(node2) node1.add_neighbor(node2) node2.add_neighbor(node2) # Define nodes for graph 2 nodeA = UndirectedGraphNode(0) nodeB = UndirectedGraphNode(1) nodeC = UndirectedGraphNode(2) # Establish neighbors for graph 2 nodeA.add_neighbor(nodeB) nodeA.add_neighbor(nodeC) nodeB.add_neighbor(nodeC) nodeC.add_neighbor(nodeC) # Identical check print(are_graphs_identical(node0, nodeA)) # Should print True ``` Ensure your solution considers nodes that might have different addresses but identical content, accounting for graph structure rather than physical memory locations.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def add_neighbor(self, neighbor_node): self.neighbors.append(neighbor_node) def are_graphs_identical(node1: UndirectedGraphNode, node2: UndirectedGraphNode) -> bool: if not node1 and not node2: return True if not node1 or not node2: return False visited1 = {} visited2 = {} def dfs(node, visited): if node.label in visited: return visited[node.label] visited[node.label] = UndirectedGraphNode(node.label) for neighbor in node.neighbors: visited[node.label].neighbors.append(dfs(neighbor, visited)) return visited[node.label] clone1 = dfs(node1, visited1) clone2 = dfs(node2, visited2) def compare_graphs(node1, node2, visited): if node1.label in visited: return True if node1.label != node2.label: return False visited[node1.label] = True if len(node1.neighbors) != len(node2.neighbors): return False for n1, n2 in zip(node1.neighbors, node2.neighbors): if not compare_graphs(n1, n2, visited): return False return True return compare_graphs(clone1, clone2, {})"},{"question":"# Exchange Sort Variants in Python Context You are designing a series of sorting functions for educational purposes. Each function should sort a list of integers but follow slightly different logic to illustrate various sorting algorithms\' approaches. Task Implement a function `exchange_sort_variant(arr)` which sorts the input list `arr` using a variant of the exchange sort algorithm. There are two specific variants you need to implement for this exercise: 1. **Descending Order**: Modify the original exchange sort so that it sorts the array in descending order. 2. **Stable Exchange Sort**: Modify the original exchange sort so that it is stable in terms of preserving the order of equal elements. Input and Output * **Input**: A list of integers `arr` where `1 <= len(arr) <= 10^3` and each element in the list is within the range `-10^3 <= arr[i] <= 10^3`. * **Output**: A tuple of two lists: 1. The input list sorted in descending order using a variant of exchange sort. 2. The input list sorted in ascending order using a stable variant of exchange sort. Constraints and Performance - Do **not** use Python\'s built-in sorting functions. - Your implementations should be efficient enough to handle the largest permissible input size within a reasonable time frame. Examples ```python # Example 1 input_arr = [4, 2, -1, 3] output_arr = exchange_sort_variant(input_arr) print(output_arr) # Should print two sorted lists: ([4, 3, 2, -1], [-1, 2, 3, 4]) # Example 2 input_arr = [2, 2, 3, 1] output_arr = exchange_sort_variant(input_arr) print(output_arr) # Should print two sorted lists: ([3, 2, 2, 1], [1, 2, 2, 3]) ``` **Note**: Pay special attention to implementing the stable version of exchange sort correctly.","solution":"def exchange_sort_variant(arr): Implements two variants of exchange sort: 1. Descending order sort. 2. Stable ascending order sort. Returns: Tuple: containing the list sorted in descending order and the list sorted in stable ascending order. def exchange_sort_descending(arr): n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] < arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr def stable_exchange_sort(arr): n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: # Swap and maintain relative order by stable swap key = arr[j] for k in range(j, i, -1): arr[k] = arr[k - 1] arr[i] = key return arr # Sort the list in descending order descending_sorted_arr = exchange_sort_descending(arr.copy()) # Sort the list in ascending order using a stable exchange sort stable_sorted_arr = stable_exchange_sort(arr.copy()) return (descending_sorted_arr, stable_sorted_arr)"},{"question":"# Question: Large Number Bogo Sort Probability Simulation Given the highly inefficient nature of the Bogo Sort algorithm, simulate how unlikely it is to sort even a small list of elements within a reasonable timeframe. Write a function that calculates the probability of Bogo Sort successfully sorting an array within a given number of iterations. # Problem Statement Create a function `bogo_sort_probability(arr: List[int], max_iterations: int) -> Tuple[bool, int]` that: 1. Attempts to sort the array using Bogo Sort for a specified number of iterations. 2. If the array gets sorted within the given number of iterations, returns `True` with the number of iterations taken. 3. If the array is not sorted within the given number of iterations, returns `False` with the number of iterations reached. Function Signature ```python from typing import List, Tuple def bogo_sort_probability(arr: List[int], max_iterations: int) -> Tuple[bool, int]: # your code here ``` Input * `arr` - A list of integers (up to 6 integers for feasibility). * `max_iterations` - An integer defining the maximum number of iterations to attempt the sort. Output * A tuple of two values: - A boolean value (`True` if sorted within `max_iterations`, `False` otherwise). - An integer representing the number of iterations taken or the maximum number of iterations reached. # Constraints * 1 <= len(arr) <= 6 * 1 <= max_iterations <= 100000 # Example ```python print(bogo_sort_probability([3, 2, 1], 1000)) # Output: (False, 1000) print(bogo_sort_probability([1, 2, 3], 1000)) # Output: (True, 0) ``` # Scenario Imagine you are conducting a scientific experiment to determine the impracticality of Bogo Sort even for very small arrays by measuring when, if ever, a small list can be sorted by this method within a large number of allowed attempts.","solution":"import random from typing import List, Tuple def is_sorted(arr: List[int]) -> bool: Helper function to determine if the array is sorted. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def bogo_sort_probability(arr: List[int], max_iterations: int) -> Tuple[bool, int]: Attempts to sort the array using Bogo Sort for a specified number of iterations. Returns: - True and the number of iterations if sorted within max_iterations. - False and the number of iterations if not sorted within max_iterations. for iteration in range(max_iterations): if is_sorted(arr): return True, iteration random.shuffle(arr) return False, max_iterations"},{"question":"# Question: You are given an array of integers where every integer appears exactly twice, except for one integer which appears exactly once. This unique integer can be found using a linear runtime complexity without using extra memory. **Task**: Write a function `find_single_number` that takes a list of integers and returns the integer that appears only once. If every element appears twice, return 0. Function Signature: ```python def find_single_number(nums: List[int]) -> int: ``` Input: - `nums`: A list of integers where every integer appears exactly twice, except for one integer which appears exactly once. Output: - The single integer that appears once, or 0 if every integer appears twice. Constraints: - The list may contain upto (10^6) elements. - The integers can be negative or positive. - The solution must run in O(n) time complexity and use O(1) additional space. Examples: 1. **Example 1**: ```python nums = [2, 2, 3, 4, 3] print(find_single_number(nums)) # Output: 4 ``` 2. **Example 2**: ```python nums = [4, 1, 2, 1, 2] print(find_single_number(nums)) # Output: 4 ``` 3. **Example 3**: ```python nums = [1, 2, 2, 4, 1, 3, 3] print(find_single_number(nums)) # Output: 4 ``` 4. **Example 4**: ```python nums = [1, 1, 4, 4] print(find_single_number(nums)) # Output: 0 ``` Scenario Imagine you are a software developer dealing with logs of network activity where every request is logged twice except for one erroneous request logged only once. You need to identify this unique erroneous request to investigate further. Implementing the `find_single_number` function would help automate this detection process efficiently.","solution":"def find_single_number(nums): Returns the single number that appears only once in the list. If every integer appears exactly twice, returns 0. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Atbash Cipher Enhancement The Atbash cipher is a simple substitution cipher where each letter of the alphabet is mapped to its reverse. Let\'s enhance this algorithm to improve efficiency and handle additional requirements. **Enhancement Objectives:** 1. Optimize for high performance by minimizing string concatenation overhead. 2. Support for preserving whitespace and punctuation. 3. Extend functionality to include digits, where \'0\' maps to \'9\', \'1\' maps to \'8\', and so on. **Function Signature:** ```python def enhanced_atbash(s: str) -> str: pass ``` **Input:** - A single string `s` that may contain any printable ASCII characters, including letters, digits, punctuation, and whitespace. **Output:** - A new string where: - Each letter of the alphabet is replaced by its reverse counterpart while preserving their case. - Each digit \'0\'-\'9\' is replaced by \'9\'-\'0\' respectively. - All other characters (including punctuation and whitespace) are left unchanged. **Constraints:** - The input string `s` has a maximum length of 10^6 characters. **Performance Requirements:** - The algorithm must run in O(n) time complexity, where n is the length of the input string. - The solution should optimize string concatenation to avoid performance degradation on large inputs. **Example:** ```python assert enhanced_atbash(\\"Attack at dawn. 123!\\") == \\"Zggzxp zg wzdm. 876!\\" assert enhanced_atbash(\\"Hello, World! 09876\\") == \\"Svool, Dliow! 90123\\" ``` # Instructions: - Implement the `enhanced_atbash` function. - Ensure your solution handles edge cases efficiently (e.g., empty string, no alphabet/digit characters). - Optimize for performance to handle the upper constraint limit.","solution":"def enhanced_atbash(s: str) -> str: def atbash_char(c): if \'a\' <= c <= \'z\': return chr(219 - ord(c)) elif \'A\' <= c <= \'Z\': return chr(155 - ord(c)) elif \'0\' <= c <= \'9\': return chr(105 - ord(c)) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"# **Heap Sort Implementation** You are given two variants of heap sort implemented in the form of functions `max_heap_sort` and `min_heap_sort`. The `max_heap_sort` sorts an array in ascending order by converting it into a max heap and repeatedly removing the greatest element, whereas `min_heap_sort` does the same by converting the array into a min heap and removing the smallest element. Your task is to write a function `hybrid_heap_sort` that uses both `max_heap_sort` and `min_heap_sort` to sort the array. Specifically, your function should be able to seamlessly switch between the two sorting strategies based on a specified parameter. # Function Signature ```python def hybrid_heap_sort(arr, use_max_heap: bool, simulation: bool=False) -> list: # Your code here ``` # Input * `arr`: list of integers to be sorted. * `use_max_heap`: boolean; if True use `max_heap_sort`, otherwise use `min_heap_sort`. * `simulation`: boolean; if True print the intermediate steps of sorting for each iteration. # Output * A sorted list of integers. # Constraints * The input list `arr` contains at most 10^6 elements. * Each element in `arr` is an integer in the range `[-10^9, 10^9]`. # Example ```python arr = [5, 1, 9, 3, 7] print(hybrid_heap_sort(arr, use_max_heap=True, simulation=False)) # Output: [1, 3, 5, 7, 9] arr = [5, 1, 9, 3, 7] print(hybrid_heap_sort(arr, use_max_heap=False, simulation=False)) # Output: [1, 3, 5, 7, 9] ``` # Notes * The `simulation` parameter is for demonstrating the progress of the algorithm. If `True`, print the array after each significant step. * Ensure your implementation leverages the provided `max_heap_sort` and `min_heap_sort` functions for sorting to confirm comprehension of these algorithms. * Handle edge cases effectively including empty list and single element list scenarios.","solution":"def max_heapify(arr, n, i, simulation=False): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\\"Max-Heapify: {arr}\\") max_heapify(arr, n, largest, simulation) def min_heapify(arr, n, i, simulation=False): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(f\\"Min-Heapify: {arr}\\") min_heapify(arr, n, smallest, simulation) def max_heap_sort(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): max_heapify(arr, n, i, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] max_heapify(arr, i, 0, simulation) if simulation: print(f\\"Max Heap Sort Step: {arr}\\") return arr def min_heap_sort(arr, simulation=False): n = len(arr) for i in range(n // 2 - 1, -1, -1): min_heapify(arr, n, i, simulation) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] min_heapify(arr, i, 0, simulation) if simulation: print(f\\"Min Heap Sort Step: {arr}\\") arr.reverse() if simulation: print(f\\"Final reversed min heap sorted array: {arr}\\") return arr def hybrid_heap_sort(arr, use_max_heap: bool, simulation: bool=False) -> list: if use_max_heap: return max_heap_sort(arr, simulation) else: return min_heap_sort(arr, simulation)"},{"question":"Problem Description You are given a string `s` and you need to find the length of the longest substring that contains all unique characters. This substring should not have any repeating characters and should be contiguous. Function Signature ```python def longest_unique_substring(s: str) -> int: pass ``` Input * `s` (str): A string `s` consisting of lowercase and uppercase letters. Constraints: * 0 <= len(s) <= 10^5 Output * Returns an integer representing the length of the longest substring without repeating characters. Example ```python assert longest_unique_substring(\\"abcabcbb\\") == 3 # \\"abc\\" assert longest_unique_substring(\\"bbbbb\\") == 1 # \\"b\\" assert longest_unique_substring(\\"pwwkew\\") == 3 # \\"wke\\" assert longest_unique_substring(\\"\\") == 0 # \\"\\" assert longest_unique_substring(\\"a\\") == 1 # \\"a\\" ``` Requirements 1. The algorithm should run in linear time, O(n), where n is the length of the input string. 2. Space complexity should be minimized to O(min(len(s), 26)), considering only the necessary character tracking. Hint You may consider using a sliding window approach where you dynamically adjust the start and end points of the window as you traverse through the string.","solution":"def longest_unique_substring(s: str) -> int: char_index_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Polynomial Arithmetic and Operations Given the provided `Monomial` and `Polynomial` class definitions, your task is to implement the following critical function: 1. **Differentiate a Polynomial:** Write a function `differentiate_polynomial(poly: Polynomial, var_idx: int) -> Polynomial` that computes the derivative of the given polynomial with respect to the variable with index `var_idx`. Use the following rules for differentiation: - The derivative of a constant is 0. - The power rule: d/dx [a * x^n] = n * a * x^(n-1) - The sum rule: d/dx [u + v] = d/dx [u] + d/dx [v] - The polynomial class handles variable differentiation gracefully. Expected Input and Output - **Input**: - `poly` (Polynomial): The polynomial to be differentiated. - `var_idx` (int): The index of the variable with respect to which the differentiation is performed. - **Output**: - (Polynomial): The resulting polynomial after differentiation. Constraints - Assume the polynomial can have any combination of variables and coefficients. - The differentiation should correctly handle both positive and negative exponents. - Handle edge cases, such as differentiation with respect to variables that are not present in the polynomial. ```python # Example: # poly = Polynomial([Monomial({1:2}, 3), Monomial({2:3}, 4), Monomial({}, 5)]) # differentiate_polynomial(poly, 1) => Polynomial([Monomial({1:1}, 6)]) def differentiate_polynomial(poly: Polynomial, var_idx: int) -> Polynomial: pass ``` You can use the provided classes and methods to aid in your implementation. Focus on the effective usage of class methods to streamline polynomial manipulation. Remember to implement this function as part of a larger codebase that includes the provided class definitions and existing operators.","solution":"class Monomial: def __init__(self, powers, coefficient): self.powers = powers # Dictionary where key is variable index and value is the power of the variable self.coefficient = coefficient def differentiate(self, var_idx): if var_idx in self.powers: new_powers = self.powers.copy() exponent = new_powers[var_idx] new_coefficient = self.coefficient * exponent if exponent == 1: del new_powers[var_idx] else: new_powers[var_idx] = exponent - 1 return Monomial(new_powers, new_coefficient) else: return Monomial({}, 0) def __eq__(self, other): return self.powers == other.powers and self.coefficient == other.coefficient class Polynomial: def __init__(self, monomials): self.monomials = monomials def differentiate(self, var_idx): differentiated_monomials = [monomial.differentiate(var_idx) for monomial in self.monomials] differentiated_monomials = [m for m in differentiated_monomials if m.coefficient != 0] return Polynomial(differentiated_monomials) def __eq__(self, other): return self.monomials == other.monomials def differentiate_polynomial(poly: Polynomial, var_idx: int) -> Polynomial: return poly.differentiate(var_idx)"},{"question":"# Scenario: You are tasked with implementing a Hash Table to store user data for a new Web application. The hashing mechanism should allow for dynamic growth as the dataset increases and must handle common edge cases like collisions efficiently. Additionally, ensure performance remains optimal with varying load conditions by implementing a dynamic resize mechanism. # Task: Implement the `ResizableHashTable` class provided by completing the resizing mechanism and ensuring the correctness of the primary methods (`put`, `get`, `del_`, `__resize`). Write the `ResizableHashTable` class in Python with the following specifications: 1. Implement a `put(self, key, value)` method: - **Input**: `key` (an integer), `value` (string or integer). - **Output**: None. Should handle dynamic resizing and linear probing for collisions. 2. Implement a `get(self, key)` method: - **Input**: `key` (an integer). - **Output**: The value stored for the given key or `None` if the key does not exist. 3. Implement a `del_(self, key)` method: - **Input**: `key` (an integer). - **Output**: None. Should mark the key as deleted and reclaim the space. 4. Implement an internal `__resize(self)` method: - **Input**: None. - **Output**: None. Should double the table size and rehash all existing keys. 5. The hash function and linear probing method are provided for you. Use these within your implementations. 6. Implement proper handling of edge cases including insertion of duplicate keys and full table scenarios. # Input/Output: ```python # Sample input execution: ht = ResizableHashTable() ht.put(10, \\"Value1\\") ht.put(21, \\"Value2\\") # This will collide and should be handled print(ht.get(10)) # Output: \\"Value1\\" print(ht.get(21)) # Output: \\"Value2\\" ht.del_(21) print(ht.get(21)) # Output: None # Simulate heavy load to trigger resizing for i in range(20): ht.put(i, f\\"Val{i}\\") print(ht.size) # Output: Size should be increased from initial when load factor > 2/3 ``` Constraints: - Size of the hash table should start at a minimum of 8. - Handle integer keys only. - The hash table should resize itself (double the size) when the load factor exceeds 2/3. # Performance Requirements: - Ensure the resizing method maintains O(n) average time complexity. - Aim for O(1) average time complexity for insertions, lookups, and deletions.","solution":"class ResizableHashTable: def __init__(self): self.initial_size = 8 self.table = [None] * self.initial_size self.size = 0 self.load_factor_threshold = 2 / 3 def hash_function(self, key): return key % len(self.table) def put(self, key, value): if self.size / len(self.table) > self.load_factor_threshold: self.__resize() index = self.hash_function(key) original_index = index while self.table[index] is not None and self.table[index] != \\"DELETED\\": if self.table[index][0] == key: break index = (index + 1) % len(self.table) if index == original_index: # If we looped through the entire table raise Exception(\\"Table is full, which should not happen after resize.\\") if self.table[index] is None or self.table[index] == \\"DELETED\\": self.size += 1 self.table[index] = (key, value) def get(self, key): index = self.hash_function(key) original_index = index while self.table[index] is not None: if self.table[index] != \\"DELETED\\" and self.table[index][0] == key: return self.table[index][1] index = (index + 1) % len(self.table) if index == original_index: # If we looped through the entire table break return None def del_(self, key): index = self.hash_function(key) original_index = index while self.table[index] is not None: if self.table[index] != \\"DELETED\\" and self.table[index][0] == key: self.table[index] = \\"DELETED\\" self.size -= 1 return index = (index + 1) % len(self.table) if index == original_index: # If we looped through the entire table break def __resize(self): old_table = self.table new_size = len(self.table) * 2 self.table = [None] * new_size self.size = 0 for item in old_table: if item is not None and item != \\"DELETED\\": self.put(item[0], item[1])"},{"question":"# Question: Transitive Closure Implementation **Objective**: Implement the `transitive_closure` method for the `Graph` class to determine the reachability of vertices in a directed graph. # Context You are given a directed graph, and you need to determine the reachability between all pairs of its vertices. For each pair (u, v), you should identify if there is a path from vertex u to vertex v. # Implementation Details 1. Implement the method `transitive_closure` within the `Graph` class. 2. Your method should produce a matrix that depicts if each vertex is reachable from another vertex. # Function Signature ```python def transitive_closure(self) -> List[List[int]]: # Your code here ``` # Input * `self` (Graph): An instance of the `Graph` class containing: - `vertex_count` (int): The number of vertices in the graph. - `graph` (Dict[int, List[int]]): Adjacency list representation of the graph. - `closure` (List[List[int]]): Initially zero-filled matrix for transitive closure. # Output * Returns a `List[List[int]]` matrix of size `vertex_count x vertex_count` representing reachability as: - `closure[u][v]` is 1 if vertex v is reachable from vertex u. # Example Let\'s consider a graph with 4 vertices and edges as follows: (0→1), (1→2), (2→3). The transitive closure of the graph will be represented as: ``` [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1]] ``` # Constraints * You can assume that the graph does not contain any parallel edges or self-loops. * The vertex IDs are from 0 to vertex_count - 1. # Notes * Your function should modify the `closure` matrix within the `Graph` instance. * Ensure your solution handles graphs with isolated vertices. * Optimize for edge cases, such as empty graphs or single-node graphs.","solution":"from typing import List, Dict class Graph: def __init__(self, vertex_count: int, edges: List[tuple]): self.vertex_count = vertex_count self.graph = {i: [] for i in range(vertex_count)} for u, v in edges: self.graph[u].append(v) self.closure = [[0] * vertex_count for _ in range(vertex_count)] def transitive_closure(self) -> List[List[int]]: def dfs(v, u): self.closure[v][u] = 1 for neighbor in self.graph[u]: if not self.closure[v][neighbor]: dfs(v, neighbor) for i in range(self.vertex_count): dfs(i, i) return self.closure"},{"question":"# Find the Last Occurrence Using Linear Search **Scenario**: You are given a list of integers and a target integer. Your task is to find the **last occurrence** of the target integer in the list. If the target integer does not exist in the list, return -1. **Function Signature**: ```python def find_last_occurrence(array: list[int], target: int) -> int: ``` **Input**: - `array`: A list of integers. Can be empty. - `target`: An integer to find in the list. **Output**: - An integer representing the index of the last occurrence of the target integer in the list, or -1 if the target is not found. **Constraints**: - Try to achieve the solution with a single pass of the array. - The length of the array can be up to 10^6. - The array can contain negative numbers. **Examples**: ```python assert find_last_occurrence([1, 2, 3, 4, 5, 6, 4], 4) == 6 assert find_last_occurrence([1, 2, 3, 4, 5, 6, 4], 8) == -1 assert find_last_occurrence([7, 7, 7, 7], 7) == 3 assert find_last_occurrence([], 1) == -1 assert find_last_occurrence([1, 2, 3, 1, 2, 3], 2) == 4 assert find_last_occurrence([10], 10) == 0 assert find_last_occurrence([1, 2, 3, 3], 3) == 3 ``` **Explanation**: - In the first example, `4` appears last at index `6`. - In the second example, `8` does not appear in the list, so the function returns -1. - The rest of the examples follow similar logic.","solution":"def find_last_occurrence(array: list[int], target: int) -> int: Returns the index of the last occurrence of the target integer in the array, or -1 if the target is not found. last_occurrence_index = -1 for i in range(len(array)): if array[i] == target: last_occurrence_index = i return last_occurrence_index"},{"question":"Merging Intervals You are given a list of `Interval` objects, each representing a set of consecutive integer real numbers. Your task is to merge all overlapping intervals and return the merged intervals as a list. Requirements: 1. Implement a function `merge_intervals(intervals: List[Interval]) -> List[Interval]` to merge overlapping intervals. 2. The merged intervals should be represented by new `Interval` instances, maintaining the order of their appearance. Input and Output Formats: **Input**: - A list of `Interval` objects `intervals`, where each `Interval` object has attributes `start` and `end`. **Output**: - A list of `Interval` objects, where overlapping intervals are merged. Constraints: 1. The list `intervals` may be empty. 2. Intervals are not necessarily sorted. 3. The start and end of the intervals are inclusive and exclusive, respectively. 4. Intervals may contain negative numbers, zero, or positive numbers. # Example: ```python intervals = [Interval(1, 3), Interval(2, 4), Interval(5, 7), Interval(6, 8)] merged = merge_intervals(intervals) print([(i.start, i.end) for i in merged]) ``` **Output:** ``` [(1, 4), (5, 8)] ``` # Constraints to Consider: 1. Efficient implementation is critical. Aim for O(n log n) time complexity due to sorting. 2. Handle edge cases like empty lists, singleton lists, completely overlapping intervals, and adjacent intervals. # Hints: 1. Sorting intervals by their start value is a key step to simplify the merging process. 2. Efficient storage and updating of the result list are essential to avoid excessive time complexity.","solution":"from typing import List class Interval: def __init__(self, start: int, end: int): self.start = start self.end = end def merge_intervals(intervals: List[Interval]) -> List[Interval]: if not intervals: return [] # Sort intervals by the starting value intervals.sort(key=lambda x: x.start) merged = [intervals[0]] for current in intervals[1:]: last_merged = merged[-1] if current.start <= last_merged.end: # If overlapping, merge the intervals last_merged.end = max(last_merged.end, current.end) else: # If not overlapping, add the interval to merged list merged.append(current) return merged"},{"question":"# Question: Enhanced Insertion Sort with Simulation and Median You are tasked with implementing an enhanced version of the Insertion Sort algorithm. In addition to sorting a list of integers, your algorithm should have two additional functionalities: providing a step-by-step simulation of the sorting process (if requested) and returning the median of the sorted list. **Function Signature**: ```python def enhanced_insertion_sort(arr: list, simulation: bool = False) -> dict: Sorts an array using the insertion sort algorithm, can provide a simulation of the sorting process, and returns the median of the sorted array. Parameters: arr (list): A list of integers to sort. simulation (bool): If True, print the array after each iteration. Default is False. Returns: dict: A dictionary with two keys: - \'sorted_array\': The sorted array. - \'median\': The median of the sorted array. ``` **Input**: - A list of integers (`arr`) to be sorted. - A boolean (`simulation`) indicating whether to print the array after each iteration. **Output**: - A dictionary with: - `\'sorted_array\'`: The sorted list of integers. - `\'median\'`: The median value of the sorted list. **Constraints**: - The list can contain between 0 and 10^6 elements. - Elements in the list can range from -10^9 to 10^9. - Median calculation: - If the list has an odd number of elements, the median is the middle element. - If the list has an even number of elements, the median is the average of the two middle elements. **Examples**: 1. **Input**: `arr = [3, 1, 2, 5, 4]`, `simulation = False` **Output**: `{\'sorted_array\': [1, 2, 3, 4, 5], \'median\': 3.0}` 2. **Input**: `arr = [5, 2, 9, 1, 5, 6]`, `simulation = True` **Output**: ``` iteration 0: 5 2 9 1 5 6 iteration 1: 2 5 9 1 5 6 iteration 2: 2 5 9 1 5 6 iteration 3: 1 2 5 9 5 6 iteration 4: 1 2 5 5 9 6 iteration 5: 1 2 5 5 6 9 {\'sorted_array\': [1, 2, 5, 5, 6, 9], \'median\': 5.0} ``` **Task**: Implement the `enhanced_insertion_sort` function that adheres to the above specifications. Ensure efficiency and proper handling of edge cases as per the guidelines.","solution":"def enhanced_insertion_sort(arr: list, simulation: bool = False) -> dict: Sorts an array using the insertion sort algorithm, can provide a simulation of the sorting process, and returns the median of the sorted array. Parameters: arr (list): A list of integers to sort. simulation (bool): If True, print the array after each iteration. Default is False. Returns: dict: A dictionary with two keys: - \'sorted_array\': The sorted array. - \'median\': The median of the sorted array. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") # Calculate the median if n == 0: median = None else: mid = n // 2 if n % 2 == 0: median = (arr[mid - 1] + arr[mid]) / 2 # Average of two middle elements else: median = arr[mid] # Middle element return {\'sorted_array\': arr, \'median\': median}"},{"question":"You\'re provided with a stack of integers. Write a function `sort_stack` that sorts the given stack in ascending order from the bottom element to the top element. You are required to use only basic stack operations (push, pop, peek, isEmpty) and you are given an initial unsorted stack as input. Your function should return the sorted stack. The function should not use any additional data structures such as arrays or linked lists. # Function Signature ```python def sort_stack(stack: list) -> list: pass ``` # Input * `stack`: A list of integers representing a stack, where the first element represents the bottom of the stack, and the last element represents the top. # Output * A list of integers representing the sorted stack, from the bottom element to the top element. # Constraints * You cannot use extra data structures like arrays or linked lists. * Use only provided stack operations: push (append), pop (remove last), peek (last element), and isEmpty (check if empty). * The stack can contain any integer values, including negative numbers. # Example Input ```python stack = [3, 5, 1, 4, 2] ``` Output ```python [1, 2, 3, 4, 5] ``` # Notes * Your solution should sort the stack such that the smallest element is at the bottom and the largest element is at the top. * Make sure your algorithm properly handles edge cases such as an already sorted stack, an empty stack, or a stack with a single element.","solution":"def sort_stack(stack): Sorts the given stack in ascending order. if not stack: return stack # Function to insert an element in sorted order def sorted_insert(stack, element): if not stack or element >= stack[-1]: stack.append(element) else: temp = stack.pop() sorted_insert(stack, element) stack.append(temp) # Remove the top element top = stack.pop() # Sort the remaining stack sort_stack(stack) # Insert the top element in sorted order sorted_insert(stack, top) return stack"},{"question":"Problem Statement You are given a fully connected directed graph represented by an adjacency matrix with non-negative edge weights. Your task is to implement a modified version of Dijkstra\'s algorithm to find the shortest paths from a given source vertex to all other vertices. Implement the function `dijkstra_modified` which takes in the following parameters: * `graph` (List[List[int]]): A 2D list of integers representing the adjacency matrix of the graph. * `src` (int): An integer representing the source vertex. The function should return a list of distances from the source vertex to each vertex. If a vertex is not reachable from the source, its distance should be represented as infinity (`float(\'inf\')`). # Example ```python graph = [ [0, 10, 20, 0], [10, 0, 30, 5], [20, 30, 0, 15], [0, 5, 15, 0] ] src = 0 print(dijkstra_modified(graph, src)) ``` Output: ``` [0, 10, 20, 15] ``` # Constraints 1. The number of vertices `V` in the graph: `2 <= V <= 1000` 2. Edge weights are non-negative integers. 3. If there\'s no edge between two vertices, the corresponding cell value in the adjacency matrix will be zero (`0`). # Performance Requirements The algorithm should aim to have a time complexity of `O(E + V log V)`, where `V` is the number of vertices and `E` is the number of edges. # Notes - The input graph is guaranteed to be non-negative and within the constraints. - You may use any additional data structures that enhance performance such as min-heaps or priority queues.","solution":"import heapq def dijkstra_modified(graph, src): Implement a modified version of Dijkstra\'s algorithm to find the shortest paths from a given source vertex to all other vertices. Parameters: graph (List[List[int]]): A 2D list of integers representing the adjacency matrix of the graph. src (int): An integer representing the source vertex. Returns: List[float]: A list of distances from the source vertex to each vertex, with unreachable vertices represented as float(\'inf\'). V = len(graph) dist = [float(\'inf\')] * V dist[src] = 0 min_heap = [(0, src)] while min_heap: current_distance, u = heapq.heappop(min_heap) if current_distance > dist[u]: continue for v in range(V): if graph[u][v] > 0: # edge exists distance = current_distance + graph[u][v] if distance < dist[v]: dist[v] = distance heapq.heappush(min_heap, (distance, v)) return dist"},{"question":"Efficient Fibonacci Number Finder Given the mathematical definition of the Fibonacci sequence: - F(0) = 0, F(1) = 1 - F(n) = F(n-1) + F(n-2) for n > 1 Write a function `efficient_fibonacci(n: int) -> int` that computes the n-th Fibonacci number. To ensure efficiency, your implementation should have: - Time Complexity: O(n) - Space Complexity: O(1) Function Signature ```python def efficient_fibonacci(n: int) -> int: pass ``` # Input - `n`: A non-negative integer (0 ≤ n ≤ 10^6) # Output - Returns the n-th Fibonacci number. # Constraints - Your solution must handle large inputs efficiently. - Ensure the function does not exceed memory limits. # Example ```python print(efficient_fibonacci(0)) # Output: 0 print(efficient_fibonacci(1)) # Output: 1 print(efficient_fibonacci(10)) # Output: 55 print(efficient_fibonacci(50)) # Output: 12586269025 print(efficient_fibonacci(100)) # Output: 354224848179261915075 ``` # Hints - Consider using an iterative approach that maintains only the last two Fibonacci numbers to compute the next one in constant space.","solution":"def efficient_fibonacci(n: int) -> int: Computes the n-th Fibonacci number using an efficient iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Scenario You are tasked with designing a system that processes images represented as binary trees. One of the operations needed is to invert the binary tree, meaning to mirror the tree such that every left subtree is swapped with its right subtree. This operation is essential in your image processing pipeline to create horizontal mirror images of the input. # Task Write a function `invert_binary_tree` that takes a binary tree and inverts it by swapping the left and right children of all nodes. # Function Signature ```python def invert_binary_tree(root: TreeNode) -> None: ``` # Input - `root` (TreeNode): The root node of the binary tree. A TreeNode is defined as below: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - This function doesn\'t return anything. It should modify the tree in-place. # Constraints - The number of nodes in the binary tree is in the range `[0, 1000]`. - Each `TreeNode` object has an integer value. # Example ```python # Creating a tree with the structure: # 4 # / # 2 7 # / / # 1 3 6 9 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7, TreeNode(6), TreeNode(9)) invert_binary_tree(root) # The tree after inversion: # 4 # / # 7 2 # / / # 9 6 3 1 ``` # Notes - Make sure to handle the edge case where the tree is empty. - Try to keep the solution as efficient as possible in terms of time and space complexities.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_binary_tree(root: TreeNode) -> None: if root is None: return # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_binary_tree(root.left) invert_binary_tree(root.right)"},{"question":"You are part of a software engineering team working on a data compression tool utilizing Huffman coding. Your task is to implement functions to encode and decode data files using the Huffman coding algorithm. # Requirements 1. **Encoding**: Implement a function `encode_data(input_file: str, output_file: str)` that reads an input file, compresses its content using Huffman coding, and writes the compressed data to an output file. 2. **Decoding**: Implement a function `decode_data(input_file: str, output_file: str)` that reads an encoded input file, decompresses its content, and writes it to an output file. # Constraints * Input files can be up to 100 MB in size. * Assume all files contain only standard ASCII characters (0-127). * Efficiency is key—your solution should handle large files within a reasonable time frame. # Function Signatures ```python def encode_data(input_file: str, output_file: str) -> None: pass def decode_data(input_file: str, output_file: str) -> None: pass ``` # Example 1. Given an input file `input.txt` containing the text: ``` this is an example for huffman encoding ``` Call `encode_data(\\"input.txt\\", \\"encoded.bin\\")` to generate a compressed binary file `encoded.bin`. 2. Call `decode_data(\\"encoded.bin\\", \\"decoded.txt\\")` to generate the original data `decoded.txt` with the same content as `input.txt`. # Implementation Hints 1. Analyze the frequency of each character in the file. 2. Build the Huffman tree based on the character frequencies. 3. Generate Huffman codes for each character. 4. Compress the file by replacing each character with its corresponding Huffman code. 5. Ensure you handle edge cases like padding the last byte for proper decoding. 6. In the decoding stage, reconstruct the Huffman tree and decode the file using the stored tree data. Your implementation will be evaluated for correctness, efficiency, and handling of edge cases.","solution":"import heapq from collections import defaultdict, Counter class HuffmanNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def build_huffman_tree(frequencies): heap = [HuffmanNode(char, freq) for char, freq in frequencies.items()] heapq.heapify(heap) while len(heap) > 1: left = heapq.heappop(heap) right = heapq.heappop(heap) merged = HuffmanNode(None, left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(heap, merged) return heap[0] def generate_huffman_codes(root): codes = {} def helper(node, current_code): if node is not None: if node.char is not None: codes[node.char] = current_code helper(node.left, current_code + \'0\') helper(node.right, current_code + \'1\') helper(root, \\"\\") return codes def encode_data(input_file, output_file): with open(input_file, \'r\') as f: text = f.read() frequency = Counter(text) huffman_tree = build_huffman_tree(frequency) codes = generate_huffman_codes(huffman_tree) # Leave 1 bit to use for the number of bits of padding added encoded_text = \'\'.join(codes[char] for char in text) extra_padding = 8 - len(encoded_text) % 8 encoded_text = f\\"{extra_padding:08b}\\" + encoded_text + \'0\' * extra_padding bytes_array = bytearray() for i in range(0, len(encoded_text), 8): byte = encoded_text[i:i+8] bytes_array.append(int(byte, 2)) with open(output_file, \'wb\') as f: f.write(bytes_array) # Also store Huffman Tree in a way that it can be reconstructed later for decoding import pickle with open(output_file + \\".tree\\", \'wb\') as f: pickle.dump(huffman_tree, f) def decode_data(input_file, output_file): with open(input_file, \'rb\') as f: bit_string = \'\'.join(f\\"{byte:08b}\\" for byte in f.read()) extra_padding = int(bit_string[:8], 2) bit_string = bit_string[8:-extra_padding] import pickle with open(input_file + \\".tree\\", \'rb\') as f: huffman_tree = pickle.load(f) current_node = huffman_tree decoded_text = [] for bit in bit_string: if bit == \'1\': current_node = current_node.right else: current_node = current_node.left if current_node.left is None and current_node.right is None: decoded_text.append(current_node.char) current_node = huffman_tree with open(output_file, \'w\') as f: f.write(\'\'.join(decoded_text))"},{"question":"You are given an implementation of the Diffie-Hellman key exchange algorithm. Your task is to enhance this implementation by introducing secure prime generation and validating the inputs thoroughly. # Function Signature ```python def diffie_hellman_secure_key_exchange(a: int, p: int, option: int=None) -> bool: pass ``` # Input * `a` (int): Primitive root of `p`. * `p` (int): A large prime number. * `option` (int, optional): If provided, print detailed steps of the key exchange process. # Output * (bool): Return `True` if the shared keys computed by both parties (Alice and Bob) match, otherwise `False`. # Constraints * `1 <= a, p <= 10^9` * `a` should be a primitive root of `p`. * `p` should be a prime number. # Requirements 1. **Secure prime generation**: Implement a function to generate large primes securely. 2. **Validation**: Ensure the given `p` is a prime and `a` is its primitive root. 3. **Functionality**: The function should properly compute the keys and ensure the shared keys match. # Example ```python assert diffie_hellman_secure_key_exchange(2, 23) == True assert diffie_hellman_secure_key_exchange(5, 23, option=1) == False # Because 5 is not a primitive root of 23 ``` # Implementation Notes * Your implementation should replace the `prime_check` and `find_primitive_root` functions with your own secure and optimized versions. * Ensure your prime generation and validation functions are efficient for high values. * Handle edge cases and invalid input gracefully, providing meaningful error messages if the constraints are not met.","solution":"import random def is_prime(n, k=5): Test if a number is prime using the Miller-Rabin test. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Find d such that d * 2^r = n-1 r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 # Witness loop def miller_test(d, n): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == n - 1: return True return False for _ in range(k): if not miller_test(d, n): return False return True def find_primitive_root(p): Find a primitive root for prime p. This is a simple method and might not work for larger primes. if not is_prime(p): return None required_set = set(num for num in range(1, p) if is_coprime(num, p)) for g in range(1, p): actual_set = set(pow(g, powers, p) for powers in range(1, p)) if required_set == actual_set: return g return None def is_coprime(a, b): Utility function to check if a and b are coprime. while b: a, b = b, a % b return a == 1 def diffie_hellman_secure_key_exchange(a: int, p: int, option: int=None) -> bool: Diffie-Hellman secure key exchange ensuring proper input validation. Arguments: a : int - Primitive root of p. p : int - A large prime number. option : int, optional - Print detailed steps if provided. Returns: bool - True if shared keys match, else False. if not is_prime(p): raise ValueError(f\\"The provided number {p} is not a prime number.\\") if not is_primitive_root(a, p): raise ValueError(f\\"The provided number {a} is not a primitive root of {p}.\\") # Private keys (secret and random) alice_private = random.randint(2, p-2) bob_private = random.randint(2, p-2) if option: print(f\\"Alice\'s private key: {alice_private}nBob\'s private key: {bob_private}\\") # Public keys alice_public = pow(a, alice_private, p) bob_public = pow(a, bob_private, p) if option: print(f\\"Alice\'s public key: {alice_public}nBob\'s public key: {bob_public}\\") # Shared keys (computed independently) alice_shared_key = pow(bob_public, alice_private, p) bob_shared_key = pow(alice_public, bob_private, p) if option: print(f\\"Alice\'s shared key: {alice_shared_key}nBob\'s shared key: {bob_shared_key}\\") return alice_shared_key == bob_shared_key def is_primitive_root(a, p): Check if a is a primitive root of p. if not is_prime(p): return False if a < 2 or a > p - 1: return False seen = set() for i in range(1, p): if (val := pow(a, i, p)) in seen: return False seen.add(val) return True"},{"question":"You are tasked with implementing a function that rotates an array of integers to the right by a specified number of steps. This problem assesses your understanding of array manipulations and efficiency in handling large datasets. Function Signature: ```python def rotate_array(array: List[int], k: int) -> List[int]: ``` Input: * `array`: A list of integers where `1 <= len(array) <= 10^5`. * `k`: An integer within the range `[0, 10^5]` indicating the number of steps to rotate the array to the right. Output: * The function should return a new list representing the array after k right rotations. Constraints: 1. Do not use extra space for another array; try to modify the input array in-place with O(1) extra space. 2. Protect against potential integer overflow or invalid inputs. 3. Assume all numbers are valid integers. # Example: ```python >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] ``` # Notes: 1. You are encouraged to come up with an efficient solution. Consider time complexity O(n) and space complexity O(1). 2. Document any potential edge cases in your initial comments and address them as part of your solution.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(array) if n == 0 or k == 0 or k % n == 0: return array k = k % n # Helper functions to reverse parts of the array def reverse(subarray, start, end): while start < end: subarray[start], subarray[end] = subarray[end], subarray[start] start += 1 end -= 1 # Step 1: Reverse the entire array reverse(array, 0, n - 1) # Step 2: Reverse the first k elements reverse(array, 0, k - 1) # Step 3: Reverse the remaining n - k elements reverse(array, k, n - 1) return array"},{"question":"Merge k Sorted Linked Lists Context You are given k sorted linked lists, and your task is to merge them into one sorted linked list. This is a common problem in applications involving data merging from multiple sources or in file external sorting. Problem Statement Write a function `merge_k_lists(lists)` that takes a list of `ListNode` objects. Each `ListNode` object represents the head of a sorted linked list. Your function should merge all k sorted linked lists into one sorted list and return its head. Function Signature ```python def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` Input - `lists`: A list containing up to k `ListNode` objects, where each `ListNode` represents the head of a sorted linked list. (1 <= k <= 10^5) - Each linked list node contains an integer value. Output - Returns the head of a single, sorted linked list resulting from merging all input lists. Constraints - The total number of elements across all input lists does not exceed 10^6. - The integer values in the list nodes can be negative or positive. Performance Requirements - Your solution must run in O(n log k) time complexity, where `n` is the total number of elements, and `k` is the number of lists. - Space complexity should be optimized to O(k). Example ```python # Example linked list node class class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Test case setup list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) lists = [list1, list2, list3] # Expected Output: A linked list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 merged_head = merge_k_lists(lists) ``` Guidelines 1. Use a heap or priority queue to manage the smallest current element across all lists efficiently. 2. Be careful with managing and updating the linked list pointers. 3. Handle edge cases where input linked lists may be empty. 4. Ensure your implementation maintains an O(n log k) time complexity. Good luck, and happy coding!","solution":"import heapq from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: # Custom comparator for ListNode to work with heapq ListNode.__lt__ = lambda self, other: self.val < other.val # Initialize the heap heap = [] # Push the head of each list into the heap for node in lists: if node: heapq.heappush(heap, node) # Dummy node to form the merged linked list dummy = ListNode(0) current = dummy while heap: # Get the smallest node from the heap node = heapq.heappop(heap) current.next = node current = current.next # If there is a next node, push it to the heap if node.next: heapq.heappush(heap, node.next) # Return the merged linked list which starts from dummy.next return dummy.next"},{"question":"You are tasked to implement a dynamic sorted array that supports insertion operations. You need to create a class `SortedArray` with the following methods: 1. `__init__(self)`: Initializes an empty instance of the sorted array. 2. `insert(self, val)`: Inserts a value into the sorted array maintaining the order. 3. `to_list(self)`: Returns the current sorted array as a list. Given the `search_insert` function already provided, implement the necessary functionality to insert elements while maintaining the array in a sorted order. # Input/Output Format Method: `__init__` **Input**: No parameters. **Output**: None. Method: `insert` **Input**: An integer `val`. **Output**: None. Method: `to_list` **Input**: No parameters. **Output**: A list of integers in non-decreasing order. ```python class SortedArray: def __init__(self): # Initialize an empty list pass def insert(self, val): # Insert value using search_insert to find the correct position pass def to_list(self): # Return the sorted list pass # Provided function def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low # Example usage sa = SortedArray() for val in [3, 1, 2, 4]: sa.insert(val) print(sa.to_list()) # Output should be [1, 2, 3, 4] ``` # Constraints 1. The elements to be inserted will be integers. 2. Your implementation should maintain an average time complexity of O(log n) for insertion operations.","solution":"class SortedArray: def __init__(self): self.array = [] def insert(self, val): position = search_insert(self.array, val) self.array.insert(position, val) def to_list(self): return self.array # Provided function def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low"},{"question":"You are given three integers representing the base, exponent, and modulus. Your task is to implement a function `fast_mod_exp(base, exponent, mod)` that efficiently computes ( (base ^ exponent) % mod ). Your solution should handle large exponents and bases efficiently by leveraging the concept of modular exponentiation. # Input * An integer `base` (0 <= base <= 10^9) * An integer `exponent` (0 <= exponent <= 10^9) * An integer `mod` (1 <= mod <= 10^9) # Output * An integer representing ( (base ^ exponent) % mod ) # Constraints * Ensure that your implementation can handle the maximum input sizes efficiently. * Make sure to raise an error if `mod` is less than or equal to 0. * Assume that both `base` and `exponent` are non-negative integers. # Example ```python assert fast_mod_exp(2, 10, 1000) == 24 assert fast_mod_exp(3, 200, 50) == 1 assert fast_mod_exp(10, 0, 5) == 1 assert fast_mod_exp(0, 10, 7) == 0 ``` # Notes * Use an iterative approach to implement the modular exponentiation to ensure optimal performance. * Remember to handle the edge cases such as when the exponent is `0` (any number raised to `0` power is `1`). # Function Signature ```python def fast_mod_exp(base: int, exponent: int, mod: int) -> int: pass ```","solution":"def fast_mod_exp(base: int, exponent: int, mod: int) -> int: Perform modular exponentiation of base, i.e., (base^exponent) % mod Args: - base (int): the base number (0 <= base <= 10^9) - exponent (int): the exponent (0 <= exponent <= 10^9) - mod (int): the modulus (1 <= mod <= 10^9) Returns: - int: the result of (base^exponent) % mod if mod <= 0: raise ValueError(\\"Modulus must be greater than 0\\") result = 1 base = base % mod # Handle cases where base >= mod while exponent > 0: # If exponent is odd, multiply base with the result if (exponent % 2) == 1: result = (result * base) % mod # Right shift the exponent by 1 (equivalent to dividing by 2) exponent = exponent >> 1 # Base = base^2 % mod base = (base * base) % mod return result"},{"question":"# Question: String Compression and Decompression using Run-Length Encoding Background: You are a software developer working on a system that needs efficient storage of repetitive data. To achieve this, you are implementing a feature that uses Run-Length Encoding (RLE) for compression and decompression of strings. Task: Write two functions `encode_rle` and `decode_rle` as specified below: 1. **Function `encode_rle(input_str: str) -> str`:** * Input: A string `input_str` which contains the data to be compressed. * Output: A string representing the RLE compressed data. * Constraints: * The input string will only contain uppercase English letters (A-Z). * The input string can be of length 0 to 10^5. 2. **Function `decode_rle(encoded_str: str) -> str`:** * Input: A string `encoded_str` that contains RLE compressed data. * Output: A string representing the original decompressed data. * Constraints: * The input string will be a valid RLE encoded string with uppercase English letters and integers. * The length of the input string can be from 0 to 10^5. Example ```python # Example 1 input_str = \\"AAABBBCCCA\\" encoded_str = encode_rle(input_str) print(encoded_str) # Output: \\"3A3B3C1A\\" decoded_str = decode_rle(encoded_str) print(decoded_str) # Output: \\"AAABBBCCCA\\" # Example 2 input_str = \\"ABC\\" encoded_str = encode_rle(input_str) print(encoded_str) # Output: \\"1A1B1C\\" decoded_str = decode_rle(encoded_str) print(decoded_str) # Output: \\"ABC\\" ``` Requirements: 1. Ensure your functions handle edge cases such as empty strings and strings with no repeated characters. 2. Your implementation should be efficient to handle large input sizes within the given constraints.","solution":"def encode_rle(input_str: str) -> str: Compresses the input string using Run-Length Encoding (RLE). Parameters: input_str (str): String to be compressed. Returns: str: RLE compressed string. if not input_str: return \\"\\" encoded_str = [] current_char = input_str[0] count = 1 for char in input_str[1:]: if char == current_char: count += 1 else: encoded_str.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded_str.append(f\\"{count}{current_char}\\") return \'\'.join(encoded_str) def decode_rle(encoded_str: str) -> str: Decompresses the RLE encoded string to its original form. Parameters: encoded_str (str): RLE encoded string Returns: str: Decompressed original string. if not encoded_str: return \\"\\" decoded_str = [] count = 0 for char in encoded_str: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 return \'\'.join(decoded_str)"},{"question":"# Objective Create a function that finds the mode, or most frequent number(s), in a given list of integers. In case of a tie, return all modes sorted in ascending order. # Problem Statement Implement a function `find_modes(arr: List[int]) -> List[int]` in Python. The function receives a list of integers and returns a list containing the mode(s) of the input list in ascending order. * **Input Format**: - A list of integers `arr` (e.g., `[1, 1, 2, 2, 3, 4]`). * **Output Format**: - A list of integers, which are the mode(s) in ascending order (e.g., `[1, 2]`). * **Constraints**: - Elements in the input array can be any integers. - The input list can be empty (returns an empty list). Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([4, 5, 6, 6, 5, 4, 4]) == [4] assert find_modes([]) == [] assert find_modes([1]) == [1] assert find_modes([2, 2, 2]) == [2] ``` # Notes * Ensure that the function handles cases where the input list is empty. * Return the modes in ascending order for consistency. * Consider handling very large lists efficiently by focusing on optimizing space complexity where possible.","solution":"from typing import List from collections import Counter def find_modes(arr: List[int]) -> List[int]: Finds the mode(s) of the input list of integers. If there are multiple modes, they are returned in ascending order. if not arr: return [] counter = Counter(arr) max_count = max(counter.values()) modes = [num for num, count in counter.items() if count == max_count] return sorted(modes)"},{"question":"# Problem Description Implement a modified Rabin-Karp Algorithm to search for all occurrences of a given word in a given text using a rolling hash method for numeric encoding of string windows. The function should handle edge cases and avoid excessive hash collisions. # Function Signature ```python def rabin_karp_search(word: str, text: str) -> List[int]: pass ``` # Parameters - **word (str)**: The substring to search for. Non-empty string with lowercase English letters. - **text (str)**: The string in which to search for the word. Contains lowercase English letters. # Returns - **List[int]**: A list of starting indices of all occurrences of the word in the text. Returns an empty list if the word is not found. # Constraints 1. `1 <= len(word) <= 100` 2. `1 <= len(text) <= 10^6` # Example ```python assert rabin_karp_search(\\"abc\\", \\"abcabc\\") == [0, 3] assert rabin_karp_search(\\"abc\\", \\"defg\\") == [] assert rabin_karp_search(\\"a\\", \\"aaaaa\\") == [0, 1, 2, 3, 4] assert rabin_karp_search(\\"longword\\", \\"short\\") == [] assert rabin_karp_search(\\"substring\\", \\"\\") == [] assert rabin_karp_search(\\"\\", \\"text\\") == [] ``` # Notes - The function must handle cases where the word or the text is empty. - The solution should be efficient and handle large text inputs within reasonable time limits. Implement the function with attention to rolling hash mechanics and edge cases such as empty inputs and hash collisions.","solution":"def rabin_karp_search(word: str, text: str) -> list: Searches for all occurrences of the word in the given text using the Rabin-Karp algorithm. if len(word) == 0 or len(text) == 0 or len(word) > len(text): return [] base = 256 prime_modulus = 101 word_length = len(word) word_hash = 0 current_window_hash = 0 highest_base_exponent = 1 # Precompute the highest base exponent for i in range(word_length - 1): highest_base_exponent = (highest_base_exponent * base) % prime_modulus # Compute the hash for the word and the first window in text for i in range(word_length): word_hash = (base * word_hash + ord(word[i])) % prime_modulus current_window_hash = (base * current_window_hash + ord(text[i])) % prime_modulus # Start sliding over the text result_indices = [] for start in range(len(text) - word_length + 1): if word_hash == current_window_hash: if text[start:start + word_length] == word: result_indices.append(start) if start < len(text) - word_length: current_window_hash = (current_window_hash - ord(text[start]) * highest_base_exponent) % prime_modulus current_window_hash = (current_window_hash * base + ord(text[start + word_length])) % prime_modulus current_window_hash = (current_window_hash + prime_modulus) % prime_modulus # Ensure non-negative return result_indices"},{"question":"# Question: Frequency Distribution Calculation You have been tasked to implement a function `calculate_frequency_distribution` that takes a list of integers and returns a dictionary representing the frequency distribution of the elements in the list. Each key in the dictionary should be an integer from the list, and the corresponding value should be the count of occurrences of that integer. Input Format: - A list `input_list` of `n` integers, where `1 <= n <= 10^6`. Output Format: - A dictionary where keys are integers from the input list and values are their frequencies. Constraints: - The integers in the list can range from `-10^6` to `10^6`. - The input list can contain duplicate elements. - The input list can be empty, in which case the function should return an empty dictionary. Example: ```python calculate_frequency_distribution([2, 3, 5, 5, 5, 6, 4, 3, 7]) # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} calculate_frequency_distribution([3, 3, 2, 1]) # Expected Output: {1: 1, 2: 1, 3: 2} calculate_frequency_distribution([]) # Expected Output: {} ``` Additional Notes: - Your implementation should consider performance efficiency to handle large input sizes effectively. - You should ensure that the function handles all edge cases gracefully. Write your implementation of `calculate_frequency_distribution` below: ```python def calculate_frequency_distribution(input_list): # Your code here pass ```","solution":"def calculate_frequency_distribution(input_list): Returns a dictionary representing the frequency distribution of the elements in the list. Parameters: input_list (list): The list of integers. Returns: dict: A dictionary with integers as keys and their frequency of occurrence as values. frequency_dict = {} for num in input_list: if num in frequency_dict: frequency_dict[num] += 1 else: frequency_dict[num] = 1 return frequency_dict"},{"question":"You are given a list of `n` people sitting in a circular fashion, indexed from 1 to n. Your task is to implement a function that simulates the Josephus problem, where every third person is eliminated in each step until no one is left. Your function should return the order in which people are eliminated. # Function Signature: ```python def josephus_problem(n: int) -> list: ``` # Input: * An integer `n` representing the number of people sitting in a circular fashion (`1 <= n <= 1000`). # Output: * A list of integers representing the order of elimination. # Example: ```python # Example 1: josephus_problem(5) # Output: # [3, 1, 5, 2, 4] # Example 2: josephus_problem(7) # Output: # [3, 6, 2, 7, 5, 1, 4] ``` # Constraints: * Ensure your function runs efficiently (consider edge cases). * Handle unexpected or invalid inputs gracefully. * Maintain the order of eliminations as per the Josephus problem. Good luck!","solution":"def josephus_problem(n: int) -> list: Solves the Josephus problem for \'n\' people, eliminating every third person in a circular fashion until no one is left. :param n: Number of people :return: List representing the order of elimination people = list(range(1, n+1)) elimination_order = [] index = 0 while people: index = (index + 2) % len(people) eliminated_person = people.pop(index) elimination_order.append(eliminated_person) return elimination_order"},{"question":"# Longest Increasing Subsequence (LIS) You are tasked with implementing a function that computes the length of the longest increasing subsequence from a given unsorted list of integers. Given this problem, you need to devise a solution that demonstrates an understanding of dynamic programming and advanced tree data structures. Function Signature ```python def longest_increasing_subsequence(arr: List[int]) -> int: pass ``` # Input Format - **arr**: A list of integers representing the sequence, where ( 1 leq text{len(arr)} leq 10^4 ) and ( -10^5 leq text{arr[i]} leq 10^5 ). # Output Format - An integer representing the length of the longest increasing subsequence. # Constraints - The solution must handle sequences efficiently within the provided input constraints. - The implementation must address performance and memory optimization. # Example ```python assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 # Explanation: The LIS is [2, 3, 7, 101] ``` # Guidelines 1. **Basic Dynamic Programming**: Implement the basic version achieving (O(n^2)) time complexity first. 2. **Optimized Approach**: Implement an optimized version using segment trees with (O(n log n)) time complexity. 3. Consider and handle edge cases effectively. **Scenario:** Imagine you are working on an analytics tool for monitoring stock prices, and you need to find periods of continuous growth within datasets to make recommendations.","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int]) -> int: if not arr: return 0 # List to store the smallest ending value for all increasing subsequences with length i + 1. dp = [] for num in arr: # Use binary search to find the index where num can be placed. pos = bisect.bisect_left(dp, num) # If pos is equal to the length of dp, append the number to dp. if pos == len(dp): dp.append(num) else: # Otherwise, replace the element at the appropriate position. dp[pos] = num # The length of dp will be the length of the longest increasing subsequence. return len(dp)"},{"question":"# Quick Sort Optimization Challenge Context Quick Sort is known for its efficient average-case performance, but its worst-case performance can be significantly affected by the choice of the pivot. You are tasked with improving the Quick Sort algorithm by implementing a median-of-three pivot selection strategy to enhance its performance. Problem Your task is to implement the improved Quick Sort algorithm with the following changes: 1. **Median-of-three pivot selection**: The pivot should be the median of the first, middle, and last elements of the portion of the array being sorted. 2. **Switch to Insertion Sort**: For subarrays of size less than a given threshold (such as 10), use Insertion Sort to avoid the overhead of recursion for small arrays. Function Signature ```python def optimized_quick_sort(arr): # Your implementation here pass ``` Input - A list of integers `arr`, where `1 <= len(arr) <= 10^5` and `-10^6 <= arr[i] <= 10^6` for all valid `i`. Output - A list of integers sorted in non-decreasing order. Example ```python input_arr = [3, 6, 8, 10, 1, 2, 1] print(optimized_quick_sort(input_arr)) # Output: [1, 1, 2, 3, 6, 8, 10] ``` Constraints - You must use a median-of-three pivot selection strategy. - For subarrays with size less than or equal to 10, Insertion Sort must be used. - The algorithm should maintain an average-case time complexity of O(n log(n)) and handle up to 10⁵ elements efficiently. Your implementation should focus on: 1. Proper pivot selection to avoid degradation to O(n²) performance. 2. Efficient handling of small subarrays with Insertion Sort. 3. Maintaining the in-place sorting characteristic to ensure space efficiency.","solution":"def optimized_quick_sort(arr): Implementation of an optimized Quick Sort algorithm with median-of-three pivot selection and insertion sort for small subarrays. def median_of_three(low, mid, high): if arr[low] <= arr[mid] <= arr[high] or arr[high] <= arr[mid] <= arr[low]: return mid elif arr[mid] <= arr[low] <= arr[high] or arr[high] <= arr[low] <= arr[mid]: return low else: return high def insertion_sort(low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def quick_sort(low, high): if low < high: if high - low <= 10: insertion_sort(low, high) else: mid = (low + high) // 2 pivot_index = median_of_three(low, mid, high) arr[low], arr[pivot_index] = arr[pivot_index], arr[low] pivot = arr[low] i = low + 1 j = high while True: while i <= j and arr[i] <= pivot: i += 1 while i <= j and arr[j] >= pivot: j -= 1 if i <= j: arr[i], arr[j] = arr[j], arr[i] else: break arr[low], arr[j] = arr[j], arr[low] quick_sort(low, j - 1) quick_sort(j + 1, high) quick_sort(0, len(arr) - 1) return arr"},{"question":"# Add Two Integers Using Bitwise Operations Context You are working as a systems programmer and you often need to perform low-level arithmetic operations. To ensure efficiency and avoid using high-level arithmetic operators, you decide to use bitwise operations for addition. Your task is to implement a function that adds two positive integers using only bitwise operations. Task Description Write a function `add_bitwise_operator(int1, int2)` which takes two non-negative integers as inputs and returns their sum without using the `+` operator. Input * `int1, int2` (0 <= int1, int2 <= 10^9): Two non-negative integers. Output * An integer representing the sum of the two inputs. Constraints * You cannot use the `+` operator or any arithmetic operators. * Use only bitwise operations (`&`, `|`, `^`, `~`, `<<`, and `>>`). * Assume the integers are represented in 32-bit binary form. Example ```python >>> add_bitwise_operator(2, 3) 5 >>> add_bitwise_operator(10, 20) 30 ``` Notes * The solution must handle carrying over bits correctly and ensure the final result is accurate. * Consider edge cases such as both inputs being zero or very close to the upper limit. * Ensure the function runs efficiently even for large numbers. Good luck!","solution":"def add_bitwise_operator(int1, int2): Adds two non-negative integers using bitwise operations. while int2 != 0: carry = int1 & int2 int1 = int1 ^ int2 int2 = carry << 1 return int1"},{"question":"# Question: Parentheses Matching Validation You are tasked with writing a function to validate the parentheses in a given string. You need to determine if the input string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is valid. An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Write a function `is_valid_parentheses(s: str) -> bool` that takes a single parameter: - `s`: a string containing the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. The function should return: - `True` if the string is valid. - `False` otherwise. **Constraints**: - The length of the string `s` will be in the range [0, 10^4]. # Edge Cases - An empty string should return `True`. - Strings that start with a closing bracket or end with an opening bracket should return `False`. # Example Input/Output: **Example 1:** Input: `s = \\"()\\"` Output: `True` **Example 2:** Input: `s = \\"()[]{}\\"` Output: `True` **Example 3:** Input: `s = \\"(]\\"` Output: `False` **Example 4:** Input: `s = \\"([)]\\"` Output: `False` **Example 5:** Input: `s = \\"{[]}\\"` Output: `True` # Guidelines: 1. Use a stack for keeping track of opening brackets. 2. Make sure to handle all types of brackets: (), {}, and []. 3. Optimize the code to handle the upper limit of the input size. ```python def is_valid_parentheses(s: str) -> bool: # Your code here... pass ```","solution":"def is_valid_parentheses(s: str) -> bool: stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in matching_parentheses: top_element = stack.pop() if stack else \'#\' if matching_parentheses[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Problem You are given a sorted array of integers and a target value. Your task is to implement a function that searches for the index at which the target should be inserted to maintain the order of the array. # Function Signature ```python def search_insert(array: List[int], val: int) -> int: pass ``` # Input - `array` (List[int]): A sorted list of integers (0 <= len(array) <= 10^4). - `val` (int): The target value to search for (could be any integer). # Output - Returns an integer representing the index at which `val` should be inserted. # Constraints - The function should run in O(log n) time complexity. - The function should not use any extra space beyond O(1) (i.e., no additional arrays or data structures that grow with input size). # Example ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 assert search_insert([], 5) == 0 ```","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Returns the index at which the target value should be inserted to maintain the order of the sorted array. left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == val: return mid elif array[mid] < val: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Scenario: You are tasked with building software that clones network topologies for simulation environments. The network topology is represented as an undirected graph, where each node has a unique label and a list of neighbors. # Task: Implement a function to clone an undirected graph using recursive depth first search (DFS). The function signature is: ```python def clone_graph(node): Returns a new undirected graph, cloned from the provided node. pass ``` # Specifications: - Each node is represented by the UndirectedGraphNode class: ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] ``` - The function should use recursive DFS. # Constraints: - Up to 10,000 nodes - The graph is connected. - Nodes are labeled uniquely and contain non-negative integer labels. - Self-loops (when a node is a neighbor of itself) are possible. # Example: Given the adjacency list notation `{0,1,2#1,2#2,2}`, the graph is: ``` 1 / / 0 --- 2 / _/ ``` Your function should output a new graph that is a clone of the input graph. The new graph\'s structure and connections should be identical to the input graph. # Notes: 1. Ensure accurate copying of both nodes and edges. 2. Consider edge cases such as self-loops and maximum node capacities. 3. The function should handle cases where the input node is None by returning None.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node): Returns a new undirected graph, cloned from the provided node using recursive DFS. if not node: return None # A dictionary to store the cloned nodes cloned_nodes = {} def dfs(node): if node.label in cloned_nodes: return cloned_nodes[node.label] # Create a clone of the node clone = UndirectedGraphNode(node.label) cloned_nodes[node.label] = clone for neighbor in node.neighbors: clone.neighbors.append(dfs(neighbor)) return clone return dfs(node)"},{"question":"# Scenario: A small tech company is implementing a feature in their product where they need to sort user records based on their unique IDs efficiently. After some analysis, they decide to use Comb Sort as it offers a good balance between time complexity and implementation simplicity for their relatively small datasets. # Task: Implement the `comb_sort` function in Python to sort an input list of integers. # Requirements: - **Function Signature** ```python def comb_sort(arr: List[int]) -> List[int] ``` - **Input**: A list of integers `arr` where ( 1 leq text{len}(arr) leq 10^6 ) - **Output**: The same list of integers, sorted in non-decreasing order. # Constraints: - Use the shrinking factor of `1.3`. - The function should sort the array in place, i.e., it should not use any additional list or more than constant extra space. - Aim for optimal performance for the given constraints. # Example: ```python assert comb_sort([8, 4, 1, 56, 3, -44, 23, -6, 28, 0]) == [-44, -6, 0, 1, 3, 4, 8, 23, 28, 56] assert comb_sort([5, 20, 10, 3, 6, 7, 2]) == [2, 3, 5, 6, 7, 10, 20] ``` # Performance Requirements: The function should efficiently handle and sort arrays up to 1,000,000 elements within reasonable time constraints.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts the array in non-decreasing order using Comb Sort algorithm. :param arr: List of integers to be sorted :return: The same list of integers, sorted in non-decreasing order gap = len(arr) shrink_factor = 1.3 sorted = False while not sorted: gap = int(gap / shrink_factor) if gap <= 1: gap = 1 sorted = True for i in range(len(arr) - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"You have been provided with an implementation of the Pigeonhole Sort algorithm. Your understanding of the algorithm will be tested by extending or optimizing this implementation. Specifically, you are required to implement a function that sorts an array of integers using Pigeonhole Sort but with additional functionality for handling more complex input scenarios. Problem Statement Write a function `pigeonhole_sort_extended(arr: List[int]) -> List[int]` that sorts the input array of integers in ascending order using the Pigeonhole Sort algorithm. Your function should handle: 1. Negative numbers in the array. 2. Large numbers, ensuring efficiency in terms of memory usage. 3. Arrays consisting of both negative and positive numbers. Input * `arr` (List[int]): A list of integers which may contain both negative and positive values, and is not empty. Output * `List[int]`: A new list with integers sorted in ascending order. Constraints * The number of elements in `arr` can be up to `10^6`. * The range of integer values in `arr` can be up to `10^9` in magnitude. Example ```python >>> pigeonhole_sort_extended([8, 3, -2, 7, -5, 0, -1, 9]) [-5, -2, -1, 0, 3, 7, 8, 9] >>> pigeonhole_sort_extended([5, -11, 2, 3, 0, 1]) [-11, 0, 1, 2, 3, 5] ``` Performance Requirements * Aim to minimize both time and space complexity. * Consider the memory overhead for large ranges and optimize accordingly.","solution":"from typing import List def pigeonhole_sort_extended(arr: List[int]) -> List[int]: if not arr: return [] # Find min and max values in the array min_val = min(arr) max_val = max(arr) range_val = max_val - min_val + 1 # Create pigeonholes holes = [0] * range_val # Populate the pigeonholes for num in arr: holes[num - min_val] += 1 # Collect the sorted elements sorted_arr = [] for index in range(range_val): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"# Stooge Sort Application and Optimization In this task, you will implement the Stooge Sort algorithm and optimize it for practical use. Despite being inefficient by nature, ensure your solution handles all edge cases and constraints effectively. **Task**: 1. Implement the `stoogesort` function. 2. Modify the function to optionally switch to a more efficient sorting algorithm (e.g., Python\'s built-in `sorted`) for large arrays. Function Signature ```python def stoogesort(arr: List[int], l: int, h: int) -> None: # Your code here ``` Input Format - An array `arr` of integers `[-10^3 <= arr[i] <= 10^3]`. - Two integers `l` and `h`, representing the starting and ending indices of the array to be sorted. Output Format - The function should modify the array `arr` in place. Constraints - 0 <= l <= h < len(arr) - Optimize for arrays larger than 10 elements by switching to efficient sorting algorithms. Example ```python # Given the array arr = [3, 2, 5, 1, 4] # Call the function: stoogesort(arr, 0, len(arr)-1) # The sorted array should be print(arr) # Output: [1, 2, 3, 4, 5] ``` **Scenario**: You are provided with a dataset containing different range values and need to ensure efficient sorting. While the Stooge Sort serves the purpose for educational demonstrations, the program you write should effectively handle larger datasets and switch to a practical sorting algorithm for arrays with more than 10 elements.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: Perform Stooge Sort on the array between indices l and h. Switch to a more efficient sorting algorithm for large arrays. if l >= h: return # If size of subarray is larger than 10, use Python\'s built-in sort if (h - l + 1) > 10: arr[l:h+1] = sorted(arr[l:h+1]) return # If first element is larger than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # Recur for first 2/3 and last 2/3 if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t)"},{"question":"# Context You\'re tasked with designing navigational algorithms for an app which helps users find paths, ensuring efficiency in route planning. Implementing this correctly can significantly enhance the user experience by quickly providing accurate paths. # Task Write a Python function named `find_optimized_shortest_path` which optimizes the provided `find_shortest_path` by addressing its potential inefficiencies. # Function Signature ```python def find_optimized_shortest_path(graph: dict, start: str, end: str) -> list: ``` # Input * `graph`: A dictionary where keys are node names (strings) and values are lists of nodes (strings) directly connected to the key node. * `start`: A string representing the starting node. * `end`: A string representing the ending node. # Output * A list of nodes (strings) representing the shortest path from `start` to `end`. If no path is found, return an empty list. # Constraints * Assume there are no negative cycles or weights. * Nodes are unique strings. * The graph may not be connected. # Optimization Requirements 1. **Avoid Deep Recursion:** Convert recursive approach to an iterative one using a stack or queue for Depth-First Search or Breadth-First Search. 2. **Efficiency:** Ensure the solution has improved performance in terms of space and time complexity over large graphs. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'], } print(find_optimized_shortest_path(graph, \'A\', \'F\')) # Expected Output: [\'A\', \'C\', \'F\'] ``` # Notes * Clearly handle edge cases such as when no path exists, or start and end nodes are the same. * Pay special attention to the complexity incurred by your solution. * Justify design choices and any trade-offs made.","solution":"from collections import deque def find_optimized_shortest_path(graph: dict, start: str, end: str) -> list: Uses Breadth-First Search (BFS) to find the shortest path between start and end nodes in an unweighted graph. Args: graph (dict): A dictionary representing the adjacency list of the graph. start (str): The starting node. end (str): The destination node. Returns: list: A list of nodes representing the shortest path from start to end. if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: current, path = queue.popleft() if current == end: return path for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Decoding Algorithm Problem Problem Statement A message containing letters from A-Z is being encoded to numbers using the following mapping: ``` \'A\' -> 1 \'B\' -> 2 ... \'Z\' -> 26 ``` Given an encoded message containing digits, determine the total number of ways to decode it. You need to handle the following rules: 1. No encoded message can start with \'0\'. 2. \'0\' cannot be paired with any number except for \'1\' and \'2\' to form valid pairs like \'10\' and \'20\'. 3. Valid pairs are within the range \'10\' to \'26\', inclusive. Examples - For the encoded message \\"12\\", it can be decoded as \\"AB\\" (1 2) or \\"L\\" (12). The number of ways to decode \\"12\\" is 2. Function Signature ```python def num_decodings(enc_mes: str) -> int: :param enc_mes: A string containing the encoded message consisting of digits (\'0\'-\'9\') :return: The total number of ways to decode the encoded message. pass ``` Constraints 1. The input will be a non-empty string of digits. 2. The input string length will not exceed 100 characters. 3. Performance requirements should be linear with respect to input size, ideally O(n) time complexity and O(1) space complexity. Objective Write a function `num_decodings(enc_mes: str) -> int` that returns the total number of ways to decode the given encoded message. Notes - Ensure to handle edge cases where the string starts with \'0\' or contains invalid two-character sequences like \\"30\\" or \\"40\\". - Do not use any external libraries for the function implementation. - The function should gracefully handle incorrect inputs by returning 0 if the message is invalid. Good luck, and happy coding!","solution":"def num_decodings(enc_mes: str) -> int: if not enc_mes or enc_mes[0] == \'0\': return 0 # dp[i] will be storing the number of ways to decode up to the i-th character n = len(enc_mes) dp = [0] * (n + 1) # Base cases dp[0] = 1 # An empty string has one way to decode (by doing nothing) dp[1] = 1 # Since we know the message doesn\'t start with \'0\', there\'s only one way to decode a single character (unless it is \'0\', but we already checked for that) for i in range(2, n + 1): # Single digit decode (must be between \'1\' and \'9\') if enc_mes[i - 1] != \'0\': dp[i] += dp[i - 1] # Two digits decode (must be between \'10\' and \'26\') two_digit_value = int(enc_mes[i - 2:i]) if 10 <= two_digit_value <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"Question: Implementing an Efficient Nearest Neighbor Algorithm Given the nearest neighbor algorithm and Euclidean distance function as described, you are to re-implement the `nearest_neighbor` function to improve its efficiency. # Task Your task is to optimize the nearest neighbor search using a spatial data structure such as a KD-tree to reduce the computation time, especially for higher-dimensional data and larger training sets. # Input: 1. A query point `x` represented as a tuple of length (m). 2. A training set `tSet` represented as a dictionary where: - Keys are tuples of length (m) denoting the data points. - Values are labels (e.g., \\"class1\\", \\"class2\\"). # Output: - The label of the nearest neighbor to the query point `x`. # Constraints: - The training set `tSet` contains at least one data point. - All data points in `tSet` and `x` have the same dimensionality (m), where (1 le m le 1000). - The training set can contain up to (10000) data points. # Performance Requirements: - Your implementation should have an average case efficiency better than (O(n cdot m)). # Example: ```python x = (1, 2) tSet = { (1, 3): \\"A\\", (2, 2): \\"B\\", (1, 1): \\"A\\" } result = nearest_neighbor(x, tSet) print(result) # Expected: \\"A\\" ``` # Notes: - You may utilize third-party libraries like `scipy` for KD-tree implementation if necessary. - Ensure to handle possible edge cases such as multiple points having the same minimum distance. Implement the function `nearest_neighbor` below: ```python from scipy.spatial import KDTree def nearest_neighbor(x, tSet): Your code here to optimize nearest neighbor with KD-tree # Extract points and labels points = list(tSet.keys()) labels = list(tSet.values()) # Build KD-tree tree = KDTree(points) # Query KD-tree to find the nearest neighbor dist, index = tree.query(x) return labels[index] ```","solution":"from scipy.spatial import KDTree def nearest_neighbor(x, tSet): Find the label of the nearest neighbor to the query point x using a KD-tree. Parameters: x (tuple): Query point. tSet (dict): Training set, where keys are data points (tuples) and values are labels. Returns: str: Label of the nearest neighbor. # Extract points and labels points = list(tSet.keys()) labels = list(tSet.values()) # Build KD-tree tree = KDTree(points) # Query KD-tree to find the nearest neighbor dist, index = tree.query(x) return labels[index]"},{"question":"# Scenario: You\'re working on a software module that deals with string manipulations. One particular task requires determining the minimum number of times a string `A` needs to be repeated for a string `B` to become a substring of the repeated string. Given the simplicity of the string operations, your task is to implement this in an optimized way. # Task: Implement a function `minimum_repeats(A: str, B: str) -> int` that returns the minimum number of times `A` needs to be repeated so that `B` is a substring of the repeated string. If `B` cannot be a substring of the repeated string, return `-1`. # Function Signature: ```python def minimum_repeats(A: str, B: str) -> int: ``` # Input: - `A` and `B` are strings with lengths in the range [1, 10000]. # Output: - Return an integer representing the minimum number of repetitions required, or -1 if `B` cannot be a substring of the repeated `A`. # Constraints: - You may assume that both A and B contain only lowercase alphabetic characters. # Examples: ```python assert minimum_repeats(\\"abcd\\", \\"cdabcdab\\") == 3 assert minimum_repeats(\\"abc\\", \\"cabcabca\\") == 4 assert minimum_repeats(\\"a\\", \\"aa\\") == 2 assert minimum_repeats(\\"abcd\\", \\"efgh\\") == -1 ``` # Additional Information: - Consider various edge cases like B being already a substring of A, and cases where B is significantly longer than A. - Aim to optimize both time and space complexity as much as possible without compromising on the correctness.","solution":"def minimum_repeats(A: str, B: str) -> int: Returns the minimum number of times A needs to be repeated for B to become a substring of the repeated A string. If B cannot be a substring, returns -1. repeated = A count = 1 # Check by increasing repeated string length of A while len(repeated) < len(B): repeated += A count += 1 # Check if B is a substring of the current repeated A if B in repeated: return count # Sometimes B might start partially in the end of the current repeated # and thus we might need one additional repetition if B in (repeated + A): return count + 1 return -1"},{"question":"# Reformatting String By Segments **Context**: Consider you are tasked with formatting a string according to specific rules. You are given a string consisting of alphanumeric characters and dashes (\'-\'). Your goal is to remove all dashes and group the remaining characters into segments of length **k**. If the remaining characters cannot be perfectly divided into segments of length **k**, the first segment may be shorter. **Function Description**: Write a function `reformat_string(key: str, k: int) -> str` that takes a string `key` and an integer `k`, and returns the reformatted string according to the rules described. **Input**: - `key` (str): A string containing alphanumeric characters and dashes (\'-\'). - `k` (int): An integer which defines the length of each segment. **Output**: - A reformatted string where the characters are grouped into segments of length `k`, separated by dashes (\'-\'). **Constraints**: - The input string `key` has a length up to 100,000 characters. - The integer `k` is greater than 0 and less than the length of the input string. **Example**: ```python reformat_string(\\"2-4A0r7-4k\\", 4) ``` Expected Output: ```plaintext \\"24A0-R74K\\" ``` **Edge Cases to Consider**: - If the `key` contains only dashes, the output should be an empty string. - If the `key` is an empty string, the output should be an empty string. - Any leading, trailing, or consecutive dashes should be removed. **Note**: The function should be case-insensitive but the formatted output should be in uppercase.","solution":"def reformat_string(key: str, k: int) -> str: Reformat the given string by removing dashes and grouping the remaining characters into segments of length k. Each segment should be separated by a dash. # Remove all dashes and convert to uppercase clean_key = key.replace(\\"-\\", \\"\\").upper() # Find the length of the first segment first_segment_length = len(clean_key) % k if first_segment_length == 0 and len(clean_key) > 0: first_segment_length = k # Extract the first segment segments = [] if first_segment_length > 0: segments.append(clean_key[:first_segment_length]) # Extract the rest of the segments for i in range(first_segment_length, len(clean_key), k): segments.append(clean_key[i:i + k]) # Join segments with dashes return \\"-\\".join(segments)"},{"question":"# Maximum Path Sum in a Binary Tree Given a binary tree, write a function to find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. # Function Signature ```python def max_path_sum(root) -> int: ``` # Input * The input is the `root` of a binary tree where each node contains an integer value. # Output * The output should be an integer representing the maximum path sum. # Constraints * The number of nodes in the tree is in the range `[1, 3 * 10^4]`. * `-1000 <= Node.val <= 1000`. # Examples ```python # Example 1: Input: root = [1,2,3] Output: 6 # Example 2: Input: root = [-10,9,20,None,None,15,7] Output: 42 ``` # Scenario Imagine you are designing a new feature for a map-based application that requires computing the most resourceful path through interconnected nodes to ensure optimal resource allocation. Implementing your solution for the maximum path sum problem will enable efficient traversing and resource calculation capabilities for your application. **Notes**: You may assume that all the node values in the given binary tree are integers and the tree is non-empty.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root) -> int: global_max = float(\'-inf\') def helper(node): nonlocal global_max if not node: return 0 # Calculate maximum path sum with left and right subtrees left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) # Potential new path including current node current_max_path = node.val + left_max + right_max # Update the global max path sum global_max = max(global_max, current_max_path) # Return the maximum path including current node and one of its subtrees return node.val + max(left_max, right_max) helper(root) return global_max"},{"question":"# Binary Tree Path Construction Challenge Problem Statement Given the root node of a binary tree, write a function `binary_tree_paths` to return all root-to-leaf paths in the tree. Each path should be represented as a string formatted using \'->\' to denote the direction from one node to the next. Function Signature ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` Input - `root`: The root node of the binary tree (Node can be a typical binary tree node structure with `val`, `left`, and `right` attributes). Output - List of all root-to-leaf paths, where each path is represented as a string. Constraints 1. The number of nodes in the binary tree is between 0 and 10^4. 2. Node values are integers and can be negative or positive. Example ```python # Example Binary Tree: # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) print(binary_tree_paths(root)) # Output: [\\"1->2->5\\", \\"1->3\\"] ``` Requirements 1. Your solution should efficiently handle trees with up to 10,000 nodes without causing stack overflow errors. 2. Make sure to handle edge cases, such as when the tree is empty or with a single node. Hints - Think about how you can traverse the tree to ensure every leaf node\'s path is captured. - Consider both recursive and iterative solutions and choose the one you find most efficient.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> List[str]: if not root: return [] def dfs(node: TreeNode, path: str, paths: List[str]): if not node.left and not node.right: paths.append(path) if node.left: dfs(node.left, path + \'->\' + str(node.left.val), paths) if node.right: dfs(node.right, path + \'->\' + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"# Question: Plus One Increment on Large Numbers You are given a non-negative integer represented as a list of digits, where each digit in the list is an integer from 0 to 9. Write a function that increments this number by one and returns the resulting list of digits. The digits are stored such that the most significant digit is at the head of the list. Function Signature ```python def increment_number(digits: List[int]) -> List[int]: pass ``` # Input * `digits`: A list of integers where each integer is in the range from 0 to 9. The list represents a non-negative integer where the most significant digit is at index 0. # Output * Return a list of integers representing the incremented value of the input integer. # Constraints * The input list will not be empty. * The input list will contain only non-negative integers (0-9). # Examples ```python increment_number([1, 2, 3]) => [1, 2, 4] increment_number([9, 9, 9]) => [1, 0, 0, 0] increment_number([0]) => [1] increment_number([8, 9, 9]) => [9, 0, 0] ``` # Notes * Ensure that your solution handles large numbers correctly. * Think about the edge cases and performance.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increments the given list of digits by one and returns the resulting list of digits. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits return [1] + digits"},{"question":"Optimized Shell Sort Implementation Objective: Write a function that implements the Shell Sort algorithm with an optimized gap sequence to improve its average-case performance. You should use the Hibbard gap sequence for this purpose. Scenario: You are given a list of integers representing the daily sales of a store over a month. The store manager wants you to sort this list so that it can be analyzed to make sales predictions. Function Signature: ```python def optimized_shell_sort(arr: List[int]) -> List[int]: ``` Expected Input and Output: * **Input**: A list of integers `arr` (0 <= len(arr) <= 10^5, -10^6 <= arr[i] <= 10^6). * **Output**: Sorted list of integers in ascending order. Constraints: * Your implementation should use the Hibbard gap sequence. * The function should handle empty arrays and arrays with a single element without errors. * Ensure the function remains efficient on larger lists. Example: ```python # Input: Daily sales over a 15-day period sales = [234, 456, 234, 532, 102, 691, 346, 237, 468, 783, 892, 453, 670, 123, 543] # Output: Sales sorted in ascending order sorted_sales = optimized_shell_sort(sales) print(sorted_sales) # Output: [102, 123, 234, 234, 237, 346, 453, 456, 468, 532, 543, 670, 691, 783, 892] ```","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: An optimized implementation of Shell Sort using the Hibbard gap sequence. def hibbard_gaps(size): k = 1 gaps = [] while (1 << k) - 1 < size: gaps.append((1 << k) - 1) k += 1 return gaps[::-1] n = len(arr) gaps = hibbard_gaps(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Shell Sort Enhancement Given the shell sort algorithm, your task is to implement an enhanced version that uses a different gap sequence which potentially improves the time complexity. Your version should implement the **Hibbard sequence** for the gaps, which is defined as the sequence of gaps: `1, 3, 7, 15, 31, ...` (where each gap is `2^k - 1`). Function Signature ```python def shell_sort_hibbard(arr: list) -> list: Sorts an array using Shell Sort with the Hibbard sequence for gaps. Args: - arr (list): list of elements to be sorted Returns: - list: the sorted array ``` Input and Output Formats - **Input**: A list of integers `arr` where `0 <= len(arr) <= 10^5` - **Output**: A sorted list of integers Constraints - You need to handle both positive and negative integers. - Ensure your implementation maintains O(n^1.25) time complexity using the Hibbard sequence. Example ```python print(shell_sort_hibbard([19, 2, 31, 45, 6, 11, 121, 27])) # Output: [2, 6, 11, 19, 27, 31, 45, 121] ``` Use the provided function signature and ensure your solution is efficient. If your implementation is inefficient or incorrect, it might not pass the constraints and performance requirements.","solution":"def shell_sort_hibbard(arr: list) -> list: Sorts an array using Shell Sort with the Hibbard sequence for gaps. Args: - arr (list): list of elements to be sorted Returns: - list: the sorted array n = len(arr) # Generate Hibbard sequence (2^k - 1) gaps = [] k = 1 while (gap := 2**k - 1) <= n: gaps.append(gap) k += 1 gaps.reverse() for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"Let\'s write a function to compute the binomial coefficient C(n, k) using dynamic programming. The binomial coefficient is the number of ways to choose k elements from a set of n elements, without regard to the order of the elements. # Detailed Requirements 1. **Function Definition**: Implement a function `dynamic_binomial_coefficient(n, k)`: ```python def dynamic_binomial_coefficient(n: int, k: int) -> int: ``` 2. **Input and Output**: - Input: Two integers `n` (number of items) and `k` (number of elements to choose). - Output: An integer representing the binomial coefficient C(n, k). 3. **Constraints**: - (0 leq k leq n) - (0 leq n leq 1000) 4. **Performance**: - Time Complexity: O(n*k) - Space Complexity: O(k), if using an optimization for space efficiency. # Function Signature ```python def dynamic_binomial_coefficient(n: int, k: int) -> int: ``` # Example ```python >>> dynamic_binomial_coefficient(5, 0) 1 >>> dynamic_binomial_coefficient(8, 2) 28 >>> dynamic_binomial_coefficient(500, 300) 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Note: - The function should handle edge cases like `n < k` by returning 0. - Use dynamic programming principles to optimize the computation and avoid excessive recursion. # Hints: - Recall that the binomial coefficient C(n, k) = C(n, n-k) for optimization. - Use a table or a list to store intermediary results and reduce redundant calculations.","solution":"def dynamic_binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) using dynamic programming. :param n: Total number of items. :param k: Number of items to choose. :return: Binomial coefficient C(n, k). if k > n: return 0 if k == 0 or k == n: return 1 k = min(k, n - k) # Use symmetry property dp = [0] * (k + 1) dp[0] = 1 # C(n, 0) is always 1 for i in range(1, n + 1): for j in range(min(i, k), 0, -1): dp[j] = dp[j] + dp[j - 1] return dp[k]"},{"question":"# Scenario: You are tasked with developing a search functionality for an academic database that finds and ranks research papers based on their similarity to a given query paper. To achieve this, you need to calculate the cosine similarity between the word frequency vectors of the papers. # Task: Write a function `cosine_similarity` that calculates the cosine similarity between two given 1-dimensional lists representing the word frequency vectors of two papers. The cosine similarity should quantify the similarity between two papers. # Function Signature: ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: pass ``` # Input: - `vec1`: A list of floating-point numbers representing the word frequency vector of the first paper. - `vec2`: A list of floating-point numbers representing the word frequency vector of the second paper. - Note: Both vectors will be of the same length, and at least one vector will have non-zero length. # Output: - A floating-point number representing the cosine similarity between the two vectors. # Constraints: - The length of each vector will be at most (10^5). - Elements in the vectors will be non-negative floating-point numbers. # Requirements: - Implement and use a helper function `_l2_distance` to calculate the L2 norm of a vector. - Handle edge cases carefully, such as vectors with zero norms. # Example: ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([0, 0, 0], [0, 0, 0]) # Output: 0.0 (Since both vectors are zero, default similarity to avoid NaN) cosine_similarity([1, 2, 3], [4, 5, 6]) # Output: 0.9746318461970762 ``` # Special Considerations: - Ensure that the code is optimized for performance, considering that vector sizes can be large. - Avoid division by zero errors by handling zero vectors appropriately.","solution":"from typing import List import math def _l2_distance(vec: List[float]) -> float: Calculate the L2 norm (Euclidean norm) of a vector. return math.sqrt(sum(x * x for x in vec)) def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Calculate the cosine similarity between two word frequency vectors. dot_product = sum(x * y for x, y in zip(vec1, vec2)) l2_norm_vec1 = _l2_distance(vec1) l2_norm_vec2 = _l2_distance(vec2) # We check if any of the norms are zero to avoid division by zero if l2_norm_vec1 == 0 or l2_norm_vec2 == 0: return 0.0 return dot_product / (l2_norm_vec1 * l2_norm_vec2)"},{"question":"You are tasked with implementing a **Singly Linked List** with a few core functionalities. Your goal is to ensure that you can handle a variety of operations efficiently as described below. Requirements Implement a class `SinglyLinkedList` with the following methods: 1. **insert_at_head(value)**: Inserts a new node containing `value` at the head of the list. 2. **insert_at_tail(value)**: Inserts a new node containing `value` at the tail of the list. 3. **delete(value)**: Deletes the first occurrence of the node containing `value`. If the value is not found, do nothing. 4. **search(value)**: Returns `True` if a node with `value` exists in the list, otherwise `False`. 5. **display()**: Returns a list of all node values in the linked list from head to tail. Constraints * You must implement the singly linked list from scratch. * You must ensure minimal time complexity for the insertion and deletion operations where possible. * The list can contain any integers or strings as values. * You should handle edge cases gracefully, including operations on an empty list. * The list should be able to dynamically resize with inserts and deletes. Function Signature ```python class SinglyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value): pass def insert_at_tail(self, value): pass def delete(self, value): pass def search(self, value): pass def display(self): pass ``` # Example Usage: ```python # Create a new singly linked list sll = SinglyLinkedList() # Insert elements at head sll.insert_at_head(1) sll.insert_at_head(2) sll.insert_at_head(3) # Insert elements at tail sll.insert_at_tail(4) sll.insert_at_tail(5) # Display elements print(sll.display()) # Output: [3, 2, 1, 4, 5] # Search for elements print(sll.search(3)) # Output: True print(sll.search(6)) # Output: False # Delete an element sll.delete(2) print(sll.display()) # Output: [3, 1, 4, 5] # Delete a non-existent element (should not crash or change the list) sll.delete(6) print(sll.display()) # Output: [3, 1, 4, 5] ```","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None class SinglyLinkedList: def __init__(self): self.head = None def insert_at_head(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def insert_at_tail(self, value): new_node = Node(value) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node def delete(self, value): current = self.head if current and current.value == value: self.head = current.next return previous = None while current and current.value != value: previous = current current = current.next if current: previous.next = current.next def search(self, value): current = self.head while current: if current.value == value: return True current = current.next return False def display(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values"},{"question":"# Objective Assume you are tasked with sorting a library\'s catalog system. The basic sorting mechanism available is extremely underperforming, known as Stooge Sort. Below is its implementation. Your goal is to fix any errors in the provided code and optimize its functionality as needed. Also, implement a function to check the sort correctness and evaluate its performance against more efficient algorithms. # Task Description **Part 1: Correction and Optimization** 1. Analyze the given Stooge Sort implementation, identify any potential bugs or inefficiencies, and correct them. 2. Implement Stooge Sort and ensure it works as intended for different sets of inputs. **Part 2: Validation and Comparison** 1. Implement a `check_sort()` function that verifies if an array is sorted. 2. Compare the execution time of Stooge Sort against the more conventional `sorted()` function provided by Python on various datasets (small, medium, large). # Input Format 1. An integer array with N elements: ```python arr = [list-of-integers] ``` # Output Format 1. The sorted array after applying Stooge Sort. # Performance Requirements 1. Ensure Stooge Sort adheres to its expected time complexity. 2. Demonstrate through execution time comparison that Stooge Sort is slower than Python\'s built-in `sorted()` function. # Constraints * The array length N should be such that `1 <= N <= 20` due to Stooge Sort\'s inefficiency. # Example ```python # Input array arr = [3, 1, 4, 1, 5, 9, 2, 6] # Expected output using Stooge Sort output = [1, 1, 2, 3, 4, 5, 6, 9] # Sample Function Usage sorted_arr = stoogesort(arr, 0, len(arr)-1) print(\\"Sorted array is:\\", sorted_arr) print(\\"Array is sorted:\\", check_sort(sorted_arr)) compare_to_builtin_sort(arr) ``` # Implementation Implement the function in Python: ```python def stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) def check_sort(arr): # Implement a function that returns True if the array is sorted pass def compare_to_builtin_sort(arr): # Implement code to compare the performance of Stooge Sort against Python\'s sorted() pass # You can add additional helper functions if needed ```","solution":"def stoogesort(arr, l, h): Function to perform Stooge Sort on the array if l >= h: return # If first element is greater than the last, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If there are more than 2 elements in the array segment if h - l + 1 > 2: t = (h - l + 1) // 3 # Recursively sort first 2/3 segment stoogesort(arr, l, h - t) # Recursively sort last 2/3 segment stoogesort(arr, l + t, h) # Recursively sort first 2/3 segment again stoogesort(arr, l, h - t) def check_sort(arr): Function to check if the array is sorted in non-decreasing order for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def compare_to_builtin_sort(arr): Function to compare the performance of Stooge Sort against Python\'s sorted() function import time import copy # Copy the array for fair comparison arr_copy = copy.deepcopy(arr) # Stooge Sort timing start_time = time.perf_counter() stoogesort(arr, 0, len(arr) - 1) stooge_sort_time = time.perf_counter() - start_time # Built-in Sort timing start_time = time.perf_counter() sorted_arr = sorted(arr_copy) built_in_sort_time = time.perf_counter() - start_time return (stooge_sort_time, built_in_sort_time)"},{"question":"# Postorder Traversal Implementation Given a binary tree, write a function that returns the postorder traversal of its nodes\' values. Function Signature ```python def postorder_traversal(root: \'Node\') -> List[int]: ``` # Input - `root` (Node): The root of the binary tree. # Output - `List[int]`: The list containing the postorder traversal of the binary tree. # Constraints - The number of nodes in the binary tree is in the range [0, 10^4]. - The values of the nodes are in the range [-10^4, 10^4]. # Performance Requirements The solution should handle large trees efficiently with an optimal time complexity of O(n). # Example ```python # Define the Tree # 1 # # 2 # / # 3 node3 = Node(3) node2 = Node(2, node3) root = Node(1, None, node2) # Function Call print(postorder_traversal(root)) # Output should be [3, 2, 1] ``` # Additional Requirements Implement both an iterative and a recursive approach within `postorder_traversal`. Choose the approach based on your preference for the main implementation, but include comments on the alternative approach.","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def postorder_traversal(root: Optional[Node]) -> List[int]: Returns the postorder traversal of a binary tree\'s nodes\' values. if root is None: return [] # Iterative Approach (Preferred) stack = [root] output = [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] # Recursive Approach (Alternative, commented out) # def postorder(node): # if not node: # return [] # return postorder(node.left) + postorder(node.right) + [node.val] # return postorder(root)"},{"question":"You are given a singly linked list where each node contains an integer value. Your task is to write a function that determines whether the linked list is sorted in strictly increasing order. # Function Signature ```python def is_sorted(head: Optional[ListNode]) -> bool: ``` # Input - `head`: An instance of `ListNode` representing the head of the singly linked list, or `None` if the list is empty. # Output - Return `True` if the list is sorted in strictly increasing order, otherwise return `False`. # Constraints - The linked list may contain any integer values. - The linked list may be empty. # Performance Requirements - Your solution should run in O(n) time complexity. - Your solution should use O(1) additional space. # Example ```python # Example of defining ListNode class (if not provided) class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, None)))) print(is_sorted(head)) # Output: True # Example 2 head = ListNode(1, ListNode(2, ListNode(-1, ListNode(3, None)))) print(is_sorted(head)) # Output: False # Example 3 head = None print(is_sorted(head)) # Output: True ``` # Scenario Imagine you are working with a database of timestamps that are stored as a singly linked list. You need to check if these timestamps are in order before running a maintenance algorithm that assumes the timestamps are sorted. By implementing your `is_sorted` function, you can ensure the integrity of your data before proceeding with further operations.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head: \\"ListNode\\") -> bool: Determines if the linked list is sorted in strictly increasing order. :param head: Optional[ListNode], the head of the singly linked list. :return: bool, True if the list is sorted in strictly increasing order, otherwise False. if not head: return True current = head while current.next: if current.val >= current.next.val: return False current = current.next return True"},{"question":"# Most Frequent Element(s) in a List Write a function `most_frequent_elements(arr)` that determines the most frequently occurring element(s) in an input list `arr` and returns them in a list. The function should have the following signature: ```python def most_frequent_elements(arr: list) -> list: ``` # Inputs * A list of integers `arr` where `0 <= len(arr) <= 10^6` and each integer value is within the range of standard 32-bit integers. # Outputs * A list of integers representing the most frequently occurring value(s) in the input list. # Constraints * The function should execute in linear time complexity O(n). * The function should handle edge cases such as: - Empty lists. - Lists where all elements are unique. - Lists with multiple elements having the same maximum frequency. # Example ```python print(most_frequent_elements([1, 1, 2, 2, 3, 4])) # Output: [1, 2] print(most_frequent_elements([])) # Output: [] print(most_frequent_elements([4, 4, 4, 4])) # Output: [4] print(most_frequent_elements([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] ``` # Performance Requirements * Ensure the solution handles inputs up to the maximum constraint efficiently without exceeding memory limits. * Implement error handling for incorrect data types to ensure robust function operation.","solution":"from collections import Counter def most_frequent_elements(arr: list) -> list: Determines the most frequently occurring element(s) in the input list. :param arr: List of integers :return: List of integers representing the most frequently occurring element(s) if not arr: return [] frequency = Counter(arr) max_freq = max(frequency.values()) most_frequent = [num for num, freq in frequency.items() if freq == max_freq] return most_frequent"},{"question":"# Coding Task You are given an array of mixed data types, which may include integers, booleans, strings, etc. Your task is to write a function `move_zeros_in_place(array)` that rearranges the array in place such that all the zeros are moved to the end, while preserving the order of the other elements. Use the following guidelines: 1. You must not use any extra list or array. 2. You can change the elements of the given array in place only. 3. The algorithm should have a linear time complexity (O(n)). 4. Handle edge cases effectively (e.g., different data types, no zeros, all zeros, empty array). Your implementation should consider a minimal memory overhead and avoid using extra space as much as possible. Function Signature ```python def move_zeros_in_place(array: list) -> None: pass ``` Example ```python array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros_in_place(array) print(array) # Output: [False, 1, 1, 2, 1, 3, \'a\', 0, 0] ``` Constraints * Do not use any additional arrays or lists. * Iterate through the array with an aim to achieve linear time complexity. * The zeros must be moved to the end, and the non-zero elements must maintain their order.","solution":"def move_zeros_in_place(array: list) -> None: Moves all the zeros in the array to the end, preserving the order of other elements. Parameters: array (list): The list to modify in place. zero_pos = 0 # Position to place the non-zero element # Traverse the array for i in range(len(array)): if array[i] != 0 or type(array[i]) == bool: # This will treat boolean `False` (which is 0 in int) differently. array[zero_pos], array[i] = array[i], array[zero_pos] if zero_pos != i: array[i] = 0 # Swap shouldn\'t affect the in-place rearrangement zero_pos += 1"},{"question":"You are given an unsorted array of integers and a query element. Implement a function that performs a Linear Search to find the index of the given query element in the array. If the element is not in the array, return -1. # Function signature ```python def linear_search(array: List[int], query: int) -> int: ``` # Input * `array` (List[int]): A list of integers which may be empty. * `query` (int): The integer to search for within `array`. # Output * `int`: The index of `query` in `array` if it exists, otherwise -1. # Constraints * The elements of the array can be any integer. * Array length can be up to 10^6. # Example ```python assert linear_search([1, 3, 5, 7, 9], 7) == 3 assert linear_search([10, 20, 30, 40, 50], 60) == -1 assert linear_search([], 4) == -1 assert linear_search([1], 1) == 0 assert linear_search([1, 2, 3, 4, 2], 2) == 1 # Returns the index of the first occurrence ``` # Notes * Pay attention to edge cases such as empty arrays or arrays where all elements are identical. * Consider the performance impact for large arrays as well.","solution":"from typing import List def linear_search(array: List[int], query: int) -> int: Perform a linear search to find the index of a query element in an array. Parameters: array (List[int]): A list of integers. query (int): The integer to search for within the array. Returns: int: The index of the query element if found, otherwise -1. for index, element in enumerate(array): if element == query: return index return -1"},{"question":"You are given a class `Node` representing a node in a Binary Search Tree (BST) and a class `bst` that can initialize an empty tree and insert values into the tree. Your task is to write a function `count_left_node` that takes as input the root node of a BST and returns the number of left children in the tree. # Function Signature ```python def count_left_node(root: Node) -> int: pass ``` # Input * `root` (Node) : The root node of the BST (it may be `None` for an empty tree). # Output * Returns the number of left children in the BST. # Constraints * The tree nodes can contain any integer values. * Tree can have duplicate values. * Tree height can be unbounded (you may assume Python\'s recursion limit is sufficiently high). # Example Consider the following BST for which you need to find the number of left children: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` In this example, the nodes storing the values `6`, `3`, `7`, and `10` are left children, so the function should return 4. ```python # Example usage: # Create the BST with provided structure tree = bst() tree.insert(9) tree.insert(6) tree.insert(12) tree.insert(3) tree.insert(8) tree.insert(10) tree.insert(15) tree.insert(7) tree.insert(18) # Invoke the count_left_node on root and assert the expected result assert count_left_node(tree.root) == 4 ``` # Additional Scenario: If the tree is empty, the function should return 0. # Notes: * Focus on handling edge cases such as empty tree or a tree where nodes only form a right-skewed or left-skewed structure. * Avoid solutions that use additional data structures unnecessarily; aim for a recursive solution as provided, but ensure it\'s robust and covers all edge cases.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class bst: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def count_left_node(root: Node) -> int: if not root: return 0 left_count = 1 if root.left else 0 return left_count + count_left_node(root.left) + count_left_node(root.right) # This implementation recursively checks each node and counts the left children."},{"question":"# Question: Implement an AVL Tree An AVL tree is a self-balancing binary search tree where the difference in heights between the left and right subtrees cannot be more than one for all nodes. **Objectives**: * Implement an AVL Tree with the following functionalities: 1. **Insert**: Insert nodes while maintaining the AVL balance property. 2. **Search**: Search for a specific value in the AVL tree. 3. **Size**: Return the size of the AVL tree (total number of nodes). 4. **Inorder Traversal**: Perform an inorder traversal of the tree. Detailed Requirements: 1. **Insert(data: int) -> bool**: - Inserts a value into the AVL tree if not already present. - Maintains balance by performing rotations following AVL rules. - Returns `True` if insertion is successful, `False` if the data already exists. 2. **Search(data: int) -> bool**: - Returns `True` if the value exists in the tree, `False` otherwise. 3. **Size() -> int**: - Returns the total number of nodes in the tree. 4. **InorderTraversal() -> List[int]**: - Returns a list of elements resulting from an inorder traversal of the tree. Constraints: - Input data is always an integer. - Your code should handle an empty tree scenario appropriately. - The AVL Tree should remain balanced after each insertion. Example: ```python # Example usage: avl = AVLTree() print(avl.insert(10)) # True print(avl.insert(15)) # True print(avl.insert(10)) # False print(avl.size()) # 2 print(avl.search(15)) # True print(avl.search(100)) # False print(avl.inorder_traversal()) # [10, 15] ``` Performance Requirements: - Ensure that the insertion and search operations have a time complexity of O(log N). **Write your code implementation below:**","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None self.node_count = 0 def insert(self, key): if self.search(key): return False self.root = self._insert(self.root, key) self.node_count += 1 return True def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def size(self): return self.node_count def inorder_traversal(self): res = [] self._inorder_traversal(self.root, res) return res def _inorder_traversal(self, node, res): if node: self._inorder_traversal(node.left, res) res.append(node.key) self._inorder_traversal(node.right, res) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y"},{"question":"Matrix Chain Multiplication Given an array `dimensions` where `dimensions[i]` represent the dimensions of the matrix chain in the following manner: if `dimensions[i]` is `p` and `dimensions[i+1]` is `q`, then the matrix (A_i) is of dimensions (p times q). # Task Write a function `optimal_matrix_chain_order(dimensions)` to compute the minimum number of scalar multiplications needed to multiply a chain of matrices. Additionally, implement a function `retrieve_order(split_points, i, j)` to print the order of multiplication using the `split_points` matrix from the Dynamic Programming table. # Function Signatures ```python def optimal_matrix_chain_order(dimensions: List[int]) -> Tuple[int, List[List[int]]]: pass def retrieve_order(split_points: List[List[int]], i: int, j: int) -> str: pass ``` # Input * An integer array `dimensions` of size (n), where the length of the matrix chain is ((n-1)). # Output * `optimal_matrix_chain_order(dimensions)` should return a tuple: - An integer representing the minimum number of multiplications. - A 2D list showing the split points to determine the order of multiplication using `retrieve_order`. * `retrieve_order(split_points, i, j)` should return a string representing the optimal order of parentheses. # Constraints * (1 leq n leq 100) * (1 leq dimensions[i] leq 1000) # Example ```python dimensions = [30, 35, 15, 5, 10, 20, 25] multiplications, split_points = optimal_matrix_chain_order(dimensions) print(multiplications) # Expected Output: 15125 order = retrieve_order(split_points, 1, len(dimensions)-1) print(order) # Expected Output: \\"((A0(A1A2))((A3A4)A5))\\" ``` # Explanation For the given example: * There are 6 matrices (A0:A0(30 times 35), A1: (35 times 15), A2: (15 times 5), A3: (5 times 10), A4: (10 times 20), A5: (20 times 25)) * The optimal order of multiplication should be determined with minimal scalar multiplications. # Constraints to Consider * Handle and return correct results for edge cases for small dimension arrays. * Ensure efficient memory usage and avoid redundant calculations.","solution":"from typing import List, Tuple def optimal_matrix_chain_order(dimensions: List[int]) -> Tuple[int, List[List[int]]]: n = len(dimensions) # Initialize DP tables m = [[0 for _ in range(n)] for _ in range(n)] s = [[0 for _ in range(n)] for _ in range(n)] # l is chain length for l in range(2, n): for i in range(1, n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dimensions[i - 1] * dimensions[k] * dimensions[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n - 1], s def retrieve_order(split_points: List[List[int]], i: int, j: int) -> str: if i == j: return f\\"A{i-1}\\" else: k = split_points[i][j] left_order = retrieve_order(split_points, i, k) right_order = retrieve_order(split_points, k + 1, j) return f\\"({left_order}{right_order})\\""}]'),O={name:"App",components:{PoemCard:E},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},L={class:"card-container"},F={key:0,class:"empty-state"},z=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,z)):u("",!0)])}const P=c(O,[["render",j],["__scopeId","data-v-95809cf5"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/49.md","filePath":"drive/49.md"}'),B={name:"drive/49.md"},H=Object.assign(B,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,H as default};
