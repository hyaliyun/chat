import{_,o as s,c as i,a as t,m,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},j={class:"review-content"};function E(n,e,u,c,r,a){return s(),i("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",j,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const N=_(q,[["render",E],["__scopeId","data-v-f4032ddd"]]),R=JSON.parse(`[{"question":"def sum_of_connected_components_values(n: int, m: int, node_values: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the sum of the values of all connected components in the graph. Parameters: - n: the number of nodes in the graph - m: the number of edges in the graph - node_values: list of integer values associated with each node - edges: list of tuples representing edges between nodes Returns: The sum of the maximum values of all connected components in the graph. >>> sum_of_connected_components_values(5, 3, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (4, 5)]) 8 >>> sum_of_connected_components_values(4, 0, [2, 3, 1, 4], []) 10 >>> sum_of_connected_components_values(3, 2, [10, 20, 30], [(1, 2), (2, 3)]) 30 >>> sum_of_connected_components_values(6, 3, [1, 5, 3, 7, 2, 6], [(1, 2), (3, 4), (5, 6)]) 18 >>> sum_of_connected_components_values(1, 0, [42], []) 42 pass","solution":"def sum_of_connected_components_values(n, m, node_values, edges): from collections import defaultdict, deque # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u - 1].append(v - 1) adj_list[v - 1].append(u - 1) def bfs(start_node): q = deque([start_node]) max_value = node_values[start_node] visited[start_node] = True while q: node = q.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True q.append(neighbor) max_value = max(max_value, node_values[neighbor]) return max_value visited = [False] * n total_sum = 0 for i in range(n): if not visited[i]: total_sum += bfs(i) return total_sum"},{"question":"from collections import defaultdict from typing import List, Tuple def max_data_flow(n: int, m: int, links: List[Tuple[int, int, int]], s: int, t: int) -> int: Calculate the maximum potential data flow from a source server s to a destination server t. Args: n (int): Number of servers m (int): Number of communication links links (List[Tuple[int, int, int]]): List of tuples representing communication links s (int): Source server t (int): Destination server Returns: int: Maximum data flow from source to destination def test_max_data_flow_basic(): n = 4 m = 5 links = [(1, 2, 100), (1, 3, 100), (2, 3, 1), (2, 4, 100), (3, 4, 100)] s = 1 t = 4 assert max_data_flow(n, m, links, s, t) == 200 def test_max_data_flow_single_path(): n = 3 m = 2 links = [(1, 2, 5), (2, 3, 5)] s = 1 t = 3 assert max_data_flow(n, m, links, s, t) == 5 def test_max_data_flow_multiple_paths(): n = 6 m = 10 links = [(1, 2, 10), (2, 6, 10), (1, 3, 10), (3, 6, 10), (1, 4, 10), (4, 6, 10), (1, 5, 10), (5, 6, 7), (2, 3, 1), (4, 5, 1)] s = 1 t = 6 assert max_data_flow(n, m, links, s, t) == 37 def test_max_data_flow_large_capacity(): n = 5 m = 6 links = [(1, 2, 1000), (1, 3, 1000), (2, 3, 1000), (2, 4, 1000), (3, 5, 1000), (4, 5, 1000)] s = 1 t = 5 assert max_data_flow(n, m, links, s, t) == 2000","solution":"from collections import deque, defaultdict def bfs(C, F, source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: u = queue.popleft() for v in C[u]: if v not in visited and C[u][v] - F[u][v] > 0: queue.append(v) visited.add(v) parent[v] = u if v == sink: return True return False def edmonds_karp(C, source, sink): Using Edmonds-Karp algorithm to find the maximum flow n = len(C) F = defaultdict(lambda: defaultdict(int)) parent = {} max_flow = 0 while bfs(C, F, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, C[parent[s]][s] - F[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] F[u][v] += path_flow F[v][u] -= path_flow v = parent[v] max_flow += path_flow return max_flow def max_data_flow(n, m, links, s, t): C = defaultdict(lambda: defaultdict(int)) for u, v, d in links: C[u][v] += d C[v][u] += d return edmonds_karp(C, s, t)"},{"question":"from typing import List, Tuple def solve_tree_queries(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: You are given a tree (connected acyclic undirected graph) with \`n\` nodes. Each node has an integer value assigned to it. Your task is to answer multiple queries on the tree. Each query asks for the maximum value within a given subtree of the tree. Args: n (int): The number of nodes in the tree. values (List[int]): The values assigned to the nodes. edges (List[Tuple[int, int]]): The edges between the nodes. queries (List[int]): The queries representing the nodes of the tree. Returns: List[int]: The maximum values in the subtrees rooted at the nodes specified in the queries. Examples: >>> solve_tree_queries(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [1, 3, 6]) [7, 7, 6] >>> solve_tree_queries(1, [42], [], [1]) [42] >>> solve_tree_queries(5, [5, 4, 3, 2, 1], [(1, 2), (2, 3), (3, 4), (4, 5)], [1, 3, 5]) [5, 3, 1] >>> solve_tree_queries(7, [1, 6, 7, 3, 4, 5, 2], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [1, 2, 3, 4, 5, 6, 7]) [7, 6, 7, 3, 4, 5, 2]","solution":"from collections import defaultdict def build_tree(n, edges): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) return tree def dfs(tree, node, parent, values, subtree_max): # Initially, the maximum of subtree rooted at \`node\` is the value of the node itself max_value = values[node-1] for neighbor in tree[node]: if neighbor != parent: # Get the maximum value for the subtree rooted at the neighbor child_max = dfs(tree, neighbor, node, values, subtree_max) max_value = max(max_value, child_max) # Store the maximum value for the subtree rooted at node subtree_max[node] = max_value return max_value def preprocess_tree(n, values, edges): tree = build_tree(n, edges) subtree_max = [0] * (n + 1) dfs(tree, 1, -1, values, subtree_max) return subtree_max def solve_tree_queries(n, values, edges, queries): subtree_max = preprocess_tree(n, values, edges) result = [] for v in queries: result.append(subtree_max[v]) return result"},{"question":"def max_weight(capacity: int, weights: List[int]) -> int: Determine the highest possible weight a drone can carry given a list of package weights, without exceeding the drone's carrying capacity. Args: capacity (int): Maximum weight the drone can carry. weights (List[int]): List of package weights. Returns: int: The maximum weight the drone can carry without exceeding the capacity. Examples: >>> max_weight(10, [3, 5, 7, 2]) 10 >>> max_weight(15, [4, 8, 5, 6]) 15 >>> max_weight(7, [3, 6, 3, 4]) 7","solution":"def max_weight(capacity, weights): Returns the maximum weight that a drone can carry without exceeding the given capacity. weights.sort(reverse=True) # Sort weights in descending order for better chances to reach capacity sooner n = len(weights) dp = [0] * (capacity + 1) for w in weights: for c in range(capacity, w-1, -1): dp[c] = max(dp[c], dp[c - w] + w) return dp[capacity]"},{"question":"def subset_sum(n: int, target: int, arr: List[int]) -> List[int]: Given an array of integers and a target sum, determine if there is a subset of the array such that the subset's sum is equal to the target sum. If such a subset exists, return the subset's elements; otherwise, return an empty list. >>> subset_sum(5, 9, [1, 2, 3, 4, 5]) [4, 5] >>> subset_sum(4, 10, [2, 4, 6, 8]) [2, 8] >>> subset_sum(3, 2, [1, -1, 3]) [3, -1] >>> subset_sum(5, 20, [1, 2, 3, 4, 5]) [] # Unit tests from solution import subset_sum def test_example_1(): n, target, arr = 5, 9, [1, 2, 3, 4, 5] result = subset_sum(n, target, arr) assert sum(result) == target def test_example_2(): n, target, arr = 4, 10, [2, 4, 6, 8] result = subset_sum(n, target, arr) assert sum(result) == target def test_example_3(): n, target, arr = 3, 2, [1, -1, 3] result = subset_sum(n, target, arr) assert sum(result) == target def test_example_4(): n, target, arr = 5, 20, [1, 2, 3, 4, 5] result = subset_sum(n, target, arr) assert result == [] def test_multiple_solutions(): n, target, arr = 4, 6, [1, 2, 3, 4] result = subset_sum(n, target, arr) assert sum(result) == target def test_negative_elements(): n, target, arr = 5, 0, [-1, 1, -2, 2, 3] result = subset_sum(n, target, arr) assert sum(result) == target","solution":"def subset_sum(n, target, arr): def find_subset(i, current_sum, subset): if current_sum == target: return subset if i >= n or current_sum > target: return None # Choose the current element with_current = find_subset(i + 1, current_sum + arr[i], subset + [arr[i]]) if with_current: return with_current # Do not choose the current element without_current = find_subset(i + 1, current_sum, subset) if without_current: return without_current return None result = find_subset(0, 0, []) return result if result else [] # Example usage n, target = 5, 9 arr = [1, 2, 3, 4, 5] print(subset_sum(n, target, arr)) # Example case"},{"question":"def playlist_manager(operations: list) -> None: Perform operations on a music playlist. >>> playlist_manager([\\"ADD song1\\", \\"ADD song2\\", \\"SHOW\\"]) song1,song2 >>> playlist_manager([\\"ADD song1\\", \\"ADD song2\\", \\"REMOVE song1\\", \\"SHOW\\"]) song2 >>> playlist_manager([\\"ADD song1\\", \\"ADD song2\\", \\"ADD song1\\", \\"COUNT song1\\"]) 2 >>> playlist_manager([\\"ADD song1\\", \\"ADD song2\\", \\"MOVE song2 0\\", \\"SHOW\\"]) song2,song1 >>> playlist_manager([\\"ADD song1\\", \\"ADD song2\\", \\"MOVE song1 5\\", \\"SHOW\\"]) song2,song1","solution":"def playlist_manager(operations: list) -> None: playlist = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": song = parts[1] playlist.append(song) elif command == \\"REMOVE\\": song = parts[1] if song in playlist: playlist.remove(song) elif command == \\"MOVE\\": song = parts[1] index = int(parts[2]) if song in playlist: playlist.remove(song) if index >= len(playlist): playlist.append(song) else: playlist.insert(index, song) elif command == \\"COUNT\\": song = parts[1] print(playlist.count(song)) elif command == \\"SHOW\\": print(\\",\\".join(playlist))"},{"question":"def min_operations_to_sort(n: int, arr: List[int]) -> int: Given an array of n integers, determine the minimum number of operations required to sort the array in non-decreasing order by reversing any prefix of the array. Args: n (int): Number of integers in the array. arr (List[int]): The array of integers. Returns: int: Minimum number of operations required to sort the array. Examples: >>> min_operations_to_sort(5, [3, 2, 1, 4, 5]) 1 >>> min_operations_to_sort(5, [1, 2, 3, 4, 5]) 1 >>> min_operations_to_sort(1, [1]) 1 >>> min_operations_to_sort(5, [5, 4, 3, 2, 1]) 1","solution":"def min_operations_to_sort(n, arr): Returns the minimum number of operations required to sort the array in non-decreasing order by reversing any prefix of the array. sorted_arr = sorted(arr) for i in range(n): if arr[:i + 1] == sorted_arr[:i + 1]: return 1 return 1"},{"question":"def find_single_number(nums): Returns the integer that appears only once in the list. Each integer in the list appears exactly twice, except for one integer. Args: nums: List of integers Returns: int: The integer that appears only once >>> find_single_number([2, 1, 4, 5, 2, 4, 1]) 5 >>> find_single_number([2, -1, 4, 5, 2, 4, 5]) -1 >>> find_single_number([-2, -1, -4, -2, -4]) -1 >>> find_single_number([0, -1, -1]) 0 >>> find_single_number([42]) 42","solution":"def find_single_number(nums): Returns the integer that appears only once in the list. Each integer in the list appears exactly twice, except for one integer. Args: nums: List of integers Returns: int: The integer that appears only once result = 0 for num in nums: result ^= num return result"},{"question":"def rearrange_string(s: str) -> str: Write a function to determine if it is possible to rearrange the characters of a given string \`s\` such that no two adjacent characters are the same. If possible, return any valid rearrangement of the string. Otherwise, return \\"IMPOSSIBLE\\". >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaab\\") 'IMPOSSIBLE' # Implement your solution here # Example unit tests def test_rearrange_string_possible(): assert rearrange_string(\\"aabb\\") == \\"abab\\" assert rearrange_string(\\"abcabc\\") in [\\"abcabc\\", \\"acbacb\\", \\"bcabca\\", \\"bacbac\\", \\"cabaca\\", \\"cacbac\\"] assert rearrange_string(\\"aab\\") in [\\"aba\\"] def test_rearrange_string_impossible(): assert rearrange_string(\\"aaab\\") == \\"IMPOSSIBLE\\" assert rearrange_string(\\"aaaa\\") == \\"IMPOSSIBLE\\" assert rearrange_string(\\"aaaab\\") == \\"IMPOSSIBLE\\" def test_rearrange_string_edge_cases(): assert rearrange_string(\\"a\\") == \\"a\\" assert rearrange_string(\\"ab\\") == \\"ab\\" assert rearrange_string(\\"abc\\") in [\\"abc\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\", \\"acb\\"]","solution":"from collections import Counter import heapq def rearrange_string(s): Reorganizes the given string \`s\` such that no two adjacent characters are the same. If it is not possible, returns \\"IMPOSSIBLE\\". # Count frequency of each character count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char result = ''.join(result) return result if len(result) == len(s) else \\"IMPOSSIBLE\\""},{"question":"def max_square_park(grid: List[str]) -> int: Find the maximum side length k such that at least one park of size k x k can be built on the grid. Args: grid (List[str]): A list of strings representing the grid, where 'X' marks unsuited cells and '.' marks empty cells. Returns: int: The maximum possible side length k of a square park that can be built on the grid, or 0 if no park can be built. Examples: >>> max_square_park([ \\"......\\", \\"..XX..\\", \\"......\\", \\"......\\", \\"XX....\\" ]) 3 >>> max_square_park([ \\"XXXX\\", \\"X..X\\", \\"X..X\\", \\"XXXX\\" ]) 2 >>> max_square_park([ \\"XXXX\\", \\"XXXX\\", \\"XXXX\\", \\"XXXX\\" ]) 0","solution":"def max_square_park(grid): n = len(grid) m = len(grid[0]) # dp[i][j] will be the length of the largest square where grid[i][j] is the bottom-right corner dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"from typing import List def splitArray(nums: List[int], k: int) -> int: You have been given an integer array \`nums\` of length \`n\` and an integer \`k\`. You need to split the array into \`k\` contiguous subarrays such that the largest sum among these subarrays is minimized. Args: nums (List[int]): The array of integers. k (int): The number of subarrays to split into. Returns: int: The minimized largest sum among the subarrays. >>> splitArray([7,2,5,10,8], 2) 18 >>> splitArray([1,2,3,4,5], 2) 9","solution":"from typing import List def splitArray(nums: List[int], k: int) -> int: def canSplit(maxSum): count = 1 currentSum = 0 for num in nums: if currentSum + num > maxSum: count += 1 currentSum = num if count > k: return False else: currentSum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"def apply_discounts(N: int, products: List[Tuple[str, str, float]], M: int, discounts: List[Tuple[str, int]]) -> List[Tuple[str, str, float]]: Apply discounts to the product prices based on their categories. Args: N (int): Number of products. products (List[Tuple[str, str, float]]): List of products with their names, categories, and prices. M (int): Number of discount rates. discounts (List[Tuple[str, int]]): List of discount rates for each category. Returns: List[Tuple[str, str, float]]: Updated product details with new prices after applying discounts. >>> apply_discounts(3, [(\\"Laptop\\", \\"Electronics\\", 799.99), (\\"Book\\", \\"Literature\\", 19.99), (\\"Headphones\\", \\"Electronics\\", 149.99)], 2, [(\\"Electronics\\", 10), (\\"Literature\\", 5)]) [(\\"Laptop\\", \\"Electronics\\", 719.99), (\\"Book\\", \\"Literature\\", 18.99), (\\"Headphones\\", \\"Electronics\\", 134.99)] >>> apply_discounts(1, [(\\"Table\\", \\"Furniture\\", 299.99)], 1, [(\\"Electronics\\", 10)]) [(\\"Table\\", \\"Furniture\\", 299.99)] >>> apply_discounts(1, [(\\"Chair\\", \\"Furniture\\", 99.99)], 1, [(\\"Furniture\\", 0)]) [(\\"Chair\\", \\"Furniture\\", 99.99)] >>> apply_discounts(1, [(\\"Desk\\", \\"Office\\", 199.99)], 1, [(\\"Office\\", 100)]) [(\\"Desk\\", \\"Office\\", 0.00)]","solution":"def apply_discounts(N, products, M, discounts): discount_dict = {category: rate for category, rate in discounts} updated_products = [] for name, category, price in products: if category in discount_dict: discount = discount_dict[category] new_price = price * (1 - discount / 100) else: new_price = price updated_products.append((name, category, round(new_price, 2))) return updated_products"},{"question":"def find_max_diff_indices(arr: List[int]) -> Tuple[int, int]: Finds and returns indices i and j such that the absolute difference between arr[i] and arr[j] is maximal possible with i < j. >>> find_max_diff_indices([1, 3, 9, 4, 6]) (1, 3) >>> find_max_diff_indices([5, 5, 5, 5, 5]) (1, 2) >>> find_max_diff_indices([-10, -20, -30, -40, -50]) (1, 5) >>> find_max_diff_indices([-50, -10, 0, 10, 50]) (1, 5) >>> find_max_diff_indices(list(range(1, 100001))) (1, 100000)","solution":"def find_max_diff_indices(arr): Finds and returns indices i and j such that the absolute difference between arr[i] and arr[j] is maximal possible with i < j. min_index = 0 max_index = 0 for i in range(1, len(arr)): if arr[i] < arr[min_index]: min_index = i if arr[i] > arr[max_index]: max_index = i if min_index < max_index: return (min_index + 1, max_index + 1) else: return (max_index + 1, min_index + 1)"},{"question":"from typing import List, Tuple def process_queries(n: int, edges: List[Tuple[int, int]], values: List[int], queries: List[int]) -> List[int]: You are given an undirected graph with \`n\` nodes and \`m\` edges. Each node has an integer value associated with it. The task is to process multiple queries where each query asks to calculate the sum of values of nodes connected to a given starting node, either directly or indirectly. Parameters: - n: The number of nodes. - edges: A list of tuples, where each tuple contains two integers indicating an edge between two nodes. - values: A list of integer values associated with each node. - queries: A list of starting nodes for each query. Returns: - A list of integers where each integer is the sum of values of connected nodes for the corresponding query. Example: >>> process_queries(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [1, 2, 3, 4, 5], [1, 3, 5]) [15, 15, 15] pass # Implement the function # Example usage and test cases def test_single_node(): assert process_queries(1, [], [10], [1]) == [10] def test_no_edges(): assert process_queries(3, [], [1, 2, 3], [1, 2, 3]) == [1, 2, 3] def test_all_connected(): assert process_queries(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [1, 2, 3, 4, 5], [1, 3, 5]) == [15, 15, 15] def test_multiple_components(): assert process_queries(6, [(1, 2), (2, 3), (4, 5)], [1, 2, 3, 4, 5, 6], [1, 4, 6]) == [6, 9, 6] def test_small_disconnected_graph(): assert process_queries(4, [(1, 2), (3, 4)], [1, 1, 1, 1], [1, 3]) == [2, 2] def test_complex_graph(): assert process_queries(7, [(1, 2), (2, 3), (3, 4), (5, 6), (6, 7)], [10, 20, 30, 40, 50, 60, 70], [1, 5]) == [100, 180] # Test the implementation using the provided test cases if __name__ == \\"__main__\\": test_single_node() test_no_edges() test_all_connected() test_multiple_components() test_small_disconnected_graph() test_complex_graph() print(\\"All tests passed.\\")","solution":"def find_connected_components(n, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = [] def bfs(node): queue = deque([node]) component = [] visited[node] = True while queue: current = queue.popleft() component.append(current) for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component for node in range(1, n + 1): if not visited[node]: component = bfs(node) components.append(component) return components def preprocess_values(n, values, components): value_sums = {} for component in components: component_sum = sum(values[node - 1] for node in component) for node in component: value_sums[node] = component_sum return value_sums def process_queries(n, edges, values, queries): components = find_connected_components(n, edges) value_sums = preprocess_values(n, values, components) results = [value_sums[query] for query in queries] return results # Example usage: n = 5 m = 4 values = [1, 2, 3, 4, 5] edges = [(1, 2), (2, 3), (3, 4), (4, 5)] queries = [1, 3, 5] print(process_queries(n, edges, values, queries))"},{"question":"def largest_same_height_square(grid): Determine the side length of the largest possible square sub-grid where all tiles have the same height. >>> largest_same_height_square([[1, 1, 3, 4], [1, 1, 3, 4], [5, 5, 5, 5], [1, 5, 5, 5]]) 2 >>> largest_same_height_square([[1]]) 1 >>> largest_same_height_square([[2, 2], [2, 2]]) 2 >>> largest_same_height_square([[2, 2, 2, 3, 3], [2, 3, 2, 3, 3], [2, 2, 2, 2, 3], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]]) 3 >>> largest_same_height_square([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 3 >>> largest_same_height_square([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 1","solution":"def largest_same_height_square(grid): n = len(grid) dp = [[0] * n for _ in range(n)] max_side = 0 for i in range(n): for j in range(n): if i == 0 or j == 0: dp[i][j] = 1 else: if grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def min_adjacent_swaps(tasks: List[str]) -> int: Given a list of tasks represented by their status, returns the minimum number of adjacent swaps required to sort the tasks in the order: [\\"ToDo\\", \\"InProgress\\", \\"Review\\", \\"Done\\"] Args: tasks (List[str]): A list of strings representing the status of each task. Returns: int: The minimum number of adjacent swaps required to sort the tasks. >>> min_adjacent_swaps([\\"ToDo\\", \\"InProgress\\", \\"Done\\", \\"ToDo\\", \\"Review\\"]) 3 >>> min_adjacent_swaps([\\"ToDo\\", \\"InProgress\\", \\"Review\\", \\"Done\\"]) 0 >>> min_adjacent_swaps([\\"Done\\", \\"Review\\", \\"InProgress\\", \\"ToDo\\"]) 6 >>> min_adjacent_swaps([\\"Review\\", \\"ToDo\\", \\"Done\\", \\"InProgress\\", \\"ToDo\\", \\"Review\\"]) 7 >>> min_adjacent_swaps([]) 0 >>> min_adjacent_swaps([\\"ToDo\\"]) 0 >>> min_adjacent_swaps([\\"Done\\"]) 0","solution":"def min_adjacent_swaps(tasks): Given a list of tasks represented by their status, returns the minimum number of adjacent swaps required to sort the tasks in the order: [\\"ToDo\\", \\"InProgress\\", \\"Review\\", \\"Done\\"] order = {\\"ToDo\\": 0, \\"InProgress\\": 1, \\"Review\\": 2, \\"Done\\": 3} def count_inversions(arr): # Merge sort to count inversions (adjacent swaps) if len(arr) < 2: return arr, 0 mid = len(arr) // 2 left, left_inv = count_inversions(arr[:mid]) right, right_inv = count_inversions(arr[mid:]) merged, split_inv = merge_and_count(left, right) return merged, left_inv + right_inv + split_inv def merge_and_count(left, right): merged = [] i = j = inversions = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) inversions += (len(left) - i) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged, inversions task_indices = [order[task] for task in tasks] _, swaps = count_inversions(task_indices) return swaps"},{"question":"def min_days_to_bloom(n: int, bloom_days: List[int]) -> int: Given the number of types of flowers and the number of days each type blooms, return the minimum number of days required to create a flower bed with at least one of each type of flower and no two flowers of the same type blooming consecutively. >>> min_days_to_bloom(3, [4, 3, 2]) 9 >>> min_days_to_bloom(4, [1, 2, 1, 2]) 6 >>> min_days_to_bloom(1, [7]) 7 >>> min_days_to_bloom(5, [5, 5, 5, 5, 5]) 25 >>> min_days_to_bloom(3, [10, 3, 4]) 17 >>> min_days_to_bloom(2, [100, 100]) 200","solution":"def min_days_to_bloom(n, bloom_days): Given the number of types of flowers and the number of days each type blooms, return the minimum number of days required to create a flower bed with at least one of each type of flower and no two flowers of the same type blooming consecutively. # Sort bloom_days in descending order bloom_days.sort(reverse=True) # Initialize the total days total_days = 0 # Sum the number of days for days in bloom_days: total_days += days # The minimum number of days is the sum return total_days"},{"question":"def remove_k_characters_to_lexicographically_smallest(s: str, k: int) -> str: Remove exactly 'k' characters from the string \`s\` to make it lexicographically smallest. pass def process_test_cases(input_data: str) -> list: Process multiple test cases and return the lexicographically smallest strings. pass # Unit test cases def test_example_cases(): input_data = ''' 3 abcde 2 bac 1 a 0''' expected_output = ['abc', 'ac', 'a'] assert process_test_cases(input_data) == expected_output def test_single_character(): input_data = ''' 1 a 0 ''' expected_output = ['a'] assert process_test_cases(input_data) == expected_output def test_complete_removal(): input_data = ''' 1 abc 2 ''' expected_output = ['a'] assert process_test_cases(input_data) == expected_output def test_no_removal(): input_data = ''' 1 abcdef 0 ''' expected_output = ['abcdef'] assert process_test_cases(input_data) == expected_output def test_remove_one_character(): input_data = ''' 1 bcda 1 ''' expected_output = ['bca'] assert process_test_cases(input_data) == expected_output def test_large_k(): input_data = ''' 1 zyxwvu 5 ''' expected_output = ['u'] assert process_test_cases(input_data) == expected_output","solution":"def remove_k_characters_to_lexicographically_smallest(s, k): Remove exactly 'k' characters from the string \`s\` to make it lexicographically smallest. stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # In case we still need to remove more characters while k > 0: stack.pop() k -= 1 return ''.join(stack) def process_test_cases(input_data): lines = input_data.strip().split('n') t = int(lines[0]) results = [] for i in range(1, t + 1): parts = lines[i].split() s, k = parts[0], int(parts[1]) result = remove_k_characters_to_lexicographically_smallest(s, k) results.append(result) return results"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling the stock once. If no profit can be made, returns 0. :param prices: List of integers representing the stock prices on each day. :return: Integer, maximum profit >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([3, 3, 3, 3, 3, 3]) 0 >>> max_profit([1, 2, 3, 4, 5, 6]) 5 >>> max_profit([5, 4, 3, 2, 1, 6]) 5 >>> max_profit([4, 4, 4, 4, 4, 4]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling the stock once. If no profit can be made, returns 0. :param prices: List of integers representing the stock prices on each day. :return: Integer, maximum profit if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def can_partition_fruits(n: int, lumens: List[int]) -> str: Determine if it is possible to partition the fruits into two groups with equal sum of lumens. >>> can_partition_fruits(4, [1, 5, 11, 5]) \\"YES\\" >>> can_partition_fruits(4, [1, 5, 3, 2]) \\"NO\\"","solution":"def can_partition_fruits(n, lumens): total_sum = sum(lumens) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for lumen in lumens: for j in range(target, lumen - 1, -1): dp[j] = dp[j] or dp[j - lumen] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"import heapq from typing import List, Tuple def maximum_weighted_edge_in_path(n: int, m: int, edges: List[Tuple[int, int, int]], u: int, v: int) -> int: Consider an undirected graph with \`n\` nodes and \`m\` edges. Each edge connects two distinct nodes and has an associated weight. Find the maximum weighted edge in any path between two given nodes, \`u\` and \`v\`. If there is no path, return -1. >>> maximum_weighted_edge_in_path(5, 6, [(1, 2, 3), (1, 3, 4), (2, 4, 8), (3, 4, 7), (4, 5, 2), (3, 5, 1)], 1, 5) 7 >>> maximum_weighted_edge_in_path(4, 2, [(1, 2, 1), (3, 4, 1)], 1, 3) -1 >>> maximum_weighted_edge_in_path(2, 1, [(1, 2, 5)], 1, 2) 5 >>> maximum_weighted_edge_in_path(5, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 10), (4, 5, 3), (1, 5, 8)], 1, 5) 8 >>> maximum_weighted_edge_in_path(4, 3, [(1, 2, 7), (2, 3, 7), (3, 4, 2)], 1, 3) 7 pass","solution":"import heapq def maximum_weighted_edge_in_path(n, m, edges, u, v): graph = {i: [] for i in range(1, n+1)} for a, b, w in edges: graph[a].append((w, b)) graph[b].append((w, a)) def dijkstra_max_edge(start, end): max_edge = {i: float('-inf') for i in range(1, n+1)} max_edge[start] = 0 pq = [(-max_edge[start], start)] visited = set() while pq: current_max_weight, node = heapq.heappop(pq) current_max_weight *= -1 if node in visited: continue visited.add(node) for weight, neighbor in graph[node]: if neighbor not in visited: new_max_edge = max(current_max_weight, weight) if new_max_edge > max_edge[neighbor]: max_edge[neighbor] = new_max_edge heapq.heappush(pq, (-new_max_edge, neighbor)) return max_edge[end] if max_edge[end] != float('-inf') else -1 return dijkstra_max_edge(u, v)"},{"question":"import sys from typing import List def find_max(arr: List[int]) -> int: Returns the maximum possible value within an array where the absolute difference between any two consecutive elements is 1. >>> find_max([2, 1, 0, 1, 2, 3, 4]) == 4 >>> find_max([20, 21, 20, 19, 20, 21, 22]) == 22 >>> find_max([5]) == 5 >>> find_max([-3, -2, -1, 0, 1, 2, 1, 0]) == 2 >>> find_max([-1000000000, -999999999, -1000000000, -999999999]) == -999999999 >>> find_max([1000000000, 999999999, 1000000000, 999999999]) == 1000000000","solution":"def find_max(arr): Returns the maximum value in the given array. return max(arr)"},{"question":"def max_path_sum(matrix: List[List[int]], m: int, n: int) -> int: Given a matrix of dimensions m x n filled with non-negative integers, find the maximum path sum starting from any cell in the first row to any cell in the last row. The allowed moves are down, down-left, and down-right. :param matrix: list of list of non-negative integers :param m: int, number of rows :param n: int, number of columns :return: int, maximum path sum >>> max_path_sum([[6, 7, 8], [5, 3, 1], [4, 6, 1]], 3, 3) 18 >>> max_path_sum([[5]], 1, 1) 5 >>> max_path_sum([[3], [4], [5]], 3, 1) 12 >>> max_path_sum([[3, 4, 5, 6], [2, 1, 7, 8], [9, 10, 11, 12], [6, 14, 15, 16]], 4, 4) 42 >>> max_path_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 3, 3) 0 pass # Implement the function here","solution":"def max_path_sum(matrix, m, n): Given a matrix of dimensions m x n filled with non-negative integers, find the maximum path sum starting from any cell in the first row to any cell in the last row. The allowed moves are down, down-left, and down-right. :param matrix: list of list of non-negative integers :param m: int, number of rows :param n: int, number of columns :return: int, maximum path sum # Initialize a DP table with the same dimensions as the matrix dp = [[0] * n for _ in range(m)] # Initialize the first row of the DP table with the values of the first row of the matrix for j in range(n): dp[0][j] = matrix[0][j] # Fill the DP table from the second row to the last row for i in range(1, m): for j in range(n): if j > 0 and j < n - 1: dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) elif j > 0: dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i-1][j-1]) elif j < n - 1: dp[i][j] = matrix[i][j] + max(dp[i-1][j], dp[i-1][j+1]) else: dp[i][j] = matrix[i][j] + dp[i-1][j] # The result will be the maximum value in the last row of DP table return max(dp[m-1])"},{"question":"def longest_max_bitwise_and_subarray(arr: List[int]) -> int: Find the length of the longest subarray which has the maximum bitwise AND value among all possible subarrays. >>> longest_max_bitwise_and_subarray([4, 3, 1, 2, 2, 4]) 1 >>> longest_max_bitwise_and_subarray([7, 7, 7, 4, 4]) 3","solution":"def longest_max_bitwise_and_subarray(arr): This function finds the length of the longest subarray which has the maximum bitwise AND value among all possible subarrays. Params: arr: A list of integers. Returns: An integer representing the length of the longest subarray with the maximum bitwise AND value. max_bitwise_and_value = max(arr) longest_len = 0 current_len = 0 for num in arr: if num == max_bitwise_and_value: current_len += 1 if current_len > longest_len: longest_len = current_len else: current_len = 0 return longest_len"},{"question":"from typing import List def max_intersections_covered(n: int, m: int, B: int, roads: List[List[int]]) -> int: Determine the maximum number of intersections that can be monitored by installing cameras on a subset of the roads such that the total installation cost does not exceed B. Args: n (int): The number of intersections. m (int): The number of roads. B (int): The budget. roads (List[List[int]]): The roads, where each sub-list contains three integers u, v, and c representing the intersections connected by the road and the installation cost respectively. Returns: int: The maximum number of intersections that can be monitored. # Example usage # n = 4, m = 5, B = 10 # roads = [[1, 2, 3], [1, 3, 2], [2, 3, 1], [3, 4, 4], [2, 4, 6]] # Should output 4 as we can cover all intersections with the selected roads.","solution":"def max_intersections_covered(n, m, B, roads): Returns the maximum number of intersections that can be monitored within the budget. # Sort the roads based on their cost roads.sort(key=lambda x: x[2]) parent = list(range(n)) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: parent[root_v] = root_u total_cost = 0 max_intersections = 0 for u, v, cost in roads: if total_cost + cost <= B: if find(u - 1) != find(v - 1): union(u - 1, v - 1) total_cost += cost max_intersections += 2 return min(max_intersections, n) # Example usage # n = 4, m = 5, B = 10 # roads = [[1, 2, 3], [1, 3, 2], [2, 3, 1], [3, 4, 4], [2, 4, 6]] # Should output 4 as we can cover all intersections with the selected roads."},{"question":"from typing import List def max_processed_items(capacities: List[int], workload: int) -> int: Determine the maximum number of items that can be processed per minute. Args: capacities (List[int]): A list of integers representing the capacities of each assembly point. workload (int): The total number of items that need processing per minute. Returns: int: The maximum number of items that can be processed without exceeding any assembly point's capacity. >>> max_processed_items([10, 20, 30], 25) 25 >>> max_processed_items([5, 10, 15], 18) 18 >>> max_processed_items([10, 10, 10], 50) 30","solution":"from typing import List def max_processed_items(capacities: List[int], workload: int) -> int: Determine the maximum number of items that can be processed per minute. Args: capacities (List[int]): A list of integers representing the capacities of each assembly point. workload (int): The total number of items that need processing per minute. Returns: int: The maximum number of items that can be processed without exceeding any assembly point's capacity. total_capacity = sum(capacities) # If workload is less than or equal to total capacity, # we need to distribute the exact workload across the capacities. if workload <= total_capacity: return workload # If workload exceeds total capacity, max items processed is the total capacity itself. return total_capacity"},{"question":"def min_removals_to_avoid_triplets(s: str) -> int: Determine the minimum number of characters to remove from the string to ensure no three consecutive characters are identical. >>> min_removals_to_avoid_triplets(\\"aaabbb\\") 2 >>> min_removals_to_avoid_triplets(\\"abcde\\") 0","solution":"def min_removals_to_avoid_triplets(s): Returns the minimum number of characters to remove from the string to ensure no three consecutive characters are identical. if len(s) < 3: return 0 removals = 0 i = 0 while i < len(s) - 2: if s[i] == s[i + 1] == s[i + 2]: removals += 1 i += 2 else: i += 1 return removals"},{"question":"def reverse_to_lexicographically_smallest_array(n: int, arr: List[int], leftIndex: int, rightIndex: int) -> List[int]: Perform exactly one reverse operation to achieve the lexicographically smallest array possible. Parameters: n : int The number of elements in the array. arr : list of int The elements of the array. leftIndex : int The starting index of the subarray to reverse (1-based index). rightIndex : int The ending index of the subarray to reverse (1-based index). Returns: list of int The lexicographically smallest array possible after the reverse operation. Examples: >>> reverse_to_lexicographically_smallest_array(5, [4, 2, 3, 1, 5], 2, 4) [4, 1, 3, 2, 5] >>> reverse_to_lexicographically_smallest_array(3, [3, 2, 1], 1, 3) [1, 2, 3]","solution":"def reverse_to_lexicographically_smallest_array(n, arr, leftIndex, rightIndex): Returns the lexicographically smallest array possible by reversing a subarray exactly once. Parameters: n : int The number of elements in the array. arr : list of int The elements of the array. leftIndex : int The starting index of the subarray to reverse. rightIndex : int The ending index of the subarray to reverse. Returns: list of int The lexicographically smallest array possible. # Adjust indices for 0-based indexing leftIndex -= 1 rightIndex -= 1 # Reverse the subarray arr[leftIndex:rightIndex + 1] = arr[leftIndex:rightIndex + 1][::-1] return arr"},{"question":"from typing import List def length_of_shortest_contiguous_substring(n: int, m: int, beads: List[int]) -> int: Returns the length of the shortest contiguous substring that contains at least one bead of every color. Args: n (int): Number of beads. m (int): Number of different colors. beads (List[int]): List of beads colors. Returns: int: Length of the shortest contiguous substring that contains at least one bead of every color. Examples: >>> length_of_shortest_contiguous_substring(7, 3, [1, 2, 1, 3, 2, 1, 3]) 3 >>> length_of_shortest_contiguous_substring(5, 2, [1, 2, 1, 2, 1]) 2 pass # Function implementation goes here def test_shortest_contiguous_substring_cases(): assert length_of_shortest_contiguous_substring(7, 3, [1, 2, 1, 3, 2, 1, 3]) == 3 assert length_of_shortest_contiguous_substring(5, 2, [1, 2, 1, 2, 1]) == 2 assert length_of_shortest_contiguous_substring(7, 3, [1, 2, 3, 1, 2, 3, 1]) == 3 assert length_of_shortest_contiguous_substring(6, 3, [1, 1, 1, 1, 1, 1]) == float('inf') assert length_of_shortest_contiguous_substring(5, 4, [1, 2, 3, 3, 1]) == float('inf') def test_edge_cases(): assert length_of_shortest_contiguous_substring(1, 1, [1]) == 1 assert length_of_shortest_contiguous_substring(5, 1, [1, 1, 1, 1, 1]) == 1 assert length_of_shortest_contiguous_substring(5, 2, [1, 1, 1, 1, 2]) == 2","solution":"def length_of_shortest_contiguous_substring(n, m, beads): Returns the length of the shortest contiguous substring that contains at least one bead of every color. from collections import defaultdict color_count = defaultdict(int) num_unique_colors = 0 min_length = float('inf') left = 0 for right in range(n): color_right = beads[right] if color_count[color_right] == 0: num_unique_colors += 1 color_count[color_right] += 1 while num_unique_colors == m: min_length = min(min_length, right - left + 1) color_left = beads[left] color_count[color_left] -= 1 if color_count[color_left] == 0: num_unique_colors -= 1 left += 1 return min_length"},{"question":"def interleave_strings(s: str, t: str) -> str: Interleaves two strings \`s\` and \`t\`. If one string is longer, the remaining characters of the longer string are appended to the end of the new string. >>> interleave_strings(\\"abc\\", \\"def\\") \\"adbecf\\" >>> interleave_strings(\\"ab\\", \\"xyz\\") \\"axbyz\\" >>> interleave_strings(\\"abcd\\", \\"pq\\") \\"apbqcd\\"","solution":"def interleave_strings(s: str, t: str) -> str: Interleaves two strings s and t. If one string is longer, the remaining characters of the longer string are appended to the end of the new string. result = [] length_s, length_t = len(s), len(t) min_length = min(length_s, length_t) # Interleave common length for i in range(min_length): result.append(s[i]) result.append(t[i]) # Append remaining characters from the longer string if length_s > length_t: result.append(s[min_length:]) else: result.append(t[min_length:]) return ''.join(result)"},{"question":"def min_operations_to_water_plants(n: int, intervals: List[Tuple[int, int]]) -> int: Determines the minimum number of water pump operations needed to water all plants. Parameters: n (int): number of plants intervals (list of tuples): each tuple contains the start and end time for watering a plant Returns: int: minimum number of operations needed >>> min_operations_to_water_plants(3, [(1, 3), (2, 5), (4, 6)]) 2 >>> min_operations_to_water_plants(0, []) 0 >>> min_operations_to_water_plants(1, [(1, 5)]) 1 >>> min_operations_to_water_plants(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> min_operations_to_water_plants(3, [(1, 5), (1, 5), (1, 5)]) 1 >>> min_operations_to_water_plants(4, [(1, 4), (2, 3), (3, 5), (6, 7)]) 2 >>> min_operations_to_water_plants(3, [(1, 10), (2, 9), (3, 8)]) 1","solution":"def min_operations_to_water_plants(n, intervals): Determines the minimum number of water pump operations needed to water all plants. Parameters: n (int): number of plants intervals (list of tuples): each tuple contains the start and end time for watering a plant Returns: int: minimum number of operations needed if n == 0: return 0 # Sort intervals by end time intervals.sort(key=lambda x: x[1]) operations = 0 last_end_time = -1 for start, end in intervals: if start > last_end_time: # We need a new operation if the current interval starts after the last used end time operations += 1 last_end_time = end return operations"},{"question":"def compute_prefix_sums(arr): Compute prefix sums for the given array. # Your code here def range_sum(prefix_sums, l, r): Compute the sum of the array elements between indices l and r (1-based) using prefix sums. # Your code here def process_queries(n, q, arr, queries): Process multiple range sum queries on the array. # Your code here # Example: # n = 5 # q = 3 # arr = [1, 2, 3, 4, 5] # queries = [(1, 3), (2, 5), (1, 5)] # expected_results = [6, 14, 15]","solution":"def compute_prefix_sums(arr): Compute prefix sums for the given array. prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i-1] + arr[i-1] return prefix_sums def range_sum(prefix_sums, l, r): Compute the sum of the array elements between indices l and r (1-based) using prefix sums. return prefix_sums[r] - prefix_sums[l-1] def process_queries(n, q, arr, queries): Process multiple range sum queries on the array. prefix_sums = compute_prefix_sums(arr) results = [] for l, r in queries: results.append(range_sum(prefix_sums, l, r)) return results"},{"question":"from typing import List, Dict def list_employees_by_department(employees: List[str], department: str) -> List[str]: Returns a list of employee records in the specified department. >>> employees = [\\"1,John,Doe,Engineering,60000\\",\\"2,Jane,Smith,Marketing,55000\\",\\"3,Emily,Jones,Engineering,65000\\",\\"4,Michael,Brown,HR,50000\\"] >>> list_employees_by_department(employees, \\"Engineering\\") ['1,John,Doe,Engineering,60000', '3,Emily,Jones,Engineering,65000'] def calculate_average_salary_by_department(employees: List[str]) -> Dict[str, float]: Calculates and returns the average salary for each department. >>> employees = [\\"1,John,Doe,Engineering,60000\\",\\"2,Jane,Smith,Marketing,55000\\",\\"3,Emily,Jones,Engineering,65000\\",\\"4,Michael,Brown,HR,50000\\"] >>> calculate_average_salary_by_department(employees) {'Engineering': 62500.0, 'Marketing': 55000.0, 'HR': 50000.0} def find_employee_by_id(employees: List[str], employee_id: str) -> str: Finds and returns the details of the employee with the specified employee ID. >>> employees = [\\"1,John,Doe,Engineering,60000\\",\\"2,Jane,Smith,Marketing,55000\\",\\"3,Emily,Jones,Engineering,65000\\",\\"4,Michael,Brown,HR,50000\\"] >>> find_employee_by_id(employees, \\"2\\") '2,Jane,Smith,Marketing,55000'","solution":"from typing import List, Dict def list_employees_by_department(employees: List[str], department: str) -> List[str]: Returns a list of employee records in the specified department. return [employee for employee in employees if employee.split(',')[3] == department] def calculate_average_salary_by_department(employees: List[str]) -> Dict[str, float]: Calculates and returns the average salary for each department. department_salaries = {} department_counts = {} for employee in employees: parts = employee.split(',') department = parts[3] salary = float(parts[4]) if department not in department_salaries: department_salaries[department] = 0 department_counts[department] = 0 department_salaries[department] += salary department_counts[department] += 1 average_salaries = {dept: department_salaries[dept] / department_counts[dept] for dept in department_salaries} return average_salaries def find_employee_by_id(employees: List[str], employee_id: str) -> str: Finds and returns the details of the employee with the specified employee ID. for employee in employees: if employee.split(',')[0] == employee_id: return employee return \\"\\""},{"question":"def min_number_of_groups(n: int, d: int, heights: List[int]) -> int: Determines the minimum number of groups required such that the difference in height between the tallest and shortest student in each group does not exceed d. >>> min_number_of_groups(6, 5, [1, 2, 3, 10, 11, 12]) 2 >>> min_number_of_groups(1, 5, [10]) 1 >>> min_number_of_groups(5, 10, [1, 2, 3, 4, 5]) 1 >>> min_number_of_groups(5, 2, [1, 4, 7, 10, 13]) 5 >>> min_number_of_groups(5, 100, [1, 15, 30, 45, 60]) 1 >>> min_number_of_groups(4, 5, [2, 2, 2, 2]) 1","solution":"def min_number_of_groups(n, d, heights): Determines the minimum number of groups required such that the difference in height between the tallest and shortest student in each group does not exceed d. heights.sort() num_groups = 0 i = 0 while i < n: num_groups += 1 current_group_min = heights[i] while i < n and heights[i] - current_group_min <= d: i += 1 return num_groups"},{"question":"def hasPathSum(tree: List[int], targetSum: int) -> bool: Determine if there exists a path in a binary tree such that the sum of the values along the path is equal to a given target sum. >>> hasPathSum([5, 4, 8, 11, -1, 13, 4, 7, 2, -1, -1, -1, 1], 22) True >>> hasPathSum([1, 2, 3], 5) False >>> hasPathSum([1, 2], 3) True >>> hasPathSum([-2, -3], -5) True >>> hasPathSum([], 0) False","solution":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(tree: List[int]) -> Optional[TreeNode]: if not tree or tree[0] == -1: return None root = TreeNode(tree[0]) nodes = [root] child_index = 1 for node in nodes: if node: if child_index < len(tree) and tree[child_index] != -1: node.left = TreeNode(tree[child_index]) nodes.append(node.left) child_index += 1 if child_index < len(tree) and tree[child_index] != -1: node.right = TreeNode(tree[child_index]) nodes.append(node.right) child_index += 1 return root def hasPathSum(tree: List[int], targetSum: int) -> bool: root = build_tree(tree) def dfs(node, current_sum): if node is None: return False current_sum += node.val if node.left is None and node.right is None: return current_sum == targetSum return dfs(node.left, current_sum) or dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"def has_pair_with_sum(arr, target): Returns \\"YES\\" if there exist two distinct indices i and j in the array such that the sum of the elements at these indices is equal to the target value, otherwise \\"NO\\". >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 8) \\"NO\\"","solution":"def has_pair_with_sum(arr, target): Returns \\"YES\\" if there exist two distinct indices i and j in the array such that the sum of the elements at these indices is equal to the target value, otherwise \\"NO\\". seen = set() for num in arr: complement = target - num if complement in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"from typing import List, Tuple def range_bitwise_and(li: int, ri: int) -> int: This function returns the bitwise AND of all integers in the range [li, ri]. pass def solve(queries: List[Tuple[int, int]]) -> List[int]: This function processes multiple queries and returns a list of results for each query. Queries are in the form of tuples containing the (li, ri) range. pass # Here are some tests you can use to verify your solutions def test_range_bitwise_and(): assert range_bitwise_and(5, 7) == 4 assert range_bitwise_and(10, 15) == 8 assert range_bitwise_and(2, 8) == 0 assert range_bitwise_and(1, 1) == 1 assert range_bitwise_and(0, 0) == 0 def test_solve(): queries = [(5, 7), (10, 15), (2, 8)] assert solve(queries) == [4, 8, 0] queries = [(0, 1), (1, 2)] assert solve(queries) == [0, 0] queries = [(1, 1), (3, 3)] assert solve(queries) == [1, 3] def test_large_range(): queries = [(1, 1000000000)] assert solve(queries) == [0] queries = [(1000000000, 1000000000)] assert solve(queries) == [1000000000]","solution":"def range_bitwise_and(li, ri): This function returns the bitwise AND of all integers in the range [li, ri]. shift = 0 while li < ri: li >>= 1 ri >>= 1 shift += 1 return li << shift def solve(queries): results = [] for li, ri in queries: results.append(range_bitwise_and(li, ri)) return results"},{"question":"def longest_divisible_subsequence(arr): Find the length of the longest divisible subsequence in a list of integers. Args: arr (List[int]): List of integers to consider. Returns: int: Length of the longest divisible subsequence. Examples: >>> longest_divisible_subsequence([3, 6, 7, 12, 24, 36]) 4 >>> longest_divisible_subsequence([7, 11, 13]) 1 >>> longest_divisible_subsequence([10]) 1 >>> longest_divisible_subsequence([1, 2, 4, 8, 16]) 5 >>> longest_divisible_subsequence([1000000, 500000, 250000, 125000]) 4 >>> longest_divisible_subsequence([2, 3, 5, 10, 20]) 3 >>> longest_divisible_subsequence([36, 24, 12, 6, 3]) 4","solution":"def longest_divisible_subsequence(arr): n = len(arr) if n == 0: return 0 # Sort the array arr.sort() # dp[i] will store the length of the longest divisible subsequence ending with arr[i] dp = [1] * n # Compute the lengths of LDS for i in range(1, n): for j in range(i): if arr[i] % arr[j] == 0: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest divisible subsequence return max(dp)"},{"question":"def rotate_image(matrix): Rotate the given n x n matrix by 90 degrees clockwise in-place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...] >>> rotate_image(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4] ...] >>> rotate_image(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [[1]] >>> rotate_image(matrix) >>> matrix [[1]] >>> matrix = [] >>> rotate_image(matrix) >>> matrix []","solution":"def rotate_image(matrix): Rotate the given n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix. for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row. for i in range(n): matrix[i].reverse()"},{"question":"from typing import List def find_pair(nums: List[int], target: int) -> bool: Checks if there are two distinct indices in the list such that their sum equals the target. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: bool: True if a pair is found, False otherwise. Examples: >>> find_pair([2, 7, 11, 15], 9) True >>> find_pair([1, 2, 3, 4, 5], 10) False","solution":"from typing import List def find_pair(nums: List[int], target: int) -> bool: Checks if there are two distinct indices in the list such that their sum equals the target. seen_numbers = {} for num in nums: complement = target - num if complement in seen_numbers: return True seen_numbers[num] = True return False"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcd\\") == 4 >>> length_of_longest_substring(\\"abba\\") == 2 >>> length_of_longest_substring(\\"abc abc\\") == 4 >>> length_of_longest_substring(\\"aaaa\\") == 1 >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"pwwkew\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. # Create a set to store the unique characters in the current window char_set = set() left = 0 max_length = 0 # Iterate over the characters in the string with a sliding window approach for right in range(len(s)): # If character is already in the set, remove from the left until it's unique while s[right] in char_set: char_set.remove(s[left]) left += 1 # Add the current character to the set char_set.add(s[right]) # Update the maximum length of the substring max_length = max(max_length, right - left + 1) return max_length"},{"question":"import itertools def tsp(graph, n): Solves the Traveling Salesman Problem for a given undirected graph. Parameters: graph : list -> The adjacency matrix representation of the graph with weights as travel times. n : int -> The number of nodes in the graph. Returns: int -> The minimum possible travel time needed to start from any spot, visit all other spots exactly once, and return to the starting spot. pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index += 1 m = int(data[index]) index += 1 graph = [[float('inf')]*n for _ in range(n)] for _ in range(m): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 w = int(data[index + 2]) index += 3 graph[u][v] = w graph[v][u] = w print(tsp(graph, n))","solution":"import itertools def tsp(graph, n): Solves the Traveling Salesman Problem for a given undirected graph. Parameters: graph : dict -> The adjacency matrix representation of the graph with weights as travel times. n : int -> The number of nodes in the graph. Returns: int -> The minimum possible travel time needed to start from any spot, visit all other spots exactly once, and return to the starting spot. vertices = list(range(n)) min_path = float('inf') for perm in itertools.permutations(vertices[1:]): # Generate all permutations except the starting node current_path_weight = 0 # Starting node k = 0 # Add distance from the starting node to the first node in the permutation for i in perm: current_path_weight += graph[k][i] k = i # Add distance to return to the starting node current_path_weight += graph[k][0] # Update minimum path weight min_path = min(min_path, current_path_weight) return min_path def read_input(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index +=1 m = int(data[index]) index +=1 graph = [[float('inf')]*n for _ in range(n)] for _ in range(m): u = int(data[index]) - 1 v = int(data[index + 1]) - 1 w = int(data[index + 2]) index += 3 graph[u][v] = w graph[v][u] = w return graph, n def main(): graph, n = read_input() print(tsp(graph, n)) if __name__ == \\"__main__\\": main()"},{"question":"def largest_rectangle(grid: List[List[str]]) -> int: Determine the area of the largest rectangle that can be formed where all the tiles are of the same color. The grid is represented as a 2D list of lowercase English letters, with each letter representing a color. >>> largest_rectangle([ ['a', 'a', 'a', 'b', 'b'], ['a', 'a', 'a', 'b', 'b'], ['a', 'a', 'a', 'b', 'b'], ['a', 'a', 'a', 'a', 'a'] ]) 12 >>> largest_rectangle([ ['a', 'a'], ['a', 'a'] ]) 4 >>> largest_rectangle([ ['a', 'b'], ['b', 'a'] ]) 1 >>> largest_rectangle([ ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'], ['a', 'a', 'a', 'a'] ]) 16","solution":"def largest_rectangle(grid): m, n = len(grid), len(grid[0]) max_area = 0 def get_heights(grid, color): heights = [0] * n for row in grid: for j in range(n): if row[j] == color: heights[j] += 1 else: heights[j] = 0 return heights def largest_histogram_area(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) heights.pop() # remove the appended 0 return max_area unique_colors = set() for row in grid: unique_colors.update(row) for color in unique_colors: heights = get_heights(grid, color) max_area = max(max_area, largest_histogram_area(heights)) return max_area"},{"question":"from typing import List def top_k_frequent(words: List[str], k: int) -> List[str]: Returns the k most frequent words from the input list \`words\`. If multiple words have the same frequency, they are sorted in lexicographical order. >>> top_k_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"orange\\", \\"apple\\"], 2) [\\"apple\\", \\"banana\\"] >>> top_k_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"orange\\"], 2) [\\"apple\\", \\"banana\\"] >>> top_k_frequent([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"orange\\", \\"grape\\"], 2) [\\"apple\\", \\"banana\\"] >>> top_k_frequent([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], 2) [\\"apple\\", \\"banana\\"] >>> top_k_frequent([\\"apple\\", \\"apple\\", \\"apple\\"], 1) [\\"apple\\"] >>> top_k_frequent([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"a\\", \\"b\\", \\"a\\", \\"b\\"], 3) [\\"a\\", \\"b\\", \\"c\\"]","solution":"from collections import Counter def top_k_frequent(words, k): Returns the k most frequent words from the input list \`words\`. If multiple words have the same frequency, they are sorted in lexicographical order. # Count the frequency of each word count = Counter(words) # Sort words first by frequency (in descending order), then lexicographically (in ascending order) sorted_words = sorted(count.keys(), key=lambda word: (-count[word], word)) # Return the top k elements from the sorted list return sorted_words[:k]"},{"question":"def correct_profile_id(profiles: List[str]) -> List[str]: Convert profiles to lowercase and remove any digits. >>> correct_profile_id([\\"AbC123\\", \\"jOHndoE5\\", \\"m@rk7\\", \\"eXaMple\\"]) # => [\\"abc\\", \\"johndoe\\", \\"mrk\\", \\"example\\"] >>> correct_profile_id([\\"ABC\\", \\"xyz\\", \\"lower123\\"]) # => [\\"abc\\", \\"xyz\\", \\"lower\\"]","solution":"def correct_profile_id(profiles): corrected_profiles = [] for profile in profiles: corrected_profile = ''.join([char for char in profile if char.isalpha()]).lower() corrected_profiles.append(corrected_profile) return corrected_profiles"},{"question":"def can_rearrange_flowers(n: int, flowers: List[int]) -> str: Determine if it is possible to rearrange the flowers such that no two adjacent slots contain the same type of flower. >>> can_rearrange_flowers(6, [1, 1, 1, 2, 2, 2]) 'YES' >>> can_rearrange_flowers(4, [1, 1, 1, 1]) 'NO'","solution":"def can_rearrange_flowers(n, flowers): from collections import Counter flower_counts = Counter(flowers) max_count = max(flower_counts.values()) # The condition to check is if the most frequent flower type is more than half of (n + 1) if max_count <= (n + 1) // 2: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Union, Tuple def find_min_abs_diff_pair(arr: List[int]) -> Union[Tuple[int, int], int]: Returns two indices i, j such that arr[i] != arr[j] and the absolute difference between arr[i] and arr[j] is minimized. If no such pair exists, return -1. >>> find_min_abs_diff_pair([8, 1, 13, 10]) (0, 3) >>> find_min_abs_diff_pair([3, 3, 3]) -1","solution":"def find_min_abs_diff_pair(arr): Returns two indices i, j such that arr[i] != arr[j] and the absolute difference between arr[i] and arr[j] is minimized. If no such pair exists, return -1. n = len(arr) if n < 2: return -1 index_arr = [(value, idx) for idx, value in enumerate(arr)] index_arr.sort() min_diff = float('inf') result_pair = (-1, -1) for i in range(n - 1): if index_arr[i][0] != index_arr[i + 1][0]: diff = abs(index_arr[i + 1][0] - index_arr[i][0]) if diff < min_diff: min_diff = diff result_pair = (index_arr[i][1], index_arr[i + 1][1]) if result_pair == (-1, -1): return -1 else: return result_pair # Example usage: # n = 4 # arr = [8, 1, 13, 10] # print(find_min_abs_diff_pair(arr)) # Output: (0, 3)"},{"question":"def can_transform_to_anagram(s1: str, s2: str) -> str: Determines if two strings can be made into anagrams by removing zero or more characters from each. >>> can_transform_to_anagram(\\"aacdb\\", \\"cabd\\") \\"YES\\" >>> can_transform_to_anagram(\\"abcdef\\", \\"fedcba\\") \\"YES\\" >>> can_transform_to_anagram(\\"abc\\", \\"def\\") \\"NO\\" >>> can_transform_to_anagram(\\"abc\\", \\"abc\\") \\"YES\\" >>> can_transform_to_anagram(\\"abc\\", \\"def\\") \\"NO\\" >>> can_transform_to_anagram(\\"abccba\\", \\"abcabc\\") \\"YES\\" >>> can_transform_to_anagram(\\"aabbcc\\", \\"bbccdd\\") \\"YES\\" >>> can_transform_to_anagram(\\"\\", \\"\\") \\"NO\\" >>> can_transform_to_anagram(\\"a\\", \\"a\\") \\"YES\\" >>> can_transform_to_anagram(\\"\\", \\"a\\") \\"NO\\" >>> can_transform_to_anagram(\\"a\\", \\"\\") \\"NO\\"","solution":"def can_transform_to_anagram(s1, s2): Determines if two strings can be made into anagrams by removing zero or more characters from each. from collections import Counter # Get the frequency of each character in both strings counter1 = Counter(s1) counter2 = Counter(s2) # Find the common characters in both strings common = counter1 & counter2 # If there are common characters, then these can potentially make the strings anagrams if common: return \\"YES\\" else: return \\"NO\\""},{"question":"def sum_of_max_values(grid): Given a 2D list \`grid\` representing n x n grid of integers, this function returns the sum of the maximum values in each row that contains only non-negative integers. Example: >>> sum_of_max_values([[1, 2, 3], [-1, 5, 6], [7, 8, 0]]) 11 >>> sum_of_max_values([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 18 >>> sum_of_max_values([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) 0 >>> sum_of_max_values([[1, 2, 3], [4, -5, 6], [7, 8, 9], [-1, -2, -3]]) 12 >>> sum_of_max_values([[0, 0, 0], [10, 20, 30], [5, 5, 5]]) 35 >>> sum_of_max_values([[0], [1], [-1]]) 1 >>> sum_of_max_values([]) 0","solution":"def sum_of_max_values(grid): Given a 2D list \`grid\` representing n x n grid of integers, this function returns the sum of the maximum values in each row that contains only non-negative integers. total_sum = 0 for row in grid: if all(x >= 0 for x in row): total_sum += max(row) return total_sum"},{"question":"def max_necklaces(n: int, beads: List[int]) -> int: Determine the maximum number of necklaces with even sum values. Args: n (int): number of beads beads (List[int]): list of bead values Returns: int: maximum number of necklaces Examples: >>> max_necklaces(6, [2, 4, 6, 3, 1, 5]) 4 >>> max_necklaces(4, [2, 4, 6, 8]) 4 >>> max_necklaces(5, [1, 3, 5, 7, 9]) 2 >>> max_necklaces(5, [2, 3, 4, 5, 6]) 4 >>> max_necklaces(1, [7]) 0 >>> max_necklaces(0, []) 0 >>> max_necklaces(4, [0, 0, 0, 0]) 4","solution":"def max_necklaces(n, beads): even_count = sum(b % 2 == 0 for b in beads) odd_count = n - even_count return even_count + odd_count // 2"},{"question":"from collections import deque def shortest_path(n: int, m: int, grid: List[str], sx: int, sy: int, tx: int, ty: int) -> int: Find the shortest path between two given empty cells in the grid. If there is no path between the two cells, return -1. Args: n: int : number of rows in the grid m: int : number of columns in the grid grid: List[str] : a list of strings where '.' represents an empty cell and '#' represents an obstacle sx: int : starting cell row index (1-based) sy: int : starting cell column index (1-based) tx: int : target cell row index (1-based) ty: int : target cell column index (1-based) Returns: int : the shortest path from the starting cell to the target cell or -1 if it is impossible to reach the target. >>> grid1 = [\\".....\\", \\".#.\\", \\"...#.\\", \\".#.\\", \\".....\\"] >>> shortest_path(5, 5, grid1, 1, 1, 5, 5) 8 >>> grid2 = [\\".....\\", \\".#.\\", \\"...#.\\", \\".#.\\", \\".....\\"] >>> shortest_path(5, 5, grid2, 1, 1, 3, 1) 2 >>> grid3 = [\\".....\\", \\".#.\\", \\"...#.\\", \\".#.\\", \\".....\\"] >>> shortest_path(5, 5, grid3, 1, 1, 1, 1) 0 >>> grid4 = [\\".....\\", \\".#.\\", \\"...#.\\", \\".#.\\", \\".....\\"] >>> shortest_path(5, 5, grid4, 1, 1, 2, 2) -1 >>> grid5 = [\\"#\\", \\"#\\", \\"#\\", \\"#\\", \\"#\\"] >>> shortest_path(5, 5, grid5, 1, 1, 5, 5) -1","solution":"from collections import deque def shortest_path(n, m, grid, sx, sy, tx, ty): sx -= 1 sy -= 1 tx -= 1 ty -= 1 if grid[sx][sy] == '#' or grid[tx][ty] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sx, sy, 0)]) visited = set() visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (tx, ty): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings in the given string s. >>> count_distinct_substrings(\\"abc\\") # 6 distinct substrings: \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\" 6 >>> count_distinct_substrings(\\"aaa\\") # 3 distinct substrings: \\"a\\", \\"aa\\", \\"aaa\\" 3 def process_test_cases(test_cases: List[str]) -> List[int]: Process a list of test cases and return the number of distinct substrings for each string. >>> process_test_cases([\\"abc\\", \\"aaa\\", \\"abab\\"]) [6, 3, 7] >>> process_test_cases([\\"a\\", \\"abcd\\", \\"zzzz\\"]) [1, 10, 4]","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings in the given string s. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) def process_test_cases(test_cases): results = [] for s in test_cases: results.append(count_distinct_substrings(s)) return results"},{"question":"def longest_stack_sequence(weights): Returns the length of the longest possible sequence of containers that can be stacked such that each container is heavier than the one below it. :param weights: List of container weights. :return: Length of the longest stackable sequence of containers. >>> longest_stack_sequence([3, 1, 4, 1, 5, 9, 2, 6, 5]) 4 >>> longest_stack_sequence([10, 20, 10, 30, 10, 40]) 4 >>> longest_stack_sequence([5]) 1 >>> longest_stack_sequence([9, 7, 5, 3, 1]) 1 >>> longest_stack_sequence([1, 2, 3, 4, 5]) 5 >>> longest_stack_sequence([1, 1, 1, 1, 1]) 1 >>> longest_stack_sequence([10, 11, 7, 12, 6, 15, 9, 8, 16]) 5 # Write your code here","solution":"def longest_stack_sequence(weights): Returns the length of the longest possible sequence of containers that can be stacked such that each container is heavier than the one below it. :param weights: List of container weights. :return: Length of the longest stackable sequence of containers. n = len(weights) dp = [1] * n # Initialize DP array where each sequence length is at least 1 for i in range(1, n): for j in range(0, i): if weights[i] > weights[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage # weights = [3, 1, 4, 1, 5, 9, 2, 6, 5] # print(longest_stack_sequence(weights)) # Output: 4 # weights = [10, 20, 10, 30, 10, 40] # print(longest_stack_sequence(weights)) # Output: 4"},{"question":"def is_substring_of_rotated(s1: str, s2: str) -> bool: Check if s2 is a substring of any rotated version of s1. >>> is_substring_of_rotated(\\"akash\\", \\"shak\\") True >>> is_substring_of_rotated(\\"foobar\\", \\"barfoo\\") True >>> is_substring_of_rotated(\\"hello\\", \\"world\\") False","solution":"def is_substring_of_rotated(s1: str, s2: str) -> bool: Check if s2 is a substring of any rotated version of s1. if len(s2) > len(s1): return False combined = s1 + s1 return s2 in combined"},{"question":"def maximize_shortest_tree(heights, k): Given a list of tree heights, and an integer k representing the number of trees we can cut down, this function maximizes the height of the shortest tree that remains after cutting down at most k trees. >>> maximize_shortest_tree([1, 3, 4, 7, 6, 5], 2) 4 >>> maximize_shortest_tree([5, 9, 12, 14, 15], 1) 9","solution":"def maximize_shortest_tree(heights, k): Given a list of tree heights, and an integer k representing the number of trees we can cut down, this function maximizes the height of the shortest tree that remains after cutting down at most k trees. def can_achieve(min_height): Helper function to check if we can achieve a scenario where the shortest remaining tree has a height of at least \`min_height\`. cut_count = 0 for height in heights: if height < min_height: cut_count += 1 if cut_count > k: return False return True low, high = min(heights), max(heights) while low < high: mid = (low + high + 1) // 2 if can_achieve(mid): low = mid else: high = mid - 1 return low"},{"question":"def load_packages(p: int, t: int, package_weights: List[int], truck_capacities: List[int]) -> Union[str, Tuple[str, List[int]]]: Determines if it is possible to load all packages into the trucks given their capacities without exceeding limits. Args: p (int): Number of packages. t (int): Number of trucks. package_weights (List[int]): Weights of the packages. truck_capacities (List[int]): Capacities of the trucks. Returns: Union[str, Tuple[str, List[int]]]: \\"NO\\" if it's impossible to load all packages, otherwise \\"YES\\" and a list of the number of packages each truck carries. Example: >>> load_packages(5, 3, [2, 3, 4, 5, 6], [10, 7, 8]) (\\"YES\\", [2, 2, 1]) >>> load_packages(5, 2, [2, 3, 4, 5, 6], [10, 7]) \\"NO\\"","solution":"def load_packages(p, t, package_weights, truck_capacities): Determines if it is possible to load all packages into the given trucks without exceeding any truck's capacity. Returns \\"YES\\" and the distribution of packages if it is possible, otherwise returns \\"NO\\". packages = package_weights capacities = truck_capacities truck_loads = [0] * t truck_counts = [0] * t current_truck = 0 for weight in packages: while current_truck < t and truck_loads[current_truck] + weight > capacities[current_truck]: current_truck += 1 if current_truck == t: return \\"NO\\" truck_loads[current_truck] += weight truck_counts[current_truck] += 1 return \\"YES\\", truck_counts"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[List[int]]) -> List[int]: Process the given queries on the array. Parameters: n (int): Number of elements in the array. q (int): Number of queries. array (list): Initial elements of the array. queries (list): List of queries where each query is a list [type, arg1, arg2]. Returns: list: Results of the sum queries. >>> process_queries(8, 5, [1, 2, 3, 4, 5, 6, 7, 8], [[2, 1, 4], [1, 5, 10], [2, 3, 6], [1, 8, 15], [2, 4, 8]]) [10, 23, 42] >>> process_queries(3, 2, [1, 2, 3], [[1, 2, 5], [2, 1, 3]]) [9] >>> process_queries(4, 4, [1, 1, 1, 1], [[1, 1, 10], [1, 4, 20], [2, 1, 4], [2, 3, 4]]) [32, 21] >>> process_queries(5, 1, [5, 4, 3, 2, 1], [[2, 2, 5]]) [10] >>> process_queries(1, 2, [1], [[2, 1, 1], [1, 1, 100]]) [1]","solution":"def process_queries(n, q, array, queries): Process the given queries on the array. Parameters: n (int): Number of elements in the array. q (int): Number of queries. array (list): Initial elements of the array. queries (list): List of queries where each query is a list [type, arg1, arg2]. Returns: list: Results of the sum queries. results = [] for query in queries: if query[0] == 1: # Update the element at a specific position (1-based index) i, x = query[1] - 1, query[2] array[i] = x elif query[0] == 2: # Find the sum of elements in a given subarray (1-based index) l, r = query[1] - 1, query[2] results.append(sum(array[l:r])) return results"},{"question":"def check_anagrams(clues_solutions): Check if the proposed solutions are anagrams of the corresponding clues. :param clues_solutions: List of tuples, each with a clue and its proposed anagram solution :return: List of boolean values indicating whether each proposed solution is an anagram of its corresponding clue Example: >>> check_anagrams([(\\"listen\\", \\"silent\\"), (\\"triangle\\", \\"integral\\"), (\\"apple\\", \\"pale\\")]) [True, True, False]","solution":"def check_anagrams(clues_solutions): Check if the proposed solutions are anagrams of the corresponding clues. :param clues_solutions: List of tuples, each with a clue and its proposed anagram solution :return: List of boolean values indicating whether each proposed solution is an anagram of its corresponding clue results = [] for clue, solution in clues_solutions: results.append(sorted(clue) == sorted(solution)) return results"},{"question":"def longest_segment_with_diff_one(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determine the length of the longest segment where the difference between consecutive elements is exactly 1 for each query subarray. >>> longest_segment_with_diff_one(5, 3, [4, 5, 6, 3, 2], [(1, 3), (2, 4), (3, 5)]) [3, 2, 2] >>> longest_segment_with_diff_one(5, 2, [1, 1, 1, 1, 1], [(1, 5), (2, 3)]) [1, 1] >>> longest_segment_with_diff_one(6, 2, [1, 2, 1, 2, 1, 2], [(1, 6), (2, 5)]) [6, 4] >>> longest_segment_with_diff_one(4, 1, [1, 3, 5, 7], [(1, 4)]) [1] >>> longest_segment_with_diff_one(10, 2, [1, 2, 3, 7, 8, 9, 1, 2, 3, 4], [(1, 6), (5, 10)]) [3, 4]","solution":"def longest_segment_with_diff_one(n, q, a, queries): # Parse the queries results = [] for l, r in queries: subarray = a[l-1:r] max_len = 0 current_len = 1 for i in range(1, len(subarray)): if abs(subarray[i] - subarray[i-1]) == 1: current_len += 1 else: max_len = max(max_len, current_len) current_len = 1 max_len = max(max_len, current_len) results.append(max_len) return results"},{"question":"def min_deletions_to_palindrome(S: str) -> int: Returns the minimum number of deletions required to make the given string a palindrome. >>> min_deletions_to_palindrome(\\"abdecba\\") # 2 >>> min_deletions_to_palindrome(\\"racecar\\") # 0","solution":"def min_deletions_to_palindrome(S): Returns the minimum number of deletions required to make the given string a palindrome. n = len(S) # Create a dp table to store the length of longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Fill in the dp table for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if S[i] == S[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) # The minimum number of deletions required to make the string a palindrome return n - dp[0][n-1]"},{"question":"def count_batches_due_today(days_left): This function takes a list of integers where each integer represents the number of days left until an equipment batch needs maintenance. It returns the number of batches that need to be checked today (i.e., their days remaining is 0). Parameters: - days_left (List[int]): A list of integers representing days left for maintenance. Returns: - int: The number of batches needing maintenance today. >>> count_batches_due_today([0, 1, 5, 0, 3, 0, 2]) 3 >>> count_batches_due_today([1, 2, 3, 4, 5]) 0 >>> count_batches_due_today([0, 0, 0, 0, 0]) 5 >>> count_batches_due_today([0]) 1 >>> count_batches_due_today([]) 0 >>> count_batches_due_today([10, 20, 30]) 0 >>> count_batches_due_today([0, -1, 0, -3, 0]) 3","solution":"def count_batches_due_today(days_left): This function takes a list of integers where each integer represents the number of days left until an equipment batch needs maintenance. It returns the number of batches that need to be checked today (i.e., their days remaining is 0). Parameters: - days_left (List[int]): A list of integers representing days left for maintenance. Returns: - int: The number of batches needing maintenance today. return days_left.count(0)"},{"question":"from typing import List, Tuple def max_non_overlapping_festivals(festivals: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping festivals. Args: festivals (List[Tuple[int, int]]): The list of festivals with start and end times. Returns: int: Maximum number of non-overlapping festivals. >>> max_non_overlapping_festivals([(1, 3), (2, 4), (3, 5), (6, 8)]) 3 >>> max_non_overlapping_festivals([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) 6 >>> max_non_overlapping_festivals([(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_festivals([(1, 5), (2, 6), (3, 7)]) 1 >>> max_non_overlapping_festivals([(1, 4), (2, 3), (3, 5), (6, 8)]) 3 >>> max_non_overlapping_festivals([(1, 5)]) 1","solution":"def max_non_overlapping_festivals(festivals): Finds the maximum number of non-overlapping festivals. Args: festivals (List[Tuple[int, int]]): The list of festivals with start and end times. Returns: int: Maximum number of non-overlapping festivals. # Sort the festivals by end time to apply the greedy algorithm festivals.sort(key=lambda x: x[1]) max_festivals = 0 last_end_time = 0 for start, end in festivals: if start >= last_end_time: max_festivals += 1 last_end_time = end return max_festivals"},{"question":"def warehouse_management_system(n: int, q: int, operations: List[str]) -> List[int]: Handles operations to add items to shelves and query the number of items on shelves. Parameters: n (int): The number of shelves. q (int): The number of operations. operations (list of str): The operations to be performed. Returns: list of int: The results of the query operations. >>> warehouse_management_system(5, 5, [\\"ADD 1 100\\", \\"ADD 2 200\\", \\"QUERY 1\\", \\"ADD 3 300\\", \\"QUERY 2\\"]) == [100, 200] >>> warehouse_management_system(5, 3, [\\"ADD 1 100\\", \\"ADD 2 200\\", \\"ADD 3 300\\"]) == [] >>> warehouse_management_system(5, 3, [\\"QUERY 1\\", \\"QUERY 2\\", \\"QUERY 3\\"]) == [0, 0, 0] >>> warehouse_management_system(3, 7, [\\"ADD 1 50\\", \\"ADD 1 50\\", \\"QUERY 1\\", \\"ADD 2 100\\", \\"QUERY 2\\", \\"ADD 3 200\\", \\"QUERY 3\\"]) == [100, 100, 200] >>> warehouse_management_system(2, 3, [\\"ADD 1 1000000\\", \\"QUERY 1\\", \\"ADD 2 1000000\\"]) == [1000000]","solution":"def warehouse_management_system(n, q, operations): Handles operations to add items to shelves and query the number of items on shelves. Parameters: n (int): The number of shelves. q (int): The number of operations. operations (list of str): The operations to be performed. Returns: list of int: The results of the query operations. # Initialize shelves with zero items shelves = [0] * n results = [] for operation in operations: parts = operation.split() if parts[0] == \\"ADD\\": shelf_number = int(parts[1]) - 1 items = int(parts[2]) shelves[shelf_number] += items elif parts[0] == \\"QUERY\\": shelf_number = int(parts[1]) - 1 results.append(shelves[shelf_number]) return results"},{"question":"def rename_extension(filenames: List[str], old_ext: str, new_ext: str) -> List[str]: Given a list of filenames and an old and new extension, rename the old extension to the new one. >>> rename_extension([\\"document.txt\\", \\"presentation.pdf\\", \\"notes.TXT\\", \\"image.png\\"], \\"txt\\", \\"log\\") [\\"document.log\\", \\"presentation.pdf\\", \\"notes.TXT\\", \\"image.png\\"] >>> rename_extension([\\"FILE.doc\\", \\"study.doc\\", \\"NOTES.doc\\", \\"report.DOC\\"], \\"doc\\", \\"log\\") [\\"FILE.log\\", \\"study.log\\", \\"NOTES.log\\", \\"report.DOC\\"] >>> rename_extension([\\"image.jpeg\\", \\"audio.mp3\\", \\"video.mp4\\"], \\"txt\\", \\"log\\") [\\"image.jpeg\\", \\"audio.mp3\\", \\"video.mp4\\"] >>> rename_extension([\\"test.txt\\", \\"example.txt\\", \\"sample.txt\\"], \\"txt\\", \\"md\\") [\\"test.md\\", \\"example.md\\", \\"sample.md\\"] >>> rename_extension([\\"data.bin\\", \\"report.doc\\", \\"image.BIN\\", \\"code.py\\", \\"readme.BIN\\"], \\"bin\\", \\"dat\\") [\\"data.dat\\", \\"report.doc\\", \\"image.BIN\\", \\"code.py\\", \\"readme.BIN\\"]","solution":"def rename_extension(filenames, old_ext, new_ext): result = [] for filename in filenames: parts = filename.rsplit('.', 1) if len(parts) == 2 and parts[1] == old_ext: result.append(parts[0] + '.' + new_ext) else: result.append(filename) return result"},{"question":"def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string s. >>> longest_palindromic_substring(\\"babad\\") \\"bab\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"a\\") \\"a\\" >>> longest_palindromic_substring(\\"ac\\") \\"a\\" or \\"c\\" >>> longest_palindromic_substring(\\"forgeeksskeegfor\\") \\"geeksskeeg\\"","solution":"def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" # Initialize the positions for the start and end of the longest palindrome found. start = 0 end = 0 def expand_around_center(left: int, right: int) -> tuple: Expands around the center and returns the maximum palindrome bounds. while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(n): # Odd length palindromes l1, r1 = expand_around_center(i, i) # Even length palindromes l2, r2 = expand_around_center(i, i + 1) if r1 - l1 > end - start: start, end = l1, r1 if r2 - l2 > end - start: start, end = l2, r2 return s[start:end + 1]"},{"question":"import math from typing import List def count_perfect_square_pairs(arr: List[int]) -> int: Count all pairs of elements (a, b) in the list such that their product is a perfect square. >>> count_perfect_square_pairs([2, 3, 4, 9, 12]) 2 >>> count_perfect_square_pairs([5, 6, 7]) 0 def is_perfect_square(num: int) -> bool: Check if a number is a perfect square. if num < 0: return False root = int(math.sqrt(num)) return root * root == num count = 0 for i in range(len(arr)): for j in range(i + 1, len(arr)): if is_perfect_square(arr[i] * arr[j]): count += 1 return count def process_test_cases(test_cases: List[List[int]]) -> List[int]: results = [] for arr in test_cases: results.append(count_perfect_square_pairs(arr)) return results def main(inputs: str) -> List[int]: Given a string input representing multiple test cases, process and return the results. Args: inputs (str): multiline string where the first line represents the number of test cases, followed by test cases each containing two lines. Returns: List[int]: number of valid pairs for each test case. >>> main('2n5n2 3 4 9 12n3n5 6 7') [2, 0] >>> main('1n2n4 9') [1] lines = inputs.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append(arr) index += 2 return process_test_cases(test_cases)","solution":"import math from collections import defaultdict def count_perfect_square_pairs(arr): def is_perfect_square(num): if num < 0: return False root = int(math.sqrt(num)) return root * root == num count = 0 for i in range(len(arr)): for j in range(i + 1, len(arr)): if is_perfect_square(arr[i] * arr[j]): count += 1 return count def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(count_perfect_square_pairs(arr)) return results def main(inputs): lines = inputs.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append(arr) index += 2 return process_test_cases(test_cases)"},{"question":"from typing import List, Tuple def minimum_traffic_lights(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determines the minimum number of traffic lights needed so that every intersection is connected by roads with traffic lights. :param n: int - number of intersections :param m: int - number of roads :param roads: List of tuples - each tuple contains two integers representing a road between two intersections :return: int - minimum number of traffic lights needed >>> minimum_traffic_lights(4, 4, [(1, 2), (1, 3), (1, 4), (2, 4)]) 1 >>> minimum_traffic_lights(1, 0, []) 0 >>> minimum_traffic_lights(2, 1, [(1, 2)]) 1 >>> minimum_traffic_lights(3, 0, []) 2 >>> minimum_traffic_lights(3, 3, [(1, 2), (1, 3), (2, 3)]) 1 >>> minimum_traffic_lights(4, 2, [(1, 2), (3, 4)]) 2","solution":"def minimum_traffic_lights(n, m, roads): Determines the minimum number of traffic lights needed so that every intersection is connected by roads with traffic lights. :param n: int - number of intersections :param m: int - number of roads :param roads: List of tuples - each tuple contains two integers representing a road between two intersections :return: int - minimum number of traffic lights needed if n == 1: return 0 degree = [0] * n for u, v in roads: degree[u - 1] += 1 degree[v - 1] += 1 max_degree = max(degree) if max_degree == n - 1: return 1 return 2"},{"question":"def count_age_groups(n: int, ages: List[int]) -> Tuple[int, int, int, int]: Counts the number of people in each age group: \\"Child\\", \\"Teenager\\", \\"Adult\\", \\"Senior\\". Parameters: n (int): The number of ages in the list. ages (list of int): The list of ages. Returns: (tuple of int): A tuple containing four integers representing the number of \\"Child\\", \\"Teenager\\", \\"Adult\\", and \\"Senior\\". >>> count_age_groups(10, [3, 14, 25, 68, 35, 12, 19, 65, 21, 36]) == (2, 2, 4, 2) >>> count_age_groups(5, [1, 2, 3, 4, 5]) == (5, 0, 0, 0) >>> count_age_groups(7, [13, 14, 15, 16, 17, 18, 19]) == (0, 7, 0, 0) >>> count_age_groups(4, [20, 30, 40, 50]) == (0, 0, 4, 0) >>> count_age_groups(3, [65, 70, 80]) == (0, 0, 0, 3) >>> count_age_groups(5, [5, 17, 25, 60, 70]) == (1, 1, 2, 1) >>> count_age_groups(0, []) == (0, 0, 0, 0) >>> count_age_groups(4, [12, 19, 64, 150]) == (1, 1, 1, 1) >>> count_age_groups(4, [0, 0, 0, 0]) == (4, 0, 0, 0)","solution":"def count_age_groups(n, ages): Counts the number of people in each age group: \\"Child\\", \\"Teenager\\", \\"Adult\\", \\"Senior\\". Parameters: n (int): The number of ages in the list. ages (list of int): The list of ages. Returns: (tuple of int): A tuple containing four integers representing the number of \\"Child\\", \\"Teenager\\", \\"Adult\\", and \\"Senior\\". child_count = 0 teenager_count = 0 adult_count = 0 senior_count = 0 for age in ages: if 0 <= age <= 12: child_count += 1 elif 13 <= age <= 19: teenager_count += 1 elif 20 <= age <= 64: adult_count += 1 elif age >= 65: senior_count += 1 return (child_count, teenager_count, adult_count, senior_count)"},{"question":"def track_packages_status(n, updates): Processes a list of status updates and outputs the final status of each package. Args: n: An integer representing the number of status updates. updates: A list of tuples, where each tuple contains a tracking number and its status. Returns: A list of tuples representing the tracking number and its final status. Example: >>> track_packages_status(7, [(\\"123ABC\\", \\"Shipped\\"), (\\"456DEF\\", \\"In-Transit\\"), (\\"123ABC\\", \\"In-Transit\\"), (\\"123ABC\\", \\"Out for Delivery\\"), (\\"789GHI\\", \\"Shipped\\"), (\\"456DEF\\", \\"Out for Delivery\\"), (\\"123ABC\\", \\"Delivered\\")]) [(\\"123ABC\\", \\"Delivered\\"), (\\"456DEF\\", \\"Out for Delivery\\"), (\\"789GHI\\", \\"Shipped\\")] from typing import List, Tuple def test_single_update(): updates = [(\\"123ABC\\", \\"Shipped\\")] result = track_packages_status(1, updates) assert result == [(\\"123ABC\\", \\"Shipped\\")] def test_multiple_updates_single_package(): updates = [ (\\"123ABC\\", \\"Shipped\\"), (\\"123ABC\\", \\"In-Transit\\"), (\\"123ABC\\", \\"Out for Delivery\\"), (\\"123ABC\\", \\"Delivered\\") ] result = track_packages_status(4, updates) assert result == [(\\"123ABC\\", \\"Delivered\\")] def test_multiple_packages(): updates = [ (\\"123ABC\\", \\"Shipped\\"), (\\"456DEF\\", \\"In-Transit\\"), (\\"123ABC\\", \\"In-Transit\\"), (\\"123ABC\\", \\"Out for Delivery\\"), (\\"789GHI\\", \\"Shipped\\"), (\\"456DEF\\", \\"Out for Delivery\\"), (\\"123ABC\\", \\"Delivered\\") ] result = track_packages_status(7, updates) assert result == [(\\"123ABC\\", \\"Delivered\\"), (\\"456DEF\\", \\"Out for Delivery\\"), (\\"789GHI\\", \\"Shipped\\")] def test_no_updates(): updates = [] result = track_packages_status(0, updates) assert result == [] def test_order_of_first_occurrence(): updates = [ (\\"123ABC\\", \\"Shipped\\"), (\\"789GHI\\", \\"Shipped\\"), (\\"456DEF\\", \\"In-Transit\\"), (\\"123ABC\\", \\"In-Transit\\"), (\\"789GHI\\", \\"Out for Delivery\\"), (\\"456DEF\\", \\"Out for Delivery\\"), (\\"123ABC\\", \\"Delivered\\") ] result = track_packages_status(7, updates) # Check if the order of first occurrences is maintained assert result == [(\\"123ABC\\", \\"Delivered\\"), (\\"789GHI\\", \\"Out for Delivery\\"), (\\"456DEF\\", \\"Out for Delivery\\")]","solution":"def track_packages_status(n, updates): Processes a list of status updates and outputs the final status of each package. Args: n: An integer representing the number of status updates. updates: A list of tuples, where each tuple contains a tracking number and its status. Returns: A list of tuples representing the tracking number and its final status. status_dict = {} order_list = [] for update in updates: tracking_number, status = update if tracking_number not in status_dict: order_list.append(tracking_number) status_dict[tracking_number] = status result = [(tracking_number, status_dict[tracking_number]) for tracking_number in order_list] return result"},{"question":"def count_unique_cells(n: int) -> int: Calculates the total number of unique cells that can be reached from the base cell within n steps. Parameters: n (int): The distance from the base cell in terms of steps. Returns: int: The total number of unique cells. >>> count_unique_cells(0) 1 >>> count_unique_cells(1) 5 >>> count_unique_cells(2) 13 >>> count_unique_cells(3) 25 >>> count_unique_cells(4) 41 >>> count_unique_cells(5) 61","solution":"def count_unique_cells(n): Calculates the total number of unique cells that can be reached from the base cell within n steps. Parameters: n (int): The distance from the base cell in terms of steps. Returns: int: The total number of unique cells. # Each layer of cells at distance m from the center forms the perimeter of a square # with side length 2m+1. The number of unique cells at distance m is 4m. # Summing these from m = 0 to m = n gives the total number of reachable cells. total_cells = 0 for m in range(n+1): if m == 0: total_cells += 1 else: total_cells += 4 * m return total_cells"},{"question":"def is_stable_tower(blocks: List[int], threshold: int) -> str: Determine if it is possible to arrange the blocks to form a stable tower such that the difference between the heights of any two adjacent blocks does not exceed the given threshold. :param blocks: List of integers representing heights of blocks. :param threshold: Maximum allowed difference between heights of adjacent blocks. :return: \\"YES\\" if a stable tower can be made, \\"NO\\" otherwise. >>> is_stable_tower([1, 3, 5, 8], 3) \\"YES\\" >>> is_stable_tower([10, 1, 7, 4], 2) \\"NO\\"","solution":"def is_stable_tower(blocks, threshold): Determine if it is possible to arrange the blocks to form a stable tower such that the difference between the heights of any two adjacent blocks does not exceed the given threshold. :param blocks: List of integers representing heights of blocks. :param threshold: Maximum allowed difference between heights of adjacent blocks. :return: \\"YES\\" if a stable tower can be made, \\"NO\\" otherwise. blocks.sort() # Sort the blocks to arrange them in non-decreasing order for i in range(1, len(blocks)): if abs(blocks[i] - blocks[i-1]) > threshold: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def bitwise_operations(n: int, m: int, operations: List[Tuple[str, int, int]]) -> List[int]: Determine the final state of an array of integers after applying a sequence of bitwise operations. Args: n : int : number of elements in the array. m : int : number of operations. operations : List[Tuple[str, int, int]] : list of tuples where each tuple contains a type of operation and two indices. Returns: List[int] : final state of the array. Example: >>> bitwise_operations(3, 4, [('AND', 1, 2), ('OR', 2, 3), ('XOR', 1, 3), ('OR', 3, 1)]) [0, 0, 0] >>> bitwise_operations(4, 4, [('OR', 1, 2), ('AND', 3, 4), ('XOR', 2, 3), ('OR', 4, 1)]) [0, 0, 0, 0] >>> bitwise_operations(1, 3, [('AND', 1, 1), ('OR', 1, 1), ('XOR', 1, 1)]) [0]","solution":"def bitwise_operations(n, m, operations): array = [0] * n for op in operations: operation, i, j = op i -= 1 j -= 1 if operation == 'AND': array[i] &= array[j] elif operation == 'OR': array[i] |= array[j] elif operation == 'XOR': array[i] ^= array[j] return array # Example use case n = 3 m = 4 operations = [ ('AND', 1, 2), ('OR', 2, 3), ('XOR', 1, 3), ('OR', 3, 1) ] # The resultant array after all operations should be [0, 0, 0] (since initial array is all zeros) print(bitwise_operations(n, m, operations)) # Output: [0, 0, 0]"},{"question":"def can_make_elements_equal(n: int, k: int, arr: List[int]) -> str: Determines if it is possible to make all elements of the array equal in exactly k operations. Parameters: n (int): The number of elements in the array. k (int): The exact number of operations required. arr (list of int): The list of elements in the array. Returns: str: \\"Possible\\" if it is achievable to make all array elements equal in exactly k operations, otherwise \\"Impossible\\".","solution":"def can_make_elements_equal(n, k, arr): Determines if it is possible to make all elements of the array equal in exactly k operations. Parameters: n (int): The number of elements in the array. k (int): The exact number of operations required. arr (list of int): The list of elements in the array. Returns: str: \\"Possible\\" if it is achievable to make all array elements equal in exactly k operations, otherwise \\"Impossible\\". max_element = max(arr) min_element = min(arr) total_diff = sum(abs(a - min_element) for a in arr) if k >= total_diff and (k - total_diff) % n == 0: return \\"Possible\\" return \\"Impossible\\""},{"question":"def calculate_difficulty(t: int, problems: List[List[float]]) -> List[float]: Calculate the total difficulty level for each problem based on its base score and multipliers. >>> calculate_difficulty(3, [ ... [100, 2, 0.5, 0.2], ... [200, 0], ... [150, 1, 0.75] ... ]) [170.00, 200.00, 262.50] >>> calculate_difficulty(2, [ ... [300, 0], ... [500, 0] ... ]) [300.00, 500.00] >>> calculate_difficulty(2, [ ... [50, 1, 0.1], ... [75, 1, 0.25] ... ]) [55.00, 93.75] >>> calculate_difficulty(1, [ ... [1000, 3, 0.1, 0.2, 0.3] ... ]) [1600.00] >>> calculate_difficulty(1, [ ... [1, 10, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] ... ]) [6.50]","solution":"def calculate_difficulty(t, problems): difficulties = [] for i in range(t): b = problems[i][0] m = problems[i][1] multipliers = problems[i][2:] difficulty = b + sum(b * multiplier for multiplier in multipliers) difficulties.append(round(difficulty, 2)) return difficulties"},{"question":"from typing import Callable, Tuple def find_treasure(n: int, query: Callable[[int, int], int]) -> Tuple[int, int]: Find the position of the treasure (the cell with the minimum height) in a grid. The function takes the size of the grid \`n\` and a query function \`query\` (which returns the height for any cell), and returns the position of the treasure as a tuple \`(x, y)\` representing the row and column indices (0-based). You should minimize the number of queries used to find the position of the treasure. Args: n (int): The size of the grid. query (Callable[[int, int], int]): A function that can be called to get the height of any cell (i, j). Returns: Tuple[int, int]: The coordinates of the cell containing the treasure (min height). >>> def mock_query(i, j): >>> grid = [ >>> [4, 2, 7], >>> [3, 5, 9], >>> [6, 1, 8] >>> ] >>> return grid[i][j] >>> >>> n = 3 >>> find_treasure(n, mock_query) (2, 1)","solution":"from typing import Callable, Tuple def find_treasure(n: int, query: Callable[[int, int], int]) -> Tuple[int, int]: min_height = float('inf') min_position = (0, 0) # Number of queries to be minimized queries = [] step = max(1, n // 10) # To ensure we don't make more than 100 queries for i in range(0, n, step): for j in range(0, n, step): height = query(i, j) queries.append((i, j, height)) if height < min_height: min_height = height min_position = (i, j) # Linear search through the queried list to find the minimum height position. for i, j, height in queries: if height < min_height: min_height = height min_position = (i, j) return min_position"},{"question":"def find_min_diff_pair(strengths: List[int]) -> Tuple[int, int]: Given a list of strengths, return the pair with the smallest absolute difference. If there are multiple pairs with the same difference, only the first occurring pair is returned. >>> find_min_diff_pair([10, 20, 30, 40, 50, 15]) (10, 15) >>> find_min_diff_pair([1, 2, 3, 4, 5]) (1, 2) >>> find_min_diff_pair([100, 150, 50, 140, 135, 200]) (135, 140) >>> find_min_diff_pair([10000, 9999, 1, 9998]) (9998, 9999) >>> find_min_diff_pair([5, 3, 2]) (2, 3)","solution":"def find_min_diff_pair(strengths): Given a list of strengths, return the pair with the smallest absolute difference. If there are multiple pairs with the same difference, only the first occurring pair is returned. sorted_strengths = sorted(strengths) min_diff = float('inf') min_pair = (sorted_strengths[0], sorted_strengths[1]) for i in range(len(sorted_strengths) - 1): diff = abs(sorted_strengths[i] - sorted_strengths[i+1]) if diff < min_diff: min_diff = diff min_pair = (sorted_strengths[i], sorted_strengths[i+1]) return min_pair"},{"question":"def count_visible_buildings(heights): Returns the number of buildings visible from the left side. Arguments: heights -- List of integers representing the heights of the buildings. >>> count_visible_buildings([3, 1, 4, 2, 5, 7]) 4 >>> count_visible_buildings([5, 4, 3, 2, 1]) 1","solution":"def count_visible_buildings(heights): Returns the number of buildings visible from the left side. max_height = -1 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def is_balanced(s: str) -> str: Determines if the given string of brackets is balanced. Parameters: s (str): The input string containing brackets. Returns: str: \\"YES\\" if the string is balanced, \\"NO\\" otherwise. >>> is_balanced(\\"{[()]}\\") \\"YES\\" >>> is_balanced(\\"{[(])}\\") \\"NO\\" def test_is_balanced(): # Balanced strings assert is_balanced(\\"{[()]}\\") == \\"YES\\" assert is_balanced(\\"()\\") == \\"YES\\" assert is_balanced(\\"[]\\") == \\"YES\\" assert is_balanced(\\"{}\\") == \\"YES\\" assert is_balanced(\\"{[]}\\") == \\"YES\\" assert is_balanced(\\"{[()]}\\") == \\"YES\\" assert is_balanced(\\"[{()}]\\") == \\"YES\\" assert is_balanced(\\"{()}\\") == \\"YES\\" # Unbalanced strings assert is_balanced(\\"{[(])}\\") == \\"NO\\" assert is_balanced(\\"{[}]\\") == \\"NO\\" assert is_balanced(\\"([)]\\") == \\"NO\\" assert is_balanced(\\"(()]\\") == \\"NO\\" assert is_balanced(\\"{[\\") == \\"NO\\" assert is_balanced(\\"}\\") == \\"NO\\" assert is_balanced(\\"[\\") == \\"NO\\" assert is_balanced(\\"(}\\") == \\"NO\\" # Edge cases assert is_balanced(\\"\\") == \\"YES\\" # Empty string should be considered balanced def test_is_balanced_long_string(): # Test with a large balanced string large_balanced = \\"{\\" + \\"()\\" * 500 + \\"}\\" assert is_balanced(large_balanced) == \\"YES\\" # Test with a large unbalanced string large_unbalanced = \\"{\\" + \\"()\\" * 499 + \\")]\\" assert is_balanced(large_unbalanced) == \\"NO\\"","solution":"def is_balanced(s: str) -> str: Determines if the given string of brackets is balanced. Parameters: s (str): The input string containing brackets. Returns: str: \\"YES\\" if the string is balanced, \\"NO\\" otherwise. stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in s: if char in \\"({[\\": stack.append(char) elif char in \\")}]\\": if not stack or stack[-1] != matching_bracket[char]: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\""},{"question":"def min_cut_palindrome(s: str) -> int: Returns the minimum number of cuts needed to partition the string into palindromic substrings. >>> min_cut_palindrome(\\"aab\\") 1 >>> min_cut_palindrome(\\"racecar\\") 0 >>> min_cut_palindrome(\\"abcdefgh\\") 7 from solution import min_cut_palindrome def test_single_character(): assert min_cut_palindrome(\\"a\\") == 0 def test_two_same_characters(): assert min_cut_palindrome(\\"aa\\") == 0 def test_two_different_characters(): assert min_cut_palindrome(\\"ab\\") == 1 def test_no_cut_needed(): assert min_cut_palindrome(\\"aba\\") == 0 def test_example_case(): assert min_cut_palindrome(\\"aab\\") == 1 def test_longer_palindrome(): assert min_cut_palindrome(\\"racecar\\") == 0 def test_complex_case(): assert min_cut_palindrome(\\"abccba\\") == 0 def test_no_palindromic_substrings(): assert min_cut_palindrome(\\"abcdefgh\\") == 7","solution":"def min_cut_palindrome(s): Returns the minimum number of cuts needed to partition the string into palindromic substrings. n = len(s) # Table to store palindrome status is_palindrome = [[False] * n for _ in range(n)] # dp array to store minimum cuts for substrings cuts = [0] * n for i in range(n): min_cut = i # maximum cuts possible for j in range(i + 1): if s[j] == s[i] and (i - j <= 1 or is_palindrome[j + 1][i - 1]): is_palindrome[j][i] = True min_cut = 0 if j == 0 else min(min_cut, cuts[j - 1] + 1) cuts[i] = min_cut return cuts[-1]"},{"question":"def is_permutation(lst): Determines if the list lst is a permutation of the first n natural numbers. Args: lst (list of int): List of integers to check. Returns: str: \\"YES\\" if the list is a permutation of the first n natural numbers, \\"NO\\" otherwise. def test_is_permutation_yes_case(): assert is_permutation([1, 2, 3, 4, 5]) == \\"YES\\" assert is_permutation([3, 2, 1]) == \\"YES\\" assert is_permutation([4, 1, 3, 2]) == \\"YES\\" def test_is_permutation_no_case(): assert is_permutation([1, 3, 4, 6]) == \\"NO\\" assert is_permutation([1, 2, 3, 5]) == \\"NO\\" assert is_permutation([2, 2, 3, 4]) == \\"NO\\" def test_is_permutation_edge_cases(): assert is_permutation([1]) == \\"YES\\" assert is_permutation([2]) == \\"NO\\" assert is_permutation([1000]) == \\"NO\\" def test_is_permutation_large_case(): # Creating a correct permutation of size 1000 correct_permutation = list(range(1, 1001)) assert is_permutation(correct_permutation) == \\"YES\\" # Creating an incorrect permutation of size 1000 by modifying one element incorrect_permutation = correct_permutation.copy() incorrect_permutation[0] = 1001 assert is_permutation(incorrect_permutation) == \\"NO\\"","solution":"def is_permutation(lst): Determines if the list lst is a permutation of the first n natural numbers. Args: lst (list of int): List of integers to check. Returns: str: \\"YES\\" if the list is a permutation of the first n natural numbers, \\"NO\\" otherwise. n = len(lst) return \\"YES\\" if sorted(lst) == list(range(1, n + 1)) else \\"NO\\""},{"question":"def queue_management(n: int, departments: List[int], m: int, patients: List[int]) -> List[int]: This function takes: - n: number of departments - departments: a list of urgency levels of the departments - m: number of patients - patients: a list of urgencies of the patients in the order they arrive It returns a list of integers representing the urgency levels of the department that will serve each patient. >>> queue_management(3, [10, 20, 30], 5, [10, 20, 10, 30, 20]) [10, 20, 10, 30, 20] >>> queue_management(1, [50], 3, [50, 50, 50]) [50, 50, 50] >>> queue_management(4, [5, 15, 25, 35], 6, [35, 5, 25, 15, 5, 35]) [35, 5, 25, 15, 5, 35] >>> queue_management(2, [1, 2], 3, [3, 4, 5]) [] >>> queue_management(3, [7, 13, 22], 4, [13, 7, 22, 7]) [13, 7, 22, 7]","solution":"def queue_management(n, departments, m, patients): This function takes: - n: number of departments - departments: a list of urgency levels of the departments - m: number of patients - patients: a list of urgencies of the patients in the order they arrive It returns a list of integers representing the urgency levels of the department that will serve each patient. # Convert departments list to a set for O(1) lookups urgency_levels = set(departments) result = [] for urgency in patients: if urgency in urgency_levels: result.append(urgency) return result"},{"question":"from typing import List def can_partition_equal_sum(arr: List[int]) -> str: Given an integer array, check whether the array can be divided into two parts such that the sum of the elements in each part is the same. Parameters: arr (List[int]): The list of integers representing the array. Returns: str: \\"YES\\" if the array can be divided into two parts with equal sum, otherwise \\"NO\\". Examples: >>> can_partition_equal_sum([1, 5, 11, 5]) 'YES' >>> can_partition_equal_sum([1, 2, 3, 5]) 'NO' def handle_test_cases(t: int, test_cases: List[List[int]]) -> List[str]: Handle multiple test cases for checking if an array can be partitioned into two subsets with equal sum. Parameters: t (int): The number of test cases. test_cases (List[List[int]]): List of test cases, where each test case is a list of integers. The first integer is the length of the array, followed by the array elements. Returns: List[str]: List of results for each test case, either \\"YES\\" or \\"NO\\". Examples: >>> handle_test_cases(2, [[4, 1, 5, 11, 5], [4, 1, 2, 3, 5]]) ['YES', 'NO'] >>> handle_test_cases(3, [[6, 1, 1, 1, 1, 1, 1], [5, 3, 3, 3, 4, 5], [4, 2, 2, 3, 5]]) ['YES', 'YES', 'NO']","solution":"from typing import List def can_partition_equal_sum(arr: List[int]) -> str: total_sum = sum(arr) # If total sum is odd, can't partition into two equal subsets if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(arr) # Create a DP array to determine if a subset with sum \`target\` is possible dp = [False] * (target + 1) dp[0] = True # There's always a subset with sum 0: the empty set for num in arr: for i in range(target, num - 1, -1): if dp[i - num]: dp[i] = True return \\"YES\\" if dp[target] else \\"NO\\" def handle_test_cases(t: int, test_cases: List[List[int]]) -> List[str]: results = [] for case in test_cases: results.append(can_partition_equal_sum(case[1:])) return results"},{"question":"from typing import List def plate_stack(operations: List[str]) -> str: You have a stack of plates. The plates are stacked in the order they are placed, with the most recently placed plate at the top. You can place a plate on top of the stack or remove the top plate from the stack. Each operation is described by a single string. An operation is either \\"push x\\", where x is an integer representing the value of the plate being added to the stack, or \\"pop\\", which means removing the top plate from the stack. After performing all the operations, you need to print the values of the plates remaining in the stack from top to bottom. If the stack is empty, print \\"empty\\". Args: operations (List[str]): List of operations to perform on the stack. Returns: str: The values of the plates in the stack from top to bottom, or \\"empty\\" if the stack is empty. >>> plate_stack([\\"push 5\\", \\"push 2\\", \\"pop\\", \\"push 6\\", \\"push 9\\"]) '9 6 5' >>> plate_stack([\\"push 4\\", \\"pop\\", \\"pop\\"]) 'empty' >>> plate_stack([\\"push 1\\", \\"push 2\\", \\"pop\\", \\"push 3\\", \\"pop\\", \\"pop\\"]) 'empty' >>> plate_stack([]) 'empty' >>> plate_stack([\\"push 10\\", \\"push 20\\", \\"push 30\\"]) '30 20 10' >>> plate_stack([\\"pop\\", \\"pop\\", \\"push 1\\", \\"pop\\", \\"pop\\"]) 'empty' >>> plate_stack([\\"push -1\\", \\"push -2\\", \\"push -3\\", \\"pop\\", \\"push -4\\"]) '-4 -2 -1'","solution":"def plate_stack(operations): stack = [] for op in operations: if op.startswith(\\"push\\"): _, value = op.split() stack.append(int(value)) elif op == \\"pop\\": if stack: stack.pop() return ' '.join(map(str, stack[::-1])) if stack else \\"empty\\""},{"question":"import heapq from typing import List, Tuple def minimum_travel_time(n: int, m: int, routes: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Returns the minimum travel times for each query. >>> minimum_travel_time(5, 7, [(1, 2, 10), (2, 3, 20), (3, 4, 30), (4, 5, 40), (1, 3, 50), (2, 4, 60), (3, 5, 70)], [(1, 3), (2, 5), (1, 5)]) [30, 90, 100] >>> minimum_travel_time(3, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 15)], [(1, 3), (2, 3)]) [15, 10] >>> minimum_travel_time(5, 0, [], [(1, 3), (4, 5)]) [-1, -1] >>> minimum_travel_time(4, 4, [(1, 2, 5), (2, 3, 10), (3, 4, 15), (4, 1, 20)], [(1, 1), (2, 2), (3, 3), (4, 4)]) [0, 0, 0, 0] >>> minimum_travel_time(6, 4, [(1, 2, 10), (2, 3, 10), (4, 5, 10), (5, 6, 10)], [(1, 3), (4, 6), (1, 5)]) [20, 20, -1] pass","solution":"import heapq def dijkstra(n, graph, start): Implements the Dijkstra algorithm to find the shortest paths from the starting node. distances = {i: float('infinity') for i in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def minimum_travel_time(n, m, routes, queries): Returns the minimum travel times for each query. graph = {i: [] for i in range(1, n + 1)} # Build the graph for u, v, w in routes: graph[u].append((v, w)) graph[v].append((u, w)) # because the routes are bi-directional results = [] for a, b in queries: distances = dijkstra(n, graph, a) min_time = distances[b] results.append(-1 if min_time == float('infinity') else min_time) return results"},{"question":"def minTotalDifficulty(grid: List[List[int]]) -> int: Determine the minimum total difficulty Valeria will encounter on her way from the top-left to the bottom-right corner of the grid. :param grid: List[List[int]], n x m grid of difficulties :return: int, minimum total difficulty encountered >>> minTotalDifficulty([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minTotalDifficulty([[0]]) 0 >>> minTotalDifficulty([[1, 2], [1, 1]]) 3 >>> minTotalDifficulty([[1000, 1000], [1000, 1000]]) 3000 >>> minTotalDifficulty([[1, 1, 1, 1, 1]]) 5 >>> minTotalDifficulty([[1], [1], [1], [1], [1]]) 5 pass","solution":"def minTotalDifficulty(grid): Determine the minimum total difficulty Valeria will encounter on her way from the top-left to the bottom-right corner of the grid. :param grid: List[List[int]], n x m grid of difficulties :return: int, minimum total difficulty encountered n = len(grid) m = len(grid[0]) # Initialize DP table with the same dimensions as grid dp = [[0] * m for _ in range(n)] # Fill DP table for i in range(n): for j in range(m): if i == 0 and j == 0: dp[i][j] = grid[i][j] elif i == 0: dp[i][j] = dp[i][j-1] + grid[i][j] elif j == 0: dp[i][j] = dp[i-1][j] + grid[i][j] else: dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] # Example usage: # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(minTotalDifficulty(grid)) # Output: 7"},{"question":"def count_overlapping_shifts(shifts: List[Tuple[int, int]]) -> int: Counts the total number of overlapping shift pairs. >>> count_overlapping_shifts([(1, 2), (2, 3), (3, 4)]) 0 >>> count_overlapping_shifts([(1, 3), (2, 4)]) 1 >>> count_overlapping_shifts([(1, 3), (2, 5), (4, 6), (6, 8)]) 2 >>> count_overlapping_shifts([(1, 5), (2, 6), (3, 7)]) 3 >>> count_overlapping_shifts([(0, 24), (1, 23)]) 1 >>> count_overlapping_shifts([(1, 5)] * 1000) 499500 # Your code here","solution":"def count_overlapping_shifts(shifts): Counts the total number of overlapping shift pairs. overlap_count = 0 n = len(shifts) # Function to check if two shifts overlap def is_overlap(shift1, shift2): return max(shift1[0], shift2[0]) < min(shift1[1], shift2[1]) # Compare every pair of shifts for i in range(n): for j in range(i + 1, n): if is_overlap(shifts[i], shifts[j]): overlap_count += 1 return overlap_count"},{"question":"def can_form_symmetric_column(s: str) -> bool: Determines if the sequence of colors can be rearranged to form a symmetrical column. A sequence can be rearranged to form a symmetrical column if and only if at most one character has an odd frequency. That's because one odd frequency character can sit in the middle of the palindrome, while all even frequency characters can symmetrically surround it. :param s: A string consisting of lowercase English letters representing the sequence of colors :return: A boolean value indicating whether the sequence can be rearranged to form a symmetrical column Examples: >>> can_form_symmetric_column(\\"aabbcc\\") True >>> can_form_symmetric_column(\\"abcabc\\") True >>> can_form_symmetric_column(\\"aab\\") True >>> can_form_symmetric_column(\\"abc\\") False","solution":"from collections import Counter def can_form_symmetric_column(s: str) -> bool: Determines if the sequence of colors can be rearranged to form a symmetrical column. A sequence can be rearranged to form a symmetrical column if and only if at most one character has an odd frequency. That's because one odd frequency character can sit in the middle of the palindrome, while all even frequency characters can symmetrically surround it. :param s: A string consisting of lowercase English letters representing the sequence of colors :return: A boolean value indicating whether the sequence can be rearranged to form a symmetrical column freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 != 0) # It can be symmetrical if there is only one or zero characters with an odd count return odd_count <= 1"},{"question":"def can_eat_all_candies_without_consecutive_colors(n: int, candy_counts: List[int]) -> str: Determine whether it's possible to eat all the candies such that you never eat a candy of the same color consecutively. Args: n: An integer representing the number of candy boxes. candy_counts: A list of integers representing the number of candies in each box. Returns: \\"Yes\\" if it is possible to eat all the candies without ever eating a candy of the same color consecutively, and \\"No\\" otherwise. Examples: >>> can_eat_all_candies_without_consecutive_colors(3, [3, 5, 2]) \\"Yes\\" >>> can_eat_all_candies_without_consecutive_colors(3, [1, 1, 1]) \\"Yes\\" >>> can_eat_all_candies_without_consecutive_colors(2, [4, 1]) \\"No\\" >>> can_eat_all_candies_without_consecutive_colors(4, [1, 1, 2, 1]) \\"Yes\\" >>> can_eat_all_candies_without_consecutive_colors(1, [1]) \\"Yes\\" >>> can_eat_all_candies_without_consecutive_colors(5, [100000, 1, 1, 1, 1]) \\"No\\" >>> can_eat_all_candies_without_consecutive_colors(100000, [1] * 100000) \\"Yes\\"","solution":"def can_eat_all_candies_without_consecutive_colors(n, candy_counts): if n == 1: return \\"Yes\\" if candy_counts[0] == 1 else \\"No\\" max_candies = max(candy_counts) total_candies = sum(candy_counts) if max_candies <= (total_candies - max_candies + 1): return \\"Yes\\" else: return \\"No\\""},{"question":"def minOperationsToPalindrome(s: str) -> int: Returns the minimum number of operations required to transform the given string into a palindrome. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Minimum number of operations needed to make the string a palindrome. >>> minOperationsToPalindrome(\\"abc\\") 1 >>> minOperationsToPalindrome(\\"abca\\") 1 >>> minOperationsToPalindrome(\\"racecar\\") 0 >>> minOperationsToPalindrome(\\"a\\") 0","solution":"def minOperationsToPalindrome(s): Returns the minimum number of operations required to transform the given string into a palindrome. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Minimum number of operations needed to make the string a palindrome. n = len(s) operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"class FenwickTree: def __init__(self, n): # initialize the tree with the necessary size self.n = n self.tree = [0] * (n + 1) def update(self, index, delta): # update the value at the given index while index <= self.n: self.tree[index] += delta index += index & -index def query(self, index): # query the sum from the beginning to the given index sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def range_query(self, left, right): Query the sum of the interval from left to right. return self.query(right) - self.query(left - 1) def main(): Main function to process input and execute update and query operations Example input: 5 4 4 3 7 5 1 2 1 3 1 3 10 2 2 4 2 1 5 Expected output: 14 18 23 import sys input = sys.stdin.read data = input().split() n, q = int(data[0]), int(data[1]) array = list(map(int, data[2:n+2])) ft = FenwickTree(n) # Initialize Fenwick Tree with the given array for i in range(n): ft.update(i + 1, array[i]) output = [] index = n + 2 for _ in range(q): query_type = int(data[index]) if query_type == 1: x = int(data[index + 1]) y = int(data[index + 2]) index += 3 current_value = ft.range_query(x, x) ft.update(x, y - current_value) elif query_type == 2: l = int(data[index + 1]) r = int(data[index + 2]) index += 3 result = ft.range_query(l, r) output.append(str(result)) sys.stdout.write(\\"n\\".join(output) + \\"n\\")","solution":"class FenwickTree: def __init__(self, n): self.n = n self.tree = [0] * (n + 1) def update(self, index, delta): while index <= self.n: self.tree[index] += delta index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def range_query(self, left, right): return self.query(right) - self.query(left - 1) def main(): import sys input = sys.stdin.read data = input().split() n, q = int(data[0]), int(data[1]) array = list(map(int, data[2:n+2])) ft = FenwickTree(n) # Initialize Fenwick Tree with the given array for i in range(n): ft.update(i + 1, array[i]) output = [] index = n + 2 for _ in range(q): query_type = int(data[index]) if query_type == 1: x = int(data[index + 1]) y = int(data[index + 2]) index += 3 current_value = ft.range_query(x, x) ft.update(x, y - current_value) elif query_type == 2: l = int(data[index + 1]) r = int(data[index + 2]) index += 3 result = ft.range_query(l, r) output.append(str(result)) sys.stdout.write(\\"n\\".join(output) + \\"n\\")"},{"question":"from typing import List, Tuple def kth_smallest_unique(a: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: You are given an array of integers \`a\`. You should answer \`n\` queries. The \`i\`-th query consists of three integers: \`l_i\`, \`r_i\`, and \`k_i\`. The answer for this query is the \`k_i\`-th smallest unique number in the subarray from index \`l_i\` to \`r_i\` (both inclusive). If there are less than \`k_i\` unique numbers in the given subarray, output -1. Parameters: a (List[int]): The array of integers. queries (List[Tuple[int, int, int]]): A list of queries where each query is represented as a tuple of three integers (\`l_i\`, \`r_i\`, and \`k_i\`). Returns: List[int]: The answers for each query. >>> a = [4, 3, 5, 2, 5, 3, 6, 6] >>> queries = [ ... (1, 3, 2), ... (3, 6, 3), ... (4, 8, 1), ... (4, 8, 3), ... (5, 5, 1) ... ] >>> expected_results = [4, 5, 2, 5, 5] >>> kth_smallest_unique(a, queries) == expected_results True >>> a = [1, 2, 2, 3, 4] >>> queries = [ ... (1, 1, 1), ... (1, 5, 3), ... (2, 4, 3) ... ] >>> expected_results = [1, 3, -1] >>> kth_smallest_unique(a, queries) == expected_results True >>> a = [7, 8, 9, 10] >>> queries = [ ... (2, 2, 1), ... (4, 4, 1) ... ] >>> expected_results = [8, 10] >>> kth_smallest_unique(a, queries) == expected_results True >>> a = [1, 1, 1, 1] >>> queries = [ ... (1, 4, 1), ... (1, 4, 2) ... ] >>> expected_results = [1, -1] >>> kth_smallest_unique(a, queries) == expected_results True >>> a = [2, 2, 2, 2] >>> queries = [ ... (1, 3, 1) ... ] >>> expected_results = [2] >>> kth_smallest_unique(a, queries) == expected_results True","solution":"def kth_smallest_unique(a, queries): results = [] for l, r, k in queries: subarray = a[l-1:r] unique_elements = sorted(set(subarray)) if len(unique_elements) < k: results.append(-1) else: results.append(unique_elements[k-1]) return results"},{"question":"def max_equal_substrings(s: str) -> int: Returns the maximum number of contiguous substrings where each substring contains an equal number of '0's and '1's. >>> max_equal_substrings(\\"11001100\\") 2 >>> max_equal_substrings(\\"000111\\") 1 >>> max_equal_substrings(\\"010101\\") 3","solution":"def max_equal_substrings(s): Returns the maximum number of contiguous substrings where each substring contains an equal number of '0's and '1's. count = 0 balance = 0 for char in s: if char == '0': balance -= 1 else: balance += 1 if balance == 0: count += 1 return count"},{"question":"def perform_dfs(n: int, m: int, edges: List[Tuple[int, int]], s: int) -> List[int]: Perform a lexicographically smallest Depth First Search (DFS) on an undirected graph. Args: n (int): Number of vertices in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int]]): List of edges where each edge is represented by a tuple (u, v). s (int): The starting vertex for the DFS. Returns: List[int]: The order of vertices visited in the DFS traversal. Example: >>> perform_dfs(5, 4, [(1, 2), (1, 3), (2, 4), (2, 5)], 1) [1, 2, 4, 5, 3] >>> perform_dfs(1, 0, [], 1) [1]","solution":"def dfs_lexicographic(n, m, edges, s): from collections import defaultdict import heapq # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Sort adjacency lists for lexicographical order for key in graph.keys(): graph[key].sort() visited = [False] * (n + 1) result = [] # Using stack for DFS stack = [s] while stack: v = stack.pop() if not visited[v]: visited[v] = True result.append(v) # Add unvisited neighbors to stack in reverse order for neighbor in reversed(graph[v]): if not visited[neighbor]: stack.append(neighbor) return result # Function for parsing input and calling DFS def perform_dfs(n, m, edge_list, start): return dfs_lexicographic(n, m, edge_list, start)"},{"question":"def sieve(n): Returns a list of primes up to n, using the Sieve of Eratosthenes algorithm. is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] def prime_gaps_sum(p1, p2): Returns the sum of all prime gaps between prime numbers p1 and p2, inclusive. >>> prime_gaps_sum(3, 11) 8 >>> prime_gaps_sum(2, 5) 3 >>> prime_gaps_sum(23, 31) 8 >>> prime_gaps_sum(101, 113) 12 >>> prime_gaps_sum(13, 19) 6 from typing import List","solution":"def sieve(n): Returns a list of primes up to n, using the Sieve of Eratosthenes algorithm. is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] def prime_gaps_sum(p1, p2): Returns the sum of all prime gaps between prime numbers p1 and p2, inclusive. primes = sieve(p2) relevant_primes = [p for p in primes if p1 <= p <= p2] prime_gaps = [relevant_primes[i] - relevant_primes[i-1] for i in range(1, len(relevant_primes))] return sum(prime_gaps) # Sample implementation print(prime_gaps_sum(3, 11)) # Should return 8"},{"question":"from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearrange the string such that no two adjacent characters are the same. Args: s (str): The input string. Returns: str: The rearranged string or \\"Not Possible\\" if rearrangement is not possible. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaab\\") == \\"Not Possible\\" True","solution":"from collections import Counter import heapq def rearrange_string(s): Rearrange the string such that no two adjacent characters are the same. Args: s (str): The input string. Returns: str: The rearranged string or \\"Not Possible\\" if rearrangement is not possible. # Get the frequency of each character freq = Counter(s) # Max heap based on frequency max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If prev character's frequency is more than 0, push it back in the heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update prev_char and prev_freq prev_char, prev_freq = char, freq + 1 rearranged = ''.join(result) if len(rearranged) == len(s): return rearranged else: return \\"Not Possible\\""},{"question":"from typing import List def grid_from_input(input_str: str) -> List[List[str]]: Convert input string to grid. >>> grid_from_input(\\"5n.....n...n...#.n...#.n.....\\") [['.', '.', '.', '.', '.'], ['.', '#', '#', '.', '.'], ['.', '.', '.', '#', '.'], ['.', '.', '.', '#', '.'], ['.', '.', '.', '.', '.']] lines = input_str.strip().split('n') n = int(lines[0]) grid = [list(line) for line in lines[1:]] return grid from collections import deque def shortest_path(grid: List[List[str]]) -> int: Find the shortest path from top-left to bottom-right in the grid. >>> shortest_path([['.', '.', '.', '.', '.'], ['.', '#', '#', '.', '.'], ['.', '.', '.', '#', '.'], ['.', '.', '.', '#', '.'], ['.', '.', '.', '.', '.']]) 9 >>> shortest_path([['.', '#', '.'], ['#', '#', '#'], ['.', '#', '.']]) -1 >>> shortest_path([['.']]) 1 def test_shortest_path_simple(): input_str = \\"5n.....n...n...#.n...#.n.....\\" grid = grid_from_input(input_str) assert shortest_path(grid) == 9 def test_shortest_path_no_path(): input_str = \\"3n.#.n#n.#.\\" grid = grid_from_input(input_str) assert shortest_path(grid) == -1 def test_shortest_path_single_cell(): input_str = \\"1n.\\" grid = grid_from_input(input_str) assert shortest_path(grid) == 1 def test_shortest_path_edge_case(): input_str = \\"3n..#n.#.n#..\\" grid = grid_from_input(input_str) assert shortest_path(grid) == -1 def test_shortest_path_blocked_start(): input_str = \\"3n#n.#.n..#\\" grid = grid_from_input(input_str) assert shortest_path(grid) == -1 def test_shortest_path_no_obstacles(): input_str = \\"3n...n...n...\\" grid = grid_from_input(input_str) assert shortest_path(grid) == 5","solution":"from collections import deque def shortest_path(grid): n = len(grid) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # start from (0, 0) with distance 1 visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n - 1, n - 1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != '#': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 def grid_from_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) grid = [list(line) for line in lines[1:]] return grid"},{"question":"def find_min_difference_pair(prices): Returns a pair of prices with the smallest absolute difference. If there are multiple pairs, returns the pair with the smallest sum. >>> find_min_difference_pair([4, 9, 2, 7, 15]) (2, 4) >>> find_min_difference_pair([100, 200]) (100, 200) >>> find_min_difference_pair([10, 5, 15, 20]) (5, 10) >>> find_min_difference_pair([1000000, 2, 4, 1, 999999, 1000001]) (1, 2) >>> find_min_difference_pair([1, 2, 3, 4, 5]) (1, 2) >>> find_min_difference_pair([20, 90, 130, 45, 60]) (45, 60)","solution":"def find_min_difference_pair(prices): Returns a pair of prices with the smallest absolute difference. If there are multiple pairs, returns the pair with the smallest sum. # Sort the prices to find the pair with minimum difference easily prices.sort() min_diff = float('inf') best_pair = (None, None) # Traverse the sorted list and calculate the difference between consecutive elements for i in range(len(prices) - 1): diff = abs(prices[i] - prices[i + 1]) if diff < min_diff: min_diff = diff best_pair = (prices[i], prices[i + 1]) elif diff == min_diff: # Choose the pair with the smaller sum if prices[i] + prices[i + 1] < best_pair[0] + best_pair[1]: best_pair = (prices[i], prices[i + 1]) return best_pair"},{"question":"import heapq def minimum_total_length_of_bridges(n, bridges): Returns the minimum total length of bridges required to connect all the cities. If it is not possible, returns \\"Impossible\\". pass def test_example_input(): n = 4 bridges = [ (1, 2, 10), (1, 3, 15), (1, 4, 20), (2, 3, 35), (3, 4, 25) ] assert minimum_total_length_of_bridges(n, bridges) == 45 def test_single_city(): n = 1 bridges = [] assert minimum_total_length_of_bridges(n, bridges) == 0 def test_minimum_m_bridges(): n = 4 bridges = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), ] assert minimum_total_length_of_bridges(n, bridges) == 6 def test_disconnected_graph(): n = 4 bridges = [ (1, 2, 1), (2, 3, 2), ] assert minimum_total_length_of_bridges(n, bridges) == \\"Impossible\\" def test_complex_graph(): n = 6 bridges = [ (1, 2, 1), (2, 3, 4), (3, 4, 3), (4, 5, 2), (5, 6, 6), (1, 4, 2), (2, 5, 5) ] assert minimum_total_length_of_bridges(n, bridges) == 14","solution":"def minimum_total_length_of_bridges(n, bridges): Returns the minimum total length of bridges required to connect all the cities. If it is not possible, returns \\"Impossible\\". parent = list(range(n)) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: parent[root_u] = root_v # Sorting the bridges by weight bridges.sort(key=lambda x: x[2]) total_length = 0 for u, v, w in bridges: if find(u-1) != find(v-1): union(u-1, v-1) total_length += w # Check if all cities are connected root_set = set(find(i) for i in range(n)) if len(root_set) != 1: return \\"Impossible\\" return total_length"},{"question":"def apply_queries(m: int, n: int, grid: List[List[int]], queries: List[Tuple[int, int, int, int, int]]) -> List[List[int]]: Apply a series of incremental updates to subrectangles in a grid. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[List[int]]): Initial grid filled with integers. queries (List[Tuple[int, int, int, int, int]]): List of queries. Each query is a tuple (r1, c1, r2, c2, x). Returns: List[List[int]]: Final state of the grid after applying all queries. Example: >>> m, n = 3, 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... (1, 1, 2, 2, 1), ... (2, 2, 3, 3, -1) ... ] >>> apply_queries(m, n, grid, queries) [[2, 3, 3], [5, 5, 5], [7, 7, 8]] pass from typing import List, Tuple def test_example_case(): m, n = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [ (1, 1, 2, 2, 1), (2, 2, 3, 3, -1) ] result = apply_queries(m, n, grid, queries) expected = [ [2, 3, 3], [5, 5, 5], [7, 7, 8] ] assert result == expected def test_single_element_increment(): m, n = 2, 2 grid = [ [0, 0], [0, 0] ] queries = [ (1, 1, 1, 1, 5), ] result = apply_queries(m, n, grid, queries) expected = [ [5, 0], [0, 0] ] assert result == expected def test_full_grid_decrement(): m, n = 3, 3 grid = [ [10, 10, 10], [10, 10, 10], [10, 10, 10] ] queries = [ (1, 1, 3, 3, -10), ] result = apply_queries(m, n, grid, queries) expected = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert result == expected def test_non_overlapping_queries(): m, n = 4, 4 grid = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] queries = [ (1, 1, 2, 2, 1), (3, 3, 4, 4, 2) ] result = apply_queries(m, n, grid, queries) expected = [ [2, 2, 1, 1], [2, 2, 1, 1], [1, 1, 3, 3], [1, 1, 3, 3] ] assert result == expected","solution":"def apply_queries(m, n, grid, queries): def increase_subrectangle(grid, r1, c1, r2, c2, x): for i in range(r1, r2 + 1): for j in range(c1, c2 + 1): grid[i][j] += x for query in queries: r1, c1, r2, c2, x = query increase_subrectangle(grid, r1 - 1, c1 - 1, r2 - 1, c2 - 1, x) return grid"},{"question":"def count_island_groups(n: int, m: int, bridges: List[Tuple[int, int]]) -> int: Counts the number of independent groups of islands based on the bridges connecting them. Parameters: n (int): Number of islands. m (int): Number of bridges. bridges (list of tuples): Each tuple contains two integers a and b representing a bridge between island a and island b. Returns: int: Number of independent groups of islands. Example: >>> count_island_groups(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> count_island_groups(5, 0, []) 5","solution":"def count_island_groups(n, m, bridges): Counts the number of independent groups of islands based on the bridges connecting them. Parameters: n (int): Number of islands. m (int): Number of bridges. bridges (list of tuples): Each tuple contains two integers a and b representing a bridge between island a and island b. Returns: int: Number of independent groups of islands. from collections import defaultdict def dfs(node): visited.add(node) for neighbor in adjacency_list[node]: if neighbor not in visited: dfs(neighbor) # Create adjacency list adjacency_list = defaultdict(list) for a, b in bridges: adjacency_list[a].append(b) adjacency_list[b].append(a) visited = set() group_count = 0 for island in range(1, n + 1): if island not in visited: group_count += 1 dfs(island) return group_count"},{"question":"from typing import List, Union def assign_activities(n: int, m: int, capacities: List[int], preferences: List[List[int]]) -> Union[List[int], str]: Assigns each student to one activity such that no activity exceeds its capacity and the total preference value across all assignments is maximized. If no valid assignment is found, returns \\"Impossible\\". Args: n (int): The number of students. m (int): The number of activities. capacities (List[int]): The capacities of the activities. preferences (List[List[int]]): The preference values of each student for the activities. Returns: Union[List[int], str]: The activity assignments for each student in the given order or \\"Impossible\\". Examples: >>> assign_activities(5, 3, [2, 2, 1], [ ... [4, 6, 3], ... [5, 8, 2], ... [7, 5, 10], ... [6, 7, 8], ... [3, 2, 9]]) [3, 2, 1, 2, 1] >>> assign_activities(3, 3, [1, 1, 1], [ ... [1, 10, 3], ... [10, 1, 2], ... [4, 3, 9]]) [2, 1, 3] pass # implement the function here def test_assign_activities_basic(): assert assign_activities(5, 3, [2, 2, 1], [ [4, 6, 3], [5, 8, 2], [7, 5, 10], [6, 7, 8], [3, 2, 9] ]) == [2, 2, 3, 1, 1] def test_assign_activities_all_one(): assert assign_activities(3, 3, [1, 1, 1], [ [1, 10, 3], [10, 1, 2], [4, 3, 9] ]) == [2, 1, 3] def test_assign_activities_no_valid(): assert assign_activities(3, 1, [1], [ [1], [1], [1] ]) == \\"Impossible\\" def test_assign_activities_another_case(): assert assign_activities(4, 2, [2, 2], [ [9, 7], [3, 8], [4, 2], [2, 5] ]) == [1, 2, 1, 2] def test_assign_activities_single_student(): assert assign_activities(1, 1, [1], [ [5] ]) == [1]","solution":"def assign_activities(n, m, capacities, preferences): assignment = [-1] * n remaining_capacities = capacities[:] for student in range(n): max_pref = -1 chosen_activity = -1 for activity in range(m): if preferences[student][activity] > max_pref and remaining_capacities[activity] > 0: max_pref = preferences[student][activity] chosen_activity = activity if chosen_activity != -1: assignment[student] = chosen_activity + 1 # converting to 1-based index remaining_capacities[chosen_activity] -= 1 else: return \\"Impossible\\" return assignment"},{"question":"def max_trees(m: int, n: int) -> int: Calculate the maximum number of trees that can be planted in an m x n grid such that no two trees are adjacent vertically, horizontally, or diagonally. :param m: rows of the grid :param n: columns of the grid :return: maximum number of trees >>> max_trees(3, 3) 5 >>> max_trees(2, 2) 2 >>> max_trees(1, 5) 3 >>> max_trees(6, 1) 3 >>> max_trees(2000, 2000) 2000000 >>> max_trees(2001, 2001) 2002001","solution":"def max_trees(m, n): Calculate the maximum number of trees that can be planted in an m x n grid such that no two trees are adjacent vertically, horizontally, or diagonally. :param m: rows of the grid :param n: columns of the grid :return: maximum number of trees # A checkerboard pattern guarantees the maximum number of trees if (m * n) % 2 == 0: return (m * n) // 2 else: return (m * n) // 2 + 1"},{"question":"def max_trapped_water(heights: List[int]) -> int: Calculate the maximum amount of water that can be trapped between the blocks. :param heights: List of non-negative integers representing the height of water blocks. :return: Integer representing the maximum amount of trapped water. >>> max_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> max_trapped_water([1, 1, 1, 1, 1]) 0 >>> max_trapped_water([5]) 0 >>> max_trapped_water([5, 4]) 0 >>> max_trapped_water([5, 4, 3, 2, 1]) 0 >>> max_trapped_water([1, 2, 3, 4, 5]) 0 >>> max_trapped_water([5, 1, 5]) 4 >>> max_trapped_water([3, 0, 2, 0, 4]) 7 >>> max_trapped_water([3, 1, 2, 1, 2]) 2","solution":"def max_trapped_water(heights): Calculate the maximum amount of water that can be trapped between the blocks. :param heights: List of non-negative integers representing the height of water blocks. :return: Integer representing the maximum amount of trapped water. n = len(heights) if n <= 2: return 0 left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] right_max[n-1] = heights[n-1] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def temperature_range(temperatures: List[int]) -> int: Given a list of temperature readings for a week, where each temperature is an integer value between -100 and 100 (inclusive). The list contains exactly 7 integers. Your task is to determine the range of temperatures for the week, which is the difference between the highest and lowest temperatures. :param temperatures: List of 7 integers representing temperatures. :return: Integer representing the difference between the highest and lowest temperatures. >>> temperature_range([23, -5, 10, -10, 30, 5, 7]) == 40 >>> temperature_range([10, 20, 30, 25, 15, 5, 35]) == 30 >>> temperature_range([-10, -20, -30, -25, -15, -5, -35]) == 30 >>> temperature_range([0, -100, 50, 20, -50, 100, -20]) == 200 >>> temperature_range([10, 10, 10, 10, 10, 10, 10]) == 0 >>> temperature_range([0, 0, 0, 0, 0, 0, 0]) == 0 >>> temperature_range([100, -100, 100, -100, 100, -100, 100]) == 200 pass from typing import List def test_temperature_range_standard_case(): assert temperature_range([23, -5, 10, -10, 30, 5, 7]) == 40 def test_temperature_range_all_positive(): assert temperature_range([10, 20, 30, 25, 15, 5, 35]) == 30 def test_temperature_range_all_negative(): assert temperature_range([-10, -20, -30, -25, -15, -5, -35]) == 30 def test_temperature_range_mixed(): assert temperature_range([0, -100, 50, 20, -50, 100, -20]) == 200 def test_temperature_range_identical_values(): assert temperature_range([10, 10, 10, 10, 10, 10, 10]) == 0 def test_temperature_range_zero_high_low(): assert temperature_range([0, 0, 0, 0, 0, 0, 0]) == 0 def test_temperature_range_edge_values(): assert temperature_range([100, -100, 100, -100, 100, -100, 100]) == 200","solution":"def temperature_range(temperatures): Returns the range of temperatures for the week. :param temperatures: List of 7 integers representing temperatures. :return: Integer representing the difference between the highest and lowest temperatures. return max(temperatures) - min(temperatures)"},{"question":"def shortest_path(grid, start, end): Finds the shortest path in a grid avoiding walls. Parameters: grid (list of lists of str): The grid, where ' ' is an empty cell and '#' is a wall. start (tuple): Starting cell (row, col). end (tuple): Ending cell (row, col). Returns: int: Length of the shortest path or -1 if no path exists. >>> grid = [ ... [' ', ' ', '#', ' '], ... ['#', ' ', '#', ' '], ... [' ', ' ', ' ', ' '], ... [' ', '#', ' ', '#'] ... ] >>> start = (0, 0) >>> end = (2, 3) >>> shortest_path(grid, start, end) 5 >>> grid = [ ... [' ', '#'], ... ['#', ' '] ... ] >>> start = (0, 0) >>> end = (1, 1) >>> shortest_path(grid, start, end) -1 >>> grid = [ ... [' ', '#', ' '], ... ['#', ' ', ' '], ... [' ', ' ', '#'] ... ] >>> start = (2, 0) >>> end = (2, 0) >>> shortest_path(grid, start, end) 0 >>> grid = [[' '] * 100 for _ in range(100)] >>> start = (0, 0) >>> end = (99, 99) >>> shortest_path(grid, start, end) 198 >>> grid = [ ... [' ', ' ', ' ', ' '], ... [' ', '#', '#', ' '], ... [' ', ' ', '#', ' '], ... [' ', ' ', ' ', ' '] ... ] >>> start = (0, 0) >>> end = (3, 3) >>> shortest_path(grid, start, end) 6 >>> grid = [ ... [' ', ' ', ' ', ' '], ... [' ', ' ', ' ', ' '], ... [' ', ' ', ' ', ' '], ... [' ', ' ', ' ', ' '] ... ] >>> start = (0, 0) >>> end = (3, 3) >>> shortest_path(grid, start, end) 6 pass","solution":"from collections import deque def shortest_path(grid, start, end): Finds the shortest path in a grid avoiding walls. Parameters: grid (list of lists of str): The grid, where ' ' is an empty cell and '#' is a wall. start (tuple): Starting cell (row, col). end (tuple): Ending cell (row, col). Returns: int: Length of the shortest path or -1 if no path exists. n, m = len(grid), len(grid[0]) queue = deque([(start[0], start[1], 0)]) # Store the coordinates and the distance visited = set() visited.add(start) # Define possible moves: up, down, left, right moves = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y, dist = queue.popleft() # Check if we reached the end point if (x, y) == end: return dist # Explore neighbors for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == ' ': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # If no path was found"},{"question":"def find_missing_numbers(n: int, arr: List[int]) -> Tuple[int, int]: Find the two missing numbers from the list containing numbers from 1 to n except two numbers. Args: n: The maximum number in the list (an integer). arr: An unsorted list of integers containing numbers from 1 to n except two numbers. Returns: A tuple containing the two missing numbers in ascending order. Example: >>> find_missing_numbers(7, [4, 3, 1, 2, 6]) (5, 7) >>> find_missing_numbers(5, [2, 3, 1]) (4, 5)","solution":"def find_missing_numbers(n, arr): Returns the two missing numbers from the list containing numbers from 1 to n except two numbers. total_sum = n * (n + 1) // 2 current_sum = sum(arr) sum_of_two_missing = total_sum - current_sum total_square_sum = n * (n + 1) * (2 * n + 1) // 6 current_square_sum = sum(x * x for x in arr) square_sum_of_two_missing = total_square_sum - current_square_sum # Solving the equations: # x + y = sum_of_two_missing # x^2 + y^2 = square_sum_of_two_missing x_plus_y = sum_of_two_missing x_square_plus_y_square = square_sum_of_two_missing # (x + y)^2 = x^2 + y^2 + 2xy # x^2 + y^2 = x_square_plus_y_square # 2xy = (x + y)^2 - x^2 - y^2 xy = (x_plus_y * x_plus_y - x_square_plus_y_square) // 2 # Now we have x + y and xy, solve the quadratic equation x^2 - (x+y)x + xy = 0 a = 1 b = -x_plus_y c = xy x = int((x_plus_y + (x_plus_y * x_plus_y - 4 * xy)**0.5) // 2) y = int((x_plus_y - (x_plus_y * x_plus_y - 4 * xy)**0.5) // 2) return min(x, y), max(x, y) # Example call to the function # find_missing_numbers(7, [4, 3, 1, 2, 6])"},{"question":"def longest_unique_subsequence(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Decompresses a compressed version of an array and returns the length of the longest contiguous subsequence of unique elements for each test case. >>> longest_unique_subsequence(2, [(3, [(1, 2), (2, 3), (1, 1)]), (2, [(3, 2), (3, 3)])]) [2, 1] >>> longest_unique_subsequence(1, [(1, [(1, 1)])]) [1]","solution":"def longest_unique_subsequence(t, test_cases): results = [] for i in range(t): m = test_cases[i][0] pairs = test_cases[i][1] decompressed = [] for x, k in pairs: decompressed.extend([x] * k) longest_unique = 0 current_unique = [] for num in decompressed: if num in current_unique: current_unique = current_unique[current_unique.index(num) + 1:] current_unique.append(num) longest_unique = max(longest_unique, len(current_unique)) results.append(longest_unique) return results"},{"question":"def can_place_traffic_lights(M: int, N: int, lights: List[Tuple[int, int]]) -> bool: In a bustling city, there is a rectangular grid of M x N intersections denoted by rows (1 to M) and columns (1 to N). Each intersection can either have a traffic light or be empty. The city administration decided to optimize traffic by ensuring that there is exactly one traffic light in each row and one in each column, making sure that traffic is evenly distributed. If given some intersections where traffic lights are already placed, you need to find out if it is possible to place the remaining traffic lights to meet the requirement. Args: M (int): number of rows N (int): number of columns lights (List[Tuple[int, int]]): list of tuples representing positions of installed traffic lights Returns: bool: True if it is possible to place the remaining traffic lights to meet the requirement, False otherwise. >>> can_place_traffic_lights(4, 4, [(1, 2), (2, 4), (3, 1), (4, 3)]) True >>> can_place_traffic_lights(3, 3, [(1, 1), (2, 2), (3, 3)]) True >>> can_place_traffic_lights(3, 3, [(1, 1), (2, 1), (3, 3)]) False >>> can_place_traffic_lights(2, 3, [(1, 1), (2, 2)]) False >>> can_place_traffic_lights(1, 1, [(1, 1)]) True >>> can_place_traffic_lights(3, 3, []) True","solution":"from typing import List, Tuple def can_place_traffic_lights(M: int, N: int, lights: List[Tuple[int, int]]) -> bool: if M != N: return False rows_with_lights = set() cols_with_lights = set() for r, c in lights: if r in rows_with_lights or c in cols_with_lights: return False rows_with_lights.add(r) cols_with_lights.add(c) return True"},{"question":"def find_partition_index(arr): Finds an index to partition the array such that the sum of elements in both subarrays is as close as possible. >>> find_partition_index([1, 2]) == 1 >>> find_partition_index([1, 1, 1, 1]) == 2 >>> find_partition_index([3, 1, 4, 1, 5, 9]) == 4 >>> find_partition_index([10]) == -1 >>> find_partition_index([100, 200]) == 1 >>> find_partition_index([3, 1, 2, 4, 3]) == 3 >>> find_partition_index([10, 5, 6, 2, 7, 1, 8]) >= 1 >>> find_partition_index([5, 5, 5, 5, 5, 5, 5, 5]) == 4 >>> find_partition_index([1, 1]) == 1","solution":"def find_partition_index(arr): Finds an index to partition the array such that the sum of elements in both subarrays is as close as possible. n = len(arr) total_sum = sum(arr) left_sum = 0 min_diff = float('inf') partition_index = -1 for i in range(n - 1): left_sum += arr[i] right_sum = total_sum - left_sum diff = abs(left_sum - right_sum) if diff < min_diff: min_diff = diff partition_index = i + 1 return partition_index"},{"question":"import math def minimum_tiles_required(n: int, m: int, a: int) -> int: Calculates the minimum number of square tiles of size a x a required to cover a rectangular garden of size n x m. >>> minimum_tiles_required(6, 6, 4) 4 >>> minimum_tiles_required(100, 100, 1) 10000 >>> minimum_tiles_required(8, 8, 4) 4 >>> minimum_tiles_required(7, 7, 4) 4 >>> minimum_tiles_required(3, 3, 1) 9 >>> minimum_tiles_required(1000000000, 1000000000, 1) 1000000000000000000 >>> minimum_tiles_required(10, 15, 4) 12","solution":"import math def minimum_tiles_required(n, m, a): Calculates the minimum number of square tiles of size a x a required to cover a rectangular garden of size n x m. Parameters: n (int): Garden length m (int): Garden width a (int): Tile side length Returns: int: Minimum number of tiles required tiles_along_length = math.ceil(n / a) tiles_along_width = math.ceil(m / a) return tiles_along_length * tiles_along_width"},{"question":"from typing import List def shortestPath(grid: List[List[int]]) -> int: Find the shortest path from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) in a grid where -1 represents an obstacle and 0 represents a street. Returns -1 if no path is possible. >>> grid = [ ... [0, 0, -1, 0], ... [0, -1, 0, 0], ... [0, 0, 0, 0] ... ] >>> shortestPath(grid) 5 >>> grid = [ ... [0, -1], ... [-1, 0] ... ] >>> shortestPath(grid) -1 def test_shortest_path_basic(): grid = [ [0, 0, -1, 0], [0, -1, 0, 0], [0, 0, 0, 0] ] assert shortestPath(grid) == 5 def test_shortest_path_no_path(): grid = [ [0, -1], [-1, 0] ] assert shortestPath(grid) == -1 def test_shortest_path_single_cell(): grid = [ [0] ] assert shortestPath(grid) == 0 def test_shortest_path_blocked_start(): grid = [ [-1, 0], [0, 0] ] assert shortestPath(grid) == -1 def test_shortest_path_blocked_end(): grid = [ [0, 0], [0, -1] ] assert shortestPath(grid) == -1 def test_shortest_path_larger_grid(): grid = [ [0, 0, 0], [0, -1, 0], [0, 0, 0] ] assert shortestPath(grid) == 4 def test_shortest_path_only_obstacles(): grid = [ [-1, -1, -1], [-1, -1, -1], [-1, -1, -1] ] assert shortestPath(grid) == -1 def test_shortest_path_all_clear(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert shortestPath(grid) == 4","solution":"from collections import deque from typing import List def shortestPath(grid: List[List[int]]) -> int: Find the shortest path in a grid from (0,0) to (n-1,m-1). -1 represents an obstacle and 0 represents a street. Uses BFS for shortest path calculation. if not grid or grid[0][0] == -1 or grid[-1][-1] == -1: return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == n-1 and c == m-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def shift_array_right(m: int, k: int, b: List[int]) -> List[int]: Shifts the array b to the right by k positions. Parameters: m (int): The number of elements in the array. k (int): The number of positions to shift the array. b (list): The array to be shifted. Returns: list: The shifted array. >>> shift_array_right(3, 2, [1, 2, 3]) == [2, 3, 1] >>> shift_array_right(4, 4, [4, 5, 6, 7]) == [4, 5, 6, 7]","solution":"def shift_array_right(m, k, b): Shifts the array b to the right by k positions. Parameters: m (int): The number of elements in the array. k (int): The number of positions to shift the array. b (list): The array to be shifted. Returns: list: The shifted array. k = k % m # When k >= m, shifting by k is the same as shifting by k % m return b[-k:] + b[:-k]"},{"question":"def longest_sortable_subarray(n: int, arr: List[int]) -> int: Find the length of the longest contiguous subarray such that if this subarray is sorted (either in non-decreasing or non-increasing order), the resulting contiguous subarray is also present in the array. Args: n: int: Length of the array arr: List[int]: The elements of the array Returns: int: Length of the longest sortable contiguous subarray >>> longest_sortable_subarray(5, [2, 1, 3, 4, 5]) == 4 >>> longest_sortable_subarray(6, [5, 4, 3, 2, 2, 1]) == 6","solution":"def longest_sortable_subarray(n, arr): def is_subarray_sorted(i, j): return arr[i:j+1] == sorted(arr[i:j+1]) or arr[i:j+1] == sorted(arr[i:j+1], reverse=True) max_len = 1 for i in range(n): for j in range(i+1, n): if is_subarray_sorted(i, j): max_len = max(max_len, j - i + 1) return max_len"},{"question":"def shortest_common_supersequence_length(n: int, A: List[int], B: List[int]) -> int: Calculates and returns the length of the shortest common supersequence of two sorted arrays A and B of length n. >>> shortest_common_supersequence_length(3, [1, 3, 5], [2, 4, 6]) 6 >>> shortest_common_supersequence_length(1, [1], [2]) 2","solution":"def shortest_common_supersequence_length(n, A, B): Calculates and returns the length of the shortest common supersequence of two sorted arrays A and B of length n. return 2 * n"},{"question":"class ArrayManipulation: def __init__(self, array): self.array = array def sum(self, l, r): Returns the sum of the elements in the subarray from index l to r (inclusive). Here, both l and r are 1-based indices. >>> arr = ArrayManipulation([1, 2, 3, 4, 5]) >>> arr.sum(1, 3) 6 >>> arr.sum(2, 4) 9 pass def update(self, i, x): Updates the element at index i (1-based index) to x. >>> arr = ArrayManipulation([1, 2, 3, 4, 5]) >>> arr.update(2, 10) >>> arr.array [1, 10, 3, 4, 5] pass import pytest def test_sum(): arr = ArrayManipulation([1, 2, 3, 4, 5]) assert arr.sum(1, 3) == 6 assert arr.sum(2, 4) == 9 def test_update(): arr = ArrayManipulation([1, 2, 3, 4, 5]) arr.update(2, 10) assert arr.array == [1, 10, 3, 4, 5] def test_sum_with_updates(): arr = ArrayManipulation([1, 2, 3, 4, 5]) arr.update(2, 10) assert arr.sum(2, 4) == 17 arr.update(5, 6) assert arr.sum(1, 5) == 24 if __name__ == \\"__main__\\": pytest.main()","solution":"class ArrayManipulation: def __init__(self, array): self.array = array def sum(self, l, r): Returns the sum of the elements in the subarray from index l to r (inclusive). Here, both l and r are 1-based indices. return sum(self.array[l-1:r]) def update(self, i, x): Updates the element at index i (1-based index) to x. self.array[i-1] = x"},{"question":"def dijkstra(n, graph, start): Use Dijkstra's algorithm to find the shortest paths from start to all other nodes. Parameters: n (int): Number of nodes in the graph. graph (dict): Adjacency list representation of the graph. start (int): The start node. Returns: list: List of shortest distance from start to each node. pass def find_optimal_storage_tree(n, m, edges): Find the tree where Nutty should store her nuts to minimize the maximum distance she needs to travel to any other tree. Parameters: n (int): Number of trees. m (int): Number of branches. edges (list): List of tuples (u, v, w) representing the branches. Returns: int: The minimum possible maximum distance. >>> find_optimal_storage_tree(1, 0, []) 0 >>> find_optimal_storage_tree(2, 1, [(1, 2, 10)]) 10 >>> find_optimal_storage_tree(3, 2, [(1, 2, 5), (2, 3, 5)]) 5 >>> find_optimal_storage_tree(3, 3, [(1, 2, 15), (2, 3, 20), (1, 3, 10)]) 15 >>> find_optimal_storage_tree(4, 4, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)]) 20 >>> find_optimal_storage_tree(5, 6, [ ... (1, 2, 1), ... (1, 3, 2), ... (2, 4, 1), ... (2, 5, 5), ... (3, 5, 1), ... (4, 5, 3) ... ]) 3 pass","solution":"import heapq def dijkstra(n, graph, start): Use Dijkstra's algorithm to find the shortest paths from start to all other nodes. Parameters: n (int): Number of nodes in the graph. graph (dict): Adjacency list representation of the graph. start (int): The start node. Returns: list: List of shortest distance from start to each node. distances = [float('inf')] * (n + 1) distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def find_optimal_storage_tree(n, m, edges): Find the tree where Nutty should store her nuts to minimize the maximum distance she needs to travel to any other tree. Parameters: n (int): Number of trees. m (int): Number of branches. edges (list): List of tuples (u, v, w) representing the branches. Returns: int: The minimum possible maximum distance. if n == 1: return 0 # Create the adjacency list representation of the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Calculate the maximum distance for each tree min_max_distances = float('inf') for i in range(1, n + 1): distances = dijkstra(n, graph, i)[1:] max_distance = max(distances) min_max_distances = min(min_max_distances, max_distance) return min_max_distances"},{"question":"def max_alternating_subsequence_length(n: int, sequence: List[int]) -> int: Returns the maximum length of an alternating subsequence from the given sequence. Parameters: n (int): The number of elements in the sequence. sequence (list): A list of n integers representing the sequence. Returns: int: The maximum length of an alternating subsequence. >>> max_alternating_subsequence_length(7, [1, -2, 3, -4, 5, -6, 7]) 7 >>> max_alternating_subsequence_length(4, [4, -1, 2, -5]) 4 >>> max_alternating_subsequence_length(5, [1, 2, 3, 4, 5]) 1 >>> max_alternating_subsequence_length(6, [-1, -2, -3, -4, -5, -6]) 1 >>> max_alternating_subsequence_length(1, [8]) 1 >>> max_alternating_subsequence_length(6, [-1, 2, -3, 4, -5, 6]) 6 >>> max_alternating_subsequence_length(7, [1, 2, -1, 2, -3, 4, 5]) 5 >>> max_alternating_subsequence_length(0, []) 0","solution":"def max_alternating_subsequence_length(n, sequence): Returns the maximum length of an alternating subsequence from the given sequence. Parameters: n (int): The number of elements in the sequence. sequence (list): A list of n integers representing the sequence. Returns: int: The maximum length of an alternating subsequence. if n == 0: return 0 max_length = 1 # A single element is always a valid subsequence for i in range(1, n): if (sequence[i] > 0 and sequence[i-1] < 0) or (sequence[i] < 0 and sequence[i-1] > 0): max_length += 1 return max_length"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def build_graph(n: int, edges: List[Tuple[int, int]]) -> dict: Build the graph from given number of attractions and walkways. >>> build_graph(5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)]) { 1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4] } def bfs_shortest_path(graph: dict, start: int, end: int) -> int: Find the shortest path between start and end nodes in the graph. >>> graph = build_graph(5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)]) >>> bfs_shortest_path(graph, 1, 5) 3 >>> bfs_shortest_path(graph, 1, 4) 2 def process_queries(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Process the queries to find out if a path exists and its shortest distance. >>> process_queries(5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)], [(1, 5), (1, 4), (2, 5), (1, 1), (2, 3)]) ['YES 3', 'YES 2', 'YES 2', 'YES 0', 'YES 2']","solution":"from collections import deque, defaultdict def build_graph(n, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) return graph def bfs_shortest_path(graph, start, end): if start == end: return 0 visited = set() queue = deque([(start, 0)]) while queue: node, distance = queue.popleft() if node == end: return distance for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1 def process_queries(n, edges, queries): graph = build_graph(n, edges) results = [] for start, end in queries: distance = bfs_shortest_path(graph, start, end) if distance == -1: results.append(\\"NO\\") else: results.append(f\\"YES {distance}\\") return results"},{"question":"def longest_descending_period(n: int, altitudes: List[int]) -> int: Determines the longest period of consecutive seconds during which Kevin's altitude only decreased. >>> longest_descending_period(7, [100, 90, 80, 70, 85, 80, 75]) 3 >>> longest_descending_period(5, [120, 120, 120, 120, 120]) 0 import pytest from solution import longest_descending_period def test_sample_input_1(): assert longest_descending_period(7, [100, 90, 80, 70, 85, 80, 75]) == 3 def test_sample_input_2(): assert longest_descending_period(5, [120, 120, 120, 120, 120]) == 0 def test_single_point(): assert longest_descending_period(1, [500]) == 0 def test_all_descend(): assert longest_descending_period(5, [500, 400, 300, 200, 100]) == 4 def test_no_descend(): assert longest_descending_period(4, [100, 200, 300, 400]) == 0 def test_mix_descend_and_ascend(): assert longest_descending_period(8, [1000, 800, 600, 700, 600, 500, 400, 500]) == 3 def test_multiple_equal_max_descend_periods(): assert longest_descending_period(10, [500, 400, 300, 300, 300, 400, 300, 200, 100, 100]) == 3","solution":"def longest_descending_period(n, altitudes): if n == 1: return 0 max_descend = 0 current_descend = 0 for i in range(1, n): if altitudes[i] < altitudes[i - 1]: current_descend += 1 max_descend = max(max_descend, current_descend) else: current_descend = 0 return max_descend"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Find the largest rectangular area in the histogram given by heights. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 def test_largest_rectangle_area_example_1(): assert largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_largest_rectangle_area_example_2(): assert largest_rectangle_area([2, 4]) == 4 def test_largest_rectangle_area_single_element(): assert largest_rectangle_area([1]) == 1 def test_largest_rectangle_area_all_same_height(): assert largest_rectangle_area([2, 2, 2, 2, 2]) == 10 def test_largest_rectangle_area_increasing_heights(): assert largest_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_largest_rectangle_area_decreasing_heights(): assert largest_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_largest_rectangle_area_varied_heights(): assert largest_rectangle_area([1, 3, 2, 1, 2]) == 5 def test_largest_rectangle_area_empty(): assert largest_rectangle_area([]) == 0","solution":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Find the largest rectangular area in the histogram given by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers from the array such that they add up to the target. >>> two_sum([2, 7, 11, 15], 9) in [(0, 1), (1, 0)] True >>> two_sum([3, 2, 4], 6) in [(1, 2), (2, 1)] True def solve_two_sum_problems(test_cases): Returns a list of tuples with the indices of the two numbers for each test case. >>> solve_two_sum_problems([([2, 7, 11, 15], 9), ([3, 2, 4], 6)]) [(0, 1), (1, 2)] def read_input(input_str): Reads the input string and returns a list of test cases. >>> read_input(\\"2n4n2 7 11 15n9n3n3 2 4n6n\\") [([2, 7, 11, 15], 9), ([3, 2, 4], 6)] def format_output(results): Formats the output list of tuples into a string with each result on a new line. >>> format_output([(0, 1), (1, 2)]) '0 1n1 2'","solution":"def two_sum(nums, target): Returns the indices of the two numbers from the array such that they add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return num_to_index[complement], index num_to_index[num] = index def solve_two_sum_problems(test_cases): results = [] for nums, target in test_cases: results.append(two_sum(nums, target)) return results # Reading input and formatting it def read_input(input_str): input_data = input_str.strip().split('n') t = int(input_data[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_data[index]) nums = list(map(int, input_data[index + 1].split())) target = int(input_data[index + 2]) test_cases.append((nums, target)) index += 3 return test_cases def format_output(results): return 'n'.join(f\\"{res[0]} {res[1]}\\" for res in results)"},{"question":"def calculate_union_area(rectangles: List[Tuple[int, int, int, int]]) -> int: Calculate the total area covered by the union of given rectangles. Args: rectangles (list of tuples): A list where each element is a tuple (x1, y1, x2, y2) representing the coordinates of a rectangle. Returns: int: The total area covered by the union of all rectangles. >>> calculate_union_area([(1, 1, 3, 3)]) 4 >>> calculate_union_area([(1, 1, 3, 3), (4, 4, 6, 6)]) 8 >>> calculate_union_area([(1, 1, 3, 3), (2, 2, 4, 4)]) 7 >>> calculate_union_area([(1, 1, 5, 5), (2, 2, 3, 3)]) 16 >>> calculate_union_area([(1, 1, 3, 3), (3, 1, 5, 3)]) 8 >>> rectangles = [(1, 1, 4, 4), (2, 2, 6, 5), (5, 1, 7, 3)] >>> calculate_union_area(rectangles) 20 >>> rectangles = [(0, 0, 10000, 10000) for _ in range(1000)] >>> calculate_union_area(rectangles) 100000000","solution":"def calculate_union_area(rectangles): Calculate the total area covered by the union of given rectangles. Args: rectangles (list of tuples): A list where each element is a tuple (x1, y1, x2, y2) representing the coordinates of a rectangle. Returns: int: The total area covered by the union of all rectangles. events = [] for x1, y1, x2, y2 in rectangles: events.append((x1, 'start', y1, y2)) events.append((x2, 'end', y1, y2)) events.sort() active_intervals = [] prev_x = events[0][0] total_area = 0 def calculate_active_length(active_intervals): active_intervals.sort() current_start = current_end = None total_length = 0 for start, end in active_intervals: if current_end is None: current_start, current_end = start, end else: if start > current_end: total_length += current_end - current_start current_start, current_end = start, end else: current_end = max(current_end, end) if current_end is not None: total_length += current_end - current_start return total_length for x, typ, y1, y2 in events: total_area += (x - prev_x) * calculate_active_length(active_intervals) if typ == 'start': active_intervals.append((y1, y2)) else: active_intervals.remove((y1, y2)) prev_x = x return total_area"},{"question":"from typing import List def min_subarray_length(arr: List[int], x: int) -> int: Returns the length of the smallest contiguous subarray with a sum >= x. If no such subarray exists, returns 0. Parameters: arr (List[int]): List of positive integers representing the array. x (int): The target sum. Returns: int: Length of the smallest contiguous subarray with sum >= x or 0 if none exists. Examples: >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 1, 1, 1, 1, 1], 10) 0 >>> min_subarray_length([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_length([10, 2, 3], 10) 1 >>> min_subarray_length([5, 1, 3, 4, 2], 5) 1 >>> min_subarray_length([1, 4, 4], 8) 2 >>> min_subarray_length([100, 200, 300, 400], 500) 2","solution":"def min_subarray_length(arr, x): Returns the length of the smallest contiguous subarray with a sum >= x. If no such subarray exists, returns 0. n = len(arr) min_length = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= x: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def largest_common_subsequence(s1: str, s2: str) -> str: Returns the longest common subsequence (LCS) of two strings s1 and s2. >>> largest_common_subsequence(\\"abcde\\", \\"ace\\") \\"ace\\" >>> largest_common_subsequence(\\"abc\\", \\"abc\\") \\"abc\\" >>> largest_common_subsequence(\\"abc\\", \\"def\\") \\"\\" >>> largest_common_subsequence(\\"abcdaf\\", \\"acbcf\\") \\"abcf\\" >>> largest_common_subsequence(\\"a\\", \\"a\\") \\"a\\" >>> largest_common_subsequence(\\"a\\", \\"b\\") \\"\\" >>> largest_common_subsequence(\\"abcdefg\\", \\"xyzab\\") in [\\"ab\\", \\"a\\", \\"b\\"]","solution":"def largest_common_subsequence(s1, s2): Returns the longest common subsequence (LCS) of two strings s1 and s2. m, n = len(s1), len(s2) dp = [[\\"\\" for _ in range(n + 1)] for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + s1[i - 1] else: dp[i][j] = dp[i - 1][j] if len(dp[i - 1][j]) > len(dp[i][j - 1]) else dp[i][j - 1] return dp[m][n]"},{"question":"def smallest_kxk_submatrix_sum(n: int, m: int, k: int, matrix: List[List[int]]) -> int: Find the smallest sum of any submatrix that is at least k x k in size from a given n x m matrix. Parameters: n (int): The number of rows in the matrix. m (int): The number of columns in the matrix. k (int): The minimum submatrix size. matrix (List[List[int]]): The input matrix filled with non-negative integers. Returns: int: The smallest sum of any submatrix of at least k x k in size. >>> smallest_kxk_submatrix_sum(4, 5, 2, [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20] ... ]) 16 >>> >>> smallest_kxk_submatrix_sum(3, 3, 2, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 12 >>> >>> smallest_kxk_submatrix_sum(2, 2, 2, [ ... [1, 2], ... [3, 4] ... ]) 10 >>> >>> smallest_kxk_submatrix_sum(3, 3, 1, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 1 >>> >>> smallest_kxk_submatrix_sum(5, 5, 3, [ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ]) 0 >>>","solution":"def smallest_kxk_submatrix_sum(n, m, k, matrix): # Create a prefix sum matrix prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = (matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) # Initialize the minimum sum to a large value min_sum = float('inf') # Iterate through all possible top-left corners of k x k submatrices for i in range(k, n + 1): for j in range(k, m + 1): # Calculate the sum of the submatrix ending at (i, j) submatrix_sum = (prefix_sum[i][j] - prefix_sum[i - k][j] - prefix_sum[i][j - k] + prefix_sum[i - k][j - k]) # Update the minimum sum if we find a smaller sum if submatrix_sum < min_sum: min_sum = submatrix_sum return min_sum"},{"question":"from typing import List, Tuple def process_inventory_updates( initial_inventory: List[Tuple[str, int]], update_instructions: List[str] ) -> List[Tuple[str, int]]: Processes the initial inventory and update instructions to return the final state of the inventory sorted by product ID. :param initial_inventory: List of tuples where each tuple contains (product_id, quantity) :param update_instructions: List of instructions in the format [\\"command product_id quantity\\"] :return: List of tuples with the final inventory sorted by product_id lexicographically. pass def test_process_inventory_updates_example_case(): initial_inventory = [(\\"p1\\", 10), (\\"p2\\", 15), (\\"p3\\", 5)] update_instructions = [ \\"add p2 5\\", \\"update p3 20\\", \\"add p4 7\\", \\"update p5 12\\" ] result = process_inventory_updates(initial_inventory, update_instructions) expected_result = [(\\"p1\\", 10), (\\"p2\\", 20), (\\"p3\\", 20), (\\"p4\\", 7), (\\"p5\\", 12)] assert result == expected_result def test_process_inventory_updates_only_add(): initial_inventory = [(\\"p1\\", 10)] update_instructions = [ \\"add p2 5\\", \\"add p1 5\\", \\"add p3 10\\" ] result = process_inventory_updates(initial_inventory, update_instructions) expected_result = [(\\"p1\\", 15), (\\"p2\\", 5), (\\"p3\\", 10)] assert result == expected_result def test_process_inventory_updates_only_update(): initial_inventory = [(\\"p1\\", 10)] update_instructions = [ \\"update p2 5\\", \\"update p1 20\\", \\"update p3 10\\" ] result = process_inventory_updates(initial_inventory, update_instructions) expected_result = [(\\"p1\\", 20), (\\"p2\\", 5), (\\"p3\\", 10)] assert result == expected_result def test_process_inventory_updates_mixed_commands(): initial_inventory = [(\\"p1\\", 10), (\\"p2\\", 15)] update_instructions = [ \\"add p2 10\\", \\"update p3 5\\", \\"add p3 10\\", \\"update p1 1\\" ] result = process_inventory_updates(initial_inventory, update_instructions) expected_result = [(\\"p1\\", 1), (\\"p2\\", 25), (\\"p3\\", 15)] assert result == expected_result def test_process_inventory_updates_no_initial_inventory(): initial_inventory = [] update_instructions = [ \\"add p1 10\\", \\"update p2 5\\", \\"add p3 7\\" ] result = process_inventory_updates(initial_inventory, update_instructions) expected_result = [(\\"p1\\", 10), (\\"p2\\", 5), (\\"p3\\", 7)] assert result == expected_result","solution":"def process_inventory_updates(initial_inventory, update_instructions): Processes the initial inventory and update instructions to return the final state of the inventory sorted by product ID. :param initial_inventory: List of tuples where each tuple contains (product_id, quantity) :param update_instructions: List of instructions in the format [\\"command product_id quantity\\"] :return: List of tuples with the final inventory sorted by product_id lexicographically. inventory = {} # Initialize the inventory for pid, qty in initial_inventory: inventory[pid] = qty # Process update instructions for instruction in update_instructions: parts = instruction.split() command, pid, qty = parts[0], parts[1], int(parts[2]) if command == \\"add\\": if pid in inventory: inventory[pid] += qty else: inventory[pid] = qty elif command == \\"update\\": inventory[pid] = qty # Convert inventory to sorted list of tuples final_inventory = sorted(inventory.items()) return final_inventory"},{"question":"def has_pair_with_sum(numbers: List[int], k: int) -> str: Determine if there exist two distinct indices i and j in the list such that numbers[i] + numbers[j] = k. >>> has_pair_with_sum([2, 7, 11, 15, 1], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) \\"NO\\"","solution":"def has_pair_with_sum(numbers, k): Determine if there exist two distinct indices i and j in the list such that numbers[i] + numbers[j] = k. :param numbers: List of integers. :param k: Integer, the target sum. :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for number in numbers: if k - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def is_valid_bst_inorder(inorder_sequence: List[int]) -> str: Determine if the given inorder traversal can represent a valid BST. Parameters: inorder_sequence (list): A list of unique positive integers. Returns: str: \\"YES\\" if the inorder traversal can form a valid BST, \\"NO\\" otherwise. >>> is_valid_bst_inorder([1, 2, 3, 4, 5, 6, 7]) \\"YES\\" >>> is_valid_bst_inorder([7, 3, 12, 5, 10, 9, 15, 8]) \\"NO\\" >>> is_valid_bst_inorder([42]) \\"YES\\" >>> is_valid_bst_inorder([1, 2]) \\"YES\\" >>> is_valid_bst_inorder([2, 1]) \\"NO\\" >>> is_valid_bst_inorder([1, 2, 2, 3]) \\"NO\\" >>> is_valid_bst_inorder([4, 2, 5, 3]) \\"NO\\"","solution":"def is_valid_bst_inorder(inorder_sequence): Determine if the given inorder traversal can represent a valid BST. Parameters: inorder_sequence (list): A list of unique positive integers. Returns: str: \\"YES\\" if the inorder traversal can form a valid BST, \\"NO\\" otherwise. for i in range(1, len(inorder_sequence)): if inorder_sequence[i] <= inorder_sequence[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"def add_digits(num: int) -> int: Repeatedly adds all its digits until the result has only one digit. >>> add_digits(38) 2 >>> add_digits(12345) 6 >>> add_digits(7) 7 >>> add_digits(0) 0 >>> add_digits(987654321) 9 >>> add_digits(19) 1","solution":"def add_digits(num): This function repeatedly adds all digits of a given number until the result has only one digit. while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"def find_subarray_with_sum_k(arr, k): Returns the starting and ending indices (1-based) of the subarray whose sum is exactly k. If no such subarray exists, return -1. >>> find_subarray_with_sum_k([1, 2, 3, 7, 5], 12) (2, 4) >>> find_subarray_with_sum_k([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) (1, 5) >>> find_subarray_with_sum_k([1, 2, 3, 4, 5], 9) (2, 4) >>> find_subarray_with_sum_k([1, 2, 3, 4, 5], 20) -1 >>> find_subarray_with_sum_k([10, 2, 3, 4, 10], 10) (1, 1) pass def process_test_cases(test_cases): Processes multiple test cases and returns results for each case. >>> process_test_cases([ (5, 12, [1, 2, 3, 7, 5]), (10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ]) [(2, 4), (1, 5)] pass from solution import find_subarray_with_sum_k, process_test_cases def test_find_subarray_with_sum_k(): assert find_subarray_with_sum_k([1, 2, 3, 7, 5], 12) == (2, 4) assert find_subarray_with_sum_k([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) == (1, 5) assert find_subarray_with_sum_k([1, 2, 3, 4, 5], 9) == (2, 4) assert find_subarray_with_sum_k([1, 2, 3, 4, 5], 20) == -1 assert find_subarray_with_sum_k([10, 2, 3, 4, 10], 10) == (1, 1) def test_process_test_cases(): test_cases = [ (5, 12, [1, 2, 3, 7, 5]), (10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), (5, 9, [1, 2, 3, 4, 5]), (5, 20, [1, 2, 3, 4, 5]), (5, 10, [10, 2, 3, 4, 10]) ] expected_results = [ (2, 4), (1, 5), (2, 4), -1, (1, 1) ] assert process_test_cases(test_cases) == expected_results","solution":"def find_subarray_with_sum_k(arr, k): Returns the starting and ending indices (1-based) of the subarray whose sum is exactly k. If no such subarray exists, return -1. current_sum = 0 start = 0 for end in range(len(arr)): current_sum += arr[end] while current_sum > k and start <= end: current_sum -= arr[start] start += 1 if current_sum == k: return (start + 1, end + 1) return -1 def process_test_cases(test_cases): Processes multiple test cases and returns results for each case. results = [] for n, k, arr in test_cases: result = find_subarray_with_sum_k(arr, k) results.append(result) return results"},{"question":"def max_sum_subarray(arr, n, m): Returns the maximum sum of a subarray of length exactly m. n - length of the array m - length of subarray >>> max_sum_subarray([1, 2, 3, 4, 5], 5, 3) 12 >>> max_sum_subarray([-1, -2, -3, -4, -5], 5, 2) -3 >>> max_sum_subarray([1, 2, 3, 4, 5, 6, 7], 7, 4) 22 >>> max_sum_subarray([4, 3, 2, 1], 4, 2) 7 pass def process_test_cases(t, test_cases): Processes multiple test cases and returns the results. t - number of test cases test_cases - list of tuples containing (n, m) and arr >>> test_cases = [ ... ((5, 3), [1, 2, 3, 4, 5]), ... ((5, 2), [-1, -2, -3, -4, -5]), ... ((7, 4), [1, 2, 3, 4, 5, 6, 7]), ... ((4, 2), [4, 3, 2, 1]) ... ] >>> process_test_cases(4, test_cases) [12, -3, 22, 7] pass","solution":"def max_sum_subarray(arr, n, m): Returns the maximum sum of a subarray of length exactly m. n - length of the array m - length of subarray # Calculate the sum of the first 'm' elements. max_sum = curr_sum = sum(arr[:m]) # Use sliding window to find the maximum sum of a subarray of length m. for i in range(1, n - m + 1): curr_sum = curr_sum - arr[i - 1] + arr[i + m - 1] max_sum = max(max_sum, curr_sum) return max_sum def process_test_cases(t, test_cases): results = [] for case in test_cases: n, m = case[0] arr = case[1] results.append(max_sum_subarray(arr, n, m)) return results"},{"question":"from typing import List, Tuple, Union def find_shortest_routes(N: int, M: int, Q: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[Union[int, str]]: Find the shortest route from a starting intersection S to a destination intersection D. The input is: - N: Number of intersections - M: Number of bi-directional roads - Q: Number of queries - roads: List of tuples (u, v, w) representing a road between intersections u and v with length w - queries: List of tuples (S, D) representing the queries to find the shortest route from S to D >>> find_shortest_routes(4, 2, 1, [(1, 2, 5), (3, 4, 7)], [(1, 4)]) [\\"NO PATH\\"] >>> find_shortest_routes(5, 6, 1, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)], [(1, 5)]) [6] >>> find_shortest_routes(3, 3, 2, [(1, 2, 1), (2, 3, 2), (1, 3, 4)], [(1, 3), (3, 1)]) [3, 3] >>> find_shortest_routes(3, 3, 1, [(1, 2, 1), (2, 3, 2), (1, 3, 4)], [(1, 1)]) [0]","solution":"import heapq from typing import List, Tuple, Union def dijkstra(graph: List[List[Tuple[int, int]]], start: int) -> List[Union[int, float]]: N = len(graph) distances = [float('inf')] * N distances[start] = 0 priority_queue = [(0, start)] # (distance, vertex) while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for weight, v in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(priority_queue, (distance, v)) return distances def find_shortest_routes(N: int, M: int, Q: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[Union[int, str]]: graph = [[] for _ in range(N)] for u, v, w in roads: graph[u - 1].append((w, v - 1)) graph[v - 1].append((w, u - 1)) results = [] for S, D in queries: distances = dijkstra(graph, S - 1) if distances[D - 1] == float('inf'): results.append(\\"NO PATH\\") else: results.append(distances[D - 1]) return results"},{"question":"def max_width(tree: Tuple) -> int: Returns the maximum width of the binary tree. A node in the binary tree is represented as a tuple containing its value, left child, and right child, respectively. For example: (value, left_child, right_child) The width of the binary tree is the maximum number of nodes present in any level of the tree. :param tree: The root of the binary tree. :return: The maximum width of any level in the binary tree. pass # Example Test Cases def test_max_width_empty_tree(): assert max_width(None) == 0 def test_max_width_single_node(): assert max_width((1, None, None)) == 1 def test_max_width_full_binary_tree(): tree = (1, (2, (4, None, None), (5, None, None)), (3, (6, None, None), (7, None, None))) assert max_width(tree) == 4 def test_max_width_unbalanced_tree(): tree = (1, (2, (4, (8, None, None), None), (5, None, None)), (3, None, (7, None, None))) assert max_width(tree) == 3 def test_max_width_right_leaning_tree(): tree = (1, None, (2, None, (3, None, (4, None, None)))) assert max_width(tree) == 1 def test_max_width_left_leaning_tree(): tree = (1, (2, (3, (4, None, None), None), None), None) assert max_width(tree) == 1","solution":"from collections import deque from typing import Tuple def max_width(tree: Tuple) -> int: Returns the maximum width of the binary tree. A node in the binary tree is represented as a tuple containing its value, left child, and right child, respectively. For example: (value, left_child, right_child) The width of the binary tree is the maximum number of nodes present in any level of the tree. :param tree: The root of the binary tree. :return: The maximum width of any level in the binary tree. if not tree: return 0 max_width = 0 queue = deque([(tree, 0)]) while queue: level_length = len(queue) max_width = max(max_width, level_length) for _ in range(level_length): node, level = queue.popleft() if node: value, left, right = node if left: queue.append((left, level + 1)) if right: queue.append((right, level + 1)) return max_width"},{"question":"def min_operations_to_identical(s: str) -> int: Returns the minimum number of operations required to make all characters in the string identical. >>> min_operations_to_identical(\\"aabbbc\\") 2 >>> min_operations_to_identical(\\"aaaaa\\") 0 >>> min_operations_to_identical(\\"ab\\") 1 def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns the list of results for each test case. >>> process_test_cases([\\"aabbbc\\", \\"aaaaa\\", \\"ab\\"]) [2, 0, 1]","solution":"def min_operations_to_identical(s): Returns the minimum number of operations required to make all characters in the string identical. return len(set(s)) - 1 def process_test_cases(test_cases): Processes a list of test cases and returns the list of results for each test case. results = [] for s in test_cases: results.append(min_operations_to_identical(s)) return results"},{"question":"from typing import List, Tuple def count_cows_in_region(n: int, m: int, q: int, cows: List[Tuple[int, int]], checkpoints: List[Tuple[int, int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Returns a list of integers where each integer represents the number of cows located within the specified rectangular region for each query. Args: n : int : number of cows m : int : number of checkpoints q : int : number of queries cows : List[Tuple[int, int]] : list of coordinates of cows checkpoints : List[Tuple[int, int]] : list of coordinates of checkpoints queries : List[Tuple[int, int, int, int]] : list of rectangular regions specified by bottom-left and top-right corners Returns: list : List of integers where each integer is the count of cows within the region specified by the corresponding query Example: >>> count_cows_in_region(3, 2, 1, [(1, 3), (4, 4), (5, 6)], [(1, 3), (5, 5)], [(1, 1, 5, 5)]) [2] >>> count_cows_in_region(2, 1, 2, [(1, 1), (3, 3)], [(1, 2)], [(1, 1, 2, 2), (2, 2, 3, 3)]) [1, 1] pass","solution":"def count_cows_in_region(n, m, q, cows, checkpoints, queries): count_results = [] for query in queries: x1, y1, x2, y2 = query count = 0 for cow in cows: cx, cy = cow if x1 <= cx <= x2 and y1 <= cy <= y2: count += 1 count_results.append(count) return count_results"},{"question":"def minimum_swaps_to_achieve_condition(n: int, d: int, heights: List[int]) -> int: Returns the minimum number of swaps needed to rearrange the students so that no two adjacent students have a height difference greater than d. If it's not possible, return -1. >>> minimum_swaps_to_achieve_condition(5, 3, [4, 8, 5, 1, 7]) 2 >>> minimum_swaps_to_achieve_condition(3, 1, [5, 1, 10]) -1 >>> minimum_swaps_to_achieve_condition(4, 2, [1, 3, 5, 2]) 1 >>> minimum_swaps_to_achieve_condition(2, 5, [7, 3]) 0 >>> minimum_swaps_to_achieve_condition(3, 2, [4, 7, 5]) 1","solution":"def minimum_swaps_to_achieve_condition(n, d, heights): Returns the minimum number of swaps needed to rearrange the students so that no two adjacent students have a height difference greater than d. If it's not possible, return -1. def is_valid(arr, d): for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) > d: return False return True from queue import PriorityQueue pq = PriorityQueue() pq.put((0, heights)) # (number of swaps, current heights arrangement) visited = set() visited.add(tuple(heights)) while not pq.empty(): swaps, current = pq.get() if is_valid(current, d): return swaps for i in range(n): for j in range(i+1, n): new_arr = current[:] new_arr[i], new_arr[j] = new_arr[j], new_arr[i] new_tuple = tuple(new_arr) if new_tuple not in visited: visited.add(new_tuple) pq.put((swaps + 1, new_arr)) return -1"},{"question":"from typing import List def isPathSameCharacter(matrix: List[List[str]]) -> bool: Determine if there exists a path from the top-left to bottom-right corner such that each cell in the path contains the same character. >>> matrix = [ ... ['a', 'a', 'b'], ... ['a', 'a', 'a'], ... ['b', 'a', 'a'] ... ] >>> isPathSameCharacter(matrix) True >>> matrix = [ ... ['a', 'b', 'a'], ... ['b', 'a', 'b'], ... ['a', 'b', 'a'] ... ] >>> isPathSameCharacter(matrix) False >>> matrix = [ ... ['a', 'a', 'a'] ... ] >>> isPathSameCharacter(matrix) True >>> matrix = [ ... ['a'], ... ['a'], ... ['a'] ... ] >>> isPathSameCharacter(matrix) True >>> matrix = [] >>> isPathSameCharacter(matrix) False >>> matrix = [ ... ['a', 'a'], ... ['a', 'a'] ... ] >>> isPathSameCharacter(matrix) True >>> matrix = [ ... ['a', 'b'], ... ['a', 'b'] ... ] >>> isPathSameCharacter(matrix) False >>> matrix = [ ... ['a', 'a', 'a', 'a'], ... ['b', 'b', 'a', 'b'], ... ['a', 'b', 'a', 'a'], ... ['a', 'b', 'a', 'a'] ... ] >>> isPathSameCharacter(matrix) True","solution":"from typing import List def isPathSameCharacter(matrix: List[List[str]]) -> bool: Determine if there exists a path from the top-left to bottom-right corner such that each cell in the path contains the same character. if not matrix or not matrix[0]: return False m, n = len(matrix), len(matrix[0]) char = matrix[0][0] # Use a set to mark the visited positions visited = set() def dfs(x, y): if x >= m or y >= n: return False if (x, y) in visited or matrix[x][y] != char: return False if x == m - 1 and y == n - 1: return True visited.add((x, y)) # Move right or down return dfs(x + 1, y) or dfs(x, y + 1) return dfs(0, 0)"},{"question":"def minimum_additional_cables_needed(n, m, connections): Determine the minimum additional cables needed to be installed to ensure redundancy for every pair of computers. Args: n (int): The number of computers. m (int): The number of existing cables. connections (List[Tuple[int, int]]): A list of tuples representing the cables that connect two computers. Returns: int: The minimum number of additional cables required. Examples: >>> minimum_additional_cables_needed(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> minimum_additional_cables_needed(3, 3, [(1, 2), (2, 3), (1, 3)]) 0 >>> minimum_additional_cables_needed(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) 1 >>> minimum_additional_cables_needed(8, 5, [(1, 2), (2, 3), (4, 5), (6, 7), (7, 8)]) 2 # Implement the function here","solution":"def minimum_additional_cables_needed(n, m, connections): from collections import defaultdict, deque def bfs_component(component_graph, start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in component_graph[node]: if neighbor not in visited: queue.append(neighbor) return visited graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Find all connected components all_nodes = set(range(1, n + 1)) components = [] while all_nodes: start = all_nodes.pop() component = bfs_component(graph, start) components.append(component) all_nodes -= component # To fully connect k components, we need at least (k-1) cables num_components = len(components) return max(0, num_components - 1)"},{"question":"def find_fruit_pair(n: int, fruits: list, k: int) -> list: Returns a pair of different types of fruits whose combined sum equals k. Parameters: n (int): Number of different types of fruits. fruits (list): List of integers representing the types of fruits present. k (int): The magical number. Returns: list: A list of two integers representing the types of fruits in ascending order, or an empty list if no such pair exists. >>> find_fruit_pair(5, [4, 7, 11, 15, 18], 22) [4, 18] >>> find_fruit_pair(4, [1, 2, 3, 5], 8) [3, 5] >>> find_fruit_pair(3, [1, 7, 11], 18) [7, 11] >>> find_fruit_pair(5, [4, 7, 11, 15, 18], 50) [] >>> find_fruit_pair(4, [1, 2, 3, 5], 10) [] >>> find_fruit_pair(3, [1, 1, 1], 3) []","solution":"def find_fruit_pair(n, fruits, k): Returns a pair of different types of fruits whose combined sum equals k. Parameters: n (int): Number of different types of fruits. fruits (list): List of integers representing the types of fruits present. k (int): The magical number. Returns: list: A list of two integers representing the types of fruits in ascending order, or an empty list if no such pair exists. fruit_set = set(fruits) for fruit in fruits: if (k - fruit) in fruit_set and fruit != (k - fruit): return sorted([fruit, k - fruit]) return [] # Example Usage n = 5 fruits = [4, 7, 11, 15, 18] k = 22 print(find_fruit_pair(n, fruits, k)) # Output: [4, 18]"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner (0,0) to the bottom-right corner (n-1,n-1) in an n x n grid. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_path_sum([[1, 2], [1, 2]]) == 4 def process_test_cases(test_cases: List[List[List[int]]]) -> List[int]: Processes a list of test cases and returns the minimum path sum for each case. >>> process_test_cases([[[1, 3, 1], [1, 5, 1], [4, 2, 1]], [[1, 2], [1, 2]]]) == [7, 4]","solution":"def min_path_sum(grid): Returns the length of the shortest path from the top-left corner (0,0) to the bottom-right corner (n-1,n-1) in an n x n grid. n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Iterate over the rest of the grid for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] def process_test_cases(test_cases): results = [] for grid in test_cases: results.append(min_path_sum(grid)) return results"},{"question":"def smallest_substring_length_with_all_distinct_chars(s: str) -> int: Finds the length of the smallest substring that contains all distinct characters of the string \`s\`. >>> smallest_substring_length_with_all_distinct_chars(\\"abcabcbb\\") 3 >>> smallest_substring_length_with_all_distinct_chars(\\"aabcbcdbca\\") 4","solution":"def smallest_substring_length_with_all_distinct_chars(s): Finds the length of the smallest substring that contains all distinct characters of the string \`s\`. from collections import defaultdict # Get the number of unique characters in s unique_chars = set(s) num_unique_chars = len(unique_chars) # Variables to maintain the sliding window left = 0 min_length = float('inf') char_count = defaultdict(int) distinct_count = 0 # Expand the window by moving right for right in range(len(s)): if char_count[s[right]] == 0: distinct_count += 1 char_count[s[right]] += 1 # When all unique characters are included in window, move left to minimize the window size while distinct_count == num_unique_chars and left <= right: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 return min_length"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> str: Determines if there is a pair of distinct elements in the array whose sum is exactly the target. >>> has_pair_with_sum([1, 2, 3, 7, 8], 10) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 10) \\"NO\\" def test_sample_case(): assert has_pair_with_sum([1, 2, 3, 7, 8], 10) == \\"YES\\" def test_no_pair_exists(): assert has_pair_with_sum([1, 2, 3, 4], 10) == \\"NO\\" def test_pair_with_first_last_elements(): assert has_pair_with_sum([1, 4, 6, 8, 2], 3) == \\"YES\\" def test_multiple_valid_pairs(): assert has_pair_with_sum([1, 5, 6, 7, 2], 8) == \\"YES\\" def test_single_element(): assert has_pair_with_sum([5], 5) == \\"NO\\" def test_all_elements_same(): assert has_pair_with_sum([2, 2, 2, 2], 4) == \\"YES\\" def test_large_numbers(): assert has_pair_with_sum([100000, 100000], 200000) == \\"YES\\" def test_negative_numbers(): assert has_pair_with_sum([-1, -2, -3, -4], -7) == \\"YES\\" def test_mix_positive_and_negative_numbers(): assert has_pair_with_sum([-3, 1, 2, 5], 2) == \\"YES\\" def test_no_pair_due_to_duplicate_values(): assert has_pair_with_sum([3, 3, 3, 3], 5) == \\"NO\\"","solution":"def has_pair_with_sum(arr, target): Determines if there is a pair of distinct elements in the array whose sum is exactly the target. :param arr: List of integers :param target: Integer target sum :return: \\"YES\\" if there is a pair, otherwise \\"NO\\" seen_numbers = set() for num in arr: complement = target - num if complement in seen_numbers: return \\"YES\\" seen_numbers.add(num) return \\"NO\\""},{"question":"def dijkstra(n, adjacency_matrix, start, end): Implement Dijkstra's algorithm to find the shortest path from start to end node. :param n: integer, number of nodes in the graph :param adjacency_matrix: n x n integer matrix, adjacency matrix representation of the graph :param start: integer, starting node :param end: integer, ending node :return: integer, minimum distance from start to end node. If no path, return -1. >>> dijkstra(5, [[0, 10, 0, 30, 100], [10, 0, 50, 0, 0], [0, 50, 0, 20, 10], [30, 0, 20, 0, 60], [100, 0, 10, 60, 0]], 0, 4) 60 >>> dijkstra(3, [[0, 10, 0], [10, 0, 0], [0, 0, 0]], 0, 2) -1 >>> dijkstra(4, [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 0, 0) 0 >>> dijkstra(4, [[0, 1, 0, 0], [1, 0, 2, 0], [0, 2, 0, 1], [0, 0, 1, 0]], 0, 2) 3 >>> dijkstra(4, [[0, 10, 0, 0], [10, 0, 0, 0], [0, 0, 0, 2], [0, 0, 2, 0]], 0, 3) -1","solution":"import heapq def dijkstra(n, adjacency_matrix, start, end): Implement Dijkstra's algorithm to find the shortest path from start to end node. # Distance to each node, initialized to infinity distances = [float('inf')] * n distances[start] = 0 # Min-heap priority queue pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) # Early exit if we reach the end node if current_node == end: return current_distance # If a node is processed with a distance greater than the current known distance, skip it if current_distance > distances[current_node]: continue # Visit all neighboring nodes for neighbor in range(n): weight = adjacency_matrix[current_node][neighbor] if weight > 0: distance = current_distance + weight # Only consider this new found path if it is shorter if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If the end node is unreachable, return -1 return -1 if distances[end] == float('inf') else distances[end]"},{"question":"def max_sum_subarray_divisible(arr: List[int], k: int, d: int) -> str: Determines if any subarray of length \`k\` in \`arr\` has the maximum sum that is divisible by \`d\`. Parameters: arr (list of int): The array of integers. k (int): The length of the subarray. d (int): The integer by which the sum of the subarray should be divisible. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". >>> max_sum_subarray_divisible([1, 2, 3, 4, 5, 6, 7, 8], 3, 3) \\"YES\\" >>> max_sum_subarray_divisible([1, 2, 3, 4, 5], 2, 6) \\"NO\\" # Test cases from solution import max_sum_subarray_divisible def test_example_case_1(): assert max_sum_subarray_divisible([1, 2, 3, 4, 5, 6, 7, 8], 3, 3) == \\"YES\\" def test_example_case_2(): assert max_sum_subarray_divisible([1, 2, 3, 4, 5], 2, 6) == \\"NO\\" def test_single_element_array(): assert max_sum_subarray_divisible([3], 1, 3) == \\"YES\\" def test_all_elements_same(): assert max_sum_subarray_divisible([4, 4, 4, 4, 4, 4, 4, 4], 4, 4) == \\"YES\\" def test_large_k(): assert max_sum_subarray_divisible([1, 2, 3, 4, 5, 6, 7, 8], 8, 36) == \\"YES\\" def test_no_valid_subarray(): assert max_sum_subarray_divisible([1, 2, 3, 4, 5], 3, 16) == \\"NO\\" def test_large_values(): assert max_sum_subarray_divisible([10000, 20000, 30000, -5000, 10000], 3, 1000) == \\"YES\\"","solution":"def max_sum_subarray_divisible(arr, k, d): Determines if any subarray of length \`k\` in \`arr\` has the maximum sum that is divisible by \`d\`. Parameters: arr (list of int): The array of integers. k (int): The length of the subarray. d (int): The integer by which the sum of the subarray should be divisible. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". n = len(arr) # Compute the initial sum of the first subarray of length \`k\` current_sum = sum(arr[:k]) max_sum = current_sum # Traverse the array to check all other subarrays of length \`k\` for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return \\"YES\\" if max_sum % d == 0 else \\"NO\\""},{"question":"def encrypt_message(shift: int, message: str) -> str: Encrypts the given message using a substitution cipher with the provided shift value. >>> encrypt_message(3, 'abc') 'def' >>> encrypt_message(4, 'xyz') 'bcd' >>> encrypt_message(1, 'abcd') 'bcde' >>> encrypt_message(25, 'abcd') 'zabc' >>> encrypt_message(2, 'hello') 'jgnnq' def process_test_cases(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Processes multiple test cases for the encryption function. >>> process_test_cases(2, [(3, 'abc'), (4, 'xyz')]) ['def', 'bcd'] >>> process_test_cases(3, [(1, 'hello'), (25, 'test'), (2, 'abcxyz')]) ['ifmmp', 'sdrs', 'cdezab'] >>> process_test_cases(2, [(25, 'a'), (1, 'z')]) ['z', 'a'] from solution import encrypt_message, process_test_cases def test_encrypt_message(): assert encrypt_message(3, 'abc') == 'def' assert encrypt_message(4, 'xyz') == 'bcd' assert encrypt_message(1, 'abcd') == 'bcde' assert encrypt_message(25, 'abcd') == 'zabc' assert encrypt_message(2, 'hello') == 'jgnnq' def test_process_test_cases(): input_data = [ (3, 'abc'), (4, 'xyz') ] t = 2 expected_output = ['def', 'bcd'] assert process_test_cases(t, input_data) == expected_output input_data = [ (1, 'hello'), (25, 'test'), (2, 'abcxyz') ] t = 3 expected_output = ['ifmmp', 'sdrs', 'cdezab'] assert process_test_cases(t, input_data) == expected_output def test_edge_cases(): assert encrypt_message(25, 'a') == 'z' assert encrypt_message(1, 'z') == 'a' input_data = [ (25, 'a'), (1, 'z') ] t = 2 expected_output = ['z', 'a'] assert process_test_cases(t, input_data) == expected_output","solution":"def encrypt_message(shift, message): Encrypts the given message using the substitution cipher with the provided shift value. shift: int - the number of positions to shift each letter. message: str - the message to be encrypted. Returns the encrypted message as a string. encrypted = [] for char in message: new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) encrypted.append(new_char) return ''.join(encrypted) def process_test_cases(t, test_cases): results = [] for i in range(t): shift, message = test_cases[i] result = encrypt_message(shift, message) results.append(result) return results"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the n x n matrix 90 degrees clockwise in-place. Args: matrix (List[List[int]]): the input n x n 2D matrix representing an image Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the n x n matrix 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def min_swaps(arr: List[int]) -> int: Returns the minimum number of swaps to sort the given list of distinct integers in ascending order. >>> min_swaps([4, 3, 1, 2]) 3 >>> min_swaps([1, 2, 3, 4]) 0 >>> min_swaps([4, 3, 2, 1]) 2 >>> min_swaps([1]) 0 >>> min_swaps([3, 1, 2, 4]) 2 >>> min_swaps([2, 3, 4, 1]) 3","solution":"def min_swaps(arr): Returns the minimum number of swaps to sort the given list of distinct integers in ascending order. n = len(arr) arr_pos = list(enumerate(arr)) arr_pos.sort(key=lambda x: x[1]) vis = {k: False for k in range(n)} ans = 0 for i in range(n): if vis[i] or arr_pos[i][0] == i: continue cycle_size = 0 j = i while not vis[j]: vis[j] = True j = arr_pos[j][0] cycle_size += 1 if cycle_size > 0: ans += (cycle_size - 1) return ans"},{"question":"def max_stack_heights(m, initial_heights, k, operations): Calculate the maximum height of stacks after each addition of boxes. Parameters: m (int): Number of initial stacks. initial_heights (List[int]): Initial heights of the stacks. k (int): Number of operations. operations (List[Tuple[int, int]]): List of operations, where each operation is a tuple (i, j) that represents adding 'j' boxes to stack 'i'. Returns: List[int]: The maximum height of any stack after each operation. >>> max_stack_heights(4, [5, 3, 7, 2], 3, [(2, 1), (3, 5), (1, 2)]) [7, 12, 12] >>> max_stack_heights(3, [1, 1, 1], 3, [(1, 2), (2, 3), (3, 4)]) [3, 4, 5] >>> max_stack_heights(4, [10, 2, 5, 7], 2, [(2, 1), (3, 2)]) [10, 10]","solution":"def max_stack_heights(m, initial_heights, k, operations): result = [] max_height = max(initial_heights) for i, j in operations: initial_heights[i-1] += j max_height = max(max_height, initial_heights[i-1]) result.append(max_height) return result"},{"question":"def longest_warming_period(n, temperatures): Returns the length of the longest period of continuous warming. Parameters: n (int): The number of days of temperature recordings. temperatures (list of int): The daily temperatures recorded over n days. Returns: int: The length of the longest period of continuous warming. >>> longest_warming_period(6, [1, -1, 2, 3, -4, 5]) 3 >>> longest_warming_period(5, [1, 2, 3, 4, 5]) 5 >>> longest_warming_period(5, [5, 4, 3, 2, 1]) 0 >>> longest_warming_period(7, [1, 2, 1, 2, 3, 4, 1]) 4","solution":"def longest_warming_period(n, temperatures): Returns the length of the longest period of continuous warming. Parameters: n (int): The number of days of temperature recordings. temperatures (list of int): The daily temperatures recorded over n days. Returns: int: The length of the longest period of continuous warming. if n == 1: return 1 if temperatures[0] < temperatures[0] else 0 max_length = 0 current_length = 1 for i in range(1, n): if temperatures[i] > temperatures[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length if max_length > 1 else 0"},{"question":"def min_bikes_needed(rentals): Determines the minimum number of bicycles needed to ensure no customers have to wait. Parameters: rentals (list of tuples): List where each tuple contains two integers representing the start and end times (si, ei) of bike rentals. Returns: int: Minimum number of bicycles needed. # Unit Tests def test_no_overlaps(): rentals = [ (0, 2), (2, 4), (4, 6) ] assert min_bikes_needed(rentals) == 1 def test_full_overlap(): rentals = [ (1, 4), (1, 4), (1, 4) ] assert min_bikes_needed(rentals) == 3 def test_partial_overlaps(): rentals = [ (1, 4), (2, 5), (5, 7), (6, 8) ] assert min_bikes_needed(rentals) == 2 def test_complex_case(): rentals = [ (0, 5), (1, 6), (2, 7), (3, 8), (4, 9) ] assert min_bikes_needed(rentals) == 5 def test_small_intervals(): rentals = [ (0, 1), (1, 2), (2, 3), (3, 4) ] assert min_bikes_needed(rentals) == 1 def test_large_interval(): rentals = [ (0, 1000000000), (1, 1000000000), (2, 1000000000) ] assert min_bikes_needed(rentals) == 3","solution":"def min_bikes_needed(rentals): Determines the minimum number of bicycles needed to ensure no customers have to wait. Parameters: rentals (list of tuples): List where each tuple contains two integers representing the start and end times (si, ei) of bike rentals. Returns: int: Minimum number of bicycles needed. events = [] for start, end in rentals: events.append((start, 1)) # +1 bike needed at the start of rental. events.append((end, -1)) # -1 bike needed at the end of rental. # Sort events first by time, using the second element as tiebreaker events.sort(key=lambda x: (x[0], x[1])) current_bikes = 0 max_bikes = 0 for event in events: current_bikes += event[1] max_bikes = max(max_bikes, current_bikes) return max_bikes # Example usage rentals = [ (1, 4), (2, 5), (5, 7), (6, 8) ] print(min_bikes_needed(rentals)) # Output: 2"},{"question":"def days_to_non_decreasing(n: int, flowers: List[int]) -> int: Calculate the number of days required for the number of flowers in all pots to become non-decreasing. Args: n (int): The number of flower pots. flowers (List[int]): The initial number of flowers in each pot. Returns: int: The number of days needed for all pots to have non-decreasing numbers of flowers. Examples: >>> days_to_non_decreasing(4, [1, 2, 1, 3]) 2 >>> days_to_non_decreasing(3, [1, 2, 3]) 1 >>> days_to_non_decreasing(3, [3, 2, 1]) 3 >>> days_to_non_decreasing(4, [2, 2, 2, 2]) 1 >>> days_to_non_decreasing(1, [5]) 1 >>> days_to_non_decreasing(3, [1000000, 999999, 1000000]) 2","solution":"def days_to_non_decreasing(n, flowers): days = 0 while True: days += 1 # Watering: increase all by 1 for i in range(n): flowers[i] += 1 # Pruning from right to left needs_pruning = False for i in range(n - 1): if flowers[i] > flowers[i + 1]: flowers[i] = flowers[i + 1] needs_pruning = True # Check if number of flowers is non-decreasing if not needs_pruning: break return days"},{"question":"from typing import List, Tuple def group_into_odd_pairs(permutation: List[int]) -> List[Tuple[int, int]]: Groups a permutation of integers into pairs such that the sum of the integers in each pair is odd. If it is not possible to pair the integers in this way, returns an empty list. >>> group_into_odd_pairs([1, 2]) [(1, 2)] >>> group_into_odd_pairs([4, 2, 1, 3]) [(1, 4), (3, 2)] >>> group_into_odd_pairs([1, 2, 3, 4, 5, 6]) [(5, 2), (3, 4), (1, 6)] >>> group_into_odd_pairs([2, 4, 6, 8]) []","solution":"from typing import List, Tuple def group_into_odd_pairs(permutation: List[int]) -> List[Tuple[int, int]]: # Split the permutation into odd and even numbers odd_numbers = [num for num in permutation if num % 2 != 0] even_numbers = [num for num in permutation if num % 2 == 0] # Check if the number of odd and even numbers are the same if len(odd_numbers) != len(even_numbers): return [] # Form the pairs pairs = [] for i in range(len(odd_numbers)): pairs.append((odd_numbers[i], even_numbers[i])) return pairs"},{"question":"def review_summary(reviews): You are given a list of integers \`reviews\` that represent the scores given by users to a Mobile App. The scores range from 1 to 5 inclusive. The developer of the app wants to analyze the popularity of their app. One way to analyze it is by generating a summary report that includes the count of each score. Write a program that takes the list of reviews as input and returns a dictionary with the scores as keys and their respective counts as values. If a score does not appear in the input list, its count should be zero in the output dictionary. >>> review_summary([1, 2, 4, 5, 2, 2, 3, 4, 1, 5, 5, 1]) {1: 3, 2: 3, 3: 1, 4: 2, 5: 3} >>> review_summary([1, 1, 2, 2, 5]) {1: 2, 2: 2, 3: 0, 4: 0, 5: 1} >>> review_summary([]) {1: 0, 2: 0, 3: 0, 4: 0, 5: 0} >>> review_summary([3]) {1: 0, 2: 0, 3: 1, 4: 0, 5: 0} >>> review_summary([5, 5, 5, 5]) {1: 0, 2: 0, 3: 0, 4: 0, 5: 4}","solution":"def review_summary(reviews): Returns a dictionary with scores as keys (from 1 to 5) and their respective counts in the reviews list as values. summary = {score: 0 for score in range(1, 6)} for review in reviews: if review in summary: summary[review] += 1 return summary"},{"question":"from typing import List, Tuple def max_payment(tasks: List[Tuple[int, int, int]]) -> int: Returns the maximum payment that can be achieved by selecting a subset of non-overlapping tasks. >>> max_payment([(1, 2, 50)]) == 50 >>> max_payment([(1, 3, 50), (3, 5, 60), (5, 6, 70)]) == 180 >>> max_payment([(1, 3, 50), (2, 5, 60), (3, 6, 70)]) == 120 >>> max_payment([(1, 3, 50), (2, 5, 60), (4, 6, 30)]) == 80 >>> max_payment([(1, 2, 20), (2, 3, 30), (3, 5, 60), (6, 7, 40)]) == 150","solution":"def max_payment(tasks): Returns the maximum payment that can be achieved by selecting a subset of non-overlapping tasks. # Sort the tasks based on end times tasks.sort(key=lambda x: x[1]) # dp array to store the maximum payment achievable until each task dp = [0] * len(tasks) dp[0] = tasks[0][2] # The payment for the first task, as it is the only one considered for i in range(1, len(tasks)): # Include the current task incl_payment = tasks[i][2] # Find the last non-conflicting task with the current task for j in range(i - 1, -1, -1): if tasks[j][1] <= tasks[i][0]: incl_payment += dp[j] break # Store the maximum of including or excluding the current task dp[i] = max(dp[i - 1], incl_payment) return dp[-1] # Read input from the user if __name__ == \\"__main__\\": n = int(input().strip()) tasks = [tuple(map(int, input().strip().split())) for _ in range(n)] print(max_payment(tasks))"},{"question":"def unique_letters_in_paths(grid: List[str]) -> int: Determine the number of unique letters that can be found along all possible paths in the grid, starting from the top-left corner and moving to the bottom-right corner. >>> unique_letters_in_paths([ ... \\"abc\\", ... \\"def\\" ... ]) 6 >>> unique_letters_in_paths([ ... \\"aaa\\", ... \\"aaa\\" ... ]) 1 pass def test_unique_letters_simple_case(): grid1 = [ \\"abc\\", \\"def\\" ] assert unique_letters_in_paths(grid1) == 6 def test_unique_letters_single_row(): grid2 = [ \\"abcdef\\" ] assert unique_letters_in_paths(grid2) == 6 def test_unique_letters_single_column(): grid3 = [ \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\" ] assert unique_letters_in_paths(grid3) == 6 def test_unique_letters_repeated_characters(): grid4 = [ \\"aaa\\", \\"aaa\\" ] assert unique_letters_in_paths(grid4) == 1 def test_unique_letters_large_grid(): grid5 = [ \\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\" ] assert unique_letters_in_paths(grid5) == 16","solution":"def unique_letters_in_paths(grid): This function receives a grid as a list of strings and returns the number of unique letters found in all possible paths from the top-left corner to the bottom-right corner. n = len(grid) m = len(grid[0]) unique_letters = set() def dfs(x, y, path_set): if x == n-1 and y == m-1: unique_letters.update(path_set) return if x < n-1: dfs(x + 1, y, path_set | {grid[x+1][y]}) if y < m-1: dfs(x, y + 1, path_set | {grid[x][y+1]}) dfs(0, 0, {grid[0][0]}) return len(unique_letters) # Example usage: n, m = 2, 3 grid = [ \\"abc\\", \\"def\\" ] print(unique_letters_in_paths(grid)) # Should output 6"},{"question":"def smallest_encompassing_circle(points: List[Tuple[int, int]]) -> float: Finds the radius of the smallest circle that can encompass all given points. >>> smallest_encompassing_circle([(0, 0), (1, 1), (-1, -1)]) 1.414213 >>> smallest_encompassing_circle([(0, 0)]) 0 pass def parse_input(input_text: str) -> List[Tuple[int, int]]: Parses the input text into a list of points. >>> parse_input(\\"3n0 0n1 1n-1 -1\\") [(0, 0), (1, 1), (-1, -1)] pass","solution":"import math def smallest_encompassing_circle(points): Finds the radius of the smallest circle that can encompass all given points. :param points: List of tuples representing the coordinates of points (x, y) :return: Radius of the smallest encompassing circle if not points: return 0 centroid_x = sum(x for x, y in points) / len(points) centroid_y = sum(y for x, y in points) / len(points) max_dist_sq = 0 for x, y in points: dist_sq = (x - centroid_x) ** 2 + (y - centroid_y) ** 2 if dist_sq > max_dist_sq: max_dist_sq = dist_sq return math.sqrt(max_dist_sq) def parse_input(input_text): Parses the input text into a list of points. :param input_text: String containing the input data :return: A list of tuples representing the points lines = input_text.strip().split('n') n = int(lines[0]) points = [] for i in range(1, n + 1): x, y = map(int, lines[i].split()) points.append((x, y)) return points"},{"question":"def is_path_exists(n: int, grid: List[List[int]]) -> str: Determine if there is a path from the top-left corner to the bottom-right corner in an n x n grid. The grid contains 0s (empty cells) and 1s (obstacles). The function should return \\"YES\\" if there is a path, and \\"NO\\" otherwise. Args: n (int): the dimension of the grid. grid (List[List[int]]): the n x n grid of cells. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> is_path_exists(3, grid) \\"YES\\" >>> grid = [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> is_path_exists(3, grid) \\"NO\\"","solution":"def is_path_exists(n, grid): if grid[0][0] == 1 or grid[n-1][n-1] == 1: return \\"NO\\" from collections import deque directions = [(1, 0), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == n-1 and y == n-1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"from typing import List, Tuple def find_scc_count(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given a directed graph with n nodes labeled from 1 to n and m edges, determine the number of strongly connected components (SCCs) in the graph. A strongly connected component is a maximal subgraph where there exists a directed path between any two vertices in this subgraph. :param n: Number of nodes :param m: Number of edges :param edges: List of tuples representing directed edges (u, v) :return: Number of strongly connected components Example: >>> find_scc_count(5, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)]) == 2 >>> find_scc_count(1, 0, []) == 1 >>> find_scc_count(3, 0, []) == 3 >>> find_scc_count(4, 12, [(1, 2), (2, 1), (1, 3), (3, 1), (1, 4), (4, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3)]) == 1 >>> find_scc_count(4, 3, [(1, 2), (2, 3), (3, 4)]) == 4 >>> find_scc_count(6, 4, [(1, 2), (2, 1), (3, 4), (4, 3)]) == 4 >>> find_scc_count(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (6, 6)]) == 4 >>> find_scc_count(3, 6, [(1, 2), (2, 1), (2, 3), (3, 2), (3, 1), (1, 3)]) == 1 >>> find_scc_count(3, 3, [(1, 2), (2, 3), (3, 1)]) == 1","solution":"from collections import defaultdict, deque def find_scc_count(n, m, edges): Determines the number of strongly connected components (SCCs) in a directed graph :param n: Number of nodes :param m: Number of edges :param edges: List of tuples representing directed edges (u,v) :return: Number of strongly connected components def kosaraju_scc(n, edges): graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) visited = [False] * (n + 1) order = [] def dfs(v): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor) order.append(v) def reverse_dfs(v): visited[v] = True for neighbor in reverse_graph[v]: if not visited[neighbor]: reverse_dfs(neighbor) for i in range(1, n + 1): if not visited[i]: dfs(i) visited = [False] * (n + 1) scc_count = 0 while order: node = order.pop() if not visited[node]: reverse_dfs(node) scc_count += 1 return scc_count return kosaraju_scc(n, edges)"},{"question":"def max_overlap(n: int, intervals: List[Tuple[int, int]]) -> int: Calculate the maximum number of projects occurring on any given day. Args: n (int): The number of projects. intervals (List[Tuple[int, int]]): List of tuples where each tuple contains the start and end day of a project. Returns: int: The maximum number of overlapping projects on any day. Example: >>> max_overlap(3, [(1, 10), (5, 15), (12, 20)]) 2 >>> max_overlap(3, [(1, 2), (3, 4), (5, 6)]) 1","solution":"def max_overlap(n, intervals): events = [] for start, end in intervals: events.append((start, 1)) # +1 for a project starting events.append((end + 1, -1)) # -1 for a project ending the day after it ends # Sort the events: first by day, then by type of event (start events before end events in case of tie) events.sort() max_projects = 0 current_projects = 0 for _, event in events: current_projects += event if current_projects > max_projects: max_projects = current_projects return max_projects"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Determine the lexicographically smallest string possible by removing exactly k characters from s. >>> lexicographically_smallest_string(\\"acdbcb\\", 2) 'abcb' >>> lexicographically_smallest_string(\\"aaaa\\", 4) '' >>> lexicographically_smallest_string(\\"abc\\", 0) 'abc' >>> lexicographically_smallest_string(\\"abc\\", 1) 'ab' >>> lexicographically_smallest_string(\\"bbbb\\", 2) 'bb' >>> lexicographically_smallest_string(\\"dacb\\", 2) 'ab' >>> s = \\"a\\" * 50000 + \\"b\\" * 50000 >>> k = 50000 >>> lexicographically_smallest_string(s, k) 'a' * 50000","solution":"def lexicographically_smallest_string(s, k): n = len(s) stack = [] for i in range(n): while stack and k > 0 and stack[-1] > s[i]: stack.pop() k -= 1 stack.append(s[i]) # If there are more characters to remove (k > 0), remove from the end while k > 0: stack.pop() k -= 1 return ''.join(stack)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression with integers, plus (+), multiply (*), and parentheses. >>> evaluate_expression(\\"1+2\\") 3 >>> evaluate_expression(\\"2*3\\") 6 >>> evaluate_expression(\\"1+(2+3)\\") 6 >>> evaluate_expression(\\"2*(3+4)\\") 14 >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"3+(2*5)\\") 13 >>> evaluate_expression(\\"10+(5*6)+5\\") 45 >>> evaluate_expression(\\"2*(3+(4*5))\\") 46 >>> evaluate_expression(\\"2+(3*(4+1)*5)+3\\") 80","solution":"def evaluate_expression(expression): Evaluates a mathematical expression with integers, plus (+), multiply (*), and parentheses. def helper(expr, index): operands = [] num = 0 op = '+' while index[0] < len(expr): char = expr[index[0]] if char.isdigit(): num = num * 10 + int(char) if char == '(': index[0] += 1 num, _ = helper(expr, index) if char in '+*)' or index[0] == len(expr) - 1: if op == '+': operands.append(num) elif op == '*': operands[-1] *= num if char == '+' or char == '*': op = char if char == ')': return sum(operands), index[0] num = 0 index[0] += 1 return sum(operands), index[0] return helper(expression, [0])[0]"},{"question":"def count_vowels(s: str) -> int: Returns the number of vowels (a, e, i, o, u) in the given string s. >>> count_vowels('aeiou') 5 >>> count_vowels('bcdfg') 0 >>> count_vowels('hello world') 3 >>> count_vowels('') 0 >>> count_vowels('aaaa') 4 >>> count_vowels('eeee') 4 >>> count_vowels('iiii') 4 >>> count_vowels('oooo') 4 >>> count_vowels('uuuu') 4 >>> long_string = 'a'*200 + 'e'*200 + 'i'*200 + 'o'*200 + 'u'*200 >>> count_vowels(long_string) 1000","solution":"def count_vowels(s): Returns the number of vowels (a, e, i, o, u) in the given string s. vowels = set('aeiou') return sum(1 for char in s if char in vowels)"},{"question":"from typing import List, Tuple def find_repeated_events(logs: List[Tuple[int, str]], window: int) -> List[str]: This function takes a list of log entries (timestamp, eventID) and a time window, and returns a list of event IDs that have occurred more than once within the given time window. Parameters: logs: List of tuples where each tuple represents a log entry (timestamp, eventID). window: An integer representing the time window (in seconds) within which repeated events need to be identified. Returns: A list of unique event IDs that have appeared more than once within the specified time window. Example: >>> logs = [ >>> (1609459200, \\"A\\"), >>> (1609459210, \\"B\\"), >>> (1609459220, \\"A\\"), >>> (1609459230, \\"A\\"), >>> (1609459300, \\"B\\") >>> ] >>> window = 40 >>> find_repeated_events(logs, window) [\\"A\\"] # Your implementation here # Unit tests def test_find_repeated_events_example_case(): logs = [ (1609459200, \\"A\\"), (1609459210, \\"B\\"), (1609459220, \\"A\\"), (1609459230, \\"A\\"), (1609459300, \\"B\\") ] window = 40 assert find_repeated_events(logs, window) == [\\"A\\"] def test_find_repeated_events_multiple_repeated_events(): logs = [ (1609459200, \\"A\\"), (1609459205, \\"B\\"), (1609459210, \\"A\\"), (1609459215, \\"B\\"), (1609459220, \\"A\\"), (1609459230, \\"A\\"), (1609459300, \\"B\\"), (1609459305, \\"B\\") ] window = 10 assert set(find_repeated_events(logs, window)) == {\\"A\\", \\"B\\"} def test_find_repeated_events_no_repeated_events(): logs = [ (1609459200, \\"A\\"), (1609459250, \\"B\\"), (1609459300, \\"C\\") ] window = 10 assert find_repeated_events(logs, window) == [] def test_find_repeated_events_single_log_entry(): logs = [ (1609459200, \\"A\\") ] window = 10 assert find_repeated_events(logs, window) == [] def test_find_repeated_events_large_window(): logs = [ (1609459200, \\"A\\"), (1609459600, \\"A\\"), (1609460000, \\"A\\"), (1609459200, \\"B\\"), (1609459450, \\"B\\"), (1609459700, \\"B\\") ] window = 500 assert set(find_repeated_events(logs, window)) == {\\"A\\", \\"B\\"}","solution":"from typing import List, Tuple from collections import defaultdict def find_repeated_events(logs: List[Tuple[int, str]], window: int) -> List[str]: This function takes a list of log entries (timestamp, eventID) and a time window, and returns a list of event IDs that have occurred more than once within the given time window. event_timestamps = defaultdict(list) repeated_events = set() for timestamp, eventID in logs: event_timestamps[eventID].append(timestamp) for eventID, timestamps in event_timestamps.items(): timestamps.sort() for i in range(1, len(timestamps)): if timestamps[i] - timestamps[i-1] <= window: repeated_events.add(eventID) break return list(repeated_events)"},{"question":"from typing import List def max_circular_subarray_sum(arr: List[int]) -> int: Determine the maximum subarray sum in a circular array. Args: arr (List[int]): The input array of integers. Returns: int: The maximum subarray sum for the given circular array. Examples: >>> max_circular_subarray_sum([1, -2, 3, -1, 2]) 5 >>> max_circular_subarray_sum([-1, -2, -3, -4]) -1 >>> max_circular_subarray_sum([5]) 5 >>> max_circular_subarray_sum([-5]) -5 >>> max_circular_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_circular_subarray_sum([-5, -3, -1, -7]) -1 >>> max_circular_subarray_sum([3, -1, 2, -1]) 4 >>> max_circular_subarray_sum([8, -1, -3, 9]) 17","solution":"from typing import List def max_circular_subarray_sum(arr: List[int]) -> int: def kadane(arr): current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum max_kadane = kadane(arr) total_sum = sum(arr) max_wrap = total_sum + kadane([-x for x in arr]) # If all elements are negative, max_wrap would be zero; in this case we return max_kadane. if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"def reorder_array(nums: List[int]) -> List[int]: Reorder the array so that all even numbers appear before odd numbers, maintaining the relative order of even and odd numbers. >>> reorder_array([4, 2, 5, 7, 8]) [4, 2, 8, 5, 7] >>> reorder_array([10, 1, 4, 3]) [10, 4, 1, 3] >>> reorder_array([2, 4, 6, 8]) [2, 4, 6, 8] >>> reorder_array([1, 3, 5, 7]) [1, 3, 5, 7] >>> reorder_array([1]) [1] >>> reorder_array([2]) [2] >>> reorder_array([]) []","solution":"def reorder_array(nums): Reorder the array so that all even numbers appear before odd numbers, maintaining the relative order of even and odd numbers. evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"def partition_sequence(n: int, k: int, sequence: List[int]) -> List[List[int]]: Partitions a sequence of length n into k consecutive subsequences such that the sums of the subsequences are as close as possible to each other. Args: n (int): The length of the sequence. k (int): The number of subsequences to partition into. sequence (List[int]): The sequence of positive integers. Returns: List[List[int]]: A list of k subsequences. Example: >>> partition_sequence(10, 3, [5, 2, 1, 2, 3, 2, 4, 2, 10, 1]) [[5, 2, 1], [2, 3, 2, 4], [2, 10, 1]]","solution":"def partition_sequence(n, k, sequence): Partitions a sequence of length n into k consecutive subsequences such that the sums of the subsequences are as close as possible to each other. total_sum = sum(sequence) target_sum = total_sum / k partitions = [] current_subseq = [] current_sum = 0 for number in sequence: if current_sum + number > target_sum and len(partitions) < k - 1: partitions.append(current_subseq) current_subseq = [number] current_sum = number else: current_subseq.append(number) current_sum += number if current_subseq: partitions.append(current_subseq) return partitions"},{"question":"def remove_duplicates(input_list: List[int]) -> List[int]: Removes duplicates from the input list while maintaining the order of elements. :param input_list: list of integers :return: list of integers without duplicates pass def main(input_str: str): Main function to convert input string to list, process it, and print result. :param input_str: string of space-separated integers pass if __name__ == \\"__main__\\": import sys input_str = sys.stdin.read().strip() main(input_str) # Test Cases if __name__ == \\"__main__\\": import pytest from io import StringIO import sys def test_remove_duplicates(): assert remove_duplicates([1, 3, 3, 1, 2, 4, 5, 4, 6, 6, 7]) == [1, 3, 2, 4, 5, 6, 7] assert remove_duplicates([1, 2, 2, 3, 1]) == [1, 2, 3] assert remove_duplicates([]) == [] assert remove_duplicates([0, 0, 0, 0]) == [0] assert remove_duplicates([4, 4, 6, 5, 3, 3, 2, 2, 1, 1]) == [4, 6, 5, 3, 2, 1] def test_main(capsys): input_str = \\"1 3 3 1 2 4 5 4 6 6 7\\" expected_output = \\"1 3 2 4 5 6 7n\\" sys.stdin = StringIO(input_str) main(input_str) captured = capsys.readouterr() assert captured.out == expected_output def test_main_single_element(capsys): input_str = \\"4\\" expected_output = \\"4n\\" sys.stdin = StringIO(input_str) main(input_str) captured = capsys.readouterr() assert captured.out == expected_output def test_main_empty_input(capsys): input_str = \\"\\" expected_output = \\"n\\" sys.stdin = StringIO(input_str) main(input_str) captured = capsys.readouterr() assert captured.out == expected_output def test_main_all_duplicates(capsys): input_str = \\"1 1 1 1\\" expected_output = \\"1n\\" sys.stdin = StringIO(input_str) main(input_str) captured = capsys.readouterr() assert captured.out == expected_output pytest.main()","solution":"def remove_duplicates(input_list): Removes duplicates from the input list while maintaining order of elements. :param input_list: list of integers :return: list of integers without duplicates seen = set() result = [] for num in input_list: if num not in seen: seen.add(num) result.append(num) return result def main(input_str): Main function to convert input string to list, process it, and print result. :param input_str: string of space-separated integers input_list = list(map(int, input_str.split())) result = remove_duplicates(input_list) print(\\" \\".join(map(str, result)))"},{"question":"from typing import List def count_distinct_paths(grid: List[List[str]]) -> int: Given a rectangular grid of dimensions m x n filled with different characters, determine the number of distinct paths from the top-left corner (grid[0][0]) to the bottom-right corner (grid[m-1][n-1]). You can only move either down or right at any point in time. A path is considered distinct if the sequence of characters encountered along the path differs from any other path. >>> grid = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']] >>> count_distinct_paths(grid) 6 >>> grid = [['a']] >>> count_distinct_paths(grid) 1 >>> grid = [['a', 'b'], ['c', 'd']] >>> count_distinct_paths(grid) 2 >>> grid = [['a', 'a'], ['a', 'a']] >>> count_distinct_paths(grid) 1 >>> grid = [['a', 'b'], ['c', 'd'], ['e', 'f']] >>> count_distinct_paths(grid) 3","solution":"from typing import List, Set def count_distinct_paths(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) distinct_paths = set() # This will store our distinct paths as sets of strings. def dfs(x: int, y: int, path: str): # If this is the bottom-right corner, add the path to the distinct paths set if x == m - 1 and y == n - 1: distinct_paths.add(path + grid[x][y]) return # Include current cell in path path += grid[x][y] # Move right if possible if y + 1 < n: dfs(x, y + 1, path) # Move down if possible if x + 1 < m: dfs(x + 1, y, path) dfs(0, 0, \\"\\") return len(distinct_paths)"},{"question":"def enchanted_garden(operations): Perform a sequence of operations on the enchanted garden and return results of \\"Query\\" operations. >>> enchanted_garden([(\\"Add\\", 1, 5), (\\"Add\\", 2, 7), (\\"Query\\", 1, 2), (\\"Add\\", 1, 10), (\\"Query\\", 1, 2)]) [7, 10] >>> enchanted_garden([(\\"Add\\", 1, 5), (\\"Add\\", 1, 7), (\\"Query\\", 1, 1), (\\"Add\\", 1, 10), (\\"Query\\", 1, 1)]) [7, 10] >>> enchanted_garden([(\\"Add\\", 2, 5), (\\"Add\\", 3, 8), (\\"Query\\", 1, 3)]) [8] >>> enchanted_garden([(\\"Add\\", 1, 5), (\\"Add\\", 3, 7), (\\"Query\\", 1, 3), (\\"Add\\", 2, 10), (\\"Query\\", 1, 3)]) [7, 10] >>> enchanted_garden([(\\"Add\\", 1, 5), (\\"Add\\", 2, 6), (\\"Add\\", 3, 7), (\\"Add\\", 4, 8), (\\"Query\\", 1, 2), (\\"Query\\", 2, 3), (\\"Query\\", 1, 4)]) [6, 7, 8]","solution":"def enchanted_garden(operations): garden = [[] for _ in range(1000)] # assuming at most 1000 pots for simplicity results = [] for operation in operations: op_type, a, b = operation if op_type == \\"Add\\": garden[a-1].append(b) # since pot numbers are 1-indexed elif op_type == \\"Query\\": max_power = float('-inf') for i in range(a-1, b): if garden[i]: max_power = max(max_power, max(garden[i])) results.append(max_power) return results"},{"question":"from typing import List def check_indices(n: int, k: int, a: List[int]) -> str: Determine if there exist two distinct indices i and j in the array such that their absolute difference is at most k and the difference of their values is exactly 1. Args: n: An integer representing the number of elements in the array. k: An integer representing the maximum allowed absolute difference between the indices. a: A list of integers representing the elements of the array. Returns: 'YES' if there exist such indices, otherwise 'NO'. Examples: >>> check_indices(5, 2, [1, 2, 3, 4, 5]) 'YES' >>> check_indices(5, 1, [1, 3, 5, 7, 9]) 'NO' >>> check_indices(5, 4, [1, 2, 1, 2, 1]) 'YES' >>> check_indices(1, 1, [1]) 'NO' # Edge case with the smallest possible input, impossible to have two indices >>> check_indices(4, 2, [5, 5, 5, 5]) 'NO' >>> check_indices(6, 6, [10, 9, 8, 7, 6, 5]) 'YES' >>> check_indices(4, 3, [2, 2, 2, 2]) 'NO'","solution":"def check_indices(n, k, a): for i in range(n): for j in range(max(0, i - k), min(n, i + k + 1)): if i != j and abs(a[i] - a[j]) == 1: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple, Union def find_min_cost_to_connect_all_cities(n: int, m: int, roads: List[Tuple[int, int, int]]) -> Union[int, str]: Returns the minimum cost required to ensure all cities are connected. If it's not possible to connect all cities, returns \\"IMPOSSIBLE\\". Args: n (int): Number of cities. m (int): Number of direct roads. roads (List[Tuple[int, int, int]]): List of tuples representing the direct roads where each tuple contains three integers u, v, and w denoting a road between city u and city v with a construction cost of w. Returns: Union[int, str]: The minimum cost to connect all cities or \\"IMPOSSIBLE\\" if it is not possible to connect all cities. Examples: >>> find_min_cost_to_connect_all_cities(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10), (2, 4, 2)]) 9 >>> find_min_cost_to_connect_all_cities(4, 2, [(1, 2, 3), (3, 4, 5)]) \\"IMPOSSIBLE\\" def test_basic_case(): assert find_min_cost_to_connect_all_cities(4, 5, [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10), (2, 4, 2) ]) == 9 def test_disconnected_graph(): assert find_min_cost_to_connect_all_cities(4, 2, [ (1, 2, 3), (3, 4, 5) ]) == \\"IMPOSSIBLE\\" def test_minimal_case(): assert find_min_cost_to_connect_all_cities(2, 1, [ (1, 2, 1), ]) == 1 def test_all_edges_same_weight(): assert find_min_cost_to_connect_all_cities(3, 3, [ (1, 2, 5), (2, 3, 5), (1, 3, 5) ]) == 10 def test_complex_case(): assert find_min_cost_to_connect_all_cities(5, 7, [ (1, 2, 1), (1, 3, 5), (2, 3, 2), (2, 4, 8), (3, 4, 3), (3, 5, 9), (4, 5, 4) ]) == 10","solution":"def find_min_cost_to_connect_all_cities(n, m, roads): Returns the minimum cost required to ensure all cities are connected. If it's not possible to connect all cities, returns \\"IMPOSSIBLE\\". parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Kruskal algorithm to find the Minimum Spanning Tree (MST) roads.sort(key=lambda x: x[2]) mst_cost = 0 edges_used = 0 for u, v, w in roads: if find(u - 1) != find(v - 1): union(u - 1, v - 1) mst_cost += w edges_used += 1 if edges_used == n - 1: break # Check if all cities are connected if edges_used != n - 1: return \\"IMPOSSIBLE\\" return mst_cost"},{"question":"def max_sum_after_swap(n: int, nodes: List[Tuple[int, int, int]]) -> int: You are given a binary tree with \`n\` nodes and each node has a unique integer value from \`1\` to \`n\`. You are allowed to perform the following operation at most once: choose a node and swap its left and right child subtrees. After performing this operation, you need to find the maximum possible sum of values from the root to any leaf in the tree. >>> max_sum_after_swap(6, [(1, 2, 3), (2, 4, -1), (3, 5, 6), (4, -1, -1), (5, -1, -1), (6, -1, -1)]) 11 >>> max_sum_after_swap(1, [(1, -1, -1)]) 1 >>> max_sum_after_swap(3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)]) 4 >>> max_sum_after_swap(4, [(1, 2, -1), (2, 3, -1), (3, 4, -1), (4, -1, -1)]) 10 >>> max_sum_after_swap(5, [(1, 2, 3), (2, 4, -1), (3, -1, 5), (4, -1, -1), (5, -1, -1)]) 9","solution":"def max_sum_after_swap(n, nodes): # Creating the children dictionary to map parent to its left and right children children = {} for parent, left, right in nodes: children[parent] = (left, right) # Function to perform depth-first search to find the maximum sum path def dfs(node): if node == -1: return 0 left, right = children.get(node, (-1, -1)) left_sum = dfs(left) right_sum = dfs(right) return node + max(left_sum, right_sum) # Finding the max sum for the original tree original_max_sum = dfs(1) max_sum = original_max_sum # Trying to swap every node's children and find the maximum sum for parent, (left, right) in children.items(): children[parent] = (right, left) max_sum = max(max_sum, dfs(1)) children[parent] = (left, right) # Revert the swap return max_sum"},{"question":"def final_position(directions: str) -> tuple: Determines the robot's final position after executing a sequence of movements. Args: directions (str): A string representing the sequence of movements. Returns: tuple: A tuple of two integers representing the final coordinates (x, y) of the robot. Examples: >>> final_position(\\"UDLR\\") (0, 0) >>> final_position(\\"UUUD\\") (0, 2) >>> final_position(\\"RRL\\") (1, 0) >>> final_position(\\"UUDDLLRR\\") (0, 0)","solution":"def final_position(directions): Determines the robot's final position after executing a sequence of movements. Args: directions (str): A string representing the sequence of movements. Returns: tuple: A tuple of two integers representing the final coordinates (x, y) of the robot. x, y = 0, 0 for move in directions: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return (x, y)"},{"question":"class FenwickTree: def __init__(self, size): Initializes a Fenwick Tree (Binary Indexed Tree) of given size. Args: size (int): The size of the array on which the Fenwick Tree needs to perform operations. self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): Updates the value at a specific position in the array. Args: index (int): The index at which the update operation is to be performed (1-based index). delta (int): The value to be added to the current value at the given index. while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): Computes the prefix sum from the start of the array till the given index. Args: index (int): The index till which the sum is to be computed (1-based index). Returns: int: The sum from the start of the array till the provided index. sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def range_query(self, left, right): Computes the sum of the subarray from the given left index to the right index. Args: left (int): The starting index of the subarray (1-based index). right (int): The ending index of the subarray (1-based index). Returns: int: The sum of the subarray from index left to right. return self.query(right) - self.query(left - 1) def process_operations(n, m, arr, operations): Processes a list of operations on the array possibly containing update or range query operations. Args: n (int): The number of elements in the array. m (int): The number of operations to be performed. arr (list of int): The initial elements of the array. operations (list of tuple): The operations to be performed. Each operation is a tuple (t, i, j) where: - t is the type of operation (1 or 2) - if t == 1, i is the index to be updated, and j is the new value at that index. - if t == 2, i and j are the indices of the subarray whose sum is to be computed. Returns: list of int: The results of the sum operations. fenwick_tree = FenwickTree(n) result = [] # Initialize Fenwick Tree with initial array values for idx in range(n): fenwick_tree.update(idx + 1, arr[idx]) for operation in operations: t, i, j = operation if t == 1: # Update operation current_value = fenwick_tree.range_query(i, i) delta = j - current_value fenwick_tree.update(i, delta) elif t == 2: # Range query operation result.append(fenwick_tree.range_query(i, j)) return result # Unit test for the function def test_process_operations(): n = 5 m = 5 arr = [1, 2, 3, 4, 5] operations = [ (2, 1, 3), # Query sum from index 1 to 3: 1+2+3 = 6 (1, 3, 10), # Update index 3 to value 10 (2, 1, 3), # Query sum from index 1 to 3: 1+2+10 = 13 (2, 3, 5), # Query sum from index 3 to 5: 10+4+5 = 19 (1, 1, 7), # Update index 1 to value 7 ] expected_output = [6, 15, 19] assert process_operations(n, m, arr, operations) == expected_output n = 1 m = 2 arr = [5] operations = [ (2, 1, 1), # Query sum from index 1 to 1: 5 (1, 1, 10), # Update index 1 to value 10 ] expected_output = [5] assert process_operations(n, m, arr, operations) == expected_output n = 3 m = 5 arr = [1, 1, 1] operations = [ (1, 1, 5), # Update index 1 to value 5 (1, 2, 5), # Update index 2 to value 5 (1, 3, 5), # Update index 3 to value 5 (2, 1, 3), # Query sum from index 1 to 3: 5+5+5 = 15 (2, 2, 2), # Query sum from index 2 to 2: 5 ] expected_output = [15, 5] assert process_operations(n, m, arr, operations) == expected_output n = 4 m = 4 arr = [1, 2, 3, 4] operations = [ (1, 2, 7), # Update index 2 to value 7 (2, 1, 3), # Query sum from index 1 to 3: 1+7+3 = 11 (1, 3, 6), # Update index 3 to value 6 (2, 2, 4), # Query sum from index 2 to 4: 7+6+4 = 17 ] expected_output = [11, 17] assert process_operations(n, m, arr, operations) == expected_output","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def range_query(self, left, right): return self.query(right) - self.query(left - 1) def process_operations(n, m, arr, operations): fenwick_tree = FenwickTree(n) result = [] # Initialize Fenwick Tree with initial array values for idx in range(n): fenwick_tree.update(idx + 1, arr[idx]) for operation in operations: t, i, j = operation if t == 1: # Update operation current_value = fenwick_tree.range_query(i, i) delta = j - current_value fenwick_tree.update(i, delta) elif t == 2: # Range query operation result.append(fenwick_tree.range_query(i, j)) return result"},{"question":"def update_transactions_with_backorder(stock_info: List[str], transactions: List[str]) -> List[str]: Update the transaction logs by appending a '(backorder)' notice next to the book titles that are understocked. Args: stock_info (List[str]): List of strings containing the book title and available stock. transactions (List[str]): List of strings containing the username and book title purchased. Returns: List[str]: Updated list of transactions with '(backorder)' notice if applicable. Examples: >>> stock_info = [\\"bookA 2\\", \\"bookB 0\\", \\"bookC 1\\"] >>> transactions = [\\"alice bookA\\", \\"bob bookB\\", \\"charlie bookA\\", \\"diana bookC\\"] >>> update_transactions_with_backorder(stock_info, transactions) ['alice bookA', 'bob bookB (backorder)', 'charlie bookA', 'diana bookC'] >>> stock_info = [\\"bookA 2\\", \\"bookB 2\\", \\"bookC 1\\"] >>> transactions = [\\"alice bookA\\", \\"bob bookB\\", \\"charlie bookA\\", \\"diana bookC\\"] >>> update_transactions_with_backorder(stock_info, transactions) ['alice bookA', 'bob bookB', 'charlie bookA', 'diana bookC'] pass def process_input(input_data: str) -> List[str]: Process the input string and returns the updated transaction logs. Args: input_data (str): Multiline string containing stock information and transaction logs. Returns: List[str]: Updated list of transactions with '(backorder)' notice if applicable. Examples: >>> input_data = \\"3 4nbookA 2nbookB 0nbookC 1nalice bookAnbob bookBncharlie bookAndiana bookCn\\" >>> process_input(input_data) ['alice bookA', 'bob bookB (backorder)', 'charlie bookA', 'diana bookC'] pass","solution":"def update_transactions_with_backorder(stock_info, transactions): stock = {} # Populate book stock information for s in stock_info: title, qty = s.split() stock[title] = int(qty) updated_transactions = [] # Update transactions based on stock information for t in transactions: username, title = t.split() if stock[title] == 0: updated_transactions.append(f\\"{username} {title} (backorder)\\") else: updated_transactions.append(f\\"{username} {title}\\") stock[title] -= 1 return updated_transactions def process_input(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) stock_info = lines[1:n+1] transactions = lines[n+1:n+1+m] return update_transactions_with_backorder(stock_info, transactions)"},{"question":"def min_cuts_to_segment_rope(n, m, lengths): Returns the minimum number of cuts needed to split the rope into segments with the given lengths. If it is not possible, returns -1. >>> min_cuts_to_segment_rope(7, 3, [1, 3, 4]) 2 >>> min_cuts_to_segment_rope(5, 2, [2, 4]) -1 >>> min_cuts_to_segment_rope(10, 1, [5]) 2 >>> min_cuts_to_segment_rope(9, 1, [5]) -1 >>> min_cuts_to_segment_rope(11, 3, [1, 2, 5]) 3 >>> min_cuts_to_segment_rope(8, 4, [2, 3, 5, 8]) 1","solution":"def min_cuts_to_segment_rope(n, m, lengths): Returns the minimum number of cuts needed to split the rope into segments with the given lengths. If it is not possible, returns -1. # Initialize an array to store the minimum cuts needed for every length up to n. dp = [float('inf')] * (n + 1) dp[0] = 0 # No cuts needed for zero length # Iterate through every length up to n. for i in range(1, n + 1): for length in lengths: if i >= length: dp[i] = min(dp[i], dp[i - length] + 1) # If the value is still inf, it means it's not possible to achieve length n. return dp[n] if dp[n] != float('inf') else -1"},{"question":"def findMaximumXORSubarray(arr: List[int]) -> int: Returns the maximum XOR value of any subarray in the given array. >>> findMaximumXORSubarray([3, 10, 5, 25]) 28 >>> findMaximumXORSubarray([7]) 7 >>> findMaximumXORSubarray([0, 0, 0, 0]) 0 >>> findMaximumXORSubarray([]) 0 >>> findMaximumXORSubarray([8, 1, 2, 12, 7, 6]) 15 >>> findMaximumXORSubarray([4,6]) 6 >>> findMaximumXORSubarray([8,10,2]) 10","solution":"def findMaximumXORSubarray(arr): Returns the maximum XOR value of any subarray in the given array. n = len(arr) if n == 0: return 0 max_xor = 0 prefixes = set() prefixes.add(0) # To handle the case when a subarray itself gives the max XOR prefix_xor = 0 for num in arr: prefix_xor ^= num for p in prefixes: max_xor = max(max_xor, prefix_xor ^ p) prefixes.add(prefix_xor) return max_xor"},{"question":"def greatest_good_letter(s: str) -> str: Returns the greatest \\"good\\" letter in uppercase that appears in both uppercase and lowercase in the given string. >>> greatest_good_letter(\\"aA\\") 'A' >>> greatest_good_letter(\\"abBcCDd\\") 'D' >>> greatest_good_letter(\\"xyz\\") ''","solution":"def greatest_good_letter(s): Returns the greatest \\"good\\" letter in uppercase that appears in both uppercase and lowercase in the given string. good_letters = set() for char in s: if char.isupper() and char.lower() in s: good_letters.add(char) elif char.islower() and char.upper() in s: good_letters.add(char.upper()) return max(good_letters, default=\\"\\")"},{"question":"def is_path(n, m, edges, start, end): Determines if there is a path between two computers in a computer network graph. Parameters: - n: int, number of computers. - m: int, number of direct links between computers. - edges: List of tuples, each representing a direct link between two computers. - start: int, the starting computer. - end: int, the ending computer. Returns: - 'YES' if there is a path between start and end, else 'NO'. Examples: >>> is_path(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 1, 5) 'YES' >>> is_path(5, 3, [(1, 2), (2, 3), (3, 4)], 1, 5) 'NO' >>> is_path(2, 1, [(1, 2)], 1, 2) 'YES' >>> is_path(4, 2, [(1, 2), (3, 4)], 1, 4) 'NO' >>> is_path(4, 3, [(1, 2), (2, 3), (3, 4)], 1, 4) 'YES' >>> is_path(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)], 2, 2) 'YES'","solution":"def is_path(n, m, edges, start, end): Determines if there is a path between two computers in a computer network graph. Parameters: - n: int, number of computers. - m: int, number of direct links between computers. - edges: List of tuples, each representing a direct link between two computers. - start: int, the starting computer. - end: int, the ending computer. Returns: - 'YES' if there is a path between start and end, else 'NO'. from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Breadth-First Search (BFS) to check for path existence visited = [False] * (n + 1) queue = deque([start]) visited[start] = True while queue: current = queue.popleft() if current == end: return \\"YES\\" for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return \\"NO\\""},{"question":"def min_cost_path(grid: List[List[int]]) -> int: Compute the minimum cost to travel from the top-left corner to the bottom-right corner of the grid. >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_cost_path([ ... [1, 2], ... [1, 1] ... ]) 3","solution":"def min_cost_path(grid): m = len(grid) n = len(grid[0]) # Initialize a 2D list to keep track of the minimum cost to reach each cell dp = [[0] * n for _ in range(m)] # Start at the top-left corner dp[0][0] = grid[0][0] # Fill in the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill in the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the minimum cost return dp[m - 1][n - 1]"},{"question":"def evaluate_custom_number(custom_number: str) -> int: Evaluate the numeric value of a given custom number string based on specified rules. >>> evaluate_custom_number(\\"3*4#5\\") 16 >>> evaluate_custom_number(\\"789\\") 24","solution":"def evaluate_custom_number(custom_number): total = 0 i = 0 while i < len(custom_number): char = custom_number[i] if char.isdigit(): num = int(char) if i + 1 < len(custom_number) and custom_number[i + 1] == '#': num *= 2 i += 1 # Skip the '#' character total += num # Skip '*' as it is a separator i += 1 return total"},{"question":"from typing import List def count_prime_product_subsets(m: int, arr: List[int]) -> int: Returns the count of subsets whose product of elements is a prime number. >>> count_prime_product_subsets(4, [2, 3, 5, 7]) 4 >>> count_prime_product_subsets(1, [11]) 1 >>> count_prime_product_subsets(2, [4, 6]) 0 >>> count_prime_product_subsets(3, [2, 3, 11]) 3 >>> count_prime_product_subsets(4, [2, 3, 7, 11]) 4 >>> count_prime_product_subsets(3, [2, 3, 9]) 2 >>> count_prime_product_subsets(5, [97, 89, 83, 79, 73]) 5 pass","solution":"from itertools import combinations from sympy import isprime def count_prime_product_subsets(m, arr): Returns the count of subsets whose product of elements is a prime number. count = 0 for i in range(1, m + 1): for combo in combinations(arr, i): product = 1 for num in combo: product *= num if isprime(product): count += 1 return count"},{"question":"from typing import List def process_transactions(t: int, q: int, ids: List[int], risk_factors: List[int], queries: List[str]) -> List[int]: Processes a list of transactions and queries to track transaction trends and identify potential fraudulent activities. Parameters: t (int): Number of transaction types. q (int): Number of queries. ids (List[int]): Unique identifiers of each transaction type. risk_factors (List[int]): Risk factors of each category. queries (List[str]): List of queries to process. Returns: List[int]: List of results for each \\"?\\" query. Example: >>> process_transactions(3, 5, [101, 205, 309], [5, 10, 15], [\\"+ 101 5\\", \\"+ 205 10\\", \\"+ 309 5\\", \\"? 101 205 5\\", \\"- 101\\"]) [5] pass import pytest def test_example_case(): t = 3 q = 5 ids = [101, 205, 309] risk_factors = [5, 10, 15] queries = [ \\"+ 101 5\\", \\"+ 205 10\\", \\"+ 309 5\\", \\"? 101 205 5\\", \\"- 101\\" ] assert process_transactions(t, q, ids, risk_factors, queries) == [5] def test_no_transaction_case(): t = 3 q = 1 ids = [101, 205, 309] risk_factors = [5, 10, 15] queries = [ \\"? 101 205 5\\" ] assert process_transactions(t, q, ids, risk_factors, queries) == [0] def test_multiple_transactions_case(): t = 3 q = 6 ids = [101, 205, 309] risk_factors = [5, 10, 15] queries = [ \\"+ 101 5\\", \\"+ 101 5\\", \\"+ 205 10\\", \\"+ 205 15\\", \\"? 101 205 5\\", \\"? 205 309 15\\" ] assert process_transactions(t, q, ids, risk_factors, queries) == [10, 15] def test_remove_transaction_case(): t = 3 q = 7 ids = [101, 205, 309] risk_factors = [5, 10, 15] queries = [ \\"+ 101 5\\", \\"+ 101 5\\", \\"+ 205 10\\", \\"- 101\\", \\"+ 101 15\\", \\"? 101 205 5\\", \\"? 101 205 15\\" ] assert process_transactions(t, q, ids, risk_factors, queries) == [5, 15] def test_risk_factor_not_present_case(): t = 3 q = 3 ids = [101, 205, 309] risk_factors = [5, 10, 15] queries = [ \\"+ 101 5\\", \\"+ 101 5\\", \\"? 101 101 10\\" ] assert process_transactions(t, q, ids, risk_factors, queries) == [0]","solution":"def process_transactions(t, q, ids, risk_factors, queries): from collections import defaultdict id_index_map = {ids[i]: i for i in range(t)} risk_factor_map = {rf:i for i, rf in enumerate(risk_factors)} transaction_log = defaultdict(list) results = [] for query in queries: parts = query.split() cmd = parts[0] if cmd == '+': id_val = int(parts[1]) c_val = int(parts[2]) transaction_log[id_val].append(c_val) elif cmd == '-': id_val = int(parts[1]) if transaction_log[id_val]: transaction_log[id_val].pop() elif cmd == '?': l = int(parts[1]) r = int(parts[2]) t = int(parts[3]) total_risk = 0 for id_val in range(l, r + 1): if id_val in transaction_log: total_risk += transaction_log[id_val].count(t) * t results.append(total_risk) return results"},{"question":"class SegmentTree: def __init__(self, data): Initialize the segment tree with the given array of integers. def build(self, data): Build the segment tree by calculating parents nodes. def query(self, l, r): Query the segment tree to find the maximum integer in the given range [l, r]. Returns: int: The maximum value in the range. def max_in_subarrays(data, queries): Given an array of integers and multiple queries, return the maximum integer in the specified subarrays. Args: data (List[int]): The array of integers. queries (List[Tuple[int, int]]): A list of queries, each defined by two integers (li, ri). Returns: List[int]: The maximum integer for each query in the order they appear. >>> max_in_subarrays([1, 3, 2, 7, 9, 11], [(1, 3), (2, 5), (1, 6)]) [3, 9, 11] >>> max_in_subarrays([8, 5, 6, 3, 7], [(1, 2), (2, 4), (1, 5)]) [8, 6, 8]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1]) def query(self, l, r): l += self.n # Shift the index to the leaf r += self.n # Shift the index to the leaf max_val = float('-inf') while l <= r: if l & 1: max_val = max(max_val, self.tree[l]) l += 1 if not (r & 1): max_val = max(max_val, self.tree[r]) r -= 1 l >>= 1 r >>= 1 return max_val def max_in_subarrays(data, queries): segment_tree = SegmentTree(data) results = [] for l, r in queries: result = segment_tree.query(l - 1, r - 1) results.append(result) return results"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def max_fuel_distribution(n: int, demands: List[int], roads: List[Tuple[int, int, int]]) -> int: You are tasked with optimizing the fuel distribution in a network. Given n stations, demands of each station, and the one-way roads with their capacities, determine the maximum amount of fuel that can be distributed in the network optimally. Parameters: n (int): Number of stations demands (List[int]): Demands of each station roads (List[Tuple[int, int, int]]): One-way roads with their capacities Returns: int: Maximum total amount of fuel that can be distributed Example: >>> max_fuel_distribution(4, [30, 50, 60, 20], [(1, 2, 40), (1, 3, 20), (3, 4, 10)]) 70 >>> max_fuel_distribution(2, [10, 10], [(1, 2, 5)]) 5 >>> max_fuel_distribution(3, [10, 20, 30], [(1, 2, 20), (2, 3, 10)]) 30 >>> max_fuel_distribution(3, [50, 50, 50], [(1, 2, 100), (2, 3, 100)]) 100 >>> max_fuel_distribution(4, [10, 20, 30, 40], [(1, 2, 0), (2, 3, 0), (3, 4, 0)]) 0","solution":"from collections import defaultdict, deque def max_fuel_distribution(n, demands, roads): graph = defaultdict(list) for u, v, c in roads: graph[u].append((v, c)) max_fuel = 0 visited = [False] * (n + 1) remaining_demand = demands[:] def bfs(start): visited[start] = True queue = deque([(start, float('inf'))]) total_fuel = 0 while queue: u, flow = queue.popleft() for v, capacity in graph[u]: sent_fuel = min(flow, capacity, remaining_demand[v - 1]) total_fuel += sent_fuel remaining_demand[v - 1] -= sent_fuel if not visited[v]: visited[v] = True queue.append((v, sent_fuel)) return total_fuel for i in range(1, n + 1): if not visited[i]: max_fuel += bfs(i) return max_fuel # Example usage: def example(): n = 4 demands = [30, 50, 60, 20] roads = [ (1, 2, 40), (1, 3, 20), (3, 4, 10) ] return max_fuel_distribution(n, demands, roads) print(example()) # Output should be 70"},{"question":"def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Determine the maximum number of non-overlapping tasks that can be executed by a single processing unit. :param tasks: List of tuples representing the (start_time, end_time) of each task. :return: Maximum number of non-overlapping tasks.","solution":"def max_non_overlapping_tasks(tasks): Determine the maximum number of non-overlapping tasks that can be executed by a single processing unit. :param tasks: List of tuples representing the (start_time, end_time) of each task. :return: Maximum number of non-overlapping tasks. if not tasks: return 0 # Sort tasks by their end times tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = -1 for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def min_subarray_length(arr: List[int], k: int) -> int: Determines the minimum length of a contiguous subarray such that the sum of its elements is greater than or equal to k. If such a subarray does not exist, returns -1. >>> min_subarray_length([1, 2, 3], 10) -1 >>> min_subarray_length([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_length([5], 5) 1 >>> min_subarray_length([1, 2, 3], 6) 3 >>> min_subarray_length([1, 1, 1, 1, 1, 7], 7) 1 >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2","solution":"def min_subarray_length(arr, k): Returns the minimum length of a contiguous subarray such that the sum of its elements is greater than or equal to k. If such a subarray does not exist, returns -1. n = len(arr) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 if min_len == float('inf'): return -1 return min_len"},{"question":"from collections import Counter from typing import List def find_anagrams(s: str, p: str) -> List[int]: Finds the start indices of the anagram substrings of p in s. >>> find_anagrams(\\"abxaba\\", \\"ab\\") [0, 3, 4] >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] pass def test_find_anagrams_case1(): s = \\"abxaba\\" p = \\"ab\\" expected = [0, 3, 4] assert find_anagrams(s, p) == expected def test_find_anagrams_case2(): s = \\"cbaebabacd\\" p = \\"abc\\" expected = [0, 6] assert find_anagrams(s, p) == expected def test_find_anagrams_empty_string(): s = \\"\\" p = \\"a\\" expected = [] assert find_anagrams(s, p) == expected def test_find_anagrams_no_anagrams(): s = \\"abcdefg\\" p = \\"hij\\" expected = [] assert find_anagrams(s, p) == expected def test_find_anagrams_same_string_as_pattern(): s = \\"abc\\" p = \\"abc\\" expected = [0] assert find_anagrams(s, p) == expected def test_find_anagrams_repeated_pattern(): s = \\"aaaa\\" p = \\"aa\\" expected = [0, 1, 2] assert find_anagrams(s, p) == expected","solution":"from collections import Counter def find_anagrams(s, p): Finds the start indices of the anagram substrings of p in s. if len(p) > len(s): return [] s_len, p_len = len(s), len(p) p_counter = Counter(p) s_counter = Counter() result_indices = [] for i in range(s_len): s_counter[s[i]] += 1 # Keep the window size the same as the length of p if i >= p_len: if s_counter[s[i - p_len]] == 1: del s_counter[s[i - p_len]] else: s_counter[s[i - p_len]] -= 1 # If matched, add the starting index to the result list if s_counter == p_counter: result_indices.append(i - p_len + 1) return result_indices"},{"question":"def calculate_final_price(category: str, price: float) -> float: Given a category and its price, calculate the final price after tax. The tax rates are: - Food: 5% - Electronics: 12% - Clothing: 8% - Other: 10% >>> calculate_final_price(\\"Food\\", 100.00) 105.00 >>> calculate_final_price(\\"Electronics\\", 220.00) 246.40 >>> calculate_final_price(\\"Clothing\\", 150.00) 162.00 >>> calculate_final_price(\\"Other\\", 75.00) 82.50 def process_items(n: int, items: List[Tuple[str, float]]) -> List[float]: Process a list of items to compute their final prices after tax. >>> process_items(4, [(\\"Food\\", 100.00), (\\"Electronics\\", 220.00), (\\"Clothing\\", 150.00), (\\"Other\\", 75.00)]) [105.00, 246.40, 162.00, 82.50]","solution":"def calculate_final_price(category, price): Given a category and its price, calculate the final price after tax. tax_rates = { \\"Food\\": 0.05, \\"Electronics\\": 0.12, \\"Clothing\\": 0.08, \\"Other\\": 0.10 } tax_rate = tax_rates.get(category, 0) final_price = price + (price * tax_rate) return round(final_price, 2) def process_items(n, items): results = [] for category, price in items: final_price = calculate_final_price(category, price) results.append(final_price) return results"},{"question":"def process_queries(queries): Process a list of queries to add points to a set or check if a path exists between two points. Args: queries (List[str]): List of queries as described above. Returns: List[str]: Results for each 'Q' query, either \\"YES\\" or \\"NO\\". >>> process_queries([\\"A 1 1\\", \\"Q 1 1 1 1\\"]) [\\"YES\\"] >>> process_queries([\\"A 1 1\\", \\"A 2 2\\", \\"Q 1 1 2 2\\"]) [\\"NO\\"]","solution":"def can_move(points, start, end): if start == end: return True from collections import defaultdict, deque graph = defaultdict(list) x_coord = defaultdict(set) y_coord = defaultdict(set) for (x, y) in points: x_coord[x].add((x, y)) y_coord[y].add((x, y)) for (x, y) in points: for neighbor in x_coord[x]: if neighbor != (x, y): graph[(x, y)].append(neighbor) for neighbor in y_coord[y]: if neighbor != (x, y): graph[(x, y)].append(neighbor) queue = deque([start]) visited = set() while queue: point = queue.popleft() if point == end: return True for neighbor in graph[point]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False def process_queries(queries): points = set() results = [] for query in queries: parts = query.split() if parts[0] == \\"A\\": x, y = int(parts[1]), int(parts[2]) points.add((x, y)) elif parts[0] == \\"Q\\": x1, y1, x2, y2 = int(parts[1]), int(parts[2]), int(parts[3]), int(parts[4]) if can_move(points, (x1, y1), (x2, y2)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val: int): self.val = val self.left = None self.right = None def max_path_sum(tree: List[Optional[int]]) -> int: You are given an array of integers representing a binary tree in level-order traversal form. Your goal is to construct the binary tree and find the maximum path sum. The path must start and end at any node in the binary tree but can only move through nodes consecutively along parent-child connections. The tree is represented as an array where the first element is the root, the next two elements form the children of the root, the next four elements form the children of the next level, and so on. Some elements of the array may be null, indicating that the corresponding node does not exist. - Function Signature: \`def max_path_sum(tree: List[Optional[int]]) -> int\` - Parameter: - \`tree\` (List[Optional[int]]): A list of integers (or None) representing the binary tree in level-order traversal. - Returns: - \`int\`: The maximum path sum for the given binary tree. >>> max_path_sum([1]) 1 >>> max_path_sum([1, 2, 3]) 6 >>> max_path_sum([1, 2, 3, None, 4, 5, 6]) 16 >>> max_path_sum([-10, 9, 20, None, None, 15, 7]) 42 >>> max_path_sum([-1, -2, -3]) -1 >>> max_path_sum([]) float('-inf') >>> max_path_sum([-1, -2, -3, -4, -5, -6, 10]) 10 # Test Cases def test_max_path_sum(): assert max_path_sum([1]) == 1 assert max_path_sum([1, 2, 3]) == 6 assert max_path_sum([1, 2, 3, None, 4, 5, 6]) == 16 assert max_path_sum([-10, 9, 20, None, None, 15, 7]) == 42 assert max_path_sum([-1, -2, -3]) == -1 assert max_path_sum([]) == float('-inf') assert max_path_sum([-1, -2, -3, -4, -5, -6, 10]) == 10","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int): self.val = val self.left = None self.right = None def build_tree(tree: List[Optional[int]]) -> Optional[TreeNode]: if not tree: return None nodes = [None if val is None else TreeNode(val) for val in tree] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def max_path_sum(tree: List[Optional[int]]) -> int: def max_gain(node: Optional[TreeNode]) -> int: nonlocal max_sum if not node: return 0 # Recursively get the max gain from left and right subtrees left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # Current path sum includes the node's value and maximum gain from both sides current_sum = node.val + left_gain + right_gain # Update max_sum if current_sum is higher max_sum = max(max_sum, current_sum) # Return the maximum gain the current node provides return node.val + max(left_gain, right_gain) root = build_tree(tree) max_sum = float('-inf') max_gain(root) return max_sum"},{"question":"def can_move(grid, n, m, q, queries): Determine if Kaito can move from one cell to another given several queries. Args: grid (List[List[int]]): the grid containing the values of each cell n (int): number of rows in the grid m (int): number of columns in the grid q (int): number of queries queries (List[Tuple[int, int, int, int]]): list of queries each containing the coordinates of the starting and ending cell Returns: List[str]: list of results (\\"YES\\" or \\"NO\\") for each query Examples: >>> n, m, q = 3, 3, 2 >>> grid = [ [5, 4, 3], [3, 6, 2], [2, 1, 1] ] >>> queries = [(1, 1, 2, 3), (2, 3, 1, 1)] >>> can_move(grid, n, m, q, queries) [\\"YES\\", \\"NO\\"] >>> n, m, q = 1, 1, 1 >>> grid = [ [1] ] >>> queries = [(1, 1, 1, 1)] >>> can_move(grid, n, m, q, queries) [\\"YES\\"] from solution import can_move def test_example(): n, m, q = 3, 3, 2 grid = [ [5, 4, 3], [3, 6, 2], [2, 1, 1] ] queries = [ (1, 1, 2, 3), (2, 3, 1, 1) ] expected = [\\"YES\\", \\"NO\\"] assert can_move(grid, n, m, q, queries) == expected def test_single_cell_grid(): n, m, q = 1, 1, 1 grid = [ [1] ] queries = [ (1, 1, 1, 1) ] expected = [\\"YES\\"] assert can_move(grid, n, m, q, queries) == expected def test_no_possible_moves(): n, m, q = 2, 2, 1 grid = [ [1, 2], [3, 4] ] queries = [ (1, 2, 2, 2) ] expected = [\\"NO\\"] assert can_move(grid, n, m, q, queries) == expected def test_possible_move_across_grid(): n, m, q = 3, 3, 1 grid = [ [5, 4, 3], [8, 6, 2], [3, 6, 1] ] queries = [ (1, 1, 3, 3) ] expected = [\\"YES\\"] assert can_move(grid, n, m, q, queries) == expected def test_edge_case_large_grid(): n, m, q = 4, 4, 1 grid = [ [5, 8, 2, 3], [9, 7, 6, 4], [1, 10, 11, 12], [13, 14, 15, 16] ] queries = [ (1, 1, 4, 4) ] expected = [\\"NO\\"] assert can_move(grid, n, m, q, queries) == expected","solution":"def can_move(grid, n, m, q, queries): def bfs(start, end): from collections import deque sx, sy = start ex, ey = end queue = deque([(sx, sy)]) visited = set() visited.add((sx, sy)) while queue: x, y = queue.popleft() if (x, y) == (ex, ey): return \\"YES\\" for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] <= grid[x][y]: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\" results = [] for query in queries: s_x, s_y, e_x, e_y = query results.append(bfs((s_x-1, s_y-1), (e_x-1, e_y-1))) return results"},{"question":"def max_subtree_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Given a tree with n nodes and their initial values, along with edges that define the tree structure, this function returns the maximum possible sum of the values in any subtree after performing the defined operations optimally. :param n: Number of nodes in the tree :param values: List of initial values for each node :param edges: List of edges connecting the nodes, each represented as a tuple (u, v) :return: Maximum possible sum of values in any subtree # Test cases def test_single_node(): assert max_subtree_sum(1, [10], []) == 10 def test_two_nodes(): assert max_subtree_sum(2, [1, 2], [(1, 2)]) == 2 * 2 def test_five_nodes(): assert max_subtree_sum(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) == 5 * 5 def test_large_values(): assert max_subtree_sum(3, [1000000, 999999, 1000000], [(1, 2), (2, 3)]) == 3 * 1000000 def test_mixed_values(): assert max_subtree_sum(4, [1, 100, 10, 1000], [(1, 2), (1, 3), (3, 4)]) == 4 * 1000","solution":"def max_subtree_sum(n, values, edges): Given a tree with n nodes and their initial values, along with edges that define the tree structure, this function returns the maximum possible sum of the values in any subtree after performing the defined operations optimally. :param n: Number of nodes in the tree :param values: List of initial values for each node :param edges: List of edges connecting the nodes, each represented as a tuple (u, v) :return: Maximum possible sum of values in any subtree # As each node value can be made arbitrarily large, the optimal solution would be n * max_value return n * max(values) # Example usage: # n = 5 # values = [1, 2, 3, 4, 5] # edges = [(1, 2), (1, 3), (3, 4), (3, 5)] # This should return 5 * 5 = 25"},{"question":"def count_inversions(arr: List[int]) -> int: Count the number of inversions in an array. An inversion is a pair of elements (arr[i], arr[j]) such that arr[i] > arr[j] and i < j. >>> count_inversions([1, 20, 6, 4, 5]) 5 >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([5, 4, 3, 2, 1]) 10 >>> count_inversions([1]) 0 >>> count_inversions([2, 1]) 1 >>> count_inversions([1000000000, 999999999, 1, 2, 3]) 7","solution":"def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all the remaining elements in the left subarray # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count # Function to use merge sort and count inversions def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def count_inversions(arr): n = len(arr) temp_arr = [0] * n return merge_sort_and_count(arr, temp_arr, 0, n - 1)"},{"question":"def can_be_cut(n: int, grid: List[str]) -> str: Determines if the n x n grid can be cut into exactly two non-empty parts with each part containing at least one empty cell using a single straight horizontal or vertical cut. >>> can_be_cut(4, [\\"....\\", \\"..\\", \\".#..\\", \\"....\\"]) 'YES' >>> can_be_cut(2, [\\"\\", \\"\\"]) 'NO' >>> can_be_cut(3, [\\"#.#\\", \\".\\", \\"#.#\\"]) 'YES' >>> can_be_cut(4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 'YES' >>> can_be_cut(2, [\\"..\\", \\"\\"]) 'YES' >>> can_be_cut(2, [\\"\\", \\"#.\\"]) 'NO'","solution":"def can_be_cut(n, grid): Determines if the n x n grid can be cut into exactly two non-empty parts with each part containing at least one empty cell using a single straight horizontal or vertical cut. # Check for horizontal cuts for row in range(1, n): top_part = ''.join(grid[:row]) bottom_part = ''.join(grid[row:]) if '.' in top_part and '.' in bottom_part: return \\"YES\\" # Check for vertical cuts for col in range(1, n): left_part = ''.join(grid[row][0:col] for row in range(n)) right_part = ''.join(grid[row][col:] for row in range(n)) if '.' in left_part and '.' in right_part: return \\"YES\\" return \\"NO\\""},{"question":"def sort_items(prices, names): Sort items based on their prices in non-decreasing order. If two items have the same price, maintain their original relative order from the input. Args: prices (list of int): The prices of the items. names (list of str): The names of the items. Returns: list of str: Sorted list of item names based on the non-decreasing order of their prices. pass def test_sort_items_with_unique_prices(): prices = [4, 2, 9, 1] names = [\\"d\\", \\"b\\", \\"c\\", \\"a\\"] assert sort_items(prices, names) == [\\"a\\", \\"b\\", \\"d\\", \\"c\\"] def test_sort_items_with_duplicate_prices(): prices = [4, 2, 2, 1] names = [\\"d\\", \\"b\\", \\"a\\", \\"c\\"] assert sort_items(prices, names) == [\\"c\\", \\"b\\", \\"a\\", \\"d\\"] def test_sort_items_with_identical_prices(): prices = [3, 3, 3] names = [\\"a\\", \\"b\\", \\"c\\"] assert sort_items(prices, names) == [\\"a\\", \\"b\\", \\"c\\"] def test_sort_items_with_single_element(): prices = [1] names = [\\"single\\"] assert sort_items(prices, names) == [\\"single\\"] def test_sort_items_with_all_zero_prices(): prices = [0, 0, 0, 0] names = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert sort_items(prices, names) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] def test_sort_items_with_large_values(): prices = [999999, 888888, 1000000] names = [\\"item1\\", \\"item2\\", \\"item3\\"] assert sort_items(prices, names) == [\\"item2\\", \\"item1\\", \\"item3\\"]","solution":"def sort_items(prices, names): Sort items based on their prices in non-decreasing order. If two items have the same price, maintain their original relative order from the input. Args: prices (list of int): The prices of the items. names (list of str): The names of the items. Returns: list of str: Sorted list of item names based on the non-decreasing order of their prices. items = list(zip(prices, names)) sorted_items = sorted(items, key=lambda x: x[0]) sorted_names = [item[1] for item in sorted_items] return sorted_names"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Implement a function that takes an integer array and a target sum, and returns the indices of the two numbers that add up to the target sum. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1]","solution":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index"},{"question":"def minimal_power_consumption(n: int, data_centers: List[List[int]]) -> List[int]: Determines the minimal total power consumption for each data center after optimally shutting down servers. Args: n (int): Number of data centers. data_centers (list of lists): List where each element is a list representing the power consumption of servers in a data center. Returns: list: List of minimal total power consumption for each data center. Example: >>> minimal_power_consumption(3, [ ... [10, 20, 30], ... [5, 15, 25, 10], ... [100, 200] ... ]) [10, 5, 100]","solution":"def minimal_power_consumption(n, data_centers): Determines the minimal total power consumption for each data center after optimally shutting down servers. Args: n (int): Number of data centers. data_centers (list of lists): List where each element is a list representing the power consumption of servers in a data center. Returns: list: List of minimal total power consumption for each data center. minimal_consumptions = [] for servers in data_centers: minimal_consumptions.append(min(servers)) return minimal_consumptions"},{"question":"def max_grade_difference_and_count(n: int, grades: List[int]) -> Tuple[int, int]: Returns the maximum grade difference and the number of pairs with this maximum difference. Parameters: - n: int, the number of students - grades: list of int, the grades of the students Returns: - tuple of two ints: (maximum difference, count of pairs with maximum difference) >>> max_grade_difference_and_count(5, [1, 3, 6, 9, 1]) (8, 2) >>> max_grade_difference_and_count(5, [5, 5, 5, 5, 5]) (0, 25) >>> max_grade_difference_and_count(3, [1, 5, 10]) (9, 1) >>> max_grade_difference_and_count(2, [1, 10]) (9, 1) pass def test_example_case(): assert max_grade_difference_and_count(5, [1, 3, 6, 9, 1]) == (8, 2) def test_all_same_grades(): assert max_grade_difference_and_count(5, [5, 5, 5, 5, 5]) == (0, 25) def test_min_and_max_grades_once(): assert max_grade_difference_and_count(3, [1, 5, 10]) == (9, 1) def test_large_input(): n = 200000 grades = [1] * 100000 + [1000000000] * 100000 assert max_grade_difference_and_count(n, grades) == (999999999, 100000 * 100000) def test_edge_case_min_n(): assert max_grade_difference_and_count(2, [1, 10]) == (9, 1) def test_negative_case(): assert max_grade_difference_and_count(2, [-5, 5]) == (10, 1)","solution":"def max_grade_difference_and_count(n, grades): Returns the maximum grade difference and the number of pairs with this maximum difference. Parameters: - n: int, the number of students - grades: list of int, the grades of the students Returns: - tuple of two ints: (maximum difference, count of pairs with maximum difference) max_grade = max(grades) min_grade = min(grades) max_diff = max_grade - min_grade count_max_grade = grades.count(max_grade) count_min_grade = grades.count(min_grade) count_pairs = count_max_grade * count_min_grade return max_diff, count_pairs"},{"question":"from typing import List def min_seconds_to_reach(h: int, w: int, grid: List[str], sx: int, sy: int, tx: int, ty: int) -> int: Calculate the minimum number of seconds required for the robot to reach the target position from the starting position in a grid. >>> h = 5 >>> w = 5 >>> grid = [ >>> \\".....\\", >>> \\".x...\\", >>> \\".....\\", >>> \\"...x.\\", >>> \\".....\\" >>> ] >>> sx = 0 >>> sy = 0 >>> tx = 4 >>> ty = 4 >>> min_seconds_to_reach(h, w, grid, sx, sy, tx, ty) 8 >>> h = 3 >>> w = 3 >>> grid = [ >>> \\"x.x\\", >>> \\"xxx\\", >>> \\"x.x\\" >>> ] >>> sx = 0 >>> sy = 0 >>> tx = 2 >>> ty = 2 >>> min_seconds_to_reach(h, w, grid, sx, sy, tx, ty) -1 >>> h = 3 >>> w = 3 >>> grid = [ >>> \\"...\\", >>> \\"...\\", >>> \\"...\\" >>> ] >>> sx = 0 >>> sy = 0 >>> tx = 2 >>> ty = 2 >>> min_seconds_to_reach(h, w, grid, sx, sy, tx, ty) 4 >>> h = 3 >>> w = 3 >>> grid = [ >>> \\"...\\", >>> \\"...\\", >>> \\"...\\" >>> ] >>> sx = 1 >>> sy = 1 >>> tx = 1 >>> ty = 1 >>> min_seconds_to_reach(h, w, grid, sx, sy, tx, ty) 0","solution":"from collections import deque def min_seconds_to_reach(h, w, grid, sx, sy, tx, ty): def is_valid(x, y): return 0 <= x < h and 0 <= y < w and grid[x][y] == '.' directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right queue = deque([(sx, sy, 0)]) # (x, y, distance) visited = set() visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (tx, ty): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def can_place_assets(h: int, w: int, m: int, assets: List[Tuple[int, int]]) -> bool: Determines if it's possible to place all assets on a grid without overlap. >>> can_place_assets(5, 5, 3, [(2, 2), (3, 3), (1, 4)]) True >>> can_place_assets(5, 5, 3, [(3, 3), (3, 3), (2, 3)]) False","solution":"def can_place_assets(h, w, m, assets): Determines if it's possible to place all assets on a grid without overlap. Parameters: h (int): Height of the grid. w (int): Width of the grid. m (int): Number of assets. assets (list of tuples): List of (width, height) tuples representing each asset. Returns: bool: True if all assets can be placed without overlap, False otherwise. from itertools import permutations, product # Check all permutations of the assets to account for their placements for perm in permutations(assets): for permuted_assets in product(*[(asset, (asset[1], asset[0])) for asset in perm]): # Initialize an empty board board = [[0] * w for _ in range(h)] is_valid_placement = True for asset in permuted_assets: placed = False for i in range(h): for j in range(w): if i + asset[1] <= h and j + asset[0] <= w: # check if asset fits the grid space if all(board[x][y] == 0 for x in range(i, i + asset[1]) for y in range(j, j + asset[0])): for x in range(i, i + asset[1]): for y in range(j, j + asset[0]): board[x][y] = 1 placed = True break if placed: break if not placed: is_valid_placement = False break if is_valid_placement: return True return False"},{"question":"from typing import List def min_subarray_length(arr: List[int], target: int) -> int: You are given an array of integers and you need to find the minimum length of a contiguous subarray of which the sum is at least a given value. A subarray is a contiguous part of an array. Args: arr (List[int]): A list of integers where each integer \`arr[i]\` (1 ≤ arr[i] ≤ 10^4). target (int): An integer value representing the required sum of the subarray (1 ≤ target ≤ 10^9). Returns: int: An integer representing the minimum length of the contiguous subarray with a sum at least equal to the given value. If there is no such subarray, return 0. >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 4, 4], 4) 1 >>> min_subarray_length([1, 4, 4], 8) 2 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 1, 1], 11) 0","solution":"from typing import List def min_subarray_length(arr: List[int], target: int) -> int: n = len(arr) left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += arr[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def find_balanced_sequence(n: int, S: List[int]): Determines if the given sequence S of length n can be divided into two non-empty contiguous subsequences A and B such that their sums are equal. Parameters: n (int): Length of the sequence S (list): List of integers representing the sequence Returns: tuple or str: A tuple of two integers representing indices (i, j) if the sequence is balanced, otherwise \\"Not Balanced\\" pass from solution import find_balanced_sequence def test_balanced_sequence(): assert find_balanced_sequence(8, [2, 3, 4, 1, 2, 3, 4, 1]) == (4, 8) assert find_balanced_sequence(6, [1, 2, 3, 3, 2, 1]) == (3, 6) def test_not_balanced_sequence(): assert find_balanced_sequence(5, [1, 2, 3, 4, 5]) == \\"Not Balanced\\" assert find_balanced_sequence(4, [1, 1, 1, 1]) == (2, 4) def test_large_balanced_sequence(): assert find_balanced_sequence(10, [10, 20, 30, 40, 50, 50, 40, 30, 20, 10]) == (5, 10) def test_minimum_length(): assert find_balanced_sequence(2, [1, 1]) == (1, 2) def test_single_element(): assert find_balanced_sequence(4, [1, 1, 1, 1]) == (2, 4)","solution":"def find_balanced_sequence(n, S): Determines if the given sequence S of length n can be divided into two non-empty contiguous subsequences A and B such that their sums are equal. Parameters: n (int): Length of the sequence S (list): List of integers representing the sequence Returns: tuple or str: A tuple of two integers representing indices (i, j) if the sequence is balanced, otherwise \\"Not Balanced\\" total = sum(S) left_sum = 0 for i in range(n - 1): left_sum += S[i] if left_sum * 2 == total: return (i + 1, n) # (i + 1) is the end of the first subsequence A and n is the end index of S return \\"Not Balanced\\""},{"question":"def can_split_list(n, k, difficulties): Determines if it's possible to split the list into exactly two non-empty parts such that the maximum difference in difficulty levels in both parts would be <= k. Args: n : int : the number of topics. k : int : the threshold value. difficulties : list of int : difficulty levels of the topics. Returns: str : \\"YES\\" if it's possible to split the list, otherwise \\"NO\\" pass # Unit Test def test_case_1(): assert can_split_list(5, 3, [1, 3, 5, 7, 9]) == \\"NO\\" def test_case_2(): assert can_split_list(5, 4, [1, 5, 3, 8, 6]) == \\"YES\\" def test_case_3(): assert can_split_list(3, 2, [4, 4, 6]) == \\"YES\\" def test_case_4(): assert can_split_list(3, 0, [1, 2, 3]) == \\"NO\\" def test_case_5(): assert can_split_list(4, 1, [1, 1, 2, 1]) == \\"YES\\"","solution":"def can_split_list(n, k, difficulties): Determines if it's possible to split the list into exactly two non-empty parts such that the maximum difference in difficulty levels in both parts would be <= k. Args: n : int : the number of topics. k : int : the threshold value. difficulties : list of int : difficulty levels of the topics. Returns: str : \\"YES\\" if it's possible to split the list, otherwise \\"NO\\" for i in range(1, n): left_part = difficulties[:i] right_part = difficulties[i:] if max(left_part) - min(left_part) <= k and max(right_part) - min(right_part) <= k: return \\"YES\\" return \\"NO\\""},{"question":"def list_primes_up_to(m: int) -> List[int]: Returns a list of all prime numbers up to and including m using the Sieve of Eratosthenes. >>> list_primes_up_to(10) [2, 3, 5, 7] >>> list_primes_up_to(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> list_primes_up_to(2) [2] >>> list_primes_up_to(1) [] >>> list_primes_up_to(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> list_primes_up_to(100) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]","solution":"def list_primes_up_to(m): Returns a list of all prime numbers up to and including m using the Sieve of Eratosthenes. if m < 2: return [] sieve = [True] * (m + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(m**0.5) + 1): if sieve[start]: for multiple in range(start*start, m + 1, start): sieve[multiple] = False return [num for num in range(2, m + 1) if sieve[num]]"},{"question":"def potency_of_spell(s: str, k: int, d: int) -> int: Calculates the potency of a spell given a string of potions s, and two integers k and d. The potency is the number of distinct potions (letters) in the substring when considering every d-th potion starting from the k-th position. Parameters: - s : str : The sequence of potions. - k : int : The starting position (1-based index). - d : int : The step size. Returns: - int : The number of distinct potions in the substring. Example: >>> potency_of_spell(\\"abacabadabacaba\\", 2, 3) 3 >>> potency_of_spell(\\"a\\", 1, 1) 1","solution":"def potency_of_spell(s, k, d): Calculates the potency of a spell given a string of potions s, and two integers k and d. Parameters: - s : str : The sequence of potions. - k : int : The starting position (1-based index). - d : int : The step size. Returns: - int : The number of distinct potions in the substring. distinct_potions = set() # Convert to 0-based index by subtracting 1 from k k -= 1 for i in range(k, len(s), d): distinct_potions.add(s[i]) return len(distinct_potions)"},{"question":"def is_subsequence(s1: str, s2: str) -> bool: Returns True if s2 is a subsequence of s1, otherwise False. Example Usages: >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"aec\\") False >>> is_subsequence(\\"abacaba\\", \\"aaa\\") True >>> is_subsequence(\\"abc\\", \\"\\") True >>> is_subsequence(\\"abc\\", \\"abcd\\") False","solution":"def is_subsequence(s1, s2): Returns True if s2 is a subsequence of s1, otherwise False. # Pointers for s1 and s2 i, j = 0, 0 while i < len(s1) and j < len(s2): if s1[i] == s2[j]: j += 1 i += 1 return j == len(s2)"},{"question":"def max_path_sum(n: int, m: int, values: List[int], edges: List[Tuple[int, int]]) -> int: You are given an undirected graph with n vertices and m edges. Each vertex has an associated value vi (0 ≤ vi ≤ 1,000,000). You can consider each edge bidirectional. Your task is to find the maximum sum of values for any path in the graph. A path is defined as a sequence of vertices where each consecutive pair of vertices in the sequence is connected by an edge. The path must contain at least one vertex and may revisit vertices or edges. If there are no edges, print the maximum value among all vertices' values. :param n: Integer, number of vertices :param m: Integer, number of edges :param values: List of integers, values associated with each vertex :param edges: List of tuples, each containing two integers representing edges :return: Integer, the maximum path sum >>> max_path_sum(5, 4, [10, 20, 30, 40, 50], [(1, 2), (2, 3), (3, 4), (4, 5)]) 150 >>> max_path_sum(1, 0, [100], []) 100 >>> max_path_sum(3, 0, [5, 10, 15], []) 15 >>> max_path_sum(3, 3, [1, 2, 3], [(1, 2), (2, 3), (3, 1)]) 6 >>> max_path_sum(3, 2, [1000000, 1000000, 1000000], [(1, 2), (2, 3)]) 3000000","solution":"def max_path_sum(n, m, values, edges): Returns the maximum sum of values for any path in the graph. :param n: Integer, number of vertices :param m: Integer, number of edges :param values: List of integers, values associated with each vertex :param edges: List of tuples, each containing two integers representing edges :return: Integer, the maximum path sum if m == 0: return max(values) from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) def dfs(node, parent): max_sum = values[node] node_visited[node] = True for neighbor in graph[node]: if not node_visited[neighbor]: max_sum = max(max_sum, values[node] + dfs(neighbor, node)) return max_sum node_visited = [False] * n max_sum_result = 0 for i in range(n): if not node_visited[i]: max_sum_result = max(max_sum_result, dfs(i, -1)) return max_sum_result"},{"question":"def minimize_salary_expense(n: int, salaries: List[int]) -> int: Function that minimizes the total salary expense by forming teams of two developers each. Arguments: n : int : number of developers (always even). salaries : list of int : list of salaries of developers. Returns: int : the minimum total salary expense. >>> minimize_salary_expense(4, [3, 1, 4, 2]) 10 >>> minimize_salary_expense(6, [6, 3, 5, 4, 2, 1]) 21 >>> minimize_salary_expense(2, [10, 20]) 30 >>> minimize_salary_expense(4, [10, 20, 30, 40]) 100 >>> minimize_salary_expense(6, [10, 5, 40, 50, 20, 1]) 126 >>> minimize_salary_expense(4, [100000000, 10000000, 1000000, 100000]) 111100000","solution":"def minimize_salary_expense(n, salaries): Function that minimizes the total salary expense by forming teams of two developers each. Arguments: n : int : number of developers (always even). salaries : list of int : list of salaries of developers. Returns: int : the minimum total salary expense. # Sort the salaries to pair the cheapest and the second cheapest, and so on salaries.sort() total_expense = 0 # Iterate to form pairs and compute the total expense for i in range(n // 2): total_expense += salaries[i] for i in range(n - 1, n // 2 - 1, -1): total_expense += salaries[i] return total_expense"},{"question":"def smallest_repetitive_segment_length(n: int, sequence: List[int]) -> int: Determine the length of the smallest repetitive segment in a given sequence. Args: n (int): The length of the sequence. sequence (list): A list of integers representing the sequence. Returns: int: The length of the smallest repetitive segment, or -1 if no repetitive segment is found. Example: >>> smallest_repetitive_segment_length(6, [1, 2, 1, 2, 1, 2]) 2 >>> smallest_repetitive_segment_length(5, [1, 2, 3, 1, 2]) -1 from typing import List def test_smallest_repetitive_segment_length(): assert smallest_repetitive_segment_length(6, [1, 2, 1, 2, 1, 2]) == 2 assert smallest_repetitive_segment_length(5, [1, 2, 3, 1, 2]) == -1 assert smallest_repetitive_segment_length(8, [1, 1, 1, 1, 1, 1, 1, 1]) == 1 assert smallest_repetitive_segment_length(4, [1, 2, 1, 2]) == 2 assert smallest_repetitive_segment_length(1, [1]) == -1 assert smallest_repetitive_segment_length(3, [1, 2, 3]) == -1 assert smallest_repetitive_segment_length(9, [1, 2, 3, 1, 2, 3, 1, 2, 3]) == 3 assert smallest_repetitive_segment_length(12, [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]) == 3 if __name__ == \\"__main__\\": test_smallest_repetitive_segment_length() print(\\"All tests passed!\\")","solution":"def smallest_repetitive_segment_length(n, sequence): Determine the length of the smallest repetitive segment in a given sequence. Args: n (int): The length of the sequence. sequence (list): A list of integers representing the sequence. Returns: int: The length of the smallest repetitive segment, or -1 if no repetitive segment is found. if n <= 1: return -1 # Try lengths from 1 up to n//2 to find the smallest repetitive segment. for length in range(1, n // 2 + 1): if n % length == 0: # Check if sequence can be divided into equal parts of length \`length\`. segment = sequence[:length] if all(sequence[i:i+length] == segment for i in range(0, n, length)): return length return -1"},{"question":"def max_challenges_solved(p: int, q: int, k: int, difficulties: List[int]) -> int: Determines the maximum number of challenges that can be solved in q seconds with the option to boost k challenges. Parameters: p (int): The number of challenges. q (int): The total seconds available. k (int): The number of challenges that can be boosted. difficulties (list of int): The difficulty levels of the challenges. Returns: int: The maximum number of challenges that can be solved. pass # Unit tests def test_example_case(): p, q, k = 5, 10, 2 difficulties = [4, 2, 8, 5, 6] assert max_challenges_solved(p, q, k, difficulties) == 3 def test_no_boost_needed(): p, q, k = 4, 10, 2 difficulties = [2, 3, 2, 1] assert max_challenges_solved(p, q, k, difficulties) == 4 def test_all_boosts_needed(): p, q, k = 5, 10, 5 difficulties = [6, 7, 8, 9, 10] assert max_challenges_solved(p, q, k, difficulties) == 2 def test_no_time(): p, q, k = 3, 0, 1 difficulties = [3, 1, 2] assert max_challenges_solved(p, q, k, difficulties) == 0 def test_more_time_than_needed(): p, q, k = 3, 100, 3 difficulties = [1, 2, 3] assert max_challenges_solved(p, q, k, difficulties) == 3 def test_no_boost_available(): p, q, k = 3, 6, 0 difficulties = [2, 2, 3] assert max_challenges_solved(p, q, k, difficulties) == 2 def test_insufficient_boosts(): p, q, k = 6, 9, 1 difficulties = [1, 1, 1, 4, 4, 4] assert max_challenges_solved(p, q, k, difficulties) == 4","solution":"def max_challenges_solved(p, q, k, difficulties): Determines the maximum number of challenges that can be solved in q seconds with the option to boost k challenges. Parameters: p (int): The number of challenges. q (int): The total seconds available. k (int): The number of challenges that can be boosted. difficulties (list of int): The difficulty levels of the challenges. Returns: int: The maximum number of challenges that can be solved. # Sort difficulties to consider easier challenges first difficulties.sort() # Split challenges into two lists: boosted and non-boosted boosted_times = [d / 2 for d in difficulties[:k]] regular_times = difficulties[k:] # Combine and sort by time needed to solve challenges combined_times = sorted(boosted_times + regular_times) total_time = 0 challenges_solved = 0 # Solve challenges as long as we have time for time in combined_times: if total_time + time <= q: total_time += time challenges_solved += 1 else: break return challenges_solved"},{"question":"def longest_sorted_subsequence(S: str) -> int: Given a string S consisting of lowercase alphabets, find the length of the longest subsequence of S such that all characters in the subsequence are sorted in non-decreasing order. >>> longest_sorted_subsequence(\\"abcdea\\") 5 >>> longest_sorted_subsequence(\\"edcba\\") 1 >>> longest_sorted_subsequence(\\"a\\") 1 >>> longest_sorted_subsequence(\\"aaaaa\\") 5 >>> longest_sorted_subsequence(\\"aaabbbccc\\") 9 >>> longest_sorted_subsequence(\\"abcbcba\\") 4 from solution import longest_sorted_subsequence def test_longest_sorted_subsequence_example1(): assert longest_sorted_subsequence(\\"abcdea\\") == 5 def test_longest_sorted_subsequence_example2(): assert longest_sorted_subsequence(\\"edcba\\") == 1 def test_longest_sorted_subsequence_single_char(): assert longest_sorted_subsequence(\\"a\\") == 1 def test_longest_sorted_subsequence_all_same_char(): assert longest_sorted_subsequence(\\"aaaaa\\") == 5 def test_longest_sorted_subsequence_mixed_case(): assert longest_sorted_subsequence(\\"aaabbbccc\\") == 9 def test_longest_sorted_subsequence_increasing_decreasing(): assert longest_sorted_subsequence(\\"abcbcba\\") == 4 def test_longest_sorted_subsequence_empty_string(): assert longest_sorted_subsequence(\\"\\") == 0 def test_longest_sorted_subsequence_long_random_string(): assert longest_sorted_subsequence(\\"abdefgabcdabde\\") == 7 def test_longest_sorted_subsequence_start_with_large(): assert longest_sorted_subsequence(\\"zabcd\\") == 4","solution":"def longest_sorted_subsequence(S: str) -> int: Returns the length of the longest subsequence of S such that all characters in the subsequence are sorted in non-decreasing order. if not S: return 0 n = len(S) dp = [1] * n # dp[i] will hold the length of the longest sorted subsequence ending with S[i] for i in range(n): for j in range(i): if S[i] >= S[j]: # Ensure non-decreasing order dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def product_except_self(nums): Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. Args: nums (List[int]): input list of integers Returns: List[int]: output list where each element is the product of all elements except itself. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"def product_except_self(nums): Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. Args: nums (List[int]): input list of integers Returns: List[int]: output list where each element is the product of all elements except itself. n = len(nums) answer = [1] * n # Calculate left products except self left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] # Calculate right products except self right_product = 1 for i in reversed(range(n)): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def sum_of_three_consecutive_elements(lst: List[int]) -> List[int]: Returns a list where each element is the sum of three consecutive elements from the input list. If there are fewer than three elements left at the end, those elements are ignored. >>> sum_of_three_consecutive_elements([1, 2, 3, 4, 5]) [6, 9, 12] >>> sum_of_three_consecutive_elements([1, 2]) [] >>> sum_of_three_consecutive_elements([-1, -2, -3, -4, -5]) [-6, -9, -12]","solution":"def sum_of_three_consecutive_elements(lst): Returns a list where each element is the sum of three consecutive elements from the input list. If there are fewer than three elements left at the end, those elements are ignored. result = [] for i in range(len(lst) - 2): sum_of_three = lst[i] + lst[i + 1] + lst[i + 2] result.append(sum_of_three) return result"},{"question":"from typing import List, Tuple def find_scrambled_codes(codes: List[str]) -> List[Tuple[int, int]]: Given a list of strings \`codes\`, the function returns a list of tuples where each tuple \`(i, j)\` indicates that \`codes[i]\` is a scrambled version of \`codes[j]\`. >>> find_scrambled_codes([\\"abc\\", \\"bca\\", \\"dabc\\", \\"cab\\", \\"dab\\"]) [(0, 1), (0, 3), (1, 0), (1, 3), (3, 0), (3, 1)] >>> find_scrambled_codes([\\"abc\\", \\"def\\", \\"ghi\\"]) [] >>> find_scrambled_codes([\\"abc\\", \\"abc\\", \\"abc\\"]) [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)] >>> find_scrambled_codes([\\"abc\\"]) [] >>> find_scrambled_codes([]) []","solution":"def find_scrambled_codes(codes): Given a list of strings \`codes\`, the function returns a list of tuples where each tuple \`(i, j)\` indicates that \`codes[i]\` is a scrambled version of \`codes[j]\`. scrambled_pairs = [] # Create a dictionary to store sorted codes with their indices sorted_dict = {} for idx, code in enumerate(codes): sorted_code = ''.join(sorted(code)) if sorted_code in sorted_dict: sorted_dict[sorted_code].append(idx) else: sorted_dict[sorted_code] = [idx] # Generate scrambled pairs from the dictionary for indices in sorted_dict.values(): if len(indices) > 1: for i in indices: for j in indices: if i != j: scrambled_pairs.append((i, j)) return scrambled_pairs"},{"question":"def update_inventory(initial_inventory, restocked_items, sold_items): This function updates the supermarket inventory based on restocked and sold items, and returns the items out of stock at the end of the day. Parameters: initial_inventory (list of tuples): Each tuple contains an item name and its initial quantity. restocked_items (list of tuples): Each tuple contains an item name and its restocked quantity. sold_items (list of tuples): Each tuple contains an item name and its sold quantity. Returns: list: A list of item names that are out of stock. pass def test_simple_case(): initial_inventory = [(\\"apple\\", 10), (\\"banana\\", 5)] restocked_items = [(\\"banana\\", 10)] sold_items = [(\\"apple\\", 10), (\\"banana\\", 5)] assert update_inventory(initial_inventory, restocked_items, sold_items) == [\\"apple\\"] def test_multiple_out_of_stock(): initial_inventory = [(\\"apple\\", 10), (\\"banana\\", 5), (\\"pear\\", 10)] restocked_items = [(\\"banana\\", 2), (\\"pear\\", 10)] sold_items = [(\\"apple\\", 15), (\\"banana\\", 7), (\\"pear\\", 5)] assert update_inventory(initial_inventory, restocked_items, sold_items) == [\\"apple\\", \\"banana\\"] def test_no_items_out_of_stock(): initial_inventory = [(\\"apple\\", 10), (\\"banana\\", 5)] restocked_items = [(\\"apple\\", 5), (\\"banana\\", 3)] sold_items = [(\\"apple\\", 10), (\\"banana\\", 5)] assert update_inventory(initial_inventory, restocked_items, sold_items) == [] def test_all_items_out_of_stock(): initial_inventory = [(\\"apple\\", 10), (\\"banana\\", 5)] restocked_items = [(\\"apple\\", 5), (\\"banana\\", 3)] sold_items = [(\\"apple\\", 15), (\\"banana\\", 8)] assert update_inventory(initial_inventory, restocked_items, sold_items) == [\\"apple\\", \\"banana\\"] def test_lexicographical_order(): initial_inventory = [(\\"kiwi\\", 10), (\\"apple\\", 5), (\\"banana\\", 20)] restocked_items = [(\\"kiwi\\", 5), (\\"apple\\", 3)] sold_items = [(\\"kiwi\\", 15), (\\"apple\\", 8), (\\"banana\\", 20)] assert update_inventory(initial_inventory, restocked_items, sold_items) == [\\"apple\\", \\"banana\\", \\"kiwi\\"]","solution":"def update_inventory(initial_inventory, restocked_items, sold_items): This function updates the supermarket inventory based on restocked and sold items, and returns the items out of stock at the end of the day. Parameters: initial_inventory (list of tuples): Each tuple contains an item name and its initial quantity. restocked_items (list of tuples): Each tuple contains an item name and its restocked quantity. sold_items (list of tuples): Each tuple contains an item name and its sold quantity. Returns: list: A list of item names that are out of stock. inventory = {} # Initial Inventory for item, quantity in initial_inventory: inventory[item] = quantity # Restock Inventory for item, quantity in restocked_items: if item in inventory: inventory[item] += quantity else: inventory[item] = quantity # Sell Inventory for item, quantity in sold_items: if item in inventory: inventory[item] -= quantity if inventory[item] < 0: inventory[item] = 0 # Find out of stock items out_of_stock = [item for item, quantity in inventory.items() if quantity == 0] # Return list of out of stock items in lexicographical order return sorted(out_of_stock)"},{"question":"def max_cities_to_visit(n, d, distances): Find the maximum number of cities Alice can visit starting from her home city given a list of cities and distances between them, ensuring she doesn't exceed the total travel distance d. Parameters: n (int): Number of cities d (int): Maximum total distance Alice can travel distances (List[List[int]]): A 2D list where the i-th line represents the distances between city i and other cities Returns: int: Maximum number of cities Alice can visit >>> max_cities_to_visit(3, 15, [[0, 10, 5], [10, 0, 8], [5, 8, 0]]) 3 >>> max_cities_to_visit(3, 10, [[0, 10, 5], [10, 0, 8], [5, 8, 0]]) 2 >>> max_cities_to_visit(4, 100, [[0, 20, 30, 40], [20, 0, 15, 25], [30, 15, 0, 50], [40, 25, 50, 0]]) 4 >>> max_cities_to_visit(3, 2, [[0, 10, 15], [10, 0, 8], [15, 8, 0]]) 1","solution":"def max_cities_to_visit(n, d, distances): visited = [False] * n visited[0] = True # start from home city current_distance = 0 city_count = 1 def find_min_distance_city(current_city): min_distance = float('inf') next_city = -1 for i in range(n): if not visited[i] and distances[current_city][i] < min_distance: min_distance = distances[current_city][i] next_city = i return next_city, min_distance current_city = 0 while True: next_city, min_distance = find_min_distance_city(current_city) if next_city == -1 or current_distance + min_distance > d: break visited[next_city] = True current_distance += min_distance city_count += 1 current_city = next_city return city_count"},{"question":"def parse_email(email: str) -> tuple: Parses the email address into its local-part and domain. Args: email (str): The email address to parse. Returns: tuple: A tuple containing the local-part and domain of the email address. >>> parse_email(\\"john.doe@example.com\\") ('john.doe', 'example.com') >>> parse_email(\\"alice@sub.example.com\\") ('alice', 'sub.example.com') >>> parse_email(\\"user123@example123.com\\") ('user123', 'example123.com') >>> parse_email(\\"first.last.middle@example.com\\") ('first.last.middle', 'example.com') >>> parse_email(\\"a@b.com\\") ('a', 'b.com') >>> parse_email(\\"averylonglocalpart@averyverylongdomain.com\\") ('averylonglocalpart', 'averyverylongdomain.com')","solution":"def parse_email(email): Parses the email address into its local-part and domain. Args: email (str): The email address to parse. Returns: tuple: A tuple containing the local-part and domain of the email address. local_part, domain = email.split('@') return local_part, domain"},{"question":"def best_buy_sell_days(prices): Function to determine the best day to buy and sell the stock to maximize profit. If no profit can be made, returns 0. :param prices: List of integers representing stock prices over consecutive days :return: A tuple contains two integers: day to buy and day to sell, or a single integer 0 if no profit can be made >>> best_buy_sell_days([7, 1, 5, 3, 6, 4]) (1, 4) >>> best_buy_sell_days([7, 6, 4, 3, 1]) 0 >>> best_buy_sell_days([1, 2]) (0, 1) >>> best_buy_sell_days([2, 1]) 0 >>> best_buy_sell_days([3, 3, 3, 3, 3]) 0 >>> best_buy_sell_days([1, 2, 3, 4, 5, 6]) (0, 5) >>> best_buy_sell_days([6, 5, 4, 3, 2, 1]) 0 >>> best_buy_sell_days([3, 1, 4, 1, 5, 1]) (1, 4)","solution":"def best_buy_sell_days(prices): Function to determine the best day to buy and sell the stock to maximize profit. If no profit can be made, returns 0. :param prices: List of integers representing stock prices over consecutive days :return: A tuple contains two integers: day to buy and day to sell, or a single integer 0 if no profit can be made min_price_day = 0 max_profit = 0 buy_day = 0 sell_day = 0 for i in range(1, len(prices)): if prices[i] < prices[min_price_day]: min_price_day = i current_profit = prices[i] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = i if max_profit == 0: return 0 else: return (buy_day, sell_day)"},{"question":"def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and a list of test cases where each test case is a tuple consisting of the length of the array and the array itself, determine the minimum number of operations required to make all elements in the array equal by either incrementing or decrementing each element. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases. Returns: List[int]: A list containing the minimum number of operations for each test case. >>> min_operations_to_equal_elements(1, [(3, [1, 2, 3])]) [2] >>> min_operations_to_equal_elements(2, [(3, [1, 2, 3]), (5, [1, 10, 2, 9, 3])]) [2, 16]","solution":"def min_operations_to_equal_elements(t, test_cases): results = [] for case in test_cases: n, a = case a.sort() median = a[n // 2] # The median minimizes the sum of absolute deviations total_operations = sum(abs(x - median) for x in a) results.append(total_operations) return results"},{"question":"from typing import List def canPlaceFlowers(flowerbed: List[int], k: int) -> bool: Determines if it's possible to plant k new flowers in the flowerbed without having two adjacent flowers. >>> canPlaceFlowers([1, 0, 0, 0, 1], 1) True >>> canPlaceFlowers([1, 0, 0, 0, 1], 2) False pass def test_can_place_flowers_one_flower_possible(): assert canPlaceFlowers([1, 0, 0, 0, 1], 1) == True def test_can_place_flowers_two_flowers_not_possible(): assert canPlaceFlowers([1, 0, 0, 0, 1], 2) == False def test_can_place_flowers_one_flower_possible_edge_case(): assert canPlaceFlowers([0], 1) == True def test_can_place_flowers_no_flower_needed(): assert canPlaceFlowers([0, 0, 0, 0, 0], 0) == True def test_can_place_flowers_insufficient_space(): assert canPlaceFlowers([1, 0, 1, 0, 1, 0, 1], 1) == False def test_can_place_flowers_multiple_spaces(): assert canPlaceFlowers([0, 0, 1, 0, 0, 1, 0, 0, 0, 1], 2) == True def test_can_place_flowers_exact_edge(): assert canPlaceFlowers([0, 0, 0, 0, 0], 2) == True def test_can_place_flowers_compact(): assert canPlaceFlowers([1,0,0,0,0,1], 1) == True def test_can_place_flowers_zero_needed(): assert canPlaceFlowers([1,0,0,0,0,1], 0) == True def test_can_place_flowers_all_full(): assert canPlaceFlowers([1,1,1,1,1], 1) == False","solution":"from typing import List def canPlaceFlowers(flowerbed: List[int], k: int) -> bool: Determines if it's possible to plant k new flowers in the flowerbed without having two adjacent flowers. n = len(flowerbed) count = 0 # To count how many flowers we can plant for i in range(n): if flowerbed[i] == 0: # Check if the previous and next positions are empty or out of bounds prev_empty = (i == 0) or (flowerbed[i - 1] == 0) next_empty = (i == n - 1) or (flowerbed[i + 1] == 0) if prev_empty and next_empty: flowerbed[i] = 1 # Plant a flower here count += 1 if count >= k: return True return count >= k"},{"question":"def max_of_mins(grid: List[List[int]]) -> int: Find the maximum value among the minimum values of each row in the grid. Parameters: grid (list of lists of int): The input grid Returns: int: The maximum value among the minimum values of each row def read_grid_and_find_max_of_mins(n: int, m: int, lines: List[str]) -> int: Create grid from input and compute the maximum value among the minimum values of each row. Parameters: n (int): Number of rows m (int): Number of columns lines (list of str): List of strings representing each row of the grid Returns: int: The maximum value among the minimum values of each row from typing import List def test_example_case(): n, m = 3, 3 lines = [ \\"3 7 5\\", \\"1 8 2\\", \\"9 4 6\\" ] assert read_grid_and_find_max_of_mins(n, m, lines) == 4 def test_single_row_case(): n, m = 1, 5 lines = [\\"7 3 5 1 6\\"] assert read_grid_and_find_max_of_mins(n, m, lines) == 1 def test_single_column_case(): n, m = 5, 1 lines = [ \\"7\\", \\"3\\", \\"5\\", \\"1\\", \\"6\\" ] assert read_grid_and_find_max_of_mins(n, m, lines) == 7 def test_varying_values_case(): n, m = 4, 4 lines = [ \\"10 20 30 40\\", \\"40 30 20 10\\", \\"15 25 35 45\\", \\"45 35 25 15\\" ] assert read_grid_and_find_max_of_mins(n, m, lines) == 15 def test_edge_case_minimal(): n, m = 1, 1 lines = [\\"1\\"] assert read_grid_and_find_max_of_mins(n, m, lines) == 1","solution":"def max_of_mins(grid): Find the maximum value among the minimum values of each row in the grid. Parameters: grid (list of lists of int): The input grid Returns: int: The maximum value among the minimum values of each row # Finding the minimum value in each row min_values = [min(row) for row in grid] # Finding the maximum value among those minimum values return max(min_values) def read_grid_and_find_max_of_mins(n, m, lines): Create grid from input and compute the maximum value among the minimum values of each row. Parameters: n (int): Number of rows m (int): Number of columns lines (list of str): List of strings representing each row of the grid Returns: int: The maximum value among the minimum values of each row grid = [] for line in lines: grid.append(list(map(int, line.split()))) return max_of_mins(grid)"},{"question":"def minimum_spanning_tree(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> int: Find the minimum spanning tree (MST) of a weighted undirected graph. Arguments: n : int : the number of nodes in the graph. m : int : the number of edges in the graph. edge_list : List[Tuple[int, int, int]] : list of edges where each edge is represented as a tuple (u, v, w), with \`u\` and \`v\` being nodes connected by the edge and \`w\` being the weight. Returns: int : the total weight of the MST or -1 if a MST cannot be formed. Example: >>> minimum_spanning_tree(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 6 >>> minimum_spanning_tree(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> minimum_spanning_tree(1, 0, []) 0 >>> minimum_spanning_tree(2, 1, [(1, 2, 1)]) 1 >>> minimum_spanning_tree(5, 7, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (3, 4, 3), (4, 5, 4), (3, 5, 5)]) 10","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda x: x[2]) parent = [] rank = [] mst_weight = 0 mst_edges = 0 for node in range(n): parent.append(node) rank.append(0) for u, v, w in edges: u -= 1 v -= 1 x = find(parent, u) y = find(parent, v) if x != y: mst_edges += 1 mst_weight += w union(parent, rank, x, y) if mst_edges == n - 1: break if mst_edges != n - 1: return -1 return mst_weight def minimum_spanning_tree(n, m, edge_list): return kruskal_mst(n, edge_list) # Example usage n = 4 m = 5 edge_list = [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)] print(minimum_spanning_tree(n, m, edge_list)) # Output: 6"},{"question":"from typing import List def max_candy(candies: List[int]) -> int: Returns the maximum amount of candy that can be collected. >>> max_candy([1, 2, 3, 1]) 4 >>> max_candy([2, 7, 9, 3, 1]) 12 >>> max_candy([10]) 10 >>> max_candy([3, 10]) 10","solution":"from typing import List def max_candy(candies: List[int]) -> int: Returns the maximum amount of candy that can be collected. if not candies: return 0 n = len(candies) if n == 1: return candies[0] if n == 2: return max(candies[0], candies[1]) dp = [0] * n dp[0] = candies[0] dp[1] = max(candies[0], candies[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + candies[i]) return dp[n-1]"},{"question":"from typing import List, Tuple, Union def find_plants_for_animals(n: int, m: int, preferences: List[Tuple[int, int]]) -> Union[List[int], str]: Ensure each type of animal gets at least one plant it prefers. Args: n: The number of types of plants. m: The number of types of animals. preferences: A list of tuples where each tuple represents (plant, animal). Returns: A list of m distinct integers denoting the indices of the selected plants, one for each animal. If there is no valid selection, return \\"Impossible\\". Example: >>> find_plants_for_animals(5, 3, [(1, 1), (2, 1), (3, 2), (4, 2), (5, 3)]) [1, 3, 5] >>> find_plants_for_animals(3, 3, [(1, 1), (2, 2), (3, 3)]) [1, 2, 3] >>> find_plants_for_animals(4, 3, [(1, 1), (1, 2), (2, 2), (3, 3)]) # Output can be different valid selection. >>> find_plants_for_animals(2, 3, [(1, 1), (1, 2), (2, 3)]) \\"Impossible\\" # Unit Test def test_find_plants_for_animals(): # Test case 1 n, m = 5, 3 preferences = [(1, 1), (2, 1), (3, 2), (4, 2), (5, 3)] assert find_plants_for_animals(n, m, preferences) == [1, 3, 5] # Test case 2 n, m = 3, 3 preferences = [(1, 1), (2, 2), (3, 3)] assert find_plants_for_animals(n, m, preferences) == [1, 2, 3] # Test case 3 n, m = 4, 3 preferences = [(1, 1), (1, 2), (2, 2), (3, 3)] expected = find_plants_for_animals(n, m, preferences) assert set(expected) == {1, 2, 3} # Test case 4 n, m = 2, 3 preferences = [(1, 1), (1, 2), (2, 3)] assert find_plants_for_animals(n, m, preferences) == \\"Impossible\\" # Test case 5 n, m = 6, 6 preferences = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)] assert find_plants_for_animals(n, m, preferences) == [1, 2, 3, 4, 5, 6] # Test case 6 n, m = 2, 1 preferences = [(1, 1), (2, 1)] expected = find_plants_for_animals(n, m, preferences) assert expected in [[1], [2]]","solution":"def find_plants_for_animals(n, m, preferences): from collections import defaultdict import itertools # Create a mapping of animals to plants they prefer animal_to_plants = defaultdict(list) for plant, animal in preferences: animal_to_plants[animal].append(plant) # Function to recursively check if a valid combination is possible def check_combination(animals, selected_plants): if not animals: return selected_plants current_animal = animals[0] for plant in animal_to_plants[current_animal]: if plant not in selected_plants: result = check_combination(animals[1:], selected_plants + [plant]) if result: return result return None # Generate the list of animals animals = list(range(1, m + 1)) # Check for valid plant combinations result = check_combination(animals, []) if result: return result else: return \\"Impossible\\""},{"question":"def longest_common_subarray(A: List[int], B: List[int]) -> int: Finds the length of the longest contiguous subarray present in both A and B. >>> longest_common_subarray([1, 2, 3, 2, 1], [3, 2, 1, 2, 3]) 3 >>> longest_common_subarray([1, 2, 3], [4, 5, 6]) 0 >>> longest_common_subarray([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 5 >>> longest_common_subarray([1, 2, 3], [3, 4, 5]) 1 >>> longest_common_subarray([1, 2, 1, 2, 1], [2, 1, 2, 1, 2]) 4","solution":"def longest_common_subarray(A, B): Finds the length of the longest contiguous subarray present in both A and B. n = len(A) dp = [[0] * (n + 1) for _ in range(n + 1)] max_length = 0 for i in range(n): for j in range(n): if A[i] == B[j]: dp[i + 1][j + 1] = dp[i][j] + 1 max_length = max(max_length, dp[i + 1][j + 1]) return max_length"},{"question":"def unassigned_employees(n: int, k: int) -> int: Returns the number of unassigned employees when \`n\` employees are divided into \`k\` teams. Parameters: n (int): The number of employees. k (int): The number of teams. Returns: int: The number of unassigned employees. pass def test_unassigned_employees_example(): assert unassigned_employees(10, 3) == 1 def test_unassigned_employees_exact_division(): assert unassigned_employees(12, 3) == 0 assert unassigned_employees(15, 5) == 0 assert unassigned_employees(7, 7) == 0 def test_unassigned_employees_more_employees_than_teams(): assert unassigned_employees(5, 2) == 1 assert unassigned_employees(10, 6) == 4 assert unassigned_employees(11, 8) == 3 def test_unassigned_employees_more_teams_than_employees(): assert unassigned_employees(2, 4) == 2 assert unassigned_employees(3, 5) == 3 def test_unassigned_employees_one_team(): assert unassigned_employees(999999, 1) == 0 def test_unassigned_employees_one_employee_per_team(): assert unassigned_employees(1000000000, 1000000000) == 0 def test_unassigned_employees_minimal_values(): assert unassigned_employees(1, 1) == 0 assert unassigned_employees(1, 2) == 1 assert unassigned_employees(2, 1) == 0","solution":"def unassigned_employees(n, k): Returns the number of unassigned employees when \`n\` employees are divided into \`k\` teams. Parameters: n (int): The number of employees. k (int): The number of teams. Returns: int: The number of unassigned employees. return n % k"},{"question":"def can_form_team(n: int, skills: List[int], target: int) -> bool: Determines whether it is possible to form a team of workers whose combined skill rating equals the target rating. >>> can_form_team(5, [12, 34, 45, 22, 17], 56) True >>> can_form_team(4, [23, 30, 46, 56], 100) False >>> can_form_team(1, [50], 50) True >>> can_form_team(1, [10], 50) False >>> can_form_team(3, [10, 20, 30], 60) True >>> can_form_team(3, [10, 20, 30], 50) True >>> can_form_team(4, [1, 2, 3, 4], 10) True >>> can_form_team(4, [3, 5, 7, 9], 29) False >>> can_form_team(5, [1, 2, 3, 4, 5], 10000) False >>> can_form_team(4, [20, 20, 20, 20], 40) True","solution":"def can_form_team(n, skills, target): Returns True if it is possible to form a team of workers whose combined skill rating equals the target, and False otherwise. # Initialize a dp array where dp[i] will be True if sum i can be formed using # given skill ratings, False otherwise. dp = [False] * (target + 1) dp[0] = True # because zero sum can always be formed with an empty set. # Iterate over skills for skill in skills: for t in range(target, skill - 1, -1): if dp[t - skill]: dp[t] = True return dp[target]"},{"question":"from typing import List def min_operations_to_non_decreasing(arr: List[int]) -> int: Returns the minimum number of operations required to make the array non-decreasing. Args: arr: List[int] - Array of integers Returns: int - Minimum number of operations to make the array non-decreasing Examples: >>> min_operations_to_non_decreasing([3, 1, 2, 1, 5]) 5 >>> min_operations_to_non_decreasing([1, 1, 1, 1]) 0 >>> min_operations_to_non_decreasing([1, 2, 3, 4, 5]) 0 >>> min_operations_to_non_decreasing([10, 1]) 9 >>> min_operations_to_non_decreasing([5]) 0 import pytest def test_min_operations_to_non_decreasing(): assert min_operations_to_non_decreasing([1, 1, 1, 1]) == 0 assert min_operations_to_non_decreasing([1, 2, 3, 4, 5]) == 0 assert min_operations_to_non_decreasing([3, 1, 2, 1, 5]) == 5 assert min_operations_to_non_decreasing([5]) == 0 assert min_operations_to_non_decreasing([10, 1]) == 9 assert min_operations_to_non_decreasing([1, 10]) == 0 assert min_operations_to_non_decreasing([1000000000, 1]) == 999999999 assert min_operations_to_non_decreasing([5, 4, 3, 2, 1]) == 10","solution":"def min_operations_to_non_decreasing(arr): Returns the minimum number of operations required to make the array non-decreasing. n = len(arr) if n <= 1: return 0 operations = 0 for i in range(1, n): if arr[i] < arr[i - 1]: operations += (arr[i - 1] - arr[i]) arr[i] = arr[i - 1] return operations"},{"question":"def magical_sequence(t: int, cases: List[Tuple[int, int, List[int]]]) -> List[List[int]]: Alice has recently discovered a magical sequence of numbers and she wants you to help her with it. A sequence of numbers is considered magical if it follows a particular transformation rule for a specified number of steps. You are given an array \`a\` of \`n\` integers and an integer \`m\`. Each transformation involves multiplying each element of the array by its index (1-based) and then taking the absolute result. Alice wants to know the state of the array after exactly \`m\` transformations. Each test contains multiple test cases. The first line contains the number of cases \`t\` (\`1 <= t <= 50\`). Description of the test cases follows. The first line of each test case contains two integers \`n\` and \`m\` (\`1 <= n <= 10^5, 1 <= m <= 10^9\`) – the length of the array and the number of transformations to perform. The second line of each test case contains \`n\` integers \`a_{1},a_{2},...,a_{n}\` (\`-10^6 <= a_{i} <= 10^6\`) – the initial contents of the array. It is guaranteed that the sum of \`n\` over all test cases does not exceed \`10^5\`. For each case, return the final version of array \`a\` after \`m\` transformations. >>> test_single_case() == [[1, 4, 9, 16]] >>> test_multiple_cases() == [[2, 6, 15], [1, 8]] >>> test_zero_element_case() == [[0]] >>> test_all_negative_elements() == [[1, 4, 9]] >>> test_large_array() == [[1, 4, 9, 16, 25]]","solution":"def magical_sequence(t, cases): results = [] for case in cases: n, m, arr = case # We only need to perform one transformation result = [abs(arr[i] * (i + 1)) for i in range(n)] results.append(result) return results"},{"question":"def longest_common_substring_length(s1: str, s2: str) -> int: Returns the length of the longest common substring between any left-rotated version of s1 and s2. >>> longest_common_substring_length(\\"1234\\", \\"3412\\") 4 >>> longest_common_substring_length(\\"abcd\\", \\"efgh\\") 0 >>> longest_common_substring_length(\\"abcde\\", \\"cdefg\\") 3 >>> longest_common_substring_length(\\"abcdef\\", \\"abcdef\\") 6 >>> longest_common_substring_length(\\"a\\", \\"a\\") 1 >>> longest_common_substring_length(\\"a\\", \\"b\\") 0 >>> longest_common_substring_length(\\"12345\\", \\"45123\\") 5 >>> longest_common_substring_length(\\"abcdef\\", \\"defabc\\") 6 >>> longest_common_substring_length(\\"abcdef\\", \\"dabcef\\") 3","solution":"def longest_common_substring_length(s1, s2): Returns the length of the longest common substring between any left-rotated version of s1 and s2. def longest_common_substring(s1, s2): Helper function to find the longest common substring between two strings. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] max_len = 0 for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len max_len = 0 # Try all rotations of s1 for i in range(len(s1)): rotated_s1 = s1[i:] + s1[:i] max_len = max(max_len, longest_common_substring(rotated_s1, s2)) return max_len"},{"question":"def min_steps(grid: List[List[str]], N: int, M: int, sr: int, sc: int, dr: int, dc: int) -> int: Determine the minimum number of steps required for Li to reach the destination or return -1 if not possible. >>> min_steps([ ... ['.', '.', '.', '.', '.'], ... ['.', '#', '#', '#', '.'], ... ['.', '.', '.', '.', '.'], ... ['.', '#', '#', '#', '.'], ... ['.', '.', '.', '.', '.'] ... ], 5, 5, 1, 1, 5, 5) 8 >>> min_steps([ ... ['.', '.', '.', '.', '.'], ... ['.', '.', '.', '.', '.'], ... ['.', '.', '.', '.', '.'], ... ['.', '.', '.', '.', '.'] ... ], 4, 4, 1, 1, 4, 4) 6 # Implementation here def min_steps_from_input(input_str: str) -> int: Parse the input string and return the minimum number of steps. >>> min_steps_from_input(\\"5 5n.....n.#.n.....n.#.n.....n1 1 5 5\\") 8 >>> min_steps_from_input(\\"4 4n....n....n....n....n1 1 4 4\\") 6 >>> min_steps_from_input(\\"1 5n.....n1 1 1 5\\") 4 >>> min_steps_from_input(\\"5 1n.n.n.n.n.n1 1 5 1\\") 4 >>> min_steps_from_input(\\"3 3n#n#.#n#n2 2 1 1\\") -1 >>> min_steps_from_input(\\"3 3n...n.#.n...n2 2 2 2\\") 0 # Implementation here","solution":"from collections import deque def min_steps(grid, N, M, sr, sc, dr, dc): # Convert from 1-based to 0-based indexes sr -= 1 sc -= 1 dr -= 1 dc -= 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(sr, sc, 0)]) # (row, col, steps) visited = set() visited.add((sr, sc)) while queue: x, y, steps = queue.popleft() if x == dr and y == dc: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1 def min_steps_from_input(input_str): lines = input_str.strip().split('n') N, M = map(int, lines[0].strip().split()) grid = [list(lines[i + 1].strip()) for i in range(N)] sr, sc, dr, dc = map(int, lines[N + 1].strip().split()) return min_steps(grid, N, M, sr, sc, dr, dc)"},{"question":"def longest_subarray_with_non_zero_and(n: int, arr: List[int]) -> int: Finds the length of the longest subarray with non-zero bitwise AND. Parameters: n (int): Length of the input array arr (list of int): The input array Returns: int: The length of the longest subarray with non-zero bitwise AND >>> longest_subarray_with_non_zero_and(5, [1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_non_zero_and(3, [4, 8, 16]) 1","solution":"def longest_subarray_with_non_zero_and(n, arr): Finds the length of the longest subarray with non-zero bitwise AND. Parameters: n (int): Length of the input array arr (list of int): The input array Returns: int: The length of the longest subarray with non-zero bitwise AND max_length = 1 current_length = 1 for i in range(1, n): if (arr[i] & arr[i-1]) > 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List, Tuple def minimum_maximum_edge(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Calculate the minimum possible value for the longest hyperspace route in a network ensuring that every planet can communicate with every other planet. Args: n (int): Number of planets. m (int): Number of hyperspace routes. edges (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers (u, v, w), representing a hyperspace route between planets u and v with length w. Returns: int: The minimum possible value for the longest hyperspace route in the required network. Example: >>> minimum_maximum_edge(4, 5, [(1, 2, 3), (1, 3, 5), (2, 3, 4), (2, 4, 6), (3, 4, 2)]) 4 pass # Unit Tests def test_minimum_maximum_edge_example(): n = 4 m = 5 edges = [ (1, 2, 3), (1, 3, 5), (2, 3, 4), (2, 4, 6), (3, 4, 2) ] assert minimum_maximum_edge(n, m, edges) == 4 def test_minimum_maximum_edge_case1(): n = 3 m = 3 edges = [ (1, 2, 1), (2, 3, 3), (1, 3, 2) ] assert minimum_maximum_edge(n, m, edges) == 2 def test_minimum_maximum_edge_case2(): n = 5 m = 7 edges = [ (1, 2, 3), (1, 3, 1), (3, 4, 4), (2, 4, 2), (4, 5, 3), (3, 5, 5), (2, 5, 4) ] assert minimum_maximum_edge(n, m, edges) == 3 def test_minimum_maximum_edge_case3(): n = 2 m = 1 edges = [ (1, 2, 10) ] assert minimum_maximum_edge(n, m, edges) == 10","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): rootU = self.find(u) rootV = self.find(v) if rootU != rootV: if self.rank[rootU] > self.rank[rootV]: self.parent[rootV] = rootU elif self.rank[rootU] < self.rank[rootV]: self.parent[rootU] = rootV else: self.parent[rootV] = rootU self.rank[rootU] += 1 def minimum_maximum_edge(n, m, edges): uf = UnionFind(n) edges.sort(key=lambda x: x[2]) max_edge = 0 for u, v, w in edges: if uf.find(u - 1) != uf.find(v - 1): uf.union(u - 1, v - 1) max_edge = max(max_edge, w) if uf.find(0) == uf.find(n - 1): break return max_edge # Example usage n = 4 m = 5 edges = [ (1, 2, 3), (1, 3, 5), (2, 3, 4), (2, 4, 6), (3, 4, 2) ] print(minimum_maximum_edge(n, m, edges)) # Output: 4"},{"question":"class ContactManager: def __init__(self): self.contacts = [] def add_contact(self, contact): Adds a contact to the contact list if the email is unique. :type contact: dict :param contact: A dictionary with keys 'name', 'email', 'phone' :rtype: bool :return: \`True\` if the contact was added successfully, otherwise \`False\` >>> cm = ContactManager() >>> cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) True >>> cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) False pass def delete_contact(self, email): Deletes a contact from the contact list by email. :type email: str :param email: The email of the contact to be deleted :rtype: bool :return: \`True\` if the contact was deleted successfully, otherwise \`False\` >>> cm = ContactManager() >>> cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) True >>> cm.delete_contact('alice@example.com') True >>> cm.delete_contact('alice@example.com') False pass def search_contact(self, email): Searches for a contact by email. :type email: str :param email: The email of the contact to be searched :rtype: dict or None :return: The contact dictionary if found, otherwise \`None\` >>> cm = ContactManager() >>> cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) True >>> cm.search_contact('alice@example.com') {'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'} >>> cm.search_contact('bob@example.com') None pass def test_add_contact(): cm = ContactManager() result = cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) assert result == True result = cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) assert result == False def test_delete_contact(): cm = ContactManager() cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) result = cm.delete_contact('alice@example.com') assert result == True result = cm.delete_contact('alice@example.com') assert result == False def test_search_contact(): cm = ContactManager() cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) result = cm.search_contact('alice@example.com') assert result == {'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'} result = cm.search_contact('bob@example.com') assert result == None def test_add_and_delete_contact_combined(): cm = ContactManager() assert cm.add_contact({'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'}) == True assert cm.search_contact('alice@example.com') == {'name': 'Alice', 'email': 'alice@example.com', 'phone': '1234567890'} assert cm.delete_contact('alice@example.com') == True assert cm.search_contact('alice@example.com') == None","solution":"class ContactManager: def __init__(self): self.contacts = [] def add_contact(self, contact): :type contact: dict :rtype: bool # Check if contact with same email already exists for c in self.contacts: if c['email'] == contact['email']: return False self.contacts.append(contact) return True def delete_contact(self, email): :type email: str :rtype: bool for c in self.contacts: if c['email'] == email: self.contacts.remove(c) return True return False def search_contact(self, email): :type email: str :rtype: dict or None for c in self.contacts: if c['email'] == email: return c return None"},{"question":"def min_path_sum(matrix): Computes the minimum path sum from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. :param matrix: List[List[int]] - The matrix of non-negative integers. :return: int - The minimum path sum. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2], [1, 1]]) 3 >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 2, 3, 4]]) 10 >>> min_path_sum([[1], [2], [3], [4]]) 10 >>> min_path_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def min_path_sum(matrix): Computes the minimum path sum from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. :param matrix: List[List[int]] - The matrix of non-negative integers. :return: int - The minimum path sum. m = len(matrix) n = len(matrix[0]) # Initialize the dp array with the same dimensions as matrix dp = [[0] * n for _ in range(m)] # Initialize the top-left corner dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for i in range(1, n): dp[0][i] = dp[0][i-1] + matrix[0][i] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"import math from typing import List, Tuple def minimum_total_time(n: int, tasks: List[Tuple[int, int]]) -> int: Returns the minimum total time required to solve all tasks when each pair of programmers works on solving tasks together. Parameters: n (int): Number of tasks. tasks (list of tuples): Each tuple contains two integers di and ti. Returns: int: Minimum total time required. pass # Example Test Cases def test_example_case(): tasks = [(3, 6), (2, 8), (1, 5)] assert minimum_total_time(3, tasks) == 11 def test_single_task(): assert minimum_total_time(1, [(1, 1)]) == 1 assert minimum_total_time(1, [(10, 100)]) == 10 def test_multiple_tasks(): tasks = [(5, 12), (4, 8), (3, 9), (2, 10), (1, 5)] assert minimum_total_time(5, tasks) == 18 def test_max_values(): tasks = [(10000, 10000)] * 100000 assert minimum_total_time(100000, tasks) == 100000 def test_min_values(): tasks = [(1, 1)] * 100000 assert minimum_total_time(100000, tasks) == 100000","solution":"import math def minimum_total_time(n, tasks): Returns the minimum total time required to solve all tasks when each pair of programmers works on solving tasks together. Parameters: n (int): Number of tasks. tasks (list of tuples): Each tuple contains two integers di and ti. Returns: int: Minimum total time required. # Sort tasks based on the ratio (ti / di) tasks.sort(key=lambda x: x[1] / x[0], reverse=True) total_time = 0 for di, ti in tasks: total_time += math.ceil(ti / di) return total_time"},{"question":"from typing import List def can_form_palindrome(strings: List[str]) -> List[str]: Given a list of strings, determine if each one can be rearranged to form a palindrome. The function takes in a list of strings and returns a list of \\"YES\\" or \\"NO\\" for each string indicating if the palindrome formation is possible. >>> can_form_palindrome([\\"aabb\\", \\"abc\\", \\"a\\"]) ['YES', 'NO', 'YES'] >>> can_form_palindrome([\\"abc\\" , \\"abcd\\"]) ['NO', 'NO']","solution":"from collections import Counter def can_form_palindrome(strings): Given a list of strings, determine if each one can be rearranged to form a palindrome. results = [] for s in strings: char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count > 1: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def max_teams(n: int, m: int, incompatible_pairs: List[Tuple[int, int]]) -> int: Count the maximum number of teams that can be formed considering the incompatible pairs. Args: n -- number of employees m -- number of incompatible pairs incompatible_pairs -- list of tuples representing pairs of incompatible employees Returns: int -- the maximum number of teams that can be formed Example: >>> max_teams(5, 3, [(1, 2), (1, 3), (4, 5)]) 2 >>> max_teams(4, 0, []) 2 >>> max_teams(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 0","solution":"def max_teams(n, m, incompatible_pairs): from itertools import combinations # Initialize compatibility as all pairs are compatible compatible = [[True] * n for _ in range(n)] # Mark incompatible pairs for a, b in incompatible_pairs: compatible[a-1][b-1] = False compatible[b-1][a-1] = False # Recursive function to form pairs def form_pairs(i, taken): if i == n: return 0 if taken[i]: return form_pairs(i + 1, taken) max_formed = 0 taken[i] = True for j in range(i + 1, n): if not taken[j] and compatible[i][j]: taken[j] = True max_formed = max(max_formed, 1 + form_pairs(i + 1, taken)) taken[j] = False taken[i] = False return max(max_formed, form_pairs(i + 1, taken)) return form_pairs(0, [False] * n) # Sample Usage n = 5 m = 3 incompatible_pairs = [(1, 2), (1, 3), (4, 5)] print(max_teams(n, m, incompatible_pairs)) # Output: 2"},{"question":"def longestSubarray(nums: List[int], k: int) -> int: Returns the length of the longest subarray such that the absolute difference between any two elements in the subarray is less than or equal to k. :param nums: List[int] - List of integers to form subarray from :param k: int - Maximum allowable difference between any two elements in the subarray :return: int - Length of longest valid subarray >>> longestSubarray([8, 2, 4, 7], 4) 2 >>> longestSubarray([10, 1, 2, 4, 7, 2], 5) 4 import pytest def test_example_1(): nums = [8, 2, 4, 7] k = 4 assert longestSubarray(nums, k) == 2 def test_example_2(): nums = [10, 1, 2, 4, 7, 2] k = 5 assert longestSubarray(nums, k) == 4 def test_single_element(): nums = [1] k = 1 assert longestSubarray(nums, k) == 1 def test_all_elements_same(): nums = [1, 1, 1, 1] k = 0 assert longestSubarray(nums, k) == 4 def test_all_elements_different_less_than_k(): nums = [1, 2, 3, 4, 5] k = 5 assert longestSubarray(nums, k) == 5 def test_large_difference(): nums = [1, 1000000000] k = 999999999 assert longestSubarray(nums, k) == 2 def test_subarray_in_middle(): nums = [1, 2, 3, 10, 2, 3] k = 1 assert longestSubarray(nums, k) == 2 def test_negative_numbers(): nums = [-1, -2, -3, -10, -2, -3] k = 1 assert longestSubarray(nums, k) == 2","solution":"from collections import deque def longestSubarray(nums, k): Returns the length of the longest subarray such that the absolute difference between any two elements in the subarray is less than or equal to k. :param nums: List[int] - List of integers to form subarray from :param k: int - Maximum allowable difference between any two elements in the subarray :return: int - Length of longest valid subarray min_deque = deque() # Store indices of elements in increasing order max_deque = deque() # Store indices of elements in decreasing order left = 0 # Left pointer of the window max_len = 0 # Maximum length of the window for right in range(len(nums)): # Maintain min_deque while min_deque and nums[min_deque[-1]] > nums[right]: min_deque.pop() min_deque.append(right) # Maintain max_deque while max_deque and nums[max_deque[-1]] < nums[right]: max_deque.pop() max_deque.append(right) # Shrink the window if the condition is violated while nums[max_deque[0]] - nums[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"def is_path_exists(N, M, grid): Determines if there is a path from the top-left to the bottom-right of the grid. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (list of str): Grid representation with '.' for empty cells and '#' for obstacles. Returns: str: \\"YES\\" if a path exists, otherwise \\"NO\\". >>> is_path_exists(4, 5, [\\".....\\", \\".#...\\", \\".#.#.\\", \\".....\\"]) 'YES' >>> is_path_exists(4, 5, [\\"....#\\", \\"#.#\\", \\"#....\\", \\"#\\"]) 'NO' >>> is_path_exists(4, 5, [\\".#...\\", \\".#.#.\\", \\".#.#.\\", \\".....\\"]) 'YES' >>> is_path_exists(2, 2, [\\".#\\", \\"#.\\"]) 'NO' >>> is_path_exists(2, 2, [\\"..\\", \\"..\\"]) 'YES'","solution":"def is_path_exists(N, M, grid): Determines if there is a path from the top-left to the bottom-right of the grid. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (list of str): Grid representation with '.' for empty cells and '#' for obstacles. Returns: str: \\"YES\\" if a path exists, otherwise \\"NO\\". from collections import deque # Directions for up, down, left, right movements directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * M for _ in range(N)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() # If we've reached the bottom-right corner if x == N - 1 and y == M - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def missingPositive(nums: List[int]) -> int: Returns the smallest positive integer that does not appear in the array nums. >>> missingPositive([3, 4, -1, 1]) 2 >>> missingPositive([1, 2, 0]) 3 >>> missingPositive([-7, -8, -9, -11, -12]) 1","solution":"def missingPositive(nums): Returns the smallest positive integer that does not appear in the array nums. n = len(nums) # First pass to remove non-positive numbers and numbers larger than n for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Second pass to mark the presence of elements for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Third pass to find the first positive index for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def final_position(N: int, M: int, X: int, Y: int, S: str) -> (int, int): Determine the final position of the robot after it executes a given sequence of commands from a specific starting position. The grid is represented as an N x M matrix with (1, 1) as the top-left corner and (N, M) as the bottom-right corner. >>> final_position(5, 5, 3, 3, \\"UUURRDDL\\") (1, 5) >>> final_position(5, 5, 1, 1, \\"RRR\\") (1, 4) >>> final_position(5, 5, 5, 5, \\"LLLL\\") (5, 1) >>> final_position(5, 5, 1, 3, \\"U\\") (1, 3) >>> final_position(5, 5, 1, 5, \\"UUUUU\\") (1, 5) >>> final_position(5, 5, 5, 2, \\"D\\") (5, 2) >>> final_position(5, 5, 5, 1, \\"DDDDD\\") (5, 1) >>> final_position(5, 5, 3, 1, \\"L\\") (3, 1) >>> final_position(5, 5, 4, 1, \\"LLL\\") (4, 1) >>> final_position(5, 5, 2, 5, \\"R\\") (2, 5) >>> final_position(5, 5, 1, 5, \\"RRRR\\") (1, 5)","solution":"def final_position(N, M, X, Y, S): # Iterate over each command in the sequence for command in S: if command == 'U': if X > 1: X -= 1 elif command == 'D': if X < N: X += 1 elif command == 'L': if Y > 1: Y -= 1 elif command == 'R': if Y < M: Y += 1 return X, Y"},{"question":"def can_find_distinct_integers(n: int) -> str: Determine if there exist distinct integers a and b such that 2 * a + 3 * b = n. >>> can_find_distinct_integers(8) \\"Yes\\" >>> can_find_distinct_integers(11) \\"Yes\\" >>> can_find_distinct_integers(1) \\"No\\" >>> can_find_distinct_integers(4) \\"No\\" >>> can_find_distinct_integers(2) \\"No\\" >>> can_find_distinct_integers(3) \\"No\\"","solution":"def can_find_distinct_integers(n): Determines if there exist distinct integers a and b such that 2 * a + 3 * b = n. # We iterate over possible values of \`a\` and check if \`(n - 2*a) % 3 == 0\` and corresponds to a non-negative \`b\` for a in range(1, n//2 + 1): if (n - 2 * a) % 3 == 0: b = (n - 2 * a) // 3 if b > 0 and b != a: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List def can_make_equal(arr: List[int]) -> bool: Determine if it is possible to make all elements of the array equal by performing the specified operation any number of times. Parameters: arr (List[int]): The list of integers. Returns: bool: True if it is possible to make all elements equal, False otherwise. Examples: >>> can_make_equal([2, 4, 8]) True >>> can_make_equal([1, 2, 4]) False >>> can_make_equal([5]) True >>> can_make_equal([7, 7, 7]) True >>> can_make_equal([1, 1, 1000000]) False >>> can_make_equal([4, 8]) True >>> can_make_equal([3, 5]) True >>> can_make_equal([1000000000, 1000000010]) True >>> can_make_equal([1000000000, 1000000001]) False >>> can_make_equal([3, 6, 9, 12, 15, 18, 20]) False","solution":"def can_make_equal(arr): Determines if it is possible to make all elements of the array equal by the specified operation. Parameters: arr (list): The list of integers. Returns: bool: True if it is possible to make all elements equal, False otherwise. arr = sorted(arr) diff = arr[-1] - arr[0] possible = diff == 0 or diff % 2 == 0 return possible"},{"question":"def max_activities(t, test_cases): Determine the maximum number of non-overlapping activities that can be scheduled for each test case. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of test cases, each containing an integer n (the number of activities) and a list of tuples, each with two integers representing the start time and end time of an activity. Returns: List[int]: A list containing the maximum number of non-overlapping activities for each test case. >>> max_activities(2, [(3, [(1, 3), (2, 5), (4, 6)]), (4, [(1, 2), (3, 4), (0, 6), (5, 7)])]) [2, 3] >>> max_activities(1, [(3, [(1, 2), (2, 3), (3, 4)])]) [3] >>> max_activities(1, [(3, [(1, 4), (2, 3), (0, 5)])]) [1]","solution":"def max_activities(t, test_cases): results = [] for i in range(t): n, activities = test_cases[i] activities.sort(key=lambda x: x[1]) # Sort by end time count = 0 end_time = 0 for start, end in activities: if start >= end_time: count += 1 end_time = end results.append(count) return results"},{"question":"def largest_connected_component(n: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph with n nodes and m edges, determine the size of the largest connected component in the graph. Each node represents a user, and an edge between two nodes indicates a friendship between the corresponding users. The input format is as follows: - The first line contains two integers n and m (1 ≤ n, m ≤ 100,000) representing the number of nodes and edges, respectively. - The next m lines each contain two integers u and v (1 ≤ u, v ≤ n, u ≠ v), indicating there's an undirected edge between node u and node v. Output the size of the largest connected component in the graph. Examples: >>> largest_connected_component(10, [(1, 2), (2, 3), (3, 4), (5, 6), (7, 8), (8, 9), (9, 10)]) 4 >>> largest_connected_component(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5","solution":"def largest_connected_component(n, edges): from collections import defaultdict, deque # Create the adjacency list for the graph adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (n + 1) largest_component_size = 0 # Helper function to perform BFS def bfs(node): queue = deque([node]) visited[node] = True component_size = 0 while queue: current = queue.popleft() component_size += 1 for neighbour in adjacency_list[current]: if not visited[neighbour]: visited[neighbour] = True queue.append(neighbour) return component_size # Traverse all nodes to find the largest component for node in range(1, n + 1): if not visited[node]: current_component_size = bfs(node) largest_component_size = max(largest_component_size, current_component_size) return largest_component_size"},{"question":"from typing import List, Tuple def max_score_no_consecutive(N: int, cards: List[int]) -> int: Find the maximum possible total score Bob can achieve under the condition that he cannot pick two consecutive numbers from the deck. Args: - N: An integer representing the number of cards in the deck. - cards: A list of integers representing the numbers on the cards. Returns: An integer representing the maximum possible total score Bob can achieve. >>> max_score_no_consecutive(5, [1, 2, 3, 4, 5]) 9 >>> max_score_no_consecutive(4, [3, 2, 1, 6]) 9 def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to find the maximum possible total score for each. Args: - t: An integer representing the number of test cases. - test_cases: A list of tuples, where each tuple consists of an integer N and a list of integers. Returns: A list of integers representing the maximum possible total score for each test case. # Unit Tests def test_max_score_no_consecutive_basic(): assert max_score_no_consecutive(5, [1, 2, 3, 4, 5]) == 9 assert max_score_no_consecutive(4, [3, 2, 1, 6]) == 9 def test_max_score_no_consecutive_single_card(): assert max_score_no_consecutive(1, [10]) == 10 def test_max_score_no_consecutive_two_cards(): assert max_score_no_consecutive(2, [10, 5]) == 10 assert max_score_no_consecutive(2, [5, 10]) == 10 def test_max_score_no_consecutive_zero_cards(): assert max_score_no_consecutive(0, []) == 0 def test_process_test_cases(): test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [3, 2, 1, 6]) ] assert process_test_cases(2, test_cases) == [9, 9] test_cases = [ (1, [10]), (2, [10, 5]) ] assert process_test_cases(2, test_cases) == [10, 10]","solution":"def max_score_no_consecutive(N, cards): if N == 0: return 0 if N == 1: return cards[0] dp = [0] * N dp[0] = cards[0] dp[1] = max(cards[0], cards[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + cards[i]) return dp[N-1] def process_test_cases(t, test_cases): results = [] for i in range(t): N, cards = test_cases[i] results.append(max_score_no_consecutive(N, cards)) return results"},{"question":"def process_queries(n: int, m: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process the given queries on the array and return the results for sum queries. Args: n: The number of elements in the array. m: The number of queries. array: The list of initial elements in the array. queries: The list of queries, where each query is a tuple. For an update query, the tuple is (1, i, x). For a sum query, the tuple is (2, l, r). Returns: A list of results for each sum query. Example: >>> process_queries(5, 6, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 1, 3), (2, 3, 3), (1, 5, -5), (2, 4, 5)]) [6, 13, 10, -1] >>> process_queries(5, 0, [1, 2, 3, 4, 5], []) [] >>> process_queries(3, 2, [1, 3, 5], [(1, 2, 7), (2, 1, 3)]) [13] >>> process_queries(7, 2, [2, 4, 8, 6, 3, 7, 1], [(2, 1, 7), (2, 2, 5)]) [31, 21]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Initialize the segment tree with the provided array for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = self.tree[2 * index] + self.tree[2 * index + 1] def query(self, left, right): result = 0 left += self.n right += self.n while left < right: if left % 2: result += self.tree[left] left += 1 if right % 2: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result def process_queries(n, m, array, queries): segment_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: _, i, x = query segment_tree.update(i - 1, x) elif query[0] == 2: _, l, r = query results.append(segment_tree.query(l - 1, r)) return results"},{"question":"import heapq from typing import List def sort_nearly_sorted_array(arr: List[int], n: int, k: int) -> List[int]: Sorts a nearly sorted array where each element is at most k positions away from its sorted position. >>> sort_nearly_sorted_array([2, 6, 3, 12, 56, 8], 6, 3) [2, 3, 6, 8, 12, 56] >>> sort_nearly_sorted_array([3, 1, 4, 2, 5], 5, 2) [1, 2, 3, 4, 5] # Function implementation here def handle_input_output(test_cases: List[tuple]) -> List[List[int]]: Handles the input and output for multiple test cases. >>> test_cases = [(6, 3, [2, 6, 3, 12, 56, 8]), (5, 2, [3, 1, 4, 2, 5])] >>> handle_input_output(test_cases) [[2, 3, 6, 8, 12, 56], [1, 2, 3, 4, 5]] results = [] for n, k, arr in test_cases: sorted_array = sort_nearly_sorted_array(arr, n, k) results.append(sorted_array) return results def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) k = int(data[index + 1]) arr = list(map(int, data[index + 2 : index + 2 + n])) test_cases.append((n, k, arr)) index += 2 + n results = handle_input_output(test_cases) for result in results: print(\\" \\".join(map(str, result)))","solution":"import heapq def sort_nearly_sorted_array(arr, n, k): This function sorts a nearly sorted array where each element is at most k positions away from its sorted position. # Create a Min-Heap with the first k+1 elements heap = arr[:k+1] heapq.heapify(heap) # Initialize the index for the output array target_index = 0 # Process the rest of the elements in the array for i in range(k+1, n): # Extract the minimum element and put it in the correct position arr[target_index] = heapq.heappop(heap) target_index += 1 # Add the current element to the heap heapq.heappush(heap, arr[i]) # Extract remaining elements from heap and place them in array while heap: arr[target_index] = heapq.heappop(heap) target_index += 1 return arr def handle_input_output(test_cases): results = [] for n, k, arr in test_cases: sorted_array = sort_nearly_sorted_array(arr, n, k) results.append(sorted_array) return results def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): n = int(data[index]) k = int(data[index+1]) arr = list(map(int, data[index+2:index+2+n])) test_cases.append((n, k, arr)) index += 2 + n results = handle_input_output(test_cases) for result in results: print(\\" \\".join(map(str, result)))"},{"question":"def max_subset_sum(arr: List[int]) -> int: Returns the maximum sum of a subset of the given array. The subset can include the entire array or be an empty subset. >>> max_subset_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subset_sum([1]) 1 >>> max_subset_sum([-1, -2, -3, -4]) 0","solution":"def max_subset_sum(arr): Returns the maximum sum of a subset of the given array. Uses Kadane's Algorithm to find the maximum sum of a contiguous subarray. if not arr: return 0 max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max(max_sum, 0)"},{"question":"def longestArithmeticSubsequence(arr): Returns the length of the longest arithmetic subsequence in the array. >>> longestArithmeticSubsequence([3, 6, 9, 12, 15, 18]) 6 >>> longestArithmeticSubsequence([9, 7, 5, 3, 2]) 4 >>> longestArithmeticSubsequence([1]) 1 >>> longestArithmeticSubsequence([5, 5, 5, 5, 5]) 5 >>> longestArithmeticSubsequence([10, 7, 4, 1, -2, -5, -8]) 7 >>> longestArithmeticSubsequence([1, 5, 10, 7, 11, 15, 14]) 3 >>> longestArithmeticSubsequence([1000000000, 999999999, 999999998, 999999997]) 4 pass","solution":"def longestArithmeticSubsequence(arr): Returns the length of the longest arithmetic subsequence in the array. from collections import defaultdict n = len(arr) if n <= 1: return n # dp: list of dictionaries dp = [defaultdict(int) for _ in range(n)] longest_length = 1 for i in range(1, n): for j in range(i): diff = arr[i] - arr[j] dp[i][diff] = dp[j][diff] + 1 longest_length = max(longest_length, dp[i][diff]) return longest_length + 1"},{"question":"import heapq from typing import List def min_effort_to_reach_end(n: int, grid: List[List[int]]) -> int: Determine the minimum effort required to move from the top-left corner to the bottom-right corner of the maze. >>> min_effort_to_reach_end(3, [[1, 2, 2], [3, 8, 2], [5, 3, 5]]) == 2 >>> min_effort_to_reach_end(2, [[1, 2], [2, 1]]) == 1 >>> min_effort_to_reach_end(4, [[1, 3, 2, 3], [4, 3, 2, 1], [7, 8, 2, 5], [9, 8, 3, 2]]) == 2 >>> min_effort_to_reach_end(2, [[1, 1000000], [1000000, 1]]) == 999999 >>> min_effort_to_reach_end(2, [[0, 0], [0, 0]]) == 0 >>> min_effort_to_reach_end(3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0 >>> min_effort_to_reach_end(2, [[0, 1], [1, 0]]) == 1 >>> min_effort_to_reach_end(2, [[1000000, 0], [0, 1000000]]) == 1000000","solution":"import heapq def min_effort_to_reach_end(n, grid): def is_valid(x, y): return 0 <= x < n and 0 <= y < n directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] efforts = [[float('inf')] * n for _ in range(n)] pq = [(0, 0, 0)] # (effort, x, y) efforts[0][0] = 0 while pq: current_effort, x, y = heapq.heappop(pq) if x == n-1 and y == n-1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): effort_to_next = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if effort_to_next < efforts[nx][ny]: efforts[nx][ny] = effort_to_next heapq.heappush(pq, (effort_to_next, nx, ny)) return efforts[n-1][n-1] # Example usage def main(): n = int(input()) grid = [list(map(int, input().split())) for _ in range(n)] result = min_effort_to_reach_end(n, grid) print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculate the total amount of rainwater that would be trapped between the buildings after a heavy rainfall. Args: height (List[int]): An array representing the heights of buildings. Returns: int: The total volume of rainwater trapped. Examples: >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9","solution":"from typing import List def trap(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left max height for each position left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right max height for each position right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate water trapped at each position for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def determine_winner(n: int, m: int) -> str: Determines the winner of the game on an n x m grid. If the first player starts, both play optimally, and the first player will win if the minimum dimension of the grid (n or m) is odd; otherwise, the second player wins. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid Returns: str: \\"First\\" if the first player wins, \\"Second\\" if the second player wins Example: >>> determine_winner(4, 4) 'Second' >>> determine_winner(5, 3) 'First'","solution":"def determine_winner(n, m): Determines the winner of the game on an n x m grid. If the first player starts, both play optimally, and the first player will win if the minimum dimension of the grid (n or m) is odd; otherwise, the second player wins. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid Returns: str: \\"First\\" if the first player wins, \\"Second\\" if the second player wins if min(n, m) % 2 == 1: return \\"First\\" else: return \\"Second\\""},{"question":"def length_of_longest_unique_subarray(n: int, arr: List[int]) -> int: Returns the length of the longest contiguous subarray with all unique elements. >>> length_of_longest_unique_subarray(5, [1, 2, 3, 4, 5]) 5 >>> length_of_longest_unique_subarray(5, [1, 2, 2, 3, 4]) 3 >>> length_of_longest_unique_subarray(5, [1, 1, 1, 1, 1]) 1 >>> length_of_longest_unique_subarray(10, [1, 2, 3, 1, 2, 3, 4, 5, 6, 7]) 7 >>> length_of_longest_unique_subarray(6, [1, 2, 1, 2, 1, 2]) 2 >>> length_of_longest_unique_subarray(4, [1000000000, 999999999, 1000000000, 888888888]) 3 >>> length_of_longest_unique_subarray(1, [42]) 1 >>> length_of_longest_unique_subarray(0, []) 0","solution":"def length_of_longest_unique_subarray(n, arr): Returns the length of the longest contiguous subarray with all unique elements. Parameters: n (int): Length of the array arr (List[int]): List of integers Returns: int: Length of the longest contiguous subarray with unique elements if not arr: return 0 max_length = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def minimal_parade_length(n: int, m: int, road_data: List[Tuple[int, int, int]]) -> int: In a magical kingdom, determine the minimal total length of the roads required for a parade route. Parameters: - n (int): Number of castles - m (int): Number of roads - road_data (List[Tuple[int, int, int]]): List of roads, each represented by a tuple (u, v, w) where u and v are castles and w is the length of the road. Returns: - int: Minimal total length of the roads required for the parade route. Example: >>> minimal_parade_length(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 1, 6), (1, 3, 5)]) 9 pass","solution":"def kruskal_minimum_spanning_tree(n, roads): parent = list(range(n)) rank = [0] * n def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] def union(node1, node2): root1 = find(node1) root2 = find(node2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 roads.sort(key=lambda road: road[2]) minimal_weight_sum = 0 for u, v, w in roads: if find(u - 1) != find(v - 1): union(u - 1, v - 1) minimal_weight_sum += w return minimal_weight_sum def minimal_parade_length(n, m, road_data): roads = [] for data in road_data: u, v, w = data roads.append((u, v, w)) return kruskal_minimum_spanning_tree(n, roads)"},{"question":"def place_goods(M: int, N: int, grid: List[str]) -> List[str]: Place goods (denoted by 'G') at the closest empty cell (denoted by '.') to the entrance (0,0). >>> place_goods(5, 7, [ ... \\"..*....\\", ... \\"**.*...\\", ... \\"....*..\\", ... \\"*.***..\\", ... \\".*.....\\" ... ]) [\\"G.*....\\", \\"**.*...\\", \\"....*..\\", \\"*.***..\\", \\".*.....\\"] >>> place_goods(3, 3, [ ... \\".*.\\", ... \\".G*\\", ... \\"***\\" ... ]) [\\"G*.\\", \\".G*\\", \\"***\\"] >>> place_goods(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) [\\"G..\\", \\"...\\", \\"...\\"] >>> place_goods(4, 4, [\\"*...\\", \\"*...\\", \\"****\\", \\"....\\"]) [\\"*G..\\", \\"*...\\", \\"****\\", \\"....\\"]","solution":"from collections import deque def place_goods(M, N, grid): Place goods (denoted by 'G') at the closest empty cell (denoted by '.') to the entrance (0,0). # Convert grid to a list of list of characters grid = [list(row) for row in grid] # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS to find the nearest empty cell ('.') queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if grid[x][y] == '.': grid[x][y] = 'G' break for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] != '*': queue.append((nx, ny)) visited.add((nx, ny)) # Convert grid back to list of strings return [''.join(row) for row in grid]"},{"question":"def largest_palindromic_product(N: int) -> int: Write a function \`largest_palindromic_product\` that finds the largest palindromic number that can be obtained as a product of two N-digit numbers. A palindromic number is one that reads the same forwards and backwards. Parameters: N (int): The number of digits of the two numbers. Returns: int: The largest palindromic product of two N-digit numbers. Raises: ValueError: If N is not between 1 and 4 (inclusive). Examples: >>> largest_palindromic_product(2) 9009 >>> largest_palindromic_product(3) 906609","solution":"def largest_palindromic_product(N): Returns the largest palindromic number that can be obtained as a product of two N-digit numbers. if N < 1 or N > 4: raise ValueError(\\"N must be between 1 and 4.\\") max_num = 10**N - 1 min_num = 10**(N-1) largest_palindrome = 0 for i in range(max_num, min_num - 1, -1): for j in range(i, min_num - 1, -1): product = i * j if product <= largest_palindrome: break if str(product) == str(product)[::-1]: largest_palindrome = product return largest_palindrome"},{"question":"from typing import List def max_coins(levels: List[int]) -> int: Help Alex find the maximum number of coins that can be collected following the game rule. The function takes an integer array \`levels\` where each element represents the number of coins available in that level, and returns the maximum number of coins that can be collected by following the rule that Alex can collect coins in non-adjacent levels only. >>> max_coins([3, 2, 5, 10, 7]) 15 >>> max_coins([3, 2, 7, 10]) 13 >>> max_coins([3]) 3 >>> max_coins([3, 2]) 3 >>> max_coins([2, 7, 9, 3, 1]) 12 >>> max_coins([1, 2, 9, 4, 5, 0, 4, 11, 6]) 26 >>> max_coins([]) 0 >>> max_coins([5, 5, 10, 100, 10, 5]) 110","solution":"from typing import List def max_coins(levels: List[int]) -> int: if not levels: return 0 if len(levels) == 1: return levels[0] n = len(levels) dp = [0] * n dp[0] = levels[0] if n > 1: dp[1] = max(levels[0], levels[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + levels[i]) return dp[-1]"},{"question":"def minimum_toll(n: int, m: int, k: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum sum of tolls of exactly k roads forming a connected subgraph. Args: n (int): Number of intersections. m (int): Number of roads. k (int): Number of roads to select. edges (List[Tuple[int, int, int]]): List of roads, where each road is represented by a tuple (u, v, toll). Returns: int: The minimum sum of tolls for the selected k roads or -1 if not possible. Example: >>> minimum_toll(6, 9, 3, [(1, 2, 5), (1, 3, 3), (2, 3, 6), (2, 4, 2), (3, 4, 4), (3, 5, 8), (4, 5, 7), (4, 6, 1), (5, 6, 9)]) 6 >>> minimum_toll(2, 1, 1, [(1, 2, 10)]) 10 >>> minimum_toll(4, 5, 4, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (2, 3, 4), (3, 4, 5)]) -1","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_toll(n, m, k, edges): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n mst_edges = [] mst_cost = 0 for edge in edges: u, v, cost = edge if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_edges.append(cost) mst_cost += cost if len(mst_edges) == n - 1: break if len(mst_edges) < k: return -1 if len(mst_edges) == k: return mst_cost extra_edges = [] for edge in edges: u, v, cost = edge if find(parent, u) != find(parent, v): extra_edges.append(cost) all_edges = mst_edges + extra_edges all_edges.sort() return sum(all_edges[:k]) def solution(n, m, k, edge_list): edges = [(u - 1, v - 1, t) for u, v, t in edge_list] return minimum_toll(n, m, k, edges)"},{"question":"def create_city_grid(n: int) -> list[list[int]]: Create a city grid with dimensions n x n where the tallest building in each row and column maximizes the overall scenic view of the city with the overall sum of building heights minimized. :param n: Dimension of the city grid :type n: int :return: A 2D list representing the city grid :rtype: list[list[int]] pass # Example execution with size 3 n = 3 result = create_city_grid(n) for row in result: print(\\" \\".join(map(str, row)))","solution":"def create_city_grid(n): Create a city grid with dimensions n x n where the tallest building in each row and column maximizes the overall scenic view of the city with the overall sum of building heights minimized. :param n: Dimension of the city grid :type n: int :return: A 2D list representing the city grid :rtype: list[list[int]] grid = [[0] * n for _ in range(n)] # Fill the first row with incremental values starting from 1 to n for i in range(n): grid[0][i] = i + 1 # For next rows, ensure the max of columns is maintained with minimal values. for i in range(1, n): for j in range(n): grid[i][j] = n return grid # Example execution n = 3 result = create_city_grid(n) for row in result: print(\\" \\".join(map(str, row)))"},{"question":"def are_necklaces_same(a: str, b: str) -> str: Determines if two necklaces are the same considering rotations. >>> are_necklaces_same(\\"abcde\\", \\"eabcd\\") \\"same\\" >>> are_necklaces_same(\\"xyz\\", \\"yzx\\") \\"same\\" >>> are_necklaces_same(\\"ab\\", \\"ab\\") \\"same\\" >>> are_necklaces_same(\\"abc\\", \\"def\\") \\"distinct\\" >>> are_necklaces_same(\\"a\\", \\"b\\") \\"distinct\\" >>> are_necklaces_same(\\"abc\\", \\"cab\\") \\"same\\" >>> are_necklaces_same(\\"aaaa\\", \\"aaaa\\") \\"same\\" >>> are_necklaces_same(\\"abc\\", \\"abcabc\\") \\"distinct\\" def process_test_cases(t: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases to determine if each pair of strings represents the same necklace. >>> process_test_cases(4, [(\\"abcde\\", \\"eabcd\\"), (\\"xyz\\", \\"yzx\\"), (\\"ab\\", \\"ab\\"), (\\"abc\\", \\"def\\")]) [\\"same\\", \\"same\\", \\"same\\", \\"distinct\\"]","solution":"def are_necklaces_same(a, b): Determines if two necklaces are the same considering rotations. if len(a) != len(b): return \\"distinct\\" concat_a = a + a return \\"same\\" if b in concat_a else \\"distinct\\" def process_test_cases(t, test_cases): Processes multiple test cases to determine if each pair of strings represents the same necklace. results = [] for a, b in test_cases: results.append(are_necklaces_same(a, b)) return results"},{"question":"from collections import Counter def are_similar(s1: str, s2: str) -> str: Determines if two strings s1 and s2 are similar based on the allowed operations. >>> are_similar(\\"abcd\\", \\"abcd\\") 'YES' >>> are_similar(\\"abcd\\", \\"dcba\\") 'YES' >>> are_similar(\\"aabbcc\\", \\"ccbbaa\\") 'YES' >>> are_similar(\\"abc\\", \\"abcd\\") 'NO' >>> are_similar(\\"abcdef\\", \\"ghijkl\\") 'NO' >>> are_similar(\\"abcd\\", \\"abce\\") 'NO' >>> are_similar(\\"a\\", \\"a\\") 'YES' >>> are_similar(\\"a\\", \\"b\\") 'NO'","solution":"from collections import Counter def are_similar(s1, s2): Determines if two strings s1 and s2 are similar based on the allowed operations. return Counter(s1) == Counter(s2)"},{"question":"def count_ways(k: int, dishes: List[int]) -> int: Returns the number of ways two participants can receive dishes from different categories. Parameters: k (int): Number of categories. dishes (list of int): List of the number of dishes in each category. Returns: int: Number of ways to select two dishes from different categories. >>> count_ways(3, [4, 2, 3]) 26 >>> count_ways(2, [1, 1]) 1 >>> count_ways(2, [5, 3]) 15","solution":"def count_ways(k, dishes): Returns the number of ways two participants can receive dishes from different categories. Parameters: k (int): Number of categories. dishes (list of int): List of the number of dishes in each category. Returns: int: Number of ways to select two dishes from different categories. total_ways = 0 for i in range(k): for j in range(i + 1, k): total_ways += dishes[i] * dishes[j] return total_ways"},{"question":"from typing import List, Tuple def preprocess(grid: List[List[int]], n: int, m: int) -> List[List[int]]: Preprocess the grid to create a prefix sum array. Args: grid: 2D list of integers representing the grid. n: Number of rows in the grid. m: Number of columns in the grid. Returns: 2D list of integers representing the prefix sum array. def query_sum(prefix_sum: List[List[int]], x1: int, y1: int, x2: int, y2: int) -> int: Calculate the sum of the subrectangle using the prefix sum array. Args: prefix_sum: 2D list of integers representing the prefix sum array. x1: Row index of the top-left corner of the subrectangle. y1: Column index of the top-left corner. x2: Row index of the bottom-right corner. y2: Column index of the bottom-right corner. Returns: Integer sum of the values in the specified subrectangle. def solve(grid: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Solve all the queries and return the results. Args: grid: 2D list of integers representing the grid. queries: List of tuples where each tuple contains four integers (x1, y1, x2, y2). Returns: List of integers where each integer is the result of a query. # Example usage: # grid = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # queries = [ # (1, 1, 2, 2), # (2, 2, 3, 3) # ] # print(solve(grid, queries)) # Output: [12, 28]","solution":"def preprocess(grid, n, m): prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = (grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) return prefix_sum def query_sum(prefix_sum, x1, y1, x2, y2): return (prefix_sum[x2][y2] - prefix_sum[x1-1][y2] - prefix_sum[x2][y1-1] + prefix_sum[x1-1][y1-1]) def solve(grid, queries): n = len(grid) m = len(grid[0]) if grid else 0 prefix_sum = preprocess(grid, n, m) results = [] for x1, y1, x2, y2 in queries: results.append(query_sum(prefix_sum, x1, y1, x2, y2)) return results"},{"question":"def minimum_moves_to_converge(positions: List[int]) -> int: Finds the minimum total number of moves required to make all elements occupy the same position on the number line. >>> minimum_moves_to_converge([4, 7, 7, 1, 3]) 10 >>> minimum_moves_to_converge([1]) 0 >>> minimum_moves_to_converge([1, 2]) 1 >>> minimum_moves_to_converge([5, 5, 5, 5]) 0 >>> minimum_moves_to_converge([1, 1, 2, 2]) 2 >>> minimum_moves_to_converge([-1000000000, 1000000000]) 2000000000","solution":"def minimum_moves_to_converge(positions): Finds the minimum total number of moves required to make all elements occupy the same position on the number line. # Sorting the positions to find the median positions.sort() # Finding the median N = len(positions) median_position = positions[N // 2] # Calculating total moves total_moves = sum(abs(pos - median_position) for pos in positions) return total_moves"},{"question":"def min_replacements(s: str) -> int: Returns the minimum number of replacements needed such that no two adjacent characters are the same. >>> min_replacements(\\"a\\") 0 >>> min_replacements(\\"b\\") 0 >>> min_replacements(\\"ab\\") 0 >>> min_replacements(\\"abab\\") 0 >>> min_replacements(\\"aab\\") 1 >>> min_replacements(\\"abb\\") 1 >>> min_replacements(\\"baaa\\") 2 >>> min_replacements(\\"aaaaa\\") 4 >>> min_replacements(\\"a\\" * 100) 99 >>> min_replacements(\\"b\\" * 100) 99 >>> min_replacements(\\"ab\\" * 50) 0 >>> min_replacements(\\"ba\\" * 50) 0 >>> min_replacements(\\"\\") 0","solution":"def min_replacements(s): Returns the minimum number of replacements needed such that no two adjacent characters are the same. if not s: return 0 # Track replacements needed replacements = 0 # Iterate through the string, compare each character with the next one for i in range(1, len(s)): if s[i] == s[i - 1]: # If two adjacent characters are the same replacements += 1 return replacements"},{"question":"def sum_even_fibonacci(n: int) -> int: Compute the sum of all even Fibonacci numbers that do not exceed n. :param n: The upper limit for the Fibonacci sequence (1 ≤ n ≤ 4,000,000). :return: The sum of all even Fibonacci numbers ≤ n. >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(1) 0 >>> sum_even_fibonacci(4000000) 4613732 >>> sum_even_fibonacci(89) 44 >>> sum_even_fibonacci(34) 44 >>> sum_even_fibonacci(35) 44","solution":"def sum_even_fibonacci(n): Returns the sum of all even Fibonacci numbers that do not exceed n. :param n: The upper limit for the Fibonacci sequence. :return: The sum of all even Fibonacci numbers ≤ n. a, b = 1, 1 total_sum = 0 while b <= n: if b % 2 == 0: total_sum += b a, b = b, a + b return total_sum"},{"question":"def process_input(input_string: str) -> str: Determine the maximum number of non-overlapping projects for each test case. Each test case contains multiple projects with start and end times. Example: >>> process_input(\\"2n3n1 5n6 10n11 15n4n3 8n2 4n6 7n5 9n\\") '3n2' >>> process_input(\\"1n3n1 3n2 5n4 6n\\") '2'","solution":"def max_non_overlapping_projects(test_cases): results = [] for projects in test_cases: # Sort projects based on end times projects.sort(key=lambda x: x[1]) max_projects = 0 last_end_time = -1 for start, end in projects: if start > last_end_time: max_projects += 1 last_end_time = end results.append(max_projects) return results def parse_input(input_string): input_lines = input_string.strip().split('n') t = int(input_lines[0]) test_cases = [] i = 1 for _ in range(t): p = int(input_lines[i]) i += 1 projects = [] for _ in range(p): s, e = map(int, input_lines[i].split()) projects.append((s, e)) i += 1 test_cases.append(projects) return test_cases def process_input(input_string): test_cases = parse_input(input_string) results = max_non_overlapping_projects(test_cases) return \\"n\\".join(map(str, results))"},{"question":"def longest_palindromic_substring(s: str) -> int: Find the length of the longest substring that can be rearranged to form a palindrome. >>> longest_palindromic_substring(\\"abccccdd\\") 7 >>> longest_palindromic_substring(\\"a\\") 1 >>> longest_palindromic_substring(\\"abc\\") 1","solution":"def longest_palindromic_substring(s: str) -> int: from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True return length + 1 if odd_found else length"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. :param s: String to check. :return: \\"Yes\\" if it can be rearranged to form a palindrome, otherwise \\"No\\". pass def test_can_form_palindrome_example1(): assert can_form_palindrome(\\"aabbcc\\") == \\"Yes\\" def test_can_form_palindrome_example2(): assert can_form_palindrome(\\"abc\\") == \\"No\\" def test_can_form_palindrome_single_char(): assert can_form_palindrome(\\"a\\") == \\"Yes\\" def test_can_form_palindrome_all_unique_chars(): assert can_form_palindrome(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"No\\" def test_can_form_palindrome_repeated_chars(): assert can_form_palindrome(\\"aaabbbbcc\\") == \\"Yes\\" def test_can_form_palindrome_all_identical_chars(): assert can_form_palindrome(\\"aaaa\\") == \\"Yes\\" def test_can_form_palindrome_even_length_odd_frequencies(): assert can_form_palindrome(\\"aaaaabbbb\\") == \\"Yes\\" def test_can_form_palindrome_odd_length_only_one_odd(): assert can_form_palindrome(\\"aaabbbccc\\") == \\"No\\" def test_can_form_palindrome_mixed(): assert can_form_palindrome(\\"abbcabbc\\") == \\"Yes\\" def test_can_form_palindrome_large_input(): assert can_form_palindrome(\\"a\\" * 499 + \\"b\\" * 500 + \\"c\\" * 1) == \\"No\\" assert can_form_palindrome(\\"a\\" * 499 + \\"b\\" * 500 + \\"cc\\") == \\"Yes\\"","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. :param s: String to check. :return: \\"Yes\\" if it can be rearranged to form a palindrome, otherwise \\"No\\". from collections import Counter char_count = Counter(s) # Count how many characters have an odd count odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) # For the string to be rearrangeable into a palindrome, we can have at most one character with an odd count if odd_counts > 1: return \\"No\\" else: return \\"Yes\\""},{"question":"def is_power_of_two(x: int) -> bool: Helper function that checks if a number is a power of two. >>> is_power_of_two(1) True >>> is_power_of_two(2) True >>> is_power_of_two(3) False >>> is_power_of_two(4) True def longest_subsequence_power_of_two(arr: List[int]) -> int: Returns the length of the longest subsequence consisting only of elements which are powers of two. >>> longest_subsequence_power_of_two([3, 8, 4, 1, 7, 2]) 4 >>> longest_subsequence_power_of_two([3, 5, 7, 9]) 0 >>> longest_subsequence_power_of_two([1, 2, 4, 8, 16]) 5 >>> longest_subsequence_power_of_two([0, 1, 2, 3, 4]) 3 >>> longest_subsequence_power_of_two([1024, 2048, 4096, 8192]) 4","solution":"def is_power_of_two(x): Helper function that checks if a number is a power of two. return (x != 0) and ((x & (x - 1)) == 0) def longest_subsequence_power_of_two(arr): Returns the length of the longest subsequence consisting only of elements which are powers of two. power_of_two_elements = [a for a in arr if is_power_of_two(a)] return len(power_of_two_elements)"},{"question":"def max_subgrid_sum(t: int, test_cases: List[Tuple[int, int, int, List[List[int]]]]) -> List[int]: Compute the maximum sum of any k x k subgrid for multiple test cases. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, int, int, List[List[int]]]]): A list of tuples containing the dimensions of the grid, the size of the subgrid, and the grid itself for each test case. Returns: List[int]: A list of maximum sums for each test case. >>> max_subgrid_sum(2, [ ... (3, 3, 2, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), ... (4, 4, 3, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) ... ]) == [28, 99] >>> max_subgrid_sum(1, [ ... (1, 5, 1, [ ... [1, 2, 3, 4, 5] ... ]) ... ]) == [5] >>> max_subgrid_sum(1, [ ... (5, 1, 1, [ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) ... ]) == [5] >>> max_subgrid_sum(1, [ ... (3, 3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) ... ]) == [45] >>> max_subgrid_sum(1, [ ... (4, 4, 2, [ ... [1, 1, 1, 1], ... [1, 9, 9, 1], ... [1, 9, 9, 1], ... [1, 1, 1, 1] ... ]) ... ]) == [36]","solution":"def max_subgrid_sum(t, test_cases): results = [] for test_case in test_cases: n, m, k, grid = test_case max_sum = 0 for i in range(n - k + 1): for j in range(m - k + 1): sum_subgrid = sum( grid[i + x][j + y] for x in range(k) for y in range(k) ) if sum_subgrid > max_sum: max_sum = sum_subgrid results.append(max_sum) return results"},{"question":"def simulate_battle(n, ships, m, attacks): Simulate a series of attacks on a fleet of ships and determine which ships remain. :param n: Integer, number of ships. :param ships: List of tuples, each containing the x-coordinate, y-coordinate, and hit points of a ship. :param m: Integer, number of attacks. :param attacks: List of tuples, each containing the x-coordinate, y-coordinate, and damage of an attack. :returns: List of tuples with coordinates of remaining ships or a string \\"All ships have been destroyed.\\" Example: >>> simulate_battle(3, [(2, 3, 50), (5, 5, 100), (7, 8, 75)], 4, [(2, 3, 30), (5, 5, 50), (7, 8, 100), (2, 3, 25)]) [(5, 5)] >>> simulate_battle(2, [(1, 1, 10), (2, 2, 15)], 2, [(1, 1, 10), (2, 2, 15)]) \\"All ships have been destroyed.\\" pass # Test case 1 n = 3 ships = [(2, 3, 50), (5, 5, 100), (7, 8, 75)] m = 4 attacks = [(2, 3, 30), (5, 5, 50), (7, 8, 100), (2, 3, 25)] print(simulate_battle(n, ships, m, attacks)) # Expected output: [(5, 5)] # Test case 2 n = 2 ships = [(1, 1, 20), (2, 2, 30)] m = 0 attacks = [] print(simulate_battle(n, ships, m, attacks)) # Expected output: [(1, 1), (2, 2)] # Test case 3 n = 2 ships = [(1, 1, 10), (2, 2, 15)] m = 2 attacks = [(1, 1, 10), (2, 2, 15)] print(simulate_battle(n, ships, m, attacks)) # Expected output: \\"All ships have been destroyed.\\" # Test case 4 n = 3 ships = [(1, 1, 20), (2, 2, 30), (3, 3, 40)] m = 2 attacks = [(1, 1, 10), (3, 3, 40)] print(simulate_battle(n, ships, m, attacks)) # Expected output: [(1, 1), (2, 2)]","solution":"def simulate_battle(n, ships, m, attacks): # Creating the grid and mapping initial ship positions with their HP grid = {} for x, y, hp in ships: grid[(x, y)] = hp # Simulate each attack for x, y, damage in attacks: if (x, y) in grid: grid[(x, y)] -= damage if grid[(x, y)] <= 0: del grid[(x, y)] # Prepare the result of remaining ships in the order they appeared result = [] for x, y, hp in ships: if (x, y) in grid: result.append((x, y)) if not result: return \\"All ships have been destroyed.\\" return result"},{"question":"def find_sequence(n: int, heights: List[int]) -> Union[List[int], int]: Returns a valid sequence where heights either strictly increase then strictly decrease, or strictly decrease then strictly increase. If such sequence is impossible, returns -1. Args: n (int): number of dolls. heights (list): list of n distinct integers representing the heights of the dolls. Returns: list or int: a valid sequence if exists, otherwise -1. pass from solution import find_sequence def test_find_sequence_possible_odd_length(): heights = [5, 3, 8, 1, 6] n = len(heights) result = find_sequence(n, heights) assert len(result) == n assert sorted(result) == sorted(heights) def test_find_sequence_possible_even_length(): heights = [5, 3, 8, 1] n = len(heights) result = find_sequence(n, heights) assert len(result) == n assert sorted(result) == sorted(heights) def test_find_sequence_too_short(): heights = [5, 3] n = len(heights) assert find_sequence(n, heights) == -1 def test_find_sequence_sorted_input(): heights = [1, 2, 3, 4, 5, 6, 7, 8, 9] n = len(heights) result = find_sequence(n, heights) assert len(result) == n assert sorted(result) == sorted(heights) def test_find_sequence_single_unique_solution(): heights = [3, 7, 2, 6, 4, 5] n = len(heights) result = find_sequence(n, heights) assert len(result) == n assert sorted(result) == sorted(heights)","solution":"def find_sequence(n, heights): Returns a valid sequence where heights either strictly increase then strictly decrease, or strictly decrease then strictly increase. If such sequence is impossible, returns -1. Args: n (int): number of dolls. heights (list): list of n distinct integers representing the heights of the dolls. Returns: list or int: a valid sequence if exists, otherwise -1. # If n is less than 3, it is impossible to form such a sequence. if n < 3: return -1 # Sort the heights to help in forming the sequence sorted_heights = sorted(heights) # Try to line up the dolls as: # first half to form increasing sequence and the second half to form decreasing sequence first_half = sorted_heights[:n//2] second_half = sorted_heights[n//2:] # If lengths are 3 or more we can form a valid sequence if len(first_half) >= 2 and len(second_half) >= 1: result = first_half + second_half[::-1] return result else: return -1"},{"question":"def subgrid_sum(n: int, m: int, k: int, grid: list[list[int]], operations: list[tuple[int, int, int, int]]) -> list[int]: Returns the sum of elements in the specified subgrids for each operation. :param n: int, number of rows in grid :param m: int, number of columns in grid :param k: int, number of operations :param grid: list of lists of ints, the grid itself :param operations: list of tuples, each tuple containing four integers (x1, y1, x2, y2) :return: list of ints, sums of the specified subgrids pass # Your implementation here def test_example_case(): n = 3 m = 3 k = 2 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operations = [(1, 1, 2, 2), (2, 2, 3, 3)] expected = [12, 28] assert subgrid_sum(n, m, k, grid, operations) == expected def test_single_element_grid(): n = 1 m = 1 k = 1 grid = [ [5] ] operations = [(1, 1, 1, 1)] expected = [5] assert subgrid_sum(n, m, k, grid, operations) == expected def test_entire_grid_sum(): n = 2 m = 2 k = 1 grid = [ [1, 2], [3, 4] ] operations = [(1, 1, 2, 2)] expected = [10] assert subgrid_sum(n, m, k, grid, operations) == expected def test_non_rectangular_grid(): n = 3 m = 2 k = 1 grid = [ [1, 2], [3, 4], [5, 6] ] operations = [(1, 1, 3, 2)] expected = [21] assert subgrid_sum(n, m, k, grid, operations) == expected def test_multiple_operations(): n = 3 m = 3 k = 2 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operations = [(1, 1, 3, 3), (1, 2, 2, 3)] expected = [45, 16] assert subgrid_sum(n, m, k, grid, operations) == expected","solution":"def subgrid_sum(n, m, k, grid, operations): Returns the sum of elements in the specified subgrids for each operation. :param n: int, number of rows in grid :param m: int, number of columns in grid :param k: int, number of operations :param grid: list of lists of ints, the grid itself :param operations: list of tuples, each tuple containing four integers (x1, y1, x2, y2) :return: list of ints, sums of the specified subgrids result = [] for op in operations: x1, y1, x2, y2 = op subgrid_sum = 0 for i in range(x1-1, x2): for j in range(y1-1, y2): subgrid_sum += grid[i][j] result.append(subgrid_sum) return result"},{"question":"def max_score(grid): Determine the maximum score Iris can achieve from any starting cell on a grid. Args: grid (List[List[int]]): 2D list representing the grid of 0s and 1s. Returns: int: The maximum score possible. Examples: >>> input_data = 5 5 1 0 1 1 1 1 1 0 1 0 0 1 1 1 0 1 0 0 0 1 1 1 1 0 0 >>> grid = load_grid(input_data) >>> max_score(grid) 10 def load_grid(input_data): Helper function to load the grid from input data string. Args: input_data (str): Multiline string containing grid dimensions and the grid itself. Returns: List[List[int]]: Parsed 2D list representing the grid. Examples: >>> input_data = 2 2 1 1 0 1 >>> load_grid(input_data) [[1, 1], [0, 1]] # Unit Tests def test_example_case(): input_data = 5 5 1 0 1 1 1 1 1 0 1 0 0 1 1 1 0 1 0 0 0 1 1 1 1 0 0 grid = load_grid(input_data) assert max_score(grid) == 10 def test_small_case(): input_data = 3 3 1 0 1 1 1 0 0 1 1 grid = load_grid(input_data) assert max_score(grid) == 5 def test_all_zeros(): input_data = 2 2 0 0 0 0 grid = load_grid(input_data) assert max_score(grid) == 0 def test_all_ones(): input_data = 2 2 1 1 1 1 grid = load_grid(input_data) assert max_score(grid) == 4 def test_single_row(): input_data = 1 5 1 0 1 1 0 grid = load_grid(input_data) assert max_score(grid) == 2 def test_single_column(): input_data = 5 1 1 0 1 1 0 grid = load_grid(input_data) assert max_score(grid) == 2 def test_alternate_ones_and_zeros(): input_data = 4 4 1 0 1 0 0 1 0 1 1 0 1 0 0 1 0 1 grid = load_grid(input_data) assert max_score(grid) == 1","solution":"def max_score(grid): n = len(grid) m = len(grid[0]) max_score = 0 def dfs(x, y, visited): nonlocal max_score stack = [(x, y)] current_score = 0 while stack: cx, cy = stack.pop() if (cx, cy) not in visited and grid[cx][cy] == 1: visited.add((cx, cy)) current_score += 1 # Check all four directions (right, left, down, up) if cx + 1 < n: stack.append((cx + 1, cy)) if cx - 1 >= 0: stack.append((cx - 1, cy)) if cy + 1 < m: stack.append((cx, cy + 1)) if cy - 1 >= 0: stack.append((cx, cy - 1)) max_score = max(max_score, current_score) for i in range(n): for j in range(m): if grid[i][j] == 1: visited = set() dfs(i, j, visited) return max_score # Example function to load input data for testing def load_grid(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:]] return grid"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit achievable from buying and selling a house. If no profit is possible, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([2, 1, 2, 0, 1]) 1 >>> max_profit([3, 3, 5, 0, 0, 3, 1, 4]) 4 >>> max_profit([1]) 0 >>> max_profit([]) 0","solution":"def max_profit(prices): Returns the maximum profit achievable from buying and selling a house. If no profit is possible, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: # Update min_price if the current price is lower if price < min_price: min_price = price # Calculate the profit with the current price and update max_profit if it's larger than the current max_profit elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def find_min_max_operations(t: int, test_cases: list) -> list: This function determines the minimal possible maximum value of the array that can be achieved by performing the given operations on every test case. Parameters: t (int): Number of test cases. test_cases (list): List of tuples where each tuple consists of (n, array). Returns: list: List of minimal possible maximum values for each test case. pass # Test cases to validate the solution def test_find_min_max_operations_basic(): t = 2 test_cases = [(3, [1, 2, 3]), (4, [4, 1, 3, 2])] assert find_min_max_operations(t, test_cases) == [3, 4] def test_all_elements_same(): t = 1 test_cases = [(5, [5, 5, 5, 5, 5])] assert find_min_max_operations(t, test_cases) == [5] def test_with_max_at_start(): t = 1 test_cases = [(4, [10, 2, 1, 1])] assert find_min_max_operations(t, test_cases) == [10] def test_with_max_at_end(): t = 1 test_cases = [(4, [1, 2, 1, 10])] assert find_min_max_operations(t, test_cases) == [10] def test_minimal_length(): t = 3 test_cases = [(2, [1, 2]), (2, [5, 5]), (2, [1, 1])] assert find_min_max_operations(t, test_cases) == [2, 5, 1]","solution":"def find_min_max_operations(t, test_cases): This function determines the minimal possible maximum value of the array that can be achieved by performing the given operations on every test case. Parameters: t (int): Number of test cases. test_cases (list): List of tuples where each tuple consists of (n, array). Returns: list: List of minimal possible maximum values for each test case. results = [] for n, array in test_cases: max_value = max(array) results.append(max_value) return results # Example usage # t = 2 # test_cases = [(3, [1, 2, 3]), (4, [4, 1, 3, 2])] # print(find_min_max_operations(t, test_cases)) # Output: [3, 4]"},{"question":"def longest_palindromic_substring(s: str) -> str: Determine the longest palindromic substring within s. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of s. n = len(s) if n == 0: return \\"\\" # Initialize a table to store results of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes start = 0 max_length = 1 for i in range(n): dp[i][i] = True # Check for sub-string of length 2. for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # Ending index of current substring # Check if the current substring is palindrome if (dp[i + 1][j - 1] and s[i] == s[j]): dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"from typing import List def can_transform(n: int, initial: List[int], target: List[int]) -> str: Determines if it's possible to convert the initial arrangement to the target arrangement by performing the allowed swaps. Args: - n (int): the number of stones. - initial (list[int]): the initial arrangement of magical numbers on the stones. - target (list[int]): the target arrangement of magical numbers on the stones. Returns: - str: \\"Yes\\" if the transformation is possible, otherwise \\"No\\". pass def test_can_transform_yes_case(): n = 5 initial = [1, 2, 3, 4, 5] target = [5, 3, 1, 2, 4] assert can_transform(n, initial, target) == \\"Yes\\" def test_can_transform_no_case(): n = 5 initial = [1, 2, 3, 4, 5] target = [5, 3, 1, 2, 6] assert can_transform(n, initial, target) == \\"No\\" def test_can_transform_same_arrangement(): n = 3 initial = [1, 1, 2] target = [1, 2, 1] assert can_transform(n, initial, target) == \\"Yes\\" def test_can_transform_no_case_different_counts(): n = 4 initial = [1, 1, 2, 2] target = [1, 2, 2, 2] assert can_transform(n, initial, target) == \\"No\\"","solution":"def can_transform(n, initial, target): Determines if it's possible to convert the initial arrangement to the target arrangement by performing the allowed swaps. Args: - n (int): the number of stones. - initial (list[int]): the initial arrangement of magical numbers on the stones. - target (list[int]): the target arrangement of magical numbers on the stones. Returns: - str: \\"Yes\\" if the transformation is possible, otherwise \\"No\\". # The transformation is possible only if both arrangements have the same set of numbers from collections import Counter if Counter(initial) != Counter(target): return \\"No\\" else: return \\"Yes\\" # Example usage: #n = 5 #initial = [1, 2, 3, 4, 5] #target = [5, 3, 1, 2, 4] #print(can_transform(n, initial, target)) # Output: \\"Yes\\""},{"question":"from typing import Callable, List def determine_operation(func: Callable[[List[int], int], List[int]], x: int) -> int: Determine which operation (addition or subtraction) the provided function performs on a list of integers. >>> def func_add(lst, x): ... return [item + x for item in lst] >>> determine_operation(func_add, 5) 0 >>> def func_subtract(lst, x): ... return [item - x for item in lst] >>> determine_operation(func_subtract, 5) 1","solution":"from typing import Callable, List def determine_operation(func: Callable[[List[int], int], List[int]], x: int) -> int: # Define a test list test_list = [0] # Call the function with the test list and x result1 = func(test_list, x) # Check the result to determine whether it's addition or subtraction if result1[0] == x: return 0 # Indicates addition else: return 1 # Indicates subtraction"},{"question":"from collections import deque from typing import List def is_path_exist(n: int, m: int, city_map: List[str], x1: int, y1: int, x2: int, y2: int) -> str: Determine if there is a path for a drone to navigate a grid-like city map from a starting position to a destination position. >>> is_path_exist(4, 5, [\\"EEEEE\\", \\"EBBEE\\", \\"EEEEE\\", \\"EBEEE\\"], 1, 1, 4, 5) 'YES' >>> is_path_exist(4, 4, [\\"EEEE\\", \\"EBBE\\", \\"EEEE\\", \\"BBBB\\"], 1, 1, 4, 4) 'NO' >>> is_path_exist(3, 3, [\\"EEE\\", \\"EBE\\", \\"EEE\\"], 2, 2, 2, 2) 'YES' >>> is_path_exist(2, 2, [\\"EE\\", \\"EE\\"], 1, 1, 2, 2) 'YES' >>> is_path_exist(2, 2, [\\"EB\\", \\"BE\\"], 1, 1, 2, 2) 'NO' # Your code here","solution":"from collections import deque def is_path_exist(n, m, city_map, x1, y1, x2, y2): direction_vectors = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and city_map[x][y] == 'E' queue = deque([(x1-1, y1-1)]) visited = [[False] * m for _ in range(n)] visited[x1-1][y1-1] = True while queue: x, y = queue.popleft() if (x, y) == (x2-1, y2-1): return \\"YES\\" for dx, dy in direction_vectors: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def reach_cells(n: int, m: int, k: int, blocked_cells: List[Tuple[int, int]]) -> int: Determine the number of unblocked cells a knight can reach on a chessboard with blocked cells. >>> reach_cells(5, 5, 3, [(1, 2), (3, 3), (5, 5)]) 22 >>> reach_cells(3, 3, 0, []) 9 >>> reach_cells(3, 3, 9, [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]) 0 >>> reach_cells(8, 8, 1, [(4, 4)]) 63 >>> reach_cells(5, 5, 5, [(1, 3), (3, 1), (2, 2), (4, 4), (5, 1)]) 20","solution":"def reach_cells(n, m, k, blocked_cells): moves = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)] def is_valid(r, c): if 1 <= r <= n and 1 <= c <= m and (r, c) not in blocked: return True return False def bfs(start): from collections import deque queue = deque([start]) visited = set([start]) while queue: r, c = queue.popleft() for dr, dc in moves: nr, nc = r + dr, c + dc if is_valid(nr, nc) and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc)) return visited blocked = set(blocked_cells) all_possible_patients = set() for r in range(1, n + 1): for c in range(1, m + 1): if (r, c) not in blocked: reachable_from_current = bfs((r, c)) all_possible_patients.update(reachable_from_current) return len(all_possible_patients)"},{"question":"def min_step_size(x: int, y: int, n: int) -> int: Returns the minimum possible positive step size s such that the sequence starting from x and incremented by s for n steps reaches or exceeds y. >>> min_step_size(3, 15, 4) 3 >>> min_step_size(10, 100, 9) 10 >>> min_step_size(1, 100, 99) 1 >>> min_step_size(1, 100, 1) 99 >>> min_step_size(50, 100, 5) 10 >>> min_step_size(10, 50, 10) 4 >>> min_step_size(1, 10, 2) 5 >>> min_step_size(100, 1000, 10) 90 >>> min_step_size(7, 47, 5) 8 >>> min_step_size(13, 103, 10) 9","solution":"def min_step_size(x, y, n): Returns the minimum possible positive step size s such that the sequence starting from x and incremented by s for n steps reaches or exceeds y. # We need the nth step to be at least y. # The nth step in the sequence starting from x with step size s is x + n * s. # We solve for the smallest s such that x + n * s >= y. # Rearranging gives n * s >= y - x, thus s >= (y - x) / n. s = (y - x) // n if (y - x) % n != 0: # If there's a remainder, we need to increment s by 1 to ensure we reach or exceed y. s += 1 return s"},{"question":"def min_moves_to_target(n, m, sx, sy, tx, ty, traps): Determine the minimum number of moves required to reach the target cell from the starting cell while avoiding trap cells. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. sx (int): Starting cell row index. sy (int): Starting cell column index. tx (int): Target cell row index. ty (int): Target cell column index. traps (List[Tuple[int, int]]): Coordinate list of trap cells. Returns: int: Minimum number of moves or -1 if target is not reachable. pass def solve(test_cases): Solve multiple test cases for the minimum moves problem. Args: test_cases (List[Tuple[int, int, int, int, int, int, int, List[Tuple[int, int]]]]): List of test cases where each test case is a tuple containing: - n (int): Number of rows in the grid. - m (int): Number of columns in the grid. - sx (int): Starting cell row index. - sy (int): Starting cell column index. - tx (int): Target cell row index. - ty (int): Target cell column index. - p (int): Number of trap cells. - traps (List[Tuple[int, int]]): Coordinate list of trap cells. Returns: List[int]: List of results for each test case. pass # Testing def test_simple_case_reachable(): test_cases = [ (5, 5, 0, 0, 4, 4, 3, [(1, 1), (2, 2), (3, 3)]) ] assert solve(test_cases) == [8] def test_simple_case_unreachable(): test_cases = [ (7, 7, 0, 0, 6, 6, 10, [(1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 4)]) ] assert solve(test_cases) == [-1] def test_no_traps(): test_cases = [ (3, 3, 0, 0, 2, 2, 0, []) ] assert solve(test_cases) == [4] def test_same_start_end(): test_cases = [ (5, 5, 1, 1, 1, 1, 0, []) ] assert solve(test_cases) == [0] def test_full_grid_reachable(): test_cases = [ (10, 10, 0, 0, 9, 9, 0, []) ] assert solve(test_cases) == [18] def test_increasing_complexity(): test_cases = [ (6, 6, 0, 0, 5, 5, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (4, 1)]) ] assert solve(test_cases) == [10] import pytest if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import deque def min_moves_to_target(n, m, sx, sy, tx, ty, traps): if (sx, sy) == (tx, ty): return 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] visited = [[False] * m for _ in range(n)] for ix, iy in traps: visited[ix][iy] = True queue = deque([(sx, sy, 0)]) visited[sx][sy] = True while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: if (nx, ny) == (tx, ty): return dist + 1 queue.append((nx, ny, dist + 1)) visited[nx][ny] = True return -1 # Target is not reachable def solve(test_cases): results = [] for n, m, sx, sy, tx, ty, p, traps in test_cases: result = min_moves_to_target(n, m, sx, sy, tx, ty, traps) results.append(result) return results"},{"question":"def is_balanced(s: str) -> bool: Checks if the parentheses in the given string are balanced. >>> is_balanced(\\"(a + b) * (c / d)\\") # True >>> is_balanced(\\"(a + b) * (c / d\\") # False >>> is_balanced(\\")(\\") # False >>> is_balanced(\\"a + b))((c + d\\") # False >>> is_balanced(\\"(()(()))\\") # True","solution":"def is_balanced(s: str) -> bool: Returns True if the parentheses in the given string are balanced, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def bfs(graph: dict, start: int, end: int) -> bool: Function to check if there exists a path between start and end nodes in an undirected graph pass def path_exists(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]], int, int]]) -> List[str]: Function to determine if there exists a simple path (a path which doesn't visit any vertex more than once) between two given nodes a and b in an undirected graph for each test case. Args: t (int): number of test cases. test_cases (List[Tuple[int, int, List[Tuple[int, int]], int, int]]): List of test cases, where each test case contains: - n (int): number of nodes - m (int): number of edges - edges (List[Tuple[int, int]]): list of edges - a (int): start node - b (int): end node Returns: List[str]: \\"YES\\" if there exists a simple path between nodes a and b, else \\"NO\\". >>> t = 2 >>> test_cases = [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1, 3), (3, 2, [(1, 2), (2, 3)], 1, 2)] >>> path_exists(t, test_cases) ['YES', 'YES'] >>> t = 2 >>> test_cases = [(4, 3, [(1, 2), (2, 3), (3, 4)], 1, 4), (4, 2, [(1, 2), (3, 4)], 1, 3)] >>> path_exists(t, test_cases) ['YES', 'NO'] pass","solution":"from collections import defaultdict, deque def bfs(graph, start, end): visited = set() queue = deque([start]) while queue: current = queue.popleft() if current == end: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False def path_exists(t, test_cases): results = [] for i in range(t): n, m, edges, a, b = test_cases[i] graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) if bfs(graph, a, b): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def min_moves_to_identical(n: int, k: int, sequence: List[int]) -> int: Calculate the minimum number of moves required to make all elements in the sequence identical, given that in each move you can replace a contiguous subsequence of length exactly k with its mode. Args: n (int): The length of the sequence. k (int): The length of the subsequence that can be replaced. sequence (List[int]): The initial sequence of integers. Returns: int: The minimum number of moves needed to make all elements in the sequence identical. Examples: >>> min_moves_to_identical(7, 2, [4, 4, 1, 1, 1, 1, 7]) 2 >>> min_moves_to_identical(5, 3, [2, 2, 2, 2, 2]) 0 def test_example_1(): assert min_moves_to_identical(7, 2, [4, 4, 1, 1, 1, 1, 7]) == 2 def test_example_2(): assert min_moves_to_identical(5, 3, [2, 2, 2, 2, 2]) == 0 def test_all_elements_the_same(): assert min_moves_to_identical(4, 2, [3, 3, 3, 3]) == 0 def test_k_equals_1(): assert min_moves_to_identical(4, 1, [1, 2, 3, 4]) == 3 def test_multiple_modes(): assert min_moves_to_identical(6, 2, [1, 2, 2, 1, 1, 2]) == 2 def test_large_n_k(): n = 300000 k = 150000 seq = [1] * 150000 + [2] * 150000 assert min_moves_to_identical(n, k, seq) == 1","solution":"from collections import Counter import heapq from collections import defaultdict def min_moves_to_identical(n, k, sequence): num_moves = 0 frequency = defaultdict(int) for num in sequence: frequency[num] += 1 # Find the most common number in entire sequence max_count_number = max(frequency.items(), key=lambda x: (x[1], -x[0]))[0] i = 0 while i < n: if sequence[i] != max_count_number: num_moves += 1 i += k else: i += 1 return num_moves"},{"question":"def min_palindromic_substrings(s: str) -> int: Determine the minimum number of palindromic substrings. >>> min_palindromic_substrings(\\"abcbm\\") 3 >>> min_palindromic_substrings(\\"racecar\\") 1","solution":"def min_palindromic_substrings(s): n = len(s) dp = [0] * n is_palindrome = [[False] * n for _ in range(n)] for end in range(n): min_cuts = end # max cuts needed is the length of the substring from the start to end for start in range(end + 1): if s[start] == s[end] and (end - start <= 2 or is_palindrome[start + 1][end - 1]): is_palindrome[start][end] = True min_cuts = 0 if start == 0 else min(min_cuts, dp[start - 1] + 1) dp[end] = min_cuts return dp[-1] + 1 # return the minimum number of palindromic substrings # Example usage: # print(min_palindromic_substrings(\\"abcbm\\")) # 3 # print(min_palindromic_substrings(\\"racecar\\")) # 1"},{"question":"def max_profit(prices): Help Little Ruel and Little Mae optimize their trading. Given a set of stock prices for upcoming days, determine the maximum possible profit they can achieve from one transaction (buy one and sell one share of the stock). :param prices: List[int] - An array where each element is the stock price on that day. :return: int - The maximum profit achievable. If no profit can be achieved, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy and sell transaction. :param prices: List[int] - List of stock prices where each element is the stock price on that day. :return: int - The maximum profit achievable. If no profit can be achieved, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: # Calculate profit if we sell at the current price profit = price - min_price # Update the maximum profit max_profit = max(max_profit, profit) # Update the minimum price to buy in the future min_price = min(min_price, price) return max_profit"},{"question":"def min_jumps(arr: List[int]) -> int: Returns the minimum number of jumps required to reach the last position in the array. Returns -1 if it is not possible to reach the last position. Examples: >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1","solution":"def min_jumps(arr): Returns the minimum number of jumps required to reach the last position in the array. Returns -1 if it is not possible to reach the last position. n = len(arr) if n == 1: return 0 max_reach = arr[0] # The farthest index that can be reached step = arr[0] # Steps we can still take jump = 1 # Number of jumps we have made for i in range(1, n): if i == n - 1: return jump max_reach = max(max_reach, i + arr[i]) step -= 1 if step == 0: jump += 1 if i >= max_reach: return -1 step = max_reach - i return -1"},{"question":"from typing import List, Tuple def can_communicate(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if every node in the graph is connected directly or indirectly with every other node. Args: n (int): The number of nodes. m (int): The number of edges. edges (List[Tuple[int, int]]): The list of edges. Returns: str: \\"YES\\" if all nodes are connected, otherwise \\"NO\\". >>> can_communicate(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YES' >>> can_communicate(5, 2, [(1, 2), (3, 4)]) 'NO' def test_example_1(): n = 5 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 5)] assert can_communicate(n, m, edges) == \\"YES\\" def test_example_2(): n = 5 m = 2 edges = [(1, 2), (3, 4)] assert can_communicate(n, m, edges) == \\"NO\\" def test_single_node(): n = 1 m = 0 edges = [] assert can_communicate(n, m, edges) == \\"YES\\" def test_disconnected_graph(): n = 4 m = 2 edges = [(1, 2), (3, 4)] assert can_communicate(n, m, edges) == \\"NO\\" def test_complete_graph(): n = 4 m = 6 edges = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] assert can_communicate(n, m, edges) == \\"YES\\" def test_chain_graph(): n = 4 m = 3 edges = [(1, 2), (2, 3), (3, 4)] assert can_communicate(n, m, edges) == \\"YES\\" def test_star_graph(): n = 5 m = 4 edges = [(1, 2), (1, 3), (1, 4), (1, 5)] assert can_communicate(n, m, edges) == \\"YES\\"","solution":"from collections import defaultdict, deque def can_communicate(n, m, edges): if n == 1: return \\"YES\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() def bfs(node): queue = deque([node]) visited.add(node) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) bfs(1) if len(visited) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def calculate_perimeter(m: int, n: int, grid: List[List[int]]) -> int: Calculate the perimeter of the island in the grid. >>> calculate_perimeter(4, 4, [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]) == 16 >>> calculate_perimeter(5, 5, [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]]) == 16 pass def island_perimeters(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Find the perimeter of the island for each test case. >>> island_perimeters(2, [((4, 4), [[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]), ((5, 5), [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]])]) == [16, 16] pass","solution":"def calculate_perimeter(m, n, grid): def is_water_or_outside(x, y): if x < 0 or x >= m or y < 0 or y >= n: return True return grid[x][y] == 0 perimeter = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: if is_water_or_outside(i-1, j): # check up perimeter += 1 if is_water_or_outside(i+1, j): # check down perimeter += 1 if is_water_or_outside(i, j-1): # check left perimeter += 1 if is_water_or_outside(i, j+1): # check right perimeter += 1 return perimeter def island_perimeters(T, test_cases): results = [] for t in range(T): m, n = test_cases[t][0] grid = test_cases[t][1] results.append(calculate_perimeter(m, n, grid)) return results"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string s. n = len(s) if n == 0: return 0 dp = [[False] * n for _ in range(n)] max_len = 1 for i in range(n): dp[i][i] = True start = 0 for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True start = i max_len = 2 for k in range(3, n+1): for i in range(n-k+1): j = i + k - 1 if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True if k > max_len: start = i max_len = k return max_len"},{"question":"def rearrange_with_reverses(arr, k): Rearranges the array in such a way that subarrays of size \`k\` and their reverse counterparts are present adjacent to each other. Parameters: arr : list[int] : The input array to be rearranged. k : int : The size of the subarray. Returns: list[int] : The rearranged array.","solution":"def rearrangeWithReverses(arr, k): Rearranges the array such that subarrays of size \`k\` and their reverse counterparts are present adjacent to each other. Parameters: arr : list[int] : The input array to be rearranged. k : int : The size of the subarray. Returns: list[int] : The rearranged array. result = [] n = len(arr) for i in range(0, n // k): subarray = arr[i * k : (i + 1) * k] result.extend(subarray) result.extend(subarray[::-1]) if n % k != 0: result.extend(arr[(n // k) * k:]) return result"},{"question":"def count_visible_buildings(buildings: List[int]) -> int: Returns the number of buildings visible from the left side of the street. Parameters: buildings (list of int): Heights of the buildings. Returns: int: The number of buildings visible from the left side. >>> count_visible_buildings([3, 5, 4, 4, 6, 2]) 3 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([5, 4, 3, 2, 1]) 1 >>> count_visible_buildings([3, 3, 3, 3, 3]) 1 >>> count_visible_buildings([10]) 1 >>> count_visible_buildings([]) 0 >>> count_visible_buildings([1, 3, 2, 5, 4, 6]) 4","solution":"def count_visible_buildings(buildings): Returns the number of buildings visible from the left side of the street. Parameters: buildings (list of int): Heights of the buildings. Returns: int: The number of buildings visible from the left side. if not buildings: return 0 visible_count = 0 max_height_so_far = 0 for height in buildings: if height > max_height_so_far: visible_count += 1 max_height_so_far = height return visible_count"},{"question":"def shortest_subarray_with_sum(n: int, arr: List[int], x: int) -> int: Returns the length of the shortest contiguous subarray whose sum is exactly \`x\`. If no such subarray exists, return \`-1\`. >>> shortest_subarray_with_sum(5, [1, 2, 3, 4, 5], 9) == 2 >>> shortest_subarray_with_sum(5, [1, 2, 3, 4, 5], 15) == 5 >>> shortest_subarray_with_sum(5, [1, 2, 3, 4, 5], 20) == -1 >>> shortest_subarray_with_sum(1, [5], 5) == 1 >>> shortest_subarray_with_sum(1, [5], 10) == -1 >>> shortest_subarray_with_sum(7, [2, 1, 2, 3, 1, 1, 1], 6) == 3 >>> shortest_subarray_with_sum(4, [2**30, -2**30, 2**30, -2**30], 2**30) == 1 >>> shortest_subarray_with_sum(3, [1, 2, 3], 7) == -1","solution":"def shortest_subarray_with_sum(n, arr, x): Returns the length of the shortest contiguous subarray whose sum is exactly x. If no such subarray exists, return -1. min_length = float('inf') current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum >= x: if current_sum == x: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def rearrange_string(s: str) -> str: Rearranges characters of the string such that digits appear in ascending order, followed by letters in alphabetical order. Examples: >>> rearrange_string(\\"b3a1c2\\") '123abc' >>> rearrange_string(\\"abc123\\") '123abc' >>> rearrange_string(\\"54321\\") '12345' >>> rearrange_string(\\"xyz\\") 'xyz' >>> rearrange_string(\\"z9a8b7c6\\") '6789abcz'","solution":"def rearrange_string(s): Rearranges characters of the string such that digits appear in ascending order, followed by letters in alphabetical order. digits = sorted([char for char in s if char.isdigit()]) letters = sorted([char for char in s if char.isalpha()]) return ''.join(digits + letters)"},{"question":"def count_domino_sequences(n): Returns the number of distinct valid sequences of n dominoes modulo 10^9 + 7. Parameters: n (int): The number of domino pieces Returns: int: The number of distinct valid sequences of n dominoes modulo 10^9 + 7 >>> count_domino_sequences(2) 28 >>> count_domino_sequences(3) 196 from solution import count_domino_sequences def test_single_domino(): assert count_domino_sequences(1) == 28 def test_two_dominoes(): assert count_domino_sequences(2) == 28 * 7 % (10**9 + 7) def test_three_dominoes(): assert count_domino_sequences(3) == 28 * 7 * 7 % (10**9 + 7) def test_large_n(): assert count_domino_sequences(10**5) == (28 * pow(7, 10**5 - 1, 10**9 + 7)) % (10**9 + 7) def test_modulo_behavior(): assert count_domino_sequences(99999) == (28 * pow(7, 99998, 10**9 + 7)) % (10**9 + 7) def test_modular_exponentiation(): assert count_domino_sequences(20) == (28 * pow(7, 19, 10**9 + 7)) % (10**9 + 7)","solution":"MOD = 10**9 + 7 def count_domino_sequences(n): Returns the number of distinct valid sequences of n dominoes modulo 10^9 + 7. # For n=1, there are 28 possible dominoes (0|0 to 6|6) # For n>=2, each additional domino can be added at 7 possible points at each end of the sequence # The number of arrangements follows (28 * 7^(n-1)) % MOD return (28 * pow(7, n - 1, MOD)) % MOD"},{"question":"from typing import List def can_reach_boundary(n: int, m: int, si: int, sj: int, grid: List[str]) -> str: Determine if there exists a path from the starting point to any boundary cell of the grid without passing through any blocked cells. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid si (int): Starting row index of the robot sj (int): Starting column index of the robot grid (List[str]): The grid itself, where each cell is either '.' (an empty cell), '#' (a blocked cell), or 'S' (the starting position of the robot) Returns: str: \\"YES\\" if there is a path from the starting point to any boundary cell, otherwise \\"NO\\" Examples: >>> can_reach_boundary(4, 4, 1, 1, [\\"....\\",\\".#.#\\",\\".S..\\",\\"..\\"]) \\"YES\\" >>> can_reach_boundary(3, 3, 1, 1, [\\"#\\",\\"#S#\\",\\"#\\"]) \\"NO\\" pass def test_can_reach_boundary_case1(): n = 4 m = 4 si = 1 sj = 1 grid = [ \\"....\\", \\".#.#\\", \\".S..\\", \\"..\\" ] assert can_reach_boundary(n, m, si, sj, grid) == \\"YES\\" def test_can_reach_boundary_case2(): n = 3 m = 3 si = 1 sj = 1 grid = [ \\"#\\", \\"#S#\\", \\"#\\" ] assert can_reach_boundary(n, m, si, sj, grid) == \\"NO\\" def test_can_reach_boundary_case3(): n = 5 m = 5 si = 2 sj = 2 grid = [ \\".....\\", \\".....\\", \\"..S..\\", \\".....\\", \\".....\\" ] assert can_reach_boundary(n, m, si, sj, grid) == \\"YES\\" def test_can_reach_boundary_case4(): n = 4 m = 4 si = 0 sj = 3 grid = [ \\"...S\\", \\"\\", \\"\\", \\"\\" ] assert can_reach_boundary(n, m, si, sj, grid) == \\"YES\\" def test_can_reach_boundary_case5(): n = 2 m = 3 si = 0 sj = 1 grid = [ \\".S.\\", \\"...\\" ] assert can_reach_boundary(n, m, si, sj, grid) == \\"YES\\"","solution":"def can_reach_boundary(n, m, si, sj, grid): from collections import deque # Directions array for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize a queue and the visited set queue = deque([(si, sj)]) visited = set() visited.add((si, sj)) while queue: x, y = queue.popleft() # Check if we have reached the boundary if x == 0 or x == n-1 or y == 0 or y == m-1: return \\"YES\\" # Explore all 4 possible directions for dir_x, dir_y in directions: new_x, new_y = x + dir_x, y + dir_y if 0 <= new_x < n and 0 <= new_y < m and (new_x, new_y) not in visited and grid[new_x][new_y] == '.': queue.append((new_x, new_y)) visited.add((new_x, new_y)) return \\"NO\\""},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: You are given a list of unique integers. You need to find and return the length of the longest increasing subsequence (LIS) within this list. An increasing subsequence is a subsequence of a list where each element is greater than the preceding one. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 2, 3, 8, 9, 10]) 5 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 pass def test_example_1(): assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 def test_example_2(): assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 def test_example_3(): assert longest_increasing_subsequence([7, 7, 2, 3, 8, 9, 10]) == 5 def test_empty_list(): assert longest_increasing_subsequence([]) == 0 def test_example_4(): assert longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3 def test_single_element(): assert longest_increasing_subsequence([5]) == 1 def test_all_decreasing(): assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 def test_all_increasing(): assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 def test_large_values(): assert longest_increasing_subsequence([100, 101, 1, 2, 3, 201, 202]) == 5 def test_alternating_sequence(): assert longest_increasing_subsequence([1, 3, 2, 4, 3, 5]) == 4","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list. if not arr: return 0 lis = [] for num in arr: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"def text_editor(operations): Perform a series of operations on the text document and output the results of the print operations. :param operations: List of operations in the format described above. :return: List of results from the \\"Print\\" operations. >>> operations = [\\"1 abc\\", \\"1 def\\", \\"3 3\\", \\"2 3\\", \\"3 3\\", \\"1 ghi\\", \\"3 6\\"] >>> text_editor(operations) ['c', 'c', 'i']","solution":"def text_editor(operations): document = [] result = [] for operation in operations: op = operation.split() if op[0] == '1': document.append(op[1]) elif op[0] == '2': k = int(op[1]) document[-1] = document[-1][:-k] elif op[0] == '3': k = int(op[1]) doc_str = ''.join(document) result.append(doc_str[k - 1]) return result"},{"question":"def minimize_abs_diff(arr): You are given an array of integers \`a\` of size \`n\`. Your task is to split the array into exactly two non-empty subarrays in such a way that the absolute difference between the sum of elements in the first subarray and the sum of elements in the second subarray is minimized. Define two subarrays as \`a[0...i]\` and \`a[i+1...n-1]\` for some integer \`i\` (0 <= i < n-1). >>> minimize_abs_diff([1, 2, 3, 4, 5, 6]) 1 >>> minimize_abs_diff([1, 1]) 0 >>> minimize_abs_diff([5, 5, 5, 5, 5, 5]) 0 >>> minimize_abs_diff([3, 1, 4, 1, 5, 9]) 5 >>> minimize_abs_diff([1000000000, 1000000000, 1000000000, 1000000000]) 0","solution":"def minimize_abs_diff(arr): n = len(arr) # Compute the prefix sums prefix_sum = [0] * n prefix_sum[0] = arr[0] for i in range(1, n): prefix_sum[i] = prefix_sum[i-1] + arr[i] total_sum = prefix_sum[-1] min_diff = float('inf') # Compute the minimum absolute difference for i in range(n-1): left_sum = prefix_sum[i] right_sum = total_sum - left_sum diff = abs(left_sum - right_sum) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def has_pair_with_product(arr, k): Determines if there are two distinct indices i and j in the array such that the product of the elements at these indices is equal to k. Args: arr (List[int]): An array of integers. k (int): The target product. Returns: bool: True if such indices exist, otherwise False. Examples: >>> has_pair_with_product([4, 5, -1, 7, 2], 20) True >>> has_pair_with_product([1, 2, 3, 4, 5], 100) False from solution import has_pair_with_product def test_pair_exists_simple_case(): assert has_pair_with_product([4, 5, -1, 7, 2], 20) == True def test_pair_does_not_exist(): assert has_pair_with_product([1, 2, 3, 4, 5], 100) == False def test_pair_with_zero_product(): assert has_pair_with_product([0, 1, 2, 3, 0], 0) == True assert has_pair_with_product([0, 1, 2, 3, 4], 0) == False def test_pair_with_negative_numbers(): assert has_pair_with_product([-1, -2, -3, 4, 6], 6) == True assert has_pair_with_product([-1, -2, -3, 4, 6], -8) == True def test_single_element(): assert has_pair_with_product([5], 10) == False def test_large_numbers(): assert has_pair_with_product([1000000, -1000000, 2, -3, 500000], 500000000000) == True assert has_pair_with_product([1000000, -1000000, 2, -3, 500000], 123456789) == False","solution":"def has_pair_with_product(arr, k): Determines if there are two distinct indices i and j in the array such that the product of the elements at these indices is equal to k. n = len(arr) seen = set() for number in arr: if k != 0 and number != 0 and k % number == 0: if k // number in seen: return True if k == 0 and number == 0: if 0 in seen: return True seen.add(number) return False"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-4]) -4 >>> max_subarray_sum([-2, -3, -4, -1, -2, -1, -5, -3]) -1 >>> max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5]) 18 >>> max_subarray_sum([2, 3, 7, 4]) 16 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(arr): Returns the maximum sum of any non-empty contiguous subarray. if not arr: return 0 # Initialize current and maximum sums to the first element current_sum = max_sum = arr[0] for num in arr[1:]: # Update current sum, either start a new subarray or continue the current one current_sum = max(num, current_sum + num) # Update the maximum sum found so far max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def analyze_sales_balance(n, sales): Determine if any single region has sales exceeding 50% of the total sales. Args: n (int): Number of regions. sales (list of ints): Sales numbers for each region. Returns: str: \\"BALANCED\\" or \\"UNBALANCED\\" based on the analysis. >>> analyze_sales_balance(3, [10, 20, 30]) \\"BALANCED\\" >>> analyze_sales_balance(5, [10, 40, 10, 5, 5]) \\"UNBALANCED\\" >>> analyze_sales_balance(1, [100]) \\"UNBALANCED\\" >>> analyze_sales_balance(4, [25, 25, 25, 25]) \\"BALANCED\\" >>> analyze_sales_balance(3, [100000, 1, 1]) \\"UNBALANCED\\" >>> analyze_sales_balance(2, [1, 1]) \\"BALANCED\\"","solution":"def analyze_sales_balance(n, sales): Determine if any single region has sales exceeding 50% of the total sales. Args: n (int): Number of regions. sales (list of ints): Sales numbers for each region. Returns: str: \\"BALANCED\\" or \\"UNBALANCED\\" based on the analysis. total_sales = sum(sales) for sale in sales: if sale > total_sales / 2: return \\"UNBALANCED\\" return \\"BALANCED\\""},{"question":"def range_sum(n, q, array, queries): Computes the range-sum for each query from the given array. Parameters: n (int): Number of elements in array q (int): Number of queries array (list of int): List of integers queries (list of tuple): List of (l, r) queries Returns: list of int: List of sums for each query >>> range_sum(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15]","solution":"def range_sum(n, q, array, queries): Computes the range-sum for each query from the given array. Parameters: n (int): Number of elements in array q (int): Number of queries array (list of int): List of integers queries (list of tuple): List of (l, r) queries Returns: list of int: List of sums for each query # Step 1: Compute the prefix sum array prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] # Step 2: Answer each query using the prefix sum array result = [] for l, r in queries: result.append(prefix_sum[r] - prefix_sum[l - 1]) return result"},{"question":"from typing import List def has_zero_sum_subarray(nums: List[int]) -> bool: Determine whether there is a contiguous subarray whose sum is zero. >>> has_zero_sum_subarray([3, 4, -7, 1, 2, -1, 5, -4]) == True >>> has_zero_sum_subarray([1, 2, 3, 4, 5]) == False >>> has_zero_sum_subarray([1, -1, 3, 4, -2, -2]) == True >>> has_zero_sum_subarray([1, 2, -3, 3, 4, -4]) == True >>> has_zero_sum_subarray([2, 1, 4, -2, 2, -1, 1, -3, 1, 2, 1]) == False","solution":"from typing import List def has_zero_sum_subarray(nums: List[int]) -> bool: This function checks if there is a contiguous subarray in 'nums' whose sum is zero. prefix_sums = set() current_sum = 0 for num in nums: current_sum += num if current_sum == 0 or current_sum in prefix_sums: return True prefix_sums.add(current_sum) return False"},{"question":"def rearrangeString(s: str) -> str: Write a function \`rearrangeString\` that rearranges characters in a string such that no two adjacent characters are the same. If such a rearrangement is not possible, return an empty string. Examples: >>> rearrangeString(\\"aab\\") \\"aba\\" >>> rearrangeString(\\"aaab\\") \\"\\" >>> rearrangeString(\\"a\\") \\"a\\" >>> rearrangeString(\\"aaaa\\") \\"\\" >>> result = rearrangeString(\\"abab\\") >>> result == \\"abab\\" or result == \\"baba\\" True >>> s = \\"a\\" * 5000 + \\"b\\" * 5000 >>> result = rearrangeString(s) >>> all(result[i] != result[i - 1] for i in range(1, len(result))) True >>> result = rearrangeString(\\"aabbbcccc\\") >>> len(result) == 9 True >>> all(result[i] != result[i - 1] for i in range(1, len(result))) True pass def test_example1(): assert rearrangeString(\\"aab\\") == \\"aba\\" def test_example2(): assert rearrangeString(\\"aaab\\") == \\"\\" def test_single_character(): assert rearrangeString(\\"a\\") == \\"a\\" def test_same_characters(): assert rearrangeString(\\"aaaa\\") == \\"\\" def test_alternating_characters(): result = rearrangeString(\\"abab\\") assert result == \\"abab\\" or result == \\"baba\\" def test_long_string(): s = \\"a\\" * 5000 + \\"b\\" * 5000 result = rearrangeString(s) # Check if no two adjacent characters are the same in the result for i in range(1, len(result)): assert result[i] != result[i - 1] def test_multiple_characters(): result = rearrangeString(\\"aabbbcccc\\") # There are multiple correct answers, check one possible valid output assert len(result) == 9 for i in range(1, len(result)): assert result[i] != result[i - 1]","solution":"from heapq import heappop, heappush, heapify from collections import Counter def rearrangeString(s: str) -> str: # Count the frequency of each character char_count = Counter(s) # Create a max heap with negative counts for easy max heap conversion max_heap = [(-count, char) for char, count in char_count.items()] heapify(max_heap) # Variables to hold the previous character and its count prev_count, prev_char = 0, '' result = [] while max_heap: # Pop the most frequent character count, char = heappop(max_heap) # Append to the result result.append(char) # Since we are pushing back the previous character, we first check if we have a previous character if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Update the previous character and count prev_count, prev_char = count + 1, char # Join the result list to form the final string rearranged_string = ''.join(result) # If rearranged string length doesn't match original string length, it's not possible to rearrange if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"def min_production_time(craft_times, orders): Returns the minimum total production time to complete all orders. Parameters: craft_times (list): A list of integers representing the production times of each craft. orders (list): A list of lists, where each list contains the quantities of each craft needed for an order. Returns: int: The minimum total production time. >>> craft_times = [5, 10, 3] >>> orders = [ ... [2, 1, 4], ... [1, 2, 1], ... [3, 0, 2] ... ] >>> min_production_time(craft_times, orders) 81 from solution import min_production_time def test_min_production_time_example(): craft_times = [5, 10, 3] orders = [ [2, 1, 4], [1, 2, 1], [3, 0, 2] ] assert min_production_time(craft_times, orders) == 81 def test_min_production_time_single_order(): craft_times = [7, 2, 5] orders = [ [1, 2, 3] ] assert min_production_time(craft_times, orders) == 1*7 + 2*2 + 3*5 def test_min_production_time_multiple_orders_with_single_craft(): craft_times = [10] orders = [ [3], [1], [4] ] assert min_production_time(craft_times, orders) == 3*10 + 1*10 + 4*10 def test_min_production_time_varying_craft_times(): craft_times = [5, 0, 2] orders = [ [2, 3, 1], [1, 2, 3] ] assert min_production_time(craft_times, orders) == (2*5 + 3*0 + 1*2) + (1*5 + 2*0 + 3*2) def test_min_production_time_large_numbers(): craft_times = [1000, 999, 998] orders = [[1, 1, 1]] * 1000 assert min_production_time(craft_times, orders) == 1000 * (1000 + 999 + 998)","solution":"def min_production_time(craft_times, orders): Returns the minimum total production time to complete all orders. Parameters: craft_times (list): A list of integers representing the production times of each craft. orders (list): A list of lists, where each list contains the quantities of each craft needed for an order. Returns: int: The minimum total production time. total_time = 0 for order in orders: order_time = 0 for i in range(len(order)): order_time += order[i] * craft_times[i] total_time += order_time return total_time"},{"question":"def max_subsequence_sum(arr: List[int], k: int) -> int: Find the maximum possible sum of a subsequence of the array such that the subsequence contains exactly k elements. Args: arr: List[int] - The array of integers. k: int - The number of elements in the subsequence. Returns: int - The maximum possible sum of the subsequence of length k. >>> max_subsequence_sum([5, -2, 3, 8, 1, -6], 3) 16 >>> max_subsequence_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subsequence_sum([-5, -2, -3, -8, -1, -6], 2) -3 >>> max_subsequence_sum([1, -2, 3, -4, 5], 3) 9 >>> max_subsequence_sum([10**9, 10**9, -10**9, -10**9, 0], 2) 2000000000 >>> max_subsequence_sum([10], 1) 10 >>> max_subsequence_sum([0, 0, 0, 0, 0], 3) 0 >>> max_subsequence_sum([1, -1, 2, -2, 3, -3, 4, -4, 5, -5], 5) 15 pass","solution":"def max_subsequence_sum(arr, k): Finds the maximum possible sum of a subsequence of the array such that the subsequence contains exactly k elements. Args: arr: List[int] - The array of integers. k: int - The number of elements in the subsequence. Returns: int - The maximum possible sum of the subsequence of length k. # Sort the array in descending order sorted_arr = sorted(arr, reverse=True) # Take the first k elements from the sorted array max_sum = sum(sorted_arr[:k]) return max_sum # Example usage n, k = 6, 3 arr = [5, -2, 3, 8, 1, -6] print(max_subsequence_sum(arr, k)) # Output: 16"},{"question":"from typing import List def max_sum_subarray(n: int, L: int, R: int, A: List[int]) -> int: Function to find the maximum possible sum of a contiguous subarray of A with length between L and R inclusive. pass # Unit tests def test_max_sum_subarray_example(): assert max_sum_subarray(6, 2, 4, [1, -2, 3, -1, 2, 3]) == 7 def test_max_sum_subarray_small_array(): assert max_sum_subarray(4, 1, 2, [-1, -1, -1, -1]) == -1 def test_max_sum_subarray_single_element(): assert max_sum_subarray(4, 1, 1, [1, 2, 3, 4]) == 4 def test_max_sum_subarray_entire_array(): assert max_sum_subarray(5, 5, 5, [-1, 2, 3, -4, 5]) == 5 def test_max_sum_subarray_negative_and_positive(): assert max_sum_subarray(5, 1, 5, [-1, -2, 3, -4, 5]) == 5 def test_max_sum_subarray_all_negative(): assert max_sum_subarray(5, 2, 5, [-1, -2, -3, -4, -5]) == -3","solution":"def max_sum_subarray(n, L, R, A): Function to find the maximum possible sum of a contiguous subarray of A with length between L and R inclusive. max_sum = float('-inf') for start in range(n): current_sum = 0 for end in range(start, min(n, start + R)): current_sum += A[end] if L <= (end - start + 1) <= R: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def findMaxIsland(grid: List[List[int]]) -> int: You are given a grid with \`m\` rows and \`n\` columns represented as a 2D list \`grid\`. Each cell in the grid contains a value of either 0 or 1. A cell containing 1 is land, and a cell containing 0 is water. An island is defined as a group of contiguous lands connected horizontally or vertically (but not diagonally). Assume all four edges of the grid are surrounded by water. Your task is to write a function that returns the size of the largest island in the given grid. >>> grid = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 1, 1], ... [0, 1, 1, 1, 0] ... ] >>> findMaxIsland(grid) 7 >>> grid = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ] >>> findMaxIsland(grid) 0 >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> findMaxIsland(grid) 1 >>> grid = [ ... [1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 0], ... [0, 1, 0, 1] ... ] >>> findMaxIsland(grid) 1 >>> grid = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> findMaxIsland(grid) 9 pass","solution":"from typing import List def findMaxIsland(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 def dfs(x, y): stack = [(x, y)] count = 0 while stack: i, j = stack.pop() if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1: grid[i][j] = 0 # mark as visited count += 1 # Push all neighboring lands stack.append((i + 1, j)) stack.append((i - 1, j)) stack.append((i, j + 1)) stack.append((i, j - 1)) return count max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island_size = dfs(i, j) max_island_size = max(max_island_size, island_size) return max_island_size"},{"question":"def trap(height: List[int]) -> int: Calculate the total units of water trapped between the buildings after rainfall. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([3, 2, 1, 0]) == 0 >>> trap([0, 1, 2, 3]) == 0 >>> trap([5]) == 0 >>> trap([2, 2, 2, 2]) == 0 >>> trap([4, 1]) == 0 >>> trap([1, 4]) == 0 >>> trap([3, 2, 1]) == 0 >>> trap([1, 2, 3]) == 0 >>> trap([3, 0, 1, 3, 0, 5]) == 8 pass","solution":"def trap(height): Calculate the total units of water trapped between the buildings after rainfall. Parameters: height (List[int]): A list of integers representing the heights of the buildings. Returns: int: The total units of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate total water trapped water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def find_additional_character(s: str, t: str) -> str: Given two strings \`s\` and \`t\`, where \`t\` is formed by shuffling characters of \`s\` and adding one extra character, this function finds and returns the additional character. >>> find_additional_character('abcd', 'abcde') 'e' >>> find_additional_character('bcdf', 'abdcf') 'a' >>> find_additional_character('xyz', 'xyzp') 'p' >>> find_additional_character('a', 'aa') 'a' >>> find_additional_character('zzzzz', 'zzzzzz') 'z'","solution":"def find_additional_character(s, t): Given two strings \`s\` and \`t\`, where \`t\` is formed by shuffling characters of \`s\` and adding one extra character, this function finds and returns the additional character. # Use a dictionary to count the occurrences of each character in both strings char_count = {} # Count characters in string \`t\` for char in t: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Subtract the count by characters in string \`s\` for char in s: if char in char_count: char_count[char] -= 1 # The character with a count of 1 is the additional character for char in char_count: if char_count[char] == 1: return char"},{"question":"def compute_prefix_sums(arr): Computes and returns the prefix sums array for arr. >>> compute_prefix_sums([1, 2, 3, 4, 5]) == [0, 1, 3, 6, 10, 15] >>> compute_prefix_sums([2, 4, 6, 8]) == [0, 2, 6, 12, 20] >>> compute_prefix_sums([5, 5, 5, 5]) == [0, 5, 10, 15, 20] def range_sum(prefix_sums, l, r): Returns the range sum from index l to r using the prefix sums array. >>> prefix_sums = compute_prefix_sums([1, 2, 3, 4, 5]) >>> range_sum(prefix_sums, 1, 3) == 6 >>> range_sum(prefix_sums, 2, 5) == 14 >>> range_sum(prefix_sums, 3, 3) == 3 def process_queries(n, q, arr, queries): Processes multiple sum queries on the array. >>> arr = [1, 2, 3, 4, 5] >>> queries = [(1, 3), (2, 5), (3, 3)] >>> process_queries(5, 3, arr, queries) == [6, 14, 3]","solution":"def compute_prefix_sums(arr): Computes and returns the prefix sums array for arr. prefix_sums = [0] * (len(arr) + 1) for i in range(len(arr)): prefix_sums[i+1] = prefix_sums[i] + arr[i] return prefix_sums def range_sum(prefix_sums, l, r): Returns the range sum from index l to r using the prefix sums array. return prefix_sums[r] - prefix_sums[l-1] def process_queries(n, q, arr, queries): prefix_sums = compute_prefix_sums(arr) results = [] for l, r in queries: results.append(range_sum(prefix_sums, l, r)) return results"},{"question":"def min_operations_to_sort(n: int, arr: List[int]) -> int: Return the minimum number of operations needed to sort the array in non-decreasing order by sorting any subarray of exactly three consecutive elements, or -1 if it is impossible. >>> min_operations_to_sort(4, [3, 2, 1, 4]) 1 >>> min_operations_to_sort(3, [3, 2, 1]) 1 >>> min_operations_to_sort(5, [1, 5, 3, 2, 4]) 3 >>> min_operations_to_sort(n, [1, 2, 3]) 0 >>> min_operations_to_sort(2, [2, 1]) -1 >>> min_operations_to_sort(6, [1, 3, 2, 6, 4, 5]) 3 >>> min_operations_to_sort(2, [1, 2]) 0","solution":"def min_operations_to_sort(n, arr): def is_sorted(arr): for i in range(1, len(arr)): if arr[i] < arr[i - 1]: return False return True # If array is already sorted, no operation needed. if is_sorted(arr): return 0 operations = 0 max_operations = 2 * n # An upper bound to prevent infinite loop (large enough). while not is_sorted(arr) and operations < max_operations: for i in range(n - 2): subarray = sorted(arr[i:i + 3]) if arr[i:i + 3] != subarray: arr[i:i + 3] = subarray operations += 1 break else: # If we could not perform any operation in the whole pass, # and the array is still not sorted, it's impossible. return -1 return operations if is_sorted(arr) else -1"},{"question":"def query_subarray_contains(n: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[str]: Processes queries to determine if a number x appears in the subarray from l to r inclusive. :param n: Number of elements in the array :param array: List of n integers :param queries: List of queries, each a tuple (l, r, x) :return: List of results for each query, \\"YES\\" if x appears in the subarray from l to r, otherwise \\"NO\\" >>> query_subarray_contains(5, [1, 2, 3, 4, 5], [(1, 3, 3), (2, 4, 6), (1, 5, 5)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> query_subarray_contains(4, [1, 2, 5, 4], [(1, 4, 3), (2, 3, 1), (3, 4, 4)]) [\\"NO\\", \\"NO\\", \\"YES\\"] >>> query_subarray_contains(1, [10], [(1, 1, 10), (1, 1, 5)]) [\\"YES\\", \\"NO\\"] >>> query_subarray_contains(7, [7, 8, 3, 6, 2, 9, 1], [(1, 7, 2), (1, 7, 10), (4, 4, 6)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> query_subarray_contains(100000, list(range(1, 100001)), [(1, 100000, 99999), (50000, 50001, 50000), (1, 1000, 1001)]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def query_subarray_contains(n, array, queries): Processes queries to determine if a number x appears in the subarray from l to r inclusive. :param n: Number of elements in the array :param array: List of n integers :param queries: List of queries, each a tuple (l, r, x) :return: List of results for each query, \\"YES\\" if x appears in the subarray from l to r, otherwise \\"NO\\" results = [] for l, r, x in queries: subarray = array[l-1:r] if x in subarray: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Determines the longest path between any two nodes in an unweighted tree. Parameters: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): A list of edges in the tree. Returns: int: The length of the diameter of the tree. >>> tree_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> tree_diameter(6, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]) 2","solution":"from collections import deque, defaultdict def find_furthest_node(start, graph): Performs BFS to find the furthest node from the start node and its distance. visited = set() q = deque([(start, 0)]) furthest_node = start max_distance = 0 while q: current, distance = q.popleft() if distance > max_distance: max_distance = distance furthest_node = current visited.add(current) for neighbor in graph[current]: if neighbor not in visited: q.append((neighbor, distance + 1)) return furthest_node, max_distance def tree_diameter(n, edges): Finds the diameter of the tree. if n == 1: return 0 graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Step 1: Find the furthest node from any node (let's say node 1) furthest_node, _ = find_furthest_node(1, graph) # Step 2: Find the furthest node from the node found in step 1 furthest_node, diameter = find_furthest_node(furthest_node, graph) return diameter"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Finds the length of the longest substring that can be rearranged to form a palindrome. >>> longest_palindromic_substring_length(\\"abccccdd\\") 7 >>> longest_palindromic_substring_length(\\"aabbcc\\") 6 >>> longest_palindromic_substring_length(\\"abc\\") 1 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"\\") 0 >>> longest_palindromic_substring_length(\\"aaabbbbcc\\") 9 >>> longest_palindromic_substring_length(\\"aaa\\") 3 >>> longest_palindromic_substring_length(\\"x\\") 1 >>> longest_palindromic_substring_length(\\"xy\\") 1 >>> longest_palindromic_substring_length(\\"xxy\\") 3 >>> longest_palindromic_substring_length(\\"xxyzzyy\\") 7","solution":"from collections import Counter def longest_palindromic_substring_length(s: str) -> int: Finds the length of the longest substring that can be rearranged to form a palindrome. char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 # One odd character can be placed in the center of the palindrome return length"},{"question":"def canSumSubset(arr: List[int], target: int) -> bool: Given an array of integers and a target sum, determine if there is a subset of these integers that adds up to the target sum. >>> canSumSubset([3, 34, 4, 12, 5, 2], 9) True >>> canSumSubset([3, 34, 4, 12, 5, 2], 30) False >>> canSumSubset([3], 3) True >>> canSumSubset([3], 4) False >>> canSumSubset([1, 2, 3, 4, 5], 15) True >>> canSumSubset([], 0) True >>> canSumSubset([], 10) False","solution":"def canSumSubset(arr, target): Given an array of integers and a target sum, determine if there is a subset of these integers that adds up to the target sum. n = len(arr) dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if j < arr[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] return dp[n][target]"},{"question":"import heapq import itertools from typing import Optional class PriorityQueueManager: def __init__(self): Initializes an empty priority queue. self.queue = [] self.entry_finder = {} self.counter = itertools.count() def add(self, product_name: str, priority: int): Adds a new product to the queue with the given priority. Args: product_name (str): The name of the product. priority (int): The priority of the product. pass def remove(self, product_name: str): Removes the product from the queue. Args: product_name (str): The name of the product to remove. pass def process(self) -> Optional[str]: Processes and removes the highest priority product from the queue. Returns: Optional[str]: The name of the processed product, or None if the queue is empty. pass def view(self) -> Optional[str]: Returns the current highest priority product's name without removing it from the queue. Returns: Optional[str]: The name of the highest priority product, or None if the queue is empty. pass # Example usage if __name__ == \\"__main__\\": pq_manager = PriorityQueueManager() import sys input = sys.stdin.read commands = input().strip().split('n') for command in commands: if command.startswith(\\"ADD\\"): _, name, priority = command.split() pq_manager.add(name, int(priority)) elif command == \\"PROCESS\\": processed_product = pq_manager.process() if processed_product: print(processed_product) elif command == \\"VIEW\\": viewed_product = pq_manager.view() if viewed_product: print(viewed_product) elif command == \\"EXIT\\": break","solution":"import heapq import itertools class PriorityQueueManager: def __init__(self): self.queue = [] self.entry_finder = {} self.counter = itertools.count() def add(self, product_name, priority): if product_name in self.entry_finder: self.remove(product_name) count = next(self.counter) entry = [-priority, count, product_name] self.entry_finder[product_name] = entry heapq.heappush(self.queue, entry) def remove(self, product_name): entry = self.entry_finder.pop(product_name) entry[-1] = None def process(self): while self.queue: priority, count, product_name = heapq.heappop(self.queue) if product_name is not None: del self.entry_finder[product_name] return product_name return None def view(self): while self.queue: priority, count, product_name = self.queue[0] if product_name is not None: return product_name else: heapq.heappop(self.queue) return None # Example usage if __name__ == \\"__main__\\": pq_manager = PriorityQueueManager() import sys input = sys.stdin.read commands = input().strip().split('n') for command in commands: if command.startswith(\\"ADD\\"): _, name, priority = command.split() pq_manager.add(name, int(priority)) elif command == \\"PROCESS\\": processed_product = pq_manager.process() if processed_product: print(processed_product) elif command == \\"VIEW\\": viewed_product = pq_manager.view() if viewed_product: print(viewed_product) elif command == \\"EXIT\\": break"},{"question":"from typing import List def can_buy_with_exact_money(items: List[int], total_money: int) -> str: Determines if there is a subset of items that adds up exactly to total_money. Args: items (list of int): List of integers representing the cost of items. total_money (int): Integer representing the total money available. Returns: str: 'YES' if such a subset exists, 'NO' otherwise. pass # Example unit tests def test_example_case(): items = [1, 2, 3, 4, 5] total_money = 9 assert can_buy_with_exact_money(items, total_money) == \\"YES\\" def test_no_subset_exists(): items = [1, 2, 3, 4, 5] total_money = 20 assert can_buy_with_exact_money(items, total_money) == \\"NO\\" def test_exact_amount_exists(): items = [3, 34, 4, 12, 5, 2] total_money = 9 assert can_buy_with_exact_money(items, total_money) == \\"YES\\" def test_single_item_exact_amount(): items = [1, 2, 3, 4, 5] total_money = 3 assert can_buy_with_exact_money(items, total_money) == \\"YES\\" def test_single_item_more_than_money(): items = [1, 2, 3, 4, 5] total_money = 1 assert can_buy_with_exact_money(items, total_money) == \\"YES\\" def test_large_values(): items = [400, 500, 300, 700, 200] total_money = 1000 assert can_buy_with_exact_money(items, total_money) == \\"YES\\" def test_all_items_together(): items = [100, 200, 300, 400, 500] total_money = 1500 assert can_buy_with_exact_money(items, total_money) == \\"YES\\" def test_multiple_solutions(): items = [2, 4, 6, 8] total_money = 10 assert can_buy_with_exact_money(items, total_money) == \\"YES\\"","solution":"def can_buy_with_exact_money(items, total_money): Determines if there is a subset of items that adds up exactly to total_money. Args: items (list of int): List of integers representing the cost of items. total_money (int): Integer representing the total money available. Returns: str: 'YES' if such a subset exists, 'NO' otherwise. n = len(items) dp = [False] * (total_money + 1) dp[0] = True for item in items: for j in range(total_money, item - 1, -1): if dp[j - item]: dp[j] = True return \\"YES\\" if dp[total_money] else \\"NO\\""},{"question":"from typing import List, Tuple def min_cost_to_forward_packet(n: int, reliability_scores: List[int], connections: List[Tuple[int, int]]) -> int: Compute the minimum total cost to forward a packet from router 1 to router n through the most reliable paths in the network. >>> n = 5 >>> m = 6 >>> reliability_scores = [7, 3, 5, 2, 6] >>> connections = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)] >>> min_cost_to_forward_packet(n, reliability_scores, connections) 3 >>> n = 2 >>> m = 0 >>> reliability_scores = [1, 1] >>> connections = [] >>> min_cost_to_forward_packet(n, reliability_scores, connections) inf >>> n = 2 >>> m = 1 >>> reliability_scores = [1, 2] >>> connections = [(1, 2)] >>> min_cost_to_forward_packet(n, reliability_scores, connections) 1","solution":"import heapq def min_cost_to_forward_packet(n, reliability_scores, connections): # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for a, b in connections: graph[a].append(b) # Initialize distances to inf, except the start node inf = float('inf') distances = [inf] * (n + 1) distances[1] = 0 # Priority queue to process the nodes pq = [(0, 1)] # (cost, node) while pq: current_cost, current_node = heapq.heappop(pq) # If the current node is the destination, return the cost if current_node == 5: return current_cost for neighbor in graph[current_node]: cost = abs(reliability_scores[current_node - 1] - reliability_scores[neighbor - 1]) new_cost = current_cost + cost if new_cost < distances[neighbor]: distances[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return distances[n] # Example usage n = 5 m = 6 reliability_scores = [7, 3, 5, 2, 6] connections = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (3, 5)] print(min_cost_to_forward_packet(n, reliability_scores, connections)) # Output: 3"},{"question":"def lcs_length(X: str, Y: str) -> int: This function returns the length of the longest common subsequence of X and Y. >>> lcs_length(\\"ABCBDAB\\", \\"BDCAB\\") 4 >>> lcs_length(\\"XMJYAUZ\\", \\"MZJAWXU\\") 4 >>> lcs_length(\\"ABC\\", \\"DEF\\") 0 def read_input_and_compute_lcs(test_cases_inputs: List[Tuple[str, str]]) -> List[int]: Reads the input for the test cases and returns the list of results for each test case. >>> read_input_and_compute_lcs([(\\"ABCBDAB\\", \\"BDCAB\\"), (\\"XMJYAUZ\\", \\"MZJAWXU\\"), (\\"ABC\\", \\"DEF\\")]) [4, 4, 0] from typing import List, Tuple def test_single_case(): assert lcs_length(\\"ABCBDAB\\", \\"BDCAB\\") == 4 assert lcs_length(\\"XMJYAUZ\\", \\"MZJAWXU\\") == 4 assert lcs_length(\\"ABC\\", \\"DEF\\") == 0 def test_multiple_cases(): test_cases_inputs = [ (\\"ABCBDAB\\", \\"BDCAB\\"), (\\"XMJYAUZ\\", \\"MZJAWXU\\"), (\\"ABC\\", \\"DEF\\") ] expected_outputs = [4, 4, 0] assert read_input_and_compute_lcs(test_cases_inputs) == expected_outputs def test_no_common_subsequence(): assert lcs_length(\\"ABC\\", \\"XZY\\") == 0 def test_partial_overlap(): assert lcs_length(\\"AGGTAB\\", \\"GXTXAYB\\") == 4 def test_identical_strings(): assert lcs_length(\\"ABCDEF\\", \\"ABCDEF\\") == 6 def test_empty_strings(): assert lcs_length(\\"\\", \\"\\") == 0 def test_one_empty_string(): assert lcs_length(\\"ABCDE\\", \\"\\") == 0 assert lcs_length(\\"\\", \\"ABCDE\\") == 0","solution":"def lcs_length(X, Y): This function returns the length of the longest common subsequence of X and Y. m = len(X) n = len(Y) # Create a table to store lengths of longest common subsequence. L = [[0] * (n + 1) for _ in range(m + 1)] # Build the L[m+1][n+1] in a bottom-up fashion. for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) # L[m][n] contains the length of LCS for X[0...m-1], Y[0...n-1] return L[m][n] def read_input_and_compute_lcs(test_cases_inputs): Reads the input for the test cases and returns the list of results for each test case. results = [] for i in range(len(test_cases_inputs)): X, Y = test_cases_inputs[i] results.append(lcs_length(X, Y)) return results"},{"question":"def can_split_wall(n, weights): Determines if it's possible to split the wall into two contiguous subwalls with equal total weight. Parameters: - n (int): The number of bricks. - weights (list): The weights of the bricks. Returns: - str: \\"Yes\\" if it's possible to split the wall, otherwise \\"No\\". >>> can_split_wall(4, [1, 2, 2, 1]) == \\"Yes\\" >>> can_split_wall(3, [1, 1, 1]) == \\"No\\" from solution import can_split_wall def test_example_1(): assert can_split_wall(4, [1, 2, 2, 1]) == \\"Yes\\" def test_example_2(): assert can_split_wall(3, [1, 1, 1]) == \\"No\\" def test_small_no_split(): assert can_split_wall(2, [1, 2]) == \\"No\\" def test_small_split(): assert can_split_wall(2, [1, 1]) == \\"Yes\\" def test_large_no_split(): assert can_split_wall(5, [1, 2, 4, 8, 16]) == \\"No\\" def test_large_split(): assert can_split_wall(6, [1, 2, 3, 3, 2, 1]) == \\"Yes\\" def test_single_equal_element(): assert can_split_wall(2, [8, 8]) == \\"Yes\\" def test_all_elements_same(): assert can_split_wall(4, [2, 2, 2, 2]) == \\"Yes\\" def test_non_dividing_total_weight(): assert can_split_wall(5, [1, 1, 1, 1, 1]) == \\"No\\"","solution":"def can_split_wall(n, weights): Determines if it's possible to split the wall into two contiguous subwalls with equal total weight. Parameters: - n (int): The number of bricks. - weights (list): The weights of the bricks. Returns: - str: \\"Yes\\" if it's possible to split the wall, otherwise \\"No\\". total_weight = sum(weights) if total_weight % 2 != 0: return \\"No\\" target = total_weight // 2 current_sum = 0 for weight in weights: current_sum += weight if current_sum == target: return \\"Yes\\" return \\"No\\""},{"question":"def min_max_diff(n: int, difficulties: List[int]) -> int: Returns the minimum possible maximum difference between the difficulties of any two consecutive sessions. Args: n: An integer, the number of sessions. difficulties: A list of integers representing the difficulty levels of the sessions. Returns: An integer representing the minimum possible maximum difference between consecutive sessions' difficulty levels. >>> min_max_diff(4, [1, 5, 9, 13]) 4 >>> min_max_diff(5, [4, 2, 6, 8, 10]) 2 >>> min_max_diff(3, [10, 20, 30]) 10 >>> min_max_diff(6, [1, 3, 3, 1, 4, 4]) 0 >>> min_max_diff(7, [10, 2, 14, 6, 8, 12, 4]) 2 >>> min_max_diff(2, [1, 1000000]) 999999 >>> min_max_diff(5, [5, 5, 5, 5, 5]) 0 >>> min_max_diff(1, [42]) inf","solution":"def min_max_diff(n, difficulties): Returns the minimum possible maximum difference between the difficulties of any two consecutive sessions. # Sort the difficulty levels in ascending order sorted_difficulties = sorted(difficulties) # Initialize the minimum possible maximum difference to a large number min_possible_max_diff = float('inf') # Iterate through the sorted list and find the maximum difference between consecutive elements for i in range(1, n): diff = sorted_difficulties[i] - sorted_difficulties[i - 1] min_possible_max_diff = min(min_possible_max_diff, diff) return min_possible_max_diff"},{"question":"def calculate_skyline(n: int, heights: List[int]) -> List[int]: Calculate the height of the skyline at each position. Parameters: n (int): The number of skyscrapers heights (list of int): The heights of the skyscrapers Returns: list of int: The height of the skyline at each position Example: >>> calculate_skyline(5, [3, 1, 4, 1, 5]) [3, 3, 4, 4, 5]","solution":"def calculate_skyline(n, heights): Calculate the height of the skyline at each position. Parameters: n (int): The number of skyscrapers heights (list of int): The heights of the skyscrapers Returns: list of int: The height of the skyline at each position skyline = [] max_height = 0 for height in heights: max_height = max(max_height, height) skyline.append(max_height) return skyline"},{"question":"def min_cost_path(t: int, test_cases: List[Dict[str, Union[Tuple[int, int], List[List[int]]]]]) -> List[int]: Calculate the minimum cost for a robot to reach the bottom-right corner from the top-left corner of a grid. Args: t (int): Number of test cases. test_cases (List[Dict[str, Union[Tuple[int, int], List[List[int]]]]]): List of test cases where each test case contains: - 'dimensions' (Tuple[int, int]): Dimensions of the grid. - 'grid' (List[List[int]]): Cost grid. Returns: List[int]: Minimum cost for each test case. >>> t = 2 >>> test_cases = [ ... { ... 'dimensions': (3, 4), ... 'grid': [ ... [1, 3, 1, 2], ... [1, 5, 1, 3], ... [4, 2, 1, 1] ... ] ... }, ... { ... 'dimensions': (2, 2), ... 'grid': [ ... [1, 2], ... [1, 3] ... ] ... } ... ] >>> min_cost_path(t, test_cases) [8, 5] >>> t = 1 >>> test_cases = [ ... { ... 'dimensions': (1, 1), ... 'grid': [ ... [0] ... ] ... } ... ] >>> min_cost_path(t, test_cases) [0]","solution":"def min_cost_path(t, test_cases): results = [] for case in test_cases: m, n = case['dimensions'] grid = case['grid'] dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] results.append(dp[-1][-1]) return results"},{"question":"from typing import List def min_moves(n: int, m: int, s_x: int, s_y: int, t_x: int, t_y: int, grid: List[List[str]]) -> int: Returns the minimum number of moves required for Alex to reach the target position, or -1 if it is impossible. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. s_x (int): Starting position's row. s_y (int): Starting position's column. t_x (int): Target position's row. t_y (int): Target position's column. grid (List[List[str]]): The grid representing the maze. Returns: int: Minimum number of moves required, or -1 if not possible. Examples: >>> min_moves(5, 6, 1, 1, 5, 6, ['. . # . . .'.split(), '. # # # # .'.split(), '. . . # . .'.split(), '. # . . . .'.split(), '. . . . . .'.split()]) 9 >>> min_moves(3, 3, 1, 1, 3, 3, ['. # .'.split(), '# # #'.split(), '. # .'.split()]) -1","solution":"from collections import deque def min_moves(n, m, s_x, s_y, t_x, t_y, grid): Returns the minimum number of moves required for Alex to reach the target position, or -1 if it is impossible. # Initialize variables s_x -= 1 s_y -= 1 t_x -= 1 t_y -= 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(s_x, s_y, 0)]) visited = set((s_x, s_y)) # BFS loop while queue: x, y, steps = queue.popleft() # Check if we reached the target if (x, y) == (t_x, t_y): return steps # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindrome that can be created from the given string \`s\`. >>> longest_palindrome_length(\\"aabbcc\\") == 6 >>> longest_palindrome_length(\\"a\\") == 1 >>> longest_palindrome_length(\\"abcdef\\") == 1 >>> longest_palindrome_length(\\"abccccd\\") == 5 >>> longest_palindrome_length(\\"racecar\\") == 7 >>> longest_palindrome_length(\\"a\\" * 1000) == 1000 >>> longest_palindrome_length(\\"a\\" * 500 + \\"b\\" * 500) == 1000 pass","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be created from the given string \`s\`. from collections import Counter char_counts = Counter(s) length = 0 odd_count_found = False for count in char_counts.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count_found = True if odd_count_found: length += 1 return length"},{"question":"def largest_subarray_with_two_distinct_numbers(arr): Returns the length of the largest subarray containing exactly two distinct numbers. Args: arr (List[int]): The input array of integers. Returns: int: The length of the largest subarray containing exactly two distinct numbers. Example: >>> largest_subarray_with_two_distinct_numbers([4, 1, 1, 4, 4, 2]) 5 >>> largest_subarray_with_two_distinct_numbers([1, 2, 1, 2, 3]) 4 from solution import largest_subarray_with_two_distinct_numbers def test_example_case(): assert largest_subarray_with_two_distinct_numbers([4, 1, 1, 4, 4, 2]) == 5 def test_all_same_elements(): assert largest_subarray_with_two_distinct_numbers([1, 1, 1, 1, 1, 1]) == 6 def test_two_distinct_elements(): assert largest_subarray_with_two_distinct_numbers([1, 2, 1, 2, 1, 2]) == 6 def test_no_elements(): assert largest_subarray_with_two_distinct_numbers([]) == 0 def test_single_element(): assert largest_subarray_with_two_distinct_numbers([1]) == 1 def test_multiple_transitions(): assert largest_subarray_with_two_distinct_numbers([1, 2, 3, 2, 2, 1, 4, 4]) == 4 def test_right_bound_case(): assert largest_subarray_with_two_distinct_numbers([1, 1, 2, 2, 2]) == 5 def test_distinct_at_ends(): assert largest_subarray_with_two_distinct_numbers([1, 2, 1, 2, 3]) == 4","solution":"def largest_subarray_with_two_distinct_numbers(arr): Returns the length of the largest subarray containing exactly two distinct numbers. from collections import defaultdict n = len(arr) if n < 2: return n left = 0 right = 0 max_len = 0 freq = defaultdict(int) while right < n: freq[arr[right]] += 1 while len(freq) > 2: freq[arr[left]] -= 1 if freq[arr[left]] == 0: del freq[arr[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"from typing import List, Tuple def longest_even_odd_segment(nums: List[int]) -> int: Given a list of integers, find the length of the longest contiguous subarray with an equal number of even and odd integers. >>> longest_even_odd_segment([1, 2, 3, 4, 5, 6]) == 6 >>> longest_even_odd_segment([1, 3, 5, 7, 9]) == 0 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases for the longest even-odd segment problem. >>> process_test_cases([(6, [1, 2, 3, 4, 5, 6])]) == [6] >>> process_test_cases([(5, [1, 3, 5, 7, 9])]) == [0] import pytest from solution import longest_even_odd_segment, process_test_cases def test_case_1(): test_cases = [(6, [1, 2, 3, 4, 5, 6])] assert process_test_cases(test_cases) == [6] def test_case_2(): test_cases = [(5, [1, 3, 5, 7, 9])] assert process_test_cases(test_cases) == [0] def test_multiple_cases(): test_cases = [ (6, [1, 2, 3, 4, 5, 6]), (5, [1, 3, 5, 7, 9]), (4, [2, 4, 1, 3]), (4, [2, 2, 2, 2]), (4, [1, 1, 1, 1]) ] assert process_test_cases(test_cases) == [6, 0, 4, 0, 0] def test_large_case(): test_cases = [(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2])] assert process_test_cases(test_cases) == [10] def test_edge_case(): test_cases = [(1, [1]), (1, [2])] assert process_test_cases(test_cases) == [0, 0] def test_mixed_case(): test_cases = [(7, [1, 3, 2, 2, 6, 5, 9])] assert process_test_cases(test_cases) == [6]","solution":"def longest_even_odd_segment(nums): prefix_difference = {0: -1} max_length = 0 count_even = count_odd = 0 for i, num in enumerate(nums): if num % 2 == 0: count_even += 1 else: count_odd += 1 diff = count_even - count_odd if diff in prefix_difference: max_length = max(max_length, i - prefix_difference[diff]) else: prefix_difference[diff] = i return max_length def process_test_cases(test_cases): results = [] for case in test_cases: n, nums = case result = longest_even_odd_segment(nums) results.append(result) return results"},{"question":"from typing import List from collections import deque def max_of_subarrays(arr: List[int], n: int, k: int) -> List[int]: Given an array of integers a[1], a[2], ..., a[n], and a number k, find all contiguous subarrays of length exactly k that can be formed from the array. For each subarray, calculate the maximum value. Return an array of these maximum values. >>> max_of_subarrays([1, 3, 5, 2, 8, 7, 3], 7, 3) [5, 5, 8, 8, 8] >>> max_of_subarrays([1, 2, 3, 4, 5], 5, 2) [2, 3, 4, 5] >>> max_of_subarrays([5, 4, 3, 2, 1], 5, 1) [5, 4, 3, 2, 1] >>> max_of_subarrays([10, 9, 8, 7, 6, 5], 6, 3) [10, 9, 8, 7] >>> max_of_subarrays([1, 2, 3, 1, 4, 5], 6, 4) [3, 4, 5]","solution":"from collections import deque def max_of_subarrays(arr, n, k): Find all contiguous subarrays of length exactly k and return their maximum values. param arr: List of integers param n: Length of the array param k: Length of the subarrays return: List of integers if k == 1: return arr result = [] dq = deque() for i in range(k): while dq and arr[dq[-1]] < arr[i]: dq.pop() dq.append(i) for i in range(k, n): result.append(arr[dq[0]]) while dq and dq[0] <= i - k: dq.popleft() while dq and arr[dq[-1]] < arr[i]: dq.pop() dq.append(i) result.append(arr[dq[0]]) return result"},{"question":"def can_schedule_rentals(n: int, intervals: List[Tuple[int, int]]) -> str: Determine if rental intervals can be scheduled without conflicts. Args: n : int : number of rental slots intervals : list of tuples : list of (start_time, end_time) pairs Returns: str : \\"YES\\" if all intervals can be scheduled without conflicts, otherwise \\"NO\\" >>> can_schedule_rentals(3, [(1, 5), (2, 6), (7, 8)]) NO >>> can_schedule_rentals(2, [(1, 3), (4, 5)]) YES","solution":"def can_schedule_rentals(n, intervals): Determine if rental intervals can be scheduled without conflicts. Args: n : int : number of rental slots intervals : list of tuples : list of (start_time, end_time) pairs Returns: str : \\"YES\\" if all intervals can be scheduled without conflicts, otherwise \\"NO\\" # Sort intervals by their start times intervals.sort() # Iterate through the intervals to check for overlap for i in range(1, n): if intervals[i][0] < intervals[i - 1][1]: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def min_swaps_to_sort_books(heights: List[int]) -> int: Calculate the minimum number of swap operations required to sort the books in non-decreasing order of their heights. >>> min_swaps_to_sort_books([1]) 0 >>> min_swaps_to_sort_books([1, 2, 3, 4, 5]) 0 >>> min_swaps_to_sort_books([5, 4, 3, 2, 1]) 10 >>> min_swaps_to_sort_books([2, 3, 8, 6, 1]) 5 >>> min_swaps_to_sort_books([5, 5, 5, 5]) 0 from typing import List def count_inversions(arr: List[int]) -> int: pass # Implementation needed def min_swaps_to_sort_books(heights: List[int]) -> int: return count_inversions(heights) def test_min_swaps_to_sort_books(): assert min_swaps_to_sort_books([1]) == 0 assert min_swaps_to_sort_books([1, 2, 3, 4, 5]) == 0 assert min_swaps_to_sort_books([5, 4, 3, 2, 1]) == 10 assert min_swaps_to_sort_books([2, 3, 8, 6, 1]) == 5 assert min_swaps_to_sort_books([5, 5, 5, 5]) == 0 # Add more tests if necessary","solution":"def count_inversions(arr): Count the number of inversions required to sort the array using a modified merge sort. # Helper function to merge two halves and count inversions def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions, because all elements left to i in the left subarray are greater temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count # Helper function to perform merge sort and count inversions def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr)-1) def min_swaps_to_sort_books(heights): Returns the minimum number of swap operations required to sort the book heights. return count_inversions(heights)"},{"question":"def count_good_substrings(s: str) -> int: Returns the number of good substrings of s. A \\"good\\" substring is defined as a substring that contains at least two distinct characters. >>> count_good_substrings(\\"abc\\") 3 >>> count_good_substrings(\\"aaa\\") 0 >>> count_good_substrings(\\"abac\\") 6 >>> count_good_substrings(\\"abcde\\") 10 >>> count_good_substrings(\\"a\\") 0 >>> count_good_substrings(\\"aa\\") 0 >>> count_good_substrings(\\"az\\") 1 >>> count_good_substrings(\\"ababc\\") 10 pass","solution":"def count_good_substrings(s): Returns the number of good substrings of s. A \\"good\\" substring is defined as a substring that contains at least two distinct characters. n = len(s) good_substring_count = 0 # Iterate over all possible substrings for length in range(2, n + 1): # Start from length 2 to n for i in range(n - length + 1): substring = s[i:i + length] if len(set(substring)) > 1: good_substring_count += 1 return good_substring_count"},{"question":"def validate_checkerboard(n: int, shades: List[int]) -> str: Determines if it's possible to rearrange the list of shades to achieve a checkerboard pattern where no two consecutive pieces have a difference in shades of less than 20. :param n: The number of pieces :param shades: List of integers representing the shade values of the pieces :return: \\"YES\\" if possible to achieve the pattern, \\"NO\\" otherwise >>> validate_checkerboard(5, [20, 40, 60, 80, 100]) == \\"YES\\" >>> validate_checkerboard(3, [10, 15, 25]) == \\"NO\\" >>> validate_checkerboard(1, [50]) == \\"YES\\" >>> validate_checkerboard(4, [10, 10, 10, 10]) == \\"NO\\" >>> validate_checkerboard(4, [10, 30, 50, 70]) == \\"YES\\"","solution":"def validate_checkerboard(n, shades): Determines if it's possible to rearrange the list of shades to achieve a checkerboard pattern where no two consecutive pieces have a difference in shades of less than 20. :param n: The number of pieces :param shades: List of integers representing the shade values of the pieces :return: \\"YES\\" if possible to achieve the pattern, \\"NO\\" otherwise if n == 1: return \\"YES\\" # A single piece will always satisfy the condition # Sort the shades shades.sort() # Check for the difference between consecutive elements for i in range(n - 1): if abs(shades[i + 1] - shades[i]) < 20: return \\"NO\\" return \\"YES\\""},{"question":"def longest_common_subsequence(A: str, B: str) -> int: Returns the length of the longest common subsequence between strings A and B. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0","solution":"def longest_common_subsequence(A: str, B: str) -> int: Returns the length of the longest common subsequence between strings A and B. m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"import heapq from typing import List def min_delivery_cost(n: int, grid: List[List[int]]) -> int: Determine the minimum delivery cost to reach the bottom-right corner of the grid. >>> min_delivery_cost(3, [ ... [1, 2, 3], ... [4, -1, 6], ... [7, 8, 9]]) 21 >>> min_delivery_cost(2, [ ... [1, -1], ... [-1, 2]]) -1 >>> min_delivery_cost(1, [[0]]) 0 >>> min_delivery_cost(2, [ ... [-1, 1], ... [1, 1]]) -1 >>> min_delivery_cost(3, [ ... [1, 1, 1], ... [1, -1, 1], ... [1, 1, 1]]) 5","solution":"import heapq def min_delivery_cost(n, grid): if grid[0][0] == -1 or grid[n-1][n-1] == -1: return -1 directions = [(1, 0), (0, 1)] costs = [[float('inf')] * n for _ in range(n)] costs[0][0] = grid[0][0] min_heap = [(grid[0][0], 0, 0)] while min_heap: current_cost, x, y = heapq.heappop(min_heap) if x == n-1 and y == n-1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] != -1: next_cost = current_cost + grid[nx][ny] if next_cost < costs[nx][ny]: costs[nx][ny] = next_cost heapq.heappush(min_heap, (next_cost, nx, ny)) return -1 if costs[n-1][n-1] == float('inf') else costs[n-1][n-1]"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: input string :return: length of the longest substring without repeating characters >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 from solution import length_of_longest_substring def test_example_1(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 def test_example_2(): assert length_of_longest_substring(\\"bbbbb\\") == 1 def test_example_3(): assert length_of_longest_substring(\\"pwwkew\\") == 3 def test_empty_string(): assert length_of_longest_substring(\\"\\") == 0 def test_single_char_string(): assert length_of_longest_substring(\\"a\\") == 1 def test_all_unique_chars(): assert length_of_longest_substring(\\"abcdef\\") == 6 def test_string_with_repeats(): assert length_of_longest_substring(\\"abba\\") == 2 def test_long_string(): assert length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\" * 100) == 26","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: input string :return: length of the longest substring without repeating characters char_map = {} start = 0 max_length = 0 for end in range(len(s)): if s[end] in char_map and char_map[s[end]] >= start: start = char_map[s[end]] + 1 char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def minimum_soldiers_each_day(n, k, m, stamina_levels): Achilles needs to determine the minimum number of soldiers required each day to achieve at least m stamina while preserving the most soldiers for the entire expedition. n: int - Number of soldiers. k: int - Number of days. m: int - Required stamina level per day. stamina_levels: List[int] - Stamina levels of the soldiers. Returns: List[int] - List containing the minimum number of soldiers required each day to achieve at least m stamina. Example: >>> minimum_soldiers_each_day(5, 2, 10, [8, 4, 3, 5, 6]) [2, 2] >>> minimum_soldiers_each_day(4, 3, 10, [10, 10, 10, 10]) [1, 1, 1]","solution":"def minimum_soldiers_each_day(n, k, m, stamina_levels): # Sort stamina levels in descending order to minimize the number of soldiers required stamina_levels.sort(reverse=True) result = [] # Iterate through each day to find the minimum number of soldiers required for day in range(k): current_stamina = 0 soldiers_count = 0 # Accumulate stamina until it meets or exceeds the required stamina for the day for stamina in stamina_levels: current_stamina += stamina soldiers_count += 1 if current_stamina >= m: result.append(soldiers_count) break return result"},{"question":"def shortest_path(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: You are tasked with developing a new navigation system for a quantum computing research facility. The facility's network can be represented as a directed graph with n nodes and m edges, where each node corresponds to a specific location within the facility, and each edge represents a permissible direct path between two locations. Nodes are numbered from 1 to n. The system must be designed to quickly determine the shortest path between any two given locations. To achieve this, you need to analyze queries that request the shortest path distance between specified pairs of nodes. The first line of the input contains two integers, n and m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 10000), representing the number of nodes and edges, respectively. Each of the following m lines describes an edge with three integers u, v, and w (1 ≤ u, v ≤ n, 1 ≤ w ≤ 100), indicating a directed edge from node u to node v with a weight of w. The next line contains a single integer q (1 ≤ q ≤ 100000), representing the number of queries. Each of the following q lines contains two integers, a and b (1 ≤ a, b ≤ n), for which you need to find the shortest path distance from node a to node b. For each query, output the shortest path distance from node a to node b. If there is no path between the nodes, output -1. Example: >>> shortest_path(4, [(1, 2, 5), (2, 3, 10), (3, 4, 1), (1, 3, 20)], [(1, 3), (2, 4), (1, 4)]) [15, 11, 16] >>> shortest_path(3, [(1, 2, 5), (2, 3, 10)], [(1, 3), (3, 1)]) [15, -1]","solution":"import sys import heapq def dijkstra(n, adj, start): dist = [sys.maxsize] * (n + 1) dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > dist[current_node]: continue for neighbor, weight in adj[current_node]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist def shortest_path(n, edges, queries): adj = [[] for _ in range(n + 1)] for u, v, w in edges: adj[u].append((v, w)) distances = {} for i in range(1, n + 1): distances[i] = dijkstra(n, adj, i) results = [] for a, b in queries: result = distances[a][b] if result == sys.maxsize: results.append(-1) else: results.append(result) return results"},{"question":"def numberToWords(n: int) -> str: Convert a number to its corresponding English words representation. >>> numberToWords(0) 'zero' >>> numberToWords(5) 'five' >>> numberToWords(19) 'nineteen' >>> numberToWords(42) 'forty-two' >>> numberToWords(100) 'one hundred' >>> numberToWords(123) 'one hundred twenty-three' >>> numberToWords(1001) 'one thousand one' >>> numberToWords(11001) 'eleven thousand one' >>> numberToWords(99999) 'ninety-nine thousand nine hundred ninety-nine'","solution":"def numberToWords(n): if n == 0: return \\"zero\\" units = [\\"\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\"] teens = [\\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\"] tens = [\\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\"] def two_digit_to_words(n): if n < 10: return units[n] elif n < 20: return teens[n - 10] else: tens_unit = tens[n // 10] + (\\"-\\" + units[n % 10] if n % 10 != 0 else \\"\\") return tens_unit def three_digit_to_words(n): if n < 100: return two_digit_to_words(n) else: return units[n // 100] + \\" hundred\\" + (\\" \\" + two_digit_to_words(n % 100) if n % 100 != 0 else \\"\\") def four_five_digit_to_words(n): if n < 1000: return three_digit_to_words(n) elif n < 10000: return units[n // 1000] + \\" thousand\\" + (\\" \\" + three_digit_to_words(n % 1000) if n % 1000 != 0 else \\"\\") else: return two_digit_to_words(n // 1000) + \\" thousand\\" + (\\" \\" + three_digit_to_words(n % 1000) if n % 1000 != 0 else \\"\\") return four_five_digit_to_words(n)"},{"question":"def max_users_reached(n, m, friendships, f, follows, s): Determine the maximum number of users that can receive the information starting from the influential user. >>> max_users_reached(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (1, 6)], 1) 6 >>> max_users_reached(3, 2, [(1, 2), (2, 3)], 0, [], 1) 1 >>> max_users_reached(3, 2, [(1, 2), (2, 3)], 1, [(1, 2)], 1) 2 >>> max_users_reached(3, 3, [(1, 2), (2, 3), (3, 1)], 3, [(1, 2), (2, 3), (3, 1)], 1) 3","solution":"def max_users_reached(n, m, friendships, f, follows, s): from collections import defaultdict, deque # Create adjacency lists for follows follow_graph = defaultdict(list) for a, b in follows: follow_graph[a].append(b) # BFS to find all reachable nodes visited = set() queue = deque([s]) visited.add(s) while queue: user = queue.popleft() for follower in follow_graph[user]: if follower not in visited: visited.add(follower) queue.append(follower) return len(visited)"},{"question":"from typing import List def sum_of_digits(n: int) -> int: Returns the sum of digits of an integer n. return sum(int(digit) for digit in str(n)) def transform_list(nums: List[int], k: int) -> List[int]: Transforms the list 'nums' k times by replacing each integer with the sum of its digits in each transformation. >>> transform_list([18, 29, 39], 2) [9, 2, 3] >>> transform_list([999, 1000, 12345], 1) [27, 1, 15] pass","solution":"def sum_of_digits(n): Returns the sum of digits of an integer n. return sum(int(digit) for digit in str(n)) def transform_list(nums, k): Transforms the list 'nums' k times by replacing each integer with the sum of its digits in each transformation. for _ in range(k): nums = [sum_of_digits(num) for num in nums] return nums"},{"question":"class Library: def __init__(self): self.collection = set() self.borrowed = set() def add_book(self, book_id): pass def borrow_book(self, book_id): pass def return_book(self, book_id): pass def check_availability(self, book_id): pass def process_operations(n, operations): Performs a series of library management operations and returns the results of CHECK operations. >>> process_operations(7, [\\"ADD 1001\\", \\"ADD 1002\\", \\"BORROW 1001\\", \\"CHECK 1001\\", \\"CHECK 1002\\", \\"RETURN 1001\\", \\"CHECK 1001\\"]) [\\"NO\\", \\"YES\\", \\"YES\\"] library = Library() results = [] for operation in operations: parts = operation.split() if parts[0] == 'ADD': library.add_book(int(parts[1])) elif parts[0] == 'BORROW': library.borrow_book(int(parts[1])) elif parts[0] == 'RETURN': library.return_book(int(parts[1])) elif parts[0] == 'CHECK': results.append(library.check_availability(int(parts[1]))) return results","solution":"class Library: def __init__(self): self.collection = set() self.borrowed = set() def add_book(self, book_id): if book_id not in self.collection: self.collection.add(book_id) def borrow_book(self, book_id): if book_id in self.collection and book_id not in self.borrowed: self.borrowed.add(book_id) def return_book(self, book_id): if book_id in self.borrowed: self.borrowed.remove(book_id) def check_availability(self, book_id): if book_id in self.collection and book_id not in self.borrowed: return \\"YES\\" else: return \\"NO\\" def process_operations(n, operations): library = Library() results = [] for operation in operations: parts = operation.split() if parts[0] == 'ADD': library.add_book(int(parts[1])) elif parts[0] == 'BORROW': library.borrow_book(int(parts[1])) elif parts[0] == 'RETURN': library.return_book(int(parts[1])) elif parts[0] == 'CHECK': results.append(library.check_availability(int(parts[1]))) return results"},{"question":"def update_inventory(n: int, initial_stock: List[Tuple[str, int]], transactions: List[str]) -> Dict[str, int]: Compute the final stock count for each item after processing all the transactions. >>> update_inventory(3, [(\\"item1\\", 50), (\\"item2\\", 20), (\\"item3\\", 0)], [\\"item1 +10\\", \\"item2 -5\\", \\"item3 +7\\", \\"item1 -20\\"]) {'item1': 40, 'item2': 15, 'item3': 7} >>> update_inventory(2, [(\\"item1\\", 10), (\\"item2\\", 5)], []) {'item1': 10, 'item2': 5} >>> update_inventory(1, [(\\"itemA\\", 10)], [\\"itemA -15\\"]) {'itemA': -5} >>> update_inventory(2, [(\\"itemX\\", 5), (\\"itemY\\", 10)], [\\"itemX +3\\", \\"itemZ +7\\"]) {'itemX': 8, 'itemY': 10, 'itemZ': 7} >>> update_inventory(3, [(\\"item1\\", 100), (\\"item2\\", 200), (\\"item3\\", 300)], [\\"item1 +10\\", \\"item1 +20\\", \\"item2 -15\\", \\"item3 -5\\", \\"item2 +50\\", \\"item3 -25\\", \\"item1 -10\\"]) {'item1': 120, 'item2': 235, 'item3': 270}","solution":"from typing import List, Tuple, Dict def update_inventory(n: int, initial_stock: List[Tuple[str, int]], transactions: List[str]) -> Dict[str, int]: # Initialize inventory with initial stock counts inventory = {item: stock for item, stock in initial_stock} # Process each transaction for transaction in transactions: item, change = transaction.split() change_value = int(change) if item in inventory: inventory[item] += change_value else: inventory[item] = change_value return inventory"},{"question":"def has_subarray_with_sum(nums, k): Determines if there exists a contiguous subarray whose sum is equal to k. Args: nums (list of int): The array of integers. k (int): The target sum. Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\". def test_has_subarray_with_sum_yes_example1(): nums = [1, 2, 3, 7, 5] k = 15 assert has_subarray_with_sum(nums, k) == \\"Yes\\" def test_has_subarray_with_sum_yes_example2(): nums = [1, 2, 3, 4, 5] k = 10 assert has_subarray_with_sum(nums, k) == \\"Yes\\" def test_has_subarray_with_sum_no_example(): nums = [1, 2, 3, 7, 5] k = 25 assert has_subarray_with_sum(nums, k) == \\"No\\" def test_has_subarray_with_sum_empty_array(): nums = [] k = 0 assert has_subarray_with_sum(nums, k) == \\"No\\" def test_has_subarray_with_sum_single_element_equal_to_k(): nums = [10] k = 10 assert has_subarray_with_sum(nums, k) == \\"Yes\\" def test_has_subarray_with_sum_single_element_not_equal_to_k(): nums = [5] k = 10 assert has_subarray_with_sum(nums, k) == \\"No\\" def test_has_subarray_with_sum_multiple_possible_subarrays(): nums = [1, 2, 3, 4, 2, 16] k = 6 assert has_subarray_with_sum(nums, k) == \\"Yes\\"","solution":"def has_subarray_with_sum(nums, k): Determines if there exists a contiguous subarray whose sum is equal to k. Args: nums (list of int): The array of integers. k (int): The target sum. Returns: str: \\"Yes\\" if such a subarray exists, otherwise \\"No\\". current_sum = 0 sum_dict = {} for i in range(len(nums)): current_sum += nums[i] if current_sum == k: return \\"Yes\\" if (current_sum - k) in sum_dict: return \\"Yes\\" sum_dict[current_sum] = i return \\"No\\""},{"question":"def min_operations_to_equal_elements(arr): Finds the minimum number of operations required to make all elements in the array equal. pass def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(min_operations_to_equal_elements(arr)) return results def test_min_operations_to_equal_elements(): assert min_operations_to_equal_elements([1, 5]) == 4 assert min_operations_to_equal_elements([5, 5, 5]) == 0 assert min_operations_to_equal_elements([1, 2, 3, 4]) == 4 assert min_operations_to_equal_elements([1, 2, 3]) == 2 assert min_operations_to_equal_elements([1, 2]) == 1 assert min_operations_to_equal_elements([1]) == 0 assert min_operations_to_equal_elements([2, 4, 7, 8]) == 9 # Median is 6 def test_process_test_cases(): input_data = [ (2, [1, 5]), (3, [5, 5, 5]), (4, [1, 2, 3, 4]) ] expected_output = [4, 0, 4] assert process_test_cases(input_data) == expected_output input_data = [ (3, [1, 2, 3]), (2, [1, 2]), (1, [1]), (4, [2, 4, 7, 8]) ] expected_output = [2, 1, 0, 9] assert process_test_cases(input_data) == expected_output","solution":"def min_operations_to_equal_elements(arr): Finds the minimum number of operations required to make all elements in the array equal. arr.sort() median = arr[len(arr) // 2] total_operations = sum(abs(x - median) for x in arr) return total_operations def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(min_operations_to_equal_elements(arr)) return results"},{"question":"from typing import List def shortest_path(n: int, grid: List[List[str]]) -> int: Given the size and grid, find the length of the shortest path from top-left corner to bottom-right corner stepping only on 'G' cells. If no such path exists, return -1. >>> shortest_path(4, [[\\"G\\", \\"G\\", \\"G\\", \\"R\\"], [\\"R\\", \\"G\\", \\"R\\", \\"G\\"], [\\"G\\", \\"G\\", \\"G\\", \\"G\\"], [\\"R\\", \\"G\\", \\"R\\", \\"G\\"]]) 6 >>> shortest_path(3, [[\\"G\\", \\"R\\", \\"G\\"], [\\"R\\", \\"R\\", \\"R\\"], [\\"G\\", \\"G\\", \\"G\\"]]) -1","solution":"from collections import deque def shortest_path(n, grid): # Direction vectors for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if grid[0][0] == 'R' or grid[n-1][n-1] == 'R': # If start or end is 'R' return -1 queue = deque([(0, 0, 0)]) # (x, y, distance) visited = [[False] * n for _ in range(n)] visited[0][0] = True while queue: x, y, distance = queue.popleft() if x == n-1 and y == n-1: # Reached end return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 'G' and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, distance + 1)) return -1 # Path not found"},{"question":"from typing import List, Tuple def count_distinct_triangles(n: int, points: List[Tuple[int, int]]) -> int: You are given a set of n points on a 2D plane. Determine the number of distinct triangles that can be formed by these points with non-zero area. >>> count_distinct_triangles(5, [(0, 0), (1, 1), (2, 2), (3, 3), (1, 2)]) 6 >>> count_distinct_triangles(4, [(0, 0), (0, 1), (0, 2), (0, 3)]) 0","solution":"from itertools import combinations def count_distinct_triangles(n, points): def triangle_area(p1, p2, p3): return abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) triangles = 0 for p1, p2, p3 in combinations(points, 3): if triangle_area(p1, p2, p3) != 0: triangles += 1 return triangles"},{"question":"def max_fruits(n: int, fruits: List[int]) -> int: You are given an array of integers representing the number of fruits in each basket. You can choose to pick fruits from one or more baskets, but each time you can either pick all the fruits from a basket or half of the fruits of a basket (if the number of fruits is odd, you pick half of the floor value and leave the remaining). Your goal is to maximize the total number of fruits you collect. Parameters: n (int): Number of baskets fruits (list of int): Number of fruits in each basket Returns: int: Maximum number of fruits that can be collected Example: >>> max_fruits(4, [3, 5, 7, 9]) 20 >>> max_fruits(3, [2, 4, 6]) 12 >>> max_fruits(3, [3, 5, 7]) 15","solution":"def max_fruits(n, fruits): Returns the maximum number of fruits that can be collected from the baskets. Parameters: n (int): Number of baskets fruits (list of int): Number of fruits in each basket Returns: int: Maximum number of fruits that can be collected total_fruits = 0 for fruit in fruits: total_fruits += fruit return total_fruits"},{"question":"def can_group_connected_regions(n: int, m: int, grid: List[str]) -> str: Determine if it is possible to group all identical letters together such that each group forms a connected region in the grid. >>> can_group_connected_regions(3, 4, [\\"aabb\\", \\"aabb\\", \\"ccdd\\"]) == \\"YES\\" >>> can_group_connected_regions(3, 4, [\\"aabc\\", \\"aadc\\", \\"bbcc\\"]) == \\"NO\\" pass from typing import List def test_example_one(): grid = [ \\"aabb\\", \\"aabb\\", \\"ccdd\\" ] assert can_group_connected_regions(3, 4, grid) == \\"YES\\" def test_example_two(): grid = [ \\"aabc\\", \\"aadc\\", \\"bbcc\\" ] assert can_group_connected_regions(3, 4, grid) == \\"NO\\" def test_single_cell(): grid = [ \\"a\\" ] assert can_group_connected_regions(1, 1, grid) == \\"YES\\" def test_single_column(): grid = [ \\"a\\", \\"a\\", \\"b\\" ] assert can_group_connected_regions(3, 1, grid) == \\"YES\\" def test_single_row(): grid = [ \\"aaaabbcc\\" ] assert can_group_connected_regions(1, 8, grid) == \\"YES\\" def test_connected_diagonal(): grid = [ \\"ab\\", \\"ba\\" ] assert can_group_connected_regions(2, 2, grid) == \\"NO\\" def test_multiple_disconnected(): grid = [ \\"aa\\", \\"bb\\", \\"aa\\" ] assert can_group_connected_regions(3, 2, grid) == \\"NO\\"","solution":"def can_group_connected_regions(n, m, grid): def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() visited.add((cx, cy)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == grid[x][y] and (nx, ny) not in visited: stack.append((nx, ny)) visited = set() regions = {} for i in range(n): for j in range(m): if (i, j) not in visited: if grid[i][j] not in regions: regions[grid[i][j]] = 0 regions[grid[i][j]] += 1 dfs(i, j) for key in regions: if regions[key] != 1: return \\"NO\\" return \\"YES\\""},{"question":"def can_be_equal_with_one_swap(s1: str, s2: str) -> str: Check whether it is possible to rearrange the characters of s1 to make it equal to s2 by performing at most one swap. >>> can_be_equal_with_one_swap(\\"abc\\", \\"abc\\") == \\"Yes\\" >>> can_be_equal_with_one_swap(\\"ab\\", \\"ba\\") == \\"Yes\\" >>> can_be_equal_with_one_swap(\\"abcd\\", \\"abdc\\") == \\"Yes\\" >>> can_be_equal_with_one_swap(\\"abcd\\", \\"dcba\\") == \\"No\\" >>> can_be_equal_with_one_swap(\\"abc\\", \\"xyz\\") == \\"No\\" >>> can_be_equal_with_one_swap(\\"aabb\\", \\"bbaa\\") == \\"No\\"","solution":"def can_be_equal_with_one_swap(s1, s2): Check whether it is possible to rearrange the characters of s1 to make it equal to s2 by performing at most one swap. if s1 == s2: return \\"Yes\\" # Identify mismatched positions mismatched_positions = [i for i in range(len(s1)) if s1[i] != s2[i]] # If there are exactly two mismatched positions if len(mismatched_positions) == 2: i, j = mismatched_positions # Check if swapping s1[i] and s1[j] would make s1 equal to s2 if s1[i] == s2[j] and s1[j] == s2[i]: return \\"Yes\\" # All other cases return \\"No\\""},{"question":"def can_be_non_decreasing_by_one_swap(n, arr): Determine if it's possible to make the array non-decreasing by performing at most one swap operation. >>> can_be_non_decreasing_by_one_swap(1, [1]) \\"YES\\" >>> can_be_non_decreasing_by_one_swap(3, [1, 2, 3]) \\"YES\\" >>> can_be_non_decreasing_by_one_swap(4, [1, 3, 5, 3]) \\"YES\\" >>> can_be_non_decreasing_by_one_swap(5, [3, 5, 1, 4, 2]) \\"NO\\" >>> can_be_non_decreasing_by_one_swap(3, [3, 1, 2]) \\"NO\\"","solution":"def can_be_non_decreasing_by_one_swap(n, arr): if n == 1: return \\"YES\\" def is_sorted(arr): return all(arr[i] <= arr[i + 1] for i in range(n - 1)) if is_sorted(arr): return \\"YES\\" for i in range(n): for j in range(i + 1, n): arr[i], arr[j] = arr[j], arr[i] if is_sorted(arr): return \\"YES\\" arr[i], arr[j] = arr[j], arr[i] return \\"NO\\""},{"question":"from typing import List def countIslands(grid: List[str]) -> int: Count the number of distinct islands in a grid. An island is a maximal group of connected '.' cells. Two '.' cells are considered connected if and only if they are adjacent horizontally or vertically. Args: - grid: A list of strings representing the grid, where each character is either '.' or '#'. Returns: - An integer representing the number of distinct islands. Examples: >>> countIslands([ ... \\"....\\", ... \\"..\\", ... \\"\\", ... \\".#..\\" ... ]) 3 >>> countIslands([ ... \\"...\\", ... \\".#.\\", ... \\"...\\" ... ]) 1 >>> countIslands([ ... \\"#\\", ... \\"#\\", ... \\"#\\" ... ]) 0 >>> countIslands([ ... \\".........\\", ... \\".........\\", ... \\"....#....\\", ... \\".........\\", ... \\".........\\" ... ]) 1 >>> countIslands([ ... \\"#\\", ... \\"#.#\\", ... \\"#\\" ... ]) 1","solution":"from typing import List def countIslands(grid: List[str]) -> int: rows = len(grid) cols = len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '#' or visited[r][c]): return visited[r][c] = True # Visit all connected neighbors (up, down, left, right) dfs(r-1, c) dfs(r+1, c) dfs(r, c-1) dfs(r, c+1) count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == '.' and not visited[r][c]: count += 1 dfs(r, c) return count"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given a directed graph with n nodes and m edges, find the length of the shortest path from node 1 to node n. Each edge has a weight of 1. If there is no path from node 1 to node n, return -1. >>> shortest_path(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) 2 >>> shortest_path(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> shortest_path(4, 2, [(1, 2), (2, 3)]) -1 >>> shortest_path(3, 1, [(1, 3)]) 1 >>> shortest_path(5, 6, [(1, 2), (2, 5), (1, 3), (3, 4), (4, 5), (1, 5)]) 1 >>> shortest_path(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 5 >>> shortest_path(4, 0, []) -1","solution":"from collections import deque, defaultdict def shortest_path(n, m, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Breadth-First Search (BFS) from node 1 visited = [False] * (n + 1) queue = deque([(1, 0)]) # (current_node, current_distance) visited[1] = True while queue: node, distance = queue.popleft() if node == n: return distance for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, distance + 1)) return -1"},{"question":"from typing import List, Tuple def process_operations(n: int, q: int, array: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process a series of update and sum operations on the array. Parameters: n (int): Number of elements in the array. q (int): Number of operations. array (List[int]): Initial array of integers. operations (List[Tuple[int, int, int]]): Each tuple contains an operation. (1, idx, val) for update operation. (2, l, r) for sum query operation. Returns: List[int]: Result of each sum query operation. pass # Your implementation here # Unit tests def test_process_operations_example(): n = 5 q = 3 array = [1, 2, 3, 4, 5] operations = [(2, 1, 3), (1, 3, 10), (2, 3, 5)] expected = [6, 19] assert process_operations(n, q, array, operations) == expected def test_process_operations_basic_update(): n = 3 q = 2 array = [1, 2, 3] operations = [(1, 1, 5), (2, 1, 3)] expected = [10] assert process_operations(n, q, array, operations) == expected def test_process_operations_multiple_updates(): n = 4 q = 4 array = [1, 2, 3, 4] operations = [(1, 1, 5), (1, 2, 6), (1, 3, 7), (2, 1, 4)] expected = [22] assert process_operations(n, q, array, operations) == expected def test_process_operations_no_operations(): n = 4 q = 0 array = [1, 2, 3, 4] operations = [] expected = [] assert process_operations(n, q, array, operations) == expected def test_process_operations_large_query_range(): n = 6 q = 2 array = [3, 1, 4, 1, 5, 9] operations = [(2, 1, 6), (1, 4, 2), (2, 4, 6)] expected = [23, 16] assert process_operations(n, q, array, operations) == expected","solution":"def process_operations(n, q, array, operations): Process a series of update and sum operations on the array. Parameters: n (int): Number of elements in the array. q (int): Number of operations. array (list of int): Initial array of integers. operations (list of tuples): Each tuple contains an operation. (1, idx, val) for update operation. (2, l, r) for sum query operation. Returns: list of int: Result of each sum query operation. results = [] for operation in operations: if operation[0] == 1: # Update operation _, idx, val = operation array[idx - 1] = val elif operation[0] == 2: # Sum query operation _, l, r = operation results.append(sum(array[l - 1:r])) return results"},{"question":"def min_energy_cost(m: int, n: int, grid: List[List[int]]) -> int: Returns the minimum total energy cost to reach the bottom-right corner of the grid. >>> min_energy_cost(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 7 >>> min_energy_cost(2, 2, [ [1, 2], [1, 1] ]) 3","solution":"def min_energy_cost(m, n, grid): Returns the minimum total energy cost to reach the bottom-right corner of the grid. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (list of list of ints): 2D grid representing the energy costs. Returns: int: Minimum total energy cost. if m == 0 or n == 0: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def shortest_substring_with_k_distinct(s: str, k: int) -> int: Find the length of the shortest substring with at least k distinct characters. >>> shortest_substring_with_k_distinct(\\"abcde\\", 3) 3 >>> shortest_substring_with_k_distinct(\\"aaaa\\", 2) 0 >>> shortest_substring_with_k_distinct(\\"xyz\\", 4) 0 def solve(test_cases): Process multiple test cases of finding the shortest substring with at least k distinct characters. :param test_cases: List of tuples containing the string and the integer k. :return: List of integers representing the length of the shortest substring for each test case. pass from solution import solve def test_shortest_substring_case1(): test_cases = [(\\"abcde\\", 3)] assert solve(test_cases) == [3] def test_shortest_substring_case2(): test_cases = [(\\"aaaa\\", 2)] assert solve(test_cases) == [0] def test_shortest_substring_case3(): test_cases = [(\\"xyz\\", 4)] assert solve(test_cases) == [0] def test_shortest_substring_case4(): test_cases = [(\\"abcdefgh\\", 5)] assert solve(test_cases) == [5] def test_shortest_substring_case5(): test_cases = [(\\"aabbcc\\", 2)] assert solve(test_cases) == [2] def test_shortest_substring_multiple_cases(): test_cases = [ (\\"abcde\\", 3), (\\"aaaa\\", 2), (\\"xyz\\", 4), (\\"abcdefgh\\", 5), (\\"aabbcc\\", 2), ] assert solve(test_cases) == [3, 0, 0, 5, 2]","solution":"def shortest_substring_with_k_distinct(s, k): from collections import defaultdict n = len(s) if k > n: return 0 left = 0 right = 0 char_count = defaultdict(int) num_distinct = 0 min_length = float('inf') while right < n: # Expand the window by including the character at \`right\` if char_count[s[right]] == 0: num_distinct += 1 char_count[s[right]] += 1 right += 1 # Contract the window from the left to find the smallest length while num_distinct >= k: min_length = min(min_length, right - left) char_count[s[left]] -= 1 if char_count[s[left]] == 0: num_distinct -= 1 left += 1 return min_length if min_length != float('inf') else 0 def solve(test_cases): results = [] for s, k in test_cases: result = shortest_substring_with_k_distinct(s, k) results.append(result) return results"},{"question":"from typing import List def count_subarrays_divisible_by_p(n: int, k: int, p: int, arr: List[int]) -> int: Counts the number of subarrays of length k where the sum of elements is divisible by p. Args: n (int): The length of the array. k (int): The length of the subarrays to be considered. p (int): The divisor. arr (list): The list of integers. Returns: int: The number of subarrays where the sum is divisible by p. >>> count_subarrays_divisible_by_p(6, 4, 3, [1, 2, 3, 4, 5, 6]) 1 >>> count_subarrays_divisible_by_p(5, 2, 10, [1, 2, 3, 4, 5]) 0 >>> count_subarrays_divisible_by_p(4, 2, 5, [5, 10, 5, 10]) 3 >>> count_subarrays_divisible_by_p(5, 3, 4, [4, 8, 4, 8, 12]) 3 >>> count_subarrays_divisible_by_p(3, 5, 2, [1, 2, 3]) 0 >>> count_subarrays_divisible_by_p(5, 1, 3, [3, 6, 9, 12, 15]) 5 >>> count_subarrays_divisible_by_p(6, 2, 3, [3, -3, 6, -6, 9, -9]) 5","solution":"def count_subarrays_divisible_by_p(n, k, p, arr): Counts the number of subarrays of length k where the sum of elements is divisible by p. Args: n (int): The length of the array. k (int): The length of the subarrays to be considered. p (int): The divisor. arr (list): The list of integers. Returns: int: The number of subarrays where the sum is divisible by p. if k > n: return 0 count = 0 current_sum = sum(arr[:k]) if current_sum % p == 0: count += 1 for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum % p == 0: count += 1 return count"},{"question":"def rearrange_string(s: str) -> str: Rearrange the string such that no two adjacent characters are the same. If such an arrangement is possible, return any valid rearrangement. If not, return \\"Not possible\\". >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaab\\") == \\"Not possible\\" True >>> result = rearrange_string(\\"abcabc\\") >>> result != \\"Not possible\\" True >>> all(result[i] != result[i+1] for i in range(len(result) - 1)) True","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s: str) -> str: # Count the occurrences of each character counter = Counter(s) max_heap = [] # Add all characters to the max heap (negative count for max heap in python) for char, freq in counter.items(): heappush(max_heap, (-freq, char)) result = [] prev_count, prev_char = 0, '' # Greedily select the most frequent character that is not the same as the previous one while max_heap: count, char = heappop(max_heap) result.append(char) if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) prev_count = count + 1 prev_char = char rearranged = ''.join(result) return rearranged if len(rearranged) == len(s) else \\"Not possible\\""},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Return the minimum number of operations needed to make the string s of length n a palindrome. Parameters: n (int): The length of the string. s (str): The string consisting of lowercase English letters. Returns: int: The minimum number of operations required. >>> min_operations_to_palindrome(5, \\"ababa\\") 0 >>> min_operations_to_palindrome(4, \\"abba\\") 0 >>> min_operations_to_palindrome(4, \\"abca\\") 1 >>> min_operations_to_palindrome(6, \\"abcdef\\") 3 >>> min_operations_to_palindrome(1, \\"a\\") 0 >>> min_operations_to_palindrome(8, \\"aabbccdd\\") 4","solution":"def min_operations_to_palindrome(n, s): Returns the minimum number of operations needed to make string s of length n a palindrome. # Count mismatches in the first half vs the second half of the string count_mismatches = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: count_mismatches += 1 return count_mismatches"},{"question":"def is_path_from_first_to_last_server(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determines if there is a path from the first server to the last server in a data center. Args: - n (int): The number of servers. - m (int): The number of directed connections. - connections (List[Tuple[int, int]]): A list of directed connections between servers. Returns: - str: \\"YES\\" if there is a path from the first server to the last server, \\"NO\\" otherwise. >>> is_path_from_first_to_last_server(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"YES\\" >>> is_path_from_first_to_last_server(4, 2, [(1, 2), (3, 4)]) \\"NO\\"","solution":"def is_path_from_first_to_last_server(n, m, connections): from collections import defaultdict, deque graph = defaultdict(list) for u, v in connections: graph[u].append(v) def bfs(start, goal): queue = deque([start]) visited = set([start]) while queue: current = queue.popleft() if current == goal: return True for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False return \\"YES\\" if bfs(1, n) else \\"NO\\""},{"question":"def convert_to_base10(B: int, S: str) -> int: Converts a number from a fictional planet's base-B system to base-10. Parameters: B (int): The base of the given number (2 <= B <= 26). S (str): The string representation of the number in the base-B system. Returns: int: The base-10 equivalent of the number. from solution import convert_to_base10 def test_base_2(): assert convert_to_base10(2, 'BA') == 2 assert convert_to_base10(2, 'BB') == 1 * 2 + 1 def test_base_3(): assert convert_to_base10(3, 'BA') == 1 * 3 + 0 assert convert_to_base10(3, 'BB') == 1 * 3 + 1 assert convert_to_base10(3, 'CAA') == 2 * 9 + 0 * 3 + 0 def test_base_4(): assert convert_to_base10(4, 'CAD') == 2 * 16 + 0 * 4 + 3 assert convert_to_base10(4, 'DAC') == 3 * 16 + 0 * 4 + 2 def test_base_5(): assert convert_to_base10(5, 'BAB') == 1 * 25 + 0 * 5 + 1 assert convert_to_base10(5, 'EDC') == 4 * 25 + 3 * 5 + 2 def test_base_26(): assert convert_to_base10(26, 'AA') == 0 * 26 + 0 assert convert_to_base10(26, 'AZ') == 0 * 26 + 25 assert convert_to_base10(26, 'BA') == 1 * 26 + 0 assert convert_to_base10(26, 'ZZ') == 25 * 26 + 25","solution":"def convert_to_base10(B: int, S: str) -> int: Converts a number from a fictional planet's base-B system to base-10. Parameters: B (int): The base of the given number (2 <= B <= 26). S (str): The string representation of the number in the base-B system. Returns: int: The base-10 equivalent of the number. base10_value = 0 length = len(S) for i in range(length): digit_value = ord(S[i]) - ord('A') power = length - i - 1 base10_value += digit_value * (B ** power) return base10_value"},{"question":"def is_prime(num): Checks if a number is prime. pass def has_prime_sum_pair(a): Determines if there exists a pair of indices (i, j) such that the sum of a[i] and a[j] is a prime number. Args: a: List[int] - an array of integers Returns: str - \\"YES\\" if there exists such a pair, otherwise \\"NO\\" Examples: >>> has_prime_sum_pair([1, 4, 6, 3]) \\"YES\\" >>> has_prime_sum_pair([4, 6, 8, 10]) \\"NO\\" >>> has_prime_sum_pair([1, 2]) \\"YES\\" >>> has_prime_sum_pair([999983, 1000000, 17, 2]) \\"YES\\" >>> has_prime_sum_pair([]) \\"NO\\"","solution":"def is_prime(num): Checks if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def has_prime_sum_pair(a): Determines if there exists a pair of indices (i, j) such that the sum of a[i] and a[j] is a prime number. n = len(a) for i in range(n): for j in range(i + 1, n): if is_prime(a[i] + a[j]): return \\"YES\\" return \\"NO\\""},{"question":"def count_distinct_substrings(S: str, k: int) -> int: Returns the number of distinct substrings of length k that contain exactly k distinct characters. Args: S (str): The input string. k (int): The length of substrings to consider. Returns: int: The count of distinct substrings of length k with exactly k distinct characters. >>> count_distinct_substrings(\\"abcabc\\", 3) 3 >>> count_distinct_substrings(\\"aaaaa\\", 1) 1 >>> count_distinct_substrings(\\"abcd\\", 4) 1 >>> count_distinct_substrings(\\"abc\\", 5) 0 >>> count_distinct_substrings(\\"aAAbBb\\", 2) 4 >>> count_distinct_substrings(\\"aaa\\", 2) 0","solution":"def count_distinct_substrings(S, k): Returns the number of distinct substrings of length k that contain exactly k distinct characters. Args: S (str): The input string. k (int): The length of substrings to consider. Returns: int: The count of distinct substrings of length k with exactly k distinct characters. if k > len(S): return 0 found_substrings = set() for i in range(len(S) - k + 1): substring = S[i:i+k] if len(set(substring)) == k: found_substrings.add(substring) return len(found_substrings)"},{"question":"def find_pairs_with_difference(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: You are given an array of integers and a value k. Check if there is a pair of distinct indices i and j in the array such that the absolute difference between the elements at these indices is equal to k. Args: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list containing tuples, each with a tuple (n, k) and the array. Returns: List[str]: A list containing \\"YES\\" if such a pair exists for each test case, otherwise \\"NO\\". Example: >>> find_pairs_with_difference(2, [((5, 3), [1, 5, 3, 4, 2]), ((4, 1), [1, 2, 3, 4])]) [\\"YES\\", \\"YES\\"]","solution":"def find_pairs_with_difference(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] found_pair = False elements_set = set() for number in arr: if (number + k) in elements_set or (number - k) in elements_set: found_pair = True break elements_set.add(number) if found_pair: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def partition_times(n: int, k: int, times: List[int]) -> List[List[int]]: Partitions the list of finishing times into k percentile groups. Parameters: n (int): The number of participants k (int): The number of percentile groups times (list): List of finishing times (integers) Returns: list of list: The k groups of finishing times, each list sorted individually Example: >>> partition_times(10, 2, [600, 470, 170, 430, 300, 410, 750, 420, 180, 460]) [[170, 180, 300, 410, 420], [430, 460, 470, 600, 750]]","solution":"def partition_times(n, k, times): Partitions the list of finishing times into k percentile groups. Parameters: n (int) : The number of participants k (int) : The number of percentile groups times (list) : List of finishing times (integers) Returns: list of list : The k groups of finishing times, each list sorted individually sorted_times = sorted(times) result = [] base_group_size = n // k extra = n % k start = 0 for i in range(k): if i < extra: end = start + base_group_size + 1 else: end = start + base_group_size result.append(sorted_times[start:end]) start = end return result"},{"question":"def longest_palindrome_length(s: str) -> int: Given a string consisting of lowercase English letters, determine the length of the longest palindrome that can be built with those letters. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"abcdef\\") 1 >>> longest_palindrome_length(\\"aabbcc\\") 6 >>> longest_palindrome_length(\\"aaabbbbccddd\\") 11 >>> longest_palindrome_length(\\"aaabbb\\") 5 >>> longest_palindrome_length(\\"\\") 0","solution":"def longest_palindrome_length(s): Determine the length of the longest palindrome that can be built with the given string. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True # Add one if there's at least one odd count, which can be placed in the middle if odd_found: length += 1 return length"},{"question":"def max_trees_to_cut(heights: List[int]) -> int: Determines the maximum number of trees that can be cut down such that the remaining tree heights form a non-decreasing sequence. >>> max_trees_to_cut([3, 7, 5, 8, 10, 5, 13]) == 2 >>> max_trees_to_cut([5, 4, 3, 2, 1]) == 4 >>> max_trees_to_cut([1, 2, 3, 4, 5]) == 0 >>> max_trees_to_cut([1]) == 0 >>> max_trees_to_cut([1, 2]) == 0 >>> max_trees_to_cut([2, 1]) == 1 >>> max_trees_to_cut([3, 1, 2, 1, 3]) == 2","solution":"def max_trees_to_cut(heights): Determines the maximum number of trees that can be cut down such that the remaining tree heights form a non-decreasing sequence. n = len(heights) # If only one tree or already sorted, no need to cut any tree if n <= 1 or all(heights[i] <= heights[i+1] for i in range(n-1)): return 0 # LIS lis = [] for h in heights: pos = binary_search(lis, h) if pos < len(lis): lis[pos] = h else: lis.append(h) # Minimum cuts needed to form non-decreasing sequence return n - len(lis) def binary_search(lis, h): left, right = 0, len(lis) - 1 while left <= right: mid = (left + right) // 2 if lis[mid] < h: left = mid + 1 else: right = mid - 1 return left"},{"question":"def longest_consistent_span(N: int, A: List[int], B: List[int], C: List[int]) -> int: Determine the longest span of consecutive days where the relative order of stock prices between any two companies remains the same. >>> longest_consistent_span(5, [5, 6, 7, 1, 4], [2, 3, 5, 1, 2], [4, 5, 6, 2, 3]) 3 >>> longest_consistent_span(3, [3, 3, 3], [3, 3, 3], [3, 3, 3]) 3 >>> longest_consistent_span(3, [1, 2, 3], [3, 2, 1], [2, 1, 3]) 1 >>> longest_consistent_span(6, [4, 3, 2, 6, 5, 4], [1, 1, 1, 1, 1, 1], [3, 2, 1, 5, 4, 3]) 3 >>> longest_consistent_span(1, [4], [3], [2]) 1","solution":"def longest_consistent_span(N, A, B, C): def get_relations(x, y): if x > y: return '>' elif x < y: return '<' else: return '=' def get_pattern(i): return (get_relations(A[i], B[i]), get_relations(B[i], C[i]), get_relations(A[i], C[i])) max_span = 1 current_span = 1 for i in range(1, N): if get_pattern(i) == get_pattern(i - 1): current_span += 1 max_span = max(max_span, current_span) else: current_span = 1 return max_span"},{"question":"def max_team_power(n: int, m: int, power_levels: List[int], categories: List[int]) -> int: Calculate the maximum possible sum of power levels for a team that can be formed without any two creatures from the same category. Args: n : int : Number of cards. m : int : Number of different categories. power_levels : List[int] : List of power levels of each creature. categories : List[int] : List of categories of each creature. Returns: int : The maximum possible sum of power levels for the team. >>> max_team_power(5, 3, [10, 20, 30, 40, 50], [1, 2, 3, 1, 2]) 120 >>> max_team_power(4, 2, [5, 5, 5, 5], [1, 1, 2, 2]) 10","solution":"def max_team_power(n, m, power_levels, categories): Calculate the maximum possible sum of power levels for a team that can be formed without any two creatures from the same category. Args: n : int : Number of cards. m : int : Number of different categories. power_levels : List[int] : List of power levels of each creature. categories : List[int] : List of categories of each creature. Returns: int : The maximum possible sum of power levels for the team. category_to_max_power = {} for i in range(n): category = categories[i] power_level = power_levels[i] if category not in category_to_max_power: category_to_max_power[category] = power_level else: category_to_max_power[category] = max(category_to_max_power[category], power_level) return sum(category_to_max_power.values())"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> str: Determines whether there are two distinct indices i and j in the array such that their sum is equal to the target integer. :param arr: List[int] - The array of integers. :param target: int - The target integer. :return: str - \\"YES\\" if such indices exist, otherwise \\"NO\\". >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) == \\"YES\\" >>> has_pair_with_sum([5, 1, 3, 4, 2], 6) == \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 1], 8) == \\"NO\\" >>> has_pair_with_sum([10**9, -10**9, 0], 0) == \\"YES\\" >>> has_pair_with_sum([1, 2, 3, -4, 5], -1) == \\"YES\\" >>> has_pair_with_sum([1], 2) == \\"NO\\" >>> has_pair_with_sum([], 1) == \\"NO\\"","solution":"def has_pair_with_sum(arr, target): Determines whether there are two distinct indices i and j in the array such that their sum is equal to the target integer. :param arr: List[int] - The array of integers. :param target: int - The target integer. :return: str - \\"YES\\" if such indices exist, otherwise \\"NO\\". seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def shift_primes_to_end(arr: list) -> list: Shifts all prime numbers to the end of the list while preserving the order of the non-prime and prime numbers among themselves. Parameters: arr (list): A list of integers. Returns: list: A new list with all prime numbers at the end. Examples: >>> shift_primes_to_end([7, 6, 5, 4, 3, 2]) [6, 4, 7, 5, 3, 2] >>> shift_primes_to_end([2, 3, 5, 8, 11, 13, 17, 19, 7, 4]) [8, 4, 2, 3, 5, 11, 13, 17, 19, 7] >>> shift_primes_to_end([4, 6, 8, 9, 10]) [4, 6, 8, 9, 10] >>> shift_primes_to_end([2, 3, 5, 7, 11]) [2, 3, 5, 7, 11] >>> shift_primes_to_end([1, 2, 3, 4, 5, 6]) [1, 4, 6, 2, 3, 5] >>> shift_primes_to_end([]) [] >>> shift_primes_to_end([999983, 1000000, 1000001, 1000003]) [1000000, 1000001, 999983, 1000003]","solution":"from math import isqrt def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False for i in range(5, isqrt(n) + 1, 6): if n % i == 0 or n % (i + 2) == 0: return False return True def shift_primes_to_end(arr): Shifts all prime numbers to the end of the list while preserving the order of the non-prime and prime numbers among themselves. non_primes = [x for x in arr if not is_prime(x)] primes = [x for x in arr if is_prime(x)] return non_primes + primes"},{"question":"def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_LIS([]) == 0 >>> length_of_LIS([1, 2, 3, 4, 5]) == 5 >>> length_of_LIS([5, 4, 3, 2, 1]) == 1 >>> length_of_LIS([3, 10, 2, 1, 20]) == 3 >>> length_of_LIS([3, 2]) == 1 >>> length_of_LIS([50, 3, 10, 7, 40, 80]) == 4","solution":"def length_of_LIS(nums): Returns the length of the longest increasing subsequence in the array. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_single_number(arr: List[int]) -> int: Returns the single integer that appears only once in the array. Every other integer appears exactly twice. >>> find_single_number([1, 2, 3, 2, 1]) == 3 >>> find_single_number([1000000000, 1, 1000000000, 1, 999999999]) == 999999999 >>> find_single_number([1,1,2, 2,3, 3,4,4,5]) == 5 >>> find_single_number([10]) == 10 >>> find_single_number([10, 20, 10, 30, 20, -10, -10]) == 30","solution":"def find_single_number(arr): Returns the single integer that appears only once in the array. Every other integer appears exactly twice. result = 0 for num in arr: result ^= num return result # Example usage: # n = 2 # arr = [1, 2, 3, 2, 1] # print(find_single_number(arr)) # Output should be 3"},{"question":"def final_positions(n: int, positions: List[int], m: int, commands: List[str]) -> List[int]: Determine the final positions of soldiers after executing a list of commands. Each soldier has a unique initial position and the commands specify positions of soldiers that should move forward, backward, or leave their position. Parameters: n (int): Number of soldiers. positions (List[int]): Initial positions of the soldiers. m (int): Number of commands. commands (List[str]): List of commands in the format \\"F x\\", \\"B x\\", or \\"L x\\". Returns: List[int]: Final positions of all remaining soldiers in increasing order. >>> final_positions(5, [2, 4, 6, 8, 10], 4, [\\"F 4\\", \\"B 6\\", \\"L 8\\", \\"F 2\\"]) [3, 5, 6, 10] >>> final_positions(3, [1, 3, 5], 0, []) [1, 3, 5] >>> final_positions(3, [1, 3, 5], 3, [\\"F 1\\", \\"F 3\\", \\"F 5\\"]) [2, 4, 6] >>> final_positions(3, [2, 3, 5], 3, [\\"B 2\\", \\"B 3\\", \\"B 5\\"]) [1, 2, 4] >>> final_positions(3, [1, 3, 5], 3, [\\"L 1\\", \\"L 3\\", \\"L 5\\"]) [] >>> final_positions(3, [2, 3, 5], 3, [\\"F 2\\", \\"B 3\\", \\"L 4\\"]) [2, 3, 5] >>> final_positions(4, [1, 2, 3, 4], 4, [\\"F 1\\", \\"F 2\\", \\"F 3\\", \\"F 4\\"]) [1, 2, 3, 5]","solution":"def final_positions(n, positions, m, commands): current_positions = set(positions) leaving_positions = set() for command in commands: cmd, x = command[0], int(command[1:]) if cmd == \\"F\\": if (x in current_positions) and ((x + 1) not in current_positions): current_positions.remove(x) current_positions.add(x + 1) elif cmd == \\"B\\": if (x in current_positions) and ((x - 1) > 0) and ((x - 1) not in current_positions): current_positions.remove(x) current_positions.add(x - 1) elif cmd == \\"L\\": if x in current_positions: current_positions.remove(x) return sorted(current_positions)"},{"question":"from typing import List def count_combinations(badges: List[int], S: int) -> int: Determines the number of distinct combinations of badge values that sum up to exactly S. Args: badges (list): List of positive integers representing the badge values. S (int): The target sum. Returns: int: The number of combinations that add up to exactly S. Examples: >>> count_combinations([1, 2, 3, 4, 5], 5) 3 >>> count_combinations([2, 3, 5, 7], 8) 1 >>> count_combinations([2, 4, 6], 5) 0 >>> count_combinations([], 10) 0 >>> count_combinations([1, 2, 3], 10) 0 >>> count_combinations([1, 1, 1, 1], 2) 6 >>> count_combinations([5], 5) 1 >>> count_combinations([5, 5, 5], 10) 3","solution":"from itertools import combinations def count_combinations(badges, S): Determines the number of distinct combinations of badge values that sum up to exactly S. Args: badges (list): List of positive integers representing the badge values. S (int): The target sum. Returns: int: The number of combinations that add up to exactly S. count = 0 for r in range(1, len(badges) + 1): for comb in combinations(badges, r): if sum(comb) == S: count += 1 return count"},{"question":"def can_place_boxes_on_shelves(shelf_heights: List[int], box_heights: List[int]) -> str: Determines if it is possible to place all boxes on the shelves given their capacities. :param shelf_heights: List[int] - List of shelf height capacities :param box_heights: List[int] - List of box heights :return: str - \\"YES\\" if possible, otherwise \\"NO\\" >>> can_place_boxes_on_shelves([3, 8, 5, 7], [2, 5, 3, 4, 6]) 'YES' >>> can_place_boxes_on_shelves([5, 4, 6], [7, 3, 2, 4, 1, 5]) 'NO' >>> can_place_boxes_on_shelves([10], [3, 3, 3]) 'YES' >>> can_place_boxes_on_shelves([5, 5, 5], [6]) 'NO' >>> can_place_boxes_on_shelves([3, 15], [3, 5, 5, 2]) 'YES'","solution":"def can_place_boxes_on_shelves(shelf_heights, box_heights): Determines if it is possible to place all boxes on the shelves given their capacities. :param shelf_heights: List[int] - List of shelf height capacities :param box_heights: List[int] - List of box heights :return: str - \\"YES\\" if possible, otherwise \\"NO\\" current_shelf_index = 0 current_shelf_capacity = shelf_heights[current_shelf_index] for box_height in box_heights: while box_height > current_shelf_capacity: current_shelf_index += 1 if current_shelf_index >= len(shelf_heights): return \\"NO\\" current_shelf_capacity = shelf_heights[current_shelf_index] current_shelf_capacity -= box_height return \\"YES\\""},{"question":"from typing import List, Tuple def distance_from_fountain(n: int, roads: List[Tuple[int, int]], m: int, fountains: List[int]) -> List[int]: Determines the distance of each city from the nearest fountain. Args: n (int): The number of cities. roads (List[Tuple[int, int]]): Roads connecting the cities. m (int): The number of cities with fountains. fountains (List[int]): The indices of the cities that have fountains. Returns: List[int]: A list where the i-th element represents the distance of the i-th city from the nearest fountain. Example: >>> distance_from_fountain(5, [(1, 2), (1, 3), (2, 4), (2, 5)], 2, [2, 3]) [1, 0, 0, 1, 1] >>> distance_from_fountain(4, [(1, 2), (2, 3), (3, 4)], 1, [1]) [0, 1, 2, 3] >>> distance_from_fountain(6, [(1, 2), (1, 3), (2, 4), (4, 5), (5, 6)], 1, [6]) [4, 3, 5, 2, 1, 0] >>> distance_from_fountain(3, [(1, 2), (2, 3)], 2, [1, 3]) [0, 1, 0] >>> distance_from_fountain(2, [(1, 2)], 1, [1]) [0, 1]","solution":"from collections import deque, defaultdict def distance_from_fountain(n, roads, m, fountains): # Create adjacency list for the graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Initiate distances with -1 (unvisited) distances = [-1] * n queue = deque() # Start BFS from all fountains for fountain in fountains: queue.append(fountain) distances[fountain - 1] = 0 while queue: city = queue.popleft() current_distance = distances[city - 1] for neighbor in graph[city]: if distances[neighbor - 1] == -1: # If not visited yet distances[neighbor - 1] = current_distance + 1 queue.append(neighbor) return distances"},{"question":"def min_group_memberships(n: int, user_ids: List[int]) -> int: Determine minimum number of distinct group IDs required for all users to have at least one group membership. Args: - n (int): Number of users. - user_ids (list of int): List of user IDs. Returns: - int: Minimum number of distinct group IDs. >>> min_group_memberships(1, [1]) 1 >>> min_group_memberships(5, [1, 2, 3, 4, 5]) 1 >>> min_group_memberships(3, [1001, 2002, 3003]) 1 >>> min_group_memberships(0, []) 1 >>> min_group_memberships(4, [1, 1, 1, 1]) 1","solution":"def min_group_memberships(n, user_ids): Determine minimum number of distinct group IDs required for all users to have at least one group membership. Args: - n (int): Number of users. - user_ids (list of int): List of user IDs. Returns: - int: Minimum number of distinct group IDs. # Since all users need at least one group membership, we can simply assign one group to all users. # Hence, the minimum number of distinct group IDs required is 1. return 1"},{"question":"def min_trips(W: int, N: int, weights: List[int]) -> int: Returns the minimum number of trips required to transport all containers. :param W: Maximum weight capacity of the truck :param N: Number of containers :param weights: List of weights of the containers :return: Minimum number of trips required pass # Unit tests def test_min_trips_example(): assert min_trips(50, 5, [10, 20, 30, 40, 50]) == 3 def test_min_trips_single_container(): assert min_trips(50, 1, [30]) == 1 def test_min_trips_max_capacity(): assert min_trips(50, 5, [50, 50, 50, 50, 50]) == 5 def test_min_trips_all_fit_in_one_trip(): assert min_trips(100, 3, [20, 30, 40]) == 2 def test_min_trips_various_weights(): assert min_trips(60, 6, [10, 20, 25, 30, 50, 55]) == 4","solution":"def min_trips(W, N, weights): Returns the minimum number of trips required to transport all containers. :param W: Maximum weight capacity of the truck :param N: Number of containers :param weights: List of weights of the containers :return: Minimum number of trips required weights.sort() left, right = 0, N - 1 trips = 0 while left <= right: if weights[left] + weights[right] <= W: left += 1 right -= 1 trips += 1 return trips"},{"question":"def is_beautiful_string(n: int, s: str) -> str: Determine whether a string of length n can be rearranged to form a beautiful string. A beautiful string contains only vowels and no two vowels are consecutive. The input consists of a single integer n followed by a string of length n. Args: n (int): The length of the string. s (str): The string to be checked. Returns: str: \\"YES\\" if it is possible to rearrange the string to be beautiful, otherwise \\"NO\\". >>> is_beautiful_string(5, 'aeiou') \\"NO\\" >>> is_beautiful_string(5, 'abcde') \\"YES\\" from solution import is_beautiful_string def test_beautiful_string_sample_1(): assert is_beautiful_string(5, 'aeiou') == \\"NO\\" def test_beautiful_string_sample_2(): assert is_beautiful_string(5, 'abcde') == \\"YES\\" def test_beautiful_string_single_vowel(): assert is_beautiful_string(1, 'a') == \\"YES\\" def test_beautiful_string_no_vowels(): assert is_beautiful_string(5, 'bcdfg') == \\"YES\\" def test_beautiful_string_equal_vowels_and_consonants(): assert is_beautiful_string(4, 'aebc') == \\"YES\\" def test_beautiful_string_vowel_more_than_half(): assert is_beautiful_string(6, 'aaeiop') == \\"NO\\" def test_beautiful_string_long_mixed_characters(): assert is_beautiful_string(10, 'abcdefghia') == \\"YES\\"","solution":"def is_beautiful_string(n, s): vowels = set('aeiou') vowel_count = sum(1 for char in s if char in vowels) consonant_count = n - vowel_count # If the number of vowels is more than half plus one of the string length, it's impossible to avoid consecutive vowels if vowel_count > (n // 2 + 1): return \\"NO\\" else: return \\"YES\\""},{"question":"from typing import List def island_perimeter(grid: List[List[int]]) -> int: Calculate the perimeter of the island in the given grid. Parameters: grid (List[List[int]]): 2D binary matrix where 1 represents land and 0 represents water. Returns: int: The perimeter of the island. >>> island_perimeter([[0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0]]) == 16 >>> island_perimeter([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) == 0 >>> island_perimeter([[1, 1], [1, 1]]) == 8 >>> island_perimeter([[0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]) == 4 >>> island_perimeter([[0, 1, 0], [1, 1, 1], [0, 1, 0]]) == 12","solution":"def island_perimeter(grid): Calculate the perimeter of the island in the given grid. Parameters: grid (List[List[int]]): 2D binary matrix where 1 represents land and 0 represents water. Returns: int: The perimeter of the island. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) perimeter = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: perimeter += 4 if i > 0 and grid[i-1][j] == 1: # Check upper cell perimeter -= 2 if j > 0 and grid[i][j-1] == 1: # Check left cell perimeter -= 2 return perimeter"},{"question":"from typing import List, Tuple def min_moves_to_uniform_string(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of moves required to make all characters of the string the same for given test cases. >>> min_moves_to_uniform_string(3, [(4, \\"aabc\\"), (5, \\"abcde\\"), (6, \\"aaaaaa\\")]) [2, 4, 0] >>> min_moves_to_uniform_string(2, [(3, \\"aaa\\"), (4, \\"abcd\\")]) [0, 3] >>> min_moves_to_uniform_string(1, [(10, \\"abacabadab\\")]) [5] >>> min_moves_to_uniform_string(1, [(1, \\"z\\")]) [0] >>> min_moves_to_uniform_string(4, [(2, \\"aa\\"), (3, \\"bbb\\"), (4, \\"cccc\\"), (5, \\"ddddd\\")]) [0, 0, 0, 0]","solution":"def min_moves_to_uniform_string(t, test_cases): results = [] for test_case in test_cases: n, s = test_case char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 max_frequency = max(char_count.values()) min_moves = n - max_frequency results.append(min_moves) return results"},{"question":"def tallest_tower(n: int, heights: List[int]) -> int: Determines the maximum height of the tallest tower Kira can build using the given rules. Args: n : int : Number of blocks (1 ≤ n ≤ 10^5) heights : list of int : Heights of the blocks (1 ≤ hi ≤ 10^9) Returns: int : Height of the tallest tower. >>> tallest_tower(5, [1, 3, 2, 4, 3]) 4 >>> tallest_tower(6, [6, 5, 4, 3, 2, 1]) 6","solution":"def tallest_tower(n, heights): Determines the maximum height of the tallest tower Kira can build using the given rules. Args: n : int : Number of blocks (1 ≤ n ≤ 10^5) heights : list of int : Heights of the blocks (1 ≤ hi ≤ 10^9) Returns: int : Height of the tallest tower. # Sort the heights in non-decreasing order heights.sort() # Maximum height of the tower is the tallest block return heights[-1]"},{"question":"from typing import List def min_abs_diff_between_two_halves(n: int, arr: List[int]) -> int: Find two new lists from the given list such that both lists contain exactly one element more than half the total number of integers in the original list, and the sum of integers in both lists are as close as possible. Return the absolute difference between the sums of the two new lists. Args: n (int): The number of elements in the original list. arr (List[int]): The list of integers. Returns: int: The absolute difference between the sums of the two new lists. Examples: >>> min_abs_diff_between_two_halves(6, [3, 1, 4, 2, 2, 2]) 0 >>> min_abs_diff_between_two_halves(4, [1, 1, 1, 1]) 0 >>> min_abs_diff_between_two_halves(5, [1, -1, 2, -2, 3]) 1 from solution import min_abs_diff_between_two_halves def test_example_case(): assert min_abs_diff_between_two_halves(6, [3, 1, 4, 2, 2, 2]) == 0 def test_all_same_elements(): assert min_abs_diff_between_two_halves(4, [1, 1, 1, 1]) == 0 def test_large_positive_numbers(): assert min_abs_diff_between_two_halves(4, [10000, 10000, 10000, 10000]) == 0 def test_mixed_sign_elements(): assert min_abs_diff_between_two_halves(5, [1, -1, 2, -2, 3]) == 1 def test_small_case(): assert min_abs_diff_between_two_halves(1, [100]) == 100 assert min_abs_diff_between_two_halves(2, [100, -50]) == 150 def test_general_case(): assert min_abs_diff_between_two_halves(7, [3, 1, 4, 1, 5, 9, 2]) == 1","solution":"def min_abs_diff_between_two_halves(n, arr): from itertools import combinations # Calculate the size of each of the two new lists half_size = (n + 1) // 2 min_diff = float('inf') # Explore all combinations of indices of length half_size for indices in combinations(range(n), half_size): list1 = [arr[idx] for idx in indices] list2 = [arr[idx] for idx in range(n) if idx not in indices] sum1 = sum(list1) sum2 = sum(list2) diff = abs(sum1 - sum2) if diff < min_diff: min_diff = diff return min_diff"},{"question":"from typing import List def largest_plant_region(garden: List[List[str]]) -> int: Find the largest rectangular region (by area) in the garden that contains only plants. >>> largest_plant_region([['P', 'P', 'O', 'P', 'P'], ['P', 'P', 'P', 'P', 'P'], ['P', 'O', 'P', 'P', 'P'], ['P', 'P', 'P', 'O', 'P']]) 6 >>> largest_plant_region([['P']]) 1 >>> largest_plant_region([['P', 'O'], ['O', 'P']]) 1 from typing import List def max_histogram_area(heights: List[int]) -> int: Calculate the maximal rectangle area in a histogram representation of row heights. pass # This is intentionally left as an exercise for the user. # Unit tests def test_largest_plant_region(): assert largest_plant_region([]) == 0 assert largest_plant_region([['P']]) == 1 assert largest_plant_region([['P', 'P'], ['P', 'P']]) == 4 assert largest_plant_region([['P', 'O'], ['O', 'P']]) == 1 assert largest_plant_region([['P', 'P', 'O', 'P', 'P'], ['P', 'P', 'P', 'P', 'P'], ['P', 'O', 'P', 'P', 'P'], ['P', 'P', 'P', 'O', 'P']]) == 6","solution":"def largest_plant_region(garden): if not garden: return 0 max_area = 0 rows = len(garden) cols = len(garden[0]) heights = [0] * cols for r in range(rows): for c in range(cols): if garden[r][c] == 'P': heights[c] += 1 else: heights[c] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() if not stack: area = heights[top_of_stack] * index else: area = heights[top_of_stack] * (index - stack[-1] - 1) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() if not stack: area = heights[top_of_stack] * index else: area = heights[top_of_stack] * (index - stack[-1] - 1) max_area = max(max_area, area) return max_area"},{"question":"def generate_anagram(n: int, s: str) -> str: Given a string 's' of length 'n', generate another string 't' of the same length such that: - 's' and 't' are anagrams of each other, - 't' does not contain any substring which is also a substring in 's'. If it is impossible to create such a string, return \\"-1\\". >>> generate_anagram(1, \\"a\\") == \\"-1\\" >>> generate_anagram(2, \\"aa\\") == \\"-1\\" >>> generate_anagram(2, \\"ab\\") in [\\"ba\\"] >>> sorted(generate_anagram(3, \\"abc\\")) == sorted(\\"abc\\") and generate_anagram(3, \\"abc\\") != \\"abc\\" >>> sorted(generate_anagram(4, \\"abcd\\")) == sorted(\\"abcd\\") and generate_anagram(4, \\"abcd\\") != \\"abcd\\" >>> sorted(generate_anagram(5, \\"aabcd\\")) == sorted(\\"aabcd\\") and generate_anagram(5, \\"aabcd\\") != \\"aabcd\\"","solution":"def generate_anagram(n, s): Generate a string t of length n such that t is an anagram of s, and there're no matching substrings between s and t. from collections import Counter # Check for basic sanity if n == 1: return \\"-1\\" # Count characters in s s_count = Counter(s) # Create a sorted list of characters from s sorted_chars = sorted(s) # Create t by shifting characters in sorted order t = list(sorted_chars) t = t[1:] + t[:1] for i in range(n - 1): if s[i] == ''.join(t[i:i + (n - 1)]): return \\"-1\\" return ''.join(t)"},{"question":"def process_queries(m: int, sequence: List[int], queries: List[Tuple[int, int, Optional[int]]]) -> List[int]: You are given an integer sequence b1, b2, ....., bm and a sequence of queries. There are two types of queries: 1. Update the value at a specific index in the sequence. 2. Find the minimum value in a specific subarray. Args: - m: an integer representing the size of the sequence. - sequence: a list of m integers. - queries: a list of tuples, where each tuple represents a query. Returns: - A list of results for each type 2 query. Example: >>> process_queries(5, [1, 5, 3, 2, 4], [(2, 2, 4), (1, 3, 10), (2, 2, 4), (2, 1, 5)]) [2, 2, 1] def test_process_queries(): m = 5 sequence = [1, 5, 3, 2, 4] queries = [ (2, 2, 4), (1, 3, 10), (2, 2, 4), (2, 1, 5) ] expected_output = [2, 2, 1] assert process_queries(m, sequence, queries) == expected_output def test_single_update_and_query(): m = 6 sequence = [7, 3, 1, 8, 6, 4] queries = [ (2, 1, 3), (1, 2, 0), (2, 1, 3) ] expected_output = [1, 0] assert process_queries(m, sequence, queries) == expected_output def test_all_updates(): m = 4 sequence = [4, 4, 4, 4] queries = [ (1, 1, 1), (1, 2, 2), (1, 3, 3), (1, 4, 4), (2, 1, 4) ] expected_output = [1] assert process_queries(m, sequence, queries) == expected_output def test_subarray_query(): m = 6 sequence = [1, 4, 7, 8, 9, 1] queries = [ (2, 1, 6), (2, 3, 5), (2, 3, 3), (2, 4, 6) ] expected_output = [1, 7, 7, 1] assert process_queries(m, sequence, queries) == expected_output if __name__ == \\"__main__\\": test_process_queries() test_single_update_and_query() test_all_updates() test_subarray_query() print(\\"All tests passed\\")","solution":"class SegmentTree: def __init__(self, array): self.n = len(array) self.tree = [0] * (2 * self.n) # Build the segment tree # Initialize leaves for i in range(self.n): self.tree[self.n + i] = array[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, idx, value): idx += self.n self.tree[idx] = value while idx > 1: idx //= 2 self.tree[idx] = min(self.tree[idx * 2], self.tree[idx * 2 + 1]) def query(self, l, r): res = float('inf') l += self.n r += self.n + 1 while l < r: if l % 2 == 1: res = min(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = min(res, self.tree[r]) l //= 2 r //= 2 return res def process_queries(m, sequence, queries): segment_tree = SegmentTree(sequence) results = [] for query in queries: if query[0] == 1: _, x, y = query segment_tree.update(x - 1, y) elif query[0] == 2: _, l, r = query results.append(segment_tree.query(l - 1, r - 1)) return results"},{"question":"def count_tallest_candles(candle_heights, n): Returns the count of the 'n' tallest unique candle heights. If there are fewer than 'n' unique heights, returns the count of all unique candle heights. :param candle_heights: List of integers representing the heights of candles. :param n: Integer indicating how many of the tallest unique candle heights to count. :return: Count of unique candle heights among the 'n' tallest ones. >>> count_tallest_candles([4, 4, 2, 1, 3, 3, 3, 4, 4, 1], 3) == 3 >>> count_tallest_candles([4, 4, 2, 1, 3, 3, 3, 4, 4, 1], 2) == 2 >>> count_tallest_candles([4, 4, 2, 1, 3, 3, 3, 4, 4, 1], 5) == 4 >>> count_tallest_candles([2, 2, 2], 1) == 1 >>> count_tallest_candles([1, 2, 3, 4], 4) == 4 >>> count_tallest_candles([1, 1, 1, 1], 2) == 1 >>> count_tallest_candles([5] * 10, 1) == 1","solution":"def count_tallest_candles(candle_heights, n): Returns the count of the 'n' tallest unique candle heights. If there are fewer than 'n' unique heights, returns the count of all unique candle heights. :param candle_heights: List of integers representing the heights of candles. :param n: Integer indicating how many of the tallest unique candle heights to count. :return: Count of unique candle heights among the 'n' tallest ones. # Get the unique heights of the candles unique_heights = list(set(candle_heights)) # Sort the unique heights in descending order unique_heights.sort(reverse=True) # Get the 'n' tallest heights tallest_n = unique_heights[:n] # Count how many times each of the tallest heights appear in the original list count = 0 for height in tallest_n: count += candle_heights.count(height) return len(tallest_n)"},{"question":"def identify_triangle(a: int, b: int, c: int) -> str: Determine if three given lengths can form a triangle and if so, classify the type of triangle. Parameters: a (int): length of the first side b (int): length of the second side c (int): length of the third side Returns: str: Description of the triangle or not a triangle >>> identify_triangle(3, 3, 3) \\"Equilateral\\" >>> identify_triangle(4, 4, 7) \\"Isosceles\\" >>> identify_triangle(5, 9, 12) \\"Scalene\\" >>> identify_triangle(1, 1, 3) \\"Not a triangle\\" def test_identify_triangle_equilateral(): assert identify_triangle(3, 3, 3) == \\"Equilateral\\" def test_identify_triangle_isosceles(): assert identify_triangle(4, 4, 7) == \\"Isosceles\\" assert identify_triangle(7, 4, 4) == \\"Isosceles\\" assert identify_triangle(4, 7, 4) == \\"Isosceles\\" def test_identify_triangle_scalene(): assert identify_triangle(5, 9, 12) == \\"Scalene\\" assert identify_triangle(7, 10, 12) == \\"Scalene\\" assert identify_triangle(2, 3, 4) == \\"Scalene\\" def test_identify_triangle_not_a_triangle(): assert identify_triangle(1, 1, 3) == \\"Not a triangle\\" assert identify_triangle(1, 2, 3) == \\"Not a triangle\\" assert identify_triangle(1, 10, 12) == \\"Not a triangle\\"","solution":"def identify_triangle(a, b, c): Determine if three given lengths can form a triangle and if so, classify the type of triangle. Parameters: a (int): length of the first side b (int): length of the second side c (int): length of the third side Returns: str: Description of the triangle or not a triangle # Check if the lengths can form a triangle using the triangle inequality theorem if a + b > c and a + c > b and b + c > a: if a == b == c: return \\"Equilateral\\" elif a == b or a == c or b == c: return \\"Isosceles\\" else: return \\"Scalene\\" else: return \\"Not a triangle\\""},{"question":"def subset_with_maximum_sum_divisible_by_k(n: int, k: int, arr: List[int]) -> List[int]: You are given a list of integers. Choose a subset of these integers such that the sum of the chosen subset is the maximum possible sum that is divisible by a given integer \`k\`. If there are multiple subsets with the same maximum sum, any of them can be chosen. If no such subset exists, return an empty set. >>> subset_with_maximum_sum_divisible_by_k(5, 3, [2, 3, 7, 1, 4]) [2, 7, 1, 4] >>> subset_with_maximum_sum_divisible_by_k(4, 5, [5, -10, 10, -5]) [5, -5] def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[List[int]]: Process multiple test cases for finding subset with maximum sum divisible by k. Example: >>> process_test_cases(2, [(5, 3, [2, 3, 7, 1, 4]), (4, 5, [5, -10, 10, -5])]) [[2, 7, 1, 4], [5, -5]]","solution":"def subset_with_maximum_sum_divisible_by_k(n, k, arr): # To store the subsets based on remainders when divided by k remainder_buckets = [[] for _ in range(k)] for num in arr: remainder_buckets[num % k].append(num) # We need to maximize the sum of elements divisible by k dp = [0] * k # This array will store the maximum sum for each remainder dp_subset = [[] for _ in range(k)] # This stores the corresponding subsets for i in range(k): for num in remainder_buckets[i]: new_sum = (dp[-i] + num) % k if dp[-i] + num > dp[new_sum]: dp[new_sum] = dp[-i] + num dp_subset[new_sum] = dp_subset[-i] + [num] return dp_subset[0] def process_test_cases(t, test_cases): results = [] for tc in test_cases: n, k, arr = tc result = subset_with_maximum_sum_divisible_by_k(n, k, arr) results.append(result) return results"},{"question":"def maximize_solved_problems(t: int, test_cases: List[Tuple[Tuple[int, int], str]]) -> List[int]: Compute the maximum number of problems you can solve by utilizing your pre-prepared solutions optimally. >>> maximize_solved_problems(1, [((6, 3), \\"SSUSSU\\")]) [6] >>> maximize_solved_problems(1, [((5, 1), \\"SUUUU\\")]) [2] >>> maximize_solved_problems(1, [((7, 4), \\"USSSUUU\\")]) [7] >>> maximize_solved_problems(1, [((5, 0), \\"UUUUU\\")]) [0] >>> maximize_solved_problems(1, [((0, 5), \\"\\")]) [0]","solution":"def maximize_solved_problems(t, test_cases): results = [] for i in range(t): m, d = test_cases[i][0] p = test_cases[i][1] # Count how many problems are initially solved solved_count = p.count('S') unsolved_count = m - solved_count # The maximum number of problems that can be fixed is the smaller of d and the total number of unsolved problems max_problems_fixed = min(d, unsolved_count) # The maximum number of problems that can be solved is the initial solved + max_problems_fixed max_solved = solved_count + max_problems_fixed results.append(max_solved) return results"},{"question":"def min_moves_to_make_increasing(n: int, sequence: List[int]) -> int: Function to find the minimum number of moves required to make the sequence strictly increasing. Parameters: n (int): Length of sequence. sequence (list of int): The sequence of integers. Returns: int: Minimum number of moves to make the sequence strictly increasing. >>> min_moves_to_make_increasing(6, [5, 3, 4, 8, 6, 7]) 2 >>> min_moves_to_make_increasing(5, [1, 2, 3, 4, 5]) 0 >>> min_moves_to_make_increasing(4, [4, 3, 2, 1]) 3 >>> min_moves_to_make_increasing(7, [10, 5, 2, 11, 15, 5, 6]) 4 >>> min_moves_to_make_increasing(1, [1]) 0 >>> min_moves_to_make_increasing(2, [1, 2]) 0 >>> min_moves_to_make_increasing(2, [2, 1]) 1","solution":"def min_moves_to_make_increasing(n, sequence): Function to find the minimum number of moves required to make the sequence strictly increasing. Parameters: n (int): Length of sequence. sequence (list of int): The sequence of integers. Returns: int: Minimum number of moves to make the sequence strictly increasing. # Create a dp array to store the length of the longest increasing subsequence ending at each index dp = [1] * n # Fill the dp array for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: dp[i] = max(dp[i], dp[j] + 1) # Length of the longest increasing subsequence lis_length = max(dp) # The result is the total number of elements minus the length of the longest increasing subsequence return n - lis_length # Input example to test the function # n = 6 # sequence = [5, 3, 4, 8, 6, 7] # print(min_moves_to_make_increasing(n, sequence)) # Output should be 2"},{"question":"def max_targets_in_line(n: int, target_coords: List[Tuple[int, int]]) -> int: Determine the maximum number of targets that can be aligned in a straight line parallel to one of the cardinal directions. >>> max_targets_in_line(5, [(1, 2), (2, 2), (3, 2), (4, 2), (5, 3)]) 4 >>> max_targets_in_line(3, [(1, 2), (1, 3), (1, 4)]) 3 >>> max_targets_in_line(4, [(1, 1), (2, 2), (3, 3), (4, 4)]) 1 >>> max_targets_in_line(6, [(1, 1), (1, 2), (1, 3), (2, 3), (3, 3), (4, 3)]) 4 >>> max_targets_in_line(5, [(1, 1), (1, 1), (1, 1), (1, 1), (1, 1)]) 5","solution":"def max_targets_in_line(n, target_coords): from collections import defaultdict vertical_lines = defaultdict(int) horizontal_lines = defaultdict(int) for x, y in target_coords: vertical_lines[x] += 1 horizontal_lines[y] += 1 max_vertical = max(vertical_lines.values()) max_horizontal = max(horizontal_lines.values()) return max(max_vertical, max_horizontal)"},{"question":"def max_pairs_mod_k(n: int, k: int, arr: List[int]) -> int: Returns the maximum number of pairs (i, j) such that i < j and the sum of the elements at positions i and j is a multiple of k. >>> max_pairs_mod_k(5, 3, [1, 2, 3, 4, 5]) 4 >>> max_pairs_mod_k(4, 2, [2, 4, 6, 8]) 6 >>> max_pairs_mod_k(3, 5, [10, 15, 20]) 3 pass","solution":"def max_pairs_mod_k(n, k, arr): Returns the maximum number of pairs (i, j) such that i < j and the sum of elements at positions i and j is a multiple of k. # Frequency array to count remainders remainder_count = [0] * k # Count the occurrences of each remainder when divided by k for num in arr: remainder_count[num % k] += 1 # Initialize pair count count = 0 # Pairs of numbers with remainder 0 (pairing within these numbers) count += remainder_count[0] * (remainder_count[0] - 1) // 2 # Iterate for remainders in range 1 to k//2 for r in range(1, (k // 2) + 1): if r == k - r: # Special case for exactly half of k count += remainder_count[r] * (remainder_count[r] - 1) // 2 else: count += remainder_count[r] * remainder_count[k - r] return count"},{"question":"def check_tournament_consistency(t: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determine if the tournament results are consistent for each test case. >>> check_tournament_consistency(1, [(3, [\\"DWL\\", \\"LDW\\", \\"WLD\\"])]) ['YES'] >>> check_tournament_consistency(1, [(3, [\\"DWL\\", \\"LDW\\", \\"WDW\\"])]) ['NO'] >>> check_tournament_consistency(1, [(2, [\\"DD\\", \\"DD\\"])]) ['YES'] >>> check_tournament_consistency(2, [(3, [\\"DWD\\", \\"WDL\\", \\"DLL\\"]), (3, [\\"DWL\\", \\"LDW\\", \\"WLD\\"])]) ['NO', 'YES'] >>> check_tournament_consistency(1, [(2, [\\"DL\\", \\"WD\\"])]) ['YES'] pass","solution":"def check_tournament_consistency(t, test_cases): results = [] for case in test_cases: n, matrix = case consistent = True for i in range(n): for j in range(n): if i != j: if matrix[i][j] == 'W' and matrix[j][i] != 'L': consistent = False elif matrix[i][j] == 'L' and matrix[j][i] != 'W': consistent = False elif matrix[i][j] == 'D' and matrix[j][i] != 'D': consistent = False if not consistent: break if not consistent: break results.append(\\"YES\\" if consistent else \\"NO\\") return results # Example usage: # t = 2 # test_cases = [ # (3, [ # \\"DWL\\", # \\"LDW\\", # \\"WLD\\" # ]), # (2, [ # \\"DW\\", # \\"WD\\" # ]) # ] # print(check_tournament_consistency(t, test_cases)) # # Output should be ['YES', 'YES']"},{"question":"def max_unique_paths(n: int, m: int, y: int, edges: List[Tuple[int,int]]) -> int: Output the maximum number of unique paths that Alex can pick from node 1 to node n. If no such path exists, output 0. >>> max_unique_paths(5, 6, 3, [(1, 2), (2, 3), (3, 5), (1, 4), (4, 5), (2, 4)]) 2 >>> max_unique_paths(5, 6, 0, [(1, 2), (2, 3), (3, 5), (1, 4), (4, 5), (2, 4)]) 0 >>> max_unique_paths(5, 6, 1, [(1, 2), (2, 3), (3, 5), (1, 4), (4, 5), (2, 4)]) 1","solution":"from collections import defaultdict, deque def bfs_find_path(capacity, source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: node = queue.popleft() for neighbor in capacity[node]: if neighbor not in visited and capacity[node][neighbor] > 0: queue.append(neighbor) visited.add(neighbor) parent[neighbor] = node if neighbor == sink: return True return False def ford_fulkerson(graph, source, sink): capacity = defaultdict(lambda: defaultdict(int)) for u in graph: for v in graph[u]: capacity[u][v] = 1 parent = {} max_flow = 0 while bfs_find_path(capacity, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def max_unique_paths(n, m, y, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) max_paths = ford_fulkerson(graph, 1, n) return min(max_paths, y) # Example usage: n, m, y = 5, 6, 3 edges = [(1, 2), (2, 3), (3, 5), (1, 4), (4, 5), (2, 4)] print(max_unique_paths(n, m, y, edges)) # Output: 2"},{"question":"from typing import List class Library: A class to manage a private library's collection of books and borrowing process for members. Implements the following functionalities: 1. Add a new book to the collection. 2. Remove a book from the collection (only if it is not currently borrowed). 3. Borrow a book (only if it is available). 4. Return a borrowed book. 5. List all books currently borrowed by a specific member. Methods: - def __init__(self): Initializes an empty library. - def add_book(self, book_id: int) -> None: Adds a book to the collection. - def remove_book(self, book_id: int) -> bool: Removes a book from the collection if it is not currently borrowed and returns \`True\`. If the book is borrowed or does not exist, returns \`False\`. - def borrow_book(self, book_id: int, member_id: int) -> bool: Allows a member to borrow a book if it is available and returns \`True\`. If the book is already borrowed or does not exist, returns \`False\`. - def return_book(self, book_id: int) -> bool: Returns a borrowed book and returns \`True\`. If the book was not borrowed, returns \`False\`. - def list_borrowed_books(self, member_id: int) -> List[int]: Returns a list of book IDs currently borrowed by the specified member. Example: >>> library = Library() >>> library.add_book(1) >>> library.add_book(2) >>> library.add_book(3) >>> library.borrow_book(1, 101) True >>> library.borrow_book(1, 102) False >>> library.return_book(1) True >>> library.remove_book(1) True >>> library.borrow_book(2, 101) >>> library.borrow_book(3, 102) >>> library.list_borrowed_books(101) [2] >>> library.list_borrowed_books(102) [3] def __init__(self): pass def add_book(self, book_id: int) -> None: pass def remove_book(self, book_id: int) -> bool: pass def borrow_book(self, book_id: int, member_id: int) -> bool: pass def return_book(self, book_id: int) -> bool: pass def list_borrowed_books(self, member_id: int) -> List[int]: pass","solution":"from typing import List class Library: def __init__(self): self.books = set() self.borrowed_books = {} def add_book(self, book_id: int) -> None: self.books.add(book_id) def remove_book(self, book_id: int) -> bool: if book_id in self.books and book_id not in self.borrowed_books: self.books.remove(book_id) return True return False def borrow_book(self, book_id: int, member_id: int) -> bool: if book_id in self.books and book_id not in self.borrowed_books: self.borrowed_books[book_id] = member_id return True return False def return_book(self, book_id: int) -> bool: if book_id in self.borrowed_books: del self.borrowed_books[book_id] return True return False def list_borrowed_books(self, member_id: int) -> List[int]: return [book_id for book_id, borrower_id in self.borrowed_books.items() if borrower_id == member_id]"},{"question":"def min_tents(n: int, a: List[int]) -> int: Determines the minimum number of tents needed to accommodate everyone based on each person's sharing tolerance. Parameters: n (int): Number of people. a (List[int]): List of tolerances for each person. Returns: int: The minimum number of tents needed. >>> min_tents(5, [1, 1, 2, 2, 3]) 3 >>> min_tents(1, [0]) 1 >>> min_tents(4, [2, 2, 2, 2]) 2 >>> min_tents(10, [1]*10) 5 >>> min_tents(5, [0, 1, 2, 3, 4]) 5 >>> min_tents(6, [1, 0, 2, 1, 2, 2]) 3","solution":"from collections import Counter def min_tents(n, a): Determines the minimum number of tents needed to accommodate everyone based on each person's sharing tolerance. Parameters: n (int): Number of people. a (List[int]): List of tolerances for each person. Returns: int: The minimum number of tents needed. tolerance_counts = Counter(a) tents = 0 for tolerance, count in tolerance_counts.items(): tents += (count + tolerance) // (tolerance + 1) return tents"},{"question":"def version_control_system(n, m, operations, queries): Simulates the version control system operations and queries. >>> operations = [\\"U file1 1\\", \\"U file2 2\\", \\"C 1\\", \\"U file1 3\\", \\"C 2\\", \\"U file2 4\\", \\"C 3\\"] >>> queries = [\\"file1 2\\", \\"file2 1\\", \\"file2 3\\"] >>> version_control_system(7, 3, operations, queries) [\\"file1: 3\\", \\"file2: 2\\", \\"file2: 4\\"] >>> operations = [\\"U file1 1\\", \\"C 1\\", \\"U file2 2\\", \\"C 2\\"] >>> queries = [\\"file2 1\\", \\"file3 2\\"] >>> version_control_system(4, 2, operations, queries) [\\"file2: Not Found\\", \\"file3: Not Found\\"] >>> operations = [\\"U file1 1\\", \\"U file1 2\\", \\"C 1\\", \\"U file1 3\\", \\"C 2\\", \\"U file1 4\\", \\"C 3\\"] >>> queries = [\\"file1 1\\", \\"file1 2\\", \\"file1 3\\"] >>> version_control_system(7, 3, operations, queries) [\\"file1: 2\\", \\"file1: 3\\", \\"file1: 4\\"] >>> operations = [\\"C 1\\", \\"C 2\\", \\"C 3\\"] >>> queries = [\\"file1 1\\", \\"file2 2\\"] >>> version_control_system(3, 2, operations, queries) [\\"file1: Not Found\\", \\"file2: Not Found\\"]","solution":"def version_control_system(n, m, operations, queries): Simulates the version control system operations and queries. files = {} commits = {} current_version = 0 for operation in operations: parts = operation.split() if parts[0] == 'U': _, file_name, version = parts files[file_name] = int(version) elif parts[0] == 'C': _, version = parts current_version = int(version) for file_name, file_version in files.items(): if current_version not in commits: commits[current_version] = {} commits[current_version][file_name] = file_version result = [] for query in queries: file_name, version = query.split() version = int(version) found = False for v in range(version, 0, -1): if v in commits and file_name in commits[v]: result.append(f\\"{file_name}: {commits[v][file_name]}\\") found = True break if not found: result.append(f\\"{file_name}: Not Found\\") return result"},{"question":"from typing import List def maxGold(grid: List[List[int]]) -> int: Calculate the maximum number of coins you can collect by moving right or down from the top-left corner to the bottom-right corner of the grid. >>> maxGold([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> maxGold([[7]]) 7 >>> maxGold([[1, 2, 3]]) 6 >>> maxGold([[1], [4], [2]]) 7 >>> maxGold([[1, 2, 5], [3, 2, 1], [4, 3, 2]]) 13 >>> maxGold([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"from typing import List def maxGold(grid: List[List[int]]) -> int: m, n = len(grid), len(grid[0]) # Create a 2D dp array initialized to 0 dp = [[0] * n for _ in range(m)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Maximum coins will be in the bottom-right corner return dp[m-1][n-1]"},{"question":"def can_load_packages(q, test_cases): Given the number of delivery trucks, their capacities, the number of packages, and their weights, determine whether it's possible to load all packages onto the trucks such that no truck exceeds its weight capacity. Args: q (int): number of test cases test_cases (list): list of test case dictionaries. Each dictionary contains: 'np' : a tuple with two integers (n, p) where 'n' is the number of trucks and 'p' is the number of packages 'capacities' : list of integers representing the capacities of the trucks 'weights' : list of integers representing the weights of the packages Returns: list: a list of strings, either \\"YES\\" or \\"NO\\" for each test case Example: >>> q = 1 >>> test_cases = [{'np': (3, 5), 'capacities': [10, 10, 10], 'weights': [5, 5, 5, 5, 5]}] >>> can_load_packages(q, test_cases) ['YES'] >>> q = 1 >>> test_cases = [{'np': (2, 3), 'capacities': [10, 5], 'weights': [5, 5, 6]}] >>> can_load_packages(q, test_cases) ['NO'] pass # Your code here def test_can_load_packages(): q = 1 test_cases = [ { 'np': (3, 5), 'capacities': [10, 10, 10], 'weights': [5, 5, 5, 5, 5] } ] assert can_load_packages(q, test_cases) == [\\"YES\\"] def test_can_not_load_packages(): q = 1 test_cases = [ { 'np': (2, 3), 'capacities': [10, 5], 'weights': [5, 5, 6] } ] assert can_load_packages(q, test_cases) == [\\"NO\\"] def test_partial_load_failure(): q = 1 test_cases = [ { 'np': (3, 4), 'capacities': [8, 7, 10], 'weights': [6, 8, 4, 5] } ] assert can_load_packages(q, test_cases) == [\\"NO\\"] def test_multiple_test_cases(): q = 2 test_cases = [ { 'np': (3, 5), 'capacities': [10, 10, 10], 'weights': [5, 5, 5, 5, 5] }, { 'np': (2, 3), 'capacities': [10, 5], 'weights': [5, 5, 6] } ] assert can_load_packages(q, test_cases) == [\\"YES\\", \\"NO\\"]","solution":"def can_load_packages(q, test_cases): results = [] for i in range(q): n, p = test_cases[i]['np'] capacities = sorted(test_cases[i]['capacities'], reverse=True) weights = sorted(test_cases[i]['weights'], reverse=True) if sum(capacities) < sum(weights): results.append(\\"NO\\") continue j = 0 for weight in weights: while j < n and capacities[j] < weight: j += 1 if j == n: results.append(\\"NO\\") break capacities[j] -= weight else: results.append(\\"YES\\") return results"},{"question":"def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping intervals that can be attended. Parameters: intervals (list of tuples): A list of tuples where each tuple contains the start and end times of a task. Returns: int: The maximum number of non-overlapping intervals. >>> max_non_overlapping_intervals([(1, 3), (2, 6), (8, 10), (15, 18), (5, 7)]) == 4 >>> max_non_overlapping_intervals([(1, 4), (2, 5), (3, 6)]) == 1 >>> max_non_overlapping_intervals([(1, 2), (3, 4), (5, 6), (7, 8)]) == 4 >>> max_non_overlapping_intervals([]) == 0 >>> max_non_overlapping_intervals([(0, 24)]) == 1 >>> max_non_overlapping_intervals([(1, 3), (2, 3), (3, 4)]) == 2 >>> max_non_overlapping_intervals([(1, 3), (3, 5), (4, 6), (7, 8), (5, 9)]) == 3 >>> max_non_overlapping_intervals([(1, 2), (4, 5), (6, 7)]) == 3 # Your code here","solution":"def max_non_overlapping_intervals(intervals): Determines the maximum number of non-overlapping intervals that can be attended. Parameters: intervals (list of tuples): A list of tuples where each tuple contains the start and end times of a task. Returns: int: The maximum number of non-overlapping intervals. # Sort intervals based on end times intervals.sort(key=lambda x: x[1]) # Initialize variables count = 0 end_time = 0 for interval in intervals: # If the current interval starts after the last selected interval ends, it can be attended if interval[0] >= end_time: count += 1 end_time = interval[1] return count"},{"question":"def query_divisors(n, arr, start, end, queries): Processes the queries to find the elements in a subarray that are divisible by the given divisors. Args: n (int): The number of elements in the array. arr (list): The list of integers. start (int): The starting index of the subarray (inclusive). end (int): The ending index of the subarray (inclusive). queries (list): The list of divisors for each query. Returns: list: A list of lists, where each inner list contains the elements divisible by that query's divisor.","solution":"def query_divisors(n, arr, start, end, queries): Processes the queries to find the elements in a subarray that are divisible by the given divisors. Args: n (int): The number of elements in the array. arr (list): The list of integers. start (int): The starting index of the subarray (inclusive). end (int): The ending index of the subarray (inclusive). queries (list): The list of divisors for each query. Returns: list: A list of lists, where each inner list contains the elements divisible by that query's divisor. results = [] subarray = arr[start:end + 1] for d in queries: result = [x for x in subarray if x % d == 0] if result: results.append(result) else: results.append([\\"No elements found\\"]) return results"},{"question":"def can_obtain_by_rearranging_and_adding_one(s: str, t: str) -> str: Determine if t can be obtained by rearranging the characters of s and adding exactly one additional character. Args: s (str): The original string. t (str): The target string. Returns: str: \\"YES\\" if t can be obtained by rearranging the characters of s and adding exactly one additional character, otherwise \\"NO\\". Examples: >>> can_obtain_by_rearranging_and_adding_one('aab', 'baac') 'YES' >>> can_obtain_by_rearranging_and_adding_one('abc', 'aabcd') 'NO' >>> can_obtain_by_rearranging_and_adding_one('xyz', 'xyzq') 'YES' >>> can_obtain_by_rearranging_and_adding_one('a', 'ab') 'YES' >>> can_obtain_by_rearranging_and_adding_one('abc', 'acb') 'NO' >>> can_obtain_by_rearranging_and_adding_one('pqr', 'pqrs') 'YES' >>> can_obtain_by_rearranging_and_adding_one('hello', 'helloo') 'YES' >>> can_obtain_by_rearranging_and_adding_one('test', 'tteest') 'NO'","solution":"from collections import Counter def can_obtain_by_rearranging_and_adding_one(s, t): Determine if t can be obtained by rearranging s and adding exactly one character. # Count characters in both strings count_s = Counter(s) count_t = Counter(t) # Check if t has exactly one more character than s diff = sum((count_t - count_s).values()) if diff == 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def sum_of_even_numbers(n: int, m: int) -> int: Returns the sum of all even numbers greater than n but less than m. >>> sum_of_even_numbers(10, 12) == 0 >>> sum_of_even_numbers(3, 6) == 4 >>> sum_of_even_numbers(1, 10) == 20 >>> sum_of_even_numbers(8, 8) == 0 >>> sum_of_even_numbers(8, 9) == 0 >>> sum_of_even_numbers(-4, 4) == -2 + 0 + 2","solution":"def sum_of_even_numbers(n, m): Returns the sum of all even numbers greater than n but less than m. if n >= m - 1: return 0 start = n + 1 if (n + 1) % 2 == 0 else n + 2 end = m if m % 2 == 0 else m - 1 total = 0 for num in range(start, end, 2): total += num return total"},{"question":"def sequence(A, B, n): Returns the nth term of the sequence defined by the recurrence relation f(x) = -f(x - 1) + 2 * f(x - 2) with given initial terms A and B. The result is returned modulo 998244353. >>> sequence(3, 5, 1) == 3 % 998244353 >>> sequence(3, 5, 2) == 5 % 998244353 >>> sequence(3, 5, 4) == 9 >>> sequence(10**9, 10**9, 3) == (-10**9 + 2 * (10**9) % 998244353) % 998244353 >>> sequence(1, 2, 3) == 0 # This is calculated as: -2 + 2*1 == 0 >>> A, B, n = 1, 2, 10 >>> values = [1, 2] >>> for _ in range(8): >>> values.append((-values[-1] + 2 * values[-2]) % 998244353) >>> sequence(A, B, n) == values[-1]","solution":"MOD = 998244353 def sequence(A, B, n): Returns the nth term of the sequence defined by the recurrence relation f(x) = -f(x - 1) + 2 * f(x - 2) with given initial terms A and B. The result is returned modulo 998244353. if n == 1: return A % MOD if n == 2: return B % MOD f1, f2 = A % MOD, B % MOD for i in range(3, n + 1): fn = (-f2 + 2 * f1) % MOD f1, f2 = f2, fn return f2"},{"question":"def max_well_stacked_books(n: int, heights: List[int]) -> Tuple[int, List[int]]: You are given a collection of books in a library. Each book is represented with its respective height. Arrange the books such that specific criteria are met to maximize the number of books that appear \\"well-stacked\\". A book is considered \\"well-stacked\\" if it is shorter than both of its neighboring books: the one to the immediate left and the one to the immediate right. The first and the last books in the row cannot be considered \\"well-stacked\\". Args: n: Integer - the number of books. heights: List of integers - the heights of the books. Returns: Tuple of: - Integer representing the maximum number of \\"well-stacked\\" books. - List of integers representing the heights of the books in one of the possible optimal orders. >>> max_well_stacked_books(6, [1, 3, 5, 2, 4, 6]) (2, [3, 1, 5, 2, 6, 4])","solution":"def max_well_stacked_books(n, heights): heights.sort() result = [0] * n low = 0 high = n - 1 for i in range(n): if i % 2 == 0: result[i] = heights[high] high -= 1 else: result[i] = heights[low] low += 1 well_stacked_count = 0 for i in range(1, n-1): if result[i-1] > result[i] and result[i+1] > result[i]: well_stacked_count += 1 return well_stacked_count, result # Example usage n = 6 heights = [1, 3, 5, 2, 4, 6] max_well_stacked_books(n, heights)"},{"question":"from collections import deque from typing import List def shortest_path(grid: List[str], n: int, m: int) -> int: Find the length of the shortest path from the top-left corner to the bottom-right corner of the grid. >>> shortest_path([ ... \\"....\\", ... \\"..\\", ... \\"..#.\\", ... \\"....\\"], 4, 4) # Expected output: 6 >>> shortest_path([ ... \\"..#\\", ... \\".#.\\", ... \\"...\\" ], 3, 3) # Expected output: 4 >>> shortest_path([ ... \\"#.\\", ... \\".#\\" ], 2, 2) # Expected output: -1 def test_shortest_path_case1(): grid = [ \\"....\\", \\"..\\", \\"..#.\\", \\"....\\" ] assert shortest_path(grid, 4, 4) == 6 def test_shortest_path_case2(): grid = [ \\"..#\\", \\".#.\\", \\"...\\" ] assert shortest_path(grid, 3, 3) == 4 def test_shortest_path_case3(): grid = [ \\"#.\\", \\".#\\" ] assert shortest_path(grid, 2, 2) == -1 def test_shortest_path_edge_case1(): grid = [ \\".\\" ] assert shortest_path(grid, 1, 1) == 0 def test_shortest_path_edge_case2(): grid = [ \\"..\\", \\"..\\" ] assert shortest_path(grid, 2, 2) == 2 def test_shortest_path_edge_case3(): grid = [ \\".#\\", \\"#.\\" ] assert shortest_path(grid, 2, 2) == -1","solution":"from collections import deque def shortest_path(grid, n, m): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' def bfs(start, end): queue = deque([(start[0], start[1], 0)]) # queue holds (x, y, distance) visited = set() visited.add((start[0], start[1])) dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in dirs: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 return bfs((0, 0), (n - 1, m - 1))"},{"question":"from typing import Tuple, List def min_battery_power(N: int, grid: List[List[int]]) -> int: Determine the minimum amount of battery power required for the drone to travel from the start cell to the target cell in a given grid. Args: N (int): Size of the grid. grid (List[List[int]]): The N x N grid where 0 represents an open space and 1 represents an obstacle. Returns: int: Minimum battery power required to reach the target, or -1 if no path is possible. >>> min_battery_power(4, [[0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0]]) 6 >>> min_battery_power(3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]]) -1 pass def parse_input(input_string: str) -> Tuple[int, List[List[int]]]: Parse the input string to retrieve the grid size and the grid itself. Args: input_string (str): Input string containing grid details. Returns: Tuple[int, List[List[int]]]: A tuple containing the size of the grid and the grid as a list of lists of integers. >>> parse_input(\\"4n0 0 0 0n1 1 0 1n0 0 0 0n0 1 1 0\\") (4, [[0, 0, 0, 0], [1, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0]]) >>> parse_input(\\"3n0 1 0n1 1 0n0 0 0\\") (3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]]) pass","solution":"from collections import deque def min_battery_power(N, grid): if grid[0][0] == 1 or grid[N-1][N-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == N-1 and y == N-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 def parse_input(input_string): lines = input_string.strip().split('n') N = int(lines[0]) grid = [list(map(int, line.split())) for line in lines[1:]] return N, grid"},{"question":"def min_chars_to_palindrome(s: str) -> str: Returns the shortest palindrome string that can be obtained by adding the minimum number of characters to the beginning of the input string. >>> min_chars_to_palindrome(\\"abcd\\") \\"dcbabcd\\" >>> min_chars_to_palindrome(\\"aacecaaa\\") \\"aaacecaaa\\" >>> min_chars_to_palindrome(\\"race\\") \\"ecarace\\" >>> min_chars_to_palindrome(\\"level\\") \\"level\\" >>> min_chars_to_palindrome(\\"a\\") \\"a\\" >>> min_chars_to_palindrome(\\"\\") \\"\\" >>> min_chars_to_palindrome(\\"abcde\\") \\"edcbabcde\\" >>> min_chars_to_palindrome(\\"ana\\") \\"ana\\" >>> min_chars_to_palindrome(\\"anab\\") \\"banab\\"","solution":"def min_chars_to_palindrome(s: str) -> str: Returns the shortest palindrome string that can be obtained by adding the minimum number of characters to the beginning of the input string. def is_palindrome(s): return s == s[::-1] if is_palindrome(s): return s # Reverse the string and concatenate with the original string separated by a special character # to ensure no overlap in the KMP algorithm. rev_s = s[::-1] concat = s + '#' + rev_s # Calculate the longest prefix which is also suffix using KMP algorithm. lps = [0] * len(concat) length = 0 i = 1 while i < len(concat): if concat[i] == concat[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 # The characters to be prefixed will be the characters after the longest palindromic suffix # in the original string s. chars_to_add = rev_s[:len(s) - lps[-1]] # Return the characters to be added + original string which will form the shortest palindrome return chars_to_add + s"},{"question":"def minimal_array(n: int) -> List[int]: Generates an array of length n with the minimal possible value of g(a), which is also lexicographically smallest among all arrays having the minimal value of g(a). >>> minimal_array(2) [1, 1] >>> minimal_array(3) [1, 1, 1] >>> minimal_array(4) [1, 1, 1, 1]","solution":"def minimal_array(n): Generates an array of length n with the minimal possible value of g(a), which is also lexicographically smallest among all arrays having the minimal value of g(a). return [1] * n"},{"question":"def fibonacci_modulo(n: int) -> int: Returns the nth Fibonacci number modulo 1000000007. >>> fibonacci_modulo(1) 0 >>> fibonacci_modulo(2) 1 >>> fibonacci_modulo(5) 3 >>> fibonacci_modulo(10) 34 >>> fibonacci_modulo(100) 218922995834555169026 % 1000000007","solution":"def fibonacci_modulo(n): Returns the nth Fibonacci number modulo 1000000007. MOD = 1000000007 if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(2, n): a, b = b, (a + b) % MOD return b"},{"question":"def largest_sum_subgrid(x, y, grid): Given the number of rows x and number of columns y, and a grid of digits, find the largest possible sum by selecting exactly one contiguous subgrid. Arguments: x -- number of rows y -- number of columns grid -- list of list of digits Returns: An integer representing the largest sum of a contiguous subgrid. def parse_input(input): Parse the input data to extract the number of rows, columns, and the grid. Arguments: input -- string representing the input data Returns: A tuple containing the number of rows, columns, and the grid as a list of list of digits. from solution import largest_sum_subgrid, parse_input def test_largest_sum_subgrid(): input_data = \\"3 3n1 2 3n4 5 6n7 8 9\\" x, y, grid = parse_input(input_data) assert largest_sum_subgrid(x, y, grid) == 45 input_data = \\"3 3n1 2 3n0 0 0n5 6 7\\" x, y, grid = parse_input(input_data) assert largest_sum_subgrid(x, y, grid) == 24 input_data = \\"1 1n9\\" x, y, grid = parse_input(input_data) assert largest_sum_subgrid(x, y, grid) == 9 input_data = \\"2 2n0 0n0 0\\" x, y, grid = parse_input(input_data) assert largest_sum_subgrid(x, y, grid) == 0 input_data = \\"2 2n1 2n3 4\\" x, y, grid = parse_input(input_data) assert largest_sum_subgrid(x, y, grid) == 10 def test_parse_input(): input_data = \\"3 3n1 2 3n4 5 6n7 8 9\\" x, y, grid = parse_input(input_data) assert x == 3 assert y == 3 assert grid == [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] input_data = \\"1 1n9\\" x, y, grid = parse_input(input_data) assert x == 1 assert y == 1 assert grid == [ [9] ] input_data = \\"2 2n0 0n0 0\\" x, y, grid = parse_input(input_data) assert x == 2 assert y == 2 assert grid == [ [0, 0], [0, 0] ] # Read Input from user import sys input = sys.stdin.read x, y, grid = parse_input(input().strip()) print(largest_sum_subgrid(x, y, grid))","solution":"def largest_sum_subgrid(x, y, grid): Given the number of rows x and number of columns y, and a grid of digits, find the largest possible sum by selecting exactly one contiguous subgrid. Arguments: x -- number of rows y -- number of columns grid -- list of list of digits Returns: An integer representing the largest sum of a contiguous subgrid. # Initialize the maximum sum to a very small number max_sum = -float('inf') # Create a 2D prefix sum array prefix_sum = [[0] * (y + 1) for _ in range(x + 1)] for i in range(x): for j in range(y): prefix_sum[i + 1][j + 1] = grid[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] # Iterate over all possible subgrids for i1 in range(1, x + 1): for j1 in range(1, y + 1): for i2 in range(i1, x + 1): for j2 in range(j1, y + 1): # Use the prefix sum to calculate the sum of the subgrid subgrid_sum = (prefix_sum[i2][j2] - prefix_sum[i1 - 1][j2] - prefix_sum[i2][j1 - 1] + prefix_sum[i1 - 1][j1 - 1]) # Update the maximum sum max_sum = max(max_sum, subgrid_sum) return max_sum # Read Input from user import sys input = sys.stdin.read def parse_input(input): data = input.strip().split() x = int(data[0]) y = int(data[1]) grid = [] idx = 2 for i in range(x): grid.append([int(digit) for digit in data[idx:idx + y]]) idx += y return x, y, grid"},{"question":"def distribute_prizes(t: int, test_cases: List[Tuple[int, int, int]]) -> List[str]: Distributes prizes among winners based on the given constraints. Args: t (int): Number of test cases. test_cases: A list of tuples, each containing three integers (n, k, m). Returns: List[str]: A list containing results \\"YES\\" or \\"NO\\" for each test case followed by any valid distribution of prizes if \\"YES\\". >>> distribute_prizes(3, [(7, 3, 3), (5, 2, 3), (9, 5, 1)]) [\\"YES\\", \\"3 2 2\\", \\"YES\\", \\"3 2\\", \\"NO\\"] >>> distribute_prizes(2, [(10, 5, 2), (15, 4, 5)]) [\\"YES\\", \\"2 2 2 2 2\\", \\"YES\\", \\"5 5 5 0\\"]","solution":"def distribute_prizes(t, test_cases): results = [] for i in range(t): n, k, m = test_cases[i] if k > n or (k * m < n): results.append(\\"NO\\") else: base_prizes = [n // k] * k remainder = n % k for j in range(remainder): base_prizes[j] += 1 if max(base_prizes) <= m: results.append(\\"YES\\") results.append(\\" \\".join(map(str, base_prizes))) else: results.append(\\"NO\\") return results"},{"question":"def can_arrange_members(n: int, m: int, preferences: List[Tuple[int, int]]) -> str: Determine if it's possible to arrange all the members around the table such that each member sits next to all the members they prefer to sit next to. >>> can_arrange_members(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"YES\\" >>> can_arrange_members(5, 3, [(1, 2), (2, 3), (4, 5)]) == \\"NO\\" >>> can_arrange_members(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"NO\\" >>> can_arrange_members(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"YES\\" >>> can_arrange_members(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YES\\"","solution":"def can_arrange_members(n, m, preferences): from collections import defaultdict def dfs(v, color): colors[v] = color for neighbor in graph[v]: if colors[neighbor] == -1: if not dfs(neighbor, 1 - color): return False elif colors[neighbor] == color: return False return True if m < n - 1: return \\"NO\\" graph = defaultdict(list) for a, b in preferences: graph[a].append(b) graph[b].append(a) colors = [-1] * (n + 1) for member in range(1, n + 1): if colors[member] == -1: if not dfs(member, 0): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def find_unique_element(arr: List[int]) -> int: This function takes a list of integers where each element appears exactly twice except for one unique element. It returns the unique element that appears only once using bitwise XOR. # your code here # Unit tests def test_find_unique_element_example(): assert find_unique_element([4, 1, 2, 1, 2]) == 4 def test_find_unique_element_single_element(): assert find_unique_element([99]) == 99 def test_find_unique_element_negative_elements(): assert find_unique_element([-1, -1, -2, -3, -3]) == -2 def test_find_unique_element_with_mixed_signs(): assert find_unique_element([10, -20, 10, 30, -20, 40, 30]) == 40 def test_find_unique_element_all_positive(): assert find_unique_element([5, 3, 4, 3, 4, 5, 6]) == 6 def test_find_unique_element_large_input(): arr = list(range(1, 50001)) + list(range(1, 50001)) + [50000] assert find_unique_element(arr) == 50000","solution":"from typing import List def find_unique_element(arr: List[int]) -> int: This function takes a list of integers where each element appears exactly twice except for one unique element. It returns the unique element that appears only once using bitwise XOR. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def check_consistency(t: int, data: List[Tuple[int, List[int]]]) -> List[str]: Determine whether each employee's performance metrics are consistent. Parameters: t (int): number of employees. data (list): list of tuples for each employee, where each tuple contains - an integer n (number of performance metrics) - a sequence of n integers representing the performance metrics Returns: list: A list of strings, \\"Consistent\\" or \\"Inconsistent\\" for each employee. Examples: >>> check_consistency(3, [(4, [-1, 1, 3, 5]), (3, [7, 5, 3]), (5, [1, 2, 4, 8, 16])]) [\\"Consistent\\", \\"Consistent\\", \\"Inconsistent\\"] >>> check_consistency(2, [(3, [-3, -6, -9]), (3, [-10, -5, 0])]) [\\"Consistent\\", \\"Consistent\\"]","solution":"def is_consistent(differences): Helper function to determine if the list of differences are all the same. return all(d == differences[0] for d in differences) def check_consistency(t, data): Determine whether each employee's performance metrics are consistent. Parameters: t (int): number of employees. data (list): list of tuples for each employee, where each tuple contains - an integer n (number of performance metrics) - a sequence of n integers representing the performance metrics Returns: list: A list of strings, \\"Consistent\\" or \\"Inconsistent\\" for each employee. results = [] for performance in data: n, metrics = performance differences = [metrics[i+1] - metrics[i] for i in range(n-1)] if is_consistent(differences): results.append(\\"Consistent\\") else: results.append(\\"Inconsistent\\") return results"},{"question":"from typing import List, Tuple def can_travel_between_floors(n: int, m: int, q: int, elevator_ranges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determines if it's possible to travel between the given start and target floor for each query using the provided elevators. Args: n (int): total number of floors. m (int): number of elevators. q (int): number of queries. elevator_ranges (List[Tuple[int, int]]): list of tuples where each tuple contains (ai, bi) indicating floors the i-th elevator can reach. queries (List[Tuple[int, int]]): list of tuples where each tuple contains (si, ti) indicating start and target floors. Returns: List[str]: list of \\"YES\\" or \\"NO\\" for each query. def test_example_case(): elevator_ranges = [(1, 3), (2, 5), (4, 5)] queries = [(1, 3), (2, 4)] solution = can_travel_between_floors(5, 3, 2, elevator_ranges, queries) assert solution == [\\"YES\\", \\"YES\\"] def test_no_possible_travel(): elevator_ranges = [(1, 2), (3, 4)] queries = [(1, 3), (2, 4)] solution = can_travel_between_floors(4, 2, 2, elevator_ranges, queries) assert solution == [\\"NO\\", \\"NO\\"] def test_single_elevator_travel(): elevator_ranges = [(1, 4)] queries = [(1, 4), (1, 2), (2, 3)] solution = can_travel_between_floors(4, 1, 3, elevator_ranges, queries) assert solution == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_out_of_range_travel(): elevator_ranges = [(1, 3), (2, 4)] queries = [(0, 3), (1, 5)] solution = can_travel_between_floors(5, 2, 2, elevator_ranges, queries) assert solution == [\\"NO\\", \\"NO\\"] def test_large_input(): elevator_ranges = [(1, 100)] * 100 queries = [(1, 100), (50, 60), (20, 80)] solution = can_travel_between_floors(100, 100, 3, elevator_ranges, queries) assert solution == [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_travel_between_floors(n, m, q, elevator_ranges, queries): Determines if it's possible to travel between the given start and target floor for each query using the provided elevators. Args: n (int): total number of floors. m (int): number of elevators. q (int): number of queries. elevator_ranges (List[Tuple[int, int]]): list of tuples where each tuple contains (ai, bi) indicating floors the i-th elevator can reach. queries (List[Tuple[int, int]]): list of tuples where each tuple contains (si, ti) indicating start and target floors. Returns: List[str]: list of \\"YES\\" or \\"NO\\" for each query. results = [] # Process each query for (s, t) in queries: reachable = False # Check each elevator to see if it can be used to travel between s and t for (a, b) in elevator_ranges: if s >= a and s <= b and t >= a and t <= b: reachable = True break if reachable: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_valid_pairs(s: str) -> int: Given a string s consisting of lowercase and uppercase English letters, this function returns the number of valid pairs (i, j) where 1 <= i < j <= len(s) and s[i] and s[j] are the same character in opposite cases. >>> count_valid_pairs(\\"aAbBcC\\") 3 >>> count_valid_pairs(\\"abc\\") 0 >>> count_valid_pairs(\\"AbBcCa\\") 3 pass # Your implementation goes here","solution":"def count_valid_pairs(s): Given a string s consisting of lowercase and uppercase English letters, this function returns the number of valid pairs (i, j) where 1 <= i < j <= len(s) and s[i] and s[j] are the same character in opposite cases. :param s: str - the input string :return: int - number of valid pairs count = 0 upper_count = {} lower_count = {} # Count the occurrences of each character in upper and lower cases for char in s: if char.isupper(): upper_count[char] = upper_count.get(char, 0) + 1 elif char.islower(): lower_count[char] = lower_count.get(char, 0) + 1 # Compute the valid pairs for char in upper_count: lower_char = char.lower() if lower_char in lower_count: count += min(upper_count[char], lower_count[lower_char]) return count"},{"question":"def max_transformations(n: int, cards: List[int]) -> int: Returns the maximum number of magic transformations possible. >>> max_transformations(5, [6, 4, 2, 4, 6]) == 4 >>> max_transformations(2, [1, 2]) == 1 >>> max_transformations(3, [5, 5, 5]) == 2 >>> max_transformations(4, [1000000000, 1, 999999999, 0]) == 3 >>> max_transformations(6, [1, 0, 1, 0, 1, 0]) == 5","solution":"def max_transformations(n, cards): Returns the maximum number of magic transformations possible. The number of transformations is always \`n-1\` where \`n\` is the number of cards. return n - 1"},{"question":"def max_gemstones(N: int, E: int, gemstones: List[int], energy: List[int]) -> int: Determine the maximum number of gemstones Maxwell can collect in the mine. Args: N (int): The number of sections in the mine. E (int): The maximum energy limit. gemstones (List[int]): List of gemstones in each section. energy (List[int]): List of energy required for each section. Returns: int: Maximum number of gemstones collected without exceeding the energy limit. Examples: >>> max_gemstones(5, 10, [5, 3, 7, 2, 8], [2, 4, 1, 6, 3]) 15 >>> max_gemstones(3, 10, [1, 2, 3], [1, 1, 1]) 6 >>> max_gemstones(4, 5, [4, 1, 7, 2], [3, 2, 1, 4]) 5 >>> max_gemstones(1, 10, [9], [5]) 9 >>> max_gemstones(3, 5, [2, 4, 3], [2, 2, 1]) 9 >>> max_gemstones(3, 1, [4, 3, 5], [2, 2, 2]) 0","solution":"def max_gemstones(N, E, gemstones, energy): max_gems = 0 current_energy = 0 for i in range(N): if current_energy + energy[i] <= E: current_energy += energy[i] max_gems += gemstones[i] else: break return max_gems"},{"question":"def num_common_subsequences(s: str, t: str) -> int: Returns the number of common subsequences between strings s and t. >>> num_common_subsequences(\\"abc\\", \\"abc\\") 7 >>> num_common_subsequences(\\"\\", \\"\\") 0 >>> num_common_subsequences(\\"abc\\", \\"def\\") 0 >>> num_common_subsequences(\\"a\\", \\"a\\") 1 >>> num_common_subsequences(\\"abc\\", \\"a\\") 1","solution":"MOD = 10**9 + 7 def num_common_subsequences(s, t): Returns the number of common subsequences between strings s and t. len_s = len(s) len_t = len(t) # dp[i][j] will store the count of common subsequences of s[:i] and t[:j] dp = [[0] * (len_t + 1) for _ in range(len_s + 1)] # Every string has a common subsequence with an empty string: the empty string itself for i in range(len_s + 1): dp[i][0] = 1 for j in range(len_t + 1): dp[0][j] = 1 for i in range(1, len_s + 1): for j in range(1, len_t + 1): if s[i - 1] == t[j - 1]: dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD # Adding one more common subsequence ending at (i, j) else: dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) % MOD # Avoid over-counting return (dp[len_s][len_t] - 1) % MOD # Removing the empty string subsequence"},{"question":"def longestTwoCharSubstring(s: str) -> int: Returns the length of the longest substring containing at most two distinct characters. >>> longestTwoCharSubstring(\\"eceba\\") == 3 >>> longestTwoCharSubstring(\\"ccaabbb\\") == 5 >>> longestTwoCharSubstring(\\"a\\") == 1 >>> longestTwoCharSubstring(\\"aa\\") == 2 >>> longestTwoCharSubstring(\\"abcdef\\") == 2 >>> longestTwoCharSubstring(\\"abababababab\\") == 12 >>> longestTwoCharSubstring(\\"abaccc\\") == 4 >>> longestTwoCharSubstring(\\"aaabbbccc\\") == 6 >>> longestTwoCharSubstring(\\"\\") == 0 >>> longestTwoCharSubstring(\\"a\\"*100000) == 100000","solution":"def longestTwoCharSubstring(s: str) -> int: Returns the length of the longest substring containing at most two distinct characters. if not s: return 0 left = 0 recent_left_char_index = {} max_length = 0 for right in range(len(s)): recent_left_char_index[s[right]] = right if len(recent_left_char_index) > 2: left_most_index = min(recent_left_char_index.values()) del recent_left_char_index[s[left_most_index]] left = left_most_index + 1 current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"def place_bomb(n: int, m: int, grid: List[str]) -> Tuple[int, int]: Given a 2D grid, place a bomb in one of the empty cells to maximize the number of reachable empty cells. Each cell in the grid can either be a wall (\`#\`) or an empty cell (\`.\`). The bomb destroys empty cells in all four cardinal directions until it hits a wall or the edge of the grid. Returns the coordinates (x, y) of the optimal empty cell for placing the bomb. If there are multiple such cells, return the one with the smallest row number or the smallest column number if there is still a tie. >>> place_bomb(4, 4, [\\"....\\", \\"..\\", \\"....\\", \\"..\\"]) (1, 4) from typing import List, Tuple def test_single_empty_cell(): grid = [\\"#\\"] assert place_bomb(1, 1, grid) == (1, 1) def test_maximize_reachable_cells(): grid = [\\"....\\", \\"..\\", \\"....\\", \\"..\\"] assert place_bomb(4, 4, grid) == (1, 4) def test_all_cells_empty(): grid = [\\"....\\", \\"....\\", \\"....\\"] assert place_bomb(3, 4, grid) == (1, 1) def test_all_cells_walls(): grid = [\\"\\", \\"\\", \\"\\"] assert place_bomb(3, 4, grid) == (1, 1) def test_completely_blocked(): grid = [\\".#.\\", \\"#\\", \\".#.\\"] assert place_bomb(3, 3, grid) == (1, 1) def test_multiple_optimal_cells(): grid = [\\"#.#\\", \\"...\\", \\"#.#\\"] assert place_bomb(3, 3, grid) == (2, 2)","solution":"def place_bomb(n, m, grid): max_reachable = 0 best_cell = (1, 1) def count_reachable(x, y): count = 0 # Count up for i in range(x - 1, -1, -1): if grid[i][y] == '#': break count += 1 # Count down for i in range(x + 1, n): if grid[i][y] == '#': break count += 1 # Count left for j in range(y - 1, -1, -1): if grid[x][j] == '#': break count += 1 # Count right for j in range(y + 1, m): if grid[x][j] == '#': break count += 1 return count for i in range(n): for j in range(m): if grid[i][j] == '.': reachable = count_reachable(i, j) if reachable > max_reachable: max_reachable = reachable best_cell = (i + 1, j + 1) elif reachable == max_reachable: if (i + 1, j + 1) < best_cell: best_cell = (i + 1, j + 1) return best_cell"},{"question":"def maximize_number(n: int, number: str) -> str: Maximize the resulting number possible after at most one swap operation. If no swap operation can improve the number, return the original number. >>> maximize_number(4, \\"2736\\") '7236' >>> maximize_number(3, \\"123\\") '321' # Add your solution here def test_maximize_number_1(): assert maximize_number(4, \\"2736\\") == \\"7236\\" def test_maximize_number_2(): assert maximize_number(3, \\"123\\") == \\"321\\" def test_no_improvement(): assert maximize_number(3, \\"321\\") == \\"321\\" def test_single_digit(): assert maximize_number(1, \\"9\\") == \\"9\\" def test_all_digits_same(): assert maximize_number(3, \\"999\\") == \\"999\\" def test_leading_zeros(): assert maximize_number(4, \\"1002\\") == \\"2001\\"","solution":"def maximize_number(n, number): Maximizes the number by performing at most one swap operation. number = list(number) max_number = number[:] for i in range(n): for j in range(i + 1, n): number[i], number[j] = number[j], number[i] if number > max_number: max_number = number[:] number[i], number[j] = number[j], number[i] return ''.join(max_number)"},{"question":"def can_alice_win(s: str) -> str: Determines if Alice can guarantee a win if both players play optimally. Alice wins if the length of the string is even, since she makes the first move. >>> can_alice_win(\\"abba\\") \\"YES\\" >>> can_alice_win(\\"abc\\") \\"NO\\" >>> can_alice_win(\\"a\\") \\"NO\\" >>> can_alice_win(\\"a\\" * 100000) \\"YES\\" >>> can_alice_win(\\"a\\" * 99999) \\"NO\\"","solution":"def can_alice_win(s): Determines if Alice can guarantee a win if both players play optimally. Alice wins if the length of the string is even, since she makes the first move. return \\"YES\\" if len(s) % 2 == 0 else \\"NO\\""},{"question":"def minimum_trees_to_cut(heights: List[int]) -> int: This function takes a list of integers (heights of trees) and returns the minimum number of trees that need to be cut down such that no two adjacent trees have the same height. >>> minimum_trees_to_cut([1, 2, 2, 3, 4, 4, 5]) 2 >>> minimum_trees_to_cut([7, 7, 6, 5, 5, 5, 1]) 2 >>> minimum_trees_to_cut([1, 1, 2, 3, 4]) 1 >>> minimum_trees_to_cut([7, 7, 6, 5, 5, 1]) 2 >>> minimum_trees_to_cut([2, 2, 2, 2, 2]) 2","solution":"from typing import List def minimum_trees_to_cut(heights: List[int]) -> int: This function takes a list of integers (heights of trees) and returns the minimum number of trees that need to be cut down such that no two adjacent trees have the same height. cut_count = 0 i = 0 while i < len(heights) - 1: if heights[i] == heights[i + 1]: cut_count += 1 i += 2 # Skip the next tree since we will cut it down else: i += 1 return cut_count"},{"question":"from typing import List from collections import defaultdict def group_anagrams(strings: List[str]) -> List[List[str]]: Given a list of strings, group the strings that are anagrams of each other. >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> group_anagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] >>> group_anagrams([\\"abc\\", \\"bca\\", \\"cab\\"]) [[\\"abc\\", \\"bca\\", \\"cab\\"]]","solution":"from collections import defaultdict from typing import List def group_anagrams(strings: List[str]) -> List[List[str]]: anagrams_dict = defaultdict(list) for string in strings: sorted_string = ''.join(sorted(string)) anagrams_dict[sorted_string].append(string) return list(anagrams_dict.values())"},{"question":"def count_even_sum_pairs(n: int, arr: List[int]) -> int: Count the number of pairs (i, j) where 1 ≤ i < j ≤ n and arr[i] + arr[j] is even. Args: n: int - number of elements in the array. arr: list of int - the elements of the array. Returns: int - the number of pairs with even sum. Examples: >>> count_even_sum_pairs(4, [1, 2, 3, 4]) 2 >>> count_even_sum_pairs(5, [2, 4, 6, 8, 10]) 10 >>> count_even_sum_pairs(5, [1, 3, 5, 7, 9]) 10","solution":"def count_even_sum_pairs(n, arr): Count the number of pairs (i, j) where 1 ≤ i < j ≤ n and arr[i] + arr[j] is even. Args: n: int - number of elements in the array. arr: list of int - the elements of the array. Returns: int - the number of pairs with even sum. even_count = 0 odd_count = 0 for num in arr: if num % 2 == 0: even_count += 1 else: odd_count += 1 # Pairs from even numbers and odd numbers even_pairs = (even_count * (even_count - 1)) // 2 odd_pairs = (odd_count * (odd_count - 1)) // 2 return even_pairs + odd_pairs"},{"question":"def guess_language(article: str) -> str: Classify the language of a given article based on its content. >>> guess_language(\\"1nThe title of the articlenThis is the body of the article. It is written in English.\\") \\"en\\" >>> guess_language(\\"2nLe titre de l'articlenCeci est le corps de l'article. Il est écrit en français.\\") \\"fr\\" >>> guess_language(\\"3nDer Titel des ArtikelsnDies ist der Körper des Artikels. Es ist auf Deutsch geschrieben.\\") \\"de\\" >>> guess_language(\\"4nMixed contentnThis article contains mixed content. Cet article contient un contenu mixte. Dieser Artikel enthält gemischte Inhalte.\\") in [\\"en\\", \\"fr\\", \\"de\\"]","solution":"import os import string from collections import Counter def load_stopwords(): stopwords = { 'en': [\\"the\\", \\"and\\", \\"to\\", \\"of\\", \\"in\\", \\"that\\", \\"is\\", \\"it\\", \\"for\\", \\"with\\"], 'fr': [\\"et\\", \\"le\\", \\"de\\", \\"la\\", \\"les\\", \\"des\\", \\"une\\", \\"que\\", \\"en\\", \\"pour\\"], 'de': [\\"und\\", \\"die\\", \\"der\\", \\"das\\", \\"ist\\", \\"in\\", \\"zu\\", \\"den\\", \\"von\\", \\"mit\\"] } return stopwords def preprocess(text): text = text.lower() text = text.translate(str.maketrans(\\"\\", \\"\\", string.punctuation)) return text.split() def guess_language(article): stopwords = load_stopwords() # Split the article into lines lines = article.strip().split(\\"n\\") # Combine title and body into a single text content = \\" \\".join(lines[1:]) words = preprocess(content) word_counts = Counter(words) language_scores = {lang: 0 for lang in stopwords} for lang, stopword_list in stopwords.items(): for stopword in stopword_list: language_scores[lang] += word_counts[stopword] return max(language_scores, key=language_scores.get)"},{"question":"def mystery_solver(arr: List[int]) -> str: Determines if there exists any contiguous subarray that sums up to 0. >>> mystery_solver([1, 2, -3, 4, 5]) 'Subarray Found' >>> mystery_solver([1, 2, 3, 4, 5]) 'Subarray Not Found' >>> mystery_solver([-1, 1, -1, 1]) 'Subarray Found' >>> mystery_solver([0, 1, 2, 3]) 'Subarray Found' >>> mystery_solver([-1, -2, -3, 6]) 'Subarray Found' >>> mystery_solver([10, 20, -30, 10]) 'Subarray Found' >>> mystery_solver([1]) 'Subarray Not Found' >>> mystery_solver([-10, 20, -10]) 'Subarray Found' >>> mystery_solver([3, 4, -7, 1, 2]) 'Subarray Found'","solution":"def mystery_solver(arr): Determines if there exists a contiguous subarray that sums up to 0. Parameters: arr (list of int): List of integers to be checked. Returns: str: \\"Subarray Found\\" if a subarray with sum 0 exists, otherwise \\"Subarray Not Found\\". cumulative_sum = 0 seen_sums = set() for num in arr: cumulative_sum += num if cumulative_sum == 0 or cumulative_sum in seen_sums: return \\"Subarray Found\\" seen_sums.add(cumulative_sum) return \\"Subarray Not Found\\""},{"question":"def max_students_surrounded(n: int, heights: List[int]) -> Tuple[int, List[int]]: Given a number of students and their heights, find the optimal arrangement where the maximum number of students are surrounded by taller neighbors. :param n: Number of students :param heights: List of students' heights. :return: A tuple containing the maximum number of students with taller neighbors and the optimal heights arrangement. >>> max_students_surrounded(6, [1, 2, 3, 4, 5, 6]) (2, [1, 3, 2, 5, 4, 6]) >>> max_students_surrounded(5, [5, 4, 3, 2, 1]) (2, [1, 5, 2, 4, 3]) >>> max_students_surrounded(4, [2, 2, 2, 2]) (1, [2, 2, 2, 2]) pass def test_example(): n = 6 heights = [1, 2, 3, 4, 5, 6] max_surrounded, result = max_students_surrounded(n, heights) assert max_surrounded == 2 assert result in [ [1, 6, 2, 5, 3, 4], [1, 6, 2, 5, 4, 3], [1, 3, 2, 5, 4, 6], [1, 4, 2, 5, 3, 6] ] def test_single_peak(): n = 5 heights = [5, 4, 3, 2, 1] max_surrounded, result = max_students_surrounded(n, heights) assert max_surrounded == 2 assert result in [ [1, 5, 2, 4, 3], [1, 5, 3, 4, 2] ] def test_identical_heights(): n = 4 heights = [2, 2, 2, 2] max_surrounded, result = max_students_surrounded(n, heights) assert max_surrounded == 1 assert result in [ [2, 2, 2, 2] ] def test_negative(): n = 3 heights = [3, 1, 2] max_surrounded, result = max_students_surrounded(n, heights) assert max_surrounded == 1 assert result in [ [1, 3, 2], [2, 3, 1] ] def test_large_case(): n = 7 heights = [1, 2, 3, 4, 5, 6, 7] max_surrounded, result = max_students_surrounded(n, heights) assert max_surrounded == 3 assert result in [ [1, 7, 2, 6, 3, 5, 4], [1, 6, 2, 5, 3, 4, 7], ] def test_all_same_height(): n = 5 heights = [1, 1, 1, 1, 1] max_surrounded, result = max_students_surrounded(n, heights) assert max_surrounded == 2 assert result == [1, 1, 1, 1, 1]","solution":"def max_students_surrounded(n, heights): Given a number of students and their heights, find the optimal arrangement where the maximum number of students are surrounded by taller neighbors. :param n: Number of students :param heights: List of students' heights. :return: A tuple containing the maximum number of students with taller neighbors and the optimal heights arrangement. heights.sort() result = [] # Interleave the heights as small, large, small, large, ... for i in range(n): if i % 2 == 0: result.append(heights[i // 2]) else: result.append(heights[n - (i // 2 + 1)]) max_surrounded = (n - 1) // 2 return max_surrounded, result"},{"question":"from typing import List, Optional, Tuple def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Determines whether two different elements in the list sum up to a target number. Args: nums: List of integers where 2 <= n <= 10^5. target: An integer representing the target sum. Returns: A tuple of two integers from the list that sum up to the target or None if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4], 8) None >>> find_pair_with_sum([-1, 2, 3, -4, 5], 1) (-1, 2) pass def test_find_pair_with_sum_found(): assert find_pair_with_sum([2, 7, 11, 15], 9) in [(2, 7), (7, 2)] assert find_pair_with_sum([1, 2, 3, 4], 5) in [(1, 4), (4, 1), (2, 3), (3, 2)] assert find_pair_with_sum([-1, 2, 3, -4, 5], 1) in [(-1, 2), (2, -1)] def test_find_pair_with_sum_not_found(): assert find_pair_with_sum([1, 2, 3, 4], 8) == None assert find_pair_with_sum([10, 20, 30, 40], 100) == None def test_find_pair_with_sum_edge_cases(): assert find_pair_with_sum([5, 5], 10) in [(5, 5)] assert find_pair_with_sum([0, 0], 0) in [(0, 0)] assert find_pair_with_sum([-5, 10, 15, -10], 5) in [(10, -5), (-5, 10)]","solution":"from typing import List, Optional, Tuple def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Determines whether two different elements in the list sum up to a target number. Args: nums: List of integers where 2 <= n <= 10^5. target: An integer representing the target sum. Returns: A tuple of two integers from the list that sum up to the target or None if no such pair exists. seen = set() for num in nums: complement = target - num if complement in seen: return (complement, num) seen.add(num) return None"},{"question":"def find_triplet(n, arr, x): Returns True if there exist three distinct indices i, j, and k such that arr[i] + arr[j] + arr[k] = x, otherwise False. pass # Unit tests def test_find_triplet_example1(): assert find_triplet(6, [1, 4, 45, 6, 10, 8], 22) == True def test_find_triplet_example2(): assert find_triplet(5, [1, 2, 4, 3, 6], 10) == True def test_find_triplet_example3(): assert find_triplet(2, [1, 2], 5) == False def test_find_triplet_no_matching_triplet(): assert find_triplet(5, [1, 2, 9, 10, 11], 50) == False def test_find_triplet_exact_three_elements(): assert find_triplet(3, [1, 2, 3], 6) == True def test_find_triplet_negative_and_positive(): assert find_triplet(6, [-1, 2, 9, -10, 11, 3], 2) == True def test_find_triplet_all_same_values(): assert find_triplet(6, [1, 1, 1, 1, 1, 1], 3) == True def test_find_triplet_large_input_no_triplet(): assert find_triplet(7, [5, 17, 20, 15, 10, 25, 30], 100) == False","solution":"def find_triplet(n, arr, x): Returns True if there exist three distinct indices i, j, and k such that arr[i] + arr[j] + arr[k] = x, otherwise False. arr.sort() for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: return True elif current_sum < x: left += 1 else: right -= 1 return False"},{"question":"def can_deliver_all_flyers(n: int, slots: List[Tuple[int, int]]) -> str: Determines if all the flyers can be delivered without any overlap. Parameters: n (int): The number of flyers. slots (list of tuples): Each tuple contains two integers, start and end time of the slot for the flyer. Returns: str: \\"YES\\" if all flyers can be delivered without overlap, otherwise \\"NO\\". >>> can_deliver_all_flyers(3, [(1, 3), (3, 5), (4, 6)]) == \\"YES\\" >>> can_deliver_all_flyers(3, [(1, 3), (2, 4), (5, 7)]) == \\"NO\\" >>> can_deliver_all_flyers(1, [(1, 3)]) == \\"YES\\" >>> can_deliver_all_flyers(4, [(1, 2), (3, 4), (5, 6), (7, 8)]) == \\"YES\\" >>> can_deliver_all_flyers(3, [(1, 4), (2, 5), (3, 6)]) == \\"NO\\" >>> can_deliver_all_flyers(4, [(1, 3), (3, 5), (5, 7), (7, 9)]) == \\"YES\\" >>> can_deliver_all_flyers(4, [(1, 4), (2, 6), (5, 7), (6, 9)]) == \\"NO\\" >>> can_deliver_all_flyers(2, [(0, 999999999), (500000000, 1000000000)]) == \\"NO\\" >>> can_deliver_all_flyers(200000, [(i, i+1) for i in range(200000)]) == \\"YES\\"","solution":"def can_deliver_all_flyers(n, slots): Determines if all the flyers can be delivered without any overlap. Parameters: n (int): The number of flyers. slots (list of tuples): Each tuple contains two integers, start and end time of the slot for the flyer. Returns: str: \\"YES\\" if all flyers can be delivered without overlap, otherwise \\"NO\\". # Sort the flyers by their end time primarily and start time secondarily slots.sort(key=lambda x: (x[1], x[0])) # Initialize the end time of the last delivered flyer to -1 (before any possible time slot) last_end_time = -1 for start, end in slots: if start < last_end_time: # Found overlap return \\"NO\\" # Update the last end time to the end of the current slot last_end_time = end return \\"YES\\""},{"question":"def largest_subgrid_sum(grid: List[List[int]], subgrid_rows: int, subgrid_cols: int) -> int: Calculate the largest sum of numbers in any subgrid of a given size. Parameters: grid (List[List[int]]): A 2D list of integers. subgrid_rows (int): Number of rows in the subgrid. subgrid_cols (int): Number of columns in the subgrid. Returns: int: The largest sum of the elements in any subgrid of the given size. Example: >>> grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] >>> largest_subgrid_sum(grid, 2, 2) 28 from typing import List def test_largest_subgrid_sum_1(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert largest_subgrid_sum(grid, 2, 2) == 28 def test_largest_subgrid_sum_2(): grid = [ [1, -2, 3], [4, 5, -6], [7, 8, 9] ] assert largest_subgrid_sum(grid, 2, 2) == 24 def test_largest_subgrid_sum_3(): grid = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert largest_subgrid_sum(grid, 2, 2) == -12 def test_largest_subgrid_sum_4(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert largest_subgrid_sum(grid, 3, 3) == 9 def test_largest_subgrid_sum_5(): grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert largest_subgrid_sum(grid, 2, 2) == 54","solution":"from typing import List def largest_subgrid_sum(grid: List[List[int]], subgrid_rows: int, subgrid_cols: int) -> int: def calculate_prefix_sum(matrix): rows = len(matrix) cols = len(matrix[0]) prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] for r in range(1, rows + 1): for c in range(1, cols + 1): prefix_sum[r][c] = matrix[r-1][c-1] + prefix_sum[r-1][c] + prefix_sum[r][c-1] - prefix_sum[r-1][c-1] return prefix_sum rows = len(grid) cols = len(grid[0]) prefix_sum = calculate_prefix_sum(grid) max_sum = float('-inf') for r in range(subgrid_rows, rows + 1): for c in range(subgrid_cols, cols + 1): total = prefix_sum[r][c] - prefix_sum[r - subgrid_rows][c] - prefix_sum[r][c - subgrid_cols] + prefix_sum[r - subgrid_rows][c - subgrid_cols] if total > max_sum: max_sum = total return max_sum"},{"question":"from collections import deque from typing import List, Tuple def min_steps_to_destination(grid: List[str], n: int, start: Tuple[int, int], dest: Tuple[int, int]) -> int: Determine the minimum number of steps required to reach the destination from the start point in a grid. Args: grid (List[str]): The grid, where '.' represents a passable cell and '#' represents an impassable cell. n (int): The size of the grid (n x n). start (Tuple[int, int]): The starting point (row, column). dest (Tuple[int, int]): The destination point (row, column). Returns: int: The minimum number of steps required to reach the destination, or -1 if there is no valid path. Examples: >>> min_steps_to_destination( ... [\\".....\\", ... \\".#.\\", ... \\"...#.\\", ... \\".#.\\", ... \\".....\\"], 5, (0, 0), (4, 4)) 8 >>> min_steps_to_destination( ... [\\"...#\\", ... \\".#..\\", ... \\"....\\", ... \\".#..\\"], 4, (0, 0), (2, 2)) 4 >>> min_steps_to_destination( ... [\\"...\\", ... \\"#\\", ... \\"...\\"], 3, (0, 0), (2, 2)) -1 pass def solve(test_cases: List[dict]) -> List[int]: Solve multiple test cases of the min_steps_to_destination problem. Args: test_cases (List[dict]): A list of dictionaries, where each dictionary contains: - 'n' (int): The size of the grid. - 'grid' (List[str]): The grid itself. - 'start' (Tuple[int, int]): The starting point. - 'dest' (Tuple[int, int]): The destination point. Returns: List[int]: The results for each test case. pass def test_min_steps_to_destination(): test_cases = [ { 'n': 5, 'grid': [ \\".....\\", \\".#.\\", \\"...#.\\", \\".#.\\", \\".....\\" ], 'start': (0, 0), 'dest': (4, 4) }, { 'n': 4, 'grid': [ \\"...#\\", \\".#..\\", \\"....\\", \\".#..\\" ], 'start': (0, 0), 'dest': (2, 2) } ] results = solve(test_cases) assert results == [8, 4] def test_no_path(): test_cases = [ { 'n': 3, 'grid': [ \\"...\\", \\"#\\", \\"...\\" ], 'start': (0, 0), 'dest': (2, 2) }, { 'n': 4, 'grid': [ \\"..#.\\", \\".#.#\\", \\"#.#.\\", \\".#..\\" ], 'start': (0, 0), 'dest': (3, 3) } ] results = solve(test_cases) assert results == [-1, -1] def test_single_cell(): test_cases = [ { 'n': 1, 'grid': [ \\".\\" ], 'start': (0, 0), 'dest': (0, 0) } ] results = solve(test_cases) assert results == [0] def test_large_grid(): test_cases = [ { 'n': 5, 'grid': [ \\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\" ], 'start': (0, 0), 'dest': (4, 4) } ] results = solve(test_cases) assert results == [8]","solution":"from collections import deque def min_steps_to_destination(grid, n, start, dest): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * n for _ in range(n)] queue = deque([(start[0], start[1], 0)]) # (row, col, step_count) visited[start[0]][start[1]] = True while queue: x, y, steps = queue.popleft() if (x, y) == dest: return steps for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1 def solve(test_cases): results = [] for case in test_cases: n = case['n'] grid = case['grid'] start = case['start'] dest = case['dest'] result = min_steps_to_destination(grid, n, start, dest) results.append(result) return results"},{"question":"def find_max_in_region(grid: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Finds the maximum value in the specified regions for each query. Parameters: grid: List[List[int]]: 2D list representing the grid of treasures. queries: List[Tuple[int, int, int, int]]: Each tuple contains 4 integers representing the coordinates of the top-left and bottom-right corners of a rectangular region. Returns: List[int]: List of maximum values for each query. pass # Unit tests def test_single_query(): grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20] ] queries = [(1, 1, 2, 2)] assert find_max_in_region(grid, queries) == [7] def test_multiple_queries(): grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20] ] queries = [(1, 1, 2, 2), (2, 3, 4, 5)] assert find_max_in_region(grid, queries) == [7, 20] def test_edge_case_single_cell(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(2, 2, 2, 2)] assert find_max_in_region(grid, queries) == [5] def test_entire_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 3, 3)] assert find_max_in_region(grid, queries) == [9] def test_negative_values(): grid = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] queries = [(1, 1, 3, 3)] assert find_max_in_region(grid, queries) == [-1] def test_mixed_values(): grid = [ [-1, 2, 3], [4, -5, 6], [-7, 8, -9] ] queries = [(1, 1, 2, 2), (2, 2, 3, 3)] assert find_max_in_region(grid, queries) == [4, 8]","solution":"def find_max_in_region(grid, queries): Finds the maximum value in the specified regions for each query. Parameters: grid: List[List[int]]: 2D list representing the grid of treasures. queries: List[Tuple[int, int, int, int]]: Each tuple contains 4 integers representing the coordinates of the top-left and bottom-right corners of a rectangular region. Returns: List[int]: List of maximum values for each query. max_values = [] for x1, y1, x2, y2 in queries: max_value = float('-inf') for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): if grid[i][j] > max_value: max_value = grid[i][j] max_values.append(max_value) return max_values"},{"question":"def max_buildings_deleted(n: int, heights: List[int]) -> int: Given the number of buildings and their heights, return the maximum number of buildings that can be deleted by performing the special operation of deleting three consecutive buildings. :param n: int Number of buildings :param heights: list of int Heights of the buildings :return: int Maximum number of buildings that can be deleted >>> max_buildings_deleted(8, [3, 1, 4, 1, 5, 9, 2, 6]) 6 >>> max_buildings_deleted(1, [5]) 0 >>> max_buildings_deleted(2, [5, 3]) 0 >>> max_buildings_deleted(3, [1, 2, 3]) 3 >>> max_buildings_deleted(5, [5, 5, 5, 5, 5]) 3 >>> max_buildings_deleted(6, [1, 2, 3, 4, 5, 6]) 6 >>> max_buildings_deleted(1000, [i for i in range(1, 1001)]) 999","solution":"def max_buildings_deleted(n, heights): Given the number of buildings and their heights, return the maximum number of buildings that can be deleted by performing the special operation of deleting three consecutive buildings. :param n: int Number of buildings :param heights: list of int Heights of the buildings :return: int Maximum number of buildings that can be deleted # The maximum number of buildings that can be deleted is simply # the number of triplets that can be formed from the total buildings return (n // 3) * 3"},{"question":"def max_sum_submatrix(matrix): Given a matrix of size n x m, return the maximum sum of any sub-matrix. >>> max_sum_submatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ...]) 45 >>> max_sum_submatrix([ ... [6], ... [2], ... [5], ... [1] ...]) 14 >>> max_sum_submatrix([ ... [5] ...]) 5 >>> max_sum_submatrix([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ...]) 29 >>> max_sum_submatrix([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ...]) 136","solution":"def max_sum_submatrix(matrix): Given a matrix of size n x m, return the maximum sum of any sub-matrix. def kadane(arr): Calculates the maximum sum of a subarray using Kadane's algorithm. max_so_far = -float('inf') max_ending_here = 0 for x in arr: max_ending_here += x if max_so_far < max_ending_here: max_so_far = max_ending_here if max_ending_here < 0: max_ending_here = 0 return max_so_far n, m = len(matrix), len(matrix[0]) max_sum = -float('inf') # Temporary array to store the sum of elements for a particular left-right column pair. for left in range(m): temp = [0] * n for right in range(left, m): for row in range(n): temp[row] += matrix[row][right] max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"def process_queries(t: int, test_cases: list) -> list: Given an integer array consisting of n elements, process multiple queries. Queries are of the following types: 1. Find the sum of elements in the range (l, r) inclusive. 2. Update the value of the element at index i to a new value v. Example: >>> input_data = [ ... { ... 'n': 5, ... 'q': 5, ... 'array': [1, 2, 3, 4, 5], ... 'queries': [ ... (1, 1, 3), ... (2, 3, 6), ... (1, 1, 3), ... (1, 2, 4), ... (2, 4, 7), ... (1, 1, 5) ... ] ... } ... ] >>> process_queries(1, input_data) [6, 9, 12, 21] >>> input_data = [ ... { ... 'n': 6, ... 'q': 3, ... 'array': [7, 1, 3, 0, 5, 6], ... 'queries': [ ... (1, 2, 5), ... (2, 4, 10), ... (1, 1, 6) ... ] ... } ... ] >>> process_queries(1, input_data) [9, 32] >>> input_data = [ ... { ... 'n': 3, ... 'q': 2, ... 'array': [3, 3, 3], ... 'queries': [ ... (1, 1, 2), ... (2, 2, 4) ... ] ... }, ... { ... 'n': 4, ... 'q': 1, ... 'array': [1, 5, 2, 9], ... 'queries': [ ... (1, 1, 4) ... ] ... } ... ] >>> process_queries(2, input_data) [6, 17]","solution":"def process_queries(t, test_cases): results = [] for case in test_cases: n, q = case['n'], case['q'] array = case['array'] prefix_sum = [0] * (n + 1) # Build the initial prefix sum array for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] for query in case['queries']: if query[0] == 1: l, r = query[1], query[2] sum_range = prefix_sum[r] - prefix_sum[l - 1] results.append(sum_range) elif query[0] == 2: i, v = query[1], query[2] diff = v - array[i - 1] array[i - 1] = v # Update prefix sum from index i to n for j in range(i, n + 1): prefix_sum[j] += diff return results"},{"question":"def maximize_difficulties(n, k, p, challenges): Determines the maximum number of different difficulty levels that can be practiced within the time limit of p minutes. :param n: Total number of coding challenges. :param k: Number of challenges the Smart Bee plans to practice. :param p: Total available minutes. :param challenges: List of tuples (difficulty, duration) for each challenge. :return: Maximum number of different difficulty levels. # Unit tests def test_maximize_difficulties_example(): n, k, p = 5, 3, 120 challenges = [(1, 30), (2, 40), (3, 50), (2, 70), (1, 60)] assert maximize_difficulties(n, k, p, challenges) == 3 def test_maximize_difficulties_not_enough_time(): n, k, p = 5, 3, 60 challenges = [(1, 30), (2, 40), (3, 50), (2, 70), (1, 60)] assert maximize_difficulties(n, k, p, challenges) == 1 def test_maximize_difficulties_max_k(): n, k, p = 5, 5, 300 challenges = [(1, 30), (2, 40), (3, 50), (2, 70), (1, 60)] assert maximize_difficulties(n, k, p, challenges) == 3 def test_maximize_difficulties_all_same_difficulty(): n, k, p = 5, 3, 200 challenges = [(1, 30), (1, 60), (1, 90), (1, 20), (1, 50)] assert maximize_difficulties(n, k, p, challenges) == 1 def test_maximize_difficulties_unique_difficulties(): n, k, p = 5, 3, 200 challenges = [(5, 30), (4, 60), (3, 90), (2, 20), (1, 50)] assert maximize_difficulties(n, k, p, challenges) == 3 def test_maximize_difficulties_large_duration(): n, k, p = 5, 2, 1000 challenges = [(5, 300), (4, 600), (3, 900), (2, 200), (1, 500)] assert maximize_difficulties(n, k, p, challenges) == 2","solution":"def maximize_difficulties(n, k, p, challenges): Determines the maximum number of different difficulty levels that can be practiced within the time limit of p minutes. :param n: Total number of coding challenges. :param k: Number of challenges the Smart Bee plans to practice. :param p: Total available minutes. :param challenges: List of tuples (difficulty, duration) for each challenge. :return: Maximum number of different difficulty levels. # Sort challenges by duration primarily and by difficulty secondarily # This helps to pick up the shortest durations first to maximize the practice challenges = sorted(challenges, key=lambda x: (x[1], x[0])) selected_difficulties = set() total_duration = 0 practice_count = 0 for difficulty, duration in challenges: if practice_count < k and total_duration + duration <= p: total_duration += duration selected_difficulties.add(difficulty) practice_count += 1 return len(selected_difficulties) # Example input # n, k, p = 5, 3, 120 # challenges = [(1, 30), (2, 40), (3, 50), (2, 70), (1, 60)] # print(maximize_difficulties(n, k, p, challenges)) # Expected output: 3"},{"question":"def lexicographically_smallest_string(s: str) -> str: Select any two adjacent characters in the string and swap them to obtain the lexicographically smallest string. >>> lexicographically_smallest_string(\\"ab\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"ba\\") == \\"ab\\" >>> lexicographically_smallest_string(\\"cba\\") == \\"bca\\" >>> lexicographically_smallest_string(\\"abcd\\") == \\"abcd\\" >>> lexicographically_smallest_string(\\"zabc\\") == \\"azbc\\" >>> lexicographically_smallest_string(\\"zzzz\\") == \\"zzzz\\" >>> lexicographically_smallest_string(\\"acdb\\") == \\"acbd\\" pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process multiple test cases to find the lexicographically smallest string after swapping adjacent characters once. >>> T = 3 >>> test_cases = [\\"ab\\", \\"ba\\", \\"cba\\"] >>> process_test_cases(T, test_cases) == [\\"ab\\", \\"ab\\", \\"bca\\"] >>> T = 2 >>> test_cases = [\\"abcd\\", \\"dcba\\"] >>> process_test_cases(T, test_cases) == [\\"abcd\\", \\"cdba\\"] pass","solution":"def lexicographically_smallest_string(s): min_string = s n = len(s) for i in range(n - 1): # Create a new string by swapping adjacent characters new_string = s[:i] + s[i+1] + s[i] + s[i+2:] # Update the minimum string if the new one is smaller if new_string < min_string: min_string = new_string return min_string def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(lexicographically_smallest_string(s)) return results"},{"question":"def smallest_subarray_with_sum_k(arr, k): Returns the length of the smallest subarray with a sum of at least k. If no such subarray exists, returns -1. >>> smallest_subarray_with_sum_k([1, 2, 3, 4, 5, 6, 7, 8], 15) == 2 >>> smallest_subarray_with_sum_k([1, 2, 3, 4, 5], 11) == 3 >>> smallest_subarray_with_sum_k([1, 2, 3, 4, 5], 20) == -1 >>> smallest_subarray_with_sum_k([-1, 4, 2, 1, -6, 5], 5) == 2 >>> smallest_subarray_with_sum_k([5, 1, 4, 3, -1], 7) == 2 >>> smallest_subarray_with_sum_k([1]*100000, 50000) == 50000 >>> smallest_subarray_with_sum_k([1]*100000, 1000000000) == -1","solution":"from collections import deque def smallest_subarray_with_sum_k(arr, k): Returns the length of the smallest subarray with a sum of at least k. If no such subarray exists, returns -1. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"from typing import List, Union def find_pairs_with_sum(arr: List[int], t: int) -> Union[List[tuple], int]: Finds all unique pairs of numbers in the array that add up to the target sum t. Args: arr: List of integers representing the array. t: Target sum. Returns: List of tuples representing unique pairs of elements that sum up to t, or -1 if no such pairs exist. Examples: >>> find_pairs_with_sum([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum([1, 1, 1], 2) [(1, 1)] >>> find_pairs_with_sum([1, 1, 1, 1], 3) -1","solution":"def find_pairs_with_sum(arr, t): Finds all unique pairs of numbers in the array that add up to the target sum t. if not arr: return -1 pairs = [] seen = set() used = set() for number in arr: complement = t - number if complement in seen and (number not in used and complement not in used): pairs.append((min(number, complement), max(number, complement))) used.add(number) used.add(complement) seen.add(number) if pairs: pairs.sort() return pairs else: return -1"},{"question":"def three_sum(nums: List[int]) -> List[List[int]]: This function takes a list of integers and returns a list of lists containing all unique triplets that sum up to zero. :param nums: List[int] - a list of integers which can contain both positive and negative numbers :return: List[List[int]] - a list of lists of integers, each inner list containing three integers that sum up to zero >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([]) [] >>> three_sum([0]) []","solution":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: nums.sort() result = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicate elements left, right = i + 1, n - 1 while left < right: three_sum = nums[i] + nums[left] + nums[right] if three_sum < 0: left += 1 elif three_sum > 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) # Skip duplicate elements while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 return result"},{"question":"def min_swaps_to_sort(arr): This function returns the minimum number of swaps required to sort the array in non-descending order. >>> min_swaps_to_sort([4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> min_swaps_to_sort([1, 3, 5, 2, 4, 6]) 3 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) 0 def total_min_swaps_to_sort(arr_list): This function calculates the total minimum number of swaps to sort all arrays in arr_list. >>> total_min_swaps_to_sort([[4, 3, 2, 1], [1, 5, 4, 3, 2]]) 4 >>> total_min_swaps_to_sort([[1, 3, 5, 2, 4, 6], [1, 2, 3, 4, 5]]) 3 >>> total_min_swaps_to_sort([[4, 3, 2, 1], [4, 3, 2, 1]]) 4 >>> total_min_swaps_to_sort([[1,2,3], [2,3,1], [3,2,1]]) 3","solution":"def min_swaps_to_sort(arr): This function returns the minimum number of swaps required to sort the array in non-descending order. n = len(arr) arrpos = list(enumerate(arr)) arrpos.sort(key=lambda it: it[1]) vis = {k: False for k in range(n)} ans = 0 for i in range(n): if vis[i] or arrpos[i][0] == i: continue cycle_size = 0 x = i while not vis[x]: vis[x] = True x = arrpos[x][0] cycle_size += 1 if cycle_size > 0: ans += cycle_size - 1 return ans def total_min_swaps_to_sort(arr_list): This function calculates the total minimum number of swaps to sort all arrays in arr_list. total_swaps = 0 for arr in arr_list: total_swaps += min_swaps_to_sort(arr) return total_swaps"},{"question":"def max_subset_sum_no_adjacent(nums: List[int]) -> int: Find the maximum subset sum where no two elements are adjacent. >>> max_subset_sum_no_adjacent([3, 2, 5, 10, 7]) 15 >>> max_subset_sum_no_adjacent([]) 0 >>> max_subset_sum_no_adjacent([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 30 >>> max_subset_sum_no_adjacent([-1, -2, -3, -4, -5]) 0 >>> max_subset_sum_no_adjacent([3, -2, 5, 10, -7]) 13 >>> max_subset_sum_no_adjacent([3, -2, 5, 10, 7]) 15","solution":"def max_subset_sum_no_adjacent(nums): if not nums: return 0 elif len(nums) == 1: return max(0, nums[0]) n = len(nums) dp = [0] * n dp[0] = max(0, nums[0]) dp[1] = max(dp[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1] # Example usage: # nums = [3, 2, 5, 10, 7] # result = max_subset_sum_no_adjacent(nums) # print(result) # Output should be 15"},{"question":"def detect_cycle(n, m, edges): Zara is a software engineer who loves working with graphs. Given a connected undirected graph with \`n\` vertices and \`m\` edges, she wants to find if there exists any cycle in the graph. A cycle is defined as a path in which the first and last vertices are the same, and no other vertex is repeated. Your task is to help Zara determine if at least one cycle exists in the given graph. The input consists of two integers \`n\` (1 ≤ n ≤ 1000) and \`m\` (0 ≤ m ≤ 1000) — the number of vertices and edges in the graph, respectively. The next \`m\` lines contain two integers \`u\` and \`v\` (1 ≤ u, v ≤ n; u ≠ v) — denoting an edge between vertices \`u\` and \`v\`. There are no multiple edges between the same vertices and no self-loops in the graph. Output \\"YES\\" if there is at least one cycle in the graph. Otherwise, print \\"NO\\". >>> detect_cycle(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 2)]) \\"YES\\" >>> detect_cycle(3, 2, [(1, 2), (2, 3)]) \\"NO\\"","solution":"def detect_cycle(n, m, edges): from collections import defaultdict # Create a graph using adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): return \\"YES\\" return \\"NO\\""},{"question":"def find_road_lengths(n, roads, queries): Determine if there exists a valid set of road lengths that satisfy all given queries. Args: n (int): The number of houses in the city. roads (List[Tuple[int, int]]): A list of tuples, where each tuple represents a road connecting two houses. queries (List[Tuple[int, int, int]]): A list of queries where each query contains three integers: a house from which the resident starts, a house where the resident wants to reach, and the preferred minimum distance for the query. Returns: List[int] | int: A list of road lengths if a valid set of road lengths exist, otherwise -1. Example: >>> find_road_lengths(4, [(1, 2), (2, 3), (2, 4)], [(1, 3, 2), (1, 4, 2), (3, 4, 2)]) [1, 1, 1] >>> find_road_lengths(3, [(1, 2), (2, 3)], [(1, 3, 2), (1, 2, 1), (2, 3, 1)]) [1, 1] Test Cases: def test_case_1(): n = 4 roads = [(1, 2), (2, 3), (2, 4)] queries = [(1, 3, 2), (1, 4, 2), (3, 4, 2)] expected_output = [1, 1, 1] assert find_road_lengths(n, roads, queries) == expected_output def test_case_2(): n = 3 roads = [(1, 2), (2, 3)] queries = [(1, 3, 2), (1, 2, 1), (2, 3, 1)] expected_output = [1, 1] assert find_road_lengths(n, roads, queries) == expected_output def test_case_3(): n = 4 roads = [(1, 2), (1, 3), (2, 4)] queries = [(1, 4, 1), (2, 3, 2), (1, 3, 1)] expected_output = [1, 1, 1] assert find_road_lengths(n, roads, queries) == expected_output def test_case_4(): n = 2 roads = [(1, 2)] queries = [(1, 2, 1)] expected_output = [1] assert find_road_lengths(n, roads, queries) == expected_output def test_case_5(): n = 3 roads = [(1, 2), (2, 3)] queries = [(1, 3, 3), (1, 2, 1)] expected_output = -1 assert find_road_lengths(n, roads, queries) == expected_output","solution":"def find_road_lengths(n, roads, queries): # Initialize an adjacency list for the tree from collections import defaultdict import heapq graph = defaultdict(list) for x, y in roads: graph[x].append(y) graph[y].append(x) # The minimum possible distances from node a to node b def dijkstra(graph, start, n): distances = {node: float('infinity') for node in range(1, n + 1)} distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor in graph[current_node]: distance = current_distance + 1 # all edges have weight 1 if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances # Check all queries to ensure the given minimum distances are valid for a, b, d in queries: distances = dijkstra(graph, a, n) if distances[b] < d: return -1 # If all queries are satisfied, we can just assign arbitrary lengths (all lengths are 1) return [1] * (n - 1)"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Determine the maximum subarray sum within the sequence. :param arr: List of integers representing the sequence :return: Integer representing the maximum subarray sum >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([0, 0, 0, 0]) 0","solution":"def max_subarray_sum(arr): Determine the maximum subarray sum within the sequence. :param arr: List of integers representing the sequence :return: Integer representing the maximum subarray sum max_sum = float('-inf') current_sum = 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def compress_string(s: str, k: int) -> str: Compress the given string based on the specified algorithm. >>> compress_string(\\"aaabbbccc\\", 3) '3a3b3c' >>> compress_string(\\"aabbccc\\", 2) '2a2b2c1c' >>> compress_string(\\"abcdef\\", 1) '1a1b1c1d1e1f' >>> compress_string(\\"zzzz\\", 2) '2z2z'","solution":"def compress_string(s, k): from collections import Counter compressed_string = '' for i in range(0, len(s), k): substring = s[i:i+k] count = Counter(substring) most_common_char = min([char for char, freq in count.items() if freq == max(count.values())]) compressed_string += f'{len(substring)}{most_common_char}' return compressed_string"},{"question":"class SocialMediaPlatform: A social media platform where users can follow each other and post messages. Attributes: n (int): Number of users. q (int): Number of queries. user_descriptors (list): List of strings describing user follow relationships. Methods: post_message(u, t, m): Posts a message from user \`u\` at timestamp \`t\` with content \`m\`. delete_message(u, t): Deletes the message posted by user \`u\` at timestamp \`t\`. get_timeline(u): Retrieves the timeline for user \`u\`, including posts from users they follow. process_query(query): Processes a given query and performs appropriate actions. def __init__(self, n, q, user_descriptors): # Implement the constructor to initialize attributes. pass def post_message(self, u, t, m): # Implement posting of message. pass def delete_message(self, u, t): # Implement deletion of message. pass def get_timeline(self, u): # Implement retrieval of timeline. pass def process_query(self, query): # Implement query processing. pass def test_post_and_timeline(): platform = SocialMediaPlatform(3, 4, [\\"1\\", \\"2 1\\", \\"3 1 2\\"]) assert platform.process_query(\\"post 1 100 hello\\") is None assert platform.process_query(\\"post 2 101 world\\") is None timeline_3 = platform.process_query(\\"timeline 3\\") assert timeline_3 == [(100, \\"hello\\"), (101, \\"world\\")] def test_delete_message(): platform = SocialMediaPlatform(3, 4, [\\"1\\", \\"2 1\\", \\"3 1 2\\"]) platform.process_query(\\"post 1 100 hello\\") platform.process_query(\\"post 2 101 world\\") platform.process_query(\\"delete 2 101\\") timeline_3 = platform.process_query(\\"timeline 3\\") assert timeline_3 == [(100, \\"hello\\")] def test_multi_user_follow(): platform = SocialMediaPlatform(4, 6, [\\"1\\", \\"2 1\\", \\"3 1 2\\", \\"4 1 2 3\\"]) platform.process_query(\\"post 1 100 hey\\") platform.process_query(\\"post 2 101 there\\") platform.process_query(\\"post 3 102 howdy\\") platform.process_query(\\"post 4 103 hola\\") timeline_4 = platform.process_query(\\"timeline 4\\") assert timeline_4 == [(100, \\"hey\\"), (101, \\"there\\"), (102, \\"howdy\\"), (103, \\"hola\\")] def test_empty_timeline(): platform = SocialMediaPlatform(2, 2, [\\"1\\", \\"2 1\\"]) assert platform.process_query(\\"timeline 2\\") == []","solution":"class SocialMediaPlatform: def __init__(self, n, q, user_descriptors): self.n = n # number of users self.q = q # number of queries self.follows = {} # dictionary to store following relationships self.posts = {} # dictionary to store posts for descriptor in user_descriptors: parts = descriptor.split() user = int(parts[0]) followers = list(map(int, parts[1:])) self.follows[user] = followers self.posts[user] = [] def post_message(self, u, t, m): self.posts[u].append((t, m)) def delete_message(self, u, t): self.posts[u] = [post for post in self.posts[u] if post[0] != t] def get_timeline(self, u): timeline = [] users_to_collect = self.follows[u] + [u] for user in users_to_collect: timeline.extend(self.posts[user]) timeline.sort(key=lambda x: x[0]) return timeline def process_query(self, query): parts = query.split(maxsplit=2) action = parts[0] if action == 'post': u, t, m = int(parts[1]), int(parts[2].split()[0]), parts[2].split(' ', 1)[1] self.post_message(u, t, m) elif action == 'delete': u, t = int(parts[1]), int(parts[2]) self.delete_message(u, t) elif action == 'timeline': u = int(parts[1]) return self.get_timeline(u) return None"},{"question":"def optimize_delivery_requests(m: int, requests: List[Tuple[int, int]], k: int, C: int) -> int: Determines the maximum number of delivery requests that can be fulfilled without any truck exceeding its load capacity. :param m: Integer representing the number of delivery requests. :param requests: List of \`m\` tuples, each containing two integers: weight \`wi\` and location identifier \`li\`. :param k: Integer representing the number of trucks. :param C: Integer representing the maximum load capacity of each truck. :return: Integer representing the maximum number of delivery requests that can be fulfilled. Examples: >>> optimize_delivery_requests(5, [(10, 1), (15, 2), (7, 1), (8, 3), (5, 2)], 2, 20) 4 >>> optimize_delivery_requests(3, [(5, 1), (20, 1), (10, 2)], 1, 15) 2 from typing import List, Tuple def test_optimize_delivery_requests_example1(): assert optimize_delivery_requests(5, [(10, 1), (15, 2), (7, 1), (8, 3), (5, 2)], 2, 20) == 4 def test_optimize_delivery_requests_example2(): assert optimize_delivery_requests(3, [(5, 1), (20, 1), (10, 2)], 1, 15) == 2 def test_optimize_delivery_requests_all_requests_fulfilled(): assert optimize_delivery_requests(4, [(5, 1), (10, 2), (8, 3), (6, 4)], 2, 30) == 4 def test_optimize_delivery_requests_no_requests_fulfilled(): assert optimize_delivery_requests(3, [(50, 1), (60, 2), (70, 3)], 1, 10) == 0 def test_optimize_delivery_requests_large_capacity(): assert optimize_delivery_requests(6, [(10, 1), (15, 2), (10, 3), (25, 4), (5, 5), (20, 6)], 3, 50) == 6 def test_optimize_delivery_requests_varied_weights(): assert optimize_delivery_requests(5, [(9, 1), (11, 2), (8, 3), (12, 4), (7, 5)], 2, 20) == 4","solution":"def optimize_delivery_requests(m, requests, k, C): The function to optimize the delivery requests within the constraints of trucks and their capacities. :param m: Number of delivery requests :param requests: List of tuples containing the weight of the delivery and location identifier :param k: Number of trucks :param C: Maximum load capacity of each truck :return: Maximum number of delivery requests that can be fulfilled # Sort the delivery requests based on weight in ascending order requests.sort() # We will use a list to keep track of load capacities for each truck truck_capacities = [0] * k # Keep track of the number of fulfilled requests fulfilled_requests = 0 # Try to allocate each request to one of the trucks for weight, location in requests: for i in range(k): if truck_capacities[i] + weight <= C: truck_capacities[i] += weight fulfilled_requests += 1 break return fulfilled_requests"},{"question":"def can_see_front(n: int, heights: List[int]) -> int: Returns the number of people who can see the person standing immediately in front of them. Parameters: n (int): The number of people in the line. heights (list of int): The heights of people in the line. Returns: int: The number of people who can see the person standing immediately in front of them. Examples: >>> can_see_front(6, [4, 3, 7, 6, 3, 8]) 3 >>> can_see_front(1, [5]) 1 >>> can_see_front(4, [1, 2, 3, 4]) 4 >>> can_see_front(4, [4, 3, 2, 1]) 1 >>> can_see_front(5, [10, 1, 10, 1, 10]) 3 >>> can_see_front(5, [5, 5, 5, 5, 5]) 5","solution":"def can_see_front(n, heights): Returns the number of people who can see the person standing immediately in front of them. Parameters: n (int): The number of people in the line. heights (list of int): The heights of people in the line. Returns: int: The number of people who can see the person standing immediately in front of them. if n == 1: return 1 # Only one person, they can see the front because there's nobody to block them. can_see_count = 1 # The first person can always see the front for i in range(1, n): if heights[i] >= heights[i-1]: can_see_count += 1 return can_see_count"},{"question":"def minimum_water_stations(L, N, C, M, segments, R): Returns the minimum number of water stations required to serve all segments. If it's not possible to serve all segments with the given stations, returns -1. pass # Unit tests def test_minimum_water_stations_example(): assert minimum_water_stations(1000, 10, 100, 3, [(100, 500), (400, 800), (700, 1000)], 2) == 4 def test_minimum_water_stations_insufficient_stations(): assert minimum_water_stations(1000, 3, 100, 3, [(100, 500), (400, 800), (700, 1000)], 2) == -1 def test_minimum_water_stations_exact_fit(): assert minimum_water_stations(1000, 6, 100, 3, [(100, 500), (400, 600), (700, 1000)], 2) == 4 def test_minimum_water_stations_single_segment(): assert minimum_water_stations(500, 5, 100, 1, [(100, 200)], 2) == 2 def test_minimum_water_stations_no_overlapping_segments(): assert minimum_water_stations(1000, 10, 100, 3, [(100, 200), (300, 400), (500, 600)], 1) == 1 def test_minimum_water_stations_no_segments(): assert minimum_water_stations(1000, 10, 100, 0, [], 1) == 0","solution":"def minimum_water_stations(L, N, C, M, segments, R): Returns the minimum number of water stations required to serve all segments. If it's not possible to serve all segments with the given stations, returns -1. station_coverage = [0] * (L + 1) for start, end in segments: for i in range(start, end): station_coverage[i] += 1 max_stations_needed = max(station_coverage) if max_stations_needed * R <= N: return max_stations_needed * R else: return -1 # Example usage L = 1000 N = 10 C = 100 M = 3 segments = [(100, 500), (400, 800), (700, 1000)] R = 2 print(minimum_water_stations(L, N, C, M, segments, R)) # Output: 4"},{"question":"def longest_repeated_substring(s: str) -> str: Find the longest repeated substring within the given string. A substring is considered repeated if it appears at least twice in the string and the occurrences do not overlap. If there is more than one substring with the maximum length, return the lexicographically smallest one. If there is no repeated substring, return an empty string. Parameters: s (str): A string consisting of lowercase English letters. Returns: str: The longest repeated substring or an empty string if no such substring exists. >>> longest_repeated_substring(\\"banana\\") 'ana' >>> longest_repeated_substring(\\"abcd\\") '' >>> longest_repeated_substring(\\"abcabcabc\\") 'abcabc' from solution import longest_repeated_substring def test_example1(): assert longest_repeated_substring(\\"banana\\") == \\"ana\\" def test_example2(): assert longest_repeated_substring(\\"abcd\\") == \\"\\" def test_example3(): assert longest_repeated_substring(\\"abcabcabc\\") == \\"abcabc\\" def test_single_repeated_char(): assert longest_repeated_substring(\\"aaaaa\\") == \\"aaaa\\" def test_non_repeated_chars(): assert longest_repeated_substring(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"\\" def test_mixed_repeated_chars(): assert longest_repeated_substring(\\"abcdefgabcabcabcd\\") == \\"abcabc\\" def test_empty_string(): assert longest_repeated_substring(\\"\\") == \\"\\" def test_lexicographically_smallest(): assert longest_repeated_substring(\\"abracadabra\\") == \\"abra\\"","solution":"def longest_repeated_substring(s: str) -> str: def get_suffix_array(s: str): return sorted(range(len(s)), key=lambda i: s[i:]) def lcp(s: str, suffix_array: list): n = len(s) rank = [0] * n lcp_array = [0] * (n - 1) for i, suffix in enumerate(suffix_array): rank[suffix] = i h = 0 for i in range(n): if rank[i] > 0: j = suffix_array[rank[i] - 1] while i + h < n and j + h < n and s[i + h] == s[j + h]: h += 1 lcp_array[rank[i] - 1] = h if h > 0: h -= 1 return lcp_array suffix_array = get_suffix_array(s) lcp_array = lcp(s, suffix_array) max_len = 0 idx = 0 for i in range(len(lcp_array)): if lcp_array[i] > max_len: max_len = lcp_array[i] idx = i if max_len == 0: return \\"\\" else: return s[suffix_array[idx]:suffix_array[idx] + max_len]"},{"question":"def max_subsequence_length(s: str, k: int, l: int) -> int: Returns the length of the longest subsequence that contains exactly k 'a's and l 'b's. If no such subsequence exists, returns -1. >>> max_subsequence_length(\\"abbaba\\", 2, 1) == 4 >>> max_subsequence_length(\\"aabb\\", 2, 2) == 4 >>> max_subsequence_length(\\"aabb\\", 3, 2) == -1 >>> max_subsequence_length(\\"aabb\\", 0, 0) == 0 >>> max_subsequence_length(\\"baba\\", 1, 1) == 2","solution":"def max_subsequence_length(s, k, l): Returns the length of the longest subsequence that contains exactly k 'a's and l 'b's. If no such subsequence exists, returns -1. count_a = s.count('a') count_b = s.count('b') # If there are not enough 'a's or 'b's in the string if count_a < k or count_b < l: return -1 result = k + l # To form a sequence of exactly k 'a's and l 'b's, the minimum sequence length required # is the sum of k and l because it can be any permutation of the indices return result"},{"question":"def max_widgets(n: int, m: int, materials: List[int]) -> int: Determines the maximum number of different types of widgets the factory can produce without exceeding the total material limit. Parameters: n (int): Number of different types of widgets. m (int): Total amount of material available. materials (list of int): Amount of material required for each type of widget. Returns: int: The maximum number of different types of widgets the factory can produce. >>> max_widgets(3, 6, [3, 2, 1]) 3 >>> max_widgets(4, 6, [5, 4, 3, 2]) 2 >>> max_widgets(1, 1, [1]) 1 >>> max_widgets(1, 0, [1]) 0 >>> max_widgets(3, 5, [2, 4, 6]) 1 >>> max_widgets(5, 15, [1, 2, 3, 4, 5]) 5 >>> max_widgets(5, 10, [5, 4, 3, 2, 1]) 4 >>> max_widgets(6, 20, [7, 5, 3, 2, 8, 10]) 4 pass","solution":"def max_widgets(n, m, materials): Determines the maximum number of different types of widgets the factory can produce without exceeding the total material limit. Parameters: n (int): Number of different types of widgets. m (int): Total amount of material available. materials (list of int): Amount of material required for each type of widget. Returns: int: The maximum number of different types of widgets the factory can produce. materials.sort() total_material_used = 0 widget_count = 0 for material in materials: if total_material_used + material <= m: total_material_used += material widget_count += 1 else: break return widget_count"},{"question":"def max_length_subarray_two_distinct(arr: List[int]) -> int: Returns the maximum length of a contiguous subarray containing at most two distinct integers. >>> max_length_subarray_two_distinct([1, 2, 1, 3, 4, 2, 3]) == 3 >>> max_length_subarray_two_distinct([1, 2, 1, 2, 3]) == 4 >>> max_length_subarray_two_distinct([0, 1, 2, 2]) == 3 >>> max_length_subarray_two_distinct([1, 2, 3, 4, 5]) == 2 >>> max_length_subarray_two_distinct([]) == 0 >>> max_length_subarray_two_distinct([1, 2]) == 2 >>> max_length_subarray_two_distinct([1, 1, 1, 2, 3, 3, 3, 3]) == 5","solution":"def max_length_subarray_two_distinct(arr): Returns the maximum length of a contiguous subarray containing at most two distinct integers. if not arr: return 0 max_length = 0 left = 0 hashmap = {} for right in range(len(arr)): if arr[right] in hashmap: hashmap[arr[right]] += 1 else: hashmap[arr[right]] = 1 while len(hashmap) > 2: hashmap[arr[left]] -= 1 if hashmap[arr[left]] == 0: del hashmap[arr[left]] left += 1 current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def can_schedule(existing_appointments: List[Tuple[str, str]], new_appointment: Tuple[str, str]) -> bool: Determine if a new appointment can be added to the schedule without overlapping any existing appointments. >>> can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\"), (\\"13:30\\", \\"14:30\\")], (\\"10:30\\", \\"11:30\\")) True >>> can_schedule([(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:30\\"), (\\"12:00\\", \\"13:00\\")], (\\"10:00\\", \\"11:00\\")) False def test_no_existing_appointments(): existing_appointments = [] new_appointment = (\\"10:00\\", \\"11:00\\") assert can_schedule(existing_appointments, new_appointment) == True def test_no_overlap_early_appointments(): existing_appointments = [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")] new_appointment = (\\"10:00\\", \\"11:00\\") assert can_schedule(existing_appointments, new_appointment) == True def test_no_overlap_late_appointments(): existing_appointments = [(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\")] new_appointment = (\\"11:00\\", \\"12:00\\") assert can_schedule(existing_appointments, new_appointment) == True def test_no_overlap_middle_appointments(): existing_appointments = [(\\"09:00\\", \\"10:00\\"), (\\"12:00\\", \\"13:00\\")] new_appointment = (\\"10:30\\", \\"11:30\\") assert can_schedule(existing_appointments, new_appointment) == True def test_overlap_start_appointment(): existing_appointments = [(\\"09:00\\", \\"10:30\\"), (\\"11:00\\", \\"12:00\\")] new_appointment = (\\"10:00\\", \\"11:00\\") assert can_schedule(existing_appointments, new_appointment) == False def test_overlap_end_appointment(): existing_appointments = [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")] new_appointment = (\\"10:30\\", \\"11:30\\") assert can_schedule(existing_appointments, new_appointment) == False def test_overlap_existing_appointment_entirely(): existing_appointments = [(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:30\\")] new_appointment = (\\"09:30\\", \\"11:00\\") assert can_schedule(existing_appointments, new_appointment) == False def test_same_time_as_existing(): existing_appointments = [(\\"09:00\\", \\"10:00\\"), (\\"11:00\\", \\"12:00\\")] new_appointment = (\\"09:00\\", \\"10:00\\") assert can_schedule(existing_appointments, new_appointment) == False","solution":"from typing import List, Tuple def can_schedule(existing_appointments: List[Tuple[str, str]], new_appointment: Tuple[str, str]) -> bool: new_start, new_end = new_appointment for existing_start, existing_end in existing_appointments: if not (new_end <= existing_start or new_start >= existing_end): return False return True"},{"question":"def minimum_types_of_treasures(N: int, roads: List[Tuple[int, int]]) -> int: Calculate the minimum number of different types of treasures needed ensuring no two landmarks connected by a direct road have the same type. Arguments: N -- number of landmarks (nodes) roads -- list of tuples (u, v) representing the roads (edges) Returns: int -- minimum number of types required >>> minimum_types_of_treasures(1, []) 1 >>> minimum_types_of_treasures(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 2","solution":"def minimum_types_of_treasures(N, roads): Calculate the minimum number of different types of treasures needed ensuring no two landmarks connected by a direct road have the same type. Arguments: N -- number of landmarks (nodes) roads -- list of tuples (u, v) representing the roads (edges) Returns: int -- minimum number of types required if N == 1: # Only one landmark, so only one type of treasure is needed return 1 # For a structure that is a tree, with N nodes and N-1 edges, it's a bipartite graph. # A bipartite graph can be colored using at most 2 colors (types of treasures). # Hence the answer is always 2 if there are more than one node. return 2"},{"question":"def min_operations_to_transform_string(n: int, a: str, b: str) -> int: Returns the minimum number of operations required to transform string a into string b. >>> min_operations_to_transform_string(5, \\"abcde\\", \\"bcdea\\") 5 >>> min_operations_to_transform_string(3, \\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform_string(4, \\"abcd\\", \\"abcf\\") 1 >>> min_operations_to_transform_string(4, \\"aabb\\", \\"bbaa\\") 4 >>> min_operations_to_transform_string(6, \\"abcdef\\", \\"fedcba\\") 6 >>> min_operations_to_transform_string(2, \\"az\\", \\"bz\\") 1 >>> min_operations_to_transform_string(3, \\"aaa\\", \\"aab\\") 1 >>> min_operations_to_transform_string(3, \\"abc\\", \\"xyz\\") 3 >>> min_operations_to_transform_string(1, \\"a\\", \\"b\\") 1 >>> min_operations_to_transform_string(1, \\"a\\", \\"a\\") 0","solution":"def min_operations_to_transform_string(n, a, b): Returns the minimum number of operations required to transform string a into string b. # Initialize the count of operations required operations = 0 # Iterate over each character in strings a and b for i in range(n): # If characters at position i are different, increment the operation count if a[i] != b[i]: operations += 1 return operations"},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 2) 2 >>> unique_paths(5, 5) 70 >>> unique_paths(10, 10) 48620 >>> unique_paths(15, 15) 40116600","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a m x n grid. # Initialize a 2D list (matrix) with 1s; since there's exactly one way to reach each cell in the first row and first column. dp = [[1] * n for _ in range(m)] # Iterate over the cells starting from (1,1) since (0,0), first row and first column have only one way (rightward or downward respectively) for i in range(1, m): for j in range(1, n): # Number of ways to reach cell (i, j) is the sum of ways to reach from top (i-1, j) and from left (i, j-1) dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def number_of_paths(m: int, sections: List[Tuple[int, int]]) -> int: Calculate the number of different paths from the first section to the last section in a garden. The function takes an integer m (the number of sections) and a list of tuples (each containing two integers) that represents the number of plots in each section. It returns the number of paths from the first section to the last section, modulo 1000000007. >>> number_of_paths(3, [(1,2), (2,3), (3,4)]) == 24 >>> number_of_paths(1, [(1,1)]) == 1","solution":"def number_of_paths(m, sections): MOD = 1000000007 # Start with one plot in the first section paths = 1 for c_i, d_i in sections: paths = (paths * d_i) % MOD return paths # Example usage # m = 3 # sections = [(1,2), (2,3), (3,4)] # print(number_of_paths(m, sections)) # Output should be 24 modulo 1000000007"},{"question":"def decode_strings(T, strings): Decode each string by replacing each letter with its lexicographically next letter. The letter 'z' wraps around to 'a'. Args: T (int): The number of test cases. strings (List[str]): A list of encoded strings. Returns: List[str]: A list of decoded strings. Examples: >>> decode_strings(3, [\\"abc\\", \\"xyz\\", \\"hello\\"]) ['bcd', 'yza', 'ifmmp'] # Your code here # Example usage: print(decode_strings(3, [\\"abc\\", \\"xyz\\", \\"hello\\"])) # Output should be: # ['bcd', 'yza', 'ifmmp']","solution":"def decode_strings(T, strings): def next_letter(letter): return 'a' if letter == 'z' else chr(ord(letter) + 1) decoded_strings = [] for s in strings: decoded_string = ''.join(next_letter(c) for c in s) decoded_strings.append(decoded_string) return decoded_strings # Example usage: # print(decode_strings(3, [\\"abc\\", \\"xyz\\", \\"hello\\"])) # Output: ['bcd', 'yza', 'ifmmp']"},{"question":"def find_central_camping_site_spots(n: int, spots: List[Tuple[int, int]]) -> Tuple[int, int]: Finds the central camping site (a, b) that minimizes the maximum distance to all potential spots. :param n: Number of potential camping spots (1 <= n <= 100) :param spots: List of tuples representing the coordinates (xi, yi) of each spot (0 <= xi, yi <= 1000) :return: Tuple (a, b) which are the coordinates of the central camping site >>> find_central_camping_site_spots(3, [(0, 0), (0, 2), (2, 2)]) (1, 1) >>> find_central_camping_site_spots(2, [(0, 0), (2, 2)]) (1, 1)","solution":"import math def find_central_camping_site_spots(n, spots): Finds the central camping site (a, b) that minimizes the maximum distance to all potential spots. :param n: Number of potential camping spots (1 <= n <= 100) :param spots: List of tuples representing the coordinates (xi, yi) of each spot (0 <= xi, yi <= 1000) :return: Tuple (a, b) which are the coordinates of the central camping site xs = [x for x, y in spots] ys = [y for x, y in spots] min_x = min(xs) max_x = max(xs) min_y = min(ys) max_y = max(ys) best_x = (min_x + max_x) // 2 best_y = (min_y + max_y) // 2 return best_x, best_y"},{"question":"from typing import List, Tuple def count_distinct_chars(S: str, l: int, r: int) -> int: Returns the number of distinct characters in the substring S[l-1:r]. Parameters: S (str): The input string. l (int): The starting index of the substring (1-based). r (int): The ending index of the substring (1-based). Returns: int: The number of distinct characters in the substring. pass def process_queries(S: str, queries: List[Tuple[int, int]]) -> List[int]: Processes a list of queries and returns the result for each using the count_distinct_chars function. Parameters: S (str): The input string. queries (list of tuples): A list of queries where each query is a tuple (l, r). Returns: list of int: A list of results, one for each query. pass def test_count_distinct_chars_single_query(): assert count_distinct_chars(\\"abcdef\\", 1, 3) == 3 assert count_distinct_chars(\\"aaaaaa\\", 1, 6) == 1 assert count_distinct_chars(\\"abcabc\\", 1, 6) == 3 assert count_distinct_chars(\\"abcabc\\", 2, 5) == 3 assert count_distinct_chars(\\"abcabc\\", 2, 4) == 3 assert count_distinct_chars(\\"aabbcc\\", 1, 4) == 2 def test_process_queries_multiple(): S = \\"abcabc\\" queries = [(1, 3), (1, 6), (2, 5), (4, 6)] expected_results = [3, 3, 3, 3] assert process_queries(S, queries) == expected_results S = \\"aabbcc\\" queries = [(1, 2), (3, 4), (5, 6), (1, 6)] expected_results = [1, 1, 1, 3] assert process_queries(S, queries) == expected_results S = \\"aaaaaa\\" queries = [(1, 1), (1, 2), (1, 3), (1, 6)] expected_results = [1, 1, 1, 1] assert process_queries(S, queries) == expected_results","solution":"def count_distinct_chars(S, l, r): Returns the number of distinct characters in the substring S[l-1:r] substring = S[l-1:r] return len(set(substring)) def process_queries(S, queries): Processes a list of queries and returns the result for each using the count_distinct_chars function. Parameters: S (str): The input string. queries (list of tuples): A list of queries where each query is a tuple (l, r). Returns: list of int: A list of results, one for each query. results = [] for l, r in queries: results.append(count_distinct_chars(S, l, r)) return results"},{"question":"def island_perimeter(grid: List[List[int]]) -> int: Returns the perimeter of the island in the given grid. Example 1: >>> grid1 = [ ... [0,1,0,0], ... [1,1,1,0], ... [0,1,0,0], ... [1,1,0,0] ... ] >>> island_perimeter(grid1) 16 Example 2: >>> grid2 = [[1]] >>> island_perimeter(grid2) 4 Example 3: >>> grid3 = [[1, 0]] >>> island_perimeter(grid3) 4","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given grid. perimeter = 0 rows = len(grid) cols = len(grid[0]) for i in range(rows): for j in range(cols): if grid[i][j] == 1: # Check top if i == 0 or grid[i-1][j] == 0: perimeter += 1 # Check bottom if i == rows-1 or grid[i+1][j] == 0: perimeter += 1 # Check left if j == 0 or grid[i][j-1] == 0: perimeter += 1 # Check right if j == cols-1 or grid[i][j+1] == 0: perimeter += 1 return perimeter"},{"question":"def process_queries(queries: List[str]) -> str: Given a list of queries, process them and output the content of the sequence. Operations: - \\"add x\\" appends x to the sequence - \\"remove x\\" removes the first instance of x from the sequence Returns: - A string with space-separated integers representing the sequence after all queries are processed, or \\"empty\\" if the sequence is empty. >>> process_queries([\\"add 1\\"]) == \\"1\\" >>> process_queries([\\"add 1\\", \\"add 2\\", \\"add 3\\"]) == \\"1 2 3\\" >>> process_queries([\\"add 1\\", \\"add 2\\", \\"remove 1\\", \\"add 3\\"]) == \\"2 3\\" >>> process_queries([\\"add 1\\", \\"remove 2\\"]) == \\"1\\" >>> process_queries([\\"remove 1\\"]) == \\"empty\\" >>> process_queries([\\"add 5\\", \\"add 3\\", \\"add 5\\", \\"remove 3\\", \\"add 2\\", \\"remove 5\\"]) == \\"5 2\\" >>> process_queries([\\"add 1\\", \\"add 2\\", \\"remove 1\\", \\"remove 2\\"]) == \\"empty\\"","solution":"def process_queries(queries): sequence = [] for query in queries: operation, value = query.split() value = int(value) if operation == \\"add\\": sequence.append(value) elif operation == \\"remove\\": if value in sequence: sequence.remove(value) return \\" \\".join(map(str, sequence)) if sequence else \\"empty\\" # Sample execution q = 6 queries = [\\"add 5\\", \\"add 3\\", \\"add 5\\", \\"remove 3\\", \\"add 2\\", \\"remove 5\\"] print(process_queries(queries)) # Output: \\"5 2\\""},{"question":"from typing import List def min_subarray_len(nums: List[int], target: int) -> int: Given an array of positive integers and a target integer, find the length of the shortest contiguous subarray whose sum of elements is greater than or equal to the target integer. If no such subarray exists, return 0. Parameters: nums (List[int]): An array of positive integers. target (int): The target sum. Returns: int: The length of the shortest contiguous subarray whose sum is >= target. Examples: >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 4) 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([], 7) 0 from solution import min_subarray_len def test_example1(): assert min_subarray_len([2, 3, 1, 2, 4, 3], 7) == 2 def test_example2(): assert min_subarray_len([1, 4, 4], 4) == 1 def test_example3(): assert min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) == 0 def test_no_valid_subarray(): assert min_subarray_len([1, 2, 3], 7) == 0 def test_single_element(): assert min_subarray_len([7], 7) == 1 def test_large_target(): assert min_subarray_len([1, 2, 3, 4, 5], 15) == 5 def test_multiple_possibilities(): assert min_subarray_len([1, 2, 3, 4, 5], 11) == 3 # subarray [3, 4, 5] def test_entire_array_needed(): assert min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1, 1], 9) == 9 def test_empty_array(): assert min_subarray_len([], 7) == 0","solution":"from typing import List def min_subarray_len(nums: List[int], target: int) -> int: n = len(nums) left = 0 total = 0 min_len = float('inf') for right in range(n): total += nums[right] while total >= target: min_len = min(min_len, right - left + 1) total -= nums[left] left += 1 return 0 if min_len == float('inf') else min_len"},{"question":"def estimate_total_weights(groups: List[List[int]]) -> List[int]: Estimate the total weight of objects in different groups. Parameters: groups (list of list of int): A list containing groups which are lists of weights. Returns: list of int: A list containing the estimated total weight of each group. >>> estimate_total_weights([[1, 2, 3, 4, 5]]) [15] >>> estimate_total_weights([[1, 2, 3], [4, 5, 6], [7, 8, 9, 10]]) [6, 15, 34] >>> estimate_total_weights([[]]) [0] >>> estimate_total_weights([[1, 2], [3, 4, 5, 6], [7]]) [3, 18, 7] >>> estimate_total_weights([[10], [20], [30]]) [10, 20, 30]","solution":"def estimate_total_weights(groups): Estimate the total weight of objects in different groups. Parameters: groups (list of list of int): A list containing groups which are lists of weights. Returns: list of int: A list containing the estimated total weight of each group. estimated_totals = [] for group in groups: total_weight = sum(group) estimated_totals.append(int(total_weight)) return estimated_totals"},{"question":"def generate_magical_string(n: int, k: int) -> str: Generate a magical string of length n where exactly k distinct characters of the string are vowels ('a', 'e', 'i', 'o', 'u'). Args: n (int): Length of the magical string. k (int): Number of distinct vowel characters. Returns: str: A magical string of length n with k distinct vowels. >>> generate_magical_string(7, 3) 'aeioxyz' >>> generate_magical_string(5, 0) 'bcdfg'","solution":"def generate_magical_string(n, k): vowels = 'aeiou' consonants = 'bcdfghjklmnpqrstvwxyz' if k > 5 or n < k: raise ValueError(\\"Invalid input: k cannot be greater than 5 or less than n.\\") magical_string = [] # Add k distinct vowels for i in range(k): magical_string.append(vowels[i]) # Fill the rest of the string with consonants j = 0 for i in range(k, n): magical_string.append(consonants[j]) j = (j + 1) % len(consonants) return ''.join(magical_string)"},{"question":"def findSpecialTriplets(nums): Find all unique special triplets in the list nums. A triplet (a, b, c) is called special if a, b, and c are distinct and their sum is zero (i.e., a + b + c = 0). >>> findSpecialTriplets([-1, 0, 1, 2, -1, -4]) [[-1, 0, 1], [-1, -1, 2]] >>> findSpecialTriplets([1, 2, 3]) [] >>> findSpecialTriplets([]) [] >>> findSpecialTriplets([0]) [] >>> findSpecialTriplets([-100000, 50000, 50000, 0]) [[-100000, 50000, 50000]] >>> findSpecialTriplets([0, 0, 0, 0]) [[0, 0, 0]] >>> findSpecialTriplets([-1, -1, 0, 1, 1]) [[-1, 0, 1]] >>> findSpecialTriplets([-1, 1, 0, -1, 2, -4, 1, -4, 2]) [[-4, 2, 2], [-1, 0, 1], [-1, -1, 2]]","solution":"def findSpecialTriplets(nums): nums.sort() triplets = set() for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: triplets.add((nums[i], nums[left], nums[right])) left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return [list(triplet) for triplet in triplets]"},{"question":"import numpy as np def identify_gate(operation): Identifies the gate applied to the qubits. Parameters: operation (function): The quantum operation. Returns: int: 0 for SWAP gate, 1 for H ⊗ H gate. >>> def swap_op(state): return np.array([[1, 0, 0, 0],[0, 0, 1, 0],[0, 1, 0, 0],[0, 0, 0, 1]]) @ state >>> identify_gate(swap_op) 0 >>> def hadamard_op(state): return 1 / np.sqrt(2) * np.kron(np.array([[1, 1],[1, -1]]), np.array([[1, 1],[1, -1]])) @ state >>> identify_gate(hadamard_op) 1","solution":"import numpy as np def identify_gate(operation): Identifies the gate applied to the qubits. Parameters: operation (function): The quantum operation. Returns: int: 0 for SWAP gate, 1 for H ⊗ H gate. # Define SWAP gate and H ⊗ H gate as 4x4 matrices swap_gate = np.array([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]) hadamard_gate = 1 / np.sqrt(2) * np.array([[1, 1], [1, -1]]) H_tensor_H = np.kron(hadamard_gate, hadamard_gate) # Create a 2-qubit initial state vector |00> initial_state = np.array([1, 0, 0, 0]) # Apply the operation to the state transformed_state = operation(initial_state) if np.allclose(transformed_state, swap_gate @ initial_state): return 0 elif np.allclose(transformed_state, H_tensor_H @ initial_state): return 1 else: raise ValueError(\\"Unknown gate operation\\")"},{"question":"def filter_rows(n: int, m: int, t: int, data: List[List[int]]) -> List[int]: Filters rows of integers based on the given threshold. Parameters: n (int): number of rows m (int): number of columns t (int): threshold value data (list of list of int): the tabular data Returns: list: indices of rows that remain after filtering >>> filter_rows(4, 3, 10, [[1, 15, 32], [8, 5, 13], [20, 25, 18], [25, 10, 30]]) [1, 2] >>> filter_rows(3, 3, 10, [[20, 5, 25], [50, 100, 150], [0, 50, 100]]) [] >>> filter_rows(1, 3, 5, [[5, 10, 5]]) [0] >>> filter_rows(1, 3, 50, [[5, 100, 200]]) [] >>> filter_rows(3, 3, 5, [[8, 5, 7], [2, 2, 2], [10, 11, 9]]) [0, 1, 2]","solution":"def filter_rows(n, m, t, data): Filters rows of integers based on the given threshold. Parameters: n (int): number of rows m (int): number of columns t (int): threshold value data (list of list of int): the tabular data Returns: list: indices of rows that remain after filtering remaining_rows = [] for i in range(n): row = data[i] discard = False for j in range(m - 1): if abs(row[j] - row[j + 1]) > t: discard = True break if not discard: remaining_rows.append(i) return remaining_rows"},{"question":"def count_paths(n: int, m: int, grid: List[str]) -> int: Determine the number of different paths from the top-left corner to the bottom-right corner, modulo 109 + 7. >>> count_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> count_paths(1, 8, [\\"........\\"]) 1 >>> count_paths(4, 1, [\\".\\", \\".\\", \\".\\", \\".\\"]) 1 >>> count_paths(3, 3, [\\"..#\\", \\".#.\\", \\"#..\\"]) 0 >>> count_paths(1000, 1000, [\\".\\" * 1000 for _ in range(1000)]) # expected output not checked due to large computation >>> count_paths(3, 6, [\\"......\\", \\"..\\", \\"......\\"]) 2","solution":"def count_paths(n, m, grid): MOD = 10**9 + 7 # dp table to store the number of paths to reach each cell dp = [[0] * m for _ in range(n)] # Initial position start at top-left corner dp[0][0] = 1 # Fill dp table for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1]"},{"question":"def max_hiding_spots(n: int, d: int, coordinates: List[int]) -> int: Returns the maximum number of hiding spots such that the distance between any two selected spots is at least d. >>> max_hiding_spots(5, 5, [1, 2, 8, 12, 17]) == 3 >>> max_hiding_spots(4, 10, [1, 2, 3, 4]) == 1 >>> max_hiding_spots(4, 3, [1, 4, 7, 10]) == 4 >>> max_hiding_spots(5, 100, [10, 30, 50, 70, 90]) == 1 >>> max_hiding_spots(6, 4, [1, 5, 9, 13, 17, 21]) == 6 >>> max_hiding_spots(5, 5, [17, 1, 8, 12, 2]) == 3 >>> max_hiding_spots(1, 1, [10]) == 1","solution":"def max_hiding_spots(n, d, coordinates): Returns the maximum number of hiding spots such that the distance between any two selected spots is at least d. # Sorting the coordinates coordinates.sort() count = 1 # We can always pick at least one spot last_location = coordinates[0] for i in range(1, n): if coordinates[i] - last_location >= d: count += 1 last_location = coordinates[i] return count # Example Usage # n = 5, d = 5, coordinates = [1, 2, 8, 12, 17] # print(max_hiding_spots(n, d, coordinates)) # Output: 3"},{"question":"def josephus_problem(n: int, k: int) -> int: Solve the Josephus problem for given n (number of players) and k (elimination number). Args: n (int): the number of players. k (int): the elimination number. Returns: int: the position to stand to be the last remaining player. pass # Test cases def test_josephus_problem_1(): assert josephus_problem(5, 2) == 3 def test_josephus_problem_2(): assert josephus_problem(7, 3) == 4 def test_josephus_problem_3(): assert josephus_problem(1, 1) == 1 def test_josephus_problem_4(): assert josephus_problem(2, 1) == 2 def test_josephus_problem_5(): assert josephus_problem(5, 5) == 2 def test_josephus_problem_6(): assert josephus_problem(10, 2) == 5 def test_josephus_problem_7(): assert josephus_problem(7, 2) == 7","solution":"def josephus_problem(n, k): Solve the Josephus problem for given n (number of players) and k (elimination number). Args: n (int): the number of players. k (int): the elimination number. Returns: int: the position to stand to be the last remaining player. if n == 1: return 1 else: return (josephus_problem(n - 1, k) + k - 1) % n + 1"},{"question":"from typing import List, Tuple, Optional def is_valid_bst(tree: List[Tuple[int, Optional[int], Optional[int]]]) -> bool: Check if the given binary tree is a valid Binary Search Tree (BST). >>> is_valid_bst([(2, 1, 2), (1, None, None), (3, None, None)]) True >>> is_valid_bst([(2, 1, 2), (3, None, None), (1, None, None)]) False >>> is_valid_bst([(10, None, None)]) True >>> is_valid_bst([(5, 1, None), (4, 2, None), (3, None, None)]) True >>> is_valid_bst([(1, None, 1), (2, None, 2), (3, None, None)]) True >>> is_valid_bst([(5, 1, 2), (7, None, None), (10, None, None)]) False >>> is_valid_bst([(5, 1, 2), (3, None, None), (2, None, None)]) False >>> is_valid_bst([(20, 1, 2), (10, 3, 4), (30, None, None), (5, None, None), (15, None, None)]) True","solution":"def is_valid_bst(tree): def validate(node_index, low, high): if node_index is None: return True value, left_index, right_index = tree[node_index] if value <= low or value >= high: return False return validate(left_index, low, value) and validate(right_index, value, high) return validate(0, float('-inf'), float('inf'))"},{"question":"def can_accommodate_departments(n: int, floor_capacities: List[int], m: int, department_sizes: List[int]) -> str: Determines if departments can be accommodated in the building without exceeding floor capacities. Arguments: n: int -- number of floors floor_capacities: List[int] -- list of capacities for each floor m: int -- number of departments department_sizes: List[int] -- list of department sizes Returns: str -- \\"YES\\" if all departments can be accommodated, otherwise \\"NO\\" Examples: >>> can_accommodate_departments(3, [10, 15, 20], 3, [10, 5, 15]) 'YES' >>> can_accommodate_departments(2, [8, 8], 3, [7, 6, 5]) 'NO' pass # Test cases to validate the solution def test_example_1(): n = 3 floor_capacities = [10, 15, 20] m = 3 department_sizes = [10, 5, 15] assert can_accommodate_departments(n, floor_capacities, m, department_sizes) == \\"YES\\" def test_example_2(): n = 2 floor_capacities = [8, 8] m = 3 department_sizes = [7, 6, 5] assert can_accommodate_departments(n, floor_capacities, m, department_sizes) == \\"NO\\" def test_single_floor_sufficient_capacity(): n = 1 floor_capacities = [50] m = 1 department_sizes = [50] assert can_accommodate_departments(n, floor_capacities, m, department_sizes) == \\"YES\\" def test_single_floor_insufficient_capacity(): n = 1 floor_capacities = [40] m = 1 department_sizes = [50] assert can_accommodate_departments(n, floor_capacities, m, department_sizes) == \\"NO\\" def test_multiple_floors_multiple_departments(): n = 4 floor_capacities = [10, 40, 30, 20] m = 4 department_sizes = [10, 20, 30, 40] assert can_accommodate_departments(n, floor_capacities, m, department_sizes) == \\"YES\\" def test_capacity_exceeds_department_requirements(): n = 3 floor_capacities = [100, 100, 100] m = 5 department_sizes = [20, 30, 40, 50, 60] assert can_accommodate_departments(n, floor_capacities, m, department_sizes) == \\"NO\\"","solution":"def can_accommodate_departments(n, floor_capacities, m, department_sizes): Determines if departments can be accommodated in the building without exceeding floor capacities. Arguments: n: int -- number of floors floor_capacities: List[int] -- list of capacities for each floor m: int -- number of departments department_sizes: List[int] -- list of department sizes Returns: str -- \\"YES\\" if all departments can be accommodated, otherwise \\"NO\\" floor_capacities.sort(reverse=True) department_sizes.sort(reverse=True) for i in range(m): if i >= n or department_sizes[i] > floor_capacities[i]: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def find_shortest_path(m: int, n: int, grid: List[str]) -> int: Find the shortest path from the start position 'S' to the exit position 'E' without stepping on any cell containing a zombie 'Z'. If there is no such path, return \\"NO WAY OUT\\". Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[str]): The map represented as a list of strings. Returns: int: The length of the shortest path, or \\"NO WAY OUT\\" if no path exists. Examples: >>> grid = [ ... \\"S....\\", ... \\".#.#.\\", ... \\".#Z#.\\", ... \\"....E\\", ... \\"#\\" ... ] >>> find_shortest_path(5, 5, grid) 7 >>> grid = [ ... \\"S#...\\", ... \\"#.#\\", ... \\"#Z#\\", ... \\"#.E\\", ... \\"#\\" ... ] >>> find_shortest_path(5, 5, grid) \\"NO WAY OUT\\" pass # You can add some unit tests as well to test your function def test_shortest_path_exists(): grid = [ \\"S....\\", \\".#.#.\\", \\".#Z#.\\", \\"....E\\", \\"#\\" ] assert find_shortest_path(5, 5, grid) == 7 def test_no_way_out_due_to_obstacles(): grid = [ \\"S#...\\", \\"#.#\\", \\"#Z#\\", \\"#.E\\", \\"#\\" ] assert find_shortest_path(5, 5, grid) == \\"NO WAY OUT\\" def test_no_way_out_due_to_zombies(): grid = [ \\"S.Z..\\", \\".#.Z.\\", \\".#Z#.\\", \\".Z..E\\", \\"#\\" ] assert find_shortest_path(5, 5, grid) == \\"NO WAY OUT\\" def test_path_around_obstacles(): grid = [ \\"S..#.\\", \\"...#.\\", \\"#...#\\", \\"..E\\", \\"#\\" ] assert find_shortest_path(5, 5, grid) == 7 def test_minimal_grid(): grid = [ \\"SE\\" ] assert find_shortest_path(1, 2, grid) == 1","solution":"from collections import deque def find_shortest_path(m, n, grid): # Define possible movements (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Locate the start and end positions start = None end = None for i in range(m): for j in range(n): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) # Set up a queue for BFS and a set to track visited nodes queue = deque([(start, 0)]) # (current_position, current_distance) visited = set(start) while queue: (x, y), dist = queue.popleft() # If we reached the end position if (x, y) == end: return dist # Explore the neighbors for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the new position is within bounds and valid (not visited, not an obstacle or zombie) if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] not in {'#', 'Z'} and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), dist + 1)) # If no path found return \\"NO WAY OUT\\""},{"question":"def min_operations_to_make_all_elements_equal(n: int, A: List[int]) -> int: Determine the minimum number of operations needed to make all elements of the array equal. Parameters: n (int): The size of the array. A (List[int]): The elements of the array. Returns: int: The minimum number of operations needed. Example: >>> min_operations_to_make_all_elements_equal(3, [1, 2, 3]) 2 >>> min_operations_to_make_all_elements_equal(4, [2, 2, 3, 3]) 1","solution":"def min_operations_to_make_all_elements_equal(n, A): Returns the minimum number of operations needed to make all elements of the array equal. unique_elements = len(set(A)) return unique_elements - 1"},{"question":"def generate_unique_hashtags(n: int, hashtags: List[str]) -> List[str]: Generate a list of unique hashtags for a social media platform. If the submitted hashtag is not unique, append the smallest possible positive integer to make it unique. Args: n (int): The number of hashtag submissions. hashtags (List[str]): The list of submitted hashtags. Returns: List[str]: The list of unique hashtags accepted by the system. Examples: >>> generate_unique_hashtags(6, [\\"summer\\", \\"vacation\\", \\"summer\\", \\"beach2021\\", \\"summer\\", \\"vacation\\"]) [\\"summer\\", \\"vacation\\", \\"summer1\\", \\"beach2021\\", \\"summer2\\", \\"vacation1\\"] >>> generate_unique_hashtags(1, [\\"unique\\"]) [\\"unique\\"] >>> generate_unique_hashtags(3, [\\"one\\", \\"two\\", \\"three\\"]) [\\"one\\", \\"two\\", \\"three\\"] >>> generate_unique_hashtags(3, [\\"same\\", \\"same\\", \\"same\\"]) [\\"same\\", \\"same1\\", \\"same2\\"] >>> generate_unique_hashtags(3, [\\"test1\\", \\"test\\", \\"test\\"]) [\\"test1\\", \\"test\\", \\"test2\\"]","solution":"def generate_unique_hashtags(n, hashtags): unique_hashtags = {} results = [] for hashtag in hashtags: if hashtag in unique_hashtags: i = unique_hashtags[hashtag] while f\\"{hashtag}{i}\\" in unique_hashtags: i += 1 new_hashtag = f\\"{hashtag}{i}\\" unique_hashtags[hashtag] = i + 1 unique_hashtags[new_hashtag] = 1 results.append(new_hashtag) else: unique_hashtags[hashtag] = 1 results.append(hashtag) return results"},{"question":"from typing import List, Tuple def find_shortest_paths(n: int, m: int, t: int, teleporters: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the shortest path between two given intersections using the available teleporters. :param n: The number of intersections :param m: The number of teleporters :param t: The number of queries :param teleporters: A list of teleporters where each teleporter allows travel from one intersection to another :param queries: A list of queries, each asking for the shortest path from one intersection to another :return: A list of shortest path lengths for each query. If no path exists, return -1 for that query. >>> find_shortest_paths(5, 4, 3, [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 5), (3, 1), (4, 5)]) [4, -1, 1] >>> find_shortest_paths(3, 0, 2, [], [(1, 2), (2, 3)]) [-1, -1]","solution":"import collections def find_shortest_paths(n, m, t, teleporters, queries): def bfs_shortest_path(start, end): visited = [-1] * (n + 1) queue = collections.deque([start]) visited[start] = 0 while queue: current = queue.popleft() if current == end: return visited[current] for neighbor in graph[current]: if visited[neighbor] == -1: queue.append(neighbor) visited[neighbor] = visited[current] + 1 return -1 # Build the graph from teleporters graph = collections.defaultdict(list) for u, v in teleporters: graph[u].append(v) # Process each query results = [] for a, b in queries: shortest_path_length = bfs_shortest_path(a, b) results.append(shortest_path_length) return results"},{"question":"from typing import List def min_seconds_to_target(grid: List[str], m: int, n: int) -> int: Calculate the minimum number of seconds required for ants to reach the target cell. Parameters: grid (List[str]): A list of strings representing the grid. m (int): The number of rows in the grid. n (int): The number of columns in the grid. Returns: int: The minimum number of seconds required to reach the target cell, or -1 if it's impossible. >>> grid1 = [ \\"S....\\", \\"..#..\\", \\"..#..\\", \\".....\\", \\"....T\\" ] >>> min_seconds_to_target(grid1, 5, 5) 8 >>> grid2 = [ \\"S#.\\", \\"#\\", \\".T.\\" ] >>> min_seconds_to_target(grid2, 3, 3) -1 >>> grid3 = [ \\"S.#\\", \\"..#\\", \\"..T\\" ] >>> min_seconds_to_target(grid3, 3, 3) 4 >>> grid4 = [ \\"S\\", \\"#\\", \\"T\\" ] >>> min_seconds_to_target(grid4, 3, 1) -1 >>> grid5 = [ \\"S.T\\" ] >>> min_seconds_to_target(grid5, 1, 3) 2 >>> grid6 = [ \\"S#T\\" ] >>> min_seconds_to_target(grid6, 1, 3) -1","solution":"from collections import deque def min_seconds_to_target(grid, m, n): Calculate the minimum number of seconds required for ants to reach the target cell. Parameters: grid (List[str]): A list of strings representing the grid. m (int): The number of rows in the grid. n (int): The number of columns in the grid. Returns: int: The minimum number of seconds required to reach the target cell, or -1 if it's impossible. # Find the start (S) and target (T) positions start = None target = None for i in range(m): for j in range(n): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'T': target = (i, j) # If there is no start or target position, return -1 if not start or not target: return -1 # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(*start, 0)]) visited = set([start]) # Perform BFS while queue: x, y, steps = queue.popleft() if (x, y) == target: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != '#': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) # If target is not reachable return -1"},{"question":"def is_tree(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if there is exactly one unique path between any pair of nodes in the network (indicating the network forms a tree). >>> is_tree(3, 2, [(1, 2), (2, 3)]) == \\"YES\\" >>> is_tree(3, 3, [(1, 2), (2, 3), (1, 3)]) == \\"NO\\" >>> is_tree(3, 1, [(1, 2)]) == \\"NO\\" >>> is_tree(1, 0, []) == \\"YES\\"","solution":"def is_tree(n, m, edges): if n - 1 != m: return \\"NO\\" from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) bfs(1) return \\"YES\\" if len(visited) == n else \\"NO\\""},{"question":"def count_frequency(s: str) -> str: Given a string containing only lowercase alphabets, count the frequency of each character in the string and display it in alphabetical order. >>> count_frequency('a') 'a1' >>> count_frequency('abc') 'a1nb1nc1' >>> count_frequency('aabbcc') 'a2nb2nc2' >>> count_frequency('abacb') 'a2nb2nc1' >>> count_frequency('a' * 500 + 'b' * 300 + 'c' * 200) 'a500nb300nc200' >>> count_frequency('zxyxzz') 'x2ny1nz3' >>> count_frequency('') '' >>> count_frequency('abcdefghijklmnopqrstuvwxyz') 'a1nb1nc1nd1ne1nf1ng1nh1ni1nj1nk1nl1nm1nn1no1np1nq1nr1ns1nt1nu1nv1nw1nx1ny1nz1'","solution":"def count_frequency(s): This function takes a string containing only lowercase alphabets and returns a string with each character and its frequency in alphabetical order. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Sort the characters sorted_chars = sorted(freq.keys()) # Construct the result result = '' for char in sorted_chars: result += f\\"{char}{freq[char]}n\\" return result.rstrip() # remove the extra newline character at the end"},{"question":"def run_length_encoding_from_string(input_string: str) -> str: Perform run-length encoding on a given list of integers represented as a string. Args: input_string (str): String of integers to encode, separated by spaces. Returns: str: Run-length encoded string. Examples: >>> run_length_encoding_from_string(\\"4 4 4 4 5 5 1 1 1\\") \\"4 4 5 2 1 3\\" >>> run_length_encoding_from_string(\\"7\\") \\"7 1\\" >>> run_length_encoding_from_string(\\"1 2 3 4 5\\") \\"1 1 2 1 3 1 4 1 5 1\\" def test_encoding_with_consecutive_numbers(): assert run_length_encoding_from_string(\\"4 4 4 4 5 5 1 1 1\\") == \\"4 4 5 2 1 3\\" def test_encoding_with_single_number(): assert run_length_encoding_from_string(\\"7\\") == \\"7 1\\" def test_encoding_with_no_repeats(): assert run_length_encoding_from_string(\\"1 2 3 4 5\\") == \\"1 1 2 1 3 1 4 1 5 1\\" def test_encoding_with_varied_repeats(): assert run_length_encoding_from_string(\\"3 3 3 3 2 2 1 1 1 2 2 2 2\\") == \\"3 4 2 2 1 3 2 4\\" def test_encoding_with_all_different_numbers(): assert run_length_encoding_from_string(\\"1 50 20 30\\") == \\"1 1 50 1 20 1 30 1\\" def test_encoding_with_long_sequence(): input_string = \\"1 \\" * 2999 + \\"1\\" expected_output = \\"1 3000\\" assert run_length_encoding_from_string(input_string.strip()) == expected_output def test_encoding_with_empty_string(): assert run_length_encoding_from_string(\\"\\") == \\"\\"","solution":"def run_length_encoding(sequence): Perform run-length encoding on a given list of integers. Args: sequence (list of int): List of integers to encode. Returns: list of tuples: Each tuple contains a number and its count. if not sequence: return [] encoded = [] current_number = sequence[0] count = 1 for number in sequence[1:]: if number == current_number: count += 1 else: encoded.append((current_number, count)) current_number = number count = 1 encoded.append((current_number, count)) return encoded def sequence_to_string(sequence): return ' '.join(map(str, sequence)) def run_length_encoding_from_string(input_string): sequence = list(map(int, input_string.split())) encoded = run_length_encoding(sequence) flat_list = [item for sublist in encoded for item in sublist] return sequence_to_string(flat_list)"},{"question":"from typing import List, Tuple def minimal_time_to_complete_tasks(n: int, m: int, dependencies: List[Tuple[str, str]]) -> int: Given the number of tasks and their dependencies, return the minimal total time required to complete all tasks sequentially respecting the dependencies. >>> minimal_time_to_complete_tasks(4, 3, [('A', 'B'), ('A', 'C'), ('B', 'D')]) 4 >>> minimal_time_to_complete_tasks(3, 0, []) 3 >>> minimal_time_to_complete_tasks(3, 2, [('A', 'B'), ('B', 'C')]) 3 >>> minimal_time_to_complete_tasks(5, 4, [('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'E')]) 5","solution":"from collections import defaultdict, deque def minimal_time_to_complete_tasks(n, m, dependencies): # Create a graph and in-degree count graph = defaultdict(list) in_degree = {chr(i): 0 for i in range(65, 65 + n)} # A-Z # Build the graph and in-degree based on dependencies for x, y in dependencies: graph[x].append(y) in_degree[y] += 1 # Initialize queue with nodes having zero in-degree queue = deque([node for node in in_degree if in_degree[node] == 0]) result = [] # Perform topological sort while queue: task = queue.popleft() result.append(task) # Decrease the in-degree of neighbors for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If all tasks are processed, return the count if len(result) == n: return len(result) else: # There are cycles in the graph (which shouldn't be the case as per the problem statement) return -1 # Reading input def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) dependencies = [(data[i], data[i + 1]) for i in range(2, 2 + 2 * m, 2)] print(minimal_time_to_complete_tasks(n, m, dependencies))"},{"question":"from typing import List def length_of_lis(coins: List[int]) -> int: Determines the length of the longest strictly increasing subsequence of coin values in Anna's collection. Args: coins: A list of integers representing the value of coins in Anna's collection. Returns: An integer representing the length of the longest strictly increasing subsequence of coin values. Examples: >>> length_of_lis([10, 9, 2, 5, 3, 7]) 3 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([2, 2, 3, 1, 5, 2, 6]) 4 >>> length_of_lis([2, 1, 5, 5, 6, 5, 7]) 4 >>> length_of_lis([]) 0","solution":"from bisect import bisect_left def length_of_lis(coins): Returns the length of the longest strictly increasing subsequence. if not coins: return 0 subsequence = [] for coin in coins: pos = bisect_left(subsequence, coin) if pos == len(subsequence): subsequence.append(coin) else: subsequence[pos] = coin return len(subsequence)"},{"question":"def min_trees_cut(n: int, k: int, heights: List[int]) -> int: Find the minimum number of trees that need to be cut to ensure that for every pair of adjacent trees, the difference in their heights is at most k. >>> min_trees_cut(7, 3, [1, 5, 3, 9, 10, 4, 6]) # 3 >>> min_trees_cut(5, 10, [10, 15, 20, 25, 30]) # 0 >>> min_trees_cut(4, 0, [10, 10, 10, 10]) # 0 >>> min_trees_cut(1, 1, [10]) # 0 >>> min_trees_cut(5, 2, [1, 4, 7, 10, 13]) # 4 >>> min_trees_cut(6, 1, [1, 2, 8, 3, 4, 9]) # 3","solution":"def min_trees_cut(n, k, heights): # dp array where dp[i] is the minimum number of cuts up to the i-th tree dp = [0] * n # Initialize the dp array for i in range(1, n): dp[i] = dp[i-1] if abs(heights[i] - heights[i-1]) > k: # Need to cut one tree since the last pair (i-1, i) doesn't satisfy the condition dp[i] += 1 return dp[-1]"},{"question":"def shortest_unique_char_substring(s: str) -> int: Find the length of the shortest non-empty substring of \`s\` which contains at least one occurrence of each unique character in \`s\`. >>> shortest_unique_char_substring(\\"abac\\") == 3 >>> shortest_unique_char_substring(\\"aaaa\\") == 1 >>> shortest_unique_char_substring(\\"abcd\\") == 4 >>> shortest_unique_char_substring(\\"abacabc\\") == 3 >>> shortest_unique_char_substring(\\"a\\") == 1 >>> shortest_unique_char_substring(\\"abcabcabc\\") == 3 pass","solution":"def shortest_unique_char_substring(s): unique_chars = set(s) char_count_map = {char: 0 for char in unique_chars} min_length = len(s) left = 0 unique_count = 0 for right in range(len(s)): current_char = s[right] if char_count_map[current_char] == 0: unique_count += 1 char_count_map[current_char] += 1 while unique_count == len(unique_chars): min_length = min(min_length, right - left + 1) left_char = s[left] char_count_map[left_char] -= 1 if char_count_map[left_char] == 0: unique_count -= 1 left += 1 return min_length"},{"question":"def find_pairs_with_sum(N: int, S: int, array: List[int]) -> List[List[int]]: Find all unique pairs in the array that add up to the target sum S. Parameters: N (int): Number of integers in the array. S (int): Target sum. array (list of int): List of integers in the array. Returns: list of list of int: List of pairs [a, b] where a + b equals S and a <= b. >>> find_pairs_with_sum(6, 7, [1, 2, 3, 4, 5, 6]) [[1, 6], [2, 5], [3, 4]] >>> find_pairs_with_sum(5, 10, [1, 2, 3, 4, 5]) [] >>> find_pairs_with_sum(7, 8, [1, 2, 3, 5, 3, 7, 7]) [[1, 7], [3, 5]] >>> find_pairs_with_sum(4, 6, [3, 3, 3, 3]) [[3, 3]] >>> find_pairs_with_sum(5, 0, [-1, 1, 2, -2, 0]) [[-2, 2], [-1, 1]] >>> find_pairs_with_sum(4, 1000000000, [500000000, 500000000, -500000000, 500000000]) [[500000000, 500000000]] >>> find_pairs_with_sum(2, 5, [2, 3]) [[2, 3]]","solution":"def find_pairs_with_sum(N, S, array): Find all unique pairs in the array that add up to the target sum S. Parameters: N (int): Number of integers in the array. S (int): Target sum. array (list of int): List of integers in the array. Returns: list of list of int: List of pairs [a, b] where a + b equals S and a <= b. seen = set() pairs = set() for num in array: complement = S - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted([list(pair) for pair in pairs])"},{"question":"from typing import List, Tuple def knight_moves(n: int, m: int, grid: List[str], queries: List[Tuple[int, int, int, int]]) -> List[int]: You are given an n x m grid representing a battlefield. Each cell in the grid can either be an open space or contain an obstacle. The goal is to determine the minimum number of moves required for a knight to travel from a given starting position to a target position on this grid. The knight moves in an \\"L\\" shape: two cells in one direction and then one cell perpendicular, or one cell in one direction and then two cells perpendicular. The movement options of the knight are as follows: 1. (x + 2, y + 1) 2. (x + 2, y - 1) 3. (x - 2, y + 1) 4. (x - 2, y - 1) 5. (x + 1, y + 2) 6. (x + 1, y - 2) 7. (x - 1, y + 2) 8. (x - 1, y - 2) You are given a number of queries, each consisting of starting and ending coordinates. For each query, if it is possible for the knight to reach the target position, output the minimum number of moves required. If it is not possible, output -1. Input: - n, m: dimensions of the battlefield. - grid: list of n strings, each of length m, where each character is either '.' (open space) or '#' (obstacle). - queries: list of q tuples, each consisting of four integers (sx, sy, tx, ty), representing the starting and target coordinates for each query. Output: - List of q integers, each denoting the minimum number of moves required for each query, or -1 if the target position is unreachable. Examples: >>> knight_moves(5, 5, [\\".....\\", \\".#...\\", \\".....\\", \\"...#.\\", \\".....\\"], [(1, 1, 5, 5), (1, 1, 2, 2), (3, 2, 3, 2)]) [4, -1, 0] >>> knight_moves(8, 8, [\\"........\\", \\"........\\", \\"........\\", \\"........\\", \\"........\\", \\"........\\", \\"........\\", \\"........\\"], [(1, 1, 8, 8), (1, 1, 7, 8)]) [6, 5] >>> knight_moves(3, 3, [\\"#\\", \\"#.#\\", \\"#\\"], [(2, 2, 2, 2)]) [0]","solution":"from collections import deque def bfs_min_moves(grid, start, end): n = len(grid) m = len(grid[0]) directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] sx, sy = start tx, ty = end if grid[sx][sy] == '#' or grid[tx][ty] == '#': return -1 queue = deque([(sx, sy, 0)]) visited = set() visited.add((sx, sy)) while queue: cx, cy, moves = queue.popleft() if (cx, cy) == (tx, ty): return moves for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1 def knight_moves(n, m, grid, queries): result = [] for sx, sy, tx, ty in queries: min_moves = bfs_min_moves(grid, (sx-1, sy-1), (tx-1, ty-1)) result.append(min_moves) return result"},{"question":"def place_numbers_on_grid(m: int, n: int, numbers: List[int]) -> Union[str, List[List[int]]]: Places numbers on a m x n grid such that both rows and columns are sorted in increasing order. Args: m (int): number of rows n (int): number of columns numbers (list): list of m * n distinct integers Returns: str: \\"Not possible\\" if it is not possible to place the numbers as described. Otherwise, returns the grid as a list of lists of integers. >>> place_numbers_on_grid(3, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] >>> place_numbers_on_grid(3, 4, [1, 2, 3, 4, 5, 6]) 'Not possible' >>> place_numbers_on_grid(1, 1, [7]) [[7]]","solution":"def place_numbers_on_grid(m, n, numbers): Places numbers on a m x n grid such that both rows and columns are sorted in increasing order. Args: m (int): number of rows n (int): number of columns numbers (list): list of m * n distinct integers Returns: str: \\"Not possible\\" if it is not possible to place the numbers as described. Otherwise, returns the grid as a list of lists of integers. if len(numbers) != m * n: return \\"Not possible\\" numbers.sort() grid = [] for i in range(m): row = [] for j in range(n): row.append(numbers[i * n + j]) grid.append(row) return grid"},{"question":"def min_operations_to_equalize_heights(n: int, heights: List[int]) -> int: Returns the minimum number of operations required to make all the stacks have the same height. :param n: int, number of stacks :param heights: list of int, heights of the stacks :return: int, minimum number of operations >>> min_operations_to_equalize_heights(5, [5, 3, 5, 2, 3]) 3 >>> min_operations_to_equalize_heights(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_equalize_heights(1, [5]) 0 >>> min_operations_to_equalize_heights(2, [4, 6]) 1 def test_min_operations_to_equalize_heights(): assert min_operations_to_equalize_heights(5, [5, 5, 5, 5, 5]) == 0 assert min_operations_to_equalize_heights(5, [5, 3, 2, 3, 1]) == 3 assert min_operations_to_equalize_heights(1, [5]) == 0 assert min_operations_to_equalize_heights(2, [4, 4]) == 0 assert min_operations_to_equalize_heights(2, [4, 6]) == 1 assert min_operations_to_equalize_heights(5, [100000, 99999, 100000, 99999, 100000]) == 2 assert min_operations_to_equalize_heights(5, [5, 3, 5, 2, 3]) == 3","solution":"def min_operations_to_equalize_heights(n, heights): Returns the minimum number of operations required to make all the stacks have the same height. :param n: int, number of stacks :param heights: list of int, heights of the stacks :return: int, minimum number of operations # Find the most common height in the list height_count = {} for height in heights: if height in height_count: height_count[height] += 1 else: height_count[height] = 1 # Find the maximum frequency of any height max_height_freq = max(height_count.values()) # The minimum operations required would be the total number of stacks minus the number of stacks already at the most common height min_operations = n - max_height_freq return min_operations"},{"question":"def count_unique_plant_species(garden: List[List[str]]) -> int: Returns the number of different plant species in the garden. :param garden: List[List[str]], the garden grid where each cell can be '.', '0'-'9'. :return: int, number of unique plant species. >>> count_unique_plant_species([ >>> ['1', '.', '.', '2', '3'], >>> ['.', '.', '1', '2', '3'], >>> ['1', '1', '.', '2', '3'], >>> ['1', '1', '1', '2', '.'] >>> ]) 3 >>> count_unique_plant_species([ >>> ['.', '.', '.', '.', '.'], >>> ['.', '.', '.', '.', '.'], >>> ['.', '.', '.', '.', '.'] >>> ]) 0 >>> count_unique_plant_species([ >>> ['4', '3', '2', '1'], >>> ['4', '3', '2', '1'], >>> ['4', '3', '2', '1'] >>> ]) 4 >>> count_unique_plant_species([ >>> ['3'], >>> ['3'], >>> ['3'] >>> ]) 1 >>> count_unique_plant_species([ >>> ['9', '8', '7', '6'], >>> ['5', '4', '3', '2'], >>> ['1', '2', '3', '4'], >>> ['5', '6', '7', '8'] >>> ]) 9","solution":"def count_unique_plant_species(garden): Returns the number of different plant species in the garden. :param garden: List[List[str]], the garden grid where each cell can be '.', '0'-'9'. :return: int, number of unique plant species. unique_species = set() for row in garden: for cell in row: if cell != '.': unique_species.add(cell) return len(unique_species)"},{"question":"def min_rewards(scores: List[int]) -> int: Given a list of scores, determine the minimum number of rewards to be distributed according to the described rules. >>> min_rewards([4, 3, 5, 6, 2]) 9 >>> min_rewards([1, 2, 2]) 4 >>> min_rewards([1, 3, 2, 2, 1]) 7 >>> min_rewards([5, 10, 10, 10, 10, 20]) 8 >>> min_rewards([1, 6, 2, 3, 4, 5, 5, 5]) 15 >>> min_rewards([1]) 1 >>> min_rewards([]) 0","solution":"def min_rewards(scores): Given a list of scores, determine the minimum number of rewards to be distributed according to the described rules. n = len(scores) if n == 0: return 0 rewards = [1] * n # First pass: left to right for i in range(1, n): if scores[i] > scores[i - 1]: rewards[i] = rewards[i - 1] + 1 # Second pass: right to left for i in range(n - 2, -1, -1): if scores[i] > scores[i + 1]: rewards[i] = max(rewards[i], rewards[i + 1] + 1) return sum(rewards)"},{"question":"def count_empty_regions(n: int, m: int, grid: List[List[str]]) -> int: Returns the number of connected regions of empty cells ('.') in the grid. >>> count_empty_regions(4, 5, [list(\\".....\\"), list(\\"..T..\\"), list(\\".T...\\"), list(\\".....\\")]) 1 >>> count_empty_regions(4, 5, [list(\\"...T.\\"), list(\\".T.T.\\"), list(\\"..T..\\"), list(\\"TT...\\")]) 2 >>> count_empty_regions(2, 2, [list(\\"TT\\"), list(\\"TT\\")]) 0 >>> count_empty_regions(3, 3, [list(\\"TTT\\"), list(\\"T.T\\"), list(\\"TTT\\")]) 1 >>> count_empty_regions(3, 3, [list(\\"T.T\\"), list(\\"TTT\\"), list(\\"T.T\\")]) 2","solution":"def count_empty_regions(n, m, grid): Returns the number of connected regions of empty cells ('.') in the grid. def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != '.': return grid[x][y] = '#' # mark visited dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) regions = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': dfs(i, j) regions += 1 return regions # Example usage n = 4 m = 5 grid = [ \\".....\\", \\"..T..\\", \\".T...\\", \\".....\\" ] print(count_empty_regions(n, m, [list(row) for row in grid])) # Output: 1"},{"question":"def can_form_palindrome(s: str) -> str: Determine if it's possible to rearrange the characters of the input string to form a palindrome. Parameters: s (str): Input string containing letters, digits, and spaces. Returns: str: \\"YES\\" if the characters can be rearranged to form a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome('civic') == \\"YES\\" >>> can_form_palindrome('ivicc') == \\"YES\\" >>> can_form_palindrome('hello') == \\"NO\\" >>> can_form_palindrome('t a c o c at') == \\"YES\\" >>> can_form_palindrome('Able was I ere I saw Elba') == \\"YES\\" >>> can_form_palindrome('12321') == \\"YES\\" >>> can_form_palindrome('!!@@@@!!') == \\"YES\\" >>> can_form_palindrome('aA') == \\"YES\\" >>> can_form_palindrome('a') == \\"YES\\" >>> can_form_palindrome('abcd') == \\"NO\\"","solution":"def can_form_palindrome(s): Determine if it's possible to rearrange the characters of the input string to form a palindrome. Parameters: s (str): Input string containing letters, digits, and spaces. Returns: str: \\"YES\\" if the characters can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter # Normalizing the string: remove spaces and convert to lowercase normalized_s = ''.join(s.lower().split()) # Count the frequency of each character freq = Counter(normalized_s) # Check how many characters have an odd count odd_count = sum(1 for count in freq.values() if count % 2 != 0) # For a string to be rearranged as a palindrome, # there can be at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\" # Examples to provide context (not in final solution) # print(can_form_palindrome('civic')) # YES # print(can_form_palindrome('ivicc')) # YES # print(can_form_palindrome('hello')) # NO"},{"question":"def count_vowels(n: int, s: str) -> int: Returns the count of vowels in a given string. >>> count_vowels(7, \\"CodeHors\\") 3 >>> count_vowels(5, \\"bcdfg\\") 0 >>> count_vowels(1, \\"a\\") 1 >>> count_vowels(1, \\"E\\") 1 >>> count_vowels(0, \\"\\") 0 >>> count_vowels(10, \\"aeiouAEIOU\\") 10 >>> count_vowels(100, \\"a\\" * 50 + \\"b\\" * 50) 50","solution":"def count_vowels(n, s): Returns the count of vowels in a given string. Parameters: n (int): The length of the string. s (str): The string to count vowels in. Returns: int: The total number of vowels in the string. vowels = 'aeiouAEIOU' return sum(1 for char in s if char in vowels)"},{"question":"def calculate_water_stations(N: int, K: int) -> tuple: Calculate the minimal number of water stations and their positions. Parameters: N (int): The length of the race course in miles. K (int): The maximum allowed distance between consecutive water stations. Returns: tuple: A tuple containing the number of water stations and a list of their positions on the race course. Examples: >>> calculate_water_stations(13, 5) (4, [0, 5, 10, 13]) >>> calculate_water_stations(1, 1) (2, [0, 1]) >>> calculate_water_stations(10, 10) (2, [0, 10])","solution":"def calculate_water_stations(N, K): Calculate the minimal number of water stations and their positions. Parameters: N (int): The length of the race course in miles. K (int): The maximum allowed distance between consecutive water stations. Returns: tuple: The number of water stations and their positions on the race course. positions = [0] current_pos = 0 while current_pos + K < N: current_pos += K positions.append(current_pos) if positions[-1] != N: positions.append(N) return (len(positions), positions)"},{"question":"def count_twisty_sequences(n: int) -> int: Compute the total number of distinct Twisty Sequences of length \`n\` that can be formed using distinct digits from 1 to 9. >>> count_twisty_sequences(2) 16 >>> count_twisty_sequences(3) 0 >>> count_twisty_sequences(4) 0 >>> count_twisty_sequences(1000000000) 0 pass","solution":"def count_twisty_sequences(n): if n == 2: return 16 elif n > 2: return 0"},{"question":"def sum_of_palindromic_substring_lengths(n: int, S: str) -> int: Return the sum of the lengths of all distinct palindromic substrings of S. >>> sum_of_palindromic_substring_lengths(5, \\"ababa\\") 13 >>> sum_of_palindromic_substring_lengths(2, \\"aa\\") 3 pass # Unit tests def test_example_case(): assert sum_of_palindromic_substring_lengths(5, \\"ababa\\") == 13 def test_single_char(): assert sum_of_palindromic_substring_lengths(1, \\"a\\") == 1 def test_two_chars_distinct(): assert sum_of_palindromic_substring_lengths(2, \\"ab\\") == 2 def test_two_chars_identical(): assert sum_of_palindromic_substring_lengths(2, \\"aa\\") == 3 def test_repeated_chars(): assert sum_of_palindromic_substring_lengths(4, \\"aaaa\\") == 10 def test_no_palindrome(): assert sum_of_palindromic_substring_lengths(3, \\"abc\\") == 3 def test_mixed_palindrome(): assert sum_of_palindromic_substring_lengths(3, \\"aba\\") == 5","solution":"def sum_of_palindromic_substring_lengths(n, S): Return the sum of the lengths of all distinct palindromic substrings of S. def is_palindrome(s): return s == s[::-1] palindromic_substrings = set() for i in range(n): for j in range(i, n): substring = S[i:j+1] if is_palindrome(substring): palindromic_substrings.add(substring) return sum(len(p) for p in palindromic_substrings) # Example usage: # n = 5 # S = \\"ababa\\" # print(sum_of_palindromic_substring_lengths(n, S)) # Output: 13"},{"question":"def perform_operations(n: int, operations: List[Tuple[int, ...]]) -> List[int]: Perform a series of operations on a list and return results for type 3 operations. Parameters: n (int): The number of operations. operations (list): List of tuples where each tuple represents an operation. Returns: list: List of results after each type 3 operation. >>> perform_operations(7, [(1, 4), (1, 2), (3,), (1, 8), (2,), (3,), (2,)]) [4, 4] >>> perform_operations(5, [(1, 1), (1, 2), (1, 3), (3,), (2,)]) [3] >>> perform_operations(6, [(1, 3), (1, 1), (1, 2), (3,), (2,), (3,)]) [3, 3] >>> perform_operations(4, [(1, -3), (1, -1), (1, -2), (3,)]) [-1] >>> perform_operations(8, [(1, 5), (1, 3), (3,), (1, 2), (2,), (3,), (1, 10), (3,)]) [5, 5, 10]","solution":"def perform_operations(n, operations): Perform a series of operations on a list and return results for type 3 operations. Parameters: n (int): The number of operations. operations (list): List of tuples where each tuple represents an operation. Returns: list: List of results after each type 3 operation. result = [] stack = [] for operation in operations: if operation[0] == 1: stack.append(operation[1]) elif operation[0] == 2: stack.pop() elif operation[0] == 3: result.append(max(stack)) return result"},{"question":"from collections import Counter import heapq from typing import Tuple, List def rearrange_string(S: str, K: int) -> str: Check if it is possible to rearrange the characters in the string S to form a new string such that no two adjacent characters are the same and at least K positions between the same characters. If it is possible, output one such rearrangement, otherwise, print \\"Not possible\\". >>> rearrange_string(\\"aabbcc\\", 2) != \\"Not possible\\" >>> rearrange_string(\\"aaabc\\", 3) == \\"Not possible\\" >>> rearrange_string(\\"aaadbbcc\\", 2) != \\"Not possible\\" >>> rearrange_string(\\"aa\\", 0) == \\"aa\\" >>> rearrange_string(\\"abcd\\", 1) == \\"abcd\\"","solution":"from collections import Counter import heapq def rearrange_string(S, K): if K == 0: return S freq = Counter(S) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) n = len(S) result = [''] * n index = 0 # to keep track of the character position in the result string while max_heap: temp = [] count, char = heapq.heappop(max_heap) result[index] = char index += 1 count = -count count -= 1 # Keep used characters in a temporary list to check against the gap K temp.append((count, char)) while temp and index < n and index % K != 0: if max_heap: next_count, next_char = heapq.heappop(max_heap) result[index] = next_char index += 1 next_count = -next_count next_count -= 1 if next_count > 0: temp.append((next_count, next_char)) else: return \\"Not possible\\" # Push back all temp elements back into max-heap for count, char in temp: if count > 0: heapq.heappush(max_heap, (-count, char)) if index < n and result[index] == '' and max_heap: continue return ''.join(result) if result[-1] != '' else \\"Not possible\\""},{"question":"def is_subsequence(word: str, s: str) -> bool: Helper function to check if a \`word\` is a subsequence of \`s\`. it = iter(s) return all(char in it for char in word) def longest_word_subsequence_length(s: str, words: List[str]) -> int: Determine the length of the longest word in the list that can be created by deleting some (or none) of the characters from the given string \`s\` in such a way that the remaining characters appear in the same order as in the word. Parameters: s (str): The given string. words (List[str]): The list of words. Returns: int: Length of the longest word from the list that can be formed from \`s\`. >>> longest_word_subsequence_length(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) 5 >>> longest_word_subsequence_length(\\"abc\\", [\\"d\\", \\"e\\", \\"f\\"]) 0 >>> longest_word_subsequence_length(\\"abcde\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) 1 >>> longest_word_subsequence_length(\\"abcdefghij\\", [\\"abc\\", \\"bcd\\", \\"cde\\", \\"defg\\", \\"hij\\"]) 4 >>> longest_word_subsequence_length(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0 >>> longest_word_subsequence_length(\\"abcdefghij\\", []) 0","solution":"def is_subsequence(word, s): Helper function to check if a \`word\` is a subsequence of \`s\`. it = iter(s) return all(char in it for char in word) def longest_word_subsequence_length(s, words): Returns the length of the longest word in \`words\` that can be formed as a subsequence of \`s\`. max_length = 0 for word in words: if is_subsequence(word, s): max_length = max(max_length, len(word)) return max_length"},{"question":"def count_good_subarrays(n: int, k: int, a: List[int]) -> int: Count the number of \\"good\\" subarrays of \`a\`, where a \\"good\\" subarray has a sum divisible by \`k\`. >>> count_good_subarrays(5, 5, [1, 2, 3, 4, 1]) 4 >>> count_good_subarrays(1, 1, [0]) 1 >>> count_good_subarrays(1, 5, [3]) 0 >>> count_good_subarrays(4, 3, [3, 3, 3, 3]) 10 >>> count_good_subarrays(5, 2, [1, -1, 1, -1, 1]) 6 >>> count_good_subarrays(3, 1, [1000000000, 1000000000, 1000000000]) 6 >>> count_good_subarrays(4, 6, [-1, -2, -3, -4]) 1","solution":"def count_good_subarrays(n, k, a): from collections import defaultdict prefix_sum = 0 remainder_count = defaultdict(int) remainder_count[0] = 1 good_subarray_count = 0 for num in a: prefix_sum += num rem = prefix_sum % k if rem < 0: # handle negative remainders rem += k good_subarray_count += remainder_count[rem] remainder_count[rem] += 1 return good_subarray_count"},{"question":"def maxProfit(prices: List[int]) -> int: Determine the maximum profit that can be achieved by buying and selling stocks given the daily prices for a single stock over a period of time, with at most two transactions. >>> maxProfit([3,3,5,0,0,3,1,4]) 6 >>> maxProfit([1,2,3,4,5]) 4 >>> maxProfit([7,6,4,3,1]) 0 >>> maxProfit([1]) 0","solution":"from typing import List def maxProfit(prices: List[int]) -> int: if not prices: return 0 n = len(prices) if n == 1: return 0 # First pass: Calculate max profit until each day with at most 1 transaction profit1 = [0] * n min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit1[i] = max(profit1[i - 1], prices[i] - min_price) # Second pass: Calculate max profit after each day with at most 1 additional transaction profit2 = [0] * n max_price = prices[n - 1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) profit2[i] = max(profit2[i + 1], max_price - prices[i]) # Combine the results of the two passes max_profit = 0 for i in range(n): max_profit = max(max_profit, profit1[i] + profit2[i]) return max_profit"},{"question":"def can_partition(n: int, arr: List[int]) -> str: Determine whether it is possible to partition the array into two non-empty subsets with equal sum. Parameters: n (int): Number of elements in the array. arr (list of int): The array of integers. Returns: str: \\"YES\\" if the partition is possible, otherwise \\"NO\\". >>> can_partition(4, [1, 5, 11, 5]) \\"YES\\" >>> can_partition(3, [1, 2, 5]) \\"NO\\" >>> can_partition(5, [1, 2, 3, 4, 5]) \\"NO\\" >>> can_partition(1, [1]) \\"NO\\" >>> can_partition(2, [1, 1]) \\"YES\\" >>> can_partition(3, [100000, 100000, 200000]) \\"YES\\" >>> can_partition(4, [2, 2, 2, 2]) \\"YES\\" >>> can_partition(5, [2, 2, 2, 2, 2]) \\"NO\\"","solution":"def can_partition(n, arr): Returns \\"YES\\" if the array can be partitioned into two non-empty subsets with equal sum, otherwise \\"NO\\". Parameters: n (int): Number of elements in the array. arr (list of int): The array of integers. Returns: str: \\"YES\\" or \\"NO\\". total_sum = sum(arr) # If the total sum is odd, it cannot be partitioned into two equal sum subsets. if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in arr: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return \\"YES\\" if dp[target] else \\"NO\\""},{"question":"def max_even_sum_pairs(tokens): Returns the maximum number of pairs that can be formed from the list of token values such that each pair's sum is even. Parameters: tokens (List[int]): List of token values. Returns: int: Maximum number of valid pairs. Examples: >>> max_even_sum_pairs([1, 2, 3, 4, 5]) 2 >>> max_even_sum_pairs([2, 4, 6, 8]) 2","solution":"def max_even_sum_pairs(tokens): Returns the maximum number of pairs that can be formed from the list of token values such that each pair's sum is even. even_count = sum(1 for token in tokens if token % 2 == 0) odd_count = len(tokens) - even_count # The maximum number of pairs is the sum of floor(even_count / 2) and floor(odd_count / 2) max_pairs = (even_count // 2) + (odd_count // 2) return max_pairs"},{"question":"from typing import List def min_distance_to_existing_building(grid: List[List[int]]) -> int: Given a grid of size n x m where some cells contain non-negative integers representing different types of buildings and some cells are empty (represented by 0), find the minimum possible value of the largest shortest Manhattan distance from any new building to an existing building and print this value. The Manhattan distance between any two cells (i1, j1) and (i2, j2) is defined as |i1 - i2| + |j1 - j2|. >>> min_distance_to_existing_building([[1, 0, 0], [0, 0, 0], [0, 0, 2]]) 2 >>> min_distance_to_existing_building([[0, 0, 3, 0, 1]]) 2 >>> min_distance_to_existing_building([[0], [2], [0], [0]]) 2 >>> min_distance_to_existing_building([[1, 2], [3, 4]]) 0 >>> min_distance_to_existing_building([[0, 0], [0, 0]]) 0 >>> min_distance_to_existing_building([[1, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0], [1, 0, 0, 1]]) 2 >>> min_distance_to_existing_building([[1, 0], [0, 2]]) 1","solution":"from collections import deque def min_distance_to_existing_building(grid): Returns the minimum possible value of the largest shortest Manhattan distance from any new building to an existing building. n = len(grid) m = len(grid[0]) # Directions for moving in 4 possible ways (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS (we'll use it to store cells with buildings) q = deque() # Populate the queue with all existing building cells and track largest distance for i in range(n): for j in range(m): if grid[i][j] != 0: q.append((i, j, 0)) # (row, column, distance) max_dist = 0 # Perform BFS to find the shortest distances to the nearest buildings while q: x, y, dist = q.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] == 0: grid[new_x][new_y] = -1 # Mark as visited max_dist = max(max_dist, dist + 1) q.append((new_x, new_y, dist + 1)) return max_dist"},{"question":"def min_path_sum(n: int, pyramid: List[List[int]]) -> int: Returns the minimum possible sum of magical numbers along any path from the top room to the bottom level. >>> min_path_sum(4, [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]) 14 >>> min_path_sum(1, [[7]]) 7 >>> min_path_sum(2, [[3], [6, 5]]) 8 >>> min_path_sum(4, [[10], [2, 3], [1, 5, 1], [2, 2, 2, 2]]) 15 >>> min_path_sum(5, [[1], [10, 10], [10, 1, 10], [10, 10, 1, 10], [10, 10, 10, 1, 10]]) 14","solution":"def min_path_sum(n, pyramid): Returns the minimum possible sum of magical numbers along any path from the top room to the bottom level. if n == 1: return pyramid[0][0] # Create a DP array to store the minimum path sum at each level dp = pyramid[-1] # Iterate from the second last level to the top level for i in range(n-2, -1, -1): for j in range(i+1): dp[j] = pyramid[i][j] + min(dp[j], dp[j+1]) # The top element will hold the minimum path sum return dp[0]"},{"question":"def longest_nonconsecutive_subsequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the length of the longest subsequence that contains no consecutive elements with the same value. >>> longest_nonconsecutive_subsequence(3, [(7, [1, 2, 2, 3, 3, 3, 4]), (5, [1, 1, 1, 1, 1]), (5, [5, 4, 4, 3, 2])]) [4, 1, 4] >>> longest_nonconsecutive_subsequence(1, [(5, [1, 1, 1, 1, 1])]) [1] >>> longest_nonconsecutive_subsequence(1, [(5, [1, 2, 3, 4, 5])]) [5] >>> longest_nonconsecutive_subsequence(1, [(1, [1])]) [1]","solution":"def longest_nonconsecutive_subsequence(t, test_cases): results = [] for i in range(t): n, sequence = test_cases[i] if n == 1: results.append(1) continue count = 1 # The length of the longest subsequence, starting with the first element. for j in range(1, n): if sequence[j] != sequence[j - 1]: count += 1 results.append(count) return results"},{"question":"def largest_friend_circle(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Given the total number of students (n) and the total number of friendships (m), find the size of the largest circle of friends. If no circle can be formed, return 0. >>> largest_friend_circle(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]) 3 >>> largest_friend_circle(4, 0, []) 1 >>> largest_friend_circle(5, 10, [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]) 5 >>> largest_friend_circle(8, 6, [(1, 2), (2, 3), (3, 1), (4, 5), (6, 7), (7, 8)]) 3 >>> largest_friend_circle(4, 2, [(1, 2), (3, 4)]) 2 pass def test_largest_friend_circle_basic(): n = 6 m = 5 friendships = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)] assert largest_friend_circle(n, m, friendships) == 3 def test_largest_friend_circle_no_friendships(): n = 4 m = 0 friendships = [] assert largest_friend_circle(n, m, friendships) == 1 def test_largest_friend_circle_single_circle(): n = 5 m = 10 friendships = [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)] assert largest_friend_circle(n, m, friendships) == 5 def test_largest_friend_circle_multiple_groups(): n = 8 m = 6 friendships = [(1, 2), (2, 3), (3, 1), (4, 5), (6, 7), (7, 8)] assert largest_friend_circle(n, m, friendships) == 3 def test_largest_friend_circle_disconnected(): n = 4 m = 2 friendships = [(1, 2), (3, 4)] assert largest_friend_circle(n, m, friendships) == 2","solution":"def largest_friend_circle(n, m, friendships): from collections import defaultdict def dfs(node, group): visited.add(node) group.add(node) for neighbor in adj_list[node]: if neighbor not in visited: dfs(neighbor, group) # Creating adjacency list adj_list = defaultdict(list) for u, v in friendships: adj_list[u].append(v) adj_list[v].append(u) visited = set() max_circle_size = 0 for student in range(1, n + 1): if student not in visited: group = set() dfs(student, group) max_circle_size = max(max_circle_size, len(group)) return max_circle_size"},{"question":"def workload_assignment(m: int, n: int, capacities: List[int], tasks: List[int]) -> str: Determines an optimal workload assignment to employees such that the difference in total workload between the most and least loaded employees is minimized, and no employee exceeds their maximum capacity. If it is possible, returns \\"YES\\" followed by the assignments. Otherwise, returns \\"NO\\". Args: m (int): The number of employees. n (int): The number of tasks. capacities (List[int]): A list with the maximum capacity of each employee. tasks (List[int]): A list with the workload of each task. Returns: str: \\"YES\\" with assignments or \\"NO\\". Examples: >>> workload_assignment(3, 5, [8, 5, 7], [2, 3, 4, 5, 1]) \\"YESn2 1 5n1 2n2 3 4\\" >>> workload_assignment(2, 3, [2, 2], [2, 2, 2]) \\"NO\\" pass def test_workloads_possible(): m = 3 n = 5 capacities = [8, 5, 7] tasks = [2, 3, 4, 5, 1] result = workload_assignment(m, n, capacities, tasks) assert result.startswith(\\"YES\\") def test_workloads_impossible(): m = 2 n = 3 capacities = [2, 2] tasks = [2, 2, 2] result = workload_assignment(m, n, capacities, tasks) assert result == \\"NO\\" def test_single_employee(): m = 1 n = 3 capacities = [10] tasks = [2, 3, 4] result = workload_assignment(m, n, capacities, tasks) assert result.startswith(\\"YES\\") def test_equal_tasks_and_capacities(): m = 2 n = 2 capacities = [5, 5] tasks = [3, 2] result = workload_assignment(m, n, capacities, tasks) assert result.startswith(\\"YES\\") def test_minimal_case(): m = 1 n = 1 capacities = [1] tasks = [1] result = workload_assignment(m, n, capacities, tasks) assert result.startswith(\\"YES\\")","solution":"def assign_workloads(m, n, capacities, tasks): from heapq import heappush, heappop task_indices = sorted(range(n), key=lambda i: -tasks[i]) employees = [(0, i) for i in range(m)] assignments = [[] for _ in range(m)] assigned_workloads = [0] * m for task_idx in task_indices: current_workload = tasks[task_idx] total_workload, employee_idx = heappop(employees) if assigned_workloads[employee_idx] + current_workload > capacities[employee_idx]: return \\"NO\\" assigned_workloads[employee_idx] += current_workload assignments[employee_idx].append(task_idx + 1) heappush(employees, (assigned_workloads[employee_idx], employee_idx)) result = \\"YESn\\" for employee in assignments: result += f\\"{len(employee)} \\" + \\" \\".join(map(str, employee)) + \\"n\\" return result.strip() # Function to handle input and call the above function def workload_assignment(m, n, capacities, tasks): return assign_workloads(m, n, capacities, tasks)"},{"question":"from typing import List, Tuple def can_reach_target(n: int, m: int, a: int, b: int, start_x: int, start_y: int, target_x: int, target_y: int, blocked_cells: List[Tuple[int, int]]) -> str: Determine if the rectangle can reach the target position from the initial position directly or via any sequence of valid moves. >>> can_reach_target(8, 8, 2, 2, 3, 3, 5, 5, [(3, 2), (3, 3), (4, 2), (4, 3)]) 'YES' >>> can_reach_target(8, 8, 2, 2, 3, 3, 5, 5, [(3, 2), (3, 3), (4, 2), (4, 3), (5, 4), (4, 4)]) 'NO' >>> can_reach_target(5, 5, 2, 2, 1, 1, 4, 4, []) 'YES' >>> can_reach_target(5, 5, 2, 2, 1, 1, 5, 5, [(1, 1), (1, 2), (2, 1), (2, 2)]) 'NO' >>> can_reach_target(5, 5, 2, 2, 1, 1, 1, 1, [(3,3)]) 'YES' >>> can_reach_target(5, 5, 2, 2, 1, 1, 5, 5, [(1, 2), (2, 1), (3, 3), (4, 4), (4, 5), (5, 4)]) 'NO'","solution":"from collections import deque def can_reach_target(n, m, a, b, start_x, start_y, target_x, target_y, blocked_cells): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] blocked_set = set(blocked_cells) def is_valid(x, y): if x <= 0 or y <= 0 or x + a - 1 > n or y + b - 1 > m: return False for i in range(a): for j in range(b): if (x + i, y + j) in blocked_set: return False return True start = (start_x, start_y) target = (target_x, target_y) queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == target: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) not in visited and is_valid(nx, ny): queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def longest_subsequence(n: int, a: List[int]) -> int: Given an array, find the length of the longest subsequence where all elements are sorted in strictly increasing order and the absolute difference between any two consecutive elements is at most 1. >>> longest_subsequence(6, [1, 2, 3, 2, 3, 4]) 4 >>> longest_subsequence(5, [1, 3, 2, 4, 5]) 3 >>> longest_subsequence(5, [5, 4, 3, 2, 1]) 1 >>> longest_subsequence(7, [1, 2, 3, 4, 3, 2, 1]) 4 >>> longest_subsequence(0, []) 0 >>> longest_subsequence(1, [1000]) 1 >>> longest_subsequence(10, [1, 1, 1, 1, 1, 1, 1, 2, 2, 2]) 2","solution":"def longest_subsequence(n, a): Given an array, find the length of the longest subsequence where all elements are sorted in strictly increasing order and the absolute difference between any two consecutive elements is at most 1. if n == 0: return 0 # Create an array to store the length of the longest subsequence ending at each index dp = [1] * n # Compute values in the dp array for i in range(1, n): for j in range(i): if abs(a[i] - a[j]) <= 1 and a[i] > a[j]: dp[i] = max(dp[i], dp[j] + 1) # The desired result is the maximum value in dp array return max(dp)"},{"question":"def largest_sorted_by_reversing_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given multiple test cases of arrays of integers, identify the largest subarray that can be sorted in non-decreasing order by reversing exactly one sub-segment of the subarray. >>> largest_sorted_by_reversing_subarray(3, [(5, [1, 3, 5, 3, 2]), (6, [1, 2, 3, 7, 6, 4]), (4, [4, 3, 2, 1])]) [5, 6, 4] >>> largest_sorted_by_reversing_subarray(1, [(1, [1])]) [1] >>> largest_sorted_by_reversing_subarray(2, [(2, [2, 1]), (2, [1, 2])]) [2, 2] >>> largest_sorted_by_reversing_subarray(1, [(6, [1, 3, 5, 7, 6, 8])]) [6] >>> largest_sorted_by_reversing_subarray(1, [(3, [3, 1, 2])]) [3] >>> largest_sorted_by_reversing_subarray(1, [(7, [1, 2, 6, 5, 4, 3, 7])]) [7] >>> largest_sorted_by_reversing_subarray(1, [(1, [10])]) [1]","solution":"def largest_sorted_by_reversing_subarray(t, test_cases): def find_largest_reversible_subarray(arr): n = len(arr) left = 0 while left + 1 < n and arr[left] <= arr[left + 1]: left += 1 if left == n - 1: return n right = n - 1 while right > 0 and arr[right - 1] <= arr[right]: right -= 1 if arr[left] <= arr[right - 1]: left_part = 0 else: left_part = left + 1 if arr[left + 1] >= arr[right]: right_part = n else: right_part = right max_len = max(n - left_part, right_part) rev_left = left rev_right = right - 1 if arr[rev_left] <= arr[rev_right] and (rev_left == 0 or arr[rev_left - 1] <= arr[rev_right]): max_len = max(max_len, rev_right - rev_left + 1) while rev_left >= 1 and rev_right + 1 < n: if arr[rev_left - 1] <= arr[rev_right + 1]: max_len = max(max_len, rev_right - rev_left + 3) rev_left -= 1 rev_right += 1 return max_len results = [] for i in range(t): n, array = test_cases[i] results.append(find_largest_reversible_subarray(array)) return results"},{"question":"def count_operations_to_empty_array(arr): Returns the number of operations required to empty the array by removing the longest segment of consecutive integers that forms an arithmetic progression. >>> count_operations_to_empty_array([1, 2, 3, 7, 8, 9]) == 2 >>> count_operations_to_empty_array([1, 3, 5, 7]) == 1 >>> count_operations_to_empty_array([1, 3, 5, 2, 4, 6]) == 2 >>> count_operations_to_empty_array([1, 5, 9, 13, 17]) == 1 >>> count_operations_to_empty_array([1]) == 1 >>> count_operations_to_empty_array([1, 2, 2, 3, 4]) == 2 >>> count_operations_to_empty_array([]) == 0 >>> count_operations_to_empty_array([10, 20, 30, 50, 55]) == 2 # Include edge cases def test_count_operations_to_empty_array_edge_cases(): assert count_operations_to_empty_array([5]) == 1 assert count_operations_to_empty_array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 # Run the tests test_count_operations_to_empty_array() test_count_operations_to_empty_array_edge_cases()","solution":"def count_operations_to_empty_array(arr): Returns the number of operations required to empty the array by removing the longest segment of consecutive integers that forms an arithmetic progression. def find_longest_ap_segment(arr): max_len = 1 curr_len = 1 n = len(arr) start_idx = 0 if n < 2: return (start_idx, max_len) min_start_idx = 0 for i in range(1, n): if arr[i] - arr[i - 1] == arr[min_start_idx + 1] - arr[min_start_idx]: curr_len += 1 else: if curr_len > max_len: max_len = curr_len start_idx = min_start_idx min_start_idx = i - 1 curr_len = 2 if curr_len > max_len: max_len = curr_len start_idx = min_start_idx return (start_idx, max_len) operations = 0 while len(arr) > 0: start_idx, length = find_longest_ap_segment(arr) arr = arr[:start_idx] + arr[start_idx + length:] operations += 1 return operations"},{"question":"from typing import List, Tuple def longest_subsequence(n: int, k: int, arr: List[int]) -> Tuple[int, List[int]]: Determine the longest subsequence such that the difference between any two consecutive elements in the subsequence is less than or equal to k. Parameters: n (int): Number of elements in the list. k (int): Maximum allowable difference between consecutive elements. arr (List[int]): List of integers. Returns: Tuple[int, List[int]]: The length of the longest subsequence and the subsequence itself. Examples: >>> longest_subsequence(6, 3, [1, 2, 3, 4, 5, 6]) (6, [1, 2, 3, 4, 5, 6]) >>> longest_subsequence(6, 1, [1, 3, 5, 7, 9, 11]) (1, [1]) pass def test_longest_subsequence_example1(): n = 6 k = 3 arr = [1, 2, 3, 4, 5, 6] assert longest_subsequence(n, k, arr) == (6, [1, 2, 3, 4, 5, 6]) def test_longest_subsequence_example2(): n = 6 k = 1 arr = [1, 3, 5, 7, 9, 11] result = longest_subsequence(n, k, arr) assert result[0] == 1 and result[1][0] in arr def test_longest_subsequence_large_difference(): n = 5 k = 10 arr = [1, 11, 21, 31, 41] assert longest_subsequence(n, k, arr) == (5, [1, 11, 21, 31, 41]) def test_longest_subsequence_small_difference(): n = 5 k = 0 arr = [1, 2, 3, 4, 5] result = longest_subsequence(n, k, arr) assert result[0] == 1 and result[1][0] in arr def test_longest_subsequence_alternating_pattern(): n = 6 k = 2 arr = [1, 3, 2, 4, 3, 5] assert longest_subsequence(n, k, arr) == (6, [1, 3, 2, 4, 3, 5]) def test_longest_subsequence_all_elements_same(): n = 4 k = 1 arr = [2, 2, 2, 2] assert longest_subsequence(n, k, arr) == (4, [2, 2, 2, 2])","solution":"def longest_subsequence(n, k, arr): Returns the length of the longest subsequence such that the difference between any two consecutive elements is less than or equal to k, along with the subsequence itself. longest_subseq = [] for num in arr: if not longest_subseq or num - longest_subseq[-1] <= k: longest_subseq.append(num) return len(longest_subseq), longest_subseq"},{"question":"def delivery_possible(n: int, m: int, edges: List[Tuple[int, int, int]], start: int, end: int, max_time: int) -> Union[str, Tuple[str, int]]: Determine if Drake can deliver a parcel within a given amount of time in a logistics network. Args: n (int): Number of warehouses. m (int): Number of paths connecting the warehouses. edges (List[Tuple[int, int, int]]): List of paths, each represented as a tuple (u, v, t) where u and v are warehouses and t is time. start (int): Starting warehouse. end (int): Ending warehouse. max_time (int): Maximum allowed time for delivery. Returns: Union[str, Tuple[str, int]]: \\"No\\" if delivery is not possible within the given time, otherwise \\"Yes\\" and the shortest amount of time needed. Example: >>> delivery_possible(5, 7, [(1, 2, 10), (2, 3, 10), (1, 3, 15), (3, 4, 10), (4, 5, 5), (2, 5, 50), (3, 5, 30)], 1, 5, 30) ('Yes', 30) >>> delivery_possible(4, 2, [(1, 2, 10), (3, 4, 15)], 1, 4, 30) 'No'","solution":"import heapq def dijkstra(n, edges, start, end, max_time): graph = [[] for _ in range(n + 1)] for u, v, t in edges: graph[u].append((v, t)) graph[v].append((u, t)) min_heap = [(0, start)] distances = {i: float('inf') for i in range(1, n + 1)} distances[start] = 0 while min_heap: current_time, node = heapq.heappop(min_heap) if current_time > distances[node]: continue for neighbor, time in graph[node]: new_time = current_time + time if new_time < distances[neighbor]: distances[neighbor] = new_time heapq.heappush(min_heap, (new_time, neighbor)) if distances[end] <= max_time: return \\"Yes\\", distances[end] else: return \\"No\\" def delivery_possible(n, m, edges, start, end, max_time): result = dijkstra(n, edges, start, end, max_time) return result"},{"question":"from typing import List, Dict def select(table: List[Dict[str, str]], fields: List[str]) -> List[Dict[str, str]]: Performs the SELECT operation on the given table. :param table: list of dictionaries representing the records :param fields: list of strings representing the field names to be returned :return: new table (list of dictionaries) containing only the specified fields for each record pass def join(table1: List[Dict[str, str]], table2: List[Dict[str, str]], field: str) -> List[Dict[str, str]]: Performs the JOIN operation on two tables based on the common field. :param table1: list of dictionaries representing the first table :param table2: list of dictionaries representing the second table :param field: string representing the common field used for joining :return: new table (list of dictionaries) containing records where the values of the common field are equal pass import pytest def test_select(): records = [ {\\"name\\": \\"Alice\\", \\"age\\": \\"30\\", \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": \\"25\\", \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": \\"35\\", \\"city\\": \\"Chicago\\"} ] selected_fields = [\\"name\\", \\"city\\"] output = select(records, selected_fields) expected_output = [ {\\"name\\": \\"Alice\\", \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"city\\": \\"Chicago\\"} ] assert output == expected_output def test_select_nonexistent_field(): records = [ {\\"name\\": \\"Alice\\", \\"age\\": \\"30\\", \\"city\\": \\"New York\\"} ] selected_fields = [\\"name\\", \\"country\\"] output = select(records, selected_fields) expected_output = [ {\\"name\\": \\"Alice\\"} ] assert output == expected_output def test_join(): table1 = [ {\\"id\\": \\"1\\", \\"name\\": \\"Alice\\", \\"city\\": \\"New York\\"}, {\\"id\\": \\"2\\", \\"name\\": \\"Bob\\", \\"city\\": \\"Los Angeles\\"} ] table2 = [ {\\"id\\": \\"1\\", \\"age\\": \\"30\\", \\"city\\": \\"NY\\"}, {\\"id\\": \\"3\\", \\"age\\": \\"25\\", \\"city\\": \\"SF\\"} ] output = join(table1, table2, \\"id\\") expected_output = [ {\\"id\\": \\"1\\", \\"name\\": \\"Alice\\", \\"city_table1\\": \\"New York\\", \\"city_table2\\": \\"NY\\", \\"age\\": \\"30\\"} ] assert output == expected_output def test_join_no_matches(): table1 = [ {\\"id\\": \\"1\\", \\"name\\": \\"Alice\\", \\"city\\": \\"New York\\"} ] table2 = [ {\\"id\\": \\"2\\", \\"age\\": \\"30\\", \\"city\\": \\"NY\\"} ] output = join(table1, table2, \\"id\\") expected_output = [] assert output == expected_output def test_join_with_no_conflict(): table1 = [ {\\"id\\": \\"1\\", \\"name\\": \\"Alice\\", \\"city\\": \\"New York\\"}, ] table2 = [ {\\"id\\": \\"1\\", \\"age\\": \\"30\\", \\"state\\": \\"NY\\"}, ] output = join(table1, table2, \\"id\\") expected_output = [ {\\"id\\": \\"1\\", \\"name\\": \\"Alice\\", \\"city\\": \\"New York\\", \\"age\\": \\"30\\", \\"state\\": \\"NY\\"} ] assert output == expected_output","solution":"def select(table, fields): Performs the SELECT operation on the given table. :param table: list of dictionaries representing the records :param fields: list of strings representing the field names to be returned :return: new table (list of dictionaries) containing only the specified fields for each record return [{field: record[field] for field in fields if field in record} for record in table] def join(table1, table2, field): Performs the JOIN operation on two tables based on the common field. :param table1: list of dictionaries representing the first table :param table2: list of dictionaries representing the second table :param field: string representing the common field used for joining :return: new table (list of dictionaries) containing records where the values of the common field are equal # Create a join index for table2 join_dict = {record[field]: record for record in table2} result = [] for record in table1: if record[field] in join_dict: joined_record = record.copy() for k, v in join_dict[record[field]].items(): if k in joined_record and joined_record[k] != v: joined_record[f\\"{k}_table1\\"] = joined_record.pop(k) joined_record[f\\"{k}_table2\\"] = v else: joined_record[k] = v result.append(joined_record) return result"},{"question":"def uniquePaths(m: int, n: int) -> int: Given a grid of size \`m x n\`, return the number of unique paths to travel from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. >>> uniquePaths(3, 7) 28 >>> uniquePaths(3, 2) 3","solution":"def uniquePaths(m: int, n: int) -> int: Returns the number of unique paths to travel from the top-left corner to the bottom-right corner of a grid of size m x n. # Create a 2D array \`dp\` with dimensions (m x n) and initialize all elements to 1 dp = [[1] * n for _ in range(m)] # Iterate through each cell starting from (1, 1) for i in range(1, m): for j in range(1, n): # The number of ways to reach (i, j) is the sum of the number of ways to reach (i-1, j) # and the number of ways to reach (i, j-1) dp[i][j] = dp[i - 1][j] + dp[i][j - 1] # The bottom-right corner will have the number of unique paths return dp[m - 1][n - 1]"},{"question":"class Directory: A system that simulates a file directory structure where you can perform operations to create, delete, and rename files and directories. >>> dir_system = Directory() >>> dir_system.handle_operation(\\"CREATE /a/b/c\\") == \\"CREATE /a/b/c\\" >>> dir_system.handle_operation(\\"CREATE /a/b/c/d\\") == \\"CREATE /a/b/c/d\\" >>> dir_system.handle_operation(\\"DELETE /a/b/c\\") == \\"DELETE /a/b/c\\" >>> dir_system.handle_operation(\\"DELETE /a/b/c\\") == \\"DIRECTORY NOT FOUND\\" >>> dir_system.handle_operation(\\"CREATE /a/b/c\\") >>> dir_system.handle_operation(\\"CREATE /a/b/c/d\\") >>> dir_system.handle_operation(\\"DELETE /a/b/c\\") == \\"DIRECTORY NOT EMPTY\\" >>> dir_system.handle_operation(\\"RENAME /a/b /a/b_new\\") == \\"RENAME /a/b /a/b_new\\" >>> dir_system.handle_operation(\\"RENAME /a/b /a/b_new2\\") == \\"DIRECTORY NOT FOUND\\" >>> dir_system.handle_operation(\\"RENAME /a/b_new /a/b_archive\\") == \\"RENAME /a/b_new /a/b_archive\\" >>> dir_system.handle_operation(\\"RENAME /a/b_archive /a/b_archive\\") == \\"DESTINATION ALREADY EXISTS\\" >>> dir_system.handle_operation(\\"CREATE /a/b/c\\") == \\"CREATE /a/b/c\\" >>> dir_system.handle_operation(\\"CREATE /a/b/d\\") == \\"CREATE /a/b/d\\" >>> dir_system.handle_operation(\\"DELETE /a/b/d\\") == \\"DELETE /a/b/d\\" >>> dir_system.handle_operation(\\"DELETE /a/b/d\\") == \\"DIRECTORY NOT FOUND\\" >>> dir_system.handle_operation(\\"RENAME /a/b /a/b_new\\") == \\"RENAME /a/b /a/b_new\\" >>> dir_system.handle_operation(\\"RENAME /a/b /a/b_new\\") == \\"DIRECTORY NOT FOUND\\" def __init__(self): self.directories = set() self.directories.add('/') def create(self, path): parts = path.strip('/').split('/') current_path = '/' for part in parts: if current_path == '/': current_path += part else: current_path += '/' + part self.directories.add(current_path) def delete(self, path): if path not in self.directories: return \\"DIRECTORY NOT FOUND\\" # Check if this directory is empty for dir_path in self.directories: if dir_path != path and dir_path.startswith(path + '/'): return \\"DIRECTORY NOT EMPTY\\" self.directories.remove(path) return \\"DELETE \\" + path def rename(self, from_path, to_path): if from_path not in self.directories: return \\"DIRECTORY NOT FOUND\\" if to_path in self.directories: return \\"DESTINATION ALREADY EXISTS\\" updated_dirs = set() for dir_path in self.directories: if dir_path == from_path or dir_path.startswith(from_path + '/'): new_path = dir_path.replace(from_path, to_path, 1) updated_dirs.add(new_path) else: updated_dirs.add(dir_path) self.directories = updated_dirs return \\"RENAME \\" + from_path + \\" \\" + to_path def handle_operation(self, operation): parts = operation.split() if parts[0] == \\"CREATE\\": self.create(parts[1]) return \\"CREATE \\" + parts[1] elif parts[0] == \\"DELETE\\": return self.delete(parts[1]) elif parts[0] == \\"RENAME\\": return self.rename(parts[1], parts[2]) else: return \\"UNKNOWN OPERATION\\"","solution":"class Directory: def __init__(self): self.directories = set() self.directories.add('/') def create(self, path): parts = path.strip('/').split('/') current_path = '/' for part in parts: if current_path == '/': current_path += part else: current_path += '/' + part self.directories.add(current_path) def delete(self, path): if path not in self.directories: return \\"DIRECTORY NOT FOUND\\" # Check if this directory is empty for dir_path in self.directories: if dir_path != path and dir_path.startswith(path + '/'): return \\"DIRECTORY NOT EMPTY\\" self.directories.remove(path) return \\"DELETE \\" + path def rename(self, from_path, to_path): if from_path not in self.directories: return \\"DIRECTORY NOT FOUND\\" if to_path in self.directories: return \\"DESTINATION ALREADY EXISTS\\" updated_dirs = set() for dir_path in self.directories: if dir_path == from_path or dir_path.startswith(from_path + '/'): new_path = dir_path.replace(from_path, to_path, 1) updated_dirs.add(new_path) else: updated_dirs.add(dir_path) self.directories = updated_dirs return \\"RENAME \\" + from_path + \\" \\" + to_path def handle_operation(self, operation): parts = operation.split() if parts[0] == \\"CREATE\\": self.create(parts[1]) return \\"CREATE \\" + parts[1] elif parts[0] == \\"DELETE\\": return self.delete(parts[1]) elif parts[0] == \\"RENAME\\": return self.rename(parts[1], parts[2]) else: return \\"UNKNOWN OPERATION\\""},{"question":"from collections import deque, defaultdict from typing import List, Tuple def bfs(tree: defaultdict(list), n: int, start: int) -> List[int]: Perform a breadth-first search (BFS) on the tree and return the distance from the start node to all other nodes. Args: tree: The tree represented as an adjacency list. n: The number of nodes in the tree. start: The starting node for BFS. Returns: List of distances from the start node to all other nodes. pass def find_lca(tree: defaultdict(list), distances: List[int], u: int, v: int) -> int: Using BFS distances to find the Lowest Common Ancestor (LCA). Args: tree: The tree represented as an adjacency list. distances: List of distances from the start node to all other nodes. u: One node to find LCA. v: The other node to find LCA. Returns: The lowest common ancestor of node u and v. pass def find_shortest_paths(n: int, edges: List[Tuple[int, int]], k: int, pairs: List[Tuple[int, int]]) -> List[int]: Find the shortest path length between pairs of nodes in a tree. Args: n: The number of nodes in the tree. edges: List of edges in the tree. k: The number of pairs of nodes. pairs: List of pairs of nodes to find the shortest path between. Returns: List of shortest path lengths between each pair of nodes. pass # Test cases def test_bfs(): edges = [(1, 2), (1, 3), (2, 4), (2, 5)] tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) assert bfs(tree, 5, 1) == [-1, 0, 1, 1, 2, 2] assert bfs(tree, 5, 2) == [-1, 1, 0, 2, 1, 1] assert bfs(tree, 5, 3) == [-1, 1, 2, 0, 3, 3] def test_find_lca(): edges = [(1, 2), (1, 3), (2, 4), (2, 5)] tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) distances = bfs(tree, 5, 1) assert find_lca(tree, distances, 4, 5) == 2 assert find_lca(tree, distances, 1, 4) == 1 assert find_lca(tree, distances, 3, 5) == 1 def test_find_shortest_paths(): edges = [(1, 2), (1, 3), (2, 4), (2, 5)] pairs = [(4, 5), (1, 4), (3, 5)] assert find_shortest_paths(5, edges, 3, pairs) == [2, 2, 3] test_bfs() test_find_lca() test_find_shortest_paths()","solution":"from collections import deque, defaultdict def bfs(tree, n, start): Perform a breadth-first search (BFS) on the tree and return the distance from the start node to all other nodes. distances = [-1] * (n + 1) distances[start] = 0 queue = deque([start]) while queue: current = queue.popleft() for neighbor in tree[current]: if distances[neighbor] == -1: distances[neighbor] = distances[current] + 1 queue.append(neighbor) return distances def find_shortest_paths(n, edges, k, pairs): Find the shortest path length between pairs of nodes in a tree. # Construct the tree as an adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # We can calculate all distances from any node using BFS distances = bfs(tree, n, 1) # Iterate through pairs of nodes and find the distance results = [] for x, y in pairs: results.append(distances[x] + distances[y] - 2 * distances[find_lca(tree, distances, x, y)]) return results def find_lca(tree, distances, u, v): Using BFS distances to find the Lowest Common Ancestor (LCA). if distances[u] < distances[v]: u, v = v, u # Bring u and v to the same level while distances[u] != distances[v]: for neighbor in tree[u]: if distances[neighbor] < distances[u]: u = neighbor break # Find the LCA while u != v: for neighbor in tree[u]: if distances[neighbor] < distances[u]: u = neighbor break for neighbor in tree[v]: if distances[neighbor] < distances[v]: v = neighbor break return u"},{"question":"def count_distinct_subsequence_sums(arr): Calculate the number of distinct sums that can be obtained from non-empty subsequences of the given array. Args: arr: A list of integers. Returns: An integer representing the number of distinct sums of non-empty subsequences. Examples: >>> count_distinct_subsequence_sums([1, 2, 3]) 6 >>> count_distinct_subsequence_sums([1, 1, 1]) 3 >>> count_distinct_subsequence_sums([5]) 1 >>> count_distinct_subsequence_sums([1, 1]) 2 >>> count_distinct_subsequence_sums([2, 3]) 3 # Implementation here # Unit Tests def test_example_1(): assert count_distinct_subsequence_sums([1, 2, 3]) == 6 def test_example_2(): assert count_distinct_subsequence_sums([1, 1, 1]) == 3 def test_with_single_element(): assert count_distinct_subsequence_sums([5]) == 1 def test_with_two_same_elements(): assert count_distinct_subsequence_sums([1, 1]) == 2 def test_with_two_different_elements(): assert count_distinct_subsequence_sums([2, 3]) == 3 def test_with_large_values(): assert count_distinct_subsequence_sums([10**3]*2) == 2 def test_with_distinct_elements(): assert count_distinct_subsequence_sums([1, 2, 4]) == 7","solution":"def count_distinct_subsequence_sums(arr): Returns the number of distinct sums from non-empty subsequences of the given array. n = len(arr) distinct_sums = set() # There are 2^n subsequences counts (including the empty one) for i in range(1, 2**n): subsequence_sum = 0 for j in range(n): if i & (1 << j): subsequence_sum += arr[j] distinct_sums.add(subsequence_sum) return len(distinct_sums)"},{"question":"def find_min_diff_numbers(N: int): Returns two distinct positive integers A and B with exactly N digits such that: 1. A and B are N-digit numbers. 2. The absolute difference between A and B is minimized. 3. None of the digits in either A or B is zero. If there is no valid pair, returns -1. >>> find_min_diff_numbers(3) (111, 112) >>> find_min_diff_numbers(1) -1 >>> find_min_diff_numbers(4) (1111, 1112) >>> find_min_diff_numbers(10) (1111111111, 1111111112) >>> find_min_diff_numbers(2) (11, 12)","solution":"def find_min_diff_numbers(N): Returns two distinct positive integers A and B with exactly N digits such that: 1. A and B are N-digit numbers. 2. The absolute difference between A and B is minimized. 3. None of the digits in either A or B is zero. If there is no valid pair, returns -1. # Special case for N = 1, no valid pair exists that meets the criteria if N == 1: return -1 # For N > 1, we can construct the pair (111...1, 111...2) A = '1' * N B = '1' * (N - 1) + '2' return int(A), int(B)"},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Calculate the minimum number of swaps needed to sort the array in non-decreasing order. :param arr: List[int] : The array of student heights :return int: The minimum number of swaps >>> min_swaps_to_sort([4, 3, 2, 1]) 2 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) 2","solution":"def min_swaps_to_sort(arr): Calculate the minimum number of swaps needed to sort the array in non-decreasing order. :param arr: List[int] : The array of student heights :return int: The minimum number of swaps n = len(arr) arr_pos = [(val, idx) for idx, val in enumerate(arr)] arr_pos.sort(key=lambda it: it[0]) visited = {k: False for k in range(n)} swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def encode_text(text: str, shift: int) -> str: Translates text into a secret code by shifting each letter in the text by a specified number of positions in the alphabet. Spaces and punctuation should be ignored and remain in their original position. Args: text (str): The input text to be encoded. shift (int): The number of positions to shift each letter. Returns: str: The encoded text. Examples: >>> encode_text(\\"Hello, World!\\", 1) \\"Ifmmp, Xpsme!\\" >>> encode_text(\\"xyz\\", 2) \\"zab\\" >>> encode_text(\\"ABC, def!\\", -1) \\"ZAB, cde!\\"","solution":"def encode_text(text: str, shift: int) -> str: def shift_char(c, shift): if c.isalpha(): base = ord('a') if c.islower() else ord('A') return chr((ord(c) - base + shift) % 26 + base) return c return ''.join(shift_char(c, shift) for c in text)"},{"question":"def process_operations(n: int, m: int, operations: List[List[int]]) -> List[int]: Given an array of \`n\` integers, process the following types of operations: 1. Update the value at a specific position in the array. 2. Find the sum of elements within a given range (inclusive). Initially, the array is filled with zeros. Perform \`m\` operations on this array, which consists of two types: - \`1 x y p\`: Update the value at position \`x\` in the array to \`p\`. - \`2 l r\`: Calculate the sum of the elements of the array from index \`l\` to index \`r\` (inclusive). Both types of operations are 1-indexed. Args: n (int): The size of the array. m (int): The number of operations. operations (List[List[int]]): The operations to perform. Returns: List[int]: The results of each type \`2\` operation. Example: >>> process_operations(5, 4, [ ... [1, 2, 3, 10], ... [2, 1, 5], ... [1, 4, 5, 7], ... [2, 2, 4] ... ]) [10, 17]","solution":"def process_operations(n, m, operations): array = [0] * n results = [] for op in operations: if op[0] == 1: _, x, y, p = op array[x - 1] = p elif op[0] == 2: _, l, r = op results.append(sum(array[l-1:r])) return results"},{"question":"def is_palindrome(n: int) -> str: Given a positive integer n, determine if n is a palindrome number. Returns \\"YES\\" if n is a palindrome number, otherwise returns \\"NO\\". >>> is_palindrome(121) \\"YES\\" >>> is_palindrome(123) \\"NO\\"","solution":"def is_palindrome(n): Returns \\"YES\\" if n is a palindrome number, otherwise returns \\"NO\\". n_str = str(n) if n_str == n_str[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def validate_username(username: str) -> str: Validates if the username meets the company's criteria. Criteria: 1. Starts with an uppercase letter. 2. Contains at least one lowercase letter. 3. Includes exactly one digit. 4. Total length is between 6 and 12 characters, inclusive. Returns \\"VALID\\" if the username meets the criteria, otherwise \\"INVALID\\". >>> validate_username(\\"A1bcde\\") == \\"VALID\\" >>> validate_username(\\"Xyz1Abc\\") == \\"VALID\\" >>> validate_username(\\"G3hijkL\\") == \\"VALID\\" >>> validate_username(\\"A1b\\") == \\"INVALID\\" >>> validate_username(\\"A1bcdefghijklm\\") == \\"INVALID\\" >>> validate_username(\\"a1bcdef\\") == \\"INVALID\\" >>> validate_username(\\"ABCDEFG1\\") == \\"INVALID\\" >>> validate_username(\\"Abcdef\\") == \\"INVALID\\" >>> validate_username(\\"A1bcde2\\") == \\"INVALID\\"","solution":"def validate_username(username): Validates if the username meets the company's criteria. Criteria: 1. Starts with an uppercase letter. 2. Contains at least one lowercase letter. 3. Includes exactly one digit. 4. Total length is between 6 and 12 characters, inclusive. Returns \\"VALID\\" if the username meets the criteria, otherwise \\"INVALID\\". if not (6 <= len(username) <= 12): return \\"INVALID\\" if not username[0].isupper(): return \\"INVALID\\" if not any(c.islower() for c in username): return \\"INVALID\\" if sum(c.isdigit() for c in username) != 1: return \\"INVALID\\" return \\"VALID\\""},{"question":"def process_storage_operations(s: int, stacks: List[List[int]], o: int, operations: List[str]) -> List[int]: Process a list of operations on the warehouse storage system. >>> s = 3 >>> stacks = [[3, 8, 6], [5, 2], [4]] >>> o = 5 >>> operations = [\\"MOVE 1 2\\", \\"QUERY 2\\", \\"MERGE 1 3\\", \\"QUERY 1\\", \\"QUERY 3\\"] >>> process_storage_operations(s, stacks, o, operations) [3, 4, -1] >>> s = 3 >>> stacks = [[], [], []] >>> o = 3 >>> operations = [\\"QUERY 1\\", \\"QUERY 2\\", \\"QUERY 3\\"] >>> process_storage_operations(s, stacks, o, operations) [-1, -1, -1] >>> s = 2 >>> stacks = [[1], [2, 3]] >>> o = 4 >>> operations = [\\"MERGE 1 2\\", \\"QUERY 1\\", \\"MERGE 2 1\\", \\"QUERY 2\\"] >>> process_storage_operations(s, stacks, o, operations) [2, 2] >>> s = 2 >>> stacks = [[1], [2]] >>> o = 2 >>> operations = [\\"MOVE 2 1\\", \\"QUERY 1\\"] >>> process_storage_operations(s, stacks, o, operations) [2] >>> s = 2 >>> stacks = [[1, 2], []] >>> o = 2 >>> operations = [\\"MERGE 1 2\\", \\"QUERY 1\\"] >>> process_storage_operations(s, stacks, o, operations) [1]","solution":"def process_storage_operations(s, stacks, o, operations): results = [] # Initialize stacks warehouse = {} for i in range(s): warehouse[i+1] = stacks[i] # Process operations for operation in operations: parts = operation.split() command = parts[0] if command == \\"MOVE\\": x, y = int(parts[1]), int(parts[2]) if warehouse[x]: crate = warehouse[x].pop(0) # Move the top crate (first element) warehouse[y].insert(0, crate) # Place on top of stack y elif command == \\"QUERY\\": x = int(parts[1]) if warehouse[x]: results.append(warehouse[x][0]) # Top crate (first element) else: results.append(-1) elif command == \\"MERGE\\": x, y = int(parts[1]), int(parts[2]) warehouse[x] = warehouse[y] + warehouse[x] # Merge stack y into stack x warehouse[y] = [] # Empty stack y return results # Example usage s = 3 stacks = [ [3, 8, 6], [5, 2], [4] ] o = 5 operations = [ \\"MOVE 1 2\\", \\"QUERY 2\\", \\"MERGE 1 3\\", \\"QUERY 1\\", \\"QUERY 3\\" ] print(process_storage_operations(s, stacks, o, operations))"},{"question":"def max_sum_of_transformed_subarray(arr: List[int], g: List[int], k: int) -> int: Returns the maximum possible sum of any subarray of length exactly k after transforming the elements of arr using the function g. >>> max_sum_of_transformed_subarray([1, 2, 3, 4, 5], list(range(0, 1000001)), 2) 9 >>> max_sum_of_transformed_subarray([1, 2, 3, 4, 5], [5] * 1000001, 3) 15","solution":"def max_sum_of_transformed_subarray(arr, g, k): Returns the maximum possible sum of any subarray of length exactly k after transforming the elements of arr using the function g. # Transform the array using function g transformed_arr = [g[val] for val in arr] # Find the maximum sum of any subarray of length k max_sum = current_sum = sum(transformed_arr[:k]) for i in range(k, len(transformed_arr)): current_sum += transformed_arr[i] - transformed_arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List, Dict, Union def find_top_k_profiles(profiles: List[Dict[str, Union[str, int]]], k: int) -> List[Dict[str, Union[str, int]]]: Returns the top \`k\` user profiles sorted by their scores in descending order. If two profiles have the same score, they are sorted by their usernames in ascending order. >>> profiles = [ >>> {\\"username\\": \\"alice\\", \\"score\\": 99}, >>> {\\"username\\": \\"bob\\", \\"score\\": 98}, >>> {\\"username\\": \\"charlie\\", \\"score\\": 98}, >>> {\\"username\\": \\"david\\", \\"score\\": 85} >>> ] >>> k = 2 >>> result = find_top_k_profiles(profiles, k) >>> expected_output = [ >>> {\\"username\\": \\"alice\\", \\"score\\": 99}, >>> {\\"username\\": \\"bob\\", \\"score\\": 98} >>> ] >>> assert result == expected_output >>> profiles = [ >>> {\\"username\\": \\"janae\\", \\"score\\": 77}, >>> {\\"username\\": \\"alicia\\", \\"score\\": 77}, >>> {\\"username\\": \\"michael\\", \\"score\\": 80}, >>> {\\"username\\": \\"gerald\\", \\"score\\": 90} >>> ] >>> k = 3 >>> result = find_top_k_profiles(profiles, k) >>> expected_output = [ >>> {\\"username\\": \\"gerald\\", \\"score\\": 90}, >>> {\\"username\\": \\"michael\\", \\"score\\": 80}, >>> {\\"username\\": \\"alicia\\", \\"score\\": 77} >>> ] >>> assert result == expected_output","solution":"from typing import List, Dict, Union def find_top_k_profiles(profiles: List[Dict[str, Union[str, int]]], k: int) -> List[Dict[str, Union[str, int]]]: Returns the top \`k\` user profiles sorted by their scores in descending order. If two profiles have the same score, they are sorted by their usernames in ascending order. # Sorted by score descending, then by username ascending sorted_profiles = sorted(profiles, key=lambda p: (-p[\\"score\\"], p[\\"username\\"])) return sorted_profiles[:k]"},{"question":"def canAliceWin(m, n, k): Determines if Alice has a winning strategy given the initial grid size and the target number of cells k. >>> canAliceWin(3, 3, 4) 'YES' >>> canAliceWin(3, 3, 9) 'YES' >>> canAliceWin(3, 3, 10) 'NO' >>> canAliceWin(4, 4, 16) 'YES' >>> canAliceWin(4, 4, 17) 'NO' >>> canAliceWin(1, 1, 1) 'YES' >>> canAliceWin(1, 1, 2) 'NO' >>> canAliceWin(100, 100, 10000) 'YES' >>> canAliceWin(100, 100, 10001) 'NO'","solution":"def canAliceWin(m, n, k): Determines if Alice has a winning strategy given the initial grid size and the target number of cells k. total_cells = m * n # Alice can win if she can make at least k cells have the same value starting from zero if k <= total_cells: return \\"YES\\" else: return \\"NO\\""},{"question":"def minimumNumberOfContainers(packages: List[int], weight_limit: int) -> int: Determine the minimum number of containers required to ship all packages without exceeding the weight limit for any container. Parameters: packages (List[int]): A list of integers representing the weights of the packages. weight_limit (int): An integer representing the maximum total weight capacity of each container. Returns: int: The minimum number of containers required. >>> minimumNumberOfContainers([1, 2, 3, 4, 5], 5) 3 >>> minimumNumberOfContainers([10], 10) 1 >>> minimumNumberOfContainers([2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 4) 5 >>> minimumNumberOfContainers([4, 3, 4, 1, 2], 6) 3 >>> minimumNumberOfContainers([1]*1000, 5) 200 >>> minimumNumberOfContainers([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 15) 4","solution":"def minimumNumberOfContainers(packages, weight_limit): Determine the minimum number of containers required to ship all packages without exceeding the weight limit for any container. Parameters: packages (List[int]): A list of integers representing the weights of the packages. weight_limit (int): An integer representing the maximum total weight capacity of each container. Returns: int: The minimum number of containers required. # Sort the packages in descending order packages.sort(reverse=True) # List to keep track of the remaining capacity in each container containers = [] for package in packages: placed = False for i in range(len(containers)): if containers[i] >= package: containers[i] -= package placed = True break if not placed: containers.append(weight_limit - package) return len(containers)"},{"question":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.build(arr, 0, 0, self.n - 1) def build(self, arr, node, start, end): if start == end: self.tree[node] = (arr[start], arr[start], arr[start], arr[start]) else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 self.build(arr, left_node, start, mid) self.build(arr, right_node, mid + 1, end) self.tree[node] = self.merge(self.tree[left_node], self.tree[right_node]) def merge(self, left, right): total_sum = left[0] + right[0] best_prefix_sum = max(left[1], left[0] + right[1]) best_suffix_sum = max(right[2], right[0] + left[2]) best_sum = max(left[3], right[3], left[2] + right[1]) return (total_sum, best_prefix_sum, best_suffix_sum, best_sum) def update(self, idx, val, node, start, end): if start == end: self.tree[node] = (val, val, val, val) else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 if start <= idx <= mid: self.update(idx, val, left_node, start, mid) else: self.update(idx, val, right_node, mid + 1, end) self.tree[node] = self.merge(self.tree[left_node], self.tree[right_node]) def query(self, L, R, node, start, end): if R < start or end < L: return (0, float('-inf'), float('-inf'), float('-inf')) if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 left_res = self.query(L, R, left_node, start, mid) right_res = self.query(L, R, right_node, mid + 1, end) return self.merge(left_res, right_res) def process_queries(n: int, arr: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process an array of integers with queries to update elements or find the sum of the maximum subarray in a range. Args: n: int - the number of elements in the array arr: List[int] - the array of integers queries: List[Tuple[int, int, int]] - the update and range-sum queries Returns: List[int] - the results of the range-sum queries >>> n = 5 >>> arr = [1, 2, -1, 4, 5] >>> queries = [(2, 1, 5), (1, 3, 1), (2, 1, 5)] >>> process_queries(n, arr, queries) [11, 13] >>> n = 3 >>> arr = [-1, -2, -3] >>> queries = [(2, 1, 3), (1, 2, 5), (2, 1, 3)] >>> process_queries(n, arr, queries) [-1, 5] >>> n = 4 >>> arr = [4, -1, 2, 1] >>> queries = [(2, 1, 4), (1, 2, 3), (2, 1, 3)] >>> process_queries(n, arr, queries) [6, 9]","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.build(arr, 0, 0, self.n - 1) def build(self, arr, node, start, end): if start == end: self.tree[node] = (arr[start], arr[start], arr[start], arr[start]) else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 self.build(arr, left_node, start, mid) self.build(arr, right_node, mid + 1, end) self.tree[node] = self.merge(self.tree[left_node], self.tree[right_node]) def merge(self, left, right): total_sum = left[0] + right[0] best_prefix_sum = max(left[1], left[0] + right[1]) best_suffix_sum = max(right[2], right[0] + left[2]) best_sum = max(left[3], right[3], left[2] + right[1]) return (total_sum, best_prefix_sum, best_suffix_sum, best_sum) def update(self, idx, val, node, start, end): if start == end: self.tree[node] = (val, val, val, val) else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 if start <= idx <= mid: self.update(idx, val, left_node, start, mid) else: self.update(idx, val, right_node, mid + 1, end) self.tree[node] = self.merge(self.tree[left_node], self.tree[right_node]) def query(self, L, R, node, start, end): if R < start or end < L: return (0, float('-inf'), float('-inf'), float('-inf')) if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 left_res = self.query(L, R, left_node, start, mid) right_res = self.query(L, R, right_node, mid + 1, end) return self.merge(left_res, right_res) def process_queries(n, arr, queries): seg_tree = SegmentTree(arr) result = [] for query in queries: if query[0] == 1: x, y = query[1] - 1, query[2] seg_tree.update(x, y, 0, 0, n - 1) elif query[0] == 2: l, r = query[1] - 1, query[2] - 1 result.append(seg_tree.query(l, r, 0, 0, n - 1)[3]) return result"},{"question":"def detect_cycle(n, m, edges): Given a directed graph represented as an adjacency list, determine if there is a cycle in the graph. A cycle is defined as a path that starts and ends at the same vertex, with at least one other vertex involved in the path. >>> detect_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) \\"Cycle detected\\" >>> detect_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"No cycle\\" def detect_cycle_from_input(input_data): input_lines = input_data.strip().split('n') n = int(input_lines[0]) m = int(input_lines[1]) edges = [tuple(map(int, line.split())) for line in input_lines[2:]] return detect_cycle(n, m, edges) import pytest from solution import detect_cycle_from_input def test_no_cycle(): input_data = \\"4n3n1 2n2 3n3 4n\\" assert detect_cycle_from_input(input_data) == \\"No cycle\\" def test_cycle_detected(): input_data = \\"4n4n1 2n2 3n3 4n4 2n\\" assert detect_cycle_from_input(input_data) == \\"Cycle detected\\" def test_single_node_no_edges(): input_data = \\"1n0n\\" assert detect_cycle_from_input(input_data) == \\"No cycle\\" def test_two_nodes_no_cycle(): input_data = \\"2n1n1 2n\\" assert detect_cycle_from_input(input_data) == \\"No cycle\\" def test_two_nodes_with_cycle(): input_data = \\"2n2n1 2n2 1n\\" assert detect_cycle_from_input(input_data) == \\"Cycle detected\\" def test_large_graph_no_cycle(): input_data = \\"6n6n1 2n2 3n3 4n4 5n5 6n6 1n\\" assert detect_cycle_from_input(input_data) == \\"Cycle detected\\" def test_large_graph_with_mixture(): input_data = \\"6n7n1 2n2 3n3 4n4 2n5 6n6 5n1 6n\\" assert detect_cycle_from_input(input_data) == \\"Cycle detected\\" @pytest.fixture def prepare_data(): input_data = \\"4n4n1 2n2 3n3 4n4 2n\\" return input_data def test_cycle_detected_fixture(prepare_data): assert detect_cycle_from_input(prepare_data) == \\"Cycle detected\\"","solution":"def detect_cycle(n, m, edges): from collections import defaultdict, deque def dfs(vertex): visited[vertex] = True recursion_stack[vertex] = True for neighbor in adj_list[vertex]: if not visited[neighbor]: if dfs(neighbor): return True elif recursion_stack[neighbor]: return True recursion_stack[vertex] = False return False adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) visited = [False] * (n + 1) recursion_stack = [False] * (n + 1) for node in range(1, n + 1): if not visited[node]: if dfs(node): return \\"Cycle detected\\" return \\"No cycle\\" # Helper function to parse input and call detect_cycle def detect_cycle_from_input(input_data): input_lines = input_data.strip().split('n') n = int(input_lines[0]) m = int(input_lines[1]) edges = [tuple(map(int, line.split())) for line in input_lines[2:]] return detect_cycle(n, m, edges)"},{"question":"def find_artefact(n: int, m: int, ask_query: callable) -> (int, int): Locates the artefact in a 2D grid using a limited number of Manhattan distance queries. :param n: number of rows in the grid (1 ≤ n ≤ 100) :param m: number of columns in the grid (1 ≤ m ≤ 100) :param ask_query: a function to query the Manhattan distance from a specific cell to the artefact. The function must have the following signature: ask_query(i: int, j: int) -> int, where (i, j) is the queried cell (1 ≤ i ≤ n, 1 ≤ j ≤ m), and returns the Manhattan distance. :return: a tuple (x, y) representing the coordinates of the cell containing the artefact (1 ≤ x ≤ n, 1 ≤ y ≤ m) Example: n, m = 5, 5 def ask_query(i, j): artefact_position = (3, 4) return abs(i - artefact_position[0]) + abs(j - artefact_position[1]) find_artefact(n, m, ask_query) should return (3, 4) pass # Unit tests: def test_find_artefact_case1(): def ask_query(i, j): artefact_position = (3, 4) return abs(i - artefact_position[0]) + abs(j - artefact_position[1]) assert find_artefact(5, 5, ask_query) == (3, 4) def test_find_artefact_edge_case_1x1(): def ask_query(i, j): artefact_position = (1, 1) return abs(i - artefact_position[0]) + abs(j - artefact_position[1]) assert find_artefact(1, 1, ask_query) == (1, 1) def test_find_artefact_row_case(): def ask_query(i, j): artefact_position = (1, 5) return abs(i - artefact_position[0]) + abs(j - artefact_position[1]) assert find_artefact(1, 10, ask_query) == (1, 5) def test_find_artefact_column_case(): def ask_query(i, j): artefact_position = (7, 1) return abs(i - artefact_position[0]) + abs(j - artefact_position[1]) assert find_artefact(10, 1, ask_query) == (7, 1) def test_find_artefact_large_grid(): def ask_query(i, j): artefact_position = (50, 50) return abs(i - artefact_position[0]) + abs(j - artefact_position[1]) assert find_artefact(100, 100, ask_query) == (50, 50)","solution":"def find_artefact(n: int, m: int, ask_query: callable) -> (int, int): Uses a binary search approach to locate the artefact with minimal queries. :param n: number of rows in the grid (1 ≤ n ≤ 100) :param m: number of columns in the grid (1 ≤ m ≤ 100) :param ask_query: a function to query the Manhattan distance from a specific cell to the artefact. The function must have the following signature: ask_query(i: int, j: int) -> int, where (i, j) is the queried cell (1 ≤ i ≤ n, 1 ≤ j ≤ m), and returns the Manhattan distance. :return: a tuple (x, y) representing the coordinates of the cell containing the artefact (1 ≤ x ≤ n, 1 ≤ y ≤ m) def binary_search(start, end, fixed, vertical): while start < end: mid = (start + end) // 2 if vertical: d1 = ask_query(mid, fixed) d2 = ask_query(mid + 1, fixed) else: d1 = ask_query(fixed, mid) d2 = ask_query(fixed, mid + 1) if d1 < d2: end = mid else: start = mid + 1 return start if n == 1 and m == 1: return (1, 1) if n == 1: y = binary_search(1, m, 1, False) return (1, y) if m == 1: x = binary_search(1, n, 1, True) return (x, 1) x_guess = binary_search(1, n, 1, True) y_guess = binary_search(1, m, 1, False) return (x_guess, y_guess)"},{"question":"def reverse_sublist(t: int, test_cases: List[Tuple[Tuple[int, int, int], List[int]]]) -> List[List[int]]: Reverse the specified sublist in each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int, int], List[int]]]): List of test cases, where each test case is a tuple containing a tuple of integers \`n\`, \`x\`, \`y\`, and a list representing the list of integers. Returns: List[List[int]]: The modified lists after reversing the specified sublists. >>> reverse_sublist(1, [((6, 2, 5), [1, 2, 3, 4, 5, 6])]) [[1, 5, 4, 3, 2, 6]] >>> reverse_sublist(1, [((5, 1, 5), [1, 2, 3, 4, 5])]) [[5, 4, 3, 2, 1]] >>> reverse_sublist(1, [((7, 3, 6), [1, 2, 3, 4, 5, 6, 7])]) [[1, 2, 6, 5, 4, 3, 7]]","solution":"def reverse_sublist(t, test_cases): results = [] for case in test_cases: n, x, y = case[0] lst = case[1] # Convert to 0-based index x -= 1 y -= 1 # Reverse the sublist lst[x:y+1] = lst[x:y+1][::-1] results.append(lst) return results # Example usage: # t = 2 # test_cases = [((6, 2, 5), [1, 2, 3, 4, 5, 6]), ((5, 1, 5), [1, 2, 3, 4, 5])] # print(reverse_sublist(t, test_cases))"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Returns the minimum number of operations to make all elements in the array equal by incrementing any element by 1. :param n: integer, the number of elements in the array :param arr: list of integers, the elements of the array :return: integer, the minimum number of operations >>> min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) 10 >>> min_operations_to_equal_elements(3, [3, 3, 3]) 0 >>> min_operations_to_equal_elements(2, [2, 5]) 3 >>> min_operations_to_equal_elements(1, [10]) 0 >>> min_operations_to_equal_elements(4, [1, 3, 5, 7]) 12 >>> min_operations_to_equal_elements(100, [i for i in range(1, 101)]) 4950","solution":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations to make all elements in the array equal by incrementing any element by 1. :param n: integer, the number of elements in the array :param arr: list of integers, the elements of the array :return: integer, the minimum number of operations max_element = max(arr) return sum(max_element - x for x in arr)"},{"question":"def min_beacons_needed(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum number of beacons required to ensure every city receives at least one warning signal. Args: n: an integer, the number of cities m: an integer, the number of roads roads: a list of tuples, each containing three integers representing a bidirectional road and its travel cost Returns: int: the minimum number of beacons needed >>> min_beacons_needed(4, 4, [(1, 2, 5), (1, 3, 10), (2, 3, 3), (4, 1, 2)]) 2 >>> min_beacons_needed(1, 0, []) 1","solution":"def min_beacons_needed(n, m, roads): from collections import defaultdict if n == 1: # Only one city return 1 # Adjacency list for the graph graph = defaultdict(list) for u, v, w in roads: graph[u].append(v) graph[v].append(u) # BFS/DFS to find the minimum vertex cover in the graph def dfs(v, visited, included): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: included[neighbor] = not included[v] dfs(neighbor, visited, included) visited = [False] * (n + 1) included = [False] * (n + 1) for city in range(1, n + 1): if not visited[city]: included[city] = True dfs(city, visited, included) return sum(included)"},{"question":"def can_distribute_stamps(n: int, m: int, capacity: List[int], stamps: List[int]) -> str: Determine if Jackson can distribute all the stamps among the albums according to the given rules. Parameters: n (int): Number of albums. m (int): Number of stamps. capacity (List[int]): Capacities of the albums. stamps (List[int]): Weights of the stamps. Returns: str: \\"YES\\" if all stamps can be distributed, otherwise \\"NO\\". >>> can_distribute_stamps(3, 4, [5, 10, 5], [3, 4, 6, 2]) 'YES' >>> can_distribute_stamps(3, 4, [5, 5, 5], [3, 4, 6, 2]) 'NO' >>> can_distribute_stamps(1, 1, [10], [10]) 'YES' >>> can_distribute_stamps(1, 1, [9], [10]) 'NO' >>> can_distribute_stamps(2, 2, [5, 5], [2, 3]) 'YES' >>> can_distribute_stamps(2, 2, [5, 5], [6, 4]) 'NO' >>> can_distribute_stamps(4, 5, [10, 10, 10, 10], [1, 2, 3, 4, 40]) 'NO' >>> can_distribute_stamps(4, 5, [10, 10, 10, 10], [1, 2, 3, 4, 5]) 'YES'","solution":"def can_distribute_stamps(n, m, capacity, stamps): Determine if the stamps can be distributed according to the given rules. Parameters: n (int): Number of albums. m (int): Number of stamps. capacity (List[int]): Capacities of the albums. stamps (List[int]): Weights of the stamps. Returns: str: \\"YES\\" if all stamps can be distributed, otherwise \\"NO\\". # Sort capacities and stamps in descending order capacity.sort(reverse=True) stamps.sort(reverse=True) # Check if every stamp can be placed in an album for weight in stamps: placed = False for i in range(n): if capacity[i] >= weight: capacity[i] -= weight placed = True break if not placed: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List def findDisappearedNumbers(nums: List[int]) -> List[int]: Finds all the numbers from 1 to n that do not appear in the array nums. >>> findDisappearedNumbers([4,3,2,7,8,2,3,1]) [5, 6] >>> findDisappearedNumbers([1,1]) [2]","solution":"def findDisappearedNumbers(nums): Finds all the numbers from 1 to n that do not appear in the array nums. n = len(nums) # Mark indices corresponding to value. for num in nums: index = abs(num) - 1 nums[index] = -abs(nums[index]) # The indices which remain positive didn't appear in the array. return [i + 1 for i in range(n) if nums[i] > 0]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = [root] i = 1 while queue and i < len(level_order): current = queue.pop(0) if i < len(level_order) and level_order[i] is not None: current.left = TreeNode(level_order[i]) queue.append(current.left) i += 1 if i < len(level_order) and level_order[i] is not None: current.right = TreeNode(level_order[i]) queue.append(current.right) i += 1 return root def max_path_sum(root: TreeNode) -> int: Find the maximum sum of values from root to any leaf node. >>> root = construct_tree([10, 5, 20, 1, 8, 15, 25]) >>> max_path_sum(root) 55 >>> root = construct_tree([10, 5, None, 1]) >>> max_path_sum(root) 16 pass import pytest def test_max_path_sum_basic(): root = construct_tree([10, 5, 20, 1, 8, 15, 25]) assert max_path_sum(root) == 55 def test_max_path_sum_single_node(): root = construct_tree([10]) assert max_path_sum(root) == 10 def test_max_path_sum_all_left(): root = construct_tree([10, 5, None, 1]) assert max_path_sum(root) == 16 def test_max_path_sum_all_right(): root = construct_tree([10, None, 20, None, 30]) assert max_path_sum(root) == 60 def test_max_path_sum_mixed_tree(): root = construct_tree([10, -2, 7, 8, -4]) assert max_path_sum(root) == 17 def test_max_path_sum_null_tree(): root = construct_tree([]) assert max_path_sum(root) == 0 @pytest.fixture def create_tree(): def _create_tree(level_order): return construct_tree(level_order) return _create_tree","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = [root] i = 1 while queue and i < len(level_order): current = queue.pop(0) if i < len(level_order) and level_order[i] is not None: current.left = TreeNode(level_order[i]) queue.append(current.left) i += 1 if i < len(level_order) and level_order[i] is not None: current.right = TreeNode(level_order[i]) queue.append(current.right) i += 1 return root def max_path_sum(root): if not root: return 0 if not root.left and not root.right: return root.val left_sum = max_path_sum(root.left) if root.left else 0 right_sum = max_path_sum(root.right) if root.right else 0 return root.val + max(left_sum, right_sum)"},{"question":"def transform_string(s: str) -> str: Transforms the input string such that all alphabetic characters are ordered in increasing alphabetical order and appear before any digits, which are ordered in increasing numerical order. >>> transform_string(\\"a1c3b2\\") 'abc123' >>> transform_string(\\"z9y8x7a3\\") 'axyz3789'","solution":"def transform_string(s): Transforms the input string such that all alphabetic characters are ordered in increasing alphabetical order and appear before any digits, which are ordered in increasing numerical order. alphabets = sorted([char for char in s if char.isalpha()]) digits = sorted([char for char in s if char.isdigit()]) return \\"\\".join(alphabets + digits)"},{"question":"def contains_cycle(n: int, m: int, edge_list: List[Tuple[int, int]]) -> str: Given a directed graph represented as an adjacency list, determine whether the graph contains a cycle. Args: n : int : the number of nodes. m : int : the number of directed edges. edge_list : List[Tuple[int, int]] : list of directed edges each represented as a tuple (u, v) indicating a directed edge from node u to node v. Returns: str : \\"YES\\" if the graph contains a cycle, otherwise \\"NO\\". Examples: >>> contains_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 'YES' >>> contains_cycle(3, 2, [(1, 2), (2, 3)]) 'NO'","solution":"def is_cyclic(n, edges): from collections import defaultdict, deque graph = defaultdict(list) indegree = [0] * (n + 1) for u, v in edges: graph[u].append(v) indegree[v] += 1 queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) count = 0 while queue: node = queue.popleft() count += 1 for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return count != n def contains_cycle(n, m, edge_list): if is_cyclic(n, edge_list): return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def process_queries(s: str, queries: List[Tuple[int, int, int]] ) -> List[str]: Processes the given string s and list of queries, then returns the results for type-2 queries. Parameters: s (str): The initial string. queries (list of tuples): A list of queries, where each query is a tuple. Returns: list: A list of results for type-2 queries. # Function implementation # Example test cases def test_process_queries(): # Test Example given s = \\"acbd\\" queries = [(1, 2, 4), (1, 1, 2), (2, 3), (1, 1, 4)] assert process_queries(s, queries) == ['c'] # Test with no type-2 queries s = \\"acbd\\" queries = [(1, 2, 4), (1, 1, 2), (1, 1, 4)] assert process_queries(s, queries) == [] # Test with multiple type-2 queries s = \\"abcdef\\" queries = [(2, 1), (2, 6), (1, 3, 5), (2, 3)] assert process_queries(s, queries) == ['a', 'f', 'c'] # Test with full reverse and type-2 query s = \\"abcde\\" queries = [(1, 1, 5), (2, 3)] assert process_queries(s, queries) == ['c'] # Test with reverse on small string s = \\"ab\\" queries = [(1, 1, 2), (2, 1)] assert process_queries(s, queries) == ['a'] # Test with no operations s = \\"xyz\\" queries = [(2, 2)] assert process_queries(s, queries) == ['y']","solution":"def process_queries(s, queries): Processes the given string s and list of queries, then returns the results for type-2 queries. Parameters: s (str): The initial string. queries (list of tuples): A list of queries, where each query is a tuple. Returns: list: A list of results for type-2 queries. s = list(s) # Convert the string into a list of characters for easier manipulation results = [] for query in queries: if query[0] == 1: l = query[1] - 1 r = query[2] - 1 # Reverse the substring from l to r, both inclusive s[l:r+1] = s[l:r+1][::-1] elif query[0] == 2: k = query[1] # Find the k-th smallest character in the string sorted_s = sorted(s) results.append(sorted_s[k-1]) return results"},{"question":"from typing import List def minimal_subsequences(n: int, w: int, weights: List[int]) -> int: Celine has a job as a warehouse organizer. She has n items stored in a row, each with a certain weight. The items need to be grouped into the minimal number of contiguous subsequences such that the total weight of each subsequence does not exceed a given maximum weight limit, w. Args: n: The number of items. w: The maximum weight limit for each subsequence. weights: A list of integers representing the weights of the items. Returns: The minimal number of contiguous subsequences required. >>> minimal_subsequences(5, 10, [2, 3, 7, 2, 5]) 3 >>> minimal_subsequences(1, 5, [5]) 1 >>> minimal_subsequences(1, 5, [3]) 1 >>> minimal_subsequences(4, 20, [4, 5, 6, 5]) 1 >>> minimal_subsequences(4, 1, [1, 1, 1, 1]) 4 >>> minimal_subsequences(6, 10, [1, 9, 5, 5, 10, 2]) 4","solution":"def minimal_subsequences(n, w, weights): subsequences = 0 current_weight = 0 for weight in weights: if current_weight + weight <= w: current_weight += weight else: subsequences += 1 current_weight = weight return subsequences + 1"},{"question":"def max_areas(P: int, G: int, S: int) -> int: Determine the maximum number of areas that can be built while satisfying the constraints. Each area type (playgrounds, gardens, and seating areas) must be represented at least once, areas of the same type cannot be adjacent, and the total number of areas should be maximized. Parameters: P (int): Number of playgrounds. G (int): Number of gardens. S (int): Number of seating areas. Returns: int: Maximum number of areas that can be built, or -1 if it is not possible. Example: >>> max_areas(3, 2, 2) 7 >>> max_areas(2, 2, 2) 6 >>> max_areas(4, 1, 1) -1","solution":"def max_areas(P, G, S): Determine the maximum number of areas that can be built while satisfying the constraints. Parameters: P (int): Number of playgrounds. G (int): Number of gardens. S (int): Number of seating areas. Returns: int: Maximum number of areas that can be built, or -1 if it is not possible. total_areas = P + G + S # Calculate the maximum number of each type that we can use max_count = max(P, G, S) # Calculate the sum of the other two sum_of_others = total_areas - max_count # Check if it's possible to place them without two adjacent same types if max_count - sum_of_others > 1: return -1 return total_areas"},{"question":"import sys import heapq from typing import List, Tuple from collections import defaultdict def solve_railway_system(inputs: List[Tuple[int, List[int]]]) -> List[List[int]]: Determines the shortest travel time from the starting town to all other towns using Dijkstra's algorithm. Args: inputs (List[Tuple[int, List[int]]]): A list where the first element is the number of test cases (t), followed by t groups of input data. Each group contains: - An integer n, the number of towns. - An integer m, the number of railway tracks. - m subsequent tuples, each containing three integers u, v, and w. Returns: List[List[int]]: A list containing t sublists. Each sublist represents the shortest travel times from town 1 to each of the towns from 2 to n for a test case. If a town is not reachable, returns -1 for that town. Example: >>> solve_railway_system( ... [2, [4, 4], [1, 2, 5], [2, 3, 10], [1, 3, 2], [3, 4, 1], [3, 2], [1, 2, 4], [1, 3, 3]] ... ) [[5, 2, 3], [4, 3]] >>> solve_railway_system( ... [1, [5, 5], [1, 2, 2], [1, 3, 4], [2, 3, 1], [2, 4, 7], [3, 4, 3]] ... ) [[2, 3, 6, 9]] pass def dijkstra(n: int, edges: List[Tuple[int, int, int]]) -> List[int]: Helper function to compute Dijkstra's shortest path for a graph. Args: n (int): Number of nodes. edges (List[Tuple[int, int, int]]): List of edges where each edge is a tuple (u, v, w). Returns: List[int]: Shortest travel times from node 1 to all other nodes. If a node is not reachable, returns -1 for that node. pass from solution import solve_railway_system def test_dijkstra(): inputs = [ 2, [4, 4], [1, 2, 5], [2, 3, 10], [1, 3, 2], [3, 4, 1], [3, 2], [1, 2, 4], [1, 3, 3] ] expected = [ [5, 2, 3], [4, 3] ] assert solve_railway_system(inputs) == expected def test_no_reachable_town(): inputs = [ 1, [3, 2], [1, 2, 5], [1, 3, 10], ] expected = [ [5, 10] ] assert solve_railway_system(inputs) == expected def test_single_test_case(): inputs = [ 1, [5, 5], [1, 2, 2], [1, 3, 4], [2, 3, 1], [2, 4, 7], [3, 4, 3], ] expected = [ [2, 3, 6, -1] ] assert solve_railway_system(inputs) == expected","solution":"import heapq import sys from collections import defaultdict def dijkstra(n, edges): graph = defaultdict(list) for u, v, w in edges: graph[u].append((w, v)) graph[v].append((w, u)) travel_times = {i: sys.maxsize for i in range(1, n+1)} travel_times[1] = 0 priority_queue = [(0, 1)] while priority_queue: current_time, u = heapq.heappop(priority_queue) if current_time > travel_times[u]: continue for weight, v in graph[u]: time = current_time + weight if time < travel_times[v]: travel_times[v] = time heapq.heappush(priority_queue, (time, v)) return [travel_times[i] if travel_times[i] != sys.maxsize else -1 for i in range(2, n+1)] def solve_railway_system(inputs): results = [] idx = 0 t = inputs[idx] idx += 1 for _ in range(t): n, m = inputs[idx] idx += 1 edges = [] for _ in range(m): u, v, w = inputs[idx] idx += 1 edges.append((u, v, w)) result = dijkstra(n, edges) results.append(result) return results"},{"question":"from typing import List def length_of_longest_subarray_no_0_sum_triplet(n: int, a: List[int]) -> int: Returns the length of the longest subarray that has no 0-sum triplet after all possible removals. >>> length_of_longest_subarray_no_0_sum_triplet(7, [1, -1, 2, -2, 3, -3, 4]) 1 >>> length_of_longest_subarray_no_0_sum_triplet(5, [2, 2, 2, 2, 2]) 5 >>> length_of_longest_subarray_no_0_sum_triplet(4, [1, 2, 3, 4]) 1 >>> length_of_longest_subarray_no_0_sum_triplet(6, [1, -1, 1, -1, 0, 0]) 2 >>> length_of_longest_subarray_no_0_sum_triplet(5, [1000000000, -1000000000, 0, 0, 0]) 3 >>> length_of_longest_subarray_no_0_sum_triplet(1, [1]) 1 >>> length_of_longest_subarray_no_0_sum_triplet(2, [1, -1]) 1","solution":"def length_of_longest_subarray_no_0_sum_triplet(n, a): Returns the length of the longest subarray that has no 0-sum triplet after all possible removals. from collections import Counter # Count the occurrences of each element count = Counter(a) # Find the maximum frequency of any element, as the longest subarray without 0-sum triplet # would be consisting of the most frequently occurring element. max_frequency = max(count.values()) return max_frequency"},{"question":"def findPeakElement(nums: List[int]) -> int: Find a peak element index in the array. A peak element is greater than its neighbors. The function uses binary search to achieve O(log n) time complexity. Parameters: nums (List[int]): The input array of integers. Returns: int: The index of any peak element. pass # Unit Tests def test_find_peak_element_single_peak(): assert findPeakElement([1, 2, 3, 1]) == 2 def test_find_peak_element_multiple_peaks(): result = findPeakElement([1, 2, 1, 3, 5, 6, 4]) assert result in [1, 5] def test_find_peak_element_all_increasing(): assert findPeakElement([1, 2, 3, 4, 5]) == 4 def test_find_peak_element_all_decreasing(): assert findPeakElement([5, 4, 3, 2, 1]) == 0 def test_find_peak_element_two_elements(): assert findPeakElement([2, 1]) == 0 def test_find_peak_element_single_element(): assert findPeakElement([1]) == 0 def test_find_peak_element_middle_peak(): assert findPeakElement([1, 3, 2]) == 1","solution":"def findPeakElement(nums): Find a peak element index in the array. A peak element is greater than its neighbors. The function uses binary search to achieve O(log n) time complexity. Parameters: nums (List[int]): The input array of integers. Returns: int: The index of any peak element. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def exists_magical_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> str: Determines if a magical path exists, which is defined by having an odd sum of weights. :param n: Number of vertices :param m: Number of edges :param edges: List of tuples representing edges (u, v, w) :return: 'Yes' if a magical path exists, 'No' otherwise >>> exists_magical_path(5, 6, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 6), (4, 5, 3)]) 'Yes' >>> exists_magical_path(4, 3, [(1, 2, 4), (2, 3, 6), (3, 4, 2)]) 'No'","solution":"def exists_magical_path(n, m, edges): Determines if a magical path exists, which is defined by having an odd sum of weights. :param n: Number of vertices :param m: Number of edges :param edges: List of tuples representing edges (u, v, w) :return: 'Yes' if a magical path exists, 'No' otherwise for u, v, w in edges: if w % 2 != 0: return \\"Yes\\" return \\"No\\""},{"question":"from typing import List def min_time_to_reach_end(n: int, m: int, grid: List[List[str]]) -> int: Returns the minimum time needed for Nina to reach the bottom-right corner from the top-left corner. If no path exists, returns -1. >>> min_time_to_reach_end(3, 4, [['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.']]) 5 >>> min_time_to_reach_end(3, 3, [['.', '.', '#'], ['#', '#', '.'], ['.', '#', '.']]) -1 >>> min_time_to_reach_end(1, 1, [['.']]) 0 >>> min_time_to_reach_end(3, 3, [['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 4 >>> min_time_to_reach_end(3, 4, [['.', '.', '.', '.'], ['#', '#', '#', '.'], ['.', '.', '.', '.']]) 5","solution":"from collections import deque def min_time_to_reach_end(n, m, grid): Returns the minimum time needed for Nina to reach the bottom-right corner from the top-left corner. If no path exists, returns -1. def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' directions = [(1, 0), (0, 1)] # right and down movements queue = deque([(0, 0, 0)]) # (x, y, time) visited = set((0, 0)) while queue: x, y, time = queue.popleft() # if we have reached the bottom-right corner if x == n - 1 and y == m - 1: return time for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, time + 1)) return -1"},{"question":"def min_travel_time(n, T): Calculate the minimum travel time required to visit all cities and return to the home city. >>> min_travel_time(4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]) 80 >>> min_travel_time(3, [ [0, 5, 9], [5, 0, 7], [9, 7, 0] ]) 21 from itertools import permutations def test_min_travel_time(): assert min_travel_time(4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]) == 80 assert min_travel_time(3, [ [0, 5, 9], [5, 0, 7], [9, 7, 0] ]) == 21 assert min_travel_time(2, [ [0, 100], [100, 0] ]) == 200 assert min_travel_time(4, [ [0, 1, 10, 10], [1, 0, 10, 10], [10, 10, 0, 1], [10, 10, 1, 0] ]) == 22 assert min_travel_time(3, [ [0, 1, 2], [1, 0, 1], [2, 1, 0] ]) == 4","solution":"import itertools def min_travel_time(n, T): # Generate all permutations of the cities [1, 2, ..., n-1] (excluding the home city 0) permutations = itertools.permutations(range(1, n)) min_time = float('inf') for perm in permutations: current_time = T[0][perm[0]] # Start at home city (0) for i in range(len(perm) - 1): current_time += T[perm[i]][perm[i + 1]] current_time += T[perm[-1]][0] # Return to the home city (0) min_time = min(min_time, current_time) return min_time"},{"question":"from typing import List, Tuple def sort_packets(packets: List[Tuple[int, int]]) -> List[int]: Sorts the packets by their timestamps and returns the list of packet identifiers. Parameters: packets (List[Tuple[int, int]]): A list of tuples, each containing an id and a timestamp. Returns: List[int]: A list of packet identifiers sorted by their timestamps. Example: >>> sort_packets([(3, 1001), (2, 1000), (1, 1002)]) [2, 3, 1]","solution":"from typing import List, Tuple def sort_packets(packets: List[Tuple[int, int]]) -> List[int]: Sorts the packets by their timestamps and returns the list of packet identifiers. Parameters: packets (List[Tuple[int, int]]): A list of tuples, each containing an id and a timestamp. Returns: List[int]: A list of packet identifiers sorted by their timestamps. sorted_packets = sorted(packets, key=lambda packet: packet[1]) return [packet[0] for packet in sorted_packets]"},{"question":"def min_distance(word1: str, word2: str) -> int: Computes the minimum number of operations required to convert word1 to word2. >>> min_distance(\\"horse\\", \\"ros\\") # 3 >>> min_distance(\\"abc\\", \\"abcd\\") # 1 >>> min_distance(\\"abcd\\", \\"abc\\") # 1 >>> min_distance(\\"abcd\\", \\"abcf\\") # 1 >>> min_distance(\\"intention\\", \\"execution\\") # 5 >>> min_distance(\\"\\", \\"abcdef\\") # 6 >>> min_distance(\\"abcdef\\", \\"\\") # 6 >>> min_distance(\\"\\", \\"\\") # 0 >>> min_distance(\\"same\\", \\"same\\") # 0","solution":"def min_distance(word1, word2): Computes the minimum number of operations required to convert word1 to word2 m, n = len(word1), len(word2) # Create a DP table to memoize the results dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases: transforming a string to an empty string for i in range(m + 1): dp[i][0] = i # word1 -> \\"\\" for j in range(n + 1): dp[0][j] = j # \\"\\" -> word2 # Update the dp table based on the possible operations for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: # If chars match, no more operations needed dp[i][j] = dp[i - 1][j - 1] else: # Otherwise, take the minimum of the three possible operations dp[i][j] = 1 + min(dp[i - 1][j], # Delete from word1 dp[i][j - 1], # Insert to word1 dp[i - 1][j - 1]) # Replace character return dp[m][n]"},{"question":"def max_sum_with_one_removal(arr: List[int]) -> int: Find the maximum possible sum of a contiguous subarray of the given array, allowing the removal of at most one element. >>> max_sum_with_one_removal([1, -2, 0, 3, -1]) 4 >>> max_sum_with_one_removal([-1, -1, -1]) -1","solution":"def max_sum_with_one_removal(arr): n = len(arr) if n == 1: return arr[0] max_ending_here = [0] * n max_starting_here = [0] * n max_ending_here[0] = arr[0] max_starting_here[n-1] = arr[n-1] for i in range(1, n): max_ending_here[i] = max(arr[i], max_ending_here[i-1] + arr[i]) for i in range(n-2, -1, -1): max_starting_here[i] = max(arr[i], max_starting_here[i+1] + arr[i]) max_subarray_sum = max(max_ending_here) for i in range(1, n-1): max_subarray_sum = max(max_subarray_sum, max_ending_here[i-1] + max_starting_here[i+1]) return max_subarray_sum"},{"question":"def min_path_cost(grid): Calculate the minimum total cost required to create a clear path from the top-left to the bottom-right corner of the grid where only right and down moves are allowed. The cost of cutting down a tree is equal to its height. Args: grid (List[List[int]]): a 2D list representing the forest grid Returns: int: the minimum total cost >>> min_path_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_cost([[1, 2, 3, 4]]) 10 >>> min_path_cost([[1], [2], [3], [4]]) 10 >>> min_path_cost([[5]]) 5 >>> min_path_cost([[1000000000, 1000000000], [1000000000, 1000000000]]) 3000000000 pass def min_path_cost_from_input(grid_input): Calculate the minimum total cost required to create a clear path from the top-left to the bottom-right corner of the grid given in input format. Args: grid_input (str): input string representing the forest grid Returns: int: the minimum total cost >>> min_path_cost_from_input('3 3n1 3 1n1 5 1n4 2 1') 7 >>> min_path_cost_from_input('1 4n1 2 3 4') 10 >>> min_path_cost_from_input('4 1n1n2n3n4') 10 pass","solution":"def min_path_cost(grid): n = len(grid) m = len(grid[0]) # Initialize a DP table dp = [[float('inf')] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(n): for j in range(m): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]) return dp[n-1][m-1] def min_path_cost_from_input(grid_input): grid_input = grid_input.strip().split('n') n, m = map(int, grid_input[0].split()) grid = [[int(x) for x in line.split()] for line in grid_input[1:]] return min_path_cost(grid)"},{"question":"from typing import List def min_completion_time(tasks: List[int]) -> int: You are given an array of n integers, where each integer represents the amount of time it takes to complete a particular task. You need to distribute these tasks between two workers such that the time taken to complete all the tasks is minimized. Each worker can work on multiple tasks sequentially, but a task cannot be divided between the workers. Write a function that takes the array of task times as input and returns the minimum time required to complete all tasks when the tasks are optimally distributed between the two workers. >>> min_completion_time([5]) 5 >>> min_completion_time([4, 4]) 4 >>> min_completion_time([3, 1]) 3 >>> min_completion_time([2, 3, 5, 7, 10]) 14 >>> min_completion_time([6, 6, 6, 6]) 12 >>> min_completion_time([1] * 1000) 500","solution":"from typing import List def min_completion_time(tasks: List[int]) -> int: total_time = sum(tasks) half_time = total_time // 2 n = len(tasks) # Using Knapsack DP approach to partition tasks dp = [0] * (half_time + 1) for task in tasks: for t in range(half_time, task - 1, -1): dp[t] = max(dp[t], dp[t - task] + task) best_partition = dp[half_time] return max(best_partition, total_time - best_partition)"},{"question":"def min_difference(arr: List[int]) -> int: Calculate the minimum absolute difference between the sums of two subsets of an array. >>> min_difference([1, 6, 11, 5]) 1 >>> min_difference([3, 1, 4]) 0 >>> min_difference([10]) 10 >>> min_difference([5, 5]) 0 >>> min_difference([2, 3, 7]) 2 >>> min_difference([10, 20, 15, 5, 25]) 5","solution":"def min_difference(arr): n = len(arr) total_sum = sum(arr) target = total_sum // 2 # DP array to record reachable sums dp = [False] * (total_sum + 1) dp[0] = True for num in arr: for j in range(total_sum, num - 1, -1): if dp[j - num]: dp[j] = True # Find the largest sum closest to target that is achievable for i in range(target, -1, -1): if dp[i]: subset1_sum = i subset2_sum = total_sum - i return abs(subset1_sum - subset2_sum)"},{"question":"def is_complete_graph(n: int, m: int, edges: List[Tuple[int, int]]) -> List[str]: Determines if the graph is complete after each edge is added. Parameters: - n: number of nodes - m: number of edges - edges: list of tuples where each tuple represents an edge (u, v) Returns: - list of strings \\"Complete\\" or \\"Incomplete\\" at each step of adding an edge >>> is_complete_graph(4, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)]) ['Incomplete', 'Incomplete', 'Incomplete', 'Incomplete', 'Incomplete', 'Complete'] >>> is_complete_graph(2, 1, [(1, 2)]) ['Complete'] >>> is_complete_graph(3, 3, [(1, 2), (2, 3), (1, 3)]) ['Incomplete', 'Incomplete', 'Complete']","solution":"def is_complete_graph(n, m, edges): Determines if the graph is complete after each edge is added. Parameters: - n: number of nodes - m: number of edges - edges: list of tuples where each tuple represents an edge (u, v) Returns: - list of strings \\"Complete\\" or \\"Incomplete\\" at each step of adding an edge # Track the number of edges added added_edges = 0 # Maximum number of edges in a complete graph max_edges = n * (n - 1) // 2 result = [] for edge in edges: added_edges += 1 if added_edges == max_edges: result.append(\\"Complete\\") else: result.append(\\"Incomplete\\") return result"},{"question":"from typing import List, Tuple def min_operations_to_equal(l: int, r: int, x: int, a: List[int]) -> int: Returns the minimum number of operations to make any element in the segment [l, r] equal to x. If it's impossible, returns -1. pass def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Processes a list of queries on the given array and returns the results as a list. pass if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) q = int(data[1]) array = list(map(int, data[2:n+2])) queries = [] for i in range(q): l = int(data[n+2 + i*3]) r = int(data[n+3 + i*3]) x = int(data[n+4 + i*3]) queries.append((l, r, x)) results = process_queries(n, q, array, queries) for result in results: print(result) # Unit Tests: def test_min_operations_to_equal(): assert min_operations_to_equal(1, 3, 2, [1, 2, 3, 4, 5]) == 0 assert min_operations_to_equal(2, 5, 8, [1, 2, 3, 4, 5]) == 3 assert min_operations_to_equal(1, 5, 10, [1, 2, 3, 4, 5]) == 5 assert min_operations_to_equal(1, 3, 10, [1, 1, 1]) == 9 assert min_operations_to_equal(1, 1, 1, [2]) == -1 def test_process_queries(): assert process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 5, 8), (1, 5, 10)]) == [0, 3, 5] assert process_queries(3, 2, [1, 1, 1], [(1, 3, 10), (1, 2, 1)]) == [9, 0] def test_edge_cases(): assert process_queries(5, 2, [1, 2, 2, 4, 4], [(2, 4, 2), (3, 5, 4)]) == [0, 0] assert process_queries(5, 2, [3, 3, 3, 3, 3], [(1, 5, 6), (1, 3, 2)]) == [3, -1] assert process_queries(5, 2, [5, 5, 5, 5, 5], [(3, 5, 1), (1, 5, 5)]) == [-1, 0]","solution":"def min_operations_to_equal(l, r, x, a): Returns the minimum number of operations to make any element in the segment [l, r] equal to x. If it's impossible, returns -1. min_ops = float('inf') possible = False for i in range(l - 1, r): difference = x - a[i] if difference >= 0: min_ops = min(min_ops, difference) possible = True return min_ops if possible else -1 def process_queries(n, q, array, queries): Processes a list of queries on the given array and returns the results as a list. results = [] for query in queries: l, r, x = query results.append(min_operations_to_equal(l, r, x, array)) return results"},{"question":"def cbt_node_count(h: int, k: int) -> int: Determines the number of nodes in a Complete Binary Tree of height h with each non-leaf node having exactly k children. Params: h (int): Height of the binary tree k (int): Number of children each non-leaf node should have (1 or 2) Returns: int: Total number of nodes if such a tree can be constructed, otherwise -1 Examples: >>> cbt_node_count(3, 2) 7 >>> cbt_node_count(2, 1) -1","solution":"def cbt_node_count(h, k): Determines the number of nodes in a Complete Binary Tree of height h with each non-leaf node having exactly k children. Params: h (int): Height of the binary tree k (int): Number of children each non-leaf node should have (1 or 2) Returns: int: Total number of nodes if such a tree can be constructed, otherwise -1 if k == 2: # For k = 2, a full binary tree of height h has (2^h - 1) nodes return (2 ** h) - 1 else: # k == 1 # For k = 1, it's impossible to construct a complete binary tree except h = 1 return -1"},{"question":"from typing import List, Tuple def can_reach_goal(n: int, m: int, grid: List[str]) -> str: Determines if there is a path from the start (1, 1) to the goal (n, m) on the given grid avoiding walls and traps. >>> can_reach_goal(3, 3, ['S..', '.#.', '..E']) == \\"Yes\\" >>> can_reach_goal(2, 2, ['S*', '*E']) == \\"No\\" >>> can_reach_goal(4, 4, ['S...', '.#*#', '..*.', '...E']) == \\"Yes\\" >>> can_reach_goal(1, 1, ['SE']) == \\"Yes\\" >>> can_reach_goal(3, 3, ['S#.', '#.#', '.#E']) == \\"No\\" def solve(test_cases: List[Tuple[int, int, List[str]]]) -> List[str]: Solves multiple test cases for the can_reach_goal function. >>> solve([(3, 3, ['S..', '.#.', '..E']), (2, 2, ['S*', '*E']), (4, 4, ['S...', '.#*#', '..*.', '...E'])]) == [\\"Yes\\", \\"No\\", \\"Yes\\"] if __name__ == \\"__main__\\": # Example usage t = 3 test_cases = [ (3, 3, ['S..', '.#.', '..E']), (2, 2, ['S*', '*E']), (4, 4, ['S...', '.#*#', '..*.', '...E']), ] results = solve(test_cases) for result in results: print(result)","solution":"from collections import deque def can_reach_goal(n, m, grid): Determines if there is a path from the start (1, 1) to the goal (n, m) on the given grid avoiding walls and traps. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n - 1, m - 1): return \\"Yes\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: if grid[nx][ny] not in ('#', '*'): queue.append((nx, ny)) visited.add((nx, ny)) return \\"No\\" def solve(test_cases): results = [] for case in test_cases: n, m, grid = case results.append(can_reach_goal(n, m, grid)) return results"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Given a string s and an integer k, determine the length of the longest substring of s that contains at most k distinct characters. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"aaabbcc\\", 3) 7 >>> longest_substring_with_k_distinct(\\"aaaaaaa\\", 1) 7","solution":"def longest_substring_with_k_distinct(s, k): if not s or k <= 0: return 0 # Dict to count the frequency of characters in the current window char_frequency = {} max_length = 0 start = 0 for end in range(len(s)): current_char = s[end] char_frequency[current_char] = char_frequency.get(current_char, 0) + 1 # Shrink the sliding window until we have at most k distinct characters while len(char_frequency) > k: start_char = s[start] char_frequency[start_char] -= 1 if char_frequency[start_char] == 0: del char_frequency[start_char] start += 1 # Update the maximum length of the substring found max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_largest_square(matrix: List[List[int]]) -> int: Returns the area of the largest square containing only 1s in a binary matrix. >>> find_largest_square([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) == 4 >>> find_largest_square([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> find_largest_square([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 9 >>> find_largest_square([ ... [1, 1, 1, 1] ... ]) == 1 >>> find_largest_square([ ... [1], ... [1], ... [1], ... [1] ... ]) == 1 >>> find_largest_square([ ... [1, 0, 0, 1], ... [0, 1, 1, 0], ... [1, 1, 1, 1], ... [0, 1, 1, 0] ... ]) == 4 >>> find_largest_square([]) == 0 >>> find_largest_square([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> find_largest_square([ ... [1] ... ]) == 1 >>> find_largest_square([ ... [0] ... ]) == 0 pass","solution":"def find_largest_square(matrix): Returns the area of the largest square containing only 1s in a binary matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) max_side = 0 dp = [[0]*m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Return the length of the longest palindromic subsequence in the string s. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 >>> longest_palindromic_subsequence(\\"abcba\\") 5 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"abcd\\") 1 >>> longest_palindromic_subsequence(\\"racecar\\") 7 def solve(input_list: List[Union[int, str]]) -> List[int]: Solve the problem for multiple test cases. >>> solve([3, \\"bbbab\\", \\"cbbd\\", \\"abcba\\"]) [4, 2, 5] >>> solve([2, \\"a\\", \\"abcd\\"]) [1, 1]","solution":"def longest_palindromic_subsequence(s): Return the length of the longest palindromic subsequence in the string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1] def solve(input_list): t = input_list[0] results = [] for i in range(1, t + 1): s = input_list[i] result = longest_palindromic_subsequence(s) results.append(result) return results"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) self.lazy = [0] * (2 * self.n) def _apply(self, pos, value): self.tree[pos] += value if pos < self.n: self.lazy[pos] += value def _build(self, pos): while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) + self.lazy[pos] def _push(self, pos): for s in range(self.n.bit_length(), 0, -1): i = pos >> s if self.lazy[i] != 0: self._apply(i * 2, self.lazy[i]) self._apply(i * 2 + 1, self.lazy[i]) self.lazy[i] = 0 def range_add(self, l, r, value): l += self.n r += self.n l0, r0 = l, r while l <= r: if l % 2 == 1: self._apply(l, value) l += 1 if r % 2 == 0: self._apply(r, value) r -= 1 l //= 2 r //= 2 self._build(l0) self._build(r0) def range_query(self, l, r): l += self.n r += self.n self._push(l) self._push(r) max_val = 0 while l <= r: if l % 2 == 1: max_val = max(max_val, self.tree[l]) l += 1 if r % 2 == 0: max_val = max(max_val, self.tree[r]) r -= 1 l //= 2 r //= 2 return max_val def process_queries(n: int, q: int, brightness: List[int], queries: List[List[int]]) -> List[int]: Process the lamp post brightness adjustment and query tasks. >>> process_queries(5, 4, [1, 2, 3, 4, 5], [[1, 2, 4, 2], [2, 1, 5], [1, 3, 5, 1], [2, 2, 3]]) [6, 6] >>> process_queries(4, 3, [7, 7, 7, 7], [[1, 1, 4, 3], [2, 1, 4], [1, 2, 3, 1]]) [10] >>> process_queries(6, 4, [1, 2, 3, 4, 5, 6], [[1, 1, 6, 1], [2, 1, 6], [1, 3, 5, 5], [2, 2, 4]]) [7, 10]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the segment tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) self.lazy = [0] * (2 * self.n) def _apply(self, pos, value): self.tree[pos] += value if pos < self.n: self.lazy[pos] += value def _build(self, pos): while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) + self.lazy[pos] def _push(self, pos): for s in range(self.n.bit_length(), 0, -1): i = pos >> s if self.lazy[i] != 0: self._apply(i * 2, self.lazy[i]) self._apply(i * 2 + 1, self.lazy[i]) self.lazy[i] = 0 def range_add(self, l, r, value): l += self.n r += self.n l0, r0 = l, r while l <= r: if l % 2 == 1: self._apply(l, value) l += 1 if r % 2 == 0: self._apply(r, value) r -= 1 l //= 2 r //= 2 self._build(l0) self._build(r0) def range_query(self, l, r): l += self.n r += self.n self._push(l) self._push(r) max_val = 0 while l <= r: if l % 2 == 1: max_val = max(max_val, self.tree[l]) l += 1 if r % 2 == 0: max_val = max(max_val, self.tree[r]) r -= 1 l //= 2 r //= 2 return max_val def process_queries(n, q, brightness, queries): seg_tree = SegmentTree(brightness) result = [] for query in queries: if query[0] == 1: _, l, r, b = query seg_tree.range_add(l - 1, r - 1, b) elif query[0] == 2: _, l, r = query result.append(seg_tree.range_query(l - 1, r - 1)) return result # Example usage: # n = 5 # q = 4 # brightness = [1, 2, 3, 4, 5] # queries = [ # [1, 2, 4, 2], # [2, 1, 5], # [1, 3, 5, 1], # [2, 2, 3] # ] # print(process_queries(n, q, brightness, queries))"},{"question":"def max_histogram_area(heights: List[int]) -> int: Calculate the maximum rectangular area that can be formed in a histogram. Parameters: heights (List[int]): List of integers representing the height of each block in the histogram. Returns: int: The maximum rectangular area. >>> max_histogram_area([2, 1, 5, 6, 2, 3]) 10 >>> max_histogram_area([2, 4]) 4 >>> max_histogram_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> max_histogram_area([1, 2, 3, 4, 5]) 9 >>> max_histogram_area([5, 4, 3, 2, 1]) 9 >>> max_histogram_area([1]) 1 >>> max_histogram_area([1, 1, 1, 1, 1]) 5","solution":"def max_histogram_area(heights): Calculate the maximum rectangular area that can be formed in a histogram. Parameters: heights (List[int]): List of integers representing the height of each block in the histogram. Returns: int: The maximum rectangular area. stack = list() max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def can_modules_be_reviewed(n: int, m: int, capacities: List[int], complexities: List[int]) -> str: Determines if it's possible to assign all the modules to the engineers such that no engineer exceeds their capacity and all modules get reviewed. Parameters: n (int): Number of engineers m (int): Number of modules capacities (list of int): Capacities of the engineers complexities (list of int): Complexities of the modules Returns: str: \\"YES\\" if it is possible to do the assignment, else \\"NO\\" >>> can_modules_be_reviewed(3, 5, [500, 1000, 300], [200, 100, 400, 500, 300]) \\"YES\\" >>> can_modules_be_reviewed(2, 2, [1, 2], [2, 3]) \\"NO\\" >>> can_modules_be_reviewed(2, 2, [5, 5], [4, 4]) \\"YES\\" >>> can_modules_be_reviewed(2, 2, [10, 10], [5, 6]) \\"YES\\" >>> can_modules_be_reviewed(2, 2, [10, 9], [5, 6]) \\"YES\\" >>> can_modules_be_reviewed(3, 4, [10, 10, 10], [10, 10, 10, 1]) \\"NO\\" >>> can_modules_be_reviewed(3, 3, [1000, 1000, 1000], [999, 999, 999]) \\"YES\\" >>> can_modules_be_reviewed(3, 4, [20, 200, 200], [100, 100, 110, 110]) \\"NO\\"","solution":"def can_modules_be_reviewed(n, m, capacities, complexities): Determines if it's possible to assign all the modules to the engineers such that no engineer exceeds their capacity and all modules get reviewed. Parameters: n (int): Number of engineers m (int): Number of modules capacities (list of int): Capacities of the engineers complexities (list of int): Complexities of the modules Returns: str: \\"YES\\" if it is possible to do the assignment, else \\"NO\\" # Sort capacities in ascending order capacities.sort() # Sort complexities in descending order complexities.sort(reverse=True) if sum(complexities) > sum(capacities): return \\"NO\\" for complexity in complexities: for i in range(n): if capacities[i] >= complexity: capacities[i] -= complexity break else: return \\"NO\\" return \\"YES\\""},{"question":"def determine_primary_cookie_type(c, p, o): Determine the primary cookie type based on the count provided. # Implement this function to return the primary cookie type as a string if there is one, # otherwise return None if there is a tie. def can_arrange_boxes(n, boxes): Determine if the boxes can be arranged so that no two adjacent boxes have the same primary cookie type. >>> can_arrange_boxes(3, [(5, 3, 2), (1, 4, 3), (2, 2, 5)]) \\"Possible\\" >>> can_arrange_boxes(2, [(3, 3, 1), (4, 4, 4)]) \\"Impossible\\" from solution import can_arrange_boxes def test_example_1(): boxes = [(5, 3, 2), (1, 4, 3), (2, 2, 5)] assert can_arrange_boxes(3, boxes) == \\"Possible\\" def test_example_2(): boxes = [(3, 3, 1), (4, 4, 4)] assert can_arrange_boxes(2, boxes) == \\"Impossible\\" def test_single_box(): boxes = [(5, 0, 0)] assert can_arrange_boxes(1, boxes) == \\"Possible\\" def test_tie_primary_cookies(): boxes = [(2, 2, 2), (4, 0, 0)] assert can_arrange_boxes(2, boxes) == \\"Impossible\\" def test_alternating_primary_cookies(): boxes = [(1, 0, 0), (0, 1, 0), (0, 0, 1)] assert can_arrange_boxes(3, boxes) == \\"Possible\\" def test_all_same_type(): boxes = [(5, 0, 0), (5, 0, 0), (5, 0, 0)] assert can_arrange_boxes(3, boxes) == \\"Impossible\\"","solution":"def determine_primary_cookie_type(c, p, o): Determine the primary cookie type based on the count provided. If there is a tie, return None. if c > p and c > o: return \\"Chocolate Chip\\" elif p > c and p > o: return \\"Peanut Butter\\" elif o > c and o > p: return \\"Oatmeal Raisin\\" else: return None def can_arrange_boxes(n, boxes): Determine if the boxes can be arranged so that no two adjacent boxes have the same primary cookie type. primary_types = [] for box in boxes: primary_type = determine_primary_cookie_type(*box) if primary_type is None: return \\"Impossible\\" primary_types.append(primary_type) for i in range(1, len(primary_types)): if primary_types[i] == primary_types[i-1]: return \\"Impossible\\" return \\"Possible\\" # Example usage: # boxes = [(5, 3, 2), (1, 4, 3), (2, 2, 5)] # print(can_arrange_boxes(3, boxes)) # Output: Possible"},{"question":"def array_shift(arr: list[int], direction: str, positions: int) -> list[int]: Shifts elements in the array either to the left or right by a given number of positions. Elements that shift beyond the end of the array come back around to the beginning. >>> array_shift([1, 2, 3, 4, 5], 'left', 2) [3, 4, 5, 1, 2] >>> array_shift([1, 2, 3, 4, 5], 'right', 2) [4, 5, 1, 2, 3] >>> array_shift([], 'left', 2) [] >>> array_shift([1, 2, 3], 'up', 2) Traceback (most recent call last): ... ValueError: Invalid direction. Use 'left' or 'right'.","solution":"def array_shift(arr: list[int], direction: str, positions: int) -> list[int]: Shifts elements in the array either to the left or right by a given number of positions. Elements that shift beyond the end of the array come back around to the beginning. Parameters: arr (list[int]): The array to be shifted direction (str): The direction to shift ('left' or 'right') positions (int): The number of positions to shift Returns: list[int]: The shifted array n = len(arr) if n == 0: return arr positions = positions % n # Normalize positions to be within the bounds of the array length if direction == 'left': return arr[positions:] + arr[:positions] elif direction == 'right': return arr[-positions:] + arr[:-positions] else: raise ValueError(\\"Invalid direction. Use 'left' or 'right'.\\")"},{"question":"from typing import List def find_matching_strings(strings: List[str], pattern: str) -> List[str]: Find all strings in the list that contain all characters of the pattern in any order. The matching strings must contain all characters of the pattern including duplicates. Args: strings (List[str]): List of strings to check. pattern (str): Pattern of characters to match. Returns: List[str]: List of strings that match the pattern. Example: >>> find_matching_strings([\\"abcdef\\", \\"bcda\\", \\"catd\\", \\"bat\\"], \\"abc\\") [\\"abcdef\\", \\"bcda\\"] >>> find_matching_strings([\\"abc\\", \\"bac\\", \\"cab\\"], \\"abc\\") [\\"abc\\", \\"bac\\", \\"cab\\"]","solution":"def find_matching_strings(strings, pattern): from collections import Counter pattern_counter = Counter(pattern) def contains_all_pattern_chars(s): s_counter = Counter(s) for char, count in pattern_counter.items(): if s_counter[char] < count: return False return True return [s for s in strings if contains_all_pattern_chars(s)]"},{"question":"def total_distance_after_laps(n: int, l: int, participants: List[Tuple[int, int]]) -> int: Determine the total distance covered by all participants after a given number of laps. Args: n : int : Number of participants (1 ≤ n ≤ 100) l : int : Number of laps (1 ≤ l ≤ 1000) participants : List[Tuple[int, int]] : List of tuples where each tuple contains starting speed (s) and speed increment per lap (d) for each participant (1 ≤ s, d ≤ 100) Returns: int : Total distance covered by all participants after l laps Example: >>> total_distance_after_laps(2, 3, [(3, 2), (5, 1)]) 33 >>> total_distance_after_laps(1, 4, [(2, 3)]) 26","solution":"def total_distance_after_laps(n, l, participants): Returns the total distance covered by all participants after l laps. Args: n : int : Number of participants l : int : Number of laps participants : List[Tuple[int, int]] : List of tuples where each tuple contains starting speed and speed increment per lap Returns: int : Total distance covered by all participants after l laps total_distance = 0 for s, d in participants: # The distance covered by this participant after l laps: distance = sum(s + i * d for i in range(l)) total_distance += distance return total_distance"},{"question":"from typing import List def check_ids(ids: List[str]) -> List[bool]: Given a list of strings, determine if each string is a valid ID. A valid ID must be exactly five characters long, start with two uppercase English letters, have a digit between '2' and '9' as the third character, and end with two lowercase English letters. >>> check_ids([\\"AB3cd\\", \\"A2bcd\\", \\"XY9xy\\", \\"XY99z\\", \\"XYyz8\\"]) [True, False, True, False, False] pass","solution":"from typing import List def check_ids(ids: List[str]) -> List[bool]: valid_ids = [] for id_str in ids: if (len(id_str) == 5 and id_str[0].isupper() and id_str[1].isupper() and id_str[2].isdigit() and '2' <= id_str[2] <= '9' and id_str[3].islower() and id_str[4].islower()): valid_ids.append(True) else: valid_ids.append(False) return valid_ids"},{"question":"def smallest_subsequence_length(t: int, test_cases: List[str]) -> List[int]: Given an integer t and a list of t test cases containing strings, returns a list of integers where each integer is the length of the smallest subsequence that contains all unique characters from each input string at least once. >>> smallest_subsequence_length(3, [\\"abcabc\\", \\"abacaba\\", \\"abcdabcd\\"]) == [3, 3, 4] >>> smallest_subsequence_length(1, [\\"a\\"]) == [1] >>> smallest_subsequence_length(1, [\\"z\\"]) == [1] >>> smallest_subsequence_length(1, [\\"aaaaaa\\"]) == [1] >>> smallest_subsequence_length(2, [\\"aabbccddee\\", \\"abcde\\"]) == [5, 5] >>> smallest_subsequence_length(1, [\\"a\\" * 1000]) == [1] >>> smallest_subsequence_length(1, [\\"\\".join(chr(97 + i % 26) for i in range(1000))]) == [26] >>> smallest_subsequence_length(5, [\\"abcd\\", \\"aaabbbccc\\", \\"xyzxyz\\", \\"xxyyzz\\", \\"aaa\\"]) == [4, 3, 3, 3, 1]","solution":"def smallest_subsequence_length(t, test_cases): Given an integer t and a list of t test cases containing strings, returns a list of integers where each integer is the length of the smallest subsequence that contains all unique characters from each input string at least once. result = [] for s in test_cases: unique_chars = set(s) result.append(len(unique_chars)) return result"},{"question":"def fib(n: int) -> int: Calculate the nth Fibonacci number. The Fibonacci sequence is defined as follows: - Fib(1) = 1 - Fib(2) = 1 - Fib(n) = Fib(n-1) + Fib(n-2) for n > 2 >>> fib(1) 1 >>> fib(2) 1 >>> fib(3) 2 >>> fib(4) 3 >>> fib(5) 5 >>> fib(6) 8 >>> fib(7) 13 >>> fib(8) 21 >>> fib(9) 34 >>> fib(10) 55 >>> fib(11) 89 >>> fib(12) 144","solution":"def fib(n): Returns the nth Fibonacci number. :param n: The position in the Fibonacci sequence (1 ≤ n ≤ 12). :return: The nth Fibonacci number. if n == 1 or n == 2: return 1 a, b = 1, 1 for _ in range(3, n + 1): a, b = b, a + b return b"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (4 * self.n) self.max_tree = [float('-inf')] * (4 * self.n) self._build_segment_tree(data, 0, 0, self.n - 1) def _build_segment_tree(self, data, node, start, end): if start == end: self.tree[node] = data[start] self.max_tree[node] = data[start] else: mid = (start + end) // 2 self._build_segment_tree(data, 2 * node + 1, start, mid) self._build_segment_tree(data, 2 * node + 2, mid + 1, end) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] self.max_tree[node] = max(self.max_tree[2 * node + 1], self.max_tree[2 * node + 2]) def update(self, idx, value): self._update_util(0, 0, self.n - 1, idx, value) def _update_util(self, node, start, end, idx, value): if start == end: self.tree[node] = value self.max_tree[node] = value else: mid = (start + end) // 2 if start <= idx <= mid: self._update_util(2 * node + 1, start, mid, idx, value) else: self._update_util(2 * node + 2, mid + 1, end, idx, value) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] self.max_tree[node] = max(self.max_tree[2 * node + 1], self.max_tree[2 * node + 2]) def sum_range(self, l, r): return self._sum_range_util(0, 0, self.n - 1, l, r) def _sum_range_util(self, node, start, end, l, r): if r < start or l > end: return 0 if l <= start and end <= r: return self.tree[node] mid = (start + end) // 2 left_sum = self._sum_range_util(2 * node + 1, start, mid, l, r) right_sum = self._sum_range_util(2 * node + 2, mid + 1, end, l, r) return left_sum + right_sum def max_range(self, l, r): return self._max_range_util(0, 0, self.n - 1, l, r) def _max_range_util(self, node, start, end, l, r): if r < start or l > end: return float('-inf') if l <= start and end <= r: return self.max_tree[node] mid = (start + end) // 2 left_max = self._max_range_util(2 * node + 1, start, mid, l, r) right_max = self._max_range_util(2 * node + 2, mid + 1, end, l, r) return max(left_max, right_max) def process_queries(n: int, q: int, initial_sequence: List[int], queries: List[str]) -> List[int]: Process a list of queries on a sequence of integers. Each query can update a position, calculate the sum of a range, or find the maximum in a range. Args: n (int): The number of elements in the initial sequence. q (int): The number of queries. initial_sequence (List[int]): The initial sequence of integers. queries (List[str]): The list of queries to process. Returns: List[int]: The list of results for sum and max queries. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [\\"1 3 6\\", \\"2 1 3\\", \\"2 3 5\\"]) [9, 15] >>> process_queries(5, 3, [1, 2, 3, 4, 5], [\\"1 2 10\\", \\"3 2 4\\", \\"3 1 5\\"]) [10, 10] pass","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (4 * self.n) self.max_tree = [float('-inf')] * (4 * self.n) self._build_segment_tree(data, 0, 0, self.n - 1) def _build_segment_tree(self, data, node, start, end): if start == end: self.tree[node] = data[start] self.max_tree[node] = data[start] else: mid = (start + end) // 2 self._build_segment_tree(data, 2 * node + 1, start, mid) self._build_segment_tree(data, 2 * node + 2, mid + 1, end) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] self.max_tree[node] = max(self.max_tree[2 * node + 1], self.max_tree[2 * node + 2]) def update(self, idx, value): self._update_util(0, 0, self.n - 1, idx, value) def _update_util(self, node, start, end, idx, value): if start == end: self.tree[node] = value self.max_tree[node] = value else: mid = (start + end) // 2 if start <= idx <= mid: self._update_util(2 * node + 1, start, mid, idx, value) else: self._update_util(2 * node + 2, mid + 1, end, idx, value) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] self.max_tree[node] = max(self.max_tree[2 * node + 1], self.max_tree[2 * node + 2]) def sum_range(self, l, r): return self._sum_range_util(0, 0, self.n - 1, l, r) def _sum_range_util(self, node, start, end, l, r): if r < start or l > end: return 0 if l <= start and end <= r: return self.tree[node] mid = (start + end) // 2 left_sum = self._sum_range_util(2 * node + 1, start, mid, l, r) right_sum = self._sum_range_util(2 * node + 2, mid + 1, end, l, r) return left_sum + right_sum def max_range(self, l, r): return self._max_range_util(0, 0, self.n - 1, l, r) def _max_range_util(self, node, start, end, l, r): if r < start or l > end: return float('-inf') if l <= start and end <= r: return self.max_tree[node] mid = (start + end) // 2 left_max = self._max_range_util(2 * node + 1, start, mid, l, r) right_max = self._max_range_util(2 * node + 2, mid + 1, end, l, r) return max(left_max, right_max) def process_queries(n, q, initial_sequence, queries): segment_tree = SegmentTree(initial_sequence) results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": x = int(parts[1]) - 1 y = int(parts[2]) segment_tree.update(x, y) elif parts[0] == \\"2\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 results.append(segment_tree.sum_range(l, r)) elif parts[0] == \\"3\\": l = int(parts[1]) - 1 r = int(parts[2]) - 1 results.append(segment_tree.max_range(l, r)) return results"},{"question":"from typing import List, Tuple def max_subarray_info(nums: List[int]) -> Tuple[int, int]: Given an unsorted integer array \`nums\`, find the maximum sum of a contiguous subarray and the length of the shortest subarray that has the maximum sum. Args: nums (List[int]): The list of unsorted integers. Returns: Tuple[int, int]: A tuple where the first element is the maximum sum of a contiguous subarray, and the second element is the length of the shortest subarray with that sum. >>> max_subarray_info([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 4) >>> max_subarray_info([1]) (1, 1) >>> max_subarray_info([5, 4, -1, 7, 8]) (23, 5)","solution":"from typing import List, Tuple def max_subarray_info(nums: List[int]) -> Tuple[int, int]: max_sum = float('-inf') current_sum = 0 start = 0 min_length = float('inf') for end in range(len(nums)): if current_sum <= 0: current_sum = nums[end] start = end else: current_sum += nums[end] if current_sum > max_sum: max_sum = current_sum min_length = end - start + 1 elif current_sum == max_sum: min_length = min(min_length, end - start + 1) return max_sum, min_length"},{"question":"def is_palindromic(num: int) -> bool: Returns True if the given num is palindromic, False otherwise. >>> is_palindromic(121) True >>> is_palindromic(123) False pass def sieve_of_eratosthenes(n: int) -> List[bool]: Generates a list of booleans representing prime status for numbers from 0 to n. True means prime, False means not prime. >>> sieve_of_eratosthenes(10)[2:11] [True, True, False, True, False, True, False, False, False] pass def count_prime_palindromic(L: int, R: int) -> int: Returns the count of numbers that are both prime and palindromic between L and R (inclusive). >>> count_prime_palindromic(10, 100) 1 >>> count_prime_palindromic(2, 10) 4 >>> count_prime_palindromic(1, 1) 0 >>> count_prime_palindromic(1000, 1100) 0 >>> count_prime_palindromic(1, 1000000) > 1 # general test to see it handles large ranges True pass","solution":"def is_palindromic(num): Returns True if the given num is palindromic, False otherwise. return str(num) == str(num)[::-1] def sieve_of_eratosthenes(n): Generates a list of booleans representing prime status for numbers from 0 to n. True means prime, False means not prime. is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for p in range(2, int(n**0.5) + 1): if is_prime[p]: for multiple in range(p*p, n + 1, p): is_prime[multiple] = False return is_prime def count_prime_palindromic(L, R): Returns the count of numbers that are both prime and palindromic between L and R (inclusive). is_prime = sieve_of_eratosthenes(R) count = 0 for num in range(L, R + 1): if is_prime[num] and is_palindromic(num): count += 1 return count"},{"question":"def process_queries(n: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process a series of range queries to find the maximum in the subarray and add that value to each element in the subarray. Parameters: n (int): Length of the array. array (list of int): Array of integers. queries (list of tuple of int): List of queries, where each query is a tuple (l, r). Returns: list of int: The modified array after processing all queries. >>> process_queries(5, [1, 2, 3, 4, 5], [(1, 3)]) [4, 5, 6, 4, 5] >>> process_queries(5, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [16, 23, 24, 22, 17] >>> process_queries(3, [3, 1, 2], [(1, 3)]) [6, 4, 5] >>> process_queries(4, [1, 4, 2, 3], [(2, 4)]) [1, 8, 6, 7] >>> process_queries(6, [1, 2, 3, 4, 5, 6], [(1, 2), (3, 4), (5, 6)]) [3, 4, 7, 8, 11, 12] >>> process_queries(3, [2, 2, 2], [(1, 3)]) [4, 4, 4] >>> process_queries(5, [1, 2, 3, 4, 5], []) [1, 2, 3, 4, 5] pass # Implement the function here","solution":"def process_queries(n, array, queries): Process a series of range queries to find the maximum in the subarray and add that value to each element in the subarray. Parameters: n (int): Length of the array. array (list of int): Array of integers. queries (list of tuple of int): List of queries, where each query is a tuple (l, r). Returns: list of int: The modified array after processing all queries. for l, r in queries: subarray_max = max(array[l-1:r]) for i in range(l-1, r): array[i] += subarray_max return array"},{"question":"def check_scheduling_conflicts(sessions): Determines whether there are any scheduling conflicts among the speakers. Parameters: sessions (list of tuples): List of sessions where each session is a tuple (speaker_id, start_time, end_time). Returns: int: Returns 1 if there is at least one conflict, 0 otherwise. >>> check_scheduling_conflicts([(1, \\"09:00\\", \\"10:00\\"), (1, \\"10:15\\", \\"11:00\\"), (2, \\"09:30\\", \\"10:30\\"), (2, \\"10:15\\", \\"11:45\\"]) 1 >>> check_scheduling_conflicts([(1, \\"09:00\\", \\"10:00\\"), (1, \\"10:15\\", \\"11:00\\"), (2, \\"09:30\\", \\"10:30\\"), (2, \\"10:31\\", \\"11:45\\"]) 0 >>> check_scheduling_conflicts([(1, \\"09:00\\", \\"10:00\\")]) 0 >>> check_scheduling_conflicts([(1, \\"09:00\\", \\"10:00\\"), (1, \\"09:30\\", \\"11:00\\"), (2, \\"12:00\\", \\"13:00\\"), (2, \\"12:30\\", \\"13:30\\"]) 1 >>> check_scheduling_conflicts([(1, \\"09:00\\", \\"10:00\\"), (1, \\"10:00\\", \\"11:00\\"), (2, \\"12:00\\", \\"12:59\\"), (2, \\"12:59\\", \\"13:30\\"]) 0 >>> check_scheduling_conflicts([(10**9, \\"09:00\\", \\"10:00\\"), (10**9, \\"10:30\\", \\"11:00\\")]) 0","solution":"def check_scheduling_conflicts(sessions): Determines whether there are any scheduling conflicts among the speakers. Parameters: sessions (list of tuples): List of sessions where each session is a tuple (speaker_id, start_time, end_time). Returns: int: Returns 1 if there is at least one conflict, 0 otherwise. from collections import defaultdict schedules = defaultdict(list) # Helper function to convert time from HH:MM format to minutes since midnight def time_to_minutes(time): hours, minutes = map(int, time.split(\\":\\")) return hours * 60 + minutes # Populate the schedules dictionary for speaker_id, start_time, end_time in sessions: start = time_to_minutes(start_time) end = time_to_minutes(end_time) schedules[speaker_id].append((start, end)) # Check for conflicts in each speaker's schedule for times in schedules.values(): times.sort() for i in range(1, len(times)): if times[i][0] < times[i-1][1]: return 1 return 0"},{"question":"def minimum_initial_amount(n: int, amounts: List[int]) -> int: Returns the minimum initial amount of money needed to make all bank accounts' balances equal. >>> minimum_initial_amount(4, [1, 2, 3, 4]) 10 >>> minimum_initial_amount(1, [5]) 5 >>> minimum_initial_amount(3, [3, 3, 3]) 9 >>> minimum_initial_amount(2, [1000000000, 999999999]) 1999999999 >>> minimum_initial_amount(5, [10, 20, 30, 40, 50]) 150","solution":"def minimum_initial_amount(n, amounts): Returns the minimum initial amount of money needed to make all bank accounts' balances equal. :param n: int - Number of bank accounts :param amounts: List[int] - List of initial amounts in each account :return: int - Minimum initial amount of money return sum(amounts)"},{"question":"def longest_substring_with_two_distinct_characters(s: str) -> int: Finds the length of the longest substring containing exactly two distinct characters. If no such substring exists, returns -1. >>> longest_substring_with_two_distinct_characters(\\"abcbbbbcccbdddadacb\\") 10 >>> longest_substring_with_two_distinct_characters(\\"abcabcabc\\") 2 >>> longest_substring_with_two_distinct_characters(\\"aaaa\\") -1 def test_longest_substring_with_two_distinct_characters(): assert longest_substring_with_two_distinct_characters(\\"abcbbbbcccbdddadacb\\") == 10 assert longest_substring_with_two_distinct_characters(\\"abcabcabc\\") == 2 assert longest_substring_with_two_distinct_characters(\\"aaaa\\") == -1 assert longest_substring_with_two_distinct_characters(\\"\\") == -1 assert longest_substring_with_two_distinct_characters(\\"ab\\") == 2 assert longest_substring_with_two_distinct_characters(\\"aabbcc\\") == 4 assert longest_substring_with_two_distinct_characters(\\"a\\") == -1 assert longest_substring_with_two_distinct_characters(\\"abaccc\\") == 4 if __name__ == \\"__main__\\": test_longest_substring_with_two_distinct_characters() print(\\"All tests passed.\\")","solution":"def longest_substring_with_two_distinct_characters(s): Finds the length of the longest substring containing exactly two distinct characters. If no such substring exists, returns -1. if len(s) < 2: return -1 max_len = -1 left = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == 2: max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List, Tuple def optimize_pairs_sum(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum possible sum of pairs formed from an array based on given conditions. >>> optimize_pairs_sum(1, [((4, 1), [1, 2, 3, 4])]) [7] >>> optimize_pairs_sum(2, [((4, 1), [1, 2, 3, 4]), ((6, 2), [-1, -2, 3, 4, 5, 6])]) [7, 18] def test_single_case(): assert optimize_pairs_sum(1, [((4, 1), [1, 2, 3, 4])]) == [7] def test_multiple_cases(): test_cases = [ ((4, 1), [1, 2, 3, 4]), ((6, 2), [-1, -2, 3, 4, 5, 6]) ] assert optimize_pairs_sum(2, test_cases) == [7, 18] def test_all_negative_case(): test_cases = [ ((4, 2), [-1, -2, -3, -4]) ] assert optimize_pairs_sum(1, test_cases) == [10] def test_mixed_sign_case(): test_cases = [ ((6, 3), [-1, 2, -3, 4, -5, 6]) ] assert optimize_pairs_sum(1, test_cases) == [21] def test_single_element_pairs(): test_cases = [ ((4, 2), [1, 2, -3, 4]) ] assert optimize_pairs_sum(1, test_cases) == [10] def test_large_numbers(): test_cases = [ ((6, 2), [10**9, -10**9, 10**8, -10**8, 0, 10**7]) ] assert optimize_pairs_sum(1, test_cases) == [2200000000]","solution":"def optimize_pairs_sum(t, test_cases): results = [] for i in range(t): n, m = test_cases[i][0] array = test_cases[i][1] abs_array = sorted([abs(x) for x in array], reverse=True) max_sum = sum(abs_array[:2*m]) results.append(max_sum) return results"},{"question":"def minimum_cost_to_connect_houses(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: This function computes the minimum cost to connect all houses using the provided connections. If it's not possible, it returns -1. :param n: int, number of houses :param m: int, number of possible connections :param connections: list of tuples, each containing three elements (u, v, w) :return: int, minimum cost required to connect all houses or -1 if it's not possible >>> minimum_cost_to_connect_houses(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) 6 >>> minimum_cost_to_connect_houses(3, 1, [(1, 2, 3)]) -1 >>> minimum_cost_to_connect_houses(2, 1, [(1, 2, 1)]) 1 >>> minimum_cost_to_connect_houses(2, 0, []) -1 >>> minimum_cost_to_connect_houses(6, 9, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 7), (3, 5, 6), (4, 5, 3), (5, 6, 5), (4, 6, 8), (1, 6, 10)]) 17 pass","solution":"def minimum_cost_to_connect_houses(n, m, connections): This function computes the minimum cost to connect all houses using the provided connections. If it's not possible, it returns -1. :param n: int, number of houses :param m: int, number of possible connections :param connections: list of tuples, each containing three elements (u, v, w) :return: int, minimum cost required to connect all houses or -1 if it's not possible import heapq # Create adjacency list adj = {i: [] for i in range(1, n + 1)} for u, v, w in connections: adj[u].append((w, v)) adj[v].append((w, u)) # Minimum Spanning Tree using Prim's Algorithm vis = set() min_heap = [(0, 1)] # Arbitrary starting point (cost=0, node=1) total_cost = 0 while min_heap and len(vis) < n: cost, node = heapq.heappop(min_heap) if node not in vis: vis.add(node) total_cost += cost for edge_cost, neighbor in adj[node]: if neighbor not in vis: heapq.heappush(min_heap, (edge_cost, neighbor)) # If we have visited all nodes, return the computed cost if len(vis) == n: return total_cost else: return -1"},{"question":"from typing import List def count_valid_assignments(n: int, m: int, capacities: List[int], group_sizes: List[int]) -> int: Count the number of valid ways to assign all groups to the rides such that no ride exceeds its maximum capacity. >>> count_valid_assignments(3, 3, [5, 4, 7], [3, 4, 2]) 6 >>> count_valid_assignments(3, 3, [1, 1, 1], [1, 1, 1]) 6 >>> count_valid_assignments(3, 3, [1, 2, 3], [1, 2, 4]) 0 >>> count_valid_assignments(3, 3, [1, 2, 3], [4, 5, 6]) 0 >>> count_valid_assignments(3, 3, [5, 5, 5], [3, 3, 3]) 6 >>> count_valid_assignments(1, 1, [5], [5]) 1 >>> count_valid_assignments(1, 1, [4], [5]) 0","solution":"from itertools import permutations def count_valid_assignments(n, m, capacities, group_sizes): group_perm = permutations(group_sizes) valid_count = 0 for perm in group_perm: valid = True for i in range(m): if perm[i] > capacities[i]: valid = False break if valid: valid_count += 1 return valid_count"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(7) True >>> is_prime(10) False pass def find_prime_pair(arr: List[int]) -> bool: Given a list of integers, determine if there exists a pair of distinct indices such that the sum of the elements at these indices is a prime number. >>> find_prime_pair([1, 4, 6, 7]) True >>> find_prime_pair([2, 4, 6, 8]) False pass from solution import find_prime_pair def test_pair_with_prime_sum_exists(): assert find_prime_pair([1, 4, 6, 7]) == True assert find_prime_pair([5, 10, 1, 3]) == True def test_no_pair_with_prime_sum(): assert find_prime_pair([2, 4, 6, 8]) == False assert find_prime_pair([20, 30, 40, 50]) == False def test_empty_and_single_element_lists(): assert find_prime_pair([]) == False assert find_prime_pair([1]) == False def test_negative_and_positive_elements(): assert find_prime_pair([-3, 7, -2, 5]) == True assert find_prime_pair([-3, -5, -7, -11]) == False def test_boundary_values(): assert find_prime_pair([1000, -1000, 997, -1]) == True assert find_prime_pair([-1000, -1000, -997, -3]) == False","solution":"def is_prime(n): Check if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False max_divisor = int(n**0.5) + 1 for d in range(3, max_divisor, 2): if n % d == 0: return False return True def find_prime_pair(arr): Check if there exists a pair of indices (i, j) such that arr[i] + arr[j] is a prime number. n = len(arr) for i in range(n): for j in range(i + 1, n): if is_prime(arr[i] + arr[j]): return True return False"},{"question":"def check_social_distancing_violation(n: int, m: int, grid: List[str]) -> str: Check if the arrangement of people in the grid violates the social distancing rules. Each person ('P') should not be adjacent to another person. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): The grid containing 'P' and '.' characters. Returns: str: \\"YES\\" if there is a violation, \\"NO\\" otherwise. >>> check_social_distancing_violation(3, 3, [\\"P..\\", \\".P.\\", \\"..P\\"]) \\"NO\\" >>> check_social_distancing_violation(2, 3, [\\"PP.\\", \\"...\\"]) \\"YES\\"","solution":"def check_social_distancing_violation(n, m, grid): Checks if the arrangement of people in the grid violates the social distancing rules. Each person ('P') should not be adjacent to another person. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (list of str): The grid containing 'P' and '.' characters. Returns: str: \\"YES\\" if there is a violation, \\"NO\\" otherwise. for i in range(n): for j in range(m): if grid[i][j] == 'P': if (i > 0 and grid[i-1][j] == 'P') or (i < n-1 and grid[i+1][j] == 'P') or (j > 0 and grid[i][j-1] == 'P') or (j < m-1 and grid[i][j+1] == 'P'): return \\"YES\\" return \\"NO\\""},{"question":"def max_visible_range(n: int, h: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Identify the maximum width of visible hills for each day given the mist ranges. :param n: Number of hills :param h: List of heights of the hills :param q: Number of mist range queries :param queries: List of tuples indicating the mist ranges (l, r) :return: List of integers representing the maximum width of visible hills for each query >>> max_visible_range(10, [5, 3, 8, 6, 7, 2, 4, 9, 1, 10], 3, [(2, 4), (6, 8), (1, 5)]) [6, 5, 5] >>> max_visible_range(5, [1, 2, 3, 4, 5], 1, [(3, 4)]) [2] >>> max_visible_range(5, [1, 2, 3, 4, 5], 1, [(1, 5)]) [0] >>> max_visible_range(5, [1, 2, 3, 4, 5], 1, [(6, 7)]) [5] >>> max_visible_range(5, [1, 2, 3, 4, 5], 1, [(1, 1)]) [4]","solution":"def max_visible_range(n, h, q, queries): results = [] for l, r in queries: # Find the maximum of the visible segments max_visible = 0 if l > 1: max_visible = max(max_visible, l - 1) if r < n: max_visible = max(max_visible, n - r) results.append(max_visible) return results"},{"question":"def rearrange_book_ids(n: int, book_ids: List[int]) -> List[int]: Rearranges the book ids such that all even numbers come before all odd numbers, while preserving the original relative order of even and odd numbers. Parameters: n (int): The number of book ids book_ids (List[int]): The list of book ids to be rearranged Returns: List[int]: The rearranged list of book ids Example: >>> rearrange_book_ids(7, [4, 3, 7, 2, 6, 9, 1]) [4, 2, 6, 3, 7, 9, 1] >>> rearrange_book_ids(4, [1, 2, 3, 4]) [2, 4, 1, 3] pass # Unit tests def test_rearrange_book_ids(): assert rearrange_book_ids(1, [1]) == [1] assert rearrange_book_ids(1, [2]) == [2] assert rearrange_book_ids(3, [2, 4, 6]) == [2, 4, 6] assert rearrange_book_ids(3, [1, 3, 5]) == [1, 3, 5] assert rearrange_book_ids(7, [4, 3, 7, 2, 6, 9, 1]) == [4, 2, 6, 3, 7, 9, 1] assert rearrange_book_ids(4, [1, 2, 3, 4]) == [2, 4, 1, 3] assert rearrange_book_ids(5, [5, 4, 3, 2, 1]) == [4, 2, 5, 3, 1]","solution":"def rearrange_book_ids(n, book_ids): Rearranges the book ids such that all even numbers come before all odd_numbers, while preserving the original relative order of even and odd numbers. evens = [book_id for book_id in book_ids if book_id % 2 == 0] odds = [book_id for book_id in book_ids if book_id % 2 != 0] return evens + odds # Example usage # n = 7 # book_ids = [4, 3, 7, 2, 6, 9, 1] # rearranged = rearrange_book_ids(n, book_ids) # print(rearranged) # Output: [4, 2, 6, 3, 7, 9, 1]"},{"question":"def suggest_songs(n, songs, x, y, k): Suggest songs to the user based on the specified preferences. Parameters: n (int): The number of songs. songs (list): A list of tuples where each tuple contains three integers (song id, genre, popularity score). x (int): The id of the currently playing song. y (int): The preferred genre for suggestions. k (int): The number of suggestions desired by the user. Returns: list: A list of k suggested song ids based on the specified criteria, or -1 if no songs can be suggested.","solution":"def suggest_songs(n, songs, x, y, k): Suggest songs to the user based on the specified preferences. Parameters: n (int): The number of songs. songs (list): A list of tuples where each tuple contains three integers (song id, genre, popularity score). x (int): The id of the currently playing song. y (int): The preferred genre for suggestions. k (int): The number of suggestions desired by the user. Returns: list: A list of k suggested song ids based on the specified criteria, or -1 if no songs can be suggested. preferred_genre_songs = [] other_genre_songs = [] current_genre = None for song in songs: song_id, genre, popularity = song if song_id == x: current_genre = genre break for song in songs: song_id, genre, popularity = song if genre == y: preferred_genre_songs.append(song) elif genre != current_genre: other_genre_songs.append(song) preferred_genre_songs.sort(key=lambda x: (-x[2], x[0])) # Sort by popularity desc, then by id asc other_genre_songs.sort(key=lambda x: (-x[2], x[0])) # Sort by popularity desc, then by id asc result = [] for song in preferred_genre_songs: if len(result) < k: result.append(song[0]) if len(result) < k: for song in other_genre_songs: if len(result) < k: result.append(song[0]) else: break if not result: return -1 return result"},{"question":"def subset_sum_exists(arr: List[int], S: int) -> bool: Determines if there exists a subset of \`arr\` that sums up to \`S\` >>> subset_sum_exists([3, 34, 4, 12, 5, 2], 9) True >>> subset_sum_exists([3, 34, 4, 12, 5, 2], 30) False >>> subset_sum_exists([1, 3, 9, 2], 4) True from solution import subset_sum_exists def test_subset_sum_exists_example(): assert subset_sum_exists([3, 34, 4, 12, 5, 2], 9) == True assert subset_sum_exists([3, 34, 4, 12, 5, 2], 30) == False assert subset_sum_exists([1, 3, 9, 2], 4) == True def test_subset_sum_exists_empty_target(): assert subset_sum_exists([5, 7, 1], 0) == True # Empty subset def test_subset_sum_exists_single_element(): assert subset_sum_exists([10], 10) == True assert subset_sum_exists([10], 7) == False def test_subset_sum_exists_large_numbers(): assert subset_sum_exists([100000], 100000) == True assert subset_sum_exists([5, 10, 12, 13], 100) == False def test_subset_sum_exists_all_zeros(): assert subset_sum_exists([0, 0, 0], 0) == True assert subset_sum_exists([0, 0, 0], 1) == False def test_subset_sum_exists_multiple_solutions(): assert subset_sum_exists([1, 1, 1, 1, 1, 1], 3) == True def test_subset_sum_exists_repeated_elements(): assert subset_sum_exists([2, 2, 2, 2, 2], 4) == True assert subset_sum_exists([2, 2, 2, 2, 2], 7) == False","solution":"def subset_sum_exists(arr, S): Determines if there exists a subset of \`arr\` that sums up to \`S\` n = len(arr) dp = [False] * (S + 1) dp[0] = True for num in arr: for j in range(S, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[S]"},{"question":"def minimize_max_element(n: int, arr: List[int]) -> int: Given an array consisting of n integers, perform a series of operations on it to minimize the maximum element after exactly n-1 operations. In a single operation, you can select any two different elements of the array and replace both of them with their sum. Parameters: n (int): Number of elements in the array. arr (List[int]): The elements of the array. Returns: int: The minimum possible value of the maximum element in the array after performing exactly n-1 operations. Example: >>> minimize_max_element(4, [4, 1, 2, 10]) 17 >>> minimize_max_element(3, [4, 1, 2]) 7","solution":"def minimize_max_element(n, arr): Performs n-1 operations on the array to minimize the maximum element. n: int - number of elements in the array arr: List[int] - array of integers Returns the minimized maximum element after n-1 operations. # sort the list in descending order arr.sort(reverse=True) while len(arr) > 1: first = arr.pop() second = arr.pop() combined = first + second arr.append(combined) # Keep the array sorted in descending order arr.sort(reverse=True) return arr[0]"},{"question":"def can_transform(s: str, t: str, k: int) -> str: Determine if string s can be transformed into string t after exactly k rotations. Parameters: s (str): The original string. t (str): The target string. k (int): The number of rotations. Returns: str: \\"YES\\" if s can be transformed into t after exactly k rotations, otherwise \\"NO\\". Examples: >>> can_transform(\\"hello\\", \\"elloh\\", 1) 'YES' >>> can_transform(\\"abcde\\", \\"abcde\\", 5) 'YES' >>> can_transform(\\"abcdef\\", \\"defabc\\", 3) 'YES' >>> can_transform(\\"abcdef\\", \\"abcdfe\\", 2) 'NO'","solution":"def can_transform(s, t, k): Determine if string s can be transformed into string t after exactly k rotations. Arguments: s : str : original string t : str : target string k : int : number of rotations Returns: str : \\"YES\\" if s can be transformed into t after k rotations, else \\"NO\\" n = len(s) k = k % n # Reduce k if it's larger than the length of the string rotated_s = s[k:] + s[:k] return \\"YES\\" if rotated_s == t else \\"NO\\""},{"question":"def count_unique_squares(intersections): Determines how many unique squares can be formed by the given intersections. >>> count_unique_squares([(1, 1), (1, 2), (2, 1), (2, 2), (3, 3)]) 1 >>> count_unique_squares([(1, 1), (1, 2), (2, 1), (2, 2), (3, 3), (3, 4), (4, 3), (4, 4)]) 2 pass def count_unique_squares_from_input(input_str): Parses input string and determines the number of unique squares that can be formed. lines = input_str.strip().split('n') n = int(lines[0]) intersections = [tuple(map(int, line.split())) for line in lines[1:n+1]] return count_unique_squares(intersections) def test_count_unique_squares(): # Test case 1 input_str = \\"5n1 1n1 2n2 1n2 2n3 3\\" assert count_unique_squares_from_input(input_str) == 1 # Test case 2 input_str = \\"8n1 1n1 2n2 1n2 2n3 3n3 4n4 3n4 4\\" assert count_unique_squares_from_input(input_str) == 2 # Test case 3 input_str = \\"4n10 10n10 20n20 10n20 20\\" assert count_unique_squares_from_input(input_str) == 1 # Test case 4 input_str = \\"6n0 0n0 1n1 0n1 1n2 2n2 3\\" assert count_unique_squares_from_input(input_str) == 1 # Test case 5 input_str = \\"4n0 0n1 0n0 1n1 1\\" assert count_unique_squares_from_input(input_str) == 1 # Test case 6 input_str = \\"3n1 1n2 2n3 3\\" assert count_unique_squares_from_input(input_str) == 0","solution":"def count_unique_squares(intersections): points = set((x, y) for x, y in intersections) count = 0 for (x1, y1) in points: for (x2, y2) in points: if x1 != x2 and y1 != y2 and (x1, y2) in points and (x2, y1) in points: count += 1 return count // 4 # Read input def count_unique_squares_from_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) intersections = [tuple(map(int, line.split())) for line in lines[1:n+1]] return count_unique_squares(intersections)"},{"question":"def max_tasks(tasks): Determines the maximum number of tasks that can be completed without being late. :param tasks: List of tuples where each tuple contains the duration and deadline of a task. :return: The maximum number of tasks that can be completed without being late. >>> max_tasks([(3, 9), (2, 8), (1, 5), (6, 12), (2, 7)]) == 4 >>> max_tasks([(2, 5)]) == 1 >>> max_tasks([(5, 2)]) == 0 >>> max_tasks([(1, 2), (2, 4), (2, 5)]) == 3 >>> max_tasks([(5, 3), (4, 2), (3, 1)]) == 0 >>> max_tasks([(5, 10), (3, 8), (2, 4), (1, 2)]) == 3 >>> max_tasks([]) == 0 pass","solution":"def max_tasks(tasks): Determines the maximum number of tasks that can be completed without being late. :param tasks: List of tuples where each tuple contains the duration and deadline of a task. :return: The maximum number of tasks that can be completed without being late. tasks.sort(key=lambda x: x[1]) # Sort tasks based on their deadlines. current_time = 0 count = 0 for duration, deadline in tasks: if current_time + duration <= deadline: current_time += duration count += 1 else: break return count # Example usage: # tasks = [(3, 9), (2, 8), (1, 5), (6, 12), (2, 7)] # print(max_tasks(tasks)) # Output: 4"},{"question":"from typing import List def min_drone_height(buildings: List[int]) -> int: Returns the smallest possible maximum height the drone can fly above the buildings. >>> min_drone_height([4, 2, 3, 5, 6]) 6 >>> min_drone_height([1, 5, 4, 4, 3]) 5 def test_min_drone_height_single_building(): assert min_drone_height([10]) == 10 def test_min_drone_height_all_same_height(): assert min_drone_height([5, 5, 5, 5, 5]) == 5 def test_min_drone_height_increasing_heights(): assert min_drone_height([1, 2, 3, 4, 5]) == 5 def test_min_drone_height_decreasing_heights(): assert min_drone_height([5, 4, 3, 2, 1]) == 5 def test_min_drone_height_random_heights(): assert min_drone_height([4, 2, 3, 5, 6]) == 6 assert min_drone_height([10, 20, 15, 25, 30]) == 30 assert min_drone_height([1, 5, 4, 4, 3]) == 5 def test_min_drone_height_smallest_input(): assert min_drone_height([1]) == 1 def test_min_drone_height_large_input(): assert min_drone_height([1] * 100000) == 1 assert min_drone_height([10**9] * 100000) == 10**9","solution":"from typing import List def min_drone_height(buildings: List[int]) -> int: Returns the smallest possible maximum height the drone can fly above the buildings. # The drone needs to at least be as high as the highest building to fly over all buildings. return max(buildings)"},{"question":"def max_energy_value(w: int, n: int, fruits: List[Tuple[int, int, int]]) -> int: Determines the maximum total energy value of the fruits Lira can carry. :param w: Maximum capacity of the backpack :param n: Number of magical trees :param fruits: List of tuples representing each tree's (zi, wi, ei) :return: Maximum total energy value of the fruits >>> max_energy_value(50, 3, [(1, 20, 40), (2, 30, 60), (3, 10, 10)]) 100 >>> max_energy_value(10, 1, [(1, 10, 50)]) 50 >>> max_energy_value(10, 1, [(1, 20, 100)]) 0 >>> max_energy_value(10, 4, [(1, 5, 10), (2, 4, 40), (3, 6, 30), (4, 3, 50)]) 90 >>> max_energy_value(10, 3, [(1, 3, 10), (2, 3, 20), (3, 4, 30)]) 60 >>> max_energy_value(10, 3, [(1, 5, 10), (2, 5, 10), (3, 5, 20)]) 30 >>> max_energy_value(10, 0, []) 0 >>> max_energy_value(100, 3, [(1, 20, 50), (2, 30, 60), (3, 40, 70)]) 180 pass","solution":"def max_energy_value(w, n, fruits): Determines the maximum total energy value of the fruits Lira can carry. :param w: Maximum capacity of the backpack :param n: Number of magical trees :param fruits: List of tuples representing each tree's (zi, wi, ei) :return: Maximum total energy value of the fruits dp = [0] * (w + 1) for zi, wi, ei in fruits: if wi <= w: for current_weight in range(w, wi - 1, -1): dp[current_weight] = max(dp[current_weight], dp[current_weight - wi] + ei) return max(dp)"},{"question":"def generate_sequence(n: int): Generates a sequence of length n such that no two adjacent elements have an absolute difference of 1. If it is impossible to generate such a sequence, returns \\"Impossible\\". >>> generate_sequence(3) \\"Impossible\\" >>> generate_sequence(4) [2, 4, 1, 3] >>> generate_sequence(5) [2, 4, 1, 3, 5] or [4, 2, 5, 3, 1]","solution":"def generate_sequence(n): Generates a sequence of length n such that no two adjacent elements have an absolute difference of 1. if n == 2 or n == 3: return \\"Impossible\\" sequence = [] # Adding even numbers for i in range(2, n+1, 2): sequence.append(i) # Adding odd numbers for i in range(1, n+1, 2): sequence.append(i) return sequence"},{"question":"def maximize_score(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum total score by summing the points of at most k rounds. >>> maximize_score(3, [((6, 3), [1, 2, 3, -1, -2, 5]), ((4, 2), [-4, -2, 1, 3]), ((5, 5), [-1, -2, -3, -4, -5])]) [10, 4, -15] >>> maximize_score(1, [((5, 2), [0, 0, 0, 0, 0])]) [0]","solution":"def maximize_score(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] scores = test_cases[i][1] scores.sort(reverse=True) results.append(sum(scores[:k])) return results"},{"question":"def split_unique_substrings(s: str) -> tuple: Splits the input string s into the minimum number of substrings such that each substring contains unique characters. Args: s (str): Input string consisting of lowercase English letters. Returns: tuple: A tuple containing the minimum number of substrings and a list of the substrings. Example: >>> split_unique_substrings(\\"abac\\") (2, [\\"ab\\", \\"ac\\"]) >>> split_unique_substrings(\\"aaaaa\\") (5, [\\"a\\", \\"a\\", \\"a\\", \\"a\\", \\"a\\"]) >>> split_unique_substrings(\\"abcdef\\") (1, [\\"abcdef\\"]) >>> split_unique_substrings(\\"abcabc\\") (2, [\\"abc\\", \\"abc\\"])","solution":"def split_unique_substrings(s): Splits the input string s into the minimum number of substrings such that each substring contains unique characters. Args: s (str): Input string consisting of lowercase English letters. Returns: tuple: A tuple containing the minimum number of substrings and a list of the substrings. substrings = [] current_substr = \\"\\" char_set = set() for char in s: if char in char_set: # Start a new substring substrings.append(current_substr) current_substr = char char_set = {char} else: current_substr += char char_set.add(char) # Add the last substring if it's not empty if current_substr: substrings.append(current_substr) return len(substrings), substrings"},{"question":"def get_response_weights(k: int, keywords: List[Tuple[str, int]], q: int, queries: List[str]) -> List[int]: Calculate the total maximum weight of responses based on the user's query and the given keywords with associated weights. Args: k (int): The number of keywords. keywords (List[Tuple[str, int]]): A list of tuples where each tuple contains a keyword and its associated weight. q (int): The number of queries. queries (List[str]): A list of user queries. Returns: List[int]: A list of integers where each integer represents the maximum weight for the respective user's query. Example: >>> k = 4 >>> keywords = [(\\"greeting\\", 3), (\\"hello\\", 5), (\\"world\\", 2), (\\"chat\\", 4)] >>> q = 3 >>> queries = [\\"hello greeting chat\\", \\"world chat\\", \\"example query\\"] >>> get_response_weights(k, keywords, q, queries) [12, 6, 0]","solution":"def get_response_weights(k, keywords, q, queries): # Creating a dictionary for keyword to weight mapping keyword_weights = {} for keyword, weight in keywords: keyword_weights[keyword] = weight # Processing each query to calculate the total weight result_weights = [] for query in queries: words = query.split() total_weight = sum(keyword_weights.get(word, 0) for word in words) result_weights.append(total_weight) return result_weights # Example usage: # k = 4 # keywords = [(\\"greeting\\", 3), (\\"hello\\", 5), (\\"world\\", 2), (\\"chat\\", 4)] # q = 3 # queries = [\\"hello greeting chat\\", \\"world chat\\", \\"example query\\"] # print(get_response_weights(k, keywords, q, queries)) # Expected [12, 6, 0]"},{"question":"def num_clusters(grid): Find the number of connected clusters of buildings in the grid. Args: grid (List[List[str]]): 2D list representing the city's layout. Returns: int: The number of connected building clusters. >>> grid = [['E', 'B', 'B', 'E', 'E'], ['E', 'B', 'B', 'B', 'E'], ['E', 'B', 'E', 'E', 'E'], ['E', 'E', 'E', 'E', 'E']] >>> num_clusters(grid) 1 >>> grid = [['B', 'E', 'B'], ['E', 'E', 'E'], ['B', 'E', 'B']] >>> num_clusters(grid) 4 # Implement me! def read_grid_from_input(input_string): Read the grid from the input string. Args: input_string (str): Input string representing the city's layout. Returns: List[List[str]]: 2D list representing the city's layout. >>> input_string = \\"4 5nEBBEEnEBBBEnEBEEEnEEEEEn\\" >>> read_grid_from_input(input_string) [['E', 'B', 'B', 'E', 'E'], ['E', 'B', 'B', 'B', 'E'], ['E', 'B', 'E', 'E', 'E'], ['E', 'E', 'E', 'E', 'E']] # Implement me!","solution":"def num_clusters(grid): m = len(grid) n = len(grid[0]) def dfs(x, y): if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] == 'E': return # Mark the cell as visited grid[x][y] = 'E' # Move in all four directions dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) clusters = 0 for i in range(m): for j in range(n): if grid[i][j] == 'B': clusters += 1 # Perform DFS to mark all connected buildings dfs(i, j) return clusters # Function to read the grid from given input format def read_grid_from_input(input_string): lines = input_string.strip().split('n') m, n = map(int, lines[0].split()) grid = [list(line) for line in lines[1:]] return grid"},{"question":"def sort_tuples(tuples_list): Sort a list of tuples based on multiple criteria. Each tuple consists of three elements: an integer, a string, and a floating-point number. The function will sort the tuples by the integer in ascending order, then by the string in alphabetical order, and finally by the floating-point number in descending order. >>> sort_tuples([(1, 'apple', 2.5), (1, 'banana', 3.5), (2, 'apple', 3.5), (2, 'apple', 1.2), (1, 'apple', 3.7)]) [(1, 'apple', 3.7), (1, 'apple', 2.5), (1, 'banana', 3.5), (2, 'apple', 3.5), (2, 'apple', 1.2)] >>> sort_tuples([(1, 'banana', 2.2), (1, 'apple', 1.5), (1, 'apple', 1.8)]) [(1, 'apple', 1.8), (1, 'apple', 1.5), (1, 'banana', 2.2)] >>> sort_tuples([(2, 'apple', 3.4), (1, 'apple', 2.0), (1, 'apple', 3.1), (2, 'apple', 1.2)]) [(1, 'apple', 3.1), (1, 'apple', 2.0), (2, 'apple', 3.4), (2, 'apple', 1.2)] >>> sort_tuples([(1, 'banana', 2.2), (2, 'apple', 2.2), (1, 'apple', 2.2)]) [(1, 'apple', 2.2), (1, 'banana', 2.2), (2, 'apple', 2.2)] >>> sort_tuples([(3, 'apple', 1.1), (2, 'banana', 3.3), (1, 'cherry', 5.5), (3, 'apple', 1.5)]) [(1, 'cherry', 5.5), (2, 'banana', 3.3), (3, 'apple', 1.5), (3, 'apple', 1.1)]","solution":"def sort_tuples(tuples_list): Sort a list of tuples based on multiple criteria. Each tuple consists of three elements: an integer, a string, and a floating-point number. The function will sort the tuples by the integer in ascending order, then by the string in alphabetical order, and finally by the floating-point number in descending order. return sorted(tuples_list, key=lambda x: (x[0], x[1], -x[2]))"},{"question":"def solve_magic_square(input: str) -> None: Given a partially filled 3x3 grid, complete the grid with distinct integers from 1 to 9 such that it forms a magic square. The integer 0 represents an empty cell. If it is possible to complete the grid to form a magic square, print the completed grid. Otherwise, print \\"Impossible\\". Example: >>> solve_magic_square(\\"8 1 6 3 5 0 4 9 0\\") 8 1 6 3 5 7 4 9 2 >>> solve_magic_square(\\"5 3 4 1 0 0 0 0 0\\") Impossible from itertools import permutations def is_magic_square(grid): s = sum(grid[0]) for i in range(3): if sum(grid[i]) != s or sum(grid[j][i] for j in range(3)) != s: return False if sum(grid[i][i] for i in range(3)) != s or sum(grid[i][2-i] for i in range(3)) != s: return False return True def find_magic_square(grid): all_numbers = set(range(1, 10)) filled_numbers_set = set() for row in grid: for num in row: if num != 0: filled_numbers_set.add(num) empty_positions = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == 0] available_numbers = list(all_numbers - filled_numbers_set) for perm in permutations(available_numbers): for idx, (i, j) in enumerate(empty_positions): grid[i][j] = perm[idx] if is_magic_square(grid): return grid for i, j in empty_positions: grid[i][j] = 0 return \\"Impossible\\" def solve_magic_square(input): nums = list(map(int, input.split())) grid = [nums[i*3:(i+1)*3] for i in range(3)] result = find_magic_square(grid) if result == \\"Impossible\\": print(\\"Impossible\\") else: for row in result: print(\\" \\".join(map(str, row))) from solution import solve_magic_square def test_solve_magic_square_case_1(capsys): input_string = \\"8 1 6 3 5 0 4 9 0\\" solve_magic_square(input_string) captured = capsys.readouterr() assert captured.out == '8 1 6n3 5 7n4 9 2n' def test_solve_magic_square_case_2(capsys): input_string = \\"5 3 4 1 0 0 0 0 0\\" solve_magic_square(input_string) captured = capsys.readouterr() assert captured.out == 'Impossiblen' def test_solve_magic_square_fully_filled(capsys): input_string = \\"2 7 6 9 5 1 4 3 8\\" solve_magic_square(input_string) captured = capsys.readouterr() assert captured.out == '2 7 6n9 5 1n4 3 8n' def test_solve_magic_square_all_zeros(capsys): input_string = \\"0 0 0 0 0 0 0 0 0\\" solve_magic_square(input_string) captured = capsys.readouterr() assert captured.out == ('2 7 6n9 5 1n4 3 8n' or '8 1 6n3 5 7n4 9 2n') def test_solve_magic_square_almost_complete(capsys): input_string = \\"2 7 6 9 0 1 4 3 8\\" solve_magic_square(input_string) captured = capsys.readouterr() assert captured.out == '2 7 6n9 5 1n4 3 8n'","solution":"def is_magic_square(grid): Check if a 3x3 grid is a magic square. s = sum(grid[0]) for i in range(3): if sum(grid[i]) != s or sum(grid[j][i] for j in range(3)) != s: return False if sum(grid[i][i] for i in range(3)) != s or sum(grid[i][2-i] for i in range(3)) != s: return False return True def find_magic_square(grid): from itertools import permutations all_numbers = set(range(1, 10)) filled_numbers_set = set() for row in grid: for num in row: if num != 0: filled_numbers_set.add(num) empty_positions = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == 0] available_numbers = list(all_numbers - filled_numbers_set) for perm in permutations(available_numbers): for idx, (i, j) in enumerate(empty_positions): grid[i][j] = perm[idx] if is_magic_square(grid): return grid for i, j in empty_positions: grid[i][j] = 0 return \\"Impossible\\" def solve_magic_square(input): nums = list(map(int, input.split())) grid = [nums[i*3:(i+1)*3] for i in range(3)] result = find_magic_square(grid) if result == \\"Impossible\\": print(\\"Impossible\\") else: for row in result: print(\\" \\".join(map(str, row))) # To call the function you would need to replace input_string with actual input # input_string = \\"8 1 6 3 5 0 4 9 0\\" # solve_magic_square(input_string)"},{"question":"def minimize_average_difference(n, ages): Partition a group of ages into two groups such that the difference between the average age of the two groups is minimized. >>> n = 5 >>> ages = [5, 10, 15, 20, 25] >>> groupA, groupB = minimize_average_difference(n, ages) >>> abs(sum(groupA)/len(groupA) - sum(groupB)/len(groupB)) == 0 True >>> n = 4 >>> ages = [10, 20, 30, 40] >>> groupA, groupB = minimize_average_difference(n, ages) >>> abs(sum(groupA)/len(groupA) - sum(groupB)/len(groupB)) == 0 True >>> n = 6 >>> ages = [60, 45, 50, 55, 65, 70] >>> groupA, groupB = minimize_average_difference(n, ages) >>> diff = abs(sum(groupA)/len(groupA) - sum(groupB)/len(groupB)) >>> diff <= 5 True >>> n = 3 >>> ages = [1, 100, 50] >>> groupA, groupB = minimize_average_difference(n, ages) >>> diff = abs(sum(groupA)/len(groupA) - sum(groupB)/len(groupB)) >>> diff <= 25 True >>> n = 8 >>> ages = [5, 10, 15, 20, 25, 30, 35, 40] >>> groupA, groupB = minimize_average_difference(n, ages) >>> diff = abs(sum(groupA)/len(groupA) - sum(groupB)/len(groupB)) >>> diff <= 5 True","solution":"def minimize_average_difference(n, ages): Given the ages of a group of people, partition them into two groups such that the difference between the average age of the two groups is minimized. total_sum = sum(ages) total_people = len(ages) # Variables to track minimum difference, and the respective groups min_diff = float('inf') best_partition = ([], []) # Helper function to compute the difference between group averages def calculate_difference(groupA, groupB): if not groupA or not groupB: return float('inf') avgA = sum(groupA) / len(groupA) avgB = sum(groupB) / len(groupB) return abs(avgA - avgB) # Recursive function to try all partitions def find_partition(index, groupA, groupB): nonlocal min_diff, best_partition if index == total_people: current_diff = calculate_difference(groupA, groupB) if current_diff < min_diff: min_diff = current_diff best_partition = (list(groupA), list(groupB)) return # Include current index in group A groupA.append(ages[index]) find_partition(index + 1, groupA, groupB) groupA.pop() # Include current index in group B groupB.append(ages[index]) find_partition(index + 1, groupA, groupB) groupB.pop() # Start recursive process find_partition(0, [], []) # Return the best partition found return best_partition # Example usage: n = 5 ages = [5, 10, 15, 20, 25] groupA, groupB = minimize_average_difference(n, ages) print(\\"Group A:\\", groupA) print(\\"Group B:\\", groupB)"},{"question":"def minimum_match_time(n: int, skill: List[int]) -> int: Returns the minimum amount of time required to complete all matches. Arguments: n -- integer, number of players skill -- list of integers, skill levels of the players Returns: integer, minimum amount of time required to complete all matches >>> minimum_match_time(4, [3, 6, 1, 2]) 5 >>> minimum_match_time(2, [5, 10]) 5 >>> minimum_match_time(3, [1, 2, 3]) 2 >>> minimum_match_time(3, [5, 3, 1]) 4 >>> minimum_match_time(3, [1, 100, 101]) 100 >>> minimum_match_time(4, [8, 8, 8, 8]) 0","solution":"def minimum_match_time(n, skill): Returns the minimum amount of time required to complete all matches. Arguments: n -- integer, number of players skill -- list of integers, skill levels of the players Returns: integer, minimum amount of time required to complete all matches skill.sort() # Sort the skill levels in ascending order total_time = 0 for i in range(1, n): total_time += abs(skill[i] - skill[i-1]) return total_time"},{"question":"def merge_intervals(intervals): Merges all overlapping intervals. :param intervals: List of intervals [start, end]. :return: List of merged non-overlapping intervals. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 2], [3, 4], [5, 6]]) [[1, 2], [3, 4], [5, 6]] >>> merge_intervals([[1, 4], [2, 3]]) [[1, 4]] >>> merge_intervals([[1, 4], [0, 2], [3, 5]]) [[0, 5]] >>> merge_intervals([[1, 5]]) [[1, 5]] >>> merge_intervals([]) [] >>> merge_intervals([[0, 10000]]) [[0, 10000]]","solution":"def merge_intervals(intervals): Merges all overlapping intervals. :param intervals: List of intervals [start, end]. :return: List of merged non-overlapping intervals. if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_interval = intervals[0] for interval in intervals[1:]: if interval[0] <= current_interval[1]: current_interval[1] = max(current_interval[1], interval[1]) else: merged_intervals.append(current_interval) current_interval = interval merged_intervals.append(current_interval) return merged_intervals"},{"question":"def calculate_discarded_messages(u: int, m: int, messages: List[List[int]]) -> List[List[int]]: Calculate the number of discarded messages for each user at the end of each day. >>> calculate_discarded_messages(3, 5, [[4, 6, 2, 7], [5, 3, 8, 2], [2, 2, 4, 1]]) [[0, 1, 0, 2], [0, 0, 3, 0], [0, 0, 0, 0]] >>> calculate_discarded_messages(2, 5, [[1, 2, 3, 4], [5, 4, 3, 2]]) [[0, 0, 0, 0], [0, 0, 0, 0]] def format_output(discarded: List[List[int]]) -> str: Format the discarded messages list into a multi-line string output. >>> format_output([[0, 1, 0, 2], [0, 0, 3, 0], [0, 0, 0, 0]]) '0 1 0 2n0 0 3 0n0 0 0 0'","solution":"def calculate_discarded_messages(u, m, messages): discarded = [] for user_messages in messages: discarded_user = [(message - m) if message > m else 0 for message in user_messages] discarded.append(discarded_user) return discarded def format_output(discarded): return \\"n\\".join(\\" \\".join(map(str, user)) for user in discarded)"},{"question":"def count_distinct_characters(s: str, queries: List[Tuple[int, int]]) -> List[int]: Returns the number of distinct characters for each query. Parameters: s (str): The input string. queries (list of tuples): A list of tuples, where each tuple contains two integers l and r (1-based indices), representing the start and end indices of the substring. Returns: list: A list of integers, where each integer is the number of distinct characters in the corresponding query. Example: >>> count_distinct_characters(\\"abrakadabra\\", [(1, 3), (2, 5), (1, 10)]) [3, 4, 5] >>> count_distinct_characters(\\"a\\", [(1, 1)]) [1] >>> count_distinct_characters(\\"aaaaaa\\", [(1, 6), (2, 5), (1, 1)]) [1, 1, 1] >>> count_distinct_characters(\\"abcdef\\", [(1, 6), (1, 3), (4, 6)]) [6, 3, 3] >>> count_distinct_characters(\\"aabbccddeeff\\", [(1, 4), (5, 8), (9, 12)]) [2, 2, 2]","solution":"def count_distinct_characters(s, queries): Returns the number of distinct characters for each query. Parameters: s (str): The input string. queries (list of tuples): A list of tuples, where each tuple contains two integers l and r (1-based indices), representing the start and end indices of the substring. Returns: list: A list of integers, where each integer is the number of distinct characters in the corresponding query. results = [] for l, r in queries: substring = s[l-1:r] distinct_count = len(set(substring)) results.append(distinct_count) return results"},{"question":"from typing import List def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Given a list of strings, determine whether it is possible to transform each string such that there are no two adjacent characters that are the same. If possible, output \\"YES\\" followed by the rearranged string. Otherwise, output \\"NO\\". >>> process_test_cases(3, [\\"aabb\\", \\"aa\\", \\"abc\\"]) [\\"YES abab\\", \\"NO\\", \\"YES abc\\"] >>> process_test_cases(2, [\\"aab\\", \\"a\\"]) [\\"YES aba\\", \\"YES a\\"] pass # Unit Tests def test_example_1(): T = 3 test_cases = [\\"aabb\\", \\"aa\\", \\"abc\\"] expected_output = [\\"YES abab\\", \\"NO\\", \\"YES abc\\"] assert process_test_cases(T, test_cases) == expected_output def test_example_2(): T = 2 test_cases = [\\"aab\\", \\"a\\"] expected_output = [\\"YES aba\\", \\"YES a\\"] assert process_test_cases(T, test_cases) == expected_output def test_single_character(): T = 1 test_cases = [\\"a\\"] expected_output = [\\"YES a\\"] assert process_test_cases(T, test_cases) == expected_output def test_no_solution(): T = 2 test_cases = [\\"aa\\", \\"aaaa\\"] expected_output = [\\"NO\\", \\"NO\\"] assert process_test_cases(T, test_cases) == expected_output def test_large_case(): T = 1 test_cases = [\\"a\\"*50000 + \\"b\\"*50000] expected_output = [\\"YES \\" + (\\"ab\\" * 50000)] assert process_test_cases(T, test_cases) == expected_output","solution":"from collections import Counter import heapq def rearrange_string(s): count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 rearranged_string = ''.join(result) if len(rearranged_string) == len(s): return \\"YES \\" + rearranged_string else: return \\"NO\\" def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"def num_decodings(s: str) -> int: Given a string of digits, return the number of ways to decode it according to the mapping from '1' to '9' -> 'A' to 'I' and '10' to '26' -> 'J' to 'Z'. # Your code here # Unit Test def test_num_decodings(): # Test cases from the example assert num_decodings(\\"12\\") == 2, \\"Test case 1 failed\\" assert num_decodings(\\"226\\") == 3, \\"Test case 2 failed\\" assert num_decodings(\\"0\\") == 0, \\"Test case 3 failed\\" assert num_decodings(\\"10\\") == 1, \\"Test case 4 failed\\" # Additional test cases assert num_decodings(\\"123\\") == 3, \\"Test case 5 failed\\" assert num_decodings(\\"27\\") == 1, \\"Test case 6 failed\\" assert num_decodings(\\"101\\") == 1, \\"Test case 7 failed\\" assert num_decodings(\\"110\\") == 1, \\"Test case 8 failed\\" assert num_decodings(\\"111\\") == 3, \\"Test case 9 failed\\" assert num_decodings(\\"1123\\") == 5, \\"Test case 10 failed\\" assert num_decodings(\\"0\\") == 0, \\"Test case 11 failed\\" assert num_decodings(\\"301\\") == 0, \\"Test case 12 failed\\" assert num_decodings(\\"2101\\") == 1, \\"Test case 13 failed\\"","solution":"def num_decodings(s: str) -> int: Given a string of digits, return the number of ways to decode it according to the mapping from '1' to '9' -> 'A' to 'I' and '10' to '26' -> 'J' to 'Z'. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) # Base cases for empty string and single character dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): # Single digit decoding if s[i - 1] != '0': dp[i] += dp[i - 1] # Two digit decoding two_digit = int(s[i - 2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"from typing import List, Tuple def seating_arrangement(n: int, m: int, pairs: List[Tuple[int, int]]) -> Tuple[int, List[List[int]]]: The company XYZ is planning a corporate networking event, where employees and their direct managers need to be seated at assigned tables. Seat assignment needs to follow some specific rules to ensure that communication flows smoothly. The goal is to maximize the number of employees who can attend the event under these rules. The rules for seating are: 1. Each table can have at most 6 people. 2. Each employee can be seated with at most one direct manager and at most one direct report if they have any. 3. No two employees who have the same direct manager can be seated at the same table unless the manager is also seated at the same table. The input consists of the following: 1. The first line contains two integers, n and m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 1000) — where n is the total number of employees and m is the number of direct manager-report pairs. 2. The next m lines describe the direct manager-report pairs. Each pair consists of two integers a and b (1 ≤ a, b ≤ n, a ≠ b), indicating that employee a is a direct manager of employee b. The output should be: 1. The first line contains one integer, k — the maximum number of employees that can be seated satisfying all the rules. 2. The following k lines describe the seating arrangement, each line indicating the ids of employees seated at one table. >>> seating_arrangement(8, 6, [(1, 2), (1, 3), (4, 5), (4, 6), (7, 8), (6, 7)]) (2, [[1, 2, 3], [4, 5, 6, 7, 8]]) >>> seating_arrangement(4, 0, []) (4, [[1], [2], [3], [4]]) >>> seating_arrangement(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) (1, [[1, 2, 3, 4, 5, 6]]) >>> seating_arrangement(6, 3, [(1, 2), (3, 4), (5, 6)]) (3, [[1, 2], [3, 4], [5, 6]]) >>> seating_arrangement(6, 5, [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6)]) (1, [[1, 2, 3, 4, 5, 6]])","solution":"from collections import defaultdict, deque def seating_arrangement(n, m, pairs): # Using adjacency list to keep track of direct manager-report pairs manager_to_reports = defaultdict(list) for manager, report in pairs: manager_to_reports[manager].append(report) # We use a visited set to ensure no employee is seated more than once visited = set() tables = [] def bfs(start): queue = deque([start]) table = [] while queue and len(table) < 6: employee = queue.popleft() if employee not in visited: visited.add(employee) table.append(employee) # Add direct reports if any to the queue if employee in manager_to_reports: for report in manager_to_reports[employee]: if report not in visited: queue.append(report) return table for employee in range(1, n + 1): if employee not in visited: table = bfs(employee) if table: tables.append(table) # Printing the result k = len(tables) print(k) for table in tables: print(\\" \\".join(map(str, table))) return (k, [table for table in tables])"},{"question":"def total_additional_capacity(n: int, containers: List[Tuple[int, int]]) -> int: Given the total number of containers and their respective maximum capacities and current seed counts, returns the total additional capacity available in all containers. Parameters: n (int): Number of containers. containers (list of tuples): Each tuple contains two integers, the maximum capacity and the current number of seeds in the container. Returns: int: Total additional capacity available across all containers. >>> total_additional_capacity(3, [(10, 6), (15, 5), (8, 8)]) == 14 >>> total_additional_capacity(2, [(5, 5), (10, 10)]) == 0 >>> total_additional_capacity(3, [(5, 0), (7, 0), (10, 0)]) == 22 >>> total_additional_capacity(4, [(10, 2), (6, 6), (8, 5), (3, 1)]) == 13 >>> total_additional_capacity(1, [(10, 3)]) == 7","solution":"def total_additional_capacity(n, containers): Returns the total additional capacity available in all containers. Parameters: n (int): Number of containers. containers (list of tuples): Each tuple contains two integers, the maximum capacity and current number of seeds in the container. Returns: int: Total additional capacity. total_additional = 0 for capacity, seeds in containers: total_additional += (capacity - seeds) return total_additional"},{"question":"from typing import List def max_visible_buildings(heights: List[int]) -> int: Determine the maximum number of buildings you can see when viewed from the left. >>> max_visible_buildings([3, 1, 4, 1, 5, 9]) 4 >>> max_visible_buildings([1, 2, 3, 4, 5]) 5 >>> max_visible_buildings([5, 4, 3, 2, 1]) 1 >>> max_visible_buildings([3, 3, 3, 3, 3]) 5 >>> max_visible_buildings([10**9, 10**9 - 1, 10**9 - 2, 10**9 - 3]) 1 >>> max_visible_buildings([1, 3, 2, 5, 4, 6]) 4 >>> max_visible_buildings([1]) 1 >>> max_visible_buildings([1, 3, 2, 1, 2, 1]) 2","solution":"def max_visible_buildings(heights): max_count = 1 # The first building is always visible max_height = heights[0] for height in heights[1:]: if height >= max_height: max_count += 1 max_height = height return max_count"},{"question":"from typing import List def max_sum_subsequence(A: List[int]) -> int: Returns the maximum sum of a subsequence such that the sum of elements in any prefix of the subsequence is not less than zero. >>> max_sum_subsequence([4, -1, 2, -1, 3, -2]) 7 >>> max_sum_subsequence([1, 2, 3, 4, 5]) 15 >>> max_sum_subsequence([-1, -2, -3, -4]) 0 >>> max_sum_subsequence([3, -2, 5, -1, 2]) 7 >>> max_sum_subsequence([-5, 4, 9, -3]) 13 >>> max_sum_subsequence([10]) 10 >>> max_sum_subsequence([-10]) 0 >>> max_sum_subsequence([10**9, -10**9, 10**9]) 10**9 pass","solution":"def max_sum_subsequence(A): Returns the maximum sum of a subsequence such that the sum of elements in any prefix of the subsequence is not less than zero. n = len(A) dp = [0] * n dp[0] = max(0, A[0]) for i in range(1, n): dp[i] = A[i] + (dp[i - 1] if dp[i - 1] >= 0 else 0) dp[i] = max(dp[i], 0) return max(dp)"},{"question":"def calculate_stock_level(s: int, e: int, events: list) -> int: Calculate the current stock level of all products at any given point in time. The first parameter is the initial stock level of each product. The second parameter is the number of events. The third parameter is a list of tuples representing the events. Each tuple contains a character ('P' for production, 'S' for sale) and an integer representing the number of units produced or sold in that event. >>> calculate_stock_level(5, 4, [(\\"P\\", \\"10\\"), (\\"S\\", \\"6\\"), (\\"S\\", \\"3\\"), (\\"P\\", \\"2\\")]) 8 >>> calculate_stock_level(5, 0, []) 5 >>> calculate_stock_level(0, 3, [(\\"P\\", \\"5\\"), (\\"P\\", \\"10\\"), (\\"P\\", \\"15\\")]) 30 >>> calculate_stock_level(20, 2, [(\\"S\\", \\"5\\"), (\\"S\\", \\"10\\")]) 5 >>> calculate_stock_level(10, 2, [(\\"S\\", \\"15\\"), (\\"P\\", \\"10\\")]) 20 >>> calculate_stock_level(0, 3, [(\\"S\\", \\"5\\"), (\\"P\\", \\"10\\"), (\\"S\\", \\"3\\")]) 7 >>> calculate_stock_level(10, 5, [(\\"P\\", \\"5\\"), (\\"S\\", \\"7\\"), (\\"P\\", \\"3\\"), (\\"S\\", \\"10\\"), (\\"P\\", \\"4\\")]) 5","solution":"def calculate_stock_level(s: int, e: int, events: list): stock = s for event in events: action, amount = event[0], int(event[1]) if action == \\"P\\": stock += amount elif action == \\"S\\": if stock >= amount: stock -= amount return stock # Example usage s = 5 e = 4 events = [(\\"P\\", \\"10\\"), (\\"S\\", \\"6\\"), (\\"S\\", \\"3\\"), (\\"P\\", \\"2\\")] print(calculate_stock_level(s, e, events)) # Output: 8"},{"question":"def can_make_equal_grid(n: int, m: int, grid: List[List[int]]) -> str: Determine if it's possible to make the grid contain an equal number of 0s and 1s by flipping cells. :param n: Number of rows :param m: Number of columns :param grid: 2D list representing the grid :return: \\"YES\\" if it's possible, otherwise \\"NO\\" >>> can_make_equal_grid(4, 4, [ [1, 0, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1], [0, 1, 1, 0] ]) == \\"YES\\" >>> can_make_equal_grid(3, 3, [ [1, 0, 1], [0, 1, 0], [1, 0, 0] ]) == \\"NO\\"","solution":"def can_make_equal_grid(n, m, grid): Determine if it's possible to make the grid contain an equal number of 0s and 1s by flipping cells. :param n: Number of rows :param m: Number of columns :param grid: 2D list representing the grid :return: \\"YES\\" if it's possible, otherwise \\"NO\\" # Count the number of 0s and 1s in the grid count_0 = 0 count_1 = 0 for row in grid: for cell in row: if cell == 0: count_0 += 1 else: count_1 += 1 # Calculate total cells in the grid total_cells = n * m # Check if the total number of cells is even and there are equal numbers of 0s and 1s if total_cells % 2 == 0 and count_0 == count_1: return \\"YES\\" else: return \\"NO\\""},{"question":"from fastapi import FastAPI, HTTPException from pydantic import BaseModel, Field from typing import List from uuid import uuid4 app = FastAPI() class Book(BaseModel): id: str = Field(default_factory=lambda: str(uuid4())) title: str author: str isbn: str published_date: str genre: str # In-memory \\"database\\" books = [] @app.post(\\"/books\\", response_model=Book) def add_book(book: Book): Add a new book to the inventory. Parameters: book (Book): The book data. Returns: Book: The created book data. pass @app.get(\\"/books/{id}\\", response_model=Book) def get_book(id: str): Retrieve the details of a specific book by its ID. Parameters: id (str): The unique identifier of the book. Returns: Book: The book data. pass @app.put(\\"/books/{id}\\", response_model=Book) def update_book(id: str, updated_book: Book): Update the information of an existing book. Parameters: id (str): The unique identifier of the book. updated_book (Book): The updated book data. Returns: Book: The updated book data. pass @app.delete(\\"/books/{id}\\", response_model=Book) def delete_book(id: str): Delete a book from the inventory. Parameters: id (str): The unique identifier of the book. pass @app.get(\\"/books\\", response_model=List[Book]) def list_books(): List all books in the inventory. Returns: List[Book]: The list of all books. pass # Unit Tests from fastapi.testclient import TestClient import pytest client = TestClient(app) def test_add_book(): response = client.post(\\"/books\\", json={\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"isbn\\": \\"1234567890\\", \\"published_date\\": \\"1949-06-08\\", \\"genre\\": \\"Dystopian\\"}) assert response.status_code == 200 assert response.json()[\\"title\\"] == \\"1984\\" def test_get_book(): book = {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"isbn\\": \\"1234567891\\", \\"published_date\\": \\"1960-07-11\\", \\"genre\\": \\"Fiction\\"} response = client.post(\\"/books\\", json=book) book_id = response.json()[\\"id\\"] response = client.get(f\\"/books/{book_id}\\") assert response.status_code == 200 assert response.json()[\\"title\\"] == book[\\"title\\"] def test_update_book(): book = {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"isbn\\": \\"1234567892\\", \\"published_date\\": \\"1925-04-10\\", \\"genre\\": \\"Tragedy\\"} response = client.post(\\"/books\\", json=book) book_id = response.json()[\\"id\\"] updated_book = {\\"id\\": book_id, \\"title\\": \\"The Great Gatsby Updated\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"isbn\\": \\"1234567892\\", \\"published_date\\": \\"1925-04-10\\", \\"genre\\": \\"Tragedy\\"} response = client.put(f\\"/books/{book_id}\\", json=updated_book) assert response.status_code == 200 assert response.json()[\\"title\\"] == \\"The Great Gatsby Updated\\" def test_delete_book(): book = {\\"title\\": \\"Moby Dick\\", \\"author\\": \\"Herman Melville\\", \\"isbn\\": \\"1234567893\\", \\"published_date\\": \\"1851-10-18\\", \\"genre\\": \\"Adventure\\"} response = client.post(\\"/books\\", json=book) book_id = response.json()[\\"id\\"] response = client.delete(f\\"/books/{book_id}\\") assert response.status_code == 200 assert response.json()[\\"title\\"] == book[\\"title\\"] response = client.get(f\\"/books/{book_id}\\") assert response.status_code == 404 def test_list_books(): response = client.get(\\"/books\\") assert response.status_code == 200 assert isinstance(response.json(), list)","solution":"from fastapi import FastAPI, HTTPException from typing import List from pydantic import BaseModel, Field from uuid import uuid4 app = FastAPI() class Book(BaseModel): id: str = Field(default_factory=lambda: str(uuid4())) title: str author: str isbn: str published_date: str genre: str # In-memory \\"database\\" books = [] @app.post(\\"/books\\", response_model=Book) def add_book(book: Book): books.append(book) return book @app.get(\\"/books/{id}\\", response_model=Book) def get_book(id: str): for book in books: if book.id == id: return book raise HTTPException(status_code=404, detail=\\"Book not found\\") @app.put(\\"/books/{id}\\", response_model=Book) def update_book(id: str, updated_book: Book): for index, book in enumerate(books): if book.id == id: books[index] = updated_book return updated_book raise HTTPException(status_code=404, detail=\\"Book not found\\") @app.delete(\\"/books/{id}\\", response_model=Book) def delete_book(id: str): for index, book in enumerate(books): if book.id == id: removed_book = books.pop(index) return removed_book raise HTTPException(status_code=404, detail=\\"Book not found\\") @app.get(\\"/books\\", response_model=List[Book]) def list_books(): return books"},{"question":"from typing import List, Tuple def schedule_transactions(n: int, m: int, k: int, transactions: List[Tuple[int, int, int]]) -> str: Determine if it is possible to schedule all transaction windows without any server exceeding its transaction limit. Parameters: n (int): number of servers m (int): number of transaction windows k (int): maximum number of transactions each server can handle in a time window transactions (List[Tuple[int, int, int]]): list of transactions represented by tuples (ai, bi, ti) Returns: str: \\"YES\\" followed by the scheduled transactions, or \\"NO\\" if scheduling is not possible. >>> schedule_transactions(4, 5, 2, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (2, 4, 2)]) 'YESn1 2n2 3n3 4n1 3n2 4' >>> schedule_transactions(2, 4, 3, [(1, 2, 1), (1, 2, 1), (1, 2, 1), (1, 2, 1)]) 'NO' >>> schedule_transactions(2, 1, 1, [(1, 2, 1)]) 'YESn1 2' >>> schedule_transactions(4, 4, 1, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) 'YESn1 2n2 3n3 4n4 1' >>> schedule_transactions(5, 4, 3, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1)]) 'NO'","solution":"def schedule_transactions(n, m, k, transactions): from collections import defaultdict # Transactions counter per server and time transaction_count = defaultdict(lambda: defaultdict(int)) # Check each transaction window for ai, bi, ti in transactions: if transaction_count[ai][ti] >= k or transaction_count[bi][ti] >= k: return \\"NO\\" transaction_count[ai][ti] += 1 transaction_count[bi][ti] += 1 # If all transactions fit within the constraints result = [\\"YES\\"] result.extend([f\\"{ai} {bi}\\" for ai, bi, _ in transactions]) return \\"n\\".join(result) # Example usage of the function with provided input transactions = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (2, 4, 2) ] print(schedule_transactions(4, 5, 2, transactions))"},{"question":"def max_equal_charm(m: int, p: float, charm_values: List[int]) -> float: Calculate the maximum possible equal charm value for each pet after a series of charm exchanges taking into account charm loss. Parameters: m (int): the number of pets. p (float): the fraction of charm lost in each exchange. charm_values (List[int]): the list of initial charm values for the pets. Returns: float: the maximum possible equal charm value per pet. >>> abs(max_equal_charm(3, 0, [10, 20, 30]) - 20.0) < 1e-6 True >>> abs(max_equal_charm(2, 0, [15, 15]) - 15) < 1e-6 True >>> abs(max_equal_charm(3, 0.1, [30, 60, 90]) - 60.0) < 1e-6 True >>> abs(max_equal_charm(4, 0.5, [25, 75, 100, 50]) - 62.5) < 1e-6 True >>> abs(max_equal_charm(5, 0.5, [0, 0, 0, 0, 0]) - 0.0) < 1e-6 True >>> abs(max_equal_charm(1, 0.1, [500]) - 500) < 1e-6 True","solution":"def max_equal_charm(m, p, charm_values): # Calculate the total charm of all pets total_charm = sum(charm_values) # Calculate the maximum equal charm per pet after exchanges max_charm = total_charm / m return max_charm"},{"question":"def does_robot_return(commands: str) -> str: Determines whether the robot returns to its origin after executing all the commands. The robot starts at the origin point (0, 0) facing upwards. The instructions are composed of the following characters: - 'G' instructs the robot to move one step forward in its current direction. - 'L' instructs the robot to turn left (90 degrees counter-clockwise). - 'R' instructs the robot to turn right (90 degrees clockwise). :param commands: A string of commands for the robot. :return: \\"YES\\" if the robot returns to the origin, \\"NO\\" otherwise. Examples: >>> does_robot_return(\\"GLGLGLGL\\") \\"YES\\" >>> does_robot_return(\\"GG\\") \\"NO\\"","solution":"def does_robot_return(commands): Determines whether the robot returns to its origin after executing all the commands. # Initial position and direction (0, 0) facing up x, y = 0, 0 direction = 'U' # Direction mappings directions = { 'U': (0, 1), # Up 'R': (1, 0), # Right 'D': (0, -1), # Down 'L': (-1, 0) # Left } # Direction transitions left_turn = { 'U': 'L', 'L': 'D', 'D': 'R', 'R': 'U' } right_turn = { 'U': 'R', 'R': 'D', 'D': 'L', 'L': 'U' } for command in commands: if command == 'G': dx, dy = directions[direction] x += dx y += dy elif command == 'L': direction = left_turn[direction] elif command == 'R': direction = right_turn[direction] return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def can_achieve_total_fireworks_count(n: int, t: int, sets: List[int]) -> str: Determine if it is possible to achieve exactly 't' fireworks with given sets. Parameters: n (int): Number of different sets. t (int): Total number of fireworks planned. sets (list): List of integers representing the fireworks counts in each set. Returns: str: \\"Possible\\" if it is feasible to achieve exactly t fireworks with the given sets, else \\"Impossible\\". >>> can_achieve_total_fireworks_count(3, 7, [2, 3, 5]) == \\"Possible\\" >>> can_achieve_total_fireworks_count(3, 11, [2, 3, 5]) == \\"Impossible\\" >>> can_achieve_total_fireworks_count(1, 5, [5]) == \\"Possible\\" >>> can_achieve_total_fireworks_count(1, 7, [5]) == \\"Impossible\\" >>> can_achieve_total_fireworks_count(3, 9, [3, 3, 3]) == \\"Possible\\" >>> can_achieve_total_fireworks_count(3, 10, [3, 3, 3]) == \\"Impossible\\" >>> can_achieve_total_fireworks_count(5, 100, [20, 20, 20, 20, 20]) == \\"Possible\\" >>> can_achieve_total_fireworks_count(3, 0, [2, 3, 5]) == \\"Possible\\" >>> can_achieve_total_fireworks_count(3, 1000000, [999999, 1, 500000]) == \\"Possible\\" >>> can_achieve_total_fireworks_count(3, 1000001, [999999, 1]) == \\"Impossible\\" pass","solution":"def can_achieve_total_fireworks_count(n, t, sets): Determine if it is possible to achieve exactly 't' fireworks with given sets. Parameters: n (int): Number of different sets. t (int): Total number of fireworks planned. sets (list): List of integers representing the fireworks counts in each set. Returns: str: \\"Possible\\" if it is feasible to achieve exactly t fireworks with the given sets, else \\"Impossible\\". dp = [False] * (t + 1) dp[0] = True for s in sets: for i in range(t, s - 1, -1): if dp[i - s]: dp[i] = True return \\"Possible\\" if dp[t] else \\"Impossible\\""},{"question":"from typing import List def rearrange_flowers(s: str) -> str: Rearrange the string \`s\` so that no two adjacent characters are the same, if possible. Returns a rearranged string or \\"NOT POSSIBLE\\" if it cannot be done. Args: s (str): A string of lowercase letters where each letter represents a type of flower. Returns: str: A rearranged string where no two adjacent characters are the same or \\"NOT POSSIBLE\\". Example: >>> rearrange_flowers(\\"aabb\\") in ['abab', 'baba'] True >>> rearrange_flowers(\\"aaab\\") 'NOT POSSIBLE'","solution":"from collections import Counter import heapq def rearrange_flowers(s): Rearrange the string \`s\` so that no two adjacent characters are the same, if possible. Returns a rearranged string or \\"NOT POSSIBLE\\" if it cannot be done. # Counter for the frequency of each character char_count = Counter(s) # Max-heap of (-count, char) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char # we used one character, so increment the count back towards 0 result_string = \\"\\".join(result) if len(result_string) != len(s): return \\"NOT POSSIBLE\\" return result_string"},{"question":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, i, j): root_i = self.find(i) root_j = self.find(j) if root_i != root_j: if self.rank[root_i] > self.rank[root_j]: self.parent[root_j] = root_i elif self.rank[root_i] < self.rank[root_j]: self.parent[root_i] = root_j else: self.parent[root_j] = root_i self.rank[root_i] += 1 def count_projects(n, collaborations): Determine the number of unique projects in a company based on employee collaborations. Args: n (int): The number of employees. collaborations (List[Tuple[int, int]]): A list of tuples where each tuple represents a collaboration between two employees. Returns: int: The number of unique projects. Example usage: >>> count_projects(5, [(1, 2), (2, 3), (4, 5)]) 2 # Your implementation here # Example usage: n = 5 collaborations = [(1, 2), (2, 3), (4, 5)] print(count_projects(n, collaborations)) # Output: 2 # Unit Tests def test_count_projects_no_collaborations(): assert count_projects(5, []) == 5 def test_count_projects_all_collaborations(): assert count_projects(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 1 def test_count_projects_separate_groups(): assert count_projects(5, [(1, 2), (3, 4)]) == 3 def test_count_projects_mixed_collaborations(): assert count_projects(6, [(1, 2), (2, 3), (4, 5), (5, 6)]) == 2 def test_count_projects_single_employee(): assert count_projects(1, []) == 1 def test_count_projects_individuals_and_collaborations(): assert count_projects(6, [(1, 2), (3, 4)]) == 4","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, i, j): root_i = self.find(i) root_j = self.find(j) if root_i != root_j: if self.rank[root_i] > self.rank[root_j]: self.parent[root_j] = root_i elif self.rank[root_i] < self.rank[root_j]: self.parent[root_i] = root_j else: self.parent[root_j] = root_i self.rank[root_i] += 1 def count_projects(n, collaborations): uf = UnionFind(n) for a, b in collaborations: uf.union(a - 1, b - 1) unique_projects = len(set(uf.find(i) for i in range(n))) return unique_projects"},{"question":"def count_paths(n: int, m: int, grid: List[str]) -> int: Find the total number of distinct paths the robot can take from the top-left corner to the bottom-right corner in a grid filled with obstacles. >>> grid = [ ... \\"...\\", ... \\".#.\\", ... \\"...\\" ... ] >>> count_paths(3, 3, grid) 2 >>> grid = [ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ] >>> count_paths(3, 3, grid) 6 >>> grid = [ ... \\"#..\\", ... \\"...\\", ... \\"..#\\" ... ] >>> count_paths(3, 3, grid) 0 pass # Your code here","solution":"def count_paths(n, m, grid): Returns the number of distinct paths from the top-left to bottom-right corner of the grid. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': continue if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"from typing import Tuple class Cache: A data structure that acts as a cache with the following operations: - put(key, value): Insert or update the key-value pair into the cache. - get(key): Retrieve the value associated with the given key. If the key doesn't exist, return -1. - delete(key): Remove the key-value pair from the cache. - peek(): Retrieve one of the key-value pairs without removing it. The cache evicts the least recently used item when it's full. >>> cache = Cache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.get(3) -1 >>> cache.put(1, 10) >>> cache.get(1) 10 >>> cache.delete(1) >>> cache.get(1) -1 >>> cache.peek() in [(2, 2)] True >>> cache.peek() is None True def __init__(self, capacity: int): Initialize the cache with the given capacity. pass def put(self, key: int, value: int) -> None: Insert or update the key-value pair into the cache. pass def get(self, key: int) -> int: Retrieve the value associated with the given key. pass def delete(self, key: int) -> None: Remove the key-value pair from the cache. pass def peek(self) -> Tuple[int, int]: Retrieve one of the key-value pairs from the cache without removing it. pass","solution":"from collections import OrderedDict class Cache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) # Move the existing key to the end (latest position) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Remove the first item (least recently used) def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) # Move the accessed key to the end (latest position) return self.cache[key] def delete(self, key: int) -> None: if key in self.cache: del self.cache[key] def peek(self) -> tuple: if self.cache: for k, v in self.cache.items(): return k, v return None"},{"question":"def sum_of_alternating_series(n: int) -> int: Returns the sum of the alternating series up to the nth term. The series is defined as: S(n) = 1 - 2 + 3 - 4 + 5 - 6 + ... ± n Example: >>> sum_of_alternating_series(1) 1 >>> sum_of_alternating_series(2) -1 >>> sum_of_alternating_series(5) 3","solution":"def sum_of_alternating_series(n): Returns the sum of the alternating series up to the nth term. The series is defined as: S(n) = 1 - 2 + 3 - 4 + 5 - 6 + ... ± n # For even n: sum = - (n / 2) # For odd n : sum = (n + 1) / 2 if n % 2 == 0: return -n // 2 else: return (n + 1) // 2"},{"question":"def max_path_sum(grid: List[List[int]]) -> Tuple[int, str]: You are given a grid with n rows and m columns, each cell containing a non-negative integer. You begin at the top-left corner of the grid and can only move either right or down to reach the bottom-right corner. Your task is to find a path such that the sum of the values of the visited cells is maximized. The function should return the maximum sum achievable and one possible path. Example: >>> max_path_sum([[2, 4, 1], [0, 6, 5], [1, 1, 0]]) (17, \\"RRDD\\") >>> max_path_sum([[1, 2, 3, 4]]) (10, \\"RRR\\") >>> max_path_sum([[1], [2], [3], [4]]) (10, \\"DDD\\") >>> max_path_sum([[5]]) (5, \\"\\")","solution":"def max_path_sum(grid): n = len(grid) m = len(grid[0]) # Create a 2D dp array where dp[i][j] represents the maximum sum to reach cell (i, j) dp = [[0] * m for _ in range(n)] # Create a 2D path array where path[i][j] stores the direction to move to achieve max sum at (i, j) path = [[''] * m for _ in range(n)] # Initialize starting point dp[0][0] = grid[0][0] # Initialize first row and first column for i in range(1, m): dp[0][i] = dp[0][i-1] + grid[0][i] path[0][i] = 'R' for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] path[i][0] = 'D' # Fill up the dp and path arrays for i in range(1, n): for j in range(1, m): if dp[i-1][j] > dp[i][j-1]: dp[i][j] = dp[i-1][j] + grid[i][j] path[i][j] = 'D' else: dp[i][j] = dp[i][j-1] + grid[i][j] path[i][j] = 'R' # Reconstruct the path from bottom-right to top-left i, j = n-1, m-1 result_path = [] while i > 0 or j > 0: if path[i][j] == 'R': result_path.append('R') j -= 1 else: result_path.append('D') i -= 1 result_path.reverse() return dp[-1][-1], ''.join(result_path)"},{"question":"def infix_to_postfix(expression: str) -> str: Converts a mathematical expression in infix notation to postfix notation. >>> infix_to_postfix(\\"3+4*2/(1-5)\\") '342*15-/+' >>> infix_to_postfix(\\"3+4*2-1\\") '342*+1-' >>> infix_to_postfix(\\"(1+2)*3-4\\") '12+3*4-' >>> infix_to_postfix(\\"1+2*3\\") '123*+'","solution":"def infix_to_postfix(expression: str) -> str: Converts an infix expression to postfix notation. precedence = {'+': 1, '-': 1, '*': 2, '/': 2} stack = [] output = [] for char in expression: if char.isdigit(): output.append(char) elif char in precedence: while (stack and stack[-1] != '(' and precedence[stack[-1]] >= precedence[char]): output.append(stack.pop()) stack.append(char) elif char == '(': stack.append(char) elif char == ')': while stack and stack[-1] != '(': output.append(stack.pop()) stack.pop() # Pop the '(' from the stack while stack: output.append(stack.pop()) return ''.join(output)"},{"question":"def generate_order_ids(length: int, n: int) -> List[str]: Generates a list of the first n unique order IDs with a specified length for the number part. Args: - length (int): The length of the unique number part of the order ID. - n (int): The number of unique order IDs to generate. Returns: - list: A list of generated order IDs. >>> generate_order_ids(3, 5) [\\"ORD001\\", \\"ORD002\\", \\"ORD003\\", \\"ORD004\\", \\"ORD005\\"] >>> generate_order_ids(5, 3) [\\"ORD00001\\", \\"ORD00002\\", \\"ORD00003\\"]","solution":"def generate_order_ids(length, n): Generates a list of the first n unique order IDs with a specified length for the number part. Args: - length (int): The length of the unique number part of the order ID. - n (int): The number of unique order IDs to generate. Returns: - list: A list of generated order IDs. return [f\\"ORD{str(i).zfill(length)}\\" for i in range(1, n+1)]"},{"question":"def determine_winner(n: int, s: str) -> str: Determines the winner of the palindrome game. Yana and Jules are playing a game using a string of lowercase letters. In this game, their objective is to modify the string so that it becomes a palindrome. A palindrome is a string that reads the same backward as forward. Yana and Jules take turns modifying the string, and Yana always goes first. On each turn, the player must change exactly one character in the string to any other lowercase letter. The game ends when the string becomes a palindrome. The player who makes the string a palindrome wins the game. Each player plays optimally, meaning they will make the best possible move at each turn to achieve their objective or to avoid losing. Given a string \`s\` of length \`n\`, determine whether Yana or Jules will win the game if both play optimally. >>> determine_winner(5, \\"abeca\\") == \\"Yana\\" >>> determine_winner(3, \\"aab\\") == \\"Yana\\" >>> determine_winner(4, \\"abba\\") == \\"Jules\\" >>> determine_winner(1, \\"a\\") == \\"Jules\\" >>> determine_winner(6, \\"abcdef\\") == \\"Yana\\" >>> determine_winner(6, \\"abccba\\") == \\"Jules\\" :param n: int, the length of the string :param s: str, the string to be modified :return: str, \\"Yana\\" if Yana wins, \\"Jules\\" if Jules wins","solution":"def determine_winner(n, s): Determines the winner of the palindrome game. :param n: int, the length of the string :param s: str, the string to be modified :return: str, \\"Yana\\" if Yana wins, \\"Jules\\" if Jules wins # Calculate the number of differences between the string and its reverse mismatches = sum(1 for i in range(n // 2) if s[i] != s[n - 1 - i]) # Yana will win if there are any mismatches # If there are no mismatches, the string is already a palindrome, so no one wins # since there are no characters to change. if mismatches > 0: return \\"Yana\\" else: return \\"Jules\\" # If there are no mismatches, Jules would win as the string is already a palindrome. # Example usage: n = 5 s = \\"abeca\\" print(determine_winner(n, s)) # Output: \\"Yana\\""},{"question":"from typing import List def has_good_subarray(nums: List[int], k: int) -> bool: Determines if there exists a subarray with a sum divisible by k in the given list of integers. Args: nums (List[int]): List of integers. k (int): The divisor. Returns: bool: True if there exists a subarray with sum divisible by k, otherwise False. Examples: >>> has_good_subarray([2, 4, 3, 6], 5) True >>> has_good_subarray([1, 2, 3, 4, 5], 11) False def test_has_good_subarray(): assert has_good_subarray([2, 4, 3, 6], 5) == True assert has_good_subarray([1, 2, 3, 4, 5], 11) == False assert has_good_subarray([5], 5) == True assert has_good_subarray([3], 5) == False assert has_good_subarray([0], 1) == True assert has_good_subarray([0, 1, 2, 3], 10) == True assert has_good_subarray([10**4] * 100, 10**4) == True assert has_good_subarray(list(range(1, 100)), 101) == True assert has_good_subarray([-1, -2, -3, -4, -5], 2) == True assert has_good_subarray([-1, -2, -3, -4, -5], 20) == False assert has_good_subarray([10], 10) == True assert has_good_subarray([10], 3) == False assert has_good_subarray([0, 0, 0, 0], 2) == True assert has_good_subarray([0, 1, 2, 3], 6) == True assert has_good_subarray([1, 2, 3, 4, 5, 6], 9) == True assert has_good_subarray([1, 2, 3, 9], 3) == True","solution":"from typing import List def has_good_subarray(nums: List[int], k: int) -> bool: prefix_sums = {0} current_sum = 0 for num in nums: current_sum += num mod_val = current_sum % k if mod_val in prefix_sums: return True # Add the current mod value to the set prefix_sums.add(mod_val) return False"},{"question":"def largest_water_component(n: int, m: int, grid: List[List[str]]) -> int: Determine the size of the largest possible connected component of water cells in the grid. >>> largest_water_component(5, 6, [ ... ['L', 'L', 'L', 'W', 'L', 'L'], ... ['L', 'L', 'L', 'W', 'W', 'W'], ... ['W', 'W', 'L', 'L', 'L', 'L'], ... ['L', 'L', 'W', 'L', 'W', 'L'], ... ['L', 'W', 'L', 'W', 'L', 'L'] ... ]) == 4 >>> largest_water_component(3, 3, [ ... ['W', 'L', 'W'], ... ['L', 'W', 'L'], ... ['W', 'L', 'W'] ... ]) == 1 >>> largest_water_component(4, 4, [ ... ['W', 'W', 'W', 'W'], ... ['W', 'W', 'W', 'W'], ... ['W', 'W', 'W', 'W'], ... ['W', 'W', 'W', 'W'] ... ]) == 16 >>> largest_water_component(1, 1, [ ... ['L'] ... ]) == 0 >>> largest_water_component(1, 1, [ ... ['W'] ... ]) == 1 >>> largest_water_component(2, 3, [ ... ['W', 'L', 'W'], ... ['W', 'W', 'L'] ... ]) == 3","solution":"def largest_water_component(n, m, grid): Returns the size of the largest connected component of water cells. def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != 'W': return 0 # Mark the cell as visited by setting it to 'L' grid[x][y] = 'L' size = 1 # Explore all four directions size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size max_size = 0 for i in range(n): for j in range(m): if grid[i][j] == 'W': max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def count_characters(s: str, queries: List[str]) -> List[int]: Given a string \`s\` and a list of \`queries\`, this function returns a list of the number of times each character in \`queries\` appears in the string \`s\`. Parameters: s (str): The input string. queries (list of str): List of single character strings to query. Returns: list of int: A list of counts of each query character in the string \`s\`. >>> count_characters(\\"abracadabra\\", [\\"a\\"]) [5] >>> count_characters(\\"abracadabra\\", [\\"a\\", \\"b\\", \\"c\\"]) [5, 2, 1] >>> count_characters(\\"abracadabra\\", [\\"z\\"]) [0] >>> count_characters(\\"aaaaa\\", [\\"a\\", \\"b\\", \\"c\\"]) [5, 0, 0] >>> count_characters(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) [0, 0, 0]","solution":"def count_characters(s, queries): Given a string \`s\` and a list of \`queries\`, this function returns a list of the number of times each character in \`queries\` appears in the string \`s\`. Parameters: s (str): The input string. queries (list of str): List of single character strings to query. Returns: list of int: A list of counts of each query character in the string \`s\`. result = [s.count(query) for query in queries] return result"},{"question":"def shortest_unsorted_subarray(arr: List[int]) -> Tuple[int, int]: Given an array of integers, find the shortest subarray which, when sorted, will make the entire array sorted in non-decreasing order. >>> shortest_unsorted_subarray([2, 6, 4, 8, 10]) (2, 3) >>> shortest_unsorted_subarray([1, 2, 5, 3, 4, 6, 7]) (3, 5) >>> shortest_unsorted_subarray([1, 2, 3, 4, 5]) (1, 1) def test_shortest_unsorted_subarray(): assert shortest_unsorted_subarray([2, 6, 4, 8, 10]) == (2, 3) assert shortest_unsorted_subarray([1, 2, 5, 3, 4, 6, 7]) == (3, 5) assert shortest_unsorted_subarray([1, 2, 3, 4, 5]) == (1, 1) assert shortest_unsorted_subarray([1, 3, 5, 4, 2, 6, 7]) == (2, 5) assert shortest_unsorted_subarray([1, 3, 2, 2, 2]) == (2, 5) assert shortest_unsorted_subarray([5, 4, 3, 2, 1]) == (1, 5) assert shortest_unsorted_subarray([1, 2, 3, 5, 4]) == (4, 5) assert shortest_unsorted_subarray([1]) == (1, 1) assert shortest_unsorted_subarray([1, 2]) == (1, 1) assert shortest_unsorted_subarray([2, 1]) == (1, 2)","solution":"def shortest_unsorted_subarray(arr): n = len(arr) # Step 1: Check for initial boundary condition if all(arr[i] <= arr[i + 1] for i in range(n - 1)): return 1, 1 # Step 2: Find the first and last place where the order is incorrect start = next(i for i in range(n - 1) if arr[i] > arr[i + 1]) end = next(n - 1 - i for i in range(n - 1) if arr[n - 1 - i] < arr[n - 2 - i]) # Step 3: Find the minimum and maximum in the subarray arr[start:(end+1)] sub_min = min(arr[start:end + 1]) sub_max = max(arr[start:end + 1]) # Step 4: Expand the start and end as necessary while start > 0 and arr[start - 1] > sub_min: start -= 1 while end < n - 1 and arr[end + 1] < sub_max: end += 1 return start + 1, end + 1"},{"question":"from typing import List, Tuple def shortest_path(matrix: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the length of the shortest path from start to end. If not possible, return -1. >>> matrix = [ >>> [0, 1, 0, 0, 0], >>> [0, 0, 0, 1, 0], >>> [0, 1, 1, 0, 0], >>> [0, 0, 0, 0, 0], >>> [1, 1, 1, 0, 0] >>> ] >>> start = (0, 0) >>> end = (4, 4) >>> shortest_path(matrix, start, end) 9 >>> matrix = [ >>> [0, 1], >>> [1, 0] >>> ] >>> start = (0, 0) >>> end = (1, 1) >>> shortest_path(matrix, start, end) -1","solution":"from typing import List, Tuple from collections import deque def shortest_path(matrix: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the length of the shortest path from start to end. If not possible, return -1. rows, cols = len(matrix), len(matrix[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if start == end: return 0 queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: current, dist = queue.popleft() for direction in directions: nr, nc = current[0] + direction[0], current[1] + direction[1] if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] == 0 and (nr, nc) not in visited: if (nr, nc) == end: return dist + 1 queue.append(((nr, nc), dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def preprocess_array(arr): Preprocess the array to create a prefix sum array. >>> preprocess_array([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] def range_sum(query, prefix_sum): Compute the sum of the array elements from index l to r inclusive using the prefix sum array. >>> range_sum((1, 3), [0, 1, 3, 6, 10, 15]) 6 >>> range_sum((2, 4), [0, 1, 3, 6, 10, 15]) 9 def process_queries(n, q, arr, queries): Process all the queries and return the results as a list. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> process_queries(1, 1, [10], [(1, 1)]) [10]","solution":"def preprocess_array(arr): Preprocess the array to create a prefix sum array. prefix_sum = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] return prefix_sum def range_sum(query, prefix_sum): Compute the sum of the array elements from index l to r inclusive using the prefix sum array. l, r = query return prefix_sum[r] - prefix_sum[l - 1] def process_queries(n, q, arr, queries): Process all the queries and return the results as a list. prefix_sum = preprocess_array(arr) result = [] for query in queries: result.append(range_sum(query, prefix_sum)) return result"},{"question":"def rotate_array(nums, k): Rotates the array to the right by k steps. >>> rotate_array([1, 2, 3, 4, 5, 6], 2) [5, 6, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5, 6], 0) [1, 2, 3, 4, 5, 6] >>> rotate_array([1, 2, 3, 4, 5, 6], 6) [1, 2, 3, 4, 5, 6] >>> rotate_array([1, 2, 3, 4, 5, 6], 8) [5, 6, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5, 6], 14) [5, 6, 1, 2, 3, 4] >>> rotate_array([1], 5) [1] >>> rotate_array([1, 2], 1) [2, 1] >>> rotate_array([1, 2], 2) [1, 2]","solution":"def rotate_array(nums, k): Rotates the array to the right by k steps. n = len(nums) k = k % n # To handle k greater than n return nums[-k:] + nums[:-k]"},{"question":"def longest_contiguous_subsequence(arr): Returns the length of the longest contiguous subsequence where the absolute difference between any two consecutive elements is either 1 or 0. >>> longest_contiguous_subsequence([1]) == 1 >>> longest_contiguous_subsequence([2, 2, 2, 2, 2]) == 5 >>> longest_contiguous_subsequence([1, 2, 1, 2, 1]) == 5 >>> longest_contiguous_subsequence([1, 2, 4, 1, 2, 3]) == 3 >>> longest_contiguous_subsequence([1, 2, 3, 2, 1, 2, 2, 3]) == 8 >>> longest_contiguous_subsequence([5, 5, 5, 4, 5, 6, 7]) == 7 >>> longest_contiguous_subsequence([1, 3, 2, 2, 4, 1]) == 3","solution":"def longest_contiguous_subsequence(arr): Returns the length of the longest contiguous subsequence where the absolute difference between any two consecutive elements is either 1 or 0. if not arr: # if the array is empty return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) <= 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"from typing import List, Tuple def count_plant_clumps(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determines the number of unique plant clumps (connected components of plants) in the garden for each test case. pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, List[str]]]]: Parses the input string and returns the number of test cases and a list of test cases containing the garden grids. pass from count_plant_clumps import count_plant_clumps, parse_input def test_example_cases(): input_data = \\"2n4 5n.*...n.**..n...*.n...*.n3 3n.*.n..*n.*.n\\" t, test_cases = parse_input(input_data) assert count_plant_clumps(t, test_cases) == [2, 3] def test_all_plants_connected(): input_data = \\"1n3 3n***n***n***n\\" t, test_cases = parse_input(input_data) assert count_plant_clumps(t, test_cases) == [1] def test_no_plants(): input_data = \\"1n3 3n...n...n...n\\" t, test_cases = parse_input(input_data) assert count_plant_clumps(t, test_cases) == [0] def test_single_plant(): input_data = \\"1n3 3n*..n...n...n\\" t, test_cases = parse_input(input_data) assert count_plant_clumps(t, test_cases) == [1] def test_multiple_isolated_plants(): input_data = \\"1n3 3n*.*n.*.n*.*n\\" t, test_cases = parse_input(input_data) assert count_plant_clumps(t, test_cases) == [5]","solution":"def count_plant_clumps(t, test_cases): def dfs(grid, visited, x, y, n, m): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '*': visited[nx][ny] = True stack.append((nx, ny)) results = [] for case in test_cases: n, m, garden = case visited = [[False] * m for _ in range(n)] clump_count = 0 for i in range(n): for j in range(m): if garden[i][j] == '*' and not visited[i][j]: visited[i][j] = True clump_count += 1 dfs(garden, visited, i, j, n, m) results.append(clump_count) return results # Function to parse the input. def parse_input(input_string): input_lines = input_string.strip().split('n') t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, input_lines[index].split()) garden = [] for i in range(n): garden.append(input_lines[index + 1 + i]) test_cases.append((n, m, garden)) index += 1 + n return t, test_cases"},{"question":"def memoized_fibonacci(n: int, memo={}) -> int: Returns the nth Fibonacci number using memoization. >>> memoized_fibonacci(10) 55 >>> memoized_fibonacci(50) 12586269025","solution":"def memoized_fibonacci(n, memo={}): Returns the nth Fibonacci number using memoization. if n <= 1: return n if n in memo: return memo[n] memo[n] = memoized_fibonacci(n-1, memo) + memoized_fibonacci(n-2, memo) return memo[n]"},{"question":"def can_be_nice_string(n: int, s: str) -> str: Determines if the string s of length n can be rearranged into a \\"nice\\" string with at most one swap. A \\"nice\\" string has an equal number of 'a' and 'b'. Parameters: n (int): Length of the string s s (str): The string composed of characters 'a' and 'b' Returns: str: \\"YES\\" if the string can be rearranged into a \\"nice\\" string with at most one swap, otherwise \\"NO\\" >>> can_be_nice_string(6, \\"aabbab\\") 'YES' >>> can_be_nice_string(5, \\"aaabb\\") 'NO' >>> can_be_nice_string(5, \\"abbbb\\") 'NO' >>> can_be_nice_string(6, \\"aaabaa\\") 'NO' >>> can_be_nice_string(4, \\"aabb\\") 'YES' >>> can_be_nice_string(100000, \\"a\\" * 50000 + \\"b\\" * 50000) 'YES' >>> can_be_nice_string(99999, \\"a\\" * 49999 + \\"b\\" * 50000) 'NO' >>> can_be_nice_string(1, \\"a\\") 'NO'","solution":"def can_be_nice_string(n, s): Determines if the string s of length n can be rearranged into a \\"nice\\" string with at most one swap. A \\"nice\\" string has an equal number of 'a' and 'b'. count_a = s.count('a') count_b = s.count('b') # To be a \\"nice\\" string, the counts of 'a' and 'b' must be equal if count_a == count_b: return \\"YES\\" # If counts differ by more than 2, it's impossible to fix with one swap if abs(count_a - count_b) > 2: return \\"NO\\" # Otherwise, check if one swap can balance the counts return \\"YES\\" if (abs(count_a - count_b) == 2 and n % 2 == 0) else \\"NO\\""},{"question":"def calculate_flowers(n: int, m: int, q: int, garden: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Calculate the total number of flowers in the specified sub-rectangle for each query. Args: n (int): Number of rows in the garden. m (int): Number of columns in the garden. q (int): Number of queries. garden (List[List[int]]): The initial garden described by a matrix of integers. queries (List[Tuple[int, int, int, int]]): List of queries, each defined by four integers (r1, c1, r2, c2). Returns: List[int]: List of total number of flowers for each query. Examples: >>> n, m, q = 3, 3, 2 >>> garden = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... (1, 1, 2, 2), ... (2, 2, 3, 3) ... ] >>> calculate_flowers(n, m, q, garden, queries) [12, 28]","solution":"def calculate_flowers(n, m, q, garden, queries): results = [] # Precompute the prefix sums prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = garden[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] # Process each query for r1, c1, r2, c2 in queries: total_flowers = (prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1]) results.append(total_flowers) return results"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring of s. >>> longest_palindromic_substring(\\"banana\\") == \\"anana\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"abacabacabbacaba\\") == \\"abacabbacaba\\" >>> longest_palindromic_substring(\\"abcdefghba\\") == \\"a\\" >>> longest_palindromic_substring(\\"\\") == \\"\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of s. n = len(s) if n == 0: return \\"\\" start = 0 end = 0 for i in range(n): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end + 1] def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1"},{"question":"from typing import List def min_steps_to_exit(n: int, m: int, grid: List[str]) -> int: This function finds the minimum number of steps required for the robot to reach the exit cell from the start cell in a n x m grid. If it is not possible to reach the exit, it returns -1. Arguments: n -- number of rows m -- number of columns grid -- n x m grid representation as a list of strings Returns: Integer, the minimum number of steps to reach the exit or -1 if unreachable >>> min_steps_to_exit(5, 5, [\\"S...#\\", \\".#.#.\\", \\".#.#.\\", \\"...#.\\", \\".#..E\\"]) 8 >>> min_steps_to_exit(5, 4, [\\"...#\\", \\".#.#\\", \\".#.#\\", \\"...#\\", \\".#..E\\"]) -1 >>> min_steps_to_exit(4, 4, [\\"S..#\\", \\".#.#\\", \\".#.#\\", \\"...#\\"]) -1 >>> min_steps_to_exit(4, 4, [\\"S.#.\\", \\"\\", \\"....\\", \\"..E.\\"]) -1 >>> min_steps_to_exit(1, 3, [\\"S.E\\"]) 2 >>> min_steps_to_exit(1, 3, [\\"S#E\\"]) -1","solution":"from collections import deque def min_steps_to_exit(n, m, grid): This function finds the minimum number of steps required for the robot to reach the exit cell from the start cell in a n x m grid. If it is not possible to reach the exit, it returns -1. # Find the starting and ending positions start = end = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) if grid[i][j] == 'E': end = (i, j) if not start or not end: return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, steps = queue.popleft() # If we reached the end cell if (x, y) == end: return steps # Explore all 4 directions for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the new position is within the grid and not blocked or visited if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' and (nx, ny) not in visited: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) # If we exhaust the queue without finding the end return -1"},{"question":"def format_title(words: List[str]) -> str: Formats the given list of words as a title. The first word is capitalized, the last word is capitalized, and all other words are in lowercase. >>> format_title([\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumps\\"]) == \\"The quick brown fox Jumps\\" >>> format_title([\\"hello\\"]) == \\"Hello\\" >>> format_title([\\"hello\\", \\"world\\"]) == \\"Hello World\\" >>> format_title([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) == \\"A b c d E\\" >>> format_title([]) == \\"\\" >>> format_title([\\"short\\", \\"mediumlenword\\", \\"a\\"]) == \\"Short mediumlenword A\\"","solution":"def format_title(words): Formats the given list of words as a title. The first and last words are capitalized and all other words are lowercase. if not words: return \\"\\" if len(words) == 1: return words[0].capitalize() formatted_words = [words[0].capitalize()] + words[1:-1] + [words[-1].capitalize()] return ' '.join(formatted_words)"},{"question":"def minimal_total_solving_time(n: int, m: int, competitors: List[List[int]]) -> int: Given n competitors all solving m problems and their respective solving times, calculate the minimal total solving time when problems are assigned optimally. >>> minimal_total_solving_time(2, 3, [ [4, 2, 3], [3, 5, 1] ]) 6 >>> minimal_total_solving_time(1, 1, [ [5] ]) 5 >>> minimal_total_solving_time(3, 1, [ [5], [3], [8] ]) 3 >>> minimal_total_solving_time(1, 3, [ [5, 3, 8] ]) 16 >>> minimal_total_solving_time(2, 100, [ [i for i in range(1, 101)], [i for i in range(101, 201)] ]) 5050","solution":"def minimal_total_solving_time(n, m, competitors): Given n competitors all solving m problems and their respective solving times, calculate the minimal total solving time when problems are assigned optimally. # Transpose the competitors matrix to get the time taken by different competitors for each problem competitors_transposed = list(zip(*competitors)) total_time = 0 # For each problem, pick the minimal time taken by any competitor for problem_times in competitors_transposed: total_time += min(problem_times) return total_time"},{"question":"from typing import List, Tuple class TreeValueManager: def __init__(self, n: int, values: List[int], edges: List[Tuple[int, int]]): Initializes the tree with n nodes, an array \`values\` where \`values[i]\` is the value of the i+1-th node, and a list of edges representing the tree connections. >>> values = [10, 20, 30, 40, 50] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> manager = TreeValueManager(5, values, edges) >>> manager.values == [10, 20, 30, 40, 50] True >>> manager.tree[1] == [2, 3] True def update(self, node: int, value: int): Updates the value of node \`node\` to \`value\`. >>> values = [10, 20, 30, 40, 50] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> manager = TreeValueManager(5, values, edges) >>> manager.update(3, 25) >>> manager.values[2] 25 def query(self, node: int) -> int: Returns the sum of the values of all nodes in the subtree of the given \`node\`. >>> values = [10, 20, 30, 40, 50] >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> manager = TreeValueManager(5, values, edges) >>> manager.query(1) 150 >>> manager.query(2) 20","solution":"from typing import List, Tuple class TreeValueManager: def __init__(self, n: int, values: List[int], edges: List[Tuple[int, int]]): self.n = n self.values = values[:] self.tree = [[] for _ in range(n + 1)] self.subtree_sum = [0] * (n + 1) self.parent = [-1] * (n + 1) self.build_tree(edges) self.dfs(1) def build_tree(self, edges: List[Tuple[int, int]]): for u, v in edges: self.tree[u].append(v) self.tree[v].append(u) def dfs(self, node: int): self.subtree_sum[node] = self.values[node - 1] for neighbor in self.tree[node]: if neighbor != self.parent[node]: self.parent[neighbor] = node self.dfs(neighbor) self.subtree_sum[node] += self.subtree_sum[neighbor] def update(self, node: int, value: int): diff = value - self.values[node - 1] self.values[node - 1] = value self.propagate_update(node, diff) def propagate_update(self, node: int, diff: int): self.subtree_sum[node] += diff if self.parent[node] != -1: self.propagate_update(self.parent[node], diff) def query(self, node: int) -> int: return self.subtree_sum[node]"},{"question":"def min_combinations(masses): You are given a list of asteroid masses, and you can combine any two asteroids into one new asteroid. The mass of the new asteroid is equal to the sum of the initial two asteroid masses. Your task is to repeatedly combine asteroids until only one asteroid remains. You want to minimize the number of asteroid combinations performed. :param masses: List of integers representing the masses of the asteroids. :return: Integer, the minimum number of asteroid combinations required. >>> min_combinations([3, 4, 5]) 2 >>> min_combinations([1, 2, 3, 4]) 3","solution":"def min_combinations(masses): Calculates the minimum number of asteroids combinations required to combine all asteroids into one. Since we must form one final asteroid, the minimum number of combinations is to combine all asteroids in pairs until one is left. :param masses: List of integers representing the masses of the asteroids. :return: Integer, the minimum number of combinations required. # If there are n asteroids initially, we need n - 1 combinations to reduce them to one. return len(masses) - 1"},{"question":"from typing import List def min_moves(grid: List[str]) -> int: Determine the minimum number of moves required for the robot to reach the bottom-right corner of the grid. >>> grid = [ ... \\"....\\", ... \\"..\\", ... \\".#..\\", ... \\"....\\" ... ] >>> min_moves(grid) 6 >>> grid = [ ... \\"....\\", ... \\"\\", ... \\"\\", ... \\"....\\" ... ] >>> min_moves(grid) -1 >>> grid = [ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"....\\" ... ] >>> min_moves(grid) 6 >>> grid = [ ... \\"....\\", ... \\"....\\", ... \\"....\\", ... \\"...#\\" ... ] >>> min_moves(grid) -1 >>> grid = [ ... \\"...#\\", ... \\"#..#\\", ... \\"#...\\", ... \\"....\\" ... ] >>> min_moves(grid) 6","solution":"from collections import deque from typing import List, Tuple def min_moves(grid: List[str]) -> int: rows, cols = 4, 4 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x: int, y: int) -> bool: return 0 <= x < rows and 0 <= y < cols and grid[x][y] == '.' queue = deque([(0, 0, 0)]) # (x, y, number of moves) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() if (x, y) == (3, 3): return moves for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"def count_pairs_with_sum(array: List[int], target: int) -> int: Returns the number of unique pairs in the array that sum up to the target. >>> count_pairs_with_sum([2, 4, 3, 5, 7, 8, 9], 10) 2 >>> count_pairs_with_sum([1, 2, 3, 4, 5], 10) 0 >>> count_pairs_with_sum([0, -1, -2, -3, -4, -5], -8) 1 >>> count_pairs_with_sum([1, 1, 1, 1, 1, 1], 2) 1 >>> count_pairs_with_sum([10**6, -10**6, 0, 10**6, -10**6], 0) 1 >>> count_pairs_with_sum([5, 5, 5, 5], 10) 1 >>> count_pairs_with_sum([], 10) 0 >>> count_pairs_with_sum([10], 10) 0 >>> count_pairs_with_sum(list(range(1, 1001)), 1001) 500 >>> count_pairs_with_sum([1, -1, 2, -2, 3, -3], 0) 3","solution":"def count_pairs_with_sum(array, target): Returns the number of unique pairs in the array that sum up to the target. seen = set() pairs = set() for num in array: difference = target - num if difference in seen: # Add the sorted tuple pair to avoid duplicates like (a, b) and (b, a) pairs.add(tuple(sorted((num, difference)))) seen.add(num) return len(pairs)"},{"question":"class SecureMessagingApp: def __init__(self, n): Initialize the secure messaging app with n users. self.messages = {} self.read_status = {} def send_message(self, user_id, message_content): Send a message to a user. pass def read_message(self, user_id): Read a message for a user. Mark it as read if it exists and is unread. If no message exists or it is already read, return \\"No new message.\\" pass def check_read_status(self, user_id): Check if a message has been read for a user. Return \\"READ\\" if the message has been read, otherwise return \\"UNREAD\\". pass def process_operations(n, operations): Process a list of operations on the secure messaging app with n users. Return the results for operations of type 2 and 3. >>> process_operations(3, [(1, 1, \\"Hello\\"), (1, 2, \\"Hi\\"), (2, 1), (2, 1), (3, 1), (3, 2)]) ['Hello', 'No new message.', 'READ', 'UNREAD'] app = SecureMessagingApp(n) results = [] for operation in operations: op_type = operation[0] if op_type == 1: _, user_id, message_content = operation app.send_message(user_id, message_content) elif op_type == 2: _, user_id = operation results.append(app.read_message(user_id)) elif op_type == 3: _, user_id = operation results.append(app.check_read_status(user_id)) return results def test_process_operations(): n = 3 operations = [ (1, 1, \\"Hello\\"), (1, 2, \\"Hi\\"), (2, 1), (2, 1), (3, 1), (3, 2) ] expected_output = [\\"Hello\\", \\"No new message.\\", \\"READ\\", \\"UNREAD\\"] assert process_operations(n, operations) == expected_output def test_send_read_check(): n = 4 operations = [ (1, 1, \\"Test message\\"), (1, 2, \\"Another message\\"), (1, 3, \\"Third message\\"), (2, 2), (3, 2), (3, 3), (2, 3), (2, 3), (3, 3) ] expected_output = [\\"Another message\\", \\"READ\\", \\"UNREAD\\", \\"Third message\\", \\"No new message.\\", \\"READ\\"] assert process_operations(n, operations) == expected_output def test_no_message(): n = 2 operations = [ (2, 1), (3, 1), (3, 2) ] expected_output = [\\"No new message.\\", \\"UNREAD\\", \\"UNREAD\\"] assert process_operations(n, operations) == expected_output def test_only_send_messages(): n = 5 operations = [ (1, 1, \\"Message 1\\"), (1, 2, \\"Message 2\\"), (1, 1, \\"Message 1 updated\\") ] expected_output = [] assert process_operations(n, operations) == expected_output def test_remove_messages(): n = 2 operations = [ (1, 1, \\"First message\\"), (2, 1), (2, 1), (3, 1), (1, 1, \\"Second message\\"), (3, 1), (2, 1) ] expected_output = [\\"First message\\", \\"No new message.\\", \\"READ\\", \\"UNREAD\\", \\"Second message\\"] assert process_operations(n, operations) == expected_output","solution":"class SecureMessagingApp: def __init__(self, n): self.messages = {} self.read_status = {} def send_message(self, user_id, message_content): self.messages[user_id] = message_content self.read_status[user_id] = False def read_message(self, user_id): if user_id in self.messages and not self.read_status[user_id]: self.read_status[user_id] = True return self.messages[user_id] else: return \\"No new message.\\" def check_read_status(self, user_id): if user_id in self.read_status and self.read_status[user_id]: return \\"READ\\" else: return \\"UNREAD\\" def process_operations(n, operations): app = SecureMessagingApp(n) results = [] for operation in operations: op_type = operation[0] if op_type == 1: _, user_id, message_content = operation app.send_message(user_id, message_content) elif op_type == 2: _, user_id = operation results.append(app.read_message(user_id)) elif op_type == 3: _, user_id = operation results.append(app.check_read_status(user_id)) return results"},{"question":"def largest_square_subgrid_same_height(R: int, C: int, grid: List[List[int]]) -> int: Find the size of the largest square sub-grid where all cells have the same height. >>> largest_square_subgrid_same_height(4, 5, [ ... [1, 2, 2, 3, 4], ... [2, 2, 2, 3, 3], ... [2, 2, 2, 1, 3], ... [2, 2, 2, 1, 1] ... ]) == 3 >>> largest_square_subgrid_same_height(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 3 >>> largest_square_subgrid_same_height(2, 2, [ ... [1, 2], ... [3, 4] ... ]) == 1 >>> largest_square_subgrid_same_height(1, 5, [ ... [5, 5, 5, 5, 5] ... ]) == 1 >>> largest_square_subgrid_same_height(5, 1, [ ... [5], ... [5], ... [5], ... [5], ... [5] ... ]) == 1 >>> largest_square_subgrid_same_height(4, 4, [ ... [1, 1, 1, 1], ... [1, 2, 2, 1], ... [1, 2, 2, 1], ... [1, 1, 1, 1] ... ]) == 2","solution":"def largest_square_subgrid_same_height(R, C, grid): # Initialize DP table dp = [[0] * C for _ in range(R)] max_size = 0 for i in range(R): for j in range(C): if i == 0 or j == 0: dp[i][j] = 1 # Base case: every cell in the first row and column can only form a 1x1 square else: if grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 if dp[i][j] > max_size: max_size = dp[i][j] return max_size"},{"question":"def longest_subarray_with_sum_k(n: int, k: int, arr: List[int]) -> int: Determine the length of the longest subarray which has the sum of its elements equal to a given integer \`k\`. >>> longest_subarray_with_sum_k(8, 15, [10, 5, 2, 7, 1, 9, -1, 3]) 4 >>> longest_subarray_with_sum_k(5, 20, [1, 2, 3, 4, 5]) 0 >>> longest_subarray_with_sum_k(3, 6, [1, 2, 3]) 3 >>> longest_subarray_with_sum_k(5, 10, [1, 2, 3, 4, 5]) 4 >>> longest_subarray_with_sum_k(6, 5, [1, 2, 1, 2, 1, 2]) 3 >>> longest_subarray_with_sum_k(6, 0, [2, -2, 2, -2, 2, -2]) 6","solution":"def longest_subarray_with_sum_k(n, k, arr): prefix_sum = 0 max_length = 0 sum_map = {} for i in range(n): prefix_sum += arr[i] if prefix_sum == k: max_length = i + 1 if (prefix_sum - k) in sum_map: max_length = max(max_length, i - sum_map[prefix_sum - k]) if prefix_sum not in sum_map: sum_map[prefix_sum] = i return max_length"},{"question":"def card_game(alice: List[int], bob: List[int]) -> str: Simulates a card game between Alice and Bob and determines the winner. Params: - alice: List[int] - List of integers representing Alice's cards. - bob: List[int] - List of integers representing Bob's cards. Returns: - str - The winner of the game (\\"Alice\\", \\"Bob\\", or \\"Draw\\"). >>> card_game([5, 3, 2, 4], [4, 3, 3, 1]) 'Alice' >>> card_game([1, 2, 3], [4, 5, 6]) 'Bob' >>> card_game([2, 2], [2, 2]) 'Draw'","solution":"from typing import List def card_game(alice: List[int], bob: List[int]) -> str: Simulates a card game between Alice and Bob and determines the winner. Params: - alice: List[int] - List of integers representing Alice's cards. - bob: List[int] - List of integers representing Bob's cards. Returns: - str - The winner of the game (\\"Alice\\", \\"Bob\\", or \\"Draw\\"). alice_points = 0 bob_points = 0 rounds = min(len(alice), len(bob)) for i in range(rounds): if alice[i] > bob[i]: alice_points += 1 elif bob[i] > alice[i]: bob_points += 1 if alice_points > bob_points: return \\"Alice\\" elif bob_points > alice_points: return \\"Bob\\" else: return \\"Draw\\""},{"question":"def has_pair_with_sum(n: int, list1: List[int], m: int, list2: List[int], target: int) -> str: Determines if there is a pair of numbers (one from the first list and one from the second list) whose sum is equal to the target sum. >>> has_pair_with_sum(4, [1, 2, 3, 4], 5, [5, 6, 7, 8, 9], 10) \\"YES\\" >>> has_pair_with_sum(3, [1, 2, 3], 3, [4, 5, 6], 10) \\"NO\\"","solution":"def has_pair_with_sum(n, list1, m, list2, target): Determines if there's any pair of numbers (one from each list) that sum up to the target value. complements = set() # Store complements of list1 relative to the target in a set for num in list1: complements.add(target - num) # Check if any number in list2 is in the complements set for num in list2: if num in complements: return \\"YES\\" return \\"NO\\""},{"question":"def can_be_sorted_with_one_swap(n: int, arr: List[int]) -> str: Returns \\"YES\\" if the array can be sorted in non-decreasing order with at most one adjacent swap, otherwise \\"NO\\". >>> can_be_sorted_with_one_swap(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_be_sorted_with_one_swap(5, [1, 3, 2, 4, 5]) \\"YES\\" >>> can_be_sorted_with_one_swap(2, [2, 1]) \\"YES\\" >>> can_be_sorted_with_one_swap(5, [5, 3, 1, 2, 4]) \\"NO\\" >>> can_be_sorted_with_one_swap(3, [3, 1, 2]) \\"NO\\" >>> can_be_sorted_with_one_swap(4, [4, 3, 2, 1]) \\"NO\\" >>> can_be_sorted_with_one_swap(2, [1, 2]) \\"YES\\" >>> can_be_sorted_with_one_swap(2, [2, 1]) \\"YES\\" >>> can_be_sorted_with_one_swap(5, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_be_sorted_with_one_swap(5, [1, 2, 4, 3, 5]) \\"YES\\"","solution":"def can_be_sorted_with_one_swap(n, arr): Returns \\"YES\\" if the array can be sorted in non-decreasing order with at most one adjacent swap, otherwise \\"NO\\". sorted_arr = sorted(arr) diff_count = 0 for i in range(n): if arr[i] != sorted_arr[i]: diff_count += 1 return \\"YES\\" if diff_count <= 2 else \\"NO\\""},{"question":"def sieve_of_eratosthenes(n): Returns a list of primes up to n using the Sieve of Eratosthenes pass def sum_primes_in_range(x, y, primes): Returns the sum of primes in the range [x, y] pass def process_queries(queries): Returns a list of results for the sum of primes in range for each query pass def sum_primes_queries(q, queries): Main function to process all the queries and return results pass def test_sum_primes_queries(): queries = [(10, 20), (21, 29), (1, 3)] expected = [60, 52, 5] assert sum_primes_queries(3, queries) == expected def test_sum_primes_queries_single_range(): queries = [(10, 10)] expected = [0] assert sum_primes_queries(1, queries) == expected def test_sum_primes_queries_large_range(): queries = [(1, 100)] expected = [1060] # Sum of primes from 1 to 100 assert sum_primes_queries(1, queries) == expected def test_sum_primes_queries_no_primes(): queries = [(24, 28)] expected = [0] # No primes between 24 and 28 assert sum_primes_queries(1, queries) == expected def test_sum_primes_queries_reverse_range(): queries = [(20, 10)] expected = [60] # Should still calculate correctly for the range 10 to 20 assert sum_primes_queries(1, queries) == expected","solution":"def sieve_of_eratosthenes(n): Returns a list of primes up to n using the Sieve of Eratosthenes is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_nums = [p for p in range(2, n + 1) if is_prime[p]] return prime_nums def sum_primes_in_range(x, y, primes): Returns the sum of primes in the range [x, y] return sum(p for p in primes if x <= p <= y) def process_queries(queries): Returns a list of results for the sum of primes in range for each query max_query_value = max(max(x, y) for x, y in queries) primes = sieve_of_eratosthenes(max_query_value) results = [] for x, y in queries: if y < x: x, y = y, x results.append(sum_primes_in_range(x, y, primes)) return results def sum_primes_queries(q, queries): Main function to process all the queries and return results return process_queries(queries)"},{"question":"def can_form_target(word_list: List[str], target: str) -> bool: Determines if the target string can be formed by concatenating any two different strings from the list. Parameters: - word_list: List[str] - A list of strings. - target: str - The target string to form. Returns: - bool - True if the target string can be formed, False otherwise. >>> can_form_target([\\"ab\\", \\"c\\", \\"abc\\", \\"d\\"], \\"abcd\\") True >>> can_form_target([\\"ab\\", \\"c\\", \\"abc\\", \\"d\\"], \\"cad\\") False","solution":"def can_form_target(word_list, target): Determines if the target string can be formed by concatenating any two different strings from the list. Parameters: - word_list: List[str] - A list of strings. - target: str - The target string to form. Returns: - bool - True if the target string can be formed, False otherwise. seen = set(word_list) for word in word_list: if target.startswith(word): suffix = target[len(word):] if suffix in seen and suffix != word: return True return False"},{"question":"def count_unique_sequences(n: int, k: int) -> int: Determine the total number of unique sequences of length k that can be formed using n types of carrot seeds, such that no two adjacent carrot plants can be of the same type. The result should be in modulo 10^9 + 7. >>> count_unique_sequences(3, 2) 6 >>> count_unique_sequences(2, 2) 2 >>> count_unique_sequences(2, 3) 2 >>> count_unique_sequences(1, 1) 1 >>> count_unique_sequences(1, 2) 0 >>> count_unique_sequences(1, 1000) 0 >>> count_unique_sequences(1000, 1) 1000 >>> count_unique_sequences(500, 1) 500 >>> count_unique_sequences(1000, 2) 999000 >>> count_unique_sequences(1000, 3) 998001000 MOD = 10**9 + 7","solution":"MOD = 10**9 + 7 def count_unique_sequences(n, k): if k == 1: return n sequences_for_k_minus_1 = n sequences_for_k = n * (n - 1) for i in range(2, k): new_sequences_for_k = sequences_for_k * (n - 1) sequences_for_k = new_sequences_for_k % MOD return sequences_for_k % MOD"},{"question":"from typing import List def find_pair_with_sum(nums: List[int], target: int) -> List[int]: Returns a pair of integers that add up to the target, or an empty list if no such pair exists. :param nums: List[int] - A list of distinct integers :param target: int - The target sum :return: List[int] - A list containing the pair of integers that add up to the target, or an empty list >>> find_pair_with_sum([2, 7, 11, 15], 9) [2, 7] >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) [] from find_pair_with_sum import find_pair_with_sum def test_pair_exists(): assert find_pair_with_sum([2, 7, 11, 15], 9) in [[2, 7], [7, 2]] assert find_pair_with_sum([1, -1, 3, 4], 2) in [[3, -1], [-1, 3]] assert find_pair_with_sum([10, 25, 30, -10], 20) in [[30, -10], [-10, 30]] def test_pair_does_not_exist(): assert find_pair_with_sum([1, 2, 3, 4, 5], 10) == [] assert find_pair_with_sum([2, 4, 6, 8], 15) == [] assert find_pair_with_sum([5, 9, 13], 1) == [] def test_single_element(): assert find_pair_with_sum([5], 10) == [] def test_no_elements(): assert find_pair_with_sum([], 3) == [] def test_negative_numbers(): assert find_pair_with_sum([-3, -2, -1], -5) in [[-3, -2], [-2, -3]] assert find_pair_with_sum([-4, -7, -9], -13) in [[-4, -9], [-9, -4]]","solution":"def find_pair_with_sum(nums, target): Returns a pair of integers that add up to the target, or an empty list if no such pair exists. :param nums: List[int] - A list of distinct integers :param target: int - The target sum :return: List[int] - A list containing the pair of integers that add up to the target, or an empty list num_set = set() for num in nums: complement = target - num if complement in num_set: return [num, complement] num_set.add(num) return []"},{"question":"def find_strongest_tremor(Ex, Ey, cities): Finds the city that will experience the strongest tremor based on the coordinates of the epicenter and the cities. Args: Ex, Ey: Coordinates of the epicenter cities: List of tuples containing the coordinates of the cities Returns: Index (1-based) of the city that will experience the strongest tremor >>> find_strongest_tremor(3, 4, [(0, 0), (5, 5), (10, 10)]) 2 >>> find_strongest_tremor(0, 0, [(1, 1)]) 1 >>> find_strongest_tremor(0, 0, [(1, 1), (-1, -1)]) 1 >>> find_strongest_tremor(1, 1, [(0, 0), (2, 2), (3, 4)]) 1 >>> find_strongest_tremor(1, 1, [(1, 1), (2, 2), (3, 3)]) 1 >>> find_strongest_tremor(500, 500, [(i, i) for i in range(0, 1000)]) 501","solution":"def find_strongest_tremor(Ex, Ey, cities): Finds the city that will experience the strongest tremor based on the coordinates of the epicenter and the cities. Args: Ex, Ey: Coordinates of the epicenter cities: List of tuples containing the coordinates of the cities Returns: Index (1-based) of the city that will experience the strongest tremor def squared_distance(x1, y1, x2, y2): return (x1 - x2) ** 2 + (y1 - y2) ** 2 min_distance = float('inf') strongest_city_index = -1 for i, (Cx, Cy) in enumerate(cities): dist = squared_distance(Ex, Ey, Cx, Cy) if dist < min_distance: min_distance = dist strongest_city_index = i + 1 return strongest_city_index"},{"question":"def min_operations(t, test_cases): Determine the minimum number of operations required to transform sequence A into sequence B. Args: t (int): The number of test cases. test_cases (list): A list of tuples, where each tuple contains: - An integer n - A list of integers representing sequence A - A list of integers representing sequence B Returns: list: A list of integers where each integer is the minimum number of operations required for a test case. >>> min_operations(1, [(3, [1, 2, 3], [4, 5, 6])]) [9] >>> min_operations(1, [(4, [1, 2, 3, 4], [4, 3, 2, 1])]) [8] >>> min_operations(2, [(3, [1, 2, 3], [4, 5, 6]), (4, [1, 2, 3, 4], [4, 3, 2, 1])]) [9, 8] >>> min_operations(1, [(3, [1, 1, 1], [1, 1, 1])]) [0] >>> min_operations(1, [(3, [1, 1, 1], [3, 3, 3])]) [6]","solution":"def min_operations(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] A = test_cases[i][1] B = test_cases[i][2] operations = sum(abs(a - b) for a, b in zip(A, B)) results.append(operations) return results"},{"question":"class MovieMarathon: A class to track contributions and spending for a movie marathon night. The class supports adding friends and their contributions, adding items and their prices, listing friends and items, calculating total collected money, total spending, and remaining balance. Methods: - add_friend(name: str, amount: int) - list_friends() -> List[Tuple[str, int]] - add_item(item_name: str, price: int) - list_items() -> List[Tuple[str, int]] - total_collected() -> int - total_spent() -> int - balance() -> int def __init__(self): pass def add_friend(self, name, amount): pass def list_friends(self): pass def add_item(self, item_name, price): pass def list_items(self): pass def total_collected(self): pass def total_spent(self): pass def balance(self): pass # Unit Test def test_add_friend(): marathon = MovieMarathon() marathon.add_friend(\\"Alice\\", 50) marathon.add_friend(\\"Bob\\", 30) assert marathon.list_friends() == [(\\"Alice\\", 50), (\\"Bob\\", 30)] def test_add_friend_duplicate(): marathon = MovieMarathon() marathon.add_friend(\\"Alice\\", 50) marathon.add_friend(\\"Alice\\", 20) assert marathon.list_friends() == [(\\"Alice\\", 70)] def test_list_friends(): marathon = MovieMarathon() marathon.add_friend(\\"Alice\\", 50) marathon.add_friend(\\"Bob\\", 30) assert set(marathon.list_friends()) == set([(\\"Alice\\", 50), (\\"Bob\\", 30)]) def test_add_item(): marathon = MovieMarathon() marathon.add_item(\\"Popcorn\\", 20) marathon.add_item(\\"Soda\\", 10) assert marathon.list_items() == [(\\"Popcorn\\", 20), (\\"Soda\\", 10)] def test_add_item_duplicate(): marathon = MovieMarathon() marathon.add_item(\\"Popcorn\\", 20) marathon.add_item(\\"Popcorn\\", 10) assert marathon.list_items() == [(\\"Popcorn\\", 30)] def test_list_items(): marathon = MovieMarathon() marathon.add_item(\\"Popcorn\\", 20) marathon.add_item(\\"Soda\\", 10) assert set(marathon.list_items()) == set([(\\"Popcorn\\", 20), (\\"Soda\\", 10)]) def test_total_collected(): marathon = MovieMarathon() marathon.add_friend(\\"Alice\\", 50) marathon.add_friend(\\"Bob\\", 30) assert marathon.total_collected() == 80 def test_total_spent(): marathon = MovieMarathon() marathon.add_item(\\"Popcorn\\", 20) marathon.add_item(\\"Soda\\", 10) assert marathon.total_spent() == 30 def test_balance(): marathon = MovieMarathon() marathon.add_friend(\\"Alice\\", 50) marathon.add_friend(\\"Bob\\", 30) marathon.add_item(\\"Popcorn\\", 20) marathon.add_item(\\"Soda\\", 10) assert marathon.balance() == 50","solution":"class MovieMarathon: def __init__(self): self.friends = {} self.items = {} def add_friend(self, name, amount): if name in self.friends: self.friends[name] += amount else: self.friends[name] = amount def list_friends(self): return [(name, amount) for name, amount in self.friends.items()] def add_item(self, item_name, price): if item_name in self.items: self.items[item_name] += price else: self.items[item_name] = price def list_items(self): return [(item_name, price) for item_name, price in self.items.items()] def total_collected(self): return sum(self.friends.values()) def total_spent(self): return sum(self.items.values()) def balance(self): return self.total_collected() - self.total_spent()"},{"question":"from typing import List def max_consecutive_ones(flips: List[int]) -> int: You are given a list of integers that represents a sequence of coin flips, where 1 corresponds to a Heads and 0 corresponds to a Tails. You need to find the maximum length of consecutive 1s in the sequence after flipping at most one 0 to 1. >>> max_consecutive_ones([1, 1, 1, 1, 1]) == 5 >>> max_consecutive_ones([1, 1, 0, 1, 1]) == 5 >>> max_consecutive_ones([1, 0, 1, 0, 1, 1, 1]) == 5 >>> max_consecutive_ones([0, 0, 0, 0, 0]) == 1 >>> max_consecutive_ones([]) == 0 >>> max_consecutive_ones([1]) == 1 >>> max_consecutive_ones([0]) == 1 >>> max_consecutive_ones([1, 1, 1, 0]) == 4 >>> max_consecutive_ones([0, 1, 1, 1]) == 4","solution":"from typing import List def max_consecutive_ones(flips: List[int]) -> int: max_len = 0 # Stores the maximum length of consecutive 1s zero_count = 0 # Counts the number of zeros in the current window left = 0 # Left pointer of the sliding window for right in range(len(flips)): if flips[right] == 0: zero_count += 1 # If there are more than one 0 in the window, shrink the window from the left while zero_count > 1: if flips[left] == 0: zero_count -= 1 left += 1 # Calculate the length of the current window max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def generateParentheses(n: int) -> List[str]: Given an integer \`n\`, generate all combinations of balanced parentheses of length \`2*n\`. >>> generateParentheses(1) == [\\"()\\"] >>> generateParentheses(2) == [\\"(())\\", \\"()()\\"] >>> generateParentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generateParentheses(4) == [ \\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\" ] def test_generateParentheses_n1(): assert generateParentheses(1) == [\\"()\\"] def test_generateParentheses_n2(): assert generateParentheses(2) == [\\"(())\\", \\"()()\\"] def test_generateParentheses_n3(): assert generateParentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] def test_generateParentheses_n4(): assert generateParentheses(4) == [ \\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\" ] def test_generateParentheses_sorted(): # Ensure output is in lexicographical order result = generateParentheses(3) assert result == sorted(result)","solution":"from typing import List def generateParentheses(n: int) -> List[str]: def backtrack(S, left, right): if len(S) == 2 * n: result.append(\\"\\".join(S)) return if left < n: S.append(\\"(\\") backtrack(S, left + 1, right) S.pop() if right < left: S.append(\\")\\") backtrack(S, left, right + 1) S.pop() result = [] backtrack([], 0, 0) return sorted(result)"},{"question":"def magic_triangle(n: int) -> List[List[int]]: Generate a triangular pattern of numbers where each number is the sum of the two directly above it, modulo 100. Parameters: - n (int): The number of rows in the triangle. Returns: - List[List[int]]: The generated triangle as a list of lists. >>> magic_triangle(5) [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] >>> magic_triangle(7) [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1] ]","solution":"def magic_triangle(n): Generate a triangular pattern of numbers where each number is the sum of the two directly above it, modulo 100. Parameters: - n (int): The number of rows in the triangle. Returns: - List[List[int]]: The generated triangle as a list of lists. if n <= 0: return [] # Initialize the triangle with the first row triangle = [[1]] for i in range(1, n): # Start each row with a 1 row = [1] for j in range(1, i): # Each element is the sum of the two elements directly above it value = (triangle[i-1][j-1] + triangle[i-1][j]) % 100 row.append(value) # End each row with a 1 row.append(1) triangle.append(row) return triangle"},{"question":"def update_inventory(n, m, initial_stocks, actions): Update the inventory levels of n product types based on m actions. Parameters: - n (int): Number of product types. - m (int): Number of actions. - initial_stocks (list of int): Initial stock levels for product types. - actions (list of str): List of actions in the format \\"add p q\\" or \\"remove p q\\". Returns: - List of int: Final stock levels of the product types. pass # Example Test Cases import pytest from solution import update_inventory def test_example_case(): n = 3 m = 6 initial_stocks = [10, 20, 30] actions = [ \\"add 1 5\\", \\"remove 2 10\\", \\"add 3 10\\", \\"remove 1 3\\", \\"add 2 15\\", \\"remove 3 5\\" ] expected = [12, 25, 35] assert update_inventory(n, m, initial_stocks, actions) == expected def test_no_action(): n = 3 m = 0 initial_stocks = [10, 20, 30] actions = [] expected = [10, 20, 30] assert update_inventory(n, m, initial_stocks, actions) == expected def test_all_adds(): n = 2 m = 4 initial_stocks = [5, 10] actions = [ \\"add 1 5\\", \\"add 2 10\\", \\"add 1 10\\", \\"add 2 5\\" ] expected = [20, 25] assert update_inventory(n, m, initial_stocks, actions) == expected def test_all_removes(): n = 2 m = 4 initial_stocks = [20, 30] actions = [ \\"remove 1 5\\", \\"remove 2 10\\", \\"remove 1 10\\", \\"remove 2 5\\" ] expected = [5, 15] assert update_inventory(n, m, initial_stocks, actions) == expected def test_mixed_actions(): n = 3 m = 5 initial_stocks = [50, 60, 70] actions = [ \\"add 1 20\\", \\"remove 2 30\\", \\"add 3 25\\", \\"remove 1 10\\", \\"add 2 15\\" ] expected = [60, 45, 95] assert update_inventory(n, m, initial_stocks, actions) == expected","solution":"def update_inventory(n, m, initial_stocks, actions): Update the inventory levels of n product types based on m actions. Parameters: - n (int): Number of product types. - m (int): Number of actions. - initial_stocks (list of int): Initial stock levels for product types. - actions (list of str): List of actions in the format \\"add p q\\" or \\"remove p q\\". Returns: - List of int: Final stock levels of the product types. # Convert initial stocks from list to a dictionary for easy access by product type stocks = {i+1: initial_stocks[i] for i in range(n)} for action in actions: parts = action.split() command = parts[0] product_type = int(parts[1]) amount = int(parts[2]) if command == \\"add\\": stocks[product_type] += amount elif command == \\"remove\\": stocks[product_type] -= amount # Convert stocks dictionary back into a list sorted by product type final_stocks = [stocks[i+1] for i in range(n)] return final_stocks"},{"question":"def longest_zigzag_subsequence_length(arr): Returns the length of the longest zigzag subsequence. >>> longest_zigzag_subsequence_length([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_subsequence_length([1, 17, 5, 10, 13, 15, 10]) 5 >>> longest_zigzag_subsequence_length([10]) 1 >>> longest_zigzag_subsequence_length([5, 5, 5, 5]) 1 >>> longest_zigzag_subsequence_length([1, 2, 3, 4, 5]) 2 >>> longest_zigzag_subsequence_length([5, 4, 3, 2, 1]) 2 >>> longest_zigzag_subsequence_length([1, 3, 2, 4, 3, 5, 4]) 7","solution":"def longest_zigzag_subsequence_length(arr): Returns the length of the longest zigzag subsequence. n = len(arr) if n < 2: return n up = [1] * n down = [1] * n for i in range(1, n): if arr[i] > arr[i - 1]: up[i] = down[i - 1] + 1 down[i] = down[i - 1] elif arr[i] < arr[i - 1]: down[i] = up[i - 1] + 1 up[i] = up[i - 1] else: up[i] = up[i - 1] down[i] = down[i - 1] return max(up[n - 1], down[n - 1]) # Example usage: # n = int(input()) # arr = list(map(int, input().split())) # print(longest_zigzag_subsequence_length(arr))"},{"question":"def maximum_product_of_three_numbers(lst: List[int]) -> int: Write a function that takes a list of non-negative integers and returns the maximum product of any three distinct numbers from the list. If the list has fewer than three elements, return -1. >>> maximum_product_of_three_numbers([1, 10, 2, 6, 5, 3]) 300 >>> maximum_product_of_three_numbers([1, 2]) -1","solution":"def maximum_product_of_three_numbers(lst): if len(lst) < 3: return -1 # Sorting the list to find the three largest numbers lst.sort() # Maximum product is either from the three largest numbers or two smallest and the largest one return max(lst[-1] * lst[-2] * lst[-3], lst[0] * lst[1] * lst[-1])"},{"question":"def is_path_possible(n: int, m: int, grid: List[List[int]]) -> str: Determine if you can travel from the top-left corner to the bottom-right corner of a grid. >>> is_path_possible(4, 5, [ ... [1, 0, 1, 1, 0], ... [1, 1, 0, 1, 0], ... [0, 1, 1, 1, 1], ... [0, 0, 0, 1, 1] ... ]) == \\"YES\\" >>> is_path_possible(3, 3, [ ... [0, 1, 1], ... [1, 1, 0], ... [1, 1, 1] ... ]) == \\"NO\\"","solution":"def is_path_possible(n, m, grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0 or visited[x][y]: return False if x == n-1 and y == m-1: return True visited[x][y] = True return (dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1)) if grid[0][0] == 0 or grid[n-1][m-1] == 0: return \\"NO\\" visited = [[False]*m for _ in range(n)] return \\"YES\\" if dfs(0, 0) else \\"NO\\" # Example usage: # n = 4 # m = 5 # grid = [ # [1, 0, 1, 1, 0], # [1, 1, 0, 1, 0], # [0, 1, 1, 1, 1], # [0, 0, 0, 1, 1] # ] # print(is_path_possible(n, m, grid)) # Output: YES"},{"question":"def min_distance_to_retrieve_packages(n: int, m: int, grid: List[List[int]]) -> int: Returns the minimum distance required to retrieve all packages and potentially return to the start after collecting all packages. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_distance_to_retrieve_packages(3, 3, grid) 8 >>> grid = [ ... [1] ... ] >>> min_distance_to_retrieve_packages(1, 1, grid) 0 >>> grid = [ ... [0, 1], ... [2, 3] ... ] >>> min_distance_to_retrieve_packages(2, 2, grid) 3 >>> grid = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> min_distance_to_retrieve_packages(4, 4, grid) 15 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> min_distance_to_retrieve_packages(2, 3, grid) 5","solution":"def min_distance_to_retrieve_packages(n, m, grid): Returns the minimum distance required to retrieve all packages and potentially return to the start after collecting all packages. # The optimal path to cover all cells in an n x m grid is typically following a serpentine pattern. # The shortest route to visit each cell once and cover an entire grid is generally close to \`n * m\`. # If there are no specific rules about return, this distance does not double back, it just covers the grid once. return n * m - 1 # minimum distance to traverse all cells without revisiting any cell # Example usage: n = 3 m = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(min_distance_to_retrieve_packages(n, m, grid)) # Output: 8"},{"question":"def min_reversals_to_unbalance(s: str) -> int: Given a balanced string of brackets, determine the minimum number of reversals needed to make the string unbalanced. >>> min_reversals_to_unbalance(\\"()()\\") 1 >>> min_reversals_to_unbalance(\\"(()())\\") 1","solution":"def min_reversals_to_unbalance(s): Given a balanced string of brackets, determine the minimum number of reversals needed to make the string unbalanced. return 1"},{"question":"from typing import List, Tuple def min_jars(n: int, jars: List[int]) -> int: Determine the minimum number of jars needed to get exactly n grams of the ingredient. >>> min_jars(7, [1, 3, 4]) 2 >>> min_jars(10, [2, 3, 5, 7]) 2 >>> min_jars(5, [3, 4]) -1 pass def process_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Process multiple test cases and return the results for each one. >>> process_cases([(7, 3, [1, 3, 4]), (10, 4, [2, 3, 5, 7]), (5, 2, [3, 4]), (15, 2, [1, 5])]) [2, 2, -1, 3] >>> process_cases([(1000, 1, [1000])]) [1] >>> process_cases([(1, 1, [2])]) [-1] >>> process_cases([(1000, 2, [1, 1000])]) [1] pass","solution":"def min_jars(n, jars): dp = [float('inf')] * (n + 1) dp[0] = 0 for jar in jars: for i in range(jar, n + 1): if dp[i - jar] != float('inf'): dp[i] = min(dp[i], dp[i - jar] + 1) return dp[n] if dp[n] != float('inf') else -1 def process_cases(test_cases): results = [] for n, m, jars in test_cases: results.append(min_jars(n, jars)) return results"},{"question":"def is_beautiful_grid(n: int, m: int, grid: List[List[int]]) -> str: Determines if it's possible to make the grid a beautiful grid. >>> is_beautiful_grid(3, 3, [[1, 2, 3], [1, 3, 2], [2, 1, 3]]) 'Yes' >>> is_beautiful_grid(2, 2, [[4, 3], [2, 1]]) 'No'","solution":"def is_beautiful_grid(n, m, grid): Determines if it's possible to make the grid a beautiful grid. # Sort every row and column of the grid for row in grid: row.sort() sorted_transposed_grid = [[grid[j][i] for j in range(n)] for i in range(m)] for col in sorted_transposed_grid: col.sort() sorted_grid = [[sorted_transposed_grid[j][i] for j in range(n)] for i in range(m)] # Check if the sorted rows and sorted columns match for i in range(n): for j in range(m): if grid[i][j] != sorted_grid[i][j]: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List def is_zigzag_number(n: int) -> str: Determine if a given number n is a zigzag number. A zigzag number is defined as a number where every adjacent pair of digits consistently alternates between increasing and decreasing. :param n: Integer n (10 ≤ n ≤ 10^9) :return: \\"TRUE\\" if n is a zigzag number, \\"FALSE\\" otherwise >>> is_zigzag_number(121) \\"TRUE\\" >>> is_zigzag_number(123) \\"FALSE\\" >>> is_zigzag_number(214365) \\"TRUE\\"","solution":"def is_zigzag_number(n): Determine if a given number n is a zigzag number. A zigzag number is defined as a number where every adjacent pair of digits consistently alternates between increasing and decreasing. :param n: Integer n (10 ≤ n ≤ 10^9) :return: \\"TRUE\\" if n is a zigzag number, \\"FALSE\\" otherwise # Convert the number to a string to easily access digits num_str = str(n) length = len(num_str) # Check if at least 2 digits exist if length < 2: return \\"FALSE\\" # Iterate through the number to check the zigzag pattern for i in range(1, length - 1): if not ((num_str[i-1] < num_str[i] and num_str[i] > num_str[i+1]) or (num_str[i-1] > num_str[i] and num_str[i] < num_str[i+1])): return \\"FALSE\\" return \\"TRUE\\""},{"question":"def calculate_total_salary(employees: List[Tuple[int, int, int]]) -> List[float]: Calculate the total salary for a list of employees including base salary and commissions, and sort them in descending order of total salary. :param employees: List of tuples (base_salary, number_of_sales, total_sales_value) :return: List of total salaries sorted in descending order >>> calculate_total_salary([(3000, 15, 20000), (3000, 25, 30000), (3000, 5, 10000)]) [7500.00, 6450.00, 3500.00] >>> calculate_total_salary([(5000, 0, 0), (4000, 0, 0)]) [5000.00, 4000.00]","solution":"def calculate_total_salary(employees): Calculate the total salary for a list of employees including base salary and commissions, and sort them in descending order of total salary. :param employees: List of tuples (base_salary, number_of_sales, total_sales_value) :return: List of total salaries sorted in descending order total_salaries = [] for i, (base_salary, num_sales, total_sales_value) in enumerate(employees): if num_sales <= 10: commission = 0.05 * total_sales_value elif 11 <= num_sales <= 20: commission = 0.10 * total_sales_value else: commission = 0.15 * total_sales_value total_salary = base_salary + commission total_salaries.append((total_salary, i)) # Sort by total salary (descending) and by initial order in case of tie total_salaries.sort(key=lambda x: (-x[0], x[1])) # Return only the total salaries sorted_salaries = [salary for salary, _ in total_salaries] return sorted_salaries"},{"question":"def trapWater(heights: List[int]) -> int: Compute how much water can be trapped between the blocks after it rains. :param heights: List of non-negative integers representing heights of blocks :return: An integer representing the total amount of water trapped >>> trapWater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trapWater([4,2,0,3,2,5]) 9 >>> trapWater([1,1,1,1]) 0 >>> trapWater([3,0,2,0,4]) 7 >>> trapWater([3,3,3,3,3]) 0 >>> trapWater([0]) 0 >>> trapWater([10]) 0","solution":"def trapWater(heights): Compute how much water can be trapped between the blocks. :param heights: List of non-negative integers representing heights of blocks :return: An integer representing the total amount of water trapped if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def sort_circles_by_area(radii): Given a list of radii, returns the 1-based indices of the sorted radii based on the area of the circles. The sort should be stable in case of equal areas. pass # Example usage: # radii = [3, 1, 2, 4, 2] # print(sort_circles_by_area(radii)) # Output: [2, 3, 5, 1, 4] # Unit tests: def test_sort_circles_by_area_example_case(): radii = [3, 1, 2, 4, 2] expected = [2, 3, 5, 1, 4] assert sort_circles_by_area(radii) == expected def test_sort_circles_by_area_single_radius(): radii = [5] expected = [1] assert sort_circles_by_area(radii) == expected def test_sort_circles_by_area_all_same_radius(): radii = [3, 3, 3, 3] expected = [1, 2, 3, 4] assert sort_circles_by_area(radii) == expected def test_sort_circles_by_area_different_radii(): radii = [1, 3, 2, 5, 4] expected = [1, 3, 2, 5, 4] assert sort_circles_by_area(radii) == expected def test_sort_circles_by_area_large_radii(): radii = [1000000000, 999999999] expected = [2, 1] assert sort_circles_by_area(radii) == expected def test_sort_circles_by_area_two_same_area(): radii = [1, 2, 2] expected = [1, 2, 3] assert sort_circles_by_area(radii) == expected","solution":"def sort_circles_by_area(radii): Given a list of radii, returns the 1-based indices of the sorted radii based on the area of the circles. The sort should be stable in case of equal areas. areas = [(i, r**2) for i, r in enumerate(radii)] sorted_areas = sorted(areas, key=lambda x: x[1]) sorted_indices = [index + 1 for index, area in sorted_areas] return sorted_indices"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Returns True if the string s can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aab\\") True pass def process_queries(s: str, queries: List[int]) -> List[str]: Processes a list of queries on the string s and returns a list of answers (\\"Yes\\" or \\"No\\"). Queries: 1 means \\"Is the string a palindrome?\\", 2 means \\"Can the string be rearranged to form a palindrome?\\" >>> process_queries(\\"civic\\", [1, 2]) ['Yes', 'Yes'] >>> process_queries(\\"ivicc\\", [1, 2]) ['No', 'Yes'] >>> process_queries(\\"hello\\", [1, 2]) ['No', 'No'] >>> process_queries(\\"aab\\", [1, 2]) ['No', 'Yes'] >>> process_queries(\\"aba\\", [1]) ['Yes'] >>> process_queries(\\"abcd\\", [2]) ['No'] pass","solution":"def can_form_palindrome(s): Returns True if the string s can be rearranged to form a palindrome, False otherwise. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1 def process_queries(s, queries): Processes a list of queries on the string s and returns a list of answers (\\"Yes\\" or \\"No\\"). Queries: 1 means \\"Is the string a palindrome?\\", 2 means \\"Can the string be rearranged to form a palindrome?\\" results = [] for query in queries: if query == 1: # Is the string a palindrome? if s == s[::-1]: results.append(\\"Yes\\") else: results.append(\\"No\\") elif query == 2: # Can the string be rearranged to form a palindrome? if can_form_palindrome(s): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"from typing import List from math import gcd from functools import reduce def max_possible_gcd(n: int, arr: List[int]) -> int: Returns the maximum possible GCD of the remaining array elements after performing the given operations any number of times. >>> max_possible_gcd(6, [12, 15, 18, 21, 24, 27]) 3 >>> max_possible_gcd(1, [5]) 5 >>> max_possible_gcd(5, [7, 7, 7, 7, 7]) 7 >>> max_possible_gcd(4, [1, 1, 1, 1]) 1 >>> max_possible_gcd(3, [13, 17, 19]) 1 >>> max_possible_gcd(5, [2, 4, 6, 8, 10]) 2","solution":"from math import gcd from functools import reduce def max_possible_gcd(n, arr): Returns the maximum possible GCD of the remaining array elements after performing the given operations any number of times. array_gcd = reduce(gcd, arr) return array_gcd"},{"question":"def is_path_possible(n: int, grid: List[str]) -> str: Determines if there is a path from the top-left corner to the bottom-right corner in a given n x n grid. Parameters: n (int): The size of the grid. grid (list of str): The grid represented as a list of strings, where '.' denotes a free cell and '#' denotes a blocked cell. Returns: str: \\"YES\\" if there is a path, \\"NO\\" otherwise. from solution import is_path_possible def test_is_path_possible_path_exists(): n = 4 grid = [ \\"....\\", \\".#..\\", \\"..#.\\", \\"....\\" ] assert is_path_possible(n, grid) == \\"YES\\" def test_is_path_possible_no_path(): n = 4 grid = [ \\"....\\", \\"\\", \\"....\\", \\"....\\" ] assert is_path_possible(n, grid) == \\"NO\\" def test_is_path_possible_min_size(): n = 1 grid = [ \\".\\" ] assert is_path_possible(n, grid) == \\"YES\\" def test_is_path_possible_full_block(): n = 4 grid = [ \\"....\\", \\"\\", \\"\\", \\"....\\" ] assert is_path_possible(n, grid) == \\"NO\\" def test_is_path_possible_edge_path(): n = 3 grid = [ \\".#.\\", \\".#.\\", \\"...\\" ] assert is_path_possible(n, grid) == \\"YES\\" def test_is_path_possible_blocked_start(): n = 4 grid = [ \\"..#.\\", \\"\\", \\"....\\", \\"....\\" ] assert is_path_possible(n, grid) == \\"NO\\"","solution":"def is_path_possible(n, grid): Determines if there is a path from the top-left corner to the bottom-right corner in a given n x n grid. Parameters: n (int): The size of the grid. grid (list of str): The grid represented as a list of strings, where '.' denotes a free cell and '#' denotes a blocked cell. Returns: str: \\"YES\\" if there is a path, \\"NO\\" otherwise. if n == 1: return \\"YES\\" directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] visited = [[False] * n for _ in range(n)] queue = [(0, 0)] visited[0][0] = True while queue: i, j = queue.pop(0) if (i, j) == (n-1, n-1): return \\"YES\\" for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < n and not visited[ni][nj] and grid[ni][nj] == '.': visited[ni][nj] = True queue.append((ni, nj)) return \\"NO\\""},{"question":"def find_two_sum_indices(arr: List[int], target: int) -> Tuple[int, int]: Given an array of integers and a target integer, return the indices of two numbers that add up to the target. Parameters: arr (List[int]): List of integers. target (int): Target integer. Returns: Tuple[int, int]: A tuple of two indices if such a pair exists, otherwise an empty tuple. >>> find_two_sum_indices([2, 7, 11, 15], 9) (0, 1) >>> find_two_sum_indices([1, 2, 3, 4, 5], 10) ()","solution":"def find_two_sum_indices(arr, target): Given an array of integers and a target integer, return the indices of two numbers that add up to the target. Parameters: arr (list): List of integers. target (int): Target integer. Returns: tuple: A tuple of two indices if such a pair exists, otherwise an empty tuple. index_map = {} for idx, num in enumerate(arr): complement = target - num if complement in index_map: return (index_map[complement], idx) index_map[num] = idx return ()"},{"question":"def reorganize_string(s: str) -> str: Rearranges the given string such that no two adjacent characters are the same. If such a rearrangement is not possible, returns an empty string. >>> reorganize_string(\\"aaabc\\") in (\\"abaca\\", \\"bacaa\\") True >>> reorganize_string(\\"aabbcc\\") in (\\"abcabc\\", \\"acbacb\\", \\"bacbac\\", \\"bcbaba\\", \\"cacbab\\", \\"cbacba\\") True >>> reorganize_string(\\"aaab\\") \\"\\" >>> reorganize_string(\\"a\\") \\"a\\" >>> reorganize_string(\\"ab\\") \\"ab\\" or \\"ba\\" >>> reorganize_string(\\"aaa\\") \\"\\" >>> input_str = \\"a\\" * 5000 + \\"b\\" * 5000 >>> output = reorganize_string(input_str) >>> len(output) == 10000 and all(output[i] != output[i + 1] for i in range(9999)) True","solution":"from heapq import heappop, heappush from collections import Counter def reorganize_string(s): Rearranges the given string such that no two adjacent characters are the same. If such a rearrangement is not possible, returns an empty string. # Get the frequency of each character counter = Counter(s) # Create a max heap based on character frequency max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) # Since we used one instance of \`char\`, decrease its frequency if prev_char and prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # freq is negative # After reconstructing, if the length matches original, return the result if len(result) == len(s): return ''.join(result) else: return \\"\\""},{"question":"def classify_genre(training_data: str, unknown_book: str) -> int: Categorize the genre of an unknown book based on a provided training set. Args: training_data: A string containing the training data of books with genres. unknown_book: A string containing the content of the unknown book. Returns: An integer from 1 to 5 representing the predicted genre of the unknown book. >>> training_data = 3 ... 1 ... Mystery in the Woods ... It was a dark and stormy night... ... 2 ... Adventures of Tom ... Once upon a time, in a small village... ... 3 ... The Economics of 21st Century ... With the rise of globalization... >>> unknown_book = Fantastic Stories ... In a galaxy far, far away... >>> classify_genre(training_data, unknown_book) 1 # Your implementation here def main(training_data: str, unknown_book: str) -> int: Main function to be called with training data and unknown book's content. Args: training_data: A string containing the training data for books. unknown_book: A string containing the unknown book's content. Returns: An integer representing the genre of the unknown book. return classify_genre(training_data, unknown_book) # Unit tests def test_genre_classification(): training_data = 3 1 Mystery in the Woods It was a dark and stormy night... 2 Adventures of Tom Once upon a time, in a small village... 3 The Economics of 21st Century With the rise of globalization... unknown_book = Fantastic Stories In a galaxy far, far away... assert main(training_data, unknown_book) == 1 def test_genre_classification_edge_case(): training_data = 3 1 Mystery in the Woods It was a dark and stormy night... 2 Adventures of Tom Once upon a time, in a small village... 3 The Economics of 21st Century With the rise of globalization... unknown_book = Economics in Global World Globalization has changed the course... assert main(training_data, unknown_book) == 3","solution":"from collections import defaultdict import re from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.neighbors import KNeighborsClassifier def classify_genre(training_data, unknown_book_content): # Parse the training data genres = [] content = [] temp_content = '' for line in training_data: if line == '': continue # Genre if line.isdigit(): if temp_content: content[-1] += temp_content temp_content = '' genres.append(int(line)) content.append('') else: temp_content += line + ' ' # Don't forget to add the last content if temp_content: content[-1] += temp_content.strip() # Create a tf-idf vectorizer vectorizer = TfidfVectorizer(stop_words='english') X = vectorizer.fit_transform(content) y = genres # Train a k-neighbors classifier knn = KNeighborsClassifier(n_neighbors=3) knn.fit(X, y) # Vectorize the unknown book content unknown_vector = vectorizer.transform([unknown_book_content.strip()]) # Predict the genre predicted_genre = knn.predict(unknown_vector)[0] return predicted_genre def main(training_data, unknown_book): formatted_training_data = [item.strip() for item in training_data.split('n') if item.strip()] formatted_unknown_book = ' '.join([line.strip() for line in unknown_book.split('n') if line.strip()]) return classify_genre(formatted_training_data, formatted_unknown_book)"},{"question":"def count_posts_with_hashtags(posts: List[str], queries: List[str]) -> List[int]: Returns a list containing the number of posts that each query is found in at least once. >>> posts = [\\"#hello world this is a test\\", \\"this is a #sample post for testing\\", \\"another #hashtag to check\\"] >>> queries = [\\"#hello\\", \\"#hashtag\\"] >>> count_posts_with_hashtags(posts, queries) [1, 1] >>> posts = [\\"#hello world\\", \\"#hello\\", \\"world #hello\\"] >>> queries = [\\"#hello\\"] >>> count_posts_with_hashtags(posts, queries) [3] >>> posts = [\\"#sample post\\", \\"this is a sample post\\", \\"another post to check\\"] >>> queries = [\\"#hashtag\\"] >>> count_posts_with_hashtags(posts, queries) [0] >>> posts = [\\"\\"] >>> queries = [\\"#test\\"] >>> count_posts_with_hashtags(posts, queries) [0] >>> posts = [\\"#test post\\"] >>> queries = [\\"\\"] >>> count_posts_with_hashtags(posts, queries) [0] >>> posts = [\\"#test post #example\\", \\"another post\\", \\"example #test post\\"] >>> queries = [\\"#test\\", \\"#example\\"] >>> count_posts_with_hashtags(posts, queries) [2, 1] >>> posts = [\\"this is a post\\", \\"another post without hashtags\\"] >>> queries = [\\"#missing\\"] >>> count_posts_with_hashtags(posts, queries) [0]","solution":"def count_posts_with_hashtags(posts, queries): Returns a list containing the number of posts that each query is found in at least once. results = [] for query in queries: count = sum(1 for post in posts if query in post.split()) results.append(count) return results"},{"question":"def find_minimum_effort(n: int, m: int, connections: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the minimum effort required for the adventurer to travel from the entrance cave to the treasure cave. n: Number of caves (nodes) m: Number of paths (edges) connections: List of tuples where each tuple contains two caves and the effort required to travel between them queries: List of tuples, each containing two integers representing a query to determine the minimum effort from one cave to another Returns: A list of integers representing the minimum effort required for each query >>> find_minimum_effort(4, 4, [(1, 2, 3), (1, 3, 1), (2, 4, 4), (3, 4, 2)], [(1, 4), (3, 2)]) [3, 4] >>> find_minimum_effort(3, 2, [(1, 2, 1), (2, 3, 1)], [(1, 3)]) [2] >>> find_minimum_effort(2, 1, [(1, 2, 5)], [(1, 2)]) [5] >>> find_minimum_effort(4, 2, [(1, 2, 5), (3, 4, 6)], [(1, 4)]) [-1] >>> find_minimum_effort(5, 6, [(1, 2, 1), (1, 3, 5), (2, 3, 1), (2, 4, 2), (3, 5, 1), (4, 5, 1)], [(1, 5)]) [3]","solution":"import heapq def find_minimum_effort(n, m, connections, queries): def dijkstra(graph, start): effort = [float('inf')] * (n + 1) effort[start] = 0 priority_queue = [(0, start)] while priority_queue: current_effort, u = heapq.heappop(priority_queue) if current_effort > effort[u]: continue for v, w in graph[u]: if effort[u] + w < effort[v]: effort[v] = effort[u] + w heapq.heappush(priority_queue, (effort[v], v)) return effort # Create graph graph = [[] for _ in range(n + 1)] for u, v, w in connections: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for s, t in queries: effort = dijkstra(graph, s) results.append(effort[t] if effort[t] != float('inf') else -1) return results"},{"question":"import requests def fetch_users(url): Fetches the list of users from the given URL. Args: - url (str): The URL to fetch the users from. Returns: - list: A list of user dictionaries if the request is successful. - None: If the request fails. pass def get_user_profile(user_id, url_template): Fetches the profile of a user by their user_id. Args: - user_id (int): The user ID. - url_template (str): The URL template with a placeholder for user ID. Returns: - dict: A dictionary of user profile details if successful. - None: If the request fails. pass from pytest import fixture @fixture def mocked_users_response(monkeypatch): Fixture to mock the response of the fetch_users function. def mock_get(*args, **kwargs): response = requests.Response() response.status_code = 200 response._content = b'[{\\"id\\": 1, \\"name\\": \\"Leanne Graham\\", \\"email\\": \\"Sincere@april.biz\\"}]' return response monkeypatch.setattr(requests, \\"get\\", mock_get) @fixture def mocked_user_profile_response(monkeypatch): Fixture to mock the response of the get_user_profile function. def mock_get(*args, **kwargs): response = requests.Response() response.status_code = 200 response._content = b'{\\"id\\": 1, \\"name\\": \\"Leanne Graham\\", \\"username\\": \\"Bret\\", \\"email\\": \\"Sincere@april.biz\\", \\"address\\": {\\"street\\": \\"Kulas Light\\", \\"suite\\": \\"Apt. 556\\", \\"city\\": \\"Gwenborough\\", \\"zipcode\\": \\"92998-3874\\"}, \\"phone\\": \\"1-770-736-8031 x56442\\", \\"website\\": \\"hildegard.org\\", \\"company\\": {\\"name\\": \\"Romaguera-Crona\\", \\"catchPhrase\\": \\"Multi-layered client-server neural-net\\", \\"bs\\": \\"harness real-time e-markets\\"}}' return response monkeypatch.setattr(requests, \\"get\\", mock_get) def test_fetch_users_success(mocked_users_response): url = \\"https://jsonplaceholder.typicode.com/users\\" users = fetch_users(url) assert users is not None assert isinstance(users, list) assert len(users) == 1 assert users[0][\\"name\\"] == \\"Leanne Graham\\" def test_fetch_users_failure(monkeypatch): def mock_get(*args, **kwargs): raise requests.RequestException(\\"Failed to fetch\\") monkeypatch.setattr(requests, \\"get\\", mock_get) url = \\"https://jsonplaceholder.typicode.com/users\\" users = fetch_users(url) assert users is None def test_get_user_profile_success(mocked_user_profile_response): url_template = \\"https://jsonplaceholder.typicode.com/users/{}\\" user_id = 1 user_profile = get_user_profile(user_id, url_template) assert user_profile is not None assert isinstance(user_profile, dict) assert user_profile[\\"name\\"] == \\"Leanne Graham\\" def test_get_user_profile_failure(monkeypatch): def mock_get(*args, **kwargs): raise requests.RequestException(\\"Failed to fetch\\") monkeypatch.setattr(requests, \\"get\\", mock_get) url_template = \\"https://jsonplaceholder.typicode.com/users/{}\\" user_id = 1 user_profile = get_user_profile(user_id, url_template) assert user_profile is None","solution":"import requests def fetch_users(url): Fetches the list of users from the given URL. Args: - url (str): The URL to fetch the users from. Returns: - list: A list of user dictionaries if the request is successful. - None: If the request fails. try: response = requests.get(url) response.raise_for_status() # Raise an exception for HTTP errors return response.json() except requests.RequestException as e: print(f\\"Error fetching users: {e}\\") return None def get_user_profile(user_id, url_template): Fetches the profile of a user by their user_id. Args: - user_id (int): The user ID. - url_template (str): The URL template with a placeholder for user ID. Returns: - dict: A dictionary of user profile details if successful. - None: If the request fails. try: url = url_template.format(user_id) response = requests.get(url) response.raise_for_status() # Raise an exception for HTTP errors return response.json() except requests.RequestException as e: print(f\\"Error fetching user profile: {e}\\") return None"},{"question":"MOD = 10**9 + 7 def factorial_mod(n, mod): Compute n! % mod using iterative approach. result = 1 for i in range(1, n + 1): result = (result * i) % mod return result def number_of_transformation_plans(k, p, districts): Given the number of districts and species and their distributions in districts, return the number of valid transformation plans. Args: k: An integer representing the number of districts. p: An integer representing the number of species. districts: A list of lists where each sublist represents the species distribution in a district. Returns: An integer representing the number of valid transformation plans modulo 10^9 + 7. Example: >>> k, p = 3, 3 >>> districts = [ ... [5, 1, 2, 3, 2, 1], ... [4, 2, 3, 2, 3], ... [3, 1, 1, 1] ... ] >>> number_of_transformation_plans(k, p, districts) 6 pass # Example Unit Tests def test_number_of_transformation_plans_example(): k, p = 3, 3 districts = [ [5, 1, 2, 3, 2, 1], [4, 2, 3, 2, 3], [3, 1, 1, 1] ] assert number_of_transformation_plans(k, p, districts) == 6 def test_number_of_transformation_plans_single_species(): k, p = 2, 1 districts = [ [3, 1, 1, 1], [2, 1, 1] ] assert number_of_transformation_plans(k, p, districts) == 1 def test_number_of_transformation_plans_large_p(): k, p = 2, 5 districts = [ [2, 1, 1], [3, 2, 2, 2] ] expected = 120 # 5! = 120 assert number_of_transformation_plans(k, p, districts) == expected def test_number_of_transformation_plans_modulo(): k, p = 2, 1000 districts = [ [1] * 100, [2] * 50 + [3] * 50 ] # Since 1000! is very large, we don't compute it directly in tests. # We simply check the function runs and returns a number. result = number_of_transformation_plans(k, p, districts) assert result > 0","solution":"MOD = 10**9 + 7 def factorial_mod(n, mod): Compute n! % mod using iterative approach. result = 1 for i in range(1, n + 1): result = (result * i) % mod return result def number_of_transformation_plans(k, p, districts): Given the number of districts and species and their distributions in districts, return the number of valid transformation plans. # The number of valid transformation plans is p! return factorial_mod(p, MOD)"},{"question":"def exercise_groups(J: int, L: int, S: int) -> Tuple[int, int]: Determines the maximum number of exercise groups that can be formed and the number of leftover people. Parameters: J (int): Number of people available for jumping jacks. L (int): Number of people available for lunges. S (int): Number of people available for squats. Returns: (tuple): A tuple containing two integers: - The maximum number of groups that can be formed. - The number of people left without a group. >>> exercise_groups(9, 6, 8) (6, 5) >>> exercise_groups(1, 1, 1) (1, 0) >>> exercise_groups(10**14, 10**14, 10**14) (10**14, 0) >>> exercise_groups(7, 10, 5) (5, 7) >>> exercise_groups(5, 5, 5) (5, 0) >>> exercise_groups(3, 3, 4) (3, 1) >>> exercise_groups(4, 3, 3) (3, 1) >>> exercise_groups(3, 4, 3) (3, 1) >>> exercise_groups(10**14, 10**14, 2*10**14 - 1) (10**14, 10**14 - 1)","solution":"def exercise_groups(J, L, S): Determines the maximum number of exercise groups that can be formed and the number of leftover people. Parameters: J (int): Number of people available for jumping jacks. L (int): Number of people available for lunges. S (int): Number of people available for squats. Returns: (tuple): A tuple containing two integers: - The maximum number of groups that can be formed. - The number of people left without a group. # Maximum number of groups is determined by the minimum of J, L, and S max_groups = min(J, L, S) # Calculate the leftover people after forming the groups leftover = (J - max_groups) + (L - max_groups) + (S - max_groups) return max_groups, leftover"},{"question":"from typing import Dict, List, Tuple def sort_students_by_score(students: Dict[str, int]) -> List[Tuple[str, int]]: Sorts students based on their scores in descending order. If two students have the same score, they are sorted alphabetically by their names. :param students: Dictionary where keys are student names and values are their scores :return: List of tuples with student names and their scores sorted as described above >>> students = { ... \\"Alice\\": 85, ... \\"Bob\\": 70, ... \\"Charlie\\": 85, ... \\"Dave\\": 70, ... \\"Eve\\": 95 ... } >>> sort_students_by_score(students) [('Eve', 95), ('Alice', 85), ('Charlie', 85), ('Bob', 70), ('Dave', 70)] >>> students = { ... \\"Alice\\": 85 ... } >>> sort_students_by_score(students) [('Alice', 85)] >>> students = { ... \\"Charlie\\": 80, ... \\"Alice\\": 80, ... \\"Bob\\": 80 ... } >>> sort_students_by_score(students) [('Alice', 80), ('Bob', 80), ('Charlie', 80)] >>> students = { ... \\"Alice\\": 90, ... \\"Bob\\": 80, ... \\"Charlie\\": 70 ... } >>> sort_students_by_score(students) [('Alice', 90), ('Bob', 80), ('Charlie', 70)] >>> students = { ... \\"Alice\\": 80, ... \\"Bob\\": 95, ... \\"Charlie\\": 80, ... \\"Dave\\": 85 ... } >>> sort_students_by_score(students) [('Bob', 95), ('Dave', 85), ('Alice', 80), ('Charlie', 80)]","solution":"from typing import Dict, List, Tuple def sort_students_by_score(students: Dict[str, int]) -> List[Tuple[str, int]]: Sorts students based on their scores in descending order. If two students have the same score, they are sorted alphabetically by their names. :param students: Dictionary where keys are student names and values are their scores :return: List of tuples with student names and their scores sorted as described above # Sort the dictionary items first by score in descending order, then by name in ascending order sorted_students = sorted(students.items(), key=lambda x: (-x[1], x[0])) return sorted_students"},{"question":"def min_operations_to_same_char(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Returns a list of minimum operations required for each test case to make all characters in string the same. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer n and a string s. Returns: List[int]: A list of minimum operations required for each test case. >>> min_operations_to_same_char(1, [(1, 'a')]) [0] >>> min_operations_to_same_char(1, [(3, 'aaa')]) [0] >>> min_operations_to_same_char(1, [(3, 'abc')]) [2] >>> min_operations_to_same_char(2, [(1, 'a'), (2, 'ab')]) [0, 1] >>> min_operations_to_same_char(1, [(6, 'ababab')]) [3] >>> test_cases = [(3, 'abc'), (4, 'aabb'), (6, 'abacbc')] >>> expected = [2, 2, 4] >>> min_operations_to_same_char(3, test_cases) expected >>> test_cases = [(3, 'abc') for _ in range(5000)] >>> expected = [2] * 5000 >>> min_operations_to_same_char(5000, test_cases) expected","solution":"def min_operations_to_same_char(t, test_cases): Returns a list of minimum operations required for each test case to make all characters in string the same. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer n and a string s. Returns: List[int]: A list of minimum operations required for each test case. import collections results = [] for n, s in test_cases: char_count = collections.Counter(s) max_freq = max(char_count.values()) min_operations = n - max_freq results.append(min_operations) return results"},{"question":"def can_reduce_to_empty(t: int, strings: List[str]) -> List[str]: Determine if it's possible to make the given strings empty by repeatedly removing substrings of consecutive same characters. Parameters: t (int): number of test cases strings (list of str): list of strings to check Returns: list of str: list containing \\"YES\\" or \\"NO\\" for each test case >>> can_reduce_to_empty(3, [\\"aaabb\\", \\"aaaaa\\", \\"abab\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_reduce_to_empty(1, [\\"a\\"]) [\\"YES\\"] from typing import List def test_can_reduce_to_empty(): assert can_reduce_to_empty(3, [\\"aaabb\\", \\"aaaaa\\", \\"abab\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\"] assert can_reduce_to_empty(1, [\\"a\\"]) == [\\"YES\\"] assert can_reduce_to_empty(2, [\\"abc\\", \\"aabbcc\\"]) == [\\"YES\\", \\"YES\\"] assert can_reduce_to_empty(2, [\\"aa\\", \\"bb\\"]) == [\\"YES\\", \\"YES\\"] assert can_reduce_to_empty(2, [\\"abcabc\\", \\"abccba\\"]) == [\\"YES\\", \\"YES\\"]","solution":"def can_reduce_to_empty(t, strings): This function determines if it's possible to make the given strings empty by repeatedly removing substrings of consecutive same characters. Parameters: t (int): number of test cases strings (list of str): list of strings to check Returns: list of str: list containing \\"YES\\" or \\"NO\\" for each test case results = [] for s in strings: results.append(\\"YES\\") return results"},{"question":"def max_total_yield(n: int, m: int, k: int, yields: List[int]) -> int: Returns the maximum possible total yield for the entire field. :param n: Number of rows in the 2D grid :param m: Number of columns in the 2D grid :param k: Number of different crop types :param yields: List of yield values of the crop types :return: Maximum possible total yield >>> max_total_yield(3, 3, 3, [4, 2, 7]) 63 >>> max_total_yield(2, 2, 1, [5]) 20 >>> max_total_yield(4, 4, 4, [2, 7, 7, 4]) 112 >>> max_total_yield(2, 5, 3, [3, 8, 1]) 80 >>> max_total_yield(1, 1, 1, [1]) 1 >>> max_total_yield(100, 100, 100, [i for i in range(1, 101)]) 1000000","solution":"def max_total_yield(n, m, k, yields): Returns the maximum possible total yield for the entire field. :param n: Number of rows in the 2D grid :param m: Number of columns in the 2D grid :param k: Number of different crop types :param yields: List of yield values of the crop types :return: Maximum possible total yield max_yield = max(yields) # Find the highest yield value total_yield = n * m * max_yield # Calculate the total yield by planting the highest yield crop in every cell return total_yield"},{"question":"from typing import List, Tuple, Union def process_minerals(n: int, minerals: List[Tuple[int, int]], k: int, operations: List[Tuple[int, Union[int, Tuple[int, int]]]]) -> List[Union[List[int], str]]: Process minerals and maintain clusters based on their weights. Args: n : int : Number of initial minerals. minerals : List[Tuple[int, int]] : List of tuples containing mineral id and weight. k : int : Number of operations. operations : List[Tuple[int, Union[int, Tuple[int, int]]]] : List of operations to be performed. Returns: List[Union[List[int], str]] : List containing the results of cluster finding operations. Example: >>> n = 4 >>> minerals = [(1, 2), (2, 3), (3, 2), (4, 1)] >>> k = 5 >>> operations = [(2, 1), (1, 5, 3), (2, 5), (2, 4), (2, 20)] >>> process_minerals(n, minerals, k, operations) == [[1, 3], [2, 5], [4], \\"Mineral not found\\"]","solution":"def process_minerals(n, minerals, k, operations): from collections import defaultdict # Store minerals by id and clusters by weight mineral_dict = {} clusters = defaultdict(list) # Initialize minerals and their clusters for mineral in minerals: mineral_id, weight = mineral mineral_dict[mineral_id] = weight clusters[weight].append(mineral_id) # Helper function to find cluster for a given mineral_id def find_cluster(mineral_id): if mineral_id in mineral_dict: weight = mineral_dict[mineral_id] return sorted(clusters[weight]) else: return \\"Mineral not found\\" results = [] # Process operations for op in operations: if op[0] == 1: # Add a new mineral _, mineral_id, weight = op mineral_dict[mineral_id] = weight clusters[weight].append(mineral_id) elif op[0] == 2: # Find cluster _, mineral_id = op results.append(find_cluster(mineral_id)) return results"},{"question":"def is_valid_chain(n: int, arrangement: List[int]) -> str: Check if the arrangement is a valid chain. >>> is_valid_chain(4, [1, 2, 3, 4]) \\"YES\\" >>> is_valid_chain(4, [4, 3, 2, 1]) \\"YES\\" >>> is_valid_chain(5, [1, 3, 2, 4, 5]) \\"NO\\" ... def check_arrangements(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if each arrangement in the test cases list is a valid chain. >>> check_arrangements([(4, [1, 2, 3, 4]), (4, [4, 3, 2, 1]), (5, [1, 3, 2, 4, 5])]) [\\"YES\\", \\"YES\\", \\"NO\\"] ...","solution":"def is_valid_chain(n, arrangement): Check if the arrangement is a valid chain. for i in range(1, n): if abs(arrangement[i] - arrangement[i-1]) != 1: return \\"NO\\" return \\"YES\\" def check_arrangements(test_cases): results = [] for n, arrangement in test_cases: result = is_valid_chain(n, arrangement) results.append(result) return results"},{"question":"def multiply_strings(num1: str, num2: str) -> str: Returns the product of two non-negative integers represented as strings. >>> multiply_strings(\\"2\\", \\"3\\") \\"6\\" >>> multiply_strings(\\"0\\", \\"12345\\") \\"0\\" >>> multiply_strings(\\"12345\\", \\"0\\") \\"0\\" >>> multiply_strings(\\"9\\", \\"9\\") \\"81\\" >>> multiply_strings(\\"123\\", \\"4567\\") \\"561741\\" >>> multiply_strings(\\"123456789\\", \\"987654321\\") \\"121932631112635269\\" >>> multiply_strings(\\"1234\\", \\"5678\\") \\"7006652\\"","solution":"def multiply_strings(num1, num2): Returns the product of two non-negative integers represented as strings. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" result = [0] * (len(num1) + len(num2)) num1 = num1[::-1] num2 = num2[::-1] for i in range(len(num1)): for j in range(len(num2)): product = int(num1[i]) * int(num2[j]) result[i + j] += product result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 while result[-1] == 0: result.pop() return ''.join(map(str, result[::-1]))"},{"question":"import heapq from typing import List def merge_k_sorted_lists(lists: List[List[int]]) -> List[int]: Merges k sorted integer lists into a single sorted list. Args: lists (List[List[int]]): A list of k sorted integer lists. Returns: List[int]: A single sorted list containing all elements from input lists. Examples: >>> merge_k_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_k_sorted_lists([[], [], []]) [] >>> merge_k_sorted_lists([[1, 2, 3]]) [1, 2, 3] >>> merge_k_sorted_lists([[], [1, 2, 3]]) [1, 2, 3] >>> merge_k_sorted_lists([[1000, 1001, 1002], [2000, 2001, 2002], [3000, 3001, 3002]]) [1000, 1001, 1002, 2000, 2001, 2002, 3000, 3001, 3002]","solution":"import heapq def merge_k_sorted_lists(lists): Merges k sorted integer lists into a single sorted list. Args: lists (List[List[int]]): A list of k sorted integer lists. Returns: List[int]: A single sorted list containing all elements from input lists. min_heap = [] for index, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst[0], index, 0)) result = [] while min_heap: val, list_index, element_index = heapq.heappop(min_heap) result.append(val) if element_index + 1 < len(lists[list_index]): heapq.heappush(min_heap, (lists[list_index][element_index + 1], list_index, element_index + 1)) return result"},{"question":"def max_total_price(n: int, k: int, prices: List[int]) -> int: Returns the maximum total price achievable by selecting at most k items from the prices array. Parameters: n (int): The number of items. k (int): The maximum number of items that can be bought. prices (list): The list of prices of the items. Returns: int: The maximum total price. pass def test_max_total_price_example(): assert max_total_price(5, 3, [8, 2, 9, 1, 4]) == 21 def test_max_total_price_all_items(): assert max_total_price(5, 5, [8, 2, 9, 1, 4]) == 24 def test_max_total_price_k_greater_than_n(): assert max_total_price(3, 5, [7, 5, 3]) == 15 def test_max_total_price_large_k_small_array(): assert max_total_price(4, 2, [10, 20, 30, 40]) == 70 def test_max_total_price_all_ones(): assert max_total_price(5, 3, [1, 1, 1, 1, 1]) == 3 def test_max_total_price_single_item(): assert max_total_price(1, 1, [100]) == 100 def test_max_total_price_multiple_high_values(): assert max_total_price(6, 2, [5, 10, 15, 20, 25, 30]) == 55 def test_max_total_price_large_numbers(): assert max_total_price(3, 2, [1000000000, 999999999, 999999998]) == 1999999999","solution":"def max_total_price(n, k, prices): Returns the maximum total price achievable by selecting at most k items from the prices array. Parameters: n (int): The number of items. k (int): The maximum number of items that can be bought. prices (list): The list of prices of the items. Returns: int: The maximum total price. # Sort the prices array in descending order sorted_prices = sorted(prices, reverse=True) # Take the first k items from the sorted_prices array (or all if n < k) max_prices = sorted_prices[:k] # Return the sum of these selected prices return sum(max_prices)"},{"question":"def max_movies_to_watch(movie_durations, available_time): Returns the maximum number of movies Xania can watch in one day without exceeding the available time. :param movie_durations: List of integers representing the duration of each movie in minutes. :param available_time: Integer representing the total available time in minutes. :return: Integer representing the maximum number of movies that can be watched. >>> max_movies_to_watch([90, 85, 75, 60, 120], 180) 2 >>> max_movies_to_watch([30, 40, 50], 200) 3 >>> max_movies_to_watch([150, 160, 170], 100) 0 >>> max_movies_to_watch([100], 100) 1 >>> max_movies_to_watch([100], 90) 0 >>> max_movies_to_watch([100, 100, 100], 200) 2 >>> max_movies_to_watch([100, 100, 100], 100) 1","solution":"def max_movies_to_watch(movie_durations, available_time): Returns the maximum number of movies Xania can watch in one day without exceeding the available time. :param movie_durations: List of integers representing the duration of each movie in minutes. :param available_time: Integer representing the total available time in minutes. :return: Integer representing the maximum number of movies that can be watched. movie_durations.sort() total_time = 0 movie_count = 0 for duration in movie_durations: if total_time + duration <= available_time: total_time += duration movie_count += 1 else: break return movie_count"},{"question":"from math import sqrt import heapq def euclidean_distance(x1, y1, x2, y2): Calculate the Euclidean distance between two points (x1, y1) and (x2, y2). return sqrt((x2 - x1)**2 + (y1 - y2)**2) def minimum_travel_cost(n, m, coordinates, edges, s, t): Determine the minimum travel cost for a vehicle considering it can switch to aerial mode at any point. Parameters: n (int): The number of vertices. m (int): The number of edges. coordinates (List[Tuple[int, int]]): The coordinates of each vertex. edges (List[Tuple[int, int, int]]): The edges with weights. s (int): The source vertex. t (int): The target vertex. Returns: int: The minimum travel cost from source to target. # Your code here def main(input_data: str) -> int: Parse input data and calculate minimum travel cost. Parameters: input_data (str): The input data as a string. Returns: int: The minimum travel cost. lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) coordinates = [] for i in range(1, n+1): coordinates.append(tuple(map(int, lines[i].split()))) edges = [] for i in range(n+1, n+m+1): edges.append(tuple(map(int, lines[i].split()))) s, t = map(int, lines[n+m+1].split()) return minimum_travel_cost(n, m, coordinates, edges, s, t)","solution":"import heapq from math import sqrt def euclidean_distance(x1, y1, x2, y2): return sqrt((x2 - x1)**2 + (y2 - y1)**2) def minimum_travel_cost(n, m, coordinates, edges, s, t): graph = {i: [] for i in range(n)} for u, v, w in edges: graph[u-1].append((v-1, w)) graph[v-1].append((u-1, w)) pq = [(0, s-1)] dist = [float('inf')] * n dist[s-1] = 0 while pq: current_distance, u = heapq.heappop(pq) if current_distance > dist[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) min_cost = dist[t-1] s_x, s_y = coordinates[s-1] t_x, t_y = coordinates[t-1] for i in range(n): if dist[i] != float('inf'): i_x, i_y = coordinates[i] aerial_cost = dist[i] + euclidean_distance(i_x, i_y, t_x, t_y) min_cost = min(min_cost, aerial_cost) return int(min_cost) def main(input_data): lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) coordinates = [] for i in range(1, n+1): coordinates.append(tuple(map(int, lines[i].split()))) edges = [] for i in range(n+1, n+m+1): edges.append(tuple(map(int, lines[i].split()))) s, t = map(int, lines[n+m+1].split()) return minimum_travel_cost(n, m, coordinates, edges, s, t)"},{"question":"def smallest_missing_positive_key(n: int, keys: List[int]) -> int: Returns the smallest positive integer that is not used as a primary key. Parameters: n (int): The number of existing records. keys (list of int): The primary keys of existing records. Returns: int: The smallest positive integer not in keys. >>> smallest_missing_positive_key(4, [3, 1, 2, 6]) 4 >>> smallest_missing_positive_key(5, [1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive_key(1, [1]) 2 >>> smallest_missing_positive_key(3, [7, 8, 9]) 1 >>> smallest_missing_positive_key(6, [2, 3, 4, 5, 6, 7]) 1 >>> smallest_missing_positive_key(10, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 11 >>> smallest_missing_positive_key(0, []) 1 >>> smallest_missing_positive_key(5, [5, 8, 1, 10, 7]) 2 pass # Write your code here","solution":"def smallest_missing_positive_key(n, keys): Returns the smallest positive integer that is not used as a primary key. Parameters: n (int): The number of existing records. keys (list of int): The primary keys of existing records. Returns: int: The smallest positive integer not in keys. keys_set = set(keys) smallest_missing = 1 while smallest_missing in keys_set: smallest_missing += 1 return smallest_missing # Example usage: # n = 4 # keys = [3, 1, 2, 6] # print(smallest_missing_positive_key(n, keys)) # Output: 4"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def bfs_find_farthest_node(start, adj): visited = set() queue = deque([(start, 0)]) # (node, distance) visited.add(start) farthest_node = start max_distance = 0 while queue: node, dist = queue.popleft() if dist > max_distance: max_distance = dist farthest_node = node for neighbor in adj[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return farthest_node, max_distance def find_tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Find the diameter of an undirected tree represented by an adjacency list. Args: n (int): The number of nodes in the tree. edges (List[Tuple[int, int]]): The list of edges in the tree. Returns: int: The diameter of the tree. Example: >>> find_tree_diameter(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> find_tree_diameter(2, [(1, 2)]) 1","solution":"from collections import deque, defaultdict def bfs_find_farthest_node(start, adj): visited = set() queue = deque([(start, 0)]) # (node, distance) visited.add(start) farthest_node = start max_distance = 0 while queue: node, dist = queue.popleft() if dist > max_distance: max_distance = dist farthest_node = node for neighbor in adj[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return farthest_node, max_distance def find_tree_diameter(n, edges): # Create the adjacency list adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # Step 1: Perform BFS from any node (let's choose node 1) farthest_node, _ = bfs_find_farthest_node(1, adj) # Step 2: Perform BFS from the farthest node found in step 1 _, diameter = bfs_find_farthest_node(farthest_node, adj) return diameter"},{"question":"def organize_books(n: int, k: int, genres: List[str]) -> List[List[int]]: Organizes books into k groups such that the number of distinct genres within each group is maximized. Parameters: n (int): Number of books k (int): Number of groups genres (list): List of genres for the books (length is n) Returns: list: A list of k lists, each containing book indices organized into groups >>> organize_books(6, 2, [\\"Fantasy\\", \\"Mystery\\", \\"Fantasy\\", \\"Science\\", \\"Mystery\\", \\"Science\\"]) [[0, 1, 3], [2, 4, 5]] >>> organize_books(8, 4, [\\"Fantasy\\", \\"Mystery\\", \\"Science\\", \\"Fantasy\\", \\"Mystery\\", \\"Science\\", \\"Fantasy\\", \\"Science\\"]) [[0, 1], [2, 3], [4, 5], [6, 7]]","solution":"import itertools from collections import defaultdict def organize_books(n, k, genres): Organizes books into k groups such that the number of distinct genres within each group is maximized. Parameters: n (int): Number of books k (int): Number of groups genres (list): List of genres for the books (length is n) Returns: list: A list of k lists, each containing book indices organized into groups genre_to_books = defaultdict(list) for idx, genre in enumerate(genres): genre_to_books[genre].append(idx) # Create the solution groups groups = [[] for _ in range(k)] sorted_genres = sorted(genre_to_books.items(), key=lambda x: len(x[1]), reverse=True) book_count_per_group = n // k additional_books = n % k index_per_group = [book_count_per_group] * k for i in range(additional_books): index_per_group[i] += 1 # Fill the groups with the largest number of distinct genres book_index = 0 for genre, book_ids in sorted_genres: for book_id in book_ids: if index_per_group[book_index] > 0: groups[book_index].append(book_id) index_per_group[book_index] -= 1 book_index = (book_index + 1) % k return groups"},{"question":"from typing import List, Tuple def express_bus_routes(n: int, m: int, routes: List[Tuple[int, int, int]]) -> List[int]: Determine the shortest possible time it takes for an express bus to travel from the central station (intersection 1) to each of the other intersections. Parameters: n (int): Number of intersections. m (int): Number of bus routes. routes (List[Tuple[int, int, int]]): Each tuple represents a bus route from intersection u to intersection v with travel time t. Returns: List[int]: Shortest travel time from the central station to each intersection. If an intersection is unreachable, the corresponding entry should be -1. Example: >>> express_bus_routes(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7), (2, 5, 3), (4, 5, 1)]) [0, 4, 2, 9, 7] >>> express_bus_routes(4, 4, [(1, 2, 5), (2, 3, 10), (3, 4, 2), (1, 4, 100)]) [0, 5, 15, 17]","solution":"import heapq import sys from collections import defaultdict def dijkstra(n, edges): graph = defaultdict(list) for u, v, t in edges: graph[u].append((v, t)) distances = [float('inf')] * (n + 1) distances[1] = 0 priority_queue = [(0, 1)] # (distance to node, node) while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(1, n+1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result def express_bus_routes(n, m, routes): return dijkstra(n, routes)"},{"question":"def maximal_rectangle(matrix: List[List[int]]) -> int: Given a matrix of size n x m filled with non-negative integers, find the largest rectangle containing only zeros and return its area. >>> maximal_rectangle([[1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 1, 0], [1, 0, 0, 0]]) == 4 >>> maximal_rectangle([[0]]) == 1 >>> maximal_rectangle([[1]]) == 0 >>> maximal_rectangle([[0, 0], [0, 0]]) == 4 >>> maximal_rectangle([[0, 1], [1, 0]]) == 1 >>> maximal_rectangle([[0]*1000]*1000) == 1000000 >>> maximal_rectangle([]) == 0 >>> maximal_rectangle([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0","solution":"def maximal_rectangle(matrix): if not matrix: return 0 n, m = len(matrix), len(matrix[0]) max_area = 0 dp = [0] * m for i in range(n): for j in range(m): dp[j] = dp[j] + 1 if matrix[i][j] == 0 else 0 max_area = max(max_area, largest_rectangle_area(dp)) return max_area def largest_rectangle_area(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[stack[-1]] > heights[i]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"def min_weight_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Calculate the minimum weight of a path that connects two given nodes s and t in an undirected graph. >>> min_weight_path(6, 7, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 6, 1), (5, 6, 5)], 1, 6) 10 >>> min_weight_path(4, 2, [(1, 2, 1), (3, 4, 1)], 1, 4) -1 >>> min_weight_path(2, 1, [(1, 2, 3)], 1, 2) 3 >>> min_weight_path(5, 6, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 5, 2), (1, 3, 2), (3, 5, 4)], 1, 5) 5 >>> min_weight_path(3, 3, [(1, 2, 2), (2, 3, 3), (3, 1, 1)], 1, 3) 1","solution":"import heapq def dijkstra(n, edges, start, end): graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) pq = [(0, start)] distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) if current_node == end: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[end] if distances[end] != float('inf') else -1 def min_weight_path(n, m, edges, s, t): return dijkstra(n, edges, s, t)"},{"question":"def exists_valid_rectangle(n: int, m: int, grid: List[str]) -> str: Determine if there exists at least one valid rectangle in the grid. >>> exists_valid_rectangle(5, 7, [ ... \\"#\\", ... \\"#.....#\\", ... \\"#.....#\\", ... \\"#.....#\\", ... \\"#\\", ... ]) \\"YES\\" >>> exists_valid_rectangle(4, 4, [ ... \\"\\", ... \\"#..#\\", ... \\".#\\", ... \\"\\" ... ]) \\"NO\\"","solution":"def is_valid_rectangle(grid, n, m): Returns True if there is at least one valid rectangle in the grid; otherwise, returns False. for top in range(n): for left in range(m): if grid[top][left] == '#': for bottom in range(top + 2, n): for right in range(left + 2, m): if grid[bottom][right] == '#': if all(grid[top][k] == '#' for k in range(left, right + 1)) and all(grid[bottom][k] == '#' for k in range(left, right + 1)) and all(grid[i][left] == '#' for i in range(top, bottom + 1)) and all(grid[i][right] == '#' for i in range(top, bottom + 1)): if all(grid[i][j] == '.' for i in range(top + 1, bottom) for j in range(left + 1, right)): return True return False def exists_valid_rectangle(n, m, grid): if is_valid_rectangle(grid, n, m): return \\"YES\\" else: return \\"NO\\""},{"question":"def min_height_difference(heights: List[int]) -> int: Calculate the minimum possible difference between the height of the tallest remaining tree and the shortest remaining tree after cutting down some trees. >>> min_height_difference([3, 1, 4, 7, 2]) 1 >>> min_height_difference([1, 3, 5, 7]) 2 >>> min_height_difference([8, 3]) 5 >>> min_height_difference([2, 2, 2, 2]) 0 >>> min_height_difference([1000, 1]) 999 >>> min_height_difference([5, 5, 5, 7]) 0 >>> min_height_difference([1, 2, 5, 9, 3]) 1 >>> min_height_difference([10, 9, 8, 7, 6]) 1","solution":"def min_height_difference(heights): Calculate the minimum possible difference between the height of the tallest remaining tree and the shortest remaining tree after cutting down some trees. :param heights: List of integers representing tree heights. :return: Minimum possible difference between the tallest and shortest remaining tree. heights.sort() min_diff = float('inf') for i in range(1, len(heights)): min_diff = min(min_diff, heights[i] - heights[i - 1]) return min_diff"},{"question":"def subarray_sum_equal(arr: List[int], queries: List[Tuple[int, int, int]]) -> List[str]: Determine if the sum of a specified subarray equals a given value for each query. Arguments: arr : list of int - List of integers representing the array. queries : list of tuples - List of tuples where each tuple contains three integers (l, r, k). Returns: list of str - List containing \\"Yes\\" or \\"No\\" for each query. >>> subarray_sum_equal([1, 2, 3, 4, 5], [(1, 3, 6), (2, 5, 14), (1, 5, 15)]) ['Yes', 'Yes', 'No'] >>> subarray_sum_equal([1, 2, 3, 4, 5], [(1, 3, 5), (2, 5, 13), (1, 5, 10)]) ['No', 'No', 'No'] pass","solution":"def subarray_sum_equal(arr, queries): Determine if the sum of a specified subarray equals a given value for each query. Arguments: arr : list of int - List of integers representing the array. queries : list of tuples - List of tuples where each tuple contains three integers (l, r, k). Returns: list of str - List containing \\"Yes\\" or \\"No\\" for each query. # Precompute prefix sums n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] results = [] for l, r, k in queries: # Sum of subarray arr[l-1] to arr[r-1] subarray_sum = prefix_sums[r] - prefix_sums[l - 1] # Check if the sum equals k if subarray_sum == k: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def can_transform(s: str, t: str) -> bool: Determines if binary string s can be transformed into binary string t by reversing any non-empty substrings any number of times. >>> can_transform(\\"1010\\", \\"1010\\") True >>> can_transform(\\"1100\\", \\"0011\\") True >>> can_transform(\\"1100\\", \\"1000\\") False >>> can_transform(\\"1\\", \\"1\\") True >>> can_transform(\\"0\\", \\"0\\") True >>> can_transform(\\"1\\", \\"0\\") False >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"1111\\", \\"0000\\") False","solution":"def can_transform(s, t): Determines if binary string s can be transformed into binary string t by reversing any non-empty substrings any number of times. return sorted(s) == sorted(t)"},{"question":"def min_changes_to_avoid_adjacent_duplicates(n: int, s: str) -> int: Returns the minimum number of changes needed to ensure no two adjacent birds belong to the same species. :param n: Length of the observation string :param s: Observation string of bird species :return: Minimum number of changes required Example: >>> min_changes_to_avoid_adjacent_duplicates(4, \\"aabb\\") 2 >>> min_changes_to_avoid_adjacent_duplicates(5, \\"abcde\\") 0","solution":"def min_changes_to_avoid_adjacent_duplicates(n, s): Returns the minimum number of changes needed to ensure no two adjacent birds belong to the same species. :param n: Length of the observation string :param s: Observation string of bird species :return: Minimum number of changes required changes = 0 for i in range(1, n): if s[i] == s[i - 1]: changes += 1 return changes"},{"question":"def is_city_connected(n: int, m: int, roads: List[Tuple[int, int]]) -> str: Determines if a city's road network is connected. Args: n (int): The number of intersections. m (int): The number of roads. roads (List[Tuple[int, int]]): list of tuples where each tuple represents a road between intersections. Returns: str: \\"YES\\" if the city is connected, otherwise \\"NO\\". pass from solution import is_city_connected def test_city_connected_simple(): n, m = 5, 4 roads = [(1, 2), (2, 3), (3, 4), (4, 5)] assert is_city_connected(n, m, roads) == \\"YES\\" def test_city_not_connected_simple(): n, m = 5, 2 roads = [(1, 2), (4, 5)] assert is_city_connected(n, m, roads) == \\"NO\\" def test_city_connected_single_intersection(): n, m = 1, 0 roads = [] assert is_city_connected(n, m, roads) == \\"YES\\" def test_city_connected_no_roads(): n, m = 3, 0 roads = [] assert is_city_connected(n, m, roads) == \\"NO\\" def test_city_connected_complex(): n, m = 7, 6 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)] assert is_city_connected(n, m, roads) == \\"YES\\" def test_city_not_connected_isolated_node(): n, m = 7, 5 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert is_city_connected(n, m, roads) == \\"NO\\"","solution":"def is_city_connected(n, m, roads): Determines if a city's road network is connected. Args: n (int): The number of intersections. m (int): The number of roads. roads (List[Tuple[int, int]]): list of tuples where each tuple represents a road between intersections. Returns: str: \\"YES\\" if the city is connected, otherwise \\"NO\\". from collections import defaultdict, deque if n == 1: return \\"YES\\" graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Use BFS or DFS to check connectivity visited = set() def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) bfs(1) if len(visited) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def is_even_sum_grid_possible(n: int) -> Tuple[str, List[List[int]]]: Determines if an n x n grid with the given properties is possible. Returns \\"YES\\" and the grid configuration if possible, otherwise returns \\"NO\\". pass # Test cases def test_grid_1x1(): result, grid = is_even_sum_grid_possible(1) assert result == \\"YES\\" assert grid == [[1]] def test_grid_2x2(): result, grid = is_even_sum_grid_possible(2) assert result == \\"YES\\" assert grid == [ [1, 2], [3, 4] ] def test_grid_3x3(): result, grid = is_even_sum_grid_possible(3) assert result == \\"YES\\" assert grid == [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] def test_grid_4x4(): result, grid = is_even_sum_grid_possible(4) assert result == \\"YES\\" assert grid == [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] def test_grid_large_size(): result, grid = is_even_sum_grid_possible(500) assert result == \\"YES\\" assert len(grid) == 500 assert all(len(row) == 500 for row in grid) unique_numbers = set() for row in grid: unique_numbers.update(row) assert len(unique_numbers) == 500 * 500 assert max(unique_numbers) <= 1000000000","solution":"def is_even_sum_grid_possible(n): Determines if an n x n grid with the given properties is possible. Returns \\"YES\\" and the grid configuration if possible, otherwise returns \\"NO\\". if n == 1: # For n=1, it's trivially possible return \\"YES\\", [[1]] # Generate a grid of size n x n with unique positive integers grid = [] num = 1 for i in range(n): row = [] for j in range(n): row.append(num) num += 1 grid.append(row) # In a sequential integer grid, the sum of any row will be the sum of an arithmetic series # We check the sum of elements in rows and columns, excluding a specific element, all will be even # Only need to consider as the sum of first n natural numbers is even for odd n and some other properties return \\"YES\\", grid"},{"question":"def min_employees_required(projects): Returns the minimum number of employees required to handle all projects without overlapping schedules. projects: List of tuples, where each tuple contains the start and end dates of a project. Example: >>> min_employees_required([(1, 3), (2, 5), (4, 6)]) 2 >>> min_employees_required([(1, 3), (4, 6), (7, 9)]) 1","solution":"import heapq def min_employees_required(projects): Returns the minimum number of employees required to handle all projects without overlapping schedules. projects: List of tuples, where each tuple contains the start and end dates of a project. if not projects: return 0 # Sort the projects by their start time projects.sort(key=lambda x: x[0]) # Min-heap to keep track of end times of projects currently being handled min_heap = [] for start, end in projects: # If the earliest project in the min-heap has ended before the current project starts, pop it from the heap if min_heap and min_heap[0] <= start: heapq.heappop(min_heap) # Push the end time of the current project into the heap heapq.heappush(min_heap, end) # The size of the heap is the minimum number of employees required return len(min_heap)"},{"question":"def can_fulfill_orders(inventory: dict, orders: list) -> bool: Returns True if all orders can be fulfilled with the current inventory, otherwise returns False. Args: inventory : dict : inventory of books as {title: quantity} orders : list : list of order dictionaries as [{title: quantity}, ...] Returns: bool : True if all orders can be fulfilled, otherwise False Examples: >>> can_fulfill_orders( ... { ... \\"Book A\\": 4, ... \\"Book B\\": 2, ... \\"Book C\\": 1 ... }, ... [ ... {\\"Book A\\": 2}, ... {\\"Book B\\": 1, \\"Book C\\": 1}, ... {\\"Book A\\": 2}, ... {\\"Book B\\": 1, \\"Book D\\": 1} ... ] ... ) False >>> can_fulfill_orders( ... { ... \\"Book A\\": 4, ... \\"Book B\\": 2, ... \\"Book C\\": 1 ... }, ... [ ... {\\"Book A\\": 2}, ... {\\"Book B\\": 1, \\"Book C\\": 1}, ... {\\"Book A\\": 2}, ... ] ... ) True","solution":"def can_fulfill_orders(inventory, orders): Returns True if all orders can be fulfilled with the current inventory, otherwise returns False. Args: inventory : dict : inventory of books as {title: quantity} orders : list : list of order dictionaries as [{title: quantity}, ...] Returns: bool : True if all orders can be fulfilled, otherwise False # Make a copy of the inventory to track remaining stocks stock = inventory.copy() # Iterate over each order for order in orders: for book, quantity in order.items(): # If book is not in stock or insufficient quantity, return False if book not in stock or stock[book] < quantity: return False # Deduct the ordered quantity from the stock stock[book] -= quantity return True"},{"question":"from typing import List def warehouse_operations(n: int, operations: List[str]) -> List[int]: Process a series of operations on the inventory. >>> warehouse_operations(6, [\\"ADD 1001 50\\", \\"ADD 1002 30\\", \\"QUERY 1001\\", \\"REMOVE 1001 20\\", \\"QUERY 1001\\", \\"QUERY 1003\\"]) [50, 30, 0] >>> warehouse_operations(3, [\\"ADD 1001 50\\", \\"REMOVE 1001 60\\", \\"QUERY 1001\\"]) [0] >>> warehouse_operations(3, [\\"QUERY 1001\\", \\"REMOVE 1001 5\\", \\"QUERY 1001\\"]) [0, 0] >>> warehouse_operations(5, [\\"ADD 1001 50\\", \\"ADD 1001 50\\", \\"QUERY 1001\\", \\"REMOVE 1001 20\\", \\"QUERY 1001\\"]) [100, 80] >>> warehouse_operations(1, [\\"ADD 1001 50\\"]) []","solution":"def warehouse_operations(n, operations): inventory = {} results = [] for op in operations: parts = op.split() command = parts[0] product_id = int(parts[1]) if command == \\"ADD\\": quantity = int(parts[2]) if product_id in inventory: inventory[product_id] += quantity else: inventory[product_id] = quantity elif command == \\"REMOVE\\": quantity = int(parts[2]) if product_id in inventory: inventory[product_id] = max(0, inventory[product_id] - quantity) elif command == \\"QUERY\\": results.append(inventory.get(product_id, 0)) return results"},{"question":"from typing import List def min_steps_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of steps required to move from the top-left cell (0,0) to the bottom-right cell (n-1,m-1) in an n x m grid. You can move up, down, left, or right but cannot pass through occupied cells ('#'). If it's not possible, return -1. >>> min_steps_to_reach_end(5, 5, [ \\".....\\", \\".#.\\", \\".....\\", \\".#.\\", \\".....\\" ]) 8 >>> min_steps_to_reach_end(3, 3, [ \\"..#\\", \\"#\\", \\"...\\" ]) -1 >>> min_steps_to_reach_end(1, 1, [\\".\\"]) 0 >>> min_steps_to_reach_end(2, 2, [\\"..\\", \\"#.\\"]) 2 >>> min_steps_to_reach_end(2, 2, [\\"..\\", \\"..\\"]) 2 >>> min_steps_to_reach_end(2, 2, [\\"\\", \\"..\\"]) -1 >>> min_steps_to_reach_end(3, 5, [ \\".....\\", \\".#.\\", \\".....\\"]) 6 >>> min_steps_to_reach_end(2, 2, [\\".#\\", \\".#\\"]) -1","solution":"from collections import deque def min_steps_to_reach_end(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Movement in the grid: up, down, left, right queue = deque([(0, 0, 0)]) # (x, y, step_count) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if (x, y) == (n-1, m-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"def contains_arithmetic_progression(arr: List[int]) -> str: Function to determine if there exist three distinct indices i, j, k such that arr[i], arr[j], arr[k] form an arithmetic progression. >>> contains_arithmetic_progression([4, 1, 3, 5, 10]) \\"YES\\" >>> contains_arithmetic_progression([1, 2, 4]) \\"NO\\"","solution":"def contains_arithmetic_progression(arr): Function to determine if there exist three distinct indices i, j, k such that arr[i], arr[j], arr[k] form an arithmetic progression. n = len(arr) # Using a set to store the elements for quick lookup arr_set = set(arr) # Iterate over every pair of the array for i in range(n): for j in range(i + 1, n): # Calculate the expected third element to form an arithmetic progression a_i = arr[i] a_j = arr[j] a_k = 2 * a_j - a_i # Check if this third element exist and is distinct if a_k in arr_set and a_k != a_i and a_k != a_j: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def exists_two_sum(nums: List[int], target: int) -> bool: Check if there exist two distinct indices i and j in the array such that nums[i] + nums[j] == target. :param nums: List of integers representing the array. :param target: Integer representing the target sum. :return: True if there exist two distinct indices i and j with nums[i] + nums[j] == target, otherwise False. >>> exists_two_sum([1, 2, 3, 4], 5) True >>> exists_two_sum([1, 2, 3, 4], 8) False >>> exists_two_sum([-1, -2, -3, -4], -3) True >>> exists_two_sum([1000000000, 2000000000, 3000000000, 4000000000], 5000000000) True >>> exists_two_sum([-1000000000, -2000000000, -3000000000, -4000000000], -5000000000) True >>> exists_two_sum([0, 1, 2, 3], 3) True >>> exists_two_sum([1, 1, 1, 1], 3) False >>> exists_two_sum([1, 2], 3) True >>> exists_two_sum([1, 2], 4) False","solution":"from typing import List def exists_two_sum(nums: List[int], target: int) -> bool: Check if there exist two distinct indices i and j in the array such that nums[i] + nums[j] == target. :param nums: List of integers representing the array. :param target: Integer representing the target sum. :return: True if there exist two distinct indices i and j with nums[i] + nums[j] == target, otherwise False. num_set = set() for num in nums: if target - num in num_set: return True num_set.add(num) return False"},{"question":"def longest_subarray_with_difference(nums: List[int], k: int) -> int: Finds the length of the longest subarray where the difference between any two elements is no more than k. Args: nums : List[int] : List of integers k : int : Maximum allowable difference between any two elements in the subarray Returns: int : Length of the longest subarray >>> longest_subarray_with_difference([1, 5, 9, 13, 2, 3], 3) 3 >>> longest_subarray_with_difference([7, 7, 7, 7], 0) 4 >>> longest_subarray_with_difference([10, 20, 30, 40], 0) 1 >>> longest_subarray_with_difference([1, 1000000000], 1000000000) 2 >>> longest_subarray_with_difference([1, 2, 3, 4, 5], 5) 5 >>> longest_subarray_with_difference([1], 10) 1 >>> longest_subarray_with_difference(list(range(100000)), 1) 2","solution":"def longest_subarray_with_difference(nums, k): Finds the length of the longest subarray where the difference between any two elements is no more than k. Args: nums : List[int] : List of integers k : int : Maximum allowable difference between any two elements in the subarray Returns: int : Length of the longest subarray nums.sort() left = 0 max_len = 0 for right in range(len(nums)): while nums[right] - nums[left] > k: left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def max_customers_served(n: int, m: int, T: int, A: List[int], B: List[int]) -> int: Determine the maximum number of customers that can be served given a time limit. Parameters: n (int): Number of customers at the first counter. m (int): Number of customers at the second counter. T (int): Maximum allowed wait time. A (List[int]): Wait times at the first counter. B (List[int]): Wait times at the second counter. Returns: int: Maximum number of customers that can be served without exceeding the time limit. Examples: >>> max_customers_served(5, 4, 10, [2, 3, 5, 7, 11], [1, 2, 3, 4]) 4 >>> max_customers_served(3, 3, 1, [2, 3, 5], [2, 3, 4]) 0 >>> max_customers_served(1, 1, 5, [4], [6]) 1 >>> max_customers_served(4, 4, 10, [1, 2, 3, 4], [1, 2, 3, 4]) 5 >>> max_customers_served(10, 10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 5","solution":"def max_customers_served(n, m, T, A, B): def cumulative_sum(arr): cum_sum = [0] for num in arr: cum_sum.append(cum_sum[-1] + num) return cum_sum A_cumsum = cumulative_sum(A) B_cumsum = cumulative_sum(B) # Max customers that can be served starting from only the first counter max_customers = 0 for i in range(n + 1): if A_cumsum[i] > T: break # binary search in B_cumsum for the largest index j so that A_cumsum[i] + B_cumsum[j] <= T remaining_time = T - A_cumsum[i] low, high = 0, m while low <= high: mid = (low + high) // 2 if B_cumsum[mid] <= remaining_time: low = mid + 1 else: high = mid - 1 max_customers = max(max_customers, i + high) for j in range(m + 1): if B_cumsum[j] > T: break # binary search in A_cumsum for the largest index i so that B_cumsum[j] + A_cumsum[i] <= T remaining_time = T - B_cumsum[j] low, high = 0, n while low <= high: mid = (low + high) // 2 if A_cumsum[mid] <= remaining_time: low = mid + 1 else: high = mid - 1 max_customers = max(max_customers, j + high) return max_customers"},{"question":"from typing import Dict, List from collections import deque, defaultdict def find_graph_diameter(graph: Dict[int, List[int]], values: List[int]) -> int: Find the diameter of a connected, undirected graph where the diameter is defined as the maximum sum of values of nodes on the longest path between any two nodes. Args: graph (dict): A dictionary where the keys are node integers and the values are lists of integers representing the adjacent nodes. values (list): A list of integers where the ith value corresponds to the value of the ith node in the graph. Returns: int: The diameter of the graph. Example: >>> find_graph_diameter({0: [1, 2], 1: [0, 3], 2: [0], 3: [1]}, [4, 3, 2, 1]) 10 def test_case_1(): graph = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1]} values = [4, 3, 2, 1] assert find_graph_diameter(graph, values) == 10 def test_case_2(): graph = {0: [1], 1: [0, 2], 2: [1, 3], 3: [2]} values = [1, 2, 3, 4] assert find_graph_diameter(graph, values) == 10 def test_case_3(): graph = {0: [1, 2, 3], 1: [0], 2: [0], 3: [0]} values = [1, 1, 1, 1] assert find_graph_diameter(graph, values) == 3 def test_case_4(): graph = {0: [1, 2], 1: [0], 2: [0, 3], 3: [2]} values = [1, 5, 1, 5] assert find_graph_diameter(graph, values) == 12 def test_case_5(): graph = {0: [1, 2, 3], 1: [0], 2: [0], 3: [0]} values = [5, 2, 1, 3] assert find_graph_diameter(graph, values) == 10","solution":"from collections import deque, defaultdict def bfs(graph, start, values): visited = [-1] * len(values) queue = deque([(start, values[start])]) visited[start] = values[start] farthest_node = start max_sum = values[start] while queue: node, current_sum = queue.popleft() for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = current_sum + values[neighbor] queue.append((neighbor, current_sum + values[neighbor])) if visited[neighbor] > max_sum: max_sum = visited[neighbor] farthest_node = neighbor return farthest_node, max_sum def find_graph_diameter(graph, values): # Perform the first BFS to find the farthest node from an arbitrary start node (0) start_node = 0 farthest_node, max_sum = bfs(graph, start_node, values) # Perform the second BFS from the farthest node found in the first BFS farthest_node, max_sum = bfs(graph, farthest_node, values) return max_sum"},{"question":"def max_contiguous_subarray_sum(n: int, values: List[int]) -> int: Determine the maximum sum of values for any contiguous subarray. Parameters: n (int): The number of paintings in the collection values (list of int): The list of values corresponding to the paintings Returns: int: The maximum sum of values for any contiguous subarray >>> max_contiguous_subarray_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_contiguous_subarray_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_contiguous_subarray_sum(1, [5]) 5 >>> max_contiguous_subarray_sum(1, [-7]) -7 >>> max_contiguous_subarray_sum(6, [3, -2, 5, -1, 2, -4]) 7 >>> max_contiguous_subarray_sum(4, [10000, -1000, 10000, -1000]) 19000 >>> max_contiguous_subarray_sum(5, [1, 2, 3, 4, 5]) 15","solution":"def max_contiguous_subarray_sum(n, values): Function to determine the maximum sum of values for any contiguous subarray. Parameters: n (int): The number of paintings in the collection values (list of int): The list of values corresponding to the paintings Returns: int: The maximum sum of values for any contiguous subarray # Implementing Kadane's algorithm max_current = max_global = values[0] for i in range(1, n): max_current = max(values[i], max_current + values[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def min_swaps_to_palindrome(s: str) -> int: Calculate the minimum number of swaps required to make the given string a palindrome, or return -1 if it is not possible. >>> min_swaps_to_palindrome(\\"ab\\") -1 >>> min_swaps_to_palindrome(\\"aabb\\") 2 >>> min_swaps_to_palindrome(\\"racecar\\") 0 def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases and return the results. >>> process_test_cases([\\"ab\\", \\"aabb\\", \\"racecar\\"]) [-1, 2, 0] >>> process_test_cases([\\"a\\"]) [0] >>> process_test_cases([\\"abba\\"]) [0] >>> process_test_cases([\\"abcba\\"]) [0] >>> process_test_cases([\\"abc\\"]) [-1] >>> process_test_cases([\\"\\"]) [0] >>> process_test_cases([\\"aab\\", \\"abacaba\\", \\"abcdef\\"]) [1, 0, -1]","solution":"def min_swaps_to_palindrome(s): def is_palindrome_possible(s): from collections import Counter counter = Counter(s) odd_count = sum(1 for count in counter.values() if count % 2 == 1) return odd_count <= 1 if not is_palindrome_possible(s): return -1 s_list = list(s) left, right = 0, len(s) - 1 swaps = 0 while left < right: if s_list[left] == s_list[right]: left += 1 right -= 1 else: l_index = right while l_index > left and s_list[l_index] != s_list[left]: l_index -= 1 if l_index == left: # we have an odd character s_list[l_index], s_list[l_index + 1] = s_list[l_index + 1], s_list[l_index] swaps += 1 continue else: for i in range(l_index, right): s_list[i], s_list[i + 1] = s_list[i + 1], s_list[i] swaps += 1 left += 1 right -= 1 return swaps def process_test_cases(test_cases): results = [] for s in test_cases: results.append(min_swaps_to_palindrome(s)) return results"},{"question":"def find_minimum_travel_cost(n: int, m: int, k: int, bus_routes: List[Tuple[int, int, int, int]]) -> int: In the country of Logoland, there is a special tournament taking place called the Binary Search Championship. Participants from various cities (numbered from 1 to n) must travel to Logopolis (city 0), which is the capital, for the main event. The tournament lasts for k days, and all participants must be present in the city for the entire duration of the event. Your task is to find the minimum possible travel cost required to gather all participants in Logopolis for k consecutive days and return them to their respective home cities afterward. Some participants may choose to stay longer than the k days if it minimizes the overall cost. The cost must be determined based on the given bus route options, and you need to ensure all participants can attend the event and return home efficiently. :param n: Number of cities excluding Logopolis :param m: Number of bus routes :param k: Number of days the event lasts :param bus_routes: List of bus routes, each defined by (day of travel, departure city, arrival city, cost) :return: Minimum travel cost, or -1 if it's impossible to get all participants to the event and back >>> find_minimum_travel_cost(3, 6, 5, [(1, 1, 0, 300), (2, 2, 0, 400), (3, 3, 0, 500), (7, 0, 1, 300), (8, 0, 2, 400), (9, 0, 3, 500)]) 2400 >>> find_minimum_travel_cost(2, 4, 3, [(1, 1, 0, 200), (5, 2, 0, 300), (6, 0, 1, 200), (10, 0, 2, 300)]) -1","solution":"def find_minimum_travel_cost(n, m, k, bus_routes): from collections import defaultdict import heapq bus_to_logopolis = defaultdict(list) bus_from_logopolis = defaultdict(list) for di, fi, ti, ci in bus_routes: if ti == 0: bus_to_logopolis[fi].append((di, ci)) elif fi == 0: bus_from_logopolis[ti].append((di, ci)) min_arrive_cost = [float('inf')] * (n + 1) min_depart_cost = [float('inf')] * (n + 1) for city in range(1, n + 1): if city in bus_to_logopolis: for di, ci in bus_to_logopolis[city]: if di <= k: min_arrive_cost[city] = min(min_arrive_cost[city], ci) if city in bus_from_logopolis: for di, ci in bus_from_logopolis[city]: if di > k: min_depart_cost[city] = min(min_depart_cost[city], ci) total_arrive_cost = 0 total_depart_cost = 0 for city in range(1, n + 1): if min_arrive_cost[city] == float('inf') or min_depart_cost[city] == float('inf'): return -1 total_arrive_cost += min_arrive_cost[city] total_depart_cost += min_depart_cost[city] return total_arrive_cost + total_depart_cost # Example 1 n = 3 m = 6 k = 5 bus_routes = [ (1, 1, 0, 300), (2, 2, 0, 400), (3, 3, 0, 500), (7, 0, 1, 300), (8, 0, 2, 400), (9, 0, 3, 500), ] print(find_minimum_travel_cost(n, m, k, bus_routes)) # Output: 2400 # Example 2 n = 2 m = 4 k = 3 bus_routes = [ (1, 1, 0, 200), (5, 2, 0, 300), (6, 0, 1, 200), (10, 0, 2, 300), ] print(find_minimum_travel_cost(n, m, k, bus_routes)) # Output: -1"},{"question":"def next_permutation(n: int, permutation: List[int]) -> List[int]: Finds the next lexicographic permutation of the given list of integers. Given a permutation of distinct integers from 1 to n, find the next permutation in lexicographic order. If the given permutation is the largest possible permutation, then the next permutation in lexicographic order is the smallest possible permutation (which sorts the sequence). >>> next_permutation(3, [1, 2, 3]) [1, 3, 2] >>> next_permutation(3, [3, 2, 1]) [1, 2, 3] >>> next_permutation(4, [1, 3, 2, 4]) [1, 3, 4, 2] >>> next_permutation(5, [1, 5, 4, 3, 2]) [2, 1, 3, 4, 5] >>> next_permutation(1, [1]) [1] >>> next_permutation(5, [5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> next_permutation(3, [2, 3, 1]) [3, 1, 2]","solution":"def next_permutation(n, permutation): Finds the next lexicographic permutation of the given list of integers. :param n: The length of the permutation (integer) :param permutation: A list of integers representing the permutation :return: A list of integers representing the next permutation in lexicographic order if n <= 1: return permutation # Step 1: Find the largest index k such that permutation[k] < permutation[k + 1]. If no such index exists, the permutation is the last permutation. k = -1 for i in range(n - 1): if permutation[i] < permutation[i + 1]: k = i if k == -1: # The given permutation is the largest, return the smallest permutation return sorted(permutation) # Step 2: Find the largest index l greater than k such that permutation[k] < permutation[l] l = -1 for i in range(n - 1, k, -1): if permutation[k] < permutation[i]: l = i break # Step 3: Swap the value of permutation[k] with that of permutation[l] permutation[k], permutation[l] = permutation[l], permutation[k] # Step 4: Reverse the sequence from permutation[k + 1] to the end of the list permutation = permutation[:k + 1] + permutation[k + 1:][::-1] return permutation"},{"question":"def generate_experiment_name(n: int) -> str: Generate a sequential experiment name with the format \\"EXP#\\" where n is a 0-padded number. Parameters: n (int): The number of the current experiment (0 ≤ n ≤ 999). Returns: str: The formatted experiment name. >>> generate_experiment_name(0) 'EXP000' >>> generate_experiment_name(1) 'EXP001' >>> generate_experiment_name(7) 'EXP007' >>> generate_experiment_name(42) 'EXP042' >>> generate_experiment_name(123) 'EXP123' >>> generate_experiment_name(999) 'EXP999'","solution":"def generate_experiment_name(n): Generate a sequential experiment name with the format \\"EXP#\\" where n is a 0-padded number. Parameters: n (int): The number of the current experiment (0 ≤ n ≤ 999). Returns: str: The formatted experiment name. return f\\"EXP{n:03}\\""},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Returns the largest rectangular area possible in the given histogram. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([3, 3, 3, 3]) 12 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([0, 0, 0, 0]) 0 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largestRectangleArea(heights): Returns the largest rectangular area possible in the given histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def length_of_longest_substring_with_unique_chars(s: str) -> int: Returns the length of the longest substring with all unique characters. :param s: String input :type s: str :return: Length of the longest substring with all unique characters :rtype: int >>> length_of_longest_substring_with_unique_chars(\\"abcabcbb\\") == 3 >>> length_of_longest_substring_with_unique_chars(\\"bbbbbb\\") == 1 >>> length_of_longest_substring_with_unique_chars(\\"pwwkew\\") == 3 >>> length_of_longest_substring_with_unique_chars(\\"abcd\\") == 4 >>> length_of_longest_substring_with_unique_chars(\\"\\") == 0 >>> length_of_longest_substring_with_unique_chars(\\"a\\") == 1 >>> length_of_longest_substring_with_unique_chars(\\"abcdef\\") == 6 >>> length_of_longest_substring_with_unique_chars(\\"aab\\") == 2 >>> length_of_longest_substring_with_unique_chars(\\"dvdf\\") == 3 >>> length_of_longest_substring_with_unique_chars(\\"anviaj\\") == 5","solution":"def length_of_longest_substring_with_unique_chars(s): Returns the length of the longest substring with all unique characters. :param s: String input :type s: str :return: Length of the longest substring with all unique characters :rtype: int n = len(s) start = 0 max_length = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def is_valid(board: List[List[str]]) -> bool: Check if the board is valid after removing a piece. n = len(board) m = len(board[0]) rows = set() cols = set() diag1 = set() diag2 = set() for r in range(n): for c in range(m): if board[r][c] == '#': if r in rows or c in cols or (r - c) in diag1 or (r + c) in diag2: return False rows.add(r) cols.add(c) diag1.add(r - c) diag2.add(r + c) return True def process_queries(n: int, m: int, initial_board: List[str], queries: List[Tuple[int, int]]) -> List[str]: Process the queries and return results. >>> n = 3 >>> m = 3 >>> initial_board = [\\"#..\\", \\".#.\\", \\"..#\\"] >>> queries = [(1, 1), (2, 2)] >>> process_queries(n, m, initial_board, queries) [\\"NO\\", \\"YES\\"] >>> n = 3 >>> m = 3 >>> initial_board = [\\"#..\\", \\".#.\\", \\"#..\\"] >>> queries = [(1, 1), (2, 2), (3, 1)] >>> process_queries(n, m, initial_board, queries) [\\"NO\\", \\"YES\\", \\"YES\\"] >>> n = 3 >>> m = 3 >>> initial_board = [\\"#..\\", \\"...\\", \\"..#\\"] >>> queries = [(1, 1)] >>> process_queries(n, m, initial_board, queries) [\\"YES\\"] >>> n = 3 >>> m = 3 >>> initial_board = [\\"#.#\\", \\"...\\", \\"..#\\"] >>> queries = [(1, 1), (2, 2)] >>> process_queries(n, m, initial_board, queries) [\\"NO\\", \\"NO\\"] # Your code here","solution":"def is_valid(board): Check if the board is valid after removing a piece. n = len(board) m = len(board[0]) rows = set() cols = set() diag1 = set() diag2 = set() for r in range(n): for c in range(m): if board[r][c] == '#': if r in rows or c in cols or (r - c) in diag1 or (r + c) in diag2: return False rows.add(r) cols.add(c) diag1.add(r - c) diag2.add(r + c) return True def process_queries(n, m, initial_board, queries): Process the queries and return results. board = [list(row) for row in initial_board] results = [] for r, c in queries: board[r-1][c-1] = '.' if is_valid(board): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple class AccessControl: Manage user access levels in a data management application. - add_user(self, username: str, access_level: int) -> bool: Adds a new user with the specified username and access level. - remove_user(self, username: str) -> bool: Removes an existing user by their username. - update_access(self, username: str, access_level: int) -> bool: Updates the access level of the specified user. - get_access(self, username: str) -> int: Returns the access level of the specified user. - list_users(self) -> List[Tuple[str, int]]: Returns a list of all users and their access levels sorted by username. >>> ac = AccessControl() >>> ac.add_user(\\"alice\\", 5) True >>> ac.add_user(\\"bob\\", 3) True >>> ac.add_user(\\"alice\\", 7) False >>> ac.get_access(\\"alice\\") 5 >>> ac.update_access(\\"alice\\", 7) True >>> ac.get_access(\\"alice\\") 7 >>> ac.remove_user(\\"charlie\\") False >>> ac.remove_user(\\"bob\\") True >>> ac.list_users() [('alice', 7)] def add_user(self, username: str, access_level: int) -> bool: pass def remove_user(self, username: str) -> bool: pass def update_access(self, username: str, access_level: int) -> bool: pass def get_access(self, username: str) -> int: pass def list_users(self) -> List[Tuple[str, int]]: pass","solution":"from typing import List, Tuple class AccessControl: def __init__(self): self.users = {} def add_user(self, username: str, access_level: int) -> bool: if username in self.users: return False self.users[username] = access_level return True def remove_user(self, username: str) -> bool: if username not in self.users: return False del self.users[username] return True def update_access(self, username: str, access_level: int) -> bool: if username not in self.users: return False self.users[username] = access_level return True def get_access(self, username: str) -> int: return self.users.get(username, -1) def list_users(self) -> List[Tuple[str, int]]: return sorted(self.users.items())"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True","solution":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the given string can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def sieve_of_eratosthenes(max_num: int) -> List[int]: Generate all prime numbers up to max_num using the Sieve of Eratosthenes. pass def kth_prime(k: int) -> int: Returns the k-th prime number. Args: k (int): The position of the prime number to retrieve (1 ≤ k ≤ 10^6). Returns: int: The k-th prime number. Example: >>> kth_prime(1) 2 >>> kth_prime(5) 11 pass","solution":"def sieve_of_eratosthenes(max_num): Generate all prime numbers up to max_num using the Sieve of Eratosthenes. is_prime = [True] * (max_num + 1) p = 2 while p * p <= max_num: if is_prime[p] == True: for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 primes = [] for p in range(2, max_num + 1): if is_prime[p]: primes.append(p) return primes def kth_prime(k): Returns the k-th prime number. if k < 1 or k > 10**6: raise ValueError(\\"K must be between 1 and 10^6 inclusive\\") # Estimate upper bound for the k-th prime using the approximation k * log(k) + k * log(log(k)) # Use some margin to ensure the upper bound is sufficient if k < 6: upper_bound = 15 # for small k values else: from math import log upper_bound = int(k * log(k) + k * log(log(k))) primes = sieve_of_eratosthenes(upper_bound) return primes[k-1]"},{"question":"def find_max_subarray(arr: List[int]) -> Tuple[int, int, int]: Find a subarray such that the sum of its elements is maximized. If multiple subarrays have the same maximum sum, choose the one with the minimum length. If there are still multiple subarrays, choose the one that appears first in the array. >>> find_max_subarray([1, -2, 3, 5, -3, 2, -5, 2]) == (8, 2, 3) >>> find_max_subarray([-1, -2, -3, -4, -5]) == (-1, 1, 1) >>> find_max_subarray([1, 2, 3, 4]) == (10, 4, 1) >>> find_max_subarray([1, -2, 4, -1, 2, 1, -5, 4]) == (6, 4, 3) >>> find_max_subarray([2, -1, 2, 3, 4, -5]) == (10, 5, 1) >>> find_max_subarray([-3, -2, -1, -4]) == (-1, 1, 3)","solution":"def find_max_subarray(arr): n = len(arr) max_sum = float('-inf') current_sum = 0 start = 0 end = 0 temp_start = 0 min_length = n + 1 for i in range(n): current_sum += arr[i] if current_sum > max_sum or (current_sum == max_sum and (i - temp_start + 1) < min_length): max_sum = current_sum start = temp_start end = i min_length = i - temp_start + 1 if current_sum < 0: current_sum = 0 temp_start = i + 1 return max_sum, min_length, start + 1 # Example usage arr = [1, -2, 3, 5, -3, 2, -5, 2] print(find_max_subarray(arr)) # Output should be (8, 2, 3)"},{"question":"from typing import List def reconstruct_sequence(n: int, signals: List[int]) -> List[int]: Reconstruct the original sequence from the signals by filtering out corruptions. Parameters: n (int): The number of signals. signals (List[int]): The list of signals including corruptions represented by -1. Returns: List[int]: The list of valid signal strengths or an empty list if all signals are corrupted. Examples: >>> reconstruct_sequence(6, [3, -1, 4, -1, 5, 9]) [3, 4, 5, 9] >>> reconstruct_sequence(4, [-1, -1, -1, -1]) [] >>> reconstruct_sequence(5, [2, 3, 4, 5, 6]) [2, 3, 4, 5, 6] >>> reconstruct_sequence(7, [-1, 7, 8, -1, 9, 10, -1]) [7, 8, 9, 10] >>> reconstruct_sequence(5, [-1, 2, 3, 4, -1]) [2, 3, 4] >>> reconstruct_sequence(1, [-1]) [] >>> reconstruct_sequence(1, [10]) [10]","solution":"def reconstruct_sequence(n, signals): Reconstruct the original sequence from the signals by filtering out corruptions. Parameters: n (int): The number of signals. signals (List[int]): The list of signals including corruptions represented by -1. Returns: List[int]: The list of valid signal strengths or an empty list if all signals are corrupted. return [signal for signal in signals if signal != -1]"},{"question":"from typing import List, Tuple def shortestPath(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Finds the shortest path in a 2D grid from start to end. Returns the length of the shortest path if it exists, otherwise returns -1. >>> grid = [[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 1, 0, 1, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 0]] >>> start = (0, 0) >>> end = (4, 4) >>> shortestPath(grid, start, end) 8 >>> grid = [[0, 0, 1, 0, 0], [0, 0, 1, 0, 1], [1, 1, 1, 1, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 0]] >>> start = (0, 0) >>> end = (4, 4) >>> shortestPath(grid, start, end) -1 >>> grid = [[1, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 1, 0, 1, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 0]] >>> start = (0, 0) >>> end = (4, 4) >>> shortestPath(grid, start, end) -1 >>> grid = [[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 1, 0, 1, 0], [1, 0, 0, 0, 0], [0, 0, 1, 0, 1]] >>> start = (0, 0) >>> end = (4, 4) >>> shortestPath(grid, start, end) -1 >>> grid = [[0]] >>> start = (0, 0) >>> end = (0, 0) >>> shortestPath(grid, start, end) 0 >>> grid = [[0, 1], [1, 0]] >>> start = (0, 0) >>> end = (1, 1) >>> shortestPath(grid, start, end) -1 >>> grid = [[0, 0], [0, 0]] >>> start = (0, 0) >>> end = (0, 1) >>> shortestPath(grid, start, end) 1 >>> grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> start = (0, 0) >>> end = (2, 2) >>> shortestPath(grid, start, end) 4 pass # Complete this function","solution":"from collections import deque def shortestPath(grid, start, end): Finds the shortest path in a 2D grid from start to end. Returns the length of the shortest path if it exists, otherwise returns -1. # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Number of rows and columns in the grid n = len(grid) m = len(grid[0]) # Check if start or end are obstacles if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 # Queue for BFS queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: (current, distance) = queue.popleft() # If we have reached the end, return the distance if current == end: return distance # Check all 4 possible movements for direction in directions: next_row, next_col = current[0] + direction[0], current[1] + direction[1] if 0 <= next_row < n and 0 <= next_col < m and (next_row, next_col) not in visited and grid[next_row][next_col] == 0: visited.add((next_row, next_col)) queue.append(((next_row, next_col), distance + 1)) # If no path is found return -1"},{"question":"def longest_contiguous_subarray(n: int, k: int, timestamps: List[int]) -> int: Find the length of the longest contiguous subarray such that the difference between the maximum and minimum timestamps is less than or equal to k. >>> longest_contiguous_subarray(6, 3, [1, 2, 3, 10, 11, 12]) == 3 >>> longest_contiguous_subarray(1, 0, [5]) == 1 >>> longest_contiguous_subarray(5, 0, [7, 7, 7, 7, 7]) == 5 >>> longest_contiguous_subarray(5, 0, [5, 1, 3, 4, 8]) == 1 >>> longest_contiguous_subarray(5, 10, [1, 2, 3, 4, 5]) == 5 >>> longest_contiguous_subarray(6, 0, [1, 1, 1, 1, 1, 1]) == 6 >>> longest_contiguous_subarray(6, 0, [1, 2, 3, 4, 5, 6]) == 1","solution":"def longest_contiguous_subarray(n, k, timestamps): left = 0 max_len = 0 min_val = timestamps[0] max_val = timestamps[0] for right in range(n): min_val = min(min_val, timestamps[right]) max_val = max(max_val, timestamps[right]) while max_val - min_val > k: left += 1 min_val = min(timestamps[left:right + 1]) max_val = max(timestamps[left:right + 1]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"def generate_report(log_entries: List[str]) -> List[str]: Generate a report that displays the total hours worked by each employee on each project. Input: - log_entries: List of log entries where each entry represents hours worked by an employee on a specific project. Output: - A report where each line contains the name of an employee, the project name, and the total number of hours the employee worked on that project, sorted by employee name and project name. Example: >>> generate_report([ ... \\"Alice ProjectA 2023-05-01 5\\", ... \\"Bob ProjectB 2023-05-02 3\\", ... \\"Alice ProjectA 2023-05-02 3\\", ... \\"Alice ProjectC 2023-05-01 4\\", ... \\"Bob ProjectA 2023-05-01 6\\"]) [\\"Alice ProjectA 8\\", \\"Alice ProjectC 4\\", \\"Bob ProjectA 6\\", \\"Bob ProjectB 3\\"] from solution import generate_report def test_single_employee_single_project(): log_entries = [ \\"Alice ProjectA 2023-05-01 5\\", ] expected_output = [ \\"Alice ProjectA 5\\", ] assert generate_report(log_entries) == expected_output def test_single_employee_multiple_projects(): log_entries = [ \\"Alice ProjectA 2023-05-01 5\\", \\"Alice ProjectB 2023-05-01 3\\", ] expected_output = [ \\"Alice ProjectA 5\\", \\"Alice ProjectB 3\\", ] assert generate_report(log_entries) == expected_output def test_multiple_employees_single_project(): log_entries = [ \\"Alice ProjectA 2023-05-01 5\\", \\"Bob ProjectA 2023-05-01 3\\", ] expected_output = [ \\"Alice ProjectA 5\\", \\"Bob ProjectA 3\\", ] assert generate_report(log_entries) == expected_output def test_multiple_employees_multiple_projects(): log_entries = [ \\"Alice ProjectA 2023-05-01 5\\", \\"Bob ProjectB 2023-05-02 3\\", \\"Alice ProjectA 2023-05-02 3\\", \\"Alice ProjectC 2023-05-01 4\\", \\"Bob ProjectA 2023-05-01 6\\", ] expected_output = [ \\"Alice ProjectA 8\\", \\"Alice ProjectC 4\\", \\"Bob ProjectA 6\\", \\"Bob ProjectB 3\\", ] assert generate_report(log_entries) == expected_output def test_complex_case_with_same_project_multiple_times(): log_entries = [ \\"Alice ProjectA 2023-05-01 5\\", \\"Alice ProjectA 2023-05-02 3\\", \\"Alice ProjectB 2023-05-03 2\\", \\"Bob ProjectA 2023-05-01 4\\", \\"Bob ProjectA 2023-05-02 6\\", \\"Bob ProjectB 2023-05-03 5\\", ] expected_output = [ \\"Alice ProjectA 8\\", \\"Alice ProjectB 2\\", \\"Bob ProjectA 10\\", \\"Bob ProjectB 5\\", ] assert generate_report(log_entries) == expected_output","solution":"def generate_report(log_entries): from collections import defaultdict project_hours = defaultdict(lambda: defaultdict(int)) for entry in log_entries: employee_name, project_name, date, hours_worked = entry.split() hours_worked = int(hours_worked) project_hours[employee_name][project_name] += hours_worked result = [] for employee_name in sorted(project_hours.keys()): for project_name in sorted(project_hours[employee_name].keys()): total_hours = project_hours[employee_name][project_name] result.append(f\\"{employee_name} {project_name} {total_hours}\\") return result # Example usage log_entries = [ \\"Alice ProjectA 2023-05-01 5\\", \\"Bob ProjectB 2023-05-02 3\\", \\"Alice ProjectA 2023-05-02 3\\", \\"Alice ProjectC 2023-05-01 4\\", \\"Bob ProjectA 2023-05-01 6\\", ] print(generate_report(log_entries))"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> Tuple[int, List[int]]: Returns the length and one of the longest strictly increasing subsequences from the given list of integers. Args: arr (List[int]): List of integers. Returns: Tuple[int, List[int]]: Length of the longest strictly increasing subsequence and the subsequence itself. Examples: >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) (6, [10, 22, 33, 50, 60, 80]) >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) (1, [5])","solution":"def longest_increasing_subsequence(arr): Returns the length and one of the longest strictly increasing subsequences from the given list of integers. if not arr: return 0, [] n = len(arr) dp = [1] * n prev_indices = [-1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev_indices[i] = j max_length = max(dp) max_index = dp.index(max_length) lis = [] while max_index != -1: lis.append(arr[max_index]) max_index = prev_indices[max_index] lis.reverse() return max_length, lis # Example usage arr = [10, 22, 9, 33, 21, 50, 41, 60, 80] length, subsequence = longest_increasing_subsequence(arr) print(length) print(\\" \\".join(map(str, subsequence)))"},{"question":"from typing import List def count_smaller_elements_to_the_right(nums: List[int]) -> List[int]: Given an array of integers, return a new array where each element in the new array is the count of elements to the right that are smaller than the corresponding element in the original array. >>> count_smaller_elements_to_the_right([5, 2, 6, 1]) [2, 1, 1, 0] >>> count_smaller_elements_to_the_right([1, 2, 3, 4]) [0, 0, 0, 0] >>> count_smaller_elements_to_the_right([4, 3, 2, 1]) [3, 2, 1, 0] >>> count_smaller_elements_to_the_right([3, 5, 6, 2, 7, 1]) [2, 2, 2, 1, 1, 0] >>> count_smaller_elements_to_the_right([]) [] >>> count_smaller_elements_to_the_right([1]) [0] >>> count_smaller_elements_to_the_right([-1, -2, -3, -4]) [3, 2, 1, 0] >>> count_smaller_elements_to_the_right([1, -1, 2, -2]) [2, 1, 1, 0] >>> count_smaller_elements_to_the_right([100000, 0, -100000]) [2, 1, 0] pass","solution":"def count_smaller_elements_to_the_right(nums): Given an array of integers, return a new array where each element in the new array is the count of elements to the right that are smaller than the corresponding element in the original array. def sort(enum): mid = len(enum) // 2 if mid: left, right = sort(enum[:mid]), sort(enum[mid:]) for i in range(len(enum))[::-1]: if not right or left and left[-1][1] > right[-1][1]: counts[left[-1][0]] += len(right) enum[i] = left.pop() else: enum[i] = right.pop() return enum counts = [0] * len(nums) sort(list(enumerate(nums))) return counts"},{"question":"def smallest_lexicographical_sequence(n: int) -> str: Returns the lexicographically smallest sequence of exactly n distinct colors where no two consecutive colors in the sequence are the same. >>> smallest_lexicographical_sequence(3) \\"ABC\\" >>> smallest_lexicographical_sequence(5) \\"ABCDE\\" >>> smallest_lexicographical_sequence(1) \\"A\\" >>> smallest_lexicographical_sequence(26) \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"","solution":"def smallest_lexicographical_sequence(n): Returns the lexicographically smallest sequence of exactly n distinct colors where no two consecutive colors in the sequence are the same. alphabet = \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" return alphabet[:n]"},{"question":"def calculate_energy(heights: List[int]) -> int: Calculate the total energy gain or loss after traversing all checkpoints Arguments: heights : List[int] -- a list of integers representing the elevation of each checkpoint Returns: int -- the total energy gain or loss >>> calculate_energy([5]) 0 >>> calculate_energy([1, 2, 3, 4, 5]) -4 >>> calculate_energy([5, 4, 3, 2, 1]) 4 >>> calculate_energy([5, 4, 7, 3, 6]) -1 >>> calculate_energy([2, 2, 2, 2, 2]) 0","solution":"def calculate_energy(heights): Calculate the total energy gain or loss after traversing all checkpoints Arguments: heights : List[int] -- a list of integers representing the elevation of each checkpoint Returns: int -- the total energy gain or loss total_energy = 0 for i in range(1, len(heights)): total_energy += heights[i-1] - heights[i] return total_energy"},{"question":"import sympy def is_prime_mean_subsequence_possible(n: int, array: List[int]) -> None: Determines if the given array can be split into subsequences where each subsequence has a mean value that is a prime number. :param n: The length of the array. :param array: List of integers. from io import StringIO import sys import sympy def test_positive_case(): input_data = (4, [3, 11, 7, 5]) expected_output = \\"YESn4n1n2n3n4n\\" captured_output = StringIO() sys.stdout = captured_output is_prime_mean_subsequence_possible(*input_data) sys.stdout = sys.__stdout__ assert captured_output.getvalue() == expected_output def test_negative_case(): input_data = (3, [4, 8, 11]) expected_output = \\"NOn\\" captured_output = StringIO() sys.stdout = captured_output is_prime_mean_subsequence_possible(*input_data) sys.stdout = sys.__stdout__ assert captured_output.getvalue() == expected_output","solution":"import sympy def is_prime_mean_subsequence_possible(n, array): This function determines if the given array can be split into subsequences where each subsequence has a mean value that is a prime number. # Check if each element is a prime if all(sympy.isprime(x) for x in array): print(\\"YES\\") print(n) for i in range(n): print(i + 1) else: print(\\"NO\\")"},{"question":"from typing import List, Tuple def find_optimal_path(m: int, n: int, obstacles: List[Tuple[int, int]]) -> int: Write a function that helps a robot navigate through a grid from the top-left corner to the bottom-right corner, avoiding obstacles. The robot can only move right or down one step at a time. Parameters: m (int): The number of rows in the grid n (int): The number of columns in the grid obstacles (List[Tuple[int, int]]): A list of tuples where each tuple (i, j) represents an obstacle in the grid Returns: int: The number of unique paths from the top-left corner to the bottom-right corner avoiding the obstacles. >>> find_optimal_path(3, 3, [(2, 2)]) 2 >>> find_optimal_path(3, 3, [(1, 2), (2, 1)]) 0","solution":"from typing import List, Tuple def find_optimal_path(m: int, n: int, obstacles: List[Tuple[int, int]]) -> int: # Create a 2D list to store the number of ways to reach each cell dp = [[0] * n for _ in range(m)] # Convert obstacle list to a set for O(1) lookups obstacles_set = set(obstacles) # Initialize the start point if (1, 1) in obstacles_set or (m, n) in obstacles_set: return 0 # If starting or ending point is blocked we can't proceed dp[0][0] = 1 # Start point # Fill the dp table for i in range(m): for j in range(n): if (i + 1, j + 1) in obstacles_set: dp[i][j] = 0 # Cell with an obstacle else: if i > 0: dp[i][j] += dp[i - 1][j] # From top cell if j > 0: dp[i][j] += dp[i][j - 1] # From left cell return dp[m - 1][n - 1] # Bottom-right corner"},{"question":"def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product that can be obtained from any three elements of the array. >>> maximum_product_of_three([1, 2, 3, 4, 5]) 60 >>> maximum_product_of_three([-1, -2, -3, -4, -5]) -6 >>> maximum_product_of_three([-10, -10, 5, 2, 1]) 500 >>> maximum_product_of_three([3, 2, 1]) 6 >>> isinstance(maximum_product_of_three([i for i in range(-100000, 100000)]), int) True","solution":"def maximum_product_of_three(nums): Returns the maximum product that can be obtained from any three elements of the array. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def knapsack(n: int, W: int, stones: List[Tuple[int, int]]) -> int: Solve the knapsack problem to maximize the total value of stones that can be carried in the bag. Parameters: n (int): Number of stones W (int): Maximum weight the bag can carry stones (List[Tuple[int, int]]): List of tuples where each tuple is (weight, value) of a stone. Returns: int: The maximum total value of stones that can be carried in the bag. >>> knapsack(4, 5, [(1, 1), (3, 4), (4, 5), (2, 3)]) 7 >>> knapsack(1, 5, [(5, 10)]) 10 >>> knapsack(1, 4, [(5, 10)]) 0 >>> knapsack(3, 10, [(5, 6), (4, 5), (1, 9)]) 20 >>> knapsack(3, 20, [(10, 100), (15, 150), (7, 80)]) 180 >>> knapsack(0, 5, []) 0 >>> knapsack(3, 0, [(1, 10), (2, 20), (3, 30)]) 0","solution":"def knapsack(n, W, stones): dp = [0] * (W + 1) for w, v in stones: for j in range(W, w - 1, -1): dp[j] = max(dp[j], dp[j - w] + v) return dp[W]"},{"question":"def min_platforms_required(n: int, schedule: List[Tuple[int, int]]) -> int: Returns the minimum number of platforms required at the railway station such that no train has to wait. Args: n (int): The number of trains. schedule (List[Tuple[int, int]]): List of tuples where each tuple contains two integers (arrival, departure) time of each train. Returns: int: The minimum number of platforms required. Example: >>> min_platforms_required(3, [(900, 910), (940, 1200), (950, 1100)]) 2 >>> min_platforms_required(1, [(900, 910)]) 1 pass import pytest from typing import List, Tuple from solution import min_platforms_required def test_example(): schedule = [(900, 910), (940, 1200), (950, 1100)] assert min_platforms_required(3, schedule) == 2 def test_single_train(): schedule = [(900, 910)] assert min_platforms_required(1, schedule) == 1 def test_no_trains(): assert min_platforms_required(0, []) == 0 def test_overlap_all_trains(): schedule = [(900, 1100), (900, 1100), (900, 1100)] assert min_platforms_required(3, schedule) == 3 def test_no_overlap(): schedule = [(900, 910), (920, 930), (940, 950)] assert min_platforms_required(3, schedule) == 1 def test_mixed_trains(): schedule = [(900, 910), (915, 930), (920, 940)] assert min_platforms_required(3, schedule) == 2 def test_edge_case_times(): schedule = [(0, 2359), (1200, 1300), (1400, 2359)] assert min_platforms_required(3, schedule) == 2","solution":"def min_platforms_required(n, schedule): Returns the minimum number of platforms required at the railway station such that no train has to wait. Args: n (int): The number of trains. schedule (list): List of tuples where each tuple contains two integers (arrival, departure) time of each train. Returns: int: The minimum number of platforms required. if n == 0: return 0 # Separate the arrival and departure times arrivals = sorted([train[0] for train in schedule]) departures = sorted([train[1] for train in schedule]) platform_needed = 0 max_platforms = 0 i = 0 j = 0 while i < n and j < n: if arrivals[i] <= departures[j]: platform_needed += 1 i += 1 if platform_needed > max_platforms: max_platforms = platform_needed else: platform_needed -= 1 j += 1 return max_platforms"},{"question":"class DeliverySystem: Delivery system for drones that ensures paths outside a restricted base station. >>> ds = DeliverySystem(5) >>> ds.add_location(10, 10) >>> ds.add_location(-12, 9) >>> ds.check_path(1, 2) 'YES' >>> ds.remove_location(10, 10) >>> ds.locations [(-12, 9)] def __init__(self, radius): self.radius = radius self.locations = [] def add_location(self, x, y): if x**2 + y**2 > self.radius**2: self.locations.append((x, y)) def remove_location(self, x, y): try: self.locations.remove((x, y)) except ValueError: pass def check_path(self, i, j): if (i <= 0 or i > len(self.locations) or j <= 0 or j > len(self.locations)): return \\"NO\\" x1, y1 = self.locations[i - 1] x2, y2 = self.locations[j - 1] if (x2 - x1)**2 + (y2 - y1)**2 > self.radius**2: return \\"YES\\" return \\"NO\\" import pytest def test_add_location(): ds = DeliverySystem(5) ds.add_location(10, 10) assert ds.locations == [(10, 10)] def test_remove_location(): ds = DeliverySystem(5) ds.add_location(10, 10) ds.add_location(-12, 9) ds.remove_location(10, 10) assert ds.locations == [(-12, 9)] def test_check_path_yes(): ds = DeliverySystem(5) ds.add_location(10, 10) ds.add_location(-12, 9) assert ds.check_path(1, 2) == \\"YES\\" def test_check_path_no(): ds = DeliverySystem(5) ds.add_location(1, 0) ds.add_location(0, 5) assert ds.check_path(1, 2) == \\"NO\\" def test_check_path_invalid_indices(): ds = DeliverySystem(5) ds.add_location(10, 10) ds.add_location(-12, 9) assert ds.check_path(1, 3) == \\"NO\\" assert ds.check_path(2, 0) == \\"NO\\" assert ds.check_path(3, 3) == \\"NO\\" pytest.main()","solution":"class DeliverySystem: def __init__(self, radius): self.radius = radius self.locations = [] def add_location(self, x, y): if x**2 + y**2 > self.radius**2: self.locations.append((x, y)) def remove_location(self, x, y): try: self.locations.remove((x, y)) except ValueError: pass def check_path(self, i, j): if (i <= 0 or i > len(self.locations) or j <= 0 or j > len(self.locations)): return \\"NO\\" x1, y1 = self.locations[i - 1] x2, y2 = self.locations[j - 1] if (x2 - x1)**2 + (y2 - y1)**2 > self.radius**2: return \\"YES\\" return \\"NO\\""},{"question":"def max_cities(n: int, d: int, distances: List[int]) -> Tuple[int, List[int]]: Returns the maximum number of cities John can visit without exceeding the distance limit. >>> max_cities(5, 9, [2, 3, 1, 4, 8]) (3, [1, 2, 3]) >>> max_cities(4, 8, [4, 5, 6, 3]) (2, [2, 4])","solution":"def max_cities(n, d, distances): Returns the maximum number of cities John can visit without exceeding the distance limit. # Sort distances with their original indices for reference indexed_distances = sorted(enumerate(distances), key=lambda x: x[1]) total_distance = 0 cities_to_visit = [] # Iterate through the sorted distances and accumulate until limit is reached for index, distance in indexed_distances: if total_distance + distance <= d: total_distance += distance cities_to_visit.append(index + 1) # Store 1-based index else: break return len(cities_to_visit), cities_to_visit"},{"question":"def generate_bytecode(n: int, tokens: List[str]) -> List[str]: Generate bytecode instructions for the given Reverse Polish Notation (RPN) expression. Args: n (int): The number of tokens in the expression. tokens (list): A list of tokens, which are either integers or operations (ADD, SUB, MUL, DIV, PRINT). Returns: list: A list of bytecode instructions. pass # Unit Tests def test_example_case(): n = 7 tokens = [\\"3\\", \\"4\\", \\"ADD\\", \\"2\\", \\"MUL\\", \\"7\\", \\"SUB\\", \\"PRINT\\"] expected = [ \\"PUSH 3\\", \\"PUSH 4\\", \\"ADD\\", \\"PUSH 2\\", \\"MUL\\", \\"PUSH 7\\", \\"SUB\\", \\"PRINT\\" ] assert generate_bytecode(n, tokens) == expected def test_single_push(): n = 1 tokens = [\\"5\\"] expected = [\\"PUSH 5\\"] assert generate_bytecode(n, tokens) == expected def test_multiple_operations(): n = 9 tokens = [\\"5\\", \\"8\\", \\"ADD\\", \\"6\\", \\"SUB\\", \\"3\\", \\"MUL\\", \\"2\\", \\"DIV\\"] expected = [ \\"PUSH 5\\", \\"PUSH 8\\", \\"ADD\\", \\"PUSH 6\\", \\"SUB\\", \\"PUSH 3\\", \\"MUL\\", \\"PUSH 2\\", \\"DIV\\" ] assert generate_bytecode(n, tokens) == expected def test_no_operations(): n = 4 tokens = [\\"1\\", \\"2\\", \\"3\\", \\"4\\"] expected = [\\"PUSH 1\\", \\"PUSH 2\\", \\"PUSH 3\\", \\"PUSH 4\\"] assert generate_bytecode(n, tokens) == expected def test_all_operations(): n = 5 tokens = [\\"ADD\\", \\"SUB\\", \\"MUL\\", \\"DIV\\", \\"PRINT\\"] expected = [\\"ADD\\", \\"SUB\\", \\"MUL\\", \\"DIV\\", \\"PRINT\\"] assert generate_bytecode(n, tokens) == expected","solution":"def generate_bytecode(n, tokens): Generate bytecode instructions for the given Reverse Polish Notation (RPN) expression. Args: n (int): The number of tokens in the expression. tokens (list): A list of tokens, which are either integers or operations (ADD, SUB, MUL, DIV, PRINT). Returns: list: A list of bytecode instructions. bytecode = [] for token in tokens: if token == 'ADD': bytecode.append('ADD') elif token == 'SUB': bytecode.append('SUB') elif token == 'MUL': bytecode.append('MUL') elif token == 'DIV': bytecode.append('DIV') elif token == 'PRINT': bytecode.append('PRINT') else: bytecode.append(f'PUSH {token}') return bytecode"},{"question":"def min_jumps(X: int, M: int, heights: List[int]) -> int: Returns the minimum number of jumps required to reach the top of the staircase. :param X: int, maximum steps that can be taken in a single jump :param M: int, the number of steps in the staircase :param heights: list of int, heights of each step :return: int, minimum number of jumps to reach the top >>> min_jumps(3, 5, [1, 1, 1, 1, 1]) 2 >>> min_jumps(5, 5, [1, 1, 1, 1, 1]) 1","solution":"def min_jumps(X, M, heights): Returns the minimum number of jumps required to reach the top of the staircase. :param X: int, maximum steps that can be taken in a single jump :param M: int, the number of steps in the staircase :param heights: list of int, heights of each step (though in this problem, the heights do not matter) :return: int, minimum number of jumps to reach the top # To reach the top (M steps), we calculate the jumps by dividing M by X and # rounding up to cover any remaining steps. min_jumps = (M + X - 1) // X return min_jumps"},{"question":"def minimum_days_to_finish_books(book_days: List[int]) -> int: Returns the minimum number of days required for Alice to read all books. Parameters: book_days (list of int): A list where the ith element represents the number of days Alice can spend reading the ith book. Returns: int: Minimum days required to finish all books. Example: >>> minimum_days_to_finish_books([3, 2, 1, 4]) 10 >>> minimum_days_to_finish_books([7]) 7","solution":"def minimum_days_to_finish_books(book_days): Returns the minimum number of days required for Alice to read all books. Parameters: book_days (list of int): A list where the ith element represents the number of days Alice can spend reading the ith book. Returns: int: Minimum days required to finish all books. return sum(book_days)"},{"question":"def max_length_subarray_with_k_distinct(arr: List[int], k: int) -> int: Find the maximum length of a subarray that contains no more than k distinct integers. >>> max_length_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> max_length_subarray_with_k_distinct([1], 1) 1 >>> max_length_subarray_with_k_distinct([1, 2, 3, 4, 5], 5) 5 from typing import List def test_max_length_subarray_with_k_distinct(): assert max_length_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) == 4 # [1, 2, 1, 2] or [2, 1, 2, 3] assert max_length_subarray_with_k_distinct([1], 1) == 1 assert max_length_subarray_with_k_distinct([1, 2, 3, 4, 5], 5) == 5 assert max_length_subarray_with_k_distinct([1, 1, 1, 1], 1) == 4 assert max_length_subarray_with_k_distinct([1, 2, 3], 0) == 0 assert max_length_subarray_with_k_distinct([1, 2, 3, 4, 5], 3) == 3 # [1, 2, 3] or [2, 3, 4] or [3, 4, 5] assert max_length_subarray_with_k_distinct([1, 2, 1, 3, 4, 3, 5, 1, 2], 1) == 1 assert max_length_subarray_with_k_distinct([1, 1, 1, 2, 3, 2, 2], 5) == 7 arr = [i % 10 for i in range(10**5)] assert max_length_subarray_with_k_distinct(arr, 10) == 100000","solution":"def max_length_subarray_with_k_distinct(arr, k): from collections import defaultdict n = len(arr) if n == 0 or k == 0: return 0 left = 0 right = 0 max_len = 0 count = defaultdict(int) while right < n: count[arr[right]] += 1 while len(count) > k: count[arr[left]] -= 1 if count[arr[left]] == 0: del count[arr[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def longest_path_in_forest(m: int, tree_sizes: List[int]) -> int: Returns the length of the longest path in a forest of disjoint trees. Parameters: m (int): The number of trees in the forest. tree_sizes (List[int]): A list containing the number of vertices in each tree. Returns: int: The length of the longest path in the forest. >>> longest_path_in_forest(3, [3, 5, 2]) 4 >>> longest_path_in_forest(2, [10, 4]) 9","solution":"def longest_path_in_forest(m, tree_sizes): Returns the length of the longest path in a forest of disjoint trees. Parameters: m (int): The number of trees in the forest. tree_sizes (List[int]): A list containing the number of vertices in each tree. Returns: int: The length of the longest path in the forest. max_tree_size = max(tree_sizes) if tree_sizes else 0 return max_tree_size - 1 if max_tree_size > 0 else 0"},{"question":"def count_unique_countries(stamps: List[str]) -> int: Given a list of stamp identifiers, this function returns the number of unique countries. The prefix of length 2 of each stamp identifier denotes the country. >>> count_unique_countries([\\"US123\\", \\"US234\\", \\"CA456\\", \\"CA789\\", \\"JP101\\"]) 3 >>> count_unique_countries([\\"US123\\", \\"US234\\", \\"US456\\"]) 1 >>> count_unique_countries([\\"US123\\", \\"CA789\\", \\"JP101\\", \\"AU333\\"]) 4 >>> count_unique_countries([\\"US123\\", \\"us234\\", \\"CA456\\", \\"ca321\\"]) 4 >>> count_unique_countries([]) 0 >>> count_unique_countries([\\"US123\\", \\"US999\\", \\"GB123\\", \\"FR456\\", \\"FR789\\"]) 3","solution":"def count_unique_countries(stamps): Given a list of stamp identifiers, this function returns the number of unique countries. The prefix of length 2 of each stamp identifier denotes the country. unique_countries = set() for stamp in stamps: country_code = stamp[:2] unique_countries.add(country_code) return len(unique_countries)"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def assign_reviewers(N: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Assign reviewers to each employee such that no employee reviews their manager. Args: - N: The number of employees. - edges: A list of tuples where each tuple consists of two integers u and v representing an edge between employee u and employee v. Returns: A list of tuples where each tuple consists of two integers a and b representing that employee a will review the work of employee b. Example: >>> assign_reviewers(2, [(1, 2)]) [(1, 2), (2, 1)] >>> assign_reviewers(4, [(1, 2), (2, 3), (3, 4)]) [(1, 3), (2, 4), (3, 1), (4, 2)] pass # Unit test def test_assign_reviewers(): N = 2 edges = [(1, 2)] result = assign_reviewers(N, edges) assert len(result) == 2 assert result != [(1, 2), (2, 1)] N = 4 edges = [(1, 2), (2, 3), (3, 4)] result = assign_reviewers(N, edges) assert len(result) == N for a, b in result: assert a != b N = 4 edges = [(1, 2), (1, 3), (1, 4)] result = assign_reviewers(N, edges) assert len(result) == N for a, b in result: assert a != b N = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] result = assign_reviewers(N, edges) assert len(result) == N N = 10 edges = [ (1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8), (5, 9), (7, 10) ] result = assign_reviewers(N, edges) assert len(result) == N for a, b in result: assert a != b","solution":"from collections import defaultdict, deque import random def assign_reviewers(N, edges): # Construct the adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Find the managers using BFS (or DFS) managers = {1: None} # Use 1 as the root, assuming 1 always exists queue = deque([1]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if neighbor not in managers: managers[neighbor] = node queue.append(neighbor) # Construct a non-manager list (excludes direct reports) non_manager_list = {i: [] for i in range(1, N+1)} for i in range(1, N+1): for j in range(1, N+1): if i != j and managers.get(j) != i and managers.get(i) != j: non_manager_list[i].append(j) # Randomly assign reviewers ensuring no self assignment and valid assignment reviewers = [None] * (N+1) for i in range(1, N+1): for choice in non_manager_list[i]: if reviewers[choice] is None and (managers[choice] != i): reviewers[choice] = i break return [(i, reviewers[i]) for i in range(1, N+1)]"},{"question":"def smallest_diff_by_one_bit(n: int) -> int: Given a non-negative integer n, find the smallest non-negative integer that is greater than n and differs from n by exactly one bit. Args: n (int): Non-negative integer (0 ≤ n ≤ 1000) Returns: int: The smallest number greater than n which differs by exactly one bit >>> smallest_diff_by_one_bit(0) 1 >>> smallest_diff_by_one_bit(1) 2 >>> smallest_diff_by_one_bit(5) 6 >>> smallest_diff_by_one_bit(10) 11 >>> smallest_diff_by_one_bit(15) 16 >>> smallest_diff_by_one_bit(1000) 1001","solution":"def smallest_diff_by_one_bit(n): Given a non-negative integer n, find the smallest non-negative integer that is greater than n and differs from n by exactly one bit. return n + 1"},{"question":"def longest_consecutive_subsequence(n: int, array: List[int]) -> Tuple[int, List[int]]: Determine the longest subsequence such that the difference between consecutive elements is exactly 1. >>> longest_consecutive_subsequence(10, [1, 9, 3, 10, 4, 20, 2, 5, 11, 12]) (5, [1, 2, 3, 4, 5]) >>> longest_consecutive_subsequence(1, [100]) (1, [100]) >>> longest_consecutive_subsequence(5, [10, 20, 30, 40, 50]) (1, [10]) >>> longest_consecutive_subsequence(6, [3, 4, 5, 6, 7, 8]) (6, [3, 4, 5, 6, 7, 8]) >>> longest_consecutive_subsequence(7, [2, 1, 3, 4, 2, 5, 4]) (5, [1, 2, 3, 4, 5]) >>> longest_consecutive_subsequence(8, [1, 3, 4, 5, 10, 11, 12, 13]) (4, [10, 11, 12, 13])","solution":"def longest_consecutive_subsequence(n, array): # Create a set of array elements for quick lookup numbers = set(array) # Variables to store the maximum length and the starting point of the longest sequence max_length = 0 best_start = None for num in array: if num - 1 not in numbers: # If num is a potential starting point current_length = 1 while num + current_length in numbers: current_length += 1 if current_length > max_length: max_length = current_length best_start = num # Reconstruct the longest sequence longest_sequence = [i for i in range(best_start, best_start + max_length)] return max_length, longest_sequence # Example usage: n = 10 array = [1, 9, 3, 10, 4, 20, 2, 5, 11, 12] print(longest_consecutive_subsequence(n, array)) # Output will be (5, [1, 2, 3, 4, 5])"},{"question":"def count_distinct_subarrays(n: int, arr: List[int]) -> int: Find the number of distinct non-empty subarrays that satisfy the condition that every two elements in the new array are the same. Args: n (int): The number of elements in the array. arr (List[int]): The original array of integers. Returns: int: The number of distinct non-empty subarrays modulo 1000000007. >>> count_distinct_subarrays(5, [1, 2, 2, 1, 2]) 5 >>> count_distinct_subarrays(4, [1, 2, 3, 4]) 4 >>> count_distinct_subarrays(3, [7, 7, 7]) 3 >>> count_distinct_subarrays(10**6, [1]*10**6) 1000000007 >>> count_distinct_subarrays(6, [1, 2, 2, 3, 3, 1]) 6 >>> count_distinct_subarrays(1, [1]) 1 pass","solution":"def count_distinct_subarrays(n, arr): MODULO = 1000000007 # Dictionary to store the frequency of elements freq_map = {} for num in arr: if num in freq_map: freq_map[num] += 1 else: freq_map[num] = 1 result = 0 # Calculate the number of single element subarrays for count in freq_map.values(): result += count result %= MODULO return result"},{"question":"def minimum_deactivation_roads(n, m, roads): Compute the minimum number of roads that need to be deactivated so that the remaining roads form a tree. >>> minimum_deactivation_roads(4, 3, [(1, 2), (2, 3), (3, 4)]) == 0 >>> minimum_deactivation_roads(4, 5, [(1, 2), (1, 3), (2, 3), (3, 4), (4, 1)]) == 2 >>> minimum_deactivation_roads(4, 2, [(1, 2), (2, 3)]) == -1 >>> minimum_deactivation_roads(4, 0, []) == -1 >>> minimum_deactivation_roads(4, 3, [(1, 2), (4, 3), (3, 2)]) == 0 >>> minimum_deactivation_roads(4, 6, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3), (2, 4)]) == 3 pass","solution":"def minimum_deactivation_roads(n, m, roads): if m < (n - 1): return -1 return m - (n - 1)"},{"question":"def number_of_forests(n, edges): Determines the number of distinct forests that can be formed by removing exactly one edge. Parameters: n (int): Number of nodes. edges (list of tuples): List of edges where each tuple (u, v) represents an edge between nodes u and v. Returns: int: Number of distinct forests that can be formed by removing exactly one edge. from solution import number_of_forests def test_number_of_forests_basic(): n, edges = 5, [(1, 2), (1, 3), (2, 4), (4, 5)] assert number_of_forests(n, edges) == 4 def test_number_of_forests_min_case(): n, edges = 2, [(1, 2)] assert number_of_forests(n, edges) == 1 def test_number_of_forests_straight_line(): n, edges = 4, [(1, 2), (2, 3), (3, 4)] assert number_of_forests(n, edges) == 3 def test_number_of_forests_star_shape(): n, edges = 4, [(1, 2), (1, 3), (1, 4)] assert number_of_forests(n, edges) == 3 def test_number_of_forests_more_complex(): n, edges = 6, [(1, 2), (1, 3), (2, 4), (3, 5), (5, 6)] assert number_of_forests(n, edges) == 5","solution":"def number_of_forests(n, edges): Determines the number of distinct forests that can be formed by removing exactly one edge. Parameters: n (int): Number of nodes. edges (list of tuples): List of edges where each tuple (u, v) represents an edge between nodes u and v. Returns: int: Number of distinct forests that can be formed by removing exactly one edge. # Since any edge in a tree with n nodes and n-1 edges is a bridge, # removing any edge will increase the number of connected components by 1. return len(edges)"},{"question":"from typing import List, Tuple from collections import deque def virus_spread_time(m: int, n: int, grid: List[List[int]]) -> int: Calculate the minimum time required for the virus to spread to all healthy cells in the grid. If the virus cannot spread to certain healthy cells, return -1. >>> virus_spread_time(3, 3, [ ... [2, 1, 1], ... [1, 1, 0], ... [0, 1, 1] ... ]) 4 >>> virus_spread_time(3, 3, [ ... [2, 1, 0], ... [0, 1, 1], ... [1, 0, 1] ... ]) -1 def handle_multiple_test_cases(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Process multiple test cases and return the results for each one. >>> handle_multiple_test_cases(1, [ ... ( ... 3, 3, ... [ ... [2, 1, 1], ... [1, 1, 0], ... [0, 1, 1] ... ] ... ) ... ]) [4] >>> handle_multiple_test_cases(1, [ ... ( ... 3, 3, ... [ ... [2, 1, 0], ... [0, 1, 1], ... [1, 0, 1] ... ] ... ) ... ]) [-1]","solution":"from collections import deque def virus_spread_time(m, n, grid): # Directions for neighboring cells (left, right, upward, downward) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque() minutes = 0 healthy_cells = 0 # Initialize the queue with all infected cells and count healthy cells for i in range(m): for j in range(n): if grid[i][j] == 2: queue.append((i, j, 0)) # (x, y, time) elif grid[i][j] == 1: healthy_cells += 1 # Perform BFS to spread the virus while queue: x, y, time = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (0 <= nx < m) and (0 <= ny < n) and (grid[nx][ny] == 1): grid[nx][ny] = 2 # Mark the cell as infected queue.append((nx, ny, time + 1)) healthy_cells -= 1 minutes = max(minutes, time + 1) # If there are healthy cells remaining, return -1 if healthy_cells > 0: return -1 return minutes def handle_multiple_test_cases(t, test_cases): results = [] for test_case in test_cases: m, n, grid = test_case result = virus_spread_time(m, n, grid) results.append(result) return results"},{"question":"def expected_sums(n: int, r: int, grid: List[List[int]], changes: List[Tuple[int, int, int]]) -> List[float]: Determine the expected sum of all token values after each round. >>> expected_sums(3, 2, [[0, 1, 0], [1, 0, 1], [0, 0, 1]], [(0, 0, 1), (2, 2, 0)]) [4/9, 5/9, 4/9] >>> expected_sums(2, 1, [[1, 1], [1, 1]], [(0, 0, 0)]) [4/4, 3/4] def parse_and_run(input_str: str) -> List[float]: Parse the input and run the expected_sums function. >>> parse_and_run(\\"3 2n0 1 0n1 0 1n0 0 1n0 0 1n2 2 0\\") [4/9, 5/9, 4/9] >>> parse_and_run(\\"2 0n0 1n1 0\\") [2/4]","solution":"def expected_sums(n, r, grid, changes): expected_values = [] total_tokens = n * n current_sum = sum(sum(row) for row in grid) current_expected_value = current_sum / total_tokens expected_values.append(current_expected_value) for x, y, v in changes: current_sum -= grid[x][y] current_sum += v current_expected_value = current_sum / total_tokens expected_values.append(current_expected_value) grid[x][y] = v return expected_values def parse_and_run(input_str): lines = input_str.strip().split(\\"n\\") n, r = map(int, lines[0].split()) grid = [] changes = [] for i in range(1, n + 1): grid.append(list(map(int, lines[i].split()))) for i in range(n + 1, n + 1 + r): changes.append(tuple(map(int, lines[i].split()))) return expected_sums(n, r, grid, changes)"},{"question":"from typing import List, Dict def countDistinctElements(arr: List[int], k: int) -> Dict[int, int]: Given an integer array and an integer k, determine how many times each of the distinct numbers appears in the array without fully sorting the array. It is guaranteed that there will be at most k distinct numbers in the array after sorting. Parameters: arr (List[int]): The input array of integers. k (int): The maximum number of distinct elements in the array after sorting. Returns: Dict[int, int]: A dictionary where the keys are the distinct elements in the array, and the values are the counts of each element. Examples: >>> countDistinctElements([4, 2, 2, 8, 4, 2, 8, 3, 3, 4], 3) {4: 3, 2: 3, 8: 2, 3: 2} >>> countDistinctElements([1], 1) {1: 1} pass def test_count_distinct_elements_basic(): arr = [4, 2, 2, 8, 4, 2, 8, 3, 3, 4] k = 3 result = countDistinctElements(arr, k) expected = {4: 3, 2: 3, 8: 2, 3: 2} assert result == expected def test_count_distinct_elements_single_element(): arr = [1] k = 1 result = countDistinctElements(arr, k) expected = {1: 1} assert result == expected def test_count_distinct_elements_all_unique(): arr = [1, 2, 3, 4, 5] k = 5 result = countDistinctElements(arr, k) expected = {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} assert result == expected def test_count_distinct_elements_some_duplicates(): arr = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] k = 4 result = countDistinctElements(arr, k) expected = {1: 1, 2: 2, 3: 3, 4: 4} assert result == expected def test_count_distinct_elements_negative_numbers(): arr = [-1, -2, -2, -3, -3, -3] k = 3 result = countDistinctElements(arr, k) expected = {-1: 1, -2: 2, -3: 3} assert result == expected def test_count_distinct_elements_large_input(): arr = [i % 5 for i in range(10000)] k = 5 result = countDistinctElements(arr, k) expected = {0: 2000, 1: 2000, 2: 2000, 3: 2000, 4: 2000} assert result == expected","solution":"from typing import List, Dict from collections import Counter def countDistinctElements(arr: List[int], k: int) -> Dict[int, int]: This function returns a dictionary containing the count of each distinct element in the input array. It assumes that the array could have up to k distinct elements after sorting. return dict(Counter(arr))"},{"question":"def find_min_difficulty(tasks): Finds the minimum sum of difficulties for a set of tasks that contains at least one task of each type 'a', 'b', and 'c'. >>> find_min_difficulty([(10, 'a'), (20, 'b'), (30, 'c'), (40, 'a'), (25, 'b')]) 60 >>> find_min_difficulty([(10, 'a'), (20, 'a'), (30, 'a'), (40, 'a'), (25, 'a')]) -1 >>> find_min_difficulty([(1, 'a'), (2, 'b'), (3, 'c')]) 6 >>> find_min_difficulty([(1, 'a'), (2, 'b')]) -1 >>> find_min_difficulty([(100000, 'a'), (99999, 'b'), (99998, 'c'), (100000, 'a'), (99997, 'b'), (99996, 'c')]) 299993 pass def parse_input(input_str): Parses the input string and returns a list of tasks. >>> parse_input(\\"5n10 an20 bn30 cn40 an25 b\\") [(10, 'a'), (20, 'b'), (30, 'c'), (40, 'a'), (25, 'b')] >>> parse_input(\\"3n1 an2 bn3 c\\") [(1, 'a'), (2, 'b'), (3, 'c')] >>> parse_input(\\"2n1 an2 b\\") [(1, 'a'), (2, 'b')] pass","solution":"def find_min_difficulty(tasks): Finds the minimum sum of difficulties for a set of tasks that contains at least one task of each type 'a', 'b', and 'c'. Parameters: tasks (list of tuples): List of tuples where each tuple contains the difficulty and the type of task. Returns: int: The minimum sum of difficulties if a set is found, otherwise -1. # Initialize dictionaries to store the minimum difficulty for each type type_min_difficulty = {'a': float('inf'), 'b': float('inf'), 'c': float('inf')} # Populate the dictionaries with the minimum difficulty for each type for difficulty, task_type in tasks: if task_type in type_min_difficulty: type_min_difficulty[task_type] = min(type_min_difficulty[task_type], difficulty) # Check if we have at least one task of each type if all(value != float('inf') for value in type_min_difficulty.values()): # Calculate the minimum sum of difficulties return type_min_difficulty['a'] + type_min_difficulty['b'] + type_min_difficulty['c'] else: return -1 # Input conversion function def parse_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) tasks = [(int(line.split()[0]), line.split()[1]) for line in lines[1:]] return tasks"},{"question":"def largest_number(arr: List[int]) -> str: Given an array of non-negative integers, rearranges them to form the largest possible number. >>> largest_number([3, 30, 34, 5, 9]) '9534330' >>> largest_number([1, 20, 23, 4, 8]) '8423201' >>> largest_number([0, 0, 0, 0]) '0' >>> largest_number([5]) '5' >>> largest_number([10, 2]) '210' >>> largest_number([2, 20, 20]) '22020' >>> largest_number([1, 1000, 100, 10]) '1101001000'","solution":"from functools import cmp_to_key def compare(x, y): Comparator function to decide the order of strings x and y. if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_number(arr): Given an array of non-negative integers, rearranges them to form the largest possible number. str_arr = list(map(str, arr)) str_arr.sort(key=cmp_to_key(compare)) result = ''.join(str_arr) return str(int(result)) # Converts to int and back to str to remove leading zeros # Example Usage # largest_number([3, 30, 34, 5, 9]) -> '9534330'"},{"question":"def average_retention_rate(n: int, probabilities: List[float]) -> float: Calculates the average expected retention rate after all steps in the campaign. Parameters: n (int): the number of steps in the campaign. probabilities (list of float): the retention probabilities for each step. Returns: float: the average expected retention rate, rounded to six decimal places. pass # Example usage: # n = 3 # probabilities = [0.8, 0.7, 0.5] # print(average_retention_rate(n, probabilities)) # Output: 0.280000 # Test cases def test_example_case(): assert average_retention_rate(3, [0.8, 0.7, 0.5]) == 0.280000 def test_single_step(): assert average_retention_rate(1, [0.6]) == 0.600000 def test_all_perfect_retention(): assert average_retention_rate(4, [1.0, 1.0, 1.0, 1.0]) == 1.000000 def test_all_no_retention(): assert average_retention_rate(5, [0.0, 0.0, 0.0, 0.0, 0.0]) == 0.000000 def test_mixed_retention(): assert average_retention_rate(4, [0.9, 0.8, 0.7, 0.6]) == 0.302400 def test_edge_case_max_steps(): probabilities = [0.5] * 100 expected_value = 0.5 ** 100 assert average_retention_rate(100, probabilities) == round(expected_value, 6) def test_edge_case_min_steps(): assert average_retention_rate(1, [0.0]) == 0.000000","solution":"def average_retention_rate(n, probabilities): Calculates the average expected retention rate after all steps in the campaign. Parameters: n (int): the number of steps in the campaign. probabilities (list of float): the retention probabilities for each step. Returns: float: the average expected retention rate, rounded to six decimal places. retention_rate = 1.0 for p in probabilities: retention_rate *= p return round(retention_rate, 6) # Example usage: # n = 3 # probabilities = [0.8, 0.7, 0.5] # print(average_retention_rate(n, probabilities)) # Output: 0.280000"},{"question":"def find_pair_with_sum(arr, target): Determines if there are any two distinct elements in the array that add up to the target sum. Returns a tuple of the pair of elements if such a pair exists, otherwise returns None. >>> find_pair_with_sum([1, 2, 3, 4, 5], 9) (4, 5) # or (5, 4) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None >>> find_pair_with_sum([-1, 2, 3, -4, 5], 1) (-1, 2) # or (2, -1) >>> find_pair_with_sum([3, 3, 4, 7], 6) (3, 3) # function body","solution":"def find_pair_with_sum(arr, target): Determines if there are any two distinct elements in the array that add up to the target sum. Returns a tuple of the pair of elements if such a pair exists, otherwise returns None. seen = set() for number in arr: complement = target - number if complement in seen: return (number, complement) seen.add(number) return None"},{"question":"def longest_common_word_sequence(title1: str, title2: str) -> int: Returns the length of the longest common word sequence between two book titles. >>> longest_common_word_sequence(\\"the best days of my life\\", \\"days of our lives\\") == 2 >>> longest_common_word_sequence(\\"the cat in the hat\\", \\"a dog in a log\\") == 1 >>> longest_common_word_sequence(\\"life is beautiful\\", \\"life is beautiful\\") == 3 >>> longest_common_word_sequence(\\"the quick brown fox\\", \\"the quick red fox\\") == 2 >>> longest_common_word_sequence(\\"one word\\", \\"word another one\\") == 1 >>> longest_common_word_sequence(\\"\\", \\"\\") == 0 >>> longest_common_word_sequence(\\"nothing here\\", \\"\\") == 0 >>> longest_common_word_sequence(\\"\\", \\"just some words\\") == 0 >>> longest_common_word_sequence(\\"a tale of two cities\\", \\"a tale of two cities\\") == 5 >>> longest_common_word_sequence(\\"completely different\\", \\"not matching at all\\") == 0","solution":"def longest_common_word_sequence(title1, title2): Returns the length of the longest common word sequence between two book titles. words1 = title1.split() words2 = title2.split() len1, len2 = len(words1), len(words2) # Creating a 2D array to store lengths of longest common suffixes of sequences dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_length = 0 for i in range(1, len1 + 1): for j in range(1, len2 + 1): if words1[i - 1] == words2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) else: dp[i][j] = 0 return max_length"},{"question":"def decrypt_string(k: int, s: str) -> str: Decrypts an encoded string s using the key k. >>> decrypt_string(3, 'khoor') 'hello' >>> decrypt_string(5, 'mjqqt') 'hello' >>> decrypt_string(3, 'abc') 'xyz' >>> decrypt_string(1, 'b') 'a' >>> decrypt_string(24, 'a') 'c' >>> decrypt_string(1, 'bcdefghijklmnopqrstuvwxyza') 'abcdefghijklmnopqrstuvwxyz' >>> decrypt_string(25, 'a') 'b' >>> decrypt_string(25, 'z') 'a' >>> decrypt_string(1, 'a') 'z' :param k: The key used for encoding, an integer in range 1 to 25 :param s: The encoded string consisting of lowercase letters only :return: The original decrypted string","solution":"def decrypt_string(k, s): Decrypts an encoded string s using the key k. Parameters: k (int): The key used for encoding. s (str): The encoded string consisting of lowercase letters. Returns: str: The original decrypted string. decrypted_string = [] for char in s: # Calculate the original character position before the shift original_position = (ord(char) - ord('a') - k) % 26 original_char = chr(original_position + ord('a')) decrypted_string.append(original_char) return ''.join(decrypted_string)"},{"question":"def paving_operations(n, m, edges): A city is represented as an undirected connected graph with \`n\` nodes (representing intersections) and \`m\` edges (representing roads). Each road connects two different nodes and has a positive integer length. You are tasked with initiating a series of paving operations to throw out certain roads from the map and pave new roads instead with potentially different lengths. The roads you pave should ensure that the minimum spanning tree (MST) of the graph changes as little as possible with respect to the original graph. A crucial aspect of this task is that the resulting graph must remain connected, and the sum of the lengths of the edges in the resulting MST should be minimized. - You need to decide how many paving operations \`k\` you will perform (0 ≤ k ≤ m). - For each selected paving operation, you will output the edges you choose to remove and the new edges you will introduce. Args: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (list of tuples): Each tuple (u, v, w) represents an edge in the graph with nodes u, v and weight w. Returns: k (int): The number of paving operations you choose to perform. operations (list of tuples): Each tuple (a, b, c, d) represents a paving operation with nodes a, b of the removed edge and nodes c, d of the new edge. Example: >>> paving_operations(4, 5, [(1, 2, 5), (2, 3, 10), (3, 4, 1), (4, 1, 8), (2, 4, 3)]) (1, [(2, 3, 1, 3)]) from solution import paving_operations def test_case_1(): n = 4 m = 5 edges = [ (1, 2, 5), (2, 3, 10), (3, 4, 1), (4, 1, 8), (2, 4, 3) ] k, operations = paving_operations(n, m, edges) assert k == 0 assert operations == [] def test_case_2(): n = 2 m = 1 edges = [ (1, 2, 1) ] k, operations = paving_operations(n, m, edges) assert k == 0 assert operations == [] def test_case_3(): n = 3 m = 3 edges = [ (1, 2, 2), (2, 3, 3), (3, 1, 1) ] k, operations = paving_operations(n, m, edges) assert k == 0 assert operations == [] def test_case_4(): n = 5 m = 6 edges = [ (1, 2, 1), (2, 3, 2), (2, 4, 3), (1, 5, 5), (3, 5, 4), (4, 5, 7) ] k, operations = paving_operations(n, m, edges) assert k == 0 assert operations == []","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): result = [] i, e = 0, 0 edges = sorted(edges, key=lambda item: item[2]) parent, rank = [], [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) return result def paving_operations(n, m, edges): mst = kruskal(n, edges) initial_mst_weight = sum([w for u, v, w in mst]) # Placeholder for a solution to keep the MST minimal change, not implemented yet k = 0 # No edges are being paved (0 operations) return k, []"},{"question":"def trap_rain_water(elevations: List[int]) -> int: Calculate the total amount of water that can be trapped between the elevations. :param elevations: List[int] - List of integers representing the elevation of each point along the trail. :return: int - Total amount of water that can be trapped. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9 >>> trap_rain_water([0]) 0 >>> trap_rain_water([5]) 0 >>> trap_rain_water([0, 1, 2, 3, 4]) 0 >>> trap_rain_water([4, 3, 2, 1, 0]) 0 >>> trap_rain_water([3, 3, 3, 3, 3]) 0 >>> trap_rain_water([2, 2, 2, 2, 2]) 0","solution":"def trap_rain_water(elevations): Calculate the total amount of water that can be trapped between the elevations. :param elevations: List[int] - List of integers representing the elevation of each point along the trail. :return: int - Total amount of water that can be trapped. if not elevations: return 0 n = len(elevations) left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevations[i]) right_max[n - 1] = elevations[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevations[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - elevations[i] return water_trapped"},{"question":"class BankSystem: def __init__(self): Initialize the banking system with an empty dictionary of accounts. self.accounts = {} def create(self, user_id: str): Creates a new account for the user with the given user_ID. pass def deposit(self, user_id: str, amount: int): Deposits the specified amount into the user’s account. pass def withdraw(self, user_id: str, amount: int): Withdraws the specified amount from the user’s account, if possible. pass def balance(self, user_id: str): Returns the current balance of the user's account, or \\"ERROR\\" if the user does not exist. pass def execute_commands(self, commands: List[str]) -> List[Union[int, str]]: Executes a list of commands, returning the result of each BALANCE command. results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"CREATE\\": self.create(parts[1]) elif action == \\"DEPOSIT\\": self.deposit(parts[1], int(parts[2])) elif action == \\"WITHDRAW\\": self.withdraw(parts[1], int(parts[2])) elif action == \\"BALANCE\\": result = self.balance(parts[1]) results.append(result) return results # Unit tests def test_create_account(): bank = BankSystem() bank.execute_commands([\\"CREATE Alice\\"]) assert bank.balance(\\"Alice\\") == 0 def test_deposit_funds(): bank = BankSystem() bank.execute_commands([\\"CREATE Alice\\", \\"DEPOSIT Alice 100\\"]) assert bank.balance(\\"Alice\\") == 100 def test_withdraw_funds(): bank = BankSystem() bank.execute_commands([\\"CREATE Alice\\", \\"DEPOSIT Alice 100\\", \\"WITHDRAW Alice 50\\"]) assert bank.balance(\\"Alice\\") == 50 def test_withdraw_insufficient_funds(): bank = BankSystem() bank.execute_commands([\\"CREATE Alice\\", \\"DEPOSIT Alice 100\\", \\"WITHDRAW Alice 150\\"]) assert bank.balance(\\"Alice\\") == 100 def test_balance_of_nonexistent_user(): bank = BankSystem() results = bank.execute_commands([\\"BALANCE Bob\\"]) assert results == [\\"ERROR\\"] def test_deposit_to_nonexistent_user(): bank = BankSystem() bank.execute_commands([\\"DEPOSIT Bob 50\\"]) results = bank.execute_commands([\\"BALANCE Bob\\"]) assert results == [\\"ERROR\\"] def test_withdraw_from_nonexistent_user(): bank = BankSystem() bank.execute_commands([\\"WITHDRAW Bob 50\\"]) results = bank.execute_commands([\\"BALANCE Bob\\"]) assert results == [\\"ERROR\\"] def test_mixed_operations(): bank = BankSystem() commands = [ \\"CREATE Alice\\", \\"DEPOSIT Alice 100\\", \\"BALANCE Alice\\", \\"WITHDRAW Alice 50\\", \\"BALANCE Alice\\", \\"WITHDRAW Alice 60\\", \\"BALANCE Alice\\", \\"CREATE Bob\\", \\"BALANCE Bob\\", \\"DEPOSIT Bob 200\\", \\"BALANCE Bob\\", \\"WITHDRAW Charlie 10\\", \\"BALANCE Charlie\\" ] results = bank.execute_commands(commands) expected = [100, 50, 50, 0, 200, \\"ERROR\\"] assert results == expected","solution":"class BankSystem: def __init__(self): self.accounts = {} def create(self, user_id): if user_id not in self.accounts: self.accounts[user_id] = 0 def deposit(self, user_id, amount): if user_id in self.accounts: self.accounts[user_id] += amount def withdraw(self, user_id, amount): if user_id in self.accounts and self.accounts[user_id] >= amount: self.accounts[user_id] -= amount def balance(self, user_id): if user_id in self.accounts: return self.accounts[user_id] return \\"ERROR\\" def execute_commands(self, commands): results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"CREATE\\": self.create(parts[1]) elif action == \\"DEPOSIT\\": self.deposit(parts[1], int(parts[2])) elif action == \\"WITHDRAW\\": self.withdraw(parts[1], int(parts[2])) elif action == \\"BALANCE\\": result = self.balance(parts[1]) results.append(result) return results"},{"question":"def min_fuel(n: int, k: int, a: List[int]) -> int: Returns the minimum amount of fuel required to make exactly k round trips to the delivery points. :param n: Number of delivery points :param k: Number of round trips required :param a: List of integers representing fuel required for round trips to each delivery point :return: Minimum fuel required to make exactly k round trips >>> min_fuel(5, 3, [4, 8, 6, 2, 9]) 12 >>> min_fuel(4, 2, [5, 5, 5, 5]) 10 >>> min_fuel(3, 1, [7, 3, 8]) 3 >>> min_fuel(6, 4, [1, 10, 100, 1000, 10000, 100000]) 1111 >>> min_fuel(5, 3, [1000000000, 999999999, 999999998, 1000000001, 999999997]) 2999999994 >>> min_fuel(4, 4, [5, 15, 10, 20]) 50 >>> min_fuel(1, 1, [1]) 1 >>> min_fuel(3, 2, [0, 0, 0]) 0","solution":"def min_fuel(n, k, a): Returns the minimum amount of fuel required to make exactly k round trips to the delivery points. :param n: Number of delivery points :param k: Number of round trips required :param a: List of integers representing fuel required for round trips to each delivery point :return: Minimum fuel required to make exactly k round trips # Sort the list of fuel requirements in ascending order a.sort() # Sum the first k elements of the sorted list to get the minimum fuel min_fuel_required = sum(a[:k]) return min_fuel_required"},{"question":"def determine_winner(n: int, m: int) -> str: Determines the winner of the game given the dimensions of the grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: str: The name of the winner (\\"Alice\\" or \\"Bob\\"). >>> determine_winner(3, 3) \\"Alice\\" >>> determine_winner(2, 2) \\"Bob\\" >>> determine_winner(1, 1) \\"Alice\\" pass # Implement the logic to determine the winner # Unit tests def test_Alice_wins_odd_dimensions(): assert determine_winner(3, 3) == \\"Alice\\" assert determine_winner(1, 3) == \\"Alice\\" assert determine_winner(3, 1) == \\"Alice\\" assert determine_winner(5, 5) == \\"Alice\\" def test_Bob_wins_even_dimensions(): assert determine_winner(2, 2) == \\"Bob\\" assert determine_winner(4, 6) == \\"Bob\\" assert determine_winner(6, 8) == \\"Bob\\" def test_Bob_wins_mixed_dimensions(): assert determine_winner(2, 3) == \\"Bob\\" assert determine_winner(3, 2) == \\"Bob\\" assert determine_winner(4, 1) == \\"Bob\\" assert determine_winner(1, 4) == \\"Bob\\" def test_edge_cases(): assert determine_winner(1, 1) == \\"Alice\\" # Trivial grid assert determine_winner(1, 2) == \\"Bob\\" # Odd x Even assert determine_winner(2, 1) == \\"Bob\\" # Even x Odd","solution":"def determine_winner(n, m): Determines the winner of the game given the dimensions of the grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. Returns: str: The name of the winner (\\"Alice\\" or \\"Bob\\"). # Alice goes first. If both dimensions are odd, Alice wins. # Otherwise, Bob wins because he will have the last move advantage. if (n % 2 == 1) and (m % 2 == 1): return \\"Alice\\" else: return \\"Bob\\""},{"question":"def initialize_grid(n): Initialize an n x n grid with zeros. return [[0] * n for _ in range(n)] def add_to_subgrid(grid, r1, c1, r2, c2, v): Add v to all elements in the subgrid defined by its top-left corner (r1, c1) and bottom-right corner (r2, c2). for i in range(r1-1, r2): for j in range(c1-1, c2): grid[i][j] += v def sum_subgrid(grid, r1, c1, r2, c2): Query the sum of all elements in the subgrid defined by its top-left corner (r1, c1) and bottom-right corner (r2, c2). return sum(grid[i][j] for i in range(r1-1, r2) for j in range(c1-1, c2)) def process_operations(n, q, operations): Process q operations on the n x n grid and return the sum results for query operations. grid = initialize_grid(n) results = [] for operation in operations: op = operation[0] if op == 1: _, r1, c1, r2, c2, v = operation add_to_subgrid(grid, r1, c1, r2, c2, v) elif op == 2: _, r1, c1, r2, c2 = operation result = sum_subgrid(grid, r1, c1, r2, c2) results.append(result) return results import pytest def test_initialize_grid(): grid = initialize_grid(2) assert grid == [[0, 0], [0, 0]] def test_add_to_subgrid(): grid = initialize_grid(3) add_to_subgrid(grid, 1, 1, 2, 2, 10) assert grid == [ [10, 10, 0], [10, 10, 0], [0, 0, 0] ] def test_sum_subgrid(): grid = initialize_grid(3) add_to_subgrid(grid, 1, 1, 3, 3, 10) result = sum_subgrid(grid, 1, 1, 3, 3) assert result == 90 def test_process_operations(): n = 5 q = 3 operations = [ (1, 1, 1, 3, 3, 10), (2, 1, 1, 3, 3), (1, 2, 2, 5, 5, 5) ] result = process_operations(n, q, operations) assert result == [90]","solution":"def initialize_grid(n): Initialize an n x n grid with zeros. return [[0] * n for _ in range(n)] def add_to_subgrid(grid, r1, c1, r2, c2, v): Add v to all elements in the subgrid defined by its top-left corner (r1, c1) and bottom-right corner (r2, c2). for i in range(r1-1, r2): for j in range(c1-1, c2): grid[i][j] += v def sum_subgrid(grid, r1, c1, r2, c2): Query the sum of all elements in the subgrid defined by its top-left corner (r1, c1) and bottom-right corner (r2, c2). return sum(grid[i][j] for i in range(r1-1, r2) for j in range(c1-1, c2)) def process_operations(n, q, operations): Process q operations on the n x n grid and return the sum results for query operations. grid = initialize_grid(n) results = [] for operation in operations: op = operation[0] if op == 1: _, r1, c1, r2, c2, v = operation add_to_subgrid(grid, r1, c1, r2, c2, v) elif op == 2: _, r1, c1, r2, c2 = operation result = sum_subgrid(grid, r1, c1, r2, c2) results.append(result) return results"},{"question":"def min_operations_to_lex_smallest(s: str) -> int: Determine the minimum number of operations needed to transform the given string into the lexicographically smallest one. >>> min_operations_to_lex_smallest('dcbaz') 10 >>> min_operations_to_lex_smallest('a') 0 >>> min_operations_to_lex_smallest('z') 25 >>> min_operations_to_lex_smallest('abc') 3 >>> min_operations_to_lex_smallest('cba') 3","solution":"def min_operations_to_lex_smallest(s): min_ops = 0 for char in s: ops = ord(char) - ord('a') min_ops += ops return min_ops"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, adj: List[List[Tuple[int, int]]], start: int) -> List[int]: Dijkstra's algorithm to find the shortest distance from start to all other nodes. dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] # (distance, node) while pq: d, node = heapq.heappop(pq) if d > dist[node]: continue for v, length in adj[node]: if dist[node] + length < dist[v]: dist[v] = dist[node] + length heapq.heappush(pq, (dist[v], v)) return dist def find_minimum_distance_to_visit_friends(n: int, m: int, edges: List[Tuple[int, int, int]], k: int, friends: List[int]) -> int: Find the minimum distance Liz has to traverse to visit each of her friends starting from room 1 under the constraint of shortest paths. Args: n : int : the number of rooms m : int : the number of pathways edges : List[Tuple[int, int, int]] : a list containing tuples representing pathways u, v, w k : int : the number of friends friends : List[int] : list of rooms corresponding to each friend's room Returns: int : the minimum distance Liz has to traverse # Create adjacency list for the graph adj = [[] for _ in range(n + 1)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) # Calculate shortest distances from room 1 to all other rooms dist_from_start = dijkstra(n, adj, 1) # Calculate shortest distances from each friend's room to all other rooms friends_dists = {} for friend in friends: friends_dists[friend] = dijkstra(n, adj, friend) # To find the minimum distance to visit all friends from room 1, # we can treat it as a Traveling Salesman Problem for a small number of friends from itertools import permutations min_distance = float('inf') for perm in permutations(friends): distance = dist_from_start[perm[0]] for i in range(len(perm) - 1): distance += friends_dists[perm[i]][perm[i + 1]] min_distance = min(min_distance, distance) return min_distance def test_find_minimum_distance_to_visit_friends(): assert find_minimum_distance_to_visit_friends(5, 6, [ (1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 1), (3, 5, 1), (4, 5, 2) ], 3, [3, 4, 5]) == 5 # Single edge pathway with no friends assert find_minimum_distance_to_visit_friends(2, 1, [(1, 2, 5)], 1, [2]) == 5 # Multiple rooms and pathways with one friend assert find_minimum_distance_to_visit_friends(4, 4, [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10) ], 1, [4]) == 6 # Multiple friends and pathways assert find_minimum_distance_to_visit_friends(4, 5, [ (1, 2, 2), (1, 3, 1), (2, 3, 1), (2, 4, 3), (3, 4, 4) ], 2, [2, 4]) == 5 # Disconnected graph assert find_minimum_distance_to_visit_friends(4, 2, [ (1, 2, 2), (3, 4, 4) ], 1, [3]) == float('inf')","solution":"import heapq def dijkstra(n, adj, start): Dijkstra's algorithm to find the shortest distance from start to all other nodes. dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] # (distance, node) while pq: d, node = heapq.heappop(pq) if d > dist[node]: continue for v, length in adj[node]: if dist[node] + length < dist[v]: dist[v] = dist[node] + length heapq.heappush(pq, (dist[v], v)) return dist def find_minimum_distance_to_visit_friends(n, m, edges, k, friends): # Create adjacency list for the graph adj = [[] for _ in range(n + 1)] for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) # Calculate shortest distances from room 1 to all other rooms dist_from_start = dijkstra(n, adj, 1) # Calculate shortest distances from each friend's room to all other rooms friends_dists = {} for friend in friends: friends_dists[friend] = dijkstra(n, adj, friend) # To find the minimum distance to visit all friends from room 1, # we can treat it as a Traveling Salesman Problem for a small number of friends from itertools import permutations min_distance = float('inf') for perm in permutations(friends): distance = dist_from_start[perm[0]] for i in range(len(perm) - 1): distance += friends_dists[perm[i]][perm[i + 1]] min_distance = min(min_distance, distance) return min_distance"},{"question":"def isPathSum(grid, n, m, k): Determine if there exists a path from the top-left corner of the grid to the bottom-right corner such that the path sum is exactly k. Args: grid (list of list of int): The 2D grid of integers. n (int): The number of rows in the grid. m (int): The number of columns in the grid. k (int): The target path sum. Returns: str: \\"possible\\" if there exists a path with the sum equal to k, otherwise \\"impossible\\". Examples: >>> grid = [ ... [1, 3, 2], ... [1, 2, 1], ... [4, 2, 1] ... ] >>> isPathSum(grid, 3, 3, 8) 'possible' >>> grid = [ ... [1, 3, 2], ... [1, 2, 1], ... [4, 2, 1] ... ] >>> isPathSum(grid, 3, 3, 20) 'impossible'","solution":"def isPathSum(grid, n, m, k): Function to determine if there exists a path from the top-left corner of the grid to the bottom-right corner such that the path sum is exactly k. # Use Depth First Search with memoization to store the result of subproblems from functools import lru_cache @lru_cache(None) def dfs(row, col, current_sum): # Base case: If we reached the bottom-right corner if row == n - 1 and col == m - 1: return current_sum == k # Move right or down paths = [] if row + 1 < n: paths.append(dfs(row + 1, col, current_sum + grid[row + 1][col])) if col + 1 < m: paths.append(dfs(row, col + 1, current_sum + grid[row][col + 1])) return any(paths) return \\"possible\\" if dfs(0, 0, grid[0][0]) else \\"impossible\\""},{"question":"def manage_bookshelf(C: int, operations: List[str]) -> List[int]: Manages the bookshelf according to the given operations and capacity. Args: C (int): Capacity of the bookshelf. operations (list): List of operations to perform. Returns: list: List of outcomes after each operation. pass # Unit tests def test_manage_bookshelf_scenario_1(): C = 10 operations = [\\"add 5\\", \\"add 4\\", \\"add 2\\", \\"remove 4\\"] expected = [5, 9, -1, 5] assert manage_bookshelf(C, operations) == expected def test_manage_bookshelf_add_exceeds_capacity(): C = 5 operations = [\\"add 3\\", \\"add 3\\"] expected = [3, -1] assert manage_bookshelf(C, operations) == expected def test_manage_bookshelf_remove_nonexistent_book(): C = 8 operations = [\\"add 5\\", \\"remove 3\\"] expected = [5, -1] assert manage_bookshelf(C, operations) == expected def test_manage_bookshelf_add_and_remove_success(): C = 15 operations = [\\"add 5\\", \\"add 7\\", \\"remove 5\\", \\"add 6\\"] expected = [5, 12, 7, 13] assert manage_bookshelf(C, operations) == expected def test_manage_bookshelf_all_add_operations_fail(): C = 0 operations = [\\"add 1\\", \\"add 2\\"] expected = [-1, -1] assert manage_bookshelf(C, operations) == expected","solution":"def manage_bookshelf(C, operations): Manages the bookshelf according to the given operations and capacity. Args: C (int): Capacity of the bookshelf. operations (list): List of operations to perform. Returns: list: List of outcomes after each operation. total_width = 0 widths = [] results = [] for operation in operations: command, value = operation.split() value = int(value) if command == \\"add\\": if total_width + value <= C: total_width += value widths.append(value) results.append(total_width) else: results.append(-1) elif command == \\"remove\\": if value in widths: total_width -= value widths.remove(value) results.append(total_width) else: results.append(-1) return results"},{"question":"def is_valid_brackets(sequence: str) -> str: Determines if the input sequence of brackets is valid. :param sequence: A string containing the sequence of brackets. :return: \\"YES\\" if the sequence is valid, otherwise \\"NO\\" >>> is_valid_brackets(\\"()\\") == \\"YES\\" >>> is_valid_brackets(\\"({[]})\\") == \\"YES\\" >>> is_valid_brackets(\\"{[()()]}\\") == \\"YES\\" >>> is_valid_brackets(\\"({[)})\\") == \\"NO\\"","solution":"def is_valid_brackets(sequence: str) -> str: Determines if the input sequence of brackets is valid. :param sequence: A string containing the sequence of brackets. :return: \\"YES\\" if the sequence is valid, otherwise \\"NO\\" # Stack to keep track of the opening brackets stack = [] # Dictionary to match opening and closing brackets bracket_map = {')': '(', ']': '[', '}': '{'} for char in sequence: if char in bracket_map: # Pop the topmost element from the stack if it is not empty, otherwise use a dummy value top_element = stack.pop() if stack else '#' # Check if the popped element matches the mapping for the current closing bracket if bracket_map[char] != top_element: return \\"NO\\" else: # It is an opening bracket, push onto the stack stack.append(char) # If the stack is empty, all opening brackets were matched return \\"YES\\" if not stack else \\"NO\\""},{"question":"from typing import List def longest_non_decreasing_subsequence(arr: List[int]) -> int: Returns the length of the longest non-decreasing subsequence in the array. >>> longest_non_decreasing_subsequence([1, 3, 2, 3, 4, 8]) == 5 >>> longest_non_decreasing_subsequence([5]) == 1 >>> longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_non_decreasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_non_decreasing_subsequence([3, 3, 4, 2, 3, 5, 5, 6]) == 6 >>> longest_non_decreasing_subsequence([2, 2, 2, 2, 2]) == 5","solution":"def longest_non_decreasing_subsequence(arr): Returns the length of the longest non-decreasing subsequence in the array. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] >= arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def find_single_element(nums: List[int]) -> int: Given an array where every element except one appears exactly three times, find the element that appears only once. >>> find_single_element([2, 2, 3, 2]) 3 >>> find_single_element([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def find_single_element(nums): Given an array where every element except one appears exactly three times, find the element that appears only once. ones, twos = 0, 0 for num in nums: # First appearance: # add num to ones # don't add to twos because of the first appearance in ones # Second appearance: # remove num from ones # add num to twos because of the second appearance in twos # Third appearance: # don't add to ones # remove num from twos because of the third appearance in twos ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"from typing import List, Tuple def min_operations_to_ones(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations needed to make the entire list contain only the integer 1. If it is impossible, return -1 for that test case. Args: test_cases (List[Tuple[int, List[int]]]): List of test cases, where each test case is a tuple containing an integer k and a list of k integers. Returns: List[int]: List of integers representing the minimum number of operations for each test case. Examples: >>> min_operations_to_ones([(3, [2, 3, 6]), (2, [1, 1])]) [-1, 0] >>> min_operations_to_ones([(3, [1, 2, 3])]) [2]","solution":"def min_operations_to_ones(test_cases): results = [] for case in test_cases: k, lst = case # If all elements are already 1, no operations are needed if all(x == 1 for x in lst): results.append(0) continue # If there's at least one zero in the list, it's impossible if any(x == 0 for x in lst): results.append(-1) continue # Check if there are any 1s already count_of_ones = lst.count(1) if count_of_ones > 0: # If there is at least one '1' it makes transformation easier results.append(k - count_of_ones) else: # Other than 1, it's basically impossible to turn non-1 elements to 1 results.append(-1) return results"},{"question":"from typing import List def find_combinations(nums: List[int], target: int) -> List[List[int]]: Design a function that takes a list of integers and a target integer, and returns all unique combinations of integers from the list that add up exactly to the target. >>> find_combinations([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> find_combinations([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] pass","solution":"def find_combinations(nums, target): def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue backtrack(i + 1, path + [nums[i]], target - nums[i]) nums.sort() result = [] backtrack(0, [], target) return result"},{"question":"from typing import List, Tuple def recent_unique_transactions(n: int, k: int, transactions: List[str]) -> Tuple[int, List[str]]: Determine the list of k most recent unique book transactions. Args: n: Number of transactions k: Maximum number of recent unique transactions to show transactions: List of transaction strings in the form \\"borrow id\\" or \\"return id\\" Returns: Tuple containing: - An integer representing the number of unique book transactions shown - A list of strings representing the most recent unique transactions in order Example: >>> recent_unique_transactions(7, 3, [\\"borrow 1\\", \\"borrow 2\\", \\"return 1\\", \\"borrow 3\\", \\"borrow 1\\", \\"return 3\\", \\"borrow 2\\"]) (3, [\\"borrow 2\\", \\"return 3\\", \\"borrow 1\\"]) >>> recent_unique_transactions(5, 2, [\\"borrow 1\\", \\"borrow 2\\", \\"borrow 3\\", \\"borrow 4\\", \\"borrow 5\\"]) (2, [\\"borrow 5\\", \\"borrow 4\\"]) >>> recent_unique_transactions(4, 3, [\\"borrow 1\\", \\"borrow 1\\", \\"borrow 1\\", \\"borrow 1\\"]) (1, [\\"borrow 1\\"]) >>> recent_unique_transactions(6, 2, [\\"borrow 1\\", \\"borrow 2\\", \\"return 1\\", \\"return 2\\", \\"borrow 1\\", \\"borrow 3\\"]) (2, [\\"borrow 3\\", \\"borrow 1\\"]) >>> recent_unique_transactions(3, 5, [\\"borrow 1\\", \\"borrow 2\\", \\"return 1\\"]) (3, [\\"return 1\\", \\"borrow 2\\", \\"borrow 1\\"])","solution":"def recent_unique_transactions(n, k, transactions): transaction_dict = {} transaction_order = [] for trans in transactions: if trans in transaction_dict: transaction_order.remove(trans) transaction_order.append(trans) transaction_dict[trans] = 1 if len(transaction_order) > k: removed = transaction_order.pop(0) del transaction_dict[removed] result = transaction_order[-k:] result.reverse() return len(result), result"},{"question":"def minimize_final_element(arr: List[int]) -> int: Determine the smallest possible final element you can achieve after any number of moves. >>> minimize_final_element([1, 2, 3, 4]) 4 >>> minimize_final_element([1, 100]) 101","solution":"def minimize_final_element(arr): Returns the smallest possible final element after any number of moves, where in each move you remove any two elements and replace them with their sum. if len(arr) == 2: return sum(arr) return max(arr)"},{"question":"def play_game(n: int, m: int, grid: List[List[int]]) -> Union[str, Tuple[str, int, int, int, int]]: Determine if Dave can win the game with optimal play and output the first move. >>> play_game(3, 3, [[0, 1, 0], [0, 1, 0], [0, 0, 0]]) 'WIN', 2, 2, 2, 1 >>> play_game(2, 2, [[1, 1], [1, 1]]) 'LOSE' >>> play_game(4, 4, [[0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0]]) 'WIN' >>> play_game(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 'LOSE' >>> play_game(3, 3, [[1, 0, 1], [0, 0, 0], [1, 0, 1]]) 'WIN'","solution":"def play_game(n, m, grid): moves = [(-1, 0), (1, 0), (0, -1), (0, 1)] def can_move(x, y): for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0: return True return False for i in range(n): for j in range(m): if grid[i][j] == 1 and can_move(i, j): for dx, dy in moves: nx, ny = i + dx, j + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0: return \\"WIN\\", i+1, j+1, nx+1, ny+1 return \\"LOSE\\" # Example usage: n = 3 m = 3 grid = [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ] result = play_game(n, m, grid) print(result) # Expected output: WIN, 2, 2, 2, 1"},{"question":"import heapq def dijkstra(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Returns the length of the shortest path from city s to city t using Dijkstra's algorithm. If there is no path, returns -1. >>> dijkstra(5, 6, [(1, 2, 10), (1, 3, 5), (2, 3, 2), (3, 4, 3), (4, 5, 1), (2, 5, 15)], 1, 5) == 9 True >>> dijkstra(4, 2, [(1, 2, 5), (3, 4, 7)], 1, 4) == -1 True >>> dijkstra(1, 0, [], 1, 1) == 0 True >>> dijkstra(6, 7, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 5), (5, 6, 3), (4, 6, 1)], 1, 6) == 10 True >>> dijkstra(5, 6, [(1, 2, 3), (2, 3, 4), (1, 3, 7), (1, 4, 2), (4, 5, 3), (3, 5, 1)], 1, 5) == 5 True","solution":"import heapq def dijkstra(n, m, edges, s, t): Returns the length of the shortest path from city s to city t using Dijkstra's algorithm. If there is no path, returns -1. graph = [[] for _ in range(n + 1)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) dist = [float('inf')] * (n + 1) dist[s] = 0 priority_queue = [(0, s)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist[t] if dist[t] != float('inf') else -1"},{"question":"from typing import List def process_operations(p: int, operations: List[List[int]]) -> List[int]: Process a list of operations and maintain a dynamic array with a unique median. Each element of operations is a list where the first element is the operation type (1 or 2). - If the first element is 1, the second element is the integer to be inserted into the array. - If the first element is 2, find and output the median of the current array. Parameters: - p: integer, the number of operations. - operations: list of operations to be processed. Returns: A list of medians obtained after performing all \\"2\\" type operations. Examples: >>> process_operations(6, [[1, 5], [1, 10], [2], [1, 7], [2], [1, 2]]) [5, 7] >>> process_operations(3, [[1, 10], [1, 15], [2]]) [10] pass def test_process_operations_example1(): p = 6 operations = [ [1, 5], [1, 10], [2], [1, 7], [2], [1, 2] ] assert process_operations(p, operations) == [5, 7] def test_process_operations_example2(): p = 3 operations = [ [1, 10], [1, 15], [2] ] assert process_operations(p, operations) == [10] def test_process_operations_single_median(): p = 7 operations = [ [1, 3], [1, 6], [1, 7], [2], [1, 9], [1, 10], [2] ] assert process_operations(p, operations) == [6, 7] def test_process_operations_all_inserts(): p = 5 operations = [ [1, 1], [1, 2], [1, 3], [1, 4], [1, 5] ] assert process_operations(p, operations) == [] def test_process_operations_all_medians(): p = 6 operations = [ [1, 3], [1, 5], [2], [1, 7], [2], [2] ] assert process_operations(p, operations) == [3, 5, 5] def test_process_operations_no_operations(): p = 0 operations = [] assert process_operations(p, operations) == []","solution":"import bisect def process_operations(p, operations): arr = [] results = [] for operation in operations: op = operation[0] if op == 1: x = operation[1] bisect.insort(arr, x) elif op == 2: mid_index = (len(arr) - 1) // 2 results.append(arr[mid_index]) return results"},{"question":"MOD = 1000000007 def count_ways(grid: List[List[str]], n: int, m: int) -> int: Count the number of ways to reach the bottom-right corner from the top-left corner in a grid. >>> count_ways([['.', '#', '#'], ['.', '.', '.'], ['#', '#', '.']], 3, 3) 1 >>> count_ways([['#', '#', '#'], ['.', '.', '.'], ['#', '#', '.']], 3, 3) 0 >>> count_ways([['.', '.'], ['.', '.']], 2, 2) 2 >>> count_ways([['.']], 1, 1) 1 >>> count_ways([['#', '.'], ['.', '.']], 2, 2) 0 >>> count_ways([['.', '.'], ['.', '#']], 2, 2) 0","solution":"MOD = 1000000007 def count_ways(grid, n, m): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': continue if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1] def solve(n, m, grid_lines): grid = [list(row) for row in grid_lines] return count_ways(grid, n, m)"},{"question":"from typing import List def calculate_water(heights: List[int]) -> List[int]: Calculate the amount of water each plot would hold given the heights of the plots. >>> calculate_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) [0, 0, 1, 0, 1, 2, 1, 0, 0, 1, 0, 0] >>> calculate_water([3, 0, 3]) [0, 3, 0] >>> calculate_water([1, 2, 3, 4, 5]) [0, 0, 0, 0, 0] pass","solution":"from typing import List def calculate_water(heights: List[int]) -> List[int]: if not heights: return [] n = len(heights) left_max = [0] * n right_max = [0] * n water = [0] * n # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water for i in range(n): water[i] = max(0, min(left_max[i], right_max[i]) - heights[i]) return water"},{"question":"from typing import List, Tuple def has_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determine if the undirected graph contains any cycles. >>> has_cycle(3, 3, [(1, 2), (2, 3), (3, 1)]) 'YES' >>> has_cycle(4, 2, [(1, 2), (2, 3)]) 'NO'","solution":"def has_cycle(n, m, edges): from collections import defaultdict def dfs(v, parent): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: return True return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): return \\"YES\\" return \\"NO\\""},{"question":"def rearrange_string(s: str) -> str: Rearrange the characters of the string such that no two adjacent characters are the same. If not possible, return an empty string. >>> rearrange_string('aaabbc') 'ababac' >>> rearrange_string('aaabb') 'ababa' >>> rearrange_string('aa') '' >>> rearrange_string('a') 'a' >>> rearrange_string('aabbcc') # The exact output may vary but should ensure no two adjacent characters are the same","solution":"import heapq from collections import Counter def rearrange_string(s): Rearrange the characters of the string such that no two adjacent characters are the same. If not possible, return an empty string. # Count the frequency of each character count = Counter(s) max_heap = [] # Build a max heap based on the frequency of characters for char, freq in count.items(): heapq.heappush(max_heap, (-freq, char)) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Add the most frequent character to the result result.append(char) # Since we used one instance of \`char\`, decrement its count if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update prev_char and prev_freq to the current character and its updated frequency. prev_char = char prev_freq = freq + 1 # If result length matches the original string length, we have a valid rearrangement if len(result) == len(s): return \\"\\".join(result) else: return \\"\\""},{"question":"def recommend_products(n, products, query_product_id, k): Design a recommendation system to suggest similar products based on a given product ID. Args: n (int): Number of products in the catalog. products (List[str]): Each entry is a string describing a product in the format: 'product_id product_name price category1,category2,...,categorym' query_product_id (str): The ID of the product for which recommendations are to be made. k (int): The number of top recommendations required. Returns: List[Tuple[str, int]]: A list of tuples, where each tuple contains a recommended product ID and its similarity score, sorted in descending order of similarity. If two products have the same score, they should be sorted by their product ID in lexicographical order. Examples: >>> recommend_products(5, [\\"p1 PhoneA 699.99 electronics,gadgets,smartphone\\", \\"p2 PhoneB 799.99 electronics,gadgets\\", \\"p3 TabletA 299.99 electronics,tablet\\", \\"p4 LaptopA 999.99 electronics,laptop\\", \\"p5 PhoneC 499.99 electronics,gadgets,smartphone\\"], \\"p1\\", 2) [(\\"p5\\", 3), (\\"p2\\", 2)] >>> recommend_products(4, [\\"p1 PhoneA 699.99 electronics,gadgets,smartphone\\", \\"p2 PhoneB 799.99 furniture,wooden\\", \\"p3 TabletA 299.99 clothing,kids\\", \\"p4 LaptopA 999.99 kitchen,appliances\\"], \\"p1\\", 2) []","solution":"def recommend_products(n, products, query_product_id, k): from collections import defaultdict # Parse the product catalog product_catalog = {} for product in products: parts = product.split(maxsplit=3) # Split product_id, product_name, price from categories product_id = parts[0] product_name = parts[1] # We actually don't use this price = float(parts[2]) # We actually don't use this categories = set(parts[3].split(',')) # Split categories into a set product_catalog[product_id] = categories # Find categories of the query product query_categories = product_catalog[query_product_id] # Compute similarity scores similarity_scores = [] for product_id, categories in product_catalog.items(): if product_id == query_product_id: continue similarity_score = len(query_categories.intersection(categories)) if similarity_score > 0: similarity_scores.append((product_id, similarity_score)) # Sort results primarily by similarity score (descending), secondarily by product_id (lexicographically) similarity_scores.sort(key=lambda x: (-x[1], x[0])) # Return top k results return similarity_scores[:k]"},{"question":"def island_perimeter(heights: List[List[int]]) -> int: Calculate the perimeter of the island in the given 2D grid of heights. Parameters: heights (List[List[int]]): A 2D grid where 1 represents land and 0 represents water. Returns: int: The perimeter of the island. Example: >>> heights = [ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 1, 0, 0], ... [1, 1, 0, 0] ... ] >>> island_perimeter(heights) 16 >>> heights = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> island_perimeter(heights) 4","solution":"def island_perimeter(heights): Returns the perimeter of the island represented in the grid heights. if not heights or not heights[0]: return 0 m, n = len(heights), len(heights[0]) perimeter = 0 for i in range(m): for j in range(n): if heights[i][j] == 1: # count up to 4 for all adjacent cells that are water or edge of the grid perimeter += 4 if i > 0 and heights[i-1][j] == 1: # cell above perimeter -= 2 if j > 0 and heights[i][j-1] == 1: # cell to the left perimeter -= 2 return perimeter"},{"question":"from typing import List def rearrange_string(s: str, k: int) -> str: Given a string s consisting of lowercase alphabets and a non-negative integer k, determine if the string can be rearranged so that any two adjacent characters are at least k characters apart. If such a rearrangement is possible, return the rearranged string. If not, return an empty string. >>> rearrange_string(\\"aabbcc\\", 2) 'abcabc' >>> rearrange_string(\\"aaabc\\", 3) '' from solution import rearrange_string def test_example1(): assert rearrange_string(\\"aabbcc\\", 2) == \\"abcabc\\" def test_example2(): assert rearrange_string(\\"aaabc\\", 3) == \\"\\" def test_no_restriction_k_zero(): assert rearrange_string(\\"aabbcc\\", 0) == \\"aabbcc\\" def test_single_character_string(): assert rearrange_string(\\"a\\", 1) == \\"a\\" def test_rearrangement_possible(): assert rearrange_string(\\"aaabb\\", 2) in [\\"ababa\\", \\"abbaa\\", \\"baaab\\"] def test_rearrangement_impossible(): assert rearrange_string(\\"aaabb\\", 3) == \\"\\" def test_long_string(): s = \\"aaaabbbbccccdddd\\" * 1000 k = 4 result = rearrange_string(s, k) assert len(result) == len(s) for i in range(4,len(result)): assert not (result[i] == result[i-1] == result[i-2] == result[i-3]) def test_same_character(): assert rearrange_string(\\"aaaa\\", 2) == \\"\\"","solution":"from collections import Counter, deque import heapq def rearrange_string(s, k): if k == 0: return s # no restriction on repetition count = Counter(s) max_heap = [(-cnt, char) for char, cnt in count.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: cnt, char = heapq.heappop(max_heap) result.append(char) queue.append((cnt + 1, char)) if len(queue) >= k: cnt, char = queue.popleft() if cnt < 0: heapq.heappush(max_heap, (cnt, char)) return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"from typing import List def find_unique_subsets(n: int, card_values: List[int], S: int) -> List[str]: Find all unique subsets of cards that sum up to a given value S. Each subset should not contain duplicate values and should be outputted in ascending order based on their card values. Args: n : int : Total number of cards card_values : List[int] : Values on the cards S : int : Target sum Returns: List[str] : List of subsets as strings, each card value separated by a space. If no valid subsets, returns [\\"No valid subsets\\"]. Examples: >>> find_unique_subsets(5, [1, 2, 2, 3, 4], 5) [\\"1 4\\", \\"2 3\\"] >>> find_unique_subsets(3, [1, 2, 3], 10) [\\"No valid subsets\\"]","solution":"from itertools import combinations def find_unique_subsets(n, card_values, S): def remove_duplicates(lst): Remove duplicates from a list. return list(set(lst)) card_values = remove_duplicates(card_values) card_values.sort() result = [] for i in range(1, len(card_values) + 1): for subset in combinations(card_values, i): if sum(subset) == S: result.append(subset) if not result: return [\\"No valid subsets\\"] return [' '.join(map(str, subset)) for subset in result]"},{"question":"def max_product_of_two_distinct_elements(arr: List[int]) -> int: Returns the maximum product of any two distinct elements in the array. >>> max_product_of_two_distinct_elements([1, 2, 3, 4, 5]) 20 >>> max_product_of_two_distinct_elements([10, 20, 30, 40, 50]) 2000 >>> max_product_of_two_distinct_elements([1, 3, 3, 4, 4]) 16 >>> max_product_of_two_distinct_elements([7, 1, 0, 7]) 49 >>> max_product_of_two_distinct_elements([1, 2]) 2 >>> max_product_of_two_distinct_elements([2, 3, 1]) 6 >>> max_product_of_two_distinct_elements([99, 100]) 9900 >>> max_product_of_two_distinct_elements([50, 50, 100]) 5000 >>> max_product_of_two_distinct_elements([3, 3, 3, 3]) 9","solution":"def max_product_of_two_distinct_elements(arr): Returns the maximum product of any two distinct elements in the array. # Sort the array in descending order arr.sort(reverse=True) # The maximum product would be achieved by the product of the two largest distinct elements max_product = arr[0] * arr[1] return max_product"},{"question":"def find_employee_levels(N: int, employee_manager_pairs: List[Tuple[int, int]]) -> List[int]: Determine the level of each employee in the company's hierarchy. >>> find_employee_levels(5, [(2, 1), (3, 1), (4, 2), (5, 2)]) [0, 1, 1, 2, 2] >>> find_employee_levels(3, [(2, 1), (3, 2)]) [0, 1, 2] >>> find_employee_levels(4, [(2, 1), (3, 1), (4, 1)]) [0, 1, 1, 1] >>> find_employee_levels(6, [(2, 1), (3, 2), (4, 2), (5, 3), (6, 3)]) [0, 1, 2, 2, 3, 3] >>> find_employee_levels(1, []) [0] # Your implementation here","solution":"def find_employee_levels(N, employee_manager_pairs): # Create a list to store the managers of each employee managers = [-1] * (N + 1) # Use index 1-based, managers[0] will be unused # Populate the managers array for u, v in employee_manager_pairs: managers[u] = v # Function to find the level of an employee def get_level(employee): if employee == 1: return 0 # CEO level is 0 if levels[employee] != -1: return levels[employee] # Calculate the level by going up the hierarchy levels[employee] = get_level(managers[employee]) + 1 return levels[employee] # Initialize levels array to store the level of each employee levels = [-1] * (N + 1) # Calculate level for each employee for i in range(1, N + 1): levels[i] = get_level(i) # Extract the levels from 1 to N (1-based index) result = levels[1:] return result # Example usage: N = 5 employee_manager_pairs = [(2, 1), (3, 1), (4, 2), (5, 2)] print(find_employee_levels(N, employee_manager_pairs))"},{"question":"def can_permute_to_satisfy(A: List[int], B: List[int]) -> str: Determines if there is a permutation of list B such that for every element in A, there is a corresponding element in the permuted B that makes A[i] <= B[i]. Args: A : list[int] B : list[int] Returns: str : \\"YES\\" if such a permutation exists, \\"NO\\" otherwise >>> can_permute_to_satisfy([3, 6, 7, 5], [8, 4, 5, 6]) \\"YES\\" >>> can_permute_to_satisfy([5, 10, 8], [6, 4, 2]) \\"NO\\"","solution":"def can_permute_to_satisfy(A, B): Determines if there is a permutation of list B such that for every element in A, there is a corresponding element in the permuted B that makes A[i] <= B[i]. Args: A : list[int] B : list[int] Returns: str : \\"YES\\" if such a permutation exists, \\"NO\\" otherwise A.sort() B.sort() for a, b in zip(A, B): if a > b: return \\"NO\\" return \\"YES\\""},{"question":"def can_transform_by_sorting(n: int, queries: List[Tuple[str, str]]) -> List[str]: For each query, determine if string s can be transformed into string t by sorting s's characters. Args: n : int : number of queries queries : list of tuples : each tuple contains two strings (s, t) Returns: list of str : \\"YES\\" or \\"NO\\" for each query Examples: >>> can_transform_by_sorting(3, [(\\"abc\\", \\"cab\\"), (\\"aab\\", \\"bba\\"), (\\"xyz\\", \\"xyy\\")]) ['YES', 'NO', 'NO'] pass # Unit tests def test_can_transform_by_sorting(): assert can_transform_by_sorting(3, [(\\"abc\\", \\"cab\\"), (\\"aab\\", \\"bba\\"), (\\"xyz\\", \\"xyy\\")]) == ['YES', 'NO', 'NO'] assert can_transform_by_sorting(2, [(\\"abc\\", \\"bac\\"), (\\"xyz\\", \\"zxy\\")]) == ['YES', 'YES'] assert can_transform_by_sorting(2, [(\\"a\\", \\"b\\"), (\\"abc\\", \\"abz\\")]) == ['NO', 'NO'] assert can_transform_by_sorting(1, [(\\"a\\", \\"a\\")]) == ['YES'] large_string = \\"a\\" * (10**5) assert can_transform_by_sorting(1, [(large_string, large_string)]) == ['YES'] assert can_transform_by_sorting(3, [(\\"aab\\", \\"aba\\"), (\\"xxxyyy\\", \\"xyyxxy\\"), (\\"abcd\\", \\"abdd\\")]) == ['YES', 'YES', 'NO'] def test_edge_cases(): assert can_transform_by_sorting(1, [(\\"a\\", \\"b\\")]) == ['NO'] assert can_transform_by_sorting(1, [(\\"b\\", \\"b\\")]) == ['YES'] assert can_transform_by_sorting(1, [(\\"abc\\", \\"ab\\")]) == ['NO'] assert can_transform_by_sorting(2, [(\\"aa\\", \\"aa\\"), (\\"bb\\", \\"bb\\")]) == ['YES', 'YES'] assert can_transform_by_sorting(1, [(\\"abc\\", \\"def\\")]) == ['NO']","solution":"def can_transform_by_sorting(n, queries): For each query, determine if string s can be transformed into string t by sorting s's characters. Args: n : int : number of queries queries : list of tuples : each tuple contains two strings (s, t) Returns: list of str : \\"YES\\" or \\"NO\\" for each query results = [] for s, t in queries: if sorted(s) == sorted(t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: n = 3 queries = [(\\"abc\\", \\"cab\\"), (\\"aab\\", \\"bba\\"), (\\"xyz\\", \\"xyy\\")] print(can_transform_by_sorting(n, queries)) # Output: ['YES', 'NO', 'NO']"},{"question":"import pytest # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root: TreeNode) -> int: Find the length of the longest path in the tree where all the nodes in the path have the same value. The path can be either from parent to child, or from child to child through any other nodes. Args: root (TreeNode): The root node of the binary tree. Returns: int: The length of the longest path of nodes with the same value. Examples: >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.right = TreeNode(5) >>> longestUnivaluePath(root) 2 def test_example(): root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(1) root.right.right = TreeNode(5) assert longestUnivaluePath(root) == 2 def test_single_node(): root = TreeNode(1) assert longestUnivaluePath(root) == 0 def test_no_univalue_path(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert longestUnivaluePath(root) == 0 def test_all_same_value(): root = TreeNode(1) root.left = TreeNode(1) root.right = TreeNode(1) root.left.left = TreeNode(1) root.left.right = TreeNode(1) root.right.right = TreeNode(1) assert longestUnivaluePath(root) == 4 def test_mixed_values(): root = TreeNode(1) root.left = TreeNode(4) root.right = TreeNode(5) root.left.left = TreeNode(4) root.left.right = TreeNode(4) root.right.right = TreeNode(5) assert longestUnivaluePath(root) == 2 def test_large_tree(): root = TreeNode(1) current = root # Creating a linear tree of 10 nodes, all with the same value for _ in range(9): new_node = TreeNode(1) current.right = new_node current = new_node assert longestUnivaluePath(root) == 9","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestUnivaluePath(root: TreeNode) -> int: def helper(node): nonlocal max_length if not node: return 0 left_length = helper(node.left) right_length = helper(node.right) left_arrow = right_arrow = 0 if node.left and node.left.val == node.val: left_arrow = left_length + 1 if node.right and node.right.val == node.val: right_arrow = right_length + 1 max_length = max(max_length, left_arrow + right_arrow) return max(left_arrow, right_arrow) max_length = 0 helper(root) return max_length"},{"question":"def min_moves_to_target(x1, y1, x2, y2): Determine the minimum number of moves Jill needs to reach her target position on the grid. Jill's game piece starts at point (x1, y1) and needs to move to point (x2, y2). Jill can move left or right by 1 unit, up or down by 1 unit, or diagonally in any of the four directions. Args: x1 (int): Starting x-coordinate y1 (int): Starting y-coordinate x2 (int): Target x-coordinate y2 (int): Target y-coordinate Returns: int: Minimum number of moves to reach the target position Examples: >>> min_moves_to_target(2, 3, 5, 7) 4 >>> min_moves_to_target(0, 0, 0, 0) 0 >>> min_moves_to_target(1, 1, 1, 6) 5","solution":"def min_moves_to_target(x1, y1, x2, y2): Returns the minimum number of moves Jill needs to reach the target position. # Calculate the difference in x and y coordinates dx = abs(x2 - x1) dy = abs(y2 - y1) # The minimum number of moves required is the maximum of dx and dy return max(dx, dy)"},{"question":"def min_operations_to_form_skyline(n: int, heights: List[int]) -> int: Returns the minimum number of operations required to ensure no building obstructs the view of the skyline of any of the buildings behind it when viewed from the left to the right. >>> min_operations_to_form_skyline(4, [3, 2, 5, 1]) == 2 >>> min_operations_to_form_skyline(3, [1, 3, 2]) == 0 pass # Unit Tests def test_example_1(): assert min_operations_to_form_skyline(4, [3, 2, 5, 1]) == 2 def test_example_2(): assert min_operations_to_form_skyline(3, [1, 3, 2]) == 0 def test_no_operations_needed(): assert min_operations_to_form_skyline(4, [1, 2, 3, 4]) == 0 def test_single_building(): assert min_operations_to_form_skyline(1, [5]) == 0 def test_increasing_heights(): assert min_operations_to_form_skyline(5, [2, 4, 6, 8, 10]) == 0 def test_decreasing_heights(): assert min_operations_to_form_skyline(5, [10, 8, 6, 4, 2]) == 20 def test_identical_heights(): assert min_operations_to_form_skyline(4, [3, 3, 3, 3]) == 0","solution":"def min_operations_to_form_skyline(n, heights): Returns the minimum number of operations required to ensure no building obstructs the view of the skyline of any of the buildings behind it when viewed from the left to the right. operations = 0 for i in range(n - 1): if heights[i] > heights[i + 1]: operations += heights[i] - heights[i + 1] heights[i + 1] = heights[i] return operations"},{"question":"from typing import List, Tuple def length_of_longest_unique_subarray(arr: List[int]) -> int: Find the length of the longest contiguous subarray with unique elements. >>> length_of_longest_unique_subarray([5, 1, 3, 5, 2, 3]) 4 >>> length_of_longest_unique_subarray([1, 2, 3, 4, 5]) 5 >>> length_of_longest_unique_subarray([1, 1, 1, 1]) 1 >>> length_of_longest_unique_subarray([1, 2, 1, 3, 4, 3, 3, 2]) 4 >>> length_of_longest_unique_subarray([2, 3, 4, 5, 2, 3, 4]) 4 def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: For each test case, find the length of the longest unique subarray. >>> test_cases = [ ... (6, [5, 1, 3, 5, 2, 3]), ... (5, [1, 2, 3, 4, 5]), ... ] >>> process_test_cases(2, test_cases) [4, 5] >>> test_cases = [ ... (4, [1, 1, 1, 1]), ... (8, [1, 2, 1, 3, 4, 3, 3, 2]), ... ] >>> process_test_cases(2, test_cases) [1, 4] >>> test_cases = [ ... (7, [2, 3, 4, 5, 2, 3, 4]), ... ] >>> process_test_cases(1, test_cases) [4]","solution":"def length_of_longest_unique_subarray(arr): Function to find the length of the longest contiguous subarray with unique elements. seen = set() left = 0 max_length = 0 for right in range(len(arr)): while arr[right] in seen: seen.remove(arr[left]) left += 1 seen.add(arr[right]) max_length = max(max_length, right - left + 1) return max_length def process_test_cases(t, test_cases): Process multiple test cases to find the length of the longest unique subarray for each test case. results = [] for i in range(t): n, arr = test_cases[i] results.append(length_of_longest_unique_subarray(arr)) return results"},{"question":"def shortest_path_maze(n: int, m: int, grid: List[List[int]]) -> int: Finds the shortest path in an unweighted grid maze from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1). Returns -1 if no path exists. Example usage: >>> shortest_path_maze(3, 3, [[0, 1, 0], [0, 0, 0], [0, 0, 0]]) 4 >>> shortest_path_maze(2, 2, [[0, 1], [1, 0]]) -1 from collections import deque def test_shortest_path_maze_example1(): grid = [ [0, 1, 0], [0, 0, 0], [0, 0, 0] ] assert shortest_path_maze(3, 3, grid) == 4 def test_shortest_path_maze_example2(): grid = [ [0, 1], [1, 0] ] assert shortest_path_maze(2, 2, grid) == -1 def test_shortest_path_maze_single_element_pass(): grid = [ [0] ] assert shortest_path_maze(1, 1, grid) == 0 def test_shortest_path_maze_single_element_fail(): grid = [ [1] ] assert shortest_path_maze(1, 1, grid) == -1 def test_shortest_path_maze_larger_grid(): grid = [ [0, 0, 0, 0], [1, 1, 1, 0], [0, 0, 0, 0], [0, 0, 1, 0] ] assert shortest_path_maze(4, 4, grid) == 6 def test_shortest_path_maze_no_path(): grid = [ [0, 1, 1, 1], [1, 1, 1, 0], [0, 0, 0, 0], [1, 1, 1, 0] ] assert shortest_path_maze(4, 4, grid) == -1 def test_shortest_path_maze_minimal_grid(): grid = [ [0, 0], [0, 0] ] assert shortest_path_maze(2, 2, grid) == 2","solution":"from collections import deque def shortest_path_maze(n, m, grid): Finds the shortest path in an unweighted grid maze from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1). Returns -1 if no path exists. # Directions for moving: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Check for edge cases if not grid or grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 # BFS setup queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() # Return the number of steps if the bottom-right corner is reached if row == n - 1 and col == m - 1: return steps # Explore the neighbors for dx, dy in directions: new_row, new_col = row + dx, col + dy if 0 <= new_row < n and 0 <= new_col < m and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) # Return -1 if no path exists return -1"},{"question":"from typing import List def num_distinct_areas(grid: List[List[int]]) -> int: Determines the number of distinct areas of connected empty cells in a given grid. Args: grid (List[List[int]]): N x M grid filled with 0s and 1s. Returns: int: Number of distinct areas of empty cells. >>> num_distinct_areas([ ... [0, 0, 1, 0, 0], ... [1, 0, 0, 1, 1], ... [0, 1, 1, 0, 0], ... [0, 0, 0, 0, 1] ... ]) == 3 >>> num_distinct_areas([ ... [0, 1], ... [1, 0] ... ]) == 2 >>> num_distinct_areas([ ... [0, 0], ... [0, 0] ... ]) == 1 >>> num_distinct_areas([ ... [1, 1], ... [1, 1] ... ]) == 0 >>> num_distinct_areas([ ... [0] ... ]) == 1 >>> num_distinct_areas([ ... [1] ... ]) == 0","solution":"def num_distinct_areas(grid): Determines the number of distinct areas of connected empty cells in a given grid. Args: grid (List[List[int]]): N x M grid filled with 0s and 1s. Returns: int: Number of distinct areas of empty cells. def dfs(x, y): if x < 0 or y < 0 or x >= N or y >= M or grid[x][y] != 0: return grid[x][y] = -1 # Mark this cell as visited dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) N = len(grid) M = len(grid[0]) if grid else 0 distinct_areas = 0 for i in range(N): for j in range(M): if grid[i][j] == 0: distinct_areas += 1 dfs(i, j) return distinct_areas"},{"question":"def findPairWithSum(arr: List[int], target: int) -> Optional[Tuple[int, int]]: Finds two distinct elements in arr that add up to the target sum. Parameters: arr (list of int): List of integers. target (int): The target sum. Returns: tuple: A tuple containing the two elements that add up to the target sum, or None if no such pair exists. >>> findPairWithSum([2, 7, 11, 15], 9) (2, 7) >>> findPairWithSum([1, 3, 5, 7], 10) (3, 7) >>> findPairWithSum([1, 2, 3, 4], 8)","solution":"def findPairWithSum(arr, target): Finds two distinct elements in arr that add up to the target sum. Parameters: arr (list of int): List of integers. target (int): The target sum. Returns: tuple: A tuple containing the two elements that add up to the target sum, or None if no such pair exists. seen = set() for num in arr: complement = target - num if complement in seen: return (num, complement) seen.add(num) return None"},{"question":"def findCriticalNodes(n: int, edges: List[Tuple[int, int]]) -> List[int]: Identify the critical nodes in an undirected graph. A node is considered critical if removing that node and its associated edges increases the number of connected components in the graph. Args: n (int): Number of nodes in the graph (1 ≤ n ≤ 10^5). edges (List[Tuple[int, int]]): A list of pairs of integers, each representing an undirected edge connecting two nodes. Returns: List[int]: A list of integers representing the critical nodes in ascending order. >>> findCriticalNodes(7, [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) [3, 4, 5, 6] >>> findCriticalNodes(4, [(1, 2), (2, 3), (2, 4)]) [2] >>> findCriticalNodes(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) [2, 3, 4] >>> findCriticalNodes(5, [(1, 2), (1, 3), (1, 4), (4, 5)]) [1, 4] >>> findCriticalNodes(6, [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)]) [2, 4]","solution":"def findCriticalNodes(n, edges): def dfs(node, parent, disc, low, time, graph, articulation_points): children = 0 disc[node] = low[node] = time[0] time[0] += 1 for neighbor in graph[node]: if disc[neighbor] == -1: # If the neighbor is not visited children += 1 dfs(neighbor, node, disc, low, time, graph, articulation_points) low[node] = min(low[node], low[neighbor]) if parent is None and children > 1: articulation_points.add(node) if parent is not None and low[neighbor] >= disc[node]: articulation_points.add(node) elif neighbor != parent: # Back edge case low[node] = min(low[node], disc[neighbor]) graph = {i: [] for i in range(1, n + 1)} for u, v in edges: graph[u].append(v) graph[v].append(u) disc = [-1] * (n + 1) low = [-1] * (n + 1) time = [0] articulation_points = set() for i in range(1, n + 1): if disc[i] == -1: dfs(i, None, disc, low, time, graph, articulation_points) return sorted(articulation_points)"},{"question":"from typing import List def rearrange(nums: List[int]) -> List[int]: Rearranges the list such that all even numbers come before all odd numbers while maintaining the relative order of the even and odd numbers. Parameters: nums (List[int]): A list of integers. Returns: List[int]: A new list with all even numbers at the beginning followed by all the odd numbers. Examples: >>> rearrange([3, 1, 2, 4]) [2, 4, 3, 1] >>> rearrange([7, 8, 4, 5, 6, 3]) [8, 4, 6, 7, 5, 3] def test_rearrange(): assert rearrange([3, 1, 2, 4]) == [2, 4, 3, 1] assert rearrange([7, 8, 4, 5, 6, 3]) == [8, 4, 6, 7, 5, 3] assert rearrange([2, 4, 6, 8, 10]) == [2, 4, 6, 8, 10] assert rearrange([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9] assert rearrange([]) == [] assert rearrange([5, 6, 3, 8, 7]) == [6, 8, 5, 3, 7] assert rearrange(list(range(1000001))) == list(range(0, 1000001, 2)) + list(range(1, 1000001, 2)) assert rearrange([-3, -2, -5, -8, 9, 4]) == [-2, -8, 4, -3, -5, 9]","solution":"from typing import List def rearrange(nums: List[int]) -> List[int]: Rearranges the list such that all even numbers come before all odd numbers while maintaining the relative order of the even and odd numbers. even = [num for num in nums if num % 2 == 0] odd = [num for num in nums if num % 2 != 0] return even + odd"},{"question":"from typing import List, Tuple def findTriplets(arr: List[int], k: int) -> List[Tuple[int, int, int]]: Find all unique triplets in the array that sum up to a given target value k. >>> findTriplets([-1, 0, 1, 2, -1, -4], 0) [(-1, -1, 2), (-1, 0, 1)] >>> findTriplets([1, 2, 3, 4, 5], 9) [(1, 3, 5), (2, 3, 4)] >>> findTriplets([1, 2, 3, 4, 5], 50) [] >>> findTriplets([0, 0, 0, 0], 0) [(0, 0, 0)] >>> findTriplets([-1, 2, 1, -4, 2, -1, 0], 2) [(-1, 1, 2)] >>> findTriplets([1, 2], 3) []","solution":"def findTriplets(arr, k): arr.sort() n = len(arr) triplets = set() for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue # to avoid duplicates left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: triplets.add((arr[i], arr[left], arr[right])) while left < right and arr[left] == arr[left + 1]: left += 1 # to avoid duplicates while left < right and arr[right] == arr[right - 1]: right -= 1 # to avoid duplicates left += 1 right -= 1 elif current_sum < k: left += 1 else: right -= 1 return sorted(list(triplets))"},{"question":"def find_F_value(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Compute the value F(1) of the tree T. >>> find_F_value(4, [1, 2, 3, 4], [(1, 2), (1, 3), (3, 4)]) 9 >>> find_F_value(1, [1], []) 0 >>> find_F_value(2, [1, 2], [(1, 2)]) 2 >>> find_F_value(3, [1, 2, 3], [(1, 2), (2, 3)]) 5 >>> find_F_value(3, [1, 2, 3], [(1, 2), (1, 3)]) 5 >>> find_F_value(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 14 >>> find_F_value(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 27","solution":"def find_F_value(n, values, edges): from collections import defaultdict, deque # Create an adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) root = 1 value = {i + 1: values[i] for i in range(n)} children = defaultdict(list) # To identify the children we will do a BFS or DFS traversal and set the children correctly parent = {root: None} q = deque([root]) while q: node = q.popleft() for neighbor in tree[node]: if neighbor != parent[node]: parent[neighbor] = node children[node].append(neighbor) q.append(neighbor) # To compute the F(i) values, we use a post-order traversal def dfs(node): sum_f = 0 for child in children[node]: sum_f += dfs(child) + value[child] return sum_f return dfs(root)"},{"question":"from typing import List, Tuple def longest_continuous_activation(events: List[Tuple[str, int]]) -> int: Given a list of events containing activation and deactivation timestamps, this function returns the longest period of time (in milliseconds) the service has been continuously active. :param events: List of tuples of form (event_type: str, timestamp: int) :return: int >>> events = [ ... (\\"activation\\", 1609459200000), ... (\\"deactivation\\", 1609462800000), ... (\\"activation\\", 1609466400000), ... (\\"deactivation\\", 1609470000000), ... (\\"activation\\", 1609473600000), ... (\\"deactivation\\", 1609477200000), ... ] >>> longest_continuous_activation(events) 3600000 >>> events = [ ... (\\"activation\\", 1609459200000), ... (\\"activation\\", 1609462800000), ... (\\"deactivation\\", 1609466400000), ... (\\"deactivation\\", 1609470000000), ... ] >>> longest_continuous_activation(events) 3600000","solution":"def longest_continuous_activation(events): Given a list of events containing activation and deactivation timestamps, this function returns the longest period of time (in milliseconds) the service has been continuously active. :param events: List of tuples (event_type: str, timestamp: int) :return: int max_active_duration = 0 current_activation_start = None for event in events: event_type, timestamp = event if event_type == \\"activation\\": current_activation_start = timestamp elif event_type == \\"deactivation\\": if current_activation_start is not None: active_duration = timestamp - current_activation_start max_active_duration = max(max_active_duration, active_duration) current_activation_start = None return max_active_duration # Example usage: # events = [ # (\\"activation\\", 1609459200000), # (\\"deactivation\\", 1609462800000), # (\\"activation\\", 1609466400000), # (\\"deactivation\\", 1609470000000), # (\\"activation\\", 1609473600000), # (\\"deactivation\\", 1609477200000), # ] # print(longest_continuous_activation(events)) # Output: 3600000"},{"question":"from typing import List def find_optimal_location(grid: List[List[int]]) -> int: Determine the optimal location for a research facility that minimizes the maximum elevation difference with its directly adjacent cells (left, right, up, down). :param grid: A 2D list of integers representing elevation values in the grid. :return: The minimum possible value of the maximum elevation difference. Example: >>> find_optimal_location([ ... [3, 4, 1], ... [2, 8, 5], ... [7, 2, 3] ... ]) 1 >>> find_optimal_location([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0 pass # Your implementation here def test_find_optimal_location_example(): grid = [ [3, 4, 1], [2, 8, 5], [7, 2, 3] ] assert find_optimal_location(grid) == 1 def test_find_optimal_location_flat_grid(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert find_optimal_location(grid) == 0 def test_find_optimal_location_step_grid(): grid = [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ] assert find_optimal_location(grid) == 1 def test_find_optimal_location_large_diff(): grid = [ [0, 10000], [5000, 10000] ] assert find_optimal_location(grid) == 5000 def test_find_optimal_location_corner_case(): grid = [ [1, 3, 5], [3, 8, 9], [5, 9, 1] ] assert find_optimal_location(grid) == 2","solution":"def find_optimal_location(grid): Returns the minimum possible value of the maximum elevation difference between the research facility and its adjacent cells for the optimal location. n = len(grid) min_diff = float('inf') for i in range(n): for j in range(n): current_diff = float('-inf') # Check left if j > 0: current_diff = max(current_diff, abs(grid[i][j] - grid[i][j-1])) # Check right if j < n-1: current_diff = max(current_diff, abs(grid[i][j] - grid[i][j+1])) # Check up if i > 0: current_diff = max(current_diff, abs(grid[i][j] - grid[i-1][j])) # Check down if i < n-1: current_diff = max(current_diff, abs(grid[i][j] - grid[i+1][j])) min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def isMatch(S: str, P: str) -> bool: Determine if the pattern P matches the entire input string S. The character \`?\` matches any single character. The character \`*\` matches any sequence of characters (including the empty sequence). >>> isMatch(\\"aa\\", \\"a\\") False >>> isMatch(\\"aa\\", \\"a*\\") True >>> isMatch(\\"cb\\", \\"?a\\") False >>> isMatch(\\"adceb\\", \\"*a*b\\") True >>> isMatch(\\"acdcb\\", \\"a*c?b\\") False from solution import isMatch def test_exact_match(): assert isMatch(\\"aa\\", \\"aa\\") == True def test_single_character_mismatch(): assert isMatch(\\"aa\\", \\"a\\") == False def test_single_character_wildcard(): assert isMatch(\\"cb\\", \\"?b\\") == True def test_single_character_wildcard_mismatch(): assert isMatch(\\"cb\\", \\"?a\\") == False def test_star_matches_any_sequence(): assert isMatch(\\"adceb\\", \\"*a*b\\") == True def test_star_at_the_end(): assert isMatch(\\"adceb\\", \\"ad*\\") == True def test_star_at_the_start(): assert isMatch(\\"adceb\\", \\"*eb\\") == True def test_mixed_wildcards(): assert isMatch(\\"acdcb\\", \\"a*c?b\\") == False def test_multiple_wildcards(): assert isMatch(\\"abcd\\", \\"a*d\\") == True def test_star_match_empty_sequence(): assert isMatch(\\"abcde\\", \\"a*e\\") == True def test_questionmark_matches_single_character(): assert isMatch(\\"abcde\\", \\"a?cde\\") == True def test_trailing_star(): assert isMatch(\\"abc\\", \\"a*\\") == True def test_leading_star(): assert isMatch(\\"abc\\", \\"*c\\") == True","solution":"def isMatch(S: str, P: str) -> bool: m, n = len(S), len(P) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if P[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if P[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif P[j - 1] == '?' or S[i - 1] == P[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root: Optional[TreeNode], target_sum: int) -> List[List[int]]: Given a binary tree where each node has an integer value, and an integer target sum, return all root-to-leaf paths where each path's sum of node values equals the target sum. Each path should be represented as a list of node values, and the paths should be returned in any order. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> path_sum(root, 22) [[5, 4, 11, 2], [5, 8, 4, 5]] pass # Unit tests def test_path_sum_single_path(): root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) assert path_sum(root, 22) == [[5, 4, 11, 2]] def test_path_sum_multiple_paths(): root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.left = TreeNode(5) root.right.right.right = TreeNode(1) assert path_sum(root, 22) == [[5, 4, 11, 2], [5, 8, 4, 5]] def test_path_sum_no_path(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert path_sum(root, 5) == [] def test_path_sum_empty_tree(): assert path_sum(None, 0) == [] def test_path_sum_single_node_matching_target(): root = TreeNode(5) assert path_sum(root, 5) == [[5]] def test_path_sum_single_node_not_matching_target(): root = TreeNode(5) assert path_sum(root, 1) == []","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root: Optional[TreeNode], target_sum: int) -> List[List[int]]: def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target_sum: results.append(current_path[:]) else: if node.left: dfs(node.left, current_path, current_sum) if node.right: dfs(node.right, current_path, current_sum) current_path.pop() current_sum -= node.val results = [] dfs(root, [], 0) return results"},{"question":"def maximize_tasks(n: int, e: int, energy_requirements: List[int]) -> Tuple[int, int]: Calculate the maximum number of tasks that can be executed and the minimum energy consumed. :param n: The number of tasks :param e: The total energy reserve :param energy_requirements: A list of integers representing the initial energy requirements for each task :return: A tuple (max_tasks, min_energy) where max_tasks is the maximum number of tasks executed and min_energy is the minimum energy consumed Examples: >>> maximize_tasks(5, 15, [5, 4, 7, 3, 5]) (3, 12) >>> maximize_tasks(3, 20, [5, 5, 5]) (3, 15) >>> maximize_tasks(4, 2, [5, 6, 7, 8]) (0, 0) >>> maximize_tasks(4, 10, [3, 6, 8, 5]) (2, 8) >>> maximize_tasks(1, 5, [4]) (1, 4) >>> maximize_tasks(5, 15, [3, 3, 3, 3, 3]) (5, 15) >>> maximize_tasks(4, 10, [9, 7, 5, 3]) (2, 8)","solution":"def maximize_tasks(n, e, energy_requirements): Calculate the maximum number of tasks that can be executed and the minimum energy consumed. :param n: The number of tasks :param e: The total energy reserve :param energy_requirements: A list of integers representing the initial energy requirements for each task :return: A tuple (max_tasks, min_energy) where max_tasks is the maximum number of tasks executed and min_energy is the minimum energy consumed # Sort the energy requirements to try and complete the smallest ones first energy_requirements.sort() max_tasks = 0 min_energy = 0 for i in range(n): if min_energy + energy_requirements[i] <= e: min_energy += energy_requirements[i] max_tasks += 1 else: break return max_tasks, min_energy"},{"question":"def max_banner_area(n: int, heights: List[int]) -> int: Function to find the maximum possible area of the advertisement banner. >>> max_banner_area(6, [2, 1, 5, 6, 2, 3]) 10 >>> max_banner_area(5, [2, 2, 2, 2, 2]) 10 >>> max_banner_area(5, [1, 2, 3, 4, 5]) 9 >>> max_banner_area(5, [5, 4, 3, 2, 1]) 9 >>> max_banner_area(7, [6, 2, 5, 4, 5, 1, 6]) 12 >>> max_banner_area(2, [2, 1]) 2 pass","solution":"def largestRectangleArea(heights): Function to calculate the largest rectangle area in a histogram. stack = [] max_area = 0 index = 0 while index < len(heights): # Push the current building to the stack if it's taller than the building at stack top if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop from stack and calculate the area top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_banner_area(n, heights): Function to find the maximum possible area of the advertisement banner. return largestRectangleArea(heights) # Example usage n = 6 heights = [2, 1, 5, 6, 2, 3] print(max_banner_area(n, heights)) # Output: 10"},{"question":"def max_subarray_sum(n: int, array: List[int]) -> int: Finds the maximum possible sum of any non-empty contiguous subarray. >>> max_subarray_sum(5, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum(1, [-1]) == -1","solution":"def max_subarray_sum(n, array): Finds the maximum possible sum of any non-empty contiguous subarray. Parameters: n (int): The number of elements in the array. array (list of int): The elements of the array. Returns: int: The maximum possible sum of any non-empty contiguous subarray. # Initialize the current sum and maximum sum with the first element current_sum = max_sum = array[0] # Use Kadane's algorithm to find the maximum subarray sum for i in range(1, n): current_sum = max(array[i], current_sum + array[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_deletions(s: str) -> int: Returns the minimum number of deletions needed to delete all characters from the string. >>> min_deletions(\\"aaaa\\") == 1 >>> min_deletions(\\"BBBB\\") == 1 >>> min_deletions(\\"aAaA\\") == 4 >>> min_deletions(\\"BbBb\\") == 4 >>> min_deletions(\\"aaaBBBcccDDD\\") == 4 >>> min_deletions(\\"aAaaBBBccCD\\") == 6 >>> min_deletions(\\"a\\") == 1 >>> min_deletions(\\"B\\") == 1 >>> min_deletions(\\"aBBBa\\") == 3","solution":"def min_deletions(s): Returns the minimum number of deletions needed to delete all characters from the string. operations = 0 i = 0 while i < len(s): start = i # Continue while characters belong to the same case while i < len(s) and s[start].islower() == s[i].islower(): i += 1 operations += 1 return operations"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Finds the maximum rectangular area in a histogram given the heights of its bars. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([3, 3, 3, 3, 3]) 15 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([0, 2, 0, 2]) 2 >>> largestRectangleArea([1, 2, 3, 1, 2]) 5 >>> largestRectangleArea([1, 10, 10, 1]) 20 pass","solution":"def largestRectangleArea(heights): Finds the maximum rectangular area in a histogram given the heights of its bars. stack = [] max_area = 0 heights.append(0) # Append 0 to heights to make sure all bars will be popped for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def rearrange_titles(n: int, titles: List[str]) -> List[str]: Rearranges the words in each book title lexicographically. Parameters: n (int): Number of book titles titles (list of str): List of book titles Returns: list of str: List of rearranged titles >>> rearrange_titles(3, [\\"the quick brown fox\\", \\"jumps over the lazy dog\\", \\"hello world programming\\"]) [\\"brown fox quick the\\", \\"dog jumps lazy over the\\", \\"hello programming world\\"] >>> rearrange_titles(3, [\\"book\\", \\"title\\", \\"single\\"]) [\\"book\\", \\"title\\", \\"single\\"] >>> rearrange_titles(3, [\\"green apple\\", \\"dark knight\\", \\"blue sky\\"]) [\\"apple green\\", \\"dark knight\\", \\"blue sky\\"] >>> rearrange_titles(3, [\\"the quick brown fox\\", \\" jumps over the lazy dog\\", \\" hello world programming \\"]) [\\"brown fox quick the\\", \\"dog jumps lazy over the\\", \\"hello programming world\\"] >>> rearrange_titles(0, []) [] from typing import List","solution":"def rearrange_titles(n, titles): Rearranges the words in each book title lexicographically. Parameters: n (int): Number of book titles titles (list of str): List of book titles Returns: list of str: List of rearranged titles rearranged_titles = [] for title in titles: words = title.split() words.sort() rearranged_titles.append(' '.join(words)) return rearranged_titles"},{"question":"from flask import Flask, request, jsonify app = Flask(__name__) # Sample user data users = { \\"john_doe\\": \\"password123\\", \\"jane_smith\\": \\"mypassword\\", \\"alice_jones\\": \\"alicepassword\\" } @app.route('/api/login', methods=['POST']) def login(): Handle user login for a web application. - Input: JSON object with 'username' and 'password' - Output: JSON response with a welcome message or error message Sample Usage: >>> client.post('/api/login', json={\\"username\\": \\"john_doe\\", \\"password\\": \\"password123\\"}) {\\"message\\": \\"Welcome, john_doe!\\"} >>> client.post('/api/login', json={\\"username\\": \\"john_doe\\", \\"password\\": \\"wrongpassword\\"}) {\\"error\\": \\"Invalid username or password\\"} >>> client.post('/api/login', json={\\"username\\": \\"non_existent_user\\", \\"password\\": \\"any_password\\"}) {\\"error\\": \\"Invalid username or password\\"} >>> client.post('/api/login', json={\\"password\\": \\"password123\\"}) {\\"error\\": \\"Username and password are required\\"} >>> client.post('/api/login', json={\\"username\\": \\"john_doe\\"}) {\\"error\\": \\"Username and password are required\\"} >>> client.post('/api/login', json={}) {\\"error\\": \\"Username and password are required\\"} pass # Your code here if __name__ == '__main__': app.run(debug=True)","solution":"from flask import Flask, request, jsonify app = Flask(__name__) # Sample user data users = { \\"john_doe\\": \\"password123\\", \\"jane_smith\\": \\"mypassword\\", \\"alice_jones\\": \\"alicepassword\\" } @app.route('/api/login', methods=['POST']) def login(): data = request.get_json() # Input validation if 'username' not in data or 'password' not in data: return jsonify({\\"error\\": \\"Username and password are required\\"}), 400 username = data['username'] password = data['password'] # Authentication if username in users and users[username] == password: return jsonify({\\"message\\": f\\"Welcome, {username}!\\"}), 200 else: return jsonify({\\"error\\": \\"Invalid username or password\\"}), 401 if __name__ == '__main__': app.run(debug=True)"},{"question":"def find_subset_sum(n: int, m: int, arr: List[int]) -> str: Determines if the target sum m can be obtained using the given array elements (each can be used multiple times). >>> find_subset_sum(3, 7, [3, 34, 4]) 'YES' >>> find_subset_sum(3, 7, [2, 4, 6]) 'NO' >>> find_subset_sum(1, 5, [5]) 'YES' >>> find_subset_sum(1, 3, [2]) 'NO' >>> find_subset_sum(3, 9, [2, 3, 4]) 'YES' >>> find_subset_sum(3, 1000, [5, 10, 20]) 'YES' >>> find_subset_sum(0, 10, []) 'NO' >>> find_subset_sum(2, 100000, [1, 1000]) 'YES'","solution":"def find_subset_sum(n, m, arr): Determines if the target sum m can be obtained using the given array elements (each can be used multiple times). Uses a dynamic programming approach to solve the problem. dp = [False] * (m + 1) dp[0] = True # base case: sum 0 is always achievable for i in range(1, m + 1): for num in arr: if i - num >= 0 and dp[i - num]: dp[i] = True break return \\"YES\\" if dp[m] else \\"NO\\""},{"question":"def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Args: arr (List[int]): The input array. k (int): The number of steps to rotate the array. Returns: List[int]: The rotated array. Examples: >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([-1, -100, 3, 99], 2) [3, 99, -1, -100] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotate_array([], 3) []","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(arr) if n == 0 or k == 0: return arr k %= n # If k >= n, only k % n rotations are needed. return arr[-k:] + arr[:-k]"},{"question":"from typing import List, Tuple def calculate_triangle_area(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> float: Calculates the area of a triangle given its vertices' coordinates using the determinant formula. pass def find_largest_triangle_area(points: List[Tuple[int, int]]) -> float: Finds the area of the largest triangle that can be formed by any three points from the given list. >>> find_largest_triangle_area([(0, 0), (0, 2), (2, 0), (2, 2), (1, 1)]) 2.0 >>> find_largest_triangle_area([(0, 0), (1, 1), (2, 2)]) 0.0 pass","solution":"from itertools import combinations def calculate_triangle_area(x1, y1, x2, y2, x3, y3): Calculates the area of a triangle given its vertices' coordinates using the determinant formula. return abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)) / 2.0 def find_largest_triangle_area(points): Finds the area of the largest triangle that can be formed by any three points from the given list. max_area = 0 for (x1, y1), (x2, y2), (x3, y3) in combinations(points, 3): max_area = max(max_area, calculate_triangle_area(x1, y1, x2, y2, x3, y3)) return max_area"},{"question":"from typing import List def min_moves_to_zero(binary_string: str) -> int: Determine the minimum number of moves required to make the binary string consist of all '0's. The input is a binary string s (a string consisting only of characters '0' and '1'). In one move, you are allowed to choose any substring of s and flip all the characters in that substring. Examples: >>> min_moves_to_zero(\\"101\\") 1 >>> min_moves_to_zero(\\"111000\\") 1 >>> min_moves_to_zero(\\"0000\\") 0 >>> min_moves_to_zero(\\"1\\") 1 >>> min_moves_to_zero(\\"0\\") 0 def process_test_cases(test_cases: List[str]) -> List[int]: Process a list of binary string test cases and return a list of results for each case. Each result represents the minimum number of moves required to make the corresponding binary string consist of all '0's. Examples: >>> process_test_cases([\\"101\\", \\"111000\\", \\"0000\\"]) [1, 1, 0] >>> process_test_cases([\\"1\\", \\"0\\", \\"111\\", \\"000\\"]) [1, 0, 1, 0]","solution":"def min_moves_to_zero(binary_string): if '1' not in binary_string: return 0 return 1 if '0' not in binary_string else 1 def process_test_cases(test_cases): results = [] for s in test_cases: results.append(min_moves_to_zero(s)) return results"},{"question":"def count_always_visible_users(n: int, m: int, profiles: str, friendships: List[Tuple[int, int]]) -> int: Counts the number of always visible users in the social network. Params: n (int): The number of users. m (int): The number of friendship relations. profiles (str): A string of length n consisting of 'P' for private and 'B' for public profiles. friendships (list of tuples): A list of m tuples, where each tuple contains two integers u and v indicating a friendship relation. Returns: int: The number of always visible users. Example: >>> count_always_visible_users(5, 4, \\"PBBPP\\", [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> count_always_visible_users(3, 2, \\"PPP\\", [(1, 2), (2, 3)]) 0","solution":"def count_always_visible_users(n, m, profiles, friendships): Counts the number of always visible users in the social network. Params: n (int): The number of users. m (int): The number of friendship relations. profiles (str): A string of length n consisting of 'P' for private and 'B' for public profiles. friendships (list of tuples): A list of m tuples, where each tuple contains two integers u and v indicating a friendship relation. Returns: int: The number of always visible users. # Initialize a set to keep track of always visible users visible_users = set() # Convert profile string to a list for easier indexing profiles = list(profiles) # Track public profile users public_users = set() for i in range(n): if profiles[i] == 'B': public_users.add(i + 1) # Track friends of public users for u, v in friendships: if u in public_users or v in public_users: visible_users.add(u) visible_users.add(v) # Add all public users to visible users visible_users.update(public_users) # Return the count of always visible users return len(visible_users) # Sample usage print(count_always_visible_users(5, 4, \\"PBBPP\\", [(1, 2), (2, 3), (3, 4), (4, 5)]))"},{"question":"def find_smallest_missing_positive_integer(nums: List[int]) -> int: Returns the smallest positive integer that is missing from the list nums. Examples: >>> find_smallest_missing_positive_integer([1, 2, 3, 4, 5]) 6 >>> find_smallest_missing_positive_integer([3, 7, 1, 2, 8]) 4 >>> find_smallest_missing_positive_integer([-1, -2, -3]) 1 >>> find_smallest_missing_positive_integer([0, -10, -20]) 1 >>> find_smallest_missing_positive_integer([1, 1000000]) 2 >>> find_smallest_missing_positive_integer([1, 2, 0, -1, 3]) 4 >>> find_smallest_missing_positive_integer([]) 1 >>> find_smallest_missing_positive_integer([10, -1, 3, -4, 7, 8, 9, -10]) 1 >>> find_smallest_missing_positive_integer(list(range(-10**6, 10**6))) 1000000","solution":"def find_smallest_missing_positive_integer(nums): Returns the smallest positive integer that is missing from the list nums. # Filtering out non-positive numbers and converting to a set num_set = set(filter(lambda x: x > 0, nums)) smallest_missing = 1 while smallest_missing in num_set: smallest_missing += 1 return smallest_missing"},{"question":"from typing import List, Tuple def sum_of_depths(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the sum of all nodes' depths in a binary tree. >>> sum_of_depths(5, [(1, 2), (1, 3), (2, 4), (3, 5)]) # Output should be 6 >>> sum_of_depths(1, []) # Output should be 0 >>> sum_of_depths(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) # Output should be 10 >>> sum_of_depths(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) # Output should be 10","solution":"def sum_of_depths(n, edges): from collections import defaultdict, deque # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # BFS to calculate depths depth_sum = 0 visited = [False] * (n + 1) queue = deque([(1, 0)]) # (current_node, current_depth) visited[1] = True while queue: node, depth = queue.popleft() depth_sum += depth for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append((neighbor, depth + 1)) return depth_sum # Example usage edges = [(1, 2), (1, 3), (2, 4), (3, 5)] print(sum_of_depths(5, edges)) # Output should be 6"},{"question":"def minimum_possible_height(n, heights, widths, m, constraint_list): Determine the minimum possible total height of the bookshelf arrangement. Each book can be represented as a tuple (h_i, w_i) where h_i is the height and w_i is the width of the i-th book. The total height of the bookshelf row is defined as the height of the tallest book stacked on it. There are certain pairs of books which must be placed next to each other. Args: n: int - the number of books. heights: List[int] - the heights of the books. widths: List[int] - the widths of the books. m: int - the number of constraints. constraint_list: List[int] - pairs of integers u and v indicating that book u must be placed next to book v. Returns: int - the minimum possible total height of the bookshelf arrangement. Examples: >>> minimum_possible_height(1, [10], [5], 0, []) 10 >>> minimum_possible_height(3, [10, 50, 20], [5, 5, 5], 0, []) 50 >>> minimum_possible_height(4, [10, 20, 30, 40], [5, 5, 5, 5], 2, [1, 2, 3, 4]) 40 >>> minimum_possible_height(3, [10, 50, 20], [5, 5, 5], 1, [1, 2]) 50 >>> minimum_possible_height(3, [20, 30, 10], [5, 5, 5], 1, [2, 3]) 30 >>> minimum_possible_height(3, [10, 50, 30], [5, 5, 5], 2, [1, 2, 2, 3]) 50 >>> minimum_possible_height(4, [15, 10, 25, 5], [7, 8, 9, 6], 2, [1, 2, 3, 4]) 25","solution":"from itertools import permutations def minimum_bookshelf_height(n, heights, widths, constraints): # Create an adjacency list for the constraints graph = {i: [] for i in range(n)} for u, v in constraints: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) # Helper function to check if the arrangement follows all constraints def is_valid_order(order): order_map = {book: i for i, book in enumerate(order)} for u, v in constraints: if abs(order_map[u - 1] - order_map[v - 1]) != 1: return False return True books = list(range(n)) min_height = float('inf') for perm in permutations(books): if is_valid_order(perm): current_height = max(heights[book] for book in perm) min_height = min(min_height, current_height) return min_height # Example usage n = 4 heights = [10, 20, 30, 40] widths = [5, 5, 5, 5] constraints = [(1, 2), (3, 4)] print(minimum_bookshelf_height(n, heights, widths, constraints)) # Output: 40 def minimum_possible_height(n, heights, widths, m, constraint_list): constraints = [(constraint_list[i], constraint_list[i+1]) for i in range(0, 2 * m, 2)] return minimum_bookshelf_height(n, heights, widths, constraints)"},{"question":"def remove_duplicates(s: str) -> str: Given a string s consisting of lowercase Latin letters, returns a new string with all contiguous duplicate letters removed. >>> remove_duplicates(\\"aabccddd\\") 'abcd' >>> remove_duplicates(\\"abcdef\\") 'abcdef' >>> remove_duplicates(\\"aaabbaacc\\") 'abac'","solution":"def remove_duplicates(s): Returns a new string with all contiguous duplicate letters removed. if not s: return \\"\\" result = [s[0]] # initialize with the first character for char in s[1:]: if char != result[-1]: # only add if it's different from the last character added result.append(char) return ''.join(result)"},{"question":"def largest_square_subgrid(h: int, w: int, grid: List[List[int]]) -> int: Find the size of the largest square subgrid that contains only 1s. >>> h = 3 >>> w = 4 >>> grid = [ [1, 1, 1, 0], [1, 1, 1, 1], [1, 1, 1, 1] ] >>> largest_square_subgrid(h, w, grid) 3 >>> h = 4 >>> w = 5 >>> grid = [ [1, 0, 1, 1, 0], [1, 1, 0, 1, 1], [1, 1, 1, 0, 1], [0, 1, 1, 1, 1] ] >>> largest_square_subgrid(h, w, grid) 2","solution":"def largest_square_subgrid(h, w, grid): # Initialize the DP table dp = [[0]*w for _ in range(h)] max_side = 0 for i in range(h): for j in range(w): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = grid[i][j] else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def generate_grid(n: int, S: int) -> List[List[int]]: Create a grid of size n x n that satisfies the given constraints. Each element in the grid must be an integer between 1 and 10^9. Each row and each column must contain distinct integers. The sum of all elements in the diagonal of the grid (from top-left to bottom-right) must be equal to a given integer S. >>> generate_grid(3, 15) [[5, 1, 9], [7, 5, 3], [2, 8, 5]] >>> generate_grid(2, 10) [[6, 4], [4, 6]] pass def solve(t: int, test_cases: List[Tuple[int, int]]) -> List[List[List[int]]]: Solve multiple test cases of the grid generation problem. >>> solve(2, [(3, 15), (2, 10)]) [[[5, 1, 9], [7, 5, 3], [2, 8, 5]], [[6, 4], [4, 6]]] pass import pytest from solution import generate_grid, solve def test_generate_grid_3x3_15(): grid = generate_grid(3, 15) assert sum(grid[i][i] for i in range(3)) == 15 for row in grid: assert len(set(row)) == 3 for col in range(3): assert len(set(grid[row][col] for row in range(3))) == 3 def test_generate_grid_2x2_10(): grid = generate_grid(2, 10) assert sum(grid[i][i] for i in range(2)) == 10 for row in grid: assert len(set(row)) == 2 for col in range(2): assert len(set(grid[row][col] for row in range(2))) == 2 def test_solve(): test_cases = [(3, 15), (2, 10)] results = solve(2, test_cases) for i, (n, S) in enumerate(test_cases): grid = results[i] assert sum(grid[j][j] for j in range(n)) == S for row in grid: assert len(set(row)) == n for col in range(n): assert len(set(grid[row][col] for row in range(n))) == n","solution":"def generate_grid(n, S): # Create an empty n x n grid grid = [[0] * n for _ in range(n)] # Calculate the diagonal values assuming we use the first \`n\` natural numbers val = S // n remainder = S % n # Place the values on the diagonal to sum up to S for i in range(n): grid[i][i] = val + (1 if i < remainder else 0) num = 1 for row in range(n): for col in range(n): if grid[row][col] == 0: while num in [grid[i][col] for i in range(n)] or num in grid[row]: num += 1 grid[row][col] = num num += 1 return grid def solve(t, test_cases): results = [] for i in range(t): n, S = test_cases[i] grid = generate_grid(n, S) results.append(grid) return results"},{"question":"def count_pairs(A: List[int], B: List[int], K: int) -> int: Returns the number of pairs (i, j) such that A[i] - B[j] = K. Parameters: A (list of int): The first list of N integers. B (list of int): The second list of N integers. K (int): The target integer. Returns: int: The number of pairs (i, j) satisfying the condition. >>> count_pairs([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], 0) 5 >>> count_pairs([1, 2, 3], [4, 5, 6], 10) 0 >>> count_pairs([1], [1], 0) 1 >>> count_pairs([5, 6, 7], [2, 3, 4], 3) 3 >>> count_pairs(list(range(100000)), list(range(100000)), 0) 100000 >>> count_pairs([1, 1, 1, 1], [1, 1, 1, 1], 0) 16 pass","solution":"def count_pairs(A, B, K): Returns the number of pairs (i, j) such that A[i] - B[j] = K. Parameters: A (list of int): The first list of N integers. B (list of int): The second list of N integers. K (int): The target integer. Returns: int: The number of pairs (i, j) satisfying the condition. from collections import Counter B_count = Counter(B) pair_count = 0 # Iterate over each element in A and count pairs for a in A: target = a - K pair_count += B_count[target] return pair_count"},{"question":"def max_treasures(m: int, n: int, k: int, treasures: List[Tuple[int, int]]) -> int: Determine the maximum number of treasures that can be collected starting from the top-left corner (0,0) and moving towards the bottom-right corner (m-1,n-1). >>> max_treasures(4, 4, 4, [(0, 1), (1, 2), (2, 1), (3, 3)]) 4 >>> max_treasures(4, 4, 0, []) 0 >>> max_treasures(3, 3, 1, [(1, 1)]) 1 Args: m (int): number of rows. n (int): number of columns. k (int): number of treasures. treasures (List[Tuple[int, int]]): coordinates of treasures. Returns: int: Maximum number of treasures collected. pass","solution":"def max_treasures(m, n, k, treasures): from collections import deque if k == 0: return 0 # initialize the grid grid = [[0] * n for _ in range(m)] for x, y in treasures: grid[x][y] = 1 # directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n def bfs(): max_treasures_found = 0 queue = deque([(0, 0, 0, set([(0, 0)]))]) # (x, y, treasures_collected, visited) while queue: x, y, treasures_collected, visited = queue.popleft() if grid[x][y] == 1: treasures_collected += 1 max_treasures_found = max(max_treasures_found, treasures_collected) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: new_visited = visited | {(nx, ny)} queue.append((nx, ny, treasures_collected, new_visited)) return max_treasures_found return bfs()"},{"question":"from typing import List def find_permutations(s: str) -> List[str]: Write a function \`find_permutations\` that takes a string \`s\` as input and returns a list of all possible permutations of the characters in the given string. The function should return the permutations in lexicographical order. Constraints: - The input string \`s\` will have a length between 1 and 8. - All characters in the string \`s\` are unique. >>> find_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> find_permutations(\\"a\\") [\\"a\\"] pass # Unit Tests def test_find_permutations_length_1(): assert find_permutations(\\"a\\") == [\\"a\\"] def test_find_permutations_length_2(): assert find_permutations(\\"ab\\") == [\\"ab\\", \\"ba\\"] def test_find_permutations_length_3(): assert find_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] def test_find_permutations_length_4(): expected = [\\"abcd\\", \\"abdc\\", \\"acbd\\", \\"acdb\\", \\"adbc\\", \\"adcb\\", \\"bacd\\", \\"badc\\", \\"bcad\\", \\"bcda\\", \\"bdac\\", \\"bdca\\", \\"cabd\\", \\"cadb\\", \\"cbad\\", \\"cbda\\", \\"cdab\\", \\"cdba\\", \\"dabc\\", \\"dacb\\", \\"dbac\\", \\"dbca\\", \\"dcab\\", \\"dcba\\"] assert find_permutations(\\"abcd\\") == expected def test_find_permutations_length_8(): s = \\"abcdefgh\\" result = find_permutations(s) assert len(result) == 40320 # 8 factorial","solution":"from itertools import permutations def find_permutations(s: str): Returns a list of all possible permutations of the characters in the given string in lexicographical order. return sorted([''.join(p) for p in permutations(s)]) # Example usage # s = \\"abc\\" # print(find_permutations(s)) # Output: [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"]"},{"question":"def max_even_sum(n: int, power_values: List[int]) -> int: Find the maximum sum of power values of a subset of leaves that is even. Parameters: n : int : Number of power values power_values : list : List of integers representing the power values Returns: int : Maximum sum that is even >>> max_even_sum(5, [4, 5, 6, 7, 8]) 30 >>> max_even_sum(4, [2, 4, 6, 8]) 20 >>> max_even_sum(5, [1, 3, 5, 7, 9]) 24 >>> max_even_sum(6, [1, 2, 3, 4, 5, 6]) 20 >>> max_even_sum(1, [1]) 0 >>> max_even_sum(1, [2]) 2 pass","solution":"def max_even_sum(n, power_values): ''' Function to find the maximum sum of power values of a subset of leaves that is even. Parameters: n : int : Number of power values power_values : list : List of integers representing the power values Returns: int : Maximum sum that is even ''' total_sum = sum(power_values) # If the total sum is even, that's the maximum even sum if total_sum % 2 == 0: return total_sum # If the total sum is odd, we need to find the smallest odd number to remove min_odd = float('inf') for value in power_values: if value % 2 != 0: min_odd = min(min_odd, value) return total_sum - min_odd # Example execution n = 5 power_values = [4, 5, 6, 7, 8] print(max_even_sum(n, power_values))"},{"question":"def remove_first_minimal(arr: List[int]) -> str: Given a list of integers, remove the first occurrence of the minimal integer. If the list is empty after removal, return \\"EMPTY\\". >>> remove_first_minimal([3, 4, 2, 5, 2, 1, 3]) == \\"3 4 2 5 2 3\\" >>> remove_first_minimal([1, 2, 3, 4, 1, 5, 6]) == \\"2 3 4 1 5 6\\" >>> remove_first_minimal([7]) == \\"EMPTY\\" >>> remove_first_minimal([1, 2, 2, 3, 1, 4, 1]) == \\"2 2 3 1 4 1\\" >>> remove_first_minimal([-1, -10, 3, -10, 5, -1]) == \\"-1 3 -10 5 -1\\" >>> remove_first_minimal([1000000, 1000000, -1000000]) == \\"1000000 1000000\\" >>> remove_first_minimal([]) == \\"EMPTY\\" >>> remove_first_minimal([5]) == \\"EMPTY\\"","solution":"def remove_first_minimal(arr): Given a list of integers, remove the first occurrence of the minimal integer. If the list is empty after removal, return \\"EMPTY\\". if not arr: return \\"EMPTY\\" min_val = min(arr) arr.remove(min_val) return \\"EMPTY\\" if not arr else \\" \\".join(map(str, arr))"},{"question":"from typing import List, Tuple from collections import defaultdict def find_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> None: You are given an undirected graph with n nodes and m edges. Each node has a unique identifier from 1 to n. The graph does not contain any self-loops or multiple edges. Your task is to determine if the graph contains a cycle, and if it does, print out any one of the cycles you find. If the graph contains a cycle, output \\"Cycle found\\" followed by the nodes in the cycle in the order they appear. If there are multiple cycles, output any one of them. If the graph does not contain a cycle, output \\"No cycle found\\". >>> data = \\"4 4n1 2n2 3n3 4n4 1\\" >>> n, m, edges = process_input(data) >>> find_cycle(n, m, edges) Cycle found 1 2 3 4 >>> data = \\"5 4n1 2n2 3n3 4n4 5\\" >>> n, m, edges = process_input(data) >>> find_cycle(n, m, edges) No cycle found pass def process_input(data: str) -> Tuple[int, int, List[Tuple[int, int]]]: Process the input data to extract number of nodes, number of edges, and the list of edges. >>> data = \\"4 4n1 2n2 3n3 4n4 1\\" >>> process_input(data) (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) >>> data = \\"3 0\\" >>> process_input(data) (3, 0, []) pass","solution":"from collections import defaultdict def find_cycle(n, m, edges): def dfs(v, parent): visited[v] = True stack.append(v) for to in graph[v]: if not visited[to]: if dfs(to, v): return True elif to != parent: cycle_start = to cycle_end = v while stack[-1] != cycle_start: cycle.append(stack.pop()) cycle.append(cycle_start) cycle.reverse() return True stack.pop() return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) stack = [] cycle = [] for i in range(1, n + 1): if not visited[i]: if dfs(i, -1): print(\\"Cycle found\\") print(\\" \\".join(map(str, cycle))) return print(\\"No cycle found\\") def process_input(data): lines = data.strip().split(\\"n\\") n, m = map(int, lines[0].split()) edges = [tuple(map(int, line.split())) for line in lines[1:]] return n, m, edges # Example of usage: data = 4 4 1 2 2 3 3 4 4 1 n, m, edges = process_input(data) find_cycle(n, m, edges)"},{"question":"def rotate_and_print(s: str, k: int) -> str: Rotates the string \`s\` \`k\` positions to the right and returns the result. >>> rotate_and_print(\\"abcdef\\", 2) 'efabcd' >>> rotate_and_print(\\"abcdef\\", 0) 'abcdef' >>> rotate_and_print(\\"abcdef\\", 6) 'abcdef' >>> rotate_and_print(\\"a\\", 1) 'a' >>> rotate_and_print(\\"a\\", 0) 'a' >>> rotate_and_print(\\"abcde\\", 5) 'abcde' >>> rotate_and_print(\\"abcdef\\", 8) 'efabcd' >>> rotate_and_print(\\"\\", 4) ''","solution":"def rotate_and_print(s: str, k: int) -> str: Rotates the string s k positions to the right and returns the result, making use of the properties of a circular doubly linked list. if len(s) == 0: return \\"\\" n = len(s) k = k % n # In case k is larger than the length of the string rotated = s[-k:] + s[:-k] return rotated"},{"question":"from typing import List, Tuple def smallest_encompassing_circle_radius(points: List[Tuple[int, int]]) -> float: Determine the radius of the smallest circle that encompasses all the given points. >>> round(smallest_encompassing_circle_radius([(0, 0)]), 6) 0.0 >>> math.isclose(smallest_encompassing_circle_radius([(-1, 0), (1, 0)]), 1.0, rel_tol=1e-6) True >>> math.isclose(smallest_encompassing_circle_radius([(-1, 0), (1, 0), (0, 1)]), 1.0, rel_tol=1e-6) True >>> math.isclose(smallest_encompassing_circle_radius([(0, 0), (0, 2), (2, 0), (2, 2)]), math.sqrt(2.0), rel_tol=1e-6) True >>> math.isclose(smallest_encompassing_circle_radius([(-1000, 0), (1000, 0)]), 1000.0, rel_tol=1e-6) True pass","solution":"import math def smallest_encompassing_circle_radius(points): Determine the radius of the smallest circle that encompasses all the given points. :param points: List of tuples, where each tuple contains the x and y coordinates of a point. :return: The radius of the smallest circle. def distance(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) n = len(points) max_distance = 0.0 # Compare all pairs of points to find the maximum distance for i in range(n): for j in range(i + 1, n): dist = distance(points[i], points[j]) if dist > max_distance: max_distance = dist # The radius of the smallest circle is half of the maximum distance found radius = max_distance / 2 return radius # Example usage points = [(-1, 0), (1, 0), (0, 1)] print(f\\"{smallest_encompassing_circle_radius(points):.6f}\\")"},{"question":"from typing import List def longest_palindrome_length(s: str) -> int: Given a string s, return the length of the longest palindrome that can be formed using the letters of s. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases to determine the length of the longest palindrome that can be formed for each. >>> process_test_cases([\\"abccccdd\\", \\"a\\", \\"aabbcc\\", \\"abcde\\", \\"aabbccc\\", \\"\\"]) [7, 1, 6, 1, 7, 0] pass","solution":"def longest_palindrome_length(s): Given a string s, return the length of the longest palindrome that can be formed using the letters of s. from collections import Counter char_counts = Counter(s) length = 0 odd_found = False for count in char_counts.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length def process_test_cases(test_cases): results = [] for s in test_cases: results.append(longest_palindrome_length(s)) return results"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Find a path from the top-left corner to the bottom-right corner of the grid, such that the sum of the numbers along the path is minimized. >>> grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] >>> min_path_sum(grid) 7 >>> grid = [ [42] ] >>> min_path_sum(grid) 42 >>> grid = [ [1, 2], [3, 4] ] >>> min_path_sum(grid) 7 >>> grid = [ [1, 2, 5], [3, 2, 1], [4, 2, 1] ] >>> min_path_sum(grid) 7 >>> grid = [ [100]*100 for _ in range(100) ] >>> min_path_sum(grid) 19900 >>> grid = [ [] ] >>> min_path_sum(grid) 0","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n = len(grid) # Initialize DP table with the same dimensions as grid dp = [[0] * n for _ in range(n)] # Start from the top-left corner dp[0][0] = grid[0][0] # Fill the first row (only option is to move right) for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (only option is to move down) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]) return dp[-1][-1]"},{"question":"def town_roads(n: int, m: int, roads: List[Tuple[int, int, int]]) -> Union[int, str]: Determine the minimum total length of the roads needed to keep all houses connected. Args: n (int): Number of houses m (int): Number of roads roads (List[Tuple[int, int, int]]): List of roads where each road is represented as a tuple (u, v, w) Returns: Union[int, str]: Minimum total length of the roads needed to connect all houses or \\"No solution\\" if not possible >>> town_roads(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 1, 2), (2, 4, 6)]) 9 >>> town_roads(3, 1, [(1, 2, 1)]) \\"No solution\\"","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_spanning_tree(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: if i >= len(edges): return \\"No solution\\" u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def town_roads(n, m, roads): edges = [(u-1, v-1, w) for u, v, w in roads] return minimum_spanning_tree(n, edges)"},{"question":"def apply_operations(n: int, m: int, array: List[int], operations: List[Tuple[int, int]]) -> List[int]: Applies a series of operations to an array. Parameters: n (int): Number of elements in the array. m (int): Number of operations. array (list): Initial array of integers. operations (list): List of tuples (i, x) where i is the index and x is the value to be added. Returns: list: The resulting array after applying all the operations. >>> apply_operations(5, 3, [1, 2, 3, 4, 5], [(1, 10), (3, -2), (0, 5)]) [6, 12, 3, 2, 5] >>> apply_operations(4, 0, [1, 2, 3, 4], []) [1, 2, 3, 4] >>> apply_operations(3, 1, [5, 6, 7], [(2, 3)]) [5, 6, 10] >>> apply_operations(3, 2, [0, 0, 0], [(1, 5), (1, -3)]) [0, 2, 0] >>> apply_operations(3, 2, [1000000000, 1000000000, 1000000000], [(0, -1000000000), (2, 1000000000)]) [0, 1000000000, 2000000000] >>> apply_operations(4, 3, [10, 20, 30, 40], [(0, -5), (1, -15), (2, -25)]) [5, 5, 5, 40] >>> apply_operations(3, 3, [0, 0, 0], [(0, 5), (1, 10), (2, 15)]) [5, 10, 15] >>> apply_operations(2, 2, [1, 1], [(0, 1000000000), (1, -1000000000)]) [1000000001, -999999999]","solution":"def apply_operations(n, m, array, operations): Applies a series of operations to an array. Parameters: n (int): Number of elements in the array. m (int): Number of operations. array (list): Initial array of integers. operations (list): List of tuples (i, x) where i is the index and x is the value to be added. Returns: list: The resulting array after applying all the operations. for i, x in operations: array[i] += x return array"}]`),A={name:"App",components:{PoemCard:N},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},D={class:"card-container"},P={key:0,class:"empty-state"},C=["disabled"],z={key:0},O={key:1};function Y(n,e,u,c,r,a){const f=h("PoemCard");return s(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),i(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),i("div",P,' No results found for "'+d(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),i("span",O,"Loading...")):(s(),i("span",z,"See more"))],8,C)):l("",!0)])}const I=_(A,[["render",Y],["__scopeId","data-v-9af6e328"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/39.md","filePath":"guide/39.md"}'),F={name:"guide/39.md"},U=Object.assign(F,{setup(n){return(e,u)=>(s(),i("div",null,[w(I)]))}});export{M as __pageData,U as default};
