import{_ as c,o as r,c as s,a as t,m as u,t as _,C as h,M as g,U as y,f as d,F as b,p as v,e as x,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},N={class:"review-title"},A={class:"review-content"};function L(i,e,l,f,n,a){return r(),s("div",T,[t("div",q,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),u(_(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",A,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),u(_(l.poem.solution),1)])])])}const R=c(k,[["render",L],["__scopeId","data-v-5ed7b0b5"]]),E=JSON.parse(`[{"question":"def rotate_matrix(matrix: list) -> None: Rotate the given n x n matrix 90 degrees clockwise in-place. Args: matrix (list): A list of lists representing a square 2D matrix of integers. Returns: None. The function modifies the input matrix in-place. Examples: >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix1) >>> matrix1 [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix2 = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix2) >>> matrix2 [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"def rotate_matrix(matrix: list) -> None: Rotate the given n x n matrix 90 degrees clockwise in-place. n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # save top element top = matrix[first][i] # move left to top matrix[first][i] = matrix[last - offset][first] # move bottom to left matrix[last - offset][first] = matrix[last][last - offset] # move right to bottom matrix[last][last - offset] = matrix[i][last] # move top to right matrix[i][last] = top"},{"question":"from typing import List, NamedTuple, Callable class Talk(NamedTuple): start: int end: int def schedule_talks(talks: List[Talk], key: Callable[[Talk], int] = lambda x: x.end) -> int: Calculate the maximum number of non-overlapping talks that can be attended. Args: talks (List[Talk]): a list of Talk objects, each with a start and end time. key (Callable[[Talk], int], optional): a function that takes a Talk and returns a value used for sorting. Defaults to end time. Returns: int: the maximum number of non-overlapping talks that can be attended. Examples: >>> talks = [Talk(1, 3), Talk(2, 5), Talk(3, 9), Talk(6, 8)] >>> schedule_talks(talks) 2 >>> talks = [Talk(1, 2), Talk(2, 3), Talk(3, 4)] >>> schedule_talks(talks) 3 >>> schedule_talks([]) 0 >>> talks = [Talk(1, 5), Talk(2, 3), Talk(4, 6)] >>> schedule_talks(talks) 2 from solution import schedule_talks, Talk def test_schedule_talks_example_case(): talks = [Talk(1, 3), Talk(2, 5), Talk(3, 9), Talk(6, 8)] assert schedule_talks(talks) == 2 def test_schedule_talks_no_talks(): assert schedule_talks([]) == 0 def test_schedule_talks_non_overlapping(): talks = [Talk(1, 2), Talk(2, 3), Talk(3, 4)] assert schedule_talks(talks) == 3 def test_schedule_talks_some_overlapping(): talks = [Talk(1, 3), Talk(2, 4), Talk(3, 5)] assert schedule_talks(talks) == 2 def test_schedule_talks_back_to_back(): talks = [Talk(1, 5), Talk(2, 3), Talk(4, 6)] assert schedule_talks(talks) == 2 def test_schedule_talks_custom_sort(): talks = [Talk(1, 3), Talk(2, 5), Talk(3, 9), Talk(6, 8)] custom_key = lambda x: (x.end - x.start) assert schedule_talks(talks, key=custom_key) == 2 def test_schedule_talks_single_talk(): talks = [Talk(1, 2)] assert schedule_talks(talks) == 1","solution":"from typing import List, NamedTuple, Callable class Talk(NamedTuple): start: int end: int def schedule_talks(talks: List[Talk], key: Callable[[Talk], int] = lambda x: x.end) -> int: # Sort the talks based on the given key (default is by the end time) sorted_talks = sorted(talks, key=key) max_talks = 0 last_end_time = 0 for talk in sorted_talks: if talk.start >= last_end_time: max_talks += 1 last_end_time = talk.end return max_talks"},{"question":"def generate_primes(n: int) -> list: Generate the first n prime numbers. Parameters: n (int): The number of prime numbers to generate. Returns: list: A list containing the first n prime numbers. >>> generate_primes(5) [2, 3, 5, 7, 11] >>> generate_primes(0) [] >>> generate_primes(1) [2] >>> generate_primes(-5) [] >>> generate_primes(7) [2, 3, 5, 7, 11, 13, 17]","solution":"def generate_primes(n): Generate the first n prime numbers. Parameters: n (int): The number of prime numbers to generate. Returns: list: A list containing the first n prime numbers. if not isinstance(n, int) or n <= 0: return [] primes = [] candidate = 2 while len(primes) < n: is_prime = True for p in primes: if p * p > candidate: break if candidate % p == 0: is_prime = False break if is_prime: primes.append(candidate) candidate += 1 return primes"},{"question":"class Graph: Graph class to represent an undirected graph using an adjacency list. The class supports adding vertices and edges, and performs a Depth-First Search (DFS) traversal. Example usage: >>> graph = Graph() >>> graph.add_vertex(\\"A\\") >>> graph.add_vertex(\\"B\\") >>> graph.add_vertex(\\"C\\") >>> graph.add_edge(\\"A\\", \\"B\\") >>> graph.add_edge(\\"A\\", \\"C\\") >>> graph.dfs(\\"A\\") ['A', 'B', 'C'] >>> graph = Graph() >>> graph.add_vertex(\\"A\\") >>> graph.add_edge(\\"A\\", \\"B\\") # Assume add_vertex(\\"B\\") is called implicitly Traceback (most recent call last): ... KeyError: 'B' Test cases for unit testing: def test_dfs_basic(): graph = Graph() graph.add_vertex(\\"A\\") graph.add_vertex(\\"B\\") graph.add_vertex(\\"C\\") graph.add_vertex(\\"D\\") graph.add_vertex(\\"E\\") graph.add_edge(\\"A\\", \\"B\\") graph.add_edge(\\"A\\", \\"C\\") graph.add_edge(\\"B\\", \\"D\\") graph.add_edge(\\"C\\", \\"E\\") assert graph.dfs(\\"A\\") == ['A', 'B', 'D', 'C', 'E'] assert graph.dfs(\\"C\\") == ['C', 'A', 'B', 'D', 'E'] def test_dfs_cycle(): graph = Graph() graph.add_vertex(\\"A\\") graph.add_vertex(\\"B\\") graph.add_vertex(\\"C\\") graph.add_edge(\\"A\\", \\"B\\") graph.add_edge(\\"B\\", \\"C\\") graph.add_edge(\\"C\\", \\"A\\") assert graph.dfs(\\"A\\") == ['A', 'B', 'C'] def test_dfs_single_vertex(): graph = Graph() graph.add_vertex(\\"A\\") assert graph.dfs(\\"A\\") == ['A'] def test_dfs_disconnected_graph(): graph = Graph() graph.add_vertex(\\"A\\") graph.add_vertex(\\"B\\") graph.add_vertex(\\"C\\") graph.add_vertex(\\"D\\") graph.add_vertex(\\"E\\") graph.add_edge(\\"A\\", \\"B\\") graph.add_edge(\\"A\\", \\"C\\") graph.add_edge(\\"D\\", \\"E\\") assert graph.dfs(\\"A\\") == ['A', 'B', 'C'] assert graph.dfs(\\"D\\") == ['D', 'E'] def test_dfs_complex_graph(): graph = Graph() graph.add_vertex(\\"A\\") graph.add_vertex(\\"B\\") graph.add_vertex(\\"C\\") graph.add_vertex(\\"D\\") graph.add_vertex(\\"E\\") graph.add_vertex(\\"F\\") graph.add_vertex(\\"G\\") graph.add_edge(\\"A\\", \\"B\\") graph.add_edge(\\"A\\", \\"C\\") graph.add_edge(\\"B\\", \\"D\\") graph.add_edge(\\"B\\", \\"E\\") graph.add_edge(\\"C\\", \\"F\\") graph.add_edge(\\"E\\", \\"G\\") assert graph.dfs(\\"A\\") == ['A', 'B', 'D', 'E', 'G', 'C', 'F'] def __init__(self): self.adjacency_list = {} def add_vertex(self, vertex): pass def add_edge(self, u, v): pass def dfs(self, start_vertex): pass","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = [] def add_edge(self, u, v): if u in self.adjacency_list and v in self.adjacency_list: self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def dfs(self, start_vertex): visited = set() traversal_order = [] def dfs_recursive(v): if v not in visited: visited.add(v) traversal_order.append(v) for neighbor in self.adjacency_list[v]: dfs_recursive(neighbor) dfs_recursive(start_vertex) return traversal_order"},{"question":"# Function to Implement: sum_of_nested_lists def sum_of_nested_lists(nested_list: list) -> int: Computes the sum of all integers in the nested list. Parameters: nested_list (list): A list which may contain integers and other lists of integers. Returns: int: The sum of all integers in the nested list. total_sum = 0 for element in nested_list: if isinstance(element, int): total_sum += element elif isinstance(element, list): total_sum += sum_of_nested_lists(element) return total_sum # Test cases def test_single_level_list(): assert sum_of_nested_lists([1, 2, 3, 4, 5]) == 15 def test_nested_list(): assert sum_of_nested_lists([1, [2, 3], [4, [5, 6]], 7]) == 28 def test_deeply_nested_list(): assert sum_of_nested_lists([1, [2, [3, [4, [5]]]]]) == 15 def test_list_with_negatives(): assert sum_of_nested_lists([1, [-2, 3], [-4, [5, -6]], 7]) == 4 def test_all_nested_empty_sublist(): assert sum_of_nested_lists([[], [[]], [[[]]]]) == 0 def test_empty_list(): assert sum_of_nested_lists([]) == 0","solution":"def sum_of_nested_lists(nested_list: list) -> int: Computes the sum of all integers in the nested list. Parameters: nested_list (list): A list which may contain integers and other lists of integers. Returns: int: The sum of all integers in the nested list. total_sum = 0 for element in nested_list: if isinstance(element, int): total_sum += element elif isinstance(element, list): total_sum += sum_of_nested_lists(element) return total_sum"},{"question":"def is_palindrome_check(s: str) -> bool: Returns True if the given string is a palindrome, ignoring non-alphanumeric characters and case differences. >>> is_palindrome_check(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome_check(\\"race a car\\") False >>> is_palindrome_check(\\"\\") True >>> is_palindrome_check(\\" \\") True >>> is_palindrome_check(\\"0P\\") False def reverse_and_compare(s: str) -> bool: Returns True if the given string is a palindrome by reversing the string and comparing it to the original, ignoring non-alphanumeric characters and case differences. >>> reverse_and_compare(\\"A man, a plan, a canal: Panama\\") True >>> reverse_and_compare(\\"race a car\\") False >>> reverse_and_compare(\\"\\") True >>> reverse_and_compare(\\" \\") True >>> reverse_and_compare(\\"0P\\") False","solution":"def is_palindrome_check(s: str) -> bool: Returns True if the given string is a palindrome, ignoring non-alphanumeric characters and case differences. def is_alphanumeric(c): return c.isalnum() left, right = 0, len(s) - 1 while left < right: while left < right and not is_alphanumeric(s[left]): left += 1 while left < right and not is_alphanumeric(s[right]): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True def reverse_and_compare(s: str) -> bool: Returns True if the given string is a palindrome by reversing the string and comparing it to the original, ignoring non-alphanumeric characters and case differences. filtered_chars = [c.lower() for c in s if c.isalnum()] reversed_chars = filtered_chars[::-1] return filtered_chars == reversed_chars"},{"question":"def calculate_binomial_coefficient(n: int, k: int) -> int: Compute the binomial coefficient C(n, k). :param n: The size of the set (n ≥ 0). :param k: The size of the subset to choose (0 ≤ k ≤ n). :return: The binomial coefficient C(n, k). >>> calculate_binomial_coefficient(5, 2) 10 >>> calculate_binomial_coefficient(10, 3) 120 >>> calculate_binomial_coefficient(0, 0) 1 >>> calculate_binomial_coefficient(10, 0) 1 >>> calculate_binomial_coefficient(10, 10) 1 >>> calculate_binomial_coefficient(1, 2) Traceback (most recent call last): ... ValueError: k is greater than n. >>> calculate_binomial_coefficient(-5, 2) Traceback (most recent call last): ... ValueError: n and k should be non-negative. >>> calculate_binomial_coefficient(10, \\"three\\") Traceback (most recent call last): ... TypeError: n and k must be integers.","solution":"def calculate_binomial_coefficient(n, k): Compute the binomial coefficient C(n, k). :param n: The size of the set (n ≥ 0). :param k: The size of the subset to choose (0 ≤ k ≤ n). :return: The binomial coefficient C(n, k). if not isinstance(n, int) or not isinstance(k, int): raise TypeError(\\"n and k must be integers.\\") if n < 0 or k < 0: raise ValueError(\\"n and k should be non-negative.\\") if k > n: raise ValueError(\\"k is greater than n.\\") if k == 0 or k == n: return 1 k = min(k, n - k) c = 1 for i in range(k): c = c * (n - i) // (i + 1) return c"},{"question":"def count_palindrome_words(s: str) -> int: Given a string, return the total number of words in the string that are palindromes. >>> count_palindrome_words(\\"madam arora teaches malayalam\\") 3 >>> count_palindrome_words(\\"nurses run\\") 0 >>> count_palindrome_words(\\"hello world\\") 0 >>> count_palindrome_words(\\"a b c d\\") 4 >>> count_palindrome_words(\\"\\") 0 pass def test_single_word_palindrome(): assert count_palindrome_words(\\"madam\\") == 1 def test_single_word_not_palindrome(): assert count_palindrome_words(\\"hello\\") == 0 def test_multiple_palindromes(): assert count_palindrome_words(\\"madam arora teaches malayalam\\") == 3 def test_no_palindromes(): assert count_palindrome_words(\\"hello world\\") == 0 def test_palindrome_with_spaces(): assert count_palindrome_words(\\"nurses run\\") == 0 # \\"nurses run\\" aren't palindromes themselves def test_mixed_case_palindromes(): assert count_palindrome_words(\\"level civic rotor\\") == 3 def test_empty_string(): assert count_palindrome_words(\\"\\") == 0 def test_strings_with_single_char_words(): assert count_palindrome_words(\\"a b c d\\") == 4 assert count_palindrome_words(\\"a a a b b b\\") == 6 def test_large_input(): assert count_palindrome_words(\\" \\".join([\\"madam\\"] * 1000000)) == 1000000 # Test with 1 million instances of \\"madam\\"","solution":"def count_palindrome_words(s: str) -> int: Returns the total number of palindrome words in a given string. words = s.split() palindrome_count = 0 for word in words: if word == word[::-1]: palindrome_count += 1 return palindrome_count"},{"question":"def is_palindromic_substring(input_string: str, start: int, end: int) -> bool: Check if a specific substring of the input string is a palindrome. >>> is_palindromic_substring(\\"racecar\\", 0, 6) True >>> is_palindromic_substring(\\"level\\", 0, 4) True >>> is_palindromic_substring(\\"hello\\", 1, 3) False","solution":"def is_palindromic_substring(input_string: str, start: int, end: int) -> bool: Checks if the substring of input_string from start to end (inclusive) is a palindrome. while start < end: if input_string[start] != input_string[end]: return False start += 1 end -= 1 return True"},{"question":"from typing import List def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: Find the median of two sorted arrays merged into one sorted array. >>> find_median_sorted_arrays([1, 3], [2]) 2 >>> find_median_sorted_arrays([1, 2], [3, 4]) 2.5","solution":"def find_median_sorted_arrays(nums1: [int], nums2: [int]) -> float: if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 x, y = len(nums1), len(nums2) low, high = 0, x while low <= high: partitionX = (low + high) // 2 partitionY = (x + y + 1) // 2 - partitionX maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1] minX = float('inf') if partitionX == x else nums1[partitionX] maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1] minY = float('inf') if partitionY == y else nums2[partitionY] if maxX <= minY and maxY <= minX: if (x + y) % 2 == 0: return (max(maxX, maxY) + min(minX, minY)) / 2 else: return max(maxX, maxY) elif maxX > minY: high = partitionX - 1 else: low = partitionX + 1 raise ValueError(\\"Input arrays are not valid\\")"},{"question":"import heapq def n_th_ugly_number(n: int) -> int: Given an integer \`n\`, return the nth ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, and 5. >>> n_th_ugly_number(10) 12 >>> n_th_ugly_number(1) 1 >>> n_th_ugly_number(15) 24","solution":"import heapq def n_th_ugly_number(n: int) -> int: # Min-heap to keep track of the next smallest ugly number heap = [1] # A set to check for duplicates before inserting in the heap seen = {1} # Factors for ugly numbers factors = [2, 3, 5] # Generate ugly numbers until we reach the nth one for _ in range(n): # Extract the smallest number from the heap current_ugly = heapq.heappop(heap) # Generate new ugly numbers and add them to the heap if they are not seen before for factor in factors: new_ugly = current_ugly * factor if new_ugly not in seen: heapq.heappush(heap, new_ugly) seen.add(new_ugly) return current_ugly"},{"question":"def reachable_nodes(graph, start): Returns a set of all nodes that can be reached from the given starting node. >>> reachable_nodes({'A': ['B', 'C'], 'B': ['C', 'D'], 'C': [], 'D': ['E'], 'E': []}, 'A') {'A', 'B', 'C', 'D', 'E'} >>> reachable_nodes({1: [2, 3], 2: [4], 3: [5], 4: [], 5: []}, 1) {1, 2, 3, 4, 5} >>> reachable_nodes({}, 'A') set()","solution":"def reachable_nodes(graph, start): Returns a set of all nodes that can be reached from the given starting node. Parameters: - graph (dict): Dictionary representing the directed graph. - start (str/int): The starting node. Returns: - set: Set of reachable nodes. if not graph or start not in graph: return {start} if start in graph else set() visited = set() stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: stack.append(neighbor) return visited"},{"question":"from typing import List, Tuple import time def sieve_of_eratosthenes(n: int) -> Tuple[List[int], float]: Find all prime numbers less than the given integer \`n\` using the sieve of Eratosthenes, and return the list of primes along with the time taken to perform the computation. :param n: The upper limit (exclusive) to find primes below. :returns: A tuple consisting of a list of prime numbers and the time taken to compute them. :raises ValueError: If n is less than 2. # Test case 1: primes, time_taken = sieve_of_eratosthenes(10) assert primes == [2, 3, 5, 7] assert type(time_taken) == float # Test case 2: primes, time_taken = sieve_of_eratosthenes(20) assert primes == [2, 3, 5, 7, 11, 13, 17, 19] assert type(time_taken) == float # Test case 3: try: sieve_of_eratosthenes(1) except ValueError: pass # Test case 4: primes, time_taken = sieve_of_eratosthenes(30) assert primes == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] assert type(time_taken) == float # Test case 5: primes, time_taken = sieve_of_eratosthenes(1000) assert len(primes) == 168 assert primes[-1] == 997 assert type(time_taken) == float","solution":"from typing import List, Tuple import time def sieve_of_eratosthenes(n: int) -> Tuple[List[int], float]: if n < 2: raise ValueError(\\"\`n\` must be greater than or equal to 2.\\") start_time = time.time() sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False primes_list = [num for num, is_prime in enumerate(sieve) if is_prime] elapsed_time = time.time() - start_time return (primes_list, elapsed_time)"},{"question":"def convert_binary_to_decimal(binary_str: str) -> int: Converts a binary string into its decimal integer equivalent. Parameters: binary_str (str): The binary string to convert. Returns: int: The decimal equivalent of the binary number or -1 for invalid input. Examples: >>> convert_binary_to_decimal(\\"101\\") 5 >>> convert_binary_to_decimal(\\"1101\\") 13 >>> convert_binary_to_decimal(\\" 1110 \\") 14 >>> convert_binary_to_decimal(\\" 1001 \\") 9 >>> convert_binary_to_decimal(\\" \\") -1 >>> convert_binary_to_decimal(None) -1 def test_convert_binary_to_decimal(): # Testing valid binary strings assert convert_binary_to_decimal(\\"101\\") == 5 assert convert_binary_to_decimal(\\"1101\\") == 13 assert convert_binary_to_decimal(\\" 1110 \\") == 14 assert convert_binary_to_decimal(\\" 1001 \\") == 9 # Testing invalid binary strings assert convert_binary_to_decimal(\\" \\") == -1 assert convert_binary_to_decimal(None) == -1 assert convert_binary_to_decimal(\\"abc\\") == -1 assert convert_binary_to_decimal(\\"123\\") == -1 assert convert_binary_to_decimal(\\"2\\") == -1 assert convert_binary_to_decimal(\\"10210\\") == -1 # Testing edge cases assert convert_binary_to_decimal(\\"\\") == -1 assert convert_binary_to_decimal(\\"0\\") == 0 assert convert_binary_to_decimal(\\"1\\") == 1 assert convert_binary_to_decimal(\\"0000\\") == 0 assert convert_binary_to_decimal(\\"1111\\") == 15","solution":"def convert_binary_to_decimal(binary_str: str) -> int: Converts a binary string into its decimal integer equivalent. Parameters: binary_str (str): The binary string to convert. Returns: int: The decimal equivalent of the binary number or -1 for invalid input. if binary_str is None: return -1 # Strip leading or trailing spaces from the string binary_str = binary_str.strip() # Return -1 if the string is empty after stripping spaces if binary_str == \\"\\": return -1 # Check if the string contains only '0' and '1' characters if not all(char in '01' for char in binary_str): return -1 # Convert the binary string to a decimal integer decimal_value = 0 for i, char in enumerate(reversed(binary_str)): if char == '1': decimal_value += 2 ** i return decimal_value"},{"question":"def sum_of_multiples(limit: int) -> int: Calculate the sum of all multiples of 3 or 5 below the given limit. Parameters: limit (int): the upper bound (exclusive) to find multiples Returns: int: Sum of all multiples of 3 or 5 below the limit Example: >>> sum_of_multiples(10) 23 >>> sum_of_multiples(20) 78","solution":"def sum_of_multiples(limit: int) -> int: Returns the sum of all multiples of 3 or 5 below the given limit. Parameters: limit (int): the upper bound (exclusive) to find multiples Returns: int: Sum of all multiples of 3 or 5 below the limit # Initialize sum total_sum = 0 # Iterate through each number below the limit for i in range(limit): # Check if the number is a multiple of 3 or 5 if i % 3 == 0 or i % 5 == 0: total_sum += i return total_sum"},{"question":"# Scenario You are developing a tool to compress large text files for efficient storage and transmission. Implementing an algorithm to encode text using Huffman coding is crucial for achieving high compression ratios. # Problem Statement **Task**: Implement the Huffman Coding algorithm to generate the Huffman codes for each character in a given text string. **Function Name**: \`huffman_coding\` **Input**: - \`text\`: A string, representing the input text for which we need to generate Huffman codes. **Output**: - \`codes\`: A dictionary where keys are characters from the input text and values are the corresponding Huffman codes as strings. # Example text = \\"this is an example for huffman encoding\\" codes = huffman_coding(text) print(codes) # Output could be: {' ': '00', 'a': '010', 'c': '0110', 'd': '0111', 'e': '100', 'f': '101', 'g': '1100', 'h': '1101', 'i': '1110', 'l': '11110', 'm': '11111', 'n': '1000', 'o': '1001', 'p': '1100', 'r': '1011', 's': '1110', 't': '0000', 'u': '01110', 'x': '01000'} # Constraints - The function should handle both uppercase and lowercase letters as different characters. - Non-alphabet characters (spaces, punctuation) should also be included in the Huffman coding. # Performance Requirements - The solution should have a time complexity of O(n log n) where n is the number of unique characters in the input text. - The space complexity should be O(n). # Implementation Guidance 1. Count the frequency of each character in the text. 2. Build a priority queue (min-heap) of nodes where each node represents a character and its frequency. 3. While the priority queue has more than one node: - Extract the two nodes with the lowest frequency. - Create a new internal node with these two nodes as children and the sum of their frequencies as the new frequency. - Insert the new node back into the priority queue. 4. The remaining node is the root of the Huffman tree. Traverse the tree to generate the codes. from heapq import heappush, heappop, heapify from collections import Counter class Node: def __init__(char=None, freq=0): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def huffman_coding(text: str) -> dict: if not text: return {} # Count the frequency of each character in the text frequency = Counter(text) # Create a heap (priority queue) of nodes heap = [Node(char, freq) for char, freq in frequency.items()] heapify(heap) # Combine nodes until there's only one node left (the root of the Huffman tree) while len(heap) > 1: node1 = heappop(heap) node2 = heappop(heap) merged = Node(freq=node1.freq + node2.freq) merged.left = node1 merged.right = node2 heappush(heap, merged) # The remaining node is the root of the Huffman tree root = heap[0] huffman_codes = {} def generate_codes(node, code=\\"\\"): if node is not None: if node.char is not None: huffman_codes[node.char] = code generate_codes(node.left, code + \\"0\\") generate_codes(node.right, code + \\"1\\") generate_codes(root) return huffman_codes Output Format: [Completion Task in Python]","solution":"from heapq import heappush, heappop, heapify from collections import Counter class Node: def __init__(self, char=None, freq=0): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def huffman_coding(text: str) -> dict: if not text: return {} # Count the frequency of each character in the text frequency = Counter(text) # Create a heap (priority queue) of nodes heap = [Node(char, freq) for char, freq in frequency.items()] heapify(heap) # Combine nodes until there's only one node left (the root of the Huffman tree) while len(heap) > 1: node1 = heappop(heap) node2 = heappop(heap) merged = Node(freq=node1.freq + node2.freq) merged.left = node1 merged.right = node2 heappush(heap, merged) # The remaining node is the root of the Huffman tree root = heap[0] huffman_codes = {} def generate_codes(node, code=\\"\\"): if node is not None: if node.char is not None: huffman_codes[node.char] = code generate_codes(node.left, code + \\"0\\") generate_codes(node.right, code + \\"1\\") generate_codes(root) return huffman_codes"},{"question":"[Completion Task in Python] days_between_dates \\"Determine the number of days between two given dates.\\" Function Signature: def days_between_dates(date1: str, date2: str) -> int: Examples: >>> days_between_dates(\\"2023-04-01\\", \\"2023-04-10\\") 9 >>> days_between_dates(\\"2020-01-01\\", \\"2020-01-01\\") 0 >>> days_between_dates(\\"2023-04-10\\", \\"2023-04-01\\") 9 >>> days_between_dates(\\"2020-01-01\\", \\"2019-12-31\\") 1 def days_between_dates(date1: str, date2: str) -> int: Returns the number of full days between two dates. date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) delta = abs((d2 - d1).days) return delta","solution":"from datetime import datetime def days_between_dates(date1: str, date2: str) -> int: Returns the number of full days between two dates. date_format = \\"%Y-%m-%d\\" d1 = datetime.strptime(date1, date_format) d2 = datetime.strptime(date2, date_format) delta = abs((d2 - d1).days) return delta"},{"question":"from solution import rearrange_string def test_rearrange_string_possible(): assert rearrange_string(\\"aabbcc\\", 3) == \\"abcabc\\" def test_rearrange_string_impossible(): assert rearrange_string(\\"aaab\\", 2) == \\"\\" def test_rearrange_string_single_char(): assert rearrange_string(\\"a\\", 1) == \\"a\\" def test_rearrange_string_no_rearrangement_needed(): assert rearrange_string(\\"abcdef\\", 1) == \\"abcdef\\" def test_rearrange_string_large_k(): assert rearrange_string(\\"aaabbcc\\", 4) == \\"\\" def test_rearrange_string_large_input(): assert rearrange_string(\\"a\\" * 10000, 10000) == \\"\\" def test_rearrange_string_k_is_zero(): assert rearrange_string(\\"aaabbcc\\", 0) == \\"aaabbcc\\"","solution":"import heapq from collections import Counter, deque def rearrange_string(s: str, k: int) -> str: if k == 0: return s char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] wait_queue = deque() while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((char, count + 1)) if len(wait_queue) < k: continue next_char, next_count = wait_queue.popleft() if -next_count > 0: heapq.heappush(max_heap, (next_count, next_char)) return ''.join(result) if len(result) == len(s) else \\"\\""},{"question":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Calculates the frequency of each unique word in the given text. Args: text: A string containing the text to analyze. Returns: A dictionary where the keys are unique words and the values are their frequencies. Example: >>> word_frequency(\\"Hello, world! Hello, everyone.\\") {'hello': 2, 'world': 1, 'everyone': 1} >>> word_frequency(\\"Python is great. Python is versatile.\\") {'python': 2, 'is': 2, 'great': 1, 'versatile': 1} # Your code goes here","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Calculates the frequency of each unique word in the given text. Args: text: A string containing the text to analyze. Returns: A dictionary where the keys are unique words and the values are their frequencies. text = text.lower() words = re.findall(r'bw+b', text) frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"def is_rotated_palindrome(s: str) -> bool: Determine whether the given string can be rotated to form a palindrome. Check if the given string s can be rotated (or shifted) any number of positions to become a palindrome. >>> is_rotated_palindrome(\\"aab\\") == True >>> is_rotated_palindrome(\\"abc\\") == False","solution":"def is_palindrome(s): Helper function to check if a given string is a palindrome. return s == s[::-1] def is_rotated_palindrome(s: str) -> bool: Determine whether the given string can be rotated to form a palindrome. if len(s) <= 1: return True # Construct a new string which is the original string concatenated to itself doubled_s = s + s # Check all substrings of length len(s) in the doubled string for i in range(len(s)): if is_palindrome(doubled_s[i:i + len(s)]): return True return False"},{"question":"def max_subarray_sum(arr: list) -> int: Implements Kadane's Algorithm to find the maximum sum of a contiguous subarray within a given list of integers. Parameters: arr (list): A list of integers where -10^6 <= arr[i] <= 10^6. Returns: int: The maximum sum of a contiguous subarray. >>> max_subarray_sum([4, -1, 2, 1]) 6 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-4, -2, -3, -1]) -1 >>> max_subarray_sum([5]) 5 # Your implementation here. def test_max_subarray_sum_positive_numbers(): assert max_subarray_sum([1, 2, 3, 4]) == 10 def test_max_subarray_sum_mixed_numbers(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_max_subarray_sum_with_negatives(): assert max_subarray_sum([-4, -2, -3, -1]) == -1 def test_max_subarray_sum_single_element(): assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_max_subarray_sum_mixed_with_large(): assert max_subarray_sum([-10**6, 2, -3, 50, -1]) == 50 def test_max_subarray_sum_mixed_with_small(): assert max_subarray_sum([4, -1, 2, 1]) == 6 assert max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5]) == 18","solution":"def max_subarray_sum(arr: list) -> int: Implements Kadane's Algorithm to find the maximum sum of a contiguous subarray within a given list of integers. Parameters: arr (list): A list of integers. Returns: int: The maximum sum of a contiguous subarray. if not arr: return 0 max_current = max_global = arr[0] for number in arr[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def find_k_largest_elements(input_list: List[int], k: int) -> List[int]: Finds the k largest elements in an input list of integers. Parameters: input_list (List[int]): A list of integers. k (int): The number of largest elements to find. Returns: List[int]: A list containing the k largest elements from the input list, sorted in descending order. Examples: >>> find_k_largest_elements([3, 1, 5, 12, 2, 11], 3) [12, 11, 5] >>> find_k_largest_elements([9, 4, 7, 1, -2, 6, 5], 2) [9, 7] >>> find_k_largest_elements([20, 10, 30, 50, 40], 1) [50] >>> find_k_largest_elements([4, 4, 4, 4, 4], 3) [4, 4, 4] >>> find_k_largest_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) [10, 9, 8, 7, 6]","solution":"import heapq def find_k_largest_elements(input_list: list[int], k: int) -> list[int]: Finds and returns the k largest elements in the input list, sorted in descending order. Parameters: input_list (list): A list of integers. k (int): The number of largest elements to find. Returns: list: A list containing the k largest elements in descending order. # Use a heap to efficiently find the k largest elements k_largest = heapq.nlargest(k, input_list) # Return the largest elements sorted in descending order return sorted(k_largest, reverse=True)"},{"question":"def manage_call_queue(commands: list) -> list: Simulates the management of an emergency call queue for a hospital. The function processes a list of commands to either add a new call to the queue, process an existing call by removing it from the queue, or retrieve the current state of the queue. Args: commands (list): A list of tuples where each tuple represents a command. Each command can be one of the following: - (\\"ADD\\", call_id): Add a new call to the queue with the identifier \`call_id\` (a string). - (\\"PROCESS\\",): Process (i.e., remove) the call that has been in the queue the longest (FIFO order). - (\\"RETRIEVE\\",): Retrieve and return the current state of the queue as a list of \`call_id\`s in FIFO order. Returns: list: A list of lists. Each inner list is a snapshot of the queue for each \`RETRIEVE\` command in the order they were processed. >>> manage_call_queue([ ... (\\"ADD\\", \\"C123\\"), ... (\\"ADD\\", \\"C124\\"), ... (\\"RETRIEVE\\",), ... (\\"PROCESS\\",), ... (\\"RETRIEVE\\",), ... (\\"ADD\\", \\"C125\\"), ... (\\"RETRIEVE\\",) ... ]) [[\\"C123\\", \\"C124\\"], [\\"C124\\"], [\\"C124\\", \\"C125\\"]] >>> manage_call_queue([ ... (\\"ADD\\", \\"A1\\"), ... (\\"ADD\\", \\"A2\\"), ... (\\"PROCESS\\",), ... (\\"ADD\\", \\"A3\\"), ... (\\"RETRIEVE\\",) ... ]) [[\\"A2\\", \\"A3\\"]]","solution":"def manage_call_queue(commands): Manages an emergency call queue based on the given commands. queue = [] result = [] for command in commands: if command[0] == \\"ADD\\": call_id = command[1] queue.append(call_id) elif command[0] == \\"PROCESS\\": if queue: queue.pop(0) elif command[0] == \\"RETRIEVE\\": result.append(queue.copy()) return result"},{"question":"from datetime import datetime, timedelta import uuid class SessionManager: SESSION_DURATION = timedelta(minutes=30) def __init__(self): self.sessions = {} def create_session(self, user_id: int) -> str: Create a new session for a given user ID. Invalidate any existing session for the user. Args: user_id (int): The ID of the user. Returns: str: A unique session ID. pass def get_session_info(self, session_id: str) -> dict: Retrieve information associated with a session ID. Args: session_id (str): The session ID. Returns: dict: A dictionary with keys \\"user_id\\" and \\"created_at\\". pass def delete_session(self, session_id: str) -> bool: Delete a session with a given session ID. Args: session_id (str): The session ID. Returns: bool: True if the session was successfully deleted, otherwise False. pass def cleanup_expired_sessions(self) -> None: Delete all sessions that have expired. pass def is_valid_session(self, session_id: str) -> bool: Check if a session ID is still valid (i.e., not expired and exists). Args: session_id (str): The session ID. Returns: bool: True if the session is valid, otherwise False. pass def test_create_session(): manager = SessionManager() user_id = 1 session_id = manager.create_session(user_id) assert isinstance(session_id, str) assert session_id in manager.sessions assert manager.sessions[session_id][\\"user_id\\"] == user_id def test_get_session_info(): manager = SessionManager() user_id = 1 session_id = manager.create_session(user_id) session_info = manager.get_session_info(session_id) assert session_info[\\"user_id\\"] == user_id assert isinstance(session_info[\\"created_at\\"], datetime) assert manager.get_session_info(\\"invalid_id\\") is None def test_delete_session(): manager = SessionManager() user_id = 1 session_id = manager.create_session(user_id) assert manager.delete_session(session_id) is True assert session_id not in manager.sessions assert user_id not in manager.user_sessions assert manager.delete_session(session_id) is False def test_cleanup_expired_sessions(): manager = SessionManager() user_id = 1 session_id = manager.create_session(user_id) manager.sessions[session_id][\\"created_at\\"] = datetime.now() - timedelta(minutes=31) manager.cleanup_expired_sessions() assert session_id not in manager.sessions def test_is_valid_session(): manager = SessionManager() user_id = 1 session_id = manager.create_session(user_id) assert manager.is_valid_session(session_id) is True manager.sessions[session_id][\\"created_at\\"] = datetime.now() - timedelta(minutes=31) assert manager.is_valid_session(session_id) is False assert manager.is_valid_session(\\"invalid_id\\") is False def test_single_active_session_per_user(): manager = SessionManager() user_id = 1 session_id1 = manager.create_session(user_id) session_id2 = manager.create_session(user_id) assert session_id1 != session_id2 assert session_id1 not in manager.sessions assert session_id2 in manager.sessions assert manager.user_sessions[user_id] == session_id2","solution":"from datetime import datetime, timedelta import uuid class SessionManager: SESSION_DURATION = timedelta(minutes=30) def __init__(self): self.sessions = {} self.user_sessions = {} def create_session(self, user_id: int) -> str: # Invalidate any existing session for the user if user_id in self.user_sessions: old_session_id = self.user_sessions[user_id] if old_session_id in self.sessions: del self.sessions[old_session_id] # Create a new session session_id = str(uuid.uuid4()) created_at = datetime.now() self.sessions[session_id] = {\\"user_id\\": user_id, \\"created_at\\": created_at} self.user_sessions[user_id] = session_id return session_id def get_session_info(self, session_id: str) -> dict: # Retrieve session information return self.sessions.get(session_id, None) def delete_session(self, session_id: str) -> bool: if session_id in self.sessions: user_id = self.sessions[session_id]['user_id'] del self.sessions[session_id] if user_id in self.user_sessions and self.user_sessions[user_id] == session_id: del self.user_sessions[user_id] return True return False def cleanup_expired_sessions(self) -> None: now = datetime.now() expired_sessions = [sid for sid, info in self.sessions.items() if now - info[\\"created_at\\"] > self.SESSION_DURATION] for session_id in expired_sessions: user_id = self.sessions[session_id]['user_id'] del self.sessions[session_id] if user_id in self.user_sessions and self.user_sessions[user_id] == session_id: del self.user_sessions[user_id] def is_valid_session(self, session_id: str) -> bool: if session_id in self.sessions: session_info = self.sessions[session_id] if datetime.now() - session_info[\\"created_at\\"] <= self.SESSION_DURATION: return True return False"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: Merges two sorted singly linked lists into one sorted linked list. >>> merge_two_sorted_linked_lists(ListNode(1, ListNode(2, ListNode(4))), ListNode(1, ListNode(3, ListNode(4)))) # Returns l1 -> 1 -> 2 -> 3 -> 4 -> 4 >>> merge_two_sorted_linked_lists(ListNode(5), ListNode(1, ListNode(2, ListNode(3)))) # Returns l1 -> 1 -> 2 -> 3 -> 5 pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next if l1: tail.next = l1 if l2: tail.next = l2 return dummy.next"},{"question":"class CustomDict: Custom dictionary class with case-insensitive search and search count logging. >>> d = CustomDict() >>> d['Apple'] = 10 >>> d['banana'] = 20 >>> d['Cherry'] = 30 >>> d['apple'] 10 >>> d['BANANA'] 20 >>> try: ... d['Grape'] ... except KeyError: ... print('KeyError raised') # Expected output >>> d.get_search_report() (2, 1) def __init__(self): pass def __setitem__(self, key, value): pass def __getitem__(self, key): pass def get_search_report(self): pass","solution":"class CustomDict: def __init__(self): self._data = {} self.successful_searches = 0 self.unsuccessful_searches = 0 def __setitem__(self, key, value): self._data[key.lower()] = (key, value) def __getitem__(self, key): lower_key = key.lower() if lower_key in self._data: self.successful_searches += 1 return self._data[lower_key][1] else: self.unsuccessful_searches += 1 raise KeyError(f\\"Key '{key}' not found\\") def get_search_report(self): return self.successful_searches, self.unsuccessful_searches"},{"question":"def find_happy_numbers(start: int, end: int) -> list: Returns a list of all happy numbers in the range [start, end]. >>> find_happy_numbers(1, 10) [1, 7, 10] >>> find_happy_numbers(15, 25) [19]","solution":"def find_happy_numbers(start: int, end: int) -> list: Returns a list of all happy numbers in the range [start, end]. def is_happy(n): seen = set() while n != 1 and n not in seen: seen.add(n) n = sum(int(digit) ** 2 for digit in str(n)) return n == 1 happy_numbers = [] for num in range(start, end + 1): if is_happy(num): happy_numbers.append(num) return happy_numbers"},{"question":"def min_operations_to_transform(s1: str, s2: str) -> int: Calculate the minimum number of operations required to transform s1 into s2. Operations allowed: insertion, deletion, substitution. Uses dynamic programming for optimal performance. :param s1: str - source string :param s2: str - target string :return: int - minimum number of operations required >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") == 3 >>> min_operations_to_transform(\\"flaw\\", \\"lawn\\") == 2 >>> min_operations_to_transform(\\"\\", \\"abc\\") == 3 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") == 0 >>> min_operations_to_transform(\\"intention\\", \\"execution\\") == 5 >>> min_operations_to_transform(\\"horse\\", \\"ros\\") == 3 >>> min_operations_to_transform(\\"\\", \\"\\") == 0 >>> min_operations_to_transform(\\"a\\", \\"\\") == 1 >>> min_operations_to_transform(\\"\\", \\"a\\") == 1 pass","solution":"def min_operations_to_transform(s1: str, s2: str) -> int: Calculate the minimum number of operations required to transform s1 into s2. Operations allowed: insertion, deletion, substitution. Uses dynamic programming for optimal performance. :param s1: str - source string :param s2: str - target string :return: int - minimum number of operations required m, n = len(s1), len(s2) # If one of the strings is empty if m == 0: return n if n == 0: return m # Create a DP table to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore last char and recur for remaining string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are different, consider all possibilities and find minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def custom_atbash_encode(plain: str) -> str: Converts a given string using the atbash cipher. >>> custom_atbash_encode(\\"hello world!\\") 'svool dliow!' >>> custom_atbash_encode(\\"abc xyz\\") 'zyx cba' >>> custom_atbash_encode(\\"123-456-789\\") '123-456-789' >>> custom_atbash_encode(\\"the quick brown-fox jumps over the lazy-dog.\\") 'gsv jfrxp yildm-ulc qfnkh levi gsv ozab-wlt.' pass def custom_atbash_decode(encoded: str) -> str: Reverses the modified atbash cipher transformation to retrieve the original string. >>> custom_atbash_decode(\\"svool dliow!\\") 'hello world!' >>> custom_atbash_decode(\\"zyx cba\\") 'abc xyz' >>> custom_atbash_decode(\\"123-456-789\\") '123-456-789' >>> custom_atbash_decode(\\"gsv jfrxp yildm-ulc qfnkh levi gsv ozab-wlt.\\") 'the quick brown-fox jumps over the lazy-dog.' pass","solution":"def custom_atbash_encode(plain: str) -> str: def atbash(char): if 'a' <= char <= 'z': return chr(ord('z') - (ord(char) - ord('a'))) return char return ''.join(atbash(char) for char in plain) def custom_atbash_decode(encoded: str) -> str: return custom_atbash_encode(encoded)"},{"question":"from typing import List def tokenize(sentence: str) -> List[str]: Tokenizes a given sentence into words, removing leading or trailing punctuation. >>> tokenize(\\"Hello, world! This is a test.\\") ['Hello', 'world', 'This', 'is', 'a', 'test'] >>> tokenize(\\"High-quality, efficient code!\\") ['High-quality', 'efficient', 'code'] >>> tokenize(\\"Let's, tokenize: this sentence correctly.\\") ['Let's', 'tokenize', 'this', 'sentence', 'correctly']","solution":"from typing import List import re def tokenize(sentence: str) -> List[str]: Tokenizes a given sentence into words, removing leading or trailing punctuation. # Define a regex pattern to match words, including internal punctuation pattern = r'bw[w'-]*w?b' # Find all words using the regex pattern words = re.findall(pattern, sentence) return words"},{"question":"import math import scipy.special def gelu(inputs: list[float]) -> list[float]: Applies the GELU (Gaussian Error Linear Unit) activation function to each element in the input list. Args: inputs (list of float): List of input values to apply the GELU function. Returns: list of float: The input values transformed by the GELU activation function. Example: >>> gelu([0.5, -1.0, 3.0, -2.0, 0.0]) [0.3457312306375286, -0.1588080373121406, 2.996362425668276, -0.0003499581780757233, 0.0]","solution":"import math import scipy.special def gelu(inputs): Applies the GELU activation function to each element in the input list. Args: inputs (list of float): List of input values to apply the GELU function. Returns: list of float: The input values transformed by the GELU activation function. return [x * 0.5 * (1 + scipy.special.erf(x / math.sqrt(2))) for x in inputs]"},{"question":"import csv def find_top_student(file_path: str, grade_threshold: float) -> tuple[str, str]: Reads student grade data from a CSV file, calculates the average grade for each student excluding grades below the grade_threshold, and returns the name and student ID of the student with the highest average grade. Args: - file_path (str): The path to the CSV file containing student grade data. - grade_threshold (float): The minimum grade that should be considered when calculating averages. Returns: - A tuple (name, student_id): The name and student ID of the top-performing student. Example: >>> find_top_student('grades.csv', 60) ('Carol', '13579') pass # Unit tests import pytest def test_top_student_with_valid_data(): sample_data = name,student_id,math,science,english Alice,12345,88,92,87 Bob,67890,75,50,80 Carol,13579,90,85,93 Dave,24680,70,72,65 with open('grades.csv', 'w') as file: file.write(sample_data) result = find_top_student('grades.csv', 60) assert result == ('Carol', '13579') def test_top_student_with_missing_grades(): sample_data = name,student_id,math,science,english Alice,12345,88,,87 Bob,67890,75,50,80 Carol,13579,90,85,93 with open('grades.csv', 'w') as file: file.write(sample_data) result = find_top_student('grades.csv', 60) assert result == ('Carol', '13579') def test_top_student_with_all_grades_below_threshold(): sample_data = name,student_id,math,science,english Alice,12345,55,52,50 Bob,67890,45,40,40 Carol,13579,30,20,35 Dave,24680,20,18,15 with open('grades.csv', 'w') as file: file.write(sample_data) result = find_top_student('grades.csv', 60) assert result is None def test_top_student_with_empty_file(): sample_data = name,student_id,math,science,english with open('grades.csv', 'w') as file: file.write(sample_data) result = find_top_student('grades.csv', 60) assert result is None def test_top_student_with_single_student(): sample_data = name,student_id,math,science,english Alice,12345,88,92,87 with open('grades.csv', 'w') as file: file.write(sample_data) result = find_top_student('grades.csv', 60) assert result == ('Alice', '12345') def test_top_student_with_grades_on_threshold(): sample_data = name,student_id,math,science,english Alice,12345,60,60,60 Bob,67890,60,60,60 Carol,13579,60,60,60 with open('grades.csv', 'w') as file: file.write(sample_data) result = find_top_student('grades.csv', 60) assert result == ('Alice', '12345')","solution":"import csv def find_top_student(file_path: str, grade_threshold: float) -> tuple[str, str]: Reads student grade data from a CSV file, calculates the average grade for each student excluding grades below the grade_threshold, and returns the name and student ID of the student with the highest average grade. top_student = None highest_avg_grade = 0 try: with open(file_path, mode='r') as file: csv_reader = csv.DictReader(file) for row in csv_reader: name = row['name'] student_id = row['student_id'] grades = [ float(value) for key, value in row.items() if key not in ['name', 'student_id'] and value ] valid_grades = [grade for grade in grades if grade >= grade_threshold] if valid_grades: avg_grade = sum(valid_grades) / len(valid_grades) else: avg_grade = 0 if avg_grade > highest_avg_grade: highest_avg_grade = avg_grade top_student = (name, student_id) return top_student except Exception as e: print(f\\"Error reading file: {e}\\") return None"},{"question":"class ExpenseTracker: def __init__(self) -> None: Initialize an empty expense tracker. pass def add_expense(self, date: str, category: str, amount: float) -> None: Add an expense for a given date and category. :param date: The date of the expense in 'YYYY-MM-DD' format. :param category: The category of the expense. :param amount: The amount of the expense. >>> tracker = ExpenseTracker() >>> tracker.add_expense(\\"2023-10-01\\", \\"groceries\\", 50.25) pass def get_daily_total(self, date: str) -> float: Get the total expenses for a given date. :param date: The date in 'YYYY-MM-DD' format. :return: The total expenses for the date. >>> tracker = ExpenseTracker() >>> tracker.add_expense(\\"2023-10-01\\", \\"groceries\\", 50.25) >>> tracker.add_expense(\\"2023-10-01\\", \\"transport\\", 15.75) >>> tracker.get_daily_total(\\"2023-10-01\\") 66.0 pass def get_category_total(self, date: str, category: str) -> float: Get the total expenses for a given category on a specific date. :param date: The date in 'YYYY-MM-DD' format. :param category: The category of the expense. :return: The total expenses for the category on the given date. >>> tracker = ExpenseTracker() >>> tracker.add_expense(\\"2023-10-01\\", \\"groceries\\", 50.25) >>> tracker.add_expense(\\"2023-10-01\\", \\"transport\\", 15.75) >>> tracker.get_category_total(\\"2023-10-01\\", \\"groceries\\") 50.25 pass","solution":"class ExpenseTracker: def __init__(self) -> None: self.expenses = {} def add_expense(self, date: str, category: str, amount: float) -> None: if date not in self.expenses: self.expenses[date] = {} if category not in self.expenses[date]: self.expenses[date][category] = 0.0 self.expenses[date][category] += amount def get_daily_total(self, date: str) -> float: if date not in self.expenses: return 0.0 return sum(self.expenses[date].values()) def get_category_total(self, date: str, category: str) -> float: if date not in self.expenses or category not in self.expenses[date]: return 0.0 return self.expenses[date][category]"},{"question":"class CustomAllocator: A simple custom memory allocator class to manage a fixed-size block of memory, allowing for dynamic allocations and deallocations. Example: >>> allocator = CustomAllocator(100) >>> addr1 = allocator.allocate(10) >>> addr2 = allocator.allocate(20) >>> print(addr1, addr2) 0 10 >>> allocator.free(addr1) >>> addr3 = allocator.allocate(5) >>> print(addr3) 0 def __init__(self, total_size: int) -> None: pass def allocate(self, size: int) -> int: pass def free(self, address: int) -> None: pass if __name__ == \\"__main__\\": import pytest def test_allocate_and_free(): allocator = CustomAllocator(100) addr1 = allocator.allocate(10) addr2 = allocator.allocate(20) assert addr1 == 0 assert addr2 == 10 allocator.free(addr1) addr3 = allocator.allocate(5) assert addr3 == 0 # since we freed the first 10 bytes, addr1 should be reusable allocator.free(addr2) allocator.free(addr3) addr4 = allocator.allocate(30) assert addr4 == 0 # should now fit in the start of the memory block def test_out_of_memory(): allocator = CustomAllocator(50) allocator.allocate(30) allocator.allocate(20) with pytest.raises(MemoryError): allocator.allocate(5) # no space should be left def test_allocate_exact_remaining_space(): allocator = CustomAllocator(50) addr1 = allocator.allocate(25) addr2 = allocator.allocate(25) assert addr1 == 0 assert addr2 == 25 def test_free_and_reuse(): allocator = CustomAllocator(50) addr1 = allocator.allocate(10) allocator.free(addr1) addr2 = allocator.allocate(10) assert addr1 == addr2 # should be same if memory is reused correctly def test_merge_free_blocks(): allocator = CustomAllocator(50) addr1 = allocator.allocate(10) addr2 = allocator.allocate(10) addr3 = allocator.allocate(10) allocator.free(addr1) allocator.free(addr3) allocator.free(addr2) # Memory should be completely free now, so allocating 50 should succeed addr4 = allocator.allocate(50) assert addr4 == 0 pytest.main()","solution":"class CustomAllocator: def __init__(self, total_size: int) -> None: self.total_size = total_size self.free_blocks = [(0, total_size)] # List of tuples (address, size), initially whole memory is free. def allocate(self, size: int) -> int: for i, (start, free_size) in enumerate(self.free_blocks): if free_size >= size: if free_size == size: self.free_blocks.pop(i) else: self.free_blocks[i] = (start + size, free_size - size) return start raise MemoryError(\\"Not enough memory available to allocate\\") def free(self, address: int) -> None: for i, (start, size) in enumerate(self.free_blocks): if start > address: self.free_blocks.insert(i, (address, size)) break else: self.free_blocks.append((address, size)) self._merge_free_blocks() def _merge_free_blocks(self): merged_blocks = [] for block in sorted(self.free_blocks): if not merged_blocks or merged_blocks[-1][0] + merged_blocks[-1][1] < block[0]: merged_blocks.append(block) else: merged_blocks[-1] = (merged_blocks[-1][0], merged_blocks[-1][1] + block[1]) self.free_blocks = merged_blocks"},{"question":"def sum_of_squares_of_digits(number: int) -> int: This function returns the sum of the squares of the digits of a given non-negative integer. Parameters: number (int): A non-negative integer. Returns: int: The sum of the squares of the digits of the input number. Examples: >>> sum_of_squares_of_digits(123) 14 >>> sum_of_squares_of_digits(456) 77 >>> sum_of_squares_of_digits(0) 0 >>> sum_of_squares_of_digits(9999) 324","solution":"def sum_of_squares_of_digits(number): This function returns the sum of the squares of the digits of a given non-negative integer. Parameters: number (int): A non-negative integer. Returns: int: The sum of the squares of the digits of the input number. return sum(int(digit) ** 2 for digit in str(number))"},{"question":"import numpy as np def detect_edges(rgb_image: np.ndarray, threshold: int) -> np.ndarray: Perform image edge detection using the Sobel operator, followed by thresholding and edge-linking. The function follows these steps: 1. Convert the RGB image to a grayscale image. 2. Apply the Sobel operator to detect edges. 3. Apply a threshold to the edge magnitude to create a binary edge map. 4. Perform edge-linking on the binary edge map to ensure connectivity. Parameters: rgb_image (np.ndarray): A 3D NumPy array of shape (M, N, 3) representing an RGB image. threshold (int): An integer value used for thresholding the edge magnitude. Returns: np.ndarray: A 2D binary NumPy array of the same dimensions as the input image representing the final edge-detected result. Examples: >>> rgb_image = np.array([ ... [[0, 0, 0], [255, 255, 255]], ... [[255, 255, 255], [0, 0, 0]] ... ]) >>> detect_edges(rgb_image, 100) array([[1, 1], [1, 1]], dtype=uint8) >>> rgb_image = np.array([ ... [[0, 0, 0], [0, 0, 0]], ... [[0, 0, 0], [0, 0, 0]] ... ]) >>> detect_edges(rgb_image, 50) array([[0, 0], [0, 0]], dtype=uint8) >>> rgb_image = np.array([ ... [[255, 255, 255], [255, 255, 255]], ... [[255, 255, 255], [255, 255, 255]] ... ]) >>> detect_edges(rgb_image, 50) array([[0, 0], [0, 0]], dtype=uint8) >>> rgb_image = np.array([ ... [[127, 255, 0], [255, 0, 0]], ... [[0, 0, 255], [0, 255, 0]] ... ]) >>> detect_edges(rgb_image, 50) # Continue this example according to actual expected edge-detection results manually calculated or pre-verified. # Write your implementation here pass","solution":"import numpy as np from scipy.ndimage import convolve def detect_edges(rgb_image: np.ndarray, threshold: int) -> np.ndarray: # Step 1: Convert RGB to Grayscale grayscale = 0.2989 * rgb_image[:, :, 0] + 0.5870 * rgb_image[:, :, 1] + 0.1140 * rgb_image[:, :, 2] # Define Sobel operators sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) sobel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]]) # Step 2: Apply Sobel operators to detect edges gradient_x = convolve(grayscale, sobel_x, mode='reflect') gradient_y = convolve(grayscale, sobel_y, mode='reflect') # Compute gradient magnitude gradient_magnitude = np.sqrt(gradient_x**2 + gradient_y**2) # Step 3: Apply threshold to create binary edge map binary_edge_map = (gradient_magnitude >= threshold).astype(np.uint8) # Step 4: Perform edge-linking (simple edge-linking by connecting 8 neighboring pixels) def edge_linking(binary_edge): # Create a copy of the binary edge map to store the linked edges linked_edges = binary_edge.copy() h, w = binary_edge.shape for i in range(1, h-1): for j in range(1, w-1): if binary_edge[i, j] == 1: continue # Check 8-connected neighbors if np.any(binary_edge[i-1:i+2, j-1:j+2] == 1): linked_edges[i, j] = 1 return linked_edges final_edges = edge_linking(binary_edge_map) return final_edges"},{"question":"from typing import List def find_gcd(arr: List[int]) -> int: Calculates the Greatest Common Divisor (GCD) of an array of integers. Args: arr: List of integers of size 1 to 10^6, each integer ranging from 1 to 10^9. Returns: An integer that is the GCD of the input list arr. Examples: >>> find_gcd([12, 15, 21]) 3 >>> find_gcd([3, 5, 7]) 1 >>> find_gcd([48, 180, 240]) 12 >>> find_gcd([1024, 2048, 4096]) 1024 pass # Test cases def test_find_gcd_single_element(): assert find_gcd([12]) == 12 def test_find_gcd_simple_case(): assert find_gcd([12, 15, 21]) == 3 def test_find_gcd_prime_numbers(): assert find_gcd([3, 5, 7]) == 1 def test_find_gcd_common_factor(): assert find_gcd([48, 180, 240]) == 12 def test_find_gcd_power_of_two(): assert find_gcd([1024, 2048, 4096]) == 1024 def test_find_gcd_all_ones(): assert find_gcd([1, 1, 1, 1, 1]) == 1 def test_find_gcd_mixed_numbers(): assert find_gcd([14, 56, 98]) == 14 def test_find_gcd_large_numbers(): assert find_gcd([1000000000, 500000000]) == 500000000","solution":"from typing import List import math from functools import reduce def find_gcd(arr: List[int]) -> int: Returns the GCD of a list of integers. return reduce(math.gcd, arr)"},{"question":"def find_all_permutations(s: str) -> list[str]: Returns all distinct permutations of the input string \`s\`. >>> find_all_permutations(\\"abc\\") == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> find_all_permutations(\\"aab\\") == [\\"aab\\", \\"aba\\", \\"baa\\"] >>> find_all_permutations(\\"\\") == [\\"\\"]","solution":"def find_all_permutations(s: str) -> list[str]: Returns all distinct permutations of the input string \`s\`. def backtrack(path, used, res): if len(path) == len(s): res.append(\\"\\".join(path)) return for i in range(len(s)): if used[i]: continue # Avoid duplicates by skipping over duplicates if i > 0 and s[i] == s[i - 1] and not used[i - 1]: continue used[i] = True path.append(s[i]) backtrack(path, used, res) path.pop() used[i] = False if not s: return [\\"\\"] s = sorted(s) res = [] used = [False] * len(s) backtrack([], used, res) return res"},{"question":"def has_cycle(graph: dict) -> bool: Detects if there is a cycle in the given directed graph. :param graph: A dictionary where keys are vertex identifiers (strings) and values are lists of adjacent vertex identifiers. :return: Boolean indicating whether a cycle is present in the graph. >>> graph_with_cycle = { ... \\"A\\": [\\"B\\"], ... \\"B\\": [\\"C\\"], ... \\"C\\": [\\"A\\"] ... } >>> has_cycle(graph_with_cycle) True >>> graph_without_cycle = { ... \\"A\\": [\\"B\\", \\"C\\"], ... \\"B\\": [\\"D\\"], ... \\"C\\": [\\"D\\"], ... \\"D\\": [] ... } >>> has_cycle(graph_without_cycle) False","solution":"def has_cycle(graph: dict) -> bool: Detects if there is a cycle in the given directed graph. :param graph: A dictionary where keys are vertex identifiers (strings) and values are lists of adjacent vertex identifiers. :return: Boolean indicating whether a cycle is present in the graph. def dfs(vertex, visited, stack): visited.add(vertex) stack.add(vertex) for neighbor in graph.get(vertex, []): if neighbor not in visited: if dfs(neighbor, visited, stack): return True elif neighbor in stack: return True stack.remove(vertex) return False visited = set() stack = set() for vertex in graph: if vertex not in visited: if dfs(vertex, visited, stack): return True return False"},{"question":"def process_file_data( input_file: str, output_file: str, filter_word: str | None = None, transform_case: str | None = None ) -> None: Processes an input text file by filtering and transforming lines, then writes the result to an output file. :param input_file: Path to the input text file. :param output_file: Path to the output text file. :param filter_word: Word to filter out lines containing it (default None). :param transform_case: Case transformation (\\"upper\\", \\"lower\\", \\"title\\", None) (default None). :raise FileNotFoundError: If the input file does not exist. :raise ValueError: If an invalid case transformation is provided. Example Usage: >>> try: >>> process_file_data( >>> input_file=\\"input.txt\\", >>> output_file=\\"output.txt\\", >>> filter_word=\\"filter\\", >>> transform_case=\\"upper\\" >>> ) >>> except FileNotFoundError as fnfe: >>> print(fnfe) >>> except ValueError as ve: >>> print(ve) Example Input File: plaintext hello world this is a test filter this sentence another line here Example Output File: (when filter_word=\\"filter\\" and transform_case=\\"upper\\") plaintext HELLO WORLD THIS IS A TEST ANOTHER LINE HERE","solution":"def process_file_data(input_file, output_file, filter_word=None, transform_case=None): Processes an input text file by filtering and transforming lines, then writes the result to an output file. :param input_file: Path to the input text file. :param output_file: Path to the output text file. :param filter_word: Word to filter out lines containing it (default None). :param transform_case: Case transformation (\\"upper\\", \\"lower\\", \\"title\\", None) (default None). :raise FileNotFoundError: If the input file does not exist. :raise ValueError: If an invalid case transformation is provided. if transform_case not in (None, \\"upper\\", \\"lower\\", \\"title\\"): raise ValueError(f\\"Invalid case transformation: {transform_case}\\") try: with open(input_file, 'r') as infile: lines = infile.readlines() except FileNotFoundError: raise FileNotFoundError(f\\"Input file not found: {input_file}\\") with open(output_file, 'w') as outfile: for line in lines: if filter_word and filter_word in line: continue if transform_case == \\"upper\\": line = line.upper() elif transform_case == \\"lower\\": line = line.lower() elif transform_case == \\"title\\": line = line.title() outfile.write(line)"},{"question":"def filter_data(data: list[dict], conditions: list[tuple[str, str, any]]) -> list[dict]: Filters a list of dictionaries based on multiple conditions. Parameters: - data: list of dictionaries where each dictionary represents a data record - conditions: list of tuples, each containing a key (str), an operator (str), and a value (any) to compare against Returns: - A list of dictionaries that meet all specified conditions. Examples: >>> data = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, ... {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, ... {\\"name\\": \\"David\\", \\"age\\": 40, \\"city\\": \\"New York\\"} ... ] >>> filter_data(data, [(\\"age\\", \\">\\", 30)]) [{'name': 'Charlie', 'age': 35, 'city': 'Chicago'}, {'name': 'David', 'age': 40, 'city': 'New York'}] >>> filter_data(data, [(\\"age\\", \\">\\", 30), (\\"city\\", \\"==\\", \\"New York\\")]) [{'name': 'David', 'age': 40, 'city': 'New York'}] >>> filter_data(data, []) [{'name': 'Alice', 'age': 30, 'city': 'New York'}, {'name': 'Bob', 'age': 25, 'city': 'Los Angeles'}, {'name': 'Charlie', 'age': 35, 'city': 'Chicago'}, {'name': 'David', 'age': 40, 'city': 'New York'}]","solution":"def filter_data(data, conditions): Filters a list of dictionaries based on multiple conditions. Parameters: - data: list of dictionaries where each dictionary represents a data record - conditions: list of tuples, each containing a key (str), an operator (str), and a value (any) to compare against Returns: - A list of dictionaries that meet all specified conditions. def match_conditions(entry, conditions): for key, operator, value in conditions: if operator == \\"==\\": if not entry[key] == value: return False elif operator == \\"!=\\": if not entry[key] != value: return False elif operator == \\"<\\": if not entry[key] < value: return False elif operator == \\">\\": if not entry[key] > value: return False elif operator == \\"<=\\": if not entry[key] <= value: return False elif operator == \\">=\\": if not entry[key] >= value: return False return True return [item for item in data if match_conditions(item, conditions)]"},{"question":"from typing import List def reverse_string(s: str) -> str: Reverses the entire string. >>> reverse_string(\\"hello world\\") \\"dlrow olleh\\" >>> reverse_string(\\"abcde\\") \\"edcba\\" def reverse_words(s: str) -> str: Reverses the order of words in the string while maintaining the order of characters in each word. >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"good morning\\") \\"morning good\\" def reverse_each_word(s: str) -> str: Reverses each word individually in the string while maintaining the order of the words. >>> reverse_each_word(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_each_word(\\"good morning\\") \\"doog gninrom\\" def is_palindrome(s: str) -> bool: Checks if the string is a palindrome (reads the same forward and backward). >>> is_palindrome(\\"madam\\") True >>> is_palindrome(\\"hello\\") False def reverse_in_place(s: str) -> str: Reverses the string by swapping characters in place. >>> reverse_in_place(\\"hello\\") \\"olleh\\" >>> reverse_in_place(\\"world\\") \\"dlrow\\"","solution":"def reverse_string(s: str) -> str: return s[::-1] def reverse_words(s: str) -> str: return ' '.join(s.split()[::-1]) def reverse_each_word(s: str) -> str: return ' '.join(word[::-1] for word in s.split()) def is_palindrome(s: str) -> bool: return s == s[::-1] def reverse_in_place(s: str) -> str: s = list(s) left, right = 0, len(s) - 1 while left < right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 return ''.join(s)"},{"question":"def is_fibonacci_subsequence(lst: list) -> bool: Determine if the given list is a subsequence of the Fibonacci sequence. >>> is_fibonacci_subsequence([1, 3, 13]) True >>> is_fibonacci_subsequence([2, 8, 21]) True >>> is_fibonacci_subsequence([4, 6, 9]) False >>> is_fibonacci_subsequence([1, 2, 3, 5, 13]) True","solution":"def is_fibonacci_subsequence(lst: list) -> bool: Determine if the given list is a subsequence of the Fibonacci sequence. if not lst: return True # Find the maximum value in the list max_val = max(lst) # Generate Fibonacci sequence up to the maximum value fib = [0, 1] while fib[-1] < max_val: fib.append(fib[-1] + fib[-2]) # Convert to set for quick lookup fib_set = set(fib) # Check if all elements in lst are found in the Fibonacci set for num in lst: if num not in fib_set: return False return True"},{"question":"def newton_fractal_image( image_width: int, image_height: int, polynomial_roots: list, figure_center_x: float = 0.0, figure_center_y: float = 0.0, figure_width: float = 3.2, max_step: int = 50, tolerance: float = 1e-6, use_detailed_color_coding: bool = True, ) -> Image.Image: Generates an image of the Newton fractal for the given polynomial roots. Parameters: - image_width (int): Width of the image in pixels. - image_height (int): Height of the image in pixels. - polynomial_roots (list): List of complex numbers representing the roots of the polynomial. - figure_center_x (float): X-coordinate of the center of the image in the complex plane. - figure_center_y (float): Y-coordinate of the center of the image in the complex plane. - figure_width (float): Width of the figure in the complex plane. - max_step (int): Maximum number of iterations. - tolerance (float): Tolerance for considering convergence. - use_detailed_color_coding (bool): Whether to use detailed color coding based on convergence and iterations. Returns: - Image.Image: The generated image of the Newton fractal. import numpy as np from PIL import Image roots = np.array(polynomial_roots) color_map = [ (0, 255, 0), # green (0, 0, 255), # blue (255, 0, 0) # red ] # Normalize figure width figure_height = figure_width * image_height / image_width x_range = np.linspace(figure_center_x - figure_width / 2, figure_center_x + figure_width / 2, image_width) y_range = np.linspace(figure_center_y - figure_height / 2, figure_center_y + figure_height / 2, image_height) xv, yv = np.meshgrid(x_range, y_range) z = xv + 1j * yv output = np.zeros((image_height, image_width, 3), dtype=np.uint8) for i in range(max_step): # Newton iteration z -= (z**3 - 1) / (3 * z**2) for j, root in enumerate(roots): mask = np.abs(z - root) < tolerance output[mask, :] = color_map[j % len(color_map)] if mask.all(): break img = Image.fromarray(output) return img","solution":"import numpy as np from PIL import Image def newton_fractal_image( image_width: int, image_height: int, polynomial_roots: list, figure_center_x: float = 0.0, figure_center_y: float = 0.0, figure_width: float = 3.2, max_step: int = 50, tolerance: float = 1e-6, use_detailed_color_coding: bool = True, ) -> Image.Image: Generates an image of the Newton fractal for the given polynomial roots. Parameters: - image_width (int): Width of the image in pixels. - image_height (int): Height of the image in pixels. - polynomial_roots (list): List of complex numbers representing the roots of the polynomial. - figure_center_x (float): X-coordinate of the center of the image in the complex plane. - figure_center_y (float): Y-coordinate of the center of the image in the complex plane. - figure_width (float): Width of the figure in the complex plane. - max_step (int): Maximum number of iterations. - tolerance (float): Tolerance for considering convergence. - use_detailed_color_coding (bool): Whether to use detailed color coding based on convergence and iterations. Returns: - Image.Image: The generated image of the Newton fractal. roots = np.array(polynomial_roots) color_map = [ (0, 255, 0), # green (0, 0, 255), # blue (255, 0, 0) # red ] # Normalize figure width figure_height = figure_width * image_height / image_width x_range = np.linspace(figure_center_x - figure_width / 2, figure_center_x + figure_width / 2, image_width) y_range = np.linspace(figure_center_y - figure_height / 2, figure_center_y + figure_height / 2, image_height) xv, yv = np.meshgrid(x_range, y_range) z = xv + 1j * yv output = np.zeros((image_height, image_width, 3), dtype=np.uint8) for i in range(max_step): # Newton iteration z -= (z**3 - 1) / (3 * z**2) for j, root in enumerate(roots): mask = np.abs(z - root) < tolerance output[mask, :] = color_map[j % len(color_map)] if mask.all(): break img = Image.fromarray(output) return img"},{"question":"from typing import List class Task: def __init__(self, deadline: int, profit: int): self.deadline = deadline self.profit = profit def __repr__(self): return f\\"Task(deadline={self.deadline}, profit={self.profit})\\" def schedule_tasks(tasks: List[Task]) -> None: Schedules tasks to maximize profit with no overlapping deadlines. Prints the maximum profit and the sequence of tasks leading to it. Example: tasks = [ Task(deadline=2, profit=100), Task(deadline=1, profit=19), Task(deadline=2, profit=27), Task(deadline=1, profit=25), Task(deadline=3, profit=15) ] schedule_tasks(tasks) pass def test_single_task(): tasks = [Task(deadline=1, profit=100)] schedule_tasks(tasks) def test_multiple_tasks_with_varied_deadlines(): tasks = [ Task(deadline=2, profit=100), Task(deadline=1, profit=19), Task(deadline=2, profit=27), Task(deadline=1, profit=25), Task(deadline=3, profit=15) ] schedule_tasks(tasks) def test_all_tasks_same_deadline(): tasks = [ Task(deadline=1, profit=20), Task(deadline=1, profit=30), Task(deadline=1, profit=10), Task(deadline=1, profit=40) ] schedule_tasks(tasks) def test_tasks_with_zero_profit(): tasks = [ Task(deadline=1, profit=0), Task(deadline=2, profit=0), Task(deadline=1, profit=0) ] schedule_tasks(tasks) def test_fully_occupied_time_slots(): tasks = [ Task(deadline=1, profit=10), Task(deadline=2, profit=20), Task(deadline=3, profit=30), Task(deadline=4, profit=40), Task(deadline=5, profit=50) ] schedule_tasks(tasks)","solution":"from typing import List class Task: def __init__(self, deadline: int, profit: int): self.deadline = deadline self.profit = profit def __repr__(self): return f\\"Task(deadline={self.deadline}, profit={self.profit})\\" def schedule_tasks(tasks: List[Task]) -> None: Schedules tasks to maximize profit with no overlapping deadlines. Prints the maximum profit and the sequence of tasks leading to it. # Sort tasks based on profit in descending order tasks.sort(key=lambda x: x.profit, reverse=True) # Find the maximum deadline to determine the time slots max_deadline = max(task.deadline for task in tasks) # Time slots, initialized to None time_slots = [None] * max_deadline total_profit = 0 for task in tasks: # Try to schedule task in the latest possible slot before its deadline for slot in range(min(max_deadline, task.deadline) - 1, -1, -1): if time_slots[slot] is None: time_slots[slot] = task total_profit += task.profit break # Filter out None slots and keep only scheduled tasks scheduled_tasks = [task for task in time_slots if task is not None] # Output the results print(f\\"Maximum profit is {total_profit}.\\") print(\\"The sequence of tasks is:\\") for task in scheduled_tasks: print(task) # Example usage: # tasks = [ # Task(deadline=2, profit=100), # Task(deadline=1, profit=19), # Task(deadline=2, profit=27), # Task(deadline=1, profit=25), # Task(deadline=3, profit=15) # ] # schedule_tasks(tasks)"},{"question":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number in the sequence from 1 to n. >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([2, 3, 4, 6, 1, 5, 7, 9, 10, 8]) 11 >>> find_missing_number([1, 3]) 2 >>> find_missing_number([1, 2]) 3","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Returns the missing number in the sequence from 1 to n. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"import csv def calculate_student_averages(input_file: str, output_file: str) -> None: Calculates the average grade for each student and saves the result to a new file. Parameters: input_file (str): The file path to the input CSV file, which contains student names and grades. output_file (str): The file path to the output CSV file, where the average grades will be saved. Returns: None Example: >>> calculate_student_averages(\\"students_grades.csv\\", \\"averages.csv\\") # Test Cases import os import csv from calculate_student_averages import calculate_student_averages def test_calculate_student_averages(tmpdir): input_file = tmpdir.join(\\"students_grades.csv\\") output_file = tmpdir.join(\\"averages.csv\\") # Prepare the input CSV file input_file.write( \\"john,85,90,78n\\" \\"jane,80,70,88,92n\\" \\"doe,95,100n\\" ) # Expected Output expected_output = [ (\\"john\\", \\"84.33\\"), (\\"jane\\", \\"82.5\\"), (\\"doe\\", \\"97.5\\") ] # Calculate the averages and write to the output file calculate_student_averages(str(input_file), str(output_file)) # Verify the output CSV file with open(output_file, mode='r') as file: reader = csv.reader(file) output_data = list(reader) assert len(output_data) == len(expected_output) for row, expected in zip(output_data, expected_output): assert row[0] == expected[0] assert row[1] == expected[1] def test_calculate_student_averages_single_grade(tmpdir): input_file = tmpdir.join(\\"students_grades_one.csv\\") output_file = tmpdir.join(\\"averages_one.csv\\") # Prepare the input CSV file input_file.write( \\"alex,80n\\" ) # Expected Output expected_output = [ (\\"alex\\", \\"80.0\\") ] # Calculate the averages and write to the output file calculate_student_averages(str(input_file), str(output_file)) # Verify the output CSV file with open(output_file, mode='r') as file: reader = csv.reader(file) output_data = list(reader) assert len(output_data) == len(expected_output) for row, expected in zip(output_data, expected_output): assert row[0] == expected[0] assert row[1] == expected[1] def test_calculate_student_averages_multiple_students(tmpdir): input_file = tmpdir.join(\\"students_grades_multiple.csv\\") output_file = tmpdir.join(\\"averages_multiple.csv\\") # Prepare the input CSV file input_file.write( \\"mike,75.5,85.0n\\" \\"tom,60n\\" \\"ann,90,95,100n\\" ) # Expected Output expected_output = [ (\\"mike\\", \\"80.25\\"), (\\"tom\\", \\"60.0\\"), (\\"ann\\", \\"95.0\\") ] # Calculate the averages and write to the output file calculate_student_averages(str(input_file), str(output_file)) # Verify the output CSV file with open(output_file, mode='r') as file: reader = csv.reader(file) output_data = list(reader) assert len(output_data) == len(expected_output) for row, expected in zip(output_data, expected_output): assert row[0] == expected[0] assert row[1] == expected[1]","solution":"import csv def calculate_student_averages(input_file: str, output_file: str) -> None: with open(input_file, mode='r') as infile: reader = csv.reader(infile) student_grades = {row[0]: list(map(float, row[1:])) for row in reader} student_averages = {student: round(sum(grades) / len(grades), 2) for student, grades in student_grades.items()} with open(output_file, mode='w', newline='') as outfile: writer = csv.writer(outfile) for student, avg in student_averages.items(): writer.writerow([student, avg])"},{"question":"def longest_substring_with_k_unique_characters(s: str, k: int) -> int: Find the length of the longest substring that contains exactly k unique characters. >>> longest_substring_with_k_unique_characters(\\"aabacbebebe\\", 3) 7 >>> longest_substring_with_k_unique_characters(\\"aaaa\\", 1) 4 >>> longest_substring_with_k_unique_characters(\\"aabbcc\\", 2) 4 from solution import longest_substring_with_k_unique_characters def test_example_cases(): assert longest_substring_with_k_unique_characters(\\"aabacbebebe\\", 3) == 7 assert longest_substring_with_k_unique_characters(\\"aaaa\\", 1) == 4 assert longest_substring_with_k_unique_characters(\\"aabbcc\\", 2) == 4 def test_edge_cases(): assert longest_substring_with_k_unique_characters(\\"\\", 3) == 0 assert longest_substring_with_k_unique_characters(\\"a\\", 0) == 0 assert longest_substring_with_k_unique_characters(\\"a\\", 2) == 0 assert longest_substring_with_k_unique_characters(\\"ab\\", 3) == 0 def test_single_character_string(): assert longest_substring_with_k_unique_characters(\\"aaaaa\\", 1) == 5 assert longest_substring_with_k_unique_characters(\\"aaaaa\\", 2) == 0 def test_large_input(): s = \\"a\\" * 50000 + \\"b\\" * 50000 # 100000 length assert longest_substring_with_k_unique_characters(s, 1) == 50000 assert longest_substring_with_k_unique_characters(s, 2) == 100000 def test_all_unique_characters(): assert longest_substring_with_k_unique_characters(\\"abcdefghijklmnopqrstuvwxyz\\", 26) == 26 assert longest_substring_with_k_unique_characters(\\"abcdefghijklmnopqrstuvwxyz\\", 1) == 1 assert longest_substring_with_k_unique_characters(\\"abcdefghijklmnopqrstuvwxyz\\", 13) == 13","solution":"def longest_substring_with_k_unique_characters(s, k): Given a string s, find the length of the longest substring that contains exactly k unique characters. :param s: A string consisting of lowercase alphabets. :param k: An integer representing the number of unique characters required. :return: An integer representing the length of the longest substring with exactly k unique characters. if k == 0 or len(s) == 0: return 0 left = 0 right = 0 char_frequency = {} max_length = 0 while right < len(s): char_frequency[s[right]] = char_frequency.get(s[right], 0) + 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 if len(char_frequency) == k: max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def rgb_to_hex(r: int, g: int, b: int) -> str: Converts RGB values to a hexadecimal color code. Parameters: r (int): Red component (0-255) g (int): Green component (0-255) b (int): Blue component (0-255) Returns: str: Hexadecimal color code in the format '#RRGGBB' Raises: ValueError: If any of the input values are not in the range [0, 255]. >>> rgb_to_hex(0, 128, 255) '#0080FF' >>> rgb_to_hex(255, 255, 255) '#FFFFFF' >>> rgb_to_hex(34, 139, 34) '#228B22' >>> rgb_to_hex(0, 0, 0) '#000000' >>> rgb_to_hex(256, 100, 100) Traceback (most recent call last): ... ValueError: RGB values must be in the range [0, 255] >>> rgb_to_hex(-1, 50, 50) Traceback (most recent call last): ... ValueError: RGB values must be in the range [0, 255] >>> rgb_to_hex(100, 100, -20) Traceback (most recent call last): ... ValueError: RGB values must be in the range [0, 255] if not(0 <= r <= 255) or not(0 <= g <= 255) or not(0 <= b <= 255): raise ValueError(\\"RGB values must be in the range [0, 255]\\") return f\\"#{r:02X}{g:02X}{b:02X}\\"","solution":"def rgb_to_hex(r: int, g: int, b: int) -> str: Converts RGB values to a hexadecimal color code. Parameters: r (int): Red component (0-255) g (int): Green component (0-255) b (int): Blue component (0-255) Returns: str: Hexadecimal color code in the format '#RRGGBB' Raises: ValueError: If any of the input values are not in the range [0, 255]. if not(0 <= r <= 255) or not(0 <= g <= 255) or not(0 <= b <= 255): raise ValueError(\\"RGB values must be in the range [0, 255]\\") return f\\"#{r:02X}{g:02X}{b:02X}\\""},{"question":"markdown Task Write a function \`find_shortest_route(n: int, edges: List[Tuple[int, int, int]], required_stops: List[int]) -> List[int]:\` to determine the shortest route traveling through a series of required stops using Dijkstra's algorithm as described. Your function should return the shortest route as a list of location indices. Signature def find_shortest_route(n: int, edges: List[Tuple[int, int, int]], required_stops: List[int]) -> List[int]: pass Example n = 5 edges = [(0, 1, 10), (1, 2, 10), (0, 2, 15), (2, 3, 10), (3, 4, 10)] required_stops = [0, 2, 4] print(find_shortest_route(n, edges, required_stops)) Output: [0, 1, 2, 3, 4] Constraints - The locations are indexed from 0 to n-1. - The list of edges represents an undirected graph with no negative travel times. - Ensure the solution can handle up to 1000 locations and 5000 edges efficiently within a reasonable time limit. Unit Test def test_dijkstra_basic(): graph = [ [(1, 2), (2, 4)], [(0, 2), (2, 1)], [(0, 4), (1, 1)] ] assert dijkstra(graph, 0) == [0, 2, 3] assert dijkstra(graph, 1) == [2, 0, 1] assert dijkstra(graph, 2) == [3, 1, 0] def test_find_shortest_route_case1(): assert find_shortest_route(5, [(0, 1, 10), (1, 2, 10), (0, 2, 15), (2, 3, 10), (3, 4, 10)], [0, 2, 4]) == [0, 2, 4] def test_find_shortest_route_case2(): assert find_shortest_route(6, [(0, 1, 10), (1, 2, 20), (1, 3, 15), (2, 3, 30), (3, 4, 15), (4, 5, 10)], [0, 4, 5]) == [0, 4, 5] def test_find_shortest_route_empty_required_stops(): assert find_shortest_route(5, [(0, 1, 10), (1, 2, 10), (0, 2, 15), (2, 3, 10), (3, 4, 10)], []) == [] def test_find_shortest_route_disconnected_graph(): # Graph is disconnected, cannot visit all required stops try: find_shortest_route(5, [(0, 1, 10), (2, 3, 15), (3, 4, 10)], [0, 2, 4]) except ValueError as e: assert str(e) == \\"Cannot visit all required stops\\"","solution":"import heapq from typing import List, Tuple def dijkstra(graph: List[List[Tuple[int, int]]], start: int) -> List[int]: Implements Dijkstra's algorithm to find the shortest path from 'start' to all other nodes. Parameters: - graph: Adjacency list representation of the graph where graph[u] is a list of tuples (v, w) representing an edge from u to v with weight w. - start: The starting node. Returns: - List of minimum distances from start to each node. n = len(graph) distances = [float('inf')] * n distances[start] = 0 pq = [(0, start)] # priority queue of (distance, node) while pq: current_distance, u = heapq.heappop(pq) if current_distance > distances[u]: continue for neighbor, weight in graph[u]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def find_shortest_route(n: int, edges: List[Tuple[int, int, int]], required_stops: List[int]) -> List[int]: Find the shortest route that visits all required stops. Parameters: - n (int): The number of locations. - edges (List[Tuple[int, int, int]]): The edges where each edge is represented as a tuple (u, v, w) with u and v being the locations and w being the travel time. - required_stops (List[int]): The list of locations that are mandatory stops. Returns: - List[int]: The shortest route as a list of location indices. # Create a graph in adjacency list format graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Compute distances between each pair of required stops using Dijkstra's algorithm required_stops = list(set(required_stops)) # Remove duplicates if any distance_between_required = {} for i in range(len(required_stops)): u = required_stops[i] distances = dijkstra(graph, u) for j in range(i + 1, len(required_stops)): v = required_stops[j] distance_between_required[(u, v)] = distances[v] distance_between_required[(v, u)] = distances[v] # Since it's undirected # Note: Implement a strategy to find the shortest path visiting all required stops (e.g., TSP approximation) # Placeholder for the required route finding logic # Assuming we visit them in the given order in \`required_stops\`: return required_stops"},{"question":"import json def count_keys(json_str: str) -> int: Parses the JSON string and returns the number of top-level key-value pairs. Parameters: json_str (str): A string in JSON format representing an object. Returns: int: The number of top-level key-value pairs in the JSON object. Examples: >>> count_keys('{\\"name\\": \\"John\\", \\"age\\": 30, \\"city\\": \\"New York\\"}') 3 >>> count_keys('{\\"success\\": true, \\"data\\": {\\"type\\": \\"user\\", \\"id\\": \\"1234\\"}}') 2","solution":"import json def count_keys(json_str: str) -> int: Parses the JSON string and returns the number of top-level key-value pairs. Parameters: json_str (str): A string in JSON format representing an object. Returns: int: The number of top-level key-value pairs in the JSON object. json_obj = json.loads(json_str) return len(json_obj)"},{"question":"def count_lottery_combinations(m: int, k: int) -> int: Calculate the number of unique lottery combinations. Parameters: m (int): The total number of unique balls in the lottery, where 1 <= m <= 100. k (int): The number of balls a player selects, where 1 <= k <= m. Returns: int: The total number of unique lottery combinations. Examples: >>> count_lottery_combinations(50, 5) 2118760 >>> count_lottery_combinations(30, 10) 30045015 >>> count_lottery_combinations(10, 5) 252 pass def test_count_lottery_combinations(): assert count_lottery_combinations(50, 5) == 2118760 assert count_lottery_combinations(30, 10) == 30045015 assert count_lottery_combinations(10, 5) == 252 assert count_lottery_combinations(100, 1) == 100 assert count_lottery_combinations(100, 0) == 1 assert count_lottery_combinations(23, 6) == 100947 def test_count_lottery_combinations_edge_cases(): assert count_lottery_combinations(1, 1) == 1 assert count_lottery_combinations(2, 1) == 2 assert count_lottery_combinations(5, 5) == 1 assert count_lottery_combinations(6, 3) == 20 assert count_lottery_combinations(10, 0) == 1","solution":"def count_lottery_combinations(m: int, k: int) -> int: Calculate the number of unique lottery combinations. Parameters: m (int): The total number of unique balls in the lottery. k (int): The number of balls a player selects. Returns: int: The total number of unique lottery combinations. from math import comb return comb(m, k)"},{"question":"def is_valid_parentheses(s: str) -> bool: Determines if the input string of round parentheses is valid. Parameters: s (str): The input string containing only '(' and ')'. Returns: bool: True if the string is valid, False otherwise. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\"()(()(()))\\") True >>> is_valid_parentheses(\\")(\\") False","solution":"def is_valid_parentheses(s: str) -> bool: Determines if the input string of round parentheses is valid. Parameters: s (str): The input string containing only '(' and ')'. Returns: bool: True if the string is valid, False otherwise. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def combine_inventories(inventory_a: list, inventory_b: list) -> list: Combine the inventories of two branches, updating the quantities based on ISBN numbers. >>> combine_inventories([(\\"12345\\", 5), (\\"67890\\", 2)], [(\\"12345\\", 3), (\\"11111\\", 4)]) [(\\"11111\\", 4), (\\"12345\\", 8), (\\"67890\\", 2)] >>> combine_inventories([], [(\\"22222\\", 7)]) [(\\"22222\\", 7)] >>> combine_inventories([(\\"99999\\", 10)], []) [(\\"99999\\", 10)]","solution":"def combine_inventories(inventory_a: list, inventory_b: list) -> list: if not (isinstance(inventory_a, list) and isinstance(inventory_b, list)): raise TypeError(\\"Both inventories must be lists of tuples\\") combined_inventory = {} for inventory in [inventory_a, inventory_b]: for isbn, quantity in inventory: if not isinstance(isbn, str): raise ValueError(\\"ISBN must be a string\\") if not isinstance(quantity, int) or quantity < 0: raise ValueError(\\"Quantity must be a non-negative integer\\") if isbn in combined_inventory: combined_inventory[isbn] += quantity else: combined_inventory[isbn] = quantity return sorted(combined_inventory.items())"},{"question":"import math from typing import List def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Returns the cosine similarity between two vectors represented as lists of floats. >>> cosine_similarity([1, 2, 3], [4, 5, 6]) 0.9746318461970762 >>> cosine_similarity([-1, 0, 1], [1, 0, -1]) -1.0","solution":"import math from typing import List def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Returns the cosine similarity between two vectors represented as lists of floats. dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(v1 * v1 for v1 in vec1)) magnitude_vec2 = math.sqrt(sum(v2 * v2 for v2 in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"class URLShortener: URLShortener is a class that provides methods to shorten URLs and retrieve the original URLs using a shortened version. def shorten_url(self, original_url: str) -> str: Shorten a given URL. Args: original_url (str): The URL that needs to be shortened. Returns: str: A unique shortened URL. >>> shortener = URLShortener() >>> shortener.shorten_url(\\"https://www.example.com\\") == \\"http://short.url/1\\" True >>> shortener.shorten_url(\\"https://www.example.com\\") == \\"http://short.url/1\\" True def retrieve_url(self, short_url: str) -> str: Retrieve the original URL for a given shortened URL. Args: short_url (str): The shortened URL. Returns: str: The original URL or an error message if the shortened URL does not exist. >>> shortener = URLShortener() >>> short_url = shortener.shorten_url(\\"https://www.example.com\\") >>> shortener.retrieve_url(short_url) == \\"https://www.example.com\\" True >>> shortener.retrieve_url(\\"http://short.url/9999\\") == \\"Error: Short URL not found\\" True","solution":"class URLShortener: def __init__(self): self.url_mapping = {} self.counter = 1 self.base_url = \\"http://short.url/\\" def shorten_url(self, original_url: str) -> str: for existing_short_url, url in self.url_mapping.items(): if url == original_url: return self.base_url + existing_short_url short_key = str(self.counter) self.url_mapping[short_key] = original_url self.counter += 1 return self.base_url + short_key def retrieve_url(self, short_url: str) -> str: short_key = short_url.replace(self.base_url, \\"\\") if short_key in self.url_mapping: return self.url_mapping[short_key] else: return \\"Error: Short URL not found\\""},{"question":"def flood_fill(matrix: list[list[int]], start_row: int, start_col: int) -> list[list[int]]: Perform flood fill on the matrix starting from the given cell. >>> matrix = [ ... [1, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 1, 1], ... [1, 1, 1, 0] ... ] >>> start_row = 0 >>> start_col = 0 >>> flood_fill(matrix, start_row, start_col) [[2, 2, 0, 0], [2, 0, 0, 1], [0, 0, 1, 1], [1, 1, 1, 0]]","solution":"def flood_fill(matrix: list[list[int]], start_row: int, start_col: int) -> list[list[int]]: Perform flood fill on the matrix starting from the given cell. rows, cols = len(matrix), len(matrix[0]) starting_value = 1 new_value = 2 def dfs(r, c): # If out of bounds or the cell is not part of the contiguous block anymore if r < 0 or r >= rows or c < 0 or c >= cols or matrix[r][c] != starting_value: return # Fill the cell matrix[r][c] = new_value # Recursively fill the adjacent cells dfs(r-1, c) # up dfs(r+1, c) # down dfs(r, c-1) # left dfs(r, c+1) # right # Start flood fill from the starting cell dfs(start_row, start_col) return matrix"},{"question":"def rotate_matrix_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given NxN matrix by 90 degrees in a counterclockwise direction. Parameters: matrix (list of list of int): A square matrix (NxN) Returns: list of list of int: The rotated matrix >>> rotate_matrix_counterclockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[3, 6, 9], [2, 5, 8], [1, 4, 7]] >>> rotate_matrix_counterclockwise([[1, 2], [3, 4]]) [[2, 4], [1, 3]] >>> rotate_matrix_counterclockwise([[1]]) [[1]]","solution":"def rotate_matrix_counterclockwise(matrix): Rotates a given NxN matrix by 90 degrees in a counterclockwise direction. Parameters: matrix (list of list of int): A square matrix (NxN) Returns: list of list of int: The rotated matrix N = len(matrix) rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[N - j - 1][i] = matrix[i][j] return rotated_matrix"},{"question":"import heapq from typing import List, Dict, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start_node: int, target_node: int) -> List[int]: Implements Dijkstra's algorithm to find the shortest path from start_node to target_node in a weighted graph represented as an adjacency list. >>> graph = {0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []} >>> shortest_path(graph, 0, 3) [0, 2, 1, 3] >>> shortest_path(graph, 0, 1) [0, 2, 1] >>> shortest_path(graph, 1, 0) [] >>> shortest_path(graph, 3, 3) [3] >>> shortest_path({0: []}, 0, 0) [0] >>> shortest_path({0: [(1, 1)], 1: [], 2: [(3, 1)], 3: []}, 0, 3) [] def test_single_node_graph(): graph = { 0: [] } assert shortest_path(graph, 0, 0) == [0] def test_small_graph(): graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } assert shortest_path(graph, 0, 3) == [0, 2, 1, 3] assert shortest_path(graph, 0, 1) == [0, 2, 1] assert shortest_path(graph, 1, 0) == [] def test_large_graph(): graph = { i: [(j, 1) for j in range(1, 1000)] for i in range(1000) } assert shortest_path(graph, 0, 999) == [0, 999] def test_disconnected_graph(): graph = { 0: [(1, 1)], 1: [], 2: [(3, 1)], 3: [] } assert shortest_path(graph, 0, 3) == [] assert shortest_path(graph, 2, 3) == [2, 3] def test_same_start_target(): graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } assert shortest_path(graph, 3, 3) == [3] test_single_node_graph() test_small_graph() test_large_graph() test_disconnected_graph() test_same_start_target()","solution":"import heapq def shortest_path(graph, start_node, target_node): Implements Dijkstra's algorithm to find the shortest path from start_node to target_node in a weighted graph represented as an adjacency list. if start_node == target_node: return [start_node] # Priority queue to store (distance, node) and dictionary for distances pq = [(0, start_node)] distances = {node: float('inf') for node in graph} distances[start_node] = 0 # Dictionary to store the path previous_nodes = {node: None for node in graph} while pq: current_distance, current_node = heapq.heappop(pq) if current_node == target_node: path = [] while current_node is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] return path if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(pq, (distance, neighbor)) return []"},{"question":"def tsp_nearest_neighbor(cities: list[tuple[float, float]]) -> list[int]: Solves the Travelling Salesperson Problem using the nearest neighbor heuristic. Args: cities: A list of tuples where each tuple represents the coordinates of a city. Returns: A list of indices representing the order in which to visit the cities to achieve a near-optimal TSP route. Example: >>> tsp_nearest_neighbor([(0, 0), (1, 2), (4, 3), (6, 1)]) [0, 1, 2, 3] pass from solution import tsp_nearest_neighbor def test_single_tour(): cities = [(0, 0), (1, 1), (2, 2), (3, 3)] tour = tsp_nearest_neighbor(cities) assert tour == [0, 1, 2, 3] or tour == [0, 3, 2, 1] def test_small_set(): cities = [(0, 0), (1, 2), (4, 3), (6, 1)] expected_tours = [[0, 1, 2, 3], [0, 1, 3, 2]] tour = tsp_nearest_neighbor(cities) assert tour in expected_tours def test_three_cities(): cities = [(0, 0), (1, 2), (4, 3)] expected_tours = [[0, 1, 2], [0, 2, 1]] tour = tsp_nearest_neighbor(cities) assert tour in expected_tours def test_reversed_input(): cities = [(3, 3), (2, 2), (1, 1), (0, 0)] expected_tours = [[0, 1, 2, 3], [0, 3, 2, 1]] tour = tsp_nearest_neighbor(cities) assert tour in expected_tours def test_non_origin_start(): cities = [(10, 10), (20, 10), (30, 10)] tour = tsp_nearest_neighbor(cities) assert tour == [0, 1, 2] or tour == [0, 2, 1] def test_large_distance(): cities = [(0, 0), (100, 100), (200, 200), (300, 300)] expected_tours = [[0, 1, 2, 3], [0, 3, 2, 1]] tour = tsp_nearest_neighbor(cities) assert tour in expected_tours","solution":"import math def tsp_nearest_neighbor(cities: list[tuple[float, float]]) -> list[int]: Solves the Travelling Salesperson Problem using the nearest neighbor heuristic. Args: cities: A list of tuples where each tuple represents the coordinates of a city. Returns: A list of indices representing the order in which to visit the cities to achieve a near-optimal TSP route. def euclidean_distance(c1, c2): return math.sqrt((c1[0] - c2[0])**2 + (c1[1] - c2[1])**2) n = len(cities) visited = [False] * n tour = [0] # Start the tour with the first city visited[0] = True current_city = 0 for _ in range(n - 1): next_city = -1 min_distance = float('inf') for i in range(n): if not visited[i]: distance = euclidean_distance(cities[current_city], cities[i]) if distance < min_distance: min_distance = distance next_city = i tour.append(next_city) visited[next_city] = True current_city = next_city return tour"},{"question":"import math def plan_route(pickup_dropoff_pairs: list, start_location: tuple) -> tuple: Determine the optimal order in which the driver should visit all the locations to minimize the total travel distance using a greedy algorithm. >>> plan_route([((1, 2), (3, 4)), ((2, 3), (5, 6)), ((6, 7), (8, 9))], (0, 0)) ([(1, 2), (3, 4), (2, 3), (5, 6), (6, 7), (8, 9)], distance_value) >>> plan_route([((1, 1), (2, 2))], (0, 0)) ([(1, 1), (2, 2)], distance_value) def test_basic_scenario(): locations = [((1, 2), (3, 4)), ((2, 3), (5, 6)), ((6, 7), (8, 9))] start = (0, 0) route, distance = plan_route(locations, start) assert len(route) == 6 assert route[0] in [(1, 2), (2, 3), (6, 7)] def test_single_passenger(): locations = [((1, 1), (2, 2))] start = (0, 0) route, distance = plan_route(locations, start) assert route == [(1, 1), (2, 2)] assert distance == math.sqrt(2) + math.sqrt(2) def test_same_location_pickup_dropoff(): locations = [((1, 1), (1, 1))] start = (0, 0) route, distance = plan_route(locations, start) assert route == [(1, 1), (1, 1)] assert distance == math.sqrt(2) def test_multiple_close_locations(): locations = [((1, 2), (3, 4)), ((1, 3), (3, 5))] start = (0, 0) route, distance = plan_route(locations, start) assert len(route) == 4 assert distance > 0 def test_all_dropoffs_further_than_pickups(): locations = [((1, 2), (10, 10)), ((2, 3), (11, 11)), ((3, 4), (12, 12))] start = (0, 0) route, distance = plan_route(locations, start) assert len(route) == 6 assert distance > 0","solution":"import math def plan_route(pickup_dropoff_pairs, start_location): def distance(loc1, loc2): return math.sqrt((loc1[0] - loc2[0]) ** 2 + (loc1[1] - loc2[1]) ** 2) def find_closest_location(current_location, remaining_locations): closest_location = None min_distance = float('inf') for location in remaining_locations: curr_distance = distance(current_location, location) if curr_distance < min_distance: min_distance = curr_distance closest_location = location return closest_location, min_distance remaining_pickups = [pickup for pickup, _ in pickup_dropoff_pairs] remaining_dropoffs = [dropoff for _, dropoff in pickup_dropoff_pairs] route = [] current_location = start_location total_distance = 0 while remaining_pickups or remaining_dropoffs: if remaining_pickups: closest_pickup, dist_to_pickup = find_closest_location(current_location, remaining_pickups) closest_dropoff, dist_to_dropoff = find_closest_location(current_location, remaining_dropoffs) if dist_to_pickup < dist_to_dropoff: route.append(closest_pickup) total_distance += dist_to_pickup current_location = closest_pickup remaining_pickups.remove(closest_pickup) else: route.append(closest_dropoff) total_distance += dist_to_dropoff current_location = closest_dropoff remaining_dropoffs.remove(closest_dropoff) else: closest_dropoff, dist_to_dropoff = find_closest_location(current_location, remaining_dropoffs) route.append(closest_dropoff) total_distance += dist_to_dropoff current_location = closest_dropoff remaining_dropoffs.remove(closest_dropoff) return route, total_distance"},{"question":"import re from collections import Counter from typing import List, Tuple def count_word_frequencies(text: str, stop_words: List[str], n: int) -> List[Tuple[str, int]]: Counts the frequency of each word in the text excluding stop words, and returns the top \`n\` most frequent words and their counts. Parameters: text (str): The content of the text document. stop_words (List[str]): A list of common stop words to exclude. n (int): The number of top frequent words to return. Returns: List[Tuple[str, int]]: A list of tuples containing words and their frequencies. Examples: >>> count_word_frequencies(\\"The quick brown fox jumps over the lazy dog. The dog was not impressed.\\", [\\"the\\", \\"was\\", \\"not\\"], 3) [('dog', 2), ('quick', 1), ('brown', 1)] >>> count_word_frequencies(\\"Data mining is the process of discovering patterns in large data sets. Mining is essential.\\", [\\"is\\", \\"the\\", \\"in\\"], 2) [('mining', 2), ('data', 2)] >>> count_word_frequencies(\\"hello world, hello everyone! this world is full of wonders.\\", [\\"is\\", \\"of\\", \\"this\\"], 2) [('hello', 2), ('world', 2)] >>> count_word_frequencies(\\"\\", [\\"and\\", \\"the\\"], 3) []","solution":"import re from collections import Counter def count_word_frequencies(text: str, stop_words: list[str], n: int) -> list[tuple[str, int]]: Counts the frequency of each word in the text excluding stop words, and returns the top \`n\` most frequent words and their counts. Parameters: text (str): The content of the text document. stop_words (list[str]): A list of common stop words to exclude. n (int): The number of top frequent words to return. Returns: list[tuple[str, int]]: A list of tuples containing words and their frequencies. # Convert text to lowercase text = text.lower() # Use regex to find all words, ignoring punctuation and numbers words = re.findall(r'b[a-z]+b', text) # Filter out stop words filtered_words = [word for word in words if word not in stop_words] # Count the frequency of each word word_counts = Counter(filtered_words) # Get the top \`n\` most common words most_common_words = word_counts.most_common(n) return most_common_words"},{"question":"def celsius_to_fahrenheit(celsius_temperature): Converts Celsius temperature to Fahrenheit. Parameters: celsius_temperature (float): Temperature in Celsius. Returns: float: Temperature in Fahrenheit. >>> celsius_to_fahrenheit(0) 32.0 >>> celsius_to_fahrenheit(100) 212.0 pass def classify_temperature(fahrenheit_temperature): Classifies the temperature in Fahrenheit into categories. Parameters: fahrenheit_temperature (float): Temperature in Fahrenheit. Returns: str: Temperature category (\\"Freezing\\", \\"Cold\\", \\"Warm\\", \\"Hot\\"). >>> classify_temperature(31) 'Freezing' >>> classify_temperature(60) 'Warm' pass import pytest def test_celsius_to_fahrenheit(): assert celsius_to_fahrenheit(0) == 32.0 assert celsius_to_fahrenheit(37) == 98.6 assert celsius_to_fahrenheit(100) == 212.0 assert celsius_to_fahrenheit(-40) == -40.0 assert celsius_to_fahrenheit(20) == 68.0 def test_classify_temperature(): assert classify_temperature(31) == \\"Freezing\\" assert classify_temperature(32) == \\"Cold\\" assert classify_temperature(59) == \\"Cold\\" assert classify_temperature(60) == \\"Warm\\" assert classify_temperature(89) == \\"Warm\\" assert classify_temperature(90) == \\"Hot\\" assert classify_temperature(-10) == \\"Freezing\\" assert classify_temperature(75) == \\"Warm\\" if __name__ == \\"__main__\\": pytest.main()","solution":"def celsius_to_fahrenheit(celsius_temperature): Converts Celsius temperature to Fahrenheit. Parameters: celsius_temperature (float): Temperature in Celsius. Returns: float: Temperature in Fahrenheit. return (celsius_temperature * 9 / 5) + 32 def classify_temperature(fahrenheit_temperature): Classifies the temperature in Fahrenheit into categories. Parameters: fahrenheit_temperature (float): Temperature in Fahrenheit. Returns: str: Temperature category (\\"Freezing\\", \\"Cold\\", \\"Warm\\", \\"Hot\\"). if fahrenheit_temperature < 32: return \\"Freezing\\" elif 32 <= fahrenheit_temperature <= 59: return \\"Cold\\" elif 60 <= fahrenheit_temperature <= 89: return \\"Warm\\" else: return \\"Hot\\""},{"question":"def pattern_exists_in_grid(grid: list[list[str]], pattern: str) -> bool: Implement a function to check if a given pattern exists as a substring in a 2D grid of characters. The pattern can appear horizontally or vertically in the grid. >>> pattern_exists_in_grid( ... [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], ... \\"ABC\\" ... ) True >>> pattern_exists_in_grid( ... [ ... ['A', 'B', 'C', 'E'], ... ['A', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], ... \\"AAA\\" ... ) True >>> pattern_exists_in_grid( ... [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ], ... \\"ABF\\" ... ) False >>> pattern_exists_in_grid( ... [ ... ['A', 'B', 'C', 'D'], ... ['E', 'F', 'G', 'H'], ... ['I', 'J', 'K', 'L'], ... ['M', 'N', 'O', 'P'] ... ], ... \\"EFGH\\" ... ) True >>> pattern_exists_in_grid([], \\"A\\") False >>> pattern_exists_in_grid([['A']], \\"A\\") True","solution":"def pattern_exists_in_grid(grid, pattern): if not grid or not pattern: return False rows = len(grid) cols = len(grid[0]) pat_len = len(pattern) def search_horizontal(r, c): if c + pat_len > cols: return False for i in range(pat_len): if grid[r][c + i] != pattern[i]: return False return True def search_vertical(r, c): if r + pat_len > rows: return False for i in range(pat_len): if grid[r + i][c] != pattern[i]: return False return True for r in range(rows): for c in range(cols): if search_horizontal(r, c) or search_vertical(r, c): return True return False"},{"question":"from typing import List def kth_smallest_element(nums: List[int], k: int) -> int: Find the k-th smallest element in the list using the Quickselect algorithm. >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) 7 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) 10 pass def test_kth_smallest_element(): assert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7 assert kth_smallest_element([7, 10, 4, 3, 20, 15], 4) == 10 assert kth_smallest_element([1], 1) == 1 assert kth_smallest_element([5, 2, 9, 3, 8, 4, 7, 1, 6], 5) == 5 assert kth_smallest_element([2, 1], 1) == 1 assert kth_smallest_element([2, 1], 2) == 2 assert kth_smallest_element([-1, -3, 4, 5, -2, 6], 2) == -2 assert kth_smallest_element([2, 2, 2, 2, 2], 3) == 2 assert kth_smallest_element([1, 2, 3, 4, 5], 5) == 5 def test_empty_list(): try: kth_smallest_element([], 1) except ValueError as e: assert str(e) == \\"k is out of bounds\\"","solution":"from typing import List def kth_smallest_element(nums: List[int], k: int) -> int: def partition(low, high): pivot = nums[high] i = low for j in range(low, high): if nums[j] <= pivot: nums[i], nums[j] = nums[j], nums[i] i += 1 nums[i], nums[high] = nums[high], nums[i] return i def quickselect(low, high, k): if low == high: return nums[low] pivot_index = partition(low, high) if k == pivot_index: return nums[k] elif k < pivot_index: return quickselect(low, pivot_index - 1, k) else: return quickselect(pivot_index + 1, high, k) if not 1 <= k <= len(nums): raise ValueError(\\"k is out of bounds\\") return quickselect(0, len(nums) - 1, k - 1)"},{"question":"def reverse_words(sentence: str) -> str: Reverses the words in a given sentence. Handle leading, trailing, and multiple spaces. >>> reverse_words(\\" the sky is blue \\") \\"blue is sky the\\" >>> reverse_words(\\"hello world\\") \\"world hello\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" >>> reverse_words(\\" \\") \\"\\" >>> reverse_words(\\"\\") \\"\\"","solution":"def reverse_words(sentence: str) -> str: Reverses the words in a given sentence. Handle leading, trailing, and multiple spaces. words = sentence.split() # Split the sentence by spaces to get the words reversed_words = ' '.join(reversed(words)) # Reverse the list of words and join them with a single space return reversed_words"},{"question":"import numpy as np def euclidean_distance_matrix(points: np.ndarray) -> np.ndarray: Computes the Euclidean distance matrix for a given set of points. :param points: A numpy array of shape (m, d) where m is the number of points and d is the dimension of each point. :return: A numpy array of shape (m, m) containing the Euclidean distances between each pair of points. pass # Example Test Cases assert np.allclose(euclidean_distance_matrix(np.array([[0, 0], [3, 4]])), np.array([[0., 5.], [5., 0.]])) assert np.allclose(euclidean_distance_matrix(np.array([[1, 2], [3, 4], [5, 6]])), np.array([[0., 2.82842712, 5.65685425], [2.82842712, 0., 2.82842712], [5.65685425, 2.82842712, 0.]])) assert np.allclose(euclidean_distance_matrix(np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2]])), np.array([[0., 1.73205081, 3.46410162], [1.73205081, 0., 1.73205081], [3.46410162, 1.73205081, 0.]]))","solution":"import numpy as np def euclidean_distance_matrix(points: np.ndarray) -> np.ndarray: Computes the Euclidean distance matrix for a given set of points. :param points: A numpy array of shape (m, d) where m is the number of points and d is the dimension of each point. :return: A numpy array of shape (m, m) containing the Euclidean distances between each pair of points. # Calculate the squared differences between each pair of points squared_diffs = np.sum((points[:, np.newaxis, :] - points[np.newaxis, :, :]) ** 2, axis=2) # Take the square root of the squared differences to get the Euclidean distances distances = np.sqrt(squared_diffs) return distances"},{"question":"def filter_and_sort_logs(logs: list[dict], excluded_user_ids: set) -> list[dict]: Filters out logs with excluded user IDs and sorts the remaining logs by their timestamps. Args: logs (list of dict): List of logs where each log is a dictionary with keys 'user_id', 'timestamp', and 'activity'. excluded_user_ids (set of int): Set of user IDs to be excluded from the logs. Returns: list of dict: Filtered and sorted logs. >>> logs1 = [ >>> {'user_id': 1, 'timestamp': '2023-01-01 12:00:00', 'activity': 'login'}, >>> {'user_id': 2, 'timestamp': '2023-01-01 12:05:00', 'activity': 'logout'}, >>> {'user_id': 3, 'timestamp': '2023-01-01 12:10:00', 'activity': 'purchase'}, >>> {'user_id': 1, 'timestamp': '2023-01-01 12:15:00', 'activity': 'update profile'} >>> ] >>> excluded_user_ids1 = {1} >>> filter_and_sort_logs(logs1, excluded_user_ids1) >>> [{'user_id': 2, 'timestamp': '2023-01-01 12:05:00', 'activity': 'logout'}, {'user_id': 3, 'timestamp': '2023-01-01 12:10:00', 'activity': 'purchase'}] >>> logs2 = [ >>> {'user_id': 2, 'timestamp': '2023-02-01 10:00:00', 'activity': 'login'}, >>> {'user_id': 3, 'timestamp': '2023-02-01 09:00:00', 'activity': 'purchase'}, >>> {'user_id': 4, 'timestamp': '2023-02-01 08:00:00', 'activity': 'logout'} >>> ] >>> excluded_user_ids = {4} >>> filter_and_sort_logs(logs2, excluded_user_ids) >>> [{'user_id': 3, 'timestamp': '2023-02-01 09:00:00', 'activity': 'purchase'}, {'user_id': 2, 'timestamp': '2023-02-01 10:00:00', 'activity': 'login'}] pass","solution":"def filter_and_sort_logs(logs, excluded_user_ids): Filters out logs with excluded user IDs and sorts the remaining logs by their timestamps. Args: logs (list of dict): List of logs where each log is a dictionary with keys 'user_id', 'timestamp', and 'activity'. excluded_user_ids (set of int): Set of user IDs to be excluded from the logs. Returns: list of dict: Filtered and sorted logs. # Filter out logs where the user_id is in the excluded_user_ids set filtered_logs = [log for log in logs if log['user_id'] not in excluded_user_ids] # Sort the filtered logs by timestamp sorted_logs = sorted(filtered_logs, key=lambda log: log['timestamp']) return sorted_logs"},{"question":"import math def calculate_parabolic_motion(initial_speed: float, angle: float) -> dict[str, float]: Calculate the maximum height (H) and the horizontal range (R) of a projectile given its initial speed (v) and the angle of projection (θ) from the horizontal plane. The maximum height can be calculated using the formula: H = (v^2 * sin^2(θ)) / (2 * g) The horizontal range can be calculated using: R = (v^2 * sin(2θ)) / g Where g is the acceleration due to gravity, approximately 9.81 m/s^2. >>> calculate_parabolic_motion(20.0, 45.0) {'maximum_height': 10.19367816091954, 'horizontal_range': 40.7754713824878} >>> calculate_parabolic_motion(30.0, 30.0) {'maximum_height': 11.49425287356322, 'horizontal_range': 79.51662716352418} pass import pytest from solution import calculate_parabolic_motion def test_calculate_parabolic_motion_standard_case(): result = calculate_parabolic_motion(20.0, 45.0) assert pytest.approx(result['maximum_height'], 0.1) == 10.19367816091954 assert pytest.approx(result['horizontal_range'], 0.1) == 40.7754713824878 def test_calculate_parabolic_motion_another_case(): result = calculate_parabolic_motion(30.0, 30.0) assert pytest.approx(result['maximum_height'], 0.1) == 11.49425287356322 assert pytest.approx(result['horizontal_range'], 0.1) == 79.51662716352418 def test_calculate_parabolic_motion_zero_angle(): result = calculate_parabolic_motion(10.0, 0.0) assert pytest.approx(result['maximum_height'], 0.0001) == 0.0 assert pytest.approx(result['horizontal_range'], 0.1) == 0.0 def test_calculate_parabolic_motion_ninety_degree_angle(): result = calculate_parabolic_motion(10.0, 90.0) assert pytest.approx(result['maximum_height'], 0.1) == 5.1020408163265305 assert pytest.approx(result['horizontal_range'], 0.1) == 0.0 def test_calculate_parabolic_motion_negative_speed(): with pytest.raises(ValueError, match=\\"Initial speed must be greater than 0\\"): calculate_parabolic_motion(-10.0, 45.0) def test_calculate_parabolic_motion_out_of_range_angle(): with pytest.raises(ValueError, match=\\"Angle must be between 0 and 90 degrees\\"): calculate_parabolic_motion(10.0, 100.0) with pytest.raises(ValueError, match=\\"Angle must be between 0 and 90 degrees\\"): calculate_parabolic_motion(10.0, -10.0)","solution":"import math def calculate_parabolic_motion(initial_speed: float, angle: float) -> dict[str, float]: if initial_speed <= 0: raise ValueError(\\"Initial speed must be greater than 0\\") if not (0 <= angle <= 90): raise ValueError(\\"Angle must be between 0 and 90 degrees\\") g = 9.81 # Acceleration due to gravity in m/s^2 angle_rad = math.radians(angle) maximum_height = (initial_speed**2 * math.sin(angle_rad)**2) / (2 * g) horizontal_range = (initial_speed**2 * math.sin(2 * angle_rad)) / g return { 'maximum_height': maximum_height, 'horizontal_range': horizontal_range }"},{"question":"def sum_of_masked_subarray(arr: List[int], mask: int) -> int: Returns the sum of elements in the subarray defined by the mask. The binary representation of the mask determines which elements from arr to include in the subarray. >>> sum_of_masked_subarray([1, 2, 3, 4], 5) == 4 >>> sum_of_masked_subarray([10, 20, 30], 3) == 30 >>> sum_of_masked_subarray([5, 10, 15, 20], 10) == 30 >>> sum_of_masked_subarray([1, 2, 3, 4], 0) == 0 >>> sum_of_masked_subarray([1, 2, 3, 4], 15) == 10 >>> sum_of_masked_subarray([1, 2, 3, 4], 1) == 1 >>> sum_of_masked_subarray([1, 2, 3, 4], 2) == 2 >>> sum_of_masked_subarray([1, 2, 3, 4], 4) == 3 >>> sum_of_masked_subarray([1, 2, 3, 4], 8) == 4 >>> sum_of_masked_subarray([i for i in range(1, 33)], (1 << 32) - 1) == sum(range(1, 33))","solution":"def sum_of_masked_subarray(arr, mask): Returns the sum of elements in the subarray defined by the mask. The binary representation of the mask determines which elements from arr to include in the subarray. subarray_sum = 0 # Initialize sum of subarray for i in range(len(arr)): if (mask & (1 << i)) != 0: subarray_sum += arr[i] return subarray_sum"},{"question":"def spiral_order(matrix: list[list[int]]) -> list[int]: Returns the elements of a given matrix in spiral order. >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiral_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiral_order([ ... [1] ... ]) [1] >>> spiral_order([ ... [1, 2, 3], ... [4, 5, 6] ... ]) [1, 2, 3, 6, 5, 4]","solution":"def spiral_order(matrix): Returns the elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] left, right = 0, len(matrix[0]) - 1 top, bottom = 0, len(matrix) - 1 while left <= right and top <= bottom: # Traverse from left to right along the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"from typing import List def length_of_lis(nums: List[int]) -> int: Finds the length of the longest increasing subsequence in the given list of integers. >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([0, 1, 0, 3, 2, 3]) 4 >>> length_of_lis([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([10]) 1 >>> length_of_lis([10, 9, 8, 7, 6, 5, 4]) 1 >>> length_of_lis([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> length_of_lis([3, 4, -1, 0, 6, 2, 3]) 4 >>> length_of_lis([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6","solution":"def length_of_lis(nums: list[int]) -> int: Finds the length of the longest increasing subsequence in the given list of integers. if not nums: return 0 dp = [1] * len(nums) for i in range(len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"import threading class ThreadSafeCounter: A thread-safe counter class that supports concurrent increments by multiple threads. Methods: __init__: Initializes the counter to 0 and sets up a threading lock. increment: Safely increments the counter by 1. get_counter: Safely retrieves the current counter value. def __init__(self): self.counter = 0 self.lock = threading.Lock() def increment(self): with self.lock: self.counter += 1 def get_counter(self) -> int: with self.lock: return self.counter # Unit tests from threading import Thread def test_counter_initial_value(): counter = ThreadSafeCounter() assert counter.get_counter() == 0 def test_counter_increment_single_thread(): counter = ThreadSafeCounter() for _ in range(100): counter.increment() assert counter.get_counter() == 100 def test_counter_increment_multiple_threads(): counter = ThreadSafeCounter() def worker(): for _ in range(1000): counter.increment() threads = [Thread(target=worker) for _ in range(10)] for thread in threads: thread.start() for thread in threads: thread.join() assert counter.get_counter() == 10000 def test_counter_lock_mechanism(): counter = ThreadSafeCounter() def worker(): for _ in range(5000): counter.increment() threads = [Thread(target=worker) for _ in range(20)] for thread in threads: thread.start() for thread in threads: thread.join() assert counter.get_counter() == 100000","solution":"import threading class ThreadSafeCounter: def __init__(self): self.counter = 0 self.lock = threading.Lock() def increment(self): with self.lock: self.counter += 1 def get_counter(self) -> int: with self.lock: return self.counter"},{"question":"def is_prime_sum(num: int) -> str: Determines whether the sum of the digits of a given number is a prime number. >>> is_prime_sum(101) \\"Prime\\" >>> is_prime_sum(123) \\"Not Prime\\" >>> is_prime_sum(987) \\"Not Prime\\" >>> is_prime_sum(7) \\"Prime\\" >>> is_prime_sum(4) \\"Not Prime\\" >>> is_prime_sum(100005) \\"Not Prime\\" >>> is_prime_sum(999999999) \\"Not Prime\\"","solution":"def is_prime_sum(num: int) -> str: def sum_of_digits(n: int) -> int: return sum(int(digit) for digit in str(n)) def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True digit_sum = sum_of_digits(num) return \\"Prime\\" if is_prime(digit_sum) else \\"Not Prime\\""},{"question":"def find_perfect_numbers(start: int, end: int) -> List[int]: Find and return a list of all perfect numbers between \`start\` and \`end\` (inclusive). Parameters: - start (int): The starting integer of the range. - end (int): The ending integer of the range. Returns: - List[int]: A list of perfect numbers between \`start\` and \`end\`. Example: >>> find_perfect_numbers(1, 10000) [6, 28, 496, 8128]","solution":"from typing import List def find_perfect_numbers(start: int, end: int) -> List[int]: Find and return a list of all perfect numbers between \`start\` and \`end\` (inclusive). def is_perfect(number: int) -> bool: if number < 2: return False sum_of_divisors = 1 # 1 is a proper divisor of every number. for i in range(2, int(number**0.5) + 1): if number % i == 0: sum_of_divisors += i if i != number // i: sum_of_divisors += number // i return sum_of_divisors == number perfect_numbers = [] for num in range(start, end + 1): if is_perfect(num): perfect_numbers.append(num) return perfect_numbers"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates an NxN matrix by 90 degrees clockwise. Args: - matrix (list of list of int): The NxN matrix to rotate. Returns: - list of list of int: The rotated matrix. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] >>> rotate_matrix([ ... [1] ... ]) [ [1] ]","solution":"def rotate_matrix(matrix): Rotates an NxN matrix by 90 degrees clockwise. Args: - matrix (list of list of int): The NxN matrix to rotate. Returns: - list of list of int: The rotated matrix. N = len(matrix) # Create an empty NxN matrix rotated_matrix = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): rotated_matrix[j][N - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def count_inversions(arr: list[int]) -> int: Returns the number of inversions required to sort the list in non-decreasing order. >>> count_inversions([1, 3, 2, 3, 1]) 4 >>> count_inversions([2, 4, 1, 3, 5]) 3 >>> count_inversions([5, 4, 3, 2, 1]) 10 >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([]) 0 from solution import count_inversions def test_empty_list(): assert count_inversions([]) == 0 def test_single_element(): assert count_inversions([1]) == 0 def test_sorted_list(): assert count_inversions([1, 2, 3, 4, 5]) == 0 def test_reversed_list(): assert count_inversions([5, 4, 3, 2, 1]) == 10 def test_random_list(): assert count_inversions([1, 3, 2, 3, 1]) == 4 assert count_inversions([2, 4, 1, 3, 5]) == 3 def test_duplicates_list(): assert count_inversions([1, 3, 1, 3]) == 1 def test_large_numbers(): assert count_inversions([1000000000, -1000000000]) == 1 def test_all_elements_same(): assert count_inversions([2, 2, 2]) == 0 def test_large_input(): arr = list(range(100000, 0, -1)) assert count_inversions(arr) == 4999950000","solution":"def count_inversions(arr: list[int]) -> int: if not arr: return 0 def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr)-1)"},{"question":"from typing import List def find_longest_word(s: str, dictionary: List[str]) -> str: Given a collection of words and a specific word, find the longest word in the collection that can be constructed by deleting some characters of the specific word without rearranging the characters. >>> find_longest_word(\\"abpcplea\\", [\\"ale\\",\\"apple\\",\\"monkey\\",\\"plea\\"]) 'apple' >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) 'a' >>> find_longest_word(\\"abpcplea\\", [\\"x\\", \\"y\\", \\"z\\"]) '' >>> find_longest_word(\\"abpcplea\\", []) '' >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"ap\\", \\"ba\\", \\"abp\\"]) 'abp' >>> find_longest_word(\\"abcdefghijklmnopqrstuvwxyz\\", [\\"zxy\\", \\"abc\\", \\"xyz\\"]) 'abc'","solution":"from typing import List def can_form_by_deleting(s: str, word: str) -> bool: it = iter(s) return all(char in it for char in word) def find_longest_word(s: str, dictionary: List[str]) -> str: possible_words = [ word for word in dictionary if can_form_by_deleting(s, word) ] # Sort primarily by -length, and lexicographically as a secondary criteria possible_words.sort(key=lambda x: (-len(x), x)) return possible_words[0] if possible_words else \\"\\""},{"question":"from typing import List, Tuple def find_k_closest_points(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]: Implement a function that returns the k closest points to the origin (0, 0) from a given list of points in a 2D plane. The distance between two points (x1, y1) and (x2, y2) is defined as the Euclidean distance: sqrt((x1 - x2)^2 + (y1 - y2)^2). For the purposes of comparison, ignore the square root operation to avoid unnecessary floating-point arithmetic. Parameters: points (List[Tuple[int, int]]): A list of tuples where each tuple represents the coordinates (x, y) of a point in the 2D plane. k (int): An integer representing the number of closest points to return. Returns: List[Tuple[int, int]]: A list of k points closest to the origin, sorted by their Euclidean distance from the origin. >>> find_k_closest_points([(1, 3), (-2, 2), (5, 8), (0, 1)], 2) [(-2, 2), (0, 1)] >>> find_k_closest_points([(3, 3), (5, -1), (-2, 4)], 1) [(3, 3)] >>> find_k_closest_points([(1, 2), (2, 1), (2, 2), (4, 5)], 3) [(1, 2), (2, 1), (2, 2)]","solution":"from typing import List, Tuple import heapq def find_k_closest_points(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]: Returns the k closest points to the origin (0, 0) from a list of points in a 2D plane. def euclidean_distance_squared(point: Tuple[int, int]) -> int: x, y = point return x * x + y * y # Use a max-heap to keep track of the k smallest elements max_heap = [] for point in points: dist = euclidean_distance_squared(point) if len(max_heap) < k: heapq.heappush(max_heap, (-dist, point)) else: heapq.heappushpop(max_heap, (-dist, point)) return [point for _, point in max_heap]"},{"question":"from typing import List def package_items(weights: List[int], max_weight: int) -> List[List[int]]: Distributes the items into packages such that no package exceeds the max_weight. >>> package_items([4, 8, 1, 4, 2, 6], 10) [[4, 4, 1], [8, 2], [6]] >>> package_items([10, 15, 7, 5, 1], 20) [[10, 7, 1], [15, 5]] >>> package_items([3, 8, 6, 5], 10) [[3, 6], [8], [5]] pass","solution":"from typing import List def package_items(weights: List[int], max_weight: int) -> List[List[int]]: Distributes the items into packages such that no package exceeds the max_weight. # Sort weights in descending order for easier packaging weights.sort(reverse=True) packages = [] for weight in weights: placed = False for package in packages: if sum(package) + weight <= max_weight: package.append(weight) placed = True break if not placed: # Start a new package if it couldn't be placed in existing ones packages.append([weight]) return packages"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotate the given n x n matrix by 90 degrees clockwise in-place. Args: matrix (list[list[int]]): The n x n matrix to rotate. Returns: None: The matrix is modified in-place. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [5, 1], ... [2, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [[2, 5], [4, 1]]","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotate the given n x n matrix by 90 degrees clockwise in-place. Args: matrix (list[list[int]]): The n x n matrix to rotate. Returns: None: The matrix is modified in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def generate_fibonacci_terms(n: int) -> list[int]: Generates the first n terms of the Fibonacci sequence using memoization. :param n: The number of terms to generate. :return: A list of the first n terms of the Fibonacci sequence. >>> generate_fibonacci_terms(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci_terms(0) [] >>> generate_fibonacci_terms(1) [0]","solution":"def generate_fibonacci_terms(n): Generates the first n terms of the Fibonacci sequence using memoization. :param n: The number of terms to generate. :return: A list of the first n terms of the Fibonacci sequence. if n == 0: return [] if n == 1: return [0] memo = {0: 0, 1: 1} def fib(k): if k not in memo: memo[k] = fib(k-1) + fib(k-2) return memo[k] fib_sequence = [fib(i) for i in range(n)] return fib_sequence"},{"question":"def longest_balanced_substring(s: str) -> int: Function to find the length of the longest balanced substring. Args: s (str): A string consisting solely of characters 'a' and 'b'. Returns: int: The length of the longest balanced substring. Examples: >>> longest_balanced_substring(\\"aabb\\") 4 >>> longest_balanced_substring(\\"ababab\\") 6 >>> longest_balanced_substring(\\"aaaa\\") 0 >>> longest_balanced_substring(\\"aabbaabbaab\\") 10","solution":"def longest_balanced_substring(s: str) -> int: Function to find the length of the longest balanced substring. Args: s (str): A string consisting solely of characters 'a' and 'b'. Returns: int: The length of the longest balanced substring. balance_map = {0: -1} balance = 0 max_length = 0 for i, char in enumerate(s): if char == 'a': balance += 1 else: balance -= 1 if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length"},{"question":"import re def parse_log_entry(log_entry: str) -> dict: Parse a single log entry. Parameters: log_entry (str): A single line log entry in Common Log Format. Returns: dict: A dictionary with keys 'ip', 'timestamp', 'request_type', 'url', and 'status_code' containing extracted data. Examples: >>> parse_log_entry('127.0.0.1 - - [10/Oct/2000:13:55:36 -0700] \\"GET /apache_pb.gif HTTP/1.0\\" 200 2326') {'ip': '127.0.0.1', 'timestamp': '10/Oct/2000:13:55:36 -0700', 'request_type': 'GET', 'url': '/apache_pb.gif', 'status_code': 200} >>> parse_log_entry('invalid log entry') {} pass # Your implementation def parse_log_file(log_file_path: str) -> list: Parse a log file and extract details from each entry. Parameters: log_file_path (str): Path to the log file. Returns: list: List of dictionaries, each representing a parsed log entry. Examples: >>> parse_log_file(\\"path_to_log_file\\") [{'ip': '127.0.0.1', 'timestamp': '10/Oct/2000:13:55:36 -0700', 'request_type': 'GET', 'url': '/apache_pb.gif', 'status_code': 200}, {'ip': '192.168.1.1', 'timestamp': '11/Oct/2000:14:56:37 -0700', 'request_type': 'POST', 'url': '/login', 'status_code': 404}] pass # Your implementation def most_frequent_ip(parsed_entries: list) -> str: Find the IP address with the most requests. Parameters: parsed_entries (list): List of parsed log entries. Returns: str: The IP address with the most requests. Examples: >>> most_frequent_ip([ {'ip': '127.0.0.1', 'timestamp': '10/Oct/2000:13:55:36 -0700', 'request_type': 'GET', 'url': '/apache_pb.gif', 'status_code': 200}, {'ip': '192.168.1.1', 'timestamp': '11/Oct/2000:14:56:37 -0700', 'request_type': 'POST', 'url': '/login', 'status_code': 404} ]) '127.0.0.1' pass # Your implementation def error_rate(parsed_entries: list) -> float: Compute the error rate of log entries. Parameters: parsed_entries (list): List of parsed log entries. Returns: float: The error rate as a proportion of all requests. Examples: >>> error_rate([ {'ip': '127.0.0.1', 'timestamp': '10/Oct/2000:13:55:36 -0700', 'request_type': 'GET', 'url': '/apache_pb.gif', 'status_code': 200}, {'ip': '192.168.1.1', 'timestamp': '11/Oct/2000:14:56:37 -0700', 'request_type': 'POST', 'url': '/login', 'status_code': 404} ]) 0.5 >>> error_rate([ {'ip': '127.0.0.1', 'timestamp': '10/Oct/2000:13:55:36 -0700', 'request_type': 'GET', 'url': '/apache_pb.gif', 'status_code': 200} ]) 0.0 pass # Your implementation","solution":"import re def parse_log_entry(log_entry: str) -> dict: Parse a single log entry. Parameters: log_entry (str): A single line log entry in Common Log Format. Returns: dict: A dictionary with keys 'ip', 'timestamp', 'request_type', 'url', and 'status_code' containing extracted data. log_pattern = r'(?P<ip>d{1,3}(?:.d{1,3}){3}) - - [(?P<timestamp>[^]]+)] \\"(?P<request_type>w+) (?P<url>S+) [^\\"]+\\" (?P<status_code>d{3})' match = re.match(log_pattern, log_entry) if match: return { 'ip': match.group('ip'), 'timestamp': match.group('timestamp'), 'request_type': match.group('request_type'), 'url': match.group('url'), 'status_code': int(match.group('status_code')) } return {} def parse_log_file(log_file_path: str) -> list: Parse a log file and extract details from each entry. Parameters: log_file_path (str): Path to the log file. Returns: list: List of dictionaries, each representing a parsed log entry. parsed_entries = [] with open(log_file_path, 'r') as file: for line in file: parsed_entry = parse_log_entry(line.strip()) if parsed_entry: parsed_entries.append(parsed_entry) return parsed_entries def most_frequent_ip(parsed_entries: list) -> str: Find the IP address with the most requests. Parameters: parsed_entries (list): List of parsed log entries. Returns: str: The IP address with the most requests. ip_count = {} for entry in parsed_entries: ip = entry['ip'] if ip in ip_count: ip_count[ip] += 1 else: ip_count[ip] = 1 return max(ip_count, key=ip_count.get) def error_rate(parsed_entries: list) -> float: Compute the error rate of log entries. Parameters: parsed_entries (list): List of parsed log entries. Returns: float: The error rate as a proportion of all requests. total_requests = len(parsed_entries) error_requests = sum(1 for entry in parsed_entries if 400 <= entry['status_code'] < 600) return error_requests / total_requests if total_requests > 0 else 0.0"},{"question":"class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root: AVLTreeNode, key: int) -> AVLTreeNode: Insert a node with the given key into the AVL tree and ensure the tree remains balanced. pass def delete(self, root: AVLTreeNode, key: int) -> AVLTreeNode: Delete the node with the given key from the AVL tree and ensure the tree remains balanced. pass def left_rotate(self, z: AVLTreeNode) -> AVLTreeNode: Perform a left rotation around the given node. pass def right_rotate(self, z: AVLTreeNode) -> AVLTreeNode: Perform a right rotation around the given node. pass def left_right_rotate(self, z: AVLTreeNode) -> AVLTreeNode: Perform a left-right rotation around the given node. pass def right_left_rotate(self, z: AVLTreeNode) -> AVLTreeNode: Perform a right-left rotation around the given node. pass def get_height(self, root: AVLTreeNode) -> int: Return the height of the given node. pass def get_balance(self, root: AVLTreeNode) -> int: Return the balance factor of the given node. pass def process_operations(operations: list, keys: list) -> list: Perform a sequence of insertions and deletions on an AVL tree. >>> process_operations([\\"insert\\", \\"insert\\", \\"insert\\", \\"delete\\", \\"insert\\", \\"insert\\", \\"delete\\"], [10, 20, 30, 20, 15, 25, 10]) [15, 25, 30] >>> process_operations([], []) [] >>> process_operations([\\"insert\\", \\"insert\\", \\"insert\\", \\"insert\\"], [5, 3, 8, 7]) [3, 5, 7, 8] >>> process_operations([\\"delete\\"], [10]) [] >>> process_operations([\\"insert\\", \\"insert\\", \\"insert\\", \\"insert\\", \\"delete\\", \\"insert\\"], [30, 20, 10, 5, 20, 25]) [5, 10, 25, 30] pass","solution":"class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def get_height(self, root: AVLTreeNode) -> int: return root.height if root else 0 def get_balance(self, root: AVLTreeNode) -> int: return self.get_height(root.left) - self.get_height(root.right) if root else 0 def left_rotate(self, z: AVLTreeNode) -> AVLTreeNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = max(self.get_height(z.left), self.get_height(z.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def right_rotate(self, z: AVLTreeNode) -> AVLTreeNode: y = z.left T3 = y.right y.right = z z.left = T3 z.height = max(self.get_height(z.left), self.get_height(z.right)) + 1 y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1 return y def insert(self, root: AVLTreeNode, key: int) -> AVLTreeNode: if not root: return AVLTreeNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def min_value_node(self, node: AVLTreeNode) -> AVLTreeNode: if node is None or node.left is None: return node return self.min_value_node(node.left) def delete(self, root: AVLTreeNode, key: int) -> AVLTreeNode: if not root: return root elif key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self.min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def in_order_traversal(self, root: AVLTreeNode) -> list: res = [] if root: res = self.in_order_traversal(root.left) res.append(root.key) res = res + self.in_order_traversal(root.right) return res def process_operations(operations, keys): tree = AVLTree() root = None for op, key in zip(operations, keys): if op == 'insert': root = tree.insert(root, key) elif op == 'delete': root = tree.delete(root, key) return tree.in_order_traversal(root)"},{"question":"def validate_form(data: dict) -> dict: Validates user inputs in a web form. Args: data (dict): A dictionary where each key is a field name and each value is the corresponding user input. Returns: dict: A dictionary with 'is_valid' (bool) and 'errors' (dict) indicating validation results. Example usage: >>> validate_form({\\"username\\": \\"john_doe\\", \\"email\\": \\"john.doe@example.com\\", \\"age\\": 28}) {'is_valid': True, 'errors': {}} >>> validate_form({\\"username\\": \\"jd!\\", \\"email\\": \\"john.doe@com\\", \\"age\\": 17}) {'is_valid': False, 'errors': {'username': ['Username must be between 3 to 30 characters long and contain only alphanumeric characters.'], 'email': ['Email must be a valid email address.'], 'age': ['Age must be an integer between 18 and 99.']}} # Your implementation here pass # Example usage: form_data = { \\"username\\": \\"john_doe\\", \\"email\\": \\"john.doe@example.com\\", \\"age\\": 28 } validation_results = validate_form(form_data) print(validation_results) # Output: # { # \\"is_valid\\": True, # \\"errors\\": {} # } invalid_form_data = { \\"username\\": \\"jd!\\", \\"email\\": \\"john.doe@com\\", \\"age\\": 17 } validation_results = validate_form(invalid_form_data) print(validation_results) # Output: # { # \\"is_valid\\": False, # \\"errors\\": { # \\"username\\": [\\"Username must be between 3 to 30 characters long and contain only alphanumeric characters.\\"], # \\"email\\": [\\"Email must be a valid email address.\\"], # \\"age\\": [\\"Age must be an integer between 18 and 99.\\"] # } # }","solution":"import re def validate_form(data: dict) -> dict: errors = {} # Validate username username = data.get(\\"username\\") if not username: errors[\\"username\\"] = [\\"Username is required.\\"] elif not re.match(\\"^[a-zA-Z0-9]{3,30}\\", username): errors[\\"username\\"] = [\\"Username must be between 3 to 30 characters long and contain only alphanumeric characters.\\"] # Validate email email = data.get(\\"email\\") if not email: errors[\\"email\\"] = [\\"Email is required.\\"] elif not re.match(r\\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\\", email): errors[\\"email\\"] = [\\"Email must be a valid email address.\\"] # Validate age age = data.get(\\"age\\") if age is None: errors[\\"age\\"] = [\\"Age is required.\\"] elif not isinstance(age, int) or not (18 <= age <= 99): errors[\\"age\\"] = [\\"Age must be an integer between 18 and 99.\\"] is_valid = not bool(errors) return {\\"is_valid\\": is_valid, \\"errors\\": errors}"},{"question":"import threading class InventoryManager: InventoryManager class to manage the product inventory. Includes thread-safe operations for adding, removing, and querying stock levels. Example usage: >>> inventory = InventoryManager() >>> inventory.add_product(product_id=1, quantity=10) >>> inventory.remove_product(product_id=1, quantity=2) >>> inventory.get_stock(product_id=1) 8 def __init__(self) -> None: pass def add_product(self, product_id: int, quantity: int) -> None: pass def remove_product(self, product_id: int, quantity: int) -> None: pass def get_stock(self, product_id: int) -> int: pass if __name__ == \\"__main__\\": inventory = InventoryManager() inventory.add_product(product_id=1, quantity=10) inventory.remove_product(product_id=1, quantity=2) stock_level = inventory.get_stock(product_id=1) print(stock_level) # Output: 8","solution":"import threading class InventoryManager: def __init__(self) -> None: # Dictionary to store the stock levels of products with thread lock for concurrency management self.inventory = {} self.lock = threading.Lock() def add_product(self, product_id: int, quantity: int) -> None: with self.lock: if product_id in self.inventory: self.inventory[product_id] += quantity else: self.inventory[product_id] = quantity def remove_product(self, product_id: int, quantity: int) -> None: with self.lock: if product_id in self.inventory: if self.inventory[product_id] >= quantity: self.inventory[product_id] -= quantity else: raise ValueError(\\"Not enough stock to remove the requested quantity\\") else: raise ValueError(\\"Product does not exist in inventory\\") def get_stock(self, product_id: int) -> int: with self.lock: return self.inventory.get(product_id, 0)"},{"question":"import os import threading import requests class FileDownloader: def __init__(self, url: str, num_threads: int): Initialize with the URL of the file to be downloaded and the number of threads. self.url = url self.num_threads = num_threads self.parts = [] def download(self): Divide the file download into multiple parts and download each part using a separate thread. # Complete this method to perform the download operation. def download_part(self, part_num: int, start: int, end: int): Download a part of the file specified by the range and save it. # Complete this method to handle the downloading of individual file parts. def combine_parts(self): Combine the downloaded parts into a single file named 'downloaded_file'. # Complete this method to combine the parts into the final file. # Sample usage: # url = \\"http://example.com/largefile.zip\\" # num_threads = 4 # downloader = FileDownloader(url, num_threads) # downloader.download() # Uncomment the following lines to test the implementation: # url = \\"http://example.com/largefile.zip\\" # num_threads = 4 # downloader = FileDownloader(url, num_threads) # downloader.download() Unit Test: import os from solution import FileDownloader import requests from unittest.mock import patch, mock_open # Mock responses for requests.head and requests.get HEADERS = {'Content-Length': '100'} def mock_requests_head(url): response = requests.Response() response.headers = HEADERS return response def mock_requests_get(url, headers): response = requests.Response() start, end = map(int, headers['Range'].split('=')[1].split('-')) response._content = bytes([i % 256 for i in range(start, end + 1)]) return response @patch('requests.head', side_effect=mock_requests_head) @patch('requests.get', side_effect=mock_requests_get) def test_file_downloader(mock_head, mock_get): url = \\"http://example.com/largefile.zip\\" num_threads = 4 downloader = FileDownloader(url, num_threads) downloader.download() with open('downloaded_file', 'rb') as f: content = f.read() expected_content = bytes([i % 256 for i in range(100)]) assert content == expected_content os.remove('downloaded_file') def test_combine_parts(): parts = ['part_0', 'part_1', 'part_2', 'part_3'] for i, part in enumerate(parts): with open(part, 'wb') as f: f.write(bytes([j % 256 for j in range(i * 25, (i + 1) * 25)])) downloader = FileDownloader(\\"http://example.com/largefile.zip\\", 4) downloader.parts = parts downloader.combine_parts() with open('downloaded_file', 'rb') as f: content = f.read() expected_content = bytes([i % 256 for i in range(100)]) assert content == expected_content os.remove('downloaded_file') for part in parts: assert not os.path.exists(part)","solution":"import os import threading import requests class FileDownloader: def __init__(self, url: str, num_threads: int): self.url = url self.num_threads = num_threads self.parts = [] self.lock = threading.Lock() def download(self): response = requests.head(self.url) file_size = int(response.headers['Content-Length']) part_size = file_size // self.num_threads threads = [] for i in range(self.num_threads): start = i * part_size end = file_size - 1 if i == self.num_threads - 1 else start + part_size - 1 thread = threading.Thread(target=self.download_part, args=(i, start, end)) threads.append(thread) thread.start() for thread in threads: thread.join() self.combine_parts() def download_part(self, part_num: int, start: int, end: int): headers = {'Range': f'bytes={start}-{end}'} response = requests.get(self.url, headers=headers) part_filename = f'part_{part_num}' with open(part_filename, 'wb') as part_file: part_file.write(response.content) with self.lock: self.parts.append(part_filename) def combine_parts(self): with open('downloaded_file', 'wb') as output_file: for part_file in sorted(self.parts, key=lambda x: int(x.split('_')[1])): with open(part_file, 'rb') as pf: output_file.write(pf.read()) os.remove(part_file)"},{"question":"def compute_prefix_sums(arr: list[int]) -> list[int]: Compute the prefix sums of an array. >>> compute_prefix_sums([1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] >>> compute_prefix_sums([-1, -2, -3, -4, -5]) [-1, -3, -6, -10, -15] >>> compute_prefix_sums([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0] pass def range_sum_query(prefix_sums: list[int], left: int, right: int) -> int: Compute the sum of elements within a specified subarray using prefix sums. >>> range_sum_query([1, 3, 6, 10, 15], 1, 3) 9 >>> range_sum_query([1, 3, 6, 10, 15], 0, 4) 15 >>> range_sum_query([1, 3, 6, 10, 15], 2, 2) 3 pass def range_update_query(arr: list[int], left: int, right: int, val: int) -> list[int]: Perform a range update that adds a given value to all elements within a specified subarray. >>> range_update_query([1, 2, 3, 4, 5], 1, 3, 2) [1, 4, 5, 6, 5] >>> range_update_query([-1, -2, -3, -4, -5], 0, 4, 1) [0, -1, -2, -3, -4] >>> range_update_query([0, 0, 0, 0, 0], 2, 4, 3) [0, 0, 3, 3, 3] pass def maximum_subarray_sum(arr: list[int]) -> int: Find the maximum sum of any contiguous subarray using prefix sums. >>> maximum_subarray_sum([1, 2, 3, 4, 5]) 15 >>> maximum_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> maximum_subarray_sum([3, -2, 5, -1]) 6 >>> maximum_subarray_sum([5, 4, -1, 7, 8]) 23 >>> maximum_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 pass","solution":"def compute_prefix_sums(arr: list[int]) -> list[int]: prefix_sums = [0] * len(arr) prefix_sums[0] = arr[0] for i in range(1, len(arr)): prefix_sums[i] = prefix_sums[i - 1] + arr[i] return prefix_sums def range_sum_query(prefix_sums: list[int], left: int, right: int) -> int: if left == 0: return prefix_sums[right] else: return prefix_sums[right] - prefix_sums[left - 1] def range_update_query(arr: list[int], left: int, right: int, val: int) -> list[int]: for i in range(left, right + 1): arr[i] += val return arr def maximum_subarray_sum(arr: list[int]) -> int: max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def k_closest_points(points: List[List[int]], k: int) -> List[List[int]]: Finds the k closest points to the origin (0, 0) from the given list of points using squared Euclidean distance. >>> k_closest_points([[1, 3], [-2, 2], [4, 6]], 2) [[-2, 2], [1, 3]] >>> k_closest_points([[3, 3], [5, -1], [-2, 4]], 1) [[3, 3]] # Your code here","solution":"import heapq from typing import List def k_closest_points(points: List[List[int]], k: int) -> List[List[int]]: Returns the k closest points to the origin. Args: points (List[List[int]]): List of points where each point is represented as [x, y]. k (int): Number of closest points to return. Returns: List[List[int]]: List of the k closest points to the origin. # Utilize a max-heap to keep track of the k closest points heap = [] for (x, y) in points: # Calculate the squared distance to the origin dist = x * x + y * y if len(heap) < k: heapq.heappush(heap, (-dist, [x, y])) else: heapq.heappushpop(heap, (-dist, [x, y])) return [point for (_, point) in heap]"},{"question":"def reverse_words(sentence: str) -> str: Returns the sentence with the order of words reversed, preserving punctuation and spacing. >>> reverse_words(\\"Hello, this is a test.\\") \\"test. a is this Hello,\\" >>> reverse_words(\\"Python programming is fun!\\") \\"fun! is programming Python\\" >>> reverse_words(\\"Hello, world!\\") \\"world! Hello,\\" >>> reverse_words(\\"Test\\") \\"Test\\" >>> reverse_words(\\"Check 123 test.\\") \\"test. 123 Check\\"","solution":"def reverse_words(sentence: str) -> str: Returns the sentence with the order of words reversed, preserving punctuation and spacing. words = sentence.split() reversed_words = words[::-1] return \\" \\".join(reversed_words)"},{"question":"from typing import List def max_temp_difference(readings: List[int]) -> int: Calculate the maximum temperature difference within a data center. >>> max_temp_difference([30, 20, 25, 28, 18, 27]) 12 >>> max_temp_difference([-10, -20, 5, -5, 0, -15, 9]) 29 >>> max_temp_difference([40, 40]) 0 >>> max_temp_difference([1, 100, -100, 50]) 200 >>> max_temp_difference([0, 1]) 1 >>> max_temp_difference([-100, -50, 0, 50, 100]) 200","solution":"from typing import List def max_temp_difference(readings: List[int]) -> int: if not readings or len(readings) < 2: return 0 min_temp = readings[0] max_temp = readings[0] for temp in readings: if temp < min_temp: min_temp = temp if temp > max_temp: max_temp = temp return max_temp - min_temp"},{"question":"def solve_maze(maze: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]: This function solves the given maze using an iterative Depth-First Search (DFS) algorithm and returns the path from start to end, inclusive. If no path exists, it returns an empty list. Parameters: maze (list of list of int): 2D list representing the maze, where '0' is a free path and '1' is a wall. start (tuple of int): Coordinates (x, y) representing the starting point. end (tuple of int): Coordinates (x, y) representing the exit point. Returns: list of tuple of int: The path from start to end, inclusive, as a list of coordinate tuples. If no path exists, an empty list is returned. stack = [(start, [start])] visited = set() while stack: (x, y), path = stack.pop() if (x, y) in visited: continue visited.add((x, y)) if (x, y) == end: return path # List of potential moves: down, up, right, left for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] == 0: stack.append(((nx, ny), path + [(nx, ny)])) return []","solution":"def solve_maze(maze, start, end): Solves the given maze using DFS and returns the path from start to end. Returns an empty list if no path is found. Parameters: maze (list[list[int]]): 2D list representing the maze start (tuple[int, int]): Starting coordinates (x, y) end (tuple[int, int]): Ending coordinates (x, y) Returns: list[tuple[int, int]]: Path from start to end if exists, otherwise empty list stack = [(start, [start])] visited = set() while stack: (x, y), path = stack.pop() if (x, y) in visited: continue visited.add((x, y)) if (x, y) == end: return path # List of potential moves: down, up, right, left for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] == 0: stack.append(((nx, ny), path + [(nx, ny)])) return []"},{"question":"import re from typing import List def count_profanities(text: str, profane_words: List[str]) -> int: Counts the number of profane words in the given text. Args: text (str): The input text. profane_words (List[str]): A list of profane words to look for. Returns: int: The count of profane words in the text. >>> count_profanities(\\"This is a very bad and nasty example!\\", [\\"bad\\", \\"nasty\\", \\"evil\\"]) 2 >>> count_profanities(\\"Nicer words here, nothing bad!\\", [\\"bad\\", \\"ugly\\"]) 1 >>> count_profanities(\\"\\", [\\"bad\\", \\"ugly\\"]) 0 >>> count_profanities(\\"All words are good and kind.\\", [\\"bad\\", \\"ugly\\"]) 0 >>> count_profanities(\\"BAD nasty Bad BAD\\", [\\"bad\\", \\"nasty\\"]) 4 def test_example_1(): assert count_profanities(\\"This is a very bad and nasty example!\\", [\\"bad\\", \\"nasty\\", \\"evil\\"]) == 2 def test_example_2(): assert count_profanities(\\"Nicer words here, nothing bad!\\", [\\"bad\\", \\"ugly\\"]) == 1 def test_example_3(): assert count_profanities(\\"\\", [\\"bad\\", \\"ugly\\"]) == 0 def test_example_4(): assert count_profanities(\\"All words are good and kind.\\", [\\"bad\\", \\"ugly\\"]) == 0 def test_example_5(): assert count_profanities(\\"BAD nasty Bad BAD\\", [\\"bad\\", \\"nasty\\"]) == 4 def test_case_insensitivity(): assert count_profanities(\\"BaD bAd BAD\\", [\\"bad\\"]) == 3 def test_ignoring_punctuation(): assert count_profanities(\\"bad. bad! bad?\\", [\\"bad\\"]) == 3 def test_whole_word_matching(): assert count_profanities(\\"bad badger bad\\", [\\"bad\\"]) == 2 def test_invalid_text_input(): try: count_profanities(123, [\\"bad\\"]) except ValueError as e: assert str(e) == \\"The input text must be a string.\\" def test_invalid_profane_words_input(): try: count_profanities(\\"test\\", [\\"bad\\", 123]) except ValueError as e: assert str(e) == \\"All profane words must be strings.\\" def test_empty_profane_word_list(): assert count_profanities(\\"bad badger bad\\", []) == 0","solution":"import re from typing import List def count_profanities(text: str, profane_words: List[str]) -> int: Counts the number of profane words in the given text. Args: text (str): The input text. profane_words (List[str]): A list of profane words to look for. Returns: int: The count of profane words in the text. if not isinstance(text, str): raise ValueError(\\"The input text must be a string.\\") if not all(isinstance(word, str) for word in profane_words): raise ValueError(\\"All profane words must be strings.\\") # Normalize the text to lowercase and remove punctuation cleaned_text = re.sub(r'[^ws]', '', text.lower()) # Split the text into words words = cleaned_text.split() # Convert the list of profane words to lowercase for case insensitivity profane_set = set(word.lower() for word in profane_words) # Count the profane words profane_count = sum(1 for word in words if word in profane_set) return profane_count"},{"question":"class InventorySystem: def __init__(self, stores_info: dict[int, int]): Initialize the inventory system with the provided store capacities. :param stores_info: Dictionary where key is the store ID and value is the capacity of the store. pass def receive_shipment(self, shipment: list[tuple[int, int]]) -> None: Receive a shipment and update the inventory for each store. :param shipment: List of tuples where each tuple contains store ID and the quantity of product to be added. :raises ValueError: If adding a shipment exceeds the capacity of a store. pass def dispatch_products(self, orders: list[tuple[int, int]]) -> None: Dispatch products from the stores based on given orders. :param orders: List of tuples where each tuple contains store ID and the quantity of product to be dispatched. :raises ValueError: If an order exceeds the current inventory of a store. pass def get_inventory_levels(self) -> dict[int, int]: Get the current inventory levels for all stores. :return: Dictionary where key is the store ID and value is the current inventory level. pass import pytest def test_receive_shipment_normal(): I = InventorySystem({1: 100, 2: 150, 3: 200}) I.receive_shipment([(1, 50), (2, 100), (3, 150)]) assert I.get_inventory_levels() == {1: 50, 2: 100, 3: 150} def test_receive_shipment_exceeds_capacity(): I = InventorySystem({1: 100}) with pytest.raises(ValueError, match=\\"Shipment exceeds capacity for store 1\\"): I.receive_shipment([(1, 101)]) def test_dispatch_products_normal(): I = InventorySystem({1: 100, 2: 150, 3: 200}) I.receive_shipment([(1, 50), (2, 100), (3, 150)]) I.dispatch_products([(1, 20), (2, 50)]) assert I.get_inventory_levels() == {1: 30, 2: 50, 3: 150} def test_dispatch_products_exceeds_inventory(): I = InventorySystem({1: 100}) I.receive_shipment([(1, 50)]) with pytest.raises(ValueError, match=\\"Order exceeds current inventory for store 1\\"): I.dispatch_products([(1, 60)]) def test_get_inventory_levels_empty_initial(): I = InventorySystem({1: 100, 2: 150, 3: 200}) assert I.get_inventory_levels() == {1: 0, 2: 0, 3: 0} def test_invalid_store_id_in_shipment(): I = InventorySystem({1: 100}) with pytest.raises(ValueError, match=\\"Store ID 2 does not exist.\\"): I.receive_shipment([(2, 50)]) def test_invalid_store_id_in_orders(): I = InventorySystem({1: 100}) with pytest.raises(ValueError, match=\\"Store ID 2 does not exist.\\"): I.dispatch_products([(2, 50)])","solution":"class InventorySystem: def __init__(self, stores_info: dict[int, int]): Initialize the inventory system with the provided store capacities. :param stores_info: Dictionary where key is the store ID and value is the capacity of the store. self.stores_capacity = stores_info self.stores_inventory = {store_id: 0 for store_id in stores_info} def receive_shipment(self, shipment: list[tuple[int, int]]) -> None: Receive a shipment and update the inventory for each store. :param shipment: List of tuples where each tuple contains store ID and the quantity of product to be added. :raises ValueError: If adding a shipment exceeds the capacity of a store. for store_id, quantity in shipment: if store_id not in self.stores_capacity: raise ValueError(f\\"Store ID {store_id} does not exist.\\") if self.stores_inventory[store_id] + quantity > self.stores_capacity[store_id]: raise ValueError(f\\"Shipment exceeds capacity for store {store_id}\\") self.stores_inventory[store_id] += quantity def dispatch_products(self, orders: list[tuple[int, int]]) -> None: Dispatch products from the stores based on given orders. :param orders: List of tuples where each tuple contains store ID and the quantity of product to be dispatched. :raises ValueError: If an order exceeds the current inventory of a store. for store_id, quantity in orders: if store_id not in self.stores_capacity: raise ValueError(f\\"Store ID {store_id} does not exist.\\") if self.stores_inventory[store_id] < quantity: raise ValueError(f\\"Order exceeds current inventory for store {store_id}\\") self.stores_inventory[store_id] -= quantity def get_inventory_levels(self) -> dict[int, int]: Get the current inventory levels for all stores. :return: Dictionary where key is the store ID and value is the current inventory level. return self.stores_inventory"},{"question":"class EventVenue: A class to manage bookings for an event venue. Attributes: capacity (int): Total capacity of the venue. Methods: __init__(self, capacity: int) -> None: Initialize the venue with a specified total capacity. book_reservation(self, group_size: int) -> None: Adds a booking for a group of the specified size. cancel_reservation(self, group_size: int) -> None: Cancels a booking for a group of the specified size. current_occupancy(self) -> int: Returns the current number of booked seats. def __init__(self, capacity: int) -> None: Initialize the venue with a specified total capacity and sets current occupancy to 0. def book_reservation(self, group_size: int) -> None: Adds a booking for a group of the specified size. Raises a ValueError if the booking exceeds the available capacity. def cancel_reservation(self, group_size: int) -> None: Cancels a booking for a group of the specified size. Raises a ValueError if the cancellation results in negative occupancy. def current_occupancy(self) -> int: Returns the current number of booked seats. import pytest from solution import EventVenue def test_initialization(): venue = EventVenue(100) assert venue.current_occupancy() == 0 def test_booking_within_capacity(): venue = EventVenue(100) venue.book_reservation(50) assert venue.current_occupancy() == 50 def test_booking_exceed_capacity(): venue = EventVenue(100) venue.book_reservation(90) with pytest.raises(ValueError, match=\\"Not enough capacity\\"): venue.book_reservation(20) def test_cancellation_within_booked(): venue = EventVenue(100) venue.book_reservation(60) venue.cancel_reservation(30) assert venue.current_occupancy() == 30 def test_cancellation_exceed_booked(): venue = EventVenue(100) venue.book_reservation(40) with pytest.raises(ValueError, match=\\"Cannot cancel more than booked\\"): venue.cancel_reservation(50) def test_booking_and_cancellation_sequence(): venue = EventVenue(100) venue.book_reservation(20) venue.book_reservation(30) assert venue.current_occupancy() == 50 venue.cancel_reservation(10) assert venue.current_occupancy() == 40 venue.book_reservation(50) assert venue.current_occupancy() == 90 with pytest.raises(ValueError, match=\\"Not enough capacity\\"): venue.book_reservation(20) venue.cancel_reservation(30) assert venue.current_occupancy() == 60 with pytest.raises(ValueError, match=\\"Cannot cancel more than booked\\"): venue.cancel_reservation(70)","solution":"class EventVenue: def __init__(self, capacity: int): Initialize the venue with a specified total capacity and sets current occupancy to 0. self.capacity = capacity self.current_booked = 0 def book_reservation(self, group_size: int) -> None: Adds a booking for a group of the specified size. Raises a ValueError if the booking exceeds the available capacity. if self.current_booked + group_size > self.capacity: raise ValueError(\\"Not enough capacity\\") self.current_booked += group_size def cancel_reservation(self, group_size: int) -> None: Cancels a booking for a group of the specified size. Raises a ValueError if the cancellation results in negative occupancy. if self.current_booked - group_size < 0: raise ValueError(\\"Cannot cancel more than booked\\") self.current_booked -= group_size def current_occupancy(self) -> int: Returns the current number of booked seats. return self.current_booked"},{"question":"from typing import Dict def unique_chars_count(s: str) -> Dict[str, int]: Create a function that counts the frequency of each unique character in a given string and returns the results as a dictionary. The string must be only lowercase alphabetical characters (1 ≤ len(s) ≤ 10^5). >>> unique_chars_count(\\"hello\\") {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> unique_chars_count(\\"programming\\") {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} The function should raise a ValueError if the input constraints are violated. import pytest def test_unique_chars_count_basic(): assert unique_chars_count(\\"hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} def test_unique_chars_count_repeated_characters(): assert unique_chars_count(\\"aabbcc\\") == {'a': 2, 'b': 2, 'c': 2} def test_unique_chars_count_no_repetition(): assert unique_chars_count(\\"abcd\\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1} def test_unique_chars_count_single_character(): assert unique_chars_count(\\"a\\") == {'a': 1} def test_unique_chars_count_programming(): assert unique_chars_count(\\"programming\\") == {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} def test_unique_chars_count_invalid_characters(): with pytest.raises(ValueError, match=\\"The string must contain only lowercase alphabetical characters\\"): unique_chars_count(\\"hello123\\") def test_unique_chars_count_invalid_length(): with pytest.raises(ValueError, match=\\"The length of the string must be between 1 and 100,000 characters\\"): unique_chars_count(\\"\\") def test_unique_chars_count_uppercase_characters(): with pytest.raises(ValueError, match=\\"The string must contain only lowercase alphabetical characters\\"): unique_chars_count(\\"Hello\\") def test_unique_chars_count_special_characters(): with pytest.raises(ValueError, match=\\"The string must contain only lowercase alphabetical characters\\"): unique_chars_count(\\"hello!\\") def test_unique_chars_count_boundary_length(): assert unique_chars_count(\\"a\\" * 100000) == {'a': 100000}","solution":"from typing import Dict def unique_chars_count(s: str) -> Dict[str, int]: if not (1 <= len(s) <= 10**5): raise ValueError(\\"The length of the string must be between 1 and 100,000 characters\\") if not s.isalpha() or not s.islower(): raise ValueError(\\"The string must contain only lowercase alphabetical characters\\") char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 return char_count"},{"question":"def time_based_greeting(time_str: str) -> str: Returns an appropriate greeting based on the provided time. >>> time_based_greeting(\\"06:30\\") \\"Good Morning\\" >>> time_based_greeting(\\"12:00\\") \\"Good Afternoon\\" >>> time_based_greeting(\\"19:45\\") \\"Good Evening\\" >>> time_based_greeting(\\"23:15\\") \\"Good Night\\"","solution":"def time_based_greeting(time_str: str) -> str: Returns an appropriate greeting based on the given time. :param time_str: A string representing the time in \`HH:MM\` format. :return: A string with the appropriate greeting. hour = int(time_str[:2]) if 5 <= hour < 12: return \\"Good Morning\\" elif 12 <= hour < 17: return \\"Good Afternoon\\" elif 17 <= hour < 21: return \\"Good Evening\\" else: return \\"Good Night\\""},{"question":"import numpy as np def generate_and_sort_matrix(n: int, min_value: int, max_value: int) -> np.ndarray: Generates an n x n matrix with random integers between min_value and max_value, and then returns the matrix with each diagonal sorted in non-decreasing order. :param n: int - the size of the matrix (n x n) :param min_value: int - the minimum value for the random integers :param max_value: int - the maximum value for the random integers :return: numpy ndarray - the n x n matrix with diagonals sorted pass def test_generate_and_sort_matrix_4x4(): matrix = generate_and_sort_matrix(4, 0, 9) assert matrix.shape == (4, 4) assert np.all(matrix >= 0) and np.all(matrix <= 9) # Check that each diagonal is sorted for i in range(4): diagonal = [matrix[j][i+j] for j in range(4-i)] assert diagonal == sorted(diagonal) for i in range(1, 4): diagonal = [matrix[i+j][j] for j in range(4-i)] assert diagonal == sorted(diagonal) def test_generate_and_sort_matrix_2x2(): matrix = generate_and_sort_matrix(2, 0, 3) assert matrix.shape == (2, 2) assert np.all(matrix >= 0) and np.all(matrix <= 3) def test_generate_and_sort_matrix_3x3(): matrix = generate_and_sort_matrix(3, -5, 5) assert matrix.shape == (3, 3) assert np.all(matrix >= -5) and np.all(matrix <= 5) # Check that each diagonal is sorted for i in range(3): diagonal = [matrix[j][i+j] for j in range(3-i)] assert diagonal == sorted(diagonal) for i in range(1, 3): diagonal = [matrix[i+j][j] for j in range(3-i)] assert diagonal == sorted(diagonal) def test_generate_and_sort_matrix_5x5(): matrix = generate_and_sort_matrix(5, 10, 20) assert matrix.shape == (5, 5) assert np.all(matrix >= 10) and np.all(matrix <= 20) # Check that each diagonal is sorted for i in range(5): diagonal = [matrix[j][i+j] for j in range(5-i)] assert diagonal == sorted(diagonal) for i in range(1, 5): diagonal = [matrix[i+j][j] for j in range(5-i)] assert diagonal == sorted(diagonal)","solution":"import numpy as np import random def generate_and_sort_matrix(n, min_value, max_value): Generates an n x n matrix with random integers between min_value and max_value, and then returns the matrix with each diagonal sorted in non-decreasing order. :param n: int - the size of the matrix (n x n) :param min_value: int - the minimum value for the random integers :param max_value: int - the maximum value for the random integers :return: numpy array - the n x n matrix with sorted diagonals # Generate the n x n matrix with random integers matrix = np.array([[random.randint(min_value, max_value) for _ in range(n)] for _ in range(n)]) # Function to sort and set a diagonal def sort_and_set_diagonal(matrix, i, j): vals = [] x, y = i, j while x < n and y < n: vals.append(matrix[x][y]) x += 1 y += 1 vals.sort() x, y = i, j idx = 0 while x < n and y < n: matrix[x][y] = vals[idx] x += 1 y += 1 idx += 1 # Sort diagonals starting from each element in the first row for j in range(n): sort_and_set_diagonal(matrix, 0, j) # Sort diagonals starting from each element in the first column (excluding the [0,0]) for i in range(1, n): sort_and_set_diagonal(matrix, i, 0) return matrix"},{"question":"Problem Statement: You need to design a data structure for a dynamic priority queue. This priority queue will support integer priorities and allow for changes to the priorities of existing elements. # Features to Implement: 1. **Insert Element**: - Method: \`insert(element: Any, priority: int) -> None\` - Description: Adds an element with a specific priority to the priority queue. If the element already exists, raise a \`ValueError\`. 2. **Increase Priority**: - Method: \`increase_priority(element: Any, priority: int) -> None\` - Description: Increases the priority of the given element. If the element does not exist or the new priority is not greater than the current priority, raise a \`ValueError\`. 3. **Decrease Priority**: - Method: \`decrease_priority(element: Any, priority: int) -> None\` - Description: Decreases the priority of the given element. If the element does not exist or the new priority is not lesser than the current priority, raise a \`ValueError\`. 4. **Extract Max**: - Method: \`extract_max() -> Any\` - Description: Removes and returns the element with the highest priority. If the priority queue is empty, raise an \`IndexError\`. 5. **Peek Max**: - Method: \`peek_max() -> Any\` - Description: Returns the element with the highest priority without removing it. If the priority queue is empty, raise an \`IndexError\`. 6. **Contains Element**: - Method: \`contains(element: Any) -> bool\` - Description: Returns \`True\` if the element is present in the priority queue, \`False\` otherwise. # Constraints: - The priority queue must be implemented efficiently, especially for the operations involving priority changes. - Duplicate priorities are allowed, but each element must be unique. - The elements within the priority queue can be of any data type. # Example: # Example Usage pq = DynamicPriorityQueue() pq.insert(\\"task1\\", priority=3) pq.insert(\\"task2\\", priority=5) pq.insert(\\"task3\\", priority=1) assert pq.peek_max() == \\"task2\\" pq.increase_priority(\\"task3\\", priority=6) assert pq.peek_max() == \\"task3\\" pq.decrease_priority(\\"task3\\", priority=2) assert pq.peek_max() == \\"task2\\" pq.extract_max() assert pq.peek_max() == \\"task1\\" assert pq.contains(\\"task2\\") == False print(\\"All tests passed.\\") import pytest from solution import DynamicPriorityQueue def test_insert(): pq = DynamicPriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 5) assert pq.contains(\\"task1\\") is True assert pq.contains(\\"task2\\") is True with pytest.raises(ValueError): pq.insert(\\"task1\\", 3) def test_increase_priority(): pq = DynamicPriorityQueue() pq.insert(\\"task1\\", 3) pq.increase_priority(\\"task1\\", 5) assert pq.peek_max() == \\"task1\\" with pytest.raises(ValueError): pq.increase_priority(\\"task1\\", 3) with pytest.raises(ValueError): pq.increase_priority(\\"nonexistent\\", 5) def test_decrease_priority(): pq = DynamicPriorityQueue() pq.insert(\\"task1\\", 5) pq.decrease_priority(\\"task1\\", 3) assert pq.peek_max() == \\"task1\\" with pytest.raises(ValueError): pq.decrease_priority(\\"task1\\", 5) with pytest.raises(ValueError): pq.decrease_priority(\\"nonexistent\\", 3) def test_extract_max(): pq = DynamicPriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 5) assert pq.extract_max() == \\"task2\\" assert pq.extract_max() == \\"task1\\" with pytest.raises(IndexError): pq.extract_max() def test_peek_max(): pq = DynamicPriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 5) assert pq.peek_max() == \\"task2\\" pq.extract_max() assert pq.peek_max() == \\"task1\\" pq.extract_max() with pytest.raises(IndexError): pq.peek_max() def test_contains(): pq = DynamicPriorityQueue() pq.insert(\\"task1\\", 3) pq.insert(\\"task2\\", 5) assert pq.contains(\\"task1\\") is True assert pq.contains(\\"task2\\") is True pq.extract_max() assert pq.contains(\\"task2\\") is False","solution":"import heapq class DynamicPriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} # mapping of elements to entries self.REMOVED = '<removed-element>' # placeholder for a removed element self.counter = 0 # unique sequence count for tie-breaking def insert(self, element, priority): Adds an element with a specific priority to the priority queue. If the element already exists, raise a ValueError. if element in self.entry_finder: raise ValueError(\\"Element already exists in the priority queue.\\") count = self.counter entry = [-priority, count, element] # use negative priority to simulate max-heap in heapq self.entry_finder[element] = entry heapq.heappush(self.heap, entry) self.counter += 1 def increase_priority(self, element, priority): Increases the priority of the given element. If element does not exist or the new priority is not greater than current priority, raise a ValueError. if element not in self.entry_finder: raise ValueError(\\"Element not found in the priority queue.\\") current_entry = self.entry_finder[element] current_priority = -current_entry[0] if priority <= current_priority: raise ValueError(\\"New priority must be greater than the current priority.\\") self._remove_element(element) self.insert(element, priority) def decrease_priority(self, element, priority): Decreases the priority of the given element. If element does not exist or the new priority is not lesser than current priority, raise a ValueError. if element not in self.entry_finder: raise ValueError(\\"Element not found in the priority queue.\\") current_entry = self.entry_finder[element] current_priority = -current_entry[0] if priority >= current_priority: raise ValueError(\\"New priority must be less than the current priority.\\") self._remove_element(element) self.insert(element, priority) def extract_max(self): Removes and returns the element with the highest priority. If the priority queue is empty, raise an IndexError. while self.heap: priority, count, element = heapq.heappop(self.heap) if element is not self.REMOVED: del self.entry_finder[element] return element raise IndexError(\\"The priority queue is empty.\\") def peek_max(self): Returns the element with the highest priority without removing it. If the priority queue is empty, raise an IndexError. while self.heap: priority, count, element = self.heap[0] if element is not self.REMOVED: return element heapq.heappop(self.heap) raise IndexError(\\"The priority queue is empty.\\") def contains(self, element): Returns True if the element is present in the priority queue, False otherwise. return element in self.entry_finder and self.entry_finder[element][2] is not self.REMOVED def _remove_element(self, element): Marks an existing element as REMOVED. entry = self.entry_finder.pop(element) entry[2] = self.REMOVED"},{"question":"from typing import List, Tuple def sort_products(products: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sort the products list first by priority in descending order, and then by price in ascending order for products with the same priority. :param products: List of tuples, where each tuple contains (product name, priority, price). :returns: Sorted list of products based on the specified criteria. Examples: >>> sort_products([(\\"Product_A\\", 3, 19.99), (\\"Product_B\\", 1, 9.99), (\\"Product_C\\", 3, 17.49), (\\"Product_D\\", 2, 5.99)]) [('Product_C', 3, 17.49), ('Product_A', 3, 19.99), ('Product_D', 2, 5.99), ('Product_B', 1, 9.99)] >>> sort_products([(\\"Product_A\\", 2, 19.99), (\\"Product_B\\", 2, 9.99), (\\"Product_C\\", 2, 17.49), (\\"Product_D\\", 2, 5.99)]) [('Product_D', 2, 5.99), ('Product_B', 2, 9.99), ('Product_C', 2, 17.49), ('Product_A', 2, 19.99)]","solution":"from typing import List, Tuple def sort_products(products: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sort the products list first by priority in descending order, and then by price in ascending order for products with the same priority. :param products: List of tuples, where each tuple contains (product name, priority, price). :returns: Sorted list of products based on the specified criteria. return sorted(products, key=lambda x: (-x[1], x[2]))"},{"question":"from typing import List def custom_sort(arr: List[int]) -> List[int]: Sort an array of integers using only adjacent swaps. >>> custom_sort([3, 2, 1]) [1, 2, 3] >>> custom_sort([4, 5, 1, 2, 3]) [1, 2, 3, 4, 5] >>> custom_sort([10, -1, 2, 5, -3]) [-3, -1, 2, 5, 10] >>> custom_sort([1]) [1] >>> custom_sort([]) [] >>> custom_sort([2, 2, 2, 2]) [2, 2, 2, 2] >>> custom_sort([-10, 2, 2, -1, 5, 0]) [-10, -1, 0, 2, 2, 5] >>> custom_sort(list(range(999, -1, -1))) list(range(1000))","solution":"from typing import List def custom_sort(arr: List[int]) -> List[int]: Sort an array of integers using only adjacent swaps. n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr"},{"question":"from typing import List, Tuple def shortest_path(num_locations: int, roads: List[Tuple[int, int, int]], start: int, target: int) -> List[int]: Find the shortest path from the starting location to the target location using Dijkstra's algorithm. >>> shortest_path(5, [(0, 1, 10), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 1, 4), (2, 3, 8), (2, 4, 2), (3, 4, 7), (4, 3, 9)], 0, 3) [0, 2, 1, 3] >>> shortest_path(5, [(0, 1, 10), (1, 2, 1), (2, 3, 2)], 0, 4) [] >>> shortest_path(1, [], 0, 0) [0] >>> shortest_path(4, [(0, 1, 1), (1, 2, 1), (0, 2, 5), (2, 3, 1)], 0, 3) [0, 1, 2, 3] >>> shortest_path(1000, [(i, i+1, 1) for i in range(999)], 0, 999) list(range(0, 1000))","solution":"import heapq from typing import List, Tuple def shortest_path(num_locations: int, roads: List[Tuple[int, int, int]], start: int, target: int) -> List[int]: # Step 1: Build the graph as an adjacency list graph = {i: [] for i in range(num_locations)} for u, v, d in roads: graph[u].append((v, d)) graph[v].append((u, d)) # Assuming undirected graph, omit if directed # Step 2: Initialize data structures for Dijkstra's algorithm distances = {node: float('inf') for node in range(num_locations)} distances[start] = 0 priority_queue = [(0, start)] predecessors = {node: None for node in range(num_locations)} while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reach the target, no need to continue if current_node == target: break # Check next nodes for neighbor, weight in graph[current_node]: distance = current_distance + weight # If a shorter path to \`neighbor\` is found if distance < distances[neighbor]: distances[neighbor] = distance predecessors[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Step 3: Reconstruct the shortest path path = [] step = target while step is not None: path.insert(0, step) step = predecessors[step] if path[0] == start: return path else: return [] # No path found"},{"question":"# Performs an in-order traversal of a binary tree. def in_order_traversal(root: Optional[TreeNode]) -> List[int]: def traverse(node: Optional[TreeNode], inorder: List[int]): if node: traverse(node.left, inorder) inorder.append(node.val) traverse(node.right, inorder) result = [] traverse(root, result) return result","solution":"from typing import List, Optional class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def in_order_traversal(root: Optional[TreeNode]) -> List[int]: Performs an in-order traversal of a binary tree. Args: root (Optional[TreeNode]): The root of the binary tree. Returns: List[int]: List of node values in in-order sequence. def traverse(node: Optional[TreeNode], inorder: List[int]): if node: traverse(node.left, inorder) inorder.append(node.val) traverse(node.right, inorder) result = [] traverse(root, result) return result"},{"question":"from typing import List def count_unique_sequences(commands: List[List[str]]) -> int: Returns the number of unique command sequences. :param commands: List of command sequences :return: Number of unique sequences >>> count_unique_sequences([[\\"start\\", \\"load\\", \\"compute\\", \\"save\\"]]) 1 >>> count_unique_sequences([ ... [\\"start\\", \\"load\\", \\"compute\\", \\"save\\"], ... [\\"deploy\\", \\"start\\", \\"compute\\", \\"shutdown\\"], ... [\\"start\\", \\"init\\", \\"compute\\", \\"log\\"] ... ]) 3 >>> count_unique_sequences([ ... [\\"start\\", \\"load\\", \\"compute\\", \\"save\\"], ... [\\"start\\", \\"load\\", \\"compute\\", \\"save\\"], ... [\\"start\\", \\"load\\", \\"compute\\", \\"save\\"] ... ]) 1 >>> count_unique_sequences([ ... [\\"start\\", \\"load\\", \\"compute\\", \\"save\\"], ... [\\"deploy\\", \\"start\\", \\"compute\\", \\"shutdown\\"], ... [\\"start\\", \\"load\\", \\"compute\\", \\"save\\"], ... [\\"start\\", \\"init\\", \\"compute\\", \\"log\\"], ... [\\"start\\", \\"init\\", \\"compute\\", \\"log\\"] ... ]) 3 >>> count_unique_sequences([]) 0","solution":"from typing import List def count_unique_sequences(commands: List[List[str]]) -> int: Returns the number of unique command sequences. :param commands: List of command sequences :return: Number of unique sequences unique_sequences = set() for sequence in commands: # Convert each sequence to a tuple so it can be added to a set unique_sequences.add(tuple(sequence)) return len(unique_sequences)"},{"question":"class ListNode: def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class MyHashMap: def __init__(self, initial_capacity=10): self.capacity = initial_capacity self.size = 0 self.buckets = [None] * self.capacity def put(self, key, value): Insert or update the value for a given key in the HashMap. pass def get(self, key): Retrieve the value associated with the key in the HashMap. If the key does not exist, return -1. pass def remove(self, key): Remove the value associated with the key in the HashMap. pass def _resize(self): Double the capacity of the HashMap and rehash all existing keys. pass import pytest def test_put_and_get(): hm = MyHashMap() hm.put(1, 1) hm.put(2, 2) assert hm.get(1) == 1 assert hm.get(2) == 2 def test_get_non_existent(): hm = MyHashMap() assert hm.get(3) == -1 def test_remove(): hm = MyHashMap() hm.put(1, 10) hm.remove(1) assert hm.get(1) == -1 def test_update_value(): hm = MyHashMap() hm.put(1, 1) hm.put(1, 2) assert hm.get(1) == 2 def test_collision_handling(): hm = MyHashMap() key1 = 1 key2 = 11 # assuming default capacity is 10, this will collide with key1 hm.put(key1, 100) hm.put(key2, 200) assert hm.get(key1) == 100 assert hm.get(key2) == 200 def test_resize(): hm = MyHashMap(initial_capacity=4) hm.put(1, 1) hm.put(2, 2) hm.put(3, 3) hm.put(4, 4) # This put should trigger a resize hm.put(5, 5) assert hm.get(1) == 1 assert hm.get(2) == 2 assert hm.get(3) == 3 assert hm.get(4) == 4 assert hm.get(5) == 5","solution":"class ListNode: def __init__(self, key=None, value=None, next=None): self.key = key self.value = value self.next = next class MyHashMap: def __init__(self, initial_capacity=10): self.capacity = initial_capacity self.size = 0 self.buckets = [None] * self.capacity def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): index = self._hash(key) if self.buckets[index] is None: self.buckets[index] = ListNode(key, value) else: current = self.buckets[index] while current: if current.key == key: current.value = value return if current.next is None: current.next = ListNode(key, value) break current = current.next self.size += 1 if self.size / self.capacity > 0.75: self._resize() def get(self, key): index = self._hash(key) current = self.buckets[index] while current: if current.key == key: return current.value current = current.next return -1 def remove(self, key): index = self._hash(key) current = self.buckets[index] prev = None while current: if current.key == key: if prev is None: self.buckets[index] = current.next else: prev.next = current.next self.size -= 1 return prev = current current = current.next def _resize(self): new_capacity = self.capacity * 2 new_buckets = [None] * new_capacity current_buckets = self.buckets self.capacity = new_capacity self.buckets = new_buckets self.size = 0 for node in current_buckets: while node: self.put(node.key, node.value) node = node.next"},{"question":"from typing import List def unique_emails(emails: List[str]) -> List[str]: Returns a list of unique email addresses, all in lowercase. Parameters: emails (List[str]): The list of email addresses. Returns: List[str]: A list of unique email addresses in lowercase. >>> unique_emails([\\"Example@domain.COM\\", \\"example@domain.com\\", \\"user@site.org\\"]) [\\"example@domain.com\\", \\"user@site.org\\"] >>> unique_emails([\\"user1@domain.com\\", \\"user2@domain.com\\", \\"user3@domain.com\\"]) [\\"user1@domain.com\\", \\"user2@domain.com\\", \\"user3@domain.com\\"] >>> unique_emails([\\"DUPLICATE@DOMAIN.com\\", \\"duplicate@domain.com\\", \\"DUPlicate@domain.com\\"]) [\\"duplicate@domain.com\\"] >>> unique_emails([]) [] >>> unique_emails([\\"single@domain.com\\"]) [\\"single@domain.com\\"] >>> unique_emails([\\"email@domain.com\\", \\"email@domain.com\\"]) [\\"email@domain.com\\"] >>> unique_emails([\\"Example@Domain.com\\", \\"example@domain.com\\", \\"EXAMPLE@DOMAIN.COM\\"]) [\\"example@domain.com\\"]","solution":"from typing import List def unique_emails(emails: List[str]) -> List[str]: Returns a list of unique email addresses, all in lowercase. Parameters: emails (List[str]): The list of email addresses. Returns: List[str]: A list of unique email addresses in lowercase. # Convert all emails to lowercase and use a set to filter out duplicates unique_emails_set = set(email.lower() for email in emails) # Convert the set back to a list return list(unique_emails_set)"},{"question":"class SimpleCache: def __init__(self, capacity: int): Initialize the cache with a given capacity. Args: capacity (int): The maximum number of items the cache can hold. Raises: ValueError: If the capacity is less than or equal to 0. pass def put(self, key: int, value: int) -> None: Insert a key-value pair into the cache. Evict the least recently added item if the cache exceeds its set capacity. Args: key (int): Key identifying the item. value (int): Value to be associated with the key. pass def get(self, key: int) -> int: Retrieve the value associated with the given key. Args: key (int): Key for which to retrieve the value. Returns: int: Value associated with the key, or -1 if the key does not exist. pass # Example Usage: cache = SimpleCache(capacity=2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Returns 1 cache.put(3, 3) # Evicts key 2 since capacity is 2 and cache is full print(cache.get(2)) # Returns -1 (not found as it was evicted) cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4","solution":"class SimpleCache: def __init__(self, capacity: int): Initialize the cache with a given capacity. Args: capacity (int): The maximum number of items the cache can hold. Raises: ValueError: If the capacity is less than or equal to 0. if capacity <= 0: raise ValueError(\\"Capacity must be greater than 0.\\") self.capacity = capacity self.cache = {} self.order = [] def put(self, key: int, value: int) -> None: Insert a key-value pair into the cache. Evict the least recently added item if the cache exceeds its set capacity. Args: key (int): Key identifying the item. value (int): Value to be associated with the key. if key in self.cache: # Remove the old occurrence of the key self.order.remove(key) elif len(self.cache) >= self.capacity: # Evict the least recently added (first in the order list) oldest_key = self.order.pop(0) del self.cache[oldest_key] self.cache[key] = value self.order.append(key) def get(self, key: int) -> int: Retrieve the value associated with the given key. Args: key (int): Key for which to retrieve the value. Returns: int: Value associated with the key, or -1 if the key does not exist. return self.cache.get(key, -1)"},{"question":"def shortest_path(grid: list[list[int]]) -> int: Returns the shortest path time from the top-left to the bottom-right corner in a weighted grid. Args: grid (list[list[int]]): A 2D list of non-negative integers representing the grid Returns: int: The shortest time to travel from the top-left to the bottom-right corner Examples: >>> shortest_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> shortest_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> shortest_path([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> shortest_path([[0]]) 0 pass import heapq def test_shortest_path_simple(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert shortest_path(grid) == 7 def test_shortest_path_larger_grid(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert shortest_path(grid) == 21 def test_shortest_path_uniform_grid(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert shortest_path(grid) == 5 def test_shortest_path_single_cell(): grid = [ [0] ] assert shortest_path(grid) == 0 def test_shortest_path_minimal_edge_case(): grid = [ [1, 1], [0, 1] ] assert shortest_path(grid) == 2","solution":"import heapq def shortest_path(grid): Returns the shortest path time from the top-left to the bottom-right corner in a weighted grid. rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up # Priority queue to manage the exploration of cells, initialized with the starting point pq = [(grid[0][0], 0, 0)] # (current_time, row, col) min_time = [[float('inf')] * cols for _ in range(rows)] min_time[0][0] = grid[0][0] while pq: current_time, r, c = heapq.heappop(pq) # If we reached the bottom-right corner, return the current_time if r == rows - 1 and c == cols - 1: return current_time for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: new_time = current_time + grid[nr][nc] if new_time < min_time[nr][nc]: min_time[nr][nc] = new_time heapq.heappush(pq, (new_time, nr, nc)) return min_time[rows - 1][cols - 1]"},{"question":"def predict_next_item( item_sequence: list, transition_matrix: dict, item_space: list ) -> str: Predict the next most viewed item using the given item sequence and a transition matrix based on the Markov Chain model. Args: item_sequence (list): A list of items that represent the sequence of items a user has interacted with. transition_matrix (dict): A nested dictionary where the outer keys represent the current items, inner keys represent the next possible items, and values are the probabilities of transitioning from the current item to the next item. item_space (list): A list of all possible items that can be recommended. Returns: str: The predicted next most viewed item. Examples: >>> sequence = [\\"item1\\", \\"item2\\", \\"item3\\"] >>> trans_matrix = {\\"item1\\": {\\"item2\\": 0.8, \\"item3\\": 0.2}, \\"item2\\": {\\"item1\\": 0.6, \\"item3\\": 0.4}, \\"item3\\": {\\"item1\\": 0.3, \\"item2\\": 0.7}} >>> items = [\\"item1\\", \\"item2\\", \\"item3\\"] >>> predict_next_item(sequence, trans_matrix, items) == \\"item2\\" >>> sequence = [\\"bookA\\", \\"bookB\\", \\"bookC\\"] >>> trans_matrix = {\\"bookA\\": {\\"bookB\\": 0.5, \\"bookD\\": 0.5}, \\"bookB\\": {\\"bookA\\": 0.4, \\"bookC\\": 0.6}, \\"bookC\\": {\\"bookA\\": 0.3, \\"bookB\\": 0.7}} >>> items = [\\"bookA\\", \\"bookB\\", \\"bookC\\", \\"bookD\\"] >>> predict_next_item(sequence, trans_matrix, items) == \\"bookB\\" pass","solution":"def predict_next_item(item_sequence, transition_matrix, item_space): Predicts the next most viewed item using the given item sequence and a transition matrix based on the Markov Chain model. Args: item_sequence (list): A list of items that represent the sequence of items a user has interacted with. transition_matrix (dict): A nested dictionary where the outer keys represent the current items, inner keys represent the next possible items, and values are the probabilities of transitioning from the current item to the next item. item_space (list): A list of all possible items that can be recommended. Returns: str: The predicted next most viewed item. if not item_sequence: raise ValueError(\\"The item_sequence list is empty.\\") last_item = item_sequence[-1] if last_item not in transition_matrix: raise ValueError(f\\"The last item {last_item} is not in the transition matrix.\\") next_items_probabilities = transition_matrix[last_item] # Find the item with the highest transition probability from the last item next_item = max(next_items_probabilities, key=next_items_probabilities.get) return next_item"},{"question":"from typing import List def product_of_array_except_self(nums: List[int]) -> List[int]: Write a function 'product_of_array_except_self(nums: List[int]) -> List[int]' that takes in an array of integers 'nums' and returns an array 'output' such that 'output[i]' is equal to the product of all the elements of 'nums' except 'nums[i]'. >>> product_of_array_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_array_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] pass","solution":"from typing import List def product_of_array_except_self(nums: List[int]) -> List[int]: length = len(nums) left_products = [1] * length # Fill left_products where left_products[i] is the product of all elements to the left of i for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] right_products = 1 for i in range(length - 1, -1, -1): left_products[i] = left_products[i] * right_products right_products *= nums[i] return left_products"},{"question":"import numpy as np def rotate_image(image: np.ndarray) -> np.ndarray: Rotates the given 2D numpy array (grayscale image) by 90 degrees clockwise. Parameters: image (numpy.ndarray): A 2D array representing the grayscale image. Returns: numpy.ndarray: The image rotated 90 degrees clockwise. Examples: >>> image = np.array([ ... [52, 55, 61], ... [59, 79, 85], ... [51, 52, 58] ... ]) >>> rotate_image(image) array([ [51, 59, 52], [52, 79, 55], [58, 85, 61] ]) >>> image = np.array([ ... [1, 2], ... [3, 4] ... ]) >>> rotate_image(image) array([ [3, 1], [4, 2] ]) pass def test_rotate_image_3x3(): image = np.array([ [52, 55, 61], [59, 79, 85], [51, 52, 58] ]) expected_output = np.array([ [51, 59, 52], [52, 79, 55], [58, 85, 61] ]) assert np.array_equal(rotate_image(image), expected_output) def test_rotate_image_2x2(): image = np.array([ [1, 2], [3, 4] ]) expected_output = np.array([ [3, 1], [4, 2] ]) assert np.array_equal(rotate_image(image), expected_output) def test_rotate_image_1x4(): image = np.array([ [1, 2, 3, 4] ]) expected_output = np.array([ [1], [2], [3], [4] ]) assert np.array_equal(rotate_image(image), expected_output) def test_rotate_image_4x1(): image = np.array([ [1], [2], [3], [4] ]) expected_output = np.array([ [4, 3, 2, 1] ]) assert np.array_equal(rotate_image(image), expected_output) def test_rotate_image_large_matrix(): # Creating a 1000x1000 matrix for testing image = np.arange(1000000).reshape((1000, 1000)) rotated_image = rotate_image(image) for i in range(1000): for j in range(1000): assert rotated_image[j][999-i] == image[i][j]","solution":"import numpy as np def rotate_image(image: np.ndarray) -> np.ndarray: Rotates the given 2D numpy array (grayscale image) by 90 degrees clockwise. Parameters: image (numpy.ndarray): A 2D array representing the grayscale image. Returns: numpy.ndarray: The image rotated 90 degrees clockwise. return np.rot90(image, -1)"},{"question":"def rle_compress(text: str) -> str: Compresses the input text using Run-Length Encoding (RLE). Parameters: text (str): The input string to compress. Returns: str: The RLE compressed string. >>> rle_compress('aaabbc') == 'a3b2c1' >>> rle_compress('') == '' >>> rle_compress('abcdefgh') == 'a1b1c1d1e1f1g1h1' >>> rle_compress('aaAA') == 'a2A2' >>> rle_compress('😀😀😀abc') == '😀3a1b1c1' pass def test_rle_compress_empty_string(): assert rle_compress('') == '' def test_rle_compress_single_character(): assert rle_compress('a') == 'a1' def test_rle_compress_no_repeats(): assert rle_compress('abcdefg') == 'a1b1c1d1e1f1g1' def test_rle_compress_all_same_characters(): assert rle_compress('aaaaa') == 'a5' def test_rle_compress_mixed_characters(): assert rle_compress('aaabbcc') == 'a3b2c2' def test_rle_compress_case_sensitivity(): assert rle_compress('aaAA') == 'a2A2' def test_rle_compress_unicode_characters(): assert rle_compress('😀😀😀abc') == '😀3a1b1c1' def test_rle_compress_large_input(): input_string = 'a' * 1000 + 'b' * 1000 + 'c' * 1000 expected_output = 'a1000b1000c1000' assert rle_compress(input_string) == expected_output","solution":"def rle_compress(text: str) -> str: Compresses the input text using Run-Length Encoding (RLE). Parameters: text (str): The input string to compress. Returns: str: The RLE compressed string. if not text: return '' compressed = [] prev_char = text[0] count = 1 for char in text[1:]: if char == prev_char: count += 1 else: compressed.append(prev_char + str(count)) prev_char = char count = 1 compressed.append(prev_char + str(count)) return ''.join(compressed)"},{"question":"from typing import List def is_rotated_sorted_array(arr: List[int]) -> bool: Checks if the given array is a rotated version of a sorted array. >>> is_rotated_sorted_array([4, 5, 6, 1, 2, 3]) True >>> is_rotated_sorted_array([1, 3, 2, 4, 5]) False >>> is_rotated_sorted_array([10]) True >>> is_rotated_sorted_array([1, 2, 3, 4, 5]) True","solution":"from typing import List def is_rotated_sorted_array(arr: List[int]) -> bool: Checks if the given array is a rotated version of a sorted array. # An empty array or single element array is trivially a rotated sorted array if len(arr) <= 1: return True # Check the number of \\"drops\\" in the array (i.e., where arr[i-1] > arr[i]) drops = 0 for i in range(1, len(arr)): if arr[i - 1] > arr[i]: drops += 1 # More than one drop indicates it's not a rotated sorted array if drops > 1: return False # Check for the drop across the boundary (from last element to first element) if drops == 1 and arr[-1] > arr[0]: return False return True"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_list_to_bst(nums: list) -> TreeNode: Constructs a height-balanced binary search tree (BBST) from a sorted list of unique integers. >>> bst = sorted_list_to_bst([-10, -3, 0, 5, 9]) >>> list_representation(bst) == [0, -3, 9, -10, None, 5] True >>> bst = sorted_list_to_bst([1, 2, 3]) >>> list_representation(bst) == [2, 1, 3] True >>> bst = sorted_list_to_bst([1]) >>> list_representation(bst) == [1] True >>> bst = sorted_list_to_bst([]) >>> bst is None True def list_representation(root: TreeNode) -> list: Helper function to get the level-order list representation of the tree for easy comparison in tests. from collections import deque if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing None values that represent missing nodes beyond the last actual node. while result and result[-1] is None: result.pop() return result","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_list_to_bst(nums: list) -> TreeNode: Constructs a height-balanced binary search tree (BBST) from a sorted list of unique integers. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_list_to_bst(nums[:mid]) root.right = sorted_list_to_bst(nums[mid + 1:]) return root"},{"question":"from typing import List from datetime import date def generate_recurring_dates(start: date, end: date, pattern: str, interval: int) -> List[date]: Generate a list of dates for recurring events. :param start: The start date of the recurrence. :param end: The end date of the recurrence. :param pattern: The recurrence pattern (\\"daily\\", \\"weekly\\", \\"monthly\\"). :param interval: The interval between recurrences. :return: List of dates when the event occurs. >>> generate_recurring_dates(date(2023, 1, 1), date(2023, 1, 10), \\"daily\\", 2) [date(2023, 1, 1), date(2023, 1, 3), date(2023, 1, 5), date(2023, 1, 7), date(2023, 1, 9)] >>> generate_recurring_dates(date(2023, 1, 1), date(2023, 3, 1), \\"weekly\\", 1) [date(2023, 1, 1), date(2023, 1, 8), date(2023, 1, 15), date(2023, 1, 22), date(2023, 1, 29), date(2023, 2, 5), date(2023, 2, 12), date(2023, 2, 19), date(2023, 2, 26)]","solution":"from typing import List from datetime import date, timedelta def generate_recurring_dates(start: date, end: date, pattern: str, interval: int) -> List[date]: Generate a list of dates for recurring events. :param start: The start date of the recurrence. :param end: The end date of the recurrence. :param pattern: The recurrence pattern (\\"daily\\", \\"weekly\\", \\"monthly\\"). :param interval: The interval between recurrences. :return: List of dates when the event occurs. dates = [] current_date = start while current_date <= end: dates.append(current_date) if pattern == \\"daily\\": current_date += timedelta(days=interval) elif pattern == \\"weekly\\": current_date += timedelta(weeks=interval) elif pattern == \\"monthly\\": month = current_date.month - 1 + interval year = current_date.year + month // 12 month = month % 12 + 1 day = min(current_date.day, [31, 29 if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1]) current_date = date(year, month, day) else: raise ValueError(\\"Invalid pattern. Should be 'daily', 'weekly', or 'monthly'.\\") return dates"},{"question":"from typing import List import heapq import os import pickle class HuffmanNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def build_frequency_table(text: str) -> dict: Build a frequency table from the given text. pass def build_huffman_tree(frequency: dict) -> HuffmanNode: Build the Huffman tree based on the frequency table. pass def build_huffman_codes(tree: HuffmanNode) -> dict: Build the Huffman codes for each character based on the Huffman tree. pass def compress(src_path: str, dest_path: str) -> None: Compress the text file at src_path using Huffman encoding and save the result at dest_path. Args: src_path (str): path to the input text file dest_path (str): path to save the compressed output file >>> compress(\\"input.txt\\", \\"compressed_output.huff\\") pass def read_compressed_file(path: str) -> tuple: Read and return the compressed file content. Args: path (str): path to the compressed output file with open(path, 'rb') as file: return pickle.load(file)","solution":"import heapq import os import pickle class HuffmanNode: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def build_frequency_table(text): frequency = {} for char in text: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency def build_huffman_tree(frequency): heap = [HuffmanNode(char, freq) for char, freq in frequency.items()] heapq.heapify(heap) while len(heap) > 1: node1 = heapq.heappop(heap) node2 = heapq.heappop(heap) merged = HuffmanNode(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(heap, merged) return heap[0] def build_huffman_codes(tree): codes = {} def traverse(node, current_code): if node is None: return if node.char is not None: codes[node.char] = current_code traverse(node.left, current_code + \\"0\\") traverse(node.right, current_code + \\"1\\") traverse(tree, \\"\\") return codes def compress(src_path, dest_path): with open(src_path, 'r') as file: text = file.read() frequency = build_frequency_table(text) huffman_tree = build_huffman_tree(frequency) huffman_codes = build_huffman_codes(huffman_tree) encoded_text = ''.join(huffman_codes[char] for char in text) extra_padding = 8 - len(encoded_text) % 8 for _ in range(extra_padding): encoded_text += \\"0\\" padded_info = \\"{0:08b}\\".format(extra_padding) encoded_text = padded_info + encoded_text b = bytearray() for i in range(0, len(encoded_text), 8): byte = encoded_text[i:i+8] b.append(int(byte, 2)) with open(dest_path, 'wb') as output: pickle.dump((huffman_tree, b), output)"},{"question":"class Bank: A class that simulates a simple banking system. This system can handle multiple bank accounts, each with its own balance. It supports creating an account, depositing money, withdrawing money, and transferring money between accounts. def __init__(self): Initializes a new instance of the Bank class with an empty dictionary of accounts. pass def create_account(self, account_id: str): Creates a new account with the given ID and an initial balance of 0.0. Args: account_id (str): The unique ID of the new account. pass def deposit(self, account_id: str, amount: float): Increases the balance of the specified account by the given amount. Args: account_id (str): The ID of the account to deposit money into. amount (float): The amount of money to deposit. pass def withdraw(self, account_id: str, amount: float) -> bool: Decreases the balance of the specified account by the given amount, if sufficient funds are available. Args: account_id (str): The ID of the account to withdraw money from. amount (float): The amount of money to withdraw. Returns: bool: Returns \`False\` if the account has insufficient funds, otherwise \`True\`. pass def transfer(self, from_account: str, to_account: str, amount: float) -> bool: Withdraws the specified amount from the source account and deposits it into the destination account, if possible. Args: from_account (str): The ID of the account to transfer money from. to_account (str): The ID of the account to transfer money to. amount (float): The amount of money to transfer. Returns: bool: Returns \`False\` if the transfer fails due to insufficient funds or nonexistent accounts, otherwise \`True\`. pass def test_create_account(): bank = Bank() bank.create_account(\\"acc1\\") assert \\"acc1\\" in bank.accounts assert bank.accounts[\\"acc1\\"] == 0.0 def test_deposit(): bank = Bank() bank.create_account(\\"acc1\\") bank.deposit(\\"acc1\\", 500.0) assert bank.accounts[\\"acc1\\"] == 500.0 def test_withdraw_success(): bank = Bank() bank.create_account(\\"acc1\\") bank.deposit(\\"acc1\\", 500.0) assert bank.withdraw(\\"acc1\\", 300.0) == True assert bank.accounts[\\"acc1\\"] == 200.0 def test_withdraw_failure(): bank = Bank() bank.create_account(\\"acc1\\") assert bank.withdraw(\\"acc1\\", 100.0) == False bank.deposit(\\"acc1\\", 100.0) assert bank.withdraw(\\"acc1\\", 200.0) == False def test_transfer_success(): bank = Bank() bank.create_account(\\"acc1\\") bank.create_account(\\"acc2\\") bank.deposit(\\"acc1\\", 500.0) assert bank.transfer(\\"acc1\\", \\"acc2\\", 300.0) == True assert bank.accounts[\\"acc1\\"] == 200.0 assert bank.accounts[\\"acc2\\"] == 300.0 def test_transfer_failure_due_to_insufficient_funds(): bank = Bank() bank.create_account(\\"acc1\\") bank.create_account(\\"acc2\\") bank.deposit(\\"acc1\\", 100.0) assert bank.transfer(\\"acc1\\", \\"acc2\\", 200.0) == False assert bank.accounts[\\"acc1\\"] == 100.0 assert bank.accounts[\\"acc2\\"] == 0.0 def test_transfer_failure_due_to_nonexistent_account(): bank = Bank() bank.create_account(\\"acc1\\") bank.deposit(\\"acc1\\", 500.0) assert bank.transfer(\\"acc1\\", \\"acc2\\", 200.0) == False assert bank.accounts[\\"acc1\\"] == 500.0","solution":"class Bank: def __init__(self): self.accounts = {} def create_account(self, account_id: str): if account_id not in self.accounts: self.accounts[account_id] = 0.0 def deposit(self, account_id: str, amount: float): if account_id in self.accounts: self.accounts[account_id] += amount def withdraw(self, account_id: str, amount: float) -> bool: if account_id in self.accounts and self.accounts[account_id] >= amount: self.accounts[account_id] -= amount return True return False def transfer(self, from_account: str, to_account: str, amount: float) -> bool: if from_account in self.accounts and to_account in self.accounts and self.accounts[from_account] >= amount: self.accounts[from_account] -= amount self.accounts[to_account] += amount return True return False"},{"question":"def remove_duplicates(int_list: list) -> list: Removes duplicates from the list while maintaining the order of the first occurrences. >>> remove_duplicates([1, 2, 3, 2, 4, 3, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 4, 4, 7, 8]) [4, 5, 7, 8] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([5, 6, 7, 7, 8, 9, 10, 6, 5, 4, 3]) [5, 6, 7, 8, 9, 10, 4, 3]","solution":"def remove_duplicates(int_list: list) -> list: Removes duplicates from the list while maintaining the order of the first occurrences. seen = set() result = [] for num in int_list: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"# Completion Task: Implement a Cache Simulator with LRU Replacement Policy **Context**: A cache is a hardware or software component that stores data so that future requests for that data can be served faster. One common cache replacement policy is Least Recently Used (LRU), which discards the least recently used items first. **Task**: Based on the information provided, create a \`CacheSimulator\` class with the specified requirements and methods. **Function Signature**: class CacheSimulator: def __init__(self, capacity: int) -> None: pass def refer(self, key: int) -> None: pass def display(self) -> list[int]: pass **Detailed Requirements**: 1. **Initialization**: The constructor should accept a single parameter: - \`capacity\`: An integer representing the maximum number of items that the cache can hold. 2. **Refer Function**: - You should implement the \`refer\` method to refer to a specific key in the cache. - If the key is already present, it should move to the most recently used position. - If the key is not present and the cache has reached its capacity, it should remove the least recently used item before adding the new key to the cache. 3. **Display Function**: - The \`display\` method should return a list of keys in the cache, ordered from the most recently used to the least recently used. **Constraints**: - All keys will be non-negative integers. - Capacity will be a positive integer. **Example**: >>> cache = CacheSimulator(4) >>> cache.refer(1) >>> cache.refer(2) >>> cache.refer(3) >>> cache.refer(1) >>> cache.refer(4) >>> cache.refer(5) >>> print(cache.display()) [5, 4, 1, 3] **Explanation**: - When you refer key 1, 2, and 3, they are added to the cache. - Referring key 1 again moves it to the most recently used position. - Adding key 4 to the cache makes the cache full. - Referring key 5 removes the least recently used key (which is key 2) and adds key 5 to the cache. **Performance Requirements**: - The \`refer\` method should operate within practical time limits for typical usage scenarios, ideally within O(1) time complexity for both insertion and deletion. - Memory usage should be efficient and within reasonable limits considering the cache capacity. <|solution|>from collections import OrderedDict class CacheSimulator: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = OrderedDict() def refer(self, key: int) -> None: if key in self.cache: self.cache.move_to_end(key) else: if len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = None self.cache.move_to_end(key) def display(self) -> list[int]: return list(self.cache.keys())[::-1]","solution":"from collections import OrderedDict class CacheSimulator: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = OrderedDict() def refer(self, key: int) -> None: if key in self.cache: self.cache.move_to_end(key) else: if len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = None self.cache.move_to_end(key) def display(self) -> list[int]: return list(self.cache.keys())[::-1]"},{"question":"def search_hierarchy(hierarchy, path): Efficiently search for all objects that match a given category path in the hierarchy. hierarchy: a nested dictionary representing the hierarchical structure. Categories are strings, and the lowest level dictionaries contain lists of objects. path: a list of strings representing the path of categories to search for. Returns a list of all objects that match the given category path. >>> hierarchy = { ... \\"Electronics\\": { ... \\"Computers\\": { ... \\"Laptops\\": [\\"Laptop1\\", \\"Laptop2\\"], ... \\"Desktops\\": [\\"Desktop1\\"] ... }, ... \\"Cameras\\": [\\"Camera1\\", \\"Camera2\\"] ... }, ... \\"Furniture\\": { ... \\"Chairs\\": [\\"Chair1\\", \\"Chair2\\"], ... \\"Tables\\": [\\"Table1\\"] ... } ... } >>> search_hierarchy(hierarchy, [\\"Electronics\\", \\"Computers\\", \\"Laptops\\"]) [\\"Laptop1\\", \\"Laptop2\\"] >>> search_hierarchy(hierarchy, [\\"Furniture\\"]) [\\"Chair1\\", \\"Chair2\\", \\"Table1\\"] >>> search_hierarchy(hierarchy, []) [\\"Laptop1\\", \\"Laptop2\\", \\"Desktop1\\", \\"Camera1\\", \\"Camera2\\", \\"Chair1\\", \\"Chair2\\", \\"Table1\\"] >>> search_hierarchy(hierarchy, [\\"Nonexistent\\", \\"Path\\"]) [] >>> search_hierarchy(hierarchy, [\\"Electronics\\", \\"Computers\\"]) [\\"Laptop1\\", \\"Laptop2\\", \\"Desktop1\\"]","solution":"def search_hierarchy(hierarchy, path): def search_helper(node, sub_path): if not sub_path: # Collect all objects from current node recursively if isinstance(node, list): return node elif isinstance(node, dict): objects = [] for key in node: objects.extend(search_helper(node[key], sub_path)) return objects else: return [] first, *rest = sub_path if first in node: return search_helper(node[first], rest) else: return [] return search_helper(hierarchy, path)"},{"question":"def first_missing_positive(nums: List[int]) -> int: Find the smallest positive integer that does not appear in the unsorted integer array. The solution should run in O(n) time and use constant extra space. Args: nums (List[int]): A list of integers (can be negative, zero, or positive). Returns: int: The smallest positive integer not present in the list. Examples: >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 from typing import List def test_example_cases(): assert first_missing_positive([3, 4, -1, 1]) == 2 assert first_missing_positive([1, 2, 0]) == 3 assert first_missing_positive([7, 8, 9, 11, 12]) == 1 def test_single_element(): assert first_missing_positive([1]) == 2 assert first_missing_positive([2]) == 1 def test_no_positive_integers(): assert first_missing_positive([-1, -2, -3]) == 1 assert first_missing_positive([-1, 0, -3]) == 1 def test_all_positions_filled(): assert first_missing_positive([1, 2, 3, 4, 5]) == 6 assert first_missing_positive([5, 4, 3, 2, 1]) == 6 def test_with_duplicates(): assert first_missing_positive([1, 1, 0, -1, -2]) == 2 assert first_missing_positive([3, 2, 2, 1, 1]) == 4 def test_mixed_numbers(): assert first_missing_positive([0, 10, 2, -10, -20]) == 1 assert first_missing_positive([4, -3, 2, 1, 7, 0]) == 3 def test_large_numbers(): assert first_missing_positive([2**31 - 1, 1, 2, 3]) == 4 assert first_missing_positive([-2**31, 1, 2, 0]) == 3","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: AVL Tree implementation with insert operation to maintain balance. Methods: insert(self, key: int) -> None: Inserts a node with the given key into the AVL Tree. inorder_traversal(self) -> list[int]: Returns a list of keys in the tree in inorder sequence. def insert(self, key: int) -> None: ... def inorder_traversal(self) -> list[int]: ... # Helper methods to maintain AVL properties def _height(self, node: AVLTreeNode) -> int: ... def _rotate_left(self, z: AVLTreeNode) -> AVLTreeNode: ... def _rotate_right(self, z: AVLTreeNode) -> AVLTreeNode: ... def _get_balance(self, node: AVLTreeNode) -> int: ... def _insert_node(self, node: AVLTreeNode, key: int) -> AVLTreeNode: ... # Example Test Cases avl = AVLTree() avl.insert(10) avl.insert(20) avl.insert(30) assert avl.inorder_traversal() == [10, 20, 30] avl.insert(5) avl.insert(15) assert avl.inorder_traversal() == [5, 10, 15, 20, 30] avl.insert(25) assert avl.inorder_traversal() == [5, 10, 15, 20, 25, 30]","solution":"class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: if not self.root: self.root = AVLTreeNode(key) else: self.root = self._insert_node(self.root, key) def inorder_traversal(self) -> list[int]: result = [] self._inorder_helper(self.root, result) return result # Helper methods to maintain AVL properties def _height(self, node: AVLTreeNode) -> int: return node.height if node else 0 def _rotate_left(self, z: AVLTreeNode) -> AVLTreeNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _rotate_right(self, z: AVLTreeNode) -> AVLTreeNode: y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _get_balance(self, node: AVLTreeNode) -> int: return self._height(node.left) - self._height(node.right) if node else 0 def _insert_node(self, node: AVLTreeNode, key: int) -> AVLTreeNode: if not node: return AVLTreeNode(key) elif key < node.key: node.left = self._insert_node(node.left, key) else: node.right = self._insert_node(node.right, key) node.height = 1 + max(self._height(node.left), self._height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and key < node.left.key: return self._rotate_right(node) # Right Right if balance < -1 and key > node.right.key: return self._rotate_left(node) # Left Right if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Left if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _inorder_helper(self, node: AVLTreeNode, result: list[int]) -> None: if node: self._inorder_helper(node.left, result) result.append(node.key) self._inorder_helper(node.right, result)"},{"question":"def roman_to_int(s: str) -> int: Convert a given Roman numeral string to an integer. Example usage: >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 >>> roman_to_int(\\"MMXXIII\\") 2023 >>> roman_to_int(\\"L\\") 50 >>> roman_to_int(\\"D\\") 500 >>> roman_to_int(\\"M\\") 1000","solution":"def roman_to_int(s: str) -> int: # Define values for Roman numerals roman_values = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } # Initialize integer result total = 0 prev_value = 0 # Process each character in the string, from left to right for char in s: # Get the value of the current Roman numeral character value = roman_values[char] # If the previous value is less than the current value, it means we should subtract twice the previous value # Because we have already added it once, we need to remove it by subtracting it twice if prev_value < value: total += value - 2 * prev_value else: total += value # Update the previous value prev_value = value return total"},{"question":"def is_mersenne_prime(num: int) -> bool: Determine if a given positive integer 'num' is a Mersenne prime. A Mersenne prime is a prime number that is one less than a power of two. >>> is_mersenne_prime(3) True >>> is_mersenne_prime(7) True >>> is_mersenne_prime(15) False >>> is_mersenne_prime(31) True >>> is_mersenne_prime(1023) False","solution":"import math def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_mersenne_prime(num: int) -> bool: if num < 2: return False p = math.log2(num + 1) if p.is_integer() and is_prime(int(p)): return is_prime(num) return False"},{"question":"from typing import List, Tuple def longest_non_decreasing_subarray(arr: List[int]) -> Tuple[int, List[int]]: Identify the longest subarray in which the elements are non-decreasing (either increasing or staying the same). >>> longest_non_decreasing_subarray([1, 3, 2, 3, 4, 1]) (3, [2, 3, 4]) >>> longest_non_decreasing_subarray([5, 5, 5, 5]) (4, [5, 5, 5, 5]) >>> longest_non_decreasing_subarray([1]) (1, [1]) >>> longest_non_decreasing_subarray([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) (3, [1, 5, 9]) def test_longest_non_decreasing_subarray(): assert longest_non_decreasing_subarray([1, 3, 2, 3, 4, 1]) == (3, [2, 3, 4]) assert longest_non_decreasing_subarray([5, 5, 5, 5]) == (4, [5, 5, 5, 5]) assert longest_non_decreasing_subarray([1]) == (1, [1]) assert longest_non_decreasing_subarray([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == (3, [1, 5, 9]) assert longest_non_decreasing_subarray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == (1, [10]) assert longest_non_decreasing_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) assert longest_non_decreasing_subarray([5, 1, 2, 3, 4, 1, 2, 3]) == (4, [1, 2, 3, 4]) assert longest_non_decreasing_subarray([]) == (0, []) assert longest_non_decreasing_subarray([2, 2, 2, 2, 2]) == (5, [2, 2, 2, 2, 2]) assert longest_non_decreasing_subarray([1, 3, 2, 2, 2, 1]) == (3, [2, 2, 2])","solution":"def longest_non_decreasing_subarray(arr): n = len(arr) if n == 0: return (0, []) max_len = 1 max_subarray = [arr[0]] current_len = 1 current_start = 0 for i in range(1, n): if arr[i] >= arr[i-1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_subarray = arr[current_start:i] current_len = 1 current_start = i # Check the last subarray if current_len > max_len: max_len = current_len max_subarray = arr[current_start:n] return (max_len, max_subarray)"},{"question":"from typing import Callable def find_root(func: Callable[[float], float], a: float, b: float, tol: float = 1e-7, max_iter: int = 1000) -> float: Input Parameters ---------------- func : a continuous function a : starting point of the interval b : end point of the interval tol : tolerance value for stopping criterion max_iter : maximum number of iterations allowed Returns ------- root : the root of the function within the interval up to a specified tolerance Example Usages -------------- >>> abs(find_root(lambda x: x**2 - 4, 0, 3) - 2.0) < 1e-7 True >>> abs(find_root(lambda x: x**3 - x - 2, 1, 2) - 1.5213797068045678) < 1e-7 True >>> abs(find_root(lambda x: x - 5, 0, 10) - 5.0) < 1e-7 True >>> find_root(lambda x: x**2 + 1, -1, 1) Traceback (most recent call last): ... ValueError: Function has the same signs at the endpoints >>> from math import cos >>> abs(find_root(lambda x: cos(x), 0, 3.14) - 1.5707963267948966) < 1e-7 True >>> root = find_root(lambda x: x**2 - 2, 1, 2, tol=1e-5) >>> abs(root - 1.41421356237) < 1e-5 True >>> root = find_root(lambda x: x**2 - 2, 1, 2, max_iter=5) >>> 1 < root < 2 True >>> abs(find_root(lambda x: x**2 - 4, -3, -1) + 2.0) < 1e-7 True","solution":"from typing import Callable def find_root(func: Callable[[float], float], a: float, b: float, tol: float = 1e-7, max_iter: int = 1000) -> float: # Check if f(a) and f(b) have opposite signs fa = func(a) fb = func(b) if (fa > 0 and fb > 0) or (fa < 0 and fb < 0): raise ValueError(\\"Function has the same signs at the endpoints\\") iter_count = 0 while abs(b - a) > tol and iter_count < max_iter: c = (a + b) / 2 fc = func(c) if fc == 0: return c if (fa > 0 and fc < 0) or (fa < 0 and fc > 0): b = c fb = fc else: a = c fa = fc iter_count += 1 return (a + b) / 2"},{"question":"class LoginMonitor: A class to track and monitor login attempts. Methods: - __init__: Initializes the LoginMonitor instance. - record_attempt(user_id, success): Records the login attempt and checks if the user has been flagged. Usage: >>> monitor = LoginMonitor() >>> monitor.record_attempt(\\"user123\\", False) # Returns False >>> monitor.record_attempt(\\"user123\\", False) # Returns False >>> monitor.record_attempt(\\"user123\\", False) # Returns True >>> monitor.record_attempt(\\"user456\\", True) # Returns False >>> monitor.record_attempt(\\"user123\\", True) # Returns False >>> monitor.record_attempt(\\"user456\\", False) # Returns False def __init__(self): pass def record_attempt(self, user_id: str, success: bool) -> bool: pass # Unit tests def test_initial_attempts(): monitor = LoginMonitor() assert monitor.record_attempt(\\"user1\\", False) == False assert monitor.record_attempt(\\"user1\\", False) == False def test_flagging_after_three_failed_attempts(): monitor = LoginMonitor() assert monitor.record_attempt(\\"user2\\", False) == False assert monitor.record_attempt(\\"user2\\", False) == False assert monitor.record_attempt(\\"user2\\", False) == True def test_reset_after_successful_attempt(): monitor = LoginMonitor() monitor.record_attempt(\\"user3\\", False) monitor.record_attempt(\\"user3\\", False) assert monitor.record_attempt(\\"user3\\", False) == True assert monitor.record_attempt(\\"user3\\", True) == False assert monitor.record_attempt(\\"user3\\", False) == False def test_continued_flagging_after_becoming_flagged(): monitor = LoginMonitor() monitor.record_attempt(\\"user4\\", False) monitor.record_attempt(\\"user4\\", False) assert monitor.record_attempt(\\"user4\\", False) == True assert monitor.record_attempt(\\"user4\\", False) == True def test_multiple_users(): monitor = LoginMonitor() monitor.record_attempt(\\"userA\\", False) monitor.record_attempt(\\"userB\\", False) monitor.record_attempt(\\"userA\\", False) monitor.record_attempt(\\"userB\\", True) assert monitor.record_attempt(\\"userA\\", False) == True # userA flagged assert monitor.record_attempt(\\"userB\\", False) == False # userB not flagged assert monitor.record_attempt(\\"userB\\", False) == False # userB still not flagged assert monitor.record_attempt(\\"userB\\", False) == True # userB flagged","solution":"class LoginMonitor: def __init__(self): self.attempts = {} def record_attempt(self, user_id: str, success: bool) -> bool: if user_id not in self.attempts: self.attempts[user_id] = [0, False] # [count_of_failed_attempts, flagged] if success: self.attempts[user_id] = [0, False] return False else: self.attempts[user_id][0] += 1 if self.attempts[user_id][0] >= 3: self.attempts[user_id][1] = True return True return False"},{"question":"class MinStack: def __init__(self): Initializes the stack and the minimum stack. # Initialize the stack def push(self, val: int) -> None: Push an integer onto the stack. Args: val: Integer value to push onto the stack. # Implementation for push operation def pop(self) -> None: Removes the element on the top of the stack. # Implementation for pop operation def top(self) -> int: Gets the top element of the stack. Returns: The top element if the stack is not empty, otherwise None. # Implementation to get the top element def get_min(self) -> int: Retrieves the minimum element in the stack. Returns: The minimum element if the stack is not empty, otherwise None. # Implementation to get the minimum element # Example Usage stack = MinStack() stack.push(5) stack.push(3) stack.push(7) print(stack.get_min()) # Expected Output: 3 stack.pop() print(stack.get_min()) # Expected Output: 3 stack.pop() print(stack.get_min()) # Expected Output: 5 print(stack.top()) # Expected Output: 5","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) # Push the new minimum to the min_stack if it's smaller than or equal to the current minimum if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: top = self.stack.pop() # If the popped element is the minimum, pop it from the min_stack as well if top == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: return self.stack[-1] if self.stack else None def get_min(self) -> int: return self.min_stack[-1] if self.min_stack else None"},{"question":"class FenwickTree: def __init__(self, size: int): Initializes a Fenwick Tree for handling 'size' elements. self.size = size self.tree = [0] * (size + 1) def build(self, a: list[int]) -> None: Builds the Fenwick Tree using the given array a. Args: a (list[int]): Original array to construct the Fenwick Tree from. Returns: None def update(self, idx: int, delta: int) -> None: Updates the element at index idx by adding delta to it. Args: idx (int): The index to be updated. delta (int): The value to add to the index. Returns: None def query(self, idx: int) -> int: Returns the sum of elements from the start of the array up to index idx. Args: idx (int): The index up to which the sum is required. Returns: int: Sum of elements from the start up to the given index. def range_query(self, left: int, right: int) -> int: Returns the sum of elements within the range [left, right]. Args: left (int): Left boundary of the range. right (int): Right boundary of the range. Returns: int: Sum of elements within the range. # Unit Tests def test_fenwick_tree_build_and_query(): A = [1, -2, 3, -4, 5, -6, 7, 8, -9, 10] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) assert fenwick_tree.query(4) == 3 # 1 - 2 + 3 - 4 + 5 = 3 assert fenwick_tree.query(9) == 13 # sum from start to 9th index def test_fenwick_tree_update(): A = [1, -2, 3, -4, 5, -6, 7, 8, -9, 10] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) fenwick_tree.update(2, 5) # A[2] becomes 8 (3+5) assert fenwick_tree.query(4) == 8 # 1 - 2 + 8 - 4 + 5 = 8 def test_fenwick_tree_range_query(): A = [1, -2, 3, -4, 5, -6, 7, 8, -9, 10] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) assert fenwick_tree.range_query(3, 7) == 10 # -4 + 5 - 6 + 7 + 8 = 10 assert fenwick_tree.range_query(0, 5) == -3 # 1 - 2 + 3 - 4 + 5 - 6 = -3 def test_fenwick_tree_edge_cases(): A = [1, 2, 3, 4, 5] fenwick_tree = FenwickTree(len(A)) fenwick_tree.build(A) assert fenwick_tree.query(0) == 1 # sum up to the first element assert fenwick_tree.query(len(A) - 1) == 15 # sum up to the last element assert fenwick_tree.range_query(0, 0) == 1 # range query of first element assert fenwick_tree.range_query(len(A) - 1, len(A) - 1) == 5 # range query of last element","solution":"class FenwickTree: def __init__(self, size: int): Initializes a Fenwick Tree for handling 'size' elements. self.size = size self.tree = [0] * (size + 1) def build(self, a: list[int]) -> None: Builds the Fenwick Tree using the given array a. for idx, value in enumerate(a): self.update(idx, value) def update(self, idx: int, delta: int) -> None: Updates the element at index idx by adding delta to it. idx += 1 while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def query(self, idx: int) -> int: Returns the sum of elements from the start of the array up to index idx. idx += 1 sum = 0 while idx > 0: sum += self.tree[idx] idx -= idx & -idx return sum def range_query(self, left: int, right: int) -> int: Returns the sum of elements within the range [left, right]. return self.query(right) - self.query(left - 1)"},{"question":"class Node: def __init__(self, timestamp: int, value: int): self.timestamp = timestamp self.value = value self.left = None self.right = None self.size = 1 # Size of the subtree including this node def insert_bst(root: Node, timestamp: int, value: int) -> Node: Insert a node with the given timestamp and value into the BST. pass def find_nth_largest(root: Node, n: int) -> int: Find the value associated with the nth largest timestamp in the BST. pass def test_insert_and_find(): root = None root = insert_bst(root, 50, 1) root = insert_bst(root, 30, 2) root = insert_bst(root, 70, 3) root = insert_bst(root, 20, 4) root = insert_bst(root, 40, 5) root = insert_bst(root, 60, 6) root = insert_bst(root, 80, 7) assert find_nth_largest(root, 1) == 7 assert find_nth_largest(root, 2) == 3 assert find_nth_largest(root, 3) == 6 assert find_nth_largest(root, 4) == 1 assert find_nth_largest(root, 5) == 5 assert find_nth_largest(root, 6) == 2 assert find_nth_largest(root, 7) == 4 if __name__ == \\"__main__\\": test_insert_and_find()","solution":"class Node: def __init__(self, timestamp: int, value: int): self.timestamp = timestamp self.value = value self.left = None self.right = None self.size = 1 # Size of the subtree including this node def insert_bst(root: Node, timestamp: int, value: int) -> Node: if root is None: return Node(timestamp, value) if timestamp < root.timestamp: root.left = insert_bst(root.left, timestamp, value) else: root.right = insert_bst(root.right, timestamp, value) root.size = 1 + (root.left.size if root.left else 0) + (root.right.size if root.right else 0) return root def find_nth_largest(root: Node, n: int) -> int: # Convert nth largest to nth smallest in zero-indexed k = root.size - n + 1 return find_kth_smallest(root, k) def find_kth_smallest(root: Node, k: int) -> int: left_size = root.left.size if root.left else 0 if k == left_size + 1: return root.value elif k <= left_size: return find_kth_smallest(root.left, k) else: return find_kth_smallest(root.right, k - left_size - 1)"},{"question":"from typing import List, Tuple import time def merge_sort(data: List[int]) -> List[int]: if len(data) <= 1: return data mid = len(data) // 2 left = merge_sort(data[:mid]) right = merge_sort(data[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def quick_sort(data: List[int]) -> List[int]: if len(data) <= 1: return data pivot = data[len(data) // 2] left = [x for x in data if x < pivot] middle = [x for x in data if x == pivot] right = [x for x in data if x > pivot] return quick_sort(left) + middle + quick_sort(right) def sort_comparison(data: List[int]) -> Tuple[float, float]: Compares the time taken by Merge Sort and Quick Sort to sort the given list. :param data: List of integers to be sorted. :return: A tuple containing the time taken by Merge Sort and Quick Sort, respectively. >>> sort_comparison([38, 27, 43, 3, 9, 82, 10]) (merge_sort_time, quick_sort_time)","solution":"from typing import List, Tuple import time def merge_sort(data: List[int]) -> List[int]: if len(data) <= 1: return data mid = len(data) // 2 left = merge_sort(data[:mid]) right = merge_sort(data[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def quick_sort(data: List[int]) -> List[int]: if len(data) <= 1: return data pivot = data[len(data) // 2] left = [x for x in data if x < pivot] middle = [x for x in data if x == pivot] right = [x for x in data if x > pivot] return quick_sort(left) + middle + quick_sort(right) def sort_comparison(data: List[int]) -> Tuple[float, float]: start_time = time.time() merge_sort(data.copy()) merge_sort_time = time.time() - start_time start_time = time.time() quick_sort(data.copy()) quick_sort_time = time.time() - start_time return merge_sort_time, quick_sort_time"},{"question":"def tallest_building_after_nights(buildings: List[int], n: int) -> int: Returns the height of the tallest building after n nights. Args: - buildings: A list of integers where each integer represents the height of a building. - n: An integer representing the number of nights. Returns: - An integer representing the height of the tallest building after n nights. Examples: >>> tallest_building_after_nights([5, 3, 9, 6, 10], 2) 12 >>> tallest_building_after_nights([4, 7, 8, 1, 2], 5) 13","solution":"def tallest_building_after_nights(buildings, n): Returns the height of the tallest building after n nights. Parameters: - buildings: list of integers representing heights of buildings. - n: integer number of nights. Returns: - integer representing the height of the tallest building after n nights. if not buildings or n == 0: return max(buildings) if buildings else 0 tallest_building_height = max(buildings) return tallest_building_height + n"},{"question":"def make_pyramid(character: str, height: int) -> str: Constructs a pyramid shape using the given character up to a specified height. Parameters: character (str): A single character string to build the pyramid. height (int): A positive integer indicating the height of the pyramid. Returns: str: A string representing the pyramid shape. Raises: ValueError: If character is not a single character string or if height is not a positive integer. Examples: >>> make_pyramid('*', 3) \\" *n ***n*****\\" >>> make_pyramid('#', 5) \\" #n #n #n #n#\\" >>> make_pyramid('@', 2) \\" @n@@@\\" >>> make_pyramid('*', 1) \\"*\\" >>> make_pyramid('#', 4) \\" #n #n #n#\\"","solution":"def make_pyramid(character: str, height: int) -> str: Constructs a pyramid shape using the given character up to a specified height. Parameters: character (str): A single character string to build the pyramid. height (int): A positive integer indicating the height of the pyramid. Returns: str: A string representing the pyramid shape. if not isinstance(character, str) or len(character) != 1: raise ValueError(\\"The character must be a single character string.\\") if not isinstance(height, int) or height <= 0: raise ValueError(\\"Height must be a positive integer.\\") pyramid_lines = [] for i in range(height): spaces = ' ' * (height - i - 1) chars = character * (2 * i + 1) pyramid_lines.append(spaces + chars) return 'n'.join(pyramid_lines)"},{"question":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of all prime factors of the given number \`n\` in ascending order. >>> prime_factors(60) == [2, 2, 3, 5] >>> prime_factors(13) == [13] >>> prime_factors(100) == [2, 2, 5, 5] >>> prime_factors(1) == [] >>> prime_factors(97) == [97] >>> prime_factors(1024) == [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of all prime factors of the given number \`n\` in ascending order. factors = [] # Start with the smallest prime number divisor = 2 while n >= divisor * divisor: while n % divisor == 0: factors.append(divisor) n //= divisor divisor += 1 if n > 1: factors.append(n) return factors"},{"question":"from typing import List, Dict def most_frequent_product_view(logs: List[dict]) -> Dict[str, str]: Analyzes user activity logs to identify the most frequently viewed product by each user. :param logs: A list of dictionaries representing user activity logs. :return: A dictionary where keys are user_ids and values are product_ids of the most frequently viewed products. :raises ValueError: If the logs are empty or not in the expected format. Example: >>> logs = [ {\\"user_id\\": \\"user1\\", \\"timestamp\\": \\"2023-09-15T12:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod123\\"}, {\\"user_id\\": \\"user1\\", \\"timestamp\\": \\"2023-09-15T13:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod123\\"}, {\\"user_id\\": \\"user1\\", \\"timestamp\\": \\"2023-09-15T14:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod124\\"}, {\\"user_id\\": \\"user2\\", \\"timestamp\\": \\"2023-09-15T15:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod123\\"}, {\\"user_id\\": \\"user2\\", \\"timestamp\\": \\"2023-09-15T16:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod124\\"}, {\\"user_id\\": \\"user2\\", \\"timestamp\\": \\"2023-09-15T17:34:56Z\\", \\"action\\": \\"view\\", \\"product_id\\": \\"prod124\\"} ] >>> most_frequent_product_view(logs) {'user1': 'prod123', 'user2': 'prod124'} pass","solution":"from collections import defaultdict from typing import List, Dict def most_frequent_product_view(logs: List[dict]) -> Dict[str, str]: if not logs: raise ValueError(\\"Logs are empty\\") user_product_views = defaultdict(lambda: defaultdict(int)) for log in logs: if not all(key in log for key in [\\"user_id\\", \\"timestamp\\", \\"action\\", \\"product_id\\"]): raise ValueError(\\"Log entries do not conform to the expected format\\") if log['action'] != 'view': continue user = log['user_id'] product = log['product_id'] user_product_views[user][product] += 1 most_frequent_views = {} for user, product_counts in user_product_views.items(): most_frequent_product = max(product_counts, key=product_counts.get) most_frequent_views[user] = most_frequent_product return most_frequent_views"},{"question":"from typing import List def reformat_string(s: str) -> List[str]: Reformats the input string by removing special characters, converting to lowercase, and splitting into chunks of 3, filling up the last chunk with 'z' if necessary. >>> reformat_string(\\"aBc!@123DEF...ghij?\\") ['abc', '123', 'def', 'ghi', 'jzz'] >>> reformat_string(\\"XYZ\\") ['xyz'] >>> reformat_string(\\"\\") [] >>> reformat_string(\\"123456789\\") ['123', '456', '789'] >>> reformat_string(\\"A!@B\\") ['abz'] ...","solution":"from typing import List import re def reformat_string(s: str) -> List[str]: Reformats the input string by removing special characters, converting to lowercase, and splitting into chunks of 3, filling up the last chunk with 'z' if necessary. # Remove special characters and convert to lowercase cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Split the cleaned string into chunks of 3 characters n = len(cleaned_s) chunks = [cleaned_s[i:i+3] for i in range(0, n, 3)] # If the last chunk is shorter than 3 characters, fill up with 'z' if chunks and len(chunks[-1]) < 3: chunks[-1] = chunks[-1].ljust(3, 'z') return chunks"},{"question":"from typing import List def calculate_moving_average(prices: List[float], n: int) -> List[float]: Calculate the n-day simple moving average for a list of stock prices. >>> calculate_moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [None, None, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] >>> calculate_moving_average([1, 2, 3], 5) [None, None, None] >>> calculate_moving_average([1, 2, 3, 4, 5], 1) [1.0, 2.0, 3.0, 4.0, 5.0] >>> calculate_moving_average([10], 1) [10.0] >>> calculate_moving_average([5, 5, 5, 5, 5], 2) [None, 5.0, 5.0, 5.0, 5.0] >>> calculate_moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) [None, None, None, None, None, None, None, None, None, 5.5]","solution":"from typing import List def calculate_moving_average(prices: List[float], n: int) -> List[float]: if len(prices) < n: return [None] * len(prices) moving_averages = [None] * (n - 1) sum_window = sum(prices[:n-1]) for i in range(n-1, len(prices)): sum_window += prices[i] moving_averages.append(sum_window / n) sum_window -= prices[i - n + 1] return moving_averages"},{"question":"class Trie: def __init__(self): Initializes the trie. ... def insert(self, word: str): Inserts a word into the trie. >>> trie = Trie() >>> trie.insert(\\"apple\\") ... def startsWith(self, prefix: str) -> bool: Returns True if there are any words in the trie that start with the given prefix, False otherwise. >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.startsWith(\\"app\\") True >>> trie.startsWith(\\"apl\\") False ... # Test Cases def test_trie_insert_and_start_with_prefix(): trie = Trie() trie.insert(\\"apple\\") assert trie.startsWith(\\"app\\") == True assert trie.startsWith(\\"apple\\") == True assert trie.startsWith(\\"appl\\") == True assert trie.startsWith(\\"apc\\") == False def test_trie_multiple_words(): trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") assert trie.startsWith(\\"ap\\") == True assert trie.startsWith(\\"app\\") == True assert trie.startsWith(\\"appl\\") == True assert trie.startsWith(\\"appe\\") == False def test_trie_no_common_prefix(): trie = Trie() trie.insert(\\"banana\\") trie.insert(\\"band\\") assert trie.startsWith(\\"ba\\") == True assert trie.startsWith(\\"ban\\") == True assert trie.startsWith(\\"bana\\") == True assert trie.startsWith(\\"bank\\") == False def test_trie_empty_prefix(): trie = Trie() trie.insert(\\"cat\\") assert trie.startsWith(\\"\\") == True # Since any string starts with an empty prefix def test_trie_repeat_insertion(): trie = Trie() trie.insert(\\"dog\\") trie.insert(\\"dog\\") assert trie.startsWith(\\"do\\") == True assert trie.startsWith(\\"dog\\") == True assert trie.startsWith(\\"dogs\\") == False","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_sorted_lists(head1: ListNode, head2: ListNode) -> ListNode: Merge two sorted singly linked lists and return the head of the new sorted list. >>> list_to_linked_list([1, 3, 5]) >>> list_to_linked_list([2, 4, 6]) >>> merged_head = merge_sorted_lists(head1, head2) >>> linked_list_to_list(merged_head) [1, 2, 3, 4, 5, 6]","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def merge_sorted_lists(head1: ListNode, head2: ListNode) -> ListNode: dummy = ListNode(0) current = dummy while head1 and head2: if head1.val < head2.val: current.next = head1 head1 = head1.next else: current.next = head2 head2 = head2.next current = current.next if head1: current.next = head1 if head2: current.next = head2 return dummy.next"},{"question":"import heapq import time class EventScheduler: def __init__(self): self.events = [] def add_event(self, event_name: str, priority: int, timestamp: int) -> None: Add an event to the scheduler with a given name, priority, and timestamp. Args: event_name (str): The name of the event. priority (int): The priority of the event (higher number means higher priority). timestamp (int): The time of occurrence of the event in UNIX format. pass def get_next_event(self) -> str: Retrieve the next event with the highest priority and earliest timestamp. Returns: str: The name of the next event, or \\"No events scheduled\\" if no events are scheduled. pass from EventScheduler import EventScheduler def test_add_event_and_get_next_event(): scheduler = EventScheduler() scheduler.add_event(\\"Meeting\\", 3, int(time.time()) + 1000) scheduler.add_event(\\"Lunch\\", 2, int(time.time()) + 2000) scheduler.add_event(\\"Code Review\\", 5, int(time.time()) + 3000) assert scheduler.get_next_event() == \\"Code Review\\" assert scheduler.get_next_event() == \\"Meeting\\" assert scheduler.get_next_event() == \\"Lunch\\" assert scheduler.get_next_event() == \\"No events scheduled\\" def test_no_events_scheduled(): scheduler = EventScheduler() assert scheduler.get_next_event() == \\"No events scheduled\\" def test_duplicate_priority_and_timestamp(): scheduler = EventScheduler() current_time = int(time.time()) scheduler.add_event(\\"Meeting\\", 3, current_time + 1000) scheduler.add_event(\\"Lunch\\", 3, current_time + 1000) first_event = scheduler.get_next_event() second_event = scheduler.get_next_event() assert (first_event == \\"Meeting\\" and second_event == \\"Lunch\\") or (first_event == \\"Lunch\\" and second_event == \\"Meeting\\") assert scheduler.get_next_event() == \\"No events scheduled\\" def test_past_event_removal(): scheduler = EventScheduler() scheduler.add_event(\\"Breakfast\\", 1, int(time.time()) - 1000) scheduler.add_event(\\"Lunch\\", 2, int(time.time()) + 2000) assert scheduler.get_next_event() == \\"Lunch\\" assert scheduler.get_next_event() == \\"No events scheduled\\"","solution":"import heapq import time class EventScheduler: def __init__(self): self.events = [] def add_event(self, event_name, priority, timestamp): # Using negative priority because heapq is a min-heap, but we need max-heap functionality heapq.heappush(self.events, (-priority, timestamp, event_name)) def get_next_event(self): current_time = int(time.time()) while self.events: priority, timestamp, event_name = heapq.heappop(self.events) if timestamp >= current_time: return event_name return \\"No events scheduled\\""},{"question":"def is_valid_bst_sequence(sequence: list[int]) -> bool: Determines if it is possible to build a valid BST from the given sequence of values. >>> is_valid_bst_sequence([10, 5, 1, 7, 40, 50]) == True >>> is_valid_bst_sequence([10, 5, 1, 7, 3, 40]) == False >>> is_valid_bst_sequence([]) == True >>> is_valid_bst_sequence([5]) == True >>> is_valid_bst_sequence([1, 2, 3, 4, 5, 6]) == True >>> is_valid_bst_sequence([5, 4, 3, 2, 1]) == True >>> is_valid_bst_sequence(list(range(1, 10001))) == True >>> is_valid_bst_sequence(list(range(1, 10001)) + [-1]) == False","solution":"def is_valid_bst_sequence(sequence: list[int]) -> bool: Determines if it is possible to build a valid BST from the given sequence of values. if not sequence: return True def verify_preorder(sequence): stack = [] root = float('-inf') for value in sequence: if value < root: return False while stack and stack[-1] < value: root = stack.pop() stack.append(value) return True return verify_preorder(sequence)"},{"question":"from typing import Optional, Any from threading import Thread import time class Cache: A cache system that stores key-value pairs with a specified time-to-live (TTL). Methods: - put(key: str, value: Any, ttl: int) -> None: Insert a key-value pair into the cache with a TTL in seconds. - get(key: str) -> Optional[Any]: Retrieve a value by its key. If the key does not exist or has expired, return \`None\`. - remove(key: str) -> None: Remove a key-value pair from the cache by its key. Ensure that keys are automatically expired and removed from the cache after their TTL has elapsed. Example Usage: >>> import time >>> cache = Cache() >>> cache.put(\\"key1\\", \\"value1\\", 2) >>> assert cache.get(\\"key1\\") == \\"value1\\" >>> time.sleep(3) >>> assert cache.get(\\"key1\\") is None >>> cache.put(\\"key2\\", \\"value2\\", 5) >>> assert cache.get(\\"key2\\") == \\"value2\\" >>> cache.remove(\\"key2\\") >>> assert cache.get(\\"key2\\") is None def __init__(self) -> None: self.store = {} self.ttl = {} def put(self, key: str, value: Any, ttl: int) -> None: pass def get(self, key: str) -> Optional[Any]: pass def remove(self, key: str) -> None: pass # Unit tests def test_cache_put_and_get(): cache = Cache() cache.put(\\"key1\\", \\"value1\\", 2) assert cache.get(\\"key1\\") == \\"value1\\" time.sleep(3) assert cache.get(\\"key1\\") is None def test_cache_put_with_zero_ttl(): cache = Cache() cache.put(\\"key_zero_ttl\\", \\"value\\", 0) assert cache.get(\\"key_zero_ttl\\") is None def test_cache_removal(): cache = Cache() cache.put(\\"key2\\", \\"value2\\", 5) assert cache.get(\\"key2\\") == \\"value2\\" cache.remove(\\"key2\\") assert cache.get(\\"key2\\") is None def test_cache_ttl_expiry(): cache = Cache() cache.put(\\"key3\\", \\"value3\\", 1) assert cache.get(\\"key3\\") == \\"value3\\" time.sleep(2) assert cache.get(\\"key3\\") is None def test_cache_multiple_keys(): cache = Cache() cache.put(\\"key4\\", \\"value4\\", 5) cache.put(\\"key5\\", \\"value5\\", 2) time.sleep(3) assert cache.get(\\"key4\\") == \\"value4\\" assert cache.get(\\"key5\\") is None cache.remove(\\"key4\\") assert cache.get(\\"key4\\") is None","solution":"from typing import Optional, Any import time import threading class Cache: def __init__(self) -> None: self.store = {} self.lock = threading.Lock() def put(self, key: str, value: Any, ttl: int) -> None: expire_time = time.time() + ttl with self.lock: self.store[key] = (value, expire_time) def get(self, key: str) -> Optional[Any]: with self.lock: if key in self.store: value, expire_time = self.store[key] if time.time() < expire_time: return value else: del self.store[key] return None def remove(self, key: str) -> None: with self.lock: if key in self.store: del self.store[key]"},{"question":"class ComplexNumber: def __init__(self, real, imag): self.real = real self.imag = imag def add(self, other): return ComplexNumber(self.real + other.real, self.imag + other.imag) def multiply(self, other): real_part = self.real * other.real - self.imag * other.imag imag_part = self.real * other.imag + self.imag * other.real return ComplexNumber(real_part, imag_part) def conjugate(self): Compute the conjugate of a given complex number. The conjugate of a complex number a + bi is a - bi. def __str__(self): return f\\"{self.real} + {self.imag}i\\" # Example usage c1 = ComplexNumber(3, 4) c2 = ComplexNumber(1, -2) conjugate_of_c1 = c1.conjugate() sum_result = c1.add(conjugate_of_c1) product_result = c1.multiply(c2) print(\\"Conjugate of c1:\\", conjugate_of_c1) print(\\"Sum of c1 and its conjugate:\\", sum_result) print(\\"Product of c1 and c2:\\", product_result)","solution":"class ComplexNumber: def __init__(self, real, imag): self.real = real self.imag = imag def add(self, other): return ComplexNumber(self.real + other.real, self.imag + other.imag) def multiply(self, other): real_part = self.real * other.real - self.imag * other.imag imag_part = self.real * other.imag + self.imag * other.real return ComplexNumber(real_part, imag_part) def conjugate(self): return ComplexNumber(self.real, -self.imag) def __str__(self): return f\\"{self.real} + {self.imag}i\\" # Example usage c1 = ComplexNumber(3, 4) c2 = ComplexNumber(1, -2) conjugate_of_c1 = c1.conjugate() sum_result = c1.add(conjugate_of_c1) product_result = c1.multiply(c2) print(\\"Conjugate of c1:\\", conjugate_of_c1) print(\\"Sum of c1 and its conjugate:\\", sum_result) print(\\"Product of c1 and c2:\\", product_result)"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Determine if one string is a permutation of another string. >>> is_permutation('abc', 'bca') True >>> is_permutation('abc', 'abcd') False >>> is_permutation('listen', 'silent') True >>> is_permutation('anagram', 'nagaram') True >>> is_permutation('', '') True >>> is_permutation('a', '') False","solution":"def is_permutation(str1: str, str2: str) -> bool: Determine if one string is a permutation of another string. from collections import Counter # If lengths of the strings are not equal, they cannot be permutations if len(str1) != len(str2): return False # Count the frequency of each character in both strings return Counter(str1) == Counter(str2)"},{"question":"class PrimeFactorizer: Compute the prime factorization of a given positive integer using an optimized algorithm. Initialize with the number to be factorized. Example: >>> factorizer = PrimeFactorizer(100) >>> factorizer.get_factors() {2: 2, 5: 2} >>> factorizer2 = PrimeFactorizer(97) >>> factorizer2.get_factors() {97: 1} >>> factorizer3 = PrimeFactorizer(84) >>> factorizer3.get_factors() {2: 2, 3: 1, 7: 1} def __init__(self, number: int): Initialize with the number to be factorized. :param number: Integer to be factorized self.number = number def get_factors(self) -> dict: Compute and return the prime factorization of the number. :return: Dictionary with prime factors as keys and their exponents as values.","solution":"class PrimeFactorizer: def __init__(self, number): Initialize with the number to be factorized. :param number: Integer to be factorized self.number = number def get_factors(self): Compute and return the prime factorization of the number. :return: Dictionary with prime factors as keys and their exponents as values. factors = {} n = self.number # Step 1: Handle factor of 2 separately while n % 2 == 0: factors[2] = factors.get(2, 0) + 1 n //= 2 # Step 2: Handle odd factors from 3 onward for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors[i] = factors.get(i, 0) + 1 n //= i # Step 3: If remaining n is a prime number greater than 2 if n > 2: factors[n] = 1 return factors"},{"question":"import re from collections import Counter from typing import List, Tuple def word_frequencies(text: str) -> List[Tuple[str, int]]: Returns a list of tuples containing words and their frequencies, sorted by frequency in descending order, then alphabetically by word in ascending order. >>> word_frequencies(\\"The quick brown fox jumps over the lazy dog.\\") [('the', 2), ('brown', 1), ('dog', 1), ('fox', 1), ('jumps', 1), ('lazy', 1), ('over', 1), ('quick', 1)] >>> word_frequencies(\\"A quick brown Fox quickly jumps over the lazy dog!\\") [('a', 1), ('brown', 1), ('dog', 1), ('fox', 1), ('jumps', 1), ('lazy', 1), ('over', 1), ('quick', 1), ('quickly', 1), ('the', 1)] >>> word_frequencies(\\"Hello, hello? HELLO!\\") [('hello', 3)] >>> word_frequencies(\\"123 123 123\\") []","solution":"import re from collections import Counter def word_frequencies(text): Returns a list of tuples containing words and their frequencies, sorted by frequency in descending order, then alphabetically by word in ascending order. # Convert to lower case text = text.lower() # Use regex to extract words (alphabetic) words = re.findall(r'b[a-z]+b', text) # Count frequencies using Counter freq_count = Counter(words) # Sort by frequency descending and then alphabetically ascending sorted_words = sorted(freq_count.items(), key=lambda x: (-x[1], x[0])) return sorted_words"},{"question":"from typing import List, Tuple, Optional def bfs_solve_maze(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: Solves the maze using BFS and returns the path from start to end. :param maze: A 2D list representing the maze where '0' is a path and '1' is a wall. :param start: The starting point in the maze as a tuple (row, col). :param end: The end point in the maze as a tuple (row, col). :return: A list of tuples representing the path from start to end. pass def dfs_solve_maze(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int], path: Optional[List[Tuple[int, int]]] = None) -> List[Tuple[int, int]]: Solves the maze using DFS and returns the path from start to end. :param maze: A 2D list representing the maze where '0' is a path and '1' is a wall. :param start: The starting point in the maze as a tuple (row, col). :param end: The end point in the maze as a tuple (row, col). :param path: The current path being followed (used for recursive calls). :return: A list of tuples representing the path from start to end. pass","solution":"from typing import List, Tuple, Optional from collections import deque def bfs_solve_maze(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1: return [] # If start or end is a wall, no path is possible. rows, cols = len(maze), len(maze[0]) queue = deque([([start], start)]) visited = set() visited.add(start) while queue: path, (row, col) = queue.popleft() if (row, col) == end: return path for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: r, c = row + dr, col + dc if 0 <= r < rows and 0 <= c < cols and maze[r][c] == 0 and (r, c) not in visited: queue.append((path + [(r, c)], (r, c))) visited.add((r, c)) return [] def dfs_solve_maze(maze: List[List[int]], start: Tuple[int, int], end: Tuple[int, int], path: Optional[List[Tuple[int, int]]] = None) -> List[Tuple[int, int]]: if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1: return [] # If start or end is a wall, no path is possible. if path is None: path = [] path.append(start) if start == end: return path row, col = start rows, cols = len(maze), len(maze[0]) for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: r, c = row + dr, col + dc if 0 <= r < rows and 0 <= c < cols and maze[r][c] == 0 and (r, c) not in path: result = dfs_solve_maze(maze, (r, c), end, path.copy()) if result: return result return []"},{"question":"import numpy as np import pandas as pd from sklearn.preprocessing import StandardScaler, LabelEncoder from sklearn.cluster import KMeans import matplotlib.pyplot as plt def segment_customers(file_path: str, max_clusters: int) -> (np.ndarray, np.ndarray): Segments customers using K-Means Clustering. Args: - file_path (str): Path to the CSV file containing customer data. - max_clusters (int): Maximum number of clusters to consider for the Elbow method. Returns: - np.ndarray: Cluster centers. - np.ndarray: Cluster labels for each customer. # Load the data data = pd.read_csv(file_path) # Prepare the feature set X = data.iloc[:, 1:] # Encode categorical variables label_encoder = LabelEncoder() X['Gender'] = label_encoder.fit_transform(X['Gender']) # Normalize numerical features scaler = StandardScaler() X_scaled = scaler.fit_transform(X) # Determine the optimal number of clusters using the Elbow method wcss = [] for i in range(1, max_clusters + 1): kmeans = KMeans(n_clusters=i, random_state=0) kmeans.fit(X_scaled) wcss.append(kmeans.inertia_) # Plotting the elbow graph to visually find the optimal clusters plt.plot(range(1, max_clusters + 1), wcss) plt.title('Elbow Method For Optimal K') plt.xlabel('Number of clusters') plt.ylabel('WCSS') plt.show() # Assuming the optimal clusters found from the Elbow method is (example: 5) k_optimal = 5 # This should be set by visualizing the elbow plot # Apply KMeans with the optimal number of clusters kmeans = KMeans(n_clusters=k_optimal, random_state=0) kmeans.fit(X_scaled) # Get the cluster centers and labels cluster_centers = kmeans.cluster_centers_ cluster_labels = kmeans.labels_ return cluster_centers, cluster_labels","solution":"import numpy as np import pandas as pd from sklearn.preprocessing import StandardScaler, LabelEncoder from sklearn.cluster import KMeans import matplotlib.pyplot as plt def segment_customers(file_path: str, max_clusters: int) -> (np.ndarray, np.ndarray): # Load the data data = pd.read_csv(file_path) # Prepare the feature set X = data.iloc[:, 1:] # Encode categorical variables label_encoder = LabelEncoder() X['Gender'] = label_encoder.fit_transform(X['Gender']) # Normalize numerical features scaler = StandardScaler() X_scaled = scaler.fit_transform(X) # Determine the optimal number of clusters using the Elbow method wcss = [] for i in range(1, max_clusters + 1): kmeans = KMeans(n_clusters=i, random_state=0) kmeans.fit(X_scaled) wcss.append(kmeans.inertia_) # Plotting the elbow graph to visually find the optimal clusters # Generally, you would look at the plot to decide on the optimal number of clusters # This plot part would not be normally in the function, but included here for demonstration purposes plt.plot(range(1, max_clusters + 1), wcss) plt.title('Elbow Method For Optimal K') plt.xlabel('Number of clusters') plt.ylabel('WCSS') plt.show() # Assuming the optimal clusters found from the Elbow method is (example: 5) # In practice, you would need to manually check the plot to decide this value k_optimal = 5 # This should be set by visualizing the elbow plot # Apply KMeans with the optimal number of clusters kmeans = KMeans(n_clusters=k_optimal, random_state=0) kmeans.fit(X_scaled) # Get the cluster centers and labels cluster_centers = kmeans.cluster_centers_ cluster_labels = kmeans.labels_ return cluster_centers, cluster_labels"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: Balance a binary search tree (BST). The function takes a binary search tree (BST) as input and returns a balanced binary search tree. Args: root (TreeNode): The root of the binary search tree. Returns: TreeNode: The root of the balanced binary search tree. from solution import TreeNode, balance_bst def tree_to_list(root): Helper function to convert tree to a list using in-order traversal def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) return inorder_traversal(root) def test_single_node_tree(): root = TreeNode(1) balanced_root = balance_bst(root) assert tree_to_list(balanced_root) == [1] def test_already_balanced_tree(): root = TreeNode(2, TreeNode(1), TreeNode(3)) balanced_root = balance_bst(root) assert tree_to_list(balanced_root) == [1, 2, 3] def test_right_skewed_tree(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4, None, TreeNode(5))))) balanced_root = balance_bst(root) assert tree_to_list(balanced_root) == [1, 2, 3, 4, 5] def test_left_skewed_tree(): root = TreeNode(5, TreeNode(4, TreeNode(3, TreeNode(2, TreeNode(1))))) balanced_root = balance_bst(root) assert tree_to_list(balanced_root) == [1, 2, 3, 4, 5] def test_complex_tree(): root = TreeNode(10, TreeNode(6, TreeNode(4), TreeNode(8)), TreeNode(15, None, TreeNode(20))) balanced_root = balance_bst(root) assert set(tree_to_list(balanced_root)) == {4, 6, 8, 10, 15, 20}","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: # Helper function to perform in-order traversal and collect nodes def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Helper function to build a balanced BST from sorted values def sorted_list_to_bst(nums): if not nums: return None mid = len(nums) // 2 node = TreeNode(nums[mid]) node.left = sorted_list_to_bst(nums[:mid]) node.right = sorted_list_to_bst(nums[mid+1:]) return node sorted_values = inorder_traversal(root) return sorted_list_to_bst(sorted_values)"},{"question":"def merge_sorted_arrays(list1: list[int], list2: list[int]) -> list[int]: Merge two sorted lists into one sorted list. >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], [4, 5, 6]) [4, 5, 6] >>> merge_sorted_arrays([1, 2, 2], [2, 2, 3]) [1, 2, 2, 2, 2, 3]","solution":"def merge_sorted_arrays(list1: list[int], list2: list[int]) -> list[int]: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are any remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are any remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def total_distance(distances): Calculates the total distance covered by summing the list of distances. Parameters: distances (list of float): List of distances covered. Returns: float: Total distance covered. Returns 0.0 if the list is empty. >>> total_distance([10.5, 14.2, 7.8, 5.6]) 38.1 >>> total_distance([]) 0.0 pass def average_speed(total_distance, total_time): Calculates the average speed given the total distance and the total time. Parameters: total_distance (float): The total distance covered. total_time (float): The total time taken in hours. Returns: float: The average speed. Returns -1 if total_time is zero or negative. >>> average_speed(150, 3) 50.0 >>> average_speed(150, 0) -1 pass def eta(total_distance, average_speed): Calculates the estimated time of arrival given the remaining distance and the average speed. Parameters: total_distance (float): The remaining distance to the destination. average_speed (float): The average speed of the vehicle. Returns: float: Estimated time of arrival in hours. Returns -1 if average_speed is zero or negative. >>> eta(200, 50) 4.0 >>> eta(200, 0) -1 pass","solution":"def total_distance(distances): Calculates the total distance covered by summing the list of distances. Parameters: distances (list of float): List of distances covered. Returns: float: Total distance covered. Returns 0.0 if the list is empty. if not distances: return 0.0 return sum(distances) def average_speed(total_distance, total_time): Calculates the average speed given the total distance and the total time. Parameters: total_distance (float): The total distance covered. total_time (float): The total time taken in hours. Returns: float: The average speed. Returns -1 if total_time is zero or negative. if total_time <= 0: return -1 return total_distance / total_time def eta(total_distance, average_speed): Calculates the estimated time of arrival given the remaining distance and the average speed. Parameters: total_distance (float): The remaining distance to the destination. average_speed (float): The average speed of the vehicle. Returns: float: Estimated time of arrival in hours. Returns -1 if average_speed is zero or negative. if average_speed <= 0: return -1 return total_distance / average_speed"},{"question":"def is_in_order(timestamps: list[int]) -> bool: Determines if the given list of timestamps is in non-decreasing order. :param timestamps: List of integers representing timestamps :return: Boolean value indicating whether timestamps are in non-decreasing order >>> is_in_order([1, 2, 3, 4, 5]) True >>> is_in_order([1, 3, 2, 4, 5]) False >>> is_in_order([1]) True >>> is_in_order([]) True >>> is_in_order([3, 3, 3, 3]) True","solution":"def is_in_order(timestamps: list[int]) -> bool: Determines if the given list of timestamps is in non-decreasing order. :param timestamps: List of integers representing timestamps :return: Boolean value indicating whether timestamps are in non-decreasing order for i in range(1, len(timestamps)): if timestamps[i] < timestamps[i - 1]: return False return True"},{"question":"# Completion Task Write a function that takes a list of integers and a target integer, and returns the indices of the two numbers in the list that add up to the target. If there are no such indices, the function should return \`[-1, -1]\`. Each input would have exactly one solution, and you may not use the same element twice. Function Signature \`def two_sum(nums: list, target: int) -> list:\` Input * \`nums\`: A list of integers. (e.g., \`[2, 7, 11, 15]\`) * \`target\`: An integer representing the sum target. Output * Returns a list of two indices of the \`nums\` list whose values add up to \`target\`. If no such indices exist, return \`[-1, -1]\`. Constraints * The length of \`nums\` will be at least 2 and at most 1000. * Each function has exactly one valid solution. * You may not use the same element twice. * The solution must have a time complexity of O(n). Examples >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 10) [-1, -1] >>> two_sum([5, 75, 25], 100) [1, 2] Notes Ensure your implementation handles edge cases, such as input lists where no two indices add up to the target. The function should operate efficiently, considering the constraints provided. def two_sum(nums: list, target: int) -> list: # Your code here def test_two_sum(): assert two_sum([2, 7, 11, 15], 9) == [0, 1] assert two_sum([3, 2, 4], 6) == [1, 2] assert two_sum([3, 3], 6) == [0, 1] assert two_sum([1, 2, 3, 4, 5], 10) == [-1, -1] assert two_sum([5, 75, 25], 100) == [1, 2] # Additional tests for edge cases assert two_sum([1, 1, 1, 1], 2) == [0, 1] assert two_sum([0, 4, 3, 0], 0) == [0, 3] assert two_sum([10, 20, 10, 20], 30) == [0, 1] def two_sum(nums: list, target: int) -> list: Returns indices of two numbers in the \`nums\` list that add up to \`target\`. If no such indices exist, return [-1, -1]. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]","solution":"def two_sum(nums: list, target: int) -> list: Returns indices of two numbers in the \`nums\` list that add up to \`target\`. If no such indices exist, return [-1, -1]. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [-1, -1]"},{"question":"def simulate_file_system(commands: List[str]) -> List[str]: pass","solution":"from typing import List class FileSystem: def __init__(self): self.root = {} self.current_dir = self.root self.path = [] def mkdir(self, directory: str): if directory not in self.current_dir: self.current_dir[directory] = {} def cd(self, directory: str): if directory == \\"..\\": if self.path: self.current_dir = self.root for dir in self.path[:-1]: self.current_dir = self.current_dir[dir] self.path.pop() else: if directory in self.current_dir: self.current_dir = self.current_dir[directory] self.path.append(directory) def touch(self, file: str): self.current_dir[file] = \\"\\" def write(self, file: str, content: str): if file in self.current_dir: self.current_dir[file] = content def read(self, file: str) -> str: return self.current_dir.get(file, \\"\\") def simulate_file_system(commands: List[str]) -> List[str]: fs = FileSystem() result = [] for command in commands: parts = command.split() cmd = parts[0] if cmd == \\"mkdir\\": fs.mkdir(parts[1]) elif cmd == \\"cd\\": fs.cd(parts[1]) elif cmd == \\"touch\\": fs.touch(parts[1]) elif cmd == \\"write\\": fs.write(parts[1], \\" \\".join(parts[2:])) elif cmd == \\"read\\": result.append(fs.read(parts[1])) return result"},{"question":"from math import factorial from typing import List def find_nth_permutation(numbers: List[int], n: int) -> List[int]: Find the n-th lexicographical permutation of the list of integers. :param numbers: List of unique integers. :param n: The position (1-based) of the desired permutation in lexicographical order. :return: The n-th permutation as a list of integers. Example: >>> find_nth_permutation([1, 2, 3], 4) [2, 3, 1] >>> find_nth_permutation([1, 2, 3, 4], 1) [1, 2, 3, 4] >>> find_nth_permutation([1, 2, 3], 6) [3, 2, 1] >>> find_nth_permutation([4, 3, 2, 1], 24) [4, 3, 2, 1] >>> find_nth_permutation([5, 2, 9], 2) [2, 9, 5] >>> find_nth_permutation([1], 1) [1] >>> find_nth_permutation([1, 2], 1) [1, 2] >>> find_nth_permutation([1, 2], 2) [2, 1] >>> find_nth_permutation([0], 1) [0] >>> find_nth_permutation([1, 2, 3, 4, 5, 6, 7], 5040) [7, 6, 5, 4, 3, 2, 1]","solution":"from math import factorial def find_nth_permutation(numbers, n): Find the n-th lexicographical permutation of the list of integers. :param numbers: List of unique integers. :param n: The position (1-based) of the desired permutation in lexicographical order. :return: The n-th permutation as a list of integers. result = [] k = n - 1 # Convert to 0-based index nums = sorted(numbers) while nums: f = factorial(len(nums) - 1) index = k // f result.append(nums.pop(index)) k %= f return result"},{"question":"class BankAccount: def __init__(self, account_holder: str): Initializes the account with the given account holder's name and a zero balance. pass def deposit(self, amount: int): Deposits the specified amount into the account and records the transaction. Ensure the amount is positive. >>> account = BankAccount(\\"Alice\\") >>> account.deposit(100) >>> account.get_balance() 100 >>> account.get_transaction_history() [{'type': 'deposit', 'amount': 100, 'balance': 100}] pass def withdraw(self, amount: int): Withdraws the specified amount from the account if sufficient funds are available and records the transaction. Ensure the amount is positive. >>> account = BankAccount(\\"Alice\\") >>> account.deposit(100) >>> account.withdraw(30) >>> account.get_balance() 70 >>> account.get_transaction_history() [{'type': 'deposit', 'amount': 100, 'balance': 100}, {'type': 'withdraw', 'amount': 30, 'balance': 70}] pass def get_balance(self) -> int: Returns the current account balance. >>> account = BankAccount(\\"Alice\\") >>> account.deposit(100) >>> account.get_balance() 100 pass def get_transaction_history(self) -> list: Returns a list of transaction records. >>> account = BankAccount(\\"Alice\\") >>> account.deposit(100) >>> account.withdraw(30) >>> account.get_transaction_history() [{'type': 'deposit', 'amount': 100, 'balance': 100}, {'type': 'withdraw', 'amount': 30, 'balance': 70}] pass","solution":"class BankAccount: def __init__(self, account_holder): Initializes the account with the given account holder's name and a zero balance. self.account_holder = account_holder self.balance = 0 self.transaction_history = [] def deposit(self, amount): Deposits the specified amount into the account and records the transaction. if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self.balance += amount self.transaction_history.append({ \\"type\\": \\"deposit\\", \\"amount\\": amount, \\"balance\\": self.balance }) def withdraw(self, amount): Withdraws the specified amount from the account if sufficient funds are available and records the transaction. if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self.balance: raise ValueError(\\"Insufficient funds.\\") self.balance -= amount self.transaction_history.append({ \\"type\\": \\"withdraw\\", \\"amount\\": amount, \\"balance\\": self.balance }) def get_balance(self): Returns the current account balance. return self.balance def get_transaction_history(self): Returns a list of transaction records. return self.transaction_history"},{"question":"class TextEditor: A simplified text editor that supports text appending, undo, and fetching current text state. >>> te = TextEditor(\\"Hello\\") >>> te.append(\\" World\\") >>> te.get_text() == \\"Hello World\\" def __init__(self, initial_text=\\"\\"): Initializes the text editor with an optional initial text. pass def append(self, text): Appends the given text to the current text. pass def undo(self): Reverts the last change made to the text. pass def get_text(self): Returns the current state of the text as a string. pass # Unit Tests def test_initial_text(): te = TextEditor() assert te.get_text() == \\"\\" te = TextEditor(\\"Hello\\") assert te.get_text() == \\"Hello\\" def test_append_text(): te = TextEditor(\\"Hello\\") te.append(\\" World\\") assert te.get_text() == \\"Hello World\\" te.append(\\"!\\") assert te.get_text() == \\"Hello World!\\" def test_single_undo(): te = TextEditor(\\"Hello\\") te.append(\\" World\\") te.undo() assert te.get_text() == \\"Hello\\" def test_multiple_undo(): te = TextEditor(\\"Hello\\") te.append(\\" World\\") te.append(\\"!\\") te.undo() assert te.get_text() == \\"Hello World\\" te.undo() assert te.get_text() == \\"Hello\\" def test_undo_beyond_initial(): te = TextEditor(\\"Hello\\") te.append(\\" World\\") te.undo() te.undo() assert te.get_text() == \\"Hello\\" te.undo() assert te.get_text() == \\"Hello\\" def test_complex_operations(): te = TextEditor(\\"Hello\\") te.append(\\",\\") te.append(\\" how are you?\\") assert te.get_text() == \\"Hello, how are you?\\" te.undo() assert te.get_text() == \\"Hello,\\" te.append(\\" friend\\") assert te.get_text() == \\"Hello, friend\\" te.undo() te.undo() assert te.get_text() == \\"Hello\\"","solution":"class TextEditor: def __init__(self, initial_text=\\"\\"): self.text = initial_text self.history = [initial_text] def append(self, text): self.text += text self.history.append(self.text) def undo(self): if len(self.history) > 1: self.history.pop() self.text = self.history[-1] elif len(self.history) == 1: self.text = self.history[0] def get_text(self): return self.text"},{"question":"import random from typing import List, Callable, Any, Tuple class MultiObjectiveProblem: def __init__(self, objectives: List[Callable], population: List[Any], mutation_rate: float, crossover_rate: float): Initialize the multi-objective problem with the given objectives, initial population, mutation rate, and crossover rate. pass def mutate(self, solution: Any) -> Any: Mutate the solution based on mutation rate. pass def crossover(self, solution1: Any, solution2: Any) -> Tuple[Any, Any]: Perform crossover between two solutions. pass def evaluate(self, solution: Any) -> List[float]: Evaluate the solution based on the objectives. pass def dominates(solution1: List[float], solution2: List[float]) -> bool: Check if one solution dominates another. pass def genetic_algorithm_multi_objective( problem: MultiObjectiveProblem, generations: int, population_size: int, selection_method: str = \\"tournament\\" ) -> List[Any]: Optimize a multi-objective problem using a genetic algorithm. >>> def objective1(solution): return sum(x**2 for x in solution) >>> def objective2(solution): return sum((x-2)**2 for x in solution) >>> initial_population = [[random.uniform(-10, 10) for _ in range(3)] for _ in range(50)] >>> problem = MultiObjectiveProblem([objective1, objective2], initial_population, mutation_rate=0.01, crossover_rate=0.8) >>> pareto_front = genetic_algorithm_multi_objective(problem, generations=100, population_size=50) >>> len(pareto_front) > 0 True pass","solution":"import random from typing import List, Callable, Any, Tuple class MultiObjectiveProblem: def __init__(self, objectives: List[Callable], population: List[Any], mutation_rate: float, crossover_rate: float): self.objectives = objectives self.population = population self.mutation_rate = mutation_rate self.crossover_rate = crossover_rate def mutate(self, solution: Any) -> Any: Mutate the solution based on mutation rate. if random.random() < self.mutation_rate: index = random.randint(0, len(solution) - 1) solution[index] = random.uniform(-10, 10) return solution def crossover(self, solution1: Any, solution2: Any) -> Tuple[Any, Any]: Perform crossover between two solutions. if random.random() < self.crossover_rate: point = random.randint(1, len(solution1) - 1) new_solution1 = solution1[:point] + solution2[point:] new_solution2 = solution2[:point] + solution1[point:] return new_solution1, new_solution2 else: return solution1, solution2 def evaluate(self, solution: Any) -> List[float]: Evaluate the solution based on the objectives. return [objective(solution) for objective in self.objectives] def dominates(solution1: List[float], solution2: List[float]) -> bool: Check if solution1 dominates solution2. return all(x <= y for x, y in zip(solution1, solution2)) and any(x < y for x, y in zip(solution1, solution2)) def genetic_algorithm_multi_objective( problem: MultiObjectiveProblem, generations: int, population_size: int, selection_method: str = \\"tournament\\" ) -> List[Any]: def tournament_selection(population: List[Any], k: int = 3) -> Any: tournament = random.sample(population, k) tournament.sort(key=lambda sol: problem.evaluate(sol)) return tournament[0] def pareto_front(population: List[Any]) -> List[Any]: front = [] for solution in population: if not any(dominates(problem.evaluate(other), problem.evaluate(solution)) for other in population): front.append(solution) return front population = problem.population for generation in range(generations): new_population = [] while len(new_population) < population_size: parent1 = tournament_selection(population) parent2 = tournament_selection(population) child1, child2 = problem.crossover(parent1, parent2) child1 = problem.mutate(child1) child2 = problem.mutate(child2) new_population.append(child1) new_population.append(child2) population = new_population population = sorted(population, key=lambda sol: problem.evaluate(sol))[:population_size] return pareto_front(population)"},{"question":"class Account: def __init__(self, account_number: int): Initialize the account with account number, zero balance, and an empty transaction list. def deposit(self, amount: float) -> None: Deposit an amount to the account balance and record the transaction. Args: amount (float): The amount to deposit. def withdraw(self, amount: float) -> bool: Withdraw an amount from the account balance if funds are sufficient and record the transaction. Args: amount (float): The amount to withdraw. Returns: bool: True if the withdrawal was successful, False if insufficient funds. def get_statement(self) -> str: Generate a statement including the account number, all transactions, and the final balance. Returns: str: The account statement. class Bank: def __init__(self): Initialize the bank with an empty dictionary of accounts. def add_account(self, account_number: int) -> None: Add a new account with the given account number. Args: account_number (int): The unique account number. def get_account(self, account_number: int) -> Account | None: Retrieve an account by its number. Args: account_number (int): The account number to retrieve. Returns: Account: The account with the given account number, or None if not found.","solution":"class Account: def __init__(self, account_number: int): self.account_number = account_number self.balance = 0.0 self.transactions = [] def deposit(self, amount: float) -> None: self.balance += round(amount, 2) self.transactions.append(f'Deposit: +{amount:.2f}') def withdraw(self, amount: float) -> bool: if amount > self.balance: return False self.balance -= round(amount, 2) self.transactions.append(f'Withdrawal: -{amount:.2f}') return True def get_statement(self) -> str: statement = f\\"Account Number: {self.account_number}n\\" statement += \\"n\\".join(self.transactions) statement += f\\"nFinal Balance: {self.balance:.2f}\\" return statement class Bank: def __init__(self): self.accounts = {} def add_account(self, account_number: int) -> None: if account_number not in self.accounts: self.accounts[account_number] = Account(account_number) def get_account(self, account_number: int) -> Account: return self.accounts.get(account_number)"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. >>> reverse_words(\\"Hello World!\\") \\"World! Hello\\" >>> reverse_words(\\" This is a test \\") \\"test a is This\\" >>> reverse_words(\\"single\\") \\"single\\" >>> reverse_words(\\" \\") \\"\\"","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. Parameters: sentence (str): A string representing the sentence to be reversed. Returns: str: A string with the words in reverse order. # Split the sentence into words by spaces, omitting any empty words words = sentence.split() # Reverse the list of words and join them back into a string with single spaces reversed_sentence = ' '.join(reversed(words)) return reversed_sentence"},{"question":"def next_palindrome(n: int) -> int: Find the smallest palindrome greater than a given integer n. >>> next_palindrome(123) 131 >>> next_palindrome(999) 1001 >>> next_palindrome(12321) 12421 >>> next_palindrome(1) 2 >>> next_palindrome(808) 818","solution":"def next_palindrome(n: int) -> int: def is_palindrome(x: int) -> bool: s = str(x) return s == s[::-1] candidate = n + 1 while not is_palindrome(candidate): candidate += 1 return candidate"},{"question":"from typing import List A completion for the function that determines if a frog can jump from the first lily pad to the last lily pad. def can_reach_end(pads: List[int]) -> bool: # Determines if the frog can jump from the first lily pad to the last lily pad. # # Args: # pads (List[int]): List of non-negative integers where each integer represents the maximum # jump length from that pad. # # Returns: # bool: True if the frog can reach the last lily pad, False otherwise. # # Traverse the array 'pads' while keeping track of the maximum reachable index. # If at any point, the current index is beyond this maximum reachable index, # it means the frog cannot proceed further and hence cannot reach the last lily pad. max_reachable = 0 n = len(pads) for i in range(n): if i > max_reachable: return False max_reachable = max(max_reachable, i + pads[i]) if max_reachable >= n - 1: return True return False","solution":"from typing import List def can_reach_end(pads: List[int]) -> bool: Determines if the frog can jump from the first lily pad to the last lily pad. Args: pads (List[int]): List of integers where each integer represents the maximum jump length from that pad. Returns: bool: True if the frog can reach the last lily pad, False otherwise. max_reachable = 0 n = len(pads) for i in range(n): # If the current index is beyond the furthest point we've reached so far, break out. if i > max_reachable: return False # Update the furthest point reached so far. max_reachable = max(max_reachable, i + pads[i]) # If the furthest point is at or beyond the last index, return True. if max_reachable >= n - 1: return True return False"},{"question":"class TreeNode: def __init__(self, val: int, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def are_trees_identical(tree1: Optional[TreeNode], tree2: Optional[TreeNode]) -> bool: Determine whether two binary trees are identical in structure and node values. >>> tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) >>> tree2 = TreeNode(1, TreeNode(2), TreeNode(3)) >>> are_trees_identical(tree1, tree2) True >>> tree1 = TreeNode(1, TreeNode(2)) >>> tree2 = TreeNode(1, None, TreeNode(2)) >>> are_trees_identical(tree1, tree2) False >>> tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) >>> tree2 = TreeNode(1, TreeNode(2), TreeNode(4)) >>> are_trees_identical(tree1, tree2) False >>> tree1 = TreeNode(1, TreeNode(2), TreeNode(3)) >>> tree2 = None >>> are_trees_identical(tree1, tree2) False >>> tree1 = None >>> tree2 = None >>> are_trees_identical(tree1, tree2) True >>> tree1 = TreeNode(1) >>> tree2 = TreeNode(1) >>> are_trees_identical(tree1, tree2) True >>> tree1 = TreeNode(1) >>> tree2 = TreeNode(2) >>> are_trees_identical(tree1, tree2) False","solution":"class TreeNode: def __init__(self, val: int, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def are_trees_identical(tree1: TreeNode, tree2: TreeNode) -> bool: # Both trees are empty if tree1 is None and tree2 is None: return True # One of the trees is empty, but not the other if tree1 is None or tree2 is None: return False # Both trees are non-empty, compare the values and the subtrees if tree1.val != tree2.val: return False return are_trees_identical(tree1.left, tree2.left) and are_trees_identical(tree1.right, tree2.right)"},{"question":"def sort_addresses_by_distance(addresses_with_distances: List[Tuple[str, float]]) -> List[str]: Sorts the addresses by their distance from the warehouse in ascending order. Parameters: addresses_with_distances (List[Tuple[str, float]]): A list of tuples where each tuple contains a delivery address and its distance from the warehouse. Returns: List[str]: A list of addresses sorted by their distance from the warehouse. >>> addresses = [ ... (\\"123 Maple Street\\", 5.2), ... (\\"456 Oak Avenue\\", 3.3), ... (\\"789 Pine Road\\", 5.2), ... (\\"101 Birch Blvd\\", 2.8) ... ] >>> sort_addresses_by_distance(addresses) [\\"101 Birch Blvd\\", \\"456 Oak Avenue\\", \\"123 Maple Street\\", \\"789 Pine Road\\"]","solution":"def sort_addresses_by_distance(addresses_with_distances): Sorts the addresses by their distance from the warehouse in ascending order. Parameters: addresses_with_distances (List[Tuple[str, float]]): A list of tuples where each tuple contains a delivery address and its distance from the warehouse. Returns: List[str]: A list of addresses sorted by their distance from the warehouse. # Use the sorted function to sort the list of tuples by the second element (distance) in each tuple sorted_addresses = sorted(addresses_with_distances, key=lambda x: x[1]) # Extract and return only the addresses in sorted order return [address for address, distance in sorted_addresses]"},{"question":"def compress(text): Compresses the input text using Run-Length Encoding (RLE). Parameters: text (str): The input string to be compressed. Returns: str: The run-length encoded version of the input text. Examples: >>> compress(\\"AAAABBBCCDAA\\") 'A4B3C2D1A2' >>> compress(\\"Hello World!!\\") 'H1e1l2o1 1W1o1r1l1d1!2' pass def decompress(data): Decompresses the input RLE text to its original form. Parameters: data (str): The run-length encoded string. Returns: str: The original string before compression. Examples: >>> decompress(\\"A4B3C2D1A2\\") 'AAAABBBCCDAA' >>> decompress('H1e1l2o1 1W1o1r1l1d1!2') 'Hello World!!' pass","solution":"def compress(text): Compresses the input text using Run-Length Encoding (RLE). Parameters: text (str): The input string to be compressed. Returns: str: The run-length encoded version of the input text. if not text: return \\"\\" compressed = [] count = 1 previous = text[0] for char in text[1:]: if char == previous: count += 1 else: compressed.append(f'{previous}{count}') previous = char count = 1 compressed.append(f'{previous}{count}') # appending the last character run return ''.join(compressed) def decompress(data): Decompresses the input RLE text to its original form. Parameters: data (str): The run-length encoded string. Returns: str: The original string before compression. if not data: return \\"\\" decompressed = [] i = 0 n = len(data) while i < n: char = data[i] j = i + 1 count = 0 while j < n and data[j].isdigit(): count = count * 10 + int(data[j]) j += 1 decompressed.append(char * count) i = j return ''.join(decompressed)"},{"question":"def binary_search_recursive(arr: list, x: int, left: int, right: int) -> int: Perform a binary search using a recursive approach to find the index of 'x' in 'arr'. >>> sorted_list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> binary_search_recursive(sorted_list1, 5, 0, len(sorted_list1) - 1) 4 >>> sorted_list2 = [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> binary_search_recursive(sorted_list2, 13, 0, len(sorted_list2) - 1) 5 >>> sorted_list3 = [8, 16, 24, 32, 40] >>> binary_search_recursive(sorted_list3, 10, 0, len(sorted_list3) - 1) -1","solution":"def binary_search_recursive(arr, x, left, right): if left > right: return -1 mid = (left + right) // 2 if arr[mid] == x: return mid elif arr[mid] > x: return binary_search_recursive(arr, x, left, mid - 1) else: return binary_search_recursive(arr, x, mid + 1, right)"},{"question":"def is_balanced_string(s: str) -> bool: Determine if the input string is balanced considering '(' as left parenthesis, ')' as right parenthesis, and '*' as a wildcard that can be treated as '(', ')', or empty. >>> is_balanced_string(\\"(*)\\") True >>> is_balanced_string(\\"(*))\\") True >>> is_balanced_string(\\"((*\\") False >>> is_balanced_string(\\"()\\") True >>> is_balanced_string(\\"**(()\\") False","solution":"def is_balanced_string(s: str) -> bool: Determine if the input string is balanced considering '(' as left parenthesis, ')' as right parenthesis, and '*' as a wildcard that can be treated as '(', ')', or empty. left_balance, right_balance = 0, 0 for char in s: if char == '(' or char == '*': left_balance += 1 else: left_balance -= 1 if left_balance < 0: return False for char in reversed(s): if char == ')' or char == '*': right_balance += 1 else: right_balance -= 1 if right_balance < 0: return False return True"},{"question":"def is_leap_year(year: int) -> bool: Returns True if the given year is a leap year, False otherwise. A year is a leap year if: - It is divisible by 4. - If it is divisible by 100, it must also be divisible by 400. >>> is_leap_year(2000) True >>> is_leap_year(1900) False >>> is_leap_year(2004) True >>> is_leap_year(2100) False >>> is_leap_year(2024) True","solution":"def is_leap_year(year: int) -> bool: Returns True if the given year is a leap year, False otherwise. A year is a leap year if: - It is divisible by 4. - If it is divisible by 100, it must also be divisible by 400. if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False"},{"question":"def find_missing_number(sequence: List[int]) -> int: Find the missing number in an arithmetic progression. >>> find_missing_number([1, 3, 5, 9, 11]) 7 >>> find_missing_number([10, 20, 30, 50, 60]) 40 def test_find_missing_number_normal_case(): assert find_missing_number([1, 3, 5, 9, 11]) == 7 assert find_missing_number([10, 20, 30, 50, 60]) == 40 def test_find_missing_number_single_missing_negative(): assert find_missing_number([-10, -5, 0, 5, 15]) == 10 assert find_missing_number([-100, -50, 0, 50, 150]) == 100 def test_find_missing_number_missing_first_numbers(): assert find_missing_number([1, 9, 13, 17, 21]) == 5 assert find_missing_number([5, 10, 20, 25, 30]) == 15 def test_find_missing_number_missing_last_numbers(): assert find_missing_number([4, 8, 12, 20, 24]) == 16 assert find_missing_number([7, 14, 21, 28, 42]) == 35 def test_find_missing_number_large_sequence(): assert find_missing_number(list(range(0, 1000000, 10))[:49999] + list(range(0, 1000000, 10))[50000:]) == 499990","solution":"def find_missing_number(sequence): Find the missing number in the arithmetic progression. Parameters: sequence (list): A list of integers representing an arithmetic progression with one number missing. Returns: int: The missing number in the sequence. n = len(sequence) # Calculate the expected common difference of the arithmetic progression common_diff = (sequence[-1] - sequence[0]) // n # Use binary search to find the missing number left, right = 0, n - 1 while left < right: mid = (left + right) // 2 expected_value = sequence[0] + mid * common_diff if sequence[mid] == expected_value: left = mid + 1 else: right = mid return sequence[0] + left * common_diff"},{"question":"from typing import List, Tuple def max_points_on_line(points: List[Tuple[int, int]]) -> int: Given a list of points, returns the maximum number of points that lie on a single straight line. Parameters: points (List[Tuple[int, int]]): A list of points represented by tuples of x and y coordinates. Returns: int: maximum number of points that lie on a single straight line. Examples: >>> max_points_on_line([(1, 1), (2, 2), (3, 3)]) 3 >>> max_points_on_line([(1, 1), (3, 2), (5, 3), (4, 1), (2, 3), (1, 4)]) 4 >>> max_points_on_line([(0, 0), (1, 1), (1, -1)]) 2 pass","solution":"from collections import defaultdict from typing import List, Tuple def max_points_on_line(points: List[Tuple[int, int]]) -> int: if not points: return 0 def gcd(a, b): while b: a, b = b, a % b return a def get_slope(p1, p2): delta_x = p2[0] - p1[0] delta_y = p2[1] - p1[1] if delta_x == 0: return ('inf', p1[0]) if delta_y == 0: return (0, p1[1]) gcd_val = gcd(delta_x, delta_y) return (delta_y // gcd_val, delta_x // gcd_val) max_points = 1 for i in range(len(points)): lines = defaultdict(int) duplicates = 1 for j in range(i + 1, len(points)): if points[i] == points[j]: duplicates += 1 else: slope = get_slope(points[i], points[j]) lines[slope] += 1 max_points = max(max_points, duplicates + max(lines.values(), default=0)) return max_points"},{"question":"def normalize_path(path: str) -> str: Normalizes a given file path by processing the separators, '.' and '..' and returns the canonical path. pass def test_normalize_path_basic(): assert normalize_path(\\"/home/\\") == \\"/home\\" def test_normalize_path_with_double_slash(): assert normalize_path(\\"/home//foo/\\") == \\"/home/foo\\" def test_normalize_path_with_single_dot(): assert normalize_path(\\"/a/./b/../../c/\\") == \\"/c\\" def test_normalize_path_root(): assert normalize_path(\\"/\\") == \\"/\\" def test_normalize_path_with_ending_dot(): assert normalize_path(\\"/a/./b/./c/\\") == \\"/a/b/c\\" def test_normalize_path_with_heading_double_dot(): assert normalize_path(\\"/../\\") == \\"/\\" def test_normalize_path_with_mixture(): assert normalize_path(\\"/a//b////c/d//././/..\\") == \\"/a/b/c\\" def test_normalize_path_multiple_double_dots(): assert normalize_path(\\"/a/b/c/../../../\\") == \\"/\\" def test_normalize_path_complex(): assert normalize_path(\\"/a/./b/../../c/./d/e/../f/\\") == \\"/c/d/f\\" if __name__ == \\"__main__\\": test_normalize_path_basic() test_normalize_path_with_double_slash() test_normalize_path_with_single_dot() test_normalize_path_root() test_normalize_path_with_ending_dot() test_normalize_path_with_heading_double_dot() test_normalize_path_with_mixture() test_normalize_path_multiple_double_dots() test_normalize_path_complex() print(\\"All tests passed!\\")","solution":"def normalize_path(path: str) -> str: Normalizes a given file path and returns the canonical path. parts = path.split('/') stack = [] for part in parts: if part == \\"\\" or part == \\".\\": continue elif part == \\"..\\": if stack: stack.pop() else: stack.append(part) return \\"/\\" + \\"/\\".join(stack)"},{"question":"def word_frequency(input_file: str, output_file: str) -> None: Read a file, count the frequency of each word, and write these frequencies to a new file sorted alphabetically by word. The words should be considered case-insensitive and punctuation should be ignored. Args: input_file (str): The path to the input file. output_file (str): The path to the output file. Example: Given an input file with the following content: Hello world! This is a test. This test is only a test. Hello again, world. The output file should contain: a 2 again 1 hello 2 is 2 only 1 test 3 this 2 world 2 import os from solution import word_frequency def test_word_frequency(): # Setup input_text = Hello world! This is a test. This test is only a test. Hello again, world. expected_output = a 2 again 1 hello 2 is 2 only 1 test 3 this 2 world 2 input_file = 'input_test.txt' output_file = 'output_test.txt' with open(input_file, 'w') as f: f.write(input_text) # Execute word_frequency(input_file, output_file) # Verify with open(output_file, 'r') as f: output_text = f.read() assert output_text == expected_output # Cleanup os.remove(input_file) os.remove(output_file)","solution":"import re from collections import Counter def word_frequency(input_file: str, output_file: str) -> None: # Read the content of the input file with open(input_file, 'r') as infile: text = infile.read() # Normalize the words (convert to lowercase and remove punctuation) text = text.lower() words = re.findall(r'b[a-z]+b', text) # Count the frequency of each word word_counts = Counter(words) # Write the results to the output file with open(output_file, 'w') as outfile: for word in sorted(word_counts): outfile.write(f\\"{word} {word_counts[word]}n\\")"},{"question":"import re from typing import List class MarkdownConverter: def convert_header(self, line: str) -> str: Converts a Markdown header line to an HTML header. >>> converter.convert_header('# Header 1') '<h1>Header 1</h1>' >>> converter.convert_header(' Header 6') '<h6>Header 6</h6>' pass def convert_bold_italic(self, line: str) -> str: Converts Markdown bold and italic formatting to HTML. >>> converter.convert_bold_italic('This is **bold** text') 'This is <b>bold</b> text' >>> converter.convert_bold_italic('This is *italic* text') 'This is <i>italic</i> text' pass def convert_list(self, lines: List[str]) -> str: Converts Markdown unordered list lines to HTML. >>> converter.convert_list(['- Item 1', '- Item 2', '- Item 3']) '<ul><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul>' pass def convert_code(self, line: str) -> str: Converts Markdown inline code to HTML. >>> converter.convert_code('This is \`inline code\`') 'This is <code>inline code</code>' pass def convert_markdown(self, markdown: str) -> str: Converts the entire Markdown text to HTML. >>> markdown_text = '''# Title ... This is a paragraph with **bold** and _italic_ text. ... ... Here is a list: ... - Item 1 ... - Item 2 ... - Item 3 ... ... Here is \`inline code\`.''' >>> expected_html = '''<h1>Title</h1> ... <p>This is a paragraph with <b>bold</b> and <i>italic</i> text.</p> ... <p>Here is a list:</p> ... <ul><li>Item 1</li><li>Item 2</li><li>Item 3</li></ul> ... <p>Here is <code>inline code</code>.</p>''' >>> converter.convert_markdown(markdown_text) == expected_html True pass","solution":"import re class MarkdownConverter: def convert_header(self, line: str) -> str: match = re.match(r'^(#{1,6})s+(.*)', line) if match: header_level = len(match.group(1)) header_text = match.group(2) return f\\"<h{header_level}>{header_text}</h{header_level}>\\" return line def convert_bold_italic(self, line: str) -> str: line = re.sub(r'**(.*?)**', r'<b>1</b>', line) line = re.sub(r'__(.*?)__', r'<b>1</b>', line) line = re.sub(r'*(.*?)*', r'<i>1</i>', line) line = re.sub(r'_(.*?)_', r'<i>1</i>', line) return line def convert_list(self, lines: list[str]) -> str: list_items = ''.join(f\\"<li>{line[2:]}</li>\\" for line in lines if line.startswith('- ')) return f\\"<ul>{list_items}</ul>\\" def convert_code(self, line: str) -> str: return re.sub(r'\`(.*?)\`', r'<code>1</code>', line) def convert_markdown(self, markdown: str) -> str: sections = markdown.split('n') html = [] list_buffer = [] in_list = False for line in sections: if line.startswith('#'): if in_list: html.append(self.convert_list(list_buffer)) list_buffer = [] in_list = False html.append(self.convert_header(line)) elif line.startswith('- '): list_buffer.append(line) in_list = True elif line.strip() == \\"\\": if in_list: html.append(self.convert_list(list_buffer)) list_buffer = [] in_list = False html.append(\\"<br>\\") else: if in_list: html.append(self.convert_list(list_buffer)) list_buffer = [] in_list = False line = self.convert_bold_italic(line) line = self.convert_code(line) html.append(f\\"<p>{line}</p>\\") if in_list: html.append(self.convert_list(list_buffer)) return 'n'.join(html)"},{"question":"Write a function named \`can_rearrange()\` that takes a single input, a string \`s\` consisting only of lowercase alphabets where 1 <= len(s) <= 10^5 and returns a boolean value indicating whether the string can be rearranged so that no two adjacent characters are the same. __Example__: def can_rearrange(s: str) -> bool: Given a string \`s\` containing only lowercase alphabets, determine whether it is possible to rearrange the characters of the string so that no two adjacent characters are the same. Parameters: s (str): A string consisting only of lowercase alphabets where 1 <= len(s) <= 10^5 Returns: bool: True if the string can be rearranged such that no two adjacent characters are the same, otherwise False. Example: >>> can_rearrange(\\"aab\\") True >>> can_rearrange(\\"aaab\\") False >>> can_rearrange(\\"aaaabbbcc\\") True >>> can_rearrange(\\"abcabc\\") True >>> can_rearrange(\\"aaaa\\") False # Example For Solution: def can_rearrange(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") from collections import Counter freq = Counter(s) max_freq = max(freq.values()) # The count of the most frequent letter should not be more than # (length of s + 1) / 2. Otherwise, it is impossible to rearrange # such that no two adjacent characters are the same. return max_freq <= (len(s) + 1) // 2 def test_valid_cases(): assert can_rearrange(\\"aab\\") == True assert can_rearrange(\\"aaab\\") == False assert can_rearrange(\\"aaaabbbcc\\") == True assert can_rearrange(\\"abcabc\\") == True assert can_rearrange(\\"aaaa\\") == False def test_single_character(): assert can_rearrange(\\"a\\") == True assert can_rearrange(\\"z\\") == True def test_multiple_same_characters(): assert can_rearrange(\\"bbbbb\\") == False def test_all_unique_characters(): assert can_rearrange(\\"abcdefg\\") == True def test_long_string(): assert can_rearrange(\\"a\\"*50000 + \\"b\\"*49999) == True assert can_rearrange(\\"a\\"*50001 + \\"b\\"*49999) == False def test_large_input_edge_case(): s = \\"a\\" * (10**5 // 2) + \\"b\\" * (10**5 // 2) assert can_rearrange(s) == True def test_invalid_input(): try: can_rearrange(123) # not a string assert False # Should not reach here except TypeError: assert True def test_mixed_valid_cases(): assert can_rearrange(\\"xxy\\") == True assert can_rearrange(\\"xyy\\") == True assert can_rearrange(\\"yyy\\") == False","solution":"def can_rearrange(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") from collections import Counter freq = Counter(s) max_freq = max(freq.values()) # The count of the most frequent letter should not be more than # (length of s + 1) / 2. Otherwise, it is impossible to rearrange # such that no two adjacent characters are the same. return max_freq <= (len(s) + 1) // 2"},{"question":"from typing import List def find_equilibrium_index(arr: List[int]) -> int: Find the first (leftmost) equilibrium index in the list. An equilibrium index is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. >>> find_equilibrium_index([1, 3, 5, 2, 2]) 2 >>> find_equilibrium_index([1, 2, 3]) -1 >>> find_equilibrium_index([10]) 0","solution":"from typing import List def find_equilibrium_index(arr: List[int]) -> int: total_sum = sum(arr) left_sum = 0 for i, value in enumerate(arr): total_sum -= value if left_sum == total_sum: return i left_sum += value return -1"},{"question":"class FibonacciGenerator: A generator for Fibonacci sequence with memoization. Methods: generate(n: int) -> list get_fibonacci(position: int) -> int clear_cache() -> None >>> fib_gen = FibonacciGenerator() >>> fib_gen.generate(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fib_gen.get_fibonacci(5) 5 >>> fib_gen.generate(15) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377] >>> fib_gen.clear_cache() def __init__(self): Initialize the Fibonacci generator with a cache. pass def generate(self, n: int) -> list: Generates the first n Fibonacci numbers. pass def get_fibonacci(self, position: int) -> int: Gets the Fibonacci number at the specified position. pass def clear_cache(self) -> None: Clears the internal cache of Fibonacci numbers. pass","solution":"class FibonacciGenerator: def __init__(self): self.cache = {0: 0, 1: 1} def generate(self, n: int) -> list: # Ensure we have memoized all Fibonacci numbers up to n-1 for i in range(2, n): if i not in self.cache: self.cache[i] = self.cache[i - 1] + self.cache[i - 2] return [self.cache[i] for i in range(n)] def get_fibonacci(self, position: int) -> int: if position not in self.cache: self.cache[position] = self.get_fibonacci(position - 1) + self.get_fibonacci(position - 2) return self.cache[position] def clear_cache(self) -> None: self.cache = {0: 0, 1: 1}"},{"question":"from collections import deque class Graph: A class to represent an unweighted graph using adjacency lists. Methods: add_edge(v1, v2): Adds an undirected edge between two vertices. bfs(start): Performs Breadth-First Search starting from the given vertex and returns the order of traversal. dfs(start): Performs Depth-First Search starting from the given vertex and returns the order of traversal. shortest_path(start, end): Finds the shortest path between two vertices using BFS and returns the path as a list of vertices. def __init__(self): self.adjacency_list = {} def add_edge(self, v1, v2): Adds an undirected edge between two vertices. Raises: TypeError: If either of the vertices are not integers. pass def bfs(self, start): Performs Breadth-First Search starting from the given vertex. Args: start (int): The starting vertex for the BFS. Returns: List[int]: The order of traversal. Raises: TypeError: If the start vertex is not an integer. ValueError: If the start vertex does not exist in the graph. pass def dfs(self, start): Performs Depth-First Search starting from the given vertex. Args: start (int): The starting vertex for the DFS. Returns: List[int]: The order of traversal. Raises: TypeError: If the start vertex is not an integer. ValueError: If the start vertex does not exist in the graph. pass def shortest_path(self, start, end): Finds the shortest path between two vertices using BFS. Args: start (int): The starting vertex. end (int): The ending vertex. Returns: List[int]: The path from start to end, or None if no path exists. Raises: TypeError: If either of the vertices are not integers. ValueError: If one or both vertices do not exist in the graph. pass import pytest from solution import Graph def test_add_edge_type_error(): graph = Graph() with pytest.raises(TypeError): graph.add_edge(1, \\"a\\") with pytest.raises(TypeError): graph.add_edge(\\"1\\", 2) def test_bfs_invalid_start(): graph = Graph() graph.add_edge(1, 2) with pytest.raises(TypeError): graph.bfs(\\"1\\") with pytest.raises(ValueError): graph.bfs(3) def test_dfs_invalid_start(): graph = Graph() graph.add_edge(1, 2) with pytest.raises(TypeError): graph.dfs(\\"1\\") with pytest.raises(ValueError): graph.dfs(3) def test_shortest_path_invalid(): graph = Graph() graph.add_edge(1, 2) with pytest.raises(TypeError): graph.shortest_path(1, \\"2\\") with pytest.raises(ValueError): graph.shortest_path(1, 3) def test_bfs(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 4) assert graph.bfs(1) == [1, 2, 3, 4] def test_dfs(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 4) assert graph.dfs(1) == [1, 3, 4, 2] def test_shortest_path(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 4) assert graph.shortest_path(1, 4) == [1, 2, 4] assert graph.shortest_path(2, 3) in [[2, 1, 3], [2, 4, 3]] def test_no_path(): graph = Graph() graph.add_edge(1, 2) graph.add_edge(3, 4) assert graph.shortest_path(1, 4) == None","solution":"from collections import deque class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, v1, v2): if not isinstance(v1, int) or not isinstance(v2, int): raise TypeError(\\"Both vertices must be integers\\") if v1 not in self.adjacency_list: self.adjacency_list[v1] = [] if v2 not in self.adjacency_list: self.adjacency_list[v2] = [] self.adjacency_list[v1].append(v2) self.adjacency_list[v2].append(v1) def bfs(self, start): if not isinstance(start, int): raise TypeError(\\"Start vertex must be an integer\\") if start not in self.adjacency_list: raise ValueError(\\"Start vertex does not exist in the graph\\") visited = set() queue = deque([start]) order = [] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) order.append(vertex) for neighbor in self.adjacency_list[vertex]: if neighbor not in visited: queue.append(neighbor) return order def dfs(self, start): if not isinstance(start, int): raise TypeError(\\"Start vertex must be an integer\\") if start not in self.adjacency_list: raise ValueError(\\"Start vertex does not exist in the graph\\") visited = set() stack = [start] order = [] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) order.append(vertex) for neighbor in self.adjacency_list[vertex]: if neighbor not in visited: stack.append(neighbor) return order def shortest_path(self, start, end): if not isinstance(start, int) or not isinstance(end, int): raise TypeError(\\"Both start and end vertices must be integers\\") if start not in self.adjacency_list or end not in self.adjacency_list: raise ValueError(\\"One or both vertices do not exist in the graph\\") visited = set() queue = deque([(start, [start])]) while queue: current, path = queue.popleft() if current == end: return path if current not in visited: visited.add(current) for neighbor in self.adjacency_list[current]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return None # No path found"},{"question":"def partition_even_odd(arr: list) -> tuple: This function receives a list of integers and partitions it into two lists: one containing even integers and the other containing odd integers, while maintaining the original order of elements. Args: arr (list): A list of integers to be partitioned. Returns: tuple: A tuple containing two lists, the first list with even integers and the second list with odd integers. >>> partition_even_odd([1, 2, 3, 4, 5, 6]) ([2, 4, 6], [1, 3, 5]) >>> partition_even_odd([11, 22, 33, 44, 55]) ([22, 44], [11, 33, 55]) >>> partition_even_odd([0, -1, -2, 3, -4]) ([0, -2, -4], [-1, 3]) >>> partition_even_odd([]) ([], [])","solution":"def partition_even_odd(arr): Partitions an array into two arrays: one with even numbers and one with odd numbers. Args: arr (list): A list of integers to be partitioned. Returns: tuple: A tuple containing two lists; the first list with even integers and the second list with odd integers. even = [] odd = [] for num in arr: if num % 2 == 0: even.append(num) else: odd.append(num) return (even, odd)"},{"question":"def travelling_salesman(dist_matrix: list[list[int]]) -> tuple: Implement a solution that uses a backtracking approach to find the shortest possible route to visit each location exactly once and return to the starting point. Parameters: dist_matrix (list[list[int]]): A 2D list where dist_matrix[i][j] represents the distance between location i and location j. Returns: tuple: The minimum distance and a list representing the order in which the locations are visited. Example: >>> dist_matrix = [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ] >>> travelling_salesman(dist_matrix) (80, [0, 1, 3, 2, 0])","solution":"from itertools import permutations def travelling_salesman(dist_matrix): n = len(dist_matrix) min_path_cost = float('inf') best_path = [] for perm in permutations(range(1, n)): current_cost = dist_matrix[0][perm[0]] for i in range(n - 2): current_cost += dist_matrix[perm[i]][perm[i + 1]] current_cost += dist_matrix[perm[-1]][0] if current_cost < min_path_cost: min_path_cost = current_cost best_path = [0] + list(perm) + [0] return min_path_cost, best_path"},{"question":"from typing import List def max_profit(stock_prices: List[float]) -> float: Determines the maximum profit that could have been made from a single buy-and-hold strategy. Parameters: stock_prices (List[float]): A list of floating-point numbers representing stock prices over a period of days. Returns: float: The maximum profit possible. If no profit is possible, returns 0. pass # Here are some example test cases to validate the functionality of the function. def test_max_profit_basic(): assert max_profit([7.1, 1.5, 5.3, 3.6, 6.4, 4.2]) == 4.9 assert max_profit([3.0, 2.9, 5.4, 6.2, 2.1, 9.0]) == 6.9 def test_max_profit_no_profit(): assert max_profit([9.0, 8.5, 8.0, 7.5, 7.0, 6.5]) == 0.0 def test_max_profit_single_price(): assert max_profit([5.0]) == 0.0 def test_max_profit_two_prices_same(): assert max_profit([5.0, 5.0]) == 0.0 def test_max_profit_two_prices_profit(): assert max_profit([1.0, 5.0]) == 4.0 def test_max_profit_large_profit(): assert max_profit([3.0, 10.0, 2.0, 12.0, 1.0, 15.0]) == 14.0 def test_max_profit_price_fluctuations(): assert max_profit([1.0, 7.0, 5.0, 3.6, 8.0, 4.2]) == 7.0 def test_max_profit_edge_case_empty(): assert max_profit([]) == 0.0 def test_max_profit_edge_case_single_element(): assert max_profit([3.5]) == 0.0 def test_max_profit_edge_case_two_elements(): assert max_profit([3.5, 7.5]) == 4.0 assert max_profit([7.5, 3.5]) == 0.0 from solution import max_profit def test_max_profit(): test_max_profit_basic() test_max_profit_no_profit() test_max_profit_single_price() test_max_profit_two_prices_same() test_max_profit_two_prices_profit() test_max_profit_large_profit() test_max_profit_price_fluctuations() test_max_profit_edge_case_empty() test_max_profit_edge_case_single_element() test_max_profit_edge_case_two_elements()","solution":"from typing import List def max_profit(stock_prices: List[float]) -> float: Determines the maximum profit that could have been made from a single buy-and-hold strategy. Parameters: stock_prices (List[float]): A list of floating-point numbers representing stock prices over a period of days. Returns: float: The maximum profit possible. If no profit is possible, returns 0. if not stock_prices or len(stock_prices) < 2: return 0.0 min_price = stock_prices[0] max_profit = 0.0 for price in stock_prices[1:]: if price < min_price: min_price = price else: profit = price - min_price max_profit = max(max_profit, profit) return max_profit"},{"question":"def left_rotate_array(arr: list, d: int) -> list: Rotates the array 'arr' to the left 'd' times. For negative 'd', it rotates the array to the right '-d' times. >>> left_rotate_array([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> left_rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> left_rotate_array([1, 2, 3, 4, 5], 7) [3, 4, 5, 1, 2] >>> left_rotate_array([], 3) [] >>> left_rotate_array([1, 2, 3, 4, 5], -2) [4, 5, 1, 2, 3] pass","solution":"def left_rotate_array(arr: list, d: int) -> list: Rotates the array 'arr' to the left 'd' times. For negative 'd', it rotates the array to the right '-d' times. if not arr: # if the array is empty, return it unchanged return arr n = len(arr) # Normalize d to be within the bounds of the array length d = d % n # if d is positive d = d + n if d < 0 else d % n # if d is negative, making it positive return arr[d:] + arr[:d]"},{"question":"def longest_substring_with_constraints(s: str, k: int) -> int: Returns the length of the longest substring with no more than k distinct characters. >>> longest_substring_with_constraints(\\"abcba\\", 2) == 3 >>> longest_substring_with_constraints(\\"aabbcc\\", 1) == 2 >>> longest_substring_with_constraints(\\"anystring\\", 0) == 0 >>> longest_substring_with_constraints(\\"abcdef\\", 6) == 6 >>> longest_substring_with_constraints(\\"abcdef\\", 10) == 6 >>> longest_substring_with_constraints(\\"\\", 1) == 0 >>> longest_substring_with_constraints(\\"a\\", 1) == 1 >>> s = \\"a\\" * 5000 + \\"b\\" * 4999 >>> longest_substring_with_constraints(s, 2) == 9999","solution":"def longest_substring_with_constraints(s: str, k: int) -> int: if k == 0: return 0 if len(set(s)) <= k: return len(s) left = 0 max_length = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def is_subsequence(sub: str, main: str) -> bool: Returns True if 'sub' is a subsequence of 'main', and False otherwise. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"ace\\", \\"abcde\\") True >>> is_subsequence(\\"aec\\", \\"abcde\\") False >>> is_subsequence(\\"a\\", \\"a\\") True >>> is_subsequence(\\"a\\", \\"b\\") False","solution":"def is_subsequence(sub, main): Returns True if 'sub' is a subsequence of 'main'. Otherwise, returns False. sub_index = 0 sub_length = len(sub) for char in main: if sub_index < sub_length and char == sub[sub_index]: sub_index += 1 return sub_index == sub_length"},{"question":"from typing import List, Tuple def balance_load(server_loads: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process load transfer operations and balance the loads across servers. :param server_loads: List of initial loads on each server :type server_loads: List[int] :param operations: List of load transfer operations :type operations: List[Tuple[int, int, int]] :return: Final balanced loads on each server :rtype: List[int] >>> balance_load([10, 20, 30, 40], [(0, 1, 5), (2, 3, 10), (1, 2, 15)]) [25, 25, 25, 25] >>> balance_load([1, 2, 3, 4], [(2, 1, 1), (3, 0, 3)]) [2, 2, 3, 3]","solution":"from typing import List, Tuple def balance_load(server_loads: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process load transfer operations and balance the loads across servers. :param server_loads: List of initial loads on each server :type server_loads: List[int] :param operations: List of load transfer operations :type operations: List[Tuple[int, int, int]] :return: Final balanced loads on each server :rtype: List[int] # First, apply all transfer operations for source, target, amount in operations: if source >= 0 and source < len(server_loads) and target >= 0 and target < len(server_loads): server_loads[source] -= amount server_loads[target] += amount # Now, balance the loads across all servers total_load = sum(server_loads) num_servers = len(server_loads) # Calculate the ideal load per server ideal_load = total_load // num_servers extra_load = total_load % num_servers balanced_loads = [ideal_load] * num_servers # Distribute the extra load evenly for i in range(extra_load): balanced_loads[i] += 1 return balanced_loads"},{"question":"# Matrix Diagonal Difference Objective Write a function: 1. \`diagonal_difference(matrix: list) -> int\`: This function calculates the absolute difference between the sums of the matrix's two diagonals. Detailed Requirements - **Input**: A list of lists (2D matrix) representing an \`n x n\` matrix of integers. - **Output**: An integer representing the absolute difference between the sums of the primary diagonal and the secondary diagonal. - **Constraints**: - The matrix should be square (same number of rows and columns). - Each element in the matrix is an integer. - Raise a \`ValueError\` if the input matrix is not square or contains non-integer elements. - Handle edge cases where the matrix is empty or has sub-lists of inconsistent lengths. - **Description**: - The primary diagonal is formed by the elements \`matrix[i][i]\` for \`i\` from \`0\` to \`n-1\`. - The secondary diagonal is formed by the elements \`matrix[i][n-1-i]\` for \`i\` from \`0\` to \`n-1\`. - The function calculates the sums of these diagonals and returns the absolute difference. Example Usage # Testing diagonal differences print(diagonal_difference([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # 0 print(diagonal_difference([[1, 2], [3, 4]])) # 0 print(diagonal_difference([[1, 2, 3], [4, 5, 6], [9, 8, 9]])) # 2","solution":"def diagonal_difference(matrix): Calculate the absolute difference between the sums of the matrix's two diagonals. :param matrix: List of equal-sized lists representing an n x n matrix. :return: Absolute difference between primary and secondary diagonal sums. :raises ValueError: If the input matrix is not square or contains non-integer elements. if not matrix or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Input matrix must be square and non-empty.\\") primary_diagonal_sum = 0 secondary_diagonal_sum = 0 n = len(matrix) for i in range(n): # Check if elements are integers if not all(isinstance(matrix[i][j], int) for j in range(n)): raise ValueError(\\"Matrix elements must be integers.\\") primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n-1-i] return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"def find_longest_arithmetic_subsequence(arr: list) -> int: Given a list of integers, find the length of the longest arithmetic subsequence. An arithmetic subsequence of a list is a subsequence that can be derived by deleting some or no elements of the list, and the difference between consecutive elements is constant. Parameters: arr (list of int): The list of integers. Returns: int: The length of the longest arithmetic subsequence. Examples: >>> find_longest_arithmetic_subsequence([3, 6, 9, 12]) 4 >>> find_longest_arithmetic_subsequence([9, 4, 7, 2, 10]) 3 >>> find_longest_arithmetic_subsequence([20, 1, 15, 3, 10, 5, 8]) 4 # Example 1 # Input: # arr = [3, 6, 9, 12] # Output: # 4 # Example 2 # Input: # arr = [9, 4, 7, 2, 10] # Output: # 3 # Example 3 # Input: # arr = [20, 1, 15, 3, 10, 5, 8] # Output: # 4","solution":"def find_longest_arithmetic_subsequence(arr): if not arr: return 0 dp = [{} for _ in range(len(arr))] max_length = 1 for i in range(1, len(arr)): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 # At least two elements (arr[j] and arr[i]) max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"from typing import List, Tuple def max_task_scheduling(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. Args: tasks (List[Tuple[int, int]]): A list of tasks represented by their start and end times. Returns: int: The maximum number of non-overlapping tasks. Examples: >>> max_task_scheduling([(1, 3), (2, 5), (4, 6)]) 2 >>> max_task_scheduling([(1, 2), (3, 4), (0, 6), (5, 7), (8, 9), (5, 9)]) 4","solution":"from typing import List, Tuple def max_task_scheduling(tasks: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. Args: tasks (List[Tuple[int, int]]): A list of tasks represented by their start and end times. Returns: int: The maximum number of non-overlapping tasks. # Sort the tasks by their end times tasks.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping tasks count = 0 # Track the end time of the last selected task last_end_time = 0 for start, end in tasks: # If the current task starts after or when the last chosen task ends if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"import pandas as pd from typing import List, Dict, Any def analyze_data(dict_list: List[Dict[str, Any]], fill_value: Any, check_field: str, check_value: Any) -> pd.DataFrame: Convert a list of dictionaries into a Pandas DataFrame and perform analysis. - Fill missing values with \`fill_value\` - Compute and print the mean of each numerical column - Add a new column \`check_column\` indicating whether \`check_value\` is present in \`check_field\` for each row. >>> data = [ {'name': 'Alice', 'age': 25, 'city': 'New York', 'score': 85}, {'name': 'Bob', 'age': 30, 'city': 'Los Angeles'}, {'name': 'Charlie', 'city': 'Chicago', 'score': 70}, {'name': 'David', 'age': 35, 'score': 92} ] fill_value = 0 check_field = 'city' check_value = 'Chicago' print(analyze_data(data, fill_value, check_field, check_value))","solution":"import pandas as pd from typing import List, Dict, Any def analyze_data(dict_list: List[Dict[str, Any]], fill_value: Any, check_field: str, check_value: Any) -> pd.DataFrame: # Convert list of dictionaries to DataFrame df = pd.DataFrame(dict_list) # Fill in missing values df.fillna(fill_value, inplace=True) # Compute and print mean of each numerical column means = df.mean(numeric_only=True) print(\\"Mean of columns:\\") for column, mean in means.items(): print(f\\"{column}: {mean}\\") # Add new column indicating whether check_value is present in check_field df['check_column'] = df[check_field] == check_value return df"},{"question":"from typing import Optional, List class Node: def __init__(self, data: int, left: 'Optional[Node]' = None, right: 'Optional[Node]' = None): self.data = data self.left = left self.right = right def find_duplicate_subtrees(root: Optional[Node]) -> List[Optional[Node]]: Find all duplicate subtrees in a binary tree. Two subtrees are duplicates if they have same structure and node values. >>> root = Node(1) >>> root.left = Node(2, left=Node(4)) >>> root.right = Node(3, left=Node(2, left=Node(4)), right=Node(4)) >>> duplicates = find_duplicate_subtrees(root) >>> len(duplicates) == 2 True >>> duplicates[0].data == 4 True >>> duplicates[1].data == 2 True","solution":"from typing import Optional, List, Tuple from collections import defaultdict class Node: def __init__(self, data: int, left: 'Optional[Node]' = None, right: 'Optional[Node]' = None): self.data = data self.left = left self.right = right def find_duplicate_subtrees(root: Optional[Node]) -> List[Optional[Node]]: def traverse(node: Optional[Node]): if not node: return \\"#\\" left_serial = traverse(node.left) right_serial = traverse(node.right) serial = f\\"{node.data},{left_serial},{right_serial}\\" trees[serial].append(node) return serial trees = defaultdict(list) traverse(root) return [nodes[0] for nodes in trees.values() if len(nodes) > 1]"},{"question":"def bitwise_and_sum(list1: list[int], list2: list[int]) -> int: Compute the sum of all bitwise AND results for pairs of integers taken from list1 and list2. >>> bitwise_and_sum([1, 2], [3, 4]) 3 >>> bitwise_and_sum([5], [1, 2, 3]) 2 >>> bitwise_and_sum([1023], [512, 256]) 768 >>> bitwise_and_sum([0, 0, 0], [0, 0, 0]) 0 >>> bitwise_and_sum([2, 4, 6], [1, 2, 3]) 8 >>> bitwise_and_sum([1], [1]) 1","solution":"def bitwise_and_sum(list1: list[int], list2: list[int]) -> int: Returns the sum of all bitwise AND computations between pairs of integers from list1 and list2. total_sum = 0 for i in list1: for j in list2: total_sum += i & j return total_sum"},{"question":"from PIL import Image def median_smooth(image: Image) -> Image: Apply median smoothing using a 3x3 kernel to a grayscale image. Parameters: image (Image): A grayscale PIL image object. Returns: Image: A new PIL image with median smoothing applied. from PIL import Image import numpy as np def test_median_smooth_constant_image(): # Create a 5x5 grayscale image with all pixels set to 128 image_data = np.full((5, 5), 128, dtype=np.uint8) image = Image.fromarray(image_data, 'L') smoothed_image = median_smooth(image) # Check that the output image is the same as the input image assert np.array(smoothed_image).tolist() == image_data.tolist() def test_median_smooth_noisy_image(): # Create a 5x5 grayscale image with random noise image_data = np.random.randint(0, 256, (5, 5), dtype=np.uint8) image = Image.fromarray(image_data, 'L') smoothed_image = median_smooth(image) smoothed_image_data = np.array(smoothed_image) # Ensure output image is not exactly the same as input for noisy data assert not np.array_equal(smoothed_image_data, image_data) def test_median_smooth_simple_case(): # Create a custom 3x3 image where the median smoothing is predictable image_data = np.array([[200, 200, 200], [200, 0, 200], [200, 200, 200]], dtype=np.uint8) image = Image.fromarray(image_data, 'L') smoothed_image = median_smooth(image) expected_output = np.array([[200, 200, 200], [200, 200, 200], [200, 200, 200]], dtype=np.uint8) assert np.array(smoothed_image).tolist() == expected_output.tolist() def test_median_smooth_border_handling(): # Create a 3x3 image to check border replication handling image_data = np.array([[50, 50, 50], [50, 100, 50], [50, 50, 50]], dtype=np.uint8) image = Image.fromarray(image_data, 'L') smoothed_image = median_smooth(image) expected_output = np.array([[50, 50, 50], [50, 50, 50], [50, 50, 50]], dtype=np.uint8) assert np.array(smoothed_image).tolist() == expected_output.tolist()","solution":"from PIL import Image import numpy as np def median_smooth(image: Image) -> Image: Apply median smoothing using a 3x3 kernel to a grayscale image. Parameters: image (Image): A grayscale PIL image object. Returns: Image: A new PIL image with median smoothing applied. image_array = np.array(image) padded_image = np.pad(image_array, ((1, 1), (1, 1)), mode='edge') smoothed_image = np.zeros(image_array.shape, dtype=np.uint8) for i in range(1, padded_image.shape[0] - 1): for j in range(1, padded_image.shape[1] - 1): window = padded_image[i-1:i+2, j-1:j+2] smoothed_image[i-1, j-1] = np.median(window) return Image.fromarray(smoothed_image)"},{"question":"def rotate_string(s: str, k: int) -> str: Rotates the string s by k positions to the right. >>> rotate_string(\\"abcdef\\", 2) 'efabcd' >>> rotate_string(\\"abcdef\\", 0) 'abcdef' >>> rotate_string(\\"abcdef\\", 6) 'abcdef' >>> rotate_string(\\"abcdef\\", 8) 'efabcd'","solution":"def rotate_string(s: str, k: int) -> str: Rotates the string s by k positions to the right. if not s: return s n = len(s) k = k % n # Avoid unnecessary full rotations return s[-k:] + s[:-k]"},{"question":"from typing import Tuple def manhattan_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> int: Calculate the Manhattan distance between two points in a 2D space. Args: point1 (tuple): coordinates of the first point (x1, y1) point2 (tuple): coordinates of the second point (x2, y2) Returns: int: the Manhattan distance between the two points Examples: >>> manhattan_distance((1, 2), (4, 6)) 7 >>> manhattan_distance((-3, -4), (3, 4)) 14 >>> manhattan_distance((0, 0), (0, 0)) 0","solution":"from typing import Tuple def manhattan_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> int: Calculate the Manhattan distance between two points in a 2D space. Args: point1 (tuple): coordinates of the first point (x1, y1) point2 (tuple): coordinates of the second point (x2, y2) Returns: int: the Manhattan distance between the two points x1, y1 = point1 x2, y2 = point2 return abs(x1 - x2) + abs(y1 - y2)"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> str: Returns the longest substring with at most \`k\` distinct characters using the simple sliding window approach. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) \\"ece\\" >>> longest_substring_with_k_distinct(\\"aa\\", 1) \\"aa\\" >>> longest_substring_with_k_distinct(\\"aabacbebebe\\", 3) \\"cbebebe\\" >>> longest_substring_with_k_distinct(\\"\\", 2) \\"\\" >>> longest_substring_with_k_distinct(\\"abc\\", 0) \\"\\" pass def longest_substring_with_k_distinct_optimized(s: str, k: int) -> str: Returns the longest substring with at most \`k\` distinct characters using the optimized sliding window approach. >>> longest_substring_with_k_distinct_optimized(\\"eceba\\", 2) \\"ece\\" >>> longest_substring_with_k_distinct_optimized(\\"aa\\", 1) \\"aa\\" >>> longest_substring_with_k_distinct_optimized(\\"aabacbebebe\\", 3) \\"cbebebe\\" >>> longest_substring_with_k_distinct_optimized(\\"\\", 2) \\"\\" >>> longest_substring_with_k_distinct_optimized(\\"abc\\", 0) \\"\\" pass","solution":"def longest_substring_with_k_distinct(s, k): Returns the longest substring with at most \`k\` distinct characters using the simple sliding window approach. if not s or k == 0: return \\"\\" n = len(s) left = 0 right = 0 max_length = 0 max_substr = \\"\\" char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if right - left + 1 > max_length: max_length = right - left + 1 max_substr = s[left:right + 1] right += 1 return max_substr def longest_substring_with_k_distinct_optimized(s, k): Returns the longest substring with at most \`k\` distinct characters using the optimized sliding window approach. if not s or k == 0: return \\"\\" n = len(s) left = 0 right = 0 max_length = 0 max_substr = \\"\\" char_index_map = {} while right < n: char_index_map[s[right]] = right while len(char_index_map) > k: left_most = min(char_index_map.values()) del char_index_map[s[left_most]] left = left_most + 1 if right - left + 1 > max_length: max_length = right - left + 1 max_substr = s[left:right + 1] right += 1 return max_substr"},{"question":"def is_prime(number: int) -> bool: Determine whether the given integer is a prime number. :param number: The integer number to evaluate :return: True if the number is prime, False otherwise Raises: TypeError: If the input is not an integer. ValueError: If the input is a negative number or zero. Examples: >>> is_prime(29) True >>> is_prime(15) False >>> is_prime(2) True >>> is_prime(1) False >>> try: ... is_prime(-5) ... except ValueError as ve: ... print(ve) Number must be a positive integer greater than 1","solution":"def is_prime(number: int) -> bool: Determine whether the given integer is a prime number. :param number: The integer number to evaluate :return: True if the number is prime, False otherwise Raises: TypeError: If the input is not an integer. ValueError: If the input is a negative number or zero. Examples: >>> is_prime(29) True >>> is_prime(15) False >>> is_prime(2) True >>> is_prime(1) False >>> try: ... is_prime(-5) ... except ValueError as ve: ... print(ve) Number must be a positive integer greater than 1 if not isinstance(number, int): raise TypeError(\\"Input must be an integer.\\") if number <= 0: raise ValueError(\\"Number must be a positive integer greater than 1.\\") if number < 2: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True"},{"question":"def calculate_ranks(scores: List[int]) -> List[int]: Determines the rank of each player based on their score. Ties (equal scores) should receive the same rank, with the next available rank skipping accordingly. >>> calculate_ranks([100, 50, 50, 25]) [1, 2, 2, 4] >>> calculate_ranks([60, 70, 70, 30, 100]) [3, 1, 1, 5, 0] pass from typing import List def test_simple_case(): assert calculate_ranks([100, 50, 50, 25]) == [1, 2, 2, 4] def test_no_duplicate_scores(): assert calculate_ranks([60, 70, 30, 100]) == [3, 2, 4, 1] def test_all_same_scores(): assert calculate_ranks([85, 85, 85, 85]) == [1, 1, 1, 1] def test_mixed_scores(): assert calculate_ranks([85, 70, 100, 23]) == [2, 3, 1, 4] def test_empty_list(): assert calculate_ranks([]) == [] def test_single_element_list(): assert calculate_ranks([99]) == [1]","solution":"from typing import List def calculate_ranks(scores: List[int]) -> List[int]: This function returns the ranks of each player in the given list of scores in descending order. sorted_scores = sorted(scores, reverse=True) rank_map = {} rank = 1 for idx, score in enumerate(sorted_scores): if score not in rank_map: rank_map[score] = rank rank += 1 ranks = [rank_map[score] for score in scores] return ranks"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. >>> linked_list_to_list(merge_two_sorted_lists( ... ListNode(1, ListNode(2, ListNode(4))), ... ListNode(1, ListNode(3, ListNode(4))))) == [1, 1, 2, 3, 4, 4] >>> linked_list_to_list(merge_two_sorted_lists(None, ListNode(0))) == [0]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() # Dummy node to simplify edge cases current = dummy # Pointer to build the merged list while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Append the remaining elements of l1 or l2 if l1: current.next = l1 elif l2: current.next = l2 # Return the next node of the dummy node which is the head of the merged list return dummy.next"},{"question":"from typing import List, Tuple def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Parameters: intervals: List[Tuple[int, int]] -> A list of tuples where each tuple contains two integers (start, end) Returns: int -> Maximum number of non-overlapping intervals >>> max_non_overlapping_intervals([(1, 3), (2, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) 3 >>> max_non_overlapping_intervals([(0, 10), (1, 11), (2, 12)]) 1 >>> max_non_overlapping_intervals([(1, 2), (3, 4), (5, 6), (7, 8)]) 4 >>> max_non_overlapping_intervals([]) 0 >>> max_non_overlapping_intervals([(1, 1), (2, 2), (3, 3)]) 3 def test_example_case(): intervals = [(1, 3), (2, 4), (3, 5), (0, 6), (5, 7), (8, 9)] assert max_non_overlapping_intervals(intervals) == 3 def test_no_intervals(): intervals = [] assert max_non_overlapping_intervals(intervals) == 0 def test_single_interval(): intervals = [(0, 1)] assert max_non_overlapping_intervals(intervals) == 1 def test_non_overlapping_intervals(): intervals = [(1, 2), (3, 4), (5, 6), (7, 8)] assert max_non_overlapping_intervals(intervals) == 4 def test_all_overlapping_intervals(): intervals = [(0, 10), (1, 11), (2, 12)] assert max_non_overlapping_intervals(intervals) == 1 def test_partially_overlapping_intervals(): intervals = [(1, 3), (2, 4), (3, 5), (6, 7)] assert max_non_overlapping_intervals(intervals) == 2 def test_intervals_same_start_end(): intervals = [(1, 1), (2, 2), (3, 3)] assert max_non_overlapping_intervals(intervals) == 3 def test_large_range_intervals(): intervals = [(0, 1000), (1001, 2000), (2001, 3000), (3001, 4000)] assert max_non_overlapping_intervals(intervals) == 4","solution":"from typing import List, Tuple def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Parameters: intervals: List[Tuple[int, int]] -> A list of tuples where each tuple contains two integers (start, end) Returns: int -> Maximum number of non-overlapping intervals if not intervals: return 0 # Sort intervals based on ending times intervals.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping intervals count = 0 current_end = -1 for interval in intervals: start, end = interval if start > current_end: # Select this interval count += 1 current_end = end return count"},{"question":"def anonymize_csv(input_file: str, output_file: str, columns_to_anonymize: List[str]) -> None: Anonymizes specified columns in a CSV file by hashing their values. Parameters: input_file (str): Path to the input CSV file. output_file (str): Path to the output CSV file. columns_to_anonymize (List[str]): List of column names to be anonymized. Example usage: >>> anonymize_csv('data.csv', 'anonymized_data.csv', ['email', 'phone_number']) # The output file 'anonymized_data.csv' will have its 'email' and 'phone_number' columns anonymized. import csv import hashlib from typing import List def setup_csv_file(filename: str, rows: List[dict], fieldnames: List[str]): with open(filename, mode='w', newline='') as file: writer = csv.DictWriter(file, fieldnames=fieldnames) writer.writeheader() writer.writerows(rows) def teardown_csv_file(filename: str): if os.path.exists(filename): os.remove(filename) def test_anonymize_csv_basic(): input_file = 'test_input.csv' output_file = 'test_output.csv' rows = [ {\\"name\\": \\"Alice\\", \\"email\\": \\"alice@example.com\\", \\"phone\\": \\"12345\\"}, {\\"name\\": \\"Bob\\", \\"email\\": \\"bob@example.com\\", \\"phone\\": \\"67890\\"} ] fieldnames = [\\"name\\", \\"email\\", \\"phone\\"] setup_csv_file(input_file, rows, fieldnames) columns_to_anonymize = [\\"email\\", \\"phone\\"] anonymize_csv(input_file, output_file, columns_to_anonymize) with open(output_file, mode='r') as file: reader = csv.DictReader(file) for row in reader: assert row['name'] in [\\"Alice\\", \\"Bob\\"] assert len(row['email']) == 64 # Length of SHA-256 hash assert len(row['phone']) == 64 # Length of SHA-256 hash teardown_csv_file(input_file) teardown_csv_file(output_file) def test_anonymize_csv_missing_columns(): input_file = 'test_missing_columns_input.csv' output_file = 'test_missing_columns_output.csv' rows = [ {\\"name\\": \\"Charlie\\", \\"email\\": \\"charlie@example.com\\"}, {\\"name\\": \\"David\\"} ] fieldnames = [\\"name\\", \\"email\\"] setup_csv_file(input_file, rows, fieldnames) columns_to_anonymize = [\\"email\\", \\"phone\\"] anonymize_csv(input_file, output_file, columns_to_anonymize) with open(output_file, mode='r') as file: reader = csv.DictReader(file) for row in reader: assert row['name'] in [\\"Charlie\\", \\"David\\"] if row['name'] == \\"Charlie\\": assert len(row['email']) == 64 # Length of SHA-256 hash else: assert 'email' not in row or row['email'] == '' teardown_csv_file(input_file) teardown_csv_file(output_file) def test_anonymize_csv_empty_cells(): input_file = 'test_empty_cells_input.csv' output_file = 'test_empty_cells_output.csv' rows = [ {\\"name\\": \\"Eve\\", \\"email\\": \\"\\", \\"phone\\": \\"54321\\"}, {\\"name\\": \\"Frank\\", \\"email\\": \\"frank@example.com\\", \\"phone\\": \\"\\"} ] fieldnames = [\\"name\\", \\"email\\", \\"phone\\"] setup_csv_file(input_file, rows, fieldnames) columns_to_anonymize = [\\"email\\", \\"phone\\"] anonymize_csv(input_file, output_file, columns_to_anonymize) with open(output_file, mode='r') as file: reader = csv.DictReader(file) for row in reader: assert row['name'] in [\\"Eve\\", \\"Frank\\"] if row['email']: assert len(row['email']) == 64 # Length of SHA-256 hash if row['phone']: assert len(row['phone']) == 64 # Length of SHA-256 hash teardown_csv_file(input_file) teardown_csv_file(output_file)","solution":"import csv import hashlib from typing import List def anonymize_csv(input_file: str, output_file: str, columns_to_anonymize: List[str]) -> None: Anonymizes specified columns in a CSV file by hashing their values. Parameters: input_file (str): Path to the input CSV file. output_file (str): Path to the output CSV file. columns_to_anonymize (List[str]): List of column names to be anonymized. with open(input_file, mode='r') as infile, open(output_file, mode='w', newline='') as outfile: reader = csv.DictReader(infile) writer = csv.DictWriter(outfile, fieldnames=reader.fieldnames) writer.writeheader() for row in reader: for column in columns_to_anonymize: if column in row and row[column]: # Hash the value of the column row[column] = hashlib.sha256(row[column].encode('utf-8')).hexdigest() writer.writerow(row)"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix by 90 degrees clockwise. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1]]) [[1]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> rotate_matrix([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) [[-7, -4, -1], [-8, -5, -2], [-9, -6, -3]]","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix by 90 degrees clockwise. N = len(matrix) rotated = [[0]*N for _ in range(N)] for i in range(N): for j in range(N): rotated[j][N-1-i] = matrix[i][j] return rotated"},{"question":"from typing import List, Tuple def find_pair_with_sum(arr: List[int], target: int) -> Tuple[int, int]: Finds two distinct elements in arr that sum up to target. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: tuple: A tuple of two integers that add up to the target sum if such a pair exists, otherwise an empty tuple. Example: >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([3, 2, 4], 6) (2, 4) >>> find_pair_with_sum([3, 3], 6) (3, 3) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) ()","solution":"from typing import List, Tuple def find_pair_with_sum(arr: List[int], target: int) -> Tuple[int, int]: Finds two distinct elements in arr that sum up to target. Parameters: arr (list of int): The array of integers. target (int): The target sum. Returns: tuple: A tuple of two integers that add up to the target sum if such a pair exists, otherwise an empty tuple. seen = {} for num in arr: complement = target - num if complement in seen: return (min(num, complement), max(num, complement)) seen[num] = True return ()"},{"question":"def sorted_unique_chars(input_str: str) -> list: Returns a list of unique alphabetic characters in alphabetical order. The function is case-insensitive and only includes alphabetic characters. >>> sorted_unique_chars(\\"Hello, World!\\") ['d', 'e', 'h', 'l', 'o', 'r', 'w'] >>> sorted_unique_chars(\\"12345\\") [] >>> sorted_unique_chars(\\"\\") [] >>> sorted_unique_chars(\\"Zebra123Apple!!\\") ['a', 'b', 'e', 'l', 'p', 'r', 'z'] >>> sorted_unique_chars(\\"PythonProgramming\\") ['a', 'g', 'h', 'i', 'm', 'n', 'o', 'p', 'r', 't', 'y']","solution":"def sorted_unique_chars(input_str: str) -> list: Returns a list of unique alphabetic characters in alphabetical order. The function is case-insensitive and only includes alphabetic characters. # Keep only alphabetic characters and convert to lowercase alphabets = [char.lower() for char in input_str if char.isalpha()] # Get unique characters and sort them return sorted(set(alphabets))"},{"question":"import requests def fetch_environmental_data(city: str) -> dict: Fetch environmental data for a given city from an open API. Args: city (str): The name of the city. Returns: dict: Raw environmental data or an error message if the fetch fails. pass def analyze_environmental_data(data: dict) -> dict: Analyze the raw environmental data. Args: data (dict): Raw environmental data. Returns: dict: Analyzed data including average temperature, humidity, air quality index, main pollutant, and recommended precautions. pass def test_fetch_environmental_data_valid_city(monkeypatch): class MockResponse: @staticmethod def json(): return {\\"temperature\\": [20, 21, 19], \\"humidity\\": [65, 66, 64], \\"air_quality\\": {\\"aqi\\": 42, \\"pollutant\\": \\"PM2.5\\"}} @staticmethod def raise_for_status(): pass def mock_get(*args, **kwargs): return MockResponse() monkeypatch.setattr(requests, \\"get\\", mock_get) result = fetch_environmental_data(\\"ValidCity\\") assert result == {\\"temperature\\": [20, 21, 19], \\"humidity\\": [65, 66, 64], \\"air_quality\\": {\\"aqi\\": 42, \\"pollutant\\": \\"PM2.5\\"}} def test_fetch_environmental_data_invalid_city(): result = fetch_environmental_data(\\"123InvalidCity\\") assert result == {\\"error\\": \\"Invalid city name\\"} def test_fetch_environmental_data_request_exception(monkeypatch): def mock_get(*args, **kwargs): raise requests.exceptions.RequestException(\\"Error fetching data\\") monkeypatch.setattr(requests, \\"get\\", mock_get) result = fetch_environmental_data(\\"ValidCity\\") assert result == {\\"error\\": \\"Error fetching data\\"} def test_analyze_environmental_data_complete(): raw_data = {\\"temperature\\": [20, 21, 19], \\"humidity\\": [65, 66, 64], \\"air_quality\\": {\\"aqi\\": 42, \\"pollutant\\": \\"PM2.5\\"}} result = analyze_environmental_data(raw_data) assert result == { \\"Average Temperature\\": \\"20.0°C\\", \\"Average Humidity\\": \\"65.0%\\", \\"Air Quality Index\\": 42, \\"Main Pollutant\\": \\"PM2.5\\", \\"Recommended Precautions\\": \\"No precautions needed.\\" } def test_analyze_environmental_data_with_error(): raw_data = {\\"error\\": \\"Invalid city name\\"} result = analyze_environmental_data(raw_data) assert result == {\\"error\\": \\"Invalid city name\\"} def test_analyze_environmental_data_missing_fields(): raw_data = {\\"temperature\\": [], \\"humidity\\": [], \\"air_quality\\": {}} result = analyze_environmental_data(raw_data) assert result == { \\"Average Temperature\\": \\"No data\\", \\"Average Humidity\\": \\"No data\\", \\"Air Quality Index\\": \\"No data\\", \\"Main Pollutant\\": \\"Unknown\\", \\"Recommended Precautions\\": \\"No data available\\" }","solution":"import requests def fetch_environmental_data(city: str) -> dict: Fetch environmental data for a given city from an open API. Args: - city (str): The name of the city. Returns: - dict: Raw environmental data or an error message if the fetch fails. if not isinstance(city, str) or not city.replace(\\" \\", \\"\\").isalpha(): return {\\"error\\": \\"Invalid city name\\"} api_url = f\\"http://example.com/environmental_data?city={city}\\" try: response = requests.get(api_url) response.raise_for_status() return response.json() except requests.exceptions.RequestException as e: return {\\"error\\": str(e)} def analyze_environmental_data(data: dict) -> dict: Analyze the raw environmental data. Args: - data (dict): Raw environmental data. Returns: - dict: Analyzed data including average temperature, humidity, air quality index, main pollutant, and recommended precautions. if \\"error\\" in data: return data temperature_data = data.get(\\"temperature\\", []) humidity_data = data.get(\\"humidity\\", []) air_quality_data = data.get(\\"air_quality\\", {}) def calculate_average(values): if not values: return None return sum(values) / len(values) average_temperature = calculate_average(temperature_data) average_humidity = calculate_average(humidity_data) aqi = air_quality_data.get(\\"aqi\\", None) main_pollutant = air_quality_data.get(\\"pollutant\\", \\"Unknown\\") precautions = \\"No data available\\" if aqi is not None: if aqi <= 50: precautions = \\"No precautions needed.\\" elif 51 <= aqi <= 100: precautions = \\"Consider reducing prolonged outdoor exertion.\\" elif 101 <= aqi <= 150: precautions = \\"Avoid prolonged outdoor exertion. Sensitive groups should limit outdoor activity.\\" else: precautions = \\"Avoid all outdoor exertion. Sensitive groups stay indoors.\\" return { \\"Average Temperature\\": f\\"{average_temperature:.1f}°C\\" if average_temperature is not None else \\"No data\\", \\"Average Humidity\\": f\\"{average_humidity:.1f}%\\" if average_humidity is not None else \\"No data\\", \\"Air Quality Index\\": aqi if aqi is not None else \\"No data\\", \\"Main Pollutant\\": main_pollutant, \\"Recommended Precautions\\": precautions }"},{"question":"from collections import deque class BinaryTreeNode: def __init__(self, value: int = 0, left: 'BinaryTreeNode' = None, right: 'BinaryTreeNode' = None): self.value = value self.left = left self.right = right def level_order_traversal(root: None | BinaryTreeNode) -> list[int]: Perform a level-order traversal (breadth-first traversal) on a binary tree and return a list of values of the nodes in the order they are visited. >>> root1 = BinaryTreeNode(1) >>> root1.left = BinaryTreeNode(2) >>> root1.right = BinaryTreeNode(3) >>> root1.left.left = BinaryTreeNode(4) >>> root1.left.right = BinaryTreeNode(5) >>> level_order_traversal(root1) [1, 2, 3, 4, 5] >>> root2 = BinaryTreeNode(1) >>> root2.left = BinaryTreeNode(2) >>> root2.right = BinaryTreeNode(3) >>> root2.left.right = BinaryTreeNode(4) >>> level_order_traversal(root2) [1, 2, 3, 4] >>> level_order_traversal(None) []","solution":"from collections import deque class BinaryTreeNode: def __init__(self, value: int = 0, left: 'BinaryTreeNode' = None, right: 'BinaryTreeNode' = None): self.value = value self.left = left self.right = right def level_order_traversal(root: None or BinaryTreeNode) -> list[int]: if not root: return [] result = [] queue = deque([root]) while queue: node = queue.popleft() result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"def max_rectangle_area(towers: list) -> int: Find the largest rectangle area that can be formed in the skyline using consecutive towers. Parameters: towers (list of int): A list of positive integers representing the heights of the towers. Returns: int: The area of the largest rectangle that can be formed using consecutive towers. >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([3, 1, 3, 2, 2]) 6 >>> max_rectangle_area([5, 5, 5, 5, 5]) 25 >>> max_rectangle_area([5]) 5 >>> max_rectangle_area([2, 4]) 4 >>> max_rectangle_area([]) 0 >>> max_rectangle_area([10000] * 100000) 1000000000","solution":"def max_rectangle_area(towers: list) -> int: Returns the maximum rectangle area that can be formed in the skyline using consecutive towers. def largestRectangleArea(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area return largestRectangleArea(towers)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Reverse a singly linked list. Args: head (ListNode): The head node of the linked list. Returns: ListNode: The head node of the reversed linked list. Examples: >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> reversed_head = reverse_linked_list(head) >>> linkedlist_to_list(reversed_head) [5, 4, 3, 2, 1] >>> head = list_to_linkedlist([]) >>> reversed_head = reverse_linked_list(head) >>> linkedlist_to_list(reversed_head) [] >>> head = list_to_linkedlist([7, 8]) >>> reversed_head = reverse_linked_list(head) >>> linkedlist_to_list(reversed_head) [8, 7]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: prev = None curr = head while curr: next_temp = curr.next # store next node curr.next = prev # reverse the link prev = curr # move prev pointer up curr = next_temp # move curr pointer up return prev # prev will be the new head at the end of the loop"},{"question":"def search_in_rotated_array(nums: list[int], target: int) -> int: Function to search for a target number in a rotated sorted array. Returns the index of the target number if it is found, otherwise returns -1. >>> search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) 4 >>> search_in_rotated_array([1, 2, 3, 4, 5], 6) -1 >>> search_in_rotated_array([], 1) -1 >>> search_in_rotated_array([1], 1) 0 >>> search_in_rotated_array([-4, -3, -7, -6, -5], -7) 2","solution":"def search_in_rotated_array(nums, target): Function to search for a target in a rotated sorted array. Returns the index of the target if found, otherwise returns -1. if not nums: return -1 low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] == target: return mid # Determine which part is sorted if nums[low] <= nums[mid]: if nums[low] <= target < nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] < target <= nums[high]: low = mid + 1 else: high = mid - 1 return -1 # Time Complexity Discussion: # The time complexity of this approach is O(log n) due to the binary search algorithm. # This is efficient for large input sizes up to 10^5 elements, # as the search space is halved in each iteration."},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: Binary Search Tree (BST) Implementation and Operations This class provides methods to: - Insert a value into the BST. - Find a value in the BST. - Find the minimum value in the BST. - Find the maximum value in the BST. - Return an inorder traversal of the BST. def __init__(self): Initializes an empty Binary Search Tree. self.root = None def insert(self, value): Inserts a value into the BST while maintaining the BST properties. Args: value: An integer to be added to the BST. Returns: None pass def find(self, value): Returns True if the value exists in the BST, otherwise returns False. Args: value: An integer to search for in the BST. Returns: A boolean indicating the presence of value. pass def find_min(self): Returns the minimum value in the BST. Returns: The minimum integer value in the BST or None if the tree is empty. pass def find_max(self): Returns the maximum value in the BST. Returns: The maximum integer value in the BST or None if the tree is empty. pass def inorder_traversal(self): Returns a list of all values in the BST, sorted in ascending order. Returns: A list of integers in ascending order. pass def test_insert_and_find(): bst = BinarySearchTree() assert bst.find(10) == False bst.insert(10) assert bst.find(10) == True assert bst.find(5) == False def test_find_min_max_empty_tree(): bst = BinarySearchTree() assert bst.find_min() == None assert bst.find_max() == None def test_find_min(): bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(20) assert bst.find_min() == 5 def test_find_max(): bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(20) assert bst.find_max() == 20 def test_inorder_traversal(): bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(1) bst.insert(7) assert bst.inorder_traversal() == [1, 5, 7, 10, 20] def test_additional_operations(): bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(1) bst.insert(7) bst.insert(15) assert bst.find_min() == 1 assert bst.find_max() == 20 assert bst.find(15) == True assert bst.find(17) == False assert bst.inorder_traversal() == [1, 5, 7, 10, 15, 20] def test_insert_duplicates(): bst = BinarySearchTree() bst.insert(10) bst.insert(10) # insert duplicate assert bst.inorder_traversal() == [10] def test_single_element_operations(): bst = BinarySearchTree() bst.insert(10) assert bst.find(10) == True assert bst.find_min() == 10 assert bst.find_max() == 10 assert bst.inorder_traversal() == [10]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): Inserts a value into the BST. if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) elif value > node.value: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def find(self, value): Returns True if the value exists in the BST, otherwise returns False. return self._find(self.root, value) def _find(self, node, value): if node is None: return False if value == node.value: return True elif value < node.value: return self._find(node.left, value) else: return self._find(node.right, value) def find_min(self): Returns the minimum value in the BST. if self.root is None: return None return self._find_min(self.root).value def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): Returns the maximum value in the BST. if self.root is None: return None return self._find_max(self.root).value def _find_max(self, node): current = node while current.right is not None: current = current.right return current def inorder_traversal(self): Returns a list of all values in the BST sorted in ascending order. result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node is not None: self._inorder_traversal(node.left, result) result.append(node.value) self._inorder_traversal(node.right, result)"},{"question":"class MyCircularDeque: Implement a Circular Deque using a Python list. This data structure supports standard deque operations efficiently, including the ability to wrap around and make use of the circular nature of the structure. Function Signatures: 1. __init__(self, k: int) -> None: Initialize the deque with a fixed size \`k\`. 2. insertFront(self, value: int) -> bool: Add an item at the front of the Deque. Return True if the operation is successful, or False if the deque is full. 3. insertLast(self, value: int) -> bool: Add an item at the rear of the Deque. Return True if the operation is successful, or False if the deque is full. 4. deleteFront(self) -> bool: Delete an item from the front of the Deque. Return True if the operation is successful, or False if the deque is empty. 5. deleteLast(self) -> bool: Delete an item from the rear of the Deque. Return True if the operation is successful, or False if the deque is empty. 6. getFront(self) -> int: Get the front item from the deque. Return -1 if the deque is empty. 7. getRear(self) -> int: Get the last item from the deque. Return -1 if the deque is empty. 8. isEmpty(self) -> bool: Check whether the deque is empty. 9. isFull(self) -> bool: Check whether the deque is full. def __init__(self, k: int) -> None: pass def insertFront(self, value: int) -> bool: pass def insertLast(self, value: int) -> bool: pass def deleteFront(self) -> bool: pass def deleteLast(self) -> bool: pass def getFront(self) -> int: pass def getRear(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass # Test Cases if __name__ == \\"__main__\\": dq = MyCircularDeque(3) assert dq.insertLast(1) == True assert dq.insertLast(2) == True assert dq.insertFront(3) == True assert dq.insertFront(4) == False assert dq.getRear() == 2 assert dq.isFull() == True assert dq.deleteLast() == True assert dq.insertFront(4) == True assert dq.getFront() == 4","solution":"class MyCircularDeque: def __init__(self, k: int) -> None: self.size = k self.deque = [0] * k self.front = -1 self.rear = -1 self.count = 0 def insertFront(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.front = (self.front - 1) % self.size self.deque[self.front] = value self.count += 1 return True def insertLast(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = self.rear = 0 else: self.rear = (self.rear + 1) % self.size self.deque[self.rear] = value self.count += 1 return True def deleteFront(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size self.count -= 1 return True def deleteLast(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = self.rear = -1 else: self.rear = (self.rear - 1 + self.size) % self.size self.count -= 1 return True def getFront(self) -> int: if self.isEmpty(): return -1 return self.deque[self.front] def getRear(self) -> int: if self.isEmpty(): return -1 return self.deque[self.rear] def isEmpty(self) -> bool: return self.count == 0 def isFull(self) -> bool: return self.count == self.size"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self): Perform a level order traversal (breadth-first traversal) of the binary tree. Returns a list of lists, where each list contains the values of the nodes at each level. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> tree = BinaryTree(root) >>> tree.level_order_traversal() [[1], [2, 3], [4, 5, 6, 7]] # Your implementation goes here","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self): if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_length = queue.__len__() current_level = [] for _ in range(level_length): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"import re def count_matching_pairs(s: str) -> int: Given a string \`s\` representing a valid XML-like structure, this function returns the number of pairs of matching opening and closing tags within the string. >>> count_matching_pairs(\\"<a><b></b><c></c></a>\\") 3 >>> count_matching_pairs(\\"<a></a><b></b>\\") 2","solution":"import re def count_matching_pairs(s: str) -> int: Returns the number of pairs of matching opening and closing tags in the given string. tag_pattern = re.compile(r'</?([a-zA-Z0-9]+)>') stack = [] count = 0 for match in tag_pattern.finditer(s): tag = match.group(1) if match.group(0).startswith('</'): if stack and stack[-1] == tag: stack.pop() count += 1 else: stack.append(tag) return count"},{"question":"from typing import List, Tuple def custom_sort(files: List[Tuple[str, int]]) -> List[str]: Implement a custom sort function to sort files based on their priority scores. Args: files (List[Tuple[str, int]]): A list of tuples, where each tuple contains a file name and its associated priority score. Returns: List[str]: A list of file names sorted in ascending order of their priority scores. Examples: >>> custom_sort([('file1', 3), ('file2', 1), ('file3', 2)]) ['file2', 'file3', 'file1'] >>> custom_sort([('red', 10), ('blue', -5), ('green', 0), ('yellow', 0)]) ['blue', 'green', 'yellow', 'red'] >>> custom_sort([]) []","solution":"from typing import List, Tuple def custom_sort(files: List[Tuple[str, int]]) -> List[str]: if not files: return [] def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i][1] <= right[j][1]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list sorted_files = merge_sort(files) return [file_name for file_name, _ in sorted_files]"},{"question":"def sum_pascals_triangle_row(n: int) -> int: Calculates the sum of the elements in the n-th row of Pascal's Triangle. The sum of the elements in the n-th row of Pascal's Triangle is always 2^n. :param n: Non-negative integer representing the row number. :return: Sum of the elements in the n-th row of Pascal's Triangle. >>> sum_pascals_triangle_row(3) 8 >>> sum_pascals_triangle_row(5) 32","solution":"def sum_pascals_triangle_row(n: int) -> int: Calculates the sum of the elements in the n-th row of Pascal's Triangle. The sum of the elements in the n-th row of Pascal's Triangle is always 2^n. :param n: Non-negative integer representing the row number. :return: Sum of the elements in the n-th row of Pascal's Triangle. return 2 ** n"},{"question":"def favorite_substring_count(melody: str, favorites: List[str]) -> List[int]: Counts the number of times each favorite substring appears in the melody. >>> favorite_substring_count(\\"abracadabra\\", [\\"abra\\", \\"cad\\", \\"br\\"]) == [2, 1, 1] >>> favorite_substring_count(\\"abababab\\", [\\"ab\\", \\"ba\\", \\"abab\\", \\"baba\\"]) == [4, 3, 3, 2] pass # Example usage: assert favorite_substring_count(\\"abracadabra\\", [\\"abra\\", \\"cad\\", \\"br\\"]) == [2, 1, 1] assert favorite_substring_count(\\"abababab\\", [\\"ab\\", \\"ba\\", \\"abab\\", \\"baba\\"]) == [4, 3, 3, 2] def test_single_occurrence(): assert favorite_substring_count(\\"abracadabra\\", [\\"cad\\"]) == [1] def test_multiple_occurrences(): assert favorite_substring_count(\\"abracadabra\\", [\\"abra\\", \\"abr\\"]) == [2, 2] def test_no_occurrences(): assert favorite_substring_count(\\"abracadabra\\", [\\"xyz\\"]) == [0] def test_overlapping_occurrences(): assert favorite_substring_count(\\"aaaaa\\", [\\"aa\\"]) == [4] def test_varied_occurrences(): assert favorite_substring_count(\\"abababab\\", [\\"ab\\", \\"ba\\", \\"abab\\", \\"baba\\"]) == [4, 3, 3, 2] def test_empty_melody(): assert favorite_substring_count(\\"\\", [\\"a\\", \\"b\\"]) == [0, 0] def test_empty_favorites(): assert favorite_substring_count(\\"abracadabra\\", []) == [] def test_non_overlapping_long_substring(): assert favorite_substring_count(\\"abcabcabc\\", [\\"abcabc\\"]) == [2]","solution":"def favorite_substring_count(melody, favorites): Counts the number of times each favorite substring appears in the melody. Parameters: melody (str): The string in which to search for favorite substrings. favorites (List[str]): The list of favorite substrings to count in the melody. Returns: List[int]: A list of integers where each integer is the count of appearances of the corresponding favorite substring. result = [] for favorite in favorites: count = 0 pos = melody.find(favorite) while pos != -1: count += 1 pos = melody.find(favorite, pos + 1) result.append(count) return result"},{"question":"from typing import List def calculate_median_session_time(session_times: List[int]) -> float: Calculate the median session time from a list of session times in seconds. :param session_times: List[int] - list of session times in seconds :return: float - median session time >>> calculate_median_session_time([30, 60, 45, 90, 120]) 60.0 >>> calculate_median_session_time([15, 45, 60, 30]) 37.5 import pytest from solution import calculate_median_session_time def test_odd_number_of_elements(): assert calculate_median_session_time([30, 60, 45, 90, 120]) == 60.0 def test_even_number_of_elements(): assert calculate_median_session_time([15, 45, 60, 30]) == 37.5 def test_single_element(): assert calculate_median_session_time([50]) == 50.0 def test_two_elements(): assert calculate_median_session_time([40, 20]) == 30.0 def test_large_dataset(): data = list(range(1000000, 2000000)) assert calculate_median_session_time(data) == 1499999.5 def test_mixed_values(): assert calculate_median_session_time([15, 30, 60, 10, 25, 50]) == 27.5 def test_all_identical_values(): assert calculate_median_session_time([20, 20, 20, 20, 20]) == 20.0 def test_large_identical_values(): data = [10**6] * 10**6 assert calculate_median_session_time(data) == float(10**6) if __name__ == \\"__main__\\": pytest.main()","solution":"from typing import List def calculate_median_session_time(session_times: List[int]) -> float: Calculate the median session time from a list of session times in seconds. :param session_times: List[int] - list of session times in seconds :return: float - median session time # Sort the session times session_times.sort() n = len(session_times) # Calculate the median based on the length being odd or even if n % 2 == 1: median = float(session_times[n // 2]) else: median = (session_times[n // 2 - 1] + session_times[n // 2]) / 2.0 return median"},{"question":"class Matrix2D: A class to represent a 2D matrix and provide basic matrix operations. Example usage: >>> m1 = Matrix2D([[1, 2], [3, 4]]) >>> m2 = Matrix2D([[5, 6], [7, 8]]) >>> m1.add(m2).matrix [[6, 8], [10, 12]] >>> m1.multiply(m2).matrix [[19, 22], [43, 50]] >>> m1.transpose().matrix [[1, 3], [2, 4]] def __init__(self, matrix): self.matrix = matrix def add(self, other): pass # To be implemented def multiply(self, other): pass # To be implemented def transpose(self): pass # To be implemented","solution":"class Matrix2D: def __init__(self, matrix): self.matrix = matrix def add(self, other): if len(self.matrix) != len(other.matrix) or len(self.matrix[0]) != len(other.matrix[0]): raise ValueError(\\"Matrices do not have the same dimensions for addition.\\") result = [ [self.matrix[i][j] + other.matrix[i][j] for j in range(len(self.matrix[0]))] for i in range(len(self.matrix)) ] return Matrix2D(result) def multiply(self, other): if len(self.matrix[0]) != len(other.matrix): raise ValueError(\\"Matrices are not compatible for multiplication.\\") result = [ [ sum(self.matrix[i][k] * other.matrix[k][j] for k in range(len(other.matrix))) for j in range(len(other.matrix[0])) ] for i in range(len(self.matrix)) ] return Matrix2D(result) def transpose(self): result = [ [self.matrix[j][i] for j in range(len(self.matrix))] for i in range(len(self.matrix[0])) ] return Matrix2D(result)"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(head1: ListNode, head2: ListNode) -> ListNode: Determines the intersection point of two linked lists and returns the intersection node. If there is no intersection, returns None. Example: # Example 1 >>> node4 = ListNode(4) >>> node3 = ListNode(3, node4) >>> node2 = ListNode(2, node3) >>> node1 = ListNode(1, node2) >>> head1 = node1 >>> node7 = ListNode(7, node3) >>> node6 = ListNode(6, node7) >>> head2 = node6 >>> get_intersection_node(head1, head2) == node3 # Example 2 >>> node4 = ListNode(4) >>> node2 = ListNode(2, node4) >>> node1 = ListNode(1, node2) >>> node9 = ListNode(9, node1) >>> head1 = ListNode(1, node9) >>> head2 = ListNode(3, node2) >>> get_intersection_node(head1, head2) == node2 # Example 3 >>> node4 = ListNode(4) >>> node6 = ListNode(6, node4) >>> head1 = ListNode(2, node6) >>> node5 = ListNode(5) >>> head2 = ListNode(1, node5) >>> get_intersection_node(head1, head2) is None","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def get_intersection_node(head1: ListNode, head2: ListNode) -> ListNode: Determines the intersection point of two linked lists and returns the intersection node. If there is no intersection, returns None. # Get the length of both linked lists def get_length(head: ListNode) -> int: length = 0 current = head while current: length += 1 current = current.next return length len1 = get_length(head1) len2 = get_length(head2) # Align both linked lists by skipping the extra nodes current1, current2 = head1, head2 if len1 > len2: for _ in range(len1 - len2): current1 = current1.next else: for _ in range(len2 - len1): current2 = current2.next # Traverse both lists together to find the intersection while current1 and current2: if current1 == current2: return current1 current1 = current1.next current2 = current2.next return None"},{"question":"from typing import List def top_k_frequent_items(items: List[str], k: int) -> List[str]: Returns the top k most frequently occurring items in the list according to the criteria of frequency and lexicographical order. :param items: List of strings representing the items. :type items: List[str] :param k: Number of top frequent items to return. :type k: int :return: List of top k frequent items sorted based on the criteria. :rtype: List[str] Example: >>> top_k_frequent_items([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\", \\"grape\\", \\"orange\\", \\"apple\\"], 2) ['apple', 'banana'] >>> top_k_frequent_items([\\"car\\", \\"truck\\", \\"car\\", \\"bike\\", \\"truck\\", \\"car\\", \\"bike\\", \\"plane\\"], 3) ['car', 'bike', 'truck']","solution":"from typing import List from collections import Counter def top_k_frequent_items(items: List[str], k: int) -> List[str]: Returns the top k most frequently occurring items in the list. :param items: List of strings representing the items. :type items: List[str] :param k: Number of top frequent items to return. :type k: int :return: List of top k frequent items sorted based on the criteria. :rtype: List[str] # Count the frequency of each item item_counts = Counter(items) # Get the items sorted by frequency and lexicographical order sorted_items = sorted(item_counts.keys(), key=lambda x: (-item_counts[x], x)) # Get the top k items return sorted_items[:k]"},{"question":"def rotate_matrix_layer_by_layer(matrix: list[list[int]]) -> list[list[int]]: Rotates the given n x n matrix 90 degrees clockwise layer by layer. Parameters: - matrix (list[list[int]]): A 2D list of integers representing the matrix to be rotated. Returns: - list[list[int]]: A 2D list representing the matrix after rotating it 90 degrees clockwise. Constraints: - The matrix must be a square (n x n). - The function should rotate the matrix layer by layer in-place. >>> rotate_matrix_layer_by_layer([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_layer_by_layer([ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ]) [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] >>> rotate_matrix_layer_by_layer([[1]]) [[1]]","solution":"def rotate_matrix_layer_by_layer(matrix): Rotates the given n x n matrix 90 degrees clockwise layer by layer. Parameters: - matrix (list[list[int]]): A 2D list of integers representing the matrix to be rotated. Returns: - list[list[int]]: A 2D list representing the matrix after rotating it 90 degrees clockwise. if not all(isinstance(row, list) and all(isinstance(elem, int) for elem in row) for row in matrix): raise ValueError(\\"The matrix must be a 2D list of integers.\\") n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be a square matrix.\\") for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = matrix[first][i] matrix[first][i] = matrix[last - offset][first] matrix[last - offset][first] = matrix[last][last - offset] matrix[last][last - offset] = matrix[i][last] matrix[i][last] = top return matrix"},{"question":"from typing import List, Tuple longest_common_prefix(transactions: List[Tuple[str, float]], initial_balance: float) -> List[float] This function calculates the balance of an account after each transaction is applied. Parameters: transactions (List[Tuple[str, float]]): A list of tuples where each tuple consists of a transaction type ('deposit' or 'withdraw') and a transaction amount (float). initial_balance (float): The starting balance of the account. Returns: List[float]: A list of balances after each transaction is applied. calculate_balance(transactions: List[Tuple[str, float]], initial_balance: float) -> float This function calculates the final account balance after all transactions have been applied. Parameters: transactions (List[Tuple[str, float]]): A list of tuples where each tuple consists of a transaction type ('deposit' or 'withdraw') and a transaction amount (float). initial_balance (float): The starting balance of the account. Returns: float: The final account balance after all transactions have been applied. def apply_transactions(transactions: List[Tuple[str, float]], initial_balance: float) -> List[float]: balances = [] current_balance = initial_balance for transaction in transactions: transaction_type, amount = transaction if transaction_type == \\"deposit\\": current_balance += amount elif transaction_type == \\"withdraw\\": if current_balance >= amount: current_balance -= amount balances.append(current_balance) return balances def calculate_balance(transactions: List[Tuple[str, float]], initial_balance: float) -> float: current_balance = initial_balance for transaction in transactions: transaction_type, amount = transaction if transaction_type == \\"deposit\\": current_balance += amount elif transaction_type == \\"withdraw\\": if current_balance >= amount: current_balance -= amount return current_balance","solution":"from typing import List, Tuple def apply_transactions(transactions: List[Tuple[str, float]], initial_balance: float) -> List[float]: balances = [] current_balance = initial_balance for transaction in transactions: transaction_type, amount = transaction if transaction_type == \\"deposit\\": current_balance += amount elif transaction_type == \\"withdraw\\": if current_balance >= amount: current_balance -= amount balances.append(current_balance) return balances def calculate_balance(transactions: List[Tuple[str, float]], initial_balance: float) -> float: current_balance = initial_balance for transaction in transactions: transaction_type, amount = transaction if transaction_type == \\"deposit\\": current_balance += amount elif transaction_type == \\"withdraw\\": if current_balance >= amount: current_balance -= amount return current_balance"},{"question":"def analyze_stock_prices(prices: list[int]) -> dict: Analyze a sequence of numbers representing daily stock prices to provide insights on the best days to buy and sell stock for maximum profit. Args: prices : list[int] : A list of integers representing daily stock prices. Returns: dict: A dictionary containing: - 'buy_day': The day (index) to buy the stock. - 'sell_day': The day (index) to sell the stock. - 'max_profit': The maximum profit obtainable. Examples: >>> analyze_stock_prices([7, 1, 5, 3, 6, 4]) {'buy_day': 1, 'sell_day': 4, 'max_profit': 5} >>> analyze_stock_prices([7, 6, 4, 3, 1]) {'buy_day': -1, 'sell_day': -1, 'max_profit': 0} >>> analyze_stock_prices([1, 2, 3, 4, 5]) {'buy_day': 0, 'sell_day': 4, 'max_profit': 4} >>> analyze_stock_prices([]) {'buy_day': -1, 'sell_day': -1, 'max_profit': 0} >>> analyze_stock_prices([5]) {'buy_day': -1, 'sell_day': -1, 'max_profit': 0} >>> analyze_stock_prices([6, 1, 3, 2, 4, 5]) {'buy_day': 1, 'sell_day': 5, 'max_profit': 4}","solution":"def analyze_stock_prices(prices): Analyzes stock prices to determine the best days to buy and sell for maximum profit. :param prices: List of integers where each integer represents the stock price for a day. :return: A dictionary with keys 'buy_day', 'sell_day', and 'max_profit'. if not prices or len(prices) < 2: return {'buy_day': -1, 'sell_day': -1, 'max_profit': 0} min_price_day = 0 max_profit = 0 buy_day = -1 sell_day = -1 for current_day in range(1, len(prices)): if prices[current_day] < prices[min_price_day]: min_price_day = current_day current_profit = prices[current_day] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = current_day if max_profit == 0: return {'buy_day': -1, 'sell_day': -1, 'max_profit': 0} return {'buy_day': buy_day, 'sell_day': sell_day, 'max_profit': max_profit}"},{"question":"class SecureMessage: Securely encrypt and decrypt messages using RSA public-private key encryption. Init Parameters: public_key: tuple private_key: tuple Methods: encrypt(self, message: str) -> List[int] Encrypt the input message using the public key and return the encrypted message as a list of integers. decrypt(self, encrypted_message: List[int]) -> str Decrypt the input encrypted message using the private key and return the decrypted message as a string. def __init__(self, public_key: tuple, private_key: tuple): self.public_key = public_key self.private_key = private_key def encrypt(self, message: str) -> List[int]: pass def decrypt(self, encrypted_message: List[int]) -> str: pass # Example usage message = \\"HELLO\\" public_key = (3233, 17) # (n, e) private_key = (3233, 2753) # (n, d) sm = SecureMessage(public_key, private_key) encrypted = sm.encrypt(message) print(encrypted) # Expected output: Encrypted message as a list of integers. decrypted = sm.decrypt(encrypted) print(decrypted) # Expected output: \\"HELLO\\"","solution":"class SecureMessage: def __init__(self, public_key, private_key): self.public_key = public_key self.private_key = private_key def encrypt(self, message): n, e = self.public_key encrypted_message = [pow(ord(char), e, n) for char in message] return encrypted_message def decrypt(self, encrypted_message): n, d = self.private_key decrypted_message = ''.join([chr(pow(char, d, n)) for char in encrypted_message]) return decrypted_message"},{"question":"def sort_dicts_by_key(dicts_list, sort_key): Sorts a list of dictionaries by a specified key. Parameters: dicts_list (list): A list of dictionaries. sort_key (str): The key to sort the dictionaries by. Returns: list: A new list of dictionaries sorted by the specified key. Raises: TypeError: If dicts_list is not a list or any element is not a dictionary, or sort_key is not a string. KeyError: If any dictionary does not contain the sort_key. Examples: >>> sort_dicts_by_key([{'id': 3, 'name': 'Alice'}, {'id': 1, 'name': 'Bob'}, {'id': 2, 'name': 'Charlie'}], 'id') [{'id': 1, 'name': 'Bob'}, {'id': 2, 'name': 'Charlie'}, {'id': 3, 'name': 'Alice'}] >>> sort_dicts_by_key([{'age': 25, 'score': 88}, {'age': 30, 'score': 95}, {'age': 22, 'score': 78}], 'age') [{'age': 22, 'score': 78}, {'age': 25, 'score': 88}, {'age': 30, 'score': 95}]","solution":"def sort_dicts_by_key(dicts_list, sort_key): Sorts a list of dictionaries by a specified key. Parameters: dicts_list (list): A list of dictionaries. sort_key (str): The key to sort the dictionaries by. Returns: list: A new list of dictionaries sorted by the specified key. Raises: TypeError: If dicts_list is not a list or any element is not a dictionary, or sort_key is not a string. KeyError: If any dictionary does not contain the sort_key. if not isinstance(dicts_list, list): raise TypeError(\\"The first argument must be a list of dictionaries\\") if not all(isinstance(d, dict) for d in dicts_list): raise TypeError(\\"All elements in the list must be dictionaries\\") if not isinstance(sort_key, str): raise TypeError(\\"The sort_key must be a string\\") for d in dicts_list: if sort_key not in d: raise KeyError(f\\"All dictionaries must contain the key '{sort_key}'\\") return sorted(dicts_list, key=lambda x: x[sort_key])"},{"question":"from collections import OrderedDict class LRUCache: A class used to represent a least recently used (LRU) cache. Attributes ---------- cache : OrderedDict The internal cache storage. capacity : int The maximum capacity of the cache. Methods ------- get(key: int) -> int: Retrieves the value associated with the key, updating its usage. If the key doesn't exist, returns -1. put(key: int, value: int) -> None: Inserts or updates the key-value pair in the cache. If the cache exceeds the given capacity, it evicts the least recently used item. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) # returns 1 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) # returns -1 (not found) -1 >>> cache.put(4, 4) # evicts key 1 >>> cache.get(1) # returns -1 (not found) -1 >>> cache.get(3) # returns 3 3 >>> cache.get(4) # returns 4 4 def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: # Implementation missing def put(self, key: int, value: int) -> None: # Implementation missing","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"from typing import List def findLHS(nums: List[int]) -> int: Finds the length of the longest harmonious subsequence. >>> findLHS([1, 3, 2, 2, 5, 2, 3, 7]) == 5 >>> findLHS([1, 1, 1, 1]) == 0","solution":"from typing import List from collections import Counter def findLHS(nums: List[int]) -> int: Finds the length of the longest harmonious subsequence. freq = Counter(nums) max_length = 0 for key in freq: if key + 1 in freq: max_length = max(max_length, freq[key] + freq[key + 1]) return max_length"},{"question":"from typing import List def minimize_partition_sum(arr: List[int], k: int) -> int: Partition the array into k contiguous subarrays such that the sum of the maximum sum of these subarrays is minimized. >>> minimize_partition_sum([1,2,3,4,5], 2) 9 >>> minimize_partition_sum([7,2,5,10,8], 2) 18","solution":"from typing import List def minimize_partition_sum(arr: List[int], k: int) -> int: n = len(arr) # If k is greater than or equal to the length of the array, each element can be its own subarray if k >= n: return max(arr) # Helper function to decide if it is possible to partition the array # into k contiguous subarrays with sum at most \`max_sum\` def can_partition(max_sum): count, current_sum = 1, 0 for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True # Binary search between the largest single element and the sum of all elements left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"def extract_domain(email: str) -> str: Extracts the domain from a given email address. Parameters: email (str): An email address. Returns: str: The domain of the email or an error message if the email is invalid. Examples: >>> extract_domain(\\"contact@example.com\\") \\"example.com\\" >>> extract_domain(\\"invalid-email.com\\") \\"Invalid email address\\" >>> extract_domain(\\"mailto:contact@sub.example.com\\") \\"sub.example.com\\"","solution":"def extract_domain(email): Extracts the domain from a given email address. Parameters: email (str): An email address. Returns: str: The domain of the email or an error message if the email is invalid. if not isinstance(email, str): return \\"Invalid input: not a string\\" if email.count('@') != 1: return \\"Invalid email address\\" local_part, domain_part = email.split('@') if not domain_part or '.' not in domain_part: return \\"Invalid email address\\" return domain_part"},{"question":"class File: def __init__(self, name): self.name = name class Directory: def __init__(self, name): self.name = name self.contents = [] def add(self, item): self.contents.append(item) def list_files(self, prefix=\\"\\"): List all files in the directory, including nested subdirectories, with relative paths. The function should return a list of filenames with their relative paths from the current directory. Example: >>> root = Directory(\\"root\\") >>> dir_a = Directory(\\"dir_a\\") >>> file_1 = File(\\"file_1.txt\\") >>> file_2 = File(\\"file_2.txt\\") >>> file_3 = File(\\"file_3.txt\\") >>> root.add(dir_a) >>> root.add(file_1) >>> dir_a.add(dir_b) >>> dir_a.add(file_2) >>> dir_b.add(file_3) >>> assert root.list_files() == ['file_1.txt', 'dir_a/file_2.txt', 'dir_a/dir_b/file_3.txt'] pass # Write your implementation here def test_list_files_single_level(): root = Directory(\\"root\\") file_1 = File(\\"file_1.txt\\") file_2 = File(\\"file_2.txt\\") root.add(file_1) root.add(file_2) assert root.list_files() == [\\"file_1.txt\\", \\"file_2.txt\\"] def test_list_files_nested_directories(): root = Directory(\\"root\\") dir_a = Directory(\\"dir_a\\") file_1 = File(\\"file_1.txt\\") file_2 = File(\\"file_2.txt\\") dir_b = Directory(\\"dir_b\\") file_3 = File(\\"file_3.txt\\") root.add(file_1) root.add(dir_a) dir_a.add(file_2) dir_a.add(dir_b) dir_b.add(file_3) assert root.list_files() == [\\"file_1.txt\\", \\"dir_a/file_2.txt\\", \\"dir_a/dir_b/file_3.txt\\"] def test_list_files_empty_directory(): root = Directory(\\"root\\") assert root.list_files() == [] def test_list_files_mixed_contents(): root = Directory(\\"root\\") dir_a = Directory(\\"dir_a\\") file_1 = File(\\"file_1.txt\\") root.add(file_1) root.add(dir_a) assert root.list_files() == [\\"file_1.txt\\"] def test_list_files_deeply_nested(): root = Directory(\\"root\\") dir_a = Directory(\\"dir_a\\") dir_b = Directory(\\"dir_b\\") dir_c = Directory(\\"dir_c\\") file_1 = File(\\"file_1.txt\\") root.add(dir_a) dir_a.add(dir_b) dir_b.add(dir_c) dir_c.add(file_1) assert root.list_files() == [\\"dir_a/dir_b/dir_c/file_1.txt\\"] def test_list_files_complex_mixture(): root = Directory(\\"root\\") dir_a = Directory(\\"dir_a\\") dir_b = Directory(\\"dir_b\\") file_1 = File(\\"file_1.txt\\") file_2 = File(\\"file_2.txt\\") file_3 = File(\\"file_3.txt\\") root.add(file_1) dir_a.add(file_2) root.add(dir_a) dir_b.add(file_3) dir_a.add(dir_b) expected_files = [\\"file_1.txt\\", \\"dir_a/file_2.txt\\", \\"dir_a/dir_b/file_3.txt\\"] assert root.list_files() == expected_files","solution":"class File: def __init__(self, name): self.name = name class Directory: def __init__(self, name): self.name = name self.contents = [] def add(self, item): self.contents.append(item) def list_files(self, prefix=\\"\\"): files_list = [] for item in self.contents: if isinstance(item, File): files_list.append(f\\"{prefix}{item.name}\\") elif isinstance(item, Directory): sub_dir_files = item.list_files(f\\"{prefix}{item.name}/\\") files_list.extend(sub_dir_files) return files_list"},{"question":"from typing import List, Dict def aggregate_sales(data: List[List[Dict[str, int]]]) -> Dict[str, int]: Aggregates sales data from multiple regions and returns total sales per month. :param data: List of lists containing dictionaries with sales data. :return: A dictionary with the total sales per month. >>> sales_data = [ ... [ ... {\\"month\\": \\"January\\", \\"sales\\": 100}, ... {\\"month\\": \\"February\\", \\"sales\\": 150}, ... {\\"month\\": \\"March\\", \\"sales\\": 200} ... ], ... [ ... {\\"month\\": \\"January\\", \\"sales\\": 80}, ... {\\"month\\": \\"March\\", \\"sales\\": 220}, ... {\\"month\\": \\"April\\", \\"sales\\": 130} ... ] ... ] >>> aggregate_sales(sales_data) {'January': 180, 'February': 150, 'March': 420, 'April': 130} >>> sales_data = [] >>> aggregate_sales(sales_data) {} >>> sales_data = [ ... [ ... {\\"month\\": \\"January\\", \\"sales\\": 100}, ... ], ... [ ... {\\"month\\": \\"February\\", \\"sales\\": 150}, ... ] ... ] >>> aggregate_sales(sales_data) {'January': 100, 'February': 150} >>> sales_data = [ ... [ ... {\\"month\\": \\"January\\", \\"sales\\": 70}, ... {\\"month\\": \\"February\\", \\"sales\\": 40}, ... ], ... [ ... {\\"month\\": \\"February\\", \\"sales\\": 60}, ... {\\"month\\": \\"March\\", \\"sales\\": 80}, ... ] ... ] >>> aggregate_sales(sales_data) {'January': 70, 'February': 100, 'March': 80} >>> sales_data = [ ... [ ... {\\"month\\": \\"May\\", \\"sales\\": 90}, ... {\\"month\\": \\"June\\", \\"sales\\": 150}, ... ], ... [ ... {\\"month\\": \\"May\\", \\"sales\\": 110}, ... {\\"month\\": \\"July\\", \\"sales\\": 120}, ... ], ... [ ... {\\"month\\": \\"June\\", \\"sales\\": 160}, ... {\\"month\\": \\"August\\", \\"sales\\": 200}, ... ] ... ] >>> aggregate_sales(sales_data) {'May': 200, 'June': 310, 'July': 120, 'August': 200}","solution":"from typing import List, Dict def aggregate_sales(data: List[List[Dict[str, int]]]) -> Dict[str, int]: Aggregates sales data from multiple regions and returns total sales per month. :param data: List of lists containing dictionaries with sales data. :return: A dictionary with the total sales per month. sales_aggregation = {} for region_data in data: for entry in region_data: month = entry[\\"month\\"] sales = entry[\\"sales\\"] if month in sales_aggregation: sales_aggregation[month] += sales else: sales_aggregation[month] = sales return sales_aggregation"},{"question":"def generate_pascals_triangle_row(n: int) -> list: Generate the n-th row of Pascal's Triangle. >>> generate_pascals_triangle_row(0) [1] >>> generate_pascals_triangle_row(3) [1, 3, 3, 1] >>> generate_pascals_triangle_row(5) [1, 5, 10, 10, 5, 1] pass from solution import generate_pascals_triangle_row def test_generate_pascals_triangle_row(): assert generate_pascals_triangle_row(0) == [1] assert generate_pascals_triangle_row(1) == [1, 1] assert generate_pascals_triangle_row(2) == [1, 2, 1] assert generate_pascals_triangle_row(3) == [1, 3, 3, 1] assert generate_pascals_triangle_row(4) == [1, 4, 6, 4, 1] assert generate_pascals_triangle_row(5) == [1, 5, 10, 10, 5, 1] assert generate_pascals_triangle_row(6) == [1, 6, 15, 20, 15, 6, 1] assert generate_pascals_triangle_row(10) == [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1] # Testing higher numbers to handle large values assert generate_pascals_triangle_row(20) == [ 1, 20, 190, 1140, 4845, 15504, 38760, 77520, 125970, 167960, 184756, 167960, 125970, 77520, 38760, 15504, 4845, 1140, 190, 20, 1 ] assert generate_pascals_triangle_row(30) == [ 1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1 ] def test_generate_pascals_triangle_row_large_n(): row_50 = generate_pascals_triangle_row(50) assert row_50[0] == 1 assert row_50[1] == 50 assert row_50[50] == 1 assert len(row_50) == 51","solution":"def generate_pascals_triangle_row(n: int) -> list: Generate the n-th row of Pascal's Triangle. if n == 0: return [1] row = [1] for i in range(1, n + 1): row.append(row[i - 1] * (n - i + 1) // i) return row"},{"question":"class InventoryManagement: A class to represent an inventory management system for a small store. def __init__(self): Initialize the inventory management system with an empty dictionary. pass def add_item(self, item_name: str, cost_price: float, sell_price: float, quantity: int): Add a new item to the inventory. :param item_name: str, name of the new item :param cost_price: float, cost price of the item :param sell_price: float, selling price of the item :param quantity: int, quantity in stock pass def update_stock(self, item_name: str, quantity: int): Update stock quantity of an existing item. :param item_name: str, name of the item to update :param quantity: int, quantity to be added to the stock pass def calculate_inventory_value(self) -> float: Calculate and return the total value of the current inventory based on cost price. :return: float, total value of the inventory pass # Unit Tests def test_add_item(): inventory = InventoryManagement() inventory.add_item(\\"Laptop\\", 1000.00, 1500.00, 10) assert \\"Laptop\\" in inventory.inventory assert inventory.inventory[\\"Laptop\\"] == { \\"cost_price\\": 1000.00, \\"sell_price\\": 1500.00, \\"quantity\\": 10 } def test_update_stock(): inventory = InventoryManagement() inventory.add_item(\\"Laptop\\", 1000.00, 1500.00, 10) inventory.update_stock(\\"Laptop\\", 5) assert inventory.inventory[\\"Laptop\\"][\\"quantity\\"] == 15 inventory.update_stock(\\"Laptop\\", -3) assert inventory.inventory[\\"Laptop\\"][\\"quantity\\"] == 12 def test_calculate_inventory_value(): inventory = InventoryManagement() inventory.add_item(\\"Laptop\\", 1000.00, 1500.00, 10) inventory.add_item(\\"Smartphone\\", 500.00, 800.00, 25) assert inventory.calculate_inventory_value() == 1000*10 + 500*25 inventory.update_stock(\\"Laptop\\", 5) assert inventory.calculate_inventory_value() == 1000*15 + 500*25","solution":"class InventoryManagement: def __init__(self): Initialize the inventory management system with an empty dictionary. self.inventory = {} def add_item(self, item_name: str, cost_price: float, sell_price: float, quantity: int): Add a new item to the inventory. :param item_name: str, name of the new item :param cost_price: float, cost price of the item :param sell_price: float, selling price of the item :param quantity: int, quantity in stock self.inventory[item_name] = { \\"cost_price\\": cost_price, \\"sell_price\\": sell_price, \\"quantity\\": quantity } def update_stock(self, item_name: str, quantity: int): Update stock quantity of an existing item. :param item_name: str, name of the item to update :param quantity: int, quantity to be added to the stock if item_name in self.inventory: self.inventory[item_name][\\"quantity\\"] += quantity def calculate_inventory_value(self) -> float: Calculate and return the total value of the current inventory based on cost price. :return: float, total value of the inventory total_value = 0.0 for item in self.inventory.values(): total_value += item[\\"cost_price\\"] * item[\\"quantity\\"] return round(total_value, 2)"},{"question":"[Completion Task in Python] # Binary Search Tree Insertion Implement the function \`insert_into_bst\` to insert a value into a binary search tree (BST), while maintaining the BST properties. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): Inserts a value into the binary search tree rooted at root. Args: root (TreeNode): The root of the binary search tree. val (int): The value to insert. Returns: TreeNode: The root of the binary search tree after the insertion. if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) elif val > root.val: root.right = insert_into_bst(root.right, val) else: # If duplicate values are not allowed, you can choose to do nothing. pass return root","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): Inserts a value into the binary search tree rooted at root. Args: root (TreeNode): The root of the binary search tree. val (int): The value to insert. Returns: TreeNode: The root of the binary search tree after the insertion. if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) elif val > root.val: root.right = insert_into_bst(root.right, val) else: # If duplicate values are not allowed, you can choose to do nothing. pass return root"},{"question":"def int_to_roman(num: int) -> str: Converts a positive integer from decimal to its corresponding Roman numeral representation. >>> int_to_roman(3) 'III' >>> int_to_roman(58) 'LVIII' >>> int_to_roman(1994) 'MCMXCIV'","solution":"def int_to_roman(num: int) -> str: Converts an integer within the range 1 to 3999 to its corresponding Roman numeral. # Define the Roman numeral mappings in descending order val_to_roman = [ (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I') ] roman_numeral = \\"\\" for value, symbol in val_to_roman: # Keep adding the symbol for as long as we can subtract the value from num while num >= value: roman_numeral += symbol num -= value return roman_numeral"},{"question":"def reverse_string(s: str) -> str: Reverses a given string. >>> reverse_string(\\"hello\\") == \\"olleh\\" >>> reverse_string(\\"\\") == \\"\\" >>> reverse_string(\\"a\\") == \\"a\\" >>> reverse_string(\\"racecar\\") == \\"racecar\\" def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome. >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True def count_vowels(s: str) -> int: Counts the number of vowels in a given string. >>> count_vowels(\\"hello\\") == 2 >>> count_vowels(\\"\\") == 0 >>> count_vowels(\\"xkcd\\") == 0 >>> count_vowels(\\"AEIOUaeiou\\") == 10 def find_substring(s: str, substring: str) -> int: Finds the first occurrence index of a substring in a given string, or returns -1 if not found. >>> find_substring(\\"hello world\\", \\"world\\") == 6 >>> find_substring(\\"hello world\\", \\"worlds\\") == -1 >>> find_substring(\\"\\", \\"world\\") == -1 >>> find_substring(\\"hello\\", \\"\\") == 0 >>> find_substring(\\"hello\\", \\"hello\\") == 0 def capitalize_words(s: str) -> str: Capitalizes the first letter of each word in a given string. >>> capitalize_words(\\"hello world\\") == \\"Hello World\\" >>> capitalize_words(\\"\\") == \\"\\" >>> capitalize_words(\\"a quick brown fox\\") == \\"A Quick Brown Fox\\" >>> capitalize_words(\\"HELLO WORLD\\") == \\"Hello World\\"","solution":"def reverse_string(s): Returns the given string reversed. return s[::-1] def is_palindrome(s): Checks if the given string is a palindrome. reversed_s = reverse_string(s) return s == reversed_s def count_vowels(s): Counts the number of vowels (a, e, i, o, u) in the given string. vowels = \\"aeiouAEIOU\\" return sum(1 for char in s if char in vowels) def find_substring(s, substring): Finds the first occurrence index of a substring in a given string, or returns -1 if not found. return s.find(substring) def capitalize_words(s): Capitalizes the first letter of each word in the given string. return ' '.join(word.capitalize() for word in s.split())"},{"question":"class Inventory: def __init__(self): pass def add_item(self, item_id: str, name: str, quantity: int, price: float): Adds the specified quantity of an item to the inventory. If the item already exists, its quantity is increased by the specified amount. Each item is uniquely identified by its item_id. pass def sell_item(self, item_id: str, quantity: int) -> bool: Decreases the quantity of the specified item by the given amount. If the item does not exist or there is not enough stock to fulfill the request, the method returns False. Otherwise, it returns True. pass def query_inventory(self) -> list[list[str, str, int, float]]: Returns the current inventory as a list of lists, where each sublist contains the item_id, name, quantity, and price of an item. pass def test_add_item(): inventory = Inventory() inventory.add_item(\\"1\\", \\"Apple\\", 50, 0.5) assert inventory.query_inventory() == [[\\"1\\", \\"Apple\\", 50, 0.5]] def test_add_existing_item(): inventory = Inventory() inventory.add_item(\\"1\\", \\"Apple\\", 50, 0.5) inventory.add_item(\\"1\\", \\"Apple\\", 20, 0.5) assert inventory.query_inventory() == [[\\"1\\", \\"Apple\\", 70, 0.5]] def test_sell_item(): inventory = Inventory() inventory.add_item(\\"1\\", \\"Apple\\", 50, 0.5) assert inventory.sell_item(\\"1\\", 20) == True assert inventory.query_inventory() == [[\\"1\\", \\"Apple\\", 30, 0.5]] def test_sell_item_not_enough_stock(): inventory = Inventory() inventory.add_item(\\"1\\", \\"Apple\\", 50, 0.5) assert inventory.sell_item(\\"1\\", 60) == False assert inventory.query_inventory() == [[\\"1\\", \\"Apple\\", 50, 0.5]] def test_sell_non_existing_item(): inventory = Inventory() assert inventory.sell_item(\\"1\\", 1) == False def test_query_inventory(): inventory = Inventory() inventory.add_item(\\"1\\", \\"Apple\\", 50, 0.5) inventory.add_item(\\"2\\", \\"Banana\\", 100, 0.3) assert inventory.query_inventory() == [[\\"1\\", \\"Apple\\", 50, 0.5], [\\"2\\", \\"Banana\\", 100, 0.3]]","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_id: str, name: str, quantity: int, price: float): if item_id in self.items: self.items[item_id]['quantity'] += quantity else: self.items[item_id] = {'name': name, 'quantity': quantity, 'price': price} def sell_item(self, item_id: str, quantity: int) -> bool: if item_id in self.items and self.items[item_id]['quantity'] >= quantity: self.items[item_id]['quantity'] -= quantity return True return False def query_inventory(self) -> list[list]: return [[item_id, self.items[item_id]['name'], self.items[item_id]['quantity'], self.items[item_id]['price']] for item_id in self.items]"},{"question":"def generate_subsets(nums: List[int]) -> List[List[int]]: Generate all possible subsets of the given list of unique integers. >>> generate_subsets([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> generate_subsets([0]) [[], [0]]","solution":"def generate_subsets(nums): Generate all possible subsets of the given list of unique integers. def backtrack(start, path): result.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() # Ensure the order of subsets is lexicographical result = [] backtrack(0, []) return result"},{"question":"import numpy as np from PIL import Image, ImageEnhance def image_augmentation_pipeline(images, augmentations): Apply a series of augmentations to a batch of images. :param images: np.ndarray, batch of images of shape (batch_size, height, width, channels) :param augmentations: list of dict, list of augmentations to apply. Each dict contains the type of augmentation and associated parameters. :return: np.ndarray, batch of augmented images with the same shape as the input >>> images = np.random.randint(0, 256, (1, 64, 64, 3), dtype=np.uint8) >>> augmentations = [{\\"type\\": \\"flip_horizontal\\"}] >>> augmented_images = image_augmentation_pipeline(images, augmentations) >>> augmented_images.shape == images.shape True >>> images = np.array([[[[0, 0, 0], [255, 255, 255]], [[255, 255, 255], [0, 0, 0]]]], dtype=np.uint8) >>> augmentations = [{\\"type\\": \\"flip_horizontal\\"}] >>> augmented_images = image_augmentation_pipeline(images, augmentations) >>> expected_result = np.array([[[[255, 255, 255], [0, 0, 0]], [[0, 0, 0], [255, 255, 255]]]], dtype=np.uint8) >>> np.array_equal(augmented_images, expected_result) True >>> images = np.array([[[[0, 0, 0], [255, 255, 255]], [[255, 255, 255], [0, 0, 0]]]], dtype=np.uint8) >>> augmentations = [{\\"type\\": \\"rotate\\", \\"angle\\": 90}] >>> augmented_images = image_augmentation_pipeline(images, augmentations) >>> expected_result = np.array([[[[255, 255, 255], [0, 0, 0]], [[0, 0, 0], [255, 255, 255]]]], dtype=np.uint8) >>> np.array_equal(augmented_images, expected_result) True >>> images = np.array([[[[100, 100, 100], [200, 200, 200]], [[200, 200, 200], [100, 100, 100]]]], dtype=np.uint8) >>> augmentations = [{\\"type\\": \\"adjust_brightness\\", \\"factor\\": 0.5}] >>> augmented_images = image_augmentation_pipeline(images, augmentations) >>> expected_result = np.array([[[[50, 50, 50], [100, 100, 100]], [[100, 100, 100], [50, 50, 50]]]], dtype=np.uint8) >>> np.array_equal(augmented_images, expected_result) True","solution":"import numpy as np from PIL import Image, ImageEnhance def image_augmentation_pipeline(images, augmentations): Apply a series of augmentations to a batch of images. :param images: np.ndarray, batch of images of shape (batch_size, height, width, channels) :param augmentations: list of dict, list of augmentations to apply. Each dict contains the type of augmentation and associated parameters. :return: np.ndarray, batch of augmented images with the same shape as the input augmented_images = [] for img in images: img_pil = Image.fromarray(img) for aug in augmentations: if aug[\\"type\\"] == \\"flip_horizontal\\": img_pil = img_pil.transpose(Image.FLIP_LEFT_RIGHT) elif aug[\\"type\\"] == \\"rotate\\": img_pil = img_pil.rotate(aug[\\"angle\\"]) elif aug[\\"type\\"] == \\"adjust_brightness\\": enhancer = ImageEnhance.Brightness(img_pil) img_pil = enhancer.enhance(aug[\\"factor\\"]) augmented_images.append(np.array(img_pil)) return np.array(augmented_images)"},{"question":"def is_shuffle(arr1: list[int], arr2: list[int]) -> bool: Determine if arr2 is the result of shuffling arr1. >>> is_shuffle([1, 2, 3, 4], [4, 3, 2, 1]) True >>> is_shuffle([1, 2, 3, 4], [1, 2, 2, 4]) False >>> is_shuffle([10, -15, 20, 5], [-15, 10, 5, 20]) True >>> is_shuffle([7, 8, 9], [1, 2, 3]) False","solution":"def is_shuffle(arr1: list[int], arr2: list[int]) -> bool: Checks if arr2 is a permutation (shuffle) of arr1. Parameters: arr1 (list[int]): The first list of unique integers. arr2 (list[int]): The second list of unique integers. Returns: bool: True if arr2 is a permutation of arr1, False otherwise. if len(arr1) != len(arr2): return False return sorted(arr1) == sorted(arr2)"},{"question":"def number_to_excel_column(n: int) -> str: Converts an integer column number to its corresponding Excel column title. >>> number_to_excel_column(1) 'A' >>> number_to_excel_column(28) 'AB' >>> number_to_excel_column(701) 'ZY'","solution":"def number_to_excel_column(n: int) -> str: Converts an integer column number to its corresponding Excel column title. result = [] while n > 0: n -= 1 # decrement n to handle 1-based indexing result.append(chr(n % 26 + ord('A'))) n //= 26 return ''.join(result[::-1])"},{"question":"def is_prefix_free(sequence_list: list) -> bool: Determines if the given list of binary sequences are prefix-free. Parameters: sequence_list (list): A list of binary sequences (strings) to be checked. Returns: bool: True if the set is prefix-free, False otherwise. Raises: TypeError: If the input is not a list of strings. Example: >>> is_prefix_free([\\"101\\", \\"110\\", \\"1111\\"]) True >>> is_prefix_free([\\"101\\", \\"10\\", \\"1111\\"]) False >>> is_prefix_free([\\"0\\", \\"1\\"]) True >>> is_prefix_free([\\"\\"]) True","solution":"def is_prefix_free(sequence_list: list) -> bool: Determines if the given list of binary sequences are prefix-free. Parameters: sequence_list (list): A list of binary sequences (strings) to be checked. Returns: bool: True if the set is prefix-free, False otherwise. Raises: TypeError: If the input is not a list of strings. # Input validation if not isinstance(sequence_list, list): raise TypeError(\\"Input should be a list of strings.\\") for seq in sequence_list: if not isinstance(seq, str) or not all(c in '01' for c in seq): raise TypeError(\\"All elements in the list should be binary strings.\\") # Check for prefix-free property sorted_sequences = sorted(sequence_list, key=len) for i in range(len(sorted_sequences)): for j in range(i + 1, len(sorted_sequences)): if sorted_sequences[j].startswith(sorted_sequences[i]): return False return True"},{"question":"def sum_of_digits_of_power(base: int, exponent: int) -> int: Calculate the sum of the digits of 'base' raised to the power of 'exponent'. Args: base (int): The base number. exponent (int): The exponent. Returns: int: Sum of the digits of the resulting number. Examples: >>> sum_of_digits_of_power(2, 10) 7 >>> sum_of_digits_of_power(7, 3) 10 >>> sum_of_digits_of_power(5, 4) 13 >>> sum_of_digits_of_power(10, 3) 1","solution":"def sum_of_digits_of_power(base, exponent): Calculates the sum of the digits of \`base\` raised to the power of \`exponent\`. Parameters: - base (int): The base number. - exponent (int): The exponent. Returns: - int: Sum of the digits of the resulting number. power_result = base ** exponent return sum(int(digit) for digit in str(power_result))"},{"question":"def is_power_of_two(n: int) -> bool: Take in a non-negative integer, return True if it is a power of two, else return False. :param n: A non-negative integer :return: A boolean value indicating whether \`n\` is a power of two. Raise ValueError for negative integers. Raise TypeError for non-integer types. >>> is_power_of_two(1) == True >>> is_power_of_two(2) == True >>> is_power_of_two(3) == False >>> is_power_of_two(4) == True >>> is_power_of_two(5) == False >>> is_power_of_two(16) == True >>> is_power_of_two(218) == False >>> is_power_of_two(256) == True >>> is_power_of_two(0) == False","solution":"def is_power_of_two(n: int) -> bool: Take in a non-negative integer, return True if it is a power of two, else return False. :param n: A non-negative integer :return: A boolean value indicating whether \`n\` is a power of two. Raise ValueError for negative integers. Raise TypeError for non-integer types. if not isinstance(n, int): raise TypeError(\\"Input value must be an int type\\") if n < 0: raise ValueError(\\"Input value must be a non-negative integer\\") # 0 is not a power of two if n == 0: return False return (n & (n - 1)) == 0"},{"question":"def find_longest_repeating_substring(s: str) -> str: Find the longest repeating non-overlapping substring in the string s. Args: s (str): The string to search within. Returns: str: The longest repeating non-overlapping substring, or an empty string if none exist. pass # Example test cases print(find_longest_repeating_substring(\\"banana\\")) # Should return \\"ana\\" print(find_longest_repeating_substring(\\"abcdef\\")) # Should return \\"\\" print(find_longest_repeating_substring(\\"aabaaab\\")) # Should return \\"aab\\" print(find_longest_repeating_substring(\\"a\\")) # Should return \\"\\" print(find_longest_repeating_substring(\\"ab\\")) # Should return \\"\\" print(find_longest_repeating_substring(\\"aa\\")) # Should return \\"a\\" print(find_longest_repeating_substring(\\"abcabcabc\\")) # Should return \\"abcabc\\" print(find_longest_repeating_substring(\\"\\")) # Should return \\"\\" print(find_longest_repeating_substring(\\"abcdabc\\")) # Should return \\"abc\\"","solution":"def find_longest_repeating_substring(s: str) -> str: Find the longest repeating non-overlapping substring in the string s. Args: s (str): The string to search within. Returns: str: The longest repeating non-overlapping substring, or an empty string if none exist. n = len(s) if n <= 1: return \\"\\" # Helper function to find common prefix length between s[i:] and s[j:] def common_prefix_length(i, j): length = 0 while i < n and j < n and s[i] == s[j]: length += 1 i += 1 j += 1 return length # Initialize variables to track the longest repeating substring max_length = 0 start_index = 0 # Use a suffix array approach to identify longest repeating substrings suffixes = sorted(range(n), key=lambda i: s[i:]) for i in range(1, n): length = common_prefix_length(suffixes[i - 1], suffixes[i]) if length > max_length: max_length = length start_index = suffixes[i] return s[start_index:start_index + max_length] if max_length > 0 else \\"\\" # Example usage print(find_longest_repeating_substring(\\"banana\\")) # Should return \\"ana\\" print(find_longest_repeating_substring(\\"abcdef\\")) # Should return \\"\\" print(find_longest_repeating_substring(\\"aabaaab\\")) # Should return \\"aab\\""},{"question":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists of integers into a single sorted list. :param list1: A sorted list of integers representing the bitrates of video packets. :param list2: Another sorted list of integers representing the bitrates of video packets. :return: A merged and sorted list of all integers from both input lists. pass # Test Cases def test_merge_sorted_lists(): assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([1, 2, 2], [2, 3, 4]) == [1, 2, 2, 2, 3, 4] assert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_lists([1, 2, 3], []) == [1, 2, 3] assert merge_sorted_lists([], []) == [] assert merge_sorted_lists([1, 1, 2, 3], [1, 2, 2, 4, 5]) == [1, 1, 1, 2, 2, 2, 3, 4, 5] assert merge_sorted_lists([1, 5, 9, 14, 20, 1000000], [3, 6, 7, 21, 1000001]) == [1, 3, 5, 6, 7, 9, 14, 20, 21, 1000000, 1000001] def test_edge_cases(): assert merge_sorted_lists([1000000], [1000000]) == [1000000, 1000000] assert merge_sorted_lists([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_lists([4, 5, 6], [1, 2, 3]) == [1, 2, 3, 4, 5, 6]","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merges two sorted lists of integers into a single sorted list. :param list1: A sorted list of integers representing the bitrates of video packets. :param list2: Another sorted list of integers representing the bitrates of video packets. :return: A merged and sorted list of all integers from both input lists. # Initialize pointers for both lists and the result list i, j = 0, 0 merged_list = [] # Traverse through both lists while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # Append remaining elements of list1, if any while i < len(list1): merged_list.append(list1[i]) i += 1 # Append remaining elements of list2, if any while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def evaluate_cobol_expression(expression: str): Evaluates a COBOL arithmetic expression that contains two operands separated by a single operation. :param expression: The COBOL arithmetic expression as a string (e.g., \\"23 + 7\\") :return: The result of the operation as either an int or float >>> evaluate_cobol_expression('23 + 7') 30 >>> evaluate_cobol_expression('50 - 8') 42 >>> evaluate_cobol_expression('4 * 5') 20 >>> evaluate_cobol_expression('20 / 4') 5.0 pass # Your implementation here # Example Test Cases: def test_evaluate_cobol_expression_addition(): assert evaluate_cobol_expression('23 + 7') == 30 def test_evaluate_cobol_expression_subtraction(): assert evaluate_cobol_expression('50 - 8') == 42 def test_evaluate_cobol_expression_multiplication(): assert evaluate_cobol_expression('4 * 5') == 20 def test_evaluate_cobol_expression_division(): assert evaluate_cobol_expression('20 / 4') == 5.0 def test_evaluate_cobol_expression_invalid_operator(): try: evaluate_cobol_expression('10 % 3') except ValueError as ve: assert str(ve) == \\"Invalid expression\\" def test_evaluate_cobol_expression_invalid_expression(): try: evaluate_cobol_expression('10 & 3') except ValueError as ve: assert str(ve) == \\"Invalid expression\\" def test_evaluate_cobol_expression_invalid_syntax(): try: evaluate_cobol_expression('23+7') except ValueError as ve: assert str(ve) == \\"Invalid expression\\" def test_evaluate_cobol_expression_more_operands(): try: evaluate_cobol_expression('23 + 7 + 8') except ValueError as ve: assert str(ve) == \\"Invalid expression\\" def test_evaluate_cobol_expression_non_integer_operands(): try: evaluate_cobol_expression('23 + seven') except ValueError as ve: assert str(ve) == \\"Invalid expression\\"","solution":"def evaluate_cobol_expression(expression: str): Evaluates a COBOL arithmetic expression that contains two operands separated by a single operation. :param expression: The COBOL arithmetic expression as a string (e.g., \\"23 + 7\\") :return: The result of the operation as either an int or float try: operand1, operator, operand2 = expression.split() operand1 = int(operand1) operand2 = int(operand2) if operator == '+': return operand1 + operand2 elif operator == '-': return operand1 - operand2 elif operator == '*': return operand1 * operand2 elif operator == '/': return operand1 / operand2 else: raise ValueError(\\"Invalid expression\\") except ValueError: raise ValueError(\\"Invalid expression\\")"},{"question":"def find_smallest_permutation(num: str) -> str: Returns the smallest lexicographical permutation of num. >>> find_smallest_permutation(\\"943\\") '349' >>> find_smallest_permutation(\\"120\\") '012' >>> find_smallest_permutation(\\"5\\") '5' >>> find_smallest_permutation(\\"9876543210\\") '0123456789' >>> find_smallest_permutation(\\"123456789\\") '123456789' pass","solution":"def find_smallest_permutation(num: str) -> str: Returns the smallest lexicographical permutation of num. return ''.join(sorted(num))"},{"question":"from collections import defaultdict, deque def find_task_order(tasks: int, dependencies: list) -> list: Determines a possible order of task execution given their dependencies using topological sort. Parameters: tasks (int): The total number of tasks, labeled from 0 to tasks-1. dependencies (list): A list of tuples where each tuple (a, b) indicates that task \`a\` must be completed before task \`b\`. Returns: list: A list of integers representing a valid task execution order, or an empty list if no valid order exists. pass # Unit Tests def test_no_dependencies(): tasks = 4 dependencies = [] assert find_task_order(tasks, dependencies) in [[0, 1, 2, 3], [0, 1, 3, 2], [0, 2, 1, 3], [0, 2, 3, 1], [0, 3, 1, 2], [0, 3, 2, 1], [1, 0, 2, 3], [1, 0, 3, 2], [1, 2, 0, 3], [1, 2, 3, 0], [1, 3, 0, 2], [1, 3, 2, 0], [2, 0, 1, 3], [2, 0, 3, 1], [2, 1, 0, 3], [2, 1, 3, 0], [2, 3, 0, 1], [2, 3, 1, 0], [3, 0, 1, 2], [3, 0, 2, 1], [3, 1, 0, 2], [3, 1, 2, 0], [3, 2, 0, 1], [3, 2, 1, 0]] def test_simple_dependencies(): tasks = 4 dependencies = [(1, 0), (2, 0), (3, 1), (3, 2)] assert find_task_order(tasks, dependencies) in [[3, 2, 1, 0], [3, 1, 2, 0]] def test_cycle_in_graph(): tasks = 2 dependencies = [(0, 1), (1, 0)] assert find_task_order(tasks, dependencies) == [] def test_complex_case(): tasks = 6 dependencies = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)] result = find_task_order(tasks, dependencies) assert result in [[4, 5, 2, 3, 1, 0], [5, 4, 2, 3, 1, 0], [4, 5, 2, 0, 3, 1], [5, 4, 0, 2, 3, 1]] # There might be other valid orders def test_single_task(): tasks = 1 dependencies = [] assert find_task_order(tasks, dependencies) == [0] def test_two_independent_tasks(): tasks = 2 dependencies = [] assert find_task_order(tasks, dependencies) in [[0, 1], [1, 0]]","solution":"from collections import defaultdict, deque def find_task_order(tasks, dependencies): Determines a possible order of task execution given their dependencies using topological sort. Parameters: tasks (int): The total number of tasks, labeled from 0 to tasks-1. dependencies (list): A list of tuples where each tuple (a, b) indicates that task \`a\` must be completed before task \`b\`. Returns: list: A list of integers representing a valid task execution order, or an empty list if no valid order exists. # Create adjacency list and in-degree array adj_list = defaultdict(list) in_degree = [0] * tasks # Populate adjacency list and in-degree array for a, b in dependencies: adj_list[a].append(b) in_degree[b] += 1 # Initialize the queue with all nodes having in-degree of 0 queue = deque([i for i in range(tasks) if in_degree[i] == 0]) result = [] while queue: node = queue.popleft() result.append(node) # Process all neighbors for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we were able to process all nodes if len(result) == tasks: return result else: return []"},{"question":"class PassengerNode: def __init__(self, booking_id: int, name: str): self.booking_id = booking_id self.name = name self.left = None self.right = None self.parent = None class FlightReservationSystem: def __init__(self): self.root = None def add_passenger(self, booking_id: int, name: str): Insert a new passenger into the system. Args: booking_id (int): The unique booking ID of the passenger. name (str): The name of the passenger. # Implement insertion logic, maintaining balance def remove_passenger(self, booking_id: int): Remove a passenger from the system. Args: booking_id (int): The unique booking ID of the passenger to be removed. # Implement deletion logic, maintaining balance def find_passenger(self, booking_id: int) -> str: Find and return the name of the passenger with the given booking ID. Args: booking_id (int): The unique booking ID of the passenger to be found. Returns: str: The name of the passenger, or None if not found. # Implement search logic def in_order_traversal(self) -> list: Return a list of all passenger names sorted by booking ID. Returns: list: List of passenger names in ascending order of their booking ID. # Implement in-order traversal logic from solution import FlightReservationSystem def test_add_find_passenger(): flight_system = FlightReservationSystem() flight_system.add_passenger(101, \\"Alice\\") flight_system.add_passenger(203, \\"Bob\\") assert flight_system.find_passenger(101) == \\"Alice\\" assert flight_system.find_passenger(203) == \\"Bob\\" def test_remove_passenger(): flight_system = FlightReservationSystem() flight_system.add_passenger(101, \\"Alice\\") flight_system.add_passenger(203, \\"Bob\\") flight_system.remove_passenger(101) assert flight_system.find_passenger(101) is None assert flight_system.find_passenger(203) == \\"Bob\\" def test_in_order_traversal(): flight_system = FlightReservationSystem() flight_system.add_passenger(101, \\"Alice\\") flight_system.add_passenger(203, \\"Bob\\") flight_system.add_passenger(150, \\"Charlie\\") assert flight_system.in_order_traversal() == [\\"Alice\\", \\"Charlie\\", \\"Bob\\"] def test_add_remove_mixed(): flight_system = FlightReservationSystem() flight_system.add_passenger(101, \\"Alice\\") flight_system.add_passenger(203, \\"Bob\\") flight_system.add_passenger(150, \\"Charlie\\") flight_system.remove_passenger(203) assert flight_system.find_passenger(203) is None assert flight_system.in_order_traversal() == [\\"Alice\\", \\"Charlie\\"] flight_system.add_passenger(203, \\"Bob\\") assert flight_system.in_order_traversal() == [\\"Alice\\", \\"Charlie\\", \\"Bob\\"]","solution":"class PassengerNode: def __init__(self, booking_id, name): self.booking_id = booking_id self.name = name self.left = None self.right = None self.parent = None class FlightReservationSystem: def __init__(self): self.root = None def add_passenger(self, booking_id: int, name: str): node = PassengerNode(booking_id, name) if not self.root: self.root = node else: self._insert(self.root, node) self._balance(node) def _insert(self, current, node): if node.booking_id < current.booking_id: if current.left: self._insert(current.left, node) else: current.left = node node.parent = current else: if current.right: self._insert(current.right, node) else: current.right = node node.parent = current def remove_passenger(self, booking_id: int): node = self._find(self.root, booking_id) if node: self._delete(node) self._balance(node.parent) def _delete(self, node): if not (node.left or node.right): self._replace_node_in_parent(node, None) elif node.left and node.right: successor = self._find_min(node.right) node.booking_id, node.name = successor.booking_id, successor.name self._delete(successor) else: if node.left: self._replace_node_in_parent(node, node.left) else: self._replace_node_in_parent(node, node.right) def _replace_node_in_parent(self, node, new_value): if node.parent: if node == node.parent.left: node.parent.left = new_value else: node.parent.right = new_value if new_value: new_value.parent = node.parent else: self.root = new_value if new_value: new_value.parent = None def find_passenger(self, booking_id: int) -> str: node = self._find(self.root, booking_id) return node.name if node else None def _find(self, current, booking_id): if not current or current.booking_id == booking_id: return current elif booking_id < current.booking_id: return self._find(current.left, booking_id) else: return self._find(current.right, booking_id) def in_order_traversal(self) -> list: return [node.name for node in self._in_order(self.root)] def _in_order(self, current): nodes = [] if current: nodes.extend(self._in_order(current.left)) nodes.append(current) nodes.extend(self._in_order(current.right)) return nodes def _find_min(self, current): while current.left: current = current.left return current def _balance(self, node): # This method would include balancing operations like rotations pass"},{"question":"def longest_zero_sequence(binary_str: str) -> int: Returns the length of the longest contiguous sequence of zeros in the given binary string. >>> longest_zero_sequence('110001000010011000') == 4 >>> longest_zero_sequence('00000') == 5 >>> longest_zero_sequence('11111') == 0 >>> longest_zero_sequence('1010101010') == 1 >>> longest_zero_sequence('0') == 1 >>> longest_zero_sequence('1') == 0 >>> longest_zero_sequence('010100') == 2 >>> longest_zero_sequence('1100110011') == 2","solution":"def longest_zero_sequence(binary_str: str) -> int: Returns the length of the longest contiguous sequence of zeros in the given binary string. # Split the string by '1' and calculate the length of each part zero_sequences = binary_str.split('1') # Find the longest sequence by taking the max length longest_sequence = max(len(seq) for seq in zero_sequences) return longest_sequence"},{"question":"def longest_common_substring(str1: str, str2: str) -> Tuple[int, str]: Given two strings, finds the longest common substring. Args: str1 (str): First input string. str2 (str): Second input string. Returns: Tuple[int, str]: A tuple containing the length of the longest common substring and the substring itself. Examples: >>> longest_common_substring(\\"babad\\", \\"ababd\\") (3, \\"bab\\") >>> longest_common_substring(\\"abc\\", \\"def\\") (0, \\"\\") def test_longest_common_substring(): assert longest_common_substring(\\"babad\\", \\"ababd\\") == (3, \\"bab\\") assert longest_common_substring(\\"abc\\", \\"def\\") == (0, \\"\\") assert longest_common_substring(\\"abcdefg\\", \\"xyzabc\\") == (3, \\"abc\\") assert longest_common_substring(\\"abcdxyz\\", \\"xyzabcd\\") == (4, \\"abcd\\") assert longest_common_substring(\\"1234abc567\\", \\"zz1234zzzabc\\") == (4, \\"1234\\") assert longest_common_substring(\\"a\\", \\"a\\") == (1, \\"a\\") assert longest_common_substring(\\"a\\", \\"b\\") == (0, \\"\\") assert longest_common_substring(\\"abcd\\", \\"abcd\\") == (4, \\"abcd\\") def test_edge_cases(): assert longest_common_substring(\\"\\", \\"\\") == (0, \\"\\") assert longest_common_substring(\\"a\\", \\"\\") == (0, \\"\\") assert longest_common_substring(\\"\\", \\"a\\") == (0, \\"\\") assert longest_common_substring(\\"abcde\\", \\"abxyz\\") == (2, \\"ab\\")","solution":"def longest_common_substring(str1: str, str2: str) -> (int, str): n, m = len(str1), len(str2) longest_length = 0 longest_substring = \\"\\" # Initialize a 2D list to keep track of the lengths of longest common suffixes dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > longest_length: longest_length = dp[i][j] longest_substring = str1[i - longest_length:i] else: dp[i][j] = 0 return longest_length, longest_substring"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: Find the node at which two singly linked lists intersect. If no intersection, return None. >>> common = ListNode(8, ListNode(4, ListNode(5))) >>> headA = ListNode(4, ListNode(1, common)) >>> headB = ListNode(5, ListNode(6, ListNode(1, common))) >>> intersection = get_intersection_node(headA, headB) >>> intersection.val if intersection else None 8 >>> headA = ListNode(1, ListNode(2)) >>> headB = ListNode(3, ListNode(4)) >>> get_intersection_node(headA, headB) None","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: if not headA or not headB: return None pointerA, pointerB = headA, headB while pointerA is not pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA # If they intersect, else they meet at None"},{"question":"def merge_sort(arr: list[int]) -> list[int]: Implement the Merge Sort algorithm to sort a list of integers in ascending order. >>> merge_sort([34, 7, 23, 32, 5, 62]) [5, 7, 23, 32, 34, 62] >>> merge_sort([]) [] >>> merge_sort([3]) [3] >>> merge_sort([10, -3, 25, 1, 0, -5, 7]) [-5, -3, 0, 1, 7, 10, 25]","solution":"def merge_sort(arr): if len(arr) <= 1: return arr def merge(left, right): sorted_list = [] left_idx, right_idx = 0, 0 while left_idx < len(left) and right_idx < len(right): if left[left_idx] < right[right_idx]: sorted_list.append(left[left_idx]) left_idx += 1 else: sorted_list.append(right[right_idx]) right_idx += 1 sorted_list.extend(left[left_idx:]) sorted_list.extend(right[right_idx:]) return sorted_list mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"def find_subarray_with_sum(arr: list[int], target: int) -> bool: Determine if there exists a contiguous subarray within the given list that sums up to the target sum. Args: arr (list[int]): A list of integers. target (int): The target sum. Returns: bool: True if there is a contiguous subarray that sums up to the target sum, else False. Raises: ValueError: If input is invalid. Examples: >>> find_subarray_with_sum([1, 2, 3, 7, 5], 12) True >>> find_subarray_with_sum([1, 2, 3, 4, 5], 9) True >>> find_subarray_with_sum([-1, 2, 3, -4, 5], 8) False pass def test_find_subarray_with_sum(): assert find_subarray_with_sum([1, 2, 3, 7, 5], 12) == True assert find_subarray_with_sum([1, 2, 3, 4, 5], 9) == True assert find_subarray_with_sum([-1, 2, 3, -4, 5], 8) == False assert find_subarray_with_sum([1, -1, 5, 3, -2], 3) == True assert find_subarray_with_sum([4, 2, -3, 1, 6], 0) == True assert find_subarray_with_sum([5, 1, 2, 3, 4], 15) == True assert find_subarray_with_sum([5], 5) == True assert find_subarray_with_sum([], 5) == False def test_find_subarray_with_sum_invalid_inputs(): import pytest with pytest.raises(ValueError): find_subarray_with_sum(\\"not a list\\", 10) with pytest.raises(ValueError): find_subarray_with_sum([1, 2, 3], \\"not a number\\") with pytest.raises(ValueError): find_subarray_with_sum(None, 10) with pytest.raises(ValueError): find_subarray_with_sum([1, 2, 3], None)","solution":"def find_subarray_with_sum(arr, target): Determine if there exists a contiguous subarray within the given list that sums up to the target sum. if not isinstance(arr, list) or not isinstance(target, (int, float)): raise ValueError(\\"Invalid input: arr must be a list and target must be a number.\\") if not arr: return False current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == target or (current_sum - target) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"def largest_connected_component(graph: dict[int, list[int]]) -> int: Finds the largest connected component in an undirected graph. Args: graph (dict[int, list[int]]): An undirected graph represented as an adjacency list. Returns: int: The size of the largest connected component. Examples: >>> graph1 = { ... 0: [1, 2], ... 1: [0, 3], ... 2: [0], ... 3: [1], ... 4: [5], ... 5: [4] ... } >>> largest_connected_component(graph1) 4 >>> graph2 = { ... 0: [1], ... 1: [0], ... 2: [] ... } >>> largest_connected_component(graph2) 2","solution":"def largest_connected_component(graph): Finds the largest connected component in an undirected graph. Args: graph (dict[int, list[int]]): An undirected graph represented as an adjacency list. Returns: int: The size of the largest connected component. def dfs(node, visited): A utility function to perform depth-first search (DFS) from a node. stack = [node] size = 0 while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) size += 1 for neighbor in graph[vertex]: if neighbor not in visited: stack.append(neighbor) return size visited = set() max_size = 0 for node in graph: if node not in visited: component_size = dfs(node, visited) max_size = max(max_size, component_size) return max_size"},{"question":"def transpose_in_place(matrix: List[List[int]]) -> None: Perform an in-place transposition of the given n x n matrix. :param matrix: 2D list of integers representing the matrix. Example: >>> matrix1 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> transpose_in_place(matrix1) >>> matrix1 [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> matrix2 = [ ... [1, 0], ... [0, 1] ... ] >>> transpose_in_place(matrix2) >>> matrix2 [[1, 0], [0, 1]] pass","solution":"from typing import List def transpose_in_place(matrix: List[List[int]]) -> None: Perform an in-place transposition of the given n x n matrix. :param matrix: 2D list of integers representing the matrix. n = len(matrix) for i in range(n): for j in range(i + 1, n): # Swap elements matrix[i][j] and matrix[j][i] matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"class TreeNode: def __init__(self, x): self.value = x self.left = None self.right = None def calculate_tree_height(root: TreeNode) -> int: Calculate the height of a binary tree. :param root: TreeNode, root of the binary tree :return: int, height of the binary tree >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> calculate_tree_height(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> calculate_tree_height(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> calculate_tree_height(root) 3","solution":"class TreeNode: def __init__(self, x): self.value = x self.left = None self.right = None def calculate_tree_height(root: TreeNode) -> int: Calculate the height of a binary tree. :param root: TreeNode, root of the binary tree :return: int, height of the binary tree if root is None: return 0 left_height = calculate_tree_height(root.left) right_height = calculate_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"import math def triangle_area(a: float, b: float, c: float) -> str: Validate and calculate the area of a triangle given the lengths of its three sides. If the input values are invalid: - Return \\"Error: All sides must be positive numbers\\" if any side is non-positive. - Return \\"Error: The given sides do not form a valid triangle\\" if the sides do not satisfy the triangle inequality. If the input values are valid: - Compute the area using Heron's formula and return a string \\"The area of the triangle is X.XX\\" with the area rounded to two decimal places. >>> triangle_area(3, 4, 5) 'The area of the triangle is 6.00' >>> triangle_area(1, 1, 3) 'Error: The given sides do not form a valid triangle' >>> triangle_area(-3, 4, 5) 'Error: All sides must be positive numbers' # Your implementation here def test_valid_triangle(): assert triangle_area(3, 4, 5) == \\"The area of the triangle is 6.00\\" assert triangle_area(6, 8, 10) == \\"The area of the triangle is 24.00\\" def test_zero_or_negative_sides(): assert triangle_area(-1, 4, 5) == \\"Error: All sides must be positive numbers\\" assert triangle_area(3, 0, 5) == \\"Error: All sides must be positive numbers\\" assert triangle_area(3, 4, -5) == \\"Error: All sides must be positive numbers\\" def test_invalid_triangle_inequality(): assert triangle_area(1, 2, 3) == \\"Error: The given sides do not form a valid triangle\\" assert triangle_area(10, 2, 2) == \\"Error: The given sides do not form a valid triangle\\" assert triangle_area(7, 3, 3) == \\"Error: The given sides do not form a valid triangle\\" def test_valid_small_triangle(): assert triangle_area(0.5, 0.5, 0.5) == \\"The area of the triangle is 0.11\\"","solution":"import math def triangle_area(a: float, b: float, c: float) -> str: # Validate that all sides are positive numbers if a <= 0 or b <= 0 or c <= 0: return \\"Error: All sides must be positive numbers\\" # Validate triangle inequality if a + b <= c or a + c <= b or b + c <= a: return \\"Error: The given sides do not form a valid triangle\\" # Calculate semi-perimeter s = (a + b + c) / 2 # Calculate area using Heron's formula area = math.sqrt(s * (s - a) * (s - b) * (s - c)) # Return area formatted to two decimal places return f\\"The area of the triangle is {area:.2f}\\""},{"question":"from typing import List class Library: def __init__(self): self.available_books = set() # Use a set to store available book titles self.rented_books = set() # Use a set to store rented book titles def add_book(self, title: str) -> None: Adds a book to the library inventory. :param title: The title of the book to add. ... def rent_book(self, title: str) -> bool: Rents out a book from the library if it is available. :param title: The title of the book to rent. :return: True if the book was successfully rented out, False if it was not available. ... def return_book(self, title: str) -> bool: Returns a rented book to the library. :param title: The title of the book to return. :return: True if the book was successfully returned, False if the book was not rented. ... def list_available_books(self) -> List[str]: Returns a list of all available book titles sorted alphabetically. :return: A sorted list of available book titles. ... def test_add_and_list_books(): library = Library() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"1984\\") library.add_book(\\"To Kill A Mockingbird\\") assert library.list_available_books() == [\\"1984\\", \\"The Great Gatsby\\", \\"To Kill A Mockingbird\\"] def test_rent_book_success(): library = Library() library.add_book(\\"1984\\") assert library.rent_book(\\"1984\\") == True assert library.list_available_books() == [] def test_rent_book_failure(): library = Library() assert library.rent_book(\\"Non-Existent Book\\") == False def test_return_book_success(): library = Library() library.add_book(\\"1984\\") library.rent_book(\\"1984\\") assert library.return_book(\\"1984\\") == True assert library.list_available_books() == [\\"1984\\"] def test_return_book_failure(): library = Library() assert library.return_book(\\"Non-Existent Book\\") == False def test_add_after_rent(): library = Library() library.add_book(\\"1984\\") library.rent_book(\\"1984\\") library.add_book(\\"1984\\") # Should not add because it is currently rented assert library.list_available_books() == [] def test_renting_already_rented(): library = Library() library.add_book(\\"1984\\") assert library.rent_book(\\"1984\\") == True assert library.rent_book(\\"1984\\") == False def test_returning_not_rented_book(): library = Library() library.add_book(\\"1984\\") assert library.return_book(\\"1984\\") == False","solution":"from typing import List class Library: def __init__(self): self.available_books = set() # Use a set to store available book titles self.rented_books = set() # Use a set to store rented book titles def add_book(self, title: str) -> None: Adds a book to the library inventory. :param title: The title of the book to add. if title not in self.rented_books: self.available_books.add(title) def rent_book(self, title: str) -> bool: Rents out a book from the library if it is available. :param title: The title of the book to rent. :return: True if the book was successfully rented out, False if it was not available. if title in self.available_books: self.available_books.remove(title) self.rented_books.add(title) return True return False def return_book(self, title: str) -> bool: Returns a rented book to the library. :param title: The title of the book to return. :return: True if the book was successfully returned, False if the book was not rented. if title in self.rented_books: self.rented_books.remove(title) self.available_books.add(title) return True return False def list_available_books(self) -> List[str]: Returns a list of all available book titles sorted alphabetically. :return: A sorted list of available book titles. return sorted(self.available_books)"},{"question":"def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transpose a given 2D list (matrix). >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2, 3]]) [[1], [2], [3]] pass","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: # Check if matrix is empty if not matrix or not matrix[0]: raise ValueError(\\"The input matrix must not be empty.\\") # Check if all rows have the same length and contain only integers row_length = len(matrix[0]) for row in matrix: if len(row) != row_length: raise ValueError(\\"All rows in the matrix should have the same length.\\") if not all(isinstance(element, int) for element in row): raise TypeError(\\"All elements in the matrix should be integers.\\") # Transpose the matrix transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] return transposed"},{"question":"from typing import List, Tuple def find_indices(nums: List[int], target: int) -> Tuple[int, int]: Given a list of integers and a target value, find two distinct indices in the list such that the numbers at these indices sum up to the target value. If no such indices exist, return (-1, -1). >>> find_indices([2, 7, 11, 15], 9) (0, 1) >>> find_indices([3, 2, 4], 6) (1, 2) >>> find_indices([3, 3], 6) (0, 1) >>> find_indices([3, 3], 10) (-1, -1) pass # your implementation here # Unit tests def test_find_indices_example1(): nums = [2, 7, 11, 15] target = 9 assert find_indices(nums, target) == (0, 1) def test_find_indices_example2(): nums = [3, 2, 4] target = 6 assert find_indices(nums, target) == (1, 2) def test_find_indices_example3(): nums = [3, 3] target = 6 assert find_indices(nums, target) == (0, 1) def test_find_indices_no_match(): nums = [3, 3] target = 10 assert find_indices(nums, target) == (-1, -1) def test_find_indices_with_negative(): nums = [1, -2, 3, 10] target = 1 assert find_indices(nums, target) == (1, 2) def test_find_indices_multiple_solutions(): nums = [1, 2, 4, 4] target = 8 assert find_indices(nums, target) == (2, 3) or find_indices(nums, target) == (3, 2) def test_find_indices_large_numbers(): nums = [10**5, 10**6, -10**6, -10**5] target = 0 assert find_indices(nums, target) == (0, 3) or find_indices(nums, target) == (1, 2)","solution":"from typing import List, Tuple def find_indices(nums: List[int], target: int) -> Tuple[int, int]: Returns two distinct indices of the numbers in the list that sum up to the target value. If no such indices exist, returns (-1, -1). num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return (num_dict[complement], i) num_dict[num] = i return (-1, -1)"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None self.prev = None def rotate_doubly_linked_list(head: Node, k: int) -> Node: Re-arranges the list such that the node at the k-th position (1-based index) becomes the new head of the list. If k is greater than the length of the list, the list should remain unchanged. >>> head = create_doubly_linked_list([1, 2, 3, 4, 5]) >>> to_list(rotate_doubly_linked_list(head, 3)) [3, 4, 5, 1, 2] >>> head = create_doubly_linked_list([1, 2, 3, 4, 5]) >>> to_list(rotate_doubly_linked_list(head, 6)) [1, 2, 3, 4, 5] >>> head = create_doubly_linked_list([1, 2, 3]) >>> to_list(rotate_doubly_linked_list(head, 1)) [1, 2, 3] pass def create_doubly_linked_list(arr): if not arr: return None head = Node(arr[0]) current = head for value in arr[1:]: new_node = Node(value) current.next = new_node new_node.prev = current current = new_node return head def to_list(head): result = [] current = head while current: result.append(current.data) current = current.next return result","solution":"class Node: def __init__(self, data): self.data = data self.next = None self.prev = None def rotate_doubly_linked_list(head: Node, k: int) -> Node: if not head or k <= 1: return head current = head length = 1 # Find the length of the list and the last node while current.next: current = current.next length += 1 # If k is greater than the length, no rotation is needed if k > length: return head # Find the new head which is the k-th node new_head = head for _ in range(k-1): new_head = new_head.next # Adjust the previous and last node pointers for new head if new_head.prev: new_head.prev.next = None if current: current.next = head head.prev = current new_head.prev = None head = new_head return head # Helper function to create a doubly linked list from an array def create_doubly_linked_list(arr): if not arr: return None head = Node(arr[0]) current = head for value in arr[1:]: new_node = Node(value) current.next = new_node new_node.prev = current current = new_node return head # Helper function to convert doubly linked list to a list (for testing) def to_list(head): result = [] current = head while current: result.append(current.data) current = current.next return result"},{"question":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: Detect all unique palindromic substrings in a given string. A palindrome is a word, phrase, number, or other sequence of characters that reads the same backward as forward. Args: s (str): The input text. Returns: List[str]: A list of unique palindromic substrings. Examples: >>> find_palindromic_substrings(\\"abracadabra\\") [\\"a\\", \\"aca\\", \\"ada\\", \\"b\\", \\"c\\", \\"d\\", \\"r\\"] >>> find_palindromic_substrings(\\"racecar\\") [\\"a\\", \\"aceca\\", \\"cec\\", \\"e\\", \\"r\\", \\"racecar\\"] >>> find_palindromic_substrings(\\"aabb\\") [\\"a\\", \\"aa\\", \\"b\\", \\"bb\\"] >>> find_palindromic_substrings(\\"abcdefg\\") [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"] >>> find_palindromic_substrings(\\"madam\\") [\\"a\\", \\"ada\\", \\"d\\", \\"m\\", \\"madam\\"] pass def test_single_character_string(): assert set(find_palindromic_substrings(\\"a\\")) == {\\"a\\"} def test_no_repeated_characters(): assert set(find_palindromic_substrings(\\"abc\\")) == {\\"a\\", \\"b\\", \\"c\\"} def test_all_characters_repeat(): assert set(find_palindromic_substrings(\\"aaa\\")) == {\\"a\\", \\"aa\\", \\"aaa\\"} def test_mixed_palindromic_and_non_palindromic(): assert set(find_palindromic_substrings(\\"racecar\\")) == {\\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"cec\\", \\"aceca\\", \\"racecar\\"} def test_palindromic_substrings_in_mixed(): assert set(find_palindromic_substrings(\\"abracadabra\\")) == {\\"a\\", \\"b\\", \\"r\\", \\"c\\", \\"d\\", \\"aca\\", \\"ada\\"} def test_case_with_multiple_palindromes(): assert set(find_palindromic_substrings(\\"aabb\\")) == {\\"a\\", \\"aa\\", \\"b\\", \\"bb\\"} def test_no_palindromic_substrings(): assert set(find_palindromic_substrings(\\"abcdefg\\")) == {\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"} def test_full_example(): assert set(find_palindromic_substrings(\\"madam\\")) == {\\"m\\", \\"a\\", \\"d\\", \\"ada\\", \\"madam\\"}","solution":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: def expand_around_center(left: int, right: int): while left >= 0 and right < len(s) and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 if not s: return [] palindromes = set() for i in range(len(s)): expand_around_center(i, i) # Check for odd-length palindromes expand_around_center(i, i+1) # Check for even-length palindromes return list(palindromes)"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Determine if two strings are permutations of each other. >>> is_permutation(\\"abc\\", \\"bca\\") True >>> is_permutation(\\"123456\\", \\"654321\\") True >>> is_permutation(\\"hello\\", \\"bello\\") False >>> is_permutation(\\"aabbcc\\", \\"abcabc\\") True >>> is_permutation(\\"xyz\\", \\"xyz \\") False","solution":"def is_permutation(str1: str, str2: str) -> bool: Determine if two strings are permutations of each other. if len(str1) != len(str2): return False count1 = {} count2 = {} for ch in str1: if ch in count1: count1[ch] += 1 else: count1[ch] = 1 for ch in str2: if ch in count2: count2[ch] += 1 else: count2[ch] = 1 return count1 == count2"},{"question":"def merge_dicts(dict1: dict, dict2: dict) -> dict: Merge two dictionaries, concatenating values into lists in case of key conflicts. >>> merge_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) {'a': 1, 'b': [2, 3], 'c': 4} >>> merge_dicts({'x': 'apple', 'y': 'banana'}, {'y': 'cherry', 'z': 'orange'}) {'x': 'apple', 'y': ['banana', 'cherry'], 'z': 'orange'} >>> merge_dicts({'key1': 100, 'key2': 200}, {'key1': 'new_value', 'key3': 300}) {'key1': ['100', 'new_value'], 'key2': 200, 'key3': 300} >>> merge_dicts({}, {'a': 1, 'b': 2}) {'a': 1, 'b': 2}","solution":"def merge_dicts(dict1: dict, dict2: dict) -> dict: result = dict1.copy() # Start with a copy of the first dictionary for key, value in dict2.items(): if key in result: if isinstance(result[key], list): result[key].append(value) else: if isinstance(result[key], type(value)): result[key] = [result[key], value] else: result[key] = [str(result[key]), str(value)] else: result[key] = value return result"},{"question":"from typing import List def is_pandigital_multiple(num: int) -> bool: Checks whether the given number is a Pandigital Multiple. >>> is_pandigital_multiple(192) #Output: True >>> is_pandigital_multiple(123) #Output: False >>> is_pandigital_multiple(9) #Output: True >>> is_pandigital_multiple(100) #Output: False >>> is_pandigital_multiple(1) #Output: True >>> is_pandigital_multiple(123456) #Output: False pass # Example test cases def test_is_pandigital_multiple_true_case(): assert is_pandigital_multiple(192) == True def test_is_pandigital_multiple_false_case(): assert is_pandigital_multiple(123) == False def test_is_pandigital_multiple_additional_true_case(): assert is_pandigital_multiple(9) == True # multiples are 9, 18, ..., 81 → 918273645 def test_is_pandigital_multiple_additional_false_case(): assert is_pandigital_multiple(100) == False # 100 produces \\"100200300...\\" which is too long def test_is_pandigital_multiple_single_digit_true_case(): assert is_pandigital_multiple(1) == True # multiples are 1, 2, 3, ..., 9 → 123456789 def test_is_pandigital_multiple_6_digit_boundary_case(): assert is_pandigital_multiple(123456) == False","solution":"def is_pandigital_multiple(num: int) -> bool: Checks whether the given number is a Pandigital Multiple. concatenated_result = '' n = 1 while len(concatenated_result) < 9: concatenated_result += str(num * n) n += 1 return len(concatenated_result) == 9 and set(concatenated_result) == set('123456789')"},{"question":"import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score from sklearn.model_selection import train_test_split def data_handling(data: dict) -> tuple: Takes a dictionary containing the dataset and target values and returns a tuple containing the feature data and the target labels. >>> data = {\\"data\\": np.array([[1, 2], [3, 4]]), \\"target\\": np.array([0, 1])} >>> data_handling(data) (np.array([[1, 2], [3, 4]]), np.array([0, 1])) pass def random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray: Initializes and trains a Random Forest classifier on provided training features and target labels, then predicts the target labels for the given test features and returns the predictions. >>> features = np.array([[1, 2], [3, 4], [5, 6]]) >>> target = np.array([0, 1, 0]) >>> test_features = np.array([[1, 2], [3, 4]]) >>> random_forest(features, target, test_features) array([0, 1]) pass def main() -> None: Main function that: - Loads a synthetic customer churn dataset. - Handles the dataset using the data_handling function. - Splits the data into training and testing sets. - Trains the model and makes predictions using the random_forest function. - Computes and prints the Accuracy, F1-Score, Precision, and Recall of the predictions. >>> main() Accuracy: 0.95 F1 Score: 0.95 Precision: 0.94 Recall: 0.95 pass if __name__ == \\"__main__\\": main()","solution":"import numpy as np from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score from sklearn.model_selection import train_test_split def data_handling(data: dict) -> tuple: Takes a dictionary containing the dataset and target values and returns a tuple containing the feature data and the target labels. return (data[\\"data\\"], data[\\"target\\"]) def random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray: Initializes and trains a Random Forest classifier on provided training features and target labels, then predicts the target labels for the given test features and returns the predictions. rf = RandomForestClassifier(n_estimators=100, random_state=42) rf.fit(features, target) predictions = rf.predict(test_features) return predictions def main() -> None: Main function that: - Loads a synthetic customer churn dataset. - Handles the dataset using the data_handling function. - Splits the data into training and testing sets. - Trains the model and makes predictions using the random_forest function. - Computes and prints the Accuracy, F1-Score, Precision, and Recall of the predictions. from sklearn.datasets import make_classification # Generating a synthetic customer churn dataset data, target = make_classification(n_samples=1000, n_features=20, n_informative=2, n_redundant=10, random_state=42) data_dict = {\\"data\\": data, \\"target\\": target} features, target = data_handling(data_dict) x_train, x_test, y_train, y_test = train_test_split(features, target, test_size=0.25, random_state=42) predictions = random_forest(x_train, y_train, x_test) print(f\\"Accuracy: {accuracy_score(y_test, predictions)}\\") print(f\\"F1 Score: {f1_score(y_test, predictions)}\\") print(f\\"Precision: {precision_score(y_test, predictions)}\\") print(f\\"Recall: {recall_score(y_test, predictions)}\\")"},{"question":"from typing import List def find_first_n_palindrome_numbers(n: int) -> List[int]: Returns the first n palindrome numbers in ascending order. >>> find_first_n_palindrome_numbers(5) [1, 2, 3, 4, 5] >>> find_first_n_palindrome_numbers(10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11] def test_single_palindrome(): assert find_first_n_palindrome_numbers(1) == [1] def test_first_five_palindromes(): assert find_first_n_palindrome_numbers(5) == [1, 2, 3, 4, 5] def test_first_ten_palindromes(): assert find_first_n_palindrome_numbers(10) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11] def test_invalid_input(): try: find_first_n_palindrome_numbers(0) assert False, \\"Expected ValueError\\" except ValueError: pass try: find_first_n_palindrome_numbers(-5) assert False, \\"Expected ValueError\\" except ValueError: pass try: find_first_n_palindrome_numbers(\\"100\\") assert False, \\"Expected ValueError\\" except ValueError: pass def test_large_n(): assert find_first_n_palindrome_numbers(20) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111]","solution":"from typing import List def find_first_n_palindrome_numbers(n: int) -> List[int]: Returns the first n palindrome numbers in ascending order. if not isinstance(n, int) or n <= 0: raise ValueError(\\"n should be a positive integer\\") def is_palindrome(num: int) -> bool: s = str(num) return s == s[::-1] result = [] num = 1 while len(result) < n: if is_palindrome(num): result.append(num) num += 1 return result"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: Given the root of a binary tree, assume you are standing on the right side of it, return an array of the values of the nodes you can see ordered from top to bottom. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> rightSideView(root) [1, 3, 4] pass import pytest def test_empty_tree(): assert rightSideView(None) == [] def test_single_node(): root = TreeNode(1) assert rightSideView(root) == [1] def test_complete_binary_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert rightSideView(root) == [1, 3, 7] def test_right_side_view(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) root.right.right = TreeNode(4) assert rightSideView(root) == [1, 3, 4] def test_unbalanced_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert rightSideView(root) == [1, 2, 3, 4] def test_full_left_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert rightSideView(root) == [1, 2, 3, 4] pytest.main()","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if level == len(result): result.append(node.val) if node.right: queue.append((node.right, level + 1)) if node.left: queue.append((node.left, level + 1)) return result"},{"question":"def max_depth(root: int, tree: dict) -> int: Compute the maximum depth of a tree representing a company's hierarchy. >>> max_depth(1, {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: [7, 8], 7: [], 8: []}) == 4 >>> max_depth(1, {1: []}) == 1 >>> max_depth(1, {1: [2], 2: [3], 3: [4], 4: [5], 5: []}) == 5 >>> max_depth(1, {1: [],}) == 1 >>> max_depth(1, {1: [2, 3, 4, 5], 2: [], 3: [], 4: [], 5: []}) == 2 >>> max_depth(1, {1: [2, 3], 2: [4], 3: [5, 6], 4: [7], 5: [], 6: [], 7: [8], 8: []}) == 5","solution":"def max_depth(root: int, tree: dict) -> int: def depth(node): if node not in tree or not tree[node]: return 1 return 1 + max(depth(child) for child in tree[node]) return depth(root)"},{"question":"from typing import List, Dict def calculate_total_score(scores: Dict[str, List[int]]) -> int: Calculate the total score for a student based on their assignment scores. >>> calculate_total_score({\\"homework\\": [90, 85, 80], \\"exam\\": [88], \\"project\\": [92]}) 435 >>> calculate_total_score({\\"homework\\": [], \\"exam\\": []}) 0 def determine_grade(total_score: int) -> str: Determine the grade for a student based on the total score. >>> determine_grade(435) 'A' >>> determine_grade(75) 'C' >>> determine_grade(-5) Traceback (most recent call last): ... ValueError: Total score must be a non-negative integer. import pytest def test_calculate_total_score_valid_inputs(): assert calculate_total_score({\\"homework\\": [90, 85, 80], \\"exam\\": [88], \\"project\\": [92]}) == 435 assert calculate_total_score({\\"homework\\": [], \\"exam\\": []}) == 0 assert calculate_total_score({\\"homework\\": [50], \\"exam\\": [50]}) == 100 assert calculate_total_score({\\"homework\\": [10, 20, 30], \\"exam\\": [40, 50], \\"project\\": [60, 70]}) == 280 def test_calculate_total_score_missing_categories(): assert calculate_total_score({}) == 0 def test_determine_grade_valid_inputs(): assert determine_grade(435) == 'A' assert determine_grade(85) == 'B' assert determine_grade(75) == 'C' assert determine_grade(65) == 'D' assert determine_grade(55) == 'F' assert determine_grade(90) == 'A' assert determine_grade(80) == 'B' assert determine_grade(70) == 'C' assert determine_grade(60) == 'D' assert determine_grade(0) == 'F' def test_determine_grade_invalid_inputs(): with pytest.raises(ValueError, match=\\"Total score must be a non-negative integer.\\"): determine_grade(-5) with pytest.raises(ValueError, match=\\"Total score must be a non-negative integer.\\"): determine_grade(\\"A\\") with pytest.raises(ValueError, match=\\"Total score must be a non-negative integer.\\"): determine_grade(None)","solution":"def calculate_total_score(scores): Calculate the total score for a student based on their assignment scores. :param scores: dict where keys are assignment categories and values are lists of integer scores :return: int total score total_score = 0 for category, score_list in scores.items(): if score_list: # If the list is not empty total_score += sum(score_list) return total_score def determine_grade(total_score): Determine the grade for a student based on the total score. :param total_score: int representing the total score :return: str grade corresponding to the total score if not isinstance(total_score, int) or total_score < 0: raise ValueError(\\"Total score must be a non-negative integer.\\") if total_score >= 90: return 'A' elif total_score >= 80: return 'B' elif total_score >= 70: return 'C' elif total_score >= 60: return 'D' else: return 'F'"},{"question":"from typing import List, Tuple def shortest_path_bfs(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> List[Tuple[int, int]]: Implements the Breadth-First Search (BFS) algorithm to find the shortest path between start and destination on a grid map. If no path exists, returns an empty list. >>> shortest_path_bfs( [ [0, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ], (0, 0), (4, 4) ) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (2, 4), (3, 4), (4, 4)] >>> shortest_path_bfs( [ [0, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ], (0, 0), (3, 3) ) [] >>> shortest_path_bfs( [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ], (0, 0), (2, 2) ) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] >>> shortest_path_bfs([[0] * 50 for _ in range(50)], (0, 0), (49, 49)) # Output: Path exists in large grid example","solution":"from typing import List, Tuple from collections import deque def shortest_path_bfs(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(grid), len(grid[0]) adj_directions = [(-1,0), (1,0), (0,-1), (0,1)] # up, down, left, right if grid[start[0]][start[1]] == 1 or grid[destination[0]][destination[1]] == 1: return [] q = deque([(start, [start])]) visited = set() visited.add(start) while q: (current, path) = q.popleft() if current == destination: return path for d in adj_directions: new_row, new_col = current[0] + d[0], current[1] + d[1] if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: new_path = path + [(new_row, new_col)] q.append(((new_row, new_col), new_path)) visited.add((new_row, new_col)) return []"},{"question":"def distribute_events(total_events: int, num_days: int) -> list[int]: Distributes total_events across num_days as evenly as possible. Args: total_events (int): The total number of events to distribute. num_days (int): The number of days to distribute events across. Returns: list[int]: A list of integers where each element represents the number of events assigned to each respective day. Examples: >>> distribute_events(10, 3) [4, 3, 3] >>> distribute_events(7, 7) [1, 1, 1, 1, 1, 1, 1] >>> distribute_events(0, 5) [0, 0, 0, 0, 0] >>> distribute_events(13, 5) [3, 3, 3, 2, 2] from solution import distribute_events def test_distribute_even_events(): assert distribute_events(10, 3) == [4, 3, 3] def test_distribute_equal_days_events(): assert distribute_events(7, 7) == [1, 1, 1, 1, 1, 1, 1] def test_distribute_zero_events(): assert distribute_events(0, 5) == [0, 0, 0, 0, 0] def test_distribute_more_days_than_events(): assert distribute_events(2, 5) == [1, 1, 0, 0, 0] def test_distribute_uneven_events(): assert distribute_events(13, 5) == [3, 3, 3, 2, 2] def test_distribute_one_day(): assert distribute_events(10, 1) == [10] def test_distribute_large_number_of_events(): result = distribute_events(1000000, 365) expected_base = 1000000 // 365 extra_days = 1000000 % 365 for i in range(extra_days): assert result[i] == expected_base + 1 for i in range(extra_days, 365): assert result[i] == expected_base def test_distribute_single_event_multiple_days(): assert distribute_events(1, 5) == [1, 0, 0, 0, 0]","solution":"def distribute_events(total_events: int, num_days: int) -> list[int]: Distributes total_events across num_days as evenly as possible. Args: total_events (int): The total number of events to distribute. num_days (int): The number of days to distribute events across. Returns: list[int]: A list of integers where each element represents the number of events assigned to each respective day. # Initialize the base number of events per day base_events = total_events // num_days # Calculate the number of days that will have one extra event extra_events_days = total_events % num_days # Generate the list with base events distribution = [base_events] * num_days # Distribute the extra events across the first 'extra_events_days' days for i in range(extra_events_days): distribution[i] += 1 return distribution"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. The Roman numeral representation follows these values: >>> int_to_roman(58) == \\"LVIII\\" >>> int_to_roman(1994) == \\"MCMXCIV\\" >>> int_to_roman(2021) == \\"MMXXI\\" >>> int_to_roman(1) == \\"I\\" >>> int_to_roman(4) == \\"IV\\" >>> int_to_roman(9) == \\"IX\\" >>> int_to_roman(44) == \\"XLIV\\" >>> int_to_roman(3999) == \\"MMMCMXCIX\\" >>> int_to_roman(1000) == \\"M\\" >>> int_to_roman(500) == \\"D\\" >>> int_to_roman(1500) == \\"MD\\" >>> int_to_roman(1987) == \\"MCMLXXXVII\\" >>> int_to_roman(1666) == \\"MDCLXVI\\" pass","solution":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. The Roman numeral representation follows these values: - M = 1000 - CM = 900 - D = 500 - CD = 400 - C = 100 - XC = 90 - L = 50 - XL = 40 - X = 10 - IX = 9 - V = 5 - IV = 4 - I = 1 val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] symbols = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = [] for i in range(len(val)): while num >= val[i]: num -= val[i] roman_numeral.append(symbols[i]) return \\"\\".join(roman_numeral)"},{"question":"class AVLNode: def __init__(self, key): self.left = None self.right = None self.key = key self.height = 1 class AVLTree: def insert(self, root: AVLNode, key: int) -> AVLNode: Insert a new value into the AVL tree and maintain its balanced property. Args: root (AVLNode): The root node of the AVL tree. key (int): The integer value to be inserted into the tree. Returns: AVLNode: The new root of the AVL tree after insertion. >>> tree = AVLTree() >>> root = tree.insert(None, 10) >>> root.key 10 >>> root.height 1 >>> root = tree.insert(root, 20) >>> root = tree.insert(root, 30) >>> root.key 20 >>> root.height 2 >>> root.left.key 10 >>> root.right.key 30","solution":"class AVLNode: def __init__(self, key): self.left = None self.right = None self.key = key self.height = 1 class AVLTree: # Function to insert a node def insert(self, root: AVLNode, key: int) -> AVLNode: # Helper function to get the height of a node def get_height(node): if not node: return 0 return node.height # Helper function to get the balance factor of a node def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) # Helper function to perform a right rotation def right_rotate(z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = max(get_height(z.left), get_height(z.right)) + 1 y.height = max(get_height(y.left), get_height(y.right)) + 1 return y # Helper function to perform a left rotation def left_rotate(z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = max(get_height(z.left), get_height(z.right)) + 1 y.height = max(get_height(y.left), get_height(y.right)) + 1 return y # Step 1: Perform the normal BST insertion if not root: return AVLNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) # Step 2: Update the height of this ancestor node root.height = max(get_height(root.left), get_height(root.right)) + 1 # Step 3: Get the balance factor of this ancestor node balance = get_balance(root) # Step 4: If the node is unbalanced, then there are 4 cases # Left Left Case if balance > 1 and key < root.left.key: return right_rotate(root) # Right Right Case if balance < -1 and key > root.right.key: return left_rotate(root) # Left Right Case if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) # Right Left Case if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) return root"},{"question":"You need to implement a function \`min_operations_to_transform(s1: str, s2: str) -> int\` that returns the minimum number of operations needed to transform string \`s1\` into string \`s2\`. The allowed operations are inserting a character, deleting a character, or replacing a character. # Example def min_operations_to_transform(s1: str, s2: str) -> int: Returns the minimum number of operations needed to transform string s1 into string s2. Allowed operations are insertion, deletion, and substitution. m, n = len(s1), len(s2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If the first string is empty, insert all characters of the second string elif j == 0: dp[i][j] = i # If the second string is empty, remove all characters of the first string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are equal, no more operations are needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]","solution":"def min_operations_to_transform(s1: str, s2: str) -> int: Returns the minimum number of operations needed to transform string s1 into string s2. Allowed operations are insertion, deletion, and substitution. m, n = len(s1), len(s2) # Create a DP table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If the first string is empty, insert all characters of the second string elif j == 0: dp[i][j] = i # If the second string is empty, remove all characters of the first string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last characters are equal, no more operations are needed else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"import hashlib from typing import List def generate_hashes(str_list: List[str]) -> List[int]: Generates a unique hash for each string in the input list. Args: str_list (List[str]): List of strings to be hashed. Returns: List[int]: List of hashes for each input string. Example Usages: >>> generate_hashes(['apple', 'banana', 'cherry']) [99162322, 225786220, 267283956] >>> generate_hashes(['dog', 'cat', 'fish']) [957123, 3221818, 101234501] >>> generate_hashes(['The quick brown fox', 'jumps over the', 'lazy dog']) [210748555, 518975106, 143242355]","solution":"import hashlib def generate_hashes(str_list): Generates a unique hash for each string in the input list. Parameters: str_list (list of str): List of strings to be hashed. Returns: list of int: List of hashes for each input string. hashes = [] for s in str_list: hash_value = int(hashlib.md5(s.encode()).hexdigest(), 16) hashes.append(hash_value) return hashes"},{"question":"# Substring Search in a Composite String Determine if the target string can be constructed by concatenating repeated substrings of the source string. def can_construct(source, target): Determine if the target string can be constructed by concatenating repeated substrings of the source string. Parameters: source (str): The source string. target (str): The target string. Returns: bool: True if the target can be constructed, otherwise False. if len(target) % len(source) != 0: return False repeat_count = len(target) // len(source) repeated_source = source * repeat_count return repeated_source == target >>> can_construct(\\"abc\\", \\"abcabcabc\\") True >>> can_construct(\\"ab\\", \\"abababab\\") True >>> can_construct(\\"abc\\", \\"abcab\\") False >>> can_construct(\\"abc\\", \\"abca\\") False >>> can_construct(\\"a\\", \\"aaaaa\\") True >>> can_construct(\\"a\\", \\"aaaab\\") False >>> can_construct(\\"xyz\\", \\"xyz\\") True >>> can_construct(\\"abc\\" * 33, \\"abc\\" * 3300) True >>> can_construct(\\"abc\\" * 33, \\"abc\\" * 3301) False","solution":"def can_construct(source, target): Determine if the target string can be constructed by concatenating repeated substrings of the source string. Parameters: source (str): The source string. target (str): The target string. Returns: bool: True if the target can be constructed, False otherwise. # Check if length of target is a multiple of the source length if len(target) % len(source) != 0: return False # Calculate the number of times the source needs to be repeated repeat_count = len(target) // len(source) # Form the repeated string repeated_source = source * repeat_count # Check if repeated string matches the target return repeated_source == target"},{"question":"class SimpleFileSystem: SimpleFileSystem class that simulates basic filesystem operations like adding files, creating directories, deleting files and directories, and listing contents. def __init__(self): Initializes the filesystem object with a root directory ('/'). pass def create_file(self, path: str) -> None: Creates a new file at the specified path. Args: path: str - The path where the file will be created (e.g., \`/home/user/file.txt\`). pass def create_directory(self, path: str) -> None: Creates a new directory at the specified path. Args: path: str - The path where the directory will be created (e.g., \`/home/user/docs\`). pass def delete(self, path: str) -> None: Deletes a file or directory at the specified path. Args: path: str - The path of the file or directory to delete (e.g., \`/home/user/file.txt\`). pass def list_contents(self, path: str) -> list[str]: Lists all files and directories at the specified path. Args: path: str - The path whose contents will be listed (e.g., \`/home/user\`). Returns: list: A list of file and directory names. pass import pytest def test_create_directory(): fs = SimpleFileSystem() fs.create_directory('/home') assert 'home' in fs.fs['/'] def test_create_file(): fs = SimpleFileSystem() fs.create_directory('/home/user') fs.create_file('/home/user/file.txt') contents = fs.list_contents('/home/user') assert 'file.txt' in contents def test_list_contents(): fs = SimpleFileSystem() fs.create_directory('/home/user/docs') fs.create_file('/home/user/docs/file1.txt') fs.create_file('/home/user/docs/file2.txt') assert fs.list_contents('/home/user/docs') == ['file1.txt', 'file2.txt'] def test_delete_file(): fs = SimpleFileSystem() fs.create_directory('/home/user/docs') fs.create_file('/home/user/docs/file1.txt') fs.delete('/home/user/docs/file1.txt') assert fs.list_contents('/home/user/docs') == [] def test_delete_directory(): fs = SimpleFileSystem() fs.create_directory('/home/user/docs') fs.create_file('/home/user/docs/file1.txt') fs.create_directory('/home/user/docs/subdir') fs.delete('/home/user/docs/subdir') assert fs.list_contents('/home/user/docs') == ['file1.txt'] def test_delete_non_existent(): fs = SimpleFileSystem() with pytest.raises(FileNotFoundError): fs.delete('/nonexistent') def test_list_non_existent(): fs = SimpleFileSystem() with pytest.raises(FileNotFoundError): fs.list_contents('/nonexistent') def test_not_a_directory(): fs = SimpleFileSystem() fs.create_directory('/home/user/docs') fs.create_file('/home/user/docs/file1.txt') with pytest.raises(NotADirectoryError): fs.list_contents('/home/user/docs/file1.txt')","solution":"class SimpleFileSystem: def __init__(self): self.fs = {'/': {}} def _navigate_to(self, path: str): Helper method to navigate the given path and return the directory (or file) referenced by the path. current = self.fs['/'] parts = path.strip('/').split('/') for part in parts: if part: if part in current: current = current[part] else: raise FileNotFoundError(f\\"Path not found: {path}\\") return current def create_file(self, path: str) -> None: parts = path.strip('/').split('/') file_name = parts.pop() current = self._navigate_to('/' + '/'.join(parts)) if file_name in current: raise FileExistsError(f\\"File already exists: {path}\\") current[file_name] = None def create_directory(self, path: str) -> None: parts = path.strip('/').split('/') current = self.fs['/'] for part in parts: if part not in current: current[part] = {} current = current[part] def delete(self, path: str) -> None: parts = path.strip('/').split('/') item_to_delete = parts.pop() parent = self._navigate_to('/' + '/'.join(parts)) if item_to_delete in parent: del parent[item_to_delete] else: raise FileNotFoundError(f\\"Item to delete not found: {path}\\") def list_contents(self, path: str) -> list: directory = self._navigate_to(path) if isinstance(directory, dict): return sorted(directory.keys()) else: raise NotADirectoryError(f\\"Not a directory: {path}\\")"},{"question":"def binary_search(collection: list, target: int) -> int: Returns the index of target in the sorted list collection or -1 if the target is not found. >>> binary_search([1, 2, 3, 4, 5], 3) == 2 >>> binary_search([1, 2, 3, 4, 5], 6) == -1 >>> binary_search([-10, -5, 0, 5, 10], -5) == 1 >>> binary_search([], 3) == -1 >>> binary_search([3], 3) == 0","solution":"def binary_search(collection: list, target: int) -> int: Returns the index of target in the sorted list collection or -1 if the target is not found. left, right = 0, len(collection) - 1 while left <= right: mid = (left + right) // 2 if collection[mid] == target: return mid elif collection[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\"","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. Args: s (str): The input string. Returns: str: The longest substring without repeating characters. n = len(s) if n == 0: return \\"\\" char_map = {} max_length = 0 max_start = 0 start = 0 for end in range(n): if s[end] in char_map and char_map[s[end]] >= start: start = char_map[s[end]] + 1 char_map[s[end]] = end if end - start + 1 > max_length: max_length = end - start + 1 max_start = start return s[max_start:max_start + max_length]"},{"question":"def log_suspicious_transactions(transactions: list[dict[str, any]]) -> list[str]: Given a list of transaction records, identify suspicious transactions and log their information. Parameters: transactions: A list of dictionaries where each dictionary represents a transaction record and contains the keys 'transaction_id', 'amount', and 'description'. Returns: A list of strings, each containing the transaction ID and a message indicating the suspicious activity. >>> log_suspicious_transactions([ {'transaction_id': 'TX123', 'amount': 5000.0, 'description': 'Utility bill payment'}, {'transaction_id': 'TX124', 'amount': 20000.0, 'description': 'Car purchase'}, {'transaction_id': 'TX125', 'amount': 300.0, 'description': 'Grocery shopping'} ]) ['Transaction ID: TX124, Message: Suspicious transaction detected (amount exceeds 10,000).'] >>> log_suspicious_transactions([]) [] >>> log_suspicious_transactions([ {'transaction_id': 'TX123', 'amount': 5000.0, 'description': 'Utility bill payment'}, {'transaction_id': 'TX125', 'amount': 300.0, 'description': 'Grocery shopping'} ]) []","solution":"def log_suspicious_transactions(transactions): Given a list of transaction records, identify suspicious transactions and log their information. Parameters: transactions: A list of dictionaries where each dictionary represents a transaction record and contains the keys 'transaction_id', 'amount', and 'description'. Returns: A list of strings, each containing the transaction ID and a message indicating the suspicious activity. suspicious_logs = [] for transaction in transactions: if transaction['amount'] > 10000.0: suspicious_logs.append( f\\"Transaction ID: {transaction['transaction_id']}, Message: Suspicious transaction detected (amount exceeds 10,000).\\" ) return suspicious_logs"},{"question":"from typing import List, Tuple def has_event_conflicts(events: List[Tuple[str, str]]) -> bool: Checks if there are any conflicts among the given calendar events. :param events: A list of tuples, where each tuple contains two strings representing the start and end times of an event. :return: True if there is any conflict, False otherwise. >>> events = [(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"11:00\\"), (\\"11:30\\", \\"12:00\\")] >>> has_event_conflicts(events) True >>> events = [(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:00\\"), (\\"11:30\\", \\"12:00\\")] >>> has_event_conflicts(events) False pass def test_no_conflict(): events = [(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:00\\"), (\\"11:30\\", \\"12:00\\")] assert not has_event_conflicts(events) def test_one_conflict(): events = [(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"11:00\\"), (\\"11:30\\", \\"12:00\\")] assert has_event_conflicts(events) def test_multiple_conflicts(): events = [(\\"09:00\\", \\"10:00\\"), (\\"09:00\\", \\"09:30\\"), (\\"09:15\\", \\"09:45\\")] assert has_event_conflicts(events) def test_edge_case_no_conflict(): events = [(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")] assert not has_event_conflicts(events) def test_single_event(): events = [(\\"09:00\\", \\"10:00\\")] assert not has_event_conflicts(events) def test_back_to_back_events(): events = [(\\"08:00\\", \\"09:00\\"), (\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\")] assert not has_event_conflicts(events)","solution":"def has_event_conflicts(events): Checks if there are any conflicts among the given calendar events. :param events: A list of tuples, where each tuple contains two strings representing the start and end times of an event. :return: True if there is any conflict, False otherwise. # First, we need to sort events by their start time events.sort(key=lambda x: x[0]) # Iterate through the events to check for any overlap for i in range(len(events) - 1): current_end_time = events[i][1] next_start_time = events[i+1][0] # If the current event's end time is later than the next event's start time, we have a conflict if current_end_time > next_start_time: return True return False"},{"question":"import heapq def k_largest_elements(data: list[int], k: int) -> list[int]: Finds the k largest elements in the provided data list using a min-heap. :param data: A list of integers. :param k: The number of largest elements to find. :return: A list containing the k largest elements in descending order. >>> k_largest_elements([10, 5, 2, 7, 8, 7], 3) [10, 8, 7] >>> k_largest_elements([1, 23, 12, 9, 30, 2, 50], 4) [50, 30, 23, 12] >>> k_largest_elements([1, 23, 12, 9, 30, 2, 50], 0) [] >>> k_largest_elements([4, 1, 7, 3, 8, 5, 2], 7) [8, 7, 5, 4, 3, 2, 1] >>> k_largest_elements([5, 5, 5, 5, 5, 5], 3) [5, 5, 5] >>> k_largest_elements([-5, -2, -1, -10, -7], 2) [-1, -2] >>> k_largest_elements([3, -1, 0, 7, -5, 8, 2], 5) [8, 7, 3, 2, 0]","solution":"import heapq def k_largest_elements(data: list[int], k: int) -> list[int]: Finds the k largest elements in the provided data list. :param data: A list of integers. :param k: The number of largest elements to find. :return: A list containing the k largest elements in descending order. if k == 0: return [] # Create a min-heap with the first k elements. min_heap = data[:k] heapq.heapify(min_heap) # Iterate through the rest of the elements. for num in data[k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) # Sort the min-heap in descending order. return sorted(min_heap, reverse=True)"},{"question":"from typing import List, Dict, Tuple def identify_invariants(data: List[int]) -> Tuple[Dict[str, str], Dict[str, str]]: Identify and explain loop invariants in the process_array function that processes an array. The invariants tell which conditions are maintained before and after every iteration of the loops. Returns a tuple containing two dictionaries: - The first dictionary has loop identifiers as keys and their corresponding invariant as values. - The second dictionary provides explanations for why each invariant holds. invariants = {} explanations = {} invariants['i_loop'] = 'For any iteration k, result[k] = data[k] - data[k - 1]' explanations['i_loop'] = 'After each iteration of the loop, the difference between data[k] and data[k - 1] is stored in result[k], ensuring the algorithm accurately computes differences for each element.' return invariants, explanations # Example Usage: invariants, explanations = identify_invariants([1, 2, 4, 7, 11]) print(invariants) # {'i_loop': 'For any iteration k, result[k] = data[k] - data[k - 1]'} print(explanations) # {'i_loop': 'After each iteration of the loop, the difference between data[k] and data[k - 1] is stored in result[k], ensuring the algorithm accurately computes differences for each element.'}","solution":"from typing import List, Dict, Tuple def identify_invariants(data: List[int]) -> Tuple[Dict[str, str], Dict[str, str]]: invariants = {} explanations = {} invariants['i_loop'] = 'For any iteration k, result[k] = data[k] - data[k - 1]' explanations['i_loop'] = 'After each iteration of the loop, the difference between data[k] and data[k - 1] is stored in result[k], ensuring the algorithm accurately computes differences for each element.' return invariants, explanations"},{"question":"def first_unread_page(read_pages: list, total_pages: int) -> int: Determines the first unread page in a book. >>> first_unread_page([1, 2, 4, 5], 6) 3 >>> first_unread_page([1, 2, 3, 4, 5, 6], 6) -1 >>> first_unread_page([], 6) 1 >>> first_unread_page([1, 2, 3, 4, 5], 6) 6 >>> first_unread_page([2, 3, 4, 5], 6) 1","solution":"def first_unread_page(read_pages, total_pages): Determines the first unread page in a book. # Create a set of read pages for quick lookup read_pages_set = set(read_pages) # Iterate through the range of pages 1 to total_pages for page in range(1, total_pages + 1): if page not in read_pages_set: return page # If all pages are read, return -1 return -1"},{"question":"def calculate_attendance(records: List[str]) -> dict: Calculate the total number of days each employee has attended work in a given month, based on the given attendance records. Args: records (List[str]): A list of strings containing the attendance records. Returns: dict: A dictionary where the keys are employee names and the values are the number of days they attended. Examples: >>> calculate_attendance([\\"2023-01-01: Alice, Bob, Charlie\\", \\"2023-01-02: Alice, Charlie\\", \\"2023-01-03: Bob, Charlie\\"]) {\\"Alice\\": 2, \\"Bob\\": 2, \\"Charlie\\": 3} >>> calculate_attendance([\\"2023-01-01: Alice, Bob\\"]) {\\"Alice\\": 1, \\"Bob\\": 1}","solution":"from typing import List, Dict def calculate_attendance(records: List[str]) -> Dict[str, int]: attendance_dict = {} for record in records: date, attendees = record.split(\\": \\") names = attendees.split(\\", \\") for name in names: if name in attendance_dict: attendance_dict[name] += 1 else: attendance_dict[name] = 1 return attendance_dict"},{"question":"def dynamic_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using dynamic programming. >>> dynamic_fibonacci(0) # Should return 0 >>> dynamic_fibonacci(1) # Should return 1 >>> dynamic_fibonacci(10) # Should return 55 >>> dynamic_fibonacci(50) # Should return 12586269025 >>> dynamic_fibonacci(100000) # Output will be a huge number, ensure your function handles this efficiently","solution":"def dynamic_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using dynamic programming. if n == 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"def rearrange_alternately(arr: list) -> list: Rearranges the array such that the elements are in an alternate max/min form. Achieves O(n) time complexity and O(1) extra space complexity. Parameters: arr (list): A list of integers sorted in non-decreasing order. Returns: list: A list of integers rearranged alternatively. Example: >>> rearrange_alternately([1, 2, 3, 4, 5, 6]) [6, 1, 5, 2, 4, 3] >>> rearrange_alternately([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) [100, 10, 90, 20, 80, 30, 70, 40, 60, 50] >>> rearrange_alternately([1, 3, 5, 7, 9]) [9, 1, 7, 3, 5] >>> rearrange_alternately([5, 5, 5, 5, 5, 5]) [5, 5, 5, 5, 5, 5]","solution":"def rearrange_alternately(arr: list) -> list: Rearranges the array such that the elements are in an alternate max/min form. Achieves O(n) time complexity and O(1) extra space complexity. Parameters: arr (list): A list of integers sorted in non-decreasing order. Returns: list: A list of integers rearranged alternatively. n = len(arr) max_idx = n - 1 min_idx = 0 max_elem = arr[-1] + 1 # A number greater than the max element in the array for i in range(n): if i % 2 == 0: arr[i] += (arr[max_idx] % max_elem) * max_elem max_idx -= 1 else: arr[i] += (arr[min_idx] % max_elem) * max_elem min_idx += 1 for i in range(n): arr[i] = arr[i] // max_elem return arr"},{"question":"import bisect from typing import List def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest increasing subsequence. Args: nums (List[int]): An array of integers representing the sequence. Returns: int: The length of the longest increasing subsequence. Example: >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 10 >>> length_of_LIS([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> length_of_LIS([3, 10, 2, 1, 20]) 3 >>> length_of_LIS([]) 0 >>> length_of_LIS([7]) 1 >>> length_of_LIS([2, 2, 2, 2, 2]) 1 >>> length_of_LIS([-1, 3, 4, -2, 2, 2, 2, 3, 4, 5, 6, 7, -3, -5, -8, 6, 7, 8, 3, 2, 1, 4, -7, -9]) 8","solution":"import bisect def length_of_LIS(nums): Returns the length of the longest increasing subsequence. if not nums: return 0 lis = [] for num in nums: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"class InventorySystem: Online Book Store Inventory Management This class provides functionalities to manage the inventory of books in an online book store. Example Usage: >>> inventory = InventorySystem() >>> inventory.add_book(\\"1234567890\\", 50) # Add 50 copies of book with ISBN \\"1234567890\\" >>> inventory.add_book(\\"0987654321\\", 30) # Add 30 copies of book with ISBN \\"0987654321\\" >>> inventory.get_stock(\\"1234567890\\") # Output: 50 >>> inventory.sell_book(\\"1234567890\\", 10) # Output: \\"Sale successful\\" >>> inventory.get_stock(\\"1234567890\\") # Output: 40 >>> inventory.sell_book(\\"0987654321\\", 40) # Output: \\"Out of stock\\" def __init__(self) -> None: Initialize the inventory system with no books initially. pass def add_book(self, isbn: str, quantity: int) -> None: Add a certain quantity of a book to the inventory using its ISBN. pass def sell_book(self, isbn: str, quantity: int) -> str: Sell a certain quantity of a book. If the requested quantity exceeds the available stock, return \\"Out of stock\\", otherwise adjust the inventory accordingly and return \\"Sale successful\\". pass def get_stock(self, isbn: str) -> int: Return the current stock level of a given book by its ISBN. pass # Example test cases def test_add_and_get_stock(): inventory = InventorySystem() inventory.add_book(\\"1234567890\\", 50) inventory.add_book(\\"0987654321\\", 30) assert inventory.get_stock(\\"1234567890\\") == 50 assert inventory.get_stock(\\"0987654321\\") == 30 def test_sell_book_success(): inventory = InventorySystem() inventory.add_book(\\"1234567890\\", 50) assert inventory.sell_book(\\"1234567890\\", 10) == \\"Sale successful\\" assert inventory.get_stock(\\"1234567890\\") == 40 def test_sell_book_out_of_stock(): inventory = InventorySystem() inventory.add_book(\\"1234567890\\", 10) assert inventory.sell_book(\\"1234567890\\", 20) == \\"Out of stock\\" assert inventory.get_stock(\\"1234567890\\") == 10 def test_sell_exact_stock(): inventory = InventorySystem() inventory.add_book(\\"1234567890\\", 10) assert inventory.sell_book(\\"1234567890\\", 10) == \\"Sale successful\\" assert inventory.get_stock(\\"1234567890\\") == 0 def test_get_stock_for_non_existent_book(): inventory = InventorySystem() assert inventory.get_stock(\\"nonexistent\\") == 0 def test_add_book_increase_stock(): inventory = InventorySystem() inventory.add_book(\\"1234567890\\", 10) inventory.add_book(\\"1234567890\\", 5) assert inventory.get_stock(\\"1234567890\\") == 15","solution":"class InventorySystem: def __init__(self) -> None: self.inventory = {} def add_book(self, isbn: str, quantity: int) -> None: if isbn in self.inventory: self.inventory[isbn] += quantity else: self.inventory[isbn] = quantity def sell_book(self, isbn: str, quantity: int) -> str: if isbn not in self.inventory or self.inventory[isbn] < quantity: return \\"Out of stock\\" else: self.inventory[isbn] -= quantity return \\"Sale successful\\" def get_stock(self, isbn: str) -> int: return self.inventory.get(isbn, 0)"},{"question":"def find_kth_largest(nums: list[int], k: int) -> int: Find the k-th largest element in an unsorted array. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([1], 1) 1","solution":"import heapq def find_kth_largest(nums: list[int], k: int) -> int: Returns the k-th largest element in an unsorted array. # Use a min-heap to keep track of the largest k elements heap = [] for num in nums: heapq.heappush(heap, num) if len(heap) > k: heapq.heappop(heap) return heap[0]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root: TreeNode, target: float) -> int: Finds the value in the BST that is closest to the target value. Args: root (TreeNode): A reference to the root node of a balanced BST. target (float): The target value. Returns: int: The integer value from the BST closest to the target value. >>> root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5)) >>> closest_value(root, 3.714286) 4 >>> root = TreeNode(10, TreeNode(5), TreeNode(20)) >>> closest_value(root, 19) 20 pass # Your code goes here def test_closest_value_single_node(): root = TreeNode(5) assert closest_value(root, 3.7) == 5 def test_closest_value_small_tree(): root = TreeNode(10, TreeNode(5), TreeNode(15)) assert closest_value(root, 14) == 15 assert closest_value(root, 6) == 5 def test_closest_value_large_tree(): root = TreeNode(10, TreeNode(5, TreeNode(2), TreeNode(8)), TreeNode(20, TreeNode(15), TreeNode(25))) assert closest_value(root, 22) == 20 assert closest_value(root, 23) == 25 assert closest_value(root, 1) == 2 def test_closest_value_exact_match(): root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5)) assert closest_value(root, 4) == 4 assert closest_value(root, 1) == 1 def test_closest_value_negative_target(): root = TreeNode(8, TreeNode(3, TreeNode(1), TreeNode(6)), TreeNode(10, None, TreeNode(14, TreeNode(13)))) assert closest_value(root, -1) == 1 def test_closest_value_large_target(): root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5)) assert closest_value(root, 100) == 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root: TreeNode, target: float) -> int: Finds the value in the BST that is closest to the target value. closest = root.val while root: # Update the closest value if the current value is closer to the target if abs(root.val - target) < abs(closest - target): closest = root.val # Since it's a BST, use the property of BST to decide the direction if target < root.val: root = root.left else: root = root.right return closest"},{"question":"class BiDict: def __init__(self): Initialize an empty Bi-Directional Dictionary. def add_pair(self, key, value): Adds a new key-value pair to the Bi-Directional Dictionary. >>> bi_dict = BiDict() >>> bi_dict.add_pair(\\"USA\\", \\"Washington\\") >>> bi_dict.get_by_key(\\"USA\\") 'Washington' >>> bi_dict.get_by_value(\\"Washington\\") 'USA' def remove_pair(self, key): Removes a key-value pair from the Bi-Directional Dictionary. >>> bi_dict = BiDict() >>> bi_dict.add_pair(\\"Germany\\", \\"Berlin\\") >>> bi_dict.remove_pair(\\"Germany\\") >>> bi_dict.get_by_key(\\"Germany\\") Traceback (most recent call last): ... KeyError: 'Key does not exist' def get_by_key(self, key): Returns the value associated with the given key. >>> bi_dict = BiDict() >>> bi_dict.add_pair(\\"France\\", \\"Paris\\") >>> bi_dict.get_by_key(\\"France\\") 'Paris' def get_by_value(self, value): Returns the key associated with the given value. >>> bi_dict = BiDict() >>> bi_dict.add_pair(\\"France\\", \\"Paris\\") >>> bi_dict.get_by_value(\\"Paris\\") 'France' def __str__(self): Returns a string representation of the Bi-Directional Dictionary. >>> bi_dict = BiDict() >>> bi_dict.add_pair(\\"India\\", \\"New Delhi\\") >>> bi_dict.add_pair(\\"Japan\\", \\"Tokyo\\") >>> str(bi_dict) \\"{'India': 'New Delhi', 'Japan': 'Tokyo'}\\"","solution":"class BiDict: def __init__(self): self.key_to_value = {} self.value_to_key = {} def add_pair(self, key, value): if key in self.key_to_value or value in self.value_to_key: raise ValueError(\\"Duplicate key or value detected\\") self.key_to_value[key] = value self.value_to_key[value] = key def remove_pair(self, key): if key not in self.key_to_value: raise KeyError(\\"Key does not exist\\") value = self.key_to_value.pop(key) del self.value_to_key[value] def get_by_key(self, key): if key not in self.key_to_value: raise KeyError(\\"Key does not exist\\") return self.key_to_value[key] def get_by_value(self, value): if value not in self.value_to_key: raise KeyError(\\"Value does not exist\\") return self.value_to_key[value] def __str__(self): return str(self.key_to_value)"},{"question":"# Completion Task Implement a Python function \`filter_data\` that filters a list of data entries (dictionaries) based on a given condition function. def filter_data(data: list, condition: callable) -> list: Filters data entries based on the provided condition function. Parameters: data (list): List of dictionaries to be filtered. condition (callable): Condition function to evaluate each dictionary. Returns: list: List of dictionaries that meet the condition. return [entry for entry in data if condition(entry)] Unit Test: def test_filter_data_with_age_condition(): data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ] condition = lambda entry: entry.get(\\"age\\", 0) > 28 filtered = filter_data(data, condition) assert filtered == [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ] def test_filter_data_empty_list(): data = [] condition = lambda entry: entry.get(\\"age\\", 0) > 28 filtered = filter_data(data, condition) assert filtered == [] def test_filter_data_with_city_condition(): data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"David\\", \\"age\\": 32, \\"city\\": \\"New York\\"} ] condition = lambda entry: entry.get(\\"city\\") == \\"New York\\" filtered = filter_data(data, condition) assert filtered == [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"David\\", \\"age\\": 32, \\"city\\": \\"New York\\"} ] def test_filter_data_with_no_matching_condition(): data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"Los Angeles\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"city\\": \\"Chicago\\"} ] condition = lambda entry: entry.get(\\"age\\", 0) > 40 filtered = filter_data(data, condition) assert filtered == []","solution":"def filter_data(data: list, condition: callable) -> list: Filters data entries based on the provided condition function. Parameters: data (list): List of dictionaries to be filtered. condition (callable): Condition function to evaluate each dictionary. Returns: list: List of dictionaries that meet the condition. return [entry for entry in data if condition(entry)]"},{"question":"from typing import List def move_zeros(arr: List[int]) -> List[int]: Move all zeros in the list to the end while maintaining the relative order of non-zero elements. >>> move_zeros([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeros([0, 0, 1]) [1, 0, 0] >>> move_zeros([4, 2, 4, 0, 0, 3, 0]) [4, 2, 4, 3, 0, 0, 0]","solution":"from typing import List def move_zeros(arr: List[int]) -> List[int]: Move all zeros in the list to the end while maintaining the relative order of non-zero elements. non_zero_index = 0 # Position to place the next non-zero element for num in arr: if num != 0: arr[non_zero_index] = num non_zero_index += 1 for i in range(non_zero_index, len(arr)): arr[i] = 0 return arr"},{"question":"from typing import List, Tuple def shortestPathToCollectAllGarbage(grid: List[List[str]]) -> int: Calculates the minimum steps needed for a garbage truck starting at the top-left corner of the grid (0, 0) to visit all garbage dumps and return to the starting position. The grid contains obstacles represented by 'X' that cannot be traversed. Garbage dumps are marked as 'G', open spaces as '.', and the starting point is always '.'. >>> shortestPathToCollectAllGarbage([['.', 'G', '.', '.', '.'], ['.', 'X', 'X', '.', '.'], ['.', '.', '.', 'G', '.']]) 10 >>> shortestPathToCollectAllGarbage([['.']]) 0 >>> shortestPathToCollectAllGarbage([['.', 'G']]) 2 >>> shortestPathToCollectAllGarbage([['.', 'G', '.'], ['.', 'X', 'G']]) 6 >>> shortestPathToCollectAllGarbage([['.', 'G', 'X'], ['X', 'X', 'G']]) -1","solution":"from typing import List, Tuple from collections import deque from itertools import permutations def bfs(grid: List[List[str]], start: Tuple[int, int]) -> dict: q = deque([start]) visited = set([start]) distances = {start: 0} while q: x, y = q.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != 'X' and (nx, ny) not in visited: visited.add((nx, ny)) distances[(nx, ny)] = distances[(x, y)] + 1 q.append((nx, ny)) return distances def shortestPathToCollectAllGarbage(grid: List[List[str]]) -> int: garbage_dumps = [] for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 'G': garbage_dumps.append((i, j)) elif grid[i][j] == '.' and i == 0 and j == 0: start = (i, j) if not garbage_dumps: return 0 # No garbage to collect dists = bfs(grid, start) for dump in garbage_dumps: if dump not in dists: return -1 # If any garbage dump is unreachable all_points = [start] + garbage_dumps all_dists = {point: bfs(grid, point) for point in all_points} def calculate_total_steps(path): steps = dists[path[0]] for i in range(len(path) - 1): steps += all_dists[path[i]][path[i + 1]] steps += all_dists[path[-1]][start] return steps min_steps = float('inf') for perm in permutations(garbage_dumps): steps = calculate_total_steps(perm) min_steps = min(min_steps, steps) return min_steps"},{"question":"def hanoi_with_limited_moves(n: int, m: int) -> list: Solve the Tower of Hanoi problem for \`n\` disks and maximum \`m\` moves. Parameters: n (int): The number of disks. m (int): The maximum number of allowed moves. Returns: list: A list of tuples representing the moves, or an empty list if it cannot be solved within \`m\` moves. >>> hanoi_with_limited_moves(2, 3) [('A', 'B'), ('A', 'C'), ('B', 'C')] >>> hanoi_with_limited_moves(3, 7) [('A', 'C'), ('A', 'B'), ('C', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('A', 'C')] >>> hanoi_with_limited_moves(3, 6) [] >>> hanoi_with_limited_moves(1, 1) [('A', 'C')] >>> hanoi_with_limited_moves(4, 15) [('A', 'B'), ('A', 'C'), ('B', 'C'), ('A', 'B'), ('C', 'A'), ('C', 'B'), ('A', 'B'), ('A', 'C'), ('B', 'C'), ('B', 'A'), ('C', 'A'), ('B', 'C'), ('A', 'B'), ('A', 'C'), ('B', 'C')] >>> hanoi_with_limited_moves(4, 14) [] >>> hanoi_with_limited_moves(5, 31) [('A', 'C'), ('A', 'B'), ('C', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('A', 'C'), ('A', 'B'), ('C', 'B'), ('C', 'A'), ('B', 'A'), ('C', 'B'), ('A', 'C'), ('A', 'B'), ('C', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('A', 'C'), ('B', 'A'), ('C', 'B'), ('C', 'A'), ('B', 'A'), ('B', 'C'), ('A', 'C'), ('A', 'B'), ('C', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('A', 'C')] pass","solution":"def hanoi_with_limited_moves(n: int, m: int) -> list: Solve the Tower of Hanoi problem for \`n\` disks and maximum \`m\` moves. Parameters: n (int): The number of disks. m (int): The maximum number of allowed moves. Returns: list: A list of tuples representing the moves, or an empty list if it cannot be solved within \`m\` moves. def hanoi_recursive(n, source, target, auxiliary, moves, result): if n == 0: return if len(result) < moves: hanoi_recursive(n - 1, source, auxiliary, target, moves, result) if len(result) < moves: result.append((source, target)) if len(result) < moves: hanoi_recursive(n - 1, auxiliary, target, source, moves, result) max_possible_moves = 2**n - 1 if m < max_possible_moves: return [] result = [] hanoi_recursive(n, 'A', 'C', 'B', m, result) return result"},{"question":"def dna_complement(dna_sequence: str) -> str: Returns the complement of a given DNA sequence. Parameters: dna_sequence (str): A string representing the DNA sequence, consisting only of characters 'A', 'T', 'C', and 'G'. Returns: str: The complement of the given DNA sequence. Example Usage: >>> dna_complement(\\"ATCG\\") 'TAGC' >>> dna_complement(\\"GCTA\\") 'CGAT' >>> dna_complement(\\"ACTGACTG\\") 'TGACTGAC'","solution":"def dna_complement(dna_sequence: str) -> str: Returns the complement of a given DNA sequence. Parameters: dna_sequence (str): A string representing the DNA sequence, consisting only of characters 'A', 'T', 'C', and 'G'. Returns: str: The complement of the given DNA sequence. # A dictionary to map each base to its complement complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'} # Generate the complement sequence complement_sequence = \\"\\".join(complement[base] for base in dna_sequence) return complement_sequence"},{"question":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k steps. :param arr: List of integers. :param k: Non-negative integer denoting steps to rotate. :return: Rotated list of integers. >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 0) [1, 2, 3, 4, 5, 6, 7] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 7) [1, 2, 3, 4, 5, 6, 7] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1], 100) [1] >>> rotate_array([], 3) [] >>> rotate_array([-1, -2, -3, -4, -5], 2) [-4, -5, -1, -2, -3] >>> rotate_array([5, -10, 15, -20, 25], 2) [-20, 25, 5, -10, 15]","solution":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k steps. :param arr: List of integers. :param k: Non-negative integer denoting steps to rotate. :return: Rotated list of integers. if len(arr) == 0: return arr k = k % len(arr) # Normalize k to prevent unnecessary full rotations return arr[-k:] + arr[:-k]"},{"question":"def max_non_overlapping_events(events): Finds the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuples): A list of events where each event is represented as a tuple (start_time, end_time). Returns: int: The maximum number of non-overlapping events that can be attended. pass # Examples events = [(1, 3), (2, 4), (3, 5), (7, 8)] # The maximum number of non-overlapping events is 3 # The selected events could be [(1, 3), (3, 5), (7, 8)], so the output should be 3. print(max_non_overlapping_events(events)) # Output: 3 events = [(1, 2), (2, 3), (3, 4), (4, 5)] # All events are non-overlapping print(max_non_overlapping_events(events)) # Output: 4","solution":"def max_non_overlapping_events(events): Finds the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuples): A list of events where each event is represented as a tuple (start_time, end_time). Returns: int: The maximum number of non-overlapping events that can be attended. # Sort the events by their end time events.sort(key=lambda x: x[1]) count = 0 last_end = float('-inf') # Iterate through the sorted events for start, end in events: # If the event does not overlap with the previous one, attend it if start >= last_end: count += 1 last_end = end return count"},{"question":"from typing import List def longest_increasing_subsequence(nums: List[int]) -> int: Given an array of integers, find the length of the longest increasing subsequence (LIS). >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([2, 7, 4, 3, 8]) 3 >>> longest_increasing_subsequence([10]) 1 pass","solution":"from typing import List import bisect def longest_increasing_subsequence(nums: List[int]) -> int: Finds the length of the longest increasing subsequence in a given list of integers. if not nums: return 0 lis = [] # This will store the current longest increasing subsequence we've found. for num in nums: pos = bisect.bisect_left(lis, num) # Find the position where 'num' should go in 'lis' to keep it sorted. if pos == len(lis): lis.append(num) # If 'num' is greater than any element in 'lis', it will create a new LIS else: lis[pos] = num # Replace the element at the found position with 'num' to potentially start a new LIS return len(lis) # Length of lis is the length of the Longest Increasing Subsequence"},{"question":"from typing import List, Dict def sort_dicts_by_key(dicts_list: List[Dict[str, int]], key: str) -> List[Dict[str, int]]: Sorts a list of dictionaries by the values associated with the specified key. Parameters: dicts_list (List[Dict[str, int]]): List of dictionaries to be sorted. key (str): The key by which the list should be sorted. Returns: List[Dict[str, int]]: A new list of dictionaries sorted by the specified key in ascending order. Example: >>> dicts_list = [ ... {'name': 'Alice', 'age': 30}, ... {'name': 'Bob', 'age': 25}, ... {'name': 'Charlie', 'age': 35} ... ] >>> key = 'age' >>> sort_dicts_by_key(dicts_list, key) [ {'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 30}, {'name': 'Charlie', 'age': 35} ] def test_sort_dicts_by_key_basic(): dicts_list = [ {'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25}, {'name': 'Charlie', 'age': 35} ] key = 'age' expected = [ {'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 30}, {'name': 'Charlie', 'age': 35} ] assert sort_dicts_by_key(dicts_list, key) == expected def test_sort_dicts_by_key_empty_list(): dicts_list = [] key = 'age' expected = [] assert sort_dicts_by_key(dicts_list, key) == expected def test_sort_dicts_by_key_single_element(): dicts_list = [{'name': 'Alice', 'age': 30}] key = 'age' expected = [{'name': 'Alice', 'age': 30}] assert sort_dicts_by_key(dicts_list, key) == expected def test_sort_dicts_by_key_another_key(): dicts_list = [ {'name': 'Alice', 'height': 160}, {'name': 'Bob', 'height': 170}, {'name': 'Charlie', 'height': 150} ] key = 'height' expected = [ {'name': 'Charlie', 'height': 150}, {'name': 'Alice', 'height': 160}, {'name': 'Bob', 'height': 170} ] assert sort_dicts_by_key(dicts_list, key) == expected def test_sort_dicts_by_key_with_negative_values(): dicts_list = [ {'product': 'A', 'price': -100}, {'product': 'B', 'price': 50}, {'product': 'C', 'price': -200} ] key = 'price' expected = [ {'product': 'C', 'price': -200}, {'product': 'A', 'price': -100}, {'product': 'B', 'price': 50} ] assert sort_dicts_by_key(dicts_list, key) == expected def test_sort_dicts_by_key_with_identical_values(): dicts_list = [ {'product': 'A', 'price': 50}, {'product': 'B', 'price': 50}, {'product': 'C', 'price': 100} ] key = 'price' expected = [ {'product': 'A', 'price': 50}, {'product': 'B', 'price': 50}, {'product': 'C', 'price': 100} ] assert sort_dicts_by_key(dicts_list, key) == expected","solution":"from typing import List, Dict def sort_dicts_by_key(dicts_list: List[Dict[str, int]], key: str) -> List[Dict[str, int]]: Sorts a list of dictionaries by the values associated with the specified key. Parameters: dicts_list (List[Dict[str, int]]): List of dictionaries to be sorted. key (str): The key by which the list should be sorted. Returns: List[Dict[str, int]]: A new list of dictionaries sorted by the specified key in ascending order. return sorted(dicts_list, key=lambda d: d[key])"},{"question":"from typing import List def min_steps_to_clean(floor: List[List[int]]) -> int: Calculates the minimum number of steps needed to completely clean all dirty tiles on the floor. Each tile can be either clean (represented by \`0\`) or dirty (represented by \`1\`). In one step, you can clean a single dirty tile and any tiles adjacent to it (sharing an edge) will also become clean. Parameters: floor (List[List[int]]): A 2D list of integers where each entry is either \`0\` or \`1\` representing a clean or dirty tile respectively (1 ≤ m, n ≤ 1000). Returns: int: The minimum number of steps required to clean all dirty tiles on the floor. Examples: >>> min_steps_to_clean([ ... [0, 1, 0, 0, 1], ... [1, 1, 0, 1, 1], ... [0, 1, 1, 0, 0] ... ]) 2 >>> min_steps_to_clean([ ... [1, 0, 0], ... [0, 1, 1], ... [0, 1, 0] ... ]) 2","solution":"from typing import List def min_steps_to_clean(floor: List[List[int]]) -> int: Returns the minimum number of steps required to clean all dirty tiles in the floor. def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < m and 0 <= ny < n and floor[nx][ny] == 1: floor[nx][ny] = 0 stack.append((nx, ny)) m, n = len(floor), len(floor[0]) steps = 0 for i in range(m): for j in range(n): if floor[i][j] == 1: steps += 1 dfs(i, j) return steps"},{"question":"from typing import List, Dict, Any def is_category_price_within_range(cart: List[Dict[str, Any]], category: str, min_price: float, max_price: float) -> bool: Checks whether the total price of items in the specified category falls within the given price range. Args: cart (List[Dict[str, Any]]): A list of dictionaries representing the items in the cart. category (str): The specific category to check the total price for. min_price (float): The minimum allowed price for the total price of the items in the specified category. max_price (float): The maximum allowed price for the total price of the items in the specified category. Returns: bool: True if the total price of items in the specified category is within the given price range, False otherwise. Examples: >>> cart = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 1500.00}, {\\"name\\": \\"Smartphone\\", \\"category\\": \\"Electronics\\", \\"price\\": 800.00}, {\\"name\\": \\"Headphones\\", \\"category\\": \\"Accessories\\", \\"price\\": 100.00}, {\\"name\\": \\"Shoes\\", \\"category\\": \\"Fashion\\", \\"price\\": 120.00} ] >>> is_category_price_within_range(cart, \\"Electronics\\", 2000.00, 3000.00) True >>> is_category_price_within_range(cart, \\"Electronics\\", 2500.00, 3000.00) False >>> is_category_price_within_range(cart, \\"Fashion\\", 100.00, 150.00) True >>> is_category_price_within_range(cart, \\"Accessories\\", 50.00, 150.00) True pass","solution":"from typing import List, Dict, Any def is_category_price_within_range(cart: List[Dict[str, Any]], category: str, min_price: float, max_price: float) -> bool: Checks whether the total price of items in the specified category falls within the given price range. total_price = sum(item['price'] for item in cart if item['category'] == category) return min_price <= total_price <= max_price"},{"question":"def rotate_and_reverse_sort(collection: list[int], rotations: int) -> list[int]: Rotate the list to the right by a given number of times and then sort it in ascending order. Args: collection: A list of integers to be sorted. rotations: The number of rotations to be applied to the list. Returns: A list of the same integers but sorted in ascending order. >>> rotate_and_reverse_sort([4, 2, 5, 1, 3], 2) [1, 2, 3, 4, 5] >>> rotate_and_reverse_sort([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> rotate_and_reverse_sort([5, 4, 3, 2, 1], 10) [1, 2, 3, 4, 5] >>> rotate_and_reverse_sort([], 3) [] >>> rotate_and_reverse_sort([7], 5) [7] >>> rotate_and_reverse_sort([2, 3, 1], 0) [1, 2, 3] >>> rotate_and_reverse_sort([0, -1, -2, 3], 3) [-2, -1, 0, 3]","solution":"def rotate_and_reverse_sort(collection: list[int], rotations: int) -> list[int]: def rotate_right(lst: list[int], k: int) -> list[int]: n = len(lst) if n == 0: return lst k = k % n # Reduce unnecessary full rotations return lst[-k:] + lst[:-k] def selection_sort(lst: list[int]) -> list[int]: n = len(lst) for i in range(n): min_index = i for j in range(i + 1, n): if lst[j] < lst[min_index]: min_index = j lst[i], lst[min_index] = lst[min_index], lst[i] return lst # Rotate the list rotated_collection = rotate_right(collection, rotations) # Sort the rotated list sorted_collection = selection_sort(rotated_collection) return sorted_collection"},{"question":"from typing import List def min_edit_distance(word1: str, word2: str) -> int: Given two strings, compute the minimum number of operations required to convert the first string into the second string using allowed operations (insert, delete, replace). Args: word1 (str): The first string. word2 (str): The second string. Returns: int: The minimum number of operations required to convert word1 into word2. Examples: >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> min_edit_distance(\\"\\", \\"abc\\") 3 >>> min_edit_distance(\\"abc\\", \\"abc\\") 0 pass def test_min_edit_distance(): assert min_edit_distance(\\"intention\\", \\"execution\\") == 5, \\"Test case 1 failed\\" assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3, \\"Test case 2 failed\\" assert min_edit_distance(\\"flaw\\", \\"lawn\\") == 2, \\"Test case 3 failed\\" assert min_edit_distance(\\"\\", \\"abc\\") == 3, \\"Test case 4 failed\\" assert min_edit_distance(\\"abc\\", \\"abc\\") == 0, \\"Test case 5 failed\\" assert min_edit_distance(\\"a\\", \\"a\\") == 0, \\"Test case 6 failed\\" assert min_edit_distance(\\"abcdef\\", \\"azced\\") == 3, \\"Test case 7 failed\\" assert min_edit_distance(\\"abc\\", \\"yabd\\") == 2, \\"Test case 8 failed\\" assert min_edit_distance(\\"horse\\", \\"ros\\") == 3, \\"Test case 9 failed\\" assert min_edit_distance(\\"dinitrophenylhydrazine\\", \\"acetylphenylhydrazine\\") == 6, \\"Test case 10 failed\\" test_min_edit_distance()","solution":"def min_edit_distance(word1: str, word2: str) -> int: Computes the minimum edit distance between two strings. m, n = len(word1), len(word2) # Create a 2D array to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize dp array for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If first string is empty, insert all characters of second string elif j == 0: dp[i][j] = i # If second string is empty, remove all characters of first string elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If characters are same, ignore them and move on else: dp[i][j] = 1 + min(dp[i - 1][j], # Insert dp[i][j - 1], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"# Description: Suppose you need to simulate a basic vending machine that dispenses items based on coins inserted. The vending machine can dispense multiple items if the amount of money inserted is sufficient for all selected items. It will also return any remaining change after the transaction. # Task: Implement a function \`vending_machine(items: list[str], prices: list[float], inserted_coins: float) -> tuple[list[str], float]\` that: 1. Takes a list of items, a corresponding list of prices, and the total amount of money inserted. 2. Dispenses as many items as the inserted coins can buy (in order of the items list). 3. Returns a list of dispensed items and the remaining change. # Constraints: - If \`inserted_coins\` is less than the price of any single item, no items should be dispensed, and all the money should be returned. - Items and prices lists are of the same length, and items have distinct prices. - All prices are positive floats. - If multiple items can be bought with the exact amount of money, the function should return all those items and 0 remaining coins. # Inputs: - \`items\` (List of strings): The names of the items in the vending machine. - \`prices\` (List of floats): The corresponding prices of the items. - \`inserted_coins\` (Float): The amount of money inserted into the vending machine. # Output: - Returns a tuple containing: 1. List of items that can be dispensed (in order of selection). 2. The remaining change after dispensing the items. # Example Usage: >>> vending_machine([\\"Soda\\", \\"Chips\\", \\"Candy\\"], [1.50, 2.00, 0.75], 3.00) ([\\"Soda\\", \\"Candy\\"], 0.75) >>> vending_machine([\\"Soda\\", \\"Chips\\", \\"Candy\\"], [1.50, 2.00, 0.75], 1.00) ([], 1.00) >>> vending_machine([\\"Soda\\", \\"Chips\\", \\"Candy\\"], [1.50, 2.00, 0.75], 5.00) ([\\"Soda\\", \\"Chips\\", \\"Candy\\"], 0.75) >>> vending_machine([\\"Soda\\", \\"Chips\\", \\"Candy\\"], [1.50, 2.00, 0.75], 0.50) ([], 0.50) # Note: - Ensure your implementation efficiently handles the process of selecting items and calculating remaining change. - Consider edge cases where no items can be dispensed or all money is spent exactly. def vending_machine(items: list[str], prices: list[float], inserted_coins: float) -> tuple[list[str], float]: dispensed_items = [] remaining_coins = inserted_coins for item, price in zip(items, prices): if price <= remaining_coins: dispensed_items.append(item) remaining_coins -= price return dispensed_items, remaining_coins","solution":"def vending_machine(items: list[str], prices: list[float], inserted_coins: float) -> tuple[list[str], float]: dispensed_items = [] remaining_coins = inserted_coins for item, price in zip(items, prices): if price <= remaining_coins: dispensed_items.append(item) remaining_coins -= price return dispensed_items, remaining_coins"},{"question":"[Completion Task in Python] ''' from typing import List def merge_and_sort_files(input_files: List[str], output_file: str) -> None: Merges multiple sorted files into a single sorted output file. Args: input_files: List of paths to the input files containing sorted integers. output_file: Path to the output file where the merged and sorted integers will be saved. min_heap = [] # Open all input files and store file iterators in a list file_iters = [open(file, 'r') for file in input_files] try: # Initialize the heap with the first element from each file for i, f_iter in enumerate(file_iters): line = f_iter.readline().strip() if line: heapq.heappush(min_heap, (int(line), i)) with open(output_file, 'w') as output_f: while min_heap: smallest, file_index = heapq.heappop(min_heap) output_f.write(f\\"{smallest}n\\") current_iter = file_iters[file_index] line = current_iter.readline().strip() if line: heapq.heappush(min_heap, (int(line), file_index)) finally: # Ensure all file handles are closed properly for f_iter in file_iters: f_iter.close() Example input_files=[\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\", \\"file4.txt\\"] output_file = \\"output.txt\\" merge_and_sort_files(input_files, output_file) '''","solution":"from typing import List import heapq def merge_and_sort_files(input_files: List[str], output_file: str) -> None: Merges multiple sorted files into a single sorted output file. Args: input_files: List of paths to the input files containing sorted integers. output_file: Path to the output file where the merged and sorted integers will be saved. min_heap = [] # Open all input files and store file iterators in a list file_iters = [open(file, 'r') for file in input_files] try: # Initialize the heap with the first element from each file for i, f_iter in enumerate(file_iters): line = f_iter.readline().strip() if line: heapq.heappush(min_heap, (int(line), i)) with open(output_file, 'w') as output_f: while min_heap: smallest, file_index = heapq.heappop(min_heap) output_f.write(f\\"{smallest}n\\") current_iter = file_iters[file_index] line = current_iter.readline().strip() if line: heapq.heappush(min_heap, (int(line), file_index)) finally: # Ensure all file handles are closed properly for f_iter in file_iters: f_iter.close()"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_largest(root: TreeNode, k: int) -> int: Returns the kth largest element in the given BST. Parameters: - root: The root node of the BST. - k: The position (1-indexed) of the largest element to be found. Returns: - The kth largest element in the BST. If the tree is empty or k is invalid, return -1. Example: >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> kth_largest(root, 1) 8 >>> kth_largest(root, 3) 6 >>> kth_largest(root, 7) 2 >>> kth_largest(root, 8) -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_largest(root: TreeNode, k: int) -> int: Returns the kth largest element in the given BST. Parameters: - root: The root node of the BST. - k: The position (1-indexed) of the largest element to be found. Returns: - The kth largest element in the BST. If the tree is empty or k is invalid, return -1. if not root or k <= 0: return -1 stack = [] current = root count = 0 while stack or current: while current: stack.append(current) current = current.right current = stack.pop() count += 1 if count == k: return current.val current = current.left return -1"},{"question":"def remove_duplicate_words(sentence: str) -> str: Removes consecutive duplicate words from the input sentence. :param sentence: The input sentence as a string. :return: A string with consecutive duplicate words removed. >>> remove_duplicate_words(\\"This is is a test test string\\") \\"This is a test string\\" >>> remove_duplicate_words(\\"Hello Hello world\\") \\"Hello world\\" >>> remove_duplicate_words(\\"Python is great great and and fun fun\\") \\"Python is great and fun\\" >>> remove_duplicate_words(\\"No duplicates here\\") \\"No duplicates here\\" >>> remove_duplicate_words(\\"\\") \\"\\" pass","solution":"def remove_duplicate_words(sentence: str) -> str: Removes consecutive duplicate words from the input sentence. :param sentence: The input sentence as a string. :return: A string with consecutive duplicate words removed. if not sentence: return sentence words = sentence.split() result = [words[0]] for word in words[1:]: if word.lower() != result[-1].lower(): result.append(word) return ' '.join(result)"},{"question":"def merge_optimized(left: List[int], right: List[int]) -> List[int]: Merge two sorted lists into a single sorted list, optimizing the number of comparisons. Parameters: left (List[int]): A sorted list of integers. right (List[int]): A sorted list of integers. Returns: List[int]: A single merged and sorted list. >>> merge_optimized([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_optimized([1, 2], [3, 4, 5]) == [1, 2, 3, 4, 5] >>> merge_optimized([], [1, 2, 3]) == [1, 2, 3] >>> merge_optimized([7, 8, 9], []) == [7, 8, 9] >>> merge_optimized([], []) == [] >>> merge_optimized([-3, 0, 2], [-2, 1, 3]) == [-3, -2, 0, 1, 2, 3] >>> merge_optimized([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 1, 1, 1] >>> merge_optimized([-5, -4, -3], [-2, -1, 0]) == [-5, -4, -3, -2, -1, 0] >>> merge_optimized([0, 0, 0], [0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0, 0, 0]","solution":"def merge_optimized(left, right): Merge two sorted lists into a single sorted list, optimizing the number of comparisons. Parameters: left (List[int]): A sorted list of integers. right (List[int]): A sorted list of integers. Returns: List[int]: A single merged and sorted list. merged = [] i, j = 0, 0 len_left, len_right = len(left), len(right) while i < len_left and j < len_right: if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 # This concatenation minimizes the number of comparisons if i < len_left: merged.extend(left[i:]) if j < len_right: merged.extend(right[j:]) return merged"},{"question":"def most_frequent_element(arr: List[int], k: int) -> int: Finds the frequency of the most frequent element in any subarray of a given array, with the maximum subarray size up to k. Args: arr (List[int]): A list of integers representing the array. k (int): The maximum size of the subarray. Returns: int: The highest frequency of any single element in a subarray of \`arr\` with size up to \`k\`. Examples: >>> most_frequent_element([1, 3, 3, 2, 1, 4, 1], 3) 2 >>> most_frequent_element([2, 2, 1, 2, 2, 1, 1], 4) 3 from collections import defaultdict def test_most_frequent_element_simple(): assert most_frequent_element([1, 3, 3, 2, 1, 4, 1], 3) == 2 def test_most_frequent_element_with_exact_k(): assert most_frequent_element([2, 2, 1, 2, 2, 1, 1], 4) == 3 def test_most_frequent_element_with_large_k(): assert most_frequent_element([5, 1, 1, 3, 3, 3, 5], 7) == 3 def test_most_frequent_element_with_k_greater_than_n(): assert most_frequent_element([2, 8, 8, 8, 8, 1, 2], 10) == 4 def test_most_frequent_element_with_all_different(): assert most_frequent_element([1, 2, 3, 4, 5, 6, 7, 8, 9], 4) == 1 def test_most_frequent_element_with_all_same(): assert most_frequent_element([7, 7, 7, 7, 7], 3) == 3","solution":"from collections import defaultdict def most_frequent_element(arr, k): Finds the frequency of the most frequent element in any subarray of a given array, with the maximum subarray size up to k. n = len(arr) max_freq = 0 freq_map = defaultdict(int) left = 0 for right in range(n): freq_map[arr[right]] += 1 while (right - left + 1) > k: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: del freq_map[arr[left]] left += 1 current_max_freq = max(freq_map.values()) max_freq = max(max_freq, current_max_freq) return max_freq"},{"question":"from typing import List, Tuple def find_login_attempts(logs: List[str]) -> Tuple[str, str]: Returns the timestamp of the first and the last failed login attempts from the provided list of logs. Args: logs (List[str]): List of timestamps sorted in ascending order. Returns: Tuple[str, str]: The first and the last timestamps from the list. >>> find_login_attempts(['2023-01-01T00:00:01', '2023-01-01T01:00:00', '2023-01-01T02:00:01', '2023-01-01T03:00:05', '2023-01-01T04:00:10']) ('2023-01-01T00:00:01', '2023-01-01T04:00:10') >>> find_login_attempts(['2023-01-01T00:00:01']) ('2023-01-01T00:00:01', '2023-01-01T00:00:01') pass def test_single_timestamp(): logs = ['2023-01-01T00:00:01'] assert find_login_attempts(logs) == ('2023-01-01T00:00:01', '2023-01-01T00:00:01') def test_multiple_timestamps(): logs = [ '2023-01-01T00:00:01', '2023-01-01T01:00:00', '2023-01-01T02:00:01', '2023-01-01T03:00:05', '2023-01-01T04:00:10' ] expected_output = ('2023-01-01T00:00:01', '2023-01-01T04:00:10') assert find_login_attempts(logs) == expected_output def test_two_timestamps(): logs = [ '2023-01-01T00:00:01', '2023-01-01T01:00:00' ] expected_output = ('2023-01-01T00:00:01', '2023-01-01T01:00:00') assert find_login_attempts(logs) == expected_output def test_empty_list_raises_error(): try: find_login_attempts([]) except ValueError: assert True else: assert False","solution":"from typing import List, Tuple def find_login_attempts(logs: List[str]) -> Tuple[str, str]: Returns the timestamp of the first and the last failed login attempts from the provided list of logs. Args: logs (List[str]): List of timestamps sorted in ascending order. Returns: Tuple[str, str]: The first and the last timestamps from the list. if not logs: raise ValueError(\\"The logs list should not be empty\\") return (logs[0], logs[-1])"},{"question":"def reverse_string(s: str) -> str: Reverses a string using recursion. Raises TypeError if input is not a string. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"world\\") \\"dlrow\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(123) # Raises TypeError","solution":"def reverse_string(s: str) -> str: Reverses a string using recursion. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") if len(s) <= 1: return s return s[-1] + reverse_string(s[:-1])"},{"question":"def transpose_matrix(matrix): Transposes the given n x m matrix. Parameters: matrix (list of lists of int): The matrix to transpose Returns: list of lists of int: The transposed matrix >>> transpose_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [1, 4, 7], ... [2, 5, 8], ... [3, 6, 9] ... ] >>> transpose_matrix([ ... [1, 2, 3], ... [4, 5, 6] ... ]) == [ ... [1, 4], ... [2, 5], ... [3, 6] ... ] >>> transpose_matrix([[1]]) == [[1]] >>> transpose_matrix([]) == [] >>> transpose_matrix([[1, 2, 3, 4]]) == [[1], [2], [3], [4]] >>> transpose_matrix([[1], [2], [3], [4]]) == [[1, 2, 3, 4]]","solution":"def transpose_matrix(matrix): Transposes the given n x m matrix. Parameters: matrix (list of lists of int): The matrix to transpose Returns: list of lists of int: The transposed matrix if not matrix: return [] # Number of rows and columns in the original matrix n, m = len(matrix), len(matrix[0]) # Initialize the transposed matrix with dimensions m x n transposed = [[0]*n for _ in range(m)] # Perform the transposition for i in range(n): for j in range(m): transposed[j][i] = matrix[i][j] return transposed"},{"question":"def convert_number(number: int) -> dict: Converts a given integer to its binary, hexadecimal, and octal representations. >>> convert_number(255) { 'binary': '11111111', 'hexadecimal': 'ff', 'octal': '377' } def test_convert_number(): result = convert_number(255) assert result == { 'binary': '11111111', 'hexadecimal': 'ff', 'octal': '377' } def test_convert_zero(): result = convert_number(0) assert result == { 'binary': '0', 'hexadecimal': '0', 'octal': '0' } def test_convert_max_range(): result = convert_number(10**6) assert result == { 'binary': '11110100001001000000', 'hexadecimal': 'f4240', 'octal': '3641100' } def test_convert_min_range(): result = convert_number(0) assert result == { 'binary': '0', 'hexadecimal': '0', 'octal': '0' } def test_convert_number_small(): result = convert_number(1) assert result == { 'binary': '1', 'hexadecimal': '1', 'octal': '1' } def test_convert_number_large(): result = convert_number(1000000) assert result == { 'binary': '11110100001001000000', 'hexadecimal': 'f4240', 'octal': '3641100' } def test_number_out_of_range(): try: convert_number(10**6 + 1) except ValueError as e: assert str(e) == \\"Number is out of the valid range (0 <= number <= 10^6)\\" try: convert_number(-1) except ValueError as e: assert str(e) == \\"Number is out of the valid range (0 <= number <= 10^6)\\"","solution":"def convert_number(number: int) -> dict: Converts a given integer to its binary, hexadecimal, and octal representations. Parameters: number (int): The decimal number to be converted. Returns: dict: A dictionary with binary, hexadecimal, and octal string representations. if not (0 <= number <= 10**6): raise ValueError(\\"Number is out of the valid range (0 <= number <= 10^6)\\") return { 'binary': bin(number)[2:], 'hexadecimal': hex(number)[2:], 'octal': oct(number)[2:] }"},{"question":"def kmp_search(text: str, pattern: str) -> list[int]: Implement the KMP algorithm to find all occurrences of a pattern string within a text string. >>> kmp_search(\\"abracadabra\\", \\"abra\\") [0, 7] >>> kmp_search(\\"hello\\", \\"ll\\") [2] >>> kmp_search(\\"abcd\\", \\"ef\\") []","solution":"def compute_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(text, pattern): if not pattern: return [] lps = compute_lps(pattern) result = [] i = 0 j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longest_unique_path(root: TreeNode) -> int: Find the longest path in the binary tree such that all the values along the path are unique. Args: root (TreeNode): the root node of the binary tree. Returns: int: The length of the longest path with all unique values. Example: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) >>> longest_unique_path(root) 6 pass def test_single_node(): root = TreeNode(1) assert longest_unique_path(root) == 1 def test_linear_tree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.left.left.left = TreeNode(4) assert longest_unique_path(root) == 4 def test_binary_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert longest_unique_path(root) == 6 def test_no_left_subtree(): root = TreeNode(1) root.right = TreeNode(3) root.right.right = TreeNode(5) assert longest_unique_path(root) == 3 def test_no_right_subtree(): root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(4) assert longest_unique_path(root) == 3","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def longest_unique_path(root): def dfs(node, path_set): if not node: return 0 if node.val in path_set: return 0 path_set.add(node.val) left_path = dfs(node.left, path_set) right_path = dfs(node.right, path_set) path_set.remove(node.val) return 1 + max(left_path, right_path) def find_max_unique_path(node): if not node: return 0 single_path_length = dfs(node, set()) left_max = find_max_unique_path(node.left) right_max = find_max_unique_path(node.right) return max(single_path_length, left_max, right_max) return find_max_unique_path(root)"},{"question":"class UserProfileLookup: Class to manage user profiles with efficient insert, lookup, and remove operations. def __init__(self): # Initialize the data structure to store user profiles pass def insert(self, user_id: int, profile: dict) -> None: Inserts or updates the user profile associated with the given user_id. Args: - user_id: int - The unique user ID. - profile: dict - A dictionary containing user profile information. pass def lookup(self, user_id: int) -> dict: Returns the profile data associated with the user_id if it exists, otherwise returns an empty dictionary. Args: - user_id: int - The unique user ID. Returns: - dict - The user profile or an empty dictionary if the user does not exist. pass def remove(self, user_id: int) -> None: Removes the profile associated with the user_id if it exists. Args: - user_id: int - The unique user ID. pass # Unit tests def test_insert_and_lookup_profile(): lookup = UserProfileLookup() user_profile = {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\"} lookup.insert(1, user_profile) assert lookup.lookup(1) == user_profile def test_lookup_non_existent_user(): lookup = UserProfileLookup() assert lookup.lookup(2) == {} def test_update_existing_profile(): lookup = UserProfileLookup() user_profile = {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\"} lookup.insert(1, user_profile) updated_profile = {\\"name\\": \\"Alice\\", \\"age\\": 31, \\"email\\": \\"alice@updated.com\\"} lookup.insert(1, updated_profile) assert lookup.lookup(1) == updated_profile def test_remove_profile(): lookup = UserProfileLookup() user_profile = {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"email\\": \\"bob@example.com\\"} lookup.insert(2, user_profile) lookup.remove(2) assert lookup.lookup(2) == {} def test_remove_non_existent_user(): lookup = UserProfileLookup() lookup.remove(3) # Should not raise any error assert lookup.lookup(3) == {} def test_insert_multiple_users(): lookup = UserProfileLookup() user_profile_1 = {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\"} user_profile_2 = {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"email\\": \\"bob@example.com\\"} lookup.insert(1, user_profile_1) lookup.insert(2, user_profile_2) assert lookup.lookup(1) == user_profile_1 assert lookup.lookup(2) == user_profile_2","solution":"class UserProfileLookup: def __init__(self): self.profiles = {} def insert(self, user_id: int, profile: dict) -> None: Inserts or updates the user profile associated with the given user_id. self.profiles[user_id] = profile def lookup(self, user_id: int) -> dict: Returns the profile data associated with the user_id if it exists, otherwise returns an empty dictionary. return self.profiles.get(user_id, {}) def remove(self, user_id: int) -> None: Removes the profile associated with the user_id if it exists. if user_id in self.profiles: del self.profiles[user_id]"},{"question":"class Fibonacci: def __init__(self): Initialize the cache as an empty dictionary. def fib(self, n: int) -> int: Calculate the n-th Fibonacci number using caching to store and reuse previously calculated results. >>> fib_calculator = Fibonacci() >>> fib_calculator.fib(10) 55 >>> fib_calculator.fib(5) 5 from solution import Fibonacci def test_fib_0(): fib_calculator = Fibonacci() assert fib_calculator.fib(0) == 0 def test_fib_1(): fib_calculator = Fibonacci() assert fib_calculator.fib(1) == 1 def test_fib_10(): fib_calculator = Fibonacci() assert fib_calculator.fib(10) == 55 def test_fib_5(): fib_calculator = Fibonacci() assert fib_calculator.fib(5) == 5 def test_fib_large_number(): fib_calculator = Fibonacci() assert fib_calculator.fib(50) == 12586269025 def test_fib_cache_usage(): fib_calculator = Fibonacci() _ = fib_calculator.fib(10) # Populate the cache assert fib_calculator.cache[10] == 55 assert fib_calculator.cache[9] == 34 assert fib_calculator.cache[8] == 21","solution":"class Fibonacci: def __init__(self): self.cache = {} def fib(self, n: int) -> int: if n == 0: return 0 elif n == 1: return 1 if n in self.cache: return self.cache[n] self.cache[n] = self.fib(n - 1) + self.fib(n - 2) return self.cache[n]"},{"question":"import math def next_prime(n: int) -> int: Return the smallest prime number greater than \`n\`. >>> next_prime(3) 5 >>> next_prime(11) 13 >>> next_prime(17) 19 >>> next_prime(24) 29 pass # Unit Tests def test_next_prime_small_numbers(): assert next_prime(1) == 2 assert next_prime(2) == 3 assert next_prime(3) == 5 assert next_prime(4) == 5 def test_next_prime_reasonable_numbers(): assert next_prime(11) == 13 assert next_prime(17) == 19 assert next_prime(24) == 29 def test_next_prime_large_number(): assert next_prime(1000000) == 1000003 def test_next_prime_invalid_input(): try: next_prime(-10) assert False, \\"Expected ValueError\\" except ValueError: assert True try: next_prime(0) assert False, \\"Expected ValueError\\" except ValueError: assert True try: next_prime(\\"10\\") assert False, \\"Expected ValueError\\" except ValueError: assert True","solution":"import math def is_prime(num): Efficient check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): Returns the smallest prime number greater than n. if not isinstance(n, int) or n <= 0: raise ValueError(\\"Input must be a positive integer.\\") candidate = n + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"from typing import List def reshape_vector(vector: List[int], rows: int, cols: int) -> List[List[int]]: Reshapes a one-dimensional list into a two-dimensional matrix based on given rows and columns. :param vector: A list of integers to reshape. :param rows: The number of rows in the new matrix. :param cols: The number of columns in the new matrix. :return: A two-dimensional list of integers if reshaping is possible, otherwise an empty list. >>> reshape_vector([1, 2, 3, 4, 5, 6], 2, 3) [[1, 2, 3], [4, 5, 6]] >>> reshape_vector([1, 2, 3, 4, 5, 6, 7], 3, 3) [] >>> reshape_vector([1, 2, 3, 4, 5, 6], 3, 2) [[1, 2], [3, 4], [5, 6]] >>> reshape_vector([1, 2, 3], 1, 3) [[1, 2, 3]] >>> reshape_vector([1, 2, 3], 3, 1) [[1], [2], [3]] >>> reshape_vector([], 0, 0) [] >>> vector = list(range(1, 10001)) >>> reshaped = reshape_vector(vector, 100, 100) >>> reshaped[0][0] == 1 True >>> reshaped[-1][-1] == 10000 True","solution":"from typing import List def reshape_vector(vector: List[int], rows: int, cols: int) -> List[List[int]]: Reshapes a one-dimensional list into a two-dimensional matrix based on given rows and columns. :param vector: A list of integers to reshape. :param rows: The number of rows in the new matrix. :param cols: The number of columns in the new matrix. :return: A two-dimensional list of integers if reshaping is possible, otherwise an empty list. if len(vector) != rows * cols: return [] reshaped_matrix = [] for row in range(rows): start_index = row * cols reshaped_matrix.append(vector[start_index:start_index + cols]) return reshaped_matrix"},{"question":"class DecisionTreeClassifier: def __init__(self): Initialize the Decision Tree Classifier. self.tree = None def fit(self, X, y): Build the decision tree from training data using the Gini index for splitting. pass def predict(self, observation): Classify new observations using the trained tree. pass def _gini_index(self, groups, classes): Calculate the Gini index for a split. pass def _split(self, index, value, dataset): Split the dataset based on a feature index and value. pass def _get_best_split(self, dataset): Find the best split point for the dataset. pass def _build_tree(self, node, max_depth, min_size, depth): Build the tree recursively. pass # Example usage: # dtc = DecisionTreeClassifier() # dtc.fit(observations, classes) # predicted_class = dtc.predict(new_observation) # Sample unit test cases: def test_fit_and_predict(): observations = [ [2.771244718, 1.784783929], [1.728571309, 1.169761413], [3.678319846, 2.81281357], [3.961043357, 2.61995032], [2.999208922, 2.209014212], [7.497545867, 3.162953546], [9.00220326, 3.339047188], [7.444542326, 0.476683375], [10.12493903, 3.234550982], [6.642287351, 3.319983761] ] classes = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1] dtc = DecisionTreeClassifier() dtc.fit(observations, classes) new_observation = [3.5, 2.0] predicted_class = dtc.predict(new_observation) assert predicted_class == 0 def test_different_splits(): observations = [ [1, 2], [3, 4], [5, 6], [7, 8], [9, 10] ] classes = [0, 0, 1, 1, 1] dtc = DecisionTreeClassifier() dtc.fit(observations, classes) new_observation = [4, 5] predicted_class = dtc.predict(new_observation) assert predicted_class == 0 new_observation = [8, 9] predicted_class = dtc.predict(new_observation) assert predicted_class == 1 def test_single_class(): observations = [ [1, 2], [3, 4], [5, 6] ] classes = [0, 0, 0] dtc = DecisionTreeClassifier() dtc.fit(observations, classes) new_observation = [7, 8] predicted_class = dtc.predict(new_observation) assert predicted_class == 0","solution":"class DecisionTreeClassifier: def __init__(self): self.tree = None def fit(self, X, y): dataset = [row + [label] for row, label in zip(X, y)] self.tree = self._build_tree(dataset) def predict(self, observation): return self._predict_one(self.tree, observation) def _predict_one(self, node, observation): if isinstance(node, dict): if observation[node['index']] < node['value']: return self._predict_one(node['left'], observation) else: return self._predict_one(node['right'], observation) else: return node def _gini_index(self, groups, classes): n_instances = float(sum([len(group) for group in groups])) gini = 0.0 for group in groups: size = float(len(group)) if size == 0: continue score = 0.0 for class_val in classes: proportion = [row[-1] for row in group].count(class_val) / size score += proportion * proportion gini += (1.0 - score) * (size / n_instances) return gini def _split(self, index, value, dataset): left, right = list(), list() for row in dataset: if row[index] < value: left.append(row) else: right.append(row) return left, right def _get_best_split(self, dataset): class_values = list(set(row[-1] for row in dataset)) best_index, best_value, best_score, best_groups = float('inf'), float('inf'), float('inf'), None for index in range(len(dataset[0])-1): for row in dataset: groups = self._split(index, row[index], dataset) gini = self._gini_index(groups, class_values) if gini < best_score: best_index, best_value, best_score, best_groups = index, row[index], gini, groups return {'index': best_index, 'value': best_value, 'groups': best_groups} def _to_terminal(self, group): outcomes = [row[-1] for row in group] return max(set(outcomes), key=outcomes.count) def _split_and_create_node(self, node, depth, max_depth=5, min_size=1): left, right = node['groups'] del(node['groups']) if not left or not right: node['left'] = node['right'] = self._to_terminal(left + right) return if depth >= max_depth: node['left'], node['right'] = self._to_terminal(left), self._to_terminal(right) return if len(left) <= min_size: node['left'] = self._to_terminal(left) else: node['left'] = self._get_best_split(left) self._split_and_create_node(node['left'], depth+1, max_depth, min_size) if len(right) <= min_size: node['right'] = self._to_terminal(right) else: node['right'] = self._get_best_split(right) self._split_and_create_node(node['right'], depth+1, max_depth, min_size) def _build_tree(self, train, max_depth=5, min_size=1): root = self._get_best_split(train) self._split_and_create_node(root, 1, max_depth, min_size) return root"},{"question":"def prime_factors(n: int) -> list: Compute the distinct prime factors of the given positive integer. :param n: A positive integer (>= 2) :return: List of distinct prime factors in ascending order. >>> prime_factors(28) [2, 7] >>> prime_factors(45) [3, 5] >>> prime_factors(97) [97] >>> prime_factors(600) [2, 3, 5] >>> prime_factors(1024) [2]","solution":"def prime_factors(n: int) -> list: Compute the distinct prime factors of the given positive integer. :param n: A positive integer (>= 2) :return: List of distinct prime factors in ascending order. factors = [] # Check for the smallest prime factor 2 if n % 2 == 0: factors.append(2) while n % 2 == 0: n //= 2 # Check for all odd numbers from 3 to sqrt(n) factor = 3 while factor * factor <= n: if n % factor == 0: factors.append(factor) while n % factor == 0: n //= factor factor += 2 # If n becomes a prime number greater than 2 if n > 2: factors.append(n) return factors"},{"question":"from typing import List def find_heaviest_package(packages: List[int], weight_limit: int) -> int: Determines the heaviest package that can be shipped without exceeding the given weight limit. >>> find_heaviest_package([10, 15, 45, 30, 50, 25], 40) 30 >>> find_heaviest_package([10, 20, 30, 40, 50], 25) 20 >>> find_heaviest_package([100, 200, 300], 50) -1 pass","solution":"from typing import List def find_heaviest_package(packages: List[int], weight_limit: int) -> int: max_weight = -1 for weight in packages: if weight <= weight_limit and weight > max_weight: max_weight = weight return max_weight"},{"question":"from typing import List def is_prime(num: int) -> bool: Check if a number is prime. :param num: int - The number to check. :return: bool - True if the number is prime, False otherwise. def prime_fibonacci(limit: int) -> List[int]: Identify all prime Fibonacci numbers up to a given limit. :param limit: int - The inclusive upper limit of the Fibonacci sequence to check. :return: List[int] - A list of prime Fibonacci numbers up to the given limit. pass # Unit Tests def test_prime_fibonacci_up_to_50(): assert prime_fibonacci(50) == [2, 3, 5, 13] def test_prime_fibonacci_up_to_100(): assert prime_fibonacci(100) == [2, 3, 5, 13, 89] def test_prime_fibonacci_up_to_0(): assert prime_fibonacci(0) == [] def test_prime_fibonacci_up_to_1(): assert prime_fibonacci(1) == [] def test_prime_fibonacci_up_to_2(): assert prime_fibonacci(2) == [2] def test_prime_fibonacci_up_to_10(): assert prime_fibonacci(10) == [2, 3, 5] def test_prime_fibonacci_large_limit(): # This test ensures the function works for larger limits within the given constraints assert prime_fibonacci(100000) == [2, 3, 5, 13, 89, 233, 1597, 28657]","solution":"from typing import List def is_prime(num: int) -> bool: if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def prime_fibonacci(limit: int) -> List[int]: a, b = 0, 1 prime_fibs = [] while a <= limit: if is_prime(a): prime_fibs.append(a) a, b = b, a + b return prime_fibs"},{"question":"class BST: def __init__(self): self.root = None def insert(self, key): Inserts a new key into the Binary Search Tree (BST) # Your implementation here def search(self, key): Searches for a given key in the BST and returns True if it exists, False otherwise # Your implementation here class Node: def __init__(self, key): self.key = key self.left = None self.right = None import pytest from solution import BST def test_insert_and_search(): bst = BST() bst.insert(5) bst.insert(2) bst.insert(8) bst.insert(6) bst.insert(1) assert bst.search(5) == True assert bst.search(2) == True assert bst.search(8) == True assert bst.search(6) == True assert bst.search(1) == True assert bst.search(10) == False assert bst.search(0) == False def test_empty_tree(): bst = BST() assert bst.search(5) == False def test_single_node_tree(): bst = BST() bst.insert(10) assert bst.search(10) == True assert bst.search(5) == False def test_large_tree(): bst = BST() elements = range(1, 1000, 2) # insert odd numbers from 1 to 999 for el in elements: bst.insert(el) for el in elements: assert bst.search(el) == True for el in range(0, 1000, 2): # test even numbers assert bst.search(el) == False","solution":"class BST: class Node: def __init__(self, key): self.key = key self.left = None self.right = None def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = self.Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = self.Node(key) else: self._insert(node.right, key) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if node is None: return False if key == node.key: return True elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key)"},{"question":"def count_unique_substrings(s: str, k: int) -> int: Counts the number of unique substrings of length k in the given string s. :param s: The input string consisting of lowercase English letters. :param k: The length of the substrings to consider. :return: The number of unique substrings of length k. >>> count_unique_substrings(\\"abcdefg\\", 3) 5 >>> count_unique_substrings(\\"abacab\\", 2) 4 >>> count_unique_substrings(\\"aaaaa\\", 2) 1","solution":"def count_unique_substrings(s: str, k: int) -> int: Counts the number of unique substrings of length k in the given string s. :param s: The input string consisting of lowercase English letters. :param k: The length of the substrings to consider. :return: The number of unique substrings of length k. if k > len(s): return 0 unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"class TrieNode: def __init__(self): A node in the Trie structure. self.children = {} self.end_of_word = False self.prefix_count = 0 class Trie: def __init__(self): Initialize the Trie. self.root = TrieNode() def insert(self, word): Insert a word into the Trie. Parameters: word : A string representing the word to be inserted. pass def search(self, word): Search for a word in the Trie. Parameters: word : A string representing the word to search. Returns: bool : True if the word exists in the Trie, False otherwise. pass def starts_with(self, prefix): Count how many words in the Trie start with the given prefix. Parameters: prefix : A string representing the prefix. Returns: int : The number of words that start with the given prefix. pass import pytest def test_insert_and_search(): trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True # \\"apple\\" is in the trie assert trie.search(\\"app\\") == False # \\"app\\" is not in the trie, only \\"apple\\" is def test_multiple_insert_and_search(): trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") assert trie.search(\\"apple\\") == True # \\"apple\\" is in the trie assert trie.search(\\"app\\") == True # \\"app\\" is now in the trie def test_starts_with(): trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") trie.insert(\\"bat\\") assert trie.starts_with(\\"app\\") == 2 # \\"apple\\" and \\"app\\" start with \\"app\\" assert trie.starts_with(\\"ap\\") == 3 # \\"apple\\", \\"app\\" and \\"apricot\\" start with \\"ap\\" assert trie.starts_with(\\"bat\\") == 1 # \\"bat\\" starts with \\"bat\\" assert trie.starts_with(\\"ba\\") == 1 # \\"bat\\" starts with \\"ba\\" assert trie.starts_with(\\"b\\") == 1 # \\"bat\\" starts with \\"b\\" def test_empty_trie(): trie = Trie() assert trie.search(\\"apple\\") == False assert trie.starts_with(\\"app\\") == 0 def test_search_nonexistent_word(): trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"banana\\") == False assert trie.starts_with(\\"ban\\") == 0 def test_insert_and_search_multiple_words(): trie = Trie() words = [\\"apple\\", \\"app\\", \\"apply\\", \\"application\\", \\"apt\\"] for word in words: trie.insert(word) for word in words: assert trie.search(word) == True assert trie.starts_with(\\"app\\") == 4 # \\"apple\\", \\"app\\", \\"apply\\", \\"application\\" assert trie.starts_with(\\"appl\\") == 3 # \\"apple\\", \\"apply\\", \\"application\\"","solution":"class TrieNode: def __init__(self): A node in the Trie structure. self.children = {} self.end_of_word = False self.prefix_count = 0 class Trie: def __init__(self): Initialize the Trie. self.root = TrieNode() def insert(self, word): Insert a word into the Trie. Parameters: word : A string representing the word to be inserted. node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.prefix_count += 1 node.end_of_word = True def search(self, word): Search for a word in the Trie. Parameters: word : A string representing the word to search. Returns: bool : True if the word exists in the Trie, False otherwise. node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def starts_with(self, prefix): Count how many words in the Trie start with the given prefix. Parameters: prefix : A string representing the prefix. Returns: int : The number of words that start with the given prefix. node = self.root for char in prefix: if char not in node.children: return 0 node = node.children[char] return node.prefix_count"},{"question":"from typing import Dict, List class Library: MAX_BORROW = 3 def __init__(self): self.books = {} self.users = {} def add_book(self, title: str, author: str, isbn: str) -> None: Adds a new book to the library inventory. # Implementation goes here. def add_user(self, name: str, user_id: int) -> None: Adds a new user to the library system. # Implementation goes here. def borrow_book(self, user_id: int, isbn: str) -> str: Allows a user to borrow a book if available. # Implementation goes here. def return_book(self, user_id: int, isbn: str) -> str: Allows a user to return a book they had borrowed. # Implementation goes here. def show_books(self) -> List[Dict]: Displays the current status of all books. # Implementation goes here. def show_user_details(self, user_id: int) -> Dict: Displays the details of a specific user. # Implementation goes here.","solution":"from typing import Dict, List class Library: MAX_BORROW = 3 def __init__(self): self.books = {} self.users = {} def add_book(self, title: str, author: str, isbn: str) -> None: Adds a new book to the library inventory. self.books[isbn] = { \\"title\\": title, \\"author\\": author, \\"available\\": True, \\"borrowed_by\\": None } def add_user(self, name: str, user_id: int) -> None: Adds a new user to the library system. self.users[user_id] = { \\"name\\": name, \\"borrowed_books\\": [] } def borrow_book(self, user_id: int, isbn: str) -> str: Allows a user to borrow a book if available. if user_id not in self.users: return \\"User not found.\\" if isbn not in self.books: return \\"Book not found.\\" user = self.users[user_id] book = self.books[isbn] if not book[\\"available\\"]: return \\"Book is not available.\\" if len(user[\\"borrowed_books\\"]) >= Library.MAX_BORROW: return \\"User has already borrowed maximum number of books.\\" book[\\"available\\"] = False book[\\"borrowed_by\\"] = user_id user[\\"borrowed_books\\"].append(isbn) return \\"Book borrowed successfully.\\" def return_book(self, user_id: int, isbn: str) -> str: Allows a user to return a book they had borrowed. if user_id not in self.users: return \\"User not found.\\" if isbn not in self.books: return \\"Book not found.\\" user = self.users[user_id] book = self.books[isbn] if book[\\"available\\"]: return \\"Book was not borrowed.\\" if book[\\"borrowed_by\\"] != user_id: return \\"User did not borrow this book.\\" book[\\"available\\"] = True book[\\"borrowed_by\\"] = None user[\\"borrowed_books\\"].remove(isbn) return \\"Book returned successfully.\\" def show_books(self) -> List[Dict]: Displays the current status of all books. return [{\\"title\\": book[\\"title\\"], \\"author\\": book[\\"author\\"], \\"isbn\\": isbn, \\"available\\": book[\\"available\\"]} for isbn, book in self.books.items()] def show_user_details(self, user_id: int) -> Dict: Displays the details of a specific user. if user_id not in self.users: return {} user = self.users[user_id] return { \\"name\\": user[\\"name\\"], \\"borrowed_books\\": user[\\"borrowed_books\\"] }"},{"question":"def get_checkout_duration(default_days: int, member_status: str) -> int: Computes the total number of days a book can be borrowed based on its default duration and the member's status. >>> get_checkout_duration(21, 'regular') 21 >>> get_checkout_duration(14, 'premium') 21 >>> get_checkout_duration(10, 'vip') 24","solution":"def get_checkout_duration(default_days: int, member_status: str) -> int: if not (1 <= default_days <= 30): raise ValueError(\\"default_days must be between 1 and 30\\") if member_status not in ['regular', 'premium', 'vip']: raise ValueError(\\"member_status must be one of 'regular', 'premium', or 'vip'\\") if member_status == 'regular': return default_days elif member_status == 'premium': return default_days + 7 elif member_status == 'vip': return default_days + 14"},{"question":"def filter_stop_words(query: str, stop_words: set) -> str: Filters out the stop words from the query. Parameters: query (str): The search query from which to filter out the stop words. stop_words (set): A set of stop words to filter out from the query. Returns: str: The query with the stop words removed, preserving the order of the remaining words. >>> filter_stop_words(\\"The quick brown fox jumps over the lazy dog\\", {\\"the\\", \\"over\\", \\"is\\"}) == \\"quick brown fox jumps lazy dog\\" >>> filter_stop_words(\\"Hello world\\", {\\"hello\\"}) == \\"world\\" >>> filter_stop_words(\\"To be or not to be\\", {\\"to\\", \\"be\\", \\"or\\", \\"not\\"}) == \\"\\" >>> filter_stop_words(\\"\\", {\\"a\\", \\"the\\"}) == \\"\\" >>> filter_stop_words(\\"a b c d e\\", {\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"}) == \\"\\" >>> filter_stop_words(\\"Python programming is fun\\", {\\"is\\", \\"fun\\"}) == \\"Python programming\\"","solution":"def filter_stop_words(query: str, stop_words: set) -> str: Filters out the stop words from the query. Parameters: query (str): The search query from which to filter out the stop words. stop_words (set): A set of stop words to filter out from the query. Returns: str: The query with the stop words removed, preserving the order of the remaining words. # Convert stop_words to lower case to handle case insensitivity stop_words = {word.lower() for word in stop_words} # Split the query into words and filter those not in stop_words filtered_words = [word for word in query.split() if word.lower() not in stop_words] # Join the filtered words back into a single string with spaces return ' '.join(filtered_words)"},{"question":"def count_paths(m: int, n: int) -> int: Returns the number of unique paths the robot can take to reach the bottom-right corner of the grid. >>> count_paths(3, 7) 28 >>> count_paths(1, 1) 1","solution":"def count_paths(m: int, n: int) -> int: if m == 0 or n == 0: return 0 # Initialize a 2D list with 1 at the starting point dp = [[1] * n for _ in range(m)] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"def is_match(s: str, p: str) -> bool: Check if the string \`s\` matches the pattern \`p\`, where the pattern may include wildcard characters '?' and '*'. \`?\` matches any single character. \`*\` matches any sequence of characters (including the empty sequence). >>> is_match(\\"adceb\\", \\"*a*b\\") True >>> is_match(\\"aa\\", \\"a\\") False >>> is_match(\\"cb\\", \\"?a\\") False >>> is_match(\\"acdcb\\", \\"a*c?b\\") False >>> is_match(\\"badge\\", \\"ba?ge\\") True m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == '?' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]","solution":"def is_match(s: str, p: str) -> bool: m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '*': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] elif p[j - 1] == '?' or s[i - 1] == p[j - 1]: dp[i][j] = dp[i - 1][j - 1] return dp[m][n]"},{"question":"from typing import List def flag_fraudulent_transactions(transactions: List[float], threshold: float) -> List[int]: Scans through a list of transaction amounts and flags transactions that exceed a given threshold. >>> flag_fraudulent_transactions([], 100.0) [] >>> flag_fraudulent_transactions([50.0, 200.0, 150.0, 300.0, 20.0], 100.0) [1, 2, 3] >>> flag_fraudulent_transactions([10.0, 20.0, 30.0], 25.0) [2]","solution":"from typing import List def flag_fraudulent_transactions(transactions: List[float], threshold: float) -> List[int]: Returns a list of indices where the transactions exceed the given threshold. return [i for i, amount in enumerate(transactions) if amount > threshold]"},{"question":"def sum_of_digits(number: int) -> int: Computes the sum of the digits of a given number recursively. Parameters: number (int): A non-negative integer whose sum of digits needs to be computed. Returns: int: The sum of the digits of the input number. Raises: ValueError: If the input number is not a non-negative integer. Examples: >>> sum_of_digits(123) 6 >>> sum_of_digits(0) 0 >>> sum_of_digits(9875) 29 >>> sum_of_digits(1001) 2 # Your implementation here import pytest def test_sum_of_digits_single_digit(): assert sum_of_digits(5) == 5 assert sum_of_digits(9) == 9 def test_sum_of_digits_multiple_digits(): assert sum_of_digits(123) == 6 assert sum_of_digits(9875) == 29 assert sum_of_digits(1001) == 2 def test_sum_of_digits_zero(): assert sum_of_digits(0) == 0 def test_sum_of_digits_max_limit(): assert sum_of_digits(999999999) == 81 def test_sum_of_digits_invalid_inputs(): try: sum_of_digits(-1) except ValueError as e: assert str(e) == \\"Input must be a non-negative integer (0 ≤ number ≤ 10^9)\\" try: sum_of_digits(12.5) except ValueError as e: assert str(e) == \\"Input must be a non-negative integer (0 ≤ number ≤ 10^9)\\" try: sum_of_digits(\\"123\\") except ValueError as e: assert str(e) == \\"Input must be a non-negative integer (0 ≤ number ≤ 10^9)\\"","solution":"def sum_of_digits(number: int) -> int: Returns the sum of the digits of a non-negative integer number. if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer (0 ≤ number ≤ 10^9)\\") if number == 0: return 0 if number < 10: return number return number % 10 + sum_of_digits(number // 10)"},{"question":"def connector_ways(matrix: list[list[int]]) -> int: Calculate the number of unique ways to connect the top-left corner of a matrix to the bottom-right corner. Movement is only allowed to the right or downward, and certain cells are blocked. Args: matrix (list[list[int]]): A 2D list where each element is either 0 (free space) or 1 (blocked space). Returns: int: The total number of unique paths from the top-left to the bottom-right cell. If no such path exists, return 0. >>> connector_ways([ ... [0, 0, 1], ... [1, 0, 0], ... [0, 0, 0] ... ]) 2 >>> connector_ways([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 6 >>> connector_ways([ ... [0, 0, 1], ... [1, 1, 0], ... [0, 0, 0] ... ]) 0 >>> connector_ways([[0]]) 1 >>> connector_ways([[1]]) 0 >>> connector_ways([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2","solution":"def connector_ways(matrix: list[list[int]]) -> int: if not matrix or matrix[0][0] == 1 or matrix[-1][-1] == 1: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = 1 for i in range(rows): for j in range(cols): if matrix[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] # Example usage: matrix = [ [0, 0, 1], [1, 0, 0], [0, 0, 0] ] print(connector_ways(matrix)) # Output: 2"},{"question":"def standardize_key(key: str) -> str: Standardizes the given key string by trimming leading and trailing whitespace and replacing internal groups of whitespace with a single underscore. >>> standardize_key(\\" config key \\") == \\"config_key\\" >>> standardize_key(\\"multi part t key\\") == \\"multi_part_key\\" >>> standardize_key(\\"nnewnline key \\") == \\"new_line_key\\" >>> standardize_key(\\"singleword\\") == \\"singleword\\"","solution":"def standardize_key(key): Standardizes the given key string by trimming leading and trailing whitespace and replacing internal groups of whitespace with a single underscore. trimmed_key = key.strip() standardized_key = [] whitespace_encountered = False for char in trimmed_key: if char.isspace(): if not whitespace_encountered: standardized_key.append('_') whitespace_encountered = True else: standardized_key.append(char) whitespace_encountered = False return ''.join(standardized_key) # Examples provided in the problem statement assert standardize_key(\\" config key \\") == \\"config_key\\" assert standardize_key(\\"multi part t key\\") == \\"multi_part_key\\" assert standardize_key(\\"nnewnline key \\") == \\"new_line_key\\" assert standardize_key(\\"singleword\\") == \\"singleword\\""},{"question":"def kruskal_min_spanning_tree(graph, n): Compute the minimum spanning tree (MST) of a graph using Kruskal's algorithm. The function should return a tuple with two elements: 1. An integer representing the total weight of the MST. 2. A list of tuples representing the edges in the MST (u, v, w), where u and v are the vertex indices and w is the weight of the edge. >>> test_graph = [ ... [0, 2, 0, 6, 0], ... [2, 0, 3, 8, 5], ... [0, 3, 0, 0, 7], ... [6, 8, 0, 0, 9], ... [0, 5, 7, 9, 0] ... ] >>> num_vertices = 5 >>> kruskal_min_spanning_tree(test_graph, num_vertices) (16, [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)]) pass def test_kruskal_min_spanning_tree(): test_graph1 = [ [0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0] ] num_vertices1 = 5 expected1 = (16, [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)]) assert kruskal_min_spanning_tree(test_graph1, num_vertices1) == expected1 test_graph2 = [ [0, 1, 3, 0], [1, 0, 3, 6], [3, 3, 0, 2], [0, 6, 2, 0] ] num_vertices2 = 4 expected2 = (6, [(0, 1, 1), (2, 3, 2), (0, 2, 3)]) assert kruskal_min_spanning_tree(test_graph2, num_vertices2) == expected2 test_graph3 = [ [0, 4, 4, 0], [4, 0, 2, 0], [4, 2, 0, 3], [0, 0, 3, 0] ] num_vertices3 = 4 expected3 = (9, [(1, 2, 2), (2, 3, 3), (0, 1, 4)]) assert kruskal_min_spanning_tree(test_graph3, num_vertices3) == expected3","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rank[rootX] < rank[rootY]: parent[rootX] = rootY elif rank[rootX] > rank[rootY]: parent[rootY] = rootX else: parent[rootY] = rootX rank[rootX] += 1 def kruskal_min_spanning_tree(graph, n): edges = [] for i in range(n): for j in range(i + 1, n): if graph[i][j] != 0: edges.append((graph[i][j], i, j)) edges.sort() parent = [i for i in range(n)] rank = [0] * n mst_weight = 0 mst_edges = [] for weight, u, v in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += weight mst_edges.append((u, v, weight)) return mst_weight, mst_edges"},{"question":"from typing import Tuple, Optional def find_intersection_point(line1: Tuple[Tuple[float, float], Tuple[float, float]], line2: Tuple[Tuple[float, float], Tuple[float, float]]) -> Optional[Tuple[float, float]]: Finds the intersection point of two lines in a 2D plane. Args: line1 (Tuple[Tuple[float, float], Tuple[float, float]]): Two points defining the first line. line2 (Tuple[Tuple[float, float], Tuple[float, float]]): Two points defining the second line. Returns: Optional[Tuple[float, float]]: The coordinates of the intersection point or None if the lines do not intersect. Examples: >>> find_intersection_point(((0, 0), (4, 4)), ((0, 4), (4, 0))) (2.0, 2.0) >>> find_intersection_point(((1, 1), (2, 2)), ((3, 3), (4, 4))) None >>> find_intersection_point(((0, 0), (0, 1)), ((1, 0), (1, 1))) None >>> find_intersection_point(((1, 1), (-1, -1)), ((1, -1), (-1, 1))) (0.0, 0.0) >>> find_intersection_point(((0, 0), (1, 2)), ((1, 0), (0, 2))) (0.5, 1.0)","solution":"def find_intersection_point(line1, line2): Finds the intersection point of two lines in a 2D plane. Args: line1 (tuple[tuple[float, float], tuple[float, float]]): Two points defining the first line. line2 (tuple[tuple[float, float], tuple[float, float]]): Two points defining the second line. Returns: tuple[float, float] or None: The coordinates of the intersection point or None if the lines do not intersect. (x1, y1), (x2, y2) = line1 (x3, y3), (x4, y4) = line2 denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4) if denominator == 0: # Lines are parallel or coincident return None # Calculating the intersection point x = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / denominator y = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / denominator return (x, y)"},{"question":"from typing import List def find_most_frequent(numbers: List[int]) -> int: Find and return the most frequently occurring element in a list of integers. If there are multiple elements with the same highest frequency, return any one of them. >>> find_most_frequent([1, 3, 1, 3, 2, 1]) 1 >>> find_most_frequent([3, 3, 1, 3, 2, 2, 1]) 3","solution":"from typing import List from collections import Counter def find_most_frequent(numbers: List[int]) -> int: Returns the most frequently occurring element in the list. # Using Counter to count frequencies of elements in the list frequency_counter = Counter(numbers) # Finding the item with the maximum frequency most_frequent = frequency_counter.most_common(1)[0][0] return most_frequent"},{"question":"def is_connected(graph: Dict[int, List[int]]) -> bool: Determines if an undirected graph is connected. Args: graph (Dict[int, List[int]]): A dictionary representation of the graph. Returns: bool: True if the graph is connected, False otherwise. Examples: >>> is_connected({0: [1, 2], 1: [0, 2], 2: [0, 1]}) True >>> is_connected({0: [1], 1: [0, 2], 2: [1], 3: []}) False >>> is_connected({0: [1], 1: [0, 2], 2: [1]}) True >>> is_connected({}) True","solution":"def is_connected(graph): Determines if an undirected graph is connected. Args: graph (Dict[int, List[int]]): A dictionary representation of the graph. Returns: bool: True if the graph is connected, False otherwise. if not graph: return True # Use a dictionary to track visited nodes visited = set() # Get an arbitrary starting node start_node = next(iter(graph)) # Use DFS to visit all nodes connected to the start_node def dfs(node): if node not in visited: visited.add(node) for neighbor in graph[node]: dfs(neighbor) dfs(start_node) # Check if all nodes were visited return len(visited) == len(graph)"},{"question":"from heapq import merge from typing import List def merge_and_sort_unique(lists: List[List[int]]) -> List[int]: This function takes a list of sorted lists of integers and returns a single sorted list of unique integers. >>> merge_and_sort_unique([[1, 3, 5], [2, 3, 4], [4, 5, 6]]) [1, 2, 3, 4, 5, 6] >>> merge_and_sort_unique([[], [], []]) [] >>> merge_and_sort_unique([[10], [10, 20], [5, 15, 25]]) [5, 10, 15, 20, 25] >>> merge_and_sort_unique([[1, 2, 3], [4, 5], [6]]) [1, 2, 3, 4, 5, 6] >>> merge_and_sort_unique([]) [] >>> merge_and_sort_unique([[1], [2], [3]]) [1, 2, 3] >>> merge_and_sort_unique([[1, 2], [1, 2], [1, 2]]) [1, 2] >>> merge_and_sort_unique([[1, 3, 5, 7], [1, 2, 3, 4, 5], [2, 4, 6]]) [1, 2, 3, 4, 5, 6, 7] >>> merge_and_sort_unique([[1000000000], [999999999, 1000000001], [1000000010]]) [999999999, 1000000000, 1000000001, 1000000010] pass","solution":"from heapq import merge def merge_and_sort_unique(lists): This function takes a list of sorted lists of integers and returns a single sorted list of unique integers. Params: lists (list of lists): A list containing sorted lists of integers. Returns: list: A sorted list of unique integers. merged = merge(*lists) unique_sorted_list = [] previous_value = None for value in merged: if value != previous_value: unique_sorted_list.append(value) previous_value = value return unique_sorted_list"},{"question":"from typing import List, Dict def max_profit(prices: List[int]) -> Dict[str, int]: Calculate the maximum profit that can be achieved by buying and selling the stock on different days. Given a list of stock prices where the index represents the day, return a dictionary with the maximum profit, and the corresponding buy and sell days. >>> max_profit([7, 1, 5, 3, 6, 4]) {'max_profit': 5, 'buy_day': 1, 'sell_day': 4} >>> max_profit([7, 6, 4, 3, 1]) {'max_profit': 0, 'buy_day': None, 'sell_day': None}","solution":"from typing import List, Dict def max_profit(prices: List[int]) -> Dict[str, int]: if not prices or len(prices) < 2: return { \\"max_profit\\": 0, \\"buy_day\\": None, \\"sell_day\\": None } min_price_day = 0 max_profit = 0 buy_day = None sell_day = None for i in range(1, len(prices)): if prices[i] < prices[min_price_day]: min_price_day = i current_profit = prices[i] - prices[min_price_day] if current_profit > max_profit: max_profit = current_profit buy_day = min_price_day sell_day = i return { \\"max_profit\\": max_profit, \\"buy_day\\": buy_day, \\"sell_day\\": sell_day }"},{"question":"class FileSystem: A simplified file system that supports basic file operations such as creating files, reading files, and updating file contents. Methods: - mkdir(path: str): Creates a new directory at the specified path. - add_file(file_path: str, content: str = \\"\\"): Creates a new file at the specified file path with the given content. - read_file(file_path: str) -> str: Returns the content of the file at the specified file path. - cd(path: str): Changes the current working directory to the specified path. def __init__(self): '''Initialize the file system with root directory.''' def mkdir(self, path: str): '''Creates a new directory at the specified path.''' def add_file(self, file_path: str, content: str = \\"\\"): '''Creates a new file at the specified file path with the given content.''' def read_file(self, file_path: str) -> str: '''Returns the content of the file at the specified file path.''' def cd(self, path: str): '''Changes the current working directory to the specified path.''' def test_mkdir(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") assert \\"a\\" in fs.fs[\\"/\\"][\\"directories\\"] assert \\"b\\" in fs.fs[\\"/\\"][\\"directories\\"][\\"a\\"][\\"directories\\"] assert \\"c\\" in fs.fs[\\"/\\"][\\"directories\\"][\\"a\\"][\\"directories\\"][\\"b\\"][\\"directories\\"] def test_add_file(): fs = FileSystem() fs.add_file(\\"/a/b/c/file.txt\\", \\"Hello, World!\\") assert fs.read_file(\\"/a/b/c/file.txt\\") == \\"Hello, World!\\" fs.add_file(\\"/a/b/c/file.txt\\", \\"Updated Content\\") assert fs.read_file(\\"/a/b/c/file.txt\\") == \\"Updated Content\\" def test_read_file(): fs = FileSystem() fs.add_file(\\"/a/b/c/file.txt\\", \\"Hello, World!\\") assert fs.read_file(\\"/a/b/c/nonexistent.txt\\") == \\"\\" assert fs.read_file(\\"/a/b/c/file.txt\\") == \\"Hello, World!\\" def test_cd(): fs = FileSystem() fs.mkdir(\\"/a/b\\") fs.cd(\\"/a\\") assert fs.cwd == \\"/a\\" fs.cd(\\"/a/b\\") assert fs.cwd == \\"/a/b\\" fs.cd(\\"/nonexistent\\") assert fs.cwd == \\"/a/b\\"","solution":"class FileSystem: def __init__(self): self.fs = {\\"/\\": {\\"directories\\": {}, \\"files\\": {}}} self.cwd = \\"/\\" def mkdir(self, path: str): dirs = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"/\\"] for d in dirs: if d not in current[\\"directories\\"]: current[\\"directories\\"][d] = {\\"directories\\": {}, \\"files\\": {}} current = current[\\"directories\\"][d] def add_file(self, file_path: str, content: str = \\"\\"): dirs, file_name = file_path.strip(\\"/\\").rsplit(\\"/\\", 1) current = self.fs[\\"/\\"] for d in dirs.split(\\"/\\") if dirs else []: if d in current[\\"directories\\"]: current = current[\\"directories\\"][d] else: current[\\"directories\\"][d] = {\\"directories\\": {}, \\"files\\": {}} current = current[\\"directories\\"][d] current[\\"files\\"][file_name] = content def read_file(self, file_path: str) -> str: dirs, file_name = file_path.strip(\\"/\\").rsplit(\\"/\\", 1) current = self.fs[\\"/\\"] for d in dirs.split(\\"/\\") if dirs else []: if d in current[\\"directories\\"]: current = current[\\"directories\\"][d] else: return \\"\\" return current[\\"files\\"].get(file_name, \\"\\") def cd(self, path: str): dirs = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\\"/\\"] for d in dirs: if d in current[\\"directories\\"]: current = current[\\"directories\\"][d] else: return self.cwd = path"},{"question":"from typing import List def summarize_documents(documents: List[str], summary_length: int) -> List[str]: Summarizes each document to the top \`summary_length\` sentences based on TF-IDF scores. Parameters: - documents: List of strings, each containing a document with multiple sentences. - summary_length: Integer representing the number of sentences to include in the summary. Returns: - A list of strings where each string is a summary of the corresponding document. >>> summarize_documents([\\"The cat in the hat. It sat on the mat. The mat was flat. The cat wore a hat.\\"], 2) [\\"It sat on the mat. The cat wore a hat.\\"] >>> summarize_documents([ \\"The cat in the hat. It sat on the mat. The mat was flat. The cat wore a hat.\\", \\"Dogs are very loyal animals. They bark when they see strangers. Dogs can be trained to perform various tasks.\\" ], 2) [\\"It sat on the mat. The cat wore a hat.\\", \\"Dogs are very loyal animals. Dogs can be trained to perform various tasks.\\"]","solution":"from typing import List from sklearn.feature_extraction.text import TfidfVectorizer import numpy as np def summarize_documents(documents: List[str], summary_length: int) -> List[str]: Summarizes each document to the top \`summary_length\` sentences based on TF-IDF scores. Parameters: - documents: List of strings, each containing a document with multiple sentences. - summary_length: Integer representing the number of sentences to include in the summary. Returns: - A list of strings where each string is a summary of the corresponding document. summaries = [] for doc in documents: sentences = doc.split('. ') vectorizer = TfidfVectorizer(stop_words='english') tfidf_matrix = vectorizer.fit_transform(sentences) tfidf_scores = tfidf_matrix.sum(axis=1).A1 # Sum of TF-IDF scores for each sentence # Get indices of the top \`summary_length\` sentences top_sentence_indices = np.argsort(tfidf_scores)[-summary_length:] top_sentence_indices.sort() # Form the summary by joining the selected sentences summary = '. '.join([sentences[i] for i in top_sentence_indices]) if summary and not summary.endswith('.'): summary += '.' summaries.append(summary) return summaries"},{"question":"import numpy as np class CustomLSTMCell: def __init__(self, input_dim, hidden_dim): Initializes the LSTM cell parameters. :param input_dim: int, number of input features. :param hidden_dim: int, number of features in the hidden state. self.input_dim = input_dim self.hidden_dim = hidden_dim self.W_f = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_f = np.zeros((1, hidden_dim)) self.W_i = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_i = np.zeros((1, hidden_dim)) self.W_c = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_c = np.zeros((1, hidden_dim)) self.W_o = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_o = np.zeros((1, hidden_dim)) def forward(self, x, h_prev, c_prev): Computes the output and new cell state. :param x: numpy array, input data. :param h_prev: numpy array, previous hidden state. :param c_prev: numpy array, previous cell state. :return: tuple of numpy arrays, next hidden state and next cell state. pass # Implement the forward pass def test_lstm_cell_initialization(): input_dim = 5 hidden_dim = 10 lstm_cell = CustomLSTMCell(input_dim, hidden_dim) assert lstm_cell.input_dim == input_dim assert lstm_cell.hidden_dim == hidden_dim assert lstm_cell.W_f.shape == (input_dim + hidden_dim, hidden_dim) assert lstm_cell.b_f.shape == (1, hidden_dim) assert lstm_cell.W_i.shape == (input_dim + hidden_dim, hidden_dim) assert lstm_cell.b_i.shape == (1, hidden_dim) assert lstm_cell.W_c.shape == (input_dim + hidden_dim, hidden_dim) assert lstm_cell.b_c.shape == (1, hidden_dim) assert lstm_cell.W_o.shape == (input_dim + hidden_dim, hidden_dim) assert lstm_cell.b_o.shape == (1, hidden_dim) def test_lstm_cell_forward(): input_dim = 5 hidden_dim = 10 batch_size = 3 lstm_cell = CustomLSTMCell(input_dim, hidden_dim) x = np.random.randn(batch_size, input_dim) h_prev = np.random.randn(batch_size, hidden_dim) c_prev = np.random.randn(batch_size, hidden_dim) h_next, c_next = lstm_cell.forward(x, h_prev, c_prev) assert h_next.shape == (batch_size, hidden_dim) assert c_next.shape == (batch_size, hidden_dim) def test_create_lstm_rnn(): chars = list(\\"abcdefghijklmnopqrstuvwxyz \\") char_to_idx = {char: idx for idx, char in enumerate(chars)} idx_to_char = {idx: char for idx, char in enumerate(chars)} input_dim = len(chars) hidden_dim = 10 batch_size = 1 # For simplicity, we'll use batch_size of 1 in this test x = np.zeros((batch_size, input_dim)) h_prev = np.zeros((batch_size, hidden_dim)) c_prev = np.zeros((batch_size, hidden_dim)) lstm_cell = CustomLSTMCell(input_dim, hidden_dim) num_chars_to_generate = 10 generated_text = create_lstm_rnn(\\"a quick brown fox\\", char_to_idx, idx_to_char, lstm_cell, h_prev, c_prev, num_chars_to_generate) assert isinstance(generated_text, str) assert len(generated_text) == num_chars_to_generate","solution":"import numpy as np class CustomLSTMCell: def __init__(self, input_dim, hidden_dim): self.input_dim = input_dim self.hidden_dim = hidden_dim self.W_f = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_f = np.zeros((1, hidden_dim)) self.W_i = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_i = np.zeros((1, hidden_dim)) self.W_c = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_c = np.zeros((1, hidden_dim)) self.W_o = np.random.randn(input_dim + hidden_dim, hidden_dim) self.b_o = np.zeros((1, hidden_dim)) def forward(self, x, h_prev, c_prev): concat = np.concatenate((x, h_prev), axis=1) f_t = self.sigmoid(np.dot(concat, self.W_f) + self.b_f) i_t = self.sigmoid(np.dot(concat, self.W_i) + self.b_i) c_tilde = np.tanh(np.dot(concat, self.W_c) + self.b_c) c_next = f_t * c_prev + i_t * c_tilde o_t = self.sigmoid(np.dot(concat, self.W_o) + self.b_o) h_next = o_t * np.tanh(c_next) return h_next, c_next def sigmoid(self, x): return 1 / (1 + np.exp(-x)) def create_lstm_rnn(text, char_to_idx, idx_to_char, lstm_cell, initial_hidden_state, initial_cell_state, num_chars_to_generate): hidden_state = initial_hidden_state cell_state = initial_cell_state x = np.zeros((1, len(char_to_idx))) generated_text = \\"\\" for _ in range(num_chars_to_generate): h_next, c_next = lstm_cell.forward(x, hidden_state, cell_state) hidden_state, cell_state = h_next, c_next predicted_char_idx = np.argmax(h_next.flatten()) generated_text += idx_to_char[predicted_char_idx] x = np.zeros((1, len(char_to_idx))) x[0, predicted_char_idx] = 1 return generated_text # Example of text generation setup chars = list(\\"abcdefghijklmnopqrstuvwxyz \\") char_to_idx = {char: idx for idx, char in enumerate(chars)} idx_to_char = {idx: char for idx, char in enumerate(chars)} input_dim = len(chars) hidden_dim = 10 batch_size = 1 # For simplicity, we'll use batch_size of 1 in this example x = np.random.randn(batch_size, input_dim) h_prev = np.zeros((batch_size, hidden_dim)) c_prev = np.zeros((batch_size, hidden_dim)) lstm_cell = CustomLSTMCell(input_dim, hidden_dim) num_chars_to_generate = 100 generated_text = create_lstm_rnn(\\"a quick brown fox\\", char_to_idx, idx_to_char, lstm_cell, h_prev, c_prev, num_chars_to_generate) print(\\"Generated text:\\", generated_text)"},{"question":"def merge_sort(arr): Performs merge sort on the provided list of integers. Args: arr (list): The list of integers to sort. Returns: list: A new list containing the sorted integers. >>> merge_sort([4, 5, 6, 7]) [4, 5, 6, 7] >>> merge_sort([4, 5, 6, 7, -10]) [-10, 4, 5, 6, 7] >>> merge_sort([]) [] >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]","solution":"def merge_sort(arr): Performs merge sort on the provided list of integers. Args: arr (list): The list of integers to sort. Returns: list: A new list containing the sorted integers. if len(arr) <= 1: return arr def merge(left, right): sorted_array = [] while left and right: if left[0] <= right[0]: sorted_array.append(left.pop(0)) else: sorted_array.append(right.pop(0)) sorted_array.extend(left) sorted_array.extend(right) return sorted_array mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"def add_polynomials(poly1, poly2): Adds two polynomials and returns the resulting polynomial in its simplified form. Parameters: poly1 (list of ints): Coefficients of the first polynomial. poly2 (list of ints): Coefficients of the second polynomial. Returns: list of ints: Coefficients of the resulting polynomial. Examples: >>> add_polynomials([3, 0, 2], [1, 2, 1]) [4, 2, 3] >>> add_polynomials([2, 3, 0, 0, 5], [1, -3, 2]) [3, 0, 2, 0, 5] def test_add_polynomials_simple(): assert add_polynomials([3, 0, 2], [1, 2, 1]) == [4, 2, 3] def test_add_polynomials_different_lengths(): assert add_polynomials([2, 3, 0, 0, 5], [1, -3, 2]) == [3, 0, 2, 0, 5] def test_add_polynomials_one_zero(): assert add_polynomials([0, 0, 0], [1, 2, 3]) == [1, 2, 3] assert add_polynomials([1, 2, 3], [0, 0, 0]) == [1, 2, 3] def test_add_polynomials_both_zero(): assert add_polynomials([0, 0, 0], [0, 0, 0]) == [0] def test_add_polynomials_negative_coefficients(): assert add_polynomials([-1, -2, -3], [1, 2, 3]) == [0] def test_add_polynomials_large_numbers(): assert add_polynomials([1000000000, 2000000000], [3000000000, 4000000000]) == [4000000000, 6000000000]","solution":"def add_polynomials(poly1, poly2): Adds two polynomials and returns the resulting polynomial in its simplified form. # Determine the length of the longer polynomial max_length = max(len(poly1), len(poly2)) # Initialize the result polynomial with zeros result = [0] * max_length # Add the coefficients of the polynomials for i in range(max_length): coeff1 = poly1[i] if i < len(poly1) else 0 coeff2 = poly2[i] if i < len(poly2) else 0 result[i] = coeff1 + coeff2 # Remove trailing zeros while len(result) > 1 and result[-1] == 0: result.pop() return result"},{"question":"def remove_k_consecutive_duplicates(s: str, k: int) -> str: Removes k consecutive duplicate characters from the string s iteratively until no such duplicates exist. >>> remove_k_consecutive_duplicates(\\"deeedbbcccbdaa\\", 3) \\"aa\\" >>> remove_k_consecutive_duplicates(\\"pbbcggttciiippooaais\\", 2) \\"ps\\" >>> remove_k_consecutive_duplicates(\\"abcd\\", 2) \\"abcd\\" >>> remove_k_consecutive_duplicates(\\"llltt\\", 3) \\"tt\\"","solution":"def remove_k_consecutive_duplicates(s: str, k: int) -> str: Removes k consecutive duplicate characters from the string s iteratively until no such duplicates exist. stack = [] for char in s: if stack and stack[-1][0] == char: stack[-1][1] += 1 else: stack.append([char, 1]) if stack[-1][1] == k: stack.pop() result = ''.join(char * count for char, count in stack) return result"},{"question":"def remove_pattern(input_string: str, pattern: str) -> str: Remove all instances of a given pattern from the input string. Args: input_string (str): The original string from which patterns need to be removed. pattern (str): The substring pattern to be removed. Returns: str: The string after removing all instances of the pattern. >>> remove_pattern(\\"abababc\\", \\"ab\\") == \\"c\\" >>> remove_pattern(\\"hellohellshell\\", \\"hell\\") == \\"os\\" >>> remove_pattern(\\"aaaaaa\\", \\"a\\") == \\"\\" >>> remove_pattern(\\"\\", \\"a\\") == \\"\\" >>> remove_pattern(\\"abcde\\", \\"f\\") == \\"abcde\\" >>> remove_pattern(\\"aaaaaa\\", \\"aa\\") == \\"\\" >>> remove_pattern(\\"aaaa\\", \\"aa\\") == \\"\\" >>> remove_pattern(\\"a\\", \\"aa\\") == \\"a\\" >>> remove_pattern(\\"aaaa\\", \\"aaaa\\") == \\"\\"","solution":"def remove_pattern(input_string: str, pattern: str) -> str: Remove all instances of a given pattern from the input string. Args: input_string (str): The original string from which patterns need to be removed. pattern (str): The substring pattern to be removed. Returns: str: The string after removing all instances of the pattern. while pattern in input_string: input_string = input_string.replace(pattern, \\"\\") return input_string"},{"question":"import re import json from collections import Counter def word_frequency_counter(text: str, exclude_stop_words: bool=False, file_path: str=None) -> dict: Calculates the frequency of each word in the given text. If exclude_stop_words is True, excludes common stop words. If file_path is provided, saves the frequency count in JSON format to the file. Otherwise, returns the frequency count as a dictionary. :param text: str - the input text to analyze :param exclude_stop_words: bool - whether to exclude common stop words :param file_path: str - optional, the path to the file where the frequency count should be saved :return: dict - a dictionary with words as keys and their frequency count as values if file_path is not provided def test_word_frequency_counter_basic(): text = \\"Hello world! Hello everyone.\\" result = word_frequency_counter(text, exclude_stop_words=False) assert result == { \\"hello\\": 2, \\"world\\": 1, \\"everyone\\": 1 } def test_word_frequency_counter_with_stop_words(): text = \\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\" result = word_frequency_counter(text, exclude_stop_words=True) assert result == { \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"over\\": 1, \\"lazy\\": 1, \\"dog\\": 2, \\"not\\": 1, \\"amused\\": 1 } def test_word_frequency_counter_with_file(tmp_path): text = \\"The quick brown fox jumps over the lazy dog. The dog was not amused.\\" file_path = tmp_path / \\"frequency_count.json\\" word_frequency_counter(text, exclude_stop_words=True, file_path=str(file_path)) with open(file_path, 'r') as file: result = json.load(file) assert result == { \\"quick\\": 1, \\"brown\\": 1, \\"fox\\": 1, \\"jumps\\": 1, \\"over\\": 1, \\"lazy\\": 1, \\"dog\\": 2, \\"not\\": 1, \\"amused\\": 1 } def test_word_frequency_counter_case_insensitivity(): text = \\"Dog dog DOG\\" result = word_frequency_counter(text, exclude_stop_words=False) assert result == { \\"dog\\": 3 } def test_word_frequency_counter_empty_text(): text = \\"\\" result = word_frequency_counter(text, exclude_stop_words=False) assert result == {}","solution":"import re import json from collections import Counter def word_frequency_counter(text: str, exclude_stop_words: bool=False, file_path: str=None) -> dict: Calculates the frequency of each word in the given text. If exclude_stop_words is True, excludes common stop words. If file_path is provided, saves the frequency count in JSON format to the file. Otherwise, returns the frequency count as a dictionary. :param text: str - the input text to analyze :param exclude_stop_words: bool - whether to exclude common stop words :param file_path: str - optional, the path to the file where the frequency count should be saved :return: dict - a dictionary with words as keys and their frequency count as values if file_path is not provided # Hardcoded list of common stop words stop_words = {\\"the\\", \\"and\\", \\"of\\", \\"to\\", \\"a\\", \\"in\\", \\"that\\", \\"is\\", \\"it\\", \\"with\\", \\"for\\", \\"as\\", \\"on\\", \\"was\\"} # Convert text to lower case and remove punctuation text = re.sub(r'[^ws]', '', text.lower()) # Split the text into words words = text.split() # Exclude stop words if required if exclude_stop_words: words = [word for word in words if word not in stop_words] # Count the frequency of each word word_count = Counter(words) # If file_path is provided, save the frequency count in JSON format to the file; otherwise, return as dictionary if file_path: with open(file_path, 'w') as file: json.dump(word_count, file) else: return dict(word_count)"},{"question":"def reverse_words(sentence: str) -> str: Reverses the order of words in the given sentence while preserving the original spacing. Args: sentence (str): The sentence consisting of words and punctuations. Returns: str: The sentence with words in reverse order. >>> reverse_words(\\"Hello, World!\\") 'World! Hello,' >>> reverse_words(\\"The quick brown fox\\") 'fox brown quick The' >>> reverse_words(\\" Jump over the lazy dog \\") ' dog lazy the over Jump ' >>> reverse_words(\\"It's amazing, isn't it?\\") \\"it? isn't amazing, It's\\" >>> reverse_words(\\"One\\") 'One' >>> reverse_words(\\" A B C \\") ' C B A ' >>> reverse_words(\\"\\") ''","solution":"def reverse_words(sentence): Reverses the order of words in the given sentence while preserving the original spacing. Args: sentence (str): The sentence consisting of words and punctuations. Returns: str: The sentence with words in reverse order. words = sentence.split(' ') reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"import math from typing import List class Statistics: Class to calculate statistical measures for a given set of numerical data. Initialize with a list of numerical data points and supports the following functionalities: - Mean Calculation - Median Calculation - Variance Calculation - Standard Deviation Calculation - String Representation >>> data = [1, 2, 3, 4, 5] >>> stats = Statistics(data) >>> stats.mean() 3.0 >>> stats.median() 3.0 >>> stats.variance() 2.0 >>> stats.standard_deviation() 1.4142135623730951 >>> str(stats) 'Statistics Summary:nMean: 3.00nMedian: 3.00nVariance: 2.00nStandard Deviation: 1.41' def __init__(self, data: List[float]) -> None: ... def mean(self) -> float: ... def median(self) -> float: ... def variance(self) -> float: ... def standard_deviation(self) -> float: ... def __str__(self) -> str: ... Unit Test: import pytest from solution import Statistics def test_mean(): data = [1, 2, 3, 4, 5] stats = Statistics(data) assert stats.mean() == 3.0 def test_median_odd(): data = [1, 2, 3, 4, 5] stats = Statistics(data) assert stats.median() == 3.0 def test_median_even(): data = [1, 2, 3, 4] stats = Statistics(data) assert stats.median() == 2.5 def test_variance(): data = [1, 2, 3, 4, 5] stats = Statistics(data) assert stats.variance() == 2.0 def test_standard_deviation(): data = [1, 2, 3, 4, 5] stats = Statistics(data) assert stats.standard_deviation() == pytest.approx(1.414213562, 0.0001) def test_string_representation(): data = [1, 2, 3, 4, 5] stats = Statistics(data) expected_output = (\\"Statistics Summary:n\\" \\"Mean: 3.00n\\" \\"Median: 3.00n\\" \\"Variance: 2.00n\\" \\"Standard Deviation: 1.41\\") assert str(stats) == expected_output def test_single_element(): data = [5] stats = Statistics(data) assert stats.mean() == 5.0 assert stats.median() == 5.0 assert stats.variance() == 0.0 assert stats.standard_deviation() == 0.0 expected_output = (\\"Statistics Summary:n\\" \\"Mean: 5.00n\\" \\"Median: 5.00n\\" \\"Variance: 0.00n\\" \\"Standard Deviation: 0.00\\") assert str(stats) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"import math from typing import List class Statistics: def __init__(self, data: List[float]) -> None: self.data = data def mean(self) -> float: return sum(self.data) / len(self.data) def median(self) -> float: sorted_data = sorted(self.data) n = len(self.data) mid = n // 2 if n % 2 == 0: return (sorted_data[mid - 1] + sorted_data[mid]) / 2.0 else: return sorted_data[mid] def variance(self) -> float: m = self.mean() return sum((x - m) ** 2 for x in self.data) / len(self.data) def standard_deviation(self) -> float: return math.sqrt(self.variance()) def __str__(self) -> str: return (f\\"Statistics Summary:n\\" f\\"Mean: {self.mean():.2f}n\\" f\\"Median: {self.median():.2f}n\\" f\\"Variance: {self.variance():.2f}n\\" f\\"Standard Deviation: {self.standard_deviation():.2f}\\")"},{"question":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) return self def merge_sort(self) -> 'Node': Sort the linked list using merge sort algorithm. # Your code here def merge_two_sorted_lists(self, l1: 'Node', l2: 'Node') -> 'Node': Merge two sorted linked lists into one sorted list. # Your code here # Unit tests import pytest def test_merge_sort(): ll = LinkedList() ll.append(4).append(2).append(1).append(3) sorted_head = ll.merge_sort() current = sorted_head result = [] while current: result.append(current.value) current = current.next assert result == [1, 2, 3, 4] def test_merge_two_sorted_lists(): ll1 = LinkedList() ll1.append(1).append(3).append(5) ll2 = LinkedList() ll2.append(2).append(4).append(6) merged_head = LinkedList().merge_two_sorted_lists(ll1.head, ll2.head) current = merged_head result = [] while current: result.append(current.value) current = current.next assert result == [1, 2, 3, 4, 5, 6] def test_merge_sort_on_empty_list(): ll = LinkedList() sorted_head = ll.merge_sort() assert sorted_head == None def test_merge_sort_on_single_element_list(): ll = LinkedList() ll.append(1) sorted_head = ll.merge_sort() assert sorted_head.value == 1 assert sorted_head.next == None def test_merge_two_empty_lists(): merged_head = LinkedList().merge_two_sorted_lists(None, None) assert merged_head == None def test_merge_one_empty_list(): ll1 = LinkedList() ll1.append(1).append(3).append(5) merged_head = LinkedList().merge_two_sorted_lists(ll1.head, None) current = merged_head result = [] while current: result.append(current.value) current = current.next assert result == [1, 3, 5]","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) return self def merge_sort(self): if not self.head or not self.head.next: return self.head def split(head): slow = head fast = head.next while fast and fast.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None return head, mid def merge(l1, l2): dummy = Node(0) current = dummy while l1 and l2: if l1.value < l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 or l2 return dummy.next def merge_sort_rec(head): if not head or not head.next: return head left, right = split(head) left_sorted = merge_sort_rec(left) right_sorted = merge_sort_rec(right) return merge(left_sorted, right_sorted) self.head = merge_sort_rec(self.head) return self.head def merge_two_sorted_lists(self, l1, l2): dummy = Node(0) current = dummy while l1 and l2: if l1.value < l2.value: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 or l2 return dummy.next"},{"question":"def min_adjacent_swaps_to_sort(nums: List[int]) -> int: Returns the minimum number of adjacent swaps needed to sort the list in non-decreasing order. >>> min_adjacent_swaps_to_sort([3, 1, 2]) 2 >>> min_adjacent_swaps_to_sort([5, 3, 1, 4, 2]) 7 >>> min_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) 0 from solution import min_adjacent_swaps_to_sort def test_min_adjacent_swaps_unsorted_list(): assert min_adjacent_swaps_to_sort([3, 1, 2]) == 2 def test_min_adjacent_swaps_multiple_swaps_needed(): assert min_adjacent_swaps_to_sort([5, 3, 1, 4, 2]) == 7 def test_min_adjacent_swaps_sorted_list(): assert min_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) == 0 def test_min_adjacent_swaps_with_duplicates(): assert min_adjacent_swaps_to_sort([2, 3, 2, 3, 1]) == 5 def test_min_adjacent_swaps_single_element(): assert min_adjacent_swaps_to_sort([1]) == 0 def test_min_adjacent_swaps_empty_list(): assert min_adjacent_swaps_to_sort([]) == 0 def test_min_adjacent_swaps_reversed_list(): assert min_adjacent_swaps_to_sort([4, 3, 2, 1]) == 6","solution":"def min_adjacent_swaps_to_sort(nums): Returns the minimum number of adjacent swaps needed to sort the list in non-decreasing order. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count # Create a temporary array temp_arr = [0]*len(nums) return merge_sort_and_count(nums, temp_arr, 0, len(nums)-1)"},{"question":"class CircularBuffer: def __init__(self, capacity: int) -> None: Initialize the Circular Buffer with a given capacity. pass def enqueue(self, value: int) -> None: Adds a value to the buffer. If the buffer is full, the oldest data in the buffer is overwritten. pass def dequeue(self) -> int | None: Removes and returns the oldest value in the buffer if the buffer is not empty. Returns None if the buffer is empty. pass def is_empty(self) -> bool: Returns True if the buffer is empty, otherwise False. pass def is_full(self) -> bool: Returns True if the buffer is full, otherwise False. pass def size(self) -> int: Returns the number of elements currently in the buffer. pass # Testing the Circular Buffer buffer = CircularBuffer(3) assert buffer.is_empty() == True # The buffer is initially empty assert buffer.is_full() == False # The buffer is initially not full assert buffer.size() == 0 # The buffer size is 0 buffer.enqueue(1) buffer.enqueue(2) buffer.enqueue(3) assert buffer.is_empty() == False # The buffer is not empty assert buffer.is_full() == True # The buffer is now full assert buffer.size() == 3 # The buffer size is 3 assert buffer.dequeue() == 1 # Removes and returns 1 (oldest value) buffer.enqueue(4) # Adds value 4, overwriting the oldest value (2) assert buffer.dequeue() == 2 # Removes and returns 2 (oldest value) buffer.enqueue(5) # Adds value 5, overwriting the oldest value (3) assert buffer.dequeue() == 3 # Removes and returns 3 (oldest value) assert buffer.dequeue() == 4 # Removes and returns 4 (oldest value) assert buffer.dequeue() == 5 # Removes and returns 5 (oldest value) assert buffer.dequeue() == None # The buffer is empty, returns None assert buffer.size() == 0 # The buffer size is 0","solution":"class CircularBuffer: def __init__(self, capacity: int) -> None: self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.count = 0 def enqueue(self, value: int) -> None: if self.is_full(): self.head = (self.head + 1) % self.capacity else: self.count += 1 self.buffer[self.tail] = value self.tail = (self.tail + 1) % self.capacity def dequeue(self) -> int | None: if self.is_empty(): return None value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.capacity self.count -= 1 return value def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.capacity def size(self) -> int: return self.count"},{"question":"class ListNode: def __init__(val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. Arguments: l1 -- ListNode, the head of the first linked list. l2 -- ListNode, the head of the second linked list. Returns: ListNode, the head of the merged sorted linked list. # Your code goes below: pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. Arguments: l1 -- ListNode, the head of the first linked list. l2 -- ListNode, the head of the second linked list. Returns: ListNode, the head of the merged linked list. # Create a dummy node to serve as the start of the merged list dummy = ListNode() current = dummy # Traverse both lists, choosing the smaller current node each time while l1 is not None and l2 is not None: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # At most one of l1 and l2 can be non-null at this point, so connect the remaining nodes current.next = l1 if l1 is not None else l2 return dummy.next"},{"question":"def read_lines(input_file: str) -> list: Reads all lines from the input file and returns a list of lines. Parameters: input_file (str): Path to the input file. Returns: list: List of lines from the file. pass def sort_lines(lines: list) -> list: Sorts a list of lines in alphabetical order. Parameters: lines (list): List of lines to sort. Returns: list: Sorted list of lines. pass def write_lines(lines: list, output_file: str) -> None: Writes the sorted lines to the output file. Parameters: lines (list): List of sorted lines. output_file (str): Path to the output file. pass def sort_large_text_file(input_file: str, output_file: str) -> None: Reads lines from the input file, sorts them and writes them to the output file. Parameters: input_file (str): Path to the input file. output_file (str): Path to the output file. pass # Example input file content (input.txt) ''' orange apple banana apple banana apple ''' # Expected output file content (output.txt) ''' apple apple banana banana apple orange ''' # The script should read the lines: input_file = \\"input.txt\\" output_file = \\"output.txt\\" sort_large_text_file(input_file, output_file) # Unit Test import os def test_read_lines(tmp_path): # Arrange input_file = tmp_path / \\"input.txt\\" input_file.write_text(\\"applenbanananorangenapple bananan\\") # Act lines = read_lines(input_file) # Assert assert lines == ['apple', 'banana', 'orange', 'apple banana'] def test_sort_lines(): # Arrange lines = ['apple', 'banana', 'orange', 'apple banana'] # Act sorted_lines = sort_lines(lines) # Assert assert sorted_lines == ['apple', 'apple banana', 'banana', 'orange'] def test_write_lines(tmp_path): # Arrange output_file = tmp_path / \\"output.txt\\" lines = ['apple', 'apple banana', 'banana', 'orange'] # Act write_lines(lines, output_file) # Assert with open(output_file, 'r') as file: written_lines = [line.strip() for line in file.readlines()] assert written_lines == lines def test_sort_large_text_file(tmp_path): # Arrange input_file = tmp_path / \\"input.txt\\" input_file.write_text(\\"orangenbanana applenapplenapple bananan\\") output_file = tmp_path / \\"output.txt\\" # Act sort_large_text_file(input_file, output_file) # Assert with open(output_file, 'r') as file: written_lines = [line.strip() for line in file.readlines()] assert written_lines == ['apple', 'apple banana', 'banana apple', 'orange']","solution":"def read_lines(input_file): Reads all lines from the input file and returns a list of lines. Parameters: input_file (str): Path to the input file. Returns: list: List of lines from the file. with open(input_file, 'r') as file: lines = file.readlines() return [line.strip() for line in lines] def sort_lines(lines): Sorts a list of lines in alphabetical order. Parameters: lines (list): List of lines to sort. Returns: list: Sorted list of lines. return sorted(lines) def write_lines(lines, output_file): Writes the sorted lines to the output file. Parameters: lines (list): List of sorted lines. output_file (str): Path to the output file. with open(output_file, 'w') as file: for line in lines: file.write(line + 'n') def sort_large_text_file(input_file, output_file): Reads lines from the input file, sorts them and writes them to the output file. Parameters: input_file (str): Path to the input file. output_file (str): Path to the output file. lines = read_lines(input_file) sorted_lines = sort_lines(lines) write_lines(sorted_lines, output_file)"},{"question":"class IntervalTree: IntervalTree data structure to manage dynamic insertion, deletion, and querying of intervals. def __init__(self) -> None: Initialize the tree with no intervals. def insert(self, start: int, end: int) -> None: Insert an interval [start, end). >>> tree = IntervalTree() >>> tree.insert(1, 3) >>> tree.insert(5, 8) >>> tree.intervals == [(1, 3), (5, 8)] True def delete(self, start: int, end: int) -> None: Remove an interval [start, end). >>> tree = IntervalTree() >>> tree.insert(1, 3) >>> tree.insert(5, 8) >>> tree.insert(4, 10) >>> tree.delete(5, 8) >>> tree.intervals == [(1, 3), (4, 10)] True def query(self, start: int, end: int) -> list[tuple[int, int]]: Query all intervals overlapping with the given interval [start, end). >>> tree = IntervalTree() >>> tree.insert(1, 3) >>> tree.insert(5, 8) >>> tree.insert(4, 10) >>> set(tree.query(2, 6)) == set([(1, 3), (5, 8), (4, 10)]) True >>> tree.delete(5, 8) >>> set(tree.query(2, 6)) == set([(1, 3), (4, 10)]) True","solution":"class IntervalTree: def __init__(self): self.intervals = [] def insert(self, start: int, end: int) -> None: self.intervals.append((start, end)) self.intervals = sorted(self.intervals, key=lambda x: x[0]) def delete(self, start: int, end: int) -> None: if (start, end) in self.intervals: self.intervals.remove((start, end)) def query(self, start: int, end: int) -> list: result = [] for interval in self.intervals: if interval[0] < end and interval[1] > start: result.append(interval) return result"},{"question":"def max_overlapping_flights(flights: list[tuple[int, int]]) -> int: Find the maximum number of flights that overlap at any given time. Each flight's time is represented as a tuple of start and end times in a 24-hour format. >>> max_overlapping_flights([(1, 3), (2, 5), (3, 6)]) 2 >>> max_overlapping_flights([(0, 2), (1, 4), (5, 8), (6, 9)]) 2 >>> max_overlapping_flights([(1, 3), (3, 5), (5, 7)]) 1 >>> max_overlapping_flights([(2, 6), (4, 9), (8, 12)]) 2 >>> max_overlapping_flights([(0, 1), (1, 2), (2, 3), (3, 4)]) 1","solution":"def max_overlapping_flights(flights): events = [] for start, end in flights: events.append((start, 'start')) events.append((end, 'end')) # Sort events, by time, with 'end' events coming before 'start' events.sort(key=lambda x: (x[0], x[1] == 'start')) max_overlap = 0 current_overlap = 0 for event in events: if event[1] == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"def is_consecutive(lst: list) -> bool: Check if the list contains consecutive integers. Parameters: lst (list): A list of integers which may or may not be consecutive. Returns: bool: True if the list contains consecutive integers, False otherwise. Raises: TypeError: If the list contains non-integer elements. Examples: >>> is_consecutive([5, 3, 4, 2, 1]) True >>> is_consecutive([10, 11, 13, 12, 14]) True >>> is_consecutive([3, 2, 1, 2]) False >>> is_consecutive([1, 2.5, 3]) Traceback (most recent call last): ... TypeError: List should only contain integers. >>> is_consecutive([3, 5, 6, 7]) False","solution":"def is_consecutive(lst: list) -> bool: Determine if the given list contains a set of consecutive integers. Parameters: lst (list): A list of integers. Returns: bool: True if lst contains consecutive integers, False otherwise. Raises: TypeError: If the list contains non-integer elements if not all(isinstance(x, int) for x in lst): raise TypeError('List should only contain integers.') if len(lst) == 0: return False min_val = min(lst) max_val = max(lst) if max_val - min_val + 1 == len(lst) and len(set(lst)) == len(lst): return True return False"},{"question":"def rank_students_by_average(student_records: list[tuple[int, list[int]]]) -> tuple[list[tuple[int, float]], float]: This function ranks students based on their average scores. Parameters: student_records (list[tuple[int, list[int]]]): The list of student records. Returns: tuple: A tuple containing: - Ranked list of students with their average score (List[tuple]): - Student ID (int) - Average Score (float) - The highest average score (float) >>> rank_students_by_average([(101, [75, 80, 85]), (102, [90, 85, 80]), (103, [80, 70, 80]), (104, [65, 70, 60])]) ([(102, 85.0), (101, 80.0), (103, 76.67), (104, 65.0)], 85.0) >>> rank_students_by_average([(101, [75, 80, 85])]) ([(101, 80.0)], 80.0) >>> rank_students_by_average([(101, [75, 80, 85]), (105, [80, 75, 85]), (102, [90, 85, 80])]) ([(102, 85.0), (101, 80.0), (105, 80.0)], 85.0) >>> rank_students_by_average([(101, [80, 80, 80]), (102, [80, 80, 80]), (103, [80, 80, 80])]) ([(101, 80.0), (102, 80.0), (103, 80.0)], 80.0) >>> rank_students_by_average([(101, [90, 80, 70]), (102, [60, 70, 80]), (103, [50, 40, 30])]) ([(101, 80.0), (102, 70.0), (103, 40.0)], 80.0)","solution":"def calculate_average(scores): return sum(scores) / len(scores) def rank_students_by_average(student_records): # Calculate average scores student_averages = [ (student_id, round(calculate_average(scores), 2)) for student_id, scores in student_records ] # Sort by average score descending, then by student_id ascending sorted_students = sorted( student_averages, key=lambda x: (-x[1], x[0]) ) # Find the highest average score highest_average = sorted_students[0][1] if sorted_students else 0 return sorted_students, highest_average"},{"question":"[Completion Task in Python] def rle_encode(s: str) -> str: Encode a string using run-length encoding. Parameters: s (str): The input string to be encoded. Returns: str: The run-length encoded string. if not s: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_string.append(f\\"{count}{s[i - 1]}\\") count = 1 # Append the last character and its count encoded_string.append(f\\"{count}{s[-1]}\\") return ''.join(encoded_string) def rle_decode(s: str) -> str: Decode a run-length encoded string. Parameters: s (str): The run-length encoded string. Returns: str: The decoded original string. decoded_string = [] count = 0 for char in s: if char.isdigit(): count = count * 10 + int(char) else: decoded_string.append(char * count) count = 0 return ''.join(decoded_string) def main(): original_string = input(\\"Enter the string to encode: \\") encoded_string = rle_encode(original_string) decoded_string = rle_decode(encoded_string) print(f\\"Original String: {original_string}\\") print(f\\"Encoded String: {encoded_string}\\") print(f\\"Decoded String: {decoded_string}\\") if original_string == decoded_string: print(\\"Success: The decoded string matches the original string.\\") else: print(\\"Error: The decoded string does not match the original string.\\")","solution":"def rle_encode(s: str) -> str: Encode a string using run-length encoding. Parameters: s (str): The input string to be encoded. Returns: str: The run-length encoded string. if not s: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_string.append(f\\"{count}{s[i - 1]}\\") count = 1 # Append the last character and its count encoded_string.append(f\\"{count}{s[-1]}\\") return ''.join(encoded_string) def rle_decode(s: str) -> str: Decode a run-length encoded string. Parameters: s (str): The run-length encoded string. Returns: str: The decoded original string. decoded_string = [] count = 0 for char in s: if char.isdigit(): count = count * 10 + int(char) else: decoded_string.append(char * count) count = 0 return ''.join(decoded_string) def main(): original_string = input(\\"Enter the string to encode: \\") encoded_string = rle_encode(original_string) decoded_string = rle_decode(encoded_string) print(f\\"Original String: {original_string}\\") print(f\\"Encoded String: {encoded_string}\\") print(f\\"Decoded String: {decoded_string}\\") if original_string == decoded_string: print(\\"Success: The decoded string matches the original string.\\") else: print(\\"Error: The decoded string does not match the original string.\\")"},{"question":"import csv def calculate_total_sales(filename: str) -> dict: Reads sales data from a CSV file and computes the total sales for each product. Args: filename (str): The path to the CSV file. Returns: dict: A dictionary with product names as keys and total sales as values. Example: >>> calculate_total_sales('sales_data.csv') {'Product A': 250.0, 'Product B': 450.0, 'Product C': 300.0}","solution":"import csv def calculate_total_sales(filename): sales_dict = {} try: with open(filename, 'r') as file: reader = csv.DictReader(file) for row in reader: product = row['Product'] sales = float(row['Sales']) if product in sales_dict: sales_dict[product] += sales else: sales_dict[product] = sales except FileNotFoundError: print(f\\"Error: File '{filename}' not found.\\") except Exception as e: print(f\\"An error occurred: {e}\\") return sales_dict"},{"question":"def multiply_large_numbers(a: str, b: str) -> str: Multiplies two non-negative integers represented as strings without directly converting them to integers. Arguments: a (str): The first non-negative integer string. b (str): The second non-negative integer string. Returns: str: The product of the two numbers as a string. >>> multiply_large_numbers(\\"123\\", \\"456\\") '56088' >>> multiply_large_numbers(\\"999\\", \\"999\\") '998001'","solution":"def multiply_large_numbers(a: str, b: str) -> str: Multiplies two non-negative integers represented as strings without directly converting them to integers. Arguments: a (str): The first non-negative integer string. b (str): The second non-negative integer string. Returns: str: The product of the two numbers as a string. # Handle special case where any of the numbers is '0' if a == \\"0\\" or b == \\"0\\": return \\"0\\" # Result can be at most len(a) + len(b) digits result = [0] * (len(a) + len(b)) # Reverse both strings to facilitate the multiplication a = a[::-1] b = b[::-1] # Perform multiplication for i in range(len(a)): for j in range(len(b)): # Multiply and add to the correct position in the result array result[i + j] += int(a[i]) * int(b[j]) result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Convert the result array back to a string and strip any leading zeros result_str = ''.join(map(str, result[::-1])).lstrip('0') return result_str"},{"question":"import json def process_records(file_path: str) -> tuple: Extract and process JSON records to find the person with the highest sum of favorite numbers. Each line in the file is a separate JSON object with \`name\` (string), \`age\` (int), and \`favorites\` (list of integers) fields. The function computes the sum of \`favorites\` for each person, identifies the person with the highest sum, and returns their \`name\` and the calculated sum. Args: file_path (str): Path to the input text file containing JSON records. Returns: tuple: Name of the person with the highest sum of favorite numbers and the sum itself. Example: >>> process_records('input.txt') ('Bob', 60) pass","solution":"import json def process_records(file_path: str) -> tuple: highest_person = None highest_sum = -float('inf') with open(file_path, 'r') as file: for line in file: person = json.loads(line) favorites_sum = sum(person['favorites']) if favorites_sum > highest_sum: highest_sum = favorites_sum highest_person = person['name'] return (highest_person, highest_sum)"},{"question":"def rotate_2d_array(matrix: list[list[int]]) -> list[list[int]]: Rotates a 2D array 90 degrees clockwise. >>> rotate_2d_array([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_2d_array([ ... [10, 20], ... [30, 40] ... ]) == [ ... [30, 10], ... [40, 20] ... ] pass def normalize_2d_array(matrix: list[list[int]]) -> list[list[float]]: Normalizes a 2D array by dividing each value by the maximum value in the original matrix. >>> normalize_2d_array([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [round(1/9, 4), round(2/9, 4), round(3/9, 4)], ... [round(4/9, 4), round(5/9, 4), round(6/9, 4)], ... [round(7/9, 4), round(8/9, 4), 1.0] ... ] >>> normalize_2d_array([ ... [10, 20], ... [30, 40] ... ]) == [ ... [0.25, 0.5], ... [0.75, 1.0] ... ] pass","solution":"def rotate_2d_array(matrix: list[list[int]]) -> list[list[int]]: Rotates a 2D array 90 degrees clockwise. return [list(reversed(col)) for col in zip(*matrix)] def normalize_2d_array(matrix: list[list[int]]) -> list[list[float]]: Normalizes a 2D array by dividing each value by the maximum value in the original matrix. max_val = max(max(row) for row in matrix) return [[round(element / max_val, 4) for element in row] for row in matrix]"},{"question":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None self.tail = None def append(self, data): new_node = Node(data) if self.head is None: self.head = new_node self.tail = new_node else: self.tail.next = new_node self.tail = new_node def extend(self, data_list): for data in data_list: self.append(data) def has_cycle(self) -> bool: Determine if the linked list contains a cycle. >>> linked_list = LinkedList() >>> linked_list.extend([3, 1, 4, 1, 5]) >>> linked_list.has_cycle() False >>> linked_list.append(9) >>> cycle_node = linked_list.head.next.next # Node with value 4 >>> linked_list.tail.next = cycle_node >>> linked_list.has_cycle() True # Your code goes here def test_empty_list(): linked_list = LinkedList() assert linked_list.has_cycle() == False def test_one_element_list(): linked_list = LinkedList() linked_list.append(1) assert linked_list.has_cycle() == False def test_no_cycle(): linked_list = LinkedList() linked_list.extend([1, 2, 3, 4, 5]) assert linked_list.has_cycle() == False def test_with_cycle(): linked_list = LinkedList() linked_list.extend([1, 2, 3, 4, 5]) cycle_node = linked_list.head.next.next # Node with value 3 linked_list.tail.next = cycle_node assert linked_list.has_cycle() == True def test_long_no_cycle(): linked_list = LinkedList() linked_list.extend(range(10000)) assert linked_list.has_cycle() == False def test_long_list_with_cycle(): linked_list = LinkedList() linked_list.extend(range(10000)) cycle_node = linked_list.head.next.next.next.next # Node with value 4 linked_list.tail.next = cycle_node assert linked_list.has_cycle() == True","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None self.tail = None def append(self, data): new_node = Node(data) if self.head is None: self.head = new_node self.tail = new_node else: self.tail.next = new_node self.tail = new_node def extend(self, data_list): for data in data_list: self.append(data) def has_cycle(self) -> bool: slow = self.head fast = self.head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def iterative_inorder_traversal(root: TreeNode) -> List[int]: Perform the in-order traversal of a binary tree iteratively. >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> iterative_inorder_traversal(root) [1, 3, 2] >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> iterative_inorder_traversal(root) [1, 2, 3, 4, 5] pass # Test cases def test_iterative_inorder_traversal_empty(): assert iterative_inorder_traversal(None) == [] def test_iterative_inorder_traversal_single_node(): root = TreeNode(1) assert iterative_inorder_traversal(root) == [1] def test_iterative_inorder_traversal_example1(): root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) assert iterative_inorder_traversal(root) == [1, 3, 2] def test_iterative_inorder_traversal_example2(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) assert iterative_inorder_traversal(root) == [1, 2, 3, 4, 5] def test_iterative_inorder_traversal_right_heavy(): root = TreeNode(4) root.right = TreeNode(5) root.right.right = TreeNode(6) assert iterative_inorder_traversal(root) == [4, 5, 6] def test_iterative_inorder_traversal_left_heavy(): root = TreeNode(4) root.left = TreeNode(3) root.left.left = TreeNode(2) root.left.left.left = TreeNode(1) assert iterative_inorder_traversal(root) == [1, 2, 3, 4]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def iterative_inorder_traversal(root: TreeNode): stack = [] inorder_list = [] current = root while current is not None or stack: # Reach the leftmost node of the current node while current is not None: stack.append(current) current = current.left # Current must be None at this point current = stack.pop() inorder_list.append(current.val) # We have visited the node and its left subtree. # Now, it's right subtree's turn current = current.right return inorder_list"},{"question":"def count_palindromic_substrings(s: str) -> int: Count the number of palindromic substrings in a given string. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"racecar\\") 10","solution":"def count_palindromic_substrings(s: str) -> int: n = len(s) count = 0 def expand_around_center(left: int, right: int) -> None: nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd-length palindromes expand_around_center(i, i) # Even-length palindromes expand_around_center(i, i + 1) return count"},{"question":"def shift_cipher(message, shift, encode): Encode or decode the given message using a shift cipher. Parameters: - message (str): The message to encode or decode. - shift (int): The number of positions to shift the letters. - encode (bool): True to encode, False to decode. Returns: - str: The encoded or decoded message. >>> shift_cipher(\\"Hello World\\", 3, True) \\"Khoor Zruog\\" >>> shift_cipher(\\"Khoor Zruog\\", 3, False) \\"Hello World\\" >>> shift_cipher(\\"Hello World\\", -3, True) \\"Ebiil Tloia\\" >>> shift_cipher(\\"Ebiil Tloia\\", -3, False) \\"Hello World\\" >>> shift_cipher(\\"xyz\\", 3, True) \\"abc\\" >>> shift_cipher(\\"abc\\", 3, False) \\"xyz\\" >>> shift_cipher(\\"ABC\\", 2, True) \\"CDE\\" >>> shift_cipher(\\"CDE\\", 2, False) \\"ABC\\" >>> shift_cipher(\\"Abc XyZ\\", 1, True) \\"Bcd YzA\\" >>> shift_cipher(\\"Bcd YzA\\", 1, False) \\"Abc XyZ\\" >>> shift_cipher(\\"A B C\\", 2, True) \\"C D E\\" >>> shift_cipher(\\"C D E\\", 2, False) \\"A B C\\" >>> shift_cipher(\\"\\", 3, True) \\"\\" >>> shift_cipher(\\"\\", 3, False) \\"\\" >>> shift_cipher(\\"Hello World\\", 0, True) \\"Hello World\\"","solution":"def shift_cipher(message, shift, encode): Encode or decode the given message using a shift cipher. Parameters: - message (str): The message to encode or decode. - shift (int): The number of positions to shift the letters. - encode (bool): True to encode, False to decode. Returns: - str: The encoded or decoded message. if not encode: # If decoding, invert the shift shift = -shift def shift_char(c, shift): if 'a' <= c <= 'z': # Handle lowercase letters return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': # Handle uppercase letters return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) return c # Non-alphabetic characters remain unchanged return ''.join(shift_char(c, shift) for c in message)"},{"question":"class BinarySearchTree: def find_kth_smallest(self, k: int) -> int: Returns the kth smallest element in the BST. pass def is_balanced(self) -> bool: Returns True if the BST is balanced, otherwise False. pass def level_order_print(self) -> None: Prints the elements of the BST in level order. pass def test_insert_and_find_kth_smallest(): bst = BinarySearchTree() values = [7, 3, 10, 1, 5, 8, 12] for value in values: bst.insert(value) assert bst.find_kth_smallest(1) == 1 assert bst.find_kth_smallest(2) == 3 assert bst.find_kth_smallest(3) == 5 assert bst.find_kth_smallest(4) == 7 assert bst.find_kth_smallest(5) == 8 assert bst.find_kth_smallest(6) == 10 assert bst.find_kth_smallest(7) == 12 def test_is_balanced(): bst = BinarySearchTree() values = [7, 3, 10, 1, 5, 8, 12] for value in values: bst.insert(value) assert bst.is_balanced() bst = BinarySearchTree() values = [1, 2, 3, 4, 5] # An unbalanced tree for value in values: bst.insert(value) assert not bst.is_balanced() def test_level_order_print(capfd): bst = BinarySearchTree() values = [7, 3, 10, 1, 5, 8, 12] for value in values: bst.insert(value) bst.level_order_print() captured = capfd.readouterr() assert captured.out.strip() == '7 3 10 1 5 8 12' if __name__ == '__main__': import pytest pytest.main([__file__])","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinarySearchTree: def __init__(self): self.root = None def insert(self, val): if not self.root: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) else: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) def find_kth_smallest(self, k: int) -> int: def inorder_traversal(node): return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) if node else [] return inorder_traversal(self.root)[k - 1] def is_balanced(self) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, balanced return check_balance(self.root)[1] def level_order_print(self) -> None: from collections import deque q = deque([self.root]) while q: node = q.popleft() if node: print(node.val, end=' ') q.append(node.left) q.append(node.right) print()"},{"question":"def convert_to_fahrenheit(celsius: float) -> float: Converts the temperature from Celsius to Fahrenheit using the formula F = (9/5)C + 32. Parameters: celsius (float): Temperature in Celsius Returns: float: Temperature in Fahrenheit Examples: >>> convert_to_fahrenheit(0) 32.0 >>> convert_to_fahrenheit(100) 212.0 >>> convert_to_fahrenheit(-40) -40.0 >>> convert_to_fahrenheit(37) 98.6","solution":"def convert_to_fahrenheit(celsius: float) -> float: Converts the temperature from Celsius to Fahrenheit. Parameters: celsius (float): Temperature in Celsius Returns: float: Temperature in Fahrenheit return (celsius * 9/5) + 32"},{"question":"class SparseMatrix: A class to efficiently handle sparse matrices, where most elements are zero. This class supports addition, subtraction, and multiplication of sparse matrices. Methods: - set(row, col, value): Set the value of an element in the matrix. - get(row, col): Get the value of an element in the matrix. - to_dense(): Convert the sparse matrix to a dense (2D list) format. - add(other): Adds two sparse matrices and returns a new SparseMatrix object. - subtract(other): Subtracts another sparse matrix from this matrix and returns a new SparseMatrix object. - multiply(other): Multiplies two sparse matrices and returns a new SparseMatrix object. Example Usage: >>> a = SparseMatrix(3, 3) >>> a.set(0, 0, 1) >>> a.set(1, 1, 2) >>> a.set(2, 2, 3) >>> b = SparseMatrix(3, 3) >>> b.set(0, 0, 4) >>> b.set(1, 1, 5) >>> b.set(2, 2, 6) >>> c = a.add(b) >>> print(c.to_dense()) [[5, 0, 0], [0, 7, 0], [0, 0, 9]] >>> d = a.subtract(b) >>> print(d.to_dense()) [[-3, 0, 0], [0, -3, 0], [0, 0, -3]] >>> e = a.multiply(b) >>> print(e.to_dense()) [[4, 0, 0], [0, 10, 0], [0, 0, 18]] def __init__(self, rows: int, cols: int): self.rows = rows self.cols = cols self.elements = {} def set(self, row: int, col: int, value: int): Set the value of an element in the matrix. # Implementation here def get(self, row: int, col: int) -> int: Get the value of an element in the matrix. # Implementation here def to_dense(self) -> list: Convert the sparse matrix to a dense (2D list) format. # Implementation here def add(self, other: 'SparseMatrix') -> 'SparseMatrix': Adds two sparse matrices and returns a new SparseMatrix object. # Implementation here def subtract(self, other: 'SparseMatrix') -> 'SparseMatrix': Subtracts another sparse matrix from this matrix and returns a new SparseMatrix object. # Implementation here def multiply(self, other: 'SparseMatrix') -> 'SparseMatrix': Multiplies two sparse matrices and returns a new SparseMatrix object. # Implementation here if __name__ == \\"__main__\\": import pytest def test_set_get(): mat = SparseMatrix(3, 3) mat.set(1, 1, 5) assert mat.get(1, 1) == 5 assert mat.get(0, 0) == 0 def test_to_dense(): mat = SparseMatrix(3, 3) mat.set(1, 1, 5) dense = mat.to_dense() assert dense == [[0, 0, 0], [0, 5, 0], [0, 0, 0]] def test_add(): a = SparseMatrix(3, 3) a.set(0, 0, 1) a.set(1, 1, 2) a.set(2, 2, 3) b = SparseMatrix(3, 3) b.set(0, 0, 4) b.set(1, 1, 5) b.set(2, 2, 6) c = a.add(b) assert c.to_dense() == [[5, 0, 0], [0, 7, 0], [0, 0, 9]] def test_subtract(): a = SparseMatrix(3, 3) a.set(0, 0, 1) a.set(1, 1, 2) a.set(2, 2, 3) b = SparseMatrix(3, 3) b.set(0, 0, 4) b.set(1, 1, 5) b.set(2, 2, 6) d = a.subtract(b) assert d.to_dense() == [[-3, 0, 0], [0, -3, 0], [0, 0, -3]] def test_multiply(): a = SparseMatrix(3, 3) a.set(0, 0, 1) a.set(1, 1, 2) a.set(2, 2, 3) b = SparseMatrix(3, 3) b.set(0, 0, 4) b.set(1, 1, 5) b.set(2, 2, 6) e = a.multiply(b) assert e.to_dense() == [[4, 0, 0], [0, 10, 0], [0, 0, 18]] def test_add_dimension_mismatch(): a = SparseMatrix(2, 3) b = SparseMatrix(3, 2) with pytest.raises(ValueError): a.add(b) def test_subtract_dimension_mismatch(): a = SparseMatrix(2, 3) b = SparseMatrix(3, 2) with pytest.raises(ValueError): a.subtract(b) def test_multiply_dimension_mismatch(): a = SparseMatrix(2, 3) b = SparseMatrix(4, 2) with pytest.raises(ValueError): a.multiply(b)","solution":"class SparseMatrix: def __init__(self, rows, cols): self.rows = rows self.cols = cols self.elements = {} # Dictionary to store non-zero elements def set(self, row, col, value): if value != 0: self.elements[(row, col)] = value elif (row, col) in self.elements: del self.elements[(row, col)] def get(self, row, col): return self.elements.get((row, col), 0) def to_dense(self): dense_matrix = [[0] * self.cols for _ in range(self.rows)] for (row, col), value in self.elements.items(): dense_matrix[row][col] = value return dense_matrix def add(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrix dimensions must match for addition.\\") result = SparseMatrix(self.rows, self.cols) all_keys = set(self.elements.keys()).union(other.elements.keys()) for key in all_keys: sum_value = self.get(*key) + other.get(*key) result.set(key[0], key[1], sum_value) return result def subtract(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrix dimensions must match for subtraction.\\") result = SparseMatrix(self.rows, self.cols) all_keys = set(self.elements.keys()).union(other.elements.keys()) for key in all_keys: diff_value = self.get(*key) - other.get(*key) result.set(key[0], key[1], diff_value) return result def multiply(self, other): if self.cols != other.rows: raise ValueError(\\"Matrix dimensions must match for multiplication.\\") result = SparseMatrix(self.rows, other.cols) for (i, k), v in self.elements.items(): for j in range(other.cols): result.set(i, j, result.get(i, j) + v * other.get(k, j)) return result"},{"question":"class ToDoList: A class to manage a to-do list with methods to add, delete, and list to-dos. Usage Example: >>> todo_list = ToDoList() >>> todo_list.add(\\"Buy milk\\") >>> todo_list.add(\\"Walk the dog\\") >>> todo_list.list() [\\"Buy milk\\", \\"Walk the dog\\"] >>> todo_list.delete(0) >>> todo_list.list() [\\"Walk the dog\\"] def __init__(self): # Initialize the to-do list pass def add(self, item: str) -> None: Add a new to-do item to the list. pass def delete(self, index: int) -> None: Delete a to-do item at the specified index. pass def list(self) -> list: Return the current list of to-do items. pass # Unit Tests import pytest def test_add_single_item(): todo_list = ToDoList() todo_list.add(\\"Buy milk\\") assert todo_list.list() == [\\"Buy milk\\"] def test_add_multiple_items(): todo_list = ToDoList() todo_list.add(\\"Buy milk\\") todo_list.add(\\"Walk the dog\\") assert todo_list.list() == [\\"Buy milk\\", \\"Walk the dog\\"] def test_delete_item(): todo_list = ToDoList() todo_list.add(\\"Buy milk\\") todo_list.add(\\"Walk the dog\\") todo_list.delete(0) assert todo_list.list() == [\\"Walk the dog\\"] def test_delete_last_item(): todo_list = ToDoList() todo_list.add(\\"Buy milk\\") todo_list.add(\\"Walk the dog\\") todo_list.delete(1) assert todo_list.list() == [\\"Buy milk\\"] def test_delete_invalid_index(): todo_list = ToDoList() todo_list.add(\\"Buy milk\\") with pytest.raises(IndexError): todo_list.delete(2) def test_list_initially_empty(): todo_list = ToDoList() assert todo_list.list() == [] def test_delete_from_empty_list(): todo_list = ToDoList() with pytest.raises(IndexError): todo_list.delete(0)","solution":"class ToDoList: def __init__(self): self._todos = [] def add(self, item: str) -> None: self._todos.append(item) def delete(self, index: int) -> None: if index < 0 or index >= len(self._todos): raise IndexError(\\"Invalid index\\") self._todos.pop(index) def list(self) -> list: return self._todos"},{"question":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: Find the smallest positive integer not present in the list. >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_smallest_missing_positive([1, 2, 3, 4, 5]) 6 >>> find_smallest_missing_positive([2, 3, 7, 6, 8, -1, -10, 15]) 1 >>> find_smallest_missing_positive([1]) 2 >>> find_smallest_missing_positive([-1, -2, -3]) 1 >>> find_smallest_missing_positive([1, 1, 1, 1, 1]) 2 >>> find_smallest_missing_positive([0, 1, 2, 3, 5]) 4","solution":"def find_smallest_missing_positive(nums): n = len(nums) # Step 1: Mark numbers (num < 0) and (num >= n) which are not useful as they are not in the range [1, n]. for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark each cell appearing in the array as negative # index = value - 1 for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first positive number for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"class Inventory: A class to manage a collection of products in a store. Methods: - add_item(name: str, quantity: int, price: float) -> None - remove_item(name: str, quantity: int) -> bool - get_stock(name: str) -> int - get_value(name: str) -> float - total_inventory_value() -> float >>> inventory = Inventory() >>> inventory.add_item(\\"apple\\", 100, 0.5) >>> inventory.add_item(\\"banana\\", 50, 0.3) >>> inventory.get_stock(\\"apple\\") 100 >>> inventory.get_value(\\"apple\\") 50.0 >>> inventory.remove_item(\\"apple\\", 30) True >>> inventory.get_stock(\\"apple\\") 70 >>> inventory.total_inventory_value() 65.0 >>> inventory.add_item(\\"apple\\", 50, 0.6) >>> inventory.get_stock(\\"apple\\") 120 >>> inventory.get_value(\\"apple\\") 72.0 >>> inventory.total_inventory_value() 123.0 >>> inventory.remove_item(\\"apple\\", 150) False def __init__(self): pass def add_item(self, name: str, quantity: int, price: float) -> None: pass def remove_item(self, name: str, quantity: int) -> bool: pass def get_stock(self, name: str) -> int: pass def get_value(self, name: str) -> float: pass def total_inventory_value(self) -> float: pass","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, name: str, quantity: int, price: float) -> None: if name in self.items: self.items[name]['quantity'] += quantity self.items[name]['price'] = price else: self.items[name] = {'quantity': quantity, 'price': price} def remove_item(self, name: str, quantity: int) -> bool: if name not in self.items or self.items[name]['quantity'] < quantity: return False self.items[name]['quantity'] -= quantity if self.items[name]['quantity'] == 0: del self.items[name] return True def get_stock(self, name: str) -> int: return self.items[name]['quantity'] if name in self.items else 0 def get_value(self, name: str) -> float: if name in self.items: return self.items[name]['quantity'] * self.items[name]['price'] return 0.0 def total_inventory_value(self) -> float: total_value = 0.0 for item in self.items.values(): total_value += item['quantity'] * item['price'] return total_value"},{"question":"def rearrange_array(nums: list[int]) -> None: Rearranges an array such that all negative numbers come before all positive numbers. >>> nums = [1, -2, 3, -4, 5, -6] >>> rearrange_array(nums) >>> all(x < 0 for x in nums[:3]) and all(x > 0 for x in nums[3:]) True >>> nums = [-1, 2, -3, 4, 5] >>> rearrange_array(nums) >>> all(x < 0 for x in nums[:2]) and all(x > 0 for x in nums[2:]) True >>> nums = [2, 1, 3, 5, 4, 6] >>> rearrange_array(nums) >>> nums == [2, 1, 3, 5, 4, 6] True","solution":"def rearrange_array(nums: list[int]) -> None: Rearranges an array such that all negative numbers come before all positive numbers. This is done in-place without using extra space. left = 0 right = len(nums) - 1 while left <= right: if nums[left] < 0: left += 1 elif nums[right] >= 0: right -= 1 else: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1"},{"question":"import asyncio import aiohttp import logging async def process_data(event_loop, data_queue: asyncio.Queue, db): Continuously monitor the data_queue for incoming data packets, send requests to a remote server, process the response data, and store the results in a database. Parameters: event_loop (Any): The asynchronous event loop. data_queue (asyncio.Queue): Queue holding the data packets to be processed. db (Any): Database interface object with insert_data(data: dict) method. Example: >>> import asyncio >>> from database_interface import DatabaseInterface >>> async def main(): >>> event_loop = asyncio.get_event_loop() >>> data_queue = asyncio.Queue() >>> db = DatabaseInterface() >>> await data_queue.put({\\"id\\": 1, \\"payload\\": \\"data1\\"}) >>> await data_queue.put({\\"id\\": 2, \\"payload\\": \\"data2\\"}) >>> await process_data(event_loop, data_queue, db) >>> if __name__ == \\"__main__\\": >>> asyncio.run(main()) pass import pytest import asyncio from unittest.mock import AsyncMock, patch @pytest.mark.asyncio async def test_process_data(): event_loop = asyncio.get_event_loop() data_queue = asyncio.Queue() # Mock database interface db = DatabaseInterface() db.insert_data = AsyncMock() # Simulated data packets to be processed data_packets = [{\\"id\\": 1, \\"payload\\": \\"data1\\"}, {\\"id\\": 2, \\"payload\\": \\"data2\\"}] for packet in data_packets: await data_queue.put(packet) await data_queue.put(None) # Termination signal with patch('aiohttp.ClientSession.post') as mock_post: mock_response = AsyncMock() mock_response.status = 200 mock_response.json = AsyncMock(return_value={\\"key\\": \\"value\\"}) mock_post.return_value.__aenter__.return_value = mock_response await process_data(event_loop, data_queue, db) # Checks if insert_data was called with the processed data db.insert_data.assert_any_call({\\"processed_data\\": {\\"key\\": \\"value\\"}}) assert db.insert_data.call_count == 2 # Verify that the tasks are marked as done in the queue assert data_queue.qsize() == 0 class DatabaseInterface: def insert_data(self, data: dict): logging.info(f\\"Data inserted to DB: {data}\\")","solution":"import asyncio import aiohttp import logging async def process_data(event_loop, data_queue: asyncio.Queue, db): async with aiohttp.ClientSession() as session: while True: try: data_packet = await data_queue.get() if data_packet is None: # Termination signal break # Send async HTTP request async with session.post('http://example.com/endpoint', json=data_packet) as response: if response.status == 200: response_data = await response.json() # Process response data processed_data = extract_data(response_data) # Insert processed data into the database db.insert_data(processed_data) else: logging.error(f\\"Failed to process data_packet {data_packet}: {response.status}\\") except aiohttp.ClientError as e: logging.error(f\\"Network error: {e}\\") # Retry logic could be added here except Exception as e: logging.error(f\\"Error processing data_packet {data_packet}: {e}\\") finally: data_queue.task_done() def extract_data(response_data): # Placeholder function to process the response data # Assuming we extract some meaningful information from the response return {\\"processed_data\\": response_data} # Example DatabaseInterface for testing purposes class DatabaseInterface: def insert_data(self, data: dict): logging.info(f\\"Data inserted to DB: {data}\\")"},{"question":"from typing import List, Tuple, Dict def find_most_expensive(items: List[Tuple[str, str, float]]) -> Dict[str, str]: Finds the most expensive item of each type from the inventory. Parameters: items (List[Tuple[str, str, float]]): List of tuples containing item identifier, type, and price. Returns: Dict[str, str]: A dictionary where keys are item types and values are the identifiers of the most expensive items. # Your code here # Example Usage: items = [ (\\"item1\\", \\"typeA\\", 29.99), (\\"item2\\", \\"typeA\\", 45.50), (\\"item3\\", \\"typeB\\", 10.00), (\\"item4\\", \\"typeB\\", 15.75), (\\"item5\\", \\"typeC\\", 5.00) ] print(find_most_expensive(items)) # Expected output: {'typeA': 'item2', 'typeB': 'item4', 'typeC': 'item5'}","solution":"from typing import List, Tuple, Dict def find_most_expensive(items: List[Tuple[str, str, float]]) -> Dict[str, str]: Finds the most expensive item of each type from the inventory. Parameters: items (List[Tuple[str, str, float]]): List of tuples containing item identifier, type, and price. Returns: Dict[str, str]: A dictionary where keys are item types and values are the identifiers of the most expensive items. most_expensive = {} for identifier, type_, price in items: if type_ not in most_expensive: most_expensive[type_] = (identifier, price) else: if price > most_expensive[type_][1]: most_expensive[type_] = (identifier, price) # Extracting only the identifiers for the return dictionary return {type_: identifier for type_, (identifier, price) in most_expensive.items()}"},{"question":"class BudgetTracker: def __init__(self) -> None: Init method to initialize the list of transactions. def add_income(self, amount: float, description: str) -> None: Add an income entry. def add_expense(self, amount: float, description: str) -> None: Add an expense entry. def calculate_balance(self) -> float: Calculate and return the balance. # Unit Tests def test_initial_balance(): tracker = BudgetTracker() assert tracker.calculate_balance() == 0.0 def test_add_income(): tracker = BudgetTracker() tracker.add_income(1000.0, \\"Salary\\") assert tracker.calculate_balance() == 1000.0 def test_add_expense(): tracker = BudgetTracker() tracker.add_income(1000.0, \\"Salary\\") tracker.add_expense(200.0, \\"Groceries\\") assert tracker.calculate_balance() == 800.0 def test_multiple_transactions(): tracker = BudgetTracker() tracker.add_income(1000.0, \\"Salary\\") tracker.add_expense(200.0, \\"Groceries\\") tracker.add_expense(150.0, \\"Utilities\\") tracker.add_income(500.0, \\"Bonus\\") tracker.add_expense(100.0, \\"Transport\\") assert tracker.calculate_balance() == 1050.0","solution":"class BudgetTracker: def __init__(self) -> None: Init method to initialize the list of transactions. self.transactions = [] def add_income(self, amount: float, description: str) -> None: Add an income entry. self.transactions.append(('income', amount, description)) def add_expense(self, amount: float, description: str) -> None: Add an expense entry. self.transactions.append(('expense', amount, description)) def calculate_balance(self) -> float: Calculate and return the balance. balance = 0.0 for transaction in self.transactions: if transaction[0] == 'income': balance += transaction[1] elif transaction[0] == 'expense': balance -= transaction[1] return balance"},{"question":"from typing import List class StringUtil: def find_palindromic_substrings(self, s: str) -> List[str]: Returns a list of all distinct palindromic substrings in the input string. Args: s (str): The input string to analyze. Returns: List[str]: A list of distinct palindromic substrings. Unit Test: from solution import StringUtil def test_find_palindromic_substrings1(): string_util = StringUtil() result = string_util.find_palindromic_substrings(\\"abba\\") expected = {\\"a\\", \\"b\\", \\"bb\\", \\"abba\\"} assert set(result) == expected def test_find_palindromic_substrings2(): string_util = StringUtil() result = string_util.find_palindromic_substrings(\\"racecar\\") expected = {\\"a\\", \\"c\\", \\"r\\", \\"e\\", \\"cec\\", \\"aceca\\", \\"racecar\\"} assert set(result) == expected def test_find_palindromic_substrings3(): string_util = StringUtil() result = string_util.find_palindromic_substrings(\\"abc\\") expected = {\\"a\\", \\"b\\", \\"c\\"} assert set(result) == expected def test_find_palindromic_substrings4(): string_util = StringUtil() result = string_util.find_palindromic_substrings(\\"\\") expected = set() assert set(result) == expected def test_find_palindromic_substrings5(): string_util = StringUtil() result = string_util.find_palindromic_substrings(\\"aaaaa\\") expected = {\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\", \\"aaaaa\\"} assert set(result) == expected","solution":"class StringUtil: def find_palindromic_substrings(self, s: str): Returns a list of all distinct palindromic substrings in the input string. Args: s (str): The input string to analyze. Returns: list: A list of distinct palindromic substrings. def is_palindrome(sub): return sub == sub[::-1] palindromes = set() n = len(s) for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring): palindromes.add(substring) return list(palindromes)"},{"question":"def can_form_palindrome(s: str) -> bool: Check if any permutation of the given string can form a palindrome. :param s: The input string to be checked. :return: True if any permutation can form a palindrome, otherwise False. >>> can_form_palindrome(\\"Tact Coa\\") True >>> can_form_palindrome(\\"hello\\") False","solution":"def can_form_palindrome(s: str) -> bool: Check if any permutation of the given string can form a palindrome. :param s: The input string to be checked. :return: True if any permutation can form a palindrome, otherwise False. from collections import Counter # Normalize the string to lowercase as the problem is case-insensitive normalized_str = s.lower().replace(\\" \\", \\"\\") # Count the frequency of each character char_count = Counter(normalized_str) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # At most one character with an odd count is allowed for a palindrome return odd_count <= 1"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Find the largest rectangle in the histogram formed by the given building heights. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([1, 1, 1, 1]) 4 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9","solution":"def largestRectangleArea(heights): Finds the largest rectangle in the histogram formed by the heights. :param heights: List[int] - list of building heights. :return: int - area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class LibrarySystem: A Library System that manages the collection of books in a library. Methods: - __init__: Initializes the library system. - add_book: Adds a new book to the system. - remove_book: Removes a book from the system. - checkout_book: Marks a book as checked out. - return_book: Marks a book as returned. - search_book: Searches for books by title. >>> lib = LibrarySystem() >>> lib.add_book(1, \\"1984\\") >>> lib.add_book(2, \\"Brave New World\\") >>> lib.search_book(\\"1984\\") [1] >>> lib.search_book(\\"Brave New World\\") [2] >>> lib.checkout_book(1) >>> lib.return_book(1) >>> lib.remove_book(1) >>> lib.search_book(\\"1984\\") [] def __init__(self): pass def add_book(self, book_id: int, book_title: str): pass def remove_book(self, book_id: int): pass def checkout_book(self, book_id: int): pass def return_book(self, book_id: int): pass def search_book(self, book_title: str): pass import pytest def test_add_book(): lib = LibrarySystem() lib.add_book(1, \\"1984\\") assert lib.books[1] == \\"1984\\" with pytest.raises(ValueError): lib.add_book(1, \\"Brave New World\\") def test_remove_book(): lib = LibrarySystem() lib.add_book(1, \\"1984\\") lib.remove_book(1) assert 1 not in lib.books with pytest.raises(ValueError): lib.remove_book(1) lib.add_book(2, \\"Brave New World\\") lib.checkout_book(2) with pytest.raises(ValueError): lib.remove_book(2) def test_checkout_book(): lib = LibrarySystem() lib.add_book(1, \\"1984\\") lib.checkout_book(1) assert 1 in lib.checked_out with pytest.raises(ValueError): lib.checkout_book(2) with pytest.raises(ValueError): lib.checkout_book(1) def test_return_book(): lib = LibrarySystem() lib.add_book(1, \\"1984\\") lib.checkout_book(1) lib.return_book(1) assert 1 not in lib.checked_out with pytest.raises(ValueError): lib.return_book(2) with pytest.raises(ValueError): lib.return_book(1) def test_search_book(): lib = LibrarySystem() lib.add_book(1, \\"1984\\") lib.add_book(2, \\"Brave New World\\") lib.add_book(3, \\"1984\\") assert lib.search_book(\\"1984\\") == [1, 3] assert lib.search_book(\\"Brave New World\\") == [2] assert lib.search_book(\\"Non-Existent Book\\") == [] if __name__ == \\"__main__\\": pytest.main()","solution":"class LibrarySystem: def __init__(self): self.books = {} self.checked_out = set() def add_book(self, book_id, book_title): if book_id in self.books: raise ValueError(\\"Book ID already exists.\\") self.books[book_id] = book_title def remove_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID does not exist.\\") if book_id in self.checked_out: raise ValueError(\\"Book is currently checked out.\\") del self.books[book_id] def checkout_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID does not exist.\\") if book_id in self.checked_out: raise ValueError(\\"Book is already checked out.\\") self.checked_out.add(book_id) def return_book(self, book_id): if book_id not in self.books: raise ValueError(\\"Book ID does not exist.\\") if book_id not in self.checked_out: raise ValueError(\\"Book is not currently checked out.\\") self.checked_out.remove(book_id) def search_book(self, book_title): return [book_id for book_id, title in self.books.items() if title == book_title]"},{"question":"from typing import List, Tuple def find_closest_points( points: List[Tuple[int, int]], target: Tuple[int, int], k: int ) -> List[Tuple[int, int]]: Find the k closest points to a target point. Parameters: - points (list[tuple[int, int]]): A list of points on a 2D plane. - target (tuple[int, int]): A tuple representing the coordinates of the target point. - k (int): The number of closest points to return. Returns: - list[tuple[int, int]]: A list of the k closest points to the target. >>> points = [(1, 2), (3, 4), (1, -1), (-1, -2), (5, 2)] >>> target = (0, 0) >>> k = 3 >>> find_closest_points(points, target, k) [(1, -1), (1, 2), (-1, -2)] >>> points = [(2, 2), (-2, -2), (2, -2), (-2, 2)] >>> target = (0, 0) >>> k = 2 >>> find_closest_points(points, target, k) [(2, 2), (-2, -2)] pass # Test cases from solution import find_closest_points def test_basic_case(): points = [(1, 2), (3, 4), (1, -1), (-1, -2), (5, 2)] target = (0, 0) k = 3 result = find_closest_points(points, target, k) assert result == [(1, -1), (1, 2), (-1, -2)] def test_all_same_distance(): points = [(2, 2), (-2, -2), (2, -2), (-2, 2)] target = (0, 0) k = 2 result = find_closest_points(points, target, k) assert result == [(2, 2), (-2, -2)] or result == [(2, -2), (-2, 2)] def test_single_point(): points = [(3, 3)] target = (0, 0) k = 1 result = find_closest_points(points, target, k) assert result == [(3, 3)] def test_points_on_line(): points = [(1, 0), (2, 0), (3, 0)] target = (0, 0) k = 2 result = find_closest_points(points, target, k) assert result == [(1, 0), (2, 0)] def test_same_point_as_target(): points = [(0, 0), (1, 1), (2, 2), (3, 3)] target = (0, 0) k = 2 result = find_closest_points(points, target, k) assert result == [(0, 0), (1, 1)] def test_large_k(): points = [(i, i) for i in range(100)] target = (0, 0) k = 10 result = find_closest_points(points, target, k) assert result == [(i, i) for i in range(10)]","solution":"import math from heapq import nsmallest def find_closest_points(points, target, k): Find the k closest points to a target point. Parameters: - points (list[tuple[int, int]]): A list of points on a 2D plane. - target (tuple[int, int]): A tuple representing the coordinates of the target point. - k (int): The number of closest points to return. Returns: - list[tuple[int, int]]: A list of the k closest points to the target. def euclidean_distance(point): return math.sqrt((point[0] - target[0]) ** 2 + (point[1] - target[1]) ** 2) closest_points = nsmallest(k, points, key=euclidean_distance) return closest_points"},{"question":"class Stack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.is_empty(): return self.stack.pop() return None def is_empty(self): return len(self.stack) == 0 def clear(self): self.stack = [] def second_largest_element(self) -> Optional[int]: Returns the second largest element in the stack. If the stack has fewer than two distinct elements, returns None. Time complexity: O(n) @returns: The second largest element in the stack or None if less than two distinct elements are present. Example: >>> stack = Stack() >>> stack.push(3) >>> stack.push(1) >>> stack.push(4) >>> stack.push(4) >>> stack.push(2) >>> stack.second_largest_element() 3 >>> stack.clear() >>> stack.push(6) >>> stack.second_largest_element() None from typing import Optional # Unit tests def test_second_largest_element(): stack = Stack() assert stack.second_largest_element() == None # Empty stack stack.push(1) assert stack.second_largest_element() == None # Stack with one element stack.push(1) assert stack.second_largest_element() == None # Stack with duplicate elements but only one unique element stack.push(2) assert stack.second_largest_element() == 1 # Stack with two elements stack.push(3) assert stack.second_largest_element() == 2 # Stack with three elements stack.push(2) assert stack.second_largest_element() == 2 # Stack with repeated elements stack.clear() stack.push(5) stack.push(2) stack.push(9) stack.push(7) stack.push(7) assert stack.second_largest_element() == 7 # Stack with multiple elements and duplicates stack.clear() stack.push(6) assert stack.second_largest_element() == None # Stack with one unique element","solution":"class Stack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.is_empty(): return self.stack.pop() return None def is_empty(self): return len(self.stack) == 0 def clear(self): self.stack = [] def second_largest_element(self): if len(self.stack) < 2: return None first, second = float('-inf'), float('-inf') unique_elements = set(self.stack) if len(unique_elements) < 2: return None for num in unique_elements: if num > first: second = first first = num elif num > second and num != first: second = num return second"},{"question":"def find_majority_element(nums: List[int]) -> int: Finds the majority element in an array, which appears more than n/2 times. >>> find_majority_element([3,2,3]) 3 >>> find_majority_element([2,2,1,1,1,2,2]) 2 from typing import List def test_find_majority_element(): assert find_majority_element([3,2,3]) == 3 def test_find_majority_element_single(): assert find_majority_element([1]) == 1 def test_find_majority_element_all_same(): assert find_majority_element([2,2,2,2,2]) == 2 def test_find_majority_element_different_numbers(): assert find_majority_element([2,2,1,1,1,2,2]) == 2 def test_find_majority_element_multiple_elements(): assert find_majority_element([1,1,1,3,3,2,2,1,1]) == 1 def test_find_majority_element_long_list(): assert find_majority_element([1]*50000 + [2]*49999) == 1","solution":"def find_majority_element(nums): Finds the majority element in the list, which appears more than n/2 times. Args: nums (List[int]): A list of integers where the majority element is guaranteed to exist. Returns: int: The majority element. # Boyer-Moore Voting Algorithm candidate = None count = 0 for num in nums: if count == 0: candidate = num count += 1 if num == candidate else -1 return candidate"},{"question":"def array_product_except_self(arr): Calculate the product of all elements except for the element at the given index for each element in the input list. Args: arr (list of int): The input array. Returns: list of int: A list where each index holds the product of all elements in the array except for the element at that index. >>> array_product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> array_product_except_self([5, 6, 2, 3]) == [36, 30, 90, 60] >>> array_product_except_self([10, 3, 5, 6, 2]) == [180, 600, 360, 300, 900] >>> array_product_except_self([4, 0, 2]) == [0, 8, 0] >>> array_product_except_self([1, 0, 0]) == [0, 0, 0]","solution":"def array_product_except_self(arr): n = len(arr) product_except_self = [1] * n # Calculate left products left = 1 for i in range(n): product_except_self[i] = left left *= arr[i] # Calculate right products and update answer array right = 1 for i in range(n-1, -1, -1): product_except_self[i] *= right right *= arr[i] return product_except_self"},{"question":"def generate_prime_factors(n: int) -> list[int]: Returns the prime factors of the given integer n in ascending order. >>> generate_prime_factors(28) [2, 2, 7] >>> generate_prime_factors(29) [29]","solution":"def generate_prime_factors(n: int) -> list[int]: Returns the prime factors of the given integer n in ascending order. prime_factors = [] # Step 1: Account for 2's while n % 2 == 0: prime_factors.append(2) n //= 2 # Step 2: Account for odd factors from 3 onwards factor = 3 while factor * factor <= n: while n % factor == 0: prime_factors.append(factor) n //= factor factor += 2 # Step 3: If n is still greater than 1, then it is prime if n > 1: prime_factors.append(n) return prime_factors"},{"question":"def reverse_string_recursive(s: str) -> str: Reverses a string using recursion. @input: s (input string) @output: reversed string @example: >>> reverse_string_recursive(\\"hello\\") 'olleh' >>> reverse_string_recursive(\\"Recursion\\") 'noisruceR' pass def test_reverse_string_recursive(): assert reverse_string_recursive(\\"hello\\") == \\"olleh\\" assert reverse_string_recursive(\\"Recursion\\") == \\"noisruceR\\" assert reverse_string_recursive(\\"example\\") == \\"elpmaxe\\" assert reverse_string_recursive(\\"abcd\\") == \\"dcba\\" assert reverse_string_recursive(\\"\\") == \\"\\" assert reverse_string_recursive(\\"a\\") == \\"a\\" assert reverse_string_recursive(\\"ab\\") == \\"ba\\" assert reverse_string_recursive(\\"racecar\\") == \\"racecar\\" # palindrome test assert reverse_string_recursive(\\"12345\\") == \\"54321\\" assert reverse_string_recursive(\\"!@#%^&*()\\") == \\")(*&^%#@!\\"","solution":"def reverse_string_recursive(s: str) -> str: Reverses a string using recursion. @input: s (input string) @output: reversed string @example: >>> reverse_string_recursive(\\"hello\\") 'olleh' >>> reverse_string_recursive(\\"Recursion\\") 'noisruceR' # Base case: if the string is empty or a single character, return itself if len(s) == 0 or len(s) == 1: return s # Recursive case: reverse the rest of the string, then add the first character at the end return reverse_string_recursive(s[1:]) + s[0]"},{"question":"def longest_unique_subsequence(s: str) -> int: Returns the length of the longest subsequence without repeating characters. >>> longest_unique_subsequence(\\"abcabcbb\\") 3 >>> longest_unique_subsequence(\\"bbbbb\\") 1 >>> longest_unique_subsequence(\\"pwwkew\\") 3","solution":"def longest_unique_subsequence(s: str) -> int: Returns the length of the longest subsequence without repeating characters. # Dictionary to store the last occurrence index of every character. last_occurrence = {} start = 0 # Starting index of current window max_length = 0 for i, char in enumerate(s): # If character is already in the dictionary and the index is within the current window if char in last_occurrence and last_occurrence[char] >= start: # Move the start to one past the last occurrence of the current character start = last_occurrence[char] + 1 # Update the last occurrence of the character last_occurrence[char] = i # Calculate the length of the current window max_length = max(max_length, i - start + 1) return max_length"},{"question":"from typing import List def merge(arr1: List[int], m: int, arr2: List[int], n: int) -> None: Merge two sorted arrays in-place. arr1 has enough buffer at its end to accommodate all elements of arr2. The function does not return anything but modifies arr1 in-place. Args: arr1 (List[int]): First sorted array with buffer for second array elements. m (int): Number of valid elements in arr1. arr2 (List[int]): Second sorted array. n (int): Number of elements in arr2. Examples: >>> arr1 = [1, 2, 3, 0, 0, 0] >>> arr2 = [2, 5, 6] >>> merge(arr1, 3, arr2, 3) >>> arr1 [1, 2, 2, 3, 5, 6] >>> arr1 = [1] >>> arr2 = [] >>> merge(arr1, 1, arr2, 0) >>> arr1 [1] >>> arr1 = [0] >>> arr2 = [1] >>> merge(arr1, 0, arr2, 1) >>> arr1 [1] # Start filling 'arr1' from the end last = m + n - 1 # Pointers for arr1 and arr2 i, j = m - 1, n - 1 # Merge arr1 and arr2 starting from the end of both arrays while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[last] = arr1[i] i -= 1 else: arr1[last] = arr2[j] j -= 1 last -= 1 # Fill arr1 with the remaining elements of arr2 (if any) while j >= 0: arr1[last] = arr2[j] j -= 1 last -= 1","solution":"from typing import List def merge(arr1: List[int], m: int, arr2: List[int], n: int) -> None: last = m + n - 1 i, j = m - 1, n - 1 while i >= 0 and j >= 0: if arr1[i] > arr2[j]: arr1[last] = arr1[i] i -= 1 else: arr1[last] = arr2[j] j -= 1 last -= 1 while j >= 0: arr1[last] = arr2[j] j -= 1 last -= 1"},{"question":"def reverse_words(input_string: str) -> str: Takes a string as input and returns a new string with the words in reverse order. Preserves leading, trailing, and multiple spaces between words. >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\"hello world!\\") \\"world! hello\\" >>> reverse_words(\\"a b c d\\") \\"d c b a\\" >>> reverse_words(\\" Leading spaces\\") \\"spaces Leading\\" >>> reverse_words(\\"Trailing spaces \\") \\"spaces Trailing\\" >>> reverse_words(\\" Leading and trailing spaces \\") \\"spaces trailing and Leading\\" >>> reverse_words(\\"Multiple spaces between words\\") \\"words between spaces Multiple\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\"single\\") \\"single\\" # Implement the function here","solution":"def reverse_words(input_string: str) -> str: Takes a string as input and returns a new string with the words in reverse order. Preserves leading, trailing, and multiple spaces between words. words = input_string.split() reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform an in-order traversal of a binary tree and return the list of node values. >>> tree1 = TreeNode(1, right=TreeNode(2, left=TreeNode(3))) >>> inorder_traversal(tree1) == [1, 3, 2] True >>> tree2 = TreeNode(4, ... left=TreeNode(2, TreeNode(1), TreeNode(3)), ... right=TreeNode(6, TreeNode(5), TreeNode(7))) >>> inorder_traversal(tree2) == [1, 2, 3, 4, 5, 6, 7] True def preorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform a pre-order traversal of a binary tree and return the list of node values. >>> tree1 = TreeNode(1, right=TreeNode(2, left=TreeNode(3))) >>> preorder_traversal(tree1) == [1, 2, 3] True >>> tree2 = TreeNode(4, ... left=TreeNode(2, TreeNode(1), TreeNode(3)), ... right=TreeNode(6, TreeNode(5), TreeNode(7))) >>> preorder_traversal(tree2) == [4, 2, 1, 3, 6, 5, 7] True def postorder_traversal(root: Optional[TreeNode]) -> List[int]: Perform a post-order traversal of a binary tree and return the list of node values. >>> tree1 = TreeNode(1, right=TreeNode(2, left=TreeNode(3))) >>> postorder_traversal(tree1) == [3, 2, 1] True >>> tree2 = TreeNode(4, ... left=TreeNode(2, TreeNode(1), TreeNode(3)), ... right=TreeNode(6, TreeNode(5), TreeNode(7))) >>> postorder_traversal(tree2) == [1, 3, 2, 5, 7, 6, 4] True","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def inorder(node): if node: inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result def preorder_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def preorder(node): if node: result.append(node.val) preorder(node.left) preorder(node.right) preorder(root) return result def postorder_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def postorder(node): if node: postorder(node.left) postorder(node.right) result.append(node.val) postorder(root) return result"},{"question":"def has_cycle(graph: dict) -> bool: Detect if a directed graph has a cycle. Args: - graph (dict): A dictionary representing a directed graph with keys as vertices and values as lists of adjacent vertices. Returns: - bool: True if there is a cycle in the graph, False otherwise. Example: >>> graph1 = {0: [1], 1: [2], 2: [0]} >>> has_cycle(graph1) True >>> graph2 = {0: [1, 2], 1: [2], 2: [3], 3: []} >>> has_cycle(graph2) False >>> graph3 = {0: [1], 1: [2], 2: [3], 3: [1]} >>> has_cycle(graph3) True","solution":"def has_cycle(graph: dict) -> bool: Detect if a directed graph has a cycle. Args: - graph (dict): A dictionary representing a directed graph with keys as vertices and values as lists of adjacent vertices. Returns: - bool: True if there is a cycle in the graph, False otherwise. def dfs(vertex): # Recursively perform depth first search if vertex in visiting: return True if vertex in visited: return False visiting.add(vertex) for neighbor in graph.get(vertex, []): if dfs(neighbor): return True visiting.remove(vertex) visited.add(vertex) return False visited = set() visiting = set() for v in graph: if dfs(v): return True return False"},{"question":"from typing import List, Dict, Union def trip_efficiency_report(trips: List[Dict[str, Union[int, float]]]) -> Dict[str, float]: Calculate the trip efficiency for each trip provided in the input list. Parameters: trips (List[Dict[str, Union[int, float]]]): A list of dictionaries where each dictionary represents a trip. Each dictionary contains: - 'trip_id' (int): A unique identifier for the trip - 'total_distance' (float): The total distance traveled during the trip - 'stops' (int): The number of stops made during the trip Returns: Dict[str, float]: A dictionary mapping each trip ID to its efficiency, calculated as the ratio of total distance to the number of stops. Examples: >>> trips = [ ... {'trip_id': 101, 'total_distance': 150.0, 'stops': 3}, ... {'trip_id': 102, 'total_distance': 200.0, 'stops': 4}, ... {'trip_id': 103, 'total_distance': 300.0, 'stops': 5} ... ] >>> trip_efficiency_report(trips) {101: 50.0, 102: 50.0, 103: 60.0} >>> trips = [ ... {'trip_id': 105, 'total_distance': 50.0, 'stops': 1}, ... {'trip_id': 106, 'total_distance': 75.0, 'stops': 1}, ... ] >>> trip_efficiency_report(trips) {105: 50.0, 106: 75.0}","solution":"from typing import List, Dict, Union def trip_efficiency_report(trips: List[Dict[str, Union[int, float]]]) -> Dict[str, float]: Calculate the trip efficiency for each trip provided in the input list. Parameters: trips (List[Dict[str, Union[int, float]]]): A list of dictionaries where each dictionary represents a trip. Each dictionary contains: - 'trip_id' (int): A unique identifier for the trip - 'total_distance' (float): The total distance traveled during the trip - 'stops' (int): The number of stops made during the trip Returns: Dict[str, float]: A dictionary mapping each trip ID to its efficiency, calculated as the ratio of total distance to the number of stops. efficiency_report = {} for trip in trips: trip_id = trip['trip_id'] total_distance = trip['total_distance'] stops = trip['stops'] # Calculate the trip efficiency efficiency = total_distance / stops if stops > 0 else 0 efficiency_report[trip_id] = efficiency return efficiency_report"},{"question":"def newton_raphson(function, derivative, initial_guess: float, tolerance: float = 1e-7, max_iterations: int = 1000) -> float: Approximates the root of the given function using the Newton-Raphson method. Parameters: - function: a callable that takes a single float argument and returns a float. - derivative: a callable that takes a single float argument and returns a float representing the derivative. - initial_guess: a float representing the starting point for the iteration. - tolerance: a float representing the tolerance for the method's stopping condition. Default is 1e-7. - max_iterations: an int representing the maximum number of iterations to perform. Default is 1000. Returns: - A float representing the approximated root of the function. >>> def func(x): ... return x**3 - x - 2 >>> def deriv_func(x): ... return 3*x**2 - 1 >>> newton_raphson(func, deriv_func, 1.5) 1.5213797068045678","solution":"def newton_raphson(function, derivative, initial_guess: float, tolerance: float = 1e-7, max_iterations: int = 1000) -> float: Approximates the root of the given function using the Newton-Raphson method. Parameters: - function: a callable that takes a single float argument and returns a float. - derivative: a callable that takes a single float argument and returns a float representing the derivative. - initial_guess: a float representing the starting point for the iteration. - tolerance: a float representing the tolerance for the method's stopping condition. Default is 1e-7. - max_iterations: an int representing the maximum number of iterations to perform. Default is 1000. Returns: - A float representing the approximated root of the function. x = initial_guess for _ in range(max_iterations): fx = function(x) dfx = derivative(x) if dfx == 0: raise ZeroDivisionError(\\"Derivative is zero. Newton-Raphson method fails.\\") x_new = x - fx / dfx if abs(x_new - x) < tolerance: return x_new x = x_new raise ValueError(\\"Maximum iterations reached. No convergence.\\")"},{"question":"from typing import List import heapq def find_k_largest_elements(arr: List[int], k: int) -> List[int]: Finds the k largest elements in a list and returns them in sorted order. Parameters: arr (List[int]): The input list of integers. k (int): The number of largest elements to return. Returns: List[int]: A list containing the k largest elements sorted in ascending order. >>> find_k_largest_elements([3, 1, 5, 12, 2, 11, 7], 3) [7, 11, 12] >>> find_k_largest_elements([1, 23, 12, 9, 30, 2, 50], 4) [23, 30, 50] >>> find_k_largest_elements([10, 20, 30], 0) [] >>> find_k_largest_elements([100], 1) [100] >>> find_k_largest_elements([4, 4, 4, 4], 2) [4, 4] >>> find_k_largest_elements([-1, -3, -2, -5, -4], 2) [-2, -1] >>> find_k_largest_elements([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5]","solution":"from typing import List import heapq def find_k_largest_elements(arr: List[int], k: int) -> List[int]: Finds the k largest elements in a list and returns them in sorted order. Parameters: arr (List[int]): The input list of integers. k (int): The number of largest elements to return. Returns: List[int]: A list containing the k largest elements sorted in ascending order. if k == 0: return [] # Use a min-heap to efficiently find the k largest elements min_heap = arr[:k] heapq.heapify(min_heap) for num in arr[k:]: if num > min_heap[0]: heapq.heapreplace(min_heap, num) return sorted(min_heap)"},{"question":"import numpy as np def normalized_histogram(img: np.ndarray) -> np.ndarray: Compute the normalized histogram of the input grayscale image. Parameters: img (numpy.ndarray): A 2D grayscale image with values in the range 0 to 255. Returns: numpy.ndarray: A 1D array of length 256 containing the normalized histogram values. Example: >>> img = np.array([ ... [ 0, 50, 100], ... [150, 200, 250], ... [ 0, 100, 200] ... ]) >>> result = normalized_histogram(img) >>> len(result) == 256 True >>> np.isclose(result.sum(), 1.0) True >>> np.isclose(result[0], 2 / 9) True >>> np.isclose(result[100], 2 / 9) True >>> np.isclose(result[50], 1 / 9) True >>> np.isclose(result[150], 1 / 9) True >>> np.isclose(result[200], 2 / 9) True >>> np.isclose(result[250], 1 / 9) True","solution":"import numpy as np def normalized_histogram(img: np.ndarray) -> np.ndarray: Compute the normalized histogram of the input grayscale image. Parameters: img (numpy.ndarray): A 2D grayscale image with values in the range 0 to 255. Returns: numpy.ndarray: A 1D array of length 256 containing the normalized histogram values. # Compute the histogram of the image with 256 bins hist, _ = np.histogram(img, bins=256, range=(0, 256)) # Normalize the histogram so that the sum equals 1 hist = hist / hist.sum() return hist"},{"question":"def binary_search_desc(arr: list, target: int) -> int: Perform binary search on a list sorted in non-increasing order and return the index of the target value. :param arr: A list of integers sorted in non-increasing order. :param target: The integer value to search for in the list. :return: The index of the target value if found, otherwise -1. >>> binary_search_desc([9, 7, 5, 3, 1], 5) 2 >>> binary_search_desc([100, 80, 60, 40, 20], 25) -1 >>> binary_search_desc([10], 10) 0 >>> binary_search_desc([], -5) -1 pass # Write your solution here def test_binary_search_desc_found(): assert binary_search_desc([9, 7, 5, 3, 1], 5) == 2 assert binary_search_desc([100, 90, 80, 70], 90) == 1 assert binary_search_desc([10, 8, 6, 4, 2, 0], 0) == 5 assert binary_search_desc([15, 14, 12, 11, 10], 12) == 2 def test_binary_search_desc_not_found(): assert binary_search_desc([9, 7, 5, 3, 1], 6) == -1 assert binary_search_desc([100, 80, 60, 40, 20], 25) == -1 assert binary_search_desc([10, 8, 6, 4, 2, 0], -1) == -1 assert binary_search_desc([15, 14, 12, 11, 10], 8) == -1 def test_binary_search_desc_edge_cases(): assert binary_search_desc([10], 10) == 0 assert binary_search_desc([10], 5) == -1 assert binary_search_desc([], 5) == -1 assert binary_search_desc([5, 4, 3, 2, 1], 3) == 2 def test_binary_search_desc_large_numbers(): assert binary_search_desc([20, 15, 10, 5, 0], 15) == 1 assert binary_search_desc([20, 15, 10, 5, 0], 21) == -1 assert binary_search_desc([1000000000, 500000000, 0, -500000000, -1000000000], -500000000) == 3 def test_binary_search_desc_duplicates(): assert binary_search_desc([10, 10, 10, 10, 10], 10) == 2 assert binary_search_desc([10, 9, 9, 9, 8], 9) == 2","solution":"def binary_search_desc(arr, target): Performs binary search on a list sorted in non-increasing order. :param arr: A list of integers sorted in non-increasing order. :param target: The integer value to search for in the list. :return: The index of the target value if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: right = mid - 1 else: left = mid + 1 return -1"},{"question":"class SpeedTracker: Implements a speed tracking system to record speeds and query minimum and maximum speeds over time intervals. Methods: - record_speed(self, time: int, speed: int) -> None: Records the speed at the specified time. - query_min_speed(self, start_time: int, end_time: int) -> int: Queries and returns the minimum speed within the time interval [start_time, end_time). - query_max_speed(self, start_time: int, end_time: int) -> int: Queries and returns the maximum speed within the time interval [start_time, end_time). def __init__(self) -> None: # Initialize the SpeedTracker with necessary properties pass def record_speed(self, time: int, speed: int) -> None: Record the speed at the specified time. Args: time (int): The timestamp of the recorded speed. speed (int): The speed to be recorded at the given time. pass def query_min_speed(self, start_time: int, end_time: int) -> int: Query the minimum speed within the time interval [start_time, end_time). Args: start_time (int): The beginning of the time interval. end_time (int): The end of the time interval. Returns: int: The minimum speed within the specified interval. pass def query_max_speed(self, start_time: int, end_time: int) -> int: Query the maximum speed within the time interval [start_time, end_time). Args: start_time (int): The beginning of the time interval. end_time (int): The end of the time interval. Returns: int: The maximum speed within the specified interval. pass def test_add_and_query_speed(): tracker = SpeedTracker() # Record speeds at different times tracker.record_speed(1, 60) tracker.record_speed(2, 55) tracker.record_speed(3, 70) tracker.record_speed(4, 50) tracker.record_speed(5, 65) # Test queries assert tracker.query_min_speed(2, 5) == 50 # The least speed between time 2 and 5 should be 50 assert tracker.query_max_speed(1, 4) == 70 # The maximum speed between time 1 and 4 should be 70 def test_record_speeds_unordered(): tracker = SpeedTracker() # Record speeds out of order tracker.record_speed(3, 70) tracker.record_speed(1, 60) tracker.record_speed(5, 65) tracker.record_speed(2, 55) tracker.record_speed(4, 50) # Test queries assert tracker.query_min_speed(2, 5) == 50 # The least speed between time 2 and 5 should be 50 assert tracker.query_max_speed(1, 4) == 70 # The maximum speed between time 1 and 4 should be 70 def test_no_speeds_in_range(): tracker = SpeedTracker() # Record speeds at different times tracker.record_speed(1, 60) tracker.record_speed(3, 70) # Test queries for range with no speeds recorded assert tracker.query_min_speed(4, 5) == float('inf') assert tracker.query_max_speed(4, 5) == float('-inf')","solution":"class SpeedTracker: def __init__(self) -> None: self.speeds = [] def record_speed(self, time: int, speed: int) -> None: self.speeds.append((time, speed)) self.speeds.sort() def query_min_speed(self, start_time: int, end_time: int) -> int: min_speed = float('inf') for time, speed in self.speeds: if start_time <= time < end_time: min_speed = min(min_speed, speed) return min_speed def query_max_speed(self, start_time: int, end_time: int) -> int: max_speed = float('-inf') for time, speed in self.speeds: if start_time <= time < end_time: max_speed = max(max_speed, speed) return max_speed"},{"question":"def normalized_temperature_conversion(temperature: float, from_unit: str) -> float: Convert temperature values from Celsius or Fahrenheit to Kelvin using predefined conversion formulas. Parameters: temperature : float: The numerical value to be converted. from_unit : str: The unit from which the value is to be converted (\\"Celsius\\" or \\"Fahrenheit\\"). Returns: float: Converted temperature value in Kelvin. Raises: ValueError: If \`from_unit\` is not supported. Example: >>> normalized_temperature_conversion(25, \\"Celsius\\") 298.15 >>> normalized_temperature_conversion(77, \\"Fahrenheit\\") 298.15 >>> normalized_temperature_conversion(100, \\"Kelvin\\") ValueError: Invalid 'from_unit' value: 'Kelvin'. Supported units: 'Celsius', 'Fahrenheit'. import pytest from solution import normalized_temperature_conversion def test_celsius_to_kelvin(): assert normalized_temperature_conversion(0, \\"Celsius\\") == 273.15 assert normalized_temperature_conversion(25, \\"Celsius\\") == 298.15 assert normalized_temperature_conversion(-273.15, \\"Celsius\\") == 0.0 def test_fahrenheit_to_kelvin(): assert normalized_temperature_conversion(32, \\"Fahrenheit\\") == 273.15 assert normalized_temperature_conversion(77, \\"Fahrenheit\\") == 298.15 assert normalized_temperature_conversion(-459.67, \\"Fahrenheit\\") == 0.0 def test_invalid_unit(): with pytest.raises(ValueError, match=\\"Invalid 'from_unit' value: 'Kelvin'. Supported units: 'Celsius', 'Fahrenheit'.\\"): normalized_temperature_conversion(100, \\"Kelvin\\") with pytest.raises(ValueError, match=\\"Invalid 'from_unit' value: 'RandomUnit'. Supported units: 'Celsius', 'Fahrenheit'.\\"): normalized_temperature_conversion(100, \\"RandomUnit\\")","solution":"def normalized_temperature_conversion(temperature: float, from_unit: str) -> float: Convert temperature values from Celsius or Fahrenheit to Kelvin using predefined conversion formulas. Parameters: temperature : float: The numerical value to be converted. from_unit : str: The unit from which the value is to be converted (\\"Celsius\\" or \\"Fahrenheit\\"). Returns: float: Converted temperature value in Kelvin. Raises: ValueError: If \`from_unit\` is not supported. if from_unit == \\"Celsius\\": return temperature + 273.15 elif from_unit == \\"Fahrenheit\\": return (temperature - 32) * 5/9 + 273.15 else: raise ValueError(f\\"Invalid 'from_unit' value: '{from_unit}'. Supported units: 'Celsius', 'Fahrenheit'.\\")"},{"question":"class BinaryTreeNode: def __init__(self, value, left_child=None, right_child=None): self.value = value self.left_child = left_child self.right_child = right_child def deepest_left_leaf(root: None | BinaryTreeNode) -> None | int: Given the root of a binary tree, find the deepest left leaf node and return its value. If no such leaf exists, return None. >>> root1 = BinaryTreeNode(1) >>> root1.left_child = BinaryTreeNode(2) >>> root1.right_child = BinaryTreeNode(3) >>> root1.right_child.right_child = BinaryTreeNode(4) >>> root1.right_child.right_child.right_child = BinaryTreeNode(5) >>> deepest_left_leaf(root1) 2 >>> root2 = BinaryTreeNode(1) >>> root2.left_child = BinaryTreeNode(2) >>> root2.left_child.left_child = BinaryTreeNode(3) >>> root2.left_child.left_child.left_child = BinaryTreeNode(4) >>> deepest_left_leaf(root2) 4 >>> deepest_left_leaf(None) None pass def test_deepest_left_leaf(): # Example 1: Should return 2 root1 = BinaryTreeNode(1) root1.left_child = BinaryTreeNode(2) root1.right_child = BinaryTreeNode(3) root1.right_child.right_child = BinaryTreeNode(4) root1.right_child.right_child.right_child = BinaryTreeNode(5) assert deepest_left_leaf(root1) == 2 # Example 2: Should return 4 root2 = BinaryTreeNode(1) root2.left_child = BinaryTreeNode(2) root2.left_child.left_child = BinaryTreeNode(3) root2.left_child.left_child.left_child = BinaryTreeNode(4) assert deepest_left_leaf(root2) == 4 # Example 3: Should return None assert deepest_left_leaf(None) == None # No left leaf: Should return None root3 = BinaryTreeNode(1) root3.right_child = BinaryTreeNode(2) root3.right_child.right_child = BinaryTreeNode(3) assert deepest_left_leaf(root3) == None # More complex tree example: Should return 8 root4 = BinaryTreeNode(1) root4.left_child = BinaryTreeNode(2) root4.right_child = BinaryTreeNode(3) root4.left_child.left_child = BinaryTreeNode(4) root4.left_child.right_child = BinaryTreeNode(5) root4.left_child.left_child.left_child = BinaryTreeNode(7) root4.left_child.left_child.left_child.left_child = BinaryTreeNode(8) # deepest left leaf root4.right_child.right_child = BinaryTreeNode(6) assert deepest_left_leaf(root4) == 8 # Balanced tree example: Should return 4 root5 = BinaryTreeNode(1) root5.left_child = BinaryTreeNode(2) root5.right_child = BinaryTreeNode(3) root5.left_child.left_child = BinaryTreeNode(4) root5.left_child.right_child = BinaryTreeNode(5) root5.right_child.left_child = BinaryTreeNode(6) root5.right_child.right_child = BinaryTreeNode(7) assert deepest_left_leaf(root5) == 4 test_deepest_left_leaf()","solution":"class BinaryTreeNode: def __init__(self, value, left_child=None, right_child=None): self.value = value self.left_child = left_child self.right_child = right_child def deepest_left_leaf(root: None | BinaryTreeNode) -> None | int: if not root: return None def dfs(node, is_left, depth): nonlocal max_depth, deepest_left_leaf_value if not node: return # Check if it's a left leaf node if is_left and not node.left_child and not node.right_child: if depth > max_depth: max_depth = depth deepest_left_leaf_value = node.value # Traverse left and right children dfs(node.left_child, True, depth + 1) dfs(node.right_child, False, depth + 1) max_depth = -1 deepest_left_leaf_value = None dfs(root, False, 0) return deepest_left_leaf_value"},{"question":"def count_primes_in_range(start: int, end: int) -> int: Count the number of prime numbers in a given range of integers. >>> count_primes_in_range(10, 30) 6 >>> count_primes_in_range(24, 28) 0 pass # Unit tests def test_primes_in_small_range(): assert count_primes_in_range(10, 30) == 6 # Prime numbers: 11, 13, 17, 19, 23, 29 def test_primes_with_zero_range(): assert count_primes_in_range(10, 10) == 0 # No prime number in the range def test_primes_with_large_numbers(): assert count_primes_in_range(1000000, 1000020) == 1 # Prime number: 100003 def test_no_primes_in_range(): assert count_primes_in_range(24, 28) == 0 # No primes between 24 and 28 def test_primes_in_single_prime_range(): assert count_primes_in_range(29, 29) == 1 # Single prime number 29 def test_adjacent_primes(): assert count_primes_in_range(17, 19) == 2 # Prime numbers: 17, 19","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes_in_range(start: int, end: int) -> int: count = 0 for num in range(start, end + 1): if is_prime(num): count += 1 return count"},{"question":"from typing import Optional from dataclasses import dataclass @dataclass class ListNode: value: int = 0 next: Optional['ListNode'] = None def reverse_k_group(head: Optional[ListNode], k: int) -> Optional[ListNode]: Reverse the nodes of a linked list in groups of size \`k\`. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> new_head = reverse_k_group(head, 2) >>> # The list should be: 2 -> 1 -> 4 -> 3 -> 5 >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> new_head = reverse_k_group(head, 3) >>> # The list should be: 3 -> 2 -> 1 -> 4 -> 5","solution":"from typing import Optional from dataclasses import dataclass @dataclass class ListNode: value: int = 0 next: Optional['ListNode'] = None def reverse_k_group(head: Optional[ListNode], k: int) -> Optional[ListNode]: def reverse_list(start: ListNode, end: ListNode) -> ListNode: prev, curr = None, start while curr != end: nxt = curr.next curr.next = prev prev = curr curr = nxt return prev dummy = ListNode(0) dummy.next = head group_prev = dummy while True: kth = group_prev for _ in range(k): kth = kth.next if not kth: return dummy.next group_next = kth.next prev = group_prev.next kth.next = None group_prev.next = reverse_list(prev, None) prev.next = group_next group_prev = prev return dummy.next"},{"question":"from typing import List class Library: def __init__(self): Initialize the library with necessary data structures pass def add_book(self, book_id: int, title: str, author: str, genre: str): Adds a new book to the library pass def remove_book(self, book_id: int) -> bool: Removes a book by id >>> library = Library() >>> library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Fiction\\") >>> library.remove_book(1) True >>> library.remove_book(1) False pass def lend_book(self, book_id: int) -> bool: Lends a book by id >>> library = Library() >>> library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Fiction\\") >>> library.lend_book(1) True >>> library.lend_book(1) False pass def return_book(self, book_id: int) -> bool: Returns a book by id >>> library = Library() >>> library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Fiction\\") >>> library.lend_book(1) True >>> library.return_book(1) True >>> library.return_book(1) False pass def get_available_books(self, genre: str) -> List[str]: Returns a list of available books by specified genre >>> library = Library() >>> library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", \\"Fiction\\") >>> library.add_book(2, \\"1984\\", \\"George Orwell\\", \\"Fiction\\") >>> library.get_available_books(\\"Fiction\\") ['The Great Gatsby', '1984'] pass","solution":"class Library: def __init__(self): self.books = {} self.genres = {} def add_book(self, book_id: int, title: str, author: str, genre: str): book_info = { 'title': title, 'author': author, 'genre': genre, 'status': 'available' } self.books[book_id] = book_info if genre not in self.genres: self.genres[genre] = [] self.genres[genre].append(book_id) def remove_book(self, book_id: int) -> bool: if book_id in self.books: book = self.books[book_id] genre = book['genre'] self.genres[genre].remove(book_id) if not self.genres[genre]: del self.genres[genre] del self.books[book_id] return True return False def lend_book(self, book_id: int) -> bool: if book_id in self.books and self.books[book_id]['status'] == 'available': self.books[book_id]['status'] = 'checked out' return True return False def return_book(self, book_id: int) -> bool: if book_id in self.books and self.books[book_id]['status'] == 'checked out': self.books[book_id]['status'] = 'available' return True return False def get_available_books(self, genre: str) -> list: if genre in self.genres: available_books = [self.books[book_id]['title'] for book_id in self.genres[genre] if self.books[book_id]['status'] == 'available'] return available_books return []"},{"question":"Completion Task from typing import List def sort_matrix_rows(matrix: List[List[int]]) -> List[List[int]]: Sort the rows of the matrix in ascending order based on the sum of their elements. return sorted(matrix, key=sum)","solution":"from typing import List def sort_matrix_rows(matrix: List[List[int]]) -> List[List[int]]: Sort the rows of the matrix in ascending order based on the sum of their elements. return sorted(matrix, key=sum)"},{"question":"def sum_prime_factors(n: int) -> int: Returns the sum of all distinct prime factors of n. if not isinstance(n, int): raise TypeError(\\"n must be an integer\\") if n < 2: raise ValueError(\\"n must be greater than or equal to 2\\") def get_prime_factors(num): prime_factors = set() while num % 2 == 0: prime_factors.add(2) num //= 2 factor = 3 while factor * factor <= num: while (num % factor == 0): prime_factors.add(factor) num //= factor factor += 2 if num > 2: prime_factors.add(num) return prime_factors prime_factors = get_prime_factors(n) return sum(prime_factors)","solution":"def sum_prime_factors(n: int) -> int: Returns the sum of all distinct prime factors of n. if not isinstance(n, int): raise TypeError(\\"n must be an integer\\") if n < 2: raise ValueError(\\"n must be greater than or equal to 2\\") def get_prime_factors(num): prime_factors = set() while num % 2 == 0: prime_factors.add(2) num //= 2 factor = 3 while factor * factor <= num: while (num % factor == 0): prime_factors.add(factor) num //= factor factor += 2 if num > 2: prime_factors.add(num) return prime_factors prime_factors = get_prime_factors(n) return sum(prime_factors)"},{"question":"from typing import List, Tuple, Dict def detect_anomalies(logs: List[Tuple[str, float]]) -> Dict[str, float]: Detects the most frequent transaction amount for each distinct hour from the transaction logs. Parameters: logs (List[Tuple[str, float]]): List of transaction logs where each entry is a tuple containing a timestamp and a transaction amount. Returns: Dict[str, float]: Dictionary where keys are hour strings and values are the most frequent transaction amounts for that hour. Example Usage: >>> transaction_logs = [ ... (\\"2023-10-01 08:01:22\\", 125.00), ... (\\"2023-10-01 08:23:45\\", 125.00), ... (\\"2023-10-01 08:45:00\\", 130.00), ... (\\"2023-10-01 09:05:01\\", 200.00), ... (\\"2023-10-01 09:20:56\\", 200.00), ... (\\"2023-10-01 09:45:12\\", 150.00) ... ] >>> detect_anomalies(transaction_logs) {'2023-10-01 08': 125.00, '2023-10-01 09': 200.00}","solution":"from typing import List, Tuple, Dict from collections import defaultdict, Counter def detect_anomalies(logs: List[Tuple[str, float]]) -> Dict[str, float]: Detects the most frequent transaction amount for each distinct hour from the transaction logs. Parameters: logs (List[Tuple[str, float]]): List of transaction logs where each entry is a tuple containing a timestamp and a transaction amount. Returns: Dict[str, float]: Dictionary where keys are hour strings and values are the most frequent transaction amounts for that hour. hour_logs = defaultdict(list) # Group the transaction amounts by hours for timestamp, amount in logs: hour = timestamp[:13] # Extract the \\"YYYY-MM-DD HH\\" part of the timestamp hour_logs[hour].append(amount) # Find the most frequent transaction amount for each hour most_frequent = {} for hour, amounts in hour_logs.items(): amount_frequency = Counter(amounts) most_frequent_amount = amount_frequency.most_common(1)[0][0] most_frequent[hour] = most_frequent_amount return most_frequent"},{"question":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: Merge two sorted lists of integers into a single sorted list. Args: list1 (list[int]): The first sorted list. list2 (list[int]): The second sorted list. Returns: list[int]: A merged and sorted list containing all elements from list1 and list2. Examples: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 2], [2, 2, 3]) [1, 2, 2, 2, 2, 3] >>> merge_sorted_lists([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([4, 5], []) [4, 5] >>> merge_sorted_lists([], []) [] from solution import merge_sorted_lists def test_merge_both_non_empty(): assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] def test_merge_duplicates(): assert merge_sorted_lists([1, 2, 2], [2, 2, 3]) == [1, 2, 2, 2, 2, 3] def test_merge_first_list_empty(): assert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3] def test_merge_second_list_empty(): assert merge_sorted_lists([4, 5], []) == [4, 5] def test_merge_both_empty(): assert merge_sorted_lists([], []) == [] def test_merge_with_negative_numbers(): assert merge_sorted_lists([-3, -1, 2], [-2, 0, 3]) == [-3, -2, -1, 0, 2, 3] def test_merge_identical_elements(): assert merge_sorted_lists([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 1, 1, 1] def test_merge_one_large_list(): assert merge_sorted_lists([1, 5, 9, 10], [2]) == [1, 2, 5, 9, 10] def test_merge_lists_with_single_elements(): assert merge_sorted_lists([1], [2]) == [1, 2] assert merge_sorted_lists([2], [1]) == [1, 2] def test_merge_alternating_order_lists(): assert merge_sorted_lists([1, 3, 5, 7], [2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 7, 8]","solution":"def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]: merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"from typing import List def compress_list(arr: List[int]) -> List[str]: Compress a list of integers using ranges and individual elements. >>> compress_list([1, 2, 3, 6, 7, 8, 10]) ['1-3', '6-8', '10'] >>> compress_list([5, 6, 7, 12, 13, 14, 15, 16]) ['5-7', '12-16'] >>> compress_list([1]) ['1'] >>> compress_list([]) []","solution":"from typing import List def compress_list(arr: List[int]) -> List[str]: if not arr: return [] arr = sorted(set(arr)) # Sort the array and remove duplicates compressed = [] start = arr[0] end = arr[0] for i in range(1, len(arr)): if arr[i] == end + 1: end = arr[i] else: if start == end: compressed.append(str(start)) else: compressed.append(f\\"{start}-{end}\\") start = arr[i] end = arr[i] if start == end: compressed.append(str(start)) else: compressed.append(f\\"{start}-{end}\\") return compressed"},{"question":"from typing import List class Player: def __init__(self, items: List[str]) -> None: Initialize the player with a given starting set of items. :param items: List of starting items for the player ... def add_item(self, item: str) -> None: Add a new unique item to the player's collection. :param item: The item to be added ... def remove_item(self, item: str) -> None: Remove an existing item from the player's collection. :param item: The item to be removed ... def has_item(self, item: str) -> bool: Check whether the player has a specific item. :param item: The item to check :return: True if the player has the item, False otherwise ... def __str__(self) -> str: Return a string representation of the player's collection. :return: Comma-separated list of items in the player's collection ... import pytest def test_initialization(): player = Player([\\"Sword\\", \\"Shield\\", \\"Potion\\"]) assert player.has_item(\\"Sword\\") assert player.has_item(\\"Shield\\") assert player.has_item(\\"Potion\\") assert not player.has_item(\\"Helmet\\") def test_add_item(): player = Player([\\"Sword\\", \\"Shield\\", \\"Potion\\"]) player.add_item(\\"Helmet\\") assert player.has_item(\\"Helmet\\") player.add_item(\\"Sword\\") # Adding a duplicate should not cause an issue assert player.has_item(\\"Sword\\") def test_remove_item(): player = Player([\\"Sword\\", \\"Shield\\", \\"Potion\\"]) player.remove_item(\\"Shield\\") assert not player.has_item(\\"Shield\\") player.remove_item(\\"Bow\\") # Removing a non-existing item should not cause an issue assert not player.has_item(\\"Bow\\") def test_has_item(): player = Player([\\"Sword\\", \\"Shield\\", \\"Potion\\"]) assert player.has_item(\\"Potion\\") assert not player.has_item(\\"Bow\\") def test_str_representation(): player = Player([\\"Sword\\", \\"Shield\\", \\"Potion\\"]) str_repr = str(player) assert str_repr == \\"Sword, Shield, Potion\\" or str_repr == \\"Sword, Potion, Shield\\" or str_repr == \\"Shield, Sword, Potion\\" or str_repr == \\"Shield, Potion, Sword\\" or str_repr == \\"Potion, Sword, Shield\\" or str_repr == \\"Potion, Shield, Sword\\" if __name__ == \\"__main__\\": pytest.main()","solution":"class Player: def __init__(self, items): Initialize the player with a given starting set of items. :param items: List[str] - starting items for the player self.items = set(items) def add_item(self, item): Add a new unique item to the player's collection. :param item: str - the item to add self.items.add(item) def remove_item(self, item): Remove an existing item from the player's collection. :param item: str - the item to remove self.items.discard(item) def has_item(self, item): Check whether the player has a specific item. :param item: str - the item to check :return: bool - True if the player has the item, False otherwise return item in self.items def __str__(self): Return a string representation of the player's collection. :return: str - comma-separated list of items return \\", \\".join(self.items)"},{"question":"def knapsack(values: list[int], weights: list[int], capacity: int) -> int: Determines the maximum value that can be obtained from a collection of items without exceeding the weight limit. :param values: List[int] - A list of values for the items :param weights: List[int] - A list of weights for the items :param capacity: int - Maximum weight capacity of the knapsack :return: int - The maximum value that can be obtained Example usage: >>> knapsack([60, 100, 120], [10, 20, 30], 50) 220 >>> knapsack([], [], 50) 0 >>> knapsack([60, 100, 120], [10, 20, 30], 0) 0","solution":"def knapsack(values, weights, capacity): Determines the maximum value that can be obtained from a collection of items without exceeding the weight limit. :param values: List[int] - A list of values for the items :param weights: List[int] - A list of weights for the items :param capacity: int - Maximum weight capacity of the knapsack :return: int - The maximum value that can be obtained n = len(values) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] <= w: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]"},{"question":"from typing import List def sum_of_unique(nums: List[int]) -> int: Given a list of integers \`nums\`, this function returns the sum of all integers that appear exactly once in the list. >>> sum_of_unique([1, 2, 3, 2, 1]) 3 >>> sum_of_unique([4, 5, 6, 7, 8, 4, 5]) 21 >>> sum_of_unique([]) 0 >>> sum_of_unique([1, 1, 2, 2, 3, 3]) 0 >>> sum_of_unique([1, 2, 3, 4, 5]) 15 >>> sum_of_unique([42]) 42 >>> sum_of_unique([1000000000, -1000000000, 1000000000]) -1000000000 def test_sum_of_unique_example1(): assert sum_of_unique([1, 2, 3, 2, 1]) == 3 def test_sum_of_unique_example2(): assert sum_of_unique([4, 5, 6, 7, 8, 4, 5]) == 21 def test_sum_of_unique_empty(): assert sum_of_unique([]) == 0 def test_sum_of_unique_all_unique(): assert sum_of_unique([1, 2, 3, 4, 5]) == 15 def test_sum_of_unique_all_duplicates(): assert sum_of_unique([1, 1, 2, 2, 3, 3]) == 0 def test_sum_of_unique_mixed(): assert sum_of_unique([1, 2, 2, 3, 3, 4]) == 5 def test_sum_of_unique_single_element(): assert sum_of_unique([42]) == 42 def test_sum_of_unique_large_numbers(): assert sum_of_unique([1000000000, -1000000000, 1000000000]) == -1000000000 def test_sum_of_unique_repeated_large_list(): nums = [1, 2, 3] * 333333 + [4] assert sum_of_unique(nums) == 4","solution":"from typing import List def sum_of_unique(nums: List[int]) -> int: This function returns the sum of all unique integers in the list \`nums\`. An integer is considered unique if it appears exactly once in the list. frequency = {} # First pass: count the frequency of each number for num in nums: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Second pass: sum up only the unique numbers unique_sum = 0 for num, count in frequency.items(): if count == 1: unique_sum += num return unique_sum"},{"question":"def process_file(input_filename: str, output_filename: str, keyword: str) -> int: Processes the lines of a given input file, filtering out lines containing the specified keyword, and writes the filtered lines to an output file. Parameters: input_filename : str : The name of the input file to read. output_filename : str : The name of the output file to write to. keyword : str : The keyword to use for filtering lines. Returns: int : The number of lines written to the output file after filtering. Raises: TypeError: If any of the parameters are not strings. ... # Unit Tests import pytest import os def setup_module(module): with open('test_input.txt', 'w') as f: f.write('hello worldn') f.write('this is a testn') f.write('filter this linen') f.write('another test linen') def teardown_module(module): os.remove('test_input.txt') if os.path.exists('test_output.txt'): os.remove('test_output.txt') def test_process_file_valid_input(): lines_written = process_file('test_input.txt', 'test_output.txt', 'test') assert lines_written == 2 with open('test_output.txt', 'r') as f: lines = f.readlines() assert lines == ['hello worldn', 'filter this linen'] def test_process_file_keyword_not_in_any_line(): lines_written = process_file('test_input.txt', 'test_output.txt', 'not_in_file') assert lines_written == 4 with open('test_output.txt', 'r') as f: lines = f.readlines() assert lines == ['hello worldn', 'this is a testn', 'filter this linen', 'another test linen'] def test_process_file_all_lines_filtered(): lines_written = process_file('test_input.txt', 'test_output.txt', 'line') assert lines_written == 2 with open('test_output.txt', 'r') as f: lines = f.readlines() assert lines == ['hello worldn', 'this is a testn'] def test_process_file_empty_file(): with open('empty_test_input.txt', 'w') as f: pass lines_written = process_file('empty_test_input.txt', 'test_output.txt', 'test') assert lines_written == 0 with open('test_output.txt', 'r') as f: lines = f.readlines() assert lines == [] os.remove('empty_test_input.txt') def test_process_file_invalid_input_types(): with pytest.raises(TypeError): process_file('test_input.txt', 'test_output.txt', 123) with pytest.raises(TypeError): process_file(123, 'test_output.txt', 'test') with pytest.raises(TypeError): process_file('test_input.txt', 123, 'test') def test_process_file_file_not_found(): with pytest.raises(FileNotFoundError): process_file('non_existent_file.txt', 'test_output.txt', 'test')","solution":"def process_file(input_filename: str, output_filename: str, keyword: str) -> int: Processes the lines of a given input file, filtering out lines containing the specified keyword, and writes the filtered lines to an output file. Parameters: - input_filename (str): The name of the input file to read. - output_filename (str): The name of the output file to write to. - keyword (str): The keyword to use for filtering lines. Returns: - int: The number of lines written to the output file after filtering. Raises: - TypeError: If any of the parameters are not strings. # Validate input types if not all(isinstance(arg, str) for arg in [input_filename, output_filename, keyword]): raise TypeError(\\"All parameters must be strings.\\") lines_written = 0 try: with open(input_filename, 'r') as infile, open(output_filename, 'w') as outfile: for line in infile: if keyword not in line: outfile.write(line) lines_written += 1 except FileNotFoundError as e: raise e # Re-raise the FileNotFoundError return lines_written"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder: list[int], inorder: list[int]) -> TreeNode: Construct a binary tree from given preorder and inorder traversals. >>> preorder = [3, 9, 20, 15, 7] >>> inorder = [9, 3, 15, 20, 7] >>> root = buildTree(preorder, inorder) >>> inorderTraversal(root) [9, 3, 15, 20, 7] Example with empty input: >>> preorder = [] >>> inorder = [] >>> root = buildTree(preorder, inorder) >>> root None Example with single element: >>> preorder = [1] >>> inorder = [1] >>> root = buildTree(preorder, inorder) >>> inorderTraversal(root) [1] def inorderTraversal(root): return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else [] def test_buildTree_regular_case(): preorder = [3, 9, 20, 15, 7] inorder = [9, 3, 15, 20, 7] root = buildTree(preorder, inorder) assert inorderTraversal(root) == inorder def test_buildTree_empty_input(): preorder = [] inorder = [] root = buildTree(preorder, inorder) assert root is None def test_buildTree_single_element(): preorder = [1] inorder = [1] root = buildTree(preorder, inorder) assert inorderTraversal(root) == [1] def test_buildTree_unbalanced_tree(): preorder = [1, 2, 3, 4] inorder = [1, 2, 3, 4] root = buildTree(preorder, inorder) assert inorderTraversal(root) == inorder def test_buildTree_complex_tree(): preorder = [1, 2, 4, 5, 3, 6, 7] inorder = [4, 2, 5, 1, 6, 3, 7] root = buildTree(preorder, inorder) assert inorderTraversal(root) == inorder","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def buildTree(preorder: list[int], inorder: list[int]) -> TreeNode: if not preorder or not inorder: return None # Create a map for quick lookup of indices in inorder traversal inorder_index_map = {val: idx for idx, val in enumerate(inorder)} def arrayToTree(left, right): if left > right: return None root_value = preorder.pop(0) root = TreeNode(root_value) root.left = arrayToTree(left, inorder_index_map[root_value] - 1) root.right = arrayToTree(inorder_index_map[root_value] + 1, right) return root return arrayToTree(0, len(inorder) - 1)"},{"question":"from typing import Sequence def max_sales_difference(sales: Sequence[int], start_day: int, end_day: int) -> int: Calculates the maximum difference in sales between any two days within the given range. Args: sales (Sequence[int]): A sequence of integers representing daily sales amounts. start_day (int): The starting index (inclusive) of the range. end_day (int): The ending index (inclusive) of the range. Returns: int: The maximum difference between sales on any two days within the specified range. >>> max_sales_difference([120, 180, 90, 200, 150, 80, 250], 1, 5) 120 >>> max_sales_difference([100, 220, 150, 180, 90], 0, 2) 120 >>> max_sales_difference([50, 60, 70, 80, 90], 2, 4) 20 pass","solution":"from typing import Sequence def max_sales_difference(sales: Sequence[int], start_day: int, end_day: int) -> int: Calculates the maximum difference in sales between any two days within the given range. Args: sales (Sequence[int]): A sequence of integers representing daily sales amounts. start_day (int): The starting index (inclusive) of the range. end_day (int): The ending index (inclusive) of the range. Returns: int: The maximum difference between sales on any two days within the specified range. min_sales = sales[start_day] max_sales = sales[start_day] for i in range(start_day, end_day + 1): if sales[i] < min_sales: min_sales = sales[i] if sales[i] > max_sales: max_sales = sales[i] return max_sales - min_sales"},{"question":"import re from collections import Counter def frequency_dict(input_string: str) -> dict[str, int]: Given a string, returns a dictionary with characters as keys and their respective frequency counts as values. The function is case-insensitive and ignores non-alphabetic characters. >>> frequency_dict(\\"Hello, World!\\") {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> frequency_dict(\\"AaBbCc123...\\") {'a': 2, 'b': 2, 'c': 2} pass def most_frequent_chars(freq_dict: dict[str, int], n: int) -> list[str]: Given a frequency dictionary and an integer n, returns a list of the n most frequent characters in descending order of frequency. Ties are resolved by returning characters in alphabetical order. >>> most_frequent_chars({'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1}, 2) ['l', 'o'] >>> most_frequent_chars({'a': 2, 'b': 2, 'c': 2, 'd': 1}, 3) ['a', 'b', 'c'] pass","solution":"import re from collections import Counter def frequency_dict(input_string: str) -> dict[str, int]: Given a string, returns a dictionary with characters as keys and their respective frequency counts as values. The function is case-insensitive and ignores non-alphabetic characters. input_string = input_string.lower() filtered_string = re.sub('[^a-z]', '', input_string) return dict(Counter(filtered_string)) def most_frequent_chars(freq_dict: dict[str, int], n: int) -> list[str]: Given a frequency dictionary and an integer n, returns a list of the n most frequent characters in descending order of frequency. Ties are resolved by returning characters in alphabetical order. sorted_chars = sorted(freq_dict.items(), key=lambda item: (-item[1], item[0])) return [char for char, freq in sorted_chars[:n]]"},{"question":"from typing import List, Dict def simulate_traffic_light(cycles: int) -> List[Dict[str, str]]: Simulate the traffic light system at a T-junction. :param cycles: number of cycles to simulate :return: a list of dictionaries representing the state of each light every second Each dictionary contains: - \\"time\\": current time in seconds from the start - \\"main_road\\": state of the main road light (\\"red\\", \\"orange\\", \\"green\\") - \\"side_road\\": state of the side road light (\\"red\\", \\"orange\\", \\"green\\") - \\"pedestrian\\": state of the pedestrian light (\\"red\\", \\"green\\") pass # Test cases def test_simulate_traffic_light_single_cycle(): result = simulate_traffic_light(1) assert len(result) == 36 assert result[0]['main_road'] == 'green' assert result[14]['main_road'] == 'green' assert result[15]['main_road'] == 'orange' assert result[17]['main_road'] == 'orange' assert result[18]['main_road'] == 'red' assert result[18]['side_road'] == 'green' assert result[27]['side_road'] == 'green' assert result[28]['side_road'] == 'orange' assert result[30]['side_road'] == 'orange' assert result[31]['side_road'] == 'red' assert result[31]['pedestrian'] == 'green' assert result[35]['pedestrian'] == 'green' def test_simulate_traffic_light_multiple_cycles(): result = simulate_traffic_light(2) assert len(result) == 72 assert result[36]['main_road'] == 'green' assert result[50]['main_road'] == 'green' assert result[51]['main_road'] == 'orange' assert result[53]['main_road'] == 'orange' assert result[54]['main_road'] == 'red' assert result[54]['side_road'] == 'green' assert result[63]['side_road'] == 'green' assert result[64]['side_road'] == 'orange' assert result[66]['side_road'] == 'orange' assert result[67]['side_road'] == 'red' assert result[67]['pedestrian'] == 'green' assert result[71]['pedestrian'] == 'green' def test_simulate_traffic_light_no_cycles(): result = simulate_traffic_light(0) assert len(result) == 0","solution":"from typing import List, Dict def simulate_traffic_light(cycles: int) -> List[Dict[str, str]]: Simulate the traffic light system at a T-junction. :param cycles: number of cycles to simulate :return: a list of dictionaries representing the state of each light every second Each dictionary contains: - \\"time\\": current time in seconds from the start - \\"main_road\\": state of the main road light (\\"red\\", \\"orange\\", \\"green\\") - \\"side_road\\": state of the side road light (\\"red\\", \\"orange\\", \\"green\\") - \\"pedestrian\\": state of the pedestrian light (\\"red\\", \\"green\\") sequence = [ (\\"main_road\\", \\"green\\", 15), (\\"main_road\\", \\"orange\\", 3), (\\"main_road\\", \\"red\\", \\"side_road\\", \\"green\\", 10), (\\"side_road\\", \\"orange\\", 3), (\\"side_road\\", \\"red\\", \\"pedestrian\\", \\"green\\", 5), (\\"pedestrian\\", \\"red\\", 0) # This is just a placeholder to restart the cycle ] state = { \\"main_road\\": \\"red\\", \\"side_road\\": \\"red\\", \\"pedestrian\\": \\"red\\" } events = [] current_time = 0 for _ in range(cycles): for s in sequence: if (len(s) == 3): state[s[0]] = s[1] duration = s[2] for t in range(duration): events.append({ \\"time\\": current_time + t, \\"main_road\\": state[\\"main_road\\"], \\"side_road\\": state[\\"side_road\\"], \\"pedestrian\\": state[\\"pedestrian\\"] }) if current_time + duration < cycles*36: current_time += duration elif(len(s) == 5): state[s[0]] = s[1] state[s[2]] = s[3] duration = s[4] for t in range(duration): events.append({ \\"time\\": current_time + t, \\"main_road\\": state[\\"main_road\\"], \\"side_road\\": state[\\"side_road\\"], \\"pedestrian\\": state[\\"pedestrian\\"] }) if current_time + duration < cycles*36: current_time += duration return events"},{"question":"from typing import List, Tuple def shortest_delivery_routes(num_cities: int, routes: List[Tuple[int, int, int]]) -> List[int]: Calculates the shortest delivery route times from the main warehouse (City 0) to all other cities using Dijkstra's algorithm. Parameters: - num_cities (int): The number of cities in the logistics network. - routes (List[Tuple[int, int, int]]): A list of tuples representing the routes in the network, where each tuple (u, v, w) indicates a direct route from city u to city v with travel time w. Returns: - List[int]: A list where the ith element represents the shortest travel time from City 0 to City i. If a city is not reachable, the travel time should be float('inf').","solution":"from typing import List, Tuple import heapq def shortest_delivery_routes(num_cities: int, routes: List[Tuple[int, int, int]]) -> List[int]: Calculates the shortest delivery route times from the main warehouse (City 0) to all other cities using Dijkstra's algorithm. Parameters: - num_cities (int): The number of cities in the logistics network. - routes (List[Tuple[int, int, int]]): A list of tuples representing the routes in the network, where each tuple (u, v, w) indicates a direct route from city u to city v with travel time w. Returns: - List[int]: A list where the ith element represents the shortest travel time from City 0 to City i. If a city is not reachable, the travel time should be float('inf'). graph = {i: [] for i in range(num_cities)} for u, v, w in routes: graph[u].append((v, w)) distances = {i: float('inf') for i in range(num_cities)} distances[0] = 0 priority_queue = [(0, 0)] # (distance, city) while priority_queue: current_distance, current_city = heapq.heappop(priority_queue) if current_distance > distances[current_city]: continue for neighbor, weight in graph[current_city]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [distances[i] for i in range(num_cities)] return result"},{"question":"def nth_prime(n: int) -> int: Returns the nth prime number >>> nth_prime(1) == 2 >>> nth_prime(10) == 29 >>> nth_prime(100) == 541 >>> nth_prime(500) == 3571 >>> nth_prime(1000) == 7919 # Example test cases def test_nth_prime_first(): assert nth_prime(1) == 2 def test_nth_prime_tenth(): assert nth_prime(10) == 29 def test_nth_prime_hundredth(): assert nth_prime(100) == 541 def test_nth_prime_five_hundredth(): assert nth_prime(500) == 3571 def test_nth_prime_thousandth(): assert nth_prime(1000) == 7919 def test_nth_prime_min_edge(): assert nth_prime(1) == 2 def test_nth_prime_max_edge(): assert nth_prime(1000) == 7919","solution":"def nth_prime(n: int) -> int: Returns the nth prime number. # To ensure optimal performance, we use the Sieve of Eratosthenes algorithm # First, we need an upper bound for the nth prime number. # For simplicity and to avoid repeatedly estimating the bound, we might overshoot and sieve more numbers. # The 1000th prime is less than 10000, we will use that as our bound. limit = 10000 # This is more than enough for our needs sieve = [True] * limit sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers p = 2 while (p * p < limit): if sieve[p] is True: for i in range(p * p, limit, p): sieve[i] = False p += 1 # Collecting primes up to the limit primes = [p for p in range(limit) if sieve[p] is True] return primes[n - 1]"},{"question":"def unique_triplets(nums: list) -> list: Returns a list of all unique triplets in nums where the sum is zero. >>> unique_triplets([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> unique_triplets([0, 1, 1]) [] >>> unique_triplets([0, 0, 0, 0]) [[0, 0, 0]] >>> unique_triplets([1, -1, -1, 0, 2, 1, -1]) [[-1, -1, 2], [-1, 0, 1]]","solution":"def unique_triplets(nums: list) -> list: Returns a list of all unique triplets in nums where the sum is zero. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip duplicates for the first element left, right = nums[i + 1], nums[-1] left_pos, right_pos = i + 1, len(nums) - 1 while left_pos < right_pos: triplet_sum = nums[i] + left + right if triplet_sum == 0: result.append([nums[i], left, right]) while left_pos < right_pos and left == nums[left_pos]: left_pos += 1 # skip duplicates for the second element while left_pos < right_pos and right == nums[right_pos]: right_pos -= 1 # skip duplicates for the third element elif triplet_sum < 0: left_pos += 1 else: right_pos -= 1 left = nums[left_pos] if left_pos < len(nums) else None right = nums[right_pos] if right_pos >= 0 else None return result"},{"question":"def sort_measurements(measurements: list[tuple[str, float]]) -> list[tuple[str, float]]: Sorts the list of radar measurements based on the measurement values in ascending order. If two measurements are identical, sorts them by their identifiers in lexicographic order. Parameters: measurements (list): A list of tuples containing a string identifier and a float value. Returns: list: A sorted list of radar measurements. pass","solution":"def sort_measurements(measurements: list[tuple[str, float]]) -> list[tuple[str, float]]: Sorts the list of radar measurements based on the measurement values in ascending order. If two measurements are identical, sorts them by their identifiers in lexicographic order. Parameters: measurements (list): A list of tuples containing a string identifier and a float value. Returns: list: A sorted list of radar measurements. return sorted(measurements, key=lambda x: (x[1], x[0]))"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in s. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"] >>> longest_palindromic_substring(\\"\\") == \\"\\" >>> longest_palindromic_substring(\\"abcdzdcab\\") == \\"cdzdc\\" pass def word_pattern(pattern: str, s: str) -> bool: Determine if s follows the given word pattern. >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") == True >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") == False >>> word_pattern(\\"aaaa\\", \\"dog dog dog dog\\") == True >>> word_pattern(\\"abba\\", \\"dog dog dog dog\\") == False >>> word_pattern(\\"a\\", \\"dog\\") == True >>> word_pattern(\\"a\\", \\"dog dog\\") == False >>> word_pattern(\\"\\", \\"\\") == True >>> word_pattern(\\"ab\\", \\"\\") == False pass def character_frequency(s: str) -> dict: Return a dictionary with characters as keys and their frequencies as values. >>> character_frequency(\\"hello\\") == {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> character_frequency(\\"aabbcc\\") == {'a': 2, 'b': 2, 'c': 2} >>> character_frequency(\\"\\") == {} >>> character_frequency(\\"a\\") == {'a': 1} >>> character_frequency(\\"abcABC\\") == {'a': 1, 'b': 1, 'c': 1, 'A': 1, 'B': 1, 'C': 1} pass","solution":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring in s. if len(s) == 0: return \\"\\" start, end = 0, 0 for i in range(len(s)): len1 = expand_around_center(s, i, i) len2 = expand_around_center(s, i, i + 1) max_len = max(len1, len2) if max_len > end - start: start = i - (max_len - 1) // 2 end = i + max_len // 2 return s[start:end + 1] def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 def word_pattern(pattern: str, s: str) -> bool: Determine if s follows the given word pattern. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for c, w in zip(pattern, words): if c in char_to_word and char_to_word[c] != w: return False if w in word_to_char and word_to_char[w] != c: return False char_to_word[c] = w word_to_char[w] = c return True def character_frequency(s: str) -> dict: Return a dictionary with characters as keys and their frequencies as values. freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"import heapq class RunningMedian: def __init__(self): Initialize your data structure here. self.max_heap = [] # Max-heap (inverted as a min-heap using negated values) self.min_heap = [] # Min-heap def add_number(self, number: int) -> None: Adds a new number to the data structure. Parameters: number (int): The new number to be added to the stream. pass def get_median(self) -> float: Retrieves the current median of the numbers. Returns: float: The median of the numbers seen so far. pass def test_running_median_basic(): rm = RunningMedian() rm.add_number(1) assert rm.get_median() == 1.0 rm.add_number(2) assert rm.get_median() == 1.5 rm.add_number(3) assert rm.get_median() == 2.0 rm.add_number(4) assert rm.get_median() == 2.5 def test_running_median_with_negative_numbers(): rm = RunningMedian() rm.add_number(-1) assert rm.get_median() == -1.0 rm.add_number(-2) assert rm.get_median() == -1.5 rm.add_number(1) assert rm.get_median() == -1.0 rm.add_number(2) assert rm.get_median() == 0.0 def test_running_median_mixed_numbers(): rm = RunningMedian() rm.add_number(5) rm.add_number(15) rm.add_number(10) rm.add_number(20) rm.add_number(3) assert rm.get_median() == 10.0 rm.add_number(8) assert rm.get_median() == 9.0 def test_large_dataset(): import random random.seed(1) rm = RunningMedian() data = [random.randint(0, 1000) for _ in range(10000)] for i, num in enumerate(data): rm.add_number(num) if i % 1000 == 0: # Check median at some point (these values are examples and should be re-checked based on data) assert 0 <= rm.get_median() <= 1000","solution":"import heapq class RunningMedian: def __init__(self): Initialize two heaps: max_heap for the lower half of the numbers and min_heap for the upper half of the numbers. self.max_heap = [] # Max-heap (inverted as a min-heap using negated values) self.min_heap = [] # Min-heap def add_number(self, number: int) -> None: Adds a new number to the data structure. Parameters: number (int): The new number to be added to the stream. # Add to max heap (invert the value to use as max-heap) heapq.heappush(self.max_heap, -number) # Balancing step to ensure the largest number in max_heap is smaller than the smallest in min_heap if (self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0])): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) # Ensuring the size property: max-heap can at most have one more element than min-heap if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) elif len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def get_median(self) -> float: Retrieves the current median of the numbers. Returns: float: The median of the numbers seen so far. # Depending on the size of the heaps, the median is either the top element of max-heap # or the average of the tops of both heaps in case they have equal size. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"def camel_to_snake(camel_case_sentence: str) -> str: Converts a camelCase sentence into snake_case format. >>> camel_to_snake(\\"thisIsCamelCase\\") == \\"this_is_camel_case\\" >>> camel_to_snake(\\"convertMeToSnakeCase\\") == \\"convert_me_to_snake_case\\" >>> camel_to_snake(\\"simpletest\\") == \\"simpletest\\"","solution":"def camel_to_snake(camel_case_sentence: str) -> str: Converts a camelCase sentence into snake_case format. :param camel_case_sentence: A sentence in camelCase format. :return: The sentence converted to snake_case format. snake_case_sentence = \\"\\" for index, char in enumerate(camel_case_sentence): if char.isupper(): if index != 0: snake_case_sentence += \\"_\\" snake_case_sentence += char.lower() else: snake_case_sentence += char return snake_case_sentence"},{"question":"from collections import deque def bfs(graph, start): Perform a breadth-first search on the graph starting from the start vertex. Arguments: graph -- A dictionary where keys are vertices and values are lists of adjacent vertices. start -- The starting vertex for BFS traversal. Returns: A list of vertices in the order they are visited. >>> graph = { >>> 0: [1, 2], >>> 1: [0, 3, 4], >>> 2: [0, 5], >>> 3: [1], >>> 4: [1, 5], >>> 5: [2, 4] >>> } >>> start_vertex = 0 >>> bfs(graph, start_vertex) == [0, 1, 2, 3, 4, 5] >>> graph = { >>> 0: [] >>> } >>> start_vertex = 0 >>> bfs(graph, start_vertex) == [0] >>> graph = { >>> 0: [1, 2], >>> 1: [0], >>> 2: [0], >>> 3: [4], >>> 4: [3] >>> } >>> start_vertex = 0 >>> bfs(graph, start_vertex) == [0, 1, 2] >>> graph = { >>> 0: [1], >>> 1: [0, 2, 3], >>> 2: [1, 4], >>> 3: [1], >>> 4: [2] >>> } >>> start_vertex = 0 >>> bfs(graph, start_vertex) == [0, 1, 2, 3, 4] >>> graph = { >>> 1: [2, 3], >>> 2: [1, 4], >>> 3: [1, 5], >>> 4: [2], >>> 5: [3] >>> } >>> start_vertex = 1 >>> bfs(graph, start_vertex) == [1, 2, 3, 4, 5]","solution":"from collections import deque def bfs(graph, start): Perform a breadth-first search on the graph starting from the start vertex. Arguments: graph -- A dictionary where keys are vertices and values are lists of adjacent vertices. start -- The starting vertex for BFS traversal. Returns: A list of vertices in the order they are visited. visited = set() queue = deque([start]) order = [] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) order.append(vertex) queue.extend(neighbor for neighbor in graph[vertex] if neighbor not in visited) return order"},{"question":"class FibonacciHeapNode: def __init__(self, key: int): self.key = key self.degree = 0 self.parent = None self.child = None self.left = self self.right = self self.mark = False class FibonacciHeap: def __init__(self): self.min_node = None self.total_nodes = 0 def insert(self, key: int): Inserts a new node with the specified key into the Fibonacci heap. pass def decrease_key(self, node: FibonacciHeapNode, new_key: int): Decreases the key of the specified node to \`new_key\`. Raises ValueError if \`new_key\` is greater than the current key of the node. pass def extract_min(self) -> FibonacciHeapNode: Removes and returns the node with the minimum key from the Fibonacci heap. pass import pytest def test_insert_and_extract_min(): fh = FibonacciHeap() fh.insert(10) fh.insert(4) fh.insert(15) min_node = fh.extract_min() assert min_node.key == 4 def test_decrease_key(): fh = FibonacciHeap() node1 = FibonacciHeapNode(10) fh.insert(5) fh.insert(15) fh._merge_with_root_list(fh.min_node, node1) fh.decrease_key(node1, 1) min_node = fh.extract_min() assert min_node.key == 1 def test_extract_min_empty_heap(): fh = FibonacciHeap() assert fh.extract_min() is None def test_insert_and_multiple_extract_min(): fh = FibonacciHeap() fh.insert(7) fh.insert(3) fh.insert(17) fh.insert(24) assert fh.extract_min().key == 3 assert fh.extract_min().key == 7 assert fh.extract_min().key == 17 assert fh.extract_min().key == 24 def test_decrease_key_and_extract_min(): fh = FibonacciHeap() node1 = FibonacciHeapNode(8) fh.insert(10) fh.insert(2) fh.insert(15) fh._merge_with_root_list(fh.min_node, node1) fh.decrease_key(node1, 1) min_node = fh.extract_min() assert min_node.key == 1","solution":"class FibonacciHeapNode: def __init__(self, key: int): self.key = key self.degree = 0 self.parent = None self.child = None self.left = self self.right = self self.mark = False class FibonacciHeap: def __init__(self): self.min_node = None self.total_nodes = 0 def insert(self, key: int): node = FibonacciHeapNode(key) self.min_node = self._merge_with_root_list(self.min_node, node) self.total_nodes += 1 def decrease_key(self, node: FibonacciHeapNode, new_key: int): if new_key > node.key: raise ValueError(\\"New key is greater than current key.\\") node.key = new_key parent = node.parent if parent and node.key < parent.key: self._cut(node, parent) self._cascading_cut(parent) if node.key < self.min_node.key: self.min_node = node def extract_min(self) -> FibonacciHeapNode: min_node = self.min_node if min_node is not None: if min_node.child is not None: children = [x for x in self._iterate(min_node.child)] for child in children: self._merge_with_root_list(self.min_node, child) child.parent = None self._remove_from_root_list(min_node) if min_node == min_node.right: self.min_node = None else: self.min_node = min_node.right self._consolidate() self.total_nodes -= 1 return min_node def _iterate(self, start): node = start while True: yield node node = node.right if node == start: break def _merge_with_root_list(self, root, node): if root is None: return node if node is None: return root if node.key < root.key: root, node = node, root node.left.right = node.right node.right.left = node.left node.right = root node.left = root.left root.left.right = node root.left = node return root def _remove_from_root_list(self, node): if node.right == node: return node.left.right = node.right node.right.left = node.left def _consolidate(self): A = [None] * self.total_nodes nodes = [x for x in self._iterate(self.min_node)] for node in nodes: d = node.degree while A[d] is not None: y = A[d] if node.key > y.key: node, y = y, node self._link(y, node) A[d] = None d += 1 A[d] = node self.min_node = None for i in range(len(A)): if A[i] is not None: if self.min_node is None: self.min_node = A[i] else: A[i].left.right = A[i].right A[i].right.left = A[i].left A[i].left = self.min_node A[i].right = self.min_node.right self.min_node.right.left = A[i] self.min_node.right = A[i] if A[i].key < self.min_node.key: self.min_node = A[i] def _link(self, y, x): self._remove_from_root_list(y) y.left = y.right = y y.parent = x if x.child is None: x.child = y else: y.right = x.child y.left = x.child.left x.child.left.right = y x.child.left = y x.degree += 1 y.mark = False def _cut(self, x, y): if x.right == x: y.child = None else: x.left.right = x.right x.right.left = x.left if y.child == x: y.child = x.right y.degree -= 1 self._merge_with_root_list(self.min_node, x) x.parent = None x.mark = False def _cascading_cut(self, y): z = y.parent if z is not None: if not y.mark: y.mark = True else: self._cut(y, z) self._cascading_cut(z)"},{"question":"def remove_sublist_elements(target_list: list, sub_list: list) -> list: Removes all elements of sub_list from target_list. Parameters: target_list (list): A list containing any type of elements. sub_list (list): A list containing any type of elements to be removed from target_list. Returns: list: A list with elements of sub_list removed from target_list. Examples: >>> remove_sublist_elements([1, 2, 3, 4, 5], [2, 4]) [1, 3, 5] >>> remove_sublist_elements([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"banana\\"]) [\\"apple\\", \\"cherry\\"] >>> remove_sublist_elements([\\"a\\", \\"b\\", \\"c\\", \\"a\\"], [\\"a\\"]) [\\"b\\", \\"c\\"] >>> remove_sublist_elements([1, 2, 3], []) [1, 2, 3]","solution":"def remove_sublist_elements(target_list, sub_list): Removes all elements of sub_list from target_list. Parameters: target_list (list): A list containing any type of elements. sub_list (list): A list containing any type of elements to be removed from target_list. Returns: list: A list with elements of sub_list removed from target_list. return [item for item in target_list if item not in sub_list]"},{"question":"import numpy as np import random from typing import List, Tuple class Chromosome: def __init__(self, route: List[int]): self.route = route self.fitness = None def evaluate_fitness(self, distance_matrix: np.ndarray) -> float: Evaluate the fitness of the chromosome's route based on the given distance matrix. Args: distance_matrix: 2D numpy array representing distances between cities. Returns: Total distance of the route. ... def crossover(parent1: Chromosome, parent2: Chromosome) -> Tuple[Chromosome, Chromosome]: Perform crossover between two parent chromosomes. Args: parent1: First parent chromosome. parent2: Second parent chromosome. Returns: Two new Chromosome instances representing the offspring. ... def mutate(chromosome: Chromosome, mutation_rate: float): Apply mutation to a chromosome with a given mutation rate. Args: chromosome: Chromosome to mutate. mutation_rate: Probability of mutation per chromosome. ... class GeneticAlgorithm: def __init__(self): self.population = [] self.distance_matrix = None def initialize_population(self, size: int, chromosome_length: int): Initialize the population with a given size and chromosome length. Args: size: Number of chromosomes in the population. chromosome_length: Length of each chromosome. ... def set_distance_matrix(self, distance_matrix: np.ndarray): Set the distance matrix for fitness evaluation. Args: distance_matrix: 2D numpy array representing distances between cities. ... def evolve(self, generations: int, mutation_rate: float, elitism_count: int) -> Tuple[List[int], float]: Evolve the population over a number of generations. Args: generations: Number of generations for evolution. mutation_rate: Probability of mutation per chromosome. elitism_count: Number of top chromosomes to retain for the next generation. Returns: Best route found and its total distance. ... # Example usage D = np.random.rand(10, 10) for i in range(10): D[i, i] = 0 # Distance from a city to itself is zero. ga = GeneticAlgorithm() ga.initialize_population(size=100, chromosome_length=10) ga.set_distance_matrix(D) best_route, best_distance = ga.evolve(generations=500, mutation_rate=0.02, elitism_count=2) print(f'Best Route: {best_route}') print(f'Total Distance: {best_distance}')","solution":"import numpy as np import random class Chromosome: def __init__(self, route): self.route = route self.fitness = None def evaluate_fitness(self, distance_matrix): self.fitness = 0 for i in range(len(self.route) - 1): self.fitness += distance_matrix[self.route[i]][self.route[i + 1]] self.fitness += distance_matrix[self.route[-1]][self.route[0]] # Return to the start return self.fitness def crossover(parent1, parent2): cut = random.randint(1, len(parent1.route) - 2) child1_route = parent1.route[:cut] + [city for city in parent2.route if city not in parent1.route[:cut]] child2_route = parent2.route[:cut] + [city for city in parent1.route if city not in parent2.route[:cut]] return Chromosome(child1_route), Chromosome(child2_route) def mutate(chromosome, mutation_rate): if random.random() < mutation_rate: i, j = random.sample(range(len(chromosome.route)), 2) chromosome.route[i], chromosome.route[j] = chromosome.route[j], chromosome.route[i] class GeneticAlgorithm: def __init__(self): self.population = [] self.distance_matrix = None def initialize_population(self, size, chromosome_length): self.population = [Chromosome(random.sample(range(chromosome_length), chromosome_length)) for _ in range(size)] def set_distance_matrix(self, distance_matrix): self.distance_matrix = distance_matrix def evolve(self, generations, mutation_rate, elitism_count): for generation in range(generations): self.population = sorted(self.population, key=lambda c: c.evaluate_fitness(self.distance_matrix)) new_population = self.population[:elitism_count] # Elitism while len(new_population) < len(self.population): parent1, parent2 = random.sample(self.population[:50], 2) # Random selection from top 50 child1, child2 = crossover(parent1, parent2) mutate(child1, mutation_rate) mutate(child2, mutation_rate) new_population.extend([child1, child2]) self.population = new_population[:len(self.population)] best_chromosome = sorted(self.population, key=lambda c: c.evaluate_fitness(self.distance_matrix))[0] return best_chromosome.route, best_chromosome.fitness"},{"question":"def longest_unique_substring(s: str, k: int) -> int: Find the length of the longest substring with all unique characters that is exactly k characters long. >>> longest_unique_substring(\\"abcabcbb\\", 3) 3 >>> longest_unique_substring(\\"aaaaa\\", 2) -1 >>> longest_unique_substring(\\"abcdef\\", 6) 6 >>> longest_unique_substring(\\"abcdef\\", 7) -1 >>> longest_unique_substring(\\"a\\", 1) 1 >>> longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyz\\" * 1000, 26) 26 >>> longest_unique_substring(\\"abcde\\", 6) -1 >>> longest_unique_substring(\\"abcdefghijklmnoprstuvwxyz\\", 4) 4 >>> longest_unique_substring(\\"abababababab\\", 2) 2","solution":"def longest_unique_substring(s: str, k: int) -> int: if k > len(s): return -1 max_length = -1 n = len(s) for i in range(n - k + 1): substring = s[i:i+k] if len(set(substring)) == k: max_length = k break return max_length"},{"question":"from typing import List, Tuple import re from collections import Counter def word_frequency(text: str) -> List[Tuple[str, int]]: Create a function that takes a string of text and returns a list of tuples. Each tuple contains a word and its frequency from the given text. The words should be returned in lowercase and sorted first by frequency (highest to lowest) and then alphabetically in the case of ties. >>> word_frequency(\\"To be, or not to be, that is the question.\\") == [('be', 2), ('to', 2), ('is', 1), ('not', 1), ('or', 1), ('question', 1), ('that', 1), ('the', 1)] >>> word_frequency(\\"Hello, world! Hello!\\") == [('hello', 2), ('world', 1)] >>> word_frequency(\\"A man, a plan, a canal, Panama.\\") == [('a', 3), ('canal', 1), ('man', 1), ('panama', 1), ('plan', 1)] >>> word_frequency(\\"\\") == []","solution":"from typing import List, Tuple import re from collections import Counter def word_frequency(text: str) -> List[Tuple[str, int]]: # Tokenize the text words = re.findall(r'bw+b', text.lower()) # Count frequency of each word freq = Counter(words) # Sort by frequency and alphabetically sorted_freq = sorted(freq.items(), key=lambda x: (-x[1], x[0])) return sorted_freq"},{"question":"from typing import List def sum_unique_elements(numbers: List[int]) -> int: Computes the sum of all unique elements in a list of integers. >>> sum_unique_elements([1, 2, 2, 3, 4, 5]) 13 >>> sum_unique_elements([4, 5, 6, 7, 4, 7, 8]) 19 >>> sum_unique_elements([10, 20, 20, 10, 30, 40, 50]) 120 >>> sum_unique_elements([1, 1, 1, 1]) 0 >>> sum_unique_elements([7, 8, 9, 10]) 34","solution":"from typing import List def sum_unique_elements(numbers: List[int]) -> int: Returns the sum of all unique elements in a list of integers. # Create a dictionary to store the count of each element count_dict = {} for num in numbers: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 # Calculate the sum of unique elements unique_sum = 0 for num, count in count_dict.items(): if count == 1: unique_sum += num return unique_sum"},{"question":"from typing import List, Callable, Tuple def process_integers( numbers: List[int], factor: int, trans_fn: Callable[[int], int] ) -> Tuple[List[int], int]: Filters integers from the list that are multiples of the given factor, applies a transformation function to the remaining integers, and returns the transformed list along with the count of removed elements. >>> def square(x): ... return x * x >>> result, removed_count = process_integers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, square) >>> print(result, removed_count) [1, 4, 16, 25, 49, 64, 100], 3 pass","solution":"from typing import List, Callable, Tuple def process_integers( numbers: List[int], factor: int, trans_fn: Callable[[int], int] ) -> Tuple[List[int], int]: Filters integers from the list that are multiples of the given factor, applies a transformation function to the remaining integers, and returns the transformed list along with the count of removed elements. filtered_numbers = [num for num in numbers if num % factor != 0] transformed_numbers = [trans_fn(num) for num in filtered_numbers] removed_count = len(numbers) - len(filtered_numbers) return transformed_numbers, removed_count"},{"question":"from dataclasses import dataclass from typing import Optional @dataclass class Node: data: int left: Optional['Node'] = None right: Optional['Node'] = None def max_path_sum(root: Optional[Node]) -> int: Find the maximum path sum in a binary tree. Each node contains an integer value, and path can be from parent to child nodes. Args: root (Node): the root of the binary tree. Returns: int: the maximum path sum. >>> root = Node(data=1, left=Node(data=2), right=Node(data=3)) >>> max_path_sum(root) 6 >>> root = Node(data=-10, left=Node(data=9), right=Node(data=20, left=Node(data=15), right=Node(data=7))) >>> max_path_sum(root) 42 >>> max_path_sum(None) 0 # Example of unit tests def test_max_path_sum(): assert max_path_sum(None) == 0 root = Node(data=5) assert max_path_sum(root) == 5 root = Node(data=1, left=Node(data=2), right=Node(data=3)) assert max_path_sum(root) == 6 root = Node(data=-10, left=Node(data=9), right=Node(data=20, left=Node(data=15), right=Node(data=7))) assert max_path_sum(root) == 42","solution":"from dataclasses import dataclass from typing import Optional @dataclass class Node: data: int left: Optional['Node'] = None right: Optional['Node'] = None def max_path_sum(root: Optional[Node]) -> int: if not root: return 0 def max_gain(node): nonlocal max_sum if not node: return 0 # Max sum on the left and right subtrees, only considering positive gains left_gain = max(max_gain(node.left), 0) right_gain = max(max_gain(node.right), 0) # Price of new path which passes through this node current_path_sum = node.data + left_gain + right_gain # Update max_sum if the current path is better max_sum = max(max_sum, current_path_sum) # For the recursion, return the max gain if continue the same path return node.data + max(left_gain, right_gain) max_sum = float('-inf') max_gain(root) return max_sum"},{"question":"def sort_items_by_quantity(items: dict) -> list: Sorts the items dictionary by their quantities in descending order. If two items have the same quantity, they are sorted alphabetically. Args: items (dict): A dictionary containing item names as keys and their quantities as values. Returns: list: A list of item names sorted by their quantities in descending order. Examples: >>> sort_items_by_quantity({'apples': 5, 'bananas': 3, 'cherries': 5}) ['apples', 'cherries', 'bananas'] >>> sort_items_by_quantity({'apples': 2, 'bananas': 10, 'oranges': 7}) ['bananas', 'oranges', 'apples'] >>> sort_items_by_quantity({'apples': 2, 'bananas': 2, 'cherries': 2}) ['apples', 'bananas', 'cherries'] >>> sort_items_by_quantity({}) []","solution":"def sort_items_by_quantity(items): Sorts the items dictionary by their quantities in descending order. If two items have the same quantity, they are sorted alphabetically. Args: items (dict): A dictionary containing item names as keys and their quantities as values. Returns: list: A list of item names sorted by their quantities in descending order. sorted_items = sorted(items.items(), key=lambda x: (-x[1], x[0])) return [item[0] for item in sorted_items]"},{"question":"def nth_fibonacci(n: int) -> int: Returns the n-th term in the Fibonacci sequence. The Fibonacci sequence is defined as: * F(0) = 0 * F(1) = 1 * F(n) = F(n-1) + F(n-2) for n >= 2 Args: n: A non-negative integer representing the position in the Fibonacci sequence. Returns: An integer representing the n-th term in the Fibonacci sequence. Examples: >>> nth_fibonacci(0) == 0 >>> nth_fibonacci(1) == 1 >>> nth_fibonacci(5) == 5 >>> nth_fibonacci(10) == 55 >>> nth_fibonacci(50) == 12586269025 # Implement function here def test_nth_fibonacci_edge_cases(): assert nth_fibonacci(0) == 0 assert nth_fibonacci(1) == 1 def test_nth_fibonacci_small_numbers(): assert nth_fibonacci(2) == 1 assert nth_fibonacci(3) == 2 assert nth_fibonacci(4) == 3 assert nth_fibonacci(5) == 5 def test_nth_fibonacci_large_number(): assert nth_fibonacci(10) == 55 assert nth_fibonacci(20) == 6765 assert nth_fibonacci(30) == 832040 assert nth_fibonacci(50) == 12586269025 def test_nth_fibonacci_random_cases(): assert nth_fibonacci(6) == 8 assert nth_fibonacci(15) == 610 assert nth_fibonacci(25) == 75025","solution":"def nth_fibonacci(n: int) -> int: Returns the n-th term in the Fibonacci sequence. if n == 0: return 0 if n == 1: return 1 prev, curr = 0, 1 for _ in range(2, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"from typing import List def generate_magic_square(n: int) -> List[List[int]]: Generate an n x n magic square. >>> generate_magic_square(3) [ [8, 1, 6], [3, 5, 7], [4, 9, 2] ] >>> generate_magic_square(5) [ [17, 24, 1, 8, 15], [23, 5, 7, 14, 16], [4, 6, 13, 20, 22], [10, 12, 19, 21, 3], [11, 18, 25, 2, 9] ]","solution":"from typing import List def generate_magic_square(n: int) -> List[List[int]]: if n % 2 == 0: raise ValueError(\\"Only odd lengths are supported by this algorithm.\\") magic_square = [[0] * n for _ in range(n)] num = 1 i, j = 0, n // 2 while num <= n * n: magic_square[i][j] = num num += 1 newi, newj = (i - 1) % n, (j + 1) % n if magic_square[newi][newj]: i += 1 else: i, j = newi, newj return magic_square"},{"question":"import heapq from typing import Dict, Any, Optional def dijkstra_shortest_path(graph: Dict[Any, Dict[Any, int]], start: Any, target: Any) -> Optional[int]: Implements Dijkstra's algorithm to find the shortest path in a graph. Parameters: graph (Dict[Any, Dict[Any, int]]): The weighted graph where key is the node and value is a dictionary of adjacent nodes and their edge weights. start (Any): The starting vertex. target (Any): The target vertex. Returns: Optional[int]: The minimum travel time (sum of edge weights) from the start to the target vertex, or None if no such path exists. >>> graph = { ... 'A': {'B': 1, 'C': 4, 'D': 2}, ... 'B': {'E': 2}, ... 'C': {'E': 1}, ... 'D': {'E': 3}, ... 'E': {} ... } >>> dijkstra_shortest_path(graph, 'A', 'E') 3 >>> dijkstra_shortest_path(graph, 'A', 'C') 4 >>> dijkstra_shortest_path(graph, 'A', 'D') 2 >>> dijkstra_shortest_path(graph, 'E', 'A') None","solution":"import heapq from typing import Dict, Any, Optional def dijkstra_shortest_path(graph: Dict[Any, Dict[Any, int]], start: Any, target: Any) -> Optional[int]: Implements Dijkstra's algorithm to find the shortest path in a graph. Parameters: graph (Dict[Any, Dict[Any, int]]): The weighted graph where key is the node and value is a dictionary of adjacent nodes and their edge weights. start (Any): The starting vertex. target (Any): The target vertex. Returns: Optional[int]: The minimum travel time (sum of edge weights) from the start to the target vertex, or None if no such path exists. # Priority queue for the minimum distance search priority_queue = [(0, start)] # Dictionary to store the minimum distances to each vertex distances = {start: 0} # Set to keep track of visited nodes visited = set() while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the current vertex is the target, return the distance if current_vertex == target: return current_distance if current_vertex in visited: continue visited.add(current_vertex) # Explore neighbors for neighbor, weight in graph[current_vertex].items(): distance = current_distance + weight # If a shorter path to neighbor is found if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return None # If there's no path to the target"},{"question":"from typing import List def merge_sort(nums: List[int]) -> List[int]: Sort the given list of integers in ascending order using the Merge Sort algorithm. >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> merge_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> merge_sort([]) [] >>> merge_sort([0, 0, 0, 0]) [0, 0, 0, 0] >>> merge_sort([-1, -2, -3, -4, -5]) [-5, -4, -3, -2, -1] >>> merge_sort([-5, 0, 5, -10, 10]) [-10, -5, 0, 5, 10]","solution":"from typing import List def merge_sort(nums: List[int]) -> List[int]: if len(nums) <= 1: return nums def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(nums) // 2 left_half = merge_sort(nums[:mid]) right_half = merge_sort(nums[mid:]) return merge(left_half, right_half)"},{"question":"def most_frequent_long_word(text: str, threshold: int) -> str: Identify the most frequent word longer than the given threshold. Parameters: text (str): A string containing a paragraph of text. threshold (int): An integer representing the minimum word length. Returns: str: The most frequent word longer than the given threshold. If multiple words have the highest frequency, return the lexicographically smallest one. If no words exceed the threshold, return an empty string. Examples: >>> most_frequent_long_word(\\"This is a sample paragraph with several words of various lengths\\", 4) 'sample' >>> most_frequent_long_word(\\"We need to identify the most frequent long word\\", 7) 'frequent' >>> most_frequent_long_word(\\"Short words won't count, like the, is, a, an\\", 5) '' pass","solution":"import re from collections import Counter def most_frequent_long_word(text: str, threshold: int) -> str: Identify the most frequent word longer than the given threshold. Parameters: text (str): A string containing a paragraph of text. threshold (int): An integer representing the minimum word length. Returns: str: The most frequent word longer than the given threshold. If multiple words have the highest frequency, return the lexicographically smallest one. If no words exceed the threshold, return an empty string. # Use regular expression to remove punctuation and non-alphanumeric characters text = re.sub(r'[^a-zA-Z0-9s]', '', text).lower() words = text.split() # Filter words that are longer than the threshold filtered_words = [word for word in words if len(word) > threshold] if not filtered_words: return '' # Count the frequency of each word word_counts = Counter(filtered_words) # Find the most frequent word or the lexicographically smallest if there is a tie most_common_word = min(word_counts, key=lambda word: (-word_counts[word], word)) return most_common_word"},{"question":"def configure_display(time_of_day: str, ambient_light: int) -> int: Set the brightness level of an LED display based on time of day and ambient light level. >>> configure_display(\\"21:30\\", 50) 40 >>> configure_display(\\"09:00\\", 50) 60 >>> configure_display(\\"14:45\\", 80) 96 >>> configure_display(\\"03:15\\", 70) 40 >>> configure_display(\\"12:00\\", 90) 100","solution":"def configure_display(time_of_day: str, ambient_light: int) -> int: # Split the time_of_day into hours and minutes hours, minutes = map(int, time_of_day.split(':')) # Check if it's night time (20:00 to 06:59) if (hours >= 20 or hours < 7): # Cap the brightness at 40 during the night return 40 else: # Calculate enhanced brightness with a 20% enhancement enhanced_brightness = int(ambient_light * 1.2) # Clamp the brightness to a maximum of 100 return min(enhanced_brightness, 100)"},{"question":"def clean_spaces(text: str) -> str: Remove extra spaces so that words are separated by only one space, and there are no leading or trailing spaces. >>> clean_spaces(\\" Hello world! \\") 'Hello world!' >>> clean_spaces(\\"Python is great \\") 'Python is great' >>> clean_spaces(\\" Multiple spaces should be reduced.\\") 'Multiple spaces should be reduced.' >>> clean_spaces(\\"SingleWord\\") 'SingleWord' >>> clean_spaces(\\"\\") ''","solution":"def clean_spaces(text: str) -> str: result = [] n = len(text) i = 0 while i < n: # Skip leading spaces while i < n and text[i] == ' ': i += 1 # Collect the word word_start = i while i < n and text[i] != ' ': i += 1 if word_start < i: result.append(text[word_start:i]) # Skip spaces between words while i < n and text[i] == ' ': i += 1 return ' '.join(result)"},{"question":"def find_missing_number(arr: list[int]) -> int: Find the missing number in an array using XOR. You are given an array containing \`n - 1\` unique numbers taken from the range \`0\` to \`n - 1\` (inclusive). This means that exactly one number is missing from the array. Your task is to find and return the missing number using XOR operations. Args: arr (list[int]): A list of integers containing unique numbers from the range \`0\` to \`n - 1\`. Returns: int: The missing number from the array. Examples: >>> find_missing_number([0, 1, 3, 4]) 2 >>> find_missing_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) 0 >>> find_missing_number([0, 2]) 1 >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0]) 1 n = len(arr) + 1 # XOR all numbers from 0 to n-1 including n itself xor_all = 0 for i in range(n): xor_all ^= i # XOR all values in the array xor_arr = 0 for num in arr: xor_arr ^= num # The missing number will be the result of xor_all ^ xor_arr return xor_all ^ xor_arr def test_find_missing_number(): Unit tests for find_missing_number() function # Basic cases assert find_missing_number([0, 1, 3, 4]) == 2 assert find_missing_number([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 0 assert find_missing_number([0, 2]) == 1 assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([0]) == 1 # Additional cases: assert find_missing_number([1, 0, 2, 4]) == 3 assert find_missing_number([0, 1, 2, 3, 5]) == 4 assert find_missing_number([5, 4, 3, 2, 1, 0, 7, 8]) == 6 # Edge cases: assert find_missing_number([1]) == 0 # n = 2 assert find_missing_number([0, 1, 2, 3, 4, 5, 7, 8, 9]) == 6 # Larger range # Large range test large_test_arr = list(range(100000)) large_test_arr.remove(54321) assert find_missing_number(large_test_arr) == 54321","solution":"def find_missing_number(arr: list[int]) -> int: This function takes in an array of integers containing n-1 unique numbers from the range 0 to n-1, and returns the missing number using XOR operations. n = len(arr) + 1 # XOR all numbers from 0 to n-1 including n itself xor_all = 0 for i in range(n): xor_all ^= i # XOR all values in the array xor_arr = 0 for num in arr: xor_arr ^= num # The missing number will be the result of xor_all ^ xor_arr return xor_all ^ xor_arr"},{"question":"def second_largest_integer(s: str) -> int: Returns the second largest unique integer from a comma-separated string of positive integers. >>> second_largest_integer(\\"4,2,9,7,5,6\\") 7 >>> second_largest_integer(\\"1,3,3,5,5,5,8\\") 5 >>> second_largest_integer(\\"3\\") None >>> second_largest_integer(\\"8,8,8,8\\") None >>> second_largest_integer(\\"10,20,10,30,40,40,50\\") 40","solution":"def second_largest_integer(s: str) -> int: Returns the second largest unique integer from a comma-separated string of positive integers. :param s: A string containing positive integers separated by commas. :return: The second largest unique integer in the list or None if there is no second largest integer. # Split the string into a list of integers numbers = list(map(int, s.split(','))) # Remove duplicates by converting to a set and then back to a sorted list unique_numbers = sorted(set(numbers), reverse=True) # Check if there are at least two unique numbers if len(unique_numbers) < 2: return None # Return the second largest unique number return unique_numbers[1]"},{"question":"from typing import List def exist(board: List[List[str]], word: str) -> bool: Determine if the word exists in the 2D grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Args: board (List[List[str]]): 2D grid of characters. word (str): The word to search for in the grid. Returns: bool: True if the word exists in the grid, False otherwise. Examples: >>> exist([ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], 'ABCCED') True >>> exist([ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], 'SEE') True >>> exist([ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], 'ABCB') False pass def test_exist_word_present(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"ABCCED\\" assert exist(board, word) == True def test_exist_word_present_different(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"SEE\\" assert exist(board, word) == True def test_exist_word_not_present(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"ABCB\\" assert exist(board, word) == False def test_exist_word_single_letter(): board = [['A']] word = \\"A\\" assert exist(board, word) == True def test_exist_word_single_letter_not_present(): board = [['A']] word = \\"B\\" assert exist(board, word) == False def test_exist_large_grid(): board = [ ['A','B','C','E'], ['S','F','E','S'], ['A','D','E','E'] ] word = \\"ABCESEEEFS\\" assert exist(board, word) == True","solution":"from typing import List def exist(board: List[List[str]], word: str) -> bool: def dfs(board, word, i, j, k): if k == len(word): # all characters are checked return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False tmp = board[i][j] # store the cell character board[i][j] = \\"#\\" # mark the cell as visited # Check in all four directions found = (dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1)) board[i][j] = tmp # unmark the cell return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"def partition_string(user_string: str, separator: str) -> tuple: Partitions a string into three parts around the first occurrence of a given separator. Parameters: user_string (str): The input string to be partitioned. separator (str): The substring to partition the string around. Returns: tuple: A tuple containing three elements - the part before the separator, the separator itself, and the part after the separator. If the separator is not found, returns the original string and two empty strings. Examples: >>> partition_string(\\"hello_world\\", \\"_\\") ('hello', '_', 'world') >>> partition_string(\\"foo:bar:baz\\", \\":\\") ('foo', ':', 'bar:baz') >>> partition_string(\\"example\\", \\"not_found\\") ('example', '', '') >>> partition_string(\\"start middle end\\", \\" middle \\") ('start', ' middle ', 'end') >>> partition_string(\\"\\", \\"sep\\") ('', '', '')","solution":"def partition_string(user_string: str, separator: str) -> tuple: Partitions a string into three parts around the first occurrence of a given separator. Parameters: user_string (str): The input string to be partitioned. separator (str): The substring to partition the string around. Returns: tuple: A tuple containing three elements - the part before the separator, the separator itself, and the part after the separator. If the separator is not found, returns the original string and two empty strings. # Safety check for empty separator if not separator: return (user_string, '', '') # Find the index of the first occurrence of the separator index = user_string.find(separator) if index == -1: return (user_string, '', '') # Extract the parts before_sep = user_string[:index] after_sep = user_string[index + len(separator):] return (before_sep, separator, after_sep)"},{"question":"import time from typing import Optional, Dict class KeyValueStore: def __init__(self): self.store: Dict[str, Dict[str, int]] = {} def set_key(self, key: str, value: int, ttl: int) -> None: Set a key with a value and a TTL (time-to-live). Args: key: The key to be stored. value: The value to be associated with the specified key. ttl: The time-to-live in seconds from the current time after which the key expires. Raises: ValueError: If the TTL is not a positive integer. Example: set_key(\\"session_1\\", 12345, 10) pass def get_key(self, key: str) -> Optional[int]: Get the value of the key if it has not expired. Args: key: The key to retrieve the value for. Returns: The value associated with the key if it has not expired, otherwise returns None. Example: get_key(\\"session_1\\") # Returns 12345 if it has not expired. pass def cleanup(self) -> None: Remove all expired keys from the store. Example: cleanup() # Manually removes all expired keys. pass import pytest import time @pytest.fixture def kv_store(): return KeyValueStore() def test_set_and_get_key(kv_store): kv_store.set_key(\\"key1\\", 100, 5) assert kv_store.get_key(\\"key1\\") == 100 def test_key_expires(kv_store): kv_store.set_key(\\"key2\\", 200, 2) time.sleep(3) assert kv_store.get_key(\\"key2\\") is None def test_cleanup_removes_expired_keys(kv_store): kv_store.set_key(\\"key3\\", 300, 1) time.sleep(2) kv_store.cleanup() assert kv_store.get_key(\\"key3\\") is None def test_cleanup_does_not_affect_unexpired_keys(kv_store): kv_store.set_key(\\"key4\\", 400, 5) kv_store.set_key(\\"key5\\", 500, 1) time.sleep(3) kv_store.cleanup() assert kv_store.get_key(\\"key4\\") == 400 assert kv_store.get_key(\\"key5\\") is None def test_set_key_with_incorrect_ttl(kv_store): with pytest.raises(ValueError): kv_store.set_key(\\"key6\\", 600, 0) def test_get_unset_key_returns_none(kv_store): assert kv_store.get_key(\\"unknown_key\\") is None","solution":"import time from typing import Optional, Dict class KeyValueStore: def __init__(self): self.store: Dict[str, Dict[str, int]] = {} def set_key(self, key: str, value: int, ttl: int) -> None: if ttl <= 0: raise ValueError(\\"TTL must be a positive integer\\") expiration_time = int(time.time()) + ttl self.store[key] = {'value': value, 'expires_at': expiration_time} def get_key(self, key: str) -> Optional[int]: current_time = int(time.time()) if key in self.store: if self.store[key]['expires_at'] > current_time: return self.store[key]['value'] else: del self.store[key] return None def cleanup(self) -> None: current_time = int(time.time()) keys_to_delete = [key for key, data in self.store.items() if data['expires_at'] <= current_time] for key in keys_to_delete: del self.store[key]"},{"question":"from typing import List def single_number(nums: List[int]) -> int: Finds the integer that appears only once in the array where each other integer appears exactly twice. Args: nums (List[int]): A list of integers where each integer appears exactly twice except for one integer that appears exactly once. Returns: int: The integer that appears only once. >>> single_number([2, 1, 4, 5, 2, 4, 1]) == 5 >>> single_number([1, 2, 3, 4, 3, 2, 1]) == 4 >>> single_number([7, 3, 5, 4, 5, 3, 4]) == 7 >>> single_number([1]) == 1","solution":"from typing import List def single_number(nums: List[int]) -> int: Finds the integer that appears only once in the array where each other integer appears exactly twice. Args: nums (List[int]): A list of integers where each integer appears exactly twice except for one integer that appears exactly once. Returns: int: The integer that appears only once. result = 0 for num in nums: result ^= num return result"},{"question":"from typing import List def length_of_LIS(prices: List[int]) -> int: This function should return the length of the longest increasing subsequence of the given list of stock prices 'prices'. >>> length_of_LIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> length_of_LIS([3, 10, 2, 1, 20]) 3 >>> length_of_LIS([3, 2]) 1 def test_example_cases(): assert length_of_LIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 assert length_of_LIS([3, 10, 2, 1, 20]) == 3 assert length_of_LIS([3, 2]) == 1 def test_single_element(): assert length_of_LIS([10]) == 1 def test_increasing_sequence(): assert length_of_LIS([1, 2, 3, 4, 5]) == 5 def test_decreasing_sequence(): assert length_of_LIS([5, 4, 3, 2, 1]) == 1 def test_mixed_sequence(): assert length_of_LIS([10, 1, 3, 2, 4, 5, 3, 6, 7]) == 6 def test_empty_list(): assert length_of_LIS([]) == 0 def test_duplicate_elements(): assert length_of_LIS([2, 2, 2, 2, 2]) == 1","solution":"from typing import List import bisect def length_of_LIS(prices: List[int]) -> int: This function returns the length of the longest increasing subsequence of the given list of stock prices 'prices'. if not prices: return 0 lis = [] for price in prices: pos = bisect.bisect_left(lis, price) if pos < len(lis): lis[pos] = price else: lis.append(price) return len(lis)"},{"question":"def is_subsequence(s: str, t: str) -> bool: Checks if the string 's' is a subsequence of string 't'. This means that the characters of 's' are present in 't' in the same order, but not necessarily consecutively. Args: s (str): Target sequence to check. t (str): String in which to check for the subsequence. Returns: bool: True if 's' is a subsequence of 't', False otherwise. Examples: >>> is_subsequence(\\"abc\\", \\"aXbYcZ\\") True >>> is_subsequence(\\"AbC\\", \\"aXbYcZ\\") True >>> is_subsequence(\\"abc\\", \\"acb\\") False >>> is_subsequence(\\"ace\\", \\"aabbccaaee\\") True >>> is_subsequence(\\"xyz\\", \\"abcdef\\") False from solution import is_subsequence def test_is_subsequence_case_insensitive(): assert is_subsequence(\\"AbC\\", \\"aXbYcZ\\") def test_is_subsequence_consecutive(): assert is_subsequence(\\"ace\\", \\"aabbccaaee\\") def test_is_subsequence_non_consecutive(): assert is_subsequence(\\"abc\\", \\"aXbYcZ\\") def test_is_subsequence_not_a_subsequence(): assert not is_subsequence(\\"abc\\", \\"acb\\") assert not is_subsequence(\\"xyz\\", \\"abcdef\\") def test_is_subsequence_empty_s(): assert is_subsequence(\\"\\", \\"abcdef\\") def test_is_subsequence_empty_t(): assert not is_subsequence(\\"abc\\", \\"\\") def test_is_subsequence_both_empty(): assert is_subsequence(\\"\\", \\"\\") def test_is_subsequence_s_longer_than_t(): assert not is_subsequence(\\"abcd\\", \\"abc\\")","solution":"def is_subsequence(s: str, t: str) -> bool: Checks if the string 's' is a subsequence of string 't'. This means that the characters of 's' are present in 't' in the same order, but not necessarily consecutively. s = s.lower() t = t.lower() it = iter(t) return all(char in it for char in s)"},{"question":"import numpy as np from typing import List, Tuple def find_largest_determinant(matrix_list: List[np.ndarray]) -> Tuple[np.ndarray, float]: Find the matrix with the largest determinant in the list, and return the matrix along with its determinant value. Parameters: matrix_list (List[np.ndarray]): List of square matrices. Returns: Tuple[np.ndarray, float]: The matrix with the largest determinant and its determinant value. pass # Test cases def test_find_largest_determinant_normal_case(): mat1 = np.array([ [1, 2], [0, 1] ]) mat2 = np.array([ [3, 1], [2, 2] ]) mat3 = np.array([ [1, 0, 0], [4, 1, 0], [7, 8, 1] ]) matrix, determinant = find_largest_determinant([mat1, mat2, mat3]) expected_matrix = mat2 expected_determinant = np.linalg.det(mat2) assert np.array_equal(matrix, expected_matrix) assert determinant == pytest.approx(expected_determinant) def test_find_largest_determinant_single_matrix(): mat = np.array([ [4, 1], [2, 5] ]) matrix, determinant = find_largest_determinant([mat]) expected_matrix = mat expected_determinant = np.linalg.det(mat) assert np.array_equal(matrix, expected_matrix) assert determinant == pytest.approx(expected_determinant) def test_find_largest_determinant_negative_determinant(): mat1 = np.array([ [1, 2], [3, 4] ]) mat2 = np.array([ [-1, -2], [-3, -4] ]) matrix, determinant = find_largest_determinant([mat1, mat2]) expected_matrix = mat1 expected_determinant = np.linalg.det(mat1) assert np.array_equal(matrix, expected_matrix) assert determinant == pytest.approx(expected_determinant) def test_find_largest_determinant_empty_list(): with pytest.raises(ValueError, match=\\"The input list should not be empty.\\"): find_largest_determinant([]) def test_find_largest_determinant_non_square_matrix(): mat1 = np.array([ [1, 2, 3], [4, 5, 6] ]) mat2 = np.array([ [1, 2], [3, 4] ]) with pytest.raises(ValueError, match=\\"All matrices must be square.\\"): find_largest_determinant([mat1, mat2])","solution":"import numpy as np from typing import List, Tuple def find_largest_determinant(matrix_list: List[np.ndarray]) -> Tuple[np.ndarray, float]: Find the matrix with the largest determinant in the list, and return the matrix along with its determinant value. Parameters: matrix_list (List[np.ndarray]): List of square matrices. Returns: Tuple[np.ndarray, float]: The matrix with the largest determinant and its determinant value. if not matrix_list: raise ValueError(\\"The input list should not be empty.\\") for matrix in matrix_list: if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"All matrices must be square.\\") max_determinant = None max_determinant_matrix = None for matrix in matrix_list: determinant = np.linalg.det(matrix) if (max_determinant is None) or (determinant > max_determinant): max_determinant = determinant max_determinant_matrix = matrix return max_determinant_matrix, max_determinant"},{"question":"def manage_stock(items: List[Dict[str, Union[str, int]]], threshold: int) -> List[str]: Manages the stock level of items in the warehouse and returns a list of item names for which the stock level is below the specified threshold. Args: items (list of dicts): A list of dictionaries where each dictionary contains: - 'name' (string): Name of the item. - 'current_stock' (int): The current stock level of the item. threshold (int): The threshold below which a restock notification should be triggered. Returns: list: A list of item names for which the stock level is below the threshold. Raises: ValueError: If any dictionary is missing required keys, or if any value does not meet the constraints. Examples: >>> items_list = [ ... {'name': 'itemA', 'current_stock': 5}, ... {'name': 'itemB', 'current_stock': 3}, ... {'name': 'itemC', 'current_stock': 10}, ... ] >>> manage_stock(items_list, 6) ['itemA', 'itemB'] >>> items_list = [ ... {'name': 'widget', 'current_stock': 13}, ... {'name': 'gadget', 'current_stock': 7}, ... {'name': 'thing', 'current_stock': 4}, ... ] >>> manage_stock(items_list, 5) ['thing'] import pytest def test_manage_stock_below_threshold(): items_list = [ {'name': 'itemA', 'current_stock': 5}, {'name': 'itemB', 'current_stock': 3}, {'name': 'itemC', 'current_stock': 10}, ] assert manage_stock(items_list, 6) == ['itemA', 'itemB'] def test_manage_stock_above_threshold(): items_list = [ {'name': 'itemA', 'current_stock': 15}, {'name': 'itemB', 'current_stock': 13}, {'name': 'itemC', 'current_stock': 20}, ] assert manage_stock(items_list, 10) == [] def test_manage_stock_edge_case_empty_list(): items_list = [] assert manage_stock(items_list, 10) == [] def test_manage_stock_no_below_threshold(): items_list = [ {'name': 'widget', 'current_stock': 13}, {'name': 'gadget', 'current_stock': 7}, {'name': 'thing', 'current_stock': 4}, ] assert manage_stock(items_list, 3) == [] def test_manage_stock_mixed_threshold(): items_list = [ {'name': 'widget', 'current_stock': 13}, {'name': 'gadget', 'current_stock': 7}, {'name': 'thing', 'current_stock': 4}, ] assert manage_stock(items_list, 5) == ['thing'] def test_manage_stock_error_missing_keys(): items_list = [ {'name': 'itemA', 'current_stock': 5}, {'name': 'itemB', 'current_stock': 3}, {'current_stock': 10}, ] with pytest.raises(ValueError): manage_stock(items_list, 6) def test_manage_stock_error_non_positive_threshold(): items_list = [ {'name': 'itemA', 'current_stock': 5}, {'name': 'itemB', 'current_stock': 3}, ] with pytest.raises(ValueError): manage_stock(items_list, -1) def test_manage_stock_error_invalid_stock_values(): items_list = [ {'name': 'itemA', 'current_stock': -5}, {'name': 'itemB', 'current_stock': 3}, ] with pytest.raises(ValueError): manage_stock(items_list, 6) def test_manage_stock_error_non_alpha_name(): items_list = [ {'name': '', 'current_stock': 9}, {'name': 'itemB', 'current_stock': 3}, ] with pytest.raises(ValueError): manage_stock(items_list, 6)","solution":"def manage_stock(items, threshold): Manages the stock level of items in the warehouse and returns a list of item names for which the stock level is below the specified threshold. Args: items (list of dicts): A list of dictionaries where each dictionary contains: - 'name' (string): Name of the item. - 'current_stock' (int): The current stock level of the item. threshold (int): The threshold below which a restock notification should be triggered. Returns: list: A list of item names for which the stock level is below the threshold. Raises: ValueError: If any dictionary is missing required keys, or if any value does not meet the constraints. if not isinstance(threshold, int) or threshold < 0: raise ValueError(\\"Threshold must be a non-negative integer.\\") low_stock_items = [] for item in items: if not all(key in item for key in ('name', 'current_stock')): raise ValueError(\\"Each item must have 'name' and 'current_stock' keys.\\") if not isinstance(item['name'], str) or not item['name']: raise ValueError(\\"Item 'name' must be a non-empty string.\\") if not isinstance(item['current_stock'], int) or item['current_stock'] < 0: raise ValueError(\\"Item 'current_stock' must be a non-negative integer.\\") if item['current_stock'] < threshold: low_stock_items.append(item['name']) return low_stock_items"},{"question":"def calculate_volume(length: float, width: float, height: float) -> float: Calculates the volume of a package given its dimensions. Args: length (float): The length of the package in meters. width (float): The width of the package in meters. height (float): The height of the package in meters. Returns: float: The volume of the package in cubic meters. Raises: ValueError: If any of the dimensions are non-positive. >>> calculate_volume(2.0, 1.5, 0.5) 1.5 >>> calculate_volume(1.0, 1.0, 1.0) 1.0 >>> calculate_volume(2.0, 0, 1.0) # This should raise ValueError Traceback (most recent call last): ... ValueError: Dimensions must be positive values! >>> calculate_volume(-2.0, 1.5, 0.5) # This should raise ValueError Traceback (most recent call last): ... ValueError: Dimensions must be positive values!","solution":"def calculate_volume(length: float, width: float, height: float) -> float: Calculates the volume of a package given its dimensions. Args: length (float): The length of the package in meters. width (float): The width of the package in meters. height (float): The height of the package in meters. Returns: float: The volume of the package in cubic meters. Raises: ValueError: If any of the dimensions are non-positive. # Validate the dimensions if length <= 0 or width <= 0 or height <= 0: raise ValueError(\\"Dimensions must be positive values!\\") # Calculate and return the volume return length * width * height"},{"question":"def max_freq_substring(s: str, k: int) -> int: Returns the maximum frequency of any substring of length k in the given string s. >>> max_freq_substring(\\"ababcababa\\", 3) 3 >>> max_freq_substring(\\"HelloHello\\", 2) 2 >>> max_freq_substring(\\"aabbcc\\", 1) 2","solution":"def max_freq_substring(s, k): Returns the maximum frequency of any substring of length k in the given string s. from collections import Counter # Convert the string to lower case to make it case-insensitive s = s.lower() # Create a counter to count the frequency of each substring of length k counter = Counter(s[i:i+k] for i in range(len(s) - k + 1)) # Return the maximum frequency found return max(counter.values())"},{"question":"def json_flatten(data: dict) -> dict: Flattens a nested JSON object. Args: - data: dict, The JSON object to flatten. Returns: - dict: The flattened JSON object. Examples: >>> json_flatten({ ... \\"a\\": { ... \\"b\\": { ... \\"c\\": 1, ... \\"d\\": [1, 2, 3] ... } ... }, ... \\"e\\": 2 ... }) {'a.b.c': 1, 'a.b.d': [1, 2, 3], 'e': 2} pass def json_expand(data: dict) -> dict: Expands a flattened dictionary back into a nested JSON object. Args: - data: dict, The flattened JSON object. Returns: - dict: The expanded JSON object. Examples: >>> json_expand({ ... 'a.b.c': 1, ... 'a.b.d': [1, 2, 3], ... 'e': 2 ... }) { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": [1, 2, 3] } }, \\"e\\": 2 } pass def test_json_flatten(): nested_json = { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": [1, 2, 3] } }, \\"e\\": 2 } expected_flattened = { 'a.b.c': 1, 'a.b.d': [1, 2, 3], 'e': 2 } assert json_flatten(nested_json) == expected_flattened def test_json_expand(): flattened_json = { 'a.b.c': 1, 'a.b.d': [1, 2, 3], 'e': 2 } expected_expanded = { \\"a\\": { \\"b\\": { \\"c\\": 1, \\"d\\": [1, 2, 3] } }, \\"e\\": 2 } assert json_expand(flattened_json) == expected_expanded def test_json_flatten_and_expand(): nested_json = { \\"x\\": { \\"y\\": { \\"z\\": 5 }, \\"w\\": 3 }, \\"v\\": { \\"u\\": [7, 8, 9] } } flattened_json = json_flatten(nested_json) expanded_json = json_expand(flattened_json) assert expanded_json == nested_json def test_json_flatten_empty(): nested_json = {} expected_flattened = {} assert json_flatten(nested_json) == expected_flattened def test_json_expand_empty(): flattened_json = {} expected_expanded = {} assert json_expand(flattened_json) == expected_expanded","solution":"def json_flatten(data: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested JSON object. Args: - data: dict, the JSON object to flatten. - parent_key: str, the base key (used in recursion). - sep: str, the separator to use between keys. Returns: - dict: the flattened JSON object. items = [] for k, v in data.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(json_flatten(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items) def json_expand(data: dict, sep: str = '.') -> dict: Expands a flattened dictionary back into a nested JSON object. Args: - data: dict, the flattened JSON object. - sep: str, the separator used in keys to denote hierarchy. Returns: - dict: the expanded JSON object. result = {} for k, v in data.items(): keys = k.split(sep) d = result for key in keys[:-1]: if key not in d: d[key] = {} d = d[key] d[keys[-1]] = v return result"},{"question":"def second_largest(nums: list) -> int: Find the second largest element in a list of integers. Args: - nums (list): A list of integers. Returns: - int: The second largest integer in the list. Raises: - ValueError: If the list contains less than two distinct elements. Examples: >>> second_largest([10, 20, 4, 45, 99]) 45 >>> second_largest([3, 1, 4, 4, 5, 5]) 4 >>> second_largest([100, 100, 10, 10]) 10 >>> second_largest([-10, -20, -30, -5, -1]) -5 >>> second_largest([1, 2, 3, 4]) 3 >>> second_largest([1, 3, 5, 5, 4]) 4 pass","solution":"def second_largest(nums: list) -> int: Find the second largest element in a list of integers. Args: - nums (list): A list of integers. Returns: - int: The second largest integer in the list. Raises: - ValueError: If the list contains less than two distinct elements. if len(nums) < 2: raise ValueError(\\"The list must contain at least two distinct elements.\\") first = second = float('-inf') for num in nums: if num > first: second = first first = num elif first > num > second: second = num if second == float('-inf'): raise ValueError(\\"The list must contain at least two distinct elements.\\") return second"},{"question":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Removes duplicates from the list while preserving the order of first occurrences. >>> remove_duplicates([1, 2, 2, 3, 4, 3, 5, 1]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 4, 4, 4, 4]) [4] >>> remove_duplicates([]) []","solution":"from typing import List def remove_duplicates(nums: List[int]) -> List[int]: Removes duplicates from the list while preserving the order of first occurrences. result = [] seen = set() for num in nums: if num not in seen: result.append(num) seen.add(num) return result"},{"question":"def split_string(input_string: str, delimiters: list) -> list: Split the input string based on multiple delimiters. Parameters: - input_string (str): The string to be split. - delimiters (list): A list of delimiter characters to split the string. Returns: - list: A list of substrings obtained by splitting the input string. Example Usage: >>> split_string(\\"hello,world;this:is-a:test\\", [\\",\\", \\";\\", \\":\\", \\"-\\"]) ['hello', 'world', 'this', 'is', 'a', 'test'] >>> split_string(\\"foo:bar-baz,qux\\", [\\":\\", \\"-\\", \\",\\"]) ['foo', 'bar', 'baz', 'qux'] >>> split_string(\\"plainstring\\", [\\",\\", \\":\\", \\"-\\"]) ['plainstring'] >>> split_string(\\"\\", [\\",\\", \\":\\", \\"-\\"]) [] import re def test_split_string_basic(): assert split_string(\\"hello,world;this:is-a:test\\", [\\",\\", \\";\\", \\":\\", \\"-\\"]) == ['hello', 'world', 'this', 'is', 'a', 'test'] assert split_string(\\"foo:bar-baz,qux\\", [\\":\\", \\"-\\", \\",\\"]) == ['foo', 'bar', 'baz', 'qux'] def test_split_string_no_delimiters_in_string(): assert split_string(\\"plainstring\\", [\\",\\", \\":\\", \\"-\\"]) == ['plainstring'] def test_split_string_empty_input_string(): assert split_string(\\"\\", [\\",\\", \\":\\", \\"-\\"]) == [] def test_split_string_single_character_delimiters(): assert split_string(\\"a,b;c:d-e\\", [\\",\\", \\";\\", \\":\\", \\"-\\"]) == ['a', 'b', 'c', 'd', 'e'] def test_split_string_input_validation(): try: split_string(1234, [\\",\\", \\";\\", \\":\\", \\"-\\"]) except ValueError as e: assert str(e) == \\"Input must be a string.\\" try: split_string(\\"hello,world\\", \\"not_a_list\\") except ValueError as e: assert str(e) == \\"Delimiters must be a list of single-character strings.\\" try: split_string(\\"hello,world\\", [\\"multi\\", \\"char\\"]) except ValueError as e: assert str(e) == \\"Delimiters must be a list of single-character strings.\\"","solution":"import re def split_string(input_string: str, delimiters: list) -> list: Split the input string based on multiple delimiters. Parameters: - input_string (str): The string to be split. - delimiters (list): A list of delimiter characters to split the string. Returns: - list: A list of substrings obtained by splitting the input string. Raises: - ValueError: If the input_string is not a string or delimiters is not a list of single-character strings. # Input Validation if not isinstance(input_string, str): raise ValueError(\\"Input must be a string.\\") if not isinstance(delimiters, list) or not all(isinstance(d, str) and len(d) == 1 for d in delimiters): raise ValueError(\\"Delimiters must be a list of single-character strings.\\") # Edge case: empty input string if input_string == \\"\\": return [] # Join the delimiters into a pattern string with regex \\"or\\" (|) operator pattern = '|'.join(map(re.escape, delimiters)) # Split the input string based on the compiled regex pattern return re.split(pattern, input_string)"},{"question":"def compress_string(input_string: str) -> str: Compresses consecutive repeated characters in a string. Args: input_string (str): a string containing any printable ASCII characters, including spaces Returns: str: a compressed string where each sequence of repeated characters is replaced by the count of repetitions followed by the character itself Raises: TypeError: If the input is not a string. Example Usage: >>> compress_string(\\"aaabbccc\\") '3a2b3c' >>> compress_string(\\"abcd\\") 'abcd' >>> compress_string(\\"aaaa\\") '4a' >>> compress_string(\\"aA\\") 'aA' >>> compress_string(123) Traceback (most recent call last): ... TypeError: Expected a string as input pass def test_compress_string(): assert compress_string(\\"aaabbccc\\") == \\"3a2b3c\\" assert compress_string(\\"abcd\\") == \\"abcd\\" assert compress_string(\\"aaaa\\") == \\"4a\\" assert compress_string(\\"aA\\") == \\"aA\\" assert compress_string(\\"abcdabcd\\") == \\"abcdabcd\\" assert compress_string(\\"aabbcc\\") == \\"2a2b2c\\" assert compress_string(\\"aabbaa\\") == \\"2a2b2a\\" def test_compress_string_single_chars(): assert compress_string(\\"a\\") == \\"a\\" assert compress_string(\\"b\\") == \\"b\\" assert compress_string(\\"z\\") == \\"z\\" def test_compress_string_single_repeating_chars(): assert compress_string(\\"aaaa\\") == \\"4a\\" assert compress_string(\\"bb\\") == \\"2b\\" assert compress_string(\\"ccc\\") == \\"3c\\" def test_compress_string_mixed_case(): assert compress_string(\\"aAaA\\") == \\"aAaA\\" assert compress_string(\\"AAAaaa\\") == \\"3A3a\\" def test_compress_string_non_string_input(): try: compress_string(123) except TypeError as e: assert str(e) == \\"Expected a string as input\\" try: compress_string([1, 2, 3]) except TypeError as e: assert str(e) == \\"Expected a string as input\\" try: compress_string(None) except TypeError as e: assert str(e) == \\"Expected a string as input\\"","solution":"def compress_string(input_string: str) -> str: if not isinstance(input_string, str): raise TypeError(\\"Expected a string as input\\") compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: if count > 1: compressed.append(f\\"{count}{input_string[i - 1]}\\") else: compressed.append(input_string[i - 1]) count = 1 if count > 1: compressed.append(f\\"{count}{input_string[-1]}\\") else: compressed.append(input_string[-1]) return ''.join(compressed)"},{"question":"class StudentRecords: A command-line interface (CLI) tool to manage student records. Each student has a unique ID, a name, and a dictionary of course grades. Commands: - add_student <ID> <name>: Adds a new student with the given ID and name. - remove_student <ID>: Removes the student with the given ID. - update_grade <ID> <course> <grade>: Updates the grade for the given course of the student with the given ID. - query_student <ID>: Prints the details (ID, name, and all courses with grades) of the student with the given ID. def __init__(self): self.records = {} def add_student(self, student_id, name): Adds a new student with the given ID and name. pass def remove_student(self, student_id): Removes the student with the given ID. pass def update_grade(self, student_id, course, grade): Updates the grade for the given course of the student with the given ID. pass def query_student(self, student_id): Prints the details (ID, name, and all courses with grades) of the student with the given ID. pass # Unit Tests def test_add_student(): sr = StudentRecords() assert sr.add_student(1, \\"Alice\\") == \\"Student 1 added: Alice\\" assert sr.add_student(1, \\"Bob\\") == \\"Student with ID 1 already exists.\\" def test_remove_student(): sr = StudentRecords() sr.add_student(1, \\"Alice\\") assert sr.remove_student(1) == \\"Student 1 removed\\" assert sr.remove_student(1) == \\"Student with ID 1 not found.\\" def test_update_grade(): sr = StudentRecords() sr.add_student(1, \\"Alice\\") assert sr.update_grade(1, \\"Math\\", 95) == \\"Updated grade for student 1: Math = 95\\" assert sr.update_grade(2, \\"Science\\", 85) == \\"Student with ID 2 not found.\\" def test_query_student(): sr = StudentRecords() sr.add_student(1, \\"Alice\\") sr.update_grade(1, \\"Math\\", 95) assert sr.query_student(1) == \\"ID: 1, Name: Alice, Grades: {'Math': 95}\\" assert sr.query_student(2) == \\"Student with ID 2 not found.\\" def test_add_and_remove_student(): sr = StudentRecords() assert sr.add_student(3, \\"Charlie\\") == \\"Student 3 added: Charlie\\" assert sr.remove_student(3) == \\"Student 3 removed\\" assert sr.query_student(3) == \\"Student with ID 3 not found.\\"","solution":"class StudentRecords: def __init__(self): self.records = {} def add_student(self, student_id, name): if student_id in self.records: return f\\"Student with ID {student_id} already exists.\\" self.records[student_id] = {\\"name\\": name, \\"grades\\": {}} return f\\"Student {student_id} added: {name}\\" def remove_student(self, student_id): if student_id not in self.records: return f\\"Student with ID {student_id} not found.\\" del self.records[student_id] return f\\"Student {student_id} removed\\" def update_grade(self, student_id, course, grade): if student_id not in self.records: return f\\"Student with ID {student_id} not found.\\" self.records[student_id][\\"grades\\"][course] = grade return f\\"Updated grade for student {student_id}: {course} = {grade}\\" def query_student(self, student_id): if student_id not in self.records: return f\\"Student with ID {student_id} not found.\\" student = self.records[student_id] return f\\"ID: {student_id}, Name: {student['name']}, Grades: {student['grades']}\\" # Example usage: # sr = StudentRecords() # print(sr.add_student(1, \\"Alice\\")) # print(sr.add_student(2, \\"Bob\\")) # print(sr.update_grade(1, \\"Math\\", 95)) # print(sr.query_student(1)) # print(sr.remove_student(1)) # print(sr.query_student(1))"},{"question":"def is_even_digit_sum_greater(number: int, threshold: int) -> bool: Returns True if the sum of all even digits in the number is greater than the threshold, False otherwise. >>> is_even_digit_sum_greater(2468, 10) True >>> is_even_digit_sum_greater(1357, 5) False >>> is_even_digit_sum_greater(4802, 10) True def test_even_digit_sum_greater_case1(): assert is_even_digit_sum_greater(2468, 10) == True def test_even_digit_sum_greater_case2(): assert is_even_digit_sum_greater(1357, 5) == False def test_even_digit_sum_greater_case3(): assert is_even_digit_sum_greater(4802, 10) == True def test_even_digit_sum_greater_edge_case_zero(): assert is_even_digit_sum_greater(0, 0) == False def test_even_digit_sum_greater_large_number(): assert is_even_digit_sum_greater(123456789012345678, 20) == True def test_even_digit_sum_greater_threshold_zero(): assert is_even_digit_sum_greater(2468, 0) == True def test_even_digit_sum_greater_no_even_digits(): assert is_even_digit_sum_greater(13579, 0) == False def test_even_digit_sum_greater_type_error_number(): try: is_even_digit_sum_greater(\\"1234\\", 10) except TypeError: assert True else: assert False def test_even_digit_sum_greater_type_error_threshold(): try: is_even_digit_sum_greater(1234, \\"10\\") except TypeError: assert True else: assert False","solution":"def is_even_digit_sum_greater(number: int, threshold: int) -> bool: Returns True if the sum of all even digits in the number is greater than the threshold, False otherwise. if not isinstance(number, int) or not isinstance(threshold, int): raise TypeError(\\"Both inputs must be integers\\") even_sum = 0 for digit in str(number): if int(digit) % 2 == 0: even_sum += int(digit) return even_sum > threshold"},{"question":"def insufficient_power_supply(power: float, energy: float, time: float) -> dict: This function computes the missing value among power, energy, and time using the formula P = E / t, where: - power (P) is in kilowatts (kW) - energy (E) is in kilowatt-hours (kWh) - time (t) is in hours (h) Exactly one of the arguments must be zero since that will be the value to compute. If more than one, or none, of the arguments are zero, the function raises a ValueError. Args: power (float): Power in kilowatts (kW) (set to zero if unknown). energy (float): Energy consumption in kilowatt-hours (kWh) (set to zero if unknown). time (float): Time period in hours (h) (set to zero if unknown). Returns: dict: A dictionary containing the name of the computed value and its result. Raises: ValueError: If more than one or none of the arguments are zero, or if any non-zero argument is negative. # Implement the function following the described behavior and constraints. # Unit tests import pytest def test_calculate_power(): result = insufficient_power_supply(power=0, energy=50, time=10) assert result == {'power': 5.0} def test_calculate_energy(): result = insufficient_power_supply(power=2, energy=0, time=4) assert result == {'energy': 8.0} def test_calculate_time(): result = insufficient_power_supply(power=2.5, energy=7.5, time=0) assert result == {'time': 3.0} def test_error_more_than_one_zero_argument(): with pytest.raises(ValueError, match=\\"One and only one argument must be 0\\"): insufficient_power_supply(power=0, energy=0, time=5) def test_error_no_zero_argument(): with pytest.raises(ValueError, match=\\"One and only one argument must be 0\\"): insufficient_power_supply(power=3, energy=4, time=5) def test_error_negative_energy(): with pytest.raises(ValueError, match=\\"Energy consumption can not be negative\\"): insufficient_power_supply(power=3, energy=-7, time=2) def test_error_negative_time(): with pytest.raises(ValueError, match=\\"Time period can not be negative\\"): insufficient_power_supply(power=3, energy=7, time=-2) def test_error_negative_power(): with pytest.raises(ValueError, match=\\"Power can not be negative\\"): insufficient_power_supply(power=-3, energy=7, time=2)","solution":"def insufficient_power_supply(power, energy, time): This function computes the missing value among power, energy, and time using the formula P = E / t, where: - power (P) is in kilowatts (kW) - energy (E) is in kilowatt-hours (kWh) - time (t) is in hours (h) Exactly one of the arguments must be zero, since that will be the value to compute. If more than one, or none, of the arguments are zero, the function raises a ValueError. Args: power (float): Power in kilowatts (kW) (set to zero if unknown). energy (float): Energy consumption in kilowatt-hours (kWh) (set to zero if unknown). time (float): Time period in hours (h) (set to zero if unknown). Returns: dict: A dictionary containing the name of the computed value and its result. Raises: ValueError: If more than one or none of the arguments are zero, or if any non-zero argument is negative. # Check if all values are valid if any([val < 0 for val in [power, energy, time]]): if power < 0: raise ValueError(\\"Power can not be negative\\") if energy < 0: raise ValueError(\\"Energy consumption can not be negative\\") if time < 0: raise ValueError(\\"Time period can not be negative\\") # Check the number of zeros zero_count = sum([1 for val in [power, energy, time] if val == 0]) if zero_count != 1: raise ValueError(\\"One and only one argument must be 0\\") # Calculate the missing value if power == 0: power = energy / time return {'power': power} elif energy == 0: energy = power * time return {'energy': energy} elif time == 0: time = energy / power return {'time': time}"},{"question":"import math def is_triangular_number(n: int) -> bool: Checks if a number is a triangular number. >>> is_triangular_number(6) == True >>> is_triangular_number(10) == True >>> is_triangular_number(7) == False >>> is_triangular_number(4) == False pass def nearest_triangular_number(n: int) -> int: Finds the nearest triangular number to the given number. >>> nearest_triangular_number(8) == 10 >>> nearest_triangular_number(14) == 15 >>> nearest_triangular_number(6) == 6 >>> nearest_triangular_number(0) == 0 pass","solution":"import math def is_triangular_number(n: int) -> bool: Checks if a number is a triangular number. if n <= 0: return False # Calculate the determinant of the quadratic equation x^2 + x - 2n = 0 determinant = 1 + 8 * n sqrt_determinant = int(math.isqrt(determinant)) # for precision in integer arithmetic if sqrt_determinant * sqrt_determinant != determinant: return False # Check if the computed root is an integer k = (-1 + sqrt_determinant) / 2 return k == int(k) def nearest_triangular_number(n: int) -> int: Finds the nearest triangular number to the given number. if n <= 0: return 0 # No positive triangular numbers for non-positive input k = int(math.isqrt(2 * n)) # Start from approximate root of the equation lower = k * (k + 1) // 2 upper = (k + 1) * (k + 2) // 2 if abs(n - lower) <= abs(n - upper): return lower else: return upper"},{"question":"def calculate_portfolio(transactions: list[str]) -> dict[str, int]: Calculates the final holdings of each stock based on a list of transactions. Args: transactions (list of str): List of transaction strings in the format \\"{action} {quantity} {ticker_symbol}\\". Returns: dict: Dictionary where keys are ticker symbols and values are the net number of shares owned. Examples: >>> calculate_portfolio([\\"BUY 50 MSFT\\", \\"SELL 20 MSFT\\", \\"BUY 30 GOOGL\\", \\"BUY 10 MSFT\\", \\"SELL 5 GOOGL\\"]) {\\"MSFT\\": 40, \\"GOOGL\\": 25} >>> calculate_portfolio([\\"BUY 50 AAPL\\", \\"SELL 20 AAPL\\", \\"BUY 100 TSLA\\", \\"SELL 10 TSLA\\"]) {\\"AAPL\\": 30, \\"TSLA\\": 90} >>> calculate_portfolio([\\"BUY 10 AAPL\\"]) {\\"AAPL\\": 10} >>> calculate_portfolio([]) {} from solution import calculate_portfolio def test_single_transaction(): assert calculate_portfolio([\\"BUY 10 AAPL\\"]) == {\\"AAPL\\": 10} def test_multiple_transactions_single_stock(): transactions = [\\"BUY 50 AAPL\\", \\"SELL 20 AAPL\\", \\"BUY 30 AAPL\\"] assert calculate_portfolio(transactions) == {\\"AAPL\\": 60} def test_multiple_transactions_multiple_stocks(): transactions = [\\"BUY 50 AAPL\\", \\"SELL 20 AAPL\\", \\"BUY 100 TSLA\\", \\"SELL 10 TSLA\\"] assert calculate_portfolio(transactions) == {\\"AAPL\\": 30, \\"TSLA\\": 90} def test_zero_stock_after_transactions(): transactions = [\\"BUY 50 AAPL\\", \\"SELL 50 AAPL\\"] assert calculate_portfolio(transactions) == {\\"AAPL\\": 0} def test_empty_transactions_list(): assert calculate_portfolio([]) == {} def test_no_sell_transactions(): transactions = [\\"BUY 50 AAPL\\", \\"BUY 20 TSLA\\"] assert calculate_portfolio(transactions) == {\\"AAPL\\": 50, \\"TSLA\\": 20} def test_no_buy_transactions(): transactions = [\\"SELL 50 AAPL\\", \\"SELL 20 TSLA\\"] assert calculate_portfolio(transactions) == {\\"AAPL\\": -50, \\"TSLA\\": -20} def test_edge_case_large_transactions(): transactions = [\\"BUY 1000000000 AAPL\\", \\"SELL 999999999 AAPL\\"] assert calculate_portfolio(transactions) == {\\"AAPL\\": 1}","solution":"def calculate_portfolio(transactions): Calculates the final holdings of each stock based on a list of transactions. Args: transactions (list of str): List of transaction strings in the format \\"{action} {quantity} {ticker_symbol}\\". Returns: dict: Dictionary where keys are ticker symbols and values are the net number of shares owned. portfolio = {} for transaction in transactions: action, quantity, ticker_symbol = transaction.split() quantity = int(quantity) if ticker_symbol not in portfolio: portfolio[ticker_symbol] = 0 if action == \\"BUY\\": portfolio[ticker_symbol] += quantity elif action == \\"SELL\\": portfolio[ticker_symbol] -= quantity return portfolio"},{"question":"def split_message(message: str, packet_size: int) -> list[str]: Splits a message into packets of a fixed size, except possibly the last packet. Parameters: - message: str: The original message to be split into packets - packet_size: int: The fixed size of each packet Returns: - list[str]: A list of packets each containing a portion of the original message >>> split_message(\\"HelloWorld\\", 4) ['Hell', 'oWor', 'ld'] >>> split_message(\\"abcdefgh\\", 4) ['abcd', 'efgh'] >>> split_message(\\"a\\", 2) ['a'] >>> split_message(\\"abc\\", 5) ['abc'] >>> split_message(\\"\\", 3) [] pass def reassemble_message(packets: list[str]) -> str: Reassembles the original message from the provided list of packets. Parameters: - packets: list[str]: The list of packets to be combined Returns: - str: The reassembled original message >>> reassemble_message(['Hell', 'oWor', 'ld']) 'HelloWorld' >>> reassemble_message(['abcd', 'efgh']) 'abcdefgh' >>> reassemble_message(['a']) 'a' >>> reassemble_message(['abc']) 'abc' >>> reassemble_message([]) '' pass # Unit tests def test_split_message(): assert split_message(\\"HelloWorld\\", 4) == [\\"Hell\\", \\"oWor\\", \\"ld\\"] assert split_message(\\"abcdefgh\\", 4) == [\\"abcd\\", \\"efgh\\"] assert split_message(\\"a\\", 2) == [\\"a\\"] assert split_message(\\"abc\\", 5) == [\\"abc\\"] assert split_message(\\"\\", 3) == [] def test_reassemble_message(): assert reassemble_message([\\"Hell\\", \\"oWor\\", \\"ld\\"]) == \\"HelloWorld\\" assert reassemble_message([\\"abcd\\", \\"efgh\\"]) == \\"abcdefgh\\" assert reassemble_message([\\"a\\"]) == \\"a\\" assert reassemble_message([\\"abc\\"]) == \\"abc\\" assert reassemble_message([]) == \\"\\" def test_combined(): message = \\"Thisisaverylongmessagethatneedstobesplitintoseveralpacketsofdata\\" packet_size = 10 packets = split_message(message, packet_size) reassembled_message = reassemble_message(packets) assert reassembled_message == message message = \\"ShortMessage\\" packet_size = 4 packets = split_message(message, packet_size) reassembled_message = reassemble_message(packets) assert reassembled_message == message def test_edge_cases(): message = \\"abcdefghij\\" packet_size = 3 packets = split_message(message, packet_size) assert packets == ['abc', 'def', 'ghi', 'j'] assert reassemble_message(packets) == message message = \\"abcdefghijk\\" packet_size = 5 packets = split_message(message, packet_size) assert packets == ['abcde', 'fghij', 'k'] assert reassemble_message(packets) == message","solution":"def split_message(message: str, packet_size: int) -> list[str]: Splits a message into packets of a fixed size, except possibly the last packet. Parameters: - message: str: The original message to be split into packets - packet_size: int: The fixed size of each packet Returns: - list[str]: A list of packets each containing a portion of the original message return [message[i:i + packet_size] for i in range(0, len(message), packet_size)] def reassemble_message(packets: list[str]) -> str: Reassembles the original message from the provided list of packets. Parameters: - packets: list[str]: The list of packets to be combined Returns: - str: The reassembled original message return ''.join(packets)"},{"question":"def max_non_overlapping_sessions(sessions: list[tuple[int, int]]) -> int: Returns the maximum number of non-overlapping sessions that can be attended. Args: sessions (list of tuples): A list of tuples where each tuple contains two integers representing the start and end times of a session. Returns: int: The maximum number of non-overlapping sessions that can be attended. >>> max_non_overlapping_sessions([(900, 1030), (1000, 1130), (1100, 1200), (1230, 1300)]) 3 >>> max_non_overlapping_sessions([(100, 200), (150, 250), (300, 400), (350, 450)]) 2 >>> max_non_overlapping_sessions([(100, 200), (250, 350), (150, 300), (300, 400)]) 2 >>> max_non_overlapping_sessions([(900, 1100), (1100, 1230), (1000, 1300), (1230, 1400)]) 3 >>> max_non_overlapping_sessions([(1000, 1200)]) 1 >>> max_non_overlapping_sessions([]) 0","solution":"def max_non_overlapping_sessions(sessions): Returns the maximum number of non-overlapping sessions that can be attended. Args: sessions (list of tuples): A list of tuples where each tuple contains two integers representing the start and end times of a session. Returns: int: The maximum number of non-overlapping sessions that can be attended. # Sort sessions based on their end times sorted_sessions = sorted(sessions, key=lambda x: x[1]) count = 0 last_end_time = 0 for session in sorted_sessions: if session[0] >= last_end_time: count += 1 last_end_time = session[1] return count"},{"question":"def rotate_array(arr: List[int], k: int) -> List[int]: Rotates an array to the right by k steps. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([], 2) [] n = len(arr) if n == 0: return arr k = k % n return arr[-k:] + arr[:-k] def reverse_array(arr: List[int]) -> List[int]: Reverses an array. >>> reverse_array([1, 2, 3, 4]) [4, 3, 2, 1] >>> reverse_array([1]) [1] >>> reverse_array([]) [] return arr[::-1] def find_max_subarray(arr: List[int]) -> int: Finds the maximum sum of any contiguous subarray. >>> find_max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> find_max_subarray([1, 2, 3, 4, 5]) 15 >>> find_max_subarray([-1, -2, -3, -4]) -1 max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def rotate_string(s: str, k: int) -> str: Rotates a string to the right by k steps. >>> rotate_string(\\"abcdef\\", 2) \\"efabcd\\" >>> rotate_string(\\"abcdef\\", 6) \\"abcdef\\" >>> rotate_string(\\"abcdef\\", 0) \\"abcdef\\" >>> rotate_string(\\"\\", 2) \\"\\" n = len(s) if n == 0: return s k = k % n return s[-k:] + s[:-k] def is_substring(s1: str, s2: str) -> bool: Checks if s2 is a substring of s1. >>> is_substring(\\"hello world\\", \\"world\\") True >>> is_substring(\\"hello world\\", \\"worlds\\") False >>> is_substring(\\"abc\\", \\"\\") True >>> is_substring(\\"\\", \\"a\\") False return s2 in s1","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates an array to the right by k steps. n = len(arr) if n == 0: return arr k = k % n return arr[-k:] + arr[:-k] def reverse_array(arr: List[int]) -> List[int]: Reverses the elements of the array. return arr[::-1] def find_max_subarray(arr: List[int]) -> int: Finds the maximum sum of any contiguous subarray. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def rotate_string(s: str, k: int) -> str: Rotates a string to the right by k steps. n = len(s) if n == 0: return s k = k % n return s[-k:] + s[:-k] def is_substring(s1: str, s2: str) -> bool: Checks if s2 is a substring of s1. return s2 in s1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: Mirrors the binary tree rooted at \`root\`. Args: root (TreeNode): The root node of the binary tree. Returns: TreeNode: The root node of the mirrored binary tree. >>> a = TreeNode(1) >>> b = TreeNode(2) >>> c = TreeNode(3) >>> a.left = b >>> a.right = c >>> mirrored_root = mirror_tree(a) >>> mirrored_root.val 1 >>> mirrored_root.left.val 3 >>> mirrored_root.right.val 2 pass def test_mirror_tree_single_node(): root = TreeNode(1) mirrored_root = mirror_tree(root) assert mirrored_root.val == 1 assert mirrored_root.left is None assert mirrored_root.right is None def test_mirror_tree_two_level_tree(): # Original Tree: # 1 # / # 2 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) # Mirrored Tree: # 1 # / # 3 2 mirrored_root = mirror_tree(root) assert mirrored_root.val == 1 assert mirrored_root.left.val == 3 assert mirrored_root.right.val == 2 assert mirrored_root.left.left is None assert mirrored_root.left.right is None assert mirrored_root.right.left is None assert mirrored_root.right.right is None def test_mirror_tree_complex_tree(): # Original Tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # Mirrored Tree: # 1 # / # 3 2 # / # 5 4 mirrored_root = mirror_tree(root) assert mirrored_root.val == 1 assert mirrored_root.left.val == 3 assert mirrored_root.right.val == 2 assert mirrored_root.right.left.val == 5 assert mirrored_root.right.right.val == 4 assert mirrored_root.left.left is None assert mirrored_root.left.right is None def test_mirror_tree_empty(): assert mirror_tree(None) is None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mirror_tree(root: TreeNode) -> TreeNode: Mirrors the binary tree rooted at \`root\`. Args: root (TreeNode): The root node of the binary tree. Returns: TreeNode: The root node of the mirrored binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively mirror the subtrees mirror_tree(root.left) mirror_tree(root.right) return root"},{"question":"from typing import List class PalindromePartition: Implement a class \`PalindromePartition\` that includes methods to: 1. Partition a given string into all possible sets of palindromic substrings. 2. Count the minimum number of cuts required to partition the string into palindromic substrings. >>> palindrome_partition = PalindromePartition() >>> palindrome_partition.all_partitions(\\"aab\\") [['a', 'a', 'b'], ['aa', 'b']] >>> palindrome_partition.min_cuts(\\"aab\\") 1 >>> palindrome_partition.all_partitions(\\"abba\\") [['a', 'b', 'b', 'a'], ['a', 'bb', 'a'], ['abba']] >>> palindrome_partition.min_cuts(\\"abba\\") 0 def all_partitions(self, text: str) -> List[List[str]]: pass def min_cuts(self, text: str) -> int: pass","solution":"from typing import List class PalindromePartition: def all_partitions(self, text: str) -> List[List[str]]: res = [] self._partition_helper(text, 0, [], res) return res def _partition_helper(self, text: str, start: int, path: List[str], res: List[List[str]]): if start == len(text): res.append(path) return for end in range(start + 1, len(text) + 1): if self._is_palindrome(text, start, end - 1): # end is non-inclusive so end - 1 is inclusive self._partition_helper(text, end, path + [text[start:end]], res) def _is_palindrome(self, text: str, left: int, right: int) -> bool: while left < right: if text[left] != text[right]: return False left += 1 right -= 1 return True def min_cuts(self, text: str) -> int: n = len(text) dp = [0] * n pal = [[False] * n for _ in range(n)] for i in range(n): min_cut = i for j in range(i + 1): if text[j] == text[i] and (i - j <= 1 or pal[j + 1][i - 1]): pal[j][i] = True min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut return dp[-1]"},{"question":"from typing import List def sort_strings(str_list: List[str]) -> List[str]: Return a new list of strings where each string is sorted such that all numerical characters appear before the alphabetical characters, and within the numerical and alphabetical sections, characters are in the same relative order as they appeared in the original string. >>> sort_strings(['a1b2c']) ['12abc'] >>> sort_strings(['3d4e5f']) ['345def']","solution":"from typing import List def sort_strings(str_list: List[str]) -> List[str]: sorted_list = [] for s in str_list: numbers = ''.join([ch for ch in s if ch.isdigit()]) letters = ''.join([ch for ch in s if ch.isalpha()]) sorted_list.append(numbers + letters) return sorted_list"},{"question":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given square matrix by 90 degrees clockwise. Args: matrix (List[List[int]]): The input square matrix. Returns: List[List[int]]: The matrix rotated by 90 degrees clockwise. Examples: >>> rotate_matrix_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) [[-7, -4, -1], [-8, -5, -2], [-9, -6, -3]]","solution":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given square matrix by 90 degrees clockwise. Args: matrix (List[List[int]]): The input square matrix. Returns: List[List[int]]: The matrix rotated by 90 degrees clockwise. n = len(matrix) rotated = [] for col in range(n): new_row = [] for row in range(n-1, -1, -1): new_row.append(matrix[row][col]) rotated.append(new_row) return rotated"},{"question":"def convert(s: str, numRows: int) -> str: Convert a string into a zigzag pattern on a given number of rows. >>> convert(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" >>> convert(\\"A\\", 1) \\"A\\" >>> convert(\\"HELLO\\", 1) \\"HELLO\\" >>> convert(\\"ABCDE\\", 2) \\"ACEBD\\" >>> convert(\\"ABCDEFGHI\\", 9) \\"ABCDEFGHI\\" >>> convert(\\"ABC\\", 5) \\"ABC\\" >>> convert(\\"ZIGZAG\\", 10) \\"ZIGZAG\\"","solution":"def convert(s: str, numRows: int) -> str: if numRows == 1 or numRows >= len(s): return s # Create an array of strings for all rows rows = [''] * numRows current_row = 0 direction = -1 # -1 means moving up, 1 means moving down for char in s: rows[current_row] += char # Change direction if at the top or bottom row if current_row == 0 or current_row == numRows - 1: direction *= -1 current_row += direction # Concatenate all the rows to form the final string result = ''.join(rows) return result"},{"question":"def pairwise_product_sum(A: list) -> int: This function calculates the sum of products of all unique pairs in the given list of non-negative integers. Args: A (list): A list of non-negative integers. Returns: int: The sum of the products of all unique pairs in the list. Example: >>> pairwise_product_sum([1, 2, 3, 4]) 35 >>> pairwise_product_sum([0, 0, 0, 0]) 0 >>> pairwise_product_sum([1, 1, 1, 1]) 6 >>> pairwise_product_sum([2, 3, 5]) 31 >>> pairwise_product_sum([1000, 2000, 3000]) 11000000","solution":"def pairwise_product_sum(A: list) -> int: This function calculates the sum of products of all unique pairs in the given list of non-negative integers. Args: A (list): A list of non-negative integers. Returns: int: The sum of the products of all unique pairs in the list. total_sum = 0 n = len(A) for i in range(n): for j in range(i + 1, n): total_sum += A[i] * A[j] return total_sum"},{"question":"Implement an Efficient Version of QuickSelect The QuickSelect algorithm is used to find the k-th smallest element in an unordered list. Although effective, its performance can be improved by optimizing the partitioning step and mitigating poor pivot choices. Hint: A median of medians or random pivot selection can improve performance. def efficient_quickselect(arr: list, k: int) -> int: Efficient QuickSelect implementation. :param arr: Unordered input list :param k: 1-based index of the k-th smallest element to find :return: The k-th smallest element in the list, or None if out of bounds Examples: >>> efficient_quickselect([3, 1, 5, 2, 4], 3) 3 >>> efficient_quickselect([10, 4, 5, 8, 6, 11, 26], 5) 10 >>> efficient_quickselect([2, 6, 10, 15], 1) 2 >>> efficient_quickselect([2, 6, 10, 15], 5) None import random def partition(arr, low, high): pivot_index = random.randint(low, high) pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = partition(arr, low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) if not arr or k < 1 or k > len(arr): return None return quickselect(arr, 0, len(arr) - 1, k - 1) if __name__ == \\"__main__\\": assert efficient_quickselect([7, 10, 4, 3, 20, 15], 3) == 7 assert efficient_quickselect([7, 10, 4, 3, 20, 15], 4) == 10 assert efficient_quickselect([3, 2, 1, 5, 6, 4], 2) == 2 assert efficient_quickselect([3, 2, 1, 5, 6, 4], 7) == None","solution":"import random def partition(arr, low, high): pivot_index = random.randint(low, high) pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = partition(arr, low, high) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, low, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, high, k) def efficient_quickselect(arr, k): if not arr or k < 1 or k > len(arr): return None return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"from typing import List, Tuple def get_top_frequent_words(novel_text: str, stopwords: List[str], top_n: int) -> List[Tuple[str, int]]: Identify the top N most frequent words in a given novel text excluding common stopwords. Args: - novel_text (str): The text of the novel to be processed. - stopwords (list[str]): A list of common stopwords to exclude from the count. - top_n (int): The number of top frequent words to return. Returns: - list[tuple[str, int]]: A list of tuples, each containing a word and its count. pass # Example test cases def test_get_top_frequent_words(): novel_text = \\"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness.\\" stopwords = [\\"was\\", \\"the\\", \\"of\\", \\"it\\"] top_n = 3 expected = [(\\"times\\", 2), (\\"age\\", 2), (\\"best\\", 1)] assert get_top_frequent_words(novel_text, stopwords, top_n) == expected def test_get_top_frequent_words_with_punctuation(): novel_text = \\"Hello, world! Hello, Universe! Hello, everyone.\\" stopwords = [\\"hello\\"] top_n = 2 expected = [(\\"world\\", 1), (\\"universe\\", 1)] assert get_top_frequent_words(novel_text, stopwords, top_n) == expected def test_get_top_frequent_words_case_insensitivity(): novel_text = \\"Hello hello HELLO\\" stopwords = [\\"hello\\"] top_n = 1 expected = [] assert get_top_frequent_words(novel_text, stopwords, top_n) == expected def test_get_top_frequent_words_empty_novel_text(): novel_text = \\"\\" stopwords = [\\"empty\\"] top_n = 1 expected = [] assert get_top_frequent_words(novel_text, stopwords, top_n) == expected def test_get_top_frequent_words_all_stopwords(): novel_text = \\"stopword test stopword example stopword\\" stopwords = [\\"stopword\\", \\"test\\", \\"example\\"] top_n = 2 expected = [] assert get_top_frequent_words(novel_text, stopwords, top_n) == expected def test_get_top_frequent_words_more_top_n_than_unique_words(): novel_text = \\"unique words in this sentence words\\" stopwords = [\\"in\\"] top_n = 10 expected = [(\\"words\\", 2), (\\"unique\\", 1), (\\"this\\", 1), (\\"sentence\\", 1)] assert get_top_frequent_words(novel_text, stopwords, top_n) == expected","solution":"import re from collections import Counter from typing import List, Tuple def get_top_frequent_words(novel_text: str, stopwords: List[str], top_n: int) -> List[Tuple[str, int]]: Identify the top N most frequent words in a given novel text excluding common stopwords. Args: - novel_text (str): The text of the novel to be processed. - stopwords (list[str]): A list of common stopwords to exclude from the count. - top_n (int): The number of top frequent words to return. Returns: - list[tuple[str, int]]: A list of tuples, each containing a word and its count. # Convert to lowercase novel_text = novel_text.lower() # Remove punctuation and tokenize the text into words words = re.findall(r'bw+b', novel_text) # Filter out stopwords filtered_words = [word for word in words if word not in stopwords] # Count the frequency of each word word_counts = Counter(filtered_words) # Get the top N most common words top_frequent_words = word_counts.most_common(top_n) return top_frequent_words"},{"question":"import numpy as np def generate_circular_matrix(n: int) -> np.ndarray: Generate a square matrix of given dimension with elements arranged in a clockwise spiral pattern. >>> generate_circular_matrix(3) array([[1, 2, 3], [8, 9, 4], [7, 6, 5]]) >>> generate_circular_matrix(4) array([[ 1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]) >>> generate_circular_matrix(1) array([[1]]) >>> generate_circular_matrix(2) array([[1, 2], [4, 3]]) >>> generate_circular_matrix(5) array([[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]])","solution":"import numpy as np def generate_circular_matrix(n: int) -> np.ndarray: matrix = np.zeros((n, n), dtype=int) top, bottom, left, right = 0, n - 1, 0, n - 1 num = 1 while top <= bottom and left <= right: # Traverse from left to right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Traverse from bottom to top for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"from PIL import Image, ImageFilter, ImageOps import os class ImageProcessor: An interactive ImageProcessor application that allows users to load images, apply various filters, and save the processed images. The application supports common image processing functions such as grayscale conversion, edge detection, and applying blur filters. Methods: - load_image(file_path: str) -> None: Loads an image from the disk. - apply_grayscale() -> None: Applies a grayscale filter to the loaded image and stores the result. - apply_edge_detection() -> None: Applies an edge detection filter to the loaded image and stores the result. - apply_blur(blur_radius: int) -> None: Applies a blur filter with the specified radius to the loaded image and stores the result. - save_image(save_path: str) -> None: Saves the processed image to the specified path. Example: >>> processor = ImageProcessor() >>> processor.load_image(\\"path/to/input/image.jpg\\") >>> processor.apply_grayscale() >>> processor.save_image(\\"path/to/output/grayscale_image.jpg\\") >>> processor.apply_edge_detection() >>> processor.save_image(\\"path/to/output/edge_image.jpg\\") >>> processor.apply_blur(5) >>> processor.save_image(\\"path/to/output/blur_image.jpg\\") def __init__(self): self.original_image = None self.processed_image = None def load_image(self, file_path: str) -> None: Loads an image from the disk. pass def apply_grayscale(self) -> None: Applies a grayscale filter to the loaded image and stores the result. pass def apply_edge_detection(self) -> None: Applies an edge detection filter to the loaded image and stores the result. pass def apply_blur(self, blur_radius: int) -> None: Applies a blur filter with the specified radius to the loaded image and stores the result. pass def save_image(self, save_path: str) -> None: Saves the processed image to the specified path. pass","solution":"from PIL import Image, ImageFilter, ImageOps import os class ImageProcessor: def __init__(self): self.original_image = None self.processed_image = None def load_image(self, file_path: str) -> None: if not os.path.isfile(file_path): raise ValueError(\\"File does not exist\\") if not file_path.lower().endswith(('.jpg', '.jpeg', '.png')): raise ValueError(\\"Unsupported file format\\") self.original_image = Image.open(file_path) self.processed_image = self.original_image.copy() def apply_grayscale(self) -> None: if self.processed_image is None: raise ValueError(\\"No image loaded\\") self.processed_image = ImageOps.grayscale(self.processed_image) def apply_edge_detection(self) -> None: if self.processed_image is None: raise ValueError(\\"No image loaded\\") self.processed_image = self.processed_image.filter(ImageFilter.FIND_EDGES) def apply_blur(self, blur_radius: int) -> None: if self.processed_image is None: raise ValueError(\\"No image loaded\\") if not isinstance(blur_radius, int) or blur_radius <= 0 or blur_radius > 50: raise ValueError(\\"Blur radius must be an integer between 1 and 50\\") self.processed_image = self.processed_image.filter(ImageFilter.GaussianBlur(blur_radius)) def save_image(self, save_path: str) -> None: if self.processed_image is None: raise ValueError(\\"No image has been processed\\") if not save_path.lower().endswith(('.jpg', '.jpeg', '.png')): raise ValueError(\\"Unsupported file format\\") self.processed_image.save(save_path)"},{"question":"def needleman_wunsch(seq1: str, seq2: str) -> int: Computes the optimal alignment score between two DNA sequences using the Needleman-Wunsch algorithm. Parameters: seq1 (str): The first DNA sequence. seq2 (str): The second DNA sequence. Returns: int: The optimal alignment score between the two sequences. >>> needleman_wunsch(\\"ACGT\\", \\"ACGT\\") 4 >>> needleman_wunsch(\\"AAAA\\", \\"TTTT\\") -4 >>> needleman_wunsch(\\"ACGT\\", \\"AAGT\\") 2 >>> needleman_wunsch(\\"GATTACA\\", \\"GCATGCU\\") 0 >>> needleman_wunsch(\\"TTAGGG\\", \\"TAGG\\") 2 >>> needleman_wunsch(\\"\\", \\"ACGT\\") -4 >>> needleman_wunsch(\\"ACGT\\", \\"\\") -4 >>> needleman_wunsch(\\"\\", \\"\\") 0","solution":"def needleman_wunsch(seq1: str, seq2: str) -> int: Computes the optimal alignment score between two DNA sequences using the Needleman-Wunsch algorithm. Parameters: seq1 (str): The first DNA sequence. seq2 (str): The second DNA sequence. Returns: int: The optimal alignment score between the two sequences. n = len(seq1) m = len(seq2) # Initialize the scoring matrix with zeros score_matrix = [[0 for _ in range(m+1)] for _ in range(n+1)] # Fill the first row and first column with gap penalties for i in range(1, n+1): score_matrix[i][0] = score_matrix[i-1][0] - 1 for j in range(1, m+1): score_matrix[0][j] = score_matrix[0][j-1] - 1 # Fill in the rest of the score matrix for i in range(1, n+1): for j in range(1, m+1): match = score_matrix[i-1][j-1] + (1 if seq1[i-1] == seq2[j-1] else -1) delete = score_matrix[i-1][j] - 1 insert = score_matrix[i][j-1] - 1 score_matrix[i][j] = max(match, delete, insert) # The optimal alignment score is in the bottom-right cell of the matrix return score_matrix[n][m]"},{"question":"from typing import List def optimized_sort_nearly_sorted(arr: List[int], k: int) -> List[int]: Sorts a nearly sorted array where each element is at most k positions away from its target position. Args: arr (List[int]): The nearly sorted array. k (int): The maximum distance any element is from its sorted position. Returns: List[int]: A sorted list of integers. pass # Example Test Cases def test_nearly_sorted(): assert optimized_sort_nearly_sorted([3, 1, 2, 5, 4, 6], 2) == [1, 2, 3, 4, 5, 6] def test_empty_array(): assert optimized_sort_nearly_sorted([], 2) == [] def test_single_element_array(): assert optimized_sort_nearly_sorted([1], 2) == [1] def test_sorted_array(): assert optimized_sort_nearly_sorted([1, 2, 3, 4, 5], 1) == [1, 2, 3, 4, 5] def test_reverse_sorted_array(): assert optimized_sort_nearly_sorted([5, 4, 3, 2, 1], 4) == [1, 2, 3, 4, 5] def test_large_k_value(): assert optimized_sort_nearly_sorted([6, 5, 3, 2, 8, 10, 9], 3) == [2, 3, 5, 6, 8, 9, 10] def test_k_zero(): assert optimized_sort_nearly_sorted([1, 2, 3, 4, 5], 0) == [1, 2, 3, 4, 5] def test_duplicate_elements(): assert optimized_sort_nearly_sorted([3, 3, 2, 1, 2, 5], 3) == [1, 2, 2, 3, 3, 5]","solution":"import heapq from typing import List def optimized_sort_nearly_sorted(arr: List[int], k: int) -> List[int]: Sorts a nearly sorted array where each element is at most k positions away from its target position. Args: arr (List[int]): The nearly sorted array. k (int): The maximum distance any element is from its sorted position. Returns: List[int]: A sorted list of integers. if not arr: return [] # Initialize a min heap with the first k+1 elements min_heap = arr[:k+1] heapq.heapify(min_heap) sorted_array = [] for i in range(k+1, len(arr)): # Extract the smallest element from the heap and add it to the result list smallest = heapq.heappop(min_heap) sorted_array.append(smallest) # Add the next element from the array to the heap heapq.heappush(min_heap, arr[i]) # Extract the remaining elements in the heap and add them to the result list while min_heap: sorted_array.append(heapq.heappop(min_heap)) return sorted_array"},{"question":"class WordCounter: A Word Counter class that can count the number of specific words in a list of strings, and provide the most common words encountered so far. Methods: add_word(word: str): Adds a word to the counter. If the word already exists, increments its count. most_common(n: int) -> List[str]: Returns the \`n\` most common words added so far, sorted by their frequency in descending order. If two words have the same frequency, they should be sorted lexicographically. count(word: str) -> int: Returns the count of the specified word. If the word does not exist in the counter, returns 0. >>> word_counter = WordCounter() >>> word_counter.add_word(\\"apple\\") >>> word_counter.add_word(\\"banana\\") >>> word_counter.add_word(\\"apple\\") >>> word_counter.add_word(\\"cherry\\") >>> word_counter.add_word(\\"banana\\") >>> word_counter.add_word(\\"banana\\") >>> word_counter.count(\\"banana\\") 3 >>> word_counter.count(\\"apple\\") 2 >>> word_counter.count(\\"cherry\\") 1 >>> word_counter.count(\\"date\\") 0 >>> word_counter.most_common(2) [\\"banana\\", \\"apple\\"] >>> word_counter.most_common(1) [\\"banana\\"] >>> word_counter.most_common(3) [\\"banana\\", \\"apple\\", \\"cherry\\"] def __init__(self): pass def add_word(self, word: str): pass def most_common(self, n: int) -> List[str]: pass def count(self, word: str) -> int: pass","solution":"from collections import defaultdict class WordCounter: def __init__(self): self.word_count = defaultdict(int) def add_word(self, word: str): self.word_count[word] += 1 def most_common(self, n: int): sorted_words = sorted(self.word_count.items(), key=lambda item: (-item[1], item[0])) return [word for word, count in sorted_words[:n]] def count(self, word: str): return self.word_count[word]"},{"question":"# Task: Implementation of a Basic Calculator In this exercise, you are required to implement a basic calculator that can evaluate simple arithmetic expressions. The calculator should handle addition, subtraction, multiplication, and division. Function to Implement 1. **calculate(expression: str) -> float**: * Input: A string (\`expression\`) consisting of a valid arithmetic expression. The expression may include integers, floating-point numbers, and the operators \`+\`, \`-\`, \`*\`, and \`/\`. * Output: The result of the arithmetic expression as a float. Constraints: - The input expression will always be non-empty and a valid arithmetic expression. - The expression will not have any spaces. - Division by zero should be handled gracefully, returning \`float('inf')\` in such cases. - The input expression might contain numbers like \`3\`, \`3.14\`, \`23.05\` or \`-15.3\`. - The order of operations must be respected (i.e., multiplication and division take precedence over addition and subtraction). Example: assert calculate(\\"3+2\\") == 5.0 assert calculate(\\"3-2.5\\") == 0.5 assert calculate(\\"3*4\\") == 12.0 assert calculate(\\"10/2\\") == 5.0 assert calculate(\\"3+2*2\\") == 7.0 assert calculate(\\"10/0\\") == float('inf') assert calculate(\\"-5+2\\") == -3.0 assert calculate(\\"3.14*2\\") == 6.28 Notes: - Implement the function without using the \`eval\` function for security reasons. - You may use the \`re\` library for parsing the expression into tokens. Ensure your function handles edge cases such as: 1. Mixed integer and floating-point operations. 2. Negative numbers. 3. Division by zero. 4. Proper order of operations. Note: - Your implementation must be efficient and capable of evaluating arbitrarily long expressions within reasonable limits.","solution":"import re def calculate(expression: str) -> float: def tokenize(expression: str): tokens = re.findall(r'd+(?:.d+)?|[-+*/()]', expression) return tokens def parse(tokens): def next_token(): return tokens.pop(0) def parse_expression(): left = parse_term() while tokens and tokens[0] in ('+', '-'): op = next_token() right = parse_term() if op == '+': left += right elif op == '-': left -= right return left def parse_term(): left = parse_factor() while tokens and tokens[0] in ('*', '/'): op = next_token() right = parse_factor() if op == '*': left *= right elif op == '/': if right == 0: return float('inf') left /= right return left def parse_factor(): token = next_token() if token == '(': expression_value = parse_expression() next_token() # consume ')' return expression_value elif token == '-': return -parse_factor() else: return float(token) return parse_expression() tokens = tokenize(expression) return parse(tokens)"},{"question":"def validate_and_merge_profiles( base_profile: dict, additional_profile: dict = {} ) -> dict: Input Parameters ---------------- base_profile : dict A dictionary containing the base user profile. additional_profile : dict, optional A dictionary containing additional user profile data (default is {}). Returns ------- result : dict A dictionary containing the merged user profile. Raises ------ ValueError If 'age' is not a positive integer, or if 'email' does not contain an \\"@\\" symbol, or if either 'age' or 'email' is missing from the resulting dictionary. Examples -------- >>> validate_and_merge_profiles({'name': 'Jane', 'age': 25, 'email': 'jane@example.com'}) {'name': 'Jane', 'age': 25, 'email': 'jane@example.com'} >>> validate_and_merge_profiles({'name': 'Jane', 'age': 25, 'email': 'jane@example.com'}, {'age': 30}) {'name': 'Jane', 'age': 30, 'email': 'jane@example.com'} >>> validate_and_merge_profiles({'name': 'Jane'}, {'age': 25, 'email': 'jane@example.com'}) {'name': 'Jane', 'age': 25, 'email': 'jane@example.com'} >>> validate_and_merge_profiles({'name': 'Jane', 'age': '25', 'email': 'jane@example.com'}) Traceback (most recent call last): ... ValueError: Age must be a positive integer. >>> validate_and_merge_profiles({'name': 'Jane', 'age': 25, 'email': 'janeexample.com'}) Traceback (most recent call last): ... ValueError: Email must contain '@' symbol. >>> validate_and_merge_profiles({'name': 'Jane'}, {}) Traceback (most recent call last): ... ValueError: Resulting profile must contain 'age' and 'email'. pass","solution":"def validate_and_merge_profiles(base_profile: dict, additional_profile: dict = {}) -> dict: Input Parameters ---------------- base_profile : dict A dictionary containing the base user profile. additional_profile : dict, optional A dictionary containing additional user profile data (default is {}). Returns ------- result : dict A dictionary containing the merged user profile. Raises ------ ValueError If 'age' is not a positive integer, or if 'email' does not contain an \\"@\\" symbol, or if either 'age' or 'email' is missing from the resulting dictionary. Examples -------- >>> validate_and_merge_profiles({'name': 'Jane', 'age': 25, 'email': 'jane@example.com'}) {'name': 'Jane', 'age': 25, 'email': 'jane@example.com'} >>> validate_and_merge_profiles({'name': 'Jane', 'age': 25, 'email': 'jane@example.com'}, {'age': 30}) {'name': 'Jane', 'age': 30, 'email': 'jane@example.com'} >>> validate_and_merge_profiles({'name': 'Jane'}, {'age': 25, 'email': 'jane@example.com'}) {'name': 'Jane', 'age': 25, 'email': 'jane@example.com'} >>> validate_and_merge_profiles({'name': 'Jane', 'age': '25', 'email': 'jane@example.com'}) Traceback (most recent call last): ... ValueError: Age must be a positive integer. >>> validate_and_merge_profiles({'name': 'Jane', 'age': 25, 'email': 'janeexample.com'}) Traceback (most recent call last): ... ValueError: Email must contain '@' symbol. >>> validate_and_merge_profiles({'name': 'Jane'}, {}) Traceback (most recent call last): ... ValueError: Resulting profile must contain 'age' and 'email'. # Merge profiles, additional_profile overwrites base_profile merged_profile = {**base_profile, **additional_profile} # Ensure 'age' and 'email' are in the merged profile if 'age' not in merged_profile or 'email' not in merged_profile: raise ValueError(\\"Resulting profile must contain 'age' and 'email'.\\") # Validate 'age' key age = merged_profile['age'] if not isinstance(age, int) or age <= 0: raise ValueError(\\"Age must be a positive integer.\\") # Validate 'email' key email = merged_profile['email'] if not isinstance(email, str) or '@' not in email: raise ValueError(\\"Email must contain '@' symbol.\\") return merged_profile"},{"question":"import heapq class TaskScheduler: def __init__(self) -> None: Initialize an empty task scheduler with a max-heap. self.heap = [] def add_task(self, task_id: int, priority: int) -> None: Add a task with the given task_id and priority to the scheduler. >>> scheduler = TaskScheduler() >>> scheduler.add_task(1, 5) >>> scheduler.add_task(2, 10) >>> scheduler.add_task(3, 3) >>> scheduler.get_next_task() 2 >>> scheduler.get_next_task() 1 >>> scheduler.get_next_task() 3 pass def get_next_task(self) -> int: Return the task_id of the highest priority task and remove it from the scheduler. Raises: IndexError: If there are no tasks in the scheduler. >>> scheduler = TaskScheduler() >>> scheduler.add_task(1, 5) >>> scheduler.add_task(2, 10) >>> scheduler.add_task(3, 3) >>> scheduler.get_next_task() 2 >>> scheduler.get_next_task() 1 >>> scheduler.get_next_task() 3 pass def test_single_task(): scheduler = TaskScheduler() scheduler.add_task(1, 5) assert scheduler.get_next_task() == 1 def test_multiple_tasks(): scheduler = TaskScheduler() scheduler.add_task(1, 5) scheduler.add_task(2, 10) scheduler.add_task(3, 3) assert scheduler.get_next_task() == 2 assert scheduler.get_next_task() == 1 assert scheduler.get_next_task() == 3 def test_same_priority_tasks(): scheduler = TaskScheduler() scheduler.add_task(1, 5) scheduler.add_task(2, 5) assert scheduler.get_next_task() in (1, 2) assert scheduler.get_next_task() in (1, 2) def test_empty_scheduler(): scheduler = TaskScheduler() with pytest.raises(IndexError): scheduler.get_next_task() def test_combination_of_tasks(): scheduler = TaskScheduler() scheduler.add_task(1, 1) scheduler.add_task(2, 2) scheduler.add_task(3, 3) assert scheduler.get_next_task() == 3 scheduler.add_task(4, 4) assert scheduler.get_next_task() == 4 assert scheduler.get_next_task() == 2 assert scheduler.get_next_task() == 1","solution":"import heapq class TaskScheduler: def __init__(self) -> None: self.heap = [] def add_task(self, task_id: int, priority: int) -> None: # Use negative priority because heapq is a min-heap by default heapq.heappush(self.heap, (-priority, task_id)) def get_next_task(self) -> int: if not self.heap: raise IndexError(\\"get_next_task() called on empty scheduler\\") return heapq.heappop(self.heap)[1]"},{"question":"def alien_language_sort(words: list[str], alphabet: str) -> list[str]: Sorts the words based on the provided alien language alphabet. Parameters: words: List of strings, each a word in the alien language. alphabet: A string of length 26 representing the custom alphabet. Returns: A list of strings sorted according to the order defined by the custom alphabet. Examples: >>> alien_language_sort([\\"hello\\", \\"world\\", \\"hi\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") [\\"hello\\", \\"hi\\", \\"world\\"] >>> alien_language_sort([\\"banana\\", \\"apple\\", \\"mango\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") [\\"mango\\", \\"banana\\", \\"apple\\"]","solution":"def alien_language_sort(words, alphabet): Sorts the words based on the provided alien language alphabet. Parameters: - words: List of strings, each a word in the alien language. - alphabet: A string of length 26 representing the custom alphabet. Returns: - A list of strings sorted according to the order defined by the custom alphabet. # Create a dictionary to map each letter in the custom alphabet to its index order_map = {char: index for index, char in enumerate(alphabet)} # A helper function to convert a word to its custom order representation def custom_order(word): return [order_map[char] for char in word] # Sort the words using the custom order representation return sorted(words, key=custom_order)"},{"question":"import numpy as np def matrix_exponential(matrix: np.ndarray) -> np.ndarray: Computes the element-wise exponential of the given 2D numpy array (matrix). Parameters: matrix (np.ndarray): 2D numpy array of real numbers Returns: np.ndarray: A 2D numpy array with the element-wise exponential of the input >>> matrix_exponential(np.array([[0, 1], [2, -1]])) array([[1. , 2.71828183], [7.3890561 , 0.36787944]]) >>> matrix_exponential(np.array([[-2, -3], [-1, 0]])) array([[0.13533528, 0.04978707], [0.36787944, 1. ]]) >>> matrix_exponential(np.array([[1e-10, 1e10], [5, -5]])) array([[1. , inf], [148.4131591, 0.00673795]])","solution":"import numpy as np def matrix_exponential(matrix): Computes the element-wise exponential of the given 2D numpy array (matrix). Parameters: matrix (np.ndarray): 2D numpy array of real numbers Returns: np.ndarray: A 2D numpy array with the element-wise exponential of the input return np.exp(matrix)"},{"question":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Processes the text and returns a dictionary containing the frequency of each word. Words are converted to lowercase and punctuation is removed. >>> word_frequency(\\"Hello, world! Hello universe.\\") {'hello': 2, 'world': 1, 'universe': 1} >>> word_frequency(\\"Python is great. Python, Python, Python.\\") {'python': 4, 'is': 1, 'great': 1} >>> word_frequency(\\"\\") {} >>> word_frequency(\\"!!! ??? ... ,,\\") {} >>> word_frequency(\\"123 123 456 abc\\") {'123': 2, '456': 1, 'abc': 1} >>> word_frequency(\\"abc123 123abc abc123\\") {'abc123': 2, '123abc': 1} >>> word_frequency(\\"HeLLo hello HELLO\\") {'hello': 3}","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Processes the text and returns a dictionary containing the frequency of each word. Words are converted to lowercase and punctuation is removed. # Convert the text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r'[^ws]', '', text) # Split the text into words words = text.split() # Initialize a default dictionary to store word frequency frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"from typing import List def find_triplet_with_sum(arr: List[int], target: int) -> bool: Determine if there are three distinct elements in the given array that add up to the target sum. >>> find_triplet_with_sum([12, 3, 4, 1, 6, 9], 24) True >>> find_triplet_with_sum([1, 2, 3, 4, 5], 10) True >>> find_triplet_with_sum([1, 2, 3, 4, 5], 20) False >>> find_triplet_with_sum([1, 2], 3) False","solution":"from typing import List def find_triplet_with_sum(arr: List[int], target: int) -> bool: arr.sort() n = len(arr) for i in range(n - 2): l, r = i + 1, n - 1 while (l < r): current_sum = arr[i] + arr[l] + arr[r] if current_sum == target: return True elif current_sum < target: l += 1 else: r -= 1 return False"},{"question":"def generate_pascals_triangle(n: int) -> list[list[int]]: Generates Pascal's triangle up to n rows. Args: n (int): The number of rows for Pascal's triangle to generate. Returns: list[list[int]]: A 2-dimensional list representing the first n rows of Pascal's triangle. Raises: ValueError: If n is not a non-negative integer. >>> generate_pascals_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascals_triangle(0) [] >>> generate_pascals_triangle(-3) Traceback (most recent call last): ... ValueError: generate_pascals_triangle() requires a non-negative integer for n","solution":"def generate_pascals_triangle(n: int) -> list[list[int]]: Generates Pascal's triangle up to n rows. Args: n (int): The number of rows for Pascal's triangle to generate. Returns: list[list[int]]: A 2-dimensional list representing the first n rows of Pascal's triangle. Raises: ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"generate_pascals_triangle() requires a non-negative integer for n\\") if n == 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i - 1][j - 1] + triangle[i - 1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"from typing import List def average_age(ages: List[int], lower: int, upper: int) -> float: Calculates the average age of employees within a given age range. Parameters: ages (List[int]): List of employee ages. lower (int): The lower bound of the age range. upper (int): The upper bound of the age range. Returns: float: The average age of employees within the specified age range, rounded to 2 decimal places. If no ages fall within the range, returns 0. Examples: >>> average_age([23, 34, 45, 56, 23, 35, 40], 30, 50) 38.5 >>> average_age([22, 34, 46, 58, 29, 36, 41], 25, 35) 31.5 >>> average_age([15, 20, 25, 30, 35, 40], 50, 60) 0 pass # Test cases def test_average_age_normal_case(): assert average_age([23, 34, 45, 56, 23, 35, 40], 30, 50) == 38.5 def test_average_age_another_case(): assert average_age([22, 34, 46, 58, 29, 36, 41], 25, 35) == 31.5 def test_average_age_no_ages_in_range(): assert average_age([15, 20, 25, 30, 35, 40], 50, 60) == 0 def test_average_age_all_ages_in_range(): assert average_age([20, 22, 25, 30, 35, 40, 45, 50], 20, 50) == 33.38 def test_average_age_some_ages_on_bounds(): assert average_age([15, 25, 35, 45, 55, 65, 75], 30, 60) == 45 def test_average_age_single_age_in_range(): assert average_age([17, 21, 27, 33, 37, 41], 27, 27) == 27.0 def test_average_age_all_ages_above_upper_bound(): assert average_age([60, 70, 80, 90], 50, 59) == 0 def test_average_age_all_ages_below_lower_bound(): assert average_age([10, 15, 20], 25, 30) == 0","solution":"from typing import List def average_age(ages: List[int], lower: int, upper: int) -> float: Calculates the average age of employees within a given age range. Parameters: ages (List[int]): List of employee ages. lower (int): The lower bound of the age range. upper (int): The upper bound of the age range. Returns: float: The average age of employees within the specified age range, rounded to 2 decimal places. If no ages fall within the range, returns 0. filtered_ages = [age for age in ages if lower <= age <= upper] if not filtered_ages: return 0.0 average = sum(filtered_ages) / len(filtered_ages) return round(average, 2)"},{"question":"def count_failed_logins(total_attempts: int, successful_attempts: int) -> int: Given the total number of login attempts and the number of successful logins, calculate and return the number of failed login attempts. Parameters: total_attempts (int): The total number of login attempts. (1 ≤ total_attempts ≤ 10^6) successful_attempts (int): The number of successful login attempts. (0 ≤ successful_attempts ≤ total_attempts) Returns: int: The number of failed login attempts. >>> count_failed_logins(100, 80) 20 >>> count_failed_logins(50, 50) 0 >>> count_failed_logins(30, 5) 25","solution":"def count_failed_logins(total_attempts: int, successful_attempts: int) -> int: Given the total number of login attempts and the number of successful logins, calculate and return the number of failed login attempts. Parameters: total_attempts (int): The total number of login attempts. successful_attempts (int): The number of successful login attempts. Returns: int: The number of failed login attempts. return total_attempts - successful_attempts"},{"question":"from typing import List, Tuple, Any def euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: Calculates the Euclidean distance between two points in 2D space. pass def knn_classify(data_points: List[Tuple[float, float, Any]], query_point: Tuple[float, float], k: int) -> Any: Classifies a query point based on the K-Nearest Neighbors algorithm. Args: - data_points: List of tuples, where each tuple consists of x, y coordinates and a class label. - query_point: A tuple representing the x, y coordinates of the query point. - k: The number of nearest neighbors to consider for classification. Returns: - The predicted class label for the query point. >>> data_points = [(1.0, 2.0, 'A'), (2.0, 3.0, 'B'), (3.0, 1.0, 'A'), (5.0, 4.0, 'B'), (3.0, 3.0, 'A')] >>> knn_classify(data_points, (3.0, 2.5), 3) 'A' >>> knn_classify(data_points, (4.0, 4.0), 3) 'B' pass def test_knn_classify_basic(): data_points = [ (1.0, 2.0, 'A'), (2.0, 3.0, 'B'), (3.0, 1.0, 'A'), (5.0, 4.0, 'B'), (3.0, 3.0, 'A') ] assert knn_classify(data_points, (3.0, 2.5), 3) == 'A' assert knn_classify(data_points, (4.0, 4.0), 3) == 'B' def test_knn_classify_tiebreaker(): data_points = [ (1.0, 2.0, 'A'), (2.0, 2.9, 'B'), (3.0, 1.1, 'A'), (5.0, 4.0, 'B'), (3.0, 3.0, 'A') ] assert knn_classify(data_points, (3.0, 2.5), 4) == 'A' # A is selected due to tiebreaker def test_knn_classify_single_neighbor(): data_points = [ (1.0, 2.0, 'A'), (2.0, 3.0, 'B'), (3.0, 1.0, 'A'), (5.0, 4.0, 'B'), (3.0, 3.0, 'A') ] assert knn_classify(data_points, (3.0, 2.5), 1) == 'A' def test_knn_classify_all_same_class(): data_points = [ (1.0, 2.0, 'A'), (2.0, 3.0, 'A'), (3.0, 1.0, 'A'), (5.0, 4.0, 'A'), (3.0, 3.0, 'A') ] assert knn_classify(data_points, (2.0, 2.0), 3) == 'A' def test_knn_classify_large_k(): data_points = [ (1.0, 2.0, 'A'), (2.0, 3.0, 'B'), (3.0, 1.0, 'A'), (5.0, 4.0, 'B'), (3.0, 3.0, 'A'), (4.0, 4.0, 'B') ] assert knn_classify(data_points, (3.0, 2.5), 6) == 'A'","solution":"from typing import List, Tuple, Any import math from collections import Counter def euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: Calculates the Euclidean distance between two points in 2D space. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def knn_classify(data_points: List[Tuple[float, float, Any]], query_point: Tuple[float, float], k: int) -> Any: Classifies a query point based on the K-Nearest Neighbors algorithm. Args: - data_points: List of tuples, where each tuple consists of x, y coordinates and a class label. - query_point: A tuple representing the x, y coordinates of the query point. - k: The number of nearest neighbors to consider for classification. Returns: - The predicted class label for the query point. # Calculate the distance from the query point to all data points distances = [(euclidean_distance(datapoint[:2], query_point), datapoint[2]) for datapoint in data_points] # Sort the distances and select the top k distances.sort(key=lambda x: x[0]) k_nearest_neighbors = distances[:k] # Count the class labels of the top k nearest neighbors labels = [label for _, label in k_nearest_neighbors] most_common_label = Counter(labels).most_common(1)[0][0] return most_common_label"},{"question":"from typing import Dict, List class TrieNode: def __init__(self): self.children = {} self.document_ids = set() def build_trie(documents: Dict[int, str]) -> TrieNode: Build a Trie from a dictionary of documents. Args: documents: A dictionary where the key is the document ID and the value is the document text. Returns: The root of the Trie. pass def search_keyword(root: TrieNode, keyword: str) -> List[int]: Search for a keyword in the Trie and return a list of document IDs containing the keyword. Args: root: The root of the Trie. keyword: The keyword string to search for. Returns: A list of document IDs that contain the keyword. pass def test_build_trie_and_search_keyword(): documents = { 1: \\"machine learning is fascinating\\", 2: \\"artificial intelligence is a subset of machine learning\\", 3: \\"deep learning is a crucial part of machine learning\\", 4: \\"natural language processing is a field of machine learning\\" } root = build_trie(documents) assert sorted(search_keyword(root, \\"machine\\")) == [1, 2, 3, 4] assert sorted(search_keyword(root, \\"learning\\")) == [1, 2, 3, 4] assert sorted(search_keyword(root, \\"artificial\\")) == [2] assert sorted(search_keyword(root, \\"processing\\")) == [4] assert search_keyword(root, \\"notindocuments\\") == [] def test_search_keyword_not_present(): documents = { 1: \\"test document one\\", 2: \\"another test document\\", 3: \\"yet another test case\\" } root = build_trie(documents) assert search_keyword(root, \\"nonexistent\\") == [] def test_search_empty_trie(): documents = {} root = build_trie(documents) assert search_keyword(root, \\"anything\\") == [] def test_partial_matches(): documents = { 1: \\"the quick brown fox jumps\\", 2: \\"over the lazy dog\\" } root = build_trie(documents) assert search_keyword(root, \\"the\\") == [1, 2] assert search_keyword(root, \\"over\\") == [2] assert search_keyword(root, \\"quic\\") == []","solution":"from typing import Dict, List class TrieNode: def __init__(self): self.children = {} self.document_ids = set() def build_trie(documents: Dict[int, str]) -> TrieNode: root = TrieNode() for doc_id, text in documents.items(): words = text.split() for word in words: current = root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.document_ids.add(doc_id) return root def search_keyword(root: TrieNode, keyword: str) -> List[int]: current = root for char in keyword: if char not in current.children: return [] current = current.children[char] return list(current.document_ids)"},{"question":"def sort_contacts(contacts: List[str]) -> List[str]: Takes a list of contact names and returns a new list where the names are sorted alphabetically by their last names and by first names in case of ties. :param contacts: A list of strings, each representing a contact name in the format \\"First Last\\". :return: A new list of strings sorted as specified. >>> sort_contacts([\\"John Smith\\", \\"Alice Johnson\\", \\"Bob Johnson\\", \\"Charlie Brown\\", \\"John Brown\\"]) ['Charlie Brown', 'John Brown', 'Alice Johnson', 'Bob Johnson', 'John Smith'] >>> sort_contacts([\\"John Smith\\"]) [\\"John Smith\\"]","solution":"def sort_contacts(contacts): Takes a list of contact names and returns a new list where the names are sorted alphabetically by their last names and by first names in case of ties. :param contacts: A list of strings, each representing a contact name in the format \\"First Last\\". :return: A new list of strings sorted as specified. return sorted(contacts, key=lambda name: (name.split()[1], name.split()[0]))"},{"question":"def zip_with_defaults(list1: list, list2: list, default=None) -> list: Zips two lists into a list of tuples. If the lists are of unequal lengths, the shorter list should be padded with the specified default value. Parameters: - list1: First list to zip. - list2: Second list to zip. - default: The default value to use for padding (default is None). Returns: - A new list containing tuples where each tuple contains elements from \`list1\` and \`list2\`. If one list is shorter, the missing values are filled with \`default\`. Raises: - TypeError: If list1 or list2 is not a list. >>> zip_with_defaults([1, 2, 3], ['a', 'b', 'c']) [(1, 'a'), (2, 'b'), (3, 'c')] >>> zip_with_defaults([1, 2], ['a', 'b', 'c']) [(1, 'a'), (2, 'b'), (None, 'c')] >>> zip_with_defaults([1, 2, 3], ['a'], default='x') [(1, 'a'), (2, 'x'), (3, 'x')] >>> zip_with_defaults([], ['a', 'b'], default=0) [(0, 'a'), (0, 'b')] >>> zip_with_defaults([1, 2], []) [(1, None), (2, None)] >>> zip_with_defaults(123, ['a', 'b']) Traceback (most recent call last): ... TypeError: list1 and list2 must be lists # Your code here def test_zip_with_defaults(): assert zip_with_defaults([1, 2, 3], ['a', 'b', 'c']) == [(1, 'a'), (2, 'b'), (3, 'c')] assert zip_with_defaults([1, 2], ['a', 'b', 'c']) == [(1, 'a'), (2, 'b'), (None, 'c')] assert zip_with_defaults([1, 2, 3], ['a'], default='x') == [(1, 'a'), (2, 'x'), (3, 'x')] assert zip_with_defaults([], ['a', 'b'], default=0) == [(0, 'a'), (0, 'b')] assert zip_with_defaults([1, 2], []) == [(1, None), (2, None)] assert zip_with_defaults([], []) == [] try: zip_with_defaults(123, ['a', 'b']) except TypeError as e: assert str(e) == \\"list1 and list2 must be lists\\" else: assert False, \\"Expected TypeError\\" try: zip_with_defaults([1, 2], 'abc') except TypeError as e: assert str(e) == \\"list1 and list2 must be lists\\" else: assert False, \\"Expected TypeError\\"","solution":"def zip_with_defaults(list1, list2, default=None): Zips two lists into a list of tuples. If the lists are of unequal lengths, the shorter list will be padded with the specified default value. Parameters: - list1: First list to zip. - list2: Second list to zip. - default: The default value to use for padding (default is None). Returns: - A new list containing tuples where each tuple contains elements from \`list1\` and \`list2\`. If one list is shorter, the missing values are filled with \`default\`. if not isinstance(list1, list) or not isinstance(list2, list): raise TypeError(\\"list1 and list2 must be lists\\") max_len = max(len(list1), len(list2)) padded_list1 = list1 + [default] * (max_len - len(list1)) padded_list2 = list2 + [default] * (max_len - len(list2)) return list(zip(padded_list1, padded_list2))"},{"question":"from typing import List, Tuple def schedule_tasks(tasks: List[Tuple[int, int]]) -> List[int]: Schedules tasks based on their priorities and returns the order of task execution. Args: tasks (List[Tuple[int, int]]): A list of tuples where each tuple contains a task id and its priority. Returns: List[int]: A list of task ids in the order they should be executed. >>> schedule_tasks([(1, 3), (2, 1), (3, 2), (4, 1)]) == [2, 4, 3, 1] >>> schedule_tasks([(10, 5), (5, 2), (8, 5), (2, 2)]) == [2, 5, 8, 10] >>> schedule_tasks([(42, 0), (23, 2), (86, 1)]) == [42, 86, 23] >>> schedule_tasks([(1, 0)]) == [1] >>> schedule_tasks([(99, 100)]) == [99] >>> schedule_tasks([(1, 2), (2, 2), (3, 2)]) == [1, 2, 3] >>> schedule_tasks([(1, 3), (2, 1), (3, 4), (4, 2)]) == [2, 4, 1, 3] >>> schedule_tasks([(1, 4), (2, 3), (3, 2), (4, 1)]) == [4, 3, 2, 1] >>> tasks = [(i, i % 10) for i in range(10000)] >>> expected = sorted(range(10000), key=lambda x: (x % 10, x)) >>> schedule_tasks(tasks) == expected >>> tasks = [(i, 10 - i) for i in range(1, 6)] >>> schedule_tasks(tasks) == [5, 4, 3, 2, 1]","solution":"from typing import List, Tuple def schedule_tasks(tasks: List[Tuple[int, int]]) -> List[int]: Schedules tasks based on their priorities and returns the order of task execution. Args: tasks (List[Tuple[int, int]]): A list of tuples where each tuple contains a task id and its priority. Returns: List[int]: A list of task ids in the order they should be executed. # Sort tasks primarily by priority (ascending) and secondarily by task_id (ascending) tasks_sorted = sorted(tasks, key=lambda x: (x[1], x[0])) # Extract the task ids from the sorted tasks ordered_task_ids = [task[0] for task in tasks_sorted] return ordered_task_ids"},{"question":"def max_profit(prices: List[int]) -> Union[int, str]: Determines the maximum profit that can be made by buying on one day and selling on a later day. Parameters: prices (list of int): List of integers representing stock prices over a series of days. Returns: int or str: Maximum profit that can be made, or \\"No Profit Possible\\" if no profit can be made. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) \\"No Profit Possible\\" >>> max_profit([]) \\"No Profit Possible\\"","solution":"def max_profit(prices): Determines the maximum profit that can be made by buying on one day and selling on a later day. Parameters: prices (list of int): List of integers representing stock prices over a series of days. Returns: int or str: Maximum profit that can be made, or \\"No Profit Possible\\" if no profit can be made. if len(prices) < 2: return \\"No Profit Possible\\" min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit if max_profit > 0 else \\"No Profit Possible\\""},{"question":"from typing import List, Dict def calculate_event_durations(logs: List[str]) -> Dict[str, int]: This function calculates the total duration of each event based on the provided logs. Args: logs: List of strings, where each string represents a log entry in the format: \\"timestamp,event_id,event_type\\", where \\"timestamp\\" is an integer representing the time in seconds, \\"event_id\\" is a unique string identifying the event, and \\"event_type\\" is either \\"start\\" or \\"end\\". Returns: Dictionary where keys are event IDs and values are the total duration in seconds for each event.","solution":"def calculate_event_durations(logs): This function calculates the total duration of each event based on the provided logs. Args: logs: List of strings, where each string represents a log entry in the format: \\"timestamp,event_id,event_type\\", where \\"timestamp\\" is an integer representing the time in seconds, \\"event_id\\" is a unique string identifying the event, and \\"event_type\\" is either \\"start\\" or \\"end\\". Returns: Dictionary where keys are event IDs and values are the total duration in seconds for each event. event_durations = {} event_start_times = {} for log in logs: timestamp, event_id, event_type = log.split(',') timestamp = int(timestamp) if event_type == \\"start\\": event_start_times[event_id] = timestamp elif event_type == \\"end\\": if event_id in event_start_times: start_time = event_start_times.pop(event_id) duration = timestamp - start_time if event_id in event_durations: event_durations[event_id] += duration else: event_durations[event_id] = duration return event_durations"},{"question":"class AVLTree: def __init__(self): Initialize an empty AVL tree. pass def insert(self, key: int) -> None: Insert a new node with the given key into the AVL Tree. Parameters: key (int): The key to insert. Examples: >>> avl = AVLTree() >>> avl.insert(10) >>> avl.inorder_traversal() [10] pass def delete(self, key: int) -> None: Delete a node with the given key from the AVL Tree. Parameters: key (int): The key to delete. Examples: >>> avl = AVLTree() >>> avl.insert(10) >>> avl.delete(10) >>> avl.inorder_traversal() [] pass def search(self, key: int) -> bool: Search for a node with the specified key. Parameters: key (int): The key to search for. Returns: bool: True if the key is found, False otherwise. Examples: >>> avl = AVLTree() >>> avl.insert(10) >>> avl.search(10) True >>> avl.search(20) False pass def inorder_traversal(self) -> list: Perform an in-order traversal of the tree and return the list of keys. Returns: list: A list of keys in in-order. Examples: >>> avl = AVLTree() >>> avl.insert(10) >>> avl.insert(20) >>> avl.inorder_traversal() [10, 20] pass","solution":"class AVLNode: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right class AVLTree: def __init__(self): self.root = None def get_height(self, node): if not node: return 0 return node.height def update_height(self, node): if node: node.height = max(self.get_height(node.left), self.get_height(node.right)) + 1 def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 self.update_height(y) self.update_height(x) return x def rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 self.update_height(x) self.update_height(y) return y def insert(self, key): def _insert(node, key): if not node: return AVLNode(key) if key < node.key: node.left = _insert(node.left, key) else: node.right = _insert(node.right, key) self.update_height(node) balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.rotate_right(node) if balance < -1 and key > node.right.key: return self.rotate_left(node) if balance > 1 and key > node.left.key: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and key < node.right.key: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node self.root = _insert(self.root, key) def delete(self, key): def _delete(node, key): if not node: return node if key < node.key: node.left = _delete(node.left, key) elif key > node.key: node.right = _delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self.get_min_value_node(node.right) node.key = temp.key node.right = _delete(node.right, temp.key) self.update_height(node) balance = self.get_balance(node) if balance > 1 and self.get_balance(node.left) >= 0: return self.rotate_right(node) if balance < -1 and self.get_balance(node.right) <= 0: return self.rotate_left(node) if balance > 1 and self.get_balance(node.left) < 0: node.left = self.rotate_left(node.left) return self.rotate_right(node) if balance < -1 and self.get_balance(node.right) > 0: node.right = self.rotate_right(node.right) return self.rotate_left(node) return node self.root = _delete(self.root, key) def search(self, key): def _search(node, key): if not node: return False if key == node.key: return True if key < node.key: return _search(node.left, key) else: return _search(node.right, key) return _search(self.root, key) def get_min_value_node(self, node): current = node while current.left: current = current.left return current def inorder_traversal(self): def _inorder(node): if node: return _inorder(node.left) + [node.key] + _inorder(node.right) return [] return _inorder(self.root)"},{"question":"class StockAnalyzer: def __init__(self, prices): self.prices = prices def max_profit(self) -> int: Calculates the maximum profit that can be achieved from exactly one transaction (buy one day and sell on a later day). >>> sa = StockAnalyzer([7, 1, 5, 3, 6, 4]) >>> sa.max_profit() 5 >>> sa = StockAnalyzer([7, 6, 4, 3, 1]) >>> sa.max_profit() 0 pass def longest_increasing_subsequence(self) -> list[int]: Finds the longest increasing subsequence of stock prices. >>> sa = StockAnalyzer([7, 1, 5, 3, 6, 4]) >>> sa.longest_increasing_subsequence() [1, 3, 4] >>> sa = StockAnalyzer([1, 2, 3, 4, 5]) >>> sa.longest_increasing_subsequence() [1, 2, 3, 4, 5] pass","solution":"class StockAnalyzer: def __init__(self, prices): self.prices = prices def max_profit(self) -> int: if not self.prices: return 0 min_price = float('inf') max_profit = 0 for price in self.prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def longest_increasing_subsequence(self) -> list[int]: from bisect import bisect_left if not self.prices: return [] subseq = [] for price in self.prices: pos = bisect_left(subseq, price) if pos < len(subseq): subseq[pos] = price else: subseq.append(price) # Reconstruct the longest increasing subsequence from the determined positions lis = [] current_min = float('inf') for i in range(len(subseq) - 1, -1, -1): if subseq[i] < current_min: lis.append(subseq[i]) current_min = subseq[i] return lis[::-1]"},{"question":"import networkx as nx import matplotlib.pyplot as plt from typing import List class LinkedInUser: def __init__(self, username: str, connections: List[str] = None): self.username = username self.connections = connections if connections else [] def add_connection(self, other_user: str): Adds a connection to the user. :param other_user: Username of the user to connect with. self.connections.append(other_user) def identify_mutual_connections(self, other_user: 'LinkedInUser') -> List[str]: Identifies mutual connections between self and another user. :param other_user: LinkedInUser instance :return: List of mutual connections (List[str]) >>> user1 = LinkedInUser(\\"alice\\", [\\"bob\\", \\"charlie\\", \\"david\\"]) >>> user2 = LinkedInUser(\\"bob\\", [\\"alice\\", \\"charlie\\", \\"edward\\"]) >>> user1.identify_mutual_connections(user2) [\\"charlie\\"] >>> user1 = LinkedInUser(\\"alice\\", [\\"bob\\", \\"charlie\\"]) >>> user2 = LinkedInUser(\\"david\\", [\\"edward\\", \\"frank\\"]) >>> user1.identify_mutual_connections(user2) [] pass def visualize_connections(self) -> None: Visualizes the user's connections using networkx and renders it using matplotlib. >>> user1 = LinkedInUser(\\"alice\\", [\\"bob\\", \\"charlie\\", \\"david\\"]) >>> user1.visualize_connections() pass def test_identify_mutual_connections(): user1 = LinkedInUser(\\"alice\\", [\\"bob\\", \\"charlie\\", \\"david\\"]) user2 = LinkedInUser(\\"bob\\", [\\"alice\\", \\"charlie\\", \\"edward\\"]) expected_mutual_connections = [\\"charlie\\"] actual_mutual_connections = user1.identify_mutual_connections(user2) assert sorted(actual_mutual_connections) == sorted(expected_mutual_connections) def test_identify_no_mutual_connections(): user1 = LinkedInUser(\\"alice\\", [\\"bob\\", \\"charlie\\"]) user2 = LinkedInUser(\\"david\\", [\\"edward\\", \\"frank\\"]) expected_mutual_connections = [] actual_mutual_connections = user1.identify_mutual_connections(user2) assert actual_mutual_connections == expected_mutual_connections def test_visualize_connections(): user1 = LinkedInUser(\\"alice\\", [\\"bob\\", \\"charlie\\", \\"david\\"]) # This test can't be verifiable through assert statements, here we invoke the method to ensure it runs without errors. user1.visualize_connections() def test_add_connection(): user1 = LinkedInUser(\\"alice\\") user1.add_connection(\\"bob\\") assert user1.connections == [\\"bob\\"] def test_add_multiple_connections(): user1 = LinkedInUser(\\"alice\\") user1.add_connection(\\"bob\\") user1.add_connection(\\"charlie\\") assert user1.connections == [\\"bob\\", \\"charlie\\"]","solution":"import networkx as nx import matplotlib.pyplot as plt class LinkedInUser: def __init__(self, username, connections=None): self.username = username self.connections = connections if connections else [] def add_connection(self, other_user): self.connections.append(other_user) def identify_mutual_connections(self, other_user): Identifies mutual connections between self and other_user. :param other_user: LinkedInUser instance :return: List of mutual connections (List[str]) return list(set(self.connections) & set(other_user.connections)) def visualize_connections(self): Visualizes the user's connections using networkx and renders it using matplotlib. graph = nx.Graph() graph.add_node(self.username) for connection in self.connections: graph.add_edge(self.username, connection) pos = nx.spring_layout(graph) nx.draw(graph, pos, with_labels=True, node_color='lightblue', node_size=3000, font_size=10, font_weight='bold') plt.show()"},{"question":"def promote_employees(employee_list: list, promotion_list: list) -> list: Updates the employee_list with promotions based on the promotion_list. Parameters: - employee_list (list): A list of employee records with 'name', 'position', and 'salary'. - promotion_list (list): A list of promotions with 'name', 'new_position', and 'new_salary'. Returns: - list: The updated list of employee records after applying all promotions. from typing import List def test_promote_employees_basic(): employee_list = [ {\\"name\\": \\"Alice\\", \\"position\\": \\"Developer\\", \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"position\\": \\"Manager\\", \\"salary\\": 90000}, {\\"name\\": \\"Charlie\\", \\"position\\": \\"Support\\", \\"salary\\": 50000} ] promotion_list = [ {\\"name\\": \\"Alice\\", \\"new_position\\": \\"Senior Developer\\", \\"new_salary\\": 85000}, {\\"name\\": \\"Charlie\\", \\"new_position\\": \\"Senior Support\\", \\"new_salary\\": 60000} ] result = promote_employees(employee_list, promotion_list) expected_result = [ {\\"name\\": \\"Alice\\", \\"position\\": \\"Senior Developer\\", \\"salary\\": 85000}, {\\"name\\": \\"Bob\\", \\"position\\": \\"Manager\\", \\"salary\\": 90000}, {\\"name\\": \\"Charlie\\", \\"position\\": \\"Senior Support\\", \\"salary\\": 60000} ] assert result == expected_result def test_promote_employees_single_promotion(): employee_list = [ {\\"name\\": \\"Eric\\", \\"position\\": \\"Analyst\\", \\"salary\\": 40000}, {\\"name\\": \\"Diana\\", \\"position\\": \\"Marketing\\", \\"salary\\": 60000} ] promotion_list = [ {\\"name\\": \\"Diana\\", \\"new_position\\": \\"Senior Marketing\\", \\"new_salary\\": 75000} ] result = promote_employees(employee_list, promotion_list) expected_result = [ {\\"name\\": \\"Eric\\", \\"position\\": \\"Analyst\\", \\"salary\\": 40000}, {\\"name\\": \\"Diana\\", \\"position\\": \\"Senior Marketing\\", \\"salary\\": 75000} ] assert result == expected_result def test_promote_employees_no_promotion(): employee_list = [ {\\"name\\": \\"Linda\\", \\"position\\": \\"HR\\", \\"salary\\": 65000}, {\\"name\\": \\"James\\", \\"position\\": \\"Engineer\\", \\"salary\\": 70000} ] promotion_list = [] result = promote_employees(employee_list, promotion_list) expected_result = [ {\\"name\\": \\"Linda\\", \\"position\\": \\"HR\\", \\"salary\\": 65000}, {\\"name\\": \\"James\\", \\"position\\": \\"Engineer\\", \\"salary\\": 70000} ] assert result == expected_result def test_promote_employees_all_promoted(): employee_list = [ {\\"name\\": \\"Anna\\", \\"position\\": \\"Developer\\", \\"salary\\": 75000}, {\\"name\\": \\"Tom\\", \\"position\\": \\"Administrator\\", \\"salary\\": 55000} ] promotion_list = [ {\\"name\\": \\"Anna\\", \\"new_position\\": \\"Lead Developer\\", \\"new_salary\\": 95000}, {\\"name\\": \\"Tom\\", \\"new_position\\": \\"Lead Administrator\\", \\"new_salary\\": 75000} ] result = promote_employees(employee_list, promotion_list) expected_result = [ {\\"name\\": \\"Anna\\", \\"position\\": \\"Lead Developer\\", \\"salary\\": 95000}, {\\"name\\": \\"Tom\\", \\"position\\": \\"Lead Administrator\\", \\"salary\\": 75000} ] assert result == expected_result","solution":"def promote_employees(employee_list: list, promotion_list: list) -> list: Updates the employee_list with promotions based on the promotion_list. Parameters: - employee_list (list): A list of employee records with 'name', 'position', and 'salary'. - promotion_list (list): A list of promotions with 'name', 'new_position', and 'new_salary'. Returns: - list: The updated list of employee records after applying all promotions. # Convert employee_list to a dictionary for faster lookups employee_dict = {employee['name']: employee for employee in employee_list} # Apply promotions for promotion in promotion_list: name = promotion['name'] if name in employee_dict: employee_dict[name]['position'] = promotion['new_position'] employee_dict[name]['salary'] = promotion['new_salary'] # Convert back to list before returning return list(employee_dict.values())"},{"question":"from typing import List, Tuple def calculate_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: Calculates the Euclidean distance between two points. def nearest_neighbor_tsp(locations: List[Tuple[int, int]]) -> List[int]: Heuristic solution to find a TSP route using the nearest neighbor algorithm. Parameters: - locations: A list of (x, y) coordinates of delivery locations, with the depot as the first location. Returns: - A list of indices representing the order of locations visited, starting and ending at the depot. >>> nearest_neighbor_tsp([(0,0), (2,3), (5,4), (6,1), (8,2)]) [0, 1, 2, 3, 4, 0] >>> nearest_neighbor_tsp([(0,0)]) [0, 0] pass","solution":"import math from typing import List, Tuple def calculate_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def nearest_neighbor_tsp(locations: List[Tuple[int, int]]) -> List[int]: n = len(locations) if n == 1: return [0, 0] visited = [False] * n route = [0] # start at depot visited[0] = True current_location = 0 for _ in range(1, n): nearest_distance = float('inf') nearest_index = -1 for i in range(1, n): if not visited[i]: distance = calculate_distance(locations[current_location], locations[i]) if distance < nearest_distance: nearest_distance = distance nearest_index = i route.append(nearest_index) current_location = nearest_index visited[current_location] = True route.append(0) # return to depot return route"},{"question":"def merge_sorted_arrays(array1: list, array2: list) -> list: Merge two sorted arrays into a single sorted array. Args: array1 (list): A sorted list of integers. array2 (list): Another sorted list of integers. Returns: list: A merged and sorted list of integers. Example: >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 1, 3], [1, 2, 2, 4]) [1, 1, 1, 2, 2, 3, 4] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([2, 3, 5], []) [2, 3, 5] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([1, 2, 2], [2, 2, 3]) [1, 2, 2, 2, 2, 3] pass","solution":"def merge_sorted_arrays(array1, array2): Merges two sorted arrays into a single sorted array. Parameters: array1 (list): A sorted list of integers. array2 (list): Another sorted list of integers. Returns: list: A merged and sorted list of integers. merged_array = [] i, j = 0, 0 while i < len(array1) and j < len(array2): if array1[i] < array2[j]: merged_array.append(array1[i]) i += 1 else: merged_array.append(array2[j]) j += 1 while i < len(array1): merged_array.append(array1[i]) i += 1 while j < len(array2): merged_array.append(array2[j]) j += 1 return merged_array"},{"question":"def deep_flatten(nested_list: list) -> list: Flattens a nested list of arbitrary depth and returns a single list with all elements flattened. >>> deep_flatten([1, [2, [3, 4]], 5]) [1, 2, 3, 4, 5] >>> deep_flatten([[\\"a\\", [\\"b\\", \\"c\\"], []], \\"d\\"]) ['a', 'b', 'c', 'd'] >>> deep_flatten([]) [] >>> deep_flatten([1, [2, [], 3], [4, [5, 6]]]) [1, 2, 3, 4, 5, 6] pass def test_deep_flatten_single_level(): assert deep_flatten([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_deep_flatten_nested_levels(): assert deep_flatten([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5] assert deep_flatten([[\\"a\\", [\\"b\\", \\"c\\"], []], \\"d\\"]) == ['a', 'b', 'c', 'd'] assert deep_flatten([1, [2, [], 3], [4, [5, 6]]]) == [1, 2, 3, 4, 5, 6] def test_deep_flatten_empty_list(): assert deep_flatten([]) == [] def test_deep_flatten_mixed_data_types(): assert deep_flatten([1, [\\"a\\", [2.5]], [True, []], \\"end\\"]) == [1, 'a', 2.5, True, 'end'] def test_deep_flatten_deeply_nested(): assert deep_flatten([1, [2, [3, [4, [5, [6, []]]]]]]) == [1, 2, 3, 4, 5, 6] def test_deep_flatten_combined_elements(): assert deep_flatten([1, [[], [2, []], [3, [4]], [[], [5]]], [], 6]) == [1, 2, 3, 4, 5, 6]","solution":"def deep_flatten(nested_list): Flattens a nested list of arbitrary depth. Args: nested_list (list): A list which can contain nested lists of arbitrary depth. Returns: list: A flattened list. flat_list = [] for element in nested_list: if isinstance(element, list): flat_list.extend(deep_flatten(element)) else: flat_list.append(element) return flat_list"},{"question":"def quiz_game(): Run a simple command-line based quiz game with multiple-choice questions. The function prints questions and options, gets player's answers, calculates score, and prints the results. pass # Example of usage quiz_game()","solution":"def quiz_game(): questions = [ { \\"question\\": \\"What is the capital of France?\\", \\"choices\\": [\\"Paris\\", \\"London\\", \\"Berlin\\", \\"Madrid\\"], \\"answer\\": 1 }, { \\"question\\": \\"What is 2 + 2?\\", \\"choices\\": [\\"3\\", \\"4\\", \\"5\\", \\"6\\"], \\"answer\\": 2 }, { \\"question\\": \\"Which planet is known as the Red Planet?\\", \\"choices\\": [\\"Venus\\", \\"Saturn\\", \\"Mars\\", \\"Jupiter\\"], \\"answer\\": 3 }, { \\"question\\": \\"Who wrote 'Romeo and Juliet'?\\", \\"choices\\": [\\"William Shakespeare\\", \\"Charles Dickens\\", \\"Jane Austen\\", \\"Mark Twain\\"], \\"answer\\": 1 }, { \\"question\\": \\"What is the freezing point of water?\\", \\"choices\\": [\\"0 degrees Celsius\\", \\"32 degrees Fahrenheit\\", \\"Both A and B\\", \\"None of the above\\"], \\"answer\\": 3 } ] correct_answers = 0 print(\\"Welcome to the Quiz Game!\\") print(\\"You will be asked 5 questions. Please enter the number corresponding to your answer.\\") for i, q in enumerate(questions): print(f\\"nQuestion {i + 1}: {q['question']}\\") for idx, choice in enumerate(q[\\"choices\\"], 1): print(f\\"{idx}. {choice}\\") answer = int(input(\\"Your answer: \\")) if answer == q[\\"answer\\"]: correct_answers += 1 print(\\"nCongratulations! You have completed the quiz.\\") print(f\\"You got {correct_answers} out of {len(questions)} questions correct.\\") score_percentage = (correct_answers / len(questions)) * 100 print(f\\"Your score: {score_percentage:.2f}%\\")"},{"question":"def find_longest_unique_substring(s: str) -> str: Finds the longest substring that contains unique characters. >>> find_longest_unique_substring(\\"abcabcbb\\") 'abc' >>> find_longest_unique_substring(\\"bbbbb\\") 'b' >>> find_longest_unique_substring(\\"pwwkew\\") 'wke'","solution":"def find_longest_unique_substring(s): Finds and returns the longest substring with all unique characters. Args: s (str): The input string. Returns: str: The longest substring with unique characters. n = len(s) if n == 0: return \\"\\" left = 0 right = 0 max_length = 0 max_substring = \\"\\" char_set = set() while right < n: if s[right] not in char_set: char_set.add(s[right]) right += 1 if right - left > max_length: max_length = right - left max_substring = s[left:right] else: char_set.remove(s[left]) left += 1 return max_substring"},{"question":"def longest_common_subsequence(a: str, b: str) -> int: Returns the length of the longest common subsequence between two strings \`a\` and \`b\`. >>> longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABA\\") 4 >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> longest_common_subsequence(\\"\\", \\"ABC\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") 0 from solution import longest_common_subsequence def test_lcs_example1(): assert longest_common_subsequence(\\"ABCBDAB\\", \\"BDCABA\\") == 4 def test_lcs_example2(): assert longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") == 4 def test_lcs_empty_string(): assert longest_common_subsequence(\\"\\", \\"ABC\\") == 0 assert longest_common_subsequence(\\"ABC\\", \\"\\") == 0 def test_lcs_no_common_subsequence(): assert longest_common_subsequence(\\"ABC\\", \\"DEF\\") == 0 def test_lcs_same_strings(): assert longest_common_subsequence(\\"ABCD\\", \\"ABCD\\") == 4 def test_lcs_one_character_common(): assert longest_common_subsequence(\\"A\\", \\"A\\") == 1 assert longest_common_subsequence(\\"A\\", \\"B\\") == 0 def test_lcs_large_input(): str1 = \\"A\\" * 1000 str2 = \\"A\\" * 1000 assert longest_common_subsequence(str1, str2) == 1000","solution":"def longest_common_subsequence(a: str, b: str) -> int: Returns the length of the longest common subsequence between two strings \`a\` and \`b\`. m, n = len(a), len(b) dp = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if a[i-1] == b[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"def process_file(input_file: str, output_file: str) -> None: Reads lines from an input file, reverses the content of each line, converts it to uppercase, and writes the processed lines to an output file. >>> test_process_file(tmp_path) >>> test_empty_file(tmp_path) >>> test_single_line_file(tmp_path)","solution":"def process_file(input_file: str, output_file: str) -> None: Reads lines from an input file, reverses the content of each line, converts it to uppercase, and writes the processed lines to an output file. with open(input_file, 'r') as infile: lines = infile.readlines() processed_lines = [line.strip()[::-1].upper() + 'n' for line in lines] with open(output_file, 'w') as outfile: outfile.writelines(processed_lines)"},{"question":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merges two sorted arrays into a single sorted array. Example: >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([1, 3, 5], []) [1, 3, 5] >>> merge_sorted_arrays([], [2, 4, 6]) [2, 4, 6] pass def test_merge_sorted_arrays_normal_case(): assert merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) == [1, 2, 3, 4, 5, 6, 7, 8] def test_merge_sorted_arrays_one_empty(): assert merge_sorted_arrays([1, 3, 5], []) == [1, 3, 5] assert merge_sorted_arrays([], [2, 4, 6]) == [2, 4, 6] def test_merge_sorted_arrays_both_empty(): assert merge_sorted_arrays([], []) == [] def test_merge_sorted_arrays_single_element(): assert merge_sorted_arrays([1], [2]) == [1, 2] assert merge_sorted_arrays([2], [1]) == [1, 2] def test_merge_sorted_arrays_different_lengths(): assert merge_sorted_arrays([1, 2, 3], [4, 5, 6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8] assert merge_sorted_arrays([4, 5, 6, 7, 8], [1, 2, 3]) == [1, 2, 3, 4, 5, 6, 7, 8] def test_merge_sorted_arrays_with_duplicates(): assert merge_sorted_arrays([1, 2, 2], [2, 3, 4]) == [1, 2, 2, 2, 3, 4] assert merge_sorted_arrays([2, 2, 3], [1, 2, 4]) == [1, 2, 2, 2, 3, 4]","solution":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merges two sorted arrays into a single sorted array. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Append remaining elements from arr1 if any while i < len(arr1): merged.append(arr1[i]) i += 1 # Append remaining elements from arr2 if any while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"def compare_strings(s1: str, s2: str, custom_order: str) -> int: Compare two strings based on a custom dictionary order. >>> compare_strings(\\"apple\\", \\"banana\\", \\"zyxwvutsrqponmlkjihgfedcba\\") 1 >>> compare_strings(\\"cat\\", \\"car\\", \\"abcdefghijklmnopqrstuvwxyz\\") 1 >>> compare_strings(\\"dog\\", \\"dog\\", \\"abcdefghijklmnopqrstuvwxyz\\") 0","solution":"def compare_strings(s1: str, s2: str, custom_order: str) -> int: # Create a dictionary to store the custom order custom_index = {char: index for index, char in enumerate(custom_order)} # Get the length of the shorter string to avoid IndexError min_len = min(len(s1), len(s2)) # Compare character by character using the custom order for i in range(min_len): if s1[i] != s2[i]: if custom_index[s1[i]] < custom_index[s2[i]]: return -1 else: return 1 # If all characters matched so far, then the shorter string is less if len(s1) < len(s2): return -1 elif len(s1) > len(s2): return 1 else: return 0"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. :param s: The input string. :type s: str :return: The length of the longest substring with unique characters. :rtype: int >>> longest_unique_substring(\\"abcabcbb\\") == 3 >>> longest_unique_substring(\\"bbbbb\\") == 1 >>> longest_unique_substring(\\"pwwkew\\") == 3 >>> longest_unique_substring(\\"\\") == 0 >>> longest_unique_substring(\\"au\\") == 2 >>> longest_unique_substring(\\"@!@!@!\\") == 2 >>> longest_unique_substring(None) # raises ValueError >>> longest_unique_substring(12345) # raises ValueError # Implement the function here import pytest def test_longest_unique_substring_normal_cases(): assert longest_unique_substring(\\"abcabcbb\\") == 3 # \\"abc\\" assert longest_unique_substring(\\"bbbbb\\") == 1 # \\"b\\" assert longest_unique_substring(\\"pwwkew\\") == 3 # \\"wke\\" assert longest_unique_substring(\\"au\\") == 2 # \\"au\\" assert longest_unique_substring(\\"@!@!@!\\") == 2 # \\"@!\\" def test_longest_unique_substring_empty_string(): assert longest_unique_substring(\\"\\") == 0 def test_longest_unique_substring_non_string_input(): with pytest.raises(ValueError, match=\\"input must be a string\\"): longest_unique_substring(None) with pytest.raises(ValueError, match=\\"input must be a string\\"): longest_unique_substring(12345) def test_longest_unique_substring_edge_cases(): assert longest_unique_substring(\\"a\\") == 1 # \\"a\\" is the only character assert longest_unique_substring(\\"abcd\\") == 4 # \\"abcd\\" all characters are unique assert longest_unique_substring(\\"abcdabc\\") == 4 # \\"abcd\\" is the longest def test_longest_unique_substring_mixed_characters(): assert longest_unique_substring(\\"aAbBcCdD\\") == 8 # all characters are unique","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. :param s: The input string. :type s: str :return: The length of the longest substring with unique characters. :rtype: int if not isinstance(s, str): raise ValueError(\\"input must be a string\\") n = len(s) if n == 0: return 0 max_length = 0 start = 0 seen_chars = {} for end in range(n): if s[end] in seen_chars and seen_chars[s[end]] >= start: start = seen_chars[s[end]] + 1 seen_chars[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def longest_consecutive_bits(binary_string: str, bit: str) -> int: Returns the length of the longest sequence of consecutive occurrences of the specified bit in the binary string. >>> longest_consecutive_bits(\\"11011101111\\", '1') 4 >>> longest_consecutive_bits(\\"001100\\", '0') 2 >>> longest_consecutive_bits(\\"101010101010\\", '1') 1 >>> longest_consecutive_bits(\\"1111100000\\", '0') 5","solution":"def longest_consecutive_bits(binary_string: str, bit: str) -> int: Returns the length of the longest sequence of consecutive occurrences of the specified bit in the binary string. max_count = 0 current_count = 0 for char in binary_string: if char == bit: current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 return max_count"},{"question":"def rolling_window_sum(transactions: list[int], window_size: int) -> list[int]: Computes the sum of transaction amounts over a rolling window of specified size. Args: - transactions: A list of integers representing transaction amounts. - window_size: An integer representing the size of the rolling window. Returns: - A list of integers representing the rolling window sums. >>> rolling_window_sum([10, 20, 30, 40, 50], 3) [60, 90, 120] >>> rolling_window_sum([5, 15, 25, 35], 2) [20, 40, 60] >>> rolling_window_sum([8, 16, 24], 5) [48] >>> rolling_window_sum([1, 2, 3, 4, 5, 6], 6) [21] >>> rolling_window_sum([], 3) [] >>> rolling_window_sum([10], 1) [10] >>> rolling_window_sum([10], 2) [10] >>> rolling_window_sum([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5]","solution":"def rolling_window_sum(transactions, window_size): Computes the sum of transaction amounts over a rolling window of specified size. Args: - transactions: A list of integers representing transaction amounts. - window_size: An integer representing the size of the rolling window. Returns: - A list of integers representing the rolling window sums. if not transactions: return [] rolling_sum = [] current_window_sum = sum(transactions[:window_size]) rolling_sum.append(current_window_sum) for i in range(1, len(transactions) - window_size + 1): current_window_sum += transactions[i + window_size - 1] - transactions[i - 1] rolling_sum.append(current_window_sum) return rolling_sum"},{"question":"def max_consecutive_sum(arr: list[int], k: int) -> int: Computes the maximum sum of k consecutive elements in the array. Parameters: - arr: List of integers. - k: Number of consecutive elements to sum. Returns: - Integer, maximum sum of k consecutive elements. Examples: >>> max_consecutive_sum([1, 2, 3, 4, 5, 6], 2) 11 >>> max_consecutive_sum([4, -1, 2, 1, 6, -5, 3], 3) 9 >>> max_consecutive_sum([1, -2, -3, 4, -1, 2, 1, -5, 4], 4) 6 >>> max_consecutive_sum([-1, -2, -3, -4], 2) -3","solution":"def max_consecutive_sum(arr: list[int], k: int) -> int: Computes the maximum sum of k consecutive elements in the array. Parameters: - arr: List of integers. - k: Number of consecutive elements to sum. Returns: - Integer, maximum sum of k consecutive elements. n = len(arr) # Compute the sum of the first k elements max_sum = curr_sum = sum(arr[:k]) # Use sliding window to find max sum of any k consecutive elements for i in range(k, n): curr_sum += arr[i] - arr[i - k] if curr_sum > max_sum: max_sum = curr_sum return max_sum"},{"question":"def generate_fibonacci(n: int) -> list: Generate a list of the first \`n\` Fibonacci numbers. :param n: The number of Fibonacci numbers to generate (must be non-negative integer) :return: List containing the first \`n\` Fibonacci numbers :raises ValueError: If \`n\` is negative. :raises TypeError: If \`n\` is not an integer. >>> generate_fibonacci(0) [] >>> generate_fibonacci(1) [0] >>> generate_fibonacci(5) [0, 1, 1, 2, 3] >>> generate_fibonacci(-1) Traceback (most recent call last): ... ValueError: Length of Fibonacci sequence can't be negative. >>> generate_fibonacci('five') Traceback (most recent call last): ... TypeError: The length of the Fibonacci sequence must be an integer.","solution":"def generate_fibonacci(n: int) -> list: Generate a list of the first n Fibonacci numbers. :param n: The number of Fibonacci numbers to generate (must be non-negative integer) :return: List containing the first n Fibonacci numbers if not isinstance(n, int): raise TypeError(\\"The length of the Fibonacci sequence must be an integer.\\") if n < 0: raise ValueError(\\"Length of Fibonacci sequence can't be negative.\\") if n == 0: return [] elif n == 1: return [0] fibonacci_sequence = [0, 1] for i in range(2, n): fibonacci_sequence.append(fibonacci_sequence[-1] + fibonacci_sequence[-2]) return fibonacci_sequence[:n]"},{"question":"from typing import Dict, List def has_cycle(graph: Dict[int, List[int]]) -> bool: Detect cycles in an undirected graph. An undirected graph is represented as an adjacency list. A cycle in an undirected graph is a path that starts and ends at the same vertex, with all edges and vertices distinct (except the starting and ending vertex). Parameters: graph (Dict[int, List[int]]): A dictionary where the keys are integers representing nodes, and the values are lists of integers representing the neighboring nodes. Returns: bool: True if the graph contains a cycle, False otherwise. Examples: >>> has_cycle({ ... 0: [1, 2], ... 1: [0, 2], ... 2: [0, 1, 3], ... 3: [2], ... }) True >>> has_cycle({ ... 0: [1], ... 1: [0, 2], ... 2: [1, 3], ... 3: [2], ... }) False # Your implementation here def test_graph_with_cycle(): graph_1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } assert has_cycle(graph_1) == True def test_graph_without_cycle(): graph_2 = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } assert has_cycle(graph_2) == False def test_empty_graph(): graph_3 = {} assert has_cycle(graph_3) == False def test_single_node_without_edges(): graph_4 = { 0: [] } assert has_cycle(graph_4) == False def test_single_node_with_self_loop(): graph_5 = { 0: [0] } assert has_cycle(graph_5) == True def test_complex_graph_with_multiple_cycles(): graph_6 = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3, 5], 5: [4, 6], 6: [5] } assert has_cycle(graph_6) == True print(\\"All tests passed.\\")","solution":"def has_cycle(graph): def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, None): return True return False"},{"question":"from typing import List def prime_factors(n: int) -> List[int]: Determine all the prime factors of a given integer. >>> prime_factors(60) [2, 2, 3, 5] >>> prime_factors(13195) [5, 7, 13, 29] >>> prime_factors(17) [17] >>> prime_factors(1009) [1009]","solution":"from typing import List def prime_factors(n: int) -> List[int]: factors = [] # Divide by 2 until n is no longer even while n % 2 == 0: factors.append(2) n //= 2 # Check for odd factors from 3 upwards factor = 3 while factor * factor <= n: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # If remaining n is a prime factor greater than 2 if n > 2: factors.append(n) return factors"},{"question":"from typing import List def strassen_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Perform matrix multiplication using the Strassen algorithm. Parameters: A (List[List[int]]): The first matrix as a list of lists, where each inner list represents a row. B (List[List[int]]): The second matrix with appropriate dimensions for matrix multiplication. Returns: List[List[int]]: The resultant matrix after performing Strassen's matrix multiplication. Examples: >>> A = [ [1, 0], [0, 1] ] >>> B = [ [4, 1], [2, 2] ] >>> strassen_matrix_multiplication(A, B) [[4, 1], [2, 2]] >>> A = [ [1, 2], [3, 4] ] >>> B = [ [5, 6], [7, 8] ] >>> strassen_matrix_multiplication(A, B) [[19, 22], [43, 50]] def test_strassen_example1(): A = [ [1, 0], [0, 1] ] B = [ [4, 1], [2, 2] ] expected = [ [4, 1], [2, 2] ] assert strassen_matrix_multiplication(A, B) == expected def test_strassen_example2(): A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] expected = [ [19, 22], [43, 50] ] assert strassen_matrix_multiplication(A, B) == expected def test_strassen_identity(): A = [ [1, 0], [0, 1] ] B = [ [1, 2], [3, 4] ] expected = [ [1, 2], [3, 4] ] assert strassen_matrix_multiplication(A, B) == expected def test_strassen_zeros(): A = [ [0, 0], [0, 0] ] B = [ [1, 2], [3, 4] ] expected = [ [0, 0], [0, 0] ] assert strassen_matrix_multiplication(A, B) == expected def test_strassen_large(): A = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] B = [ [17, 18, 19, 20], [21, 22, 23, 24], [25, 26, 27, 28], [29, 30, 31, 32] ] expected = [ [250, 260, 270, 280], [618, 644, 670, 696], [986, 1028, 1070, 1112], [1354, 1412, 1470, 1528] ] assert strassen_matrix_multiplication(A, B) == expected","solution":"from typing import List def add_matrices(A, B): return [[A[i][j] + B[i][j] for j in range(len(A))] for i in range(len(A))] def subtract_matrices(A, B): return [[A[i][j] - B[i][j] for j in range(len(A))] for i in range(len(A))] def split_matrix(M): mid = len(M) // 2 A11 = [row[:mid] for row in M[:mid]] A12 = [row[mid:] for row in M[:mid]] A21 = [row[:mid] for row in M[mid:]] A22 = [row[mid:] for row in M[mid:]] return A11, A12, A21, A22 def strassen_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if len(A) == 1: # Base case: 1x1 matrix return [[A[0][0] * B[0][0]]] # Split matrices A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) # Calculate intermediate matrices using Strassen's formula M1 = strassen_matrix_multiplication(add_matrices(A11, A22), add_matrices(B11, B22)) M2 = strassen_matrix_multiplication(add_matrices(A21, A22), B11) M3 = strassen_matrix_multiplication(A11, subtract_matrices(B12, B22)) M4 = strassen_matrix_multiplication(A22, subtract_matrices(B21, B11)) M5 = strassen_matrix_multiplication(add_matrices(A11, A12), B22) M6 = strassen_matrix_multiplication(subtract_matrices(A21, A11), add_matrices(B11, B12)) M7 = strassen_matrix_multiplication(subtract_matrices(A12, A22), add_matrices(B21, B22)) # Build the resulting matrix C11 = add_matrices(subtract_matrices(add_matrices(M1, M4), M5), M7) C12 = add_matrices(M3, M5) C21 = add_matrices(M2, M4) C22 = add_matrices(subtract_matrices(add_matrices(M1, M3), M2), M6) # Combine into a single result matrix n = len(C11) C = [[0] * (2 * n) for _ in range(2 * n)] for i in range(n): for j in range(n): C[i][j] = C11[i][j] C[i][j + n] = C12[i][j] C[i + n][j] = C21[i][j] C[i + n][j + n] = C22[i][j] return C"},{"question":"def disk_utilization_simulator(initial_utilizations: list, daily_changes: list, days: int) -> list: Simulate the disk utilization over a period, given a list of starting utilization percentages, a list of daily utilization changes, and the total number of days for the simulation. >>> disk_utilization_simulator([70, 50, 80], [2, -1, 0, 3, -4], 3) [76, 47, 86] >>> disk_utilization_simulator([50, 75, 25], [0, 0, 0], 3) [50, 75, 25] >>> disk_utilization_simulator([10, 10, 10], [10, 10, 10], 3) [40, 40, 40] >>> disk_utilization_simulator([60, 50, 40], [-5, -5, -5], 2) [50, 40, 30] >>> disk_utilization_simulator([90, 95, 85], [15, 10, 10], 3) [100, 100, 100] >>> disk_utilization_simulator([5, 10, 15], [-10, -10, -10], 3) [0, 0, 0] >>> disk_utilization_simulator([50, 50, 50], [10, -5, 20, -50], 4) [25, 25, 25]","solution":"def disk_utilization_simulator(initial_utilizations: list, daily_changes: list, days: int) -> list: final_utilizations = initial_utilizations.copy() for day in range(days): for i in range(len(final_utilizations)): final_utilizations[i] += daily_changes[day] final_utilizations[i] = max(0, min(100, final_utilizations[i])) return final_utilizations"},{"question":"def detect_cycles(graph: dict[int, list[int]]) -> list[list[int]]: Detect all cycles in a directed graph represented as an adjacency list. >>> detect_cycles({ 0: [1], 1: [2], 2: [0] }) [[0, 1, 2, 0]] >>> detect_cycles({ 0: [1], 1: [2], 2: [3] }) [] >>> detect_cycles({ 0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [5], 5: [3] }) [[0, 1, 2, 0], [3, 4, 5, 3]] >>> detect_cycles({}) [] >>> detect_cycles({ 0: [1], 1: [2], 2: [0], 3: [4, 5], 4: [3], 5: [] }) [[0, 1, 2, 0], [3, 4, 3]] >>> detect_cycles({ 0: [0] }) [[0, 0]] pass","solution":"def detect_cycles(graph): def dfs(v, stack): stack_index[v] = len(stack) stack.append(v) visited[v] = True for neighbor in graph.get(v, []): if not visited.get(neighbor, False): dfs(neighbor, stack) elif stack_index.get(neighbor, None) is not None: cycle_start_index = stack_index[neighbor] cycles.append(stack[cycle_start_index:] + [neighbor]) stack.pop() stack_index[v] = None visited = {} stack_index = {} cycles = [] for vertex in graph: if not visited.get(vertex, False): dfs(vertex, []) unique_cycles = [] for cycle in cycles: if cycle[::-1] not in unique_cycles: unique_cycles.append(cycle) return unique_cycles"},{"question":"def longest_dup_substring(s: str) -> str: Find the longest duplicated substring in the given string. >>> longest_dup_substring(\\"banana\\") \\"ana\\" >>> longest_dup_substring(\\"abcd\\") \\"\\" >>> longest_dup_substring(\\"abcabc\\") \\"abc\\"","solution":"def longest_dup_substring(s: str) -> str: def search(k): Search for a duplicate substring of length k using rolling hash. MOD = 2**63 - 1 BASE = 26 # Rolling hash with base 26 h = 0 for i in range(k): h = (h * BASE + ord(s[i]) - ord('a')) % MOD # Set to store seen hashes seen = {h} power = pow(BASE, k, MOD) # BASE^k % MOD for i in range(1, len(s) - k + 1): h = (h * BASE + ord(s[i + k - 1]) - ord('a')) % MOD h = (h - (ord(s[i - 1]) - ord('a')) * power) % MOD if h in seen: return i seen.add(h) return -1 # Binary search for the length of the longest duplicate substring left, right = 1, len(s) start = -1 while left <= right: mid = (left + right) // 2 pos = search(mid) if pos != -1: start = pos left = mid + 1 else: right = mid - 1 return s[start:start + left - 1] if start != -1 else \\"\\""},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode | None, headB: ListNode | None) -> ListNode | None: Determine if two linked lists intersect and return the intersection node. The intersection is defined based on the reference, not the value of the nodes. Args: headA (ListNode): The head node of the first linked list. headB (ListNode): The head node of the second linked list. Returns: ListNode: The node at which the intersection of the two linked lists begins, or None if there is no intersection. >>> headA = ListNode(1) >>> headA.next = ListNode(2) >>> common = ListNode(6) >>> common.next = ListNode(7) >>> common.next.next = ListNode(8) >>> headA.next.next = common >>> headB = ListNode(3) >>> headB.next = common >>> get_intersection_node(headA, headB).val 6 >>> headA = ListNode(1) >>> headA.next = ListNode(2) >>> headA.next.next = ListNode(3) >>> headB = ListNode(4) >>> headB.next = ListNode(5) >>> headB.next.next = ListNode(6) >>> get_intersection_node(headA, headB) is None True >>> get_intersection_node(None, None) is None True >>> headA = ListNode(1) >>> headA.next = ListNode(2) >>> headA.next.next = ListNode(3) >>> get_intersection_node(headA, None) is None True >>> get_intersection_node(None, headA) is None True pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode | None, headB: ListNode | None) -> ListNode | None: if not headA or not headB: return None pointerA, pointerB = headA, headB while pointerA is not pointerB: # Move to the next nodes or switch lists pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA"},{"question":"def decode_message(message: str, length_to_reverse: int) -> str: Decodes the message by reversing words of the specified length. Parameters: message (str): The string of words separated by spaces. length_to_reverse (int): The length of words that should be reversed. Returns: str: The decoded message with appropriate words reversed. >>> decode_message(\\"this is a secret message\\", 6) 'this is a terces message' >>> decode_message(\\"coding is fun\\", 2) 'coding si fun' >>> decode_message(\\"hello world\\", 5) 'olleh dlrow'","solution":"def decode_message(message: str, length_to_reverse: int) -> str: Decodes the message by reversing words of the specified length. Parameters: message (str): The string of words separated by spaces. length_to_reverse (int): The length of words that should be reversed. Returns: str: The decoded message with appropriate words reversed. decoded_words = [] words = message.split() for word in words: if len(word) == length_to_reverse: decoded_words.append(word[::-1]) else: decoded_words.append(word) return ' '.join(decoded_words)"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def level_sum(root: Optional[TreeNode]) -> List[int]: Calculate the sum of values at each level of a binary tree. Returns a list containing the sum for each level. Parameters: root (TreeNode): The root node of the binary tree. Returns: List[int]: A list where each element represents the sum of values at that level of the tree. Examples: >>> tree = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> level_sum(tree) [1, 5, 15] >>> tree = TreeNode(5, TreeNode(3, TreeNode(2)), TreeNode(8)) >>> level_sum(tree) [5, 11, 2] >>> tree = None >>> level_sum(tree) []","solution":"from typing import Optional, List from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def level_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = deque([root]) result = [] while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"def is_shift_overlapping(new_shift: tuple, existing_shifts: list) -> bool: Determine if a new shift overlaps with any existing shifts on a given day. >>> is_shift_overlapping((9, 17), [(8, 12), (13, 18)]) True >>> is_shift_overlapping((7, 9), [(10, 12), (14, 18)]) False >>> is_shift_overlapping((12, 20), [(8, 11), (11, 12)]) False >>> is_shift_overlapping((15, 19), [(14, 16), (18, 22)]) True >>> is_shift_overlapping((10, 12), [(8, 10), (11, 13)]) True","solution":"def is_shift_overlapping(new_shift, existing_shifts): Determine if a new shift overlaps with any existing shifts. Args: - new_shift (tuple): A tuple containing the start and end time of the new shift. - existing_shifts (list): A list of tuples, each containing the start and end time of existing shifts. Returns: - bool: True if the new shift overlaps with any existing shifts, otherwise False. new_start, new_end = new_shift # Validate the provided shift times if not (0 <= new_start <= 23 and 0 <= new_end <= 23): raise ValueError(\\"Shift times must be within the 24-hour range.\\") if new_start >= new_end: raise ValueError(\\"Start time must be less than end time.\\") for shift in existing_shifts: existing_start, existing_end = shift # Validate the existing shift times if not (0 <= existing_start <= 23 and 0 <= existing_end <= 23): raise ValueError(\\"Shift times must be within the 24-hour range.\\") if existing_start >= existing_end: raise ValueError(\\"Start time must be less than end time.\\") # Check for overlap if new_start < existing_end and new_end > existing_start: return True return False"},{"question":"def max_subarray_sum(nums: list) -> int: Finds the maximum sum of any subarray of the given list of integers. Args: nums: list of integers. Returns: An integer representing the maximum sum of any subarray within the given list. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5, 4, -1, 7, 8]) 23 from solution import max_subarray_sum def test_example_1(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_example_2(): assert max_subarray_sum([1]) == 1 def test_example_3(): assert max_subarray_sum([-1, -2, -3, -4]) == -1 def test_example_4(): assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 def test_empty_list(): assert max_subarray_sum([]) == 0 def test_single_negative_element(): assert max_subarray_sum([-5]) == -5 def test_all_positive(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_positive_and_negative(): assert max_subarray_sum([2, -1, 2, 3, 4, -5]) == 10","solution":"def max_subarray_sum(nums): Finds the maximum sum of any subarray of the given list of integers. Args: nums: list of integers. Returns: An integer representing the maximum sum of any subarray within the given list. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"class DocumentVersionControl: def __init__(self): Initialize the DocumentVersionControl with an empty dictionary to store document version histories. self.documents = {} def commit(self, doc_id: str, content: str) -> int: Saves the current state of a document as a new version. :param doc_id: The unique identifier of the document. :param content: The current content of the document to be saved. :return: The new version number. def rollback(self, doc_id: str, version: int) -> None: Reverts the document to the specified version. :param doc_id: The unique identifier of the document. :param version: The version number to which the document should be reverted. :return: None def get_current_content(self, doc_id: str) -> str: Retrieves the current content of the document. :param doc_id: The unique identifier of the document. :return: The current content of the document. import pytest from solution import DocumentVersionControl def test_commit(): version_control = DocumentVersionControl() assert version_control.commit('doc1', 'Initial content') == 0 assert version_control.commit('doc1', 'Updated content') == 1 def test_rollback(): version_control = DocumentVersionControl() version_control.commit('doc1', 'Initial content') version_control.commit('doc1', 'Updated content') version_control.rollback('doc1', 0) assert version_control.get_current_content('doc1') == 'Initial content' def test_get_current_content_non_existent_doc(): version_control = DocumentVersionControl() assert version_control.get_current_content('doc2') == None def test_rollback_multiple_versions(): version_control = DocumentVersionControl() version_control.commit('doc1', 'Version 0') version_control.commit('doc1', 'Version 1') version_control.commit('doc1', 'Version 2') version_control.rollback('doc1', 1) assert version_control.get_current_content('doc1') == 'Version 1' version_control.rollback('doc1', 0) assert version_control.get_current_content('doc1') == 'Version 0' def test_commit_different_docs(): version_control = DocumentVersionControl() version_control.commit('doc1', 'Doc1 - Initial content') version_control.commit('doc2', 'Doc2 - Initial content') version_control.commit('doc1', 'Doc1 - Updated content') assert version_control.get_current_content('doc1') == 'Doc1 - Updated content' assert version_control.get_current_content('doc2') == 'Doc2 - Initial content'","solution":"class DocumentVersionControl: def __init__(self): self.documents = {} def commit(self, doc_id, content): if doc_id not in self.documents: self.documents[doc_id] = [] version = len(self.documents[doc_id]) self.documents[doc_id].append({'version': version, 'content': content}) return version def rollback(self, doc_id, version): if doc_id in self.documents and 0 <= version < len(self.documents[doc_id]): self.documents[doc_id] = self.documents[doc_id][:version + 1] def get_current_content(self, doc_id): if doc_id in self.documents and self.documents[doc_id]: return self.documents[doc_id][-1]['content'] return None"},{"question":"def count_substring_occurrences(sentence: str, substring: str) -> int: Determine the number of times the substring appears in the sentence. Counting should be case-sensitive and handle overlapping substrings. >>> count_substring_occurrences(\\"hello world\\", \\"o\\") 2 >>> count_substring_occurrences(\\"hello world\\", \\"l\\") 3 >>> count_substring_occurrences(\\"hello world\\", \\"lo\\") 1 >>> count_substring_occurrences(\\"hello world\\", \\"abc\\") 0 >>> count_substring_occurrences(\\"abababab\\", \\"ab\\") 4 >>> count_substring_occurrences(\\"\\", \\"a\\") 0 >>> count_substring_occurrences(\\"abc\\", \\"\\") 0 pass","solution":"def count_substring_occurrences(sentence: str, substring: str) -> int: Returns the number of times the substring appears in the sentence. This includes overlapping substrings. if not sentence or not substring: return 0 count = 0 start = 0 while True: start = sentence.find(substring, start) if start == -1: break count += 1 # Move to the next character after the current found substring start += 1 return count"},{"question":"from typing import List def count_islands(height_map: List[List[int]]) -> int: Count the number of distinct islands on the grid where an island is identified by connected cells of the same height. Args: height_map : List[List[int]] : 2D list where each element represents the height at a specific cell in the grid. Returns: int : Number of distinct islands in the height map. >>> count_islands([[1, 2, 2, 3], [1, 2, 2, 3], [1, 1, 1, 3], [4, 4, 4, 4]]) 4 >>> count_islands([[1]]) 1 >>> count_islands([]) 0 >>> count_islands([[1, 2], [3, 4]]) 4 >>> count_islands([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> count_islands([[1, 1, 2], [2, 3, 3], [3, 3, 3]]) 4","solution":"from typing import List def count_islands(height_map: List[List[int]]) -> int: def dfs(x, y, h): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny] and height_map[nx][ny] == h: visited[nx][ny] = True stack.append((nx, ny)) if not height_map: return 0 rows, cols = len(height_map), len(height_map[0]) visited = [[False] * cols for _ in range(rows)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] islands_count = 0 for i in range(rows): for j in range(cols): if not visited[i][j]: islands_count += 1 visited[i][j] = True dfs(i, j, height_map[i][j]) return islands_count"},{"question":"from typing import List def trapRainWater(heights: List[int]) -> int: Calculate the total amount of water trapped in a landscape represented by a list of elevations >>> trapRainWater([0, 1, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 5 >>> trapRainWater([4, 2, 0, 3, 2, 5]) == 9 >>> trapRainWater([2, 1, 2]) == 1 >>> trapRainWater([5, 4, 1, 2]) == 1 >>> trapRainWater([1, 1, 1, 1]) == 0 >>> trapRainWater([]) == 0","solution":"from typing import List def trapRainWater(heights: List[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += right_max - heights[right] return water_trapped"},{"question":"class Library: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str, author: str) -> None: Adds a book with the given id, title and author to the library collection. If the book_id already exists, it will not add the book again. pass def get_book(self, book_id: int) -> dict: Retrieves the details of a book by its identifier. Returns a dictionary containing the book's information if found, otherwise an empty dictionary. pass def get_all_books_sorted_by_title(self) -> list: Retrieves a list of all books sorted alphabetically by their titles. Each book is represented as a dictionary containing its id, title, and author. pass from solution import Library def test_add_and_get_book(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") assert library.get_book(1) == {'id': 1, 'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald'} def test_add_duplicate_book(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") assert len(library.books) == 1 def test_get_nonexistent_book(): library = Library() assert library.get_book(999) == {} def test_get_all_books_sorted_by_title(): library = Library() library.add_book(1, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.add_book(3, \\"1984\\", \\"George Orwell\\") sorted_books = library.get_all_books_sorted_by_title() expected_result = [ {'id': 3, 'title': '1984', 'author': 'George Orwell'}, {'id': 1, 'title': 'The Great Gatsby', 'author': 'F. Scott Fitzgerald'}, {'id': 2, 'title': 'To Kill a Mockingbird', 'author': 'Harper Lee'} ] assert sorted_books == expected_result def test_add_and_get_multiple_books(): library = Library() library.add_book(1, \\"Harry Potter\\", \\"J.K. Rowling\\") library.add_book(2, \\"The Hobbit\\", \\"J.R.R. Tolkien\\") assert library.get_book(1) == {'id': 1, 'title': 'Harry Potter', 'author': 'J.K. Rowling'} assert library.get_book(2) == {'id': 2, 'title': 'The Hobbit', 'author': 'J.R.R. Tolkien'}","solution":"class Library: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str, author: str) -> None: Adds a book with the given id, title and author to the library collection. If the book_id already exists, it will not add the book again. if book_id not in self.books: self.books[book_id] = {'id': book_id, 'title': title, 'author': author} def get_book(self, book_id: int) -> dict: Retrieves the details of a book by its identifier. Returns a dictionary containing the book's information if found, otherwise an empty dictionary. return self.books.get(book_id, {}) def get_all_books_sorted_by_title(self) -> list: Retrieves a list of all books sorted alphabetically by their titles. Each book is represented as a dictionary containing its id, title, and author. return sorted(self.books.values(), key=lambda x: x['title'])"},{"question":"from typing import List def correct_spelling(text: str, dictionary: List[str]) -> str: Corrects common spelling errors in a given text by replacing any misspelled word with the most similar correct word from the dictionary. >>> correct_spelling('thes is an exmple', ['this', 'is', 'an', 'example']) 'this is an example' >>> correct_spelling('the quick bron fox jumps ovor the lazy dog', ['the', 'quick', 'brown', 'fox', 'jumps', 'over', 'lazy', 'dog']) 'the quick brown fox jumps over the lazy dog' pass","solution":"from typing import List from difflib import get_close_matches def correct_spelling(text: str, dictionary: List[str]) -> str: Corrects common spelling errors in a given text by replacing any misspelled word with the most similar correct word from the dictionary. words = text.split() corrected_words = [] for word in words: if word in dictionary: corrected_words.append(word) else: # Find the closest match from the dictionary using the get_close_matches function closest_matches = get_close_matches(word, dictionary, n=1, cutoff=0.6) if closest_matches: corrected_words.append(closest_matches[0]) else: corrected_words.append(word) # If no close match found, keep the original word corrected_text = ' '.join(corrected_words) return corrected_text"},{"question":"def is_palindrome(sentence: str) -> bool: Given a sentence, return True if it is a palindrome, False otherwise. A valid palindrome sentence ignores non-alphabetic characters and is case-insensitive. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"Race Car!\\") True >>> is_palindrome(\\"Hello, World!\\") False from solution import is_palindrome def test_palindrome_with_special_characters(): assert is_palindrome(\\"A man, a plan, a canal, Panama\\") == True def test_palindrome_with_spaces_and_exclamations(): assert is_palindrome(\\"Race Car!\\") == True def test_non_palindrome_sentence(): assert is_palindrome(\\"Hello, World!\\") == False def test_empty_string(): assert is_palindrome(\\"\\") == True def test_single_character(): assert is_palindrome(\\"a\\") == True assert is_palindrome(\\"Z\\") == True def test_palindrome_with_mixed_case(): assert is_palindrome(\\"No 'x' in Nixon\\") == True def test_palindrome_with_only_non_alphabetic_characters(): assert is_palindrome(\\"!!!...,,,\\") == True def test_non_palindrome_with_non_alphabetic_characters(): assert is_palindrome(\\"Python Programming 12345\\") == False","solution":"def is_palindrome(sentence: str) -> bool: Given a sentence, return True if it is a palindrome, False otherwise. A valid palindrome sentence ignores non-alphabetic characters and is case-insensitive. # Filter out non-alphabetic characters and convert to lowercase filtered_sentence = ''.join(filter(str.isalpha, sentence)).lower() # Check if the filtered sentence reads the same backward return filtered_sentence == filtered_sentence[::-1]"},{"question":"from typing import List, Tuple, Optional def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Finds the first pair of integers from the list that add up to the given target sum. :param nums: List[int] - A list of integers. :param target: int - The target sum. :return: Optional[Tuple[int, int]] - The first pair of integers that add up to the target sum, or None if no such pair exists. Examples: >>> find_pair_with_sum([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None Additional Test Case: >>> find_pair_with_sum([-1, 0, 1, 2, -1, -4], -1) (-1, 0) Edge Cases: >>> find_pair_with_sum([], 5) None >>> find_pair_with_sum([5], 5) None","solution":"def find_pair_with_sum(nums, target): Finds the first pair of integers in the list \`nums\` that add up to \`target\`. Returns the pair as a tuple. If no such pair exists, returns None. :param nums: List[int] - A list of integers. :param target: int - The target sum. :return: tuple or None seen = set() for num in nums: complement = target - num if complement in seen: return (complement, num) seen.add(num) return None"},{"question":"def longest_shared_substr(s1: str, s2: str) -> str: Finds the longest common substring between two given strings. >>> longest_shared_substr(\\"powerful\\", \\"wonderful\\") 'erful' >>> longest_shared_substr(\\"abcba\\", \\"abcbcba\\") 'abc' >>> longest_shared_substr(\\"abc\\", \\"abc\\") 'abc' >>> longest_shared_substr(\\"abc\\", \\"def\\") '' >>> longest_shared_substr(\\"abc\\", \\"xyzabc\\") 'abc' >>> result = longest_shared_substr(\\"powerful\\", \\"wonderful\\") >>> result == \\"erful\\" or result == \\"power\\" True >>> longest_shared_substr(\\"abcxyz\\", \\"xyz\\") 'xyz' >>> s1 = \\"a\\" * 100 + \\"xyz\\" + \\"b\\" * 100 >>> s2 = \\"c\\" * 50 + \\"xyz\\" + \\"d\\" * 50 >>> longest_shared_substr(s1, s2) 'xyz'","solution":"def longest_shared_substr(s1: str, s2: str) -> str: Finds the longest common substring between two given strings. Caution: This is a brute force solution with time complexity O(n^3), suitable for small strings. len_s1, len_s2 = len(s1), len(s2) max_len = 0 end = 0 dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)] for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] end = i return s1[end - max_len: end]"},{"question":"def time_until_collision(pos1: float, vel1: float, pos2: float, vel2: float) -> float: Compute the time in seconds until two particles moving in one-dimensional space collide. Parameters: pos1 (float): Initial position of the first particle. vel1 (float): Velocity of the first particle. pos2 (float): Initial position of the second particle. vel2 (float): Velocity of the second particle. Returns: float: Time in seconds until the particles collide. Raises: ValueError: If velocities are equal and positions are different; indicating no collision is possible. Examples: >>> time_until_collision(0, 2, 10, -3) 2.0 >>> time_until_collision(0, 1, 0, -1) 0.0 >>> time_until_collision(0, 1, 10, 1) Traceback (most recent call last): ... ValueError: Velocities are equal and positions are different; no collision possible.","solution":"def time_until_collision(pos1: float, vel1: float, pos2: float, vel2: float) -> float: if vel1 == vel2: if pos1 != pos2: raise ValueError(\\"Velocities are equal and positions are different; no collision possible.\\") return 0.0 # If velocities and positions are the same, they are already at the same position. collision_time = (pos2 - pos1) / (vel1 - vel2) return max(collision_time, 0.0) # collision_time cannot be negative"},{"question":"from typing import List def merge_lists(*lists: List[int]) -> List[int]: Merge multiple lists into one list without duplicates, maintaining the order of their first occurrence. >>> merge_lists([1, 2, 3], [3, 4, 5], [6, 7, 1]) [1, 2, 3, 4, 5, 6, 7] >>> merge_lists([10, 20, 30], [30, 20, 10], [40, 50]) [10, 20, 30, 40, 50] >>> merge_lists([1, 1, 1], [1, 1], [1]) [1] >>> merge_lists([1, 2, 3], [], [4, 5], [6, 7, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_lists([]) []","solution":"def merge_lists(*lists): Merges multiple lists into a single list without duplicates, preserving the order of the first occurrence of each element. Parameters: lists: A variable number of lists containing integers. Returns: A list of integers with unique elements, maintaining the order of their first appearance. seen = set() result = [] for lst in lists: for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"def find_shortest_subarray(arr: list) -> int: Finds the length of the shortest subarray, that when sorted, results in the entire array being sorted. >>> find_shortest_subarray([2, 6, 4, 8, 10, 9, 15]) 5 >>> find_shortest_subarray([1, 2, 3, 4]) 0 >>> find_shortest_subarray([1, 3, 5, 2, 4, 6]) 4","solution":"def find_shortest_subarray(arr: list) -> int: Finds the length of the shortest subarray, that when sorted, results in the entire array being sorted. sorted_arr = sorted(arr) n = len(arr) # Check if the array is already sorted if arr == sorted_arr: return 0 left = 0 while left < n and arr[left] == sorted_arr[left]: left += 1 right = n - 1 while right >= 0 and arr[right] == sorted_arr[right]: right -= 1 return right - left + 1"},{"question":"def rotate_list(nums: list, k: int) -> list: Rotates a given list to the right by k steps. Args: nums (list): A list of integers. k (int): A non-negative integer indicating the number of steps to rotate the list to the right. Returns: list: The rotated list. Raises: ValueError: If k is negative or any element within nums is not an integer. TypeError: If nums is not a list or k is not an integer. Examples: >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([0, 12, 45, 78], 3) [12, 45, 78, 0] >>> rotate_list([99, 15, 25], 1) [25, 99, 15] >>> rotate_list([], 3) [] >>> rotate_list([5], 5) [5] >>> rotate_list([4, 3, 2], 0) [4, 3, 2] import pytest def test_positive_rotation(): assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([0, 12, 45, 78], 3) == [12, 45, 78, 0] assert rotate_list([99, 15, 25], 1) == [25, 99, 15] assert rotate_list([4, 3, 2], 0) == [4, 3, 2] def test_single_element(): assert rotate_list([5], 5) == [5] def test_empty_list(): assert rotate_list([], 3) == [] def test_large_k(): assert rotate_list([1, 2, 3], 4) == [3, 1, 2] # k is larger than the list size def test_invalid_k_value_error(): with pytest.raises(ValueError): rotate_list([1, 2, 3], -1) def test_invalid_nums_value_error(): with pytest.raises(ValueError): rotate_list([1, 2, '3'], 2) def test_invalid_nums_type_error(): with pytest.raises(TypeError): rotate_list('123', 3) def test_invalid_k_type_error(): with pytest.raises(TypeError): rotate_list([1, 2, 3], '2')","solution":"def rotate_list(nums: list, k: int) -> list: # Validate input types if not isinstance(nums, list): raise TypeError(\\"nums must be a list of integers\\") if not isinstance(k, int): raise TypeError(\\"k must be an integer\\") # Check if k is non-negative if k < 0: raise ValueError(\\"k must be a non-negative integer\\") # Check if all elements in nums are integers if not all(isinstance(x, int) for x in nums): raise ValueError(\\"All elements in nums must be integers\\") # Handle the rotation n = len(nums) if n == 0: return nums # Return the empty list as is k = k % n # In case k is larger than the list length return nums[-k:] + nums[:-k]"},{"question":"from typing import List def maximize_storage(bins: List[int], max_bins: int) -> int: Computes the maximum number of units that can fit into the specified number of bins. Parameters: bins (List[int]): List of integers representing the unit capacities of different bins. max_bins (int): Integer representing the maximum number of bins that can be used. Returns: int: Maximum number of units that can be stored using the most efficient selection of bins. Raises: ValueError: If max_bins is greater than the length of bins or less than 1. TypeError: If bins contain non-integer values. Examples: >>> maximize_storage([3, 6, 2, 8, 7, 4], 3) 21 >>> maximize_storage([10, 20, 5, 5, 5], 2) 30 >>> maximize_storage([15, 8, 7, 14, 6], 5) 50 >>> maximize_storage([1, 2, 3, 4, 5], 10) Traceback (most recent call last): ... ValueError: max_bins should be in the range of 1 to len(bins) >>> maximize_storage([3, 6, 'a', 8], 2) Traceback (most recent call last): ... TypeError: All bin capacities must be integers","solution":"from typing import List def maximize_storage(bins: List[int], max_bins: int) -> int: Computes the maximum number of units that can fit into the specified number of bins. Parameters: bins (List[int]): List of integers representing the unit capacities of different bins. max_bins (int): Integer representing the maximum number of bins that can be used. Returns: int: Maximum number of units that can be stored using the most efficient selection of bins. if max_bins < 1 or max_bins > len(bins): raise ValueError(\\"max_bins should be in the range of 1 to len(bins)\\") if not all(isinstance(bin, int) for bin in bins): raise TypeError(\\"All bin capacities must be integers\\") # Sort bins in descending order of their sizes to maximize the storage sorted_bins = sorted(bins, reverse=True) # Sum up the capacities of the largest 'max_bins' bins return sum(sorted_bins[:max_bins])"},{"question":"def process_orders(order_ids: list[int], interval: int) -> list[str]: Processes orders by scheduling them at fixed intervals from the start of the process. :param order_ids: A list of unique integers, representing order IDs to be processed. :param interval: An integer, representing the fixed interval of processing time in minutes. :return: A list of strings, each indicating the order ID and its scheduled processing time. Note: The first order starts processing at minute 0. >>> process_orders([101, 102, 103], 10) [\\"Order 101 will be processed at minute 0\\", \\"Order 102 will be processed at minute 10\\", \\"Order 103 will be processed at minute 20\\"] >>> process_orders([2001, 2002], 15) [\\"Order 2001 will be processed at minute 0\\", \\"Order 2002 will be processed at minute 15\\"] >>> process_orders([303], 5) [\\"Order 303 will be processed at minute 0\\"]","solution":"def process_orders(order_ids: list[int], interval: int) -> list[str]: Processes orders by scheduling them at fixed intervals from the start of the process. :param order_ids: A list of unique integers, representing order IDs to be processed. :param interval: An integer, representing the fixed interval of processing time in minutes. :return: A list of strings, each indicating the order ID and its scheduled processing time. Note: The first order starts processing at minute 0. result = [] for i, order_id in enumerate(order_ids): result.append(f\\"Order {order_id} will be processed at minute {i * interval}\\") return result"},{"question":"class HashTable: def __init__(self, size=10): Initialize the hash table with a fixed size self.size = size self.table = [None] * size def _hash(self, key): Generate a hash for the given key return key % self.size def insert(self, key, value): Insert a key-value pair into the hash table using linear probing >>> ht = HashTable() >>> ht.insert(10, \\"A\\") >>> ht.search(10) \\"A\\" >>> ht.insert(20, \\"B\\") >>> ht.search(20) \\"B\\" pass def delete(self, key): Delete a key from the hash table >>> ht = HashTable() >>> ht.insert(10, \\"A\\") >>> ht.delete(10) >>> ht.search(10) None pass def search(self, key): Search for a key in the hash table and return its value >>> ht = HashTable() >>> ht.insert(10, \\"A\\") >>> ht.search(10) \\"A\\" >>> ht.search(20) None pass # Sample Test Cases def test_insert_and_search(): ht = HashTable() ht.insert(10, \\"A\\") assert ht.search(10) == \\"A\\" ht.insert(20, \\"B\\") assert ht.search(20) == \\"B\\" ht.insert(21, \\"C\\") # Collision with key 10 (if table size is 10) assert ht.search(21) == \\"C\\" def test_search_non_existent_key(): ht = HashTable() ht.insert(10, \\"A\\") assert ht.search(20) is None def test_delete_existing_key(): ht = HashTable() ht.insert(10, \\"A\\") ht.delete(10) assert ht.search(10) is None def test_delete_non_existent_key(): ht = HashTable() ht.insert(10, \\"A\\") try: ht.delete(20) except Exception as e: assert str(e) == \\"Key not found\\" def test_handle_collision(): ht = HashTable(size=5) ht.insert(1, \\"A\\") ht.insert(6, \\"B\\") # Both 1 and 6 will map to index 1 if table size is 5 assert ht.search(1) == \\"A\\" assert ht.search(6) == \\"B\\" def test_insert_when_table_is_full(): ht = HashTable(size=2) ht.insert(1, \\"A\\") ht.insert(2, \\"B\\") try: ht.insert(3, \\"C\\") except Exception as e: assert str(e) == \\"Hash table is full\\"","solution":"class HashTable: def __init__(self, size=10): self.size = size self.table = [None] * size def _hash(self, key): return key % self.size def insert(self, key, value): idx = self._hash(key) original_idx = idx while self.table[idx] is not None and self.table[idx][0] != key: idx = (idx + 1) % self.size if idx == original_idx: raise Exception(\\"Hash table is full\\") self.table[idx] = (key, value) def delete(self, key): idx = self._hash(key) original_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None return idx = (idx + 1) % self.size if idx == original_idx: raise Exception(\\"Key not found\\") def search(self, key): idx = self._hash(key) original_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size if idx == original_idx: return None return None"},{"question":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between text1 and text2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 pass","solution":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between text1 and text2. m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"from typing import List, Tuple def tic_tac_toe(moves: List[Tuple[str, int, int]]) -> Tuple[List[List[str]], str]: Simulate a game of Tic-Tac-Toe given a sequence of moves and return the final state of the board and the result of the game. >>> tic_tac_toe([('X', 0, 0), ('O', 1, 1), ('X', 0, 1), ('O', 2, 2), ('X', 0, 2)]) ([['X', 'X', 'X'], ['', 'O', ''], ['', '', 'O']], 'X wins') >>> tic_tac_toe([('X', 0, 0), ('O', 1, 1), ('X', 1, 1), ('O', 0, 2), ('X', 2, 2)]) ([['X', '', 'O'], ['', 'X', ''], ['', '', 'X']], 'X wins') >>> tic_tac_toe([('X', 0, 0), ('O', 0, 1), ('X', 1, 0), ('O', 1, 1), ('X', 2, 2), ('O', 2, 1)]) ([['X', 'O', ''], ['X', 'O', ''], ['', 'O', 'X']], 'O wins') >>> tic_tac_toe([('X', 0, 0), ('O', 0, 1), ('X', 0, 2), ('O', 1, 1), ('X', 1, 0), ('O', 1, 2), ('X', 2, 1), ('O', 2, 0), ('X', 2, 2)]) ([['X', 'O', 'X'], ['X', 'O', 'O'], ['O', 'X', 'X']], 'Draw') >>> tic_tac_toe([]) ([['', '', ''], ['', '', ''], ['', '', '']], 'Draw')","solution":"from typing import List, Tuple def tic_tac_toe(moves: List[Tuple[str, int, int]]) -> Tuple[List[List[str]], str]: def check_winner(board: List[List[str]], player: str) -> bool: # Check rows, columns, and diagonals for a win for row in board: if all(cell == player for cell in row): return True for col in range(3): if all(board[row][col] == player for row in range(3)): return True if all(board[i][i] == player for i in range(3)) or all(board[i][2 - i] == player for i in range(3)): return True return False # Initialize an empty 3x3 board board = [['' for _ in range(3)] for _ in range(3)] for player, row, col in moves: board[row][col] = player if check_winner(board, player): return board, f\\"{player} wins\\" return board, \\"Draw\\""},{"question":"from typing import List def num_distinct_islands(grid: List[List[int]]) -> int: Calculate the number of distinct island shapes in a given 2D grid. An island is a group of connected 1s (land) connected horizontally or vertically (not diagonally). Args: grid (List[List[int]]): A 2D grid containing 0s (water) and 1s (land). Returns: int: The number of distinct island shapes. Example: >>> num_distinct_islands([ ... [1, 1, 0, 0, 0], ... [1, 0, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 0, 1, 1] ... ]) 3 >>> num_distinct_islands([ ... [1, 1, 1], ... [1, 0, 1], ... [0, 1, 1] ... ]) 1","solution":"from typing import List, Set, Tuple def rotate_90(shape): Rotate the shape by 90 degrees return [(y, -x) for x, y in shape] def reflect(shape): Reflect the shape about the y-axis return [(-x, y) for x, y in shape] def normalize_shape(shape): Normalize the shape by rotating and reflecting to the smallest lexicographical order shapes = set() current = shape for _ in range(4): # Rotate 0°, 90°, 180°, 270° current = rotate_90(current) min_representation = tuple(sorted(current)) shapes.add(min_representation) reflected = reflect(current) min_representation = tuple(sorted(reflected)) shapes.add(min_representation) return min(shapes) def num_distinct_islands(grid: List[List[int]]) -> int: def bfs(x, y): queue = [(x, y)] island_shape = [] grid[x][y] = -1 while queue: cx, cy = queue.pop(0) island_shape.append((cx - x, cy - y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # directions nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1: grid[nx][ny] = -1 queue.append((nx, ny)) return island_shape m, n = len(grid), len(grid[0]) island_shapes = set() for i in range(m): for j in range(n): if grid[i][j] == 1: island_shape = bfs(i, j) normalized = normalize_shape(island_shape) island_shapes.add(normalized) return len(island_shapes)"},{"question":"def fib_matrix_expo(n: int) -> int: Compute the N-th Fibonacci number using matrix exponentiation. >>> fib_matrix_expo(0) == 0 >>> fib_matrix_expo(1) == 1 >>> fib_matrix_expo(10) == 55 >>> fib_matrix_expo(50) == 12586269025 from solution import fib_matrix_expo def test_fib_matrix_expo_zero(): assert fib_matrix_expo(0) == 0 def test_fib_matrix_expo_one(): assert fib_matrix_expo(1) == 1 def test_fib_matrix_expo_small_numbers(): assert fib_matrix_expo(2) == 1 assert fib_matrix_expo(3) == 2 assert fib_matrix_expo(4) == 3 assert fib_matrix_expo(5) == 5 def test_fib_matrix_expo_ten(): assert fib_matrix_expo(10) == 55 def test_fib_matrix_expo_large_number(): assert fib_matrix_expo(50) == 12586269025 def test_fib_matrix_expo_very_large_number(): # Known value of Fibonacci(100) based on computation assert fib_matrix_expo(100) == 354224848179261915075 def test_fib_matrix_expo_edge_cases(): assert fib_matrix_expo(0) == 0 assert fib_matrix_expo(1) == 1 assert fib_matrix_expo(2) == 1 assert fib_matrix_expo(3) == 2","solution":"def fib_matrix_expo(n: int) -> int: Compute the N-th Fibonacci number using matrix exponentiation. if n == 0: return 0 elif n == 1: return 1 def multiply_matrices(a, b): Multiplies two 2x2 matrices return [ [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]], [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]] ] def matrix_power(matrix, power): Efficiently raises the matrix to the specified power using exponentiation by squaring result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, base) base = multiply_matrices(base, base) power //= 2 return result # Transformation matrix for Fibonacci sequence transformation_matrix = [[1, 1], [1, 0]] # Raise the transformation matrix to the (n-1)th power result_matrix = matrix_power(transformation_matrix, n - 1) return result_matrix[0][0]"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate the given n x n matrix 90 degrees clockwise. Args: matrix (List[List[int]]): a square matrix (n x n). Returns: List[List[int]]: a new matrix that has been rotated 90 degrees clockwise. pass def test_rotate_matrix(): assert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] assert rotate_matrix([[1]]) == [[1]] assert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]] assert rotate_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] assert rotate_matrix([[1, 0], [0, 1]]) == [[0, 1], [1, 0]] assert rotate_matrix([[11, 12, 13], [21, 22, 23], [31, 32, 33]]) == [[31, 21, 11], [32, 22, 12], [33, 23, 13]] assert rotate_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] # Running the tests using pytest if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def rotate_matrix(matrix): Rotate the given n x n matrix 90 degrees clockwise. Args: matrix (List[List[int]]): a square matrix (n x n). Returns: List[List[int]]: a new matrix that has been rotated 90 degrees clockwise. n = len(matrix) # Create a new matrix to hold the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"import heapq class PriorityQueue: A PriorityQueue class that simulates a priority queue using a binary heap. Methods: - push(self, item, priority): Inserts an item with the given priority. - pop(self): Removes and returns the item with the highest priority. - peek(self): Returns the item with the highest priority without removing it. - is_empty(self): Returns a boolean indicating if the priority queue is empty. - change_priority(self, item, new_priority): Changes the priority of the given item. Example: >>> pq = PriorityQueue() >>> pq.push('urgent task', 1) >>> pq.push('normal task', 5) >>> pq.push('low task', 10) >>> pq.peek() 'urgent task' >>> pq.pop() 'urgent task' >>> pq.peek() 'normal task' >>> pq.change_priority('low task', 2) >>> pq.pop() 'low task' >>> pq.is_empty() False >>> pq.pop() 'normal task' >>> pq.is_empty() True def __init__(self): # Initialize the priority queue pass def push(self, item, priority): # Add an item with its priority to the priority queue pass def pop(self): # Remove and return the item with the highest priority pass def peek(self): # Return the item with the highest priority without removing it pass def is_empty(self): # Return True if the priority queue is empty, False otherwise pass def change_priority(self, item, new_priority): # Change the priority of an existing item pass","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._entry_finder = {} self._REMOVED = '<removed-task>' def push(self, item, priority): if item in self._entry_finder: self.change_priority(item, priority) else: entry = [priority, item] self._entry_finder[item] = entry heapq.heappush(self._queue, entry) def pop(self): while self._queue: priority, item = heapq.heappop(self._queue) if item is not self._REMOVED: del self._entry_finder[item] return item raise KeyError('pop from an empty priority queue') def peek(self): while self._queue: priority, item = self._queue[0] if item is not self._REMOVED: return item heapq.heappop(self._queue) raise KeyError('peek from an empty priority queue') def is_empty(self): return all(item[1] == self._REMOVED for item in self._queue) def change_priority(self, item, new_priority): if item in self._entry_finder: entry = self._entry_finder.pop(item) entry[-1] = self._REMOVED self.push(item, new_priority) else: raise KeyError('item not found in the priority queue')"},{"question":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def find_middle(self): Find and return the middle element of the linked list. If the list has an even number of nodes, return the value of the second middle node. Example: >>> ll = LinkedList() >>> ll.insert(1) >>> ll.insert(2) >>> ll.insert(3) >>> ll.insert(4) >>> ll.insert(5) >>> ll.find_middle() 3 >>> ll.insert(6) >>> ll.find_middle() 4","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert(self, value): new_node = Node(value) new_node.next = self.head self.head = new_node def find_middle(self): slow = fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.value"},{"question":"from typing import List, Tuple def calculate_total_price(shopping_list: List[Tuple[str, int, float]], discount_percentage: float, threshold: float) -> float: Calculate the total price of items in the shopping list after applying the discount if the total exceeds the threshold. :param shopping_list: List of tuples, where each tuple contains (item_name, quantity, unit_price) :param discount_percentage: Percentage of discount to apply if total exceeds the threshold :param threshold: The total amount threshold for applying the discount :return: The final total price after discount if applicable pass # Example test cases if __name__ == \\"__main__\\": # Test case 1: No discount applied assert calculate_total_price( [('apple', 4, 0.5), ('banana', 6, 0.3), ('milk', 2, 1.2)], discount_percentage=10.0, threshold=10.0 ) == 6.2 # Test case 2: Discount applied assert calculate_total_price( [('apple', 4, 0.5), ('banana', 6, 0.3), ('milk', 2, 1.2)], discount_percentage=10.0, threshold=5.0 ) == 5.58 # Test case 3: No items in the shopping list assert calculate_total_price( [], discount_percentage=10.0, threshold=5.0 ) == 0.0 # Test case 4: Single item, no discount assert calculate_total_price( [('bread', 1, 2.5)], discount_percentage=15.0, threshold=10.0 ) == 2.5 # Test case 5: Single item, discount applied assert calculate_total_price( [('butter', 4, 3.0)], discount_percentage=15.0, threshold=10.0 ) == 10.2 # Test case 6: Large quantity assert calculate_total_price( [('water', 1000, 1.5)], discount_percentage=20.0, threshold=1000.0 ) == 1200.0 print(\\"All test cases pass\\")","solution":"from typing import List, Tuple def calculate_total_price(shopping_list: List[Tuple[str, int, float]], discount_percentage: float, threshold: float) -> float: Calculate the total price of items in the shopping list after applying the discount if the total exceeds the threshold. :param shopping_list: List of tuples, where each tuple contains (item_name, quantity, unit_price) :param discount_percentage: Percentage of discount to apply if total exceeds the threshold :param threshold: The total amount threshold for applying the discount :return: The final total price after discount if applicable total_price = sum(quantity * unit_price for _, quantity, unit_price in shopping_list) if total_price > threshold: discount = (discount_percentage / 100) * total_price total_price -= discount return round(total_price, 2)"},{"question":"def longest_repeated_substring(dna_sequence: str) -> str: Find and return the longest repeated substring within the given DNA sequence. If there is no repeated substring, return an empty string. Args: dna_sequence (str): A string representing the DNA sequence composed of characters 'A', 'C', 'G', 'T'. Returns: str: The longest repeated substring within the provided DNA sequence. >>> longest_repeated_substring(\\"ATCGATCGA\\") \\"ATCGA\\" >>> longest_repeated_substring(\\"GATCAGATCA\\") \\"GATCA\\" >>> longest_repeated_substring(\\"ACGTACGTGCGT\\") \\"ACGT\\" >>> longest_repeated_substring(\\"AGTC\\") \\"\\" from solution import longest_repeated_substring def test_no_repeated_substring(): assert longest_repeated_substring(\\"AGTC\\") == \\"\\" def test_single_letter_repeated(): assert longest_repeated_substring(\\"AA\\") == \\"A\\" def test_longer_repeated_substring(): assert longest_repeated_substring(\\"ATCGATCGA\\") == \\"ATCGA\\" assert longest_repeated_substring(\\"GATCAGATCA\\") == \\"GATCA\\" def test_multiple_repeated_substrings(): assert longest_repeated_substring(\\"ACGTACGTGCGT\\") == \\"ACGT\\" def test_all_characters_repeated(): assert longest_repeated_substring(\\"AAAAAA\\") == \\"AAAAA\\" def test_partial_repeated_substring(): assert longest_repeated_substring(\\"BANANA\\") == \\"ANA\\" def test_edge_case_empty_string(): assert longest_repeated_substring(\\"\\") == \\"\\" def test_edge_case_single_character(): assert longest_repeated_substring(\\"A\\") == \\"\\" def test_repeated_substring_at_end(): assert longest_repeated_substring(\\"AABBCCBB\\") == \\"BB\\" def test_repeated_substring_in_middle(): assert longest_repeated_substring(\\"ABABABCC\\") == \\"ABAB\\"","solution":"def longest_repeated_substring(dna_sequence: str) -> str: Find and return the longest repeated substring within the given DNA sequence. If there is no repeated substring, return an empty string. Args: dna_sequence (str): A string representing the DNA sequence composed of characters 'A', 'C', 'G', 'T'. Returns: str: The longest repeated substring within the provided DNA sequence. def has_repeated_substring_of_length(L): Check if there is any repeated substring of length L. seen = set() for i in range(len(dna_sequence) - L + 1): substring = dna_sequence[i:i + L] if substring in seen: return True seen.add(substring) return False left, right = 1, len(dna_sequence) while left <= right: mid = (left + right) // 2 if has_repeated_substring_of_length(mid): left = mid + 1 else: right = mid - 1 max_length = right seen = {} for i in range(len(dna_sequence) - max_length + 1): substring = dna_sequence[i:i + max_length] if substring in seen: return substring seen[substring] = True return \\"\\""},{"question":"def find_smallest_missing_positive(arr: List[int]) -> int: Find the smallest positive integer that is missing from the array. >>> find_smallest_missing_positive([3, 4, -1, 1]) 2 >>> find_smallest_missing_positive([1, 2, 0]) 3 >>> find_smallest_missing_positive([-3, -2, -1]) 1 pass def test_example_cases(): assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 assert find_smallest_missing_positive([1, 2, 0]) == 3 assert find_smallest_missing_positive([-3, -2, -1]) == 1 def test_single_element(): assert find_smallest_missing_positive([1]) == 2 assert find_smallest_missing_positive([-1]) == 1 def test_all_positive(): assert find_smallest_missing_positive([1, 2, 3, 4, 5]) == 6 assert find_smallest_missing_positive([2, 3, 7, 6, 8, -1, -10, 15]) == 1 def test_all_negative(): assert find_smallest_missing_positive([-1, -2, -3, -4]) == 1 def test_large_case(): large_list = list(range(1, 100001)) large_list.remove(43) # remove element '43' assert find_smallest_missing_positive(large_list) == 43 # Including pytest import to run the tests import pytest pytest.main()","solution":"def find_smallest_missing_positive(arr): n = len(arr) # Ignore numbers out of range and use the array itself to place positive numbers in their correct index positions for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # The first index position which does not have the correct number indicates the missing number for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def most_popular_book(borrowed_books: List[str]) -> str: Determine the most frequently borrowed book from the library's log. >>> most_popular_book([\\"Harry Potter\\", \\"Lord of the Rings\\", \\"Harry Potter\\", \\"The Hobbit\\"]) == \\"Harry Potter\\" >>> most_popular_book([]) == \\"\\" >>> most_popular_book([\\"1984\\", \\"1984\\", \\"Brave New World\\"]) in [\\"1984\\", \\"Brave New World\\"]","solution":"from collections import Counter def most_popular_book(borrowed_books: list[str]) -> str: if not borrowed_books: return \\"\\" book_counter = Counter(borrowed_books) most_common_book = book_counter.most_common(1)[0][0] return most_common_book"},{"question":"from typing import List import string def calculate_sentiment(review: str, positive_words: List[str], negative_words: List[str]) -> int: Calculate the sentiment score of a movie review. Positive words add +1 to the score, and negative words subtract -1 from the score. Example: >>> review = \\"This movie was absolutely amazing, I loved every part of it. However, some parts were a bit dull.\\" >>> positive_words = [\\"amazing\\", \\"loved\\", \\"good\\", \\"fantastic\\", \\"great\\"] >>> negative_words = [\\"dull\\", \\"boring\\", \\"bad\\", \\"terrible\\", \\"awful\\"] >>> calculate_sentiment(review, positive_words, negative_words) 1","solution":"from typing import List import string def calculate_sentiment(review: str, positive_words: List[str], negative_words: List[str]) -> int: # Remove punctuation and convert the text to lowercase table = str.maketrans(\\"\\", \\"\\", string.punctuation) review = review.translate(table).lower() # Split the review into words words = review.split() # Initialize the sentiment score score = 0 # Calculate the score based on the positive and negative words for word in words: if word in positive_words: score += 1 elif word in negative_words: score -= 1 return score"},{"question":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None def insert_into_bst(root: Optional[TreeNode], key: int) -> TreeNode: Insert a node into a balanced BST while maintaining its balanced property. pass def calculate_tree_height(root: Optional[TreeNode]) -> int: Calculate the height of the BST. pass def trace_heights_after_inserts(keys: List[int]) -> List[int]: Trace the changes in the height of the tree after each insertion. >>> trace_heights_after_inserts([10, 20, 5, 15, 30]) == [0, 1, 1, 2, 2] >>> trace_heights_after_inserts([]) == [] >>> trace_heights_after_inserts([10]) == [0] pass # Unit Test from typing import Optional, List from solution import TreeNode, insert_into_bst, calculate_tree_height, trace_heights_after_inserts def test_insert_into_bst(): root = None root = insert_into_bst(root, 10) assert root.key == 10 root = insert_into_bst(root, 20) assert root.right.key == 20 root = insert_into_bst(root, 5) assert root.left.key == 5 def test_calculate_tree_height(): root = None root = insert_into_bst(root, 10) root = insert_into_bst(root, 20) root = insert_into_bst(root, 5) assert calculate_tree_height(root) == 2 root = insert_into_bst(root, 3) root = insert_into_bst(root, 4) assert calculate_tree_height(root) == 3 def test_trace_heights_after_inserts(): keys = [10, 20, 5, 15, 30] heights_trace = trace_heights_after_inserts(keys) assert heights_trace == [0, 1, 1, 2, 2] def test_empty_tree(): keys = [] heights_trace = trace_heights_after_inserts(keys) assert heights_trace == [] def test_single_element_tree(): keys = [10] heights_trace = trace_heights_after_inserts(keys) assert heights_trace == [0]","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 # New TreeNode is at height 1 (leaf) def get_height(node): return node.height if node else 0 def update_height(node): if node: node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): return get_height(node.left) - get_height(node.right) if node else 0 def left_rotate(z): y = z.right T2 = y.left # Perform rotation y.left = z z.right = T2 # Update heights update_height(z) update_height(y) return y def right_rotate(z): y = z.left T3 = y.right # Perform rotation y.right = z z.left = T3 # Update heights update_height(z) update_height(y) return y def insert_into_bst(root, key): if not root: return TreeNode(key) if key < root.key: root.left = insert_into_bst(root.left, key) else: root.right = insert_into_bst(root.right, key) update_height(root) balance = get_balance(root) # Balance subtree if needed if balance > 1 and key < root.left.key: return right_rotate(root) if balance < -1 and key > root.right.key: return left_rotate(root) if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) return root def calculate_tree_height(root): if not root: return 0 return root.height def trace_heights_after_inserts(keys): root = None heights = [] for key in keys: root = insert_into_bst(root, key) heights.append(calculate_tree_height(root)) return heights"},{"question":"def character_frequency(data: str) -> dict: Compute the frequency of each character in the given input string. :param data: str - Input string. :return: dict - A dictionary with characters as keys and their frequencies as values. >>> character_frequency('hello') {'h': 1, 'e': 1, 'l': 2, 'o': 1} >>> character_frequency('aabbbcccc') {'a': 2, 'b': 3, 'c': 4} >>> character_frequency('') {}","solution":"def character_frequency(data: str) -> dict: Compute the frequency of each character in the given input string. :param data: str - Input string. :return: dict - A dictionary with characters as keys and their frequencies as values. frequency = {} for char in data: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"def calculate_user_session_times(logs): Processes logs of user activity to determine the total logged-in time for each user. >>> logs = [ ... ('user1', 'login', 100), ... ('user2', 'login', 200), ... ('user1', 'logout', 300), ... ('user2', 'logout', 400), ... ('user1', 'login', 500), ... ('user1', 'logout', 600) ... ] >>> calculate_user_session_times(logs) {'user1': 300, 'user2': 200} from solution import calculate_user_session_times def test_calculate_user_session_times_basic(): logs = [ ('user1', 'login', 100), ('user2', 'login', 200), ('user1', 'logout', 300), ('user2', 'logout', 400), ] expected = { 'user1': 200, 'user2': 200, } assert calculate_user_session_times(logs) == expected def test_calculate_user_session_times_multiple_sessions(): logs = [ ('user1', 'login', 100), ('user2', 'login', 200), ('user1', 'logout', 300), ('user2', 'logout', 400), ('user1', 'login', 500), ('user1', 'logout', 600) ] expected = { 'user1': 300, 'user2': 200, } assert calculate_user_session_times(logs) == expected def test_calculate_user_session_times_invalid_session(): logs = [ ('user1', 'login', 100), ('user1', 'logout', 200), ('user2', 'login', 300), ('user1', 'login', 400), ('user2', 'login', 500), # Invalid session for user2 ('user1', 'logout', 600), ] expected = { 'user1': 300, } assert calculate_user_session_times(logs) == expected def test_calculate_user_session_times_no_sessions(): logs = [] expected = {} assert calculate_user_session_times(logs) == expected def test_calculate_user_session_times_partial_sessions(): logs = [ ('user1', 'login', 100), ('user2', 'login', 200), ('user1', 'logout', 300), ('user2', 'login', 400), # Invalid session for user2 ] expected = { 'user1': 200, } assert calculate_user_session_times(logs) == expected","solution":"def calculate_user_session_times(logs): user_sessions = {} login_times = {} for user_id, action, timestamp in logs: if action == 'login': if user_id in login_times: # If there's a login without a logout ignore this session login_times[user_id] = None else: login_times[user_id] = timestamp elif action == 'logout': if user_id in login_times and login_times[user_id] is not None: logged_in_time = timestamp - login_times[user_id] if user_id in user_sessions: user_sessions[user_id] += logged_in_time else: user_sessions[user_id] = logged_in_time del login_times[user_id] return user_sessions"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. Args: - l1 (ListNode): The head of the first sorted linked list. - l2 (ListNode): The head of the second sorted linked list. Returns: - ListNode: The head of the merged sorted linked list. pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into one sorted linked list. Args: - l1 (ListNode): The head of the first sorted linked list. - l2 (ListNode): The head of the second sorted linked list. Returns: - ListNode: The head of the merged sorted linked list. # Create a dummy node to serve as the start of the merged list dummy = ListNode() tail = dummy # This will be the end of the merged list # Traverse both lists and link nodes in sorted order while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next # If there are remaining nodes in either list, append them if l1: tail.next = l1 if l2: tail.next = l2 # The merged list starts from the next of the dummy node return dummy.next"},{"question":"from collections import deque from typing import List def word_morph(startWord: str, endWord: str, wordList: List[str]) -> int: Returns the minimum number of transformations needed to transform the startWord into the endWord. Returns -1 if the transformation is not possible. >>> word_morph('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog']) 5 >>> word_morph('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log']) -1 >>> word_morph('abc', 'abc', ['abc']) 1 >>> word_morph('hit', 'cog', ['hot', 'hit', 'cog']) -1 >>> word_morph('a', 'b', ['b']) 2 >>> word_morph('hit', 'cog', ['hot', 'dot', 'dog', 'lot', 'log', 'cog', 'hot', 'dot', 'dog', 'lot', 'log', 'cog']) 5 # Implement the function to compute shortest transformation here pass","solution":"from collections import deque from typing import List def word_morph(startWord: str, endWord: str, wordList: List[str]) -> int: Returns the minimum number of transformations needed to transform the startWord into the endWord. Returns -1 if the transformation is not possible. if endWord not in wordList: return -1 wordList = set(wordList) queue = deque([(startWord, 1)]) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append((next_word, steps + 1)) return -1"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Check if two strings are permutations of each other. Args: str1 (str): The first string str2 (str): The second string Returns: bool: True if the strings are permutations of each other, False otherwise. >>> are_permutations(\\"abc\\", \\"bca\\") True >>> are_permutations(\\"abcd\\", \\"abcf\\") False >>> are_permutations(\\"abc\\", \\"xyz\\") False >>> are_permutations(\\"abcd\\", \\"dcba\\") True >>> are_permutations(\\"aabbcc\\", \\"ccbbaa\\") True >>> are_permutations(\\"abc\\", \\"abcc\\") False >>> are_permutations(\\"\\", \\"\\") True >>> are_permutations(\\"a\\", \\"a\\") True >>> are_permutations(\\"a\\", \\"b\\") False","solution":"def are_permutations(str1: str, str2: str) -> bool: Check if two strings are permutations of each other. Args: str1 (str): The first string str2 (str): The second string Returns: bool: True if the strings are permutations of each other, False otherwise from collections import Counter if len(str1) != len(str2): return False return Counter(str1) == Counter(str2)"},{"question":"def word_frequency_counter(text: str) -> dict: Count the occurrences of each unique word in a given string and return a dictionary with the counts. >>> word_frequency_counter(\\"Hello, world! Hello.\\") {\\"hello\\": 2, \\"world\\": 1} >>> word_frequency_counter(\\"A man, a plan, a canal, Panama!\\") {\\"a\\": 3, \\"man\\": 1, \\"plan\\": 1, \\"canal\\": 1, \\"panama\\": 1} >>> word_frequency_counter(\\"Python is great! Python, python.\\") {\\"python\\": 3, \\"is\\": 1, \\"great\\": 1} >>> word_frequency_counter(\\"Sample text, with: various; punctuation marks.\\") {\\"sample\\": 1, \\"text\\": 1, \\"with\\": 1, \\"various\\": 1, \\"punctuation\\": 1, \\"marks\\": 1} >>> word_frequency_counter(\\"123 numbers, and 123 words.\\") {\\"123\\": 2, \\"numbers\\": 1, \\"and\\": 1, \\"words\\": 1}","solution":"import re def word_frequency_counter(text: str) -> dict: Function to count the frequency of each unique word in a given string. Args: text (str): The input string containing words separated by spaces or other non-alphanumeric characters. Returns: dict: A dictionary where keys are words and values are the counts. words = re.findall(r'bw+b', text.lower()) frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"def harmonic_mean_of_fractions(fraction_list: List[Tuple[int, int]]) -> float: Calculate the harmonic mean of a list of fractions. Parameters: fraction_list (List[Tuple[int, int]]): List of tuples representing the fractions. Returns: float: Harmonic mean of the fractions. Examples: >>> harmonic_mean_of_fractions([(1, 2), (3, 4), (5, 6)]) 0.509 >>> harmonic_mean_of_fractions([(1, 2), (2, 3)]) 0.545","solution":"def harmonic_mean_of_fractions(fraction_list): Calculate the harmonic mean of a list of fractions. Parameters: fraction_list (List[Tuple[int, int]]): List of tuples representing the fractions. Returns: float: Harmonic mean of the fractions. n = len(fraction_list) reciprocal_sum = 0.0 for a, b in fraction_list: # Ensure denominator is not zero if a == 0: return 0.0 reciprocal_sum += b / a return n / reciprocal_sum"},{"question":"import numpy as np class LinearRegression: def __init__(self, learning_rate=0.01, iterations=1000, tolerance=1e-6): self.learning_rate = learning_rate self.iterations = iterations self.tolerance = tolerance self.weights = None self.bias = None def standardize(self, X): Standardizes the training data (zero mean and unit variance). return (X - self.mean) / self.std def fit(self, X, y): Trains the linear regression model using the training data. pass def predict(self, X): Predicts target values using the trained linear regression model. pass def example(): rng = np.random.default_rng() X = rng.normal(size=(100, 3)) # 100 samples, 3 features y = 3 * X[:, 0] + 2 * X[:, 1] + X[:, 2] + rng.normal(size=100) # Linear relationship + noise model = LinearRegression(learning_rate=0.01, iterations=1000, tolerance=1e-6) model.fit(X, y) X_new = rng.normal(size=(10, 3)) # New data for prediction predictions = model.predict(X_new) print(predictions) if __name__ == \\"__main__\\": example()","solution":"import numpy as np class LinearRegression: def __init__(self, learning_rate=0.01, iterations=1000, tolerance=1e-6): self.learning_rate = learning_rate self.iterations = iterations self.tolerance = tolerance self.weights = None self.bias = None self.mean = None self.std = None def standardize(self, X): Standardizes the training data (zero mean and unit variance). self.mean = np.mean(X, axis=0) self.std = np.std(X, axis=0) return (X - self.mean) / self.std def fit(self, X, y): Trains the linear regression model using the training data. X = self.standardize(X) n_samples, n_features = X.shape self.weights = np.zeros(n_features) self.bias = 0 for _ in range(self.iterations): y_predicted = self.predict(X) dw = (1 / n_samples) * np.dot(X.T, (y_predicted - y)) db = (1 / n_samples) * np.sum(y_predicted - y) self.weights -= self.learning_rate * dw self.bias -= self.learning_rate * db if np.linalg.norm(dw) < self.tolerance and np.abs(db) < self.tolerance: break def predict(self, X): Predicts target values using the trained linear regression model. X = (X - self.mean) / self.std # Standardize input data based on training data return np.dot(X, self.weights) + self.bias def example(): rng = np.random.default_rng() X = rng.normal(size=(100, 3)) # 100 samples, 3 features y = 3 * X[:, 0] + 2 * X[:, 1] + X[:, 2] + rng.normal(size=100) # Linear relationship + noise model = LinearRegression(learning_rate=0.01, iterations=1000, tolerance=1e-6) model.fit(X, y) X_new = rng.normal(size=(10, 3)) # New data for prediction predictions = model.predict(X_new) print(predictions) if __name__ == \\"__main__\\": example()"},{"question":"def depth_first_search(graph: dict, start: int) -> list: Performs a depth-first search on the graph starting from the node 'start'. :param graph: dict, adjacency list representation of the graph :param start: int, the starting node for the DFS traversal :return: list, nodes visited in the order during DFS traversal >>> graph = {0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1], 5: [2]} >>> depth_first_search(graph, 0) [0, 1, 3, 4, 2, 5] >>> graph = {0: [1], 1: [2], 2: [0, 3], 3: [3]} >>> depth_first_search(graph, 2) [2, 0, 1, 3] >>> graph = {} >>> depth_first_search(graph, 0) [] >>> graph = {0: []} >>> depth_first_search(graph, 0) [0] >>> graph = {0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3]} >>> depth_first_search(graph, 0) [0, 1, 2] >>> depth_first_search(graph, 3) [3, 4]","solution":"def depth_first_search(graph, start): Performs a depth-first search on the graph starting from the node 'start'. :param graph: dict, adjacency list representation of the graph :param start: int, the starting node for the DFS traversal :return: list, nodes visited in the order during DFS traversal if start not in graph: return [] visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(set(graph[node]) - set(visited)) return visited"},{"question":"def reverse_words(sentence: str) -> str: Reverse the order of words in a given sentence. >>> reverse_words(\\"The quick brown fox\\") \\"fox brown quick The\\" >>> reverse_words(\\" Hello world! \\") \\"world! Hello\\" >>> reverse_words(\\"Coding is fun\\") \\"fun is Coding\\"","solution":"def reverse_words(sentence): Reverses the order of words in a given sentence. Args: sentence (str): A string containing the sentence to be reversed. Returns: str: A new string with the words in reverse order. # Split the sentence into words, stripping out extra spaces words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words into a new sentence with single spaces return ' '.join(reversed_words)"},{"question":"def is_palindrome(num: int) -> bool: Checks if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(22) True def is_prime(num: int) -> bool: Checks if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(101) True >>> is_prime(103) True >>> is_prime(104) False def smallest_prime_palindrome(N: int) -> int: Finds the smallest prime palindrome greater than or equal to N. >>> smallest_prime_palindrome(31) 101 >>> smallest_prime_palindrome(6) 7 >>> smallest_prime_palindrome(131) 131 >>> smallest_prime_palindrome(12) 101 >>> smallest_prime_palindrome(1) 2 >>> smallest_prime_palindrome(1000) 10301","solution":"def is_palindrome(num: int) -> bool: Checks if a number is a palindrome. return str(num) == str(num)[::-1] def is_prime(num: int) -> bool: Checks if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def smallest_prime_palindrome(N: int) -> int: Finds the smallest prime palindrome greater than or equal to N. while True: if is_palindrome(N) and is_prime(N): return N N += 1"},{"question":"class StudentScoresManager: A class to manage and analyze student scores. Methods: add_student(name: str): Adds a new student with the given name. add_score(name: str, score: float): Adds a new score for the specified student. get_average_score(name: str) -> float: Returns the average score of the specified student. get_highest_average_score() -> str: Returns the name of the student with the highest average score. Example: >>> score_manager = StudentScoresManager() >>> score_manager.add_student(\\"Alice\\") >>> score_manager.add_student(\\"Bob\\") >>> score_manager.add_score(\\"Alice\\", 95.0) >>> score_manager.add_score(\\"Alice\\", 85.0) >>> score_manager.add_score(\\"Bob\\", 90.0) >>> score_manager.add_score(\\"Bob\\", 88.0) >>> score_manager.get_average_score(\\"Alice\\") 90.0 >>> score_manager.get_average_score(\\"Bob\\") 89.0 >>> score_manager.get_highest_average_score() 'Alice' def test_add_student(): manager = StudentScoresManager() manager.add_student(\\"Alice\\") assert \\"Alice\\" in manager.students assert manager.students[\\"Alice\\"] == [] def test_add_score(): manager = StudentScoresManager() manager.add_student(\\"Alice\\") manager.add_score(\\"Alice\\", 90.0) assert manager.students[\\"Alice\\"] == [90.0] def test_get_average_score(): manager = StudentScoresManager() manager.add_student(\\"Alice\\") manager.add_score(\\"Alice\\", 90.0) manager.add_score(\\"Alice\\", 95.0) assert manager.get_average_score(\\"Alice\\") == 92.5 def test_get_highest_average_score(): manager = StudentScoresManager() manager.add_student(\\"Alice\\") manager.add_student(\\"Bob\\") manager.add_score(\\"Alice\\", 90.0) manager.add_score(\\"Alice\\", 95.0) manager.add_score(\\"Bob\\", 80.0) manager.add_score(\\"Bob\\", 85.0) assert manager.get_highest_average_score() == \\"Alice\\" def test_get_average_score_no_scores(): manager = StudentScoresManager() manager.add_student(\\"Alice\\") assert manager.get_average_score(\\"Alice\\") == 0.0 def test_get_highest_average_score_no_students(): manager = StudentScoresManager() assert manager.get_highest_average_score() is None","solution":"class StudentScoresManager: def __init__(self): self.students = {} def add_student(self, name: str): if name not in self.students: self.students[name] = [] def add_score(self, name: str, score: float): if name in self.students: self.students[name].append(score) def get_average_score(self, name: str) -> float: if name in self.students: scores = self.students[name] if scores: return sum(scores) / len(scores) return 0.0 def get_highest_average_score(self) -> str: highest_avg = float('-inf') top_student = None for name, scores in self.students.items(): if scores: avg_score = sum(scores) / len(scores) if avg_score > highest_avg: highest_avg = avg_score top_student = name return top_student"},{"question":"from typing import List def average_score(scores: List[int]) -> float: Calculate the average score from a list of test scores, excluding the highest and the lowest scores. Raises a ValueError if the list has fewer than 3 scores or contains negative scores. >>> average_score([80, 90, 100, 70, 85]) 85.0 >>> average_score([100, 100, 100]) 100.0 >>> average_score([50, 60, 70, 80, 90]) 70.0 >>> average_score([85, 95]) Traceback (most recent call last): ... ValueError: Calculation cannot be performed: the list must contain at least 3 scores. >>> average_score([85, 95, -70, 60]) Traceback (most recent call last): ... ValueError: Invalid input: all scores must be non-negative","solution":"from typing import List def average_score(scores: List[int]) -> float: if len(scores) < 3: raise ValueError(\\"Calculation cannot be performed: the list must contain at least 3 scores.\\") if any(score < 0 for score in scores): raise ValueError(\\"Invalid input: all scores must be non-negative\\") scores_sorted = sorted(scores) trimmed_scores = scores_sorted[1:-1] # Exclude the lowest and highest scores average = sum(trimmed_scores) / len(trimmed_scores) return round(average, 2)"},{"question":"def is_palindromic_filename(filename: str) -> bool: Determines whether a given file name is a palindrome. Args: filename (str): A string representing the file name to be checked. Returns: bool: True if the file name is a palindrome, False otherwise. Raises: TypeError: If the input is not a string. Examples: >>> is_palindromic_filename(\\"redivider\\") True >>> is_palindromic_filename(\\"deified\\") True >>> is_palindromic_filename(\\"hello.txt\\") False >>> is_palindromic_filename(\\"501abccba105\\") True >>> is_palindromic_filename(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindromic_filename(12345) Traceback (most recent call last): ... TypeError: Input must be a string >>> is_palindromic_filename([\\"palindrome\\"]) Traceback (most recent call last): ... TypeError: Input must be a string","solution":"def is_palindromic_filename(filename: str) -> bool: Determines whether a given file name is a palindrome. Args: filename (str): A string representing the file name to be checked. Returns: bool: True if the file name is a palindrome, False otherwise. Raises: TypeError: If the input is not a string. if not isinstance(filename, str): raise TypeError(\\"Input must be a string\\") # Normalize the string by removing non-alphanumeric characters and converting to lowercase normalized_filename = ''.join(ch.lower() for ch in filename if ch.isalnum()) # Check if the normalized string is a palindrome return normalized_filename == normalized_filename[::-1]"},{"question":"import re from collections import defaultdict class DocumentProcessor: A class to process documents for word frequencies, unique words, and longest sentence. Methods: - word_frequencies: Returns a dictionary with word frequencies. - unique_words: Returns a set of unique words. - longest_sentence: Returns the longest sentence based on word count. >>> document = \\"Hello world! Hello.\\" >>> processor = DocumentProcessor(document) >>> processor.word_frequencies() {'hello': 2, 'world': 1} >>> processor.unique_words() {'hello', 'world'} >>> processor.longest_sentence() 'Hello world!' def __init__(self, document: str): self.document = document def word_frequencies(self) -> dict[str, int]: Returns a dictionary where keys are words and values are their frequencies. pass def unique_words(self) -> set[str]: Returns a set of all unique words in the document. pass def longest_sentence(self) -> str: Returns the longest sentence in the document based on word count. pass","solution":"import re from collections import defaultdict class DocumentProcessor: def __init__(self, document: str): self.document = document def word_frequencies(self) -> dict[str, int]: word_counts = defaultdict(int) # Extract all words words = re.findall(r'bw+b', self.document.lower()) for word in words: word_counts[word] += 1 return dict(word_counts) def unique_words(self) -> set[str]: # Extract all words and convert to a set words = re.findall(r'bw+b', self.document.lower()) return set(words) def longest_sentence(self) -> str: # Split document into sentences sentences = re.split(r'(?<=[.!?]) +', self.document) # Find the longest sentence based on word count longest = max(sentences, key=lambda s: len(re.findall(r'bw+b', s)), default=\\"\\") return longest"},{"question":"class Vector2D: def __init__(self, x: float, y: float): Initialize a 2D vector with coordinates x and y. self.x = x self.y = y def __add__(self, other: 'Vector2D') -> 'Vector2D': Return the vector addition of self and other. pass def __sub__(self, other: 'Vector2D') -> 'Vector2D': Return the vector subtraction of self and other. pass def __mul__(self, scalar: float) -> 'Vector2D': Return the scalar multiplication of this vector. pass def __truediv__(self, scalar: float) -> 'Vector2D': Return the scalar division of this vector. pass def magnitude(self) -> float: Return the magnitude of the vector. pass def dot_product(self, other: 'Vector2D') -> float: Return the dot product of self and other. pass def is_orthogonal(self, other: 'Vector2D') -> bool: Return True if self and other are orthogonal (dot product is zero). pass def test_vector_addition(): v1 = Vector2D(1, 2) v2 = Vector2D(3, 4) result = v1 + v2 assert result.x == 4 assert result.y == 6 def test_vector_subtraction(): v1 = Vector2D(5, 7) v2 = Vector2D(2, 3) result = v1 - v2 assert result.x == 3 assert result.y == 4 def test_scalar_multiplication(): v = Vector2D(3, 4) result = v * 2 assert result.x == 6 assert result.y == 8 def test_scalar_division(): v = Vector2D(8, 6) result = v / 2 assert result.x == 4 assert result.y == 3 def test_scalar_division_by_zero(): v = Vector2D(8, 6) try: v / 0 assert False, \\"Expected ValueError\\" except ValueError as e: assert str(e) == \\"Cannot divide by zero\\" def test_magnitude(): v = Vector2D(3, 4) assert v.magnitude() == 5.0 def test_dot_product(): v1 = Vector2D(1, 2) v2 = Vector2D(3, 4) assert v1.dot_product(v2) == 11 def test_is_orthogonal_true(): v1 = Vector2D(1, 0) v2 = Vector2D(0, 1) assert v1.is_orthogonal(v2) == True def test_is_orthogonal_false(): v1 = Vector2D(1, 2) v2 = Vector2D(2, 3) assert v1.is_orthogonal(v2) == False","solution":"import math class Vector2D: def __init__(self, x, y): Initialize a 2D vector with coordinates x and y. self.x = x self.y = y def __add__(self, other): Returns the vector addition of self and other. return Vector2D(self.x + other.x, self.y + other.y) def __sub__(self, other): Returns the vector subtraction of self and other. return Vector2D(self.x - other.x, self.y - other.y) def __mul__(self, scalar): Returns the scalar multiplication of this vector. return Vector2D(self.x * scalar, self.y * scalar) def __truediv__(self, scalar): Returns the scalar division of this vector. if scalar == 0: raise ValueError(\\"Cannot divide by zero\\") return Vector2D(self.x / scalar, self.y / scalar) def magnitude(self): Returns the magnitude of the vector. return math.sqrt(self.x ** 2 + self.y ** 2) def dot_product(self, other): Returns the dot product of self and other. return self.x * other.x + self.y * other.y def is_orthogonal(self, other): Returns True if self and other are orthogonal (dot product is zero). return self.dot_product(other) == 0"},{"question":"from typing import List def calculate_resistance(resistances: List[float], connection_type: str) -> float: Calculates the total resistance of a circuit given a list of individual resistances and the connection type. Args: resistances (List[float]): A list of resistance values in ohms. connection_type (str): The type of connection ('series' or 'parallel'). Returns: float: The total resistance of the circuit. Examples: >>> calculate_resistance([10, 20, 30], 'series') 60.0 >>> calculate_resistance([10, 20, 30], 'parallel') 5.454545454545454 >>> calculate_resistance([5.0, 7.0, 10.0], 'series') 22.0 >>> calculate_resistance([5.0, 7.0, 10.0], 'parallel') 2.243243243243243 def test_calculate_resistance_series(): assert calculate_resistance([10, 20, 30], 'series') == 60.0 assert calculate_resistance([5.0, 7.0, 10.0], 'series') == 22.0 assert calculate_resistance([100], 'series') == 100.0 def test_calculate_resistance_parallel(): assert calculate_resistance([10, 20, 30], 'parallel') == 1 / (1/10 + 1/20 + 1/30) assert calculate_resistance([5.0, 7.0, 10.0], 'parallel') == 1 / (1/5.0 + 1/7.0 + 1/10.0) assert calculate_resistance([100], 'parallel') == 100.0 def test_calculate_resistance_invalid_connection_type(): try: calculate_resistance([10, 20, 30], 'invalid') except ValueError as e: assert str(e) == \\"Invalid connection type. Use 'series' or 'parallel'.\\" def test_calculate_resistance_single_element(): assert calculate_resistance([10], 'series') == 10.0 assert calculate_resistance([10], 'parallel') == 10.0 def test_calculate_resistance_complex(): assert abs(calculate_resistance([1.5, 2.5, 3.5], 'series') - 7.5) < 1e-9 assert abs(calculate_resistance([1.5, 2.5, 3.5], 'parallel') - (1 / (1/1.5 + 1/2.5 + 1/3.5))) < 1e-9","solution":"from typing import List def calculate_resistance(resistances: List[float], connection_type: str) -> float: Calculates the total resistance of a circuit given a list of resistances and the connection type. if connection_type == \\"series\\": return sum(resistances) elif connection_type == \\"parallel\\": return 1 / sum(1 / r for r in resistances) else: raise ValueError(\\"Invalid connection type. Use 'series' or 'parallel'.\\")"},{"question":"from typing import List def compress_string(input_string: str) -> str: Compresses the given string by collapsing consecutive identical characters into a single character followed by the count. >>> compress_string('aaabbc') 'a3b2c' >>> compress_string('abc') 'abc' >>> compress_string('aabbcc') 'a2b2c2' >>> compress_string('a') 'a' >>> compress_string('aaa') 'a3' pass def decompress_string(compressed_string: str) -> str: Decompresses the given compressed string back to its original form. >>> decompress_string('a3b2c') 'aaabbc' >>> decompress_string('abc') 'abc' >>> decompress_string('a2b2c2') 'aabbcc' >>> decompress_string('a') 'a' >>> decompress_string('a3') 'aaa' pass","solution":"def compress_string(input_string: str) -> str: if not input_string: return '' compressed = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: compressed.append(input_string[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(input_string[-1]) if count > 1: compressed.append(str(count)) return ''.join(compressed) def decompress_string(compressed_string: str) -> str: decompressed = [] i = 0 while i < len(compressed_string): char = compressed_string[i] i += 1 count = 0 while i < len(compressed_string) and compressed_string[i].isdigit(): count = count * 10 + int(compressed_string[i]) i += 1 if count == 0: count = 1 decompressed.append(char * count) return ''.join(decompressed)"},{"question":"import json import pickle import xml.etree.ElementTree as ET def json_serialize(obj): Serializes a Python data structure to a JSON formatted string. try: return json.dumps(obj) except (TypeError, ValueError) as e: raise ValueError(f\\"Unable to serialize object to JSON: {str(e)}\\") def json_deserialize(json_str): Deserializes a JSON formatted string to a Python data structure. try: return json.loads(json_str) except json.JSONDecodeError as e: raise ValueError(f\\"Unable to deserialize JSON string: {str(e)}\\") def dict_to_xml(tag, d): Helper function to convert a dictionary to an XML string. elem = ET.Element(tag) for key, val in d.items(): child = ET.Element(key) child.text = str(val) elem.append(child) return elem def xml_serialize(obj): Serializes a Python data structure to an XML formatted string. if not isinstance(obj, dict): raise ValueError(\\"XML serialization only supports Python dicts\\") root_name = \\"root\\" root = dict_to_xml(root_name, obj) return ET.tostring(root, encoding='unicode') def xml_deserialize(xml_str): Deserializes an XML formatted string to a Python data structure. try: root = ET.fromstring(xml_str) return {child.tag: child.text for child in root} except ET.ParseError as e: raise ValueError(f\\"Unable to deserialize XML string: {str(e)}\\") def binary_serialize(obj): Serializes a Python data structure to a binary format using the pickle module. return pickle.dumps(obj) def binary_deserialize(binary_data): Deserializes binary data to a Python data structure using the pickle module. return pickle.loads(binary_data)","solution":"import json import pickle import xml.etree.ElementTree as ET def json_serialize(obj): Serializes a Python data structure to a JSON formatted string. try: return json.dumps(obj) except (TypeError, ValueError) as e: raise ValueError(f\\"Unable to serialize object to JSON: {str(e)}\\") def json_deserialize(json_str): Deserializes a JSON formatted string to a Python data structure. try: return json.loads(json_str) except json.JSONDecodeError as e: raise ValueError(f\\"Unable to deserialize JSON string: {str(e)}\\") def dict_to_xml(tag, d): Helper function to convert a dictionary to an XML string. elem = ET.Element(tag) for key, val in d.items(): child = ET.Element(key) child.text = str(val) elem.append(child) return elem def xml_serialize(obj): Serializes a Python data structure to an XML formatted string. if not isinstance(obj, dict): raise ValueError(\\"XML serialization only supports Python dicts\\") root_name = \\"root\\" root = dict_to_xml(root_name, obj) return ET.tostring(root, encoding='unicode') def xml_deserialize(xml_str): Deserializes an XML formatted string to a Python data structure. try: root = ET.fromstring(xml_str) return {child.tag: child.text for child in root} except ET.ParseError as e: raise ValueError(f\\"Unable to deserialize XML string: {str(e)}\\") def binary_serialize(obj): Serializes a Python data structure to a binary format using the pickle module. return pickle.dumps(obj) def binary_deserialize(binary_data): Deserializes binary data to a Python data structure using the pickle module. return pickle.loads(binary_data)"},{"question":"from typing import List, Dict def sort_students(students: List[Dict[str, str, int, float]]) -> List[Dict[str, str, int, float]]: Sorts students first by GPA in descending order, then by age in ascending order. :param students: List of dictionaries, each containing 'name', 'age', and 'gpa'. :return: Sorted list of students based on the specified criteria. >>> sort_students([ {\\"name\\": \\"Alice\\", \\"age\\": 20, \\"gpa\\": 3.9}, {\\"name\\": \\"Bob\\", \\"age\\": 19, \\"gpa\\": 3.9}, {\\"name\\": \\"Charlie\\", \\"age\\": 22, \\"gpa\\": 3.8}, ]) [ {\\"name\\": \\"Alice\\", \\"age\\": 20, \\"gpa\\": 3.9}, {\\"name\\": \\"Bob\\", \\"age\\": 19, \\"gpa\\": 3.9}, {\\"name\\": \\"Charlie\\", \\"age\\": 22, \\"gpa\\": 3.8}, ] >>> sort_students([]) [] pass","solution":"def sort_students(students): Sorts students first by GPA in descending order, then by age in ascending order. :param students: List of dictionaries, each containing 'name', 'age', and 'gpa'. :return: Sorted list of students based on the specified criteria. return sorted(students, key=lambda s: (-s['gpa'], s['age']))"},{"question":"[Completion Task in Python] Write a function \`binary_search\` that takes a sorted list of integers \`arr\` (0 <= len(arr) <= 1000) and an integer \`target\`. The function should use the Binary Search algorithm to find the index of \`target\` in the list \`arr\`. If \`target\` exists in the list, the function should return its index. Otherwise, the function should return \`-1\`. Constraints: - The input list can be empty. - All integers are within the range [-10^6, 10^6]. - Do not use any in-built search functions. - Implement the search logic using the Binary Search algorithm. Function Signature: def binary_search(arr: List[int], target: int) -> int: pass Examples: assert binary_search([1, 2, 3, 4, 5], 4) == 3 assert binary_search([1, 2, 3, 4, 5], 6) == -1 assert binary_search([1, 2, 3, 4, 5], 1) == 0 assert binary_search([], 10) == -1 assert binary_search([-3, -1, 2, 3, 6], 2) == 2","solution":"def binary_search(arr, target): Uses Binary Search algorithm to find the index of the target in arr. Returns -1 if the target is not found. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"import heapq def optimized_dijkstra(graph: dict, start: str) -> dict: Optimized Dijkstra's algorithm to find the shortest path in a graph. :param graph: Dictionary where keys are node identifiers and values are dictionaries with neighboring node identifiers as keys and edge weights as values. :param start: Starting node identifier :return: Dictionary with node identifiers as keys and their respective minimum distance from the starting node as values >>> graph = { ... 'A': {'B': 1, 'C': 4}, ... 'B': {'C': 2, 'D': 5}, ... 'C': {'D': 1}, ... 'D': {} ... } >>> start = 'A' >>> optimized_dijkstra(graph, start) {'A': 0, 'B': 1, 'C': 3, 'D': 4} >>> graph = { ... 'A': {'B': 1}, ... 'B': {}, ... 'C': {'D': 1}, ... 'D': {} ... } >>> start = 'A' >>> optimized_dijkstra(graph, start) {'A': 0, 'B': 1, 'C': inf, 'D': inf} >>> graph = { ... 'A': {'B': 1000}, ... 'B': {'C': 2000}, ... 'C': {'A': 1500}, ... 'D': {'A': 2000} ... } >>> start = 'D' >>> optimized_dijkstra(graph, start) {'A': 2000, 'B': 3000, 'C': 5000, 'D': 0} >>> graph = { ... 'A': {} ... } >>> start = 'A' >>> optimized_dijkstra(graph, start) {'A': 0} >>> graph = { ... 'A': {'B': 2, 'C': 1}, ... 'B': {'C': 1, 'D': 2}, ... 'C': {'D': 4, 'E': 2}, ... 'D': {'E': 1}, ... 'E': {} ... } >>> start = 'A' >>> optimized_dijkstra(graph, start) {'A': 0, 'B': 2, 'C': 1, 'D': 4, 'E': 3}","solution":"import heapq def optimized_dijkstra(graph, start): Optimized Dijkstra's algorithm to find the shortest path in a graph. :param graph: Dictionary where keys are node identifiers and values are dictionaries with neighboring node identifiers as keys and edge weights as values. :param start: Starting node identifier :return: Dictionary with node identifiers as keys and their respective minimum distance from the starting node as values # Min-heap priority queue priority_queue = [(0, start)] # Dictionary to store shortest path to each node distances = {node: float('inf') for node in graph} distances[start] = 0 while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip processing if we have already found a better way if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it's better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"class TextCompression: def compress(self, text: str) -> str: Compresses the input string \`text\` using Run Length Encoding (RLE) and returns the compressed string. Consecutive occurrences of the same character are replaced with the character followed by the number of occurrences. For example, the input string \\"aaabccddd\\" should be compressed to \\"a3b1c2d3\\". Args: text (str): The input string to be compressed. Returns: str: The compressed string. >>> compressor = TextCompression() >>> compressor.compress(\\"aaabccddd\\") \\"a3b1c2d3\\" >>> compressor.compress(\\"\\") \\"\\" >>> compressor.compress(\\"abcd\\") \\"a1b1c1d1\\" pass def decompress(self, compressed_text: str) -> str: Decompresses the RLE compressed string \`compressed_text\` back to its original form and returns the decompressed string. The compressed string format is guaranteed to be in the correct format as output by the \`compress\` method. For example, the input string \\"a3b1c2d3\\" should be decompressed to \\"aaabccddd\\". Args: compressed_text (str): The compressed string to be decompressed. Returns: str: The decompressed string. >>> compressor = TextCompression() >>> compressor.decompress(\\"a3b1c2d3\\") \\"aaabccddd\\" >>> compressor.decompress(\\"\\") \\"\\" >>> compressor.decompress(\\"a1b1c1d1\\") \\"abcd\\" pass def test_compress_empty_string(): compressor = TextCompression() assert compressor.compress(\\"\\") == \\"\\" def test_decompress_empty_string(): compressor = TextCompression() assert compressor.decompress(\\"\\") == \\"\\" def test_compress_no_repeated_chars(): compressor = TextCompression() assert compressor.compress(\\"abcd\\") == \\"a1b1c1d1\\" def test_decompress_no_repeated_chars(): compressor = TextCompression() assert compressor.decompress(\\"a1b1c1d1\\") == \\"abcd\\" def test_compress_simple_repeated_chars(): compressor = TextCompression() assert compressor.compress(\\"aaabccddd\\") == \\"a3b1c2d3\\" def test_decompress_simple_repeated_chars(): compressor = TextCompression() assert compressor.decompress(\\"a3b1c2d3\\") == \\"aaabccddd\\" def test_compress_long_repeated_chars(): compressor = TextCompression() assert compressor.compress(\\"aaaaabbbbcccc\\") == \\"a5b4c4\\" def test_decompress_long_repeated_chars(): compressor = TextCompression() assert compressor.decompress(\\"a5b4c4\\") == \\"aaaaabbbbcccc\\" def test_compress_mixed_chars(): compressor = TextCompression() assert compressor.compress(\\"aaabbbcccaaa\\") == \\"a3b3c3a3\\" def test_decompress_mixed_chars(): compressor = TextCompression() assert compressor.decompress(\\"a3b3c3a3\\") == \\"aaabbbcccaaa\\" def test_compress_single_char(): compressor = TextCompression() assert compressor.compress(\\"a\\") == \\"a1\\" def test_decompress_single_char(): compressor = TextCompression() assert compressor.decompress(\\"a1\\") == \\"a\\"","solution":"class TextCompression: def compress(self, text: str) -> str: if not text: return \\"\\" compressed = [] n = len(text) i = 0 while i < n: count = 1 while i + 1 < n and text[i] == text[i + 1]: i += 1 count += 1 compressed.append(f\\"{text[i]}{count}\\") i += 1 return ''.join(compressed) def decompress(self, compressed_text: str) -> str: if not compressed_text: return \\"\\" decompressed = [] n = len(compressed_text) i = 0 while i < n: char = compressed_text[i] count = 0 i += 1 while i < n and compressed_text[i].isdigit(): count = count * 10 + int(compressed_text[i]) i += 1 decompressed.append(char * count) return ''.join(decompressed)"},{"question":"import numpy as np def rmsprop_update(theta, gradients, learning_rate, beta, epsilon, Eg2): Applies one step of RMSprop optimization to update the parameters. Parameters: - theta: numpy array of parameters. - gradients: numpy array of gradients with respect to each parameter. - learning_rate: the learning rate (eta). - beta: the decay rate for the moving average. - epsilon: a small constant to avoid division by zero. - Eg2: the running average of the squared gradients. Computational Constraints: - Avoid using loops. - Input array size can be up to 10^6 elements. - The function should execute in linear time relative to the size of the input arrays. # Implement RMSprop update here pass # Unit Test def test_rmsprop_update(): theta = np.array([1.0, 2.0, 3.0]) gradients = np.array([0.1, -0.2, 0.3]) learning_rate = 0.01 beta = 0.9 epsilon = 1e-8 Eg2 = np.zeros_like(theta) # Expected values after one RMSprop update expected_Eg2 = beta * Eg2 + (1 - beta) * (gradients ** 2) expected_theta = theta - learning_rate * gradients / (np.sqrt(expected_Eg2) + epsilon) updated_Eg2 = rmsprop_update(theta, gradients, learning_rate, beta, epsilon, Eg2) assert np.allclose(updated_Eg2, expected_Eg2), f\\"Eg2 not as expected: {updated_Eg2} != {expected_Eg2}\\" assert np.allclose(theta, expected_theta), f\\"Theta not as expected: {theta} != {expected_theta}\\" def test_rmsprop_update_zero_gradients(): theta = np.array([1.5, -2.5, 3.5]) gradients = np.array([0.0, 0.0, 0.0]) learning_rate = 0.01 beta = 0.9 epsilon = 1e-8 Eg2 = np.zeros_like(theta) # Expected values after one RMSprop update with zero gradients expected_Eg2 = beta * Eg2 + (1 - beta) * (gradients ** 2) expected_theta = theta - learning_rate * gradients / (np.sqrt(expected_Eg2) + epsilon) updated_Eg2 = rmsprop_update(theta, gradients, learning_rate, beta, epsilon, Eg2) assert np.allclose(updated_Eg2, expected_Eg2), f\\"Eg2 not as expected: {updated_Eg2} != {expected_Eg2}\\" assert np.allclose(theta, expected_theta), f\\"Theta not as expected: {theta} != {expected_theta}\\" def test_rmsprop_update_with_different_beta(): theta = np.array([1.0, 2.0, 3.0]) gradients = np.array([0.1, -0.2, 0.3]) learning_rate = 0.01 beta = 0.99 epsilon = 1e-8 Eg2 = np.zeros_like(theta) # Expected values after one RMSprop update with different beta expected_Eg2 = beta * Eg2 + (1 - beta) * (gradients ** 2) expected_theta = theta - learning_rate * gradients / (np.sqrt(expected_Eg2) + epsilon) updated_Eg2 = rmsprop_update(theta, gradients, learning_rate, beta, epsilon, Eg2) assert np.allclose(updated_Eg2, expected_Eg2), f\\"Eg2 not as expected: {updated_Eg2} != {expected_Eg2}\\" assert np.allclose(theta, expected_theta), f\\"Theta not as expected: {theta} != {expected_theta}\\" def test_rmsprop_update_large_parameters(): theta = np.random.rand(10**6) gradients = np.random.rand(10**6) learning_rate = 0.01 beta = 0.9 epsilon = 1e-8 Eg2 = np.zeros_like(theta) expected_Eg2 = beta * Eg2 + (1 - beta) * (gradients ** 2) expected_theta = theta - learning_rate * gradients / (np.sqrt(expected_Eg2) + epsilon) updated_Eg2 = rmsprop_update(theta, gradients, learning_rate, beta, epsilon, Eg2) assert np.allclose(updated_Eg2, expected_Eg2), f\\"Eg2 not as expected\\" assert np.allclose(theta, expected_theta), f\\"Theta not as expected\\"","solution":"import numpy as np def rmsprop_update(theta, gradients, learning_rate, beta, epsilon, Eg2): Applies one step of RMSprop optimization to update the parameters. Parameters: - theta: numpy array of parameters. - gradients: numpy array of gradients with respect to each parameter. - learning_rate: the learning rate (eta). - beta: the decay rate for the moving average. - epsilon: a small constant to avoid division by zero. - Eg2: the running average of the squared gradients. Returns: - Updated Eg2 and theta in place. Eg2 = beta * Eg2 + (1 - beta) * (gradients ** 2) theta -= learning_rate * gradients / (np.sqrt(Eg2) + epsilon) return Eg2"},{"question":"from typing import List def custom_softmax(vector: List[float]) -> List[float]: Computes the softmax of a list of numbers, returning their probabilities. :param vector: A list of float numbers :return: A list of softmax probabilities corresponding to the input list >>> custom_softmax([1.0, 2.0, 3.0]) [0.09003057, 0.24472847, 0.66524096] >>> custom_softmax([-1.0, 0.0, 1.0]) [0.09003057, 0.24472847, 0.66524096] >>> custom_softmax([2.0, 2.0, 2.0]) [0.33333333, 0.33333333, 0.33333333] >>> custom_softmax([1000.0, 1001.0, 1002.0]) [0.09003057, 0.24472847, 0.66524096] >>> custom_softmax([10.0]) [1.0] >>> custom_softmax([]) [] >>> custom_softmax([-1000.0, -1001.0, -1002.0]) [0.66524096, 0.24472847, 0.09003057]","solution":"from typing import List import math def custom_softmax(vector: List[float]) -> List[float]: Computes the softmax of a list of numbers, returning their probabilities. :param vector: A list of float numbers :return: A list of softmax probabilities corresponding to the input list if not vector: return [] max_val = max(vector) exps = [math.exp(i - max_val) for i in vector] sum_exps = sum(exps) return [j / sum_exps for j in exps]"},{"question":"# Palindrome Substring Finder **Context**: A palindrome is a word, phrase, number, or other sequences of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Detecting palindromic substrings within a string is an intriguing problem with applications in pattern recognition, bioinformatics, and text processing. You have several functions to find palindromic substrings within a string: 1. \`find_palindromes_sub1(s: str) -> List[str]\` 2. \`find_palindromes_sub2(s: str) -> List[str]\` 3. \`find_palindromes_sub3(s: str) -> List[str]\` # Task Your task is to implement a new function that returns all distinct palindromic substrings in a given string using a method different from the provided functions. Your solution will be assessed based on correctness, uniqueness of the approach, and efficiency in handling various edge cases. # Specification * **Function Name**: \`improved_find_palindromes\` * **Input**: - \`s\` (str): a string which may contain letters, numbers, and symbols * **Output**: - Returns \`List[str]\`: a list of distinct palindromic substrings in the given string. # Constraints - The input string \`s\` will have a maximum length of \`1000\` characters. - Your solution should handle edge cases such as empty strings, single-character strings, and strings without any palindromic substrings. - Your implementation should not replicate the provided functions directly but aim to offer a different and possibly more optimized approach. # Examples >>> improved_find_palindromes(\\"ababa\\") [\\"a\\", \\"aba\\", \\"ababa\\", \\"b\\", \\"bab\\"] >>> improved_find_palindromes(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> improved_find_palindromes(\\"\\") [] >>> improved_find_palindromes(\\"a\\") [\\"a\\"] >>> improved_find_palindromes(\\"racecar\\") [\\"a\\", \\"aceca\\", \\"c\\", \\"cec\\", \\"e\\", \\"r\\", \\"racecar\\"] # Additional Requirement Include a brief paragraph in your solution describing why your approach is distinct and any trade-offs made. # Bonuses 1. **Runtime Efficiency**: Provide a runtime analysis comparing your implementation with the given functions for large strings. 2. **Memory Efficiency**: Discuss any memory overhead reductions your implementation achieves compared to other popular methods such as expanding centers. Unit Test: def test_improved_find_palindromes_all_palindromes(): assert improved_find_palindromes(\\"ababa\\") == [\\"a\\", \\"aba\\", \\"ababa\\", \\"b\\", \\"bab\\"] def test_improved_find_palindromes_no_palindromes(): assert improved_find_palindromes(\\"abc\\") == [\\"a\\", \\"b\\", \\"c\\"] def test_improved_find_palindromes_empty_string(): assert improved_find_palindromes(\\"\\") == [] def test_improved_find_palindromes_single_character(): assert improved_find_palindromes(\\"a\\") == [\\"a\\"] def test_improved_find_palindromes_single_palindrome(): assert improved_find_palindromes(\\"racecar\\") == [\\"a\\", \\"aceca\\", \\"c\\", \\"cec\\", \\"e\\", \\"r\\", \\"racecar\\"] def test_improved_find_palindromes_mixed_palindromes(): assert improved_find_palindromes(\\"abccba\\") == [\\"a\\", \\"abccba\\", \\"b\\", \\"bccb\\", \\"c\\", \\"cc\\"] Solution: def improved_find_palindromes(s: str) -> list: Returns all distinct palindromic substrings in the given string. def is_palindrome(sub: str) -> bool: return sub == sub[::-1] palindromes = set() n = len(s) # Check for each substring for i in range(n): for j in range(i + 1, n + 1): sub = s[i:j] if is_palindrome(sub): palindromes.add(sub) return sorted(list(palindromes)) # Explanation: # This approach uses a simple nested loop to generate all possible substrings. # It then checks if each substring is a palindrome and adds it to a set to ensure uniqueness. # This approach is distinct from expanding center methods or dynamic programming as it directly generates substrings. # The trade-off here is potentially higher time complexity due to the nested loop structure, # but it simplifies the handling of all unique palindromic substrings directly via a set.","solution":"def improved_find_palindromes(s: str) -> list: Returns all distinct palindromic substrings in the given string. def is_palindrome(sub: str) -> bool: return sub == sub[::-1] palindromes = set() n = len(s) # Check for each substring for i in range(n): for j in range(i + 1, n + 1): sub = s[i:j] if is_palindrome(sub): palindromes.add(sub) return sorted(list(palindromes)) # Explanation: # This approach uses a simple nested loop to generate all possible substrings. # It then checks if each substring is a palindrome and adds it to a set to ensure uniqueness. # This approach is distinct from expanding center methods or dynamic programming as it directly generates substrings. # The trade-off here is potentially higher time complexity due to the nested loop structure, # but it simplifies the handling of all unique palindromic substrings directly via a set."},{"question":"def rotate_matrix_90(matrix): Rotates a square matrix by 90 degrees clockwise. Parameters: matrix : list[list[int]] A 2D list where each sublist represents a row of the matrix. Returns: list[list[int]] : A new 2D list representing the rotated matrix. Raises: ValueError : If the input is not a valid square matrix. >>> rotate_matrix_90([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90([[1]]) [[1]] >>> rotate_matrix_90([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]] >>> rotate_matrix_90([[1, 2, 3], [4, 5]]) Traceback (most recent call last): ... ValueError: The input must be a non-empty square matrix >>> rotate_matrix_90([]) Traceback (most recent call last): ... ValueError: The input must be a non-empty square matrix >>> rotate_matrix_90([[1, 2], [3, 4, 5]]) Traceback (most recent call last): ... ValueError: The input must be a non-empty square matrix pass","solution":"def rotate_matrix_90(matrix): Rotates a square matrix by 90 degrees clockwise. Parameters: matrix : list[list[int]] A 2D list where each sublist represents a row of the matrix. Returns: list[list[int]] : A new 2D list representing the rotated matrix. Raises: ValueError : If the input is not a valid square matrix. if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"The input must be a non-empty square matrix\\") n = len(matrix) # Initialize a new matrix with the same size as the original rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def checkValidString(s: str) -> bool: Determine whether a string containing the characters \`(\`, \`)\`, and \`*\` is valid. >>> checkValidString(\\"()\\") # Output: True >>> checkValidString(\\"(*)\\") # Output: True >>> checkValidString(\\"(*))\\") # Output: True >>> checkValidString(\\"(()*)\\") # Output: True >>> checkValidString(\\"*))\\") # Output: False >>> checkValidString(\\")(\\") # Output: False","solution":"def checkValidString(s: str) -> bool: low = high = 0 for char in s: if char == '(': low += 1 high += 1 elif char == ')': if low > 0: low -= 1 high -= 1 elif char == '*': if low > 0: low -= 1 high += 1 if high < 0: return False return low == 0"},{"question":"def word_break(s: str, word_dict: list) -> bool: Determines if the string s can be segmented into a sequence of one or more dictionary words. >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False >>> word_break(\\"aaaaaaa\\", [\\"aaa\\", \\"aaaa\\"]) == True","solution":"def word_break(s: str, word_dict: list) -> bool: Determines if the string s can be segmented into a sequence of one or more dictionary words. word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"from typing import List, Tuple def most_active_user(start_time: str, end_time: str, activities: List[Tuple[str, str]]) -> str: Determines the user with the most activities within the given time period. If there's a tie, returns the user with the lexicographically smaller user ID. Parameters: start_time (str): The start of the time period in the format 'YYYY-MM-DD HH:MM:SS'. end_time (str): The end of the time period in the format 'YYYY-MM-DD HH:MM:SS'. activities (List[Tuple[str, str]]): A list of tuples where each tuple contains a user ID and a timestamp in the format 'YYYY-MM-DD HH:MM:SS'. Returns: str: The user ID with the most frequent activities within the given time period. Examples: >>> activities = [ ... ('user_1', '2023-01-01 10:00:00'), ... ('user_2', '2023-01-01 11:00:00'), ... ('user_1', '2023-01-01 12:00:00'), ... ('user_3', '2023-01-01 12:30:00'), ... ('user_2', '2023-01-01 13:00:00'), ... ('user_2', '2023-01-01 14:00:00'), ... ('user_1', '2023-01-01 15:00:00') ... ] >>> most_active_user('2023-01-01 11:00:00', '2023-01-01 14:00:00', activities) 'user_2' >>> most_active_user('2023-01-01 09:00:00', '2023-01-01 12:00:00', activities) 'user_1'","solution":"from typing import List, Tuple from collections import defaultdict def most_active_user(start_time: str, end_time: str, activities: List[Tuple[str, str]]) -> str: Determines the user with the most activities within the given time period. If there's a tie, returns the user with the lexicographically smaller user ID. start_time = int(start_time.replace('-', '').replace(' ', '').replace(':', '')) end_time = int(end_time.replace('-', '').replace(' ', '').replace(':', '')) activity_count = defaultdict(int) for user_id, timestamp in activities: current_time = int(timestamp.replace('-', '').replace(' ', '').replace(':', '')) if start_time <= current_time <= end_time: activity_count[user_id] += 1 # Find the user with the maximum activities most_active = sorted(activity_count.items(), key=lambda x: (-x[1], x[0])) return most_active[0][0] if most_active else None"},{"question":"from typing import List, Tuple def prime_factorization(n: int) -> List[Tuple[int, int]]: Computes the prime factorization of a given integer n and returns a list of tuples where each tuple (p, c) represents a prime factor p of n and its count c. >>> prime_factorization(56) [(2, 3), (7, 1)] >>> prime_factorization(100) [(2, 2), (5, 2)] >>> prime_factorization(97) [(97, 1)] >>> prime_factorization(360) [(2, 3), (3, 2), (5, 1)] pass def test_prime_factorization_56(): assert prime_factorization(56) == [(2, 3), (7, 1)] def test_prime_factorization_100(): assert prime_factorization(100) == [(2, 2), (5, 2)] def test_prime_factorization_97(): assert prime_factorization(97) == [(97, 1)] def test_prime_factorization_360(): assert prime_factorization(360) == [(2, 3), (3, 2), (5, 1)] def test_prime_factorization_29(): assert prime_factorization(29) == [(29, 1)] def test_prime_factorization(): assert prime_factorization(1) == [] def test_prime_factorization_large(): n = 2**10 * 3**5 * 5**3 * 7**2 expected = [(2, 10), (3, 5), (5, 3), (7, 2)] assert prime_factorization(n) == expected def test_prime_factorization_largest_prime(): assert prime_factorization(999999937) == [(999999937, 1)]","solution":"def prime_factorization(n): Returns the prime factorization of a given integer n as a list of tuples where each tuple (p, c) represents a prime factor p of n and its count c. factors = [] count = 0 # Check for number of 2s in n while n % 2 == 0: n = n // 2 count += 1 if count > 0: factors.append((2, count)) # Check for odd factors starting from 3 p = 3 while p * p <= n: count = 0 while n % p == 0: n = n // p count += 1 if count > 0: factors.append((p, count)) p += 2 # If n becomes a prime number greater than 2 if n > 2: factors.append((n, 1)) return factors"},{"question":"def find_pythagorean_triplet(sum: int) -> tuple: Finds a Pythagorean triplet (a, b, c) such that a^2 + b^2 = c^2 and a + b + c = sum. >>> find_pythagorean_triplet(12) (3, 4, 5) >>> find_pythagorean_triplet(30) (5, 12, 13) >>> find_pythagorean_triplet(1000) (200, 375, 425) >>> find_pythagorean_triplet(17) () >>> find_pythagorean_triplet(1) ()","solution":"def find_pythagorean_triplet(target_sum): Finds a Pythagorean triplet (a, b, c) such that a^2 + b^2 = c^2 and a + b + c = target_sum. for a in range(1, target_sum): for b in range(a + 1, target_sum - a): c = target_sum - a - b if c > b and a * a + b * b == c * c: return (a, b, c) return ()"},{"question":"class PersistentStack: def __init__(self) -> None: Initialize the PersistentStack with an initial empty version 0. pass def push(self, version: int, value: int) -> int: Push a new element onto the stack, creating a new version. Args: version (int): The version number to push onto. value (int): The value to push onto the stack. Returns: int: The new version number. pass def pop(self, version: int) -> int: Pop the top element from the stack, creating a new version. Args: version (int): The version number to pop from. Returns: int: The new version number. pass def top(self, version: int) -> int: Retrieve the top element of a particular version of the stack. Args: version (int): The version number to retrieve the top element from. Returns: int: The top element of the specified version. pass def get_version(self, version: int) -> list: Get the stack of a particular version. Args: version (int): The version number to retrieve the stack from. Returns: list: The state of the stack at the specified version. pass def print_version(self, version: int) -> None: Print all elements of a particular version of the stack. Args: version (int): The version number to print the stack from. pass # Example usage: ps = PersistentStack() v1 = ps.push(0, 10) # Creates version 1 v2 = ps.push(v1, 20) # Creates version 2 v3 = ps.pop(v2) # Creates version 3 print(ps.top(v1)) # Output: 10 print(ps.top(v2)) # Output: 20 print(ps.top(v3)) # Output: 10 ps.print_version(v2) # Output: 20 10 ps.print_version(v3) # Output: 10","solution":"class PersistentStack: def __init__(self) -> None: self.versions = {0: []} # Initialize with version 0 as an empty list def push(self, version: int, value: int) -> int: if version not in self.versions: raise ValueError(\\"Version does not exist\\") new_version = len(self.versions) new_stack = self.versions[version][:] # Create a copy of the current stack new_stack.append(value) self.versions[new_version] = new_stack return new_version def pop(self, version: int) -> int: if version not in self.versions: raise ValueError(\\"Version does not exist\\") if not self.versions[version]: raise IndexError(\\"Cannot pop from an empty stack\\") new_version = len(self.versions) new_stack = self.versions[version][:] # Create a copy of the current stack new_stack.pop() self.versions[new_version] = new_stack return new_version def top(self, version: int) -> int: if version not in self.versions: raise ValueError(\\"Version does not exist\\") if not self.versions[version]: raise IndexError(\\"The stack is empty\\") return self.versions[version][-1] def get_version(self, version: int) -> list: if version not in self.versions: raise ValueError(\\"Version does not exist\\") return self.versions[version] def print_version(self, version: int) -> None: if version not in self.versions: raise ValueError(\\"Version does not exist\\") # Print each element from top to bottom for item in reversed(self.versions[version]): print(item)"},{"question":"import math def rotate_point(x: float, y: float, theta: float) -> tuple[float, float]: Rotates a point (x, y) by theta degrees around the origin. >>> rotate_point(1.0, 0.0, 90.0) (0.0, 1.0) >>> rotate_point(1.0, 0.0, 180.0) (-1.0, 0.0) >>> rotate_point(1.0, 1.0, 45.0) # Result will be approximately (0.0, sqrt(2)) def translate_rotated_point(x: float, y: float, theta: float, dx: float, dy: float) -> tuple[float, float]: Rotates a point (x, y) by theta degrees around the origin, then translates it by (dx, dy). >>> translate_rotated_point(1.0, 0.0, 90.0, 2.0, 3.0) (2.0, 4.0) >>> translate_rotated_point(1.0, 0.0, 180.0, -2.0, -3.0) (-3.0, -3.0) >>> translate_rotated_point(1.0, 1.0, 0.0, 2.0, 3.0) (3.0, 4.0)","solution":"import math def rotate_point(x: float, y: float, theta: float) -> tuple[float, float]: Rotates a point (x, y) by theta degrees around the origin. Returns the rotated point coordinates (rotated_x, rotated_y). radians = math.radians(theta) cos_theta = math.cos(radians) sin_theta = math.sin(radians) rotated_x = x * cos_theta - y * sin_theta rotated_y = x * sin_theta + y * cos_theta return rotated_x, rotated_y def translate_rotated_point(x: float, y: float, theta: float, dx: float, dy: float) -> tuple[float, float]: Rotates a point (x, y) by theta degrees around the origin, then translates it by (dx, dy). Returns the translated point coordinates (translated_x, translated_y). rotated_x, rotated_y = rotate_point(x, y, theta) translated_x = rotated_x + dx translated_y = rotated_y + dy return translated_x, translated_y"},{"question":"def find_first_last_occurrence(sorted_list: list, target: int) -> tuple: Find the first and last occurrence of a given target integer in a sorted list of integers. If the target is not found, return (-1, -1). >>> find_first_last_occurrence([1, 2, 2, 2, 3, 4, 5], 2) (1, 3) >>> find_first_last_occurrence([1, 2, 2, 2, 3, 4, 5], 3) (4, 4) >>> find_first_last_occurrence([1, 2, 2, 2, 3, 4, 5], 6) (-1, -1) >>> find_first_last_occurrence([1, 1, 1, 1, 1, 1, 1], 1) (0, 6) >>> find_first_last_occurrence([], 2) (-1, -1)","solution":"def find_first_last_occurrence(sorted_list, target): def binary_search(find_first): low, high, result = 0, len(sorted_list) - 1, -1 while low <= high: mid = (low + high) // 2 if sorted_list[mid] == target: result = mid if find_first: high = mid - 1 # Move left for the first occurrence else: low = mid + 1 # Move right for the last occurrence elif sorted_list[mid] < target: low = mid + 1 else: high = mid - 1 return result first_occurrence = binary_search(find_first=True) if first_occurrence == -1: return (-1, -1) last_occurrence = binary_search(find_first=False) return (first_occurrence, last_occurrence)"},{"question":"from typing import Optional, List, Any class Node: Node class represents the elements of the Singly Linked List. Attributes: value : int The value of the node. next : Optional[Node] The reference to the next node in the list. def __init__(self, value: int, next: 'Optional[Node]' = None) -> None: self.value: int = value self.next: Optional[Node] = next class SinglyLinkedList: SinglyLinkedList class to handle insertion, deletion, search, reversal, and getting list as array operations. Methods: insert(value: int, position: int) -> None: Inserts a value at the specified position in the SLL. delete(position: int) -> None: Deletes the node at the specified position in the SLL. search(value: int) -> Optional[int]: Searches for a value in the SLL and returns its position if found, otherwise returns None. reverse() -> None: Reverses the SLL in place. to_list() -> List[int]: Returns a list representation of the current SLL. def __init__(self) -> None: self.head: Optional[Node] = None def insert(self, value: int, position: int) -> None: Inserts a value at the specified position in the SLL. Parameters: value : int The value to be inserted. position : int The position where the value should be inserted. Example: >>> sll = SinglyLinkedList() >>> sll.insert(1, 0) >>> sll.insert(2, 1) >>> sll.insert(3, 2) >>> sll.to_list() [1, 2, 3] pass def delete(self, position: int) -> None: Deletes the node at the specified position in the SLL. Parameters: position : int The position of the node to be deleted. Example: >>> sll = SinglyLinkedList() >>> sll.insert(1, 0) >>> sll.insert(2, 1) >>> sll.insert(3, 2) >>> sll.delete(1) >>> sll.to_list() [1, 3] pass def search(self, value: int) -> Optional[int]: Searches for a value in the SLL and returns its position if found, otherwise returns None. Parameters: value : int The value to be searched. Example: >>> sll = SinglyLinkedList() >>> sll.insert(1, 0) >>> sll.insert(2, 1) >>> sll.insert(3, 2) >>> sll.search(3) 2 >>> sll.search(4) None pass def reverse(self) -> None: Reverses the SLL in place. Example: >>> sll = SinglyLinkedList() >>> sll.insert(1, 0) >>> sll.insert(2, 1) >>> sll.insert(3, 2) >>> sll.reverse() >>> sll.to_list() [3, 2, 1] pass def to_list(self) -> List[int]: Returns a list representation of the current SLL. Example: >>> sll = SinglyLinkedList() >>> sll.to_list() [] >>> sll.insert(1, 0) >>> sll.insert(2, 1) >>> sll.to_list() [1, 2] pass","solution":"from typing import Optional, List class Node: def __init__(self, value: int, next: 'Optional[Node]' = None) -> None: self.value: int = value self.next: Optional[Node] = next class SinglyLinkedList: def __init__(self) -> None: self.head: Optional[Node] = None def insert(self, value: int, position: int) -> None: new_node = Node(value) if position == 0: new_node.next = self.head self.head = new_node return current = self.head for _ in range(position - 1): current = current.next new_node.next = current.next current.next = new_node def delete(self, position: int) -> None: if position == 0: self.head = self.head.next return current = self.head for _ in range(position - 1): current = current.next current.next = current.next.next def search(self, value: int) -> Optional[int]: current = self.head position = 0 while current is not None: if current.value == value: return position current = current.next position += 1 return None def reverse(self) -> None: prev = None current = self.head while current is not None: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def to_list(self) -> List[int]: result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result"},{"question":"def normalize_task_duration(duration: float, unit: str) -> float: Converts the given task duration into hours. Parameters: duration (float): The numeric value representing the task duration. unit (str): The unit of the duration. Returns: float: The duration converted into hours. Raises: ValueError: If either the duration value or unit string is invalid. >>> normalize_task_duration(2, \\"days\\") 48.0 >>> normalize_task_duration(3, \\"weeks\\") 504.0 >>> normalize_task_duration(120, \\"minutes\\") 2.0 >>> normalize_task_duration(5, \\"years\\") Traceback (most recent call last): ... ValueError: Invalid 'unit' value: 'years'. Supported values are: weeks, days, hours, minutes >>> normalize_task_duration(4, \\"hours\\") 4.0","solution":"def normalize_task_duration(duration, unit): Converts the given task duration into hours. Parameters: duration (float): The numeric value representing the task duration. unit (str): The unit of the duration. Returns: float: The duration converted into hours. Raises: ValueError: If either the duration value or unit string is invalid. if not isinstance(duration, (int, float)) or duration < 0: raise ValueError(f\\"Invalid 'duration' value: {duration}. Must be a non-negative number.\\") conversion_factors = { 'weeks': 168, 'days': 24, 'hours': 1, 'minutes': 1/60 } if unit not in conversion_factors: raise ValueError(f\\"Invalid 'unit' value: '{unit}'. Supported values are: weeks, days, hours, minutes\\") return duration * conversion_factors[unit]"},{"question":"class Parcel: def __init__(self, parcel_id: int, description: str) -> None: Initialize a new parcel with the given id and description. Args: parcel_id (int): The unique identifier for the parcel. description (str): A brief description of the parcel. class ParcelTrackingSystem: def __init__(self) -> None: Initialize the parcel tracking system with an empty list of parcels. def add_parcel(self, parcel: Parcel) -> None: Add a new parcel to the tracking system. Args: parcel (Parcel): The parcel object to be added. def update_status(self, parcel_id: int, status: str) -> None: Update the status of a parcel given its id. Args: parcel_id (int): The unique identifier of the parcel to update. status (str): The new status of the parcel. def get_status(self, parcel_id: int) -> str: Get the current status of a parcel given its id. Args: parcel_id (int): The unique identifier of the parcel to retrieve status. Returns: str: The current status of the parcel. def list_parcels(self) -> list: List all the parcels in the system with their ids, descriptions, and statuses. Returns: list: A list of dictionaries where each dictionary represents a parcel with 'id', 'description', and 'status' keys.","solution":"class Parcel: def __init__(self, parcel_id: int, description: str) -> None: Initialize a new parcel with the given id and description. Args: parcel_id (int): The unique identifier for the parcel. description (str): A brief description of the parcel. self.parcel_id = parcel_id self.description = description self.status = 'Pending' # Default status when the parcel is created class ParcelTrackingSystem: def __init__(self) -> None: Initialize the parcel tracking system with an empty list of parcels. self.parcels = {} def add_parcel(self, parcel: Parcel) -> None: Add a new parcel to the tracking system. Args: parcel (Parcel): The parcel object to be added. self.parcels[parcel.parcel_id] = parcel def update_status(self, parcel_id: int, status: str) -> None: Update the status of a parcel given its id. Args: parcel_id (int): The unique identifier of the parcel to update. status (str): The new status of the parcel. if parcel_id in self.parcels: self.parcels[parcel_id].status = status def get_status(self, parcel_id: int) -> str: Get the current status of a parcel given its id. Args: parcel_id (int): The unique identifier of the parcel to retrieve status. Returns: str: The current status of the parcel. if parcel_id in self.parcels: return self.parcels[parcel_id].status else: return \\"Parcel not found\\" def list_parcels(self) -> list: List all the parcels in the system with their ids, descriptions, and statuses. Returns: list: A list of dictionaries where each dictionary represents a parcel with 'id', 'description', and 'status' keys. return [ { 'id': parcel.parcel_id, 'description': parcel.description, 'status': parcel.status } for parcel in self.parcels.values() ]"},{"question":"from typing import List, Tuple def optimal_delivery_route(locations: List[Tuple[int, int]], main_distribution_center: Tuple[int, int]) -> List[Tuple[int, int]]: Find the optimal route to visit all given locations exactly once starting and ending at the main distribution center using a greedy algorithm. >>> optimal_delivery_route([(1, 1), (2, 2), (3, 3)], (0, 0)) [(0, 0), (1, 1), (2, 2), (3, 3), (0, 0)] >>> optimal_delivery_route([(5, 5), (2, 1), (4, 3)], (0, 0)) [(0, 0), (2, 1), (4, 3), (5, 5), (0, 0)] >>> optimal_delivery_route([(10, 10), (20, 20), (30, 30), (40, 40)], (0, 0)) [(0, 0), (10, 10), (20, 20), (30, 30), (40, 40), (0, 0)] >>> optimal_delivery_route([(-1, -1), (-2, -2), (-3, -3)], (0, 0)) [(0, 0), (-1, -1), (-2, -2), (-3, -3), (0, 0)]","solution":"from typing import List, Tuple import math def euclidean_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def optimal_delivery_route(locations: List[Tuple[int, int]], main_distribution_center: Tuple[int, int]) -> List[Tuple[int, int]]: Finds the optimal route to visit all given locations exactly once starting and ending at the main distribution center using a greedy algorithm. unvisited = locations[:] current_location = main_distribution_center route = [current_location] while unvisited: # Find the nearest unvisited location nearest_location = min(unvisited, key=lambda loc: euclidean_distance(current_location, loc)) # Move to the nearest location current_location = nearest_location route.append(current_location) unvisited.remove(nearest_location) # Return to the main distribution center route.append(main_distribution_center) return route"},{"question":"def highlight_pattern(text: str, pattern: str) -> str: Find and highlight all occurrences of a given pattern in the text. :param text: str, input text to search within :param pattern: str, pattern to search for :return: str, text with all occurrences of the pattern highlighted >>> highlight_pattern(\\"This is a simple example. Simple solutions can be effective.\\", \\"simple\\") \\"This is a [simple] example. Simple solutions can be effective.\\" >>> highlight_pattern(\\"ABABABA\\", \\"ABA\\") \\"[ABA]B[ABA]\\" >>> highlight_pattern(\\"This is a test.\\", \\"\\") \\"This is a test.\\" >>> highlight_pattern(\\"Hello, world!\\", \\"test\\") \\"Hello, world!\\" >>> highlight_pattern(\\"banana banana banana\\", \\"banana\\") \\"[banana] [banana] [banana]\\"","solution":"def highlight_pattern(text: str, pattern: str) -> str: Find and highlight all occurrences of a given pattern in the text. :param text: str, input text to search within :param pattern: str, pattern to search for :return: str, text with all occurrences of the pattern highlighted if not pattern: return text highlighted_text = \\"\\" i = 0 while i < len(text): if text[i:i+len(pattern)] == pattern: highlighted_text += f\\"[{pattern}]\\" i += len(pattern) - 1 else: highlighted_text += text[i] i += 1 return highlighted_text"},{"question":"def validate_stack_operations(operations: list[str], expected_output: list[int]) -> bool: Validates the sequence of stack operations against the expected output. :param operations: List of stack operations to perform. Each operation is 'PUSH x' or 'POP'. :param expected_output: List of integers representing the expected sequence of outputs from the 'POP' operations. :return: True if the stack operations produce the expected sequence of outputs, False otherwise. >>> validate_stack_operations(['PUSH 1', 'PUSH 2', 'POP', 'POP'], [2, 1]) True >>> validate_stack_operations(['PUSH 1', 'PUSH 2', 'POP', 'PUSH 3', 'POP'], [2, 3]) True >>> validate_stack_operations(['PUSH 1', 'PUSH 2', 'POP', 'PUSH 3', 'POP'], [2, 1]) False >>> validate_stack_operations(['POP'], []) False >>> validate_stack_operations(['PUSH 1', 'PUSH 2'], []) True >>> validate_stack_operations(['PUSH 1', 'PUSH 2', 'POP', 'POP'], [1, 2]) False >>> validate_stack_operations(['PUSH {}'.format(i) for i in range(1, 10001)] + ['POP' for _ in range(10000)], list(range(10000, 0, -1))) True","solution":"def validate_stack_operations(operations: list[str], expected_output: list[int]) -> bool: Validates the sequence of stack operations against the expected output. :param operations: List of stack operations to perform. Each operation is 'PUSH x' or 'POP'. :param expected_output: List of integers representing the expected sequence of outputs from the 'POP' operations. :return: True if the stack operations produce the expected sequence of outputs, False otherwise. stack = [] output_index = 0 for operation in operations: if operation.startswith('PUSH '): _, value = operation.split() stack.append(int(value)) elif operation == 'POP': if not stack: return False popped_value = stack.pop() if output_index < len(expected_output) and expected_output[output_index] == popped_value: output_index += 1 else: return False return output_index == len(expected_output)"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def in_order_traversal(self): return self._in_order_traversal(self.root, []) def _in_order_traversal(self, root, result): if root: self._in_order_traversal(root.left, result) result.append(root.val) self._in_order_traversal(root.right, result) return result def find_height(self): Find the height of the binary tree. Returns: An integer representing the height of the binary tree. def zigzag_traversal(self): Return the node values in zigzag level order traversal. Returns: A list of integers representing the node values in zigzag level order. # You can run your tests here bt = BinaryTree() bt.insert(10) bt.insert(5) bt.insert(15) bt.insert(3) bt.insert(7) bt.insert(13) bt.insert(18) print(bt.find_height()) # Expected: 2 print(bt.zigzag_traversal()) # Expected: [10, 15, 5, 3, 7, 13, 18]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinaryTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def in_order_traversal(self): return self._in_order_traversal(self.root, []) def _in_order_traversal(self, root, result): if root: self._in_order_traversal(root.left, result) result.append(root.val) self._in_order_traversal(root.right, result) return result def find_height(self): return self._find_height(self.root) def _find_height(self, node): if node is None: return -1 left_height = self._find_height(node.left) right_height = self._find_height(node.right) return 1 + max(left_height, right_height) def zigzag_traversal(self): if not self.root: return [] result, temp, stack, flag = [], [], [self.root], 1 while stack: for i in range(len(stack)): node = stack.pop(0) temp.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) result += temp[::flag] temp = [] flag *= -1 return result"},{"question":"def is_synchronized(dir1: dict, dir2: dict) -> bool: Check if two directory trees are synchronized. :param dir1: dict, a tree representation of the first directory :param dir2: dict, a tree representation of the second directory :return: bool, True if directories are synchronized, False otherwise def test_identical_directories(): dir1 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id2\\", }, \\"subdir2\\": { \\"file3\\": \\"id3\\", } } } dir2 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id2\\", }, \\"subdir2\\": { \\"file3\\": \\"id3\\", } } } assert is_synchronized(dir1, dir2) == True def test_different_directories(): dir1 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id2\\", }, \\"subdir2\\": { \\"file3\\": \\"id3\\", } } } dir2 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id2\\", }, \\"subdir2\\": { \\"file4\\": \\"id4\\", } } } assert is_synchronized(dir1, dir2) == False def test_empty_directories(): dir1 = {} dir2 = {} assert is_synchronized(dir1, dir2) == True def test_missing_subdirectory(): dir1 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", }, \\"subdir2\\": { \\"file2\\": \\"id2\\", } } } dir2 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", } } } assert is_synchronized(dir1, dir2) == False def test_different_file_ids(): dir1 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id2\\", }, } } dir2 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", \\"file2\\": \\"id3\\", # Different id for file2 }, } } assert is_synchronized(dir1, dir2) == False def test_different_structure_same_files(): dir1 = { \\"root\\": { \\"subdir1\\": { \\"subdir2\\": { \\"file1\\": \\"id1\\", }, }, } } dir2 = { \\"root\\": { \\"subdir1\\": { \\"file1\\": \\"id1\\", }, \\"subdir2\\": {} # Empty subdir2 at the same level as subdir1 } } assert is_synchronized(dir1, dir2) == False","solution":"def is_synchronized(dir1: dict, dir2: dict) -> bool: Check if two directory trees are synchronized. :param dir1: dict, a tree representation of the first directory :param dir2: dict, a tree representation of the second directory :return: bool, True if directories are synchronized, False otherwise def _compare_dirs(d1, d2): if d1.keys() != d2.keys(): return False for key in d1: if isinstance(d1[key], dict) and isinstance(d2[key], dict): if not _compare_dirs(d1[key], d2[key]): return False elif d1[key] != d2[key]: return False return True return _compare_dirs(dir1, dir2)"},{"question":"class Inventory: def __init__(self): Initialize the inventory system. pass def add_item(self, item_name: str, quantity: int, price: float) -> None: Add a new item to the inventory with given quantity and price. Parameters: item_name (str): The name of the item. quantity (int): The number of items. price (float): The price per item. Returns: None pass def update_quantity(self, item_name: str, quantity: int) -> None: Update the quantity of an existing item in the inventory. Parameters: item_name (str): The name of the item. quantity (int): The number of items to update. Returns: None Raises: ValueError: If the item does not exist in inventory. pass def record_sale(self, item_name: str, quantity: int) -> None: Record the sale of items from the inventory. Parameters: item_name (str): The name of the item. quantity (int): The number of items sold. Returns: None Raises: ValueError: If the item does not exist in inventory or not enough quantity. pass def get_stock_report(self) -> dict: Generate a stock report of current inventory levels. Returns: dict: A dictionary where keys are item names and values are tuples containing the current quantity and price of each item. pass import pytest def test_add_new_item(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50, 0.5) assert inventory.get_stock_report() == {'Apple': (50, 0.50)} def test_add_existing_item(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50, 0.5) inventory.add_item(\\"Apple\\", 20, 0.5) assert inventory.get_stock_report() == {'Apple': (70, 0.50)} def test_update_quantity(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50, 0.5) inventory.update_quantity(\\"Apple\\", 20) assert inventory.get_stock_report() == {'Apple': (70, 0.50)} def test_update_quantity_nonexistent_item(): inventory = Inventory() with pytest.raises(ValueError, match=\\"Item 'Banana' does not exist in inventory.\\"): inventory.update_quantity(\\"Banana\\", 20) def test_record_sale(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50, 0.5) inventory.record_sale(\\"Apple\\", 30) assert inventory.get_stock_report() == {'Apple': (20, 0.50)} def test_record_sale_nonexistent_item(): inventory = Inventory() with pytest.raises(ValueError, match=\\"Item 'Banana' does not exist in inventory.\\"): inventory.record_sale(\\"Banana\\", 10) def test_record_sale_insufficient_quantity(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50, 0.5) with pytest.raises(ValueError, match=\\"Not enough quantity of 'Apple' to record sale.\\"): inventory.record_sale(\\"Apple\\", 60) def test_get_stock_report(): inventory = Inventory() inventory.add_item(\\"Apple\\", 50, 0.5) inventory.add_item(\\"Banana\\", 100, 0.2) assert inventory.get_stock_report() == {'Apple': (50, 0.50), 'Banana': (100, 0.20)}","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, item_name: str, quantity: int, price: float) -> None: if item_name not in self.items: self.items[item_name] = (quantity, round(price, 2)) else: current_quantity, current_price = self.items[item_name] self.items[item_name] = (current_quantity + quantity, round(price, 2)) def update_quantity(self, item_name: str, quantity: int) -> None: if item_name in self.items: current_quantity, price = self.items[item_name] self.items[item_name] = (current_quantity + quantity, price) else: raise ValueError(f\\"Item '{item_name}' does not exist in inventory.\\") def record_sale(self, item_name: str, quantity: int) -> None: if item_name in self.items: current_quantity, price = self.items[item_name] if quantity > current_quantity: raise ValueError(f\\"Not enough quantity of '{item_name}' to record sale.\\") self.items[item_name] = (current_quantity - quantity, price) else: raise ValueError(f\\"Item '{item_name}' does not exist in inventory.\\") def get_stock_report(self) -> dict: return {item: (quantity, price) for item, (quantity, price) in self.items.items()}"},{"question":"class Inventory: A class used to manage store inventory by allowing addition, removal, and viewing of products. Usage: >>> store_inventory = Inventory() >>> store_inventory.add_product(1, \\"apple\\", 10, 0.5) >>> store_inventory.add_product(2, \\"banana\\", 20, 0.2) >>> store_inventory.get_inventory() # Expected output: [{'product_id': 1, 'name': 'apple', 'quantity': 10, 'price': 0.5}, # {'product_id': 2, 'name': 'banana', 'quantity': 20, 'price': 0.2}] Methods: add_product(product_id: int, name: str, quantity: int, price: float): Adds a new product or updates an existing one in the inventory. remove_product(product_id: int): Removes a product from the inventory by its product_id. get_inventory(): Returns a list of dictionaries representing all products in the inventory. def __init__(self): self.products = {} def add_product(self, product_id: int, name: str, quantity: int, price: float): Adds a new product to the inventory with the given details. If the product_id already exists, updates the existing product's details. def remove_product(self, product_id: int): Removes the product with the given product_id from the inventory. Raises ValueError if the product_id does not exist. def get_inventory(self): Returns a list of all products currently in the inventory. import pytest def test_add_product(): inv = Inventory() inv.add_product(1, \\"apple\\", 10, 0.5) assert inv.get_inventory() == [{'product_id': 1, 'name': 'apple', 'quantity': 10, 'price': 0.5}] def test_add_existing_product_updates(): inv = Inventory() inv.add_product(1, \\"apple\\", 10, 0.5) inv.add_product(1, \\"apple\\", 20, 0.3) assert inv.get_inventory() == [{'product_id': 1, 'name': 'apple', 'quantity': 20, 'price': 0.3}] def test_remove_product(): inv = Inventory() inv.add_product(1, \\"apple\\", 10, 0.5) inv.remove_product(1) assert inv.get_inventory() == [] def test_remove_non_existing_product_raises_error(): inv = Inventory() with pytest.raises(ValueError): inv.remove_product(1) def test_get_inventory(): inv = Inventory() inv.add_product(1, \\"apple\\", 10, 0.5) inv.add_product(2, \\"banana\\", 20, 0.2) assert inv.get_inventory() == [ {'product_id': 1, 'name': 'apple', 'quantity': 10, 'price': 0.5}, {'product_id': 2, 'name': 'banana', 'quantity': 20, 'price': 0.2} ] if __name__ == \\"__main__\\": pytest.main()","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id: int, name: str, quantity: int, price: float): if product_id in self.products: self.products[product_id]['quantity'] = quantity self.products[product_id]['price'] = price else: self.products[product_id] = {'name': name, 'quantity': quantity, 'price': price} def remove_product(self, product_id: int): if product_id not in self.products: raise ValueError(\\"Product ID does not exist.\\") del self.products[product_id] def get_inventory(self): inventory_list = [] for pid, pdata in self.products.items(): product_info = {'product_id': pid, 'name': pdata['name'], 'quantity': pdata['quantity'], 'price': pdata['price']} inventory_list.append(product_info) return inventory_list"},{"question":"def summarize_orders(order_list: list) -> dict: Aggregates and transforms data from the given list of dictionaries, producing a summary that groups orders by customer and calculates the total amount spent by each customer. Parameters: order_list (list): List of dictionaries containing order information. Returns: dict: Dictionary with customer IDs as keys and the corresponding total amount spent by each customer as values. >>> summarize_orders([ ... {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O001\\", \\"amount\\": 150.0, \\"date\\": \\"2023-01-15\\"}, ... {\\"customer_id\\": \\"C002\\", \\"order_id\\": \\"O002\\", \\"amount\\": 200.0, \\"date\\": \\"2023-01-16\\"}, ... {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O003\\", \\"amount\\": 50.0, \\"date\\": \\"2023-01-17\\"}, ... {\\"customer_id\\": \\"C003\\", \\"order_id\\": \\"O004\\", \\"amount\\": 300.0, \\"date\\": \\"2023-01-18\\"}, ... {\\"customer_id\\": \\"C002\\", \\"order_id\\": \\"O005\\", \\"amount\\", 100.0, \\"date\\": \\"2023-01-19\\"}, ... ]) {'C001': 200.0, 'C002': 300.0, 'C003': 300.0} >>> summarize_orders([]) {} >>> summarize_orders([ ... {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O001\\", \\"amount\\": 100.0, \\"date\\": \\"2023-01-15\\"}, ... {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O002\\", \\"amount\\": 150.0, \\"date\\": \\"2023-01-16\\"}, ... {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O003\\", \\"amount\\": 200.0, \\"date\\": \\"2023-01-17\\"}, ... ]) {'C001': 450.0} >>> summarize_orders([ ... {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O001\\", \\"amount\\": 0.0, \\"date\\": \\"2023-01-15\\"}, ... {\\"customer_id\\": \\"C002\\", \\"order_id\\": \\"O002\\", \\"amount\\": 0.0, \\"date\\": \\"2023-01-16\\"}, ... {\\"customer_id\\": \\"C003\\", \\"order_id\\": \\"O003\\", \\"amount\\": 0.0, \\"date\\": \\"2023-01-17\\"}, ... ]) {'C001': 0.0, 'C002': 0.0, 'C003': 0.0} >>> summarize_orders([ ... {\\"customer_id\\": \\"C002\\", \\"order_id\\": \\"O001\\", \\"amount\\": 100.0, \\"date\\": \\"2023-01-15\\"}, ... {\\"customer_id\\": \\"C001\\", \\"order_id\\": \\"O002\\", \\"amount\\": 150.0, \\"date\\": \\"2023-01-16\\"}, ... {\\"customer_id\\": \\"C003\\", \\"order_id\\": \\"O003\\", \\"amount\\": 200.0, \\"date\\": \\"2023-01-17\\"}, ... ]) {'C001': 150.0, 'C002': 100.0, 'C003': 200.0} pass","solution":"def summarize_orders(order_list: list) -> dict: Aggregates and transforms data from the given list of dictionaries, producing a summary that groups orders by customer and calculates the total amount spent by each customer. Parameters: order_list (list): List of dictionaries containing order information. Returns: dict: Dictionary with customer IDs as keys and the corresponding total amount spent by each customer as values. summary = {} for order in order_list: customer_id = order[\\"customer_id\\"] amount = order[\\"amount\\"] if customer_id in summary: summary[customer_id] += amount else: summary[customer_id] = amount return dict(sorted(summary.items()))"},{"question":"def compress_string(input_string: str) -> str: Perform basic string compression using the counts of repeated characters. >>> compress_string(\\"aabbcc\\") 'aabbcc' >>> compress_string(\\"aaabccddd\\") 'a3bc2d3' # implement the function pass # Unit tests def test_compress_string_with_no_repeats(): assert compress_string(\\"abcdef\\") == \\"abcdef\\" def test_compress_string_with_all_repeats(): assert compress_string(\\"aaaaaa\\") == \\"a6\\" def test_compress_string_with_mixed_characters(): assert compress_string(\\"aaabccddd\\") == \\"a3bc2d3\\" def test_compress_string_with_single_characters(): assert compress_string(\\"abcd\\") == \\"abcd\\" def test_compress_string_with_complex_repeats(): assert compress_string(\\"aaabbbcc\\") == \\"a3b3c2\\" def test_compress_string_with_empty_string(): assert compress_string(\\"\\") == \\"\\" def test_compress_string_with_mixed_repeats_correct_order(): assert compress_string(\\"aabbccddeeff\\") == \\"aabbccddeeff\\" def test_compress_string_with_long_string(): long_string = \\"x\\" * 5000 + \\"y\\" * 5000 assert compress_string(long_string) == \\"x5000y5000\\"","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 prev_char = input_string[0] for current_char in input_string[1:]: if current_char == prev_char: count += 1 else: compressed.append(prev_char) if count > 1: compressed.append(str(count)) prev_char = current_char count = 1 # Append the final group compressed.append(prev_char) if count > 1: compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"def path_exists(grid: list[list[int]]) -> bool: Finds a path from the top-left corner to the bottom-right corner of an NxN grid. The grid contains obstacles (1) and free spaces (0). You can move only right or down through the grid. Parameters: grid (list of list of int): A list representing the grid with 0s (free spaces) and 1s (obstacles). Returns: bool: True if a path exists from the top-left to the bottom-right, False otherwise. Examples: >>> path_exists([ ... [0, 1, 0], ... [0, 0, 1], ... [1, 0, 0] ... ]) True >>> path_exists([ ... [0, 1], ... [1, 0] ... ]) False >>> path_exists([ ... [0] ... ]) True >>> path_exists([ ... [0, 0], ... [0, 0] ... ]) True","solution":"def path_exists(grid: list[list[int]]) -> bool: def dfs(x, y): if x >= len(grid) or y >= len(grid) or grid[x][y] == 1: return False if x == len(grid) - 1 and y == len(grid) - 1: return True grid[x][y] = 1 # mark as visited return dfs(x + 1, y) or dfs(x, y + 1) return dfs(0, 0)"},{"question":"from typing import List def build_kmp_table(pattern: str) -> List[int]: Computes the KMP (Knuth-Morris-Pratt) partial match table (pi table) for a given pattern. :param pattern: The pattern string for which the KMP table is to be computed. :return: The list of integers representing the KMP pi table. >>> build_kmp_table(\\"ababc\\") [0, 0, 1, 2, 0] >>> build_kmp_table(\\"a\\") [0] >>> build_kmp_table(\\"aaaa\\") [0, 1, 2, 3] >>> build_kmp_table(\\"abcdef\\") [0, 0, 0, 0, 0, 0] >>> build_kmp_table(\\"abababca\\") [0, 0, 1, 2, 3, 4, 0, 1] >>> build_kmp_table(\\"\\") [] >>> build_kmp_table(\\"a\\" * 10**6) list(range(10**6)) >>> build_kmp_table(\\"aabaabaaa\\") [0, 1, 0, 1, 2, 3, 4, 5, 2]","solution":"from typing import List def build_kmp_table(pattern: str) -> List[int]: Computes the KMP (Knuth-Morris-Pratt) partial match table (pi table) for a given pattern. :param pattern: The pattern string for which the KMP table is to be computed. :return: The list of integers representing the KMP pi table. if not pattern: # Handle edge case for empty pattern return [] pi = [0] * len(pattern) j = 0 # Length of the previous longest prefix suffix for i in range(1, len(pattern)): while (j > 0) and (pattern[i] != pattern[j]): # Fallback to the last possible position j = pi[j - 1] # If characters match, increment the length of the current prefix suffix end if pattern[i] == pattern[j]: j += 1 pi[i] = j return pi"},{"question":"class QueueUsingStacks: def __init__(self): Initialize your data structure here. def enqueue(self, x: int) -> None: Enqueues element x to the end of the queue. def dequeue(self) -> int | None: Dequeues the element from the front of the queue and returns it. # Unit Tests def test_enqueue_dequeue_simple(): queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 1 assert queue.dequeue() == 2 assert queue.dequeue() == 3 assert queue.dequeue() == None def test_enqueue_dequeue_mixed(): queue = QueueUsingStacks() queue.enqueue(1) assert queue.dequeue() == 1 queue.enqueue(2) queue.enqueue(3) assert queue.dequeue() == 2 queue.enqueue(4) assert queue.dequeue() == 3 assert queue.dequeue() == 4 assert queue.dequeue() == None def test_dequeue_empty(): queue = QueueUsingStacks() assert queue.dequeue() == None queue.enqueue(5) assert queue.dequeue() == 5 assert queue.dequeue() == None def test_alternating_operations(): queue = QueueUsingStacks() queue.enqueue(10) queue.enqueue(20) assert queue.dequeue() == 10 queue.enqueue(30) assert queue.dequeue() == 20 queue.enqueue(40) queue.enqueue(50) assert queue.dequeue() == 30 assert queue.dequeue() == 40 assert queue.dequeue() == 50 assert queue.dequeue() == None","solution":"class QueueUsingStacks: def __init__(self): Initialize your data structure here. self.in_stack = [] self.out_stack = [] def enqueue(self, x: int) -> None: Enqueues element x to the end of the queue. self.in_stack.append(x) def dequeue(self) -> int | None: Dequeues the element from the front of the queue and returns it. if not self.out_stack: while self.in_stack: self.out_stack.append(self.in_stack.pop()) return self.out_stack.pop() if self.out_stack else None"},{"question":"def sum_of_prime_factors(n: int) -> int: Returns the sum of all prime factors of the given number 'n'. Args: n : int : a positive integer (2 ≤ n ≤ 10^6) Returns: int: The sum of all prime factors of 'n'. Examples: >>> sum_of_prime_factors(28) 9 >>> sum_of_prime_factors(60) 10 >>> sum_of_prime_factors(100) 7 >>> sum_of_prime_factors(13) 13 >>> sum_of_prime_factors(1) 0 >>> sum_of_prime_factors(210) 17 >>> sum_of_prime_factors(997) 997 pass def test_sum_of_prime_factors_example_1(): assert sum_of_prime_factors(28) == 9 def test_sum_of_prime_factors_example_2(): assert sum_of_prime_factors(60) == 10 def test_sum_of_prime_factors_example_3(): assert sum_of_prime_factors(100) == 7 def test_sum_of_prime_factors_prime_number(): assert sum_of_prime_factors(13) == 13 def test_sum_of_prime_factors_no_prime_factors(): assert sum_of_prime_factors(1) == 0 def test_sum_of_prime_factors_large_number_with_multiple_prime_factors(): assert sum_of_prime_factors(210) == 17 # Prime factors are 2, 3, 5, 7 (2 + 3 + 5 + 7 = 17) def test_sum_of_prime_factors_large_prime_number(): assert sum_of_prime_factors(997) == 997 # 997 is a prime number itself","solution":"def sum_of_prime_factors(n: int) -> int: def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # To store prime numbers using Sieve of Eratosthenes max_limit = n + 1 sieve = [True] * max_limit p = 2 while (p * p <= n): if (sieve[p] == True): for i in range(p * p, max_limit, p): sieve[i] = False p += 1 prime_factors_sum = 0 # Check for each number if it is a factor and prime for i in range(2, n + 1): if n % i == 0 and sieve[i]: prime_factors_sum += i return prime_factors_sum"},{"question":"class Graph: A class representing a directed weighted graph. This class supports adding edges and finding the shortest path using Dijkstra's algorithm. Attributes: num_vertices (int): The number of vertices in the graph. adj_list (dict): Adjacency list representing the edges and their weights. Methods: add_edge(src, dest, weight): Adds a directed edge from src to dest with the given weight. shortest_path(start): Computes the shortest path from the start vertex to all other vertices using Dijkstra's algorithm. def __init__(self, num_vertices: int): self.num_vertices = num_vertices self.adj_list = {i: [] for i in range(num_vertices)} def add_edge(self, src: int, dest: int, weight: int) -> None: Adds a directed edge from vertex src to vertex dest with the given weight. Args: src (int): Source vertex. dest (int): Destination vertex. weight (int): Weight of the edge. Example usage: >>> graph = Graph(5) >>> graph.add_edge(0, 1, 10) >>> graph.adj_list[0] [(1, 10)] pass def shortest_path(self, start: int) -> list: Uses Dijkstra's algorithm to compute the shortest path from the start vertex to all other vertices. Args: start (int): The starting vertex for path calculation. Returns: list: A list where the value at index i represents the shortest distance from the start vertex to vertex i. If there is no path to vertex i, the value is float('inf'). Example usage: >>> graph = Graph(5) >>> graph.add_edge(0, 1, 10) >>> graph.add_edge(0, 4, 3) >>> graph.add_edge(1, 2, 2) >>> graph.add_edge(2, 3, 9) >>> graph.add_edge(3, 2, 7) >>> graph.add_edge(4, 1, 1) >>> graph.add_edge(4, 2, 2) >>> graph.shortest_path(0) [0, 4, 5, 14, 3] pass def test_add_edge(): graph = Graph(5) graph.add_edge(0, 1, 10) assert graph.adj_list[0] == [(1, 10)] graph.add_edge(0, 4, 3) assert graph.adj_list[0] == [(1, 10), (4, 3)] graph.add_edge(1, 2, 2) assert graph.adj_list[1] == [(2, 2)] def test_shortest_path(): graph = Graph(5) graph.add_edge(0, 1, 10) graph.add_edge(0, 4, 3) graph.add_edge(1, 2, 2) graph.add_edge(2, 3, 9) graph.add_edge(3, 2, 7) graph.add_edge(4, 1, 1) graph.add_edge(4, 2, 2) distances = graph.shortest_path(0) assert distances == [0, 4, 5, 14, 3] def test_shortest_path_unreachable_nodes(): graph = Graph(3) graph.add_edge(0, 1, 5) distances = graph.shortest_path(0) assert distances == [0, 5, float('inf')] def test_no_edges(): graph = Graph(4) distances = graph.shortest_path(0) assert distances == [0, float('inf'), float('inf'), float('inf')] def test_single_node(): graph = Graph(1) distances = graph.shortest_path(0) assert distances == [0] def test_large_graph(): graph = Graph(10000) for i in range(9999): graph.add_edge(i, i + 1, 1) distances = graph.shortest_path(0) assert distances[9999] == 9999 assert distances[500] == 500","solution":"import heapq class Graph: def __init__(self, num_vertices: int): self.num_vertices = num_vertices self.adj_list = {i: [] for i in range(num_vertices)} def add_edge(self, src: int, dest: int, weight: int) -> None: self.adj_list[src].append((dest, weight)) def shortest_path(self, start: int) -> list: distances = [float('inf')] * self.num_vertices distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adj_list[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"def is_palindrome_case_sensitive(s: str) -> bool: Checks if the given string is a palindrome considering case sensitivity. >>> is_palindrome_case_sensitive(\\"Madam\\") False >>> is_palindrome_case_sensitive(\\"madam\\") True >>> is_palindrome_case_sensitive(\\"12321\\") True >>> is_palindrome_case_sensitive(\\"123321\\") True >>> is_palindrome_case_sensitive(\\"Hello\\") False def is_palindrome_case_insensitive(s: str) -> bool: Checks if the given string is a palindrome without considering case sensitivity. >>> is_palindrome_case_insensitive(\\"Madam\\") True >>> is_palindrome_case_insensitive(\\"madam\\") True >>> is_palindrome_case_insensitive(\\"12321\\") True >>> is_palindrome_case_insensitive(\\"123321\\") True >>> is_palindrome_case_insensitive(\\"Hello\\") False >>> is_palindrome_case_insensitive(\\"Aba\\") True def palindrome_checker(s: str, case_sensitive: bool) -> bool: Determines if the given string is a palindrome based on the specified case sensitivity. >>> palindrome_checker(\\"Madam\\", False) True >>> palindrome_checker(\\"Madam\\", True) False >>> palindrome_checker(\\"madam\\", True) True >>> palindrome_checker(\\"madam\\", False) True >>> palindrome_checker(\\"12321\\", True) True >>> palindrome_checker(\\"123321\\", False) True >>> palindrome_checker(\\"Hello\\", True) False >>> palindrome_checker(\\"Hello\\", False) False","solution":"def is_palindrome_case_sensitive(s: str) -> bool: Checks if the given string is a palindrome considering case sensitivity. # Compare the string with its reverse return s == s[::-1] def is_palindrome_case_insensitive(s: str) -> bool: Checks if the given string is a palindrome without considering case sensitivity. # Convert the string to lower case and compare with its reverse s = s.lower() return s == s[::-1] def palindrome_checker(s: str, case_sensitive: bool) -> bool: Determines if the given string is a palindrome based on the specified case sensitivity. if case_sensitive: return is_palindrome_case_sensitive(s) else: return is_palindrome_case_insensitive(s)"},{"question":"def format_book_title(title: str) -> str: Returns the book title with each word capitalized appropriately. >>> format_book_title(\\"the great gatsby\\") \\"The Great Gatsby\\" >>> format_book_title(\\"TO KILL a MOCKINGBIRD\\") \\"To Kill A Mockingbird\\" >>> format_book_title(\\"1984\\") \\"1984\\" >>> format_book_title(\\"a tale of two cities\\") \\"A Tale Of Two Cities\\" >>> format_book_title(\\"pride and prejudice\\") \\"Pride And Prejudice\\"","solution":"def format_book_title(title: str) -> str: Returns the book title with each word capitalized appropriately. words = title.split() formatted_words = [word.capitalize() for word in words] return ' '.join(formatted_words)"},{"question":"def longest_consecutive_sequence(nums_str: str) -> int: Find the maximum length of a sequence of consecutive integers. Args: nums_str (str): A string containing space-separated integers. Returns: int: The maximum length of a sequence of consecutive integers. Examples: >>> longest_consecutive_sequence(\\"100 4 200 1 3 2\\") 4 >>> longest_consecutive_sequence(\\"10 20 30 40\\") 1 pass def test_longest_consecutive_sequence_example(): assert longest_consecutive_sequence(\\"100 4 200 1 3 2\\") == 4 def test_no_consecutive_sequence(): assert longest_consecutive_sequence(\\"10 20 30 40\\") == 1 def test_single_element(): assert longest_consecutive_sequence(\\"7\\") == 1 def test_all_elements_consecutive(): assert longest_consecutive_sequence(\\"1 2 3 4 5\\") == 5 def test_mixed_positive_and_negative(): assert longest_consecutive_sequence(\\"-3 -2 -1 0 1 2 3\\") == 7 def test_large_input(): input_str = \\" \\".join(map(str, range(-5000, 5000))) assert longest_consecutive_sequence(input_str) == 10000","solution":"def longest_consecutive_sequence(nums_str: str) -> int: nums = list(map(int, nums_str.split())) nums_set = set(nums) max_length = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def reverse_words_basic(sentence: str) -> str: Reverses the order of words in a sentence using basic string manipulation. Args: - sentence (str): The input sentence. Returns: - str: The sentence with the order of words reversed. >>> reverse_words_basic(\\"Hello world, this is a test sentence!\\") \\"sentence! test a is this world, Hello\\" >>> reverse_words_basic(\\"\\") \\"\\" >>> reverse_words_basic(\\"OneWord\\") \\"OneWord\\" >>> reverse_words_basic(\\"Multiple spaces between words\\") \\"words between spaces Multiple\\" >>> reverse_words_basic(\\" Leading and trailing spaces \\") \\"spaces trailing and Leading\\" # Basic implementation here pass def reverse_words_optimized(sentence: str) -> str: Reverses the order of words in a sentence using optimized techniques. Args: - sentence (str): The input sentence. Returns: - str: The sentence with the order of words reversed. >>> reverse_words_optimized(\\"Hello world, this is a test sentence!\\") \\"sentence! test a is this world, Hello\\" >>> reverse_words_optimized(\\"\\") \\"\\" >>> reverse_words_optimized(\\"OneWord\\") \\"OneWord\\" >>> reverse_words_optimized(\\"Multiple spaces between words\\") \\"words between spaces Multiple\\" >>> reverse_words_optimized(\\" Leading and trailing spaces \\") \\"spaces trailing and Leading\\" # Optimized implementation here pass def compare_performance(sentence: str) -> None: Compares the performance of the two word reversing functions. Args: - sentence (str): The input sentence to be used for performance comparison. Outputs: Prints the execution time of both functions and identifies the faster approach. # Analysis implementation here pass if __name__ == \\"__main__\\": compare_performance(\\"Hello world, this is a test sentence!\\") # Output: Execution time for reverse_words_basic: X.XXXXXX seconds # Execution time for reverse_words_optimized: Y.YYYYYY seconds # Faster approach: reverse_words_[basic/optimized]","solution":"import time def reverse_words_basic(sentence: str) -> str: Reverses the order of words in a sentence using basic string manipulation. Args: - sentence (str): The input sentence. Returns: - str: The sentence with the order of words reversed. words = sentence.split() reversed_words = [] for word in words: reversed_words.insert(0, word) return ' '.join(reversed_words) def reverse_words_optimized(sentence: str) -> str: Reverses the order of words in a sentence using optimized techniques. Args: - sentence (str): The input sentence. Returns: - str: The sentence with the order of words reversed. return ' '.join(sentence.split()[::-1]) def compare_performance(sentence: str) -> None: Compares the performance of the two word reversing functions. Args: - sentence (str): The input sentence to be used for performance comparison. Outputs: Prints the execution time of both functions and identifies the faster approach. start_basic = time.time() reverse_words_basic(sentence) end_basic = time.time() start_optimized = time.time() reverse_words_optimized(sentence) end_optimized = time.time() time_basic = end_basic - start_basic time_optimized = end_optimized - start_optimized print(f\\"Execution time for reverse_words_basic: {time_basic:.6f} seconds\\") print(f\\"Execution time for reverse_words_optimized: {time_optimized:.6f} seconds\\") faster = \\"reverse_words_optimized\\" if time_optimized < time_basic else \\"reverse_words_basic\\" print(f\\"Faster approach: {faster}\\")"},{"question":"def number_of_bins(weights: List[int], limit: int) -> int: Organize books into the smallest number of bins where each bin can hold a combined weight up to a given limit using the First-Fit Decreasing method. >>> number_of_bins([4, 8, 1, 4, 2, 1], 10) == 2 >>> number_of_bins([9, 8, 2, 2, 5, 4], 10) == 4 >>> number_of_bins([3, 3, 3, 3, 3, 3], 6) == 3","solution":"def number_of_bins(weights, limit): # Sort weights in descending order weights.sort(reverse=True) bins = [] for weight in weights: placed = False # Try to place the book in one of the existing bins for bin_index in range(len(bins)): if bins[bin_index] + weight <= limit: bins[bin_index] += weight placed = True break # If no suitable bin is found, create a new bin if not placed: bins.append(weight) return len(bins)"},{"question":"def group_identical_integers(nums: list[int]) -> list[int]: Given a list of integers, rearrange the list so that all occurrences of the same integer appear together while maintaining the relative order of different integers. Args: - nums (list[int]): list of integers. Returns: - list[int]: list of integers where identical integers are grouped together. Examples: >>> group_identical_integers([4, 2, 1, 2, 1, 4, 1, 4]) [4, 4, 4, 2, 2, 1, 1, 1] >>> group_identical_integers([1]) [1] >>> group_identical_integers([]) [] >>> group_identical_integers([3, 3, 2, 2, 1, 1]) [3, 3, 2, 2, 1, 1] >>> group_identical_integers([6, 5, 6, 6, 5, 7]) [6, 6, 6, 5, 5, 7] pass # Unit Tests def test_group_identical_integers(): assert group_identical_integers([4, 2, 1, 2, 1, 4, 1, 4]) == [4, 4, 4, 2, 2, 1, 1, 1] assert group_identical_integers([1]) == [1] assert group_identical_integers([]) == [] assert group_identical_integers([3, 3, 2, 2, 1, 1]) == [3, 3, 2, 2, 1, 1] assert group_identical_integers([6, 5, 6, 6, 5, 7]) == [6, 6, 6, 5, 5, 7] assert group_identical_integers([1, 2, 3, 1, 2, 3, 1, 2, 3]) == [1, 1, 1, 2, 2, 2, 3, 3, 3] assert group_identical_integers([4, 4, 4, 2, 2, 1, 1, 1, 1]) == [4, 4, 4, 2, 2, 1, 1, 1, 1] assert group_identical_integers([7, 7, 7, 7, 7]) == [7, 7, 7, 7, 7] assert group_identical_integers([-1, -2, -1, -2, 0, 0, -1, -2]) == [-1, -1, -1, -2, -2, -2, 0, 0] assert group_identical_integers([0, 0, 0, 1, -1, -1, 1]) == [0, 0, 0, 1, 1, -1, -1] if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def group_identical_integers(nums: list[int]) -> list[int]: Given a list of integers, rearrange the list so that all occurrences of the same integer appear together while maintaining the relative order of different integers. Args: - nums (list[int]): list of integers. Returns: - list[int]: list of integers where identical integers are grouped together. Examples: >>> group_identical_integers([4, 2, 1, 2, 1, 4, 1, 4]) [4, 4, 4, 2, 2, 1, 1, 1] >>> group_identical_integers([1]) [1] >>> group_identical_integers([]) [] >>> group_identical_integers([3, 3, 2, 2, 1, 1]) [3, 3, 2, 2, 1, 1] >>> group_identical_integers([6, 5, 6, 6, 5, 7]) [6, 6, 6, 5, 5, 7] from collections import defaultdict # Dictionary to store lists of integers grouped = defaultdict(list) # Ordered list to store the order of first occurrences order = [] for num in nums: if not grouped[num]: # If it's the first occurrence of the number, add to the order order.append(num) # Append the number to its corresponding list in grouped grouped[num].append(num) # Final result to concatenate all grouped lists in the order they appeared result = [] for num in order: result.extend(grouped[num]) return result"},{"question":"def count_vowels_in_file(filename: str) -> dict: Reads the content of a file and counts occurrences of each vowel in both lowercase and uppercase forms. Parameters: filename: str - The name of the text file to read from. Returns: dict: A dictionary with vowels as keys and their counts as values. Examples: >>> count_vowels_in_file(\\"example.txt\\") { \\"a\\": 0, \\"e\\": 1, \\"i\\": 0, \\"o\\": 2, \\"u\\": 0, \\"A\\": 0, \\"E\\": 0, \\"I\\": 0, \\"O\\": 0, \\"U\\": 0 } >>> count_vowels_in_file(\\"empty.txt\\") { \\"a\\": 0, \\"e\\": 0, \\"i\\": 0, \\"o\\": 0, \\"u\\": 0, \\"A\\": 0, \\"E\\": 0, \\"I\\": 0, \\"O\\": 0, \\"U\\": 0 } >>> count_vowels_in_file(\\"nonexistent.txt\\") { \\"error\\": \\"File not found.\\" }","solution":"def count_vowels_in_file(filename: str) -> dict: Reads the content of a file and counts occurrences of each vowel in both lowercase and uppercase forms. Parameters: filename: str - The name of the text file to read from. Returns: dict: A dictionary with vowels as keys and their counts as values. vowels = 'aeiouAEIOU' counts = {vowel: 0 for vowel in vowels} try: with open(filename, 'r') as file: text = file.read() for char in text: if char in counts: counts[char] += 1 except FileNotFoundError: return {\\"error\\": \\"File not found.\\"} return counts"},{"question":"from collections import OrderedDict class LRUCache: Implement a function that simulates the behavior of an LRU (Least Recently Used) Cache. The cache should have a fixed size, and it should eject the least recently used item when the cache reaches capacity and a new item is inserted. >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) -1 >>> cache.put(4, 4) # evicts key 1 >>> cache.get(1) -1 >>> cache.get(3) 3 >>> cache.get(4) 4 def __init__(self, capacity: int): # Initialize the data structure def get(self, key: int) -> int: # Retrieve the value for the given key def put(self, key: int, value: int) -> None: # Insert the value with the given key into the cache # Unit Tests def test_LRUCache_capacity_2(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 def test_LRUCache_updates_existing_values(): cache = LRUCache(2) cache.put(1, 1) cache.put(1, 2) assert cache.get(1) == 2 # returns updated value 2 def test_LRUCache_exceeding_capacity(): cache = LRUCache(1) cache.put(1, 1) assert cache.get(1) == 1 # returns 1 cache.put(2, 2) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 # returns 2 def test_LRUCache_get_non_existent_key(): cache = LRUCache(2) assert cache.get(1) == -1 # returns -1 (not found) def test_LRUCache_put_operation_reorders_items(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) # update key 1 value to 10 and make it the most recently used cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) assert cache.get(1) == 10 # returns 10 assert cache.get(3) == 3 # returns 3","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key in self.cache: value = self.cache.pop(key) self.cache[key] = value return value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = value"},{"question":"def text_editor(operations: list) -> list: Simulate a simple text editor that can insert, delete, and retrieve substring operations on a string. >>> text_editor([{\\"type\\": \\"insert\\", \\"position\\": 0, \\"value\\": \\"hello\\"}, {\\"type\\": \\"insert\\", \\"position\\": 5, \\"value\\": \\" world\\"}, {\\"type\\": \\"substring\\", \\"position\\": 0, \\"value\\": (0, 5)}]) [\\"hello\\"] >>> text_editor([{\\"type\\": \\"insert\\", \\"position\\": 0, \\"value\\": \\"hello\\"}, {\\"type\\": \\"insert\\", \\"position\\": 5, \\"value\\": \\" world\\"}, {\\"type\\": \\"substring\\", \\"position\\": 0, \\"value\\": (0, 5)}, {\\"type\\": \\"delete\\", \\"position\\": 5, \\"value\\": 1}, {\\"type\\": \\"substring\\", \\"position\\": 0, \\"value\\": (0, 5)}]) [\\"hello\\", \\"hello\\"] >>> text_editor([{\\"type\\": \\"insert\\", \\"position\\": 0, \\"value\\": \\"hello\\"}, {\\"type\\": \\"delete\\", \\"position\\": 4, \\"value\\": 10}]) [] >>> text_editor([]) []","solution":"def text_editor(operations): text = \\"\\" results = [] for operation in operations: op_type = operation[\\"type\\"] position = operation[\\"position\\"] value = operation[\\"value\\"] if op_type == \\"insert\\": text = text[:position] + value + text[position:] elif op_type == \\"delete\\": text = text[:position] + text[position + value:] elif op_type == \\"substring\\": start, end = value results.append(text[start:end]) return results"},{"question":"def convert_to_24_hour_format(time_str: str) -> str: Converts a 12-hour time format string to a 24-hour time format string. Args: time_str (str): A string representing the time in 12-hour format with AM/PM. Returns: str: A string representing the time in 24-hour format. Examples: >>> convert_to_24_hour_format(\\"02:30 PM\\") == \\"14:30\\" >>> convert_to_24_hour_format(\\"11:45 AM\\") == \\"11:45\\" >>> convert_to_24_hour_format(\\"12:00 PM\\") == \\"12:00\\" >>> convert_to_24_hour_format(\\"12:00 AM\\") == \\"00:00\\"","solution":"def convert_to_24_hour_format(time_str: str) -> str: Converts a 12-hour time format string to a 24-hour time format string. Args: time_str (str): A string representing the time in 12-hour format with AM/PM. Returns: str: A string representing the time in 24-hour format. # Extract the hour, minute, and AM/PM parts time, period = time_str.split(' ') hour, minute = map(int, time.split(':')) # Convert hour based on AM/PM period if period == \\"AM\\": if hour == 12: # Midnight case hour = 0 elif period == \\"PM\\": if hour != 12: # Convert PM hour unless it's the 12 PM case hour += 12 # Return the formatted time in 24-hour format return f\\"{hour:02}:{minute:02}\\""},{"question":"def product_array_except_self(nums: List[int]) -> List[int]: Calculate the Product of Array after Omitting an Element. Args: nums (List[int]): A list of integers. Returns: List[int]: A new list where each element at index \`i\` is the product of all the elements in the input list except for the one at the corresponding index. Examples: >>> product_array_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_array_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_array_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_array_except_self([0, 0]) [0, 0] >>> product_array_except_self([1]) [1] n = len(nums) if n == 1: return [1] left_products = [1] * n right_products = [1] * n # Populate left_products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Populate right_products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate result array result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result","solution":"from typing import List def product_array_except_self(nums: List[int]) -> List[int]: n = len(nums) if n == 1: return [1] left_products = [1] * n right_products = [1] * n # Populate left_products for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] # Populate right_products for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Calculate result array result = [1] * n for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"def find_local_extrema(prices): Identifies local highs and lows in a list of stock prices. Arguments: prices -- a list of float values representing stock prices at consecutive timestamps. Returns: A tuple of two lists: - List of integers representing the indices of local highs. - List of integers representing the indices of local lows. >>> find_local_extrema([100.0, 101.5, 102.0, 99.0, 100.5, 101.0, 98.5, 99.5]) ([2, 5], [3, 6]) >>> find_local_extrema([100.0, 100.0, 100.0, 100.0]) ([], []) >>> find_local_extrema([100.0, 101.0, 102.0, 103.0]) ([], []) >>> find_local_extrema([103.0, 102.0, 101.0, 100.0]) ([], []) >>> find_local_extrema([100.0, 105.0, 100.0, 95.0, 100.0]) ([1], [3]) >>> find_local_extrema([100.0, 105.0, 100.0, 110.0, 100.0, 115.0, 100.0]) ([1, 3, 5], [2, 4])","solution":"def find_local_extrema(prices): Identifies local highs and lows in a list of stock prices. Arguments: prices -- a list of float values representing stock prices at consecutive timestamps. Returns: A tuple of two lists: - List of integers representing the indices of local highs. - List of integers representing the indices of local lows. local_highs = [] local_lows = [] for i in range(1, len(prices) - 1): if prices[i] > prices[i - 1] and prices[i] > prices[i + 1]: local_highs.append(i) elif prices[i] < prices[i - 1] and prices[i] < prices[i + 1]: local_lows.append(i) return (local_highs, local_lows)"},{"question":"from typing import List def min_platforms(arrival: List[int], departure: List[int]) -> int: Determine the minimum number of platforms required for a railway station to handle all trains without any waiting. >>> min_platforms([1000, 1010, 1025, 1100, 1130, 1200], [1030, 1040, 1045, 1130, 1145, 1230]) 3 >>> min_platforms([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000]) 3","solution":"from typing import List def min_platforms(arrival: List[int], departure: List[int]) -> int: # Sort the arrival and departure times arrival.sort() departure.sort() n = len(arrival) platform_needed = 1 max_platforms = 1 i = 1 j = 0 while i < n and j < n: # If the next train is arriving before the current train departs, # we need an additional platform if arrival[i] <= departure[j]: platform_needed += 1 i += 1 # If the next train departs before the new train arrives, # we can free up a platform else: platform_needed -= 1 j += 1 # Update the max_platforms needed max_platforms = max(max_platforms, platform_needed) return max_platforms"},{"question":"from typing import Callable def simpsons_rule( fnc: Callable[[float], float], a: float, b: float, n: int = 100 ) -> float: Calculate the area under a curve given by a function \`fnc\` over an interval [a, b] using Simpson's rule for numerical integration. Args: - fnc (Callable[[float], float]): The integrand function. - a (float): The lower limit of integration. - b (float): The upper limit of integration. - n (int): Number of intervals to divide [a, b] into (default 100). Must be even. Returns: - float: The approximate area under the curve \`fnc\` from \`a\` to \`b\`. Raises: - ValueError: If \`n\` is not an even integer. >>> import math >>> def linear_fn(x): return x >>> math.isclose(simpsons_rule(linear_fn, 0, 1, 1000), 0.5, rel_tol=1e-5) True >>> def quadratic_fn(x): return x**2 >>> math.isclose(simpsons_rule(quadratic_fn, 0, 1, 1000), 1/3, rel_tol=1e-5) True >>> def exponential_fn(x): return math.exp(x) >>> math.isclose(simpsons_rule(exponential_fn, 0, 1, 1000), math.exp(1) - 1, rel_tol=1e-5) True >>> def gaussian_fn(x): return math.exp(-x**2) >>> math.isclose(simpsons_rule(gaussian_fn, 0, 1, 1000), 0.7468241328124271, rel_tol=1e-5) True >>> def any_fn(x): return x**2 >>> try: ... simpsons_rule(any_fn, 0, 1, 3) # n is not even ... except ValueError as e: ... assert str(e) == \\"n must be an even integer\\" >>> def constant_fn(x): return 1 >>> simpsons_rule(constant_fn, 1, 1, 10) 0","solution":"from typing import Callable def simpsons_rule(fnc: Callable[[float], float], a: float, b: float, n: int = 100) -> float: Calculate the area under the curve given by function \`fnc\` over the interval [a, b] using Simpson's rule with n subdivisions. Args: - fnc (Callable[[float], float]): The integrand function. - a (float): The lower limit of integration. - b (float): The upper limit of integration. - n (int): The number of intervals (must be even). Returns: - float: The approximate area under the curve. Raises: - ValueError: If n is not an even number. if n % 2 != 0: raise ValueError(\\"n must be an even integer\\") h = (b - a) / n sum_odd = sum(fnc(a + i * h) for i in range(1, n, 2)) sum_even = sum(fnc(a + i * h) for i in range(2, n, 2)) area = (h / 3) * (fnc(a) + 4 * sum_odd + 2 * sum_even + fnc(b)) return area"},{"question":"from typing import List, Tuple def shortest_path(connections: List[Tuple[int, int]], start: int, end: int) -> int: Determine the shortest path (in terms of number of connections) between two users in a directed graph representing a social media network. If no path exists, return -1. >>> shortest_path([(0, 1), (1, 2), (2, 3), (3, 4)], 0, 4) == 4 >>> shortest_path([(0, 1), (1, 2), (2, 3), (3, 4)], 0, 5) == -1 >>> shortest_path([(2, 3), (3, 4), (4, 5), (5, 6), (1, 2), (0, 1), (3, 0)], 0, 6) == 6 Args: connections (List[Tuple[int, int]]): List of tuples representing follows. start (int): The starting user node. end (int): The ending user node. Returns: int: The shortest number of connections from start to end, or -1 if no path exists.","solution":"from typing import List, Tuple from collections import deque, defaultdict def shortest_path(connections: List[Tuple[int, int]], start: int, end: int) -> int: if start == end: return 0 graph = defaultdict(list) for a, b in connections: graph[a].append(b) queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: current_node, steps = queue.popleft() for neighbor in graph[current_node]: if neighbor == end: return steps + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) return -1"},{"question":"def find_subarray_with_sum(nums: list[int], k: int) -> int: Returns the length of the shortest contiguous subarray whose sum is equal to k. If no such subarray exists, return -1. Args: nums: A list of integers. k: An integer representing the target sum. Returns: An integer representing the length of the shortest contiguous subarray whose sum is k. If no such subarray exists, return -1. Raises: ValueError: If nums is not a list of integers or if k is not an integer. Examples: >>> find_subarray_with_sum([1, 2, 3, 4, 5], 9) 2 >>> find_subarray_with_sum([1, 2, 3, 4, 5], 15) 5 >>> find_subarray_with_sum([1, 2, 3, 4, 5], 20) -1 pass from solution import find_subarray_with_sum def test_valid_cases(): assert find_subarray_with_sum([1, 2, 3, 4, 5], 9) == 2 assert find_subarray_with_sum([1, 2, 3, 4, 5], 15) == 5 assert find_subarray_with_sum([1, 2, 3, 4, 5], 10) == 4 assert find_subarray_with_sum([1, 2, 3, 4, 5], 2) == 1 def test_invalid_cases(): assert find_subarray_with_sum([1, 2, 3, 4, 5], 20) == -1 assert find_subarray_with_sum([], 0) == -1 def test_edge_cases(): assert find_subarray_with_sum([5], 5) == 1 assert find_subarray_with_sum([5], 1) == -1 assert find_subarray_with_sum([1, -1, 2, -2, 3, -3], 0) == 2 def test_invalid_input(): try: find_subarray_with_sum(\\"Not a list\\", 5) except ValueError as e: assert str(e) == \\"nums must be a list of integers\\" try: find_subarray_with_sum([1, 2, 3], \\"Not an int\\") except ValueError as e: assert str(e) == \\"k must be an integer\\"","solution":"def find_subarray_with_sum(nums: list[int], k: int) -> int: if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise ValueError(\\"nums must be a list of integers\\") if not isinstance(k, int): raise ValueError(\\"k must be an integer\\") sum_dict = {} current_sum = 0 min_length = float('inf') for i in range(len(nums)): current_sum += nums[i] if current_sum == k: min_length = min(min_length, i + 1) if (current_sum - k) in sum_dict: min_length = min(min_length, i - sum_dict[current_sum - k]) if current_sum not in sum_dict: sum_dict[current_sum] = i return min_length if min_length != float('inf') else -1"},{"question":"class Cache: def __init__(self, cache_size): Initialize the cache. :param cache_size: int self.cache_size = cache_size self.cache = [] self.access_count = 0 self.hit_count = 0 def access(self, data): Process a memory access request. :param data: int :return: str - \\"Hit\\" or \\"Miss\\" pass def get_cache_contents(self): Retrieve the current state of the cache. :return: list of int pass def get_cache_hit_rate(self): Calculate the cache hit rate. :return: float pass def simulate_cache(cache_size, access_sequence): Simulate cache operations. :param cache_size: int :param access_sequence: list of int :return: tuple (results: list of str, final_cache: list of int, hit_rate: float) cache = Cache(cache_size) results = [] for address in access_sequence: result = cache.access(address) results.append(result) return results, cache.get_cache_contents(), cache.get_cache_hit_rate() # Usage example: cache_size = 3 access_sequence = [1, 2, 3, 2, 1, 4, 5, 1, 2] results, final_cache, hit_rate = simulate_cache(cache_size, access_sequence) print(\\"Access Results:\\", results) print(\\"Final Cache Contents:\\", final_cache) print(\\"Cache Hit Rate:\\", hit_rate)","solution":"class Cache: def __init__(self, cache_size): self.cache_size = cache_size self.cache = [] self.access_count = 0 self.hit_count = 0 def access(self, data): self.access_count += 1 if data in self.cache: self.cache.remove(data) self.cache.insert(0, data) self.hit_count += 1 return \\"Hit\\" else: if len(self.cache) == self.cache_size: self.cache.pop() self.cache.insert(0, data) return \\"Miss\\" def get_cache_contents(self): return list(self.cache) def get_cache_hit_rate(self): if self.access_count == 0: return 0.0 return self.hit_count / self.access_count def simulate_cache(cache_size, access_sequence): cache = Cache(cache_size) results = [] for address in access_sequence: result = cache.access(address) results.append(result) return results, cache.get_cache_contents(), cache.get_cache_hit_rate()"},{"question":"def intersection_area(rect1: list, rect2: list) -> int: Calculate the area of intersection between two axis-aligned rectangles. Parameters: rect1: List of four integers [x1, y1, x2, y2] representing the first rectangle. rect2: List of four integers [x1, y1, x2, y2] representing the second rectangle. Returns: The area of intersection of the two rectangles. If they do not intersect, return 0. >>> intersection_area([1, 1, 4, 4], [2, 2, 5, 5]) 4 >>> intersection_area([1, 1, 2, 2], [3, 3, 4, 4]) 0 >>> intersection_area([0, 0, 3, 3], [1, 1, 2, 2]) 1 >>> intersection_area([0, 0, 5, 5], [3, 3, 7, 7]) 4","solution":"def intersection_area(rect1: list, rect2: list) -> int: Calculate the area of intersection between two axis-aligned rectangles. Parameters: - rect1: List of four integers [x1, y1, x2, y2] representing the first rectangle. - rect2: List of four integers [x1, y1, x2, y2] representing the second rectangle. Returns: - The area of intersection of the two rectangles. If they do not intersect, return 0. # Unpack the rectangles x1_1, y1_1, x2_1, y2_1 = rect1 x1_2, y1_2, x2_2, y2_2 = rect2 # Calculate the (x, y) coordinates of the intersection rectangle intersect_x1 = max(x1_1, x1_2) intersect_y1 = max(y1_1, y1_2) intersect_x2 = min(x2_1, x2_2) intersect_y2 = min(y2_1, y2_2) # Calculate the width and height of the intersection rectangle width = intersect_x2 - intersect_x1 height = intersect_y2 - intersect_y1 # If there's no intersection, width or height would be non-positive if width <= 0 or height <= 0: return 0 # Calculate and return the area of the intersection rectangle return width * height"},{"question":"class KVStore: def __init__(self): self.store = {} def get(self, key: str) -> str: Retrieve the value of the specified key from the store. >>> kv = KVStore() >>> kv.set(\\"key1\\", \\"value1\\") >>> kv.get(\\"key1\\") 'value1' return self.store.get(key, \\"\\") def set(self, key: str, value: str) -> None: Set the value of the specified key in the store. >>> kv = KVStore() >>> kv.set(\\"key1\\", \\"value1\\") >>> kv.get(\\"key1\\") 'value1' self.store[key] = value def delete(self, key: str) -> None: Delete the specified key from the store. >>> kv = KVStore() >>> kv.set(\\"key1\\", \\"value1\\") >>> kv.delete(\\"key1\\") >>> kv.get(\\"key1\\") '' if key in self.store: del self.store[key] def begin(self) -> None: Start a new transaction block. Any subsequent operations should be part of this transaction. >>> kv = KVStore() >>> kv.begin() pass def commit(self) -> None: Commit the transaction, making all changes permanent. >>> kv = KVStore() >>> kv.begin() >>> kv.set(\\"key1\\", \\"value1\\") >>> kv.commit() >>> kv.get(\\"key1\\") 'value1' pass def rollback(self) -> None: Roll back all changes made in the current transaction, reverting to the state before the transaction began. >>> kv = KVStore() >>> kv.set(\\"key1\\", \\"value1\\") >>> kv.begin() >>> kv.set(\\"key1\\", \\"value2\\") >>> kv.rollback() >>> kv.get(\\"key1\\") 'value1' pass","solution":"class KVStore: def __init__(self): self.store = {} self.transaction_log = [] self.in_transaction = False def get(self, key: str) -> str: return self.store.get(key, \\"\\") def set(self, key: str, value: str) -> None: if self.in_transaction: self.transaction_log.append((\\"set\\", key, self.store.get(key, None))) self.store[key] = value def delete(self, key: str) -> None: if self.in_transaction: self.transaction_log.append((\\"delete\\", key, self.store.get(key, None))) if key in self.store: del self.store[key] def begin(self) -> None: if self.in_transaction: raise ValueError(\\"Already in a transaction\\") self.in_transaction = True self.transaction_log = [] def commit(self) -> None: if not self.in_transaction: raise ValueError(\\"No transaction to commit\\") self.transaction_log = [] self.in_transaction = False def rollback(self) -> None: if not self.in_transaction: raise ValueError(\\"No transaction to rollback\\") while self.transaction_log: operation, key, value = self.transaction_log.pop() if operation == \\"set\\": if value is None: del self.store[key] else: self.store[key] = value elif operation == \\"delete\\": if value is not None: self.store[key] = value self.in_transaction = False"},{"question":"from typing import List def find_unique_titles(catalog: List[str]) -> List[str]: Returns a list of unique book titles while maintaining the order they appear in the provided catalog. >>> find_unique_titles([\\"A Tale of Two Cities\\", \\"A Tale of Two Cities\\", \\"Great Expectations\\", \\"Jane Eyre\\", \\"Jane Eyre\\", \\"Moby Dick\\"]) [\\"A Tale of Two Cities\\", \\"Great Expectations\\", \\"Jane Eyre\\", \\"Moby Dick\\"] >>> find_unique_titles([\\"Harry Potter\\", \\"Harry Potter and the Chamber of Secrets\\", \\"Harry Potter and the Prisoner of Azkaban\\"]) [\\"Harry Potter\\", \\"Harry Potter and the Chamber of Secrets\\", \\"Harry Potter and the Prisoner of Azkaban\\"] # Your implementation here def test_find_unique_titles(): # Test with multiple duplicates catalog1 = [\\"A Tale of Two Cities\\", \\"A Tale of Two Cities\\", \\"Great Expectations\\", \\"Jane Eyre\\", \\"Jane Eyre\\", \\"Moby Dick\\"] assert find_unique_titles(catalog1) == [\\"A Tale of Two Cities\\", \\"Great Expectations\\", \\"Jane Eyre\\", \\"Moby Dick\\"] # Test with unique titles catalog2 = [\\"Harry Potter\\", \\"Harry Potter and the Chamber of Secrets\\", \\"Harry Potter and the Prisoner of Azkaban\\"] assert find_unique_titles(catalog2) == [\\"Harry Potter\\", \\"Harry Potter and the Chamber of Secrets\\", \\"Harry Potter and the Prisoner of Azkaban\\"] # Test with single title catalog3 = [\\"The Hobbit\\"] assert find_unique_titles(catalog3) == [\\"The Hobbit\\"] # Test with no titles catalog4 = [] assert find_unique_titles(catalog4) == [] # Test with all titles the same catalog5 = [\\"War and Peace\\", \\"War and Peace\\", \\"War and Peace\\", \\"War and Peace\\"] assert find_unique_titles(catalog5) == [\\"War and Peace\\"] # Test with mixed case titles catalog6 = [\\"The Great Gatsby\\", \\"The Great Gatsby\\", \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"To Kill a Mockingbird\\"] assert find_unique_titles(catalog6) == [\\"The Great Gatsby\\", \\"To Kill a Mockingbird\\"] # Test with large list catalog7 = [\\"A\\" * i for i in range(1, 10001)] + [\\"A\\" * 5000] # 10000 unique items, last one is duplicate assert find_unique_titles(catalog7)[:-1] == [\\"A\\" * i for i in range(1, 10001)] if __name__ == \\"__main__\\": test_find_unique_titles()","solution":"from typing import List def find_unique_titles(catalog: List[str]) -> List[str]: Returns a list of unique book titles while maintaining the order they appear in the provided catalog. if not catalog: return [] unique_titles = [catalog[0]] # Initialize with the first title last_seen_title = catalog[0] for title in catalog[1:]: if title != last_seen_title: unique_titles.append(title) last_seen_title = title return unique_titles"},{"question":"class WarehouseOptimizer: def __init__(self, grid: list[list[int]], constraints: list[int]): Initializes the WarehouseOptimizer with the given grid and a list of storage constraints. Args: grid (list[list[int]]): A 2D list where each cell contains an integer that represents the storage capacity of that cell. constraints (list[int]): A list of integers where each integer represents the number of items to be allocated to the corresponding row. pass def allocate_storage(self) -> list[list[int]]: Allocates items efficiently into the warehouse cells and returns the grid after allocation. Returns: list[list[int]]: A 2D list of integers representing the warehouse grid after storage allocation. pass def test_basic_allocation(): grid = [ [3, 1, 4], [2, 0, 3], [1, 5, 2] ] constraints = [5, 3, 6] expected = [ [3, 1, 1], [2, 0, 1], [1, 5, 0] ] optimizer = WarehouseOptimizer(grid, constraints) result = optimizer.allocate_storage() assert result == expected def test_exact_fit(): grid = [ [2, 1], [3, 2] ] constraints = [3, 5] expected = [ [2, 1], [3, 2] ] optimizer = WarehouseOptimizer(grid, constraints) result = optimizer.allocate_storage() assert result == expected def test_exceeding_constraints(): grid = [ [3, 1, 2], [6, 3] ] constraints = [5, 5] expected = [ [3, 1, 1], [5, 0] ] optimizer = WarehouseOptimizer(grid, constraints) result = optimizer.allocate_storage() assert result == expected def test_zero_capacities(): grid = [ [0, 0, 0], [0, 0, 0] ] constraints = [5, 5] expected = [ [0, 0, 0], [0, 0, 0] ] optimizer = WarehouseOptimizer(grid, constraints) result = optimizer.allocate_storage() assert result == expected def test_more_items_than_capacity(): grid = [ [2, 1, 2], [1, 1] ] constraints = [10, 3] expected = [ [2, 1, 2], [1, 1] ] optimizer = WarehouseOptimizer(grid, constraints) result = optimizer.allocate_storage() assert result == expected","solution":"class WarehouseOptimizer: def __init__(self, grid, constraints): self.grid = grid self.constraints = constraints def allocate_storage(self): allocation = [[0] * len(row) for row in self.grid] for row_index, (row, constraint) in enumerate(zip(self.grid, self.constraints)): for col_index in range(len(row)): if constraint <= 0: break allocation[row_index][col_index] = min(row[col_index], constraint) constraint -= allocation[row_index][col_index] return allocation"},{"question":"from typing import List, Tuple def top_active_ips(logs: List[Tuple[str, str]], start_time: str, end_time: str) -> List[str]: Identify the IP addresses that made the most requests during a given time frame. >>> logs = [ ... (\\"192.168.1.1\\", \\"2023-01-01 10:00:00\\"), ... (\\"192.168.1.2\\", \\"2023-01-01 10:05:00\\"), ... (\\"192.168.1.1\\", \\"2023-01-01 10:10:00\\"), ... (\\"192.168.1.3\\", \\"2023-01-01 10:15:00\\"), ... (\\"192.168.1.2\\", \\"2023-01-01 10:20:00\\"), ... (\\"192.168.1.3\\", \\"2023-01-01 10:25:00\\"), ... (\\"192.168.1.1\\", \\"2023-01-01 10:30:00\\") ... ] >>> start_time = \\"2023-01-01 10:00:00\\" >>> end_time = \\"2023-01-01 10:20:00\\" >>> top_active_ips(logs, start_time, end_time) [\\"192.168.1.1\\", \\"192.168.1.2\\"] >>> start_time = \\"2023-01-01 10:15:00\\" >>> end_time = \\"2023-01-01 10:30:00\\" >>> top_active_ips(logs, start_time, end_time) [\\"192.168.1.3\\", \\"192.168.1.1\\"] # Write your code here.","solution":"from typing import List, Tuple from collections import defaultdict def top_active_ips(logs: List[Tuple[str, str]], start_time: str, end_time: str) -> List[str]: counts = defaultdict(int) for ip, timestamp in logs: if start_time <= timestamp <= end_time: counts[ip] += 1 max_requests = max(counts.values(), default=0) result = [ip for ip, count in counts.items() if count == max_requests] return sorted(result)"},{"question":"def product_except_self(nums: list[int]) -> list[int]: Transforms a given list of integers such that every element in the list becomes the product of all the integers in the original list except the one at the current index. The function must do so without using division and in O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1]) [1]","solution":"def product_except_self(nums: list[int]) -> list[int]: n = len(nums) # Initialize the answer array with 1 results = [1] * n # Calculate left products left_product = 1 for i in range(n): results[i] = left_product left_product *= nums[i] # Calculate right products and multiply with left products right_product = 1 for i in range(n-1, -1, -1): results[i] *= right_product right_product *= nums[i] return results"},{"question":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a square matrix by 90 degrees clockwise. >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix([]) Traceback (most recent call last): ... ValueError: The matrix must be a non-empty square matrix. >>> rotate_matrix([[1, 2, 3], [4, 5, 6]]) Traceback (most recent call last): ... ValueError: The matrix must be a non-empty square matrix.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a square matrix by 90 degrees clockwise. # Check if matrix is empty if not matrix or not matrix[0]: raise ValueError(\\"The matrix must be a non-empty square matrix.\\") # Check if matrix is square n = len(matrix) if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be a non-empty square matrix.\\") # Initialize the rotated matrix rotated_matrix = [[0] * n for _ in range(n)] # Fill the rotated matrix for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"def shift_array(arr: list[int], direction: str, positions: int) -> list[int]: Shifts the elements of an array either to the left or right by the specified number of positions. Parameters: - arr: list of int: A list of integers representing the array to be transformed. - direction: str: A string either \\"left\\" or \\"right\\" indicating the direction to shift the elements. - positions: int: An integer specifying the number of positions to shift. The value will always be a non-negative integer. Returns: - list of int: The array after being shifted in the specified direction by the specified number of positions. >>> shift_array([1, 2, 3, 4, 5], \\"left\\", 2) [3, 4, 5, 1, 2] >>> shift_array([1, 2, 3, 4, 5], \\"right\\", 1) [5, 1, 2, 3, 4] >>> shift_array([10, 20, 30, 40, 50], \\"left\\", 5) [10, 20, 30, 40, 50] >>> shift_array([7], \\"right\\", 3) [7] from solution import shift_array def test_left_shift(): assert shift_array([1, 2, 3, 4, 5], \\"left\\", 2) == [3, 4, 5, 1, 2] def test_right_shift(): assert shift_array([1, 2, 3, 4, 5], \\"right\\", 1) == [5, 1, 2, 3, 4] def test_full_left_shift(): assert shift_array([10, 20, 30, 40, 50], \\"left\\", 5) == [10, 20, 30, 40, 50] def test_full_right_shift(): assert shift_array([10, 20, 30, 40, 50], \\"right\\", 5) == [10, 20, 30, 40, 50] def test_single_element(): assert shift_array([7], \\"right\\", 3) == [7] def test_no_shift(): assert shift_array([1, 2, 3], \\"left\\", 0) == [1, 2, 3] assert shift_array([1, 2, 3], \\"right\\", 0) == [1, 2, 3] def test_edge_cases(): assert shift_array([1, 2], \\"left\\", 1) == [2, 1] assert shift_array([1, 2], \\"right\\", 1) == [2, 1] def test_invalid_direction(): try: shift_array([1, 2, 3], \\"up\\", 1) except ValueError as e: assert str(e) == \\"The direction must be either 'left' or 'right'\\"","solution":"def shift_array(arr, direction, positions): Shifts the elements of the array either to the left or right by the specified positions. Wraps around elements as necessary. :param arr: List of integers :param direction: A string either \\"left\\" or \\"right\\" indicating the direction to shift :param positions: An integer specifying the number of positions to shift :return: List of integers representing the shifted array length = len(arr) if positions == 0 or positions == length: return arr if direction == 'left': return arr[positions:] + arr[:positions] elif direction == 'right': return arr[-positions:] + arr[:-positions] else: raise ValueError(\\"The direction must be either 'left' or 'right'\\")"},{"question":"class Swimmer: Represents swimming behavior. def swim(self): Prints the swimming behavior. print(\\"I can swim!\\") class Flyer: Represents flying behavior. def fly(self): Prints the flying behavior. print(\\"I can fly!\\") class Bird(Flyer): Represents a bird which can fly. def speak(self): Prints the sound a bird makes. print(\\"Chirp\\") class Fish(Swimmer): Represents a fish which can swim. def speak(self): Prints the sound a fish makes. print(\\"Blub\\") class Duck(Bird, Swimmer): Represents a duck which can swim and fly. def speak(self): Prints the sound a duck makes. print(\\"Quack\\")","solution":"class Swimmer: def swim(self): print(\\"I can swim!\\") class Flyer: def fly(self): print(\\"I can fly!\\") class Bird(Flyer): def speak(self): print(\\"Chirp\\") class Fish(Swimmer): def speak(self): print(\\"Blub\\") class Duck(Bird, Swimmer): def speak(self): print(\\"Quack\\")"},{"question":"import numpy as np class KMeans: def __init__(self, K: int, n_iter: int = 100) -> None: Initialize the KMeans clustering class. Parameters: - K (int): The number of clusters. - n_iter (int): The maximum number of iterations. self.K = K self.n_iter = n_iter def initialize_centroids(self, features: np.ndarray) -> np.ndarray: Randomly initialize K centroids from the dataset. Parameters: - features (np.ndarray): The dataset. Returns: - np.ndarray: Initial centroids. def assign_clusters(self, features: np.ndarray, centroids: np.ndarray) -> np.ndarray: Assign each data point to the nearest centroid. Parameters: - features (np.ndarray): The dataset. - centroids (np.ndarray): Current centroids. Returns: - np.ndarray: Cluster assignments. def update_centroids(self, features: np.ndarray, labels: np.ndarray) -> np.ndarray: Update centroids to the mean of assigned points. Parameters: - features (np.ndarray): The dataset. - labels (np.ndarray): Cluster assignments. Returns: - np.ndarray: Updated centroids. def fit_predict(self, features: np.ndarray) -> tuple: Fit the KMeans model to the dataset and return the cluster assignments. Parameters: - features (np.ndarray): The dataset. Returns: - tuple: Final centroids and cluster assignments. centroids = self.initialize_centroids(features) for _ in range(self.n_iter): labels = self.assign_clusters(features, centroids) new_centroids = self.update_centroids(features, labels) if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, labels if __name__ == \\"__main__\\": from sklearn.datasets import make_blobs import matplotlib.pyplot as plt # Create synthetic dataset X, _ = make_blobs(n_samples=300, centers=4, n_features=2, random_state=42) # Apply KMeans K = 4 kmeans = KMeans(K) centroids, labels = kmeans.fit_predict(X) # Plot the clustering result plt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis', marker='o') plt.scatter(centroids[:, 0], centroids[:, 1], s=300, c='red', marker='x') plt.title('KMeans Clustering') plt.show()","solution":"import numpy as np class KMeans: def __init__(self, K: int, n_iter: int = 100) -> None: Initialize the KMeans clustering class. Parameters: - K (int): The number of clusters. - n_iter (int): The maximum number of iterations. self.K = K self.n_iter = n_iter def initialize_centroids(self, features: np.ndarray) -> np.ndarray: Randomly initialize K centroids from the dataset. Parameters: - features (np.ndarray): The dataset. Returns: - np.ndarray: Initial centroids. np.random.seed(42) indices = np.random.choice(features.shape[0], self.K, replace=False) return features[indices] def assign_clusters(self, features: np.ndarray, centroids: np.ndarray) -> np.ndarray: Assign each data point to the nearest centroid. Parameters: - features (np.ndarray): The dataset. - centroids (np.ndarray): Current centroids. Returns: - np.ndarray: Cluster assignments. distances = np.linalg.norm(features[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(self, features: np.ndarray, labels: np.ndarray) -> np.ndarray: Update centroids to the mean of assigned points. Parameters: - features (np.ndarray): The dataset. - labels (np.ndarray): Cluster assignments. Returns: - np.ndarray: Updated centroids. new_centroids = np.array([features[labels == k].mean(axis=0) for k in range(self.K)]) return new_centroids def fit_predict(self, features: np.ndarray) -> tuple: Fit the KMeans model to the dataset and return the cluster assignments. Parameters: - features (np.ndarray): The dataset. Returns: - tuple: Final centroids and cluster assignments. centroids = self.initialize_centroids(features) for _ in range(self.n_iter): labels = self.assign_clusters(features, centroids) new_centroids = self.update_centroids(features, labels) if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, labels"},{"question":"def closest_pair_of_points(points: list[tuple[int, int]]) -> tuple[tuple[int, int], tuple[int, int]]: Find the closest pair of points in a 2D plane from a given set of points. Args: points (list of tuple): A list of tuples where each tuple represents the coordinates of a point in the 2D plane. Returns: tuple of tuple: A tuple containing two tuples, each representing the coordinates of the closest pair of points. Example: >>> points = [(2, 3), (12, 30), (40, 50), (5, 1), (12, 10), (3, 4)] >>> closest_pair_of_points(points) ((2, 3), (3, 4)) >>> points = [(1, 1), (2, 2), (1, 1)] >>> closest_pair_of_points(points) ((1, 1), (1, 1))","solution":"def closest_pair_of_points(points: list[tuple[int, int]]) -> tuple[tuple[int, int], tuple[int, int]]: import math def distance(p1, p2): return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 # squared distance to avoid computing sqrt repeatedly def closest_pair_recursive(points_sorted_x, points_sorted_y): n = len(points_sorted_x) # Base case: if there are 3 or fewer points, compute the distance directly if n <= 3: min_dist = float('inf') min_pair = (None, None) for i in range(n): for j in range(i + 1, n): d = distance(points_sorted_x[i], points_sorted_x[j]) if d < min_dist: min_dist = d min_pair = (points_sorted_x[i], points_sorted_x[j]) return min_pair, min_dist mid = n // 2 # Find the midpoint left_x = points_sorted_x[:mid] right_x = points_sorted_x[mid:] midpoint = points_sorted_x[mid][0] left_y = [] right_y = [] for p in points_sorted_y: if p[0] <= midpoint: left_y.append(p) else: right_y.append(p) (pair_left, dist_left) = closest_pair_recursive(left_x, left_y) (pair_right, dist_right) = closest_pair_recursive(right_x, right_y) if dist_left < dist_right: min_dist = dist_left min_pair = pair_left else: min_dist = dist_right min_pair = pair_right strip_y = [p for p in points_sorted_y if abs(p[0] - midpoint) < math.sqrt(min_dist)] strip_min_dist = min_dist strip_min_pair = min_pair for i in range(len(strip_y)): for j in range(i + 1, min(i + 7, len(strip_y))): # Only need to check up to 7 points ahead d = distance(strip_y[i], strip_y[j]) if d < strip_min_dist: strip_min_dist = d strip_min_pair = (strip_y[i], strip_y[j]) return strip_min_pair, strip_min_dist points_sorted_x = sorted(points, key=lambda x: x[0]) points_sorted_y = sorted(points, key=lambda x: x[1]) result, _ = closest_pair_recursive(points_sorted_x, points_sorted_y) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None, parent=None): self.val = val self.left = left self.right = right self.parent = parent def in_order_successor(node: TreeNode | None) -> TreeNode | None: Finds the in-order successor of the given node in a BST. pass def find_min(node: TreeNode) -> TreeNode: Finds the minimum node in a BST (leftmost node). pass # Example BST # 20 # / # 8 22 # / # 4 12 # / # 10 14 root = TreeNode(20) root.left = TreeNode(8, parent=root) root.right = TreeNode(22, parent=root) root.left.left = TreeNode(4, parent=root.left) root.left.right = TreeNode(12, parent=root.left) root.left.right.left = TreeNode(10, parent=root.left.right) root.left.right.right = TreeNode(14, parent=root.left.right) # Node: 10 Successor: 12 print(in_order_successor(root.left.right.left).val) # Output should be 12 # Node: 14 Successor: 20 print(in_order_successor(root.left.right.right).val) # Output should be 20 # Node: 22 Successor: None (No successor) print(in_order_successor(root.right)) # Output should be None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None, parent=None): self.val = val self.left = left self.right = right self.parent = parent def in_order_successor(node: TreeNode | None) -> TreeNode | None: Finds the in-order successor of the given node in a BST. if not node: return None # If node has a right child, then the successor is the leftmost node in the right subtree if node.right: return find_min(node.right) # If node has no right child, go up using the parent pointer until we find a node # which is the left child of its parent, then the parent will be the successor. current = node while current.parent and current == current.parent.right: current = current.parent return current.parent def find_min(node: TreeNode) -> TreeNode: Finds the minimum node in a BST (leftmost node). while node.left: node = node.left return node"},{"question":"def format_json(json_string: str) -> str: Implement an Auto-formatter for JSON Strings. You are given a JSON-like string that lacks proper indentation and line breaks. Implement a function that formats this string with appropriate line breaks and indentation to make it more readable. The JSON-like string may contain nested objects and arrays. The function returns a string representing the input JSON but formatted with appropriate line breaks and indentation (2 spaces per level of depth). Example: >>> json_input = '{\\"name\\":\\"John\\",\\"age\\":30,\\"cars\\":[\\"Ford\\",\\"BMW\\",\\"Fiat\\"],\\"address\\":{\\"city\\":\\"New York\\",\\"zipcode\\":10001}}' >>> format_json(json_input) ''' { \\"name\\": \\"John\\", \\"age\\": 30, \\"cars\\": [ \\"Ford\\", \\"BMW\\", \\"Fiat\\" ], \\"address\\": { \\"city\\": \\"New York\\", \\"zipcode\\": 10001 } } ''' pass","solution":"import json def format_json(json_string: str) -> str: parsed_json = json.loads(json_string) return json.dumps(parsed_json, indent=2, separators=(',', ': '))"},{"question":"def calculate_ride_fare(distance: float, hour: int, car_type: str) -> float: Calculates the ride fare based on distance, hour of the day, and car type. Args: distance (float): Distance of the trip in kilometers. hour (int): Hour of the day (0-23). car_type (str): Type of the car - \\"economy\\", \\"standard\\", or \\"luxury\\". Returns: float: The calculated fare as a floating-point number. Examples: >>> calculate_ride_fare(10, 22, \\"standard\\") 45.0 >>> calculate_ride_fare(5, 14, \\"economy\\") 10.0 # Your implementation here def test_calculate_ride_fare_economy_day(): assert calculate_ride_fare(5, 14, \\"economy\\") == 10.0 assert calculate_ride_fare(10, 10, \\"economy\\") == 15.0 def test_calculate_ride_fare_standard_day(): assert calculate_ride_fare(10, 10, \\"standard\\") == 30.0 assert calculate_ride_fare(5, 14, \\"standard\\") == 20.0 def test_calculate_ride_fare_luxury_day(): assert calculate_ride_fare(10, 10, \\"luxury\\") == 50.0 assert calculate_ride_fare(5, 14, \\"luxury\\") == 35.0 def test_calculate_ride_fare_economy_night(): assert calculate_ride_fare(10, 22, \\"economy\\") == 22.5 assert calculate_ride_fare(5, 3, \\"economy\\") == 15.0 def test_calculate_ride_fare_standard_night(): assert calculate_ride_fare(10, 22, \\"standard\\") == 45.0 assert calculate_ride_fare(5, 3, \\"standard\\") == 30.0 def test_calculate_ride_fare_luxury_night(): assert calculate_ride_fare(10, 22, \\"luxury\\") == 75.0 assert calculate_ride_fare(5, 3, \\"luxury\\") == 52.5 def test_calculate_ride_fare_edge_cases(): # Hour exactly at the start of high fare period assert calculate_ride_fare(10, 0, \\"economy\\") == 22.5 # Hour exactly at the start of normal fare period assert calculate_ride_fare(10, 6, \\"standard\\") == 30.0 # Hour exactly at the end of normal fare period, beginning of high fare period assert calculate_ride_fare(10, 18, \\"luxury\\") == 75.0","solution":"def calculate_ride_fare(distance: float, hour: int, car_type: str) -> float: Calculates the ride fare based on distance, hour of the day, and car type. :param distance: Distance of the trip in kilometers. :param hour: Hour of the day (0-23). :param car_type: Type of the car - \\"economy\\", \\"standard\\", or \\"luxury\\". :return: The calculated fare as a floating-point number. base_fare = { \\"economy\\": 5, \\"standard\\": 10, \\"luxury\\": 20 } cost_per_km = { \\"economy\\": 1, \\"standard\\": 2, \\"luxury\\": 3 } time_of_day_multiplier = 1.5 if (0 <= hour < 6 or 18 <= hour < 24) else 1.0 fare = (base_fare[car_type] + distance * cost_per_km[car_type]) * time_of_day_multiplier return fare"},{"question":"class VehicleFleet: def __init__(self): Initialize the VehicleFleet with an empty dictionary to store vehicle distances. def add_vehicle(self, vehicle_id: str) -> None: Register a new vehicle with a unique vehicle_id. Raise ValueError if vehicle_id already exists. def update_distance(self, vehicle_id: str, distance: float) -> None: Update the distance traveled by a vehicle since the last update. Raise ValueError if vehicle_id not found or distance is negative. def get_total_distance(self, vehicle_id: str) -> float: Get the total distance traveled by a specified vehicle. Raise ValueError if vehicle_id not found. # Example usage fleet = VehicleFleet() fleet.add_vehicle(\\"ABC123\\") fleet.update_distance(\\"ABC123\\", 150.75) fleet.update_distance(\\"ABC123\\", 200.25) print(fleet.get_total_distance(\\"ABC123\\")) # Output: 351.0 fleet.add_vehicle(\\"DEF456\\") fleet.update_distance(\\"DEF456\\", 100.0) print(fleet.get_total_distance(\\"DEF456\\")) # Output: 100.0 try: print(fleet.get_total_distance(\\"XYZ999\\")) except ValueError as e: print(e) # Output: Vehicle not found fleet.update_distance(\\"ABC123\\", 50.0) print(fleet.get_total_distance(\\"ABC123\\")) # Output: 401.0","solution":"class VehicleFleet: def __init__(self): self.vehicles = {} def add_vehicle(self, vehicle_id: str) -> None: if vehicle_id in self.vehicles: raise ValueError(f\\"Vehicle with id {vehicle_id} already exists\\") self.vehicles[vehicle_id] = 0.0 def update_distance(self, vehicle_id: str, distance: float) -> None: if vehicle_id not in self.vehicles: raise ValueError(\\"Vehicle not found\\") if distance < 0: raise ValueError(\\"Distance cannot be negative\\") self.vehicles[vehicle_id] += distance def get_total_distance(self, vehicle_id: str) -> float: if vehicle_id not in self.vehicles: raise ValueError(\\"Vehicle not found\\") return self.vehicles[vehicle_id]"},{"question":"class TreeNode: def __init__(self, x: int, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = x self.left = left self.right = right class SymmetricalTree: def isSymmetrical(self, root: TreeNode) -> bool: Determines if a given binary tree is symmetrical around its center. Args: root (TreeNode): The root node of the binary tree. Returns: bool: True if the tree is symmetrical, False otherwise. ... def isMirror(self, left: TreeNode, right: TreeNode) -> bool: Helper method to check if two trees are mirror images of each other. Args: left (TreeNode): The root node of the first tree. right (TreeNode): The root node of the second tree. Returns: bool: True if the trees are mirrors of each other, False otherwise. ... from solution import TreeNode, SymmetricalTree def test_symmetrical_tree(): left = TreeNode(2, TreeNode(3), TreeNode(4)) right = TreeNode(2, TreeNode(4), TreeNode(3)) root = TreeNode(1, left, right) sym_tree = SymmetricalTree() assert sym_tree.isSymmetrical(root) == True def test_non_symmetrical_tree(): left = TreeNode(2, None, TreeNode(3)) right = TreeNode(2, None, TreeNode(3)) root = TreeNode(1, left, right) sym_tree = SymmetricalTree() assert sym_tree.isSymmetrical(root) == False def test_empty_tree(): root = None sym_tree = SymmetricalTree() assert sym_tree.isSymmetrical(root) == True def test_single_node_tree(): root = TreeNode(1) sym_tree = SymmetricalTree() assert sym_tree.isSymmetrical(root) == True def test_asymmetrical_tree_with_different_values(): left = TreeNode(2, TreeNode(3), TreeNode(5)) right = TreeNode(2, TreeNode(4), TreeNode(3)) root = TreeNode(1, left, right) sym_tree = SymmetricalTree() assert sym_tree.isSymmetrical(root) == False","solution":"class TreeNode: def __init__(self, x: int, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = x self.left = left self.right = right class SymmetricalTree: def isSymmetrical(self, root: TreeNode) -> bool: if not root: return True return self.isMirror(root.left, root.right) def isMirror(self, left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"},{"question":"def can_form_palindrome(s: str) -> bool: Checks whether the characters of the given string can be rearranged into a palindrome. :param s: A string consisting of lowercase English letters. :return: True if the characters can be rearranged to form a palindrome, otherwise False. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"aabbccd\\") True >>> can_form_palindrome(\\"abc\\") False","solution":"def can_form_palindrome(s: str) -> bool: Checks whether the characters of the given string can be rearranged into a palindrome. :param s: A string consisting of lowercase English letters. :return: True if the characters can be rearranged to form a palindrome, otherwise False. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For it to be rearranged to form a palindrome, at most one character can have an odd count. return odd_count <= 1"},{"question":"def merge_activity_periods(logs: dict[int, list[tuple[int, int]]]) -> dict[int, list[tuple[int, int]]]: Merges overlapping time intervals for each user. Args: logs (dict[int, list[tuple[int, int]]]): A dictionary where keys are user IDs and values are lists of tuples representing start and end times of activity periods. Returns: dict[int, list[tuple[int, int]]]: A dictionary with user IDs as keys and their merged activity periods as values. >>> logs = { ... 1: [(1, 5), (3, 7), (10, 14)], ... 2: [(8, 10), (2, 4), (1, 2), (6, 8)], ... 3: [(0, 1)] ... } >>> merge_activity_periods(logs) {1: [(1, 7), (10, 14)], 2: [(1, 4), (6, 10)], 3: [(0, 1)]} >>> logs = { ... 1: [(1, 2), (3, 5), (6, 8)], ... 2: [(10, 12), (13, 15)], ... 3: [(0, 1)] ... } >>> merge_activity_periods(logs) {1: [(1, 2), (3, 5), (6, 8)], 2: [(10, 12), (13, 15)], 3: [(0, 1)]} >>> logs = { ... 1: [(1, 4), (2, 3), (3, 5)], ... 2: [(6, 10), (7, 8), (9, 11)], ... } >>> merge_activity_periods(logs) {1: [(1, 5)], 2: [(6, 11)]} >>> logs = { ... 1: [(1, 2)], ... 2: [(0, 1)], ... 3: [(5, 6)] ... } >>> merge_activity_periods(logs) {1: [(1, 2)], 2: [(0, 1)], 3: [(5, 6)]} >>> logs = {} >>> merge_activity_periods(logs) {}","solution":"def merge_activity_periods(logs): def merge_intervals(intervals): # Sort intervals based on the start time sorted_intervals = sorted(intervals, key=lambda x: x[0]) merged = [] for interval in sorted_intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged merged_logs = {} for user_id, periods in logs.items(): merged_logs[user_id] = merge_intervals(periods) return merged_logs"},{"question":"from typing import List def uniquePathsWithObstacles(obstacleGrid: List[List[int]]) -> int: Calculate the number of unique paths to reach the bottom-right corner of a grid with obstacles. Args: obstacleGrid (List[List[int]]): A 2D grid where 0 represents an empty cell and 1 represents an obstacle. Returns: int: The number of unique paths from the top-left to the bottom-right corner of the grid. Examples: >>> uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> uniquePathsWithObstacles([[0, 1], [0, 0]]) 1 def test_example_1(): assert uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 def test_example_2(): assert uniquePathsWithObstacles([[0, 1], [0, 0]]) == 1 def test_no_paths_due_to_start_obstacle(): assert uniquePathsWithObstacles([[1, 0], [0, 0]]) == 0 def test_no_paths_due_to_end_obstacle(): assert uniquePathsWithObstacles([[0, 0], [0, 1]]) == 0 def test_single_row_no_obstacles(): assert uniquePathsWithObstacles([[0, 0, 0, 0]]) == 1 def test_single_column_no_obstacles(): assert uniquePathsWithObstacles([[0], [0], [0], [0]]) == 1 def test_single_row_with_obstacles(): assert uniquePathsWithObstacles([[0, 1, 0, 0]]) == 0 def test_single_column_with_obstacles(): assert uniquePathsWithObstacles([[0], [1], [0], [0]]) == 0 def test_large_grid(): grid = [ [0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] assert uniquePathsWithObstacles(grid) == 3","solution":"def uniquePathsWithObstacles(obstacleGrid): m = len(obstacleGrid) n = len(obstacleGrid[0]) # If the starting point or the ending point is an obstacle, there's no way to reach the end. if obstacleGrid[0][0] == 1 or obstacleGrid[m-1][n-1] == 1: return 0 # Create a 2D DP array initialized to zero dp = [[0] * n for _ in range(m)] # Initialize the starting position dp[0][0] = 1 # Fill the DP table for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def count_digits(s: str) -> int: Counts the number of digit characters in the input string. Parameters: s (str): The input string to be processed. Returns: int: The number of digit characters in the string. Raises: TypeError: If the input is not a string. Examples: >>> count_digits(\\"there are 123 digits here\\") 3 >>> count_digits(\\"984skdjf93k4dfj\\") 6 >>> count_digits(\\"no digits\\") 0 >>> count_digits(\\"1234567890\\") 10 >>> count_digits(\\"\\") 0 >>> count_digits(12345) Traceback (most recent call last): ... TypeError: Input must be a string pass def test_count_digits_normal_cases(): assert count_digits(\\"there are 123 digits here\\") == 3 assert count_digits(\\"984skdjf93k4dfj\\") == 6 assert count_digits(\\"no digits\\") == 0 def test_count_digits_all_digits(): assert count_digits(\\"1234567890\\") == 10 def test_count_digits_empty_string(): assert count_digits(\\"\\") == 0 def test_count_digits_type_error(): import pytest with pytest.raises(TypeError): count_digits(12345) with pytest.raises(TypeError): count_digits([\\"123\\", \\"456\\"]) with pytest.raises(TypeError): count_digits(None) def test_count_digits_edge_cases(): assert count_digits(\\"0a1b2c3d4e5f6g7h8i9j\\") == 10 assert count_digits(\\"!!!\\") == 0 assert count_digits(\\"1!2@3#45%6^7&8*9(0)\\") == 10","solution":"def count_digits(s: str) -> int: Counts the number of digit characters in the input string. Parameters: s (str): The input string to be processed. Returns: int: The number of digit characters in the string. Raises: TypeError: If the input is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return sum(1 for char in s if char.isdigit())"},{"question":"def list_intersection(list1: list[int], list2: list[int]) -> list[int]: Find the common elements (intersection) between two lists of integers. The result list should be sorted in ascending order and should not have any duplicates. >>> list_intersection([1, 2, 3, 4], [3, 4, 5, 6]) [3, 4] >>> list_intersection([10, 20, 30, 40], [15, 20, 25, 30]) [20, 30] >>> list_intersection([1, 1, 2, 2], [2, 2, 3, 3]) [2] >>> list_intersection([1, 2, 3], []) [] >>> list_intersection([], [4, 5, 6]) [] from solution import list_intersection def test_list_intersection_basic(): assert list_intersection([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4] def test_list_intersection_with_duplicates_in_both_lists(): assert list_intersection([1, 1, 2, 2], [2, 2, 3, 3]) == [2] def test_list_intersection_no_common_elements(): assert list_intersection([1, 2, 3], [4, 5, 6]) == [] def test_list_intersection_one_list_empty(): assert list_intersection([1, 2, 3], []) == [] assert list_intersection([], [4, 5, 6]) == [] def test_list_intersection_all_common_elements(): assert list_intersection([10, 20, 30, 40], [15, 20, 25, 30]) == [20, 30] def test_list_intersection_large_input(): list1 = list(range(1, 1000001)) list2 = list(range(500000, 1500000)) expected_output = list(range(500000, 1000001)) assert list_intersection(list1, list2) == expected_output def test_list_intersection_no_duplicates_needed(): assert list_intersection([1, 2, 3, 4], [2, 3, 4, 5]) == [2, 3, 4]","solution":"def list_intersection(list1: list[int], list2: list[int]) -> list[int]: Returns the sorted list of unique integers found in both list1 and list2. # Convert lists to sets to remove duplicates and to enable O(1) average time complexity for membership checks set1 = set(list1) set2 = set(list2) # Find the intersection of sets intersection = set1.intersection(set2) # Convert the result to a sorted list before returning return sorted(intersection)"},{"question":"def compress_sequence(sequence: list[int]) -> list[int]: Compresses a list of integers by removing consecutive duplicates. Args: sequence (list): A list of integers. Returns: list: A new list with consecutive duplicates removed. >>> compress_sequence([1, 1, 2, 2, 2, 3, 4, 4, 5, 5, 5, 5, 6]) [1, 2, 3, 4, 5, 6] >>> compress_sequence([1, 2, 2, 3, 1, 1, 2, 3, 3, 1]) [1, 2, 3, 1, 2, 3, 1]","solution":"def compress_sequence(sequence): Compresses a list of integers by removing consecutive duplicates. Args: sequence (list): A list of integers. Returns: list: A new list with consecutive duplicates removed. if not sequence: return [] compressed = [sequence[0]] for num in sequence[1:]: if num != compressed[-1]: compressed.append(num) return compressed"},{"question":"from typing import Optional class Node: Class representing a node in the binary tree. def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: Class representing the binary tree. def __init__(self, root=None): self.root = root def diameter(self) -> int: Calculate the diameter of the binary tree. The diameter is the number of nodes on the longest path between two end nodes. >>> binary_tree = make_binary_tree([1, 2, 3, 4, 5, None, None]) >>> binary_tree.diameter() 4 >>> binary_tree = make_binary_tree([1, 2]) >>> binary_tree.diameter() 2","solution":"class Node: Class representing a node in the binary tree. def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: Class representing the binary tree. def __init__(self, root=None): self.root = root def diameter(self) -> int: Calculate the diameter of the binary tree. The diameter is the number of nodes on the longest path between two end nodes. def depth(node): Helper function to calculate the depth of a node and update the diameter. nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth + 1) return max(left_depth, right_depth) + 1 diameter = 0 depth(self.root) return diameter"},{"question":"def rate_limited_request_handler(user_id, timestamp, limit, period, request_log): Implementation of a rate-limited request handler. Parameters: user_id : str representing the unique ID of the user making the request. timestamp : int representing the current time in seconds since the epoch. limit : int representing the maximum number of requests allowed within the period. period : int representing the time frame in seconds within which the request limit is applied. request_log : dict where the keys are user IDs and the values are lists of timestamps of their requests. Returns: bool : True if the request is allowed, False if it exceeds the rate limit. >>> rate_limited_request_handler(\\"user123\\", 1000000, 5, 60, {}) True >>> rate_limited_request_handler(\\"user123\\", 1000010, 5, 60, {\\"user123\\": [999950, 999990, 999995]}) True >>> rate_limited_request_handler(\\"user123\\", 1000020, 3, 60, {\\"user123\\": [1000000, 1000010, 1000015]}) False >>> rate_limited_request_handler(\\"user123\\", 1000050, 3, 60, {\\"user123\\": [999950, 999990, 1000030]}) True >>> rate_limited_request_handler(\\"user123\\", 1000050, 3, 60, {\\"user123\\": [999950, 999990, 1000030], \\"user456\\": [1000000]}) True >>> rate_limited_request_handler(\\"user456\\", 1000050, 3, 60, {\\"user123\\": [999950, 999990, 1000030], \\"user456\\": [1000000]}) True","solution":"def rate_limited_request_handler(user_id, timestamp, limit, period, request_log): Implementation of a rate-limited request handler. Parameters: user_id : str representing the unique ID of the user making the request. timestamp : int representing the current time in seconds since the epoch. limit : int representing the maximum number of requests allowed within the period. period : int representing the time frame in seconds within which the request limit is applied. request_log : dict where the keys are user IDs and the values are lists of timestamps of their requests. Returns: bool : True if the request is allowed, False if it exceeds the rate limit. if user_id not in request_log: request_log[user_id] = [] # Filter out requests which are outside the allowed period while request_log[user_id] and request_log[user_id][0] <= timestamp - period: request_log[user_id].pop(0) # Check if the user has exceeded the rate limit if len(request_log[user_id]) >= limit: return False # Add the new request to the log request_log[user_id].append(timestamp) return True"},{"question":"def is_permutation(str1: str, str2: str) -> bool: Check if one string is a permutation of another. >>> is_permutation(\\"abcde\\", \\"edcba\\") True >>> is_permutation(\\"hello\\", \\"billion\\") False >>> is_permutation(\\"aabbcc\\", \\"abcabc\\") True","solution":"def is_permutation(str1: str, str2: str) -> bool: Returns True if str2 is a permutation of str1, otherwise False. if len(str1) != len(str2): return False # Using a dictionary to count the frequency of each character char_count = {} for char in str1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in str2: if char in char_count: char_count[char] -= 1 if char_count[char] < 0: return False else: return False return True"},{"question":"def sum_of_subsequences(n: int) -> int: Returns the sum of the sums of all unique subsequences for a sequence from 1 to n. >>> sum_of_subsequences(1) == 1 >>> sum_of_subsequences(2) == 6 >>> sum_of_subsequences(3) == 24 >>> sum_of_subsequences(4) == 80 >>> sum_of_subsequences(5) == 240 >>> sum_of_subsequences(6) == 672 >>> sum_of_subsequences(7) == 1792 >>> sum_of_subsequences(8) == 4608 >>> sum_of_subsequences(9) == 11520","solution":"def sum_of_subsequences(n: int) -> int: Returns the sum of the sums of all unique subsequences for a sequence from 1 to n. return (1 << (n-1)) * n * (n + 1) // 2"},{"question":"def calculate_whitespace_percentage(image: List[List[int]], threshold: int) -> float: Calculates the percentage of white pixels in the image given a threshold. Args: image (list of list of int): 2D list representing the grayscale values of image pixels. threshold (int): The grayscale value threshold above which pixels are considered white. Returns: float: The percentage of white pixels in the image. Examples: >>> calculate_whitespace_percentage([[255, 200], [150, 100]], 150) 50.0 >>> calculate_whitespace_percentage([[255, 255], [255, 255]], 200) 100.0 >>> calculate_whitespace_percentage([[0, 50], [100, 150]], 100) 25.0","solution":"def calculate_whitespace_percentage(image, threshold): Calculates the percentage of white pixels in the image given a threshold. Args: image (list of list of int): 2D list representing the grayscale values of image pixels. threshold (int): The grayscale value threshold above which pixels are considered white. Returns: float: The percentage of white pixels in the image. total_pixels = sum([len(row) for row in image]) white_pixels = sum([1 for row in image for pixel in row if pixel > threshold]) return (white_pixels / total_pixels) * 100"},{"question":"class TarjanSCC: def __init__(self, num_of_nodes: int) -> None: Initialize a graph with num_of_nodes number of nodes. Args: num_of_nodes (int): The number of nodes in the graph. pass def add_edge(self, u_node: int, v_node: int) -> None: Adds a directed edge from u_node to v_node. Args: u_node (int): The starting node of the directed edge. v_node (int): The ending node of the directed edge. pass def tarjan_scc(self) -> list[list[int]]: Executes Tarjan's Algorithm and returns a list of SCCs. Returns: list[list[int]]: A list of strongly connected components, where each component is represented as a list of node indices. pass def test_simple_graph(): g = TarjanSCC(5) edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] for u, v in edges: g.add_edge(u, v) sccs = g.tarjan_scc() expected = [[2, 1, 0], [4], [3]] assert sorted([sorted(scc) for scc in sccs]) == sorted([sorted(scc) for scc in expected]), f\\"Expected {expected}, got {sccs}\\" def test_disconnected_graph(): g = TarjanSCC(4) edges = [(0, 1), (2, 3)] for u, v in edges: g.add_edge(u, v) sccs = g.tarjan_scc() expected = [[1], [0], [3], [2]] assert sorted([sorted(scc) for scc in sccs]) == sorted([sorted(scc) for scc in expected]), f\\"Expected {expected}, got {sccs}\\" def test_single_node_scc(): g = TarjanSCC(3) edges = [(0, 1), (1, 2), (2, 1)] for u, v in edges: g.add_edge(u, v) sccs = g.tarjan_scc() expected = [[2, 1], [0]] assert sorted([sorted(scc) for scc in sccs]) == sorted([sorted(scc) for scc in expected]), f\\"Expected {expected}, got {sccs}\\" def test_complex_graph(): g = TarjanSCC(8) edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 5), (5, 6), (6, 4), (6, 7)] for u, v in edges: g.add_edge(u, v) sccs = g.tarjan_scc() expected = [[2, 1, 0], [3], [6, 5, 4], [7]] assert sorted([sorted(scc) for scc in sccs]) == sorted([sorted(scc) for scc in expected]), f\\"Expected {expected}, got {sccs}\\" def test_all_nodes_connected(): g = TarjanSCC(4) edges = [(0, 1), (1, 2), (2, 3), (3, 0)] for u, v in edges: g.add_edge(u, v) sccs = g.tarjan_scc() expected = [[3, 2, 1, 0]] assert sorted([sorted(scc) for scc in sccs]) == sorted([sorted(scc) for scc in expected]), f\\"Expected {expected}, got {sccs}\\"","solution":"class TarjanSCC: def __init__(self, num_of_nodes: int) -> None: self.num_of_nodes = num_of_nodes self.graph = [[] for _ in range(num_of_nodes)] self.index = 0 self.indexes = [-1] * num_of_nodes self.low_links = [-1] * num_of_nodes self.on_stack = [False] * num_of_nodes self.stack = [] self.sccs = [] def add_edge(self, u_node: int, v_node: int) -> None: self.graph[u_node].append(v_node) def tarjan_scc(self) -> list[list[int]]: for i in range(self.num_of_nodes): if self.indexes[i] == -1: self._strongconnect(i) return self.sccs def _strongconnect(self, node: int) -> None: self.indexes[node] = self.low_links[node] = self.index self.index += 1 self.stack.append(node) self.on_stack[node] = True for neighbor in self.graph[node]: if self.indexes[neighbor] == -1: self._strongconnect(neighbor) self.low_links[node] = min(self.low_links[node], self.low_links[neighbor]) elif self.on_stack[neighbor]: self.low_links[node] = min(self.low_links[node], self.indexes[neighbor]) if self.low_links[node] == self.indexes[node]: scc = [] while True: w = self.stack.pop() self.on_stack[w] = False scc.append(w) if w == node: break self.sccs.append(scc)"},{"question":"def find_prime_factors(a: int, b: int) -> list: Finds and returns a sorted list of all common prime factors of two given integers. :param a: First integer. :param b: Second integer. :return: Sorted list of common prime factors. >>> find_prime_factors(28, 35) [7] >>> find_prime_factors(13, 28) [] >>> find_prime_factors(20, 20) [2, 5] >>> find_prime_factors(15, 45) [3, 5] >>> find_prime_factors(12345, 54321) [3] # Your implementation goes here. pass","solution":"def find_prime_factors(a: int, b: int) -> list: Finds and returns a sorted list of all common prime factors of two given integers. :param a: First integer. :param b: Second integer. :return: Sorted list of common prime factors. def prime_factors(n): i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return list(set(factors)) factors_a = prime_factors(a) factors_b = prime_factors(b) common_factors = list(set(factors_a) & set(factors_b)) common_factors.sort() return common_factors"},{"question":"def inventory_summary(items: list[str]) -> dict[str, int]: Generate a summary of items in the inventory. Parameters: items (list of str): A list of strings representing items. Returns: dict of {str: int}: A dictionary with unique item names as keys and their counts as values. Example usage: >>> inventory_summary(['apple', 'orange', 'apple', 'banana', 'apple']) {'apple': 3, 'orange': 1, 'banana': 1} >>> inventory_summary([]) {} >>> inventory_summary(['Apple', 'apple', 'APPLE', 'apple']) {'Apple': 1, 'apple': 2, 'APPLE': 1} >>> inventory_summary(['banana', 'banana', 'banana']) {'banana': 3} >>> inventory_summary(['a', 'b', 'c', 'a', 'b', 'a']) {'a': 3, 'b': 2, 'c': 1}","solution":"def inventory_summary(items: list[str]) -> dict[str, int]: Generate a summary of items in the inventory. Parameters: items (list of str): A list of strings representing items. Returns: dict of {str: int}: A dictionary with unique item names as keys and their counts as values. summary = {} for item in items: if item in summary: summary[item] += 1 else: summary[item] = 1 return summary"},{"question":"class TrieNode: def __init__(self): pass # Implement the TrieNode data structure class Trie: def __init__(self): Initialize the Trie data structure. pass # Implement the constructor def insert(self, word: str): Insert a word into the Trie. >>> trie = Trie() >>> trie.insert(\\"apple\\") pass # Implement the insert method def search(self, word: str) -> bool: Search for a word in the Trie. >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.search(\\"apple\\") True >>> trie.search(\\"app\\") False pass # Implement the search method def delete_prefix(self, prefix: str): Delete all words with the given prefix from the Trie. >>> trie = Trie() >>> trie.insert(\\"apple\\") >>> trie.insert(\\"app\\") >>> trie.delete_prefix(\\"app\\") >>> trie.search(\\"apple\\") False >>> trie.search(\\"app\\") False pass # Implement the delete_prefix method","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def delete_prefix(self, prefix): node = self.root stack = [] for char in prefix: if char not in node.children: return # Prefix not in trie stack.append((char, node)) node = node.children[char] # If the prefix itself is a word, mark it as not end of word if node.is_end_of_word: node.is_end_of_word = False # Remove all children nodes from the last node of the prefix node.children = {} # Clean up the nodes on the way back up the stack if they are no longer part of any word while stack: char, parent = stack.pop() if not parent.children[char].children and not parent.children[char].is_end_of_word: del parent.children[char] else: break"},{"question":"def currency_converter(amount: float, src_currency: str, dst_currency: str, exchange_rates: dict) -> float: Converts the given amount from the source currency to the destination currency using the provided exchange rates. :param amount: The amount of money to be converted. :param src_currency: The source currency code. :param dst_currency: The destination currency code. :param exchange_rates: A dictionary where keys are currency codes and values are the exchange rates against a base currency. :return: The converted amount as a float. >>> currency_converter(100, 'USD', 'EUR', {'USD': 1.0, 'EUR': 0.85, 'JPY': 110.0}) # doctest: +NORMALIZE_WHITESPACE 85.0 # Your implementation here pass # Unit Tests def test_currency_converter_same_currency(): assert currency_converter(100, 'USD', 'USD', {'USD': 1.0, 'EUR': 0.85, 'JPY': 110.0}) == 100 def test_currency_converter_usd_to_eur(): result = currency_converter(100, 'USD', 'EUR', {'USD': 1.0, 'EUR': 0.85, 'JPY': 110.0}) assert round(result, 2) == 85.00 def test_currency_converter_eur_to_usd(): result = currency_converter(100, 'EUR', 'USD', {'USD': 1.0, 'EUR': 0.85, 'JPY': 110.0}) assert round(result, 2) == 117.65 def test_currency_converter_usd_to_jpy(): result = currency_converter(100, 'USD', 'JPY', {'USD': 1.0, 'EUR': 0.85, 'JPY': 110.0}) assert round(result, 2) == 11000 def test_currency_converter_jpy_to_usd(): result = currency_converter(11000, 'JPY', 'USD', {'USD': 1.0, 'EUR': 0.85, 'JPY': 110.0}) assert round(result, 2) == 100 def test_currency_converter_small_amount(): result = currency_converter(0.01, 'USD', 'EUR', {'USD': 1.0, 'EUR': 0.85, 'JPY': 110.0}) assert round(result, 4) == 0.0085 def test_currency_converter_large_amount(): result = currency_converter(1000000, 'USD', 'JPY', {'USD': 1.0, 'EUR': 0.85, 'JPY': 110.0}) assert round(result, 2) == 110000000","solution":"def currency_converter(amount: float, src_currency: str, dst_currency: str, exchange_rates: dict) -> float: Converts the given amount from source currency to destination currency using the provided exchange rates. :param amount: The amount of money to be converted. :param src_currency: The source currency code. :param dst_currency: The destination currency code. :param exchange_rates: A dictionary where keys are currency codes and values are the exchange rates against a base currency. :return: The converted amount as a float. if src_currency == dst_currency: return amount base_amount = amount / exchange_rates[src_currency] converted_amount = base_amount * exchange_rates[dst_currency] return converted_amount"},{"question":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.data: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def height(self) -> int: Compute the height of the tree. The height of a tree is the number of edges in the longest path from the root to a leaf node. >>> bst = BinarySearchTree() >>> bst.insert(20) >>> bst.height() 0 >>> bst.insert(8) >>> bst.insert(22) >>> bst.insert(4) >>> bst.insert(12) >>> bst.insert(10) >>> bst.insert(14) >>> bst.height() 3 def find_lca(self, n1: int, n2: int) -> Node: Find the lowest common ancestor (LCA) of two given nodes n1 and n2. If either n1 or n2 is not present in the tree, return None. >>> bst = BinarySearchTree() >>> bst.insert(20) >>> bst.insert(8) >>> bst.insert(22) >>> bst.insert(4) >>> bst.insert(12) >>> bst.insert(10) >>> bst.insert(14) >>> lca_node = bst.find_lca(10, 14) >>> lca_node.data 12 from solution import BinarySearchTree, Node def test_height(): bst = BinarySearchTree() assert bst.height() == -1 # Test for empty tree bst.insert(20) assert bst.height() == 0 # Test for tree with one node bst.insert(8) bst.insert(22) bst.insert(4) bst.insert(12) bst.insert(10) bst.insert(14) assert bst.height() == 3 # Test for given example def test_find_lca(): bst = BinarySearchTree() bst.insert(20) bst.insert(8) bst.insert(22) bst.insert(4) bst.insert(12) bst.insert(10) bst.insert(14) lca = bst.find_lca(10, 14) assert lca.data == 12 # Test given example lca = bst.find_lca(8, 22) assert lca.data == 20 # LCA for nodes in different subtrees lca = bst.find_lca(4, 8) assert lca.data == 8 # LCA when one node is ancestor of the other assert bst.find_lca(10, 100) == None # Test for non-existent node assert bst.find_lca(100, 200) == None # Test for both nodes non-existent def test_empty_tree(): bst = BinarySearchTree() assert bst.find_lca(1, 2) == None","solution":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.data: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def height(self): def _height(node): if node is None: return -1 # Base case: empty tree has height -1 left_height = _height(node.left) right_height = _height(node.right) return 1 + max(left_height, right_height) return _height(self.root) def find_lca(self, n1, n2): def _find_lca(node, n1, n2): if node is None: return None # If either n1 or n2 matches with root's key, report the presence by returning root if node.data == n1 or node.data == n2: return node # Look for keys in left and right subtrees left_lca = _find_lca(node.left, n1, n2) right_lca = _find_lca(node.right, n1, n2) # If both of the above calls return non-null, then n1 and n2 are in different subtrees # so this node is their LCA if left_lca and right_lca: return node # Otherwise check if left subtree or right subtree is LCA return left_lca if left_lca is not None else right_lca # Wrapper method for LCA lca = _find_lca(self.root, n1, n2) def find(node, k): if node is None: return False if node.data == k or find(node.left, k) or find(node.right, k): return True return False if find(self.root, n1) and find(self.root, n2): return lca return None"},{"question":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: Calculate the maximum sum of non-adjacent numbers in the list. >>> max_non_adjacent_sum([4, 1, 1, 4, 2, 1]) 9 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110 >>> max_non_adjacent_sum([-1, -2, -3, -4]) 0 >>> max_non_adjacent_sum([1, 2, 20]) 21 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([0]) 0 >>> max_non_adjacent_sum([-5]) 0 >>> max_non_adjacent_sum([5, 1]) 5 >>> max_non_adjacent_sum([1, 5]) 5 >>> max_non_adjacent_sum([-1, 2]) 2 >>> max_non_adjacent_sum([1, -2]) 1","solution":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: Calculate the maximum sum of non-adjacent numbers in the list. if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) prev1 = 0 prev2 = 0 for num in nums: current = max(prev1, prev2 + num) prev2 = prev1 prev1 = current return prev1"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string s. :param s: str - The string for which we need to find the distinct substrings :return: int - The count of distinct substrings >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"abab\\") 7 >>> count_distinct_substrings(\\"abcabc\\") 15 >>> count_distinct_substrings(\\"abcd\\") 10","solution":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string s. :param s: str - The string for which we need to find the distinct substrings :return: int - The count of distinct substrings substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def caesar_cipher(message: str, shift: int) -> str: Encrypt a given message using a Caesar cipher. Args: message (str): The message to be encrypted. shift (int): The shift value for the cipher. Returns: str: The encrypted message. Examples: >>> caesar_cipher(\\"Hello, World!\\", 3) 'Khoor, Zruog!' >>> caesar_cipher(\\"python\\", 5) 'udymts' >>> caesar_cipher(\\"A quick brown fox jumps over the lazy dog.\\", 7) 'H xzbjr iytdu lve qbtwl vcly aol sgrf kvn.' >>> caesar_cipher(\\"Shift123\\", 2) 'Ujkhr123' pass from caesar_cipher_solution import caesar_cipher def test_caesar_cipher_simple(): assert caesar_cipher(\\"abc\\", 1) == \\"bcd\\" assert caesar_cipher(\\"xyz\\", 1) == \\"yza\\" def test_caesar_cipher_with_non_alphabet(): assert caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert caesar_cipher(\\"Python 3.8\\", 5) == \\"Udymts 3.8\\" def test_caesar_cipher_with_mixed_case(): assert caesar_cipher(\\"AbCdEfG\\", 2) == \\"CdEfGhI\\" assert caesar_cipher(\\"ShIfTs\\", 5) == \\"XmNkYx\\" def test_caesar_cipher_with_large_shift(): assert caesar_cipher(\\"abc\\", 27) == \\"bcd\\" assert caesar_cipher(\\"xyz\\", -1) == \\"wxy\\" def test_caesar_cipher_with_negative_shift(): assert caesar_cipher(\\"def\\", -1) == \\"cde\\" assert caesar_cipher(\\"ABC\\", -2) == \\"YZA\\"","solution":"def caesar_cipher(message: str, shift: int) -> str: def shift_char(c, shift): if 'a' <= c <= 'z': start = ord('a') elif 'A' <= c <= 'Z': start = ord('A') else: return c return chr(start + (ord(c) - start + shift) % 26) return ''.join(shift_char(c, shift) for c in message)"},{"question":"def detect_cycle(graph: Dict[int, List[int]], max_node: int) -> None: Function to detect a cycle in a directed graph. Prints \\"Cycle Detected\\" if a cycle exists in the graph, otherwise prints \\"No Cycle Detected\\". >>> g1 = {1: [2], 2: [3], 3: [4, 5], 4: [2], 5: []} >>> detect_cycle(g1, 5) Cycle Detected >>> g2 = {1: [2], 2: [3], 3: [4], 4: []} >>> detect_cycle(g2, 4) No Cycle Detected >>> g3 = {1: [2, 3], 2: [3], 3: []} >>> detect_cycle(g3, 3) No Cycle Detected >>> g4 = {1: [2], 2: [3], 3: [1], 4: [4]} >>> detect_cycle(g4, 4) Cycle Detected >>> g5 = {1: [2], 3: [4], 4: []} >>> detect_cycle(g5, 4) No Cycle Detected >>> g6 = {} >>> detect_cycle(g6, 0) No Cycle Detected","solution":"def detect_cycle(graph, max_node): Function to detect a cycle in a directed graph. def dfs(node, visited, stack): visited[node] = True stack[node] = True for neighbor in graph.get(node, []): if not visited[neighbor]: if dfs(neighbor, visited, stack): return True elif stack[neighbor]: return True stack[node] = False return False visited = [False] * (max_node + 1) stack = [False] * (max_node + 1) for node in range(1, max_node + 1): if not visited[node]: if dfs(node, visited, stack): print(\\"Cycle Detected\\") return print(\\"No Cycle Detected\\")"},{"question":"import datetime def activity_logger(log_filename: str) -> None: Logs user activities with a timestamp into a specified file and provides a summary of the logged activities when requested. The function should continuously prompt the user for a command input until the user inputs the command 'SUMMARY'. For each command entered, the function logs the command with a timestamp to the specified file. Parameters: log_filename (str): The name of the file where activities should be logged. Example usage: >>> activity_logger(\\"activity_log.txt\\") pass if __name__ == \\"__main__\\": import os import datetime import tempfile log_filename = \\"activity_log.txt\\" def input_generator(inputs): This generator function mimics user input. for item in inputs: yield item def test_activity_logger(monkeypatch): Test the activity_logger function with predefined inputs. # Create a temporary file to log activities with tempfile.NamedTemporaryFile(delete=False) as tmp_file: log_filename = tmp_file.name # Predefine inputs and mock \`input()\` to return these inputs inputs = ['command1', 'command2', 'SUMMARY'] input_gen = input_generator(inputs) monkeypatch.setattr('builtins.input', lambda _: next(input_gen)) # Run the activity_logger function activity_logger(log_filename) # Read the logged file to verify the contents with open(log_filename, 'r') as log_file: logs = log_file.readlines() # Check the contents of the logs timestamp_format = '%Y-%m-%d %H:%M:%S' current_time = datetime.datetime.now().strftime(timestamp_format) for log in logs: timestamp, command = log.strip().split(': ', 1) # Check that the timestamp is in the correct format datetime.datetime.strptime(timestamp, timestamp_format) assert logs[0].strip().endswith('command1') assert logs[1].strip().endswith('command2') # Clean up the temporary file os.remove(log_filename)","solution":"import datetime def activity_logger(log_filename: str) -> None: Logs user activities with a timestamp into a specified file and provides a summary of the logged activities when requested. # Opening the file in append mode with open(log_filename, 'a+') as log_file: while True: command = input(\\"Enter command: \\") if command == \\"SUMMARY\\": break timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') log_file.write(f\\"{timestamp}: {command}n\\") # Reopen the file to read log entries for the summary with open(log_filename, 'r') as log_file: logs = log_file.readlines() for log in logs: print(log.strip())"},{"question":"from typing import List def find_most_similar(word: str, dictionary: List[str]) -> str: Find the most similar word from the dictionary based on the Levenshtein distance. pass def correct_misspellings(text: str, dictionary: List[str]) -> str: Correct misspelled words in the text using the given dictionary. >>> correct_misspellings(\\"Ths is a smple txt\\", [\\"This\\", \\"is\\", \\"a\\", \\"simple\\", \\"text\\"]) == \\"This is a simple text\\" >>> correct_misspellings(\\"Helo wrld\\", [\\"Hello\\", \\"world\\"]) == \\"Hello world\\" pass","solution":"from typing import List import difflib def find_most_similar(word: str, dictionary: List[str]) -> str: # Use difflib.get_close_matches to find the closest match from the dictionary matches = difflib.get_close_matches(word, dictionary, n=1, cutoff=0.0) if matches: return matches[0] else: return word def correct_misspellings(text: str, dictionary: List[str]) -> str: if not isinstance(text, str): raise TypeError(\\"The text parameter must be a string.\\") if not isinstance(dictionary, list) or not all(isinstance(w, str) for w in dictionary): raise TypeError(\\"The dictionary parameter must be a list of strings.\\") words = text.split() corrected_words = [] for word in words: if word in dictionary: corrected_words.append(word) else: corrected_words.append(find_most_similar(word, dictionary)) return ' '.join(corrected_words)"},{"question":"def efficient_matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: Perform matrix multiplication of matrices A and B. Parameters: A (list of list of int): matrix A with dimensions m x n B (list of list of int): matrix B with dimensions n x p Returns: list of list of int: Resultant matrix of dimensions m x p Example: >>> efficient_matrix_multiplication([[1, 2], [3, 4]], [[5, 6], [7, 8]]) [[19, 22], [43, 50]] >>> efficient_matrix_multiplication([[2, 0], [1, 2]], [[1, 2], [3, 4]]) [[2, 4], [7, 10]] >>> efficient_matrix_multiplication([[-1, -2], [-3, -4]], [[-5, -6], [-7, -8]]) [[19, 22], [43, 50]] pass # Your code goes here # Unit test def test_basic_case(): A = [[1, 2], [3, 4]] B = [[5, 6], [7, 8]] expected = [[19, 22], [43, 50]] assert efficient_matrix_multiplication(A, B) == expected def test_mixed_sign_case(): A = [[2, 0], [1, 2]] B = [[1, 2], [3, 4]] expected = [[2, 4], [7, 10]] assert efficient_matrix_multiplication(A, B) == expected def test_negative_elements_case(): A = [[-1, -2], [-3, -4]] B = [[-5, -6], [-7, -8]] expected = [[19, 22], [43, 50]] assert efficient_matrix_multiplication(A, B) == expected def test_zero_matrix(): A = [[0, 0], [0, 0]] B = [[0, 0], [0, 0]] expected = [[0, 0], [0, 0]] assert efficient_matrix_multiplication(A, B) == expected def test_identity_matrix(): A = [[1, 0], [0, 1]] B = [[1, 2], [3, 4]] expected = [[1, 2], [3, 4]] assert efficient_matrix_multiplication(A, B) == expected def test_non_square_matrices(): A = [[1, 2, 3], [4, 5, 6]] B = [[7, 8], [9, 10], [11, 12]] expected = [[58, 64], [139, 154]] assert efficient_matrix_multiplication(A, B) == expected def test_non_square_matrices_2(): A = [[1, 2], [3, 4], [5, 6]] B = [[7, 8, 9], [10, 11, 12]] expected = [[27, 30, 33], [61, 68, 75], [95, 106, 117]] assert efficient_matrix_multiplication(A, B) == expected","solution":"def efficient_matrix_multiplication(A, B): Perform matrix multiplication of matrices A and B. Parameters: A (list of list of int): matrix A with dimensions m x n B (list of list of int): matrix B with dimensions n x p Returns: list of list of int: Resultant matrix of dimensions m x p m = len(A) n = len(A[0]) p = len(B[0]) # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"[Completion Task in Python] Write a function that sorts strings based on a custom alphabetical order. The function should take a list of strings and a custom alphabetical order string, then sorts the list based on the custom order. The function must handle cases where the input string list might contain strings with characters not specified in the custom order by placing these strings at the end of the sorted list while maintaining stability. Implement the function \`custom_sort(strings: List[str], custom_order: str) -> List[str]\`. Examples: >>> custom_sort([\\"cat\\", \\"bat\\", \\"apple\\", \\"dog\\", \\"elephant\\"], \\"dbcafghijklmnopqrstuvwxyz\\") [\\"dog\\", \\"bat\\", \\"cat\\", \\"apple\\", \\"elephant\\"] >>> custom_sort([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") [\\"cherry\\", \\"banana\\", \\"apple\\"] >>> custom_sort([\\"alpha\\", \\"beta\\", \\"gamma\\", \\"delta\\"], \\"abcdefghijmnopqrstuvwxyzkl\\") [\\"alpha\\", \\"beta\\", \\"delta\\", \\"gamma\\"] >>> custom_sort([\\"bat\\", \\"apple\\", \\"dog\\", \\"elephant\\"], \\"abcdefghi\\") [\\"apple\\", \\"bat\\", \\"dog\\", \\"elephant\\"] >>> custom_sort([\\"beta\\", \\"alpha\\", \\"alpha\\"], \\"zyxwvutsrqponmlkjihgfedcba\\") [\\"beta\\", \\"alpha\\", \\"alpha\\"]","solution":"from typing import List def custom_sort(strings: List[str], custom_order: str) -> List[str]: # Create a priority dictionary based on custom order order_dict = {char: index for index, char in enumerate(custom_order)} # Define a custom key function for sorting def custom_key(word): # Convert each character in the string to its corresponding priority return [order_dict.get(char, len(custom_order)) for char in word] # Sort the strings using the custom key function, ensuring stability return sorted(strings, key=custom_key)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a string expression containing integers with + and - operators. Inputs: expression (str): A string representing a mathematical expression with integers and operators '+' and '-'. The string may also contain spaces. Returns: int: The result of evaluating the expression. Raises: ValueError: If the input string is empty or contains invalid characters. Examples: >>> evaluate_expression(\\"12 + 7 - 5\\") 14 >>> evaluate_expression(\\" 3 - 2 + 4 \\") 5 >>> evaluate_expression(\\"1\\") 1 >>> evaluate_expression(\\"0\\") 0 >>> evaluate_expression(\\"-5 + 3\\") -2 >>> evaluate_expression(\\"20 - 4 - 8 + 2\\") 10 >>> evaluate_expression(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> evaluate_expression(\\"10 + a\\") Traceback (most recent call last): ... ValueError: Invalid characters in the expression","solution":"def evaluate_expression(expression: str) -> int: Evaluates a string expression containing integers with + and - operators. import re # Check if the expression is empty or contains only whitespace if not expression.strip(): raise ValueError(\\"Empty string was passed to the function\\") # Check for invalid characters if not re.match(r'^[ds+-]+', expression): raise ValueError(\\"Invalid characters in the expression\\") # Strip any whitespace and split the expression by spaces tokens = expression.strip().split() # Initialize the accumulator for the result result = 0 current_number = '' current_sign = 1 for token in tokens: if token in '+-': # When we encounter a sign, it indicates the end of a number if current_number: result += current_sign * int(current_number) current_number = '' current_sign = 1 if token == '+' else -1 else: current_number += token # Add the last accumulated number if any if current_number: result += current_sign * int(current_number) return result"},{"question":"def initialize_population(population_size: int, chromosome_length: int) -> list[str]: Initialize a population of random binary strings. >>> len(initialize_population(10, 5)) == 10 >>> all(len(chromosome) == 5 for chromosome in initialize_population(10, 5)) def fitness(chromosome: str) -> int: Calculate the fitness of a binary string, which is the number of ones. >>> fitness(\\"11111\\") == 5 >>> fitness(\\"10101\\") == 3 def select_parents(population: list[str], fitnesses: list[int]) -> tuple[str, str]: Select two parents from the population using fitness-proportionate selection. >>> len(select_parents([\\"11111\\", \\"00000\\"], [5, 0])) == 2 def crossover(parent1: str, parent2: str) -> str: Perform crossover between two parents to produce an offspring. >>> len(crossover(\\"1111\\", \\"0000\\")) == 4 def mutate(chromosome: str, mutation_rate: float) -> str: Apply mutation to a binary string based on the mutation rate. >>> len(mutate(\\"1111\\", 0.5)) == 4 def evolve(population_size: int, chromosome_length: int, mutation_rate: float, generations: int) -> tuple[int, str]: Evolve a population of binary strings to maximize the number of ones. >>> evolve(10, 10, 0.01, 100) == (10, '1111111111') >>> evolve(20, 20, 0.01, 200) == (20, '11111111111111111111') >>> max_fitness, best_chromosome = evolve(1, 10, 0.5, 50) >>> max_fitness <= 10 >>> len(best_chromosome) == 10 >>> max_fitness, best_chromosome = evolve(10, 10, 0.9, 50) >>> max_fitness <= 10 >>> len(best_chromosome) == 10","solution":"import random def initialize_population(population_size, chromosome_length): return [''.join(random.choice('01') for _ in range(chromosome_length)) for _ in range(population_size)] def fitness(chromosome): return chromosome.count('1') def select_parents(population, fitnesses): total_fitness = sum(fitnesses) probs = [f / total_fitness for f in fitnesses] parents = random.choices(population, weights=probs, k=2) return parents def crossover(parent1, parent2): point = random.randint(1, len(parent1) - 1) return parent1[:point] + parent2[point:] def mutate(chromosome, mutation_rate): return ''.join(ch if random.random() > mutation_rate else '1' if ch == '0' else '0' for ch in chromosome) def evolve(population_size, chromosome_length, mutation_rate, generations): population = initialize_population(population_size, chromosome_length) best_chromosome = '' max_fitness = 0 for generation in range(generations): fitnesses = [fitness(chromosome) for chromosome in population] new_population = [] if max(fitnesses) > max_fitness: max_fitness = max(fitnesses) best_chromosome = population[fitnesses.index(max_fitness)] for _ in range(population_size): parent1, parent2 = select_parents(population, fitnesses) offspring = crossover(parent1, parent2) mutated_offspring = mutate(offspring, mutation_rate) new_population.append(mutated_offspring) population = new_population return max_fitness, best_chromosome"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Finds the largest sum of a contiguous subarray within a given one-dimensional array containing at least one integer. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([3]) == 3 >>> max_subarray_sum([-3]) == -3 >>> max_subarray_sum([1000] * 10000) == 1000 * 10000 >>> max_subarray_sum([1, 1000, -500, -700, 500, -100, 700, -1000]) == 1100 >>> max_subarray_sum([]) == 0 # Assuming the function handles empty arrays explicitly with return 0","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Finds the largest sum of a contiguous subarray within a given one-dimensional array containing at least one integer. if not arr: return 0 # Assuming an empty array should return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def find_scc(graph: Dict[int, List[int]]) -> List[List[int]]: Find all strongly connected components (SCCs) in a directed graph. >>> find_scc({0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5, 7], 5: [6], 6: [4], 7: [8], 8: [7]}) [[0, 1, 2], [3], [4, 5, 6], [7, 8]] >>> find_scc({0: [], 1: []}) [[0], [1]] >>> find_scc({0: [1], 1: [0]}) [[0, 1]]","solution":"def find_scc(graph): def dfs_first_pass(node, visited, stack): visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs_first_pass(neighbor, visited, stack) stack.append(node) def dfs_second_pass(node, visited, component, reversed_graph): visited.add(node) component.append(node) for neighbor in reversed_graph.get(node, []): if neighbor not in visited: dfs_second_pass(neighbor, visited, component, reversed_graph) # Step 1: Perform the first DFS pass to get the finishing times visited = set() stack = [] for node in graph: if node not in visited: dfs_first_pass(node, visited, stack) # Step 2: Reverse the graph reversed_graph = {} for node in graph: for neighbor in graph[node]: if neighbor not in reversed_graph: reversed_graph[neighbor] = [] reversed_graph[neighbor].append(node) # Step 3: Perform the second DFS pass on the reversed graph visited = set() sccs = [] while stack: node = stack.pop() if node not in visited: component = [] dfs_second_pass(node, visited, component, reversed_graph) sccs.append(component) return sccs"},{"question":"from datetime import datetime class TextEditor: A simple text editor with version control capabilities. - write(self, text: str) -> None: Appends the given text to the document. - save_version(self) -> None: Saves the current state of the document along with a timestamp. - revert_to_version(self, version_index: int) -> None: Reverts the document to the state of the specified version by version_index. - view_history(self) -> list[tuple[str, str]]: Returns a list of tuples containing the saved versions and their timestamps. - get_content(self) -> str: Returns the current content of the document. Example: >>> editor = TextEditor() >>> editor.write(\\"Hello, World!\\") >>> editor.save_version() >>> editor.write(\\" This is a version control system.\\") >>> editor.save_version() >>> editor.write(\\" Let's test reverting.\\") >>> editor.save_version() >>> history = editor.view_history() >>> print(history) [('2023-01-01 00:00:00', 'Hello, World!'), ('2023-01-01 01:00:00', 'Hello, World! This is a version control system.'), ('2023-01-01 02:00:00', 'Hello, World! This is a version control system. Let's test reverting.')] >>> editor.revert_to_version(1) >>> print(editor.get_content()) \\"Hello, World! This is a version control system.\\" def __init__(self): pass def write(self, text: str) -> None: pass def save_version(self) -> None: pass def revert_to_version(self, version_index: int) -> None: pass def view_history(self) -> list: pass def get_content(self) -> str: pass # Unit tests for the implemented functionality def test_initial_state(): editor = TextEditor() assert editor.get_content() == \\"\\" assert editor.view_history() == [] def test_write_and_save_versions(): editor = TextEditor() editor.write(\\"Hello, World!\\") editor.save_version() assert len(editor.view_history()) == 1 assert editor.view_history()[0][1] == \\"Hello, World!\\" editor.write(\\" This is a version control system.\\") editor.save_version() assert len(editor.view_history()) == 2 assert editor.view_history()[1][1] == \\"Hello, World! This is a version control system.\\" editor.write(\\" Let's test reverting.\\") editor.save_version() assert len(editor.view_history()) == 3 assert editor.view_history()[2][1] == \\"Hello, World! This is a version control system. Let's test reverting.\\" def test_revert_to_version(): editor = TextEditor() editor.write(\\"Hello, World!\\") editor.save_version() editor.write(\\" This is a version control system.\\") editor.save_version() editor.write(\\" Let's test reverting.\\") editor.save_version() # Initial content assert editor.get_content() == \\"Hello, World! This is a version control system. Let's test reverting.\\" # Revert to first version editor.revert_to_version(0) assert editor.get_content() == \\"Hello, World!\\" # Revert to second version editor.revert_to_version(1) assert editor.get_content() == \\"Hello, World! This is a version control system.\\" def test_view_history(): editor = TextEditor() editor.write(\\"Hello, World!\\") editor.save_version() editor.write(\\" This is a version control system.\\") editor.save_version() editor.write(\\" Let's test reverting.\\") editor.save_version() history = editor.view_history() assert len(history) == 3 assert history[0][1] == \\"Hello, World!\\" assert history[1][1] == \\"Hello, World! This is a version control system.\\" assert history[2][1] == \\"Hello, World! This is a version control system. Let's test reverting.\\"","solution":"from datetime import datetime class TextEditor: def __init__(self): self.document = \\"\\" self.versions = [] def write(self, text: str) -> None: self.document += text def save_version(self) -> None: timestamp = datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") self.versions.append((timestamp, self.document)) def revert_to_version(self, version_index: int) -> None: _, self.document = self.versions[version_index] def view_history(self) -> list: return self.versions def get_content(self) -> str: return self.document"},{"question":"class MinStack: A stack data structure that supports retrieving the minimum element in O(1) time. def __init__(self): Initializes the stack object. pass def push(self, x: int) -> None: Pushes the element x onto the stack. pass def pop(self) -> None: Removes the element on top of the stack. pass def top(self) -> int: Gets the top element of the stack. pass def get_min(self) -> int: Retrieves the minimum element in the stack. pass # Example usage: # >>> min_stack = MinStack() # >>> min_stack.push(-2) # >>> min_stack.push(0) # >>> min_stack.push(-3) # >>> min_stack.get_min() # -3 # >>> min_stack.pop() # >>> min_stack.top() # 0 # >>> min_stack.get_min() # -2","solution":"class MinStack: def __init__(self): Initializes the stack object. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Pushes the element x onto the stack. self.stack.append(x) # If min_stack is empty or new element is smaller or equal to the top of min_stack if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on top of the stack. if self.stack: top_element = self.stack.pop() # If the popped element is the same as the top of min_stack, pop from min_stack if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Gets the top element of the stack. if self.stack: return self.stack[-1] def get_min(self) -> int: Retrieves the minimum element in the stack. if self.min_stack: return self.min_stack[-1]"},{"question":"import time from typing import Any, List from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize an LRUCache with a given capacity. ... def put(self, key: Any, value: Any, expiry_time: float) -> None: Add a new key-value pair to the cache with a custom expiry time. ... def get(self, key: Any) -> Any: Retrieve the value of the key if it exists and hasn't expired. If the key does not exist or has expired, return None. ... def remove(self, key: Any) -> None: Remove the key from the cache if it exists. ... def size(self) -> int: Return the current number of items in the cache. ... def clear_expired(self) -> None: Clear all expired items from the cache. ... def test_put_and_get(): cache = LRUCache(2) cache.put(1, 'A', 5.0) assert cache.get(1) == 'A' time.sleep(6) assert cache.get(1) is None def test_eviction(): cache = LRUCache(2) cache.put(1, 'A', 5.0) cache.put(2, 'B', 5.0) cache.put(3, 'C', 5.0) # Evicts key 1 assert cache.get(1) is None assert cache.get(2) == 'B' assert cache.get(3) == 'C' def test_expiry_and_eviction(): cache = LRUCache(2) cache.put(1, 'A', 1.0) time.sleep(2) cache.put(2, 'B', 5.0) cache.put(3, 'C', 5.0) # Evicts key 1 (already expired) assert cache.get(1) is None assert cache.get(2) == 'B' assert cache.get(3) == 'C' def test_remove(): cache = LRUCache(2) cache.put(1, 'A', 5.0) cache.remove(1) assert cache.get(1) is None def test_size(): cache = LRUCache(2) cache.put(1, 'A', 5.0) cache.put(2, 'B', 5.0) assert cache.size() == 2 cache.put(3, 'C', 5.0) # Evicts the oldest key assert cache.size() == 2 cache.remove(2) assert cache.size() == 1 def test_clear_expired(): cache = LRUCache(2) cache.put(1, 'A', 1.0) cache.put(2, 'B', 1.0) time.sleep(2) cache.clear_expired() assert cache.size() == 0","solution":"import time from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def _is_expired(self, expiry_time): return time.time() > expiry_time def _remove_expired_keys(self): keys_to_remove = [key for key, (value, expiry_time) in self.cache.items() if self._is_expired(expiry_time)] for key in keys_to_remove: del self.cache[key] def put(self, key, value, expiry_time): self._remove_expired_keys() if key in self.cache: del self.cache[key] elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = (value, time.time() + expiry_time) def get(self, key): self._remove_expired_keys() if key in self.cache: value, expiry_time = self.cache.pop(key) if not self._is_expired(expiry_time): self.cache[key] = (value, expiry_time) return value return None def remove(self, key): if key in self.cache: del self.cache[key] def size(self): self._remove_expired_keys() return len(self.cache) def clear_expired(self): self._remove_expired_keys()"},{"question":"def find_min_distance(points: list[tuple[int, int]]) -> float: Returns the shortest distance between any two points in the list. >>> find_min_distance([(0, 0), (1, 1), (4, 5), (1, 0)]) 1.0 >>> find_min_distance([(0, 0), (0, 0)]) 0.0 >>> find_min_distance([(1, 1), (4, 5), (1, 1), (2, 2)]) 0.0 >>> find_min_distance([(10000, 10000), (-10000, -10000), (5000, 5000)]) 7071.06781 >>> find_min_distance([(0, 0), (3, 4), (6, 8)]) 5.0 pass from math import sqrt def test_case_1(): points = [(0, 0), (1, 1), (4, 5), (1, 0)] assert find_min_distance(points) == 1.0 def test_case_2(): points = [(0, 0), (0, 0)] assert find_min_distance(points) == 0.0 def test_case_3(): points = [(1, 1), (4, 5), (1, 1), (2, 2)] assert find_min_distance(points) == 0.0 def test_case_4(): points = [(10000, 10000), (-10000, -10000), (5000, 5000)] assert find_min_distance(points) == 7071.06781 def test_case_5(): points = [(0, 0), (3, 4), (6, 8)] assert find_min_distance(points) == 5.0","solution":"import math def find_min_distance(points: list[tuple[int, int]]) -> float: def dist(p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def closest_pair_strip(strip, d): min_d = d strip.sort(key=lambda p: p[1]) # Sort strip according to y coordinate for i in range(len(strip)): for j in range(i + 1, len(strip)): if (strip[j][1] - strip[i][1]) < min_d: d = dist(strip[i], strip[j]) if d < min_d: min_d = d else: break return min_d def closest_pair_rec(points_sorted_x): if len(points_sorted_x) <= 3: min_d = float('inf') for i in range(len(points_sorted_x)): for j in range(i + 1, len(points_sorted_x)): min_d = min(min_d, dist(points_sorted_x[i], points_sorted_x[j])) return min_d mid = len(points_sorted_x) // 2 mid_point = points_sorted_x[mid] dl = closest_pair_rec(points_sorted_x[:mid]) dr = closest_pair_rec(points_sorted_x[mid:]) d = min(dl, dr) strip = [] for point in points_sorted_x: if abs(point[0] - mid_point[0]) < d: strip.append(point) return min(d, closest_pair_strip(strip, d)) points_sorted_x = sorted(points, key=lambda p: p[0]) return round(closest_pair_rec(points_sorted_x), 5)"},{"question":"def find_peak_element(nums: list[int]) -> int: Finds any peak element in the list, where a peak element is greater than or equal to its neighbors. Args: nums (list of int): The list of integers to search for a peak element. Returns: int: The index of any peak element found in the list. >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 3, 4, 5]) 4 >>> find_peak_element([5, 4, 3, 2, 1]) 0 >>> find_peak_element([2, 1]) 0 def test_find_peak_element(): assert find_peak_element([1, 2, 3, 1]) == 2 def test_find_peak_element_increasing(): assert find_peak_element([1, 2, 3, 4, 5]) == 4 def test_find_peak_element_decreasing(): assert find_peak_element([5, 4, 3, 2, 1]) == 0 def test_find_peak_element_two_elements(): assert find_peak_element([2, 1]) == 0 assert find_peak_element([1, 2]) == 1 def test_find_peak_element_single_element(): assert find_peak_element([1]) == 0 def test_find_peak_element_multiple_peaks(): result = find_peak_element([1, 3, 2, 5, 4]) assert result == 1 or result == 3 def test_find_peak_element_large_input(): large_input = list(range(1000000)) + [0] assert find_peak_element(large_input) == 999999 def test_find_peak_element_unordered(): assert find_peak_element([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0 # Run the tests test_find_peak_element() test_find_peak_element_increasing() test_find_peak_element_decreasing() test_find_peak_element_two_elements() test_find_peak_element_single_element() test_find_peak_element_multiple_peaks() test_find_peak_element_large_input() test_find_peak_element_unordered() print(\\"All tests passed.\\")","solution":"def find_peak_element(nums: list[int]) -> int: Finds any peak element in the list, where a peak element is greater than or equal to its neighbors. Args: nums (list of int): The list of integers to search for a peak element. Returns: int: The index of any peak element found in the list. def binary_search(left, right): if left == right: return left mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: return binary_search(left, mid) return binary_search(mid + 1, right) return binary_search(0, len(nums) - 1)"},{"question":"from typing import List def merge_sorted_lists(*lists: List[int]) -> List[int]: Merges multiple sorted lists into a single sorted list. Args: *lists: Variable number of sorted lists (each of type List[int]). Returns: A single sorted list containing all elements from the input lists. Examples: >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 3, 5], [2, 4, 6], [0, 7, 8]) [0, 1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_lists([], [], []) [] >>> merge_sorted_lists([1, 2, 3]) [1, 2, 3] >>> merge_sorted_lists([1, 1, 2], [2, 3, 3], [1, 3, 4]) [1, 1, 1, 2, 2, 3, 3, 3, 4] >>> merge_sorted_lists(*[[i] for i in range(10)]) list(range(10)) >>> merge_sorted_lists([1, 4, 5], [1, 3, 4], [2, 6]) [1, 1, 2, 3, 4, 4, 5, 6]","solution":"from heapq import heappop, heappush from typing import List def merge_sorted_lists(*lists: List[int]) -> List[int]: Merges multiple sorted lists into a single sorted list. Args: *lists: Variable number of sorted lists (each of type List[int]). Returns: A single sorted list containing all elements from the input lists. min_heap = [] result = [] # Push the first element of each list along with the index of the list and the index of the element for i, lst in enumerate(lists): if lst: heappush(min_heap, (lst[0], i, 0)) while min_heap: val, list_idx, element_idx = heappop(min_heap) result.append(val) # If there is a next element in the same list, push it to the heap if element_idx + 1 < len(lists[list_idx]): heappush(min_heap, (lists[list_idx][element_idx + 1], list_idx, element_idx + 1)) return result"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: Determine if a binary tree is height-balanced. A binary tree is height-balanced if the depth of the two subtrees of every node never differs by more than 1. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> is_balanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(3, TreeNode(4), TreeNode(4)), TreeNode(3)) >>> root.right = TreeNode(2) >>> is_balanced(root) False >>> is_balanced(None) True >>> root = TreeNode(1) >>> is_balanced(root) True >>> root = TreeNode(1, right=TreeNode(2, right=TreeNode(3))) >>> is_balanced(root) False >>> root = TreeNode(1, TreeNode(2, TreeNode(3), None), TreeNode(2, None, TreeNode(3))) >>> is_balanced(root) True","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root: Optional[TreeNode]) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) is_current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_current_balanced _, balanced = check_balance(root) return balanced"},{"question":"from typing import List def has_contiguous_subarray_sum(arr: List[int], target: int) -> bool: Returns True if there exists a contiguous subarray within arr that sums up to the target, otherwise returns False. >>> has_contiguous_subarray_sum([1, 2, 3, 4, 5], 9) True >>> has_contiguous_subarray_sum([1, 2, 3, 4, 5], 20) False >>> has_contiguous_subarray_sum([5], 5) True >>> has_contiguous_subarray_sum([5], 10) False >>> has_contiguous_subarray_sum([], 0) False >>> has_contiguous_subarray_sum([-1, 1, -1, 1], 0) True >>> has_contiguous_subarray_sum([3, 4, -7, 1, 2, -1, 4, 2], 5) True >>> has_contiguous_subarray_sum([1]*1000000, 1000000) True # Implement the function here","solution":"def has_contiguous_subarray_sum(arr, target): Returns True if there exists a contiguous subarray within arr that sums up to target, otherwise returns False. current_sum = 0 sum_dict = {0: 1} # Initialize with 0 sum to handle cases where subarray starts from index 0 for num in arr: current_sum += num if (current_sum - target) in sum_dict: return True if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return False"},{"question":"def longest_streak(events: list) -> int: Returns the length of the longest contiguous sub-array where all values are equal. >>> longest_streak([(1, 'a'), (2, 'a'), (3, 'b'), (4, 'b'), (5, 'b'), (6, 'a')]) 3 >>> longest_streak([(1, 'x'), (2, 'x'), (3, 'x'), (4, 'y'), (5, 'y'), (6, 'x')]) 3 >>> longest_streak([(1, 1), (2, 2), (3, 2), (4, 2), (5, 1), (6, 1), (7, 1)]) 3 >>> longest_streak([(1, 'a'), (2, 'b'), (3, 'a'), (4, 'a'), (5, 'a')]) 3 >>> longest_streak([(1, 'a')]) 1 >>> longest_streak([]) 0","solution":"def longest_streak(events): if not events: return 0 max_streak = 1 current_streak = 1 for i in range(1, len(events)): if events[i][1] == events[i - 1][1]: current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 1 return max(max_streak, current_streak)"},{"question":"def gcd_recursive(a: int, b: int) -> int: Compute the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm recursively. Parameters: - a: int, a non-negative integer - b: int, a non-negative integer Returns: - int, the greatest common divisor of \`a\` and \`b\` >>> gcd_recursive(48, 18) 6 >>> gcd_recursive(270, 192) 6 >>> gcd_recursive(0, 25) 25 >>> gcd_recursive(17, 13) 1","solution":"def gcd_recursive(a: int, b: int) -> int: Compute the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm recursively. Parameters: - a: int, a non-negative integer - b: int, a non-negative integer Returns: - int, the greatest common divisor of \`a\` and \`b\` if b == 0: return a return gcd_recursive(b, a % b)"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n grid from top-left to bottom-right. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: The number of unique paths. pass def test_unique_paths(): assert unique_paths(3, 7) == 28 assert unique_paths(3, 2) == 3 assert unique_paths(7, 3) == 28 assert unique_paths(3, 3) == 6 assert unique_paths(1, 1) == 1 assert unique_paths(1, 5) == 1 assert unique_paths(5, 1) == 1 assert unique_paths(2, 2) == 2 assert unique_paths(4, 4) == 20 def test_large_grids(): # Test with larger grid sizes assert unique_paths(10, 10) == 48620 assert unique_paths(15, 15) == 40116600","solution":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths in an m x n grid from top-left to bottom-right. :param m: Number of rows in the grid. :param n: Number of columns in the grid. :return: The number of unique paths. # Create a 2D list with dimensions m x n initialized to 0 dp = [[0] * n for _ in range(m)] # Fill the first row and first column with 1s since there's only one way to get to those cells for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the rest of the grid for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # The bottom-right corner will have the answer return dp[m-1][n-1]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_odd_even(head: ListNode) -> ListNode: Rearrange the linked list such that all odd-positioned nodes are placed before the even-positioned nodes. The relative order among odd and even-positioned nodes should remain the same. >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node4 = ListNode(4) >>> node5 = ListNode(5) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node5 >>> new_head = rearrange_odd_even(node1) >>> print_list(new_head) == [1, 3, 5, 2, 4] True >>> rearrange_odd_even(None) == None True >>> node1 = ListNode(1) >>> rearrange_odd_even(node1) == node1 True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> new_head = rearrange_odd_even(node1) >>> print_list(new_head) == [1, 2] True >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node3 = ListNode(3) >>> node1.next = node2 >>> node2.next = node3 >>> new_head = rearrange_odd_even(node1) >>> print_list(new_head) == [1, 3, 2] True >>> node1 = ListNode(2) >>> node2 = ListNode(4) >>> node3 = ListNode(6) >>> node4 = ListNode(8) >>> node5 = ListNode(10) >>> node6 = ListNode(12) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node5 >>> node5.next = node6 >>> new_head = rearrange_odd_even(node1) >>> print_list(new_head) == [2, 6, 10, 4, 8, 12] True pass def print_list(head: ListNode): result = [] while head: result.append(head.val) head = head.next return result","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rearrange_odd_even(head: ListNode) -> ListNode: if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head def print_list(head: ListNode): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"from datetime import datetime def generate_user_activity_report(user_activities, start_date, end_date): Generates a report of user activities within a specified date range. Parameters: - user_activities (list of tuples): A list of tuples where each tuple contains a user's ID (integer), and the date of activity (string in the format 'YYYY-MM-DD'). - start_date (string): The start date of the range, in the format 'YYYY-MM-DD'. - end_date (string): The end date of the range, in the format 'YYYY-MM-DD'. Returns: - dict: A dictionary where the keys are user IDs and the values are the number of activities each user had within the specified date range. Raises: - ValueError: If the end_date is before the start_date. >>> generate_user_activity_report([(1, '2023-01-15'), (2, '2023-02-20'), (1, '2023-02-25'), (3, '2023-03-10')], '2023-02-01', '2023-02-28') {1: 1, 2: 1} >>> generate_user_activity_report([(1, '2023-01-15'), (2, '2023-02-20'), (1, '2023-02-25'), (3, '2023-03-10')], '2023-01-01', '2023-03-31') {1: 2, 2: 1, 3: 1} >>> generate_user_activity_report([(1, '2023-01-15'), (2, '2023-02-20'), (1, '2023-02-25'), (3, '2023-03-10')], '2023-03-01', '2023-03-31') {3: 1} >>> generate_user_activity_report([(1, '2023-01-15'), (2, '2023-02-20'), (1, '2023-02-25'), (3, '2023-03-10')], '2023-04-01', '2023-04-30') {} >>> generate_user_activity_report([(1, '2023-01-15'), (2, '2023-02-20'), (1, '2023-02-25'), (3, '2023-03-10')], '2023-03-20', '2023-03-10') Traceback (most recent call last): ... ValueError: End date must not be before start date","solution":"from datetime import datetime def generate_user_activity_report(user_activities, start_date, end_date): Generates a report of user activities within a specified date range. Parameters: - user_activities (list of tuples): A list of tuples where each tuple contains a user's ID (integer), and the date of activity (string in the format 'YYYY-MM-DD'). - start_date (string): The start date of the range, in the format 'YYYY-MM-DD'. - end_date (string): The end date of the range, in the format 'YYYY-MM-DD'. Returns: - dict: A dictionary where the keys are user IDs and the values are the number of activities each user had within the specified date range. Raises: - ValueError: If the end_date is before the start_date. start_datetime = datetime.strptime(start_date, '%Y-%m-%d') end_datetime = datetime.strptime(end_date, '%Y-%m-%d') if end_datetime < start_datetime: raise ValueError(\\"End date must not be before start date\\") activity_report = {} for user_id, activity_date in user_activities: activity_datetime = datetime.strptime(activity_date, '%Y-%m-%d') if start_datetime <= activity_datetime <= end_datetime: if user_id not in activity_report: activity_report[user_id] = 0 activity_report[user_id] += 1 return activity_report"},{"question":"def dfs(graph, start): Performs a depth-first search (DFS) on a graph starting from the given node. Parameters: graph (dict): The graph represented as an adjacency list. start (str): The starting node for the DFS traversal. Returns: list: A list of nodes in the order they are first visited by the DFS algorithm. Example: >>> graph = {'A': ['B', 'C'], 'B': ['C', 'D'], 'C': ['D'], 'D': ['E'], 'E': []} >>> dfs(graph, 'A') ['A', 'B', 'C', 'D', 'E']","solution":"def dfs(graph, start): Performs a depth-first search (DFS) on a graph starting from the given node. Parameters: graph (dict): The graph represented as an adjacency list. start (str): The starting node for the DFS traversal. Returns: list: A list of nodes in the order they are first visited by the DFS algorithm. visited = set() visit_order = [] def dfs_helper(node): if node not in visited: visited.add(node) visit_order.append(node) for neighbor in graph[node]: dfs_helper(neighbor) dfs_helper(start) return visit_order"},{"question":"def left_rotate_array(arr: list, k: int) -> list: Perform left rotation on an array by k positions. >>> left_rotate_array([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> left_rotate_array([1, 2, 3, 4, 5], 7) [3, 4, 5, 1, 2] >>> left_rotate_array([], 3) [] >>> left_rotate_array([42], 1) [42] >>> left_rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> left_rotate_array([1, 2, 3, 4, 5], 100000) [1, 2, 3, 4, 5] >>> left_rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> left_rotate_array([1, 2, 3, 4, 5], 1) [2, 3, 4, 5, 1]","solution":"def left_rotate_array(arr: list, k: int) -> list: Returns the list \`arr\` after performing \`k\` left rotations. n = len(arr) if n == 0 or k == 0: return arr # Normalize k to be within the bounds of 0 and n-1 k = k % n return arr[k:] + arr[:k]"},{"question":"def find_missing_number(numbers: list[int]) -> int: Finds the missing number in the list of distinct integers ranging between 1 and n, inclusive. >>> find_missing_number([1, 2, 4]) 3 >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([2, 3, 4, 5, 6, 7, 8, 9, 10]) 1 >>> find_missing_number([1]) 2 >>> find_missing_number([]) 1 Raises: ValueError: If the input is not a list or tuple of integers or contains duplicates.","solution":"def find_missing_number(numbers: list[int]) -> int: Finds the missing number in the list of distinct integers ranging between 1 and n, inclusive. if not isinstance(numbers, (list, tuple)): raise ValueError(\\"numbers must be an iterable of integers\\") if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"numbers must be an iterable of integers\\") n = len(numbers) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return expected_sum - actual_sum"},{"question":"import os from datetime import datetime def search_files(directory: str, file_extension: str = None, min_size: int = None, max_size: int = None, start_date: str = None, end_date: str = None) -> list: Search for files in the specified directory based on file extension, size constraints, and modification date ranges. Parameters: directory (str): The directory path to search in. file_extension (str, optional): The file extension to filter files by. min_size (int, optional): The minimum file size in bytes. max_size (int, optional): The maximum file size in bytes. start_date (str, optional): The start of the modified date range in \\"YYYY-MM-DD\\" format. end_date (str, optional): The end of the modified date range in \\"YYYY-MM-DD\\" format. Returns: list: A list of filenames that match the specified criteria. Example: >>> search_files(\\"/path/to/search\\", file_extension=\\".txt\\", min_size=1024, max_size=1048576, start_date=\\"2023-01-01\\", end_date=\\"2023-12-31\\") ['file1.txt', 'file2.txt'] pass # Test cases import os import tempfile from datetime import datetime, timedelta def create_test_file(file_path, size, mtime=None): with open(file_path, 'wb') as f: f.write(b'0' * size) if mtime: os.utime(file_path, (mtime.timestamp(), mtime.timestamp())) def test_search_files_extension(): with tempfile.TemporaryDirectory() as tmp_dir: create_test_file(os.path.join(tmp_dir, 'test1.txt'), 100) create_test_file(os.path.join(tmp_dir, 'test2.log'), 100) files = search_files(tmp_dir, file_extension='.txt') assert len(files) == 1 assert files[0].endswith('test1.txt') def test_search_files_size(): with tempfile.TemporaryDirectory() as tmp_dir: create_test_file(os.path.join(tmp_dir, 'test1.txt'), 500) create_test_file(os.path.join(tmp_dir, 'test2.txt'), 1500) files = search_files(tmp_dir, min_size=1000) assert len(files) == 1 assert files[0].endswith('test2.txt') def test_search_files_date_range(): with tempfile.TemporaryDirectory() as tmp_dir: past_date = datetime.now() - timedelta(days=10) create_test_file(os.path.join(tmp_dir, 'test1.txt'), 100, mtime=past_date) create_test_file(os.path.join(tmp_dir, 'test2.txt'), 100) start_date = (datetime.now() - timedelta(days=5)).strftime('%Y-%m-%d') files = search_files(tmp_dir, start_date=start_date) assert len(files) == 1 assert files[0].endswith('test2.txt') def test_search_files_invalid_directory(): files = search_files('/invalid/path') assert len(files) == 0 def test_search_files_invalid_date_format(): with tempfile.TemporaryDirectory() as tmp_dir: create_test_file(os.path.join(tmp_dir, 'test1.txt'), 100) files = search_files(tmp_dir, start_date='invalid-date') assert len(files) == 0","solution":"import os from datetime import datetime import logging logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s:%(message)s') def search_files(directory: str, file_extension: str = None, min_size: int = None, max_size: int = None, start_date: str = None, end_date: str = None) -> list: Search for files in the specified directory based on file extension, size constraints, and modification date ranges. Parameters: directory (str): The directory path to search in. file_extension (str, optional): The file extension to filter files by. min_size (int, optional): The minimum file size in bytes. max_size (int, optional): The maximum file size in bytes. start_date (str, optional): The start of the modified date range in \\"YYYY-MM-DD\\" format. end_date (str, optional): The end of the modified date range in \\"YYYY-MM-DD\\" format. Returns: list: A list of filenames that match the specified criteria. if not os.path.isdir(directory): logging.error(f\\"The directory {directory} does not exist or is inaccessible.\\") return [] matched_files = [] start_dt = None end_dt = None if start_date: try: start_dt = datetime.strptime(start_date, \\"%Y-%m-%d\\") except ValueError: logging.error(f\\"Invalid start date format: {start_date}. Use 'YYYY-MM-DD' format.\\") return [] if end_date: try: end_dt = datetime.strptime(end_date, \\"%Y-%m-%d\\") except ValueError: logging.error(f\\"Invalid end date format: {end_date}. Use 'YYYY-MM-DD' format.\\") return [] for root, dirs, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) file_stat = os.stat(file_path) file_size = file_stat.st_size file_mtime = datetime.fromtimestamp(file_stat.st_mtime) if file_extension and not file.endswith(file_extension): continue if min_size and file_size < min_size: continue if max_size and file_size > max_size: continue if start_dt and file_mtime < start_dt: continue if end_dt and file_mtime > end_dt: continue matched_files.append(file_path) return matched_files"},{"question":"# Function: calculate_bus_fare def calculate_bus_fare(bus_type: str, distance: float, peak_hour: bool) -> float: Calculate the total bus fare based on the type of bus, distance traveled, and whether it is peak hour. Parameters: bus_type (str): A string representing the type of bus ('regular', 'express', 'night'). distance (float): A float representing the distance traveled in kilometers. peak_hour (bool): A boolean indicating whether it is peak hour (True) or not (False). Returns: float: The calculated total fare for the journey. # Unit Test import pytest from solution import calculate_bus_fare def test_regular_bus_non_peak(): assert calculate_bus_fare('regular', 5.0, False) == 9.5 def test_regular_bus_peak(): assert calculate_bus_fare('regular', 5.0, True) == 11.4 def test_express_bus_non_peak(): assert calculate_bus_fare('express', 10.0, False) == 23.0 def test_express_bus_peak(): assert calculate_bus_fare('express', 10.0, True) == 27.6 def test_night_bus_non_peak(): assert calculate_bus_fare('night', 3.0, False) == 7.75 def test_night_bus_peak(): assert calculate_bus_fare('night', 3.0, True) == 9.3 def test_zero_distance(): assert calculate_bus_fare('regular', 0, False) == 2.0 assert calculate_bus_fare('express', 0, False) == 3.0 assert calculate_bus_fare('night', 0, False) == 2.5 def test_negative_distance(): with pytest.raises(ValueError): calculate_bus_fare('regular', -1, False) def test_invalid_bus_type(): with pytest.raises(ValueError): calculate_bus_fare('luxury', 1, False) # Solution def calculate_bus_fare(bus_type: str, distance: float, peak_hour: bool) -> float: base_fares = { 'regular': 2.00, 'express': 3.00, 'night': 2.50, } fare_per_km = { 'regular': 1.50, 'express': 2.00, 'night': 1.75, } if bus_type not in base_fares or distance < 0: raise ValueError('Invalid bus type or distance') base_fare = base_fares[bus_type] per_km_fare = fare_per_km[bus_type] * distance total_fare = base_fare + per_km_fare if peak_hour: total_fare *= 1.2 return round(total_fare, 2)","solution":"def calculate_bus_fare(bus_type: str, distance: float, peak_hour: bool) -> float: base_fares = { 'regular': 2.00, 'express': 3.00, 'night': 2.50, } fare_per_km = { 'regular': 1.50, 'express': 2.00, 'night': 1.75, } if bus_type not in base_fares or distance < 0: raise ValueError('Invalid bus type or distance') base_fare = base_fares[bus_type] per_km_fare = fare_per_km[bus_type] * distance total_fare = base_fare + per_km_fare if peak_hour: total_fare *= 1.2 return round(total_fare, 2)"},{"question":"**Write a function named \`add_task\` that accepts a dictionary representing a to-do list and a string representing a task, and adds the task to the dictionary with a value of \`False\`.** from typing import Dict def add_task(task_list: Dict[str, bool], task: str) -> None: Adds a new task to the task_list with a status of False (incomplete). task_list[task] = False **Write a function named \`complete_task\` that accepts a dictionary representing a to-do list and a string representing a task, and marks the task as complete in the dictionary if it exists.** from typing import Dict def complete_task(task_list: Dict[str, bool], task: str) -> None: Marks an existing task as complete (True). if task in task_list: task_list[task] = True **Write a function named \`list_incomplete_tasks\` that accepts a dictionary representing a to-do list and returns a list of incomplete tasks.** from typing import Dict, List def list_incomplete_tasks(task_list: Dict[str, bool]) -> List[str]: Returns a list of incomplete tasks. return [task for task, completed in task_list.items() if not completed] **Write a function named \`list_completed_tasks\` that accepts a dictionary representing a to-do list and returns a list of completed tasks.** from typing import Dict, List def list_completed_tasks(task_list: Dict[str, bool]) -> List[str]: Returns a list of completed tasks. return [task for task, completed in task_list.items() if completed] **Write a function named \`main\` that demonstrates the functionality of the to-do list system via user input.** def main(): task_list = {} while True: print(\\"nTo-Do List Menu:\\") print(\\"1. Add Task\\") print(\\"2. Complete Task\\") print(\\"3. List Incomplete Tasks\\") print(\\"4. List Completed Tasks\\") print(\\"5. Exit\\") choice = input(\\"Enter your choice: \\") if choice == '1': task = input(\\"Enter the task description: \\") add_task(task_list, task) elif choice == '2': task = input(\\"Enter the task to mark as completed: \\") complete_task(task_list, task) elif choice == '3': incomplete_tasks = list_incomplete_tasks(task_list) print(\\"Incomplete Tasks:\\") for task in incomplete_tasks: print(f\\"- {task}\\") elif choice == '4': completed_tasks = list_completed_tasks(task_list) print(\\"Completed Tasks:\\") for task in completed_tasks: print(f\\"- {task}\\") elif choice == '5': break else: print(\\"Invalid choice. Please try again.\\") if __name__ == \\"__main__\\": main() **Test cases to validate the solution** from solution import add_task, complete_task, list_incomplete_tasks, list_completed_tasks def test_add_task(): tasks = {} add_task(tasks, \\"Task 1\\") assert tasks == {\\"Task 1\\": False} add_task(tasks, \\"Task 2\\") assert tasks == {\\"Task 1\\": False, \\"Task 2\\": False} def test_complete_task(): tasks = {\\"Task 1\\": False, \\"Task 2\\": False} complete_task(tasks, \\"Task 1\\") assert tasks == {\\"Task 1\\": True, \\"Task 2\\": False} complete_task(tasks, \\"Task 3\\") # Task 3 does not exist, should do nothing assert tasks == {\\"Task 1\\": True, \\"Task 2\\": False} def test_list_incomplete_tasks(): tasks = {\\"Task 1\\": False, \\"Task 2\\": True, \\"Task 3\\": False} result = list_incomplete_tasks(tasks) assert result == [\\"Task 1\\", \\"Task 3\\"] def test_list_completed_tasks(): tasks = {\\"Task 1\\": True, \\"Task 2\\": False, \\"Task 3\\": True} result = list_completed_tasks(tasks) assert result == [\\"Task 1\\", \\"Task 3\\"]","solution":"from typing import Dict, List def add_task(task_list: Dict[str, bool], task: str) -> None: Adds a new task to the task_list with a status of False (incomplete). task_list[task] = False def complete_task(task_list: Dict[str, bool], task: str) -> None: Marks an existing task as complete (True). if task in task_list: task_list[task] = True def list_incomplete_tasks(task_list: Dict[str, bool]) -> List[str]: Returns a list of incomplete tasks. return [task for task, completed in task_list.items() if not completed] def list_completed_tasks(task_list: Dict[str, bool]) -> List[str]: Returns a list of completed tasks. return [task for task, completed in task_list.items() if completed] def main(): task_list = {} while True: print(\\"nTo-Do List Menu:\\") print(\\"1. Add Task\\") print(\\"2. Complete Task\\") print(\\"3. List Incomplete Tasks\\") print(\\"4. List Completed Tasks\\") print(\\"5. Exit\\") choice = input(\\"Enter your choice: \\") if choice == '1': task = input(\\"Enter the task description: \\") add_task(task_list, task) elif choice == '2': task = input(\\"Enter the task to mark as completed: \\") complete_task(task_list, task) elif choice == '3': incomplete_tasks = list_incomplete_tasks(task_list) print(\\"Incomplete Tasks:\\") for task in incomplete_tasks: print(f\\"- {task}\\") elif choice == '4': completed_tasks = list_completed_tasks(task_list) print(\\"Completed Tasks:\\") for task in completed_tasks: print(f\\"- {task}\\") elif choice == '5': break else: print(\\"Invalid choice. Please try again.\\") if __name__ == \\"__main__\\": main()"},{"question":"import numpy as np def k_means_clustering(data, k, max_iters): Perform k-means clustering on the given dataset. Parameters: data (numpy.ndarray): A 2D numpy array of shape (n_samples, n_features) representing the dataset. k (int): An integer representing the number of clusters. max_iters (int): An integer representing the maximum number of iterations for the algorithm. Returns: tuple: A tuple containing two elements: - centroids (numpy.ndarray): A 2D numpy array of shape (k, n_features) representing the final cluster centroids. - labels (numpy.ndarray): A 1D numpy array of length n_samples containing the index of the cluster each data point belongs to. # Your code here pass","solution":"import numpy as np def k_means_clustering(data, k, max_iters): Perform k-means clustering on the given dataset. Parameters: data (numpy.ndarray): A 2D numpy array of shape (n_samples, n_features) representing the dataset. k (int): An integer representing the number of clusters. max_iters (int): An integer representing the maximum number of iterations for the algorithm. Returns: tuple: A tuple containing two elements: - centroids (numpy.ndarray): A 2D numpy array of shape (k, n_features) representing the final cluster centroids. - labels (numpy.ndarray): A 1D numpy array of length n_samples containing the index of the cluster each data point belongs to. n_samples, n_features = data.shape # Step 1: Initialize centroids by randomly selecting k data points np.random.seed(42) # For reproducibility random_indices = np.random.choice(n_samples, k, replace=False) centroids = data[random_indices] for iteration in range(max_iters): # Step 2: Assign each data point to the nearest centroid distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) labels = np.argmin(distances, axis=1) # Step 3: Calculate new centroids as the mean of assigned data points new_centroids = np.array([data[labels == i].mean(axis=0) for i in range(k)]) # Step 4: Check for convergence (if centroids do not change) if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, labels"}]`),C={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:E,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},F={class:"card-container"},S={key:0,class:"empty-state"},I=["disabled"],j={key:0},D={key:1};function P(i,e,l,f,n,a){const m=h("PoemCard");return r(),s("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>n.searchQuery=o),placeholder:"Search..."},null,512),[[y,n.searchQuery]]),n.searchQuery?(r(),s("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>n.searchQuery="")}," ✕ ")):d("",!0)]),t("div",F,[(r(!0),s(b,null,v(a.displayedPoems,(o,p)=>(r(),x(m,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),s("div",S,' No results found for "'+_(n.searchQuery)+'". ',1)):d("",!0)]),a.hasMorePoems?(r(),s("button",{key:0,class:"load-more-button",disabled:n.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[n.isLoading?(r(),s("span",D,"Loading...")):(r(),s("span",j,"See more"))],8,I)):d("",!0)])}const B=c(C,[["render",P],["__scopeId","data-v-0226b158"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/29.md","filePath":"library/29.md"}'),V={name:"library/29.md"},H=Object.assign(V,{setup(i){return(e,l)=>(r(),s("div",null,[w(B)]))}});export{O as __pageData,H as default};
