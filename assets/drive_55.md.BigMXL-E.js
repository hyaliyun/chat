import{_ as p,o as n,c as i,a as t,m as d,t as h,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function O(r,e,l,c,a,s){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(h(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(h(l.poem.solution),1)])])])}const A=p(k,[["render",O],["__scopeId","data-v-893927e6"]]),N=JSON.parse('[{"question":"# Priority Queue Implementation and Optimization You are tasked to implement an efficient priority queue using different underlying data structures. The priority queue should support the following operations: * Insert an item with a given priority. * Remove and return the item with the smallest (or highest) priority. We\'ll start by implementing the priority queue using a simple linear array approach. Then, we\'ll move to an optimized version using a binary heap. Part 1: Linear Array-Based Priority Queue Implement a priority queue with the following methods: - `push(item, priority)`: Insert an item with the given priority. - `pop()`: Remove and return the item with the lowest priority. - `size()`: Return the number of items in the queue. Constraints: - The `priority` can be any integer (positive, negative, or zero). - The priority queue can have up to 10^4 items. Input and Output Formats - Input to `push`: An item (any data type) and an `priority` (integer). - Output of `pop`: The item with the lowest priority, or `None` if the queue is empty. - Output of `size`: Integer representing the number of items in the queue. ```python import itertools class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def size(self): return len(self.priority_queue_list) def push(self, item, priority=None): priority = item if priority is None else priority node = PriorityQueueNode(item, priority) for index, current in enumerate(self.priority_queue_list): if current.priority < node.priority: self.priority_queue_list.insert(index, node) return self.priority_queue_list.append(node) def pop(self): if self.size() == 0: return None return self.priority_queue_list.pop().data ``` # Example Usage: ```python pq = PriorityQueue() pq.push(\'task1\', 3) pq.push(\'task2\', 2) print(pq.pop()) # Outputs: \'task2\' print(pq.size()) # Outputs: 1 ``` Part 2: Heap-Based Priority Queue (Advanced) To improve the efficiency of the priority queue, implement an optimized version using a binary heap. You may use Python\'s `heapq` module for this. Implement the following methods: - `push_heap(item, priority)`: Insert an item with the given priority using a heap. - `pop_heap()`: Remove and return the item with the lowest priority using a heap. - `size_heap()`: Return the number of items in the heap-based queue. Additional Constraints - Ensure the heap-based methods maintain the same previous constraints. - Expected time complexity for `push_heap` and `pop_heap` should be O(log n). **Note for Students**: Please provide both versions of your implementation. Compare and discuss the differences in performance observed during execution.","solution":"class PriorityQueue: def __init__(self): self.queue = [] def push(self, item, priority): self.queue.append((priority, item)) self.queue.sort(key=lambda x: x[0]) def pop(self): if self.size() == 0: return None return self.queue.pop(0)[1] def size(self): return len(self.queue) import heapq class HeapPriorityQueue: def __init__(self): self.heap = [] def push_heap(self, item, priority): heapq.heappush(self.heap, (priority, item)) def pop_heap(self): if self.size_heap() == 0: return None return heapq.heappop(self.heap)[1] def size_heap(self): return len(self.heap)"},{"question":"# Question: Implement a Function to Find the Kth Largest Element Using Bitonic Sort You are given an array of integers whose length is guaranteed to be a power of two and a positive integer `k`. Your task is to find the `k`th largest element in the array using the bitonic sort algorithm. # Function Signature ```python def kth_largest_element(arr: List[int], k: int) -> int: pass ``` # Input * `arr` (List[int]): An array of integers with a length that is a power of two. * `k` (int): A positive integer representing the position (1-based) of the largest element to find in the sorted order. # Output * `int`: The `k`th largest element in the array. # Constraints * 1 ≤ len(arr) ≤ 2^10 * 1 ≤ arr[i] ≤ 10^6 * 1 ≤ k ≤ len(arr) # Example ```python arr = [3, 2, 1, 5, 6, 4] k = 2 # Result should be 5 because the sorted array is [1, 2, 3, 4, 5, 6] and the 2nd largest element is 5 assert kth_largest_element(arr, k) == 5 ``` # Requirements 1. Implement the `kth_largest_element` function. 2. The solution must use the `bitonic_sort` method as a core sorting mechanism. 3. Handle any edge cases, such as small arrays or out of bounds `k` values appropriately. # Note You can assume that the bitonic_sort function provided above is available and you do not need to implement this function. Focus on implementing the `kth_largest_element` function and use the `bitonic_sort` function within your implementation wherever necessary.","solution":"from typing import List def bitonic_sort(arr: List[int], up: bool) -> List[int]: Helper function to sort an array using the bitonic sort. If `up` is True, the array is sorted in ascending order. If `up` is False, the array is sorted in descending order. def compare_and_swap(arr: List[int], i: int, j: int, direction: bool): if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) bitonic_sort_recursive(arr, low + k, k, False) bitonic_merge(arr, low, cnt, direction) n = len(arr) bitonic_sort_recursive(arr, 0, n, up) return arr def kth_largest_element(arr: List[int], k: int) -> int: n = len(arr) if n == 0 or k < 1 or k > n: raise ValueError(\\"Invalid k value or empty array\\") sorted_arr = bitonic_sort(arr[:], up=False) return sorted_arr[k - 1]"},{"question":"# Scenario You are working on a powerful data analysis system that can handle various types of queries over a large set of numerical data. You need to implement a data structure that allows efficient range queries, such as calculating sums, finding the minimum or maximum values, and custom aggregations over defined ranges. # Task Implement and utilize a segment tree data structure for efficient range queries on an array. You will write a class that builds a segment tree from a given array and allows efficient range queries using a user-defined function. # Requirements 1. **Input**: The constructor will accept an array of integers and a function for segment merging. 2. **Output**: The `query` method will take two integers (L and R) representing the range [L, R] and return the result of the function applied over this range. # Constraints - The array will have at least one element and at most 10^5 elements. - The function provided will be a binary function that accepts two arguments of the same type as the array\'s elements and returns a value of that type. - The range query will always be within the bounds of the array. # Performance Requirements - The segment tree should be able to handle 10^5 elements, supporting O(log N) range queries. # Class Definition The class should be structured as follows: ```python class SegmentTree: def __init__(self, arr, function): # Implement the constructor to initialize the segment tree. def make_tree(self, i, l, r): # Build the tree by recursively dividing the array segments. def __query(self, i, L, R, l, r): # Perform a range query from L to R. def query(self, L, R): # Public method to start the query process. ``` # Example ```python # Initializing a Segment Tree with an array and a max function arr = [2, 4, 5, 3, 4] max_fn = max mytree = SegmentTree(arr, max_fn) # Making queries assert mytree.query(2, 4) == 5 assert mytree.query(0, 3) == 5 # Initializing a Segment Tree with an array and a sum function arr = [4, 5, 2, 3, 4, 43, 3] sum_fn = sum mytree = SegmentTree(arr, sum_fn) # Making queries assert mytree.query(1, 3) == 10 assert mytree.query(1, 6) == 60 ``` Write the implementation for the Segment Tree class based on the provided structure and requirements.","solution":"class SegmentTree: def __init__(self, arr, function): Initialize the segment tree with the given array and function. self.n = len(arr) self.function = function self.tree = [None] * (4 * self.n) self.make_tree(arr, 0, 0, self.n - 1) def make_tree(self, arr, i, l, r): Recursively build the segment tree. if l == r: self.tree[i] = arr[l] else: mid = (l + r) // 2 left_child = 2 * i + 1 right_child = 2 * i + 2 self.make_tree(arr, left_child, l, mid) self.make_tree(arr, right_child, mid + 1, r) self.tree[i] = self.function(self.tree[left_child], self.tree[right_child]) def __query(self, i, L, R, l, r): Perform a range query from L to R within the segment [l, r]. if L > r or R < l: return None # return value outside of the range if L <= l and R >= r: return self.tree[i] mid = (l + r) // 2 left_result = self.__query(2 * i + 1, L, R, l, mid) right_result = self.__query(2 * i + 2, L, R, mid + 1, r) if left_result is None: return right_result if right_result is None: return left_result return self.function(left_result, right_result) def query(self, L, R): Public method to start the query process. return self.__query(0, L, R, 0, self.n - 1)"},{"question":"# Radix Sort Implementation: Large Dataset Sorting # Background You are tasked with implementing a highly efficient sorting algorithm to handle a vast dataset comprising non-negative integers. Your solution must leverage the Radix Sort algorithm to sort these integers. This sorting method prioritizes digit-wise sorting, offering exceptional performance for specific datasets. # Task Write a function `enhanced_radix_sort` that sorts a list of non-negative integers using the Radix Sort algorithm. The function should demonstrate an optimized implementation that handles various edge cases effectively. # Function Signature ```python def enhanced_radix_sort(arr: list[int]) -> list[int]: pass ``` # Input * `arr` (list of int): A list of non-negative integers that you need to sort. * Constraints: * `0 <= len(arr) <= 1_000_000` * `0 <= arr[i] <= 10^9` # Output * Return a list of integers sorted in non-decreasing order. # Constraints * Your implementation should not use built-in sort functions. * Optimize for large datasets with several edge cases (empty arrays, arrays with one element, etc.) * Handle digit extraction robustly to avoid mis-sorts. * Ensure efficient usage of memory. # Example ```python print(enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66])) # Output: [2, 24, 45, 66, 75, 90, 170, 802] print(enhanced_radix_sort([1, 4, 1, 2, 7, 5, 2])) # Output: [1, 1, 2, 2, 4, 5, 7] print(enhanced_radix_sort([])) # Output: [] print(enhanced_radix_sort([10**9, 10**9, 10**9])) # Output: [1000000000, 1000000000, 1000000000] ``` # Notes * The Radix Sort algorithm should illustrate sorting stability. * Consider edge cases like input arrays with large integers and repeated elements.","solution":"def enhanced_radix_sort(arr: list[int]) -> list[int]: This function sorts a list of non-negative integers using Radix Sort. if not arr: return arr # Find the maximum number in the array to determine the number of digits max_num = max(arr) exp = 1 # Start with the least significant digit while max_num // exp > 0: arr = counting_sort(arr, exp) exp *= 10 return arr def counting_sort(arr, exp): A utility function to perform counting sort on arr[] according to the digit represented by exp. n = len(arr) output = [0] * n # Output array that will have sorted numbers count = [0] * 10 # Initialize count array as 0 for digits 0 to 9 # Store count of occurrences of digits for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] now contains the actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[], so that arr[] now contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] return arr"},{"question":"# **Topological Sort Challenge** **Problem Statement**: Given a directed acyclic graph (DAG), write a function `topological_sort` that performs a topological sort of the graph. The graph is represented as an adjacency list, where the keys are node labels, and values are lists of neighbors. Your function should raise an error if the input graph contains any cycles. **Function Signature**: ```python def topological_sort(graph: Dict[int, List[int]]) -> List[int]: pass ``` **Input**: - A dictionary `graph` where `graph[node]` is the list of neighbors of `node`. **Output**: - A list of nodes in topologically sorted order. **Constraints**: - Nodes are represented by unique integer IDs. - The graph contains no cycles (is a DAG). - The graph may be disconnected. **Performance Requirements**: - Your implementation should run in O(V + E) time complexity, where V is the number of vertices, and E is the number of edges. - The space complexity should not exceed O(V). **Example**: ```python graph = { 0: [1, 2], 1: [3], 2: [3], 3: [4], 4: [] } print(topological_sort(graph)) # Output: [0, 1, 2, 3, 4] or any valid topological ordering ``` **Note**: - Consider all possible topologically sorted orders are valid as long as they respect the relative order constraints defined by the directed edges.","solution":"def topological_sort(graph): Performs topological sort on a directed acyclic graph (DAG). Parameters: graph (dict): A dictionary representing the adjacency list of the graph. Returns: list: A list of nodes in topologically sorted order. from collections import deque, defaultdict # Calculate in-degrees of all nodes in_degree = defaultdict(int) for node in graph: in_degree[node] # ensure all nodes are considered even if they don\'t have incoming edges for neighbor in graph[node]: in_degree[neighbor] += 1 # Find all nodes with 0 in-degree queue = deque([node for node in in_degree if in_degree[node] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we processed all the nodes (in case of cycle, some nodes would be left out) if len(topological_order) == len(in_degree): return topological_order else: raise ValueError(\\"The graph contains a cycle and cannot be topologically sorted\\")"},{"question":"# Flatten Nested Arrays You are given an array that may contain other nested arrays. Your task is to write a function to flatten this array into a single resultant array containing all the original elements in their original order. Function Signature ```python def flatten_nested_array(nested_array: list) -> list: pass ``` # Input * `nested_array` (List): A potentially multi-dimensional array consisting of integers, nested arrays, or strings. # Output * Returns a single-dimensional list containing all elements in the nested structure while preserving the original order. # Performance Constraints * Your implementation should handle arrays with at most depth 1000. * The total number of elements should not exceed 10^6. # Example ```python print(flatten_nested_array([1, [2, 3, [4, 5]], 6])) # [1, 2, 3, 4, 5, 6] print(flatten_nested_array([\'a\', [\'b\', [\'c\', \'d\']], \'e\'])) # [\'a\', \'b\', \'c\', \'d\', \'e\'] print(flatten_nested_array([1, [], [2, [3, [], [4]]], 5])) # [1, 2, 3, 4, 5] print(flatten_nested_array([])) # [] ``` # Edge Cases * An empty array should return an empty array. * Arrays containing other arrays with no elements should be flattened properly without errors. * Arrays containing different data types should be managed correctly. Please implement your solution using a purely recursive approach or using a generator-based iterative approach to manage memory effectively. Ensure your function handles edge cases well and performs efficiently.","solution":"def flatten_nested_array(nested_array: list) -> list: Flattens a potentially nested array into a single list containing all the original elements in their original order. def flatten_helper(arr): for element in arr: if isinstance(element, list): yield from flatten_helper(element) else: yield element return list(flatten_helper(nested_array))"},{"question":"You are provided with the implementation of the Rabin-Karp algorithm for substring searching within a main string. Your task is to extend and optimize this algorithm to handle multiple patterns efficiently and reduce the likelihood of hash collisions. # Objective Implement a function `multi_pattern_search(patterns, text)` that takes in a list of patterns and a main text and returns a dictionary where each pattern maps to a list of starting indices in the text where that pattern is found. # Input: * `patterns`: A list of strings, where each string represents a pattern to search within the main text. Assume each pattern in the list is non-empty and the list has at least one pattern. * `text`: A string in which you need to search for the patterns. # Output: * A dictionary where each key is a pattern from the input list and the corresponding value is a list of integers representing the starting indices in the text where the pattern is found. # Constraints: * (1 leq text{len(patterns)} leq 10^3) * (1 leq text{sum of lengths of all patterns} leq 10^4) * (1 leq text{len(text)} leq 10^5) # Performance Requirements: Ensure that your implementation handles the constraint limits efficiently and minimizes hash collisions. # Example: ```python patterns = [\\"abc\\", \\"bc\\", \\"a\\"] text = \\"abcabcabc\\" multi_pattern_search(patterns, text) ``` Output: ```python { \\"abc\\": [0, 3, 6], \\"bc\\": [1, 4, 7], \\"a\\": [0, 3, 6] } ``` # Hint: Consider using a rolling hash mechanism with a higher base or a prime modulus to reduce hash collisions. For multiple patterns, you may use a dictionary to store their hash values for quick lookup.","solution":"def rabin_karp_search(pattern, text, base=256, mod=101): Searches for occurrences of a pattern in the text using Rabin-Karp algorithm. Returns a list of starting indices where the pattern is found. m, n = len(pattern), len(text) if m > n: return [] # Compute the hash value of the pattern and first window of the text pattern_hash = 0 current_hash = 0 for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % mod current_hash = (base * current_hash + ord(text[i])) % mod # Precompute (base^(m-1)) % mod for use in removing the leading digit base_m = pow(base, m - 1, mod) result = [] for i in range(n - m + 1): # Check the hash values of the current window and the pattern if pattern_hash == current_hash: if text[i:i+m] == pattern: result.append(i) # Compute the hash value of the next window of the text if i < n - m: current_hash = (current_hash - ord(text[i]) * base_m) % mod current_hash = (current_hash * base + ord(text[i + m])) % mod current_hash = (current_hash + mod) % mod # Ensure non-negative return result def multi_pattern_search(patterns, text): Searches for multiple patterns in the text using Rabin-Karp algorithm. Returns a dictionary mapping each pattern to a list of its start indices in the text. result = {} base = 256 mod = 101 # Using a prime modulus smaller than the typical base to reduce collision # For each pattern, find all its occurrences in the text using Rabin-Karp algorithm for pattern in patterns: result[pattern] = rabin_karp_search(pattern, text, base, mod) return result"},{"question":"# Bracket Sequence Validation Context In several programming and text-processing applications, correctly pairing and ordering of brackets is essential. This ensures the logical structure of expressions, code blocks, and nested constructs. Problem Statement Write a function `is_valid(s: str) -> bool` that validates whether a given string containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is a valid bracket sequence. Input and Output * **Input**: * A string `s` containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. * **Output**: * A boolean value `True` if the input string is valid, otherwise `False`. Constraints * The input string `s` can be of length from 0 to 10^4. * The input will only contain the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. Examples and Explanations * Example 1: * `s = \\"()\\"` -> Output: `True` * The sequence `()` is a valid bracket sequence. * Example 2: * `s = \\"()[]{}\\"` -> Output: `True` * The sequences `()` are matched correctly. * Example 3: * `s = \\"(]\\"` -> Output: `False` * The closing bracket `]` doesn\'t match the opening bracket `(`. * Example 4: * `s = \\"([)]\\"` -> Output: `False` * The sequence `([)]` has crossing brackets and thus is invalid. * Example 5: * `s = \\"{[]}\\"` -> Output: `True` * The nested brackets `{[]}` are matched correctly. Implementation Notes * Use a stack data structure to help with matching corresponding opening and closing brackets. * Iterate through `s`, pushing opening brackets onto the stack. * For closing brackets, check against the top of the stack for a match; if matched, pop the top of the stack. * Return `True` if the stack is empty at the end of processing all characters; otherwise, return `False`. **Function Signature** ```python def is_valid(s: str) -> bool: # Your code here ```","solution":"def is_valid(s: str) -> bool: Validates whether the input string `s` containing only the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is a valid bracket sequence. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Scenario You are tasked with developing a software that dynamically keeps track of the top \\"N\\" highest scores in a game. In this scenario, players\' scores are being recorded, and the top \\"N\\" highest scores need to be efficiently maintained in sorted order at all times. # Task Implement a class `HighScoreTracker` that extends the functionality of the given `OrderedStack`, offering an additional method to maintain the top \\"N\\" high scores only: - `add_score(score: int) -> None`: Adds a new score to the top N high scores, ensuring that no more than N scores are stored at any time. - If the stack contains more than N scores, remove the lowest score to maintain only the top N scores. # Expected Input/Output 1. **Initialization**: `tracker = HighScoreTracker(N)` where `N` is the maximum number of scores to maintain. 2. **add_score**: Adding a score via `tracker.add_score(score)` should update the internal state to contain the highest `N` scores. 3. **Retrieving Scores**: You should implement a method `get_high_scores()` to return the current list of scores (in sorted order, descending). # Constraints - 1 <= N <= 10^4 - 1 <= score <= 10^9 - Ensure that all operations are as efficient as possible, ideally matching the performance characteristics of the provided `OrderedStack`. # Example ```python tracker = HighScoreTracker(3) tracker.add_score(50) tracker.add_score(30) tracker.add_score(40) tracker.add_score(60) print(tracker.get_high_scores()) # Output: [60, 50, 40] tracker.add_score(70) print(tracker.get_high_scores()) # Output: [70, 60, 50] tracker.add_score(45) print(tracker.get_high_scores()) # Output: [70, 60, 50] ``` # Implementation Notes - You may reuse and extend the provided `OrderedStack` class. - Ensure that `get_high_scores()` method returns the high scores in descending order.","solution":"import bisect class HighScoreTracker: def __init__(self, N): self.N = N self.scores = [] def add_score(self, score: int) -> None: # If we have less than N scores, just insert the new score maintaining the order. if len(self.scores) < self.N: bisect.insort(self.scores, score) else: # If new score is higher than the smallest score in the current top N, add it. if score > self.scores[0]: bisect.insort(self.scores, score) # Maintain the size to N by popping the smallest element. self.scores.pop(0) def get_high_scores(self): return sorted(self.scores, reverse=True)"},{"question":"# Question: Count the Number of Digits Scenario You are developing a feature for financial software that validates input numbers for formatting consistency. One important check is to ensure that all monetary amounts are expressed with no more than six digits, disregarding negative signs. For this, you need to write a function that quickly counts the number of digits in an integer. Task Write a function `count_digits(n: int) -> int` that calculates the number of digits in the given integer `n`, ignoring any leading negatives. Input * A single integer `n` where -10^9 <= n <= 10^9. Output * An integer representing the number of digits in `n`. Constraints * Your solution should run in O(1) time complexity. Examples ```python assert count_digits(12345) == 5 assert count_digits(-12345) == 5 assert count_digits(0) == 1 assert count_digits(1000000) == 7 assert count_digits(-999999999) == 9 ``` Ensure your function correctly handles edge cases like zero and any negative number.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the given integer `n`, ignoring any leading negative signs. Parameters: n (int): The integer whose digits are to be counted. Returns: int: Number of digits in the absolute value of `n`. return len(str(abs(n)))"},{"question":"Objective Implement a custom hybrid sorting algorithm that combines Heap Sort with another sorting algorithm like Quick Sort to optimize sorting performance. This algorithm should dynamically decide which sorting technique to use based on the characteristics of the sub-array being sorted. Problem Statement Write a Python function `hybrid_sort` that sorts an array of integers in ascending order. The function should leverage both Heap Sort and Quick Sort, using Heap Sort for larger partitions and Quick Sort for smaller partitions. Implement the function such that you can specify the threshold size where the switch between Quick Sort and Heap Sort occurs. # Function Signature ```python def hybrid_sort(arr: list[int], threshold: int) -> list[int]: Sorts an array of integers using a hybrid of Heap Sort and Quick Sort. :param arr: List of integers to be sorted. :param threshold: Size threshold for switching between Heap Sort and Quick Sort. For sub-arrays larger than this threshold, use Heap Sort. For smaller or equal-sized sub-arrays, use Quick Sort. :return: The sorted list of integers. pass ``` # Inputs * `arr` (List[int]): A list of integers which can include positive, negative numbers, and zeros. * `threshold` (int): The threshold size for deciding when to switch between Quick Sort and Heap Sort. # Outputs * The function should return a new list with the elements sorted in ascending order. # Constraints * The function should handle arrays of various sizes, including edge cases such as empty arrays and single-element arrays. # Performance Requirements * The implementation should aim to minimize time complexity by making an effective choice between Quick Sort and Heap Sort based on the given `threshold`. # Example ```python # Example usage of hybrid_sort: # Given array to sort arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Define threshold for the hybrid sort threshold = 5 # Perform hybrid sorting sorted_array = hybrid_sort(arr, threshold) print(sorted_array) # Expected Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Notes To solve this problem, you will need to implement both Quick Sort and Heap Sort within the `hybrid_sort` function. The function should dynamically choose which sort to apply based on the `threshold`. The input array should be divided and conquered recursively, using Quick Sort for smaller partitions and Heap Sort for larger ones.","solution":"def hybrid_sort(arr, threshold): Sorts an array of integers using a hybrid of Heap Sort and Quick Sort. :param arr: List of integers to be sorted. :param threshold: Size threshold for switching between Heap Sort and Quick Sort. For sub-arrays larger than this threshold, use Heap Sort. For smaller or equal-sized sub-arrays, use Quick Sort. :return: The sorted list of integers. if len(arr) <= threshold: return quick_sort(arr) else: return heap_sort(arr) def quick_sort(arr): Helper function to perform Quick Sort. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def heap_sort(arr): Helper function to perform Heap Sort. def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) for i in range(n - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr # Example usage # Given array to sort arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] # Define threshold for the hybrid sort threshold = 5 # Perform hybrid sorting sorted_array = hybrid_sort(arr, threshold) print(sorted_array) # Expected Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]"},{"question":"You are given an array of integers that was originally sorted in ascending order but has been rotated at some pivot unknown beforehand. The task is to find the minimum element in this rotated array using an efficient algorithm with a time complexity of O(log N). # Function Signature ```python def find_min_rotated_sorted_array(array: List[int]) -> int: Finds the minimum element in a rotated sorted array. :param array: List of integers representing the rotated sorted array. :return: The minimum integer in the array. ``` # Input - `array`: A list of unique integers where the list was originally sorted in ascending order and then rotated at some unknown pivot. The length of the array can range from `1` to `10^5`. # Output - An integer representing the minimum element in the array. # Constraints - The array does not contain duplicates. - The algorithm\'s time complexity must be O(log N). # Examples ```python assert find_min_rotated_sorted_array([3, 4, 5, 1, 2]) == 1 assert find_min_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2]) == 0 assert find_min_rotated_sorted_array([11, 13, 15, 17]) == 11 assert find_min_rotated_sorted_array([2, 1]) == 1 ``` # Scenario Consider an array of temperature readings over several days. These readings form a strictly increasing sequence but, due to a recording malfunction, the array got rotated at some unknown point. Your task is to determine the earliest (minimum) temperature recorded using an efficient search. # Performance Requirements - Ensure that your solution adheres to the required O(log N) time complexity.","solution":"from typing import List def find_min_rotated_sorted_array(array: List[int]) -> int: Finds the minimum element in a rotated sorted array. :param array: List of integers representing the rotated sorted array. :return: The minimum integer in the array. left, right = 0, len(array) - 1 while left < right: mid = (left + right) // 2 # If mid element is greater than the rightmost element, # it means the smallest element is in the right half if array[mid] > array[right]: left = mid + 1 else: right = mid return array[left]"},{"question":"You are given a Hash Table class that supports basic operations like insertion, deletion, and lookup. The hash table uses linear probing for collision handling and a custom resizing mechanism to maintain load factor efficiency. The `ResizableHashTable` class extends the basic hash table to support dynamic resizing when the load factor exceeds a threshold. **Objective**: Your task is to implement a new subclass `MonitorHashTable` of the `ResizableHashTable` that includes monitoring functionalities and maintains usage statistics like the number of collisions and the current load factor. # Specifications: 1. **New Methods**: - `get_collisions() -> int`: Return the number of collisions that have occurred. - `get_load_factor() -> float`: Return the current load factor of the hash table. 2. **Modified Methods**: - Update the `put` method to increment the collision count whenever a collision occurs during insertion. # Constraints: - Assume keys are non-negative integers. - Initial hash table size is provided as a constant `MIN_SIZE = 8`. - Double the size of the table whenever the load factor reaches or exceeds `2/3`. # Input: - Series of method calls to the `MonitorHashTable` class. # Output: - Return results of `get_collisions` and `get_load_factor` calls. # Example: ```python ht = MonitorHashTable() ht.put(1, \'a\') ht.put(9, \'b\') # Collision with key 1 due to initial size 8 ht.put(17, \'c\') # Collision handling required print(ht.get_collisions()) # Should output 2 print(ht.get_load_factor()) # Should output load factor e.g., 0.375 ``` **Implementation Requirements**: - Your solution should efficiently handle collision tracking without adding significant overhead. - Implement proper resizing while preserving data integrity and updating usage statistics. Implement the `MonitorHashTable` class below: ```python class MonitorHashTable(ResizableHashTable): def __init__(self): super().__init__() self.collisions = 0 def put(self, key, value): # Your implementation to track collisions and update usage stats ... def get_collisions(self) -> int: # Return the number of collisions encountered ... def get_load_factor(self) -> float: # Return current load factor ... ```","solution":"class ResizableHashTable: MIN_SIZE = 8 def __init__(self): self.size = self.MIN_SIZE self.count = 0 self.keys = [None] * self.size self.values = [None] * self.size def _hash(self, key): return key % self.size def put(self, key, value): index = self._hash(key) start_index = index while self.keys[index] is not None: if self.keys[index] == key: self.values[index] = value return index = (index + 1) % self.size if index == start_index: raise Exception(\\"HashTable is full\\") self.keys[index] = key self.values[index] = value self.count += 1 if self.count / self.size >= 2/3: self._resize() def get(self, key): index = self._hash(key) start_index = index while self.keys[index] is not None: if self.keys[index] == key: return self.values[index] index = (index + 1) % self.size if index == start_index: return None return None def _resize(self): old_keys = self.keys old_values = self.values self.size *= 2 self.keys = [None] * self.size self.values = [None] * self.size self.count = 0 for i in range(len(old_keys)): if old_keys[i] is not None: self.put(old_keys[i], old_values[i]) class MonitorHashTable(ResizableHashTable): def __init__(self): super().__init__() self.collisions = 0 def put(self, key, value): index = self._hash(key) start_index = index initial_collision = False while self.keys[index] is not None: if not initial_collision: self.collisions += 1 initial_collision = True if self.keys[index] == key: self.values[index] = value return index = (index + 1) % self.size if index == start_index: raise Exception(\\"HashTable is full\\") self.keys[index] = key self.values[index] = value self.count += 1 if self.count / self.size >= 2/3: self._resize() def get_collisions(self) -> int: return self.collisions def get_load_factor(self) -> float: return self.count / self.size"},{"question":"**Objective**: Write a function `extended_hailstone(m, limit)` that modifies the basic hailstone sequence algorithm. The function should terminate not only when the sequence reaches 1, but also if the sequence length exceeds a given limit. The function should return two values: 1. The hailstone sequence (list of integers). 2. A boolean value indicating whether the sequence terminated normally (reached 1) or due to the length limit. Function Signature ```python def extended_hailstone(m: int, limit: int) -> (list, bool): pass ``` Input * `m`: An integer (1 <= m <= 10^6) representing the starting point of the hailstone sequence. * `limit`: An integer (1 <= limit <= 10^4) defining the maximum allowed length of the sequence. Output * A tuple (sequence, normal_terminal): * `sequence`: A list of integers representing the hailstone sequence starting from `m`. * `normal_terminal`: A boolean value. True if the sequence reached 1, False if it stopped due to the length limit. Constraints * Ensure your function handles edge cases, including the largest possible sequence lengths efficiently. Example ```python def extended_hailstone(5, 10): # Returns ([5, 16, 8, 4, 2, 1], True) pass def extended_hailstone(9, 5): # Returns ([9, 28, 14, 7, 22], False) pass ``` **Explanation**: 1. In the first example, starting from `5`, we follow the hailstone sequence rules and successfully reach 1 within the length limit, thus the second return value is True. 2. In the second example, starting from `9`, the sequence exceeds the length limit before reaching 1, thus we return the sequence up to the limit and the second return value is False.","solution":"def extended_hailstone(m: int, limit: int) -> (list, bool): Compute the extended hailstone sequence starting from m. The sequence stops if 1 is reached or if the length of the sequence exceeds the specified limit. Args: m (int): The starting number for the hailstone sequence. limit (int): The maximum allowed length of the sequence. Returns: (list, bool): A tuple containing the hailstone sequence and a boolean indicating if the sequence terminated by reaching 1 (True) or by exceeding the limit (False). sequence = [m] while m != 1 and len(sequence) < limit: if m % 2 == 0: m = m // 2 else: m = 3 * m + 1 sequence.append(m) normal_terminal = (m == 1) return (sequence, normal_terminal)"},{"question":"# Cycle Detection and Identification in a Linked List Problem Description Given a singly linked list, write a function `find_cycle_start` that determines whether the linked list contains a cycle. If it does, return the node at which the cycle begins; otherwise, return `None`. Function Signature ```python def find_cycle_start(head: Node) -> Node: ... ``` Input and Output * **Input**: * `head` - The head of the singly linked list, a node of type `Node`. * **Output**: * Returns the first node of the cycle if there is a cycle; `None` otherwise. Constraints * You are expected to achieve linear time complexity O(n) and constant space complexity O(1). * The linked list can be either cyclic or acyclic. * The function should not modify the linked list. Example Given the linked list: ``` A -> B -> C -> D -> E -> C (cycle starts at C) ``` Running `find_cycle_start` should return the node with value \'C\'. For a linked list without a cycle: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` Running `find_cycle_start` should return `None`. Scenario Imagine you are working on a system monitoring tool that stores data points linked chronologically. To detect and troubleshoot potential infinite loops in the data processing pipeline, you need to ensure there are no cycles in the logging structure. Implementation Requirements Implement the required function ensuring accuracy and efficiency. Additionally, consider edge cases like: * An empty linked list (`head` is `None`). * A linked list with a single node without a cycle. * A linked list where all nodes form a cycle. ```python class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Node: # Implement this function ``` **Note**: Provide appropriate unit tests to ensure your solution handles edge cases effectively.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_cycle_start(head: Node) -> Node: Detects the start of the cycle in a linked list. :param head: The head of the linked list :return: The node where the cycle begins, or None if there is no cycle if not head or not head.next: return None slow = head fast = head # Phase 1: Determine whether there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # No cycle detected if not fast or not fast.next: return None # Phase 2: Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Context It is imperative to verify the completeness of a sequence of unique integers in applications involving data integrity and validation in competitive programming. One frequent task involves identifying the single missing integer from a sequence ranging from 0 up to n. If the sequence is already complete, the next integer should be returned instead. Task Implement a function `find_missing_number(nums)` that accepts a list of unique integers representing a sequence [0..n] where a single integer is missing. The function should return the missing number or the next integer if no number is missing. Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` Input - `nums`: A list of unique integers within the range [0, len(nums)], properly shuffled. Output - Return the missing integer in the sequence. - If the sequence is complete, return the next integer after the largest element in the sequence. Constraints - The elements are within the range [0, len(nums)]. - All elements are unique. - The length of the input list can be between 0 and 10^5. Example Input: ```python nums = [4, 1, 3, 0, 6, 5, 2] ``` Output: ```python 7 ``` Input: ```python nums = [0, 1, 2, 3] ``` Output: ```python 4 ``` Requirements - Implement a solution in O(n) time complexity. - Maintain an O(1) space complexity.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: This function finds the missing number in a sequence from 0 to len(nums). If no number is missing, it returns the next integer after the largest element. n = len(nums) # The sum of the first n+1 natural numbers (including 0 to n) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) # Difference between the expected sum and actual sum will give us the missing number return expected_sum - actual_sum"},{"question":"# Ordered Stack with Custom Push Operation Given an implementation of an `OrderedStack` class that maintains its elements in a sorted order (smallest at the bottom and largest at the top), your task is to extend its functionality by implementing a new method. Implementation Details - **Method Name**: `def to_list(self):` - **Input**: None - **Output**: Returns a list of all elements currently in the stack, preserving the order from bottom to top. Your implementation should leverage the existing functionality of the `OrderedStack` class and should not change its current methods. ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while item < self.peek() and not self.is_empty(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) # Implement the method here def to_list(self): # Your implementation pass # Example Usage: stack = OrderedStack() stack.push(10) stack.push(20) stack.push(5) print(stack.to_list()) # Output: [5, 10, 20] ``` # Constraints 1. The stack will not contain more than 10^5 elements. 2. All elements pushed into the stack will be integers. # Objective Implement the `to_list` method so that it returns a list of elements in the stack from bottom to top, preserving the correct order.","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item > self.peek(): self.push_t(item) else: while not self.is_empty() and item < self.peek(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[-1] def size(self): return len(self.items) def to_list(self): return self.items.copy()"},{"question":"You are given a list of integers where each integer except one appears exactly twice. Your task is to implement a function `find_unique(nums)` that finds and returns the single number that does not appear in pairs. # Input - A list `nums` of integers (1 ≤ len(nums) ≤ 10^6) - Each integer in `nums` fits in the range of a 32-bit signed integer. # Output - Return the single integer that does not appear twice. # Constraints - The input list always has exactly one unique element that appears once, while all other elements appear exactly twice. # Example ```python >>> find_unique([4, 1, 2, 1, 2]) 4 >>> find_unique([2, 2, 3, 3, 4]) 4 >>> find_unique([1]) 1 ``` # Additional Context This problem can often be found in coding interviews due to its exploitation of bitwise operations for skill assessment on algorithm efficiency. Make sure to handle large inputs and edge cases effectively.","solution":"def find_unique(nums): Returns the single integer that does not appear twice in the list. This function uses XOR operation to find the unique element. unique = 0 for num in nums: unique ^= num return unique"},{"question":"# Objective Implement a function to determine if a given directed graph is strongly connected. # Scenario You are given a directed graph representing routes a drone can fly between various delivery points in a city. For the drone delivery system to be robust, it must be possible to fly from any delivery point to another, directly or indirectly. You need to determine if the entire city network of delivery points is strongly connected. # Input and Output Format - **Input**: - An integer `vertex_count` representing the number of delivery points. - A list of pairs, where each pair represents a directed edge from the first element to the second. - **Output**: - Return `True` if the graph is strongly connected, otherwise `False`. # Function Signature ```python def is_strongly_connected(vertex_count: int, edges: List[Tuple[int, int]]) -> bool: pass ``` # Constraints - `1 <= vertex_count <= 10^3` - Each edge is given as a pair of integers (u, v) where 0 <= u, v < vertex_count - The list of edges is not guaranteed to contain all vertices in the graph explicitly. # Example ```python # Example 1: vertex_count = 5 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 1)] print(is_strongly_connected(vertex_count, edges)) # Output: True # Example 2: vertex_count = 4 edges = [(0, 1), (1, 2), (2, 0), (1, 3)] print(is_strongly_connected(vertex_count, edges)) # Output: False ``` # Detailed Problem Requirements 1. Design the `Graph` class (if needed) to encapsulate the graph structure. 2. Use Kosaraju’s algorithm (or any efficient method) to determine strong connectivity. 3. Be mindful of edge cases, such as disconnected graphs or graphs with no vertices.","solution":"def is_strongly_connected(vertex_count, edges): from collections import defaultdict, deque # Helper function to perform DFS def dfs(graph, start, visited): stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) stack.extend(graph[node]) # Create the graph and reversed graph graph = defaultdict(list) reversed_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reversed_graph[v].append(u) # Check connectedness on the original graph visited = set() dfs(graph, 0, visited) if len(visited) != vertex_count: return False # Check connectedness on the reversed graph visited.clear() dfs(reversed_graph, 0, visited) if len(visited) != vertex_count: return False return True"},{"question":"You are given a range of integers. A number is special if the sum of its digits raised to consecutive powers starting from 1 equals the original number. Your task is to implement a function that returns all special numbers within the given range. # Function Signature ```python def special_numbers(low: int, high: int) -> List[int]: ``` # Input * `low` (int): The starting number of the range (inclusive). * `high` (int): The ending number of the range (inclusive). # Output A list of integers containing all special numbers within the given range. # Example ```python assert special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert special_numbers(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert special_numbers(50, 150) == [89, 135] ``` # Constraints * `1 <= low <= high <= 10^6` * The output list should be sorted. * Efficient solutions are preferred as the range can be large. # Notes Carefully consider edge cases such as ranges with: * Only one number. * Extremely large ranges. * Ranges that don\'t contain any special numbers. Additionally, ensure the function handles performance efficiently for large inputs.","solution":"from typing import List def special_numbers(low: int, high: int) -> List[int]: def digit_power_sum(num: int) -> int: return sum(int(digit) ** (idx + 1) for idx, digit in enumerate(str(num))) result = [] for num in range(low, high + 1): if digit_power_sum(num) == num: result.append(num) return result"},{"question":"You are given a binary tree. Write a function `max_path_sum` to find the maximum sum of values along any path in the tree. A path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. You need to ensure your algorithm has a time complexity of O(n) and a space complexity of O(h), where n is the total number of nodes in the tree and h is the height of the tree. # Function Signature ```python def max_path_sum(root) -> int: pass ``` # Input - `root`: The root node of the binary tree. - Each `TreeNode` has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - Returns an integer representing the maximum path sum. # Constraints - The number of nodes in the tree is in the range `[1, 3 * 10^4]`. - `-1000 <= Node.val <= 1000` - The tree consists of nodes with both negative and positive values. # Example 1. **Example 1** Input: ``` root = [1, 2, 3] ``` Explanation: ``` 1 / 2 3 ``` Output: 6 2. **Example 2** Input: ``` root = [-10, 9, 20, None, None, 15, 7] ``` Explanation: ``` -10 / 9 20 / 15 7 ``` Output: 42 # Notes Consider complex edge cases like single-node trees and trees with all negative values. Ensure your solution manages performance and recursion depth effectively.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): def helper(node): nonlocal max_sum if not node: return 0 # Calculate max sum on left and right subtrees. If they\'re negative, consider them as 0. left_gain = max(helper(node.left), 0) right_gain = max(helper(node.right), 0) # Current max path could be the max of the current node value plus the best of each subtree. current_max_path = node.val + left_gain + right_gain # Update the overall max_sum if the current path\'s sum is larger. max_sum = max(max_sum, current_max_path) # Return the sum that includes the node plus one of its subtrees to be used by its parent node. return node.val + max(left_gain, right_gain) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Scenario: You are developing a search functionality for an application that deals with large datasets. The datasets are sorted in ascending order and you need to implement a search function that is optimized to work efficiently with such data. **Task**: Implement the Ternary Search algorithm. Given a sorted array of integers and a target value, write a function to find the target value in the array. If the target value exists, return its index, otherwise return -1. # Function Signature: ```python def ternary_search(arr: List[int], key: int) -> int: ``` # Input: * `arr: List[int]`: A sorted list of integers (1 ≤ len(arr) ≤ 10^6). * `key: int`: The integer value to search for in the list. # Output: * `int`: The index of the target value in the list if it exists, otherwise -1. # Constraints: * You should ensure that your solution is efficient and operates within O(log3(N)) time complexity. * The elements in the array and the target can be any integer within the range -10^9 to 10^9. # Example: ```python assert ternary_search([1,2,3,4,5,6,7,8,9,10], 5) == 4 assert ternary_search([1,2,3,4,5,6,7,8,9,10], 15) == -1 assert ternary_search([-10,-5,0,3,8,12], 0) == 2 ``` **Note**: Ensure that your implementation correctly handles edge cases and performs efficiently for large input sizes.","solution":"from typing import List def ternary_search(arr: List[int], key: int) -> int: Perform ternary search on a sorted list to find the index of the given key. If the key is not found, return -1. left, right = 0, len(arr) - 1 while left <= right: third1 = left + (right - left) // 3 third2 = right - (right - left) // 3 if arr[third1] == key: return third1 if arr[third2] == key: return third2 if key < arr[third1]: right = third1 - 1 elif key > arr[third2]: left = third2 + 1 else: left, right = third1 + 1, third2 - 1 return -1"},{"question":"# Max Flow in a Transport Network You are working as a traffic engineer, and you need to determine the maximum flow of vehicles from a starting location to a destination in a transportation network, which is modeled as a directed graph. Each node represents a junction, and each directed edge represents a one-way road with a specified vehicle capacity. **Task**: Implement an efficient algorithm to compute the maximum number of vehicles that can travel from a given source junction to a destination junction without exceeding the capacities of the roads. **Input**: * An integer `V` representing the number of vertices (junctions) in the graph. * A list of tuples `edges` where each tuple `(u, v, cap)` represents a directed edge from junction `u` to junction `v` with capacity `cap`. * Two integers, `source` and `sink` representing the source junction and the sink (destination) junction respectively. **Output**: * An integer representing the maximum flow from the source to the sink. **Constraints**: * `1 <= V <= 1000` * `0 <= u, v < V` * `0 <= cap <= 10^9` * `source != sink` **Example**: ```python V = 4 edges = [(0, 1, 100), (0, 2, 100), (1, 2, 1), (1, 3, 100), (2, 3, 100)] source = 0 sink = 3 # Example Output: 200 Explanation: From node 0 to node 3, the maximum flow is 200. ``` **Your Task**: Design and implement the function `max_flow`, which calculates the maximum flow from the source to the sink using any of the following suitable algorithms: Ford-Fulkerson, Edmonds-Karp, or Dinic. ```python def max_flow(V, edges, source, sink): # Your implementation here pass ``` **Additional Notes**: * Explain your choice of algorithm and provide the implemented function. * Consider performance implications and ensure the solution is both time and space efficient.","solution":"from collections import deque, defaultdict def bfs(source, sink, parent, capacity_graph): visited = set() queue = deque([source]) visited.add(source) while queue: current = queue.popleft() for neighbor, capacity in capacity_graph[current].items(): if neighbor not in visited and capacity > 0: parent[neighbor] = current visited.add(neighbor) queue.append(neighbor) if neighbor == sink: return True return False def max_flow(V, edges, source, sink): capacity_graph = defaultdict(lambda: defaultdict(int)) for u, v, capacity in edges: capacity_graph[u][v] += capacity parent = [-1] * V max_flow_value = 0 while bfs(source, sink, parent, capacity_graph): path_flow = float(\\"Inf\\") s = sink while s != source: path_flow = min(path_flow, capacity_graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] capacity_graph[u][v] -= path_flow capacity_graph[v][u] += path_flow v = parent[v] max_flow_value += path_flow return max_flow_value"},{"question":"You are given a Binary Search Tree (BST) and two nodes for which you need to find the Lowest Common Ancestor (LCA). The LCA of two nodes `v` and `w` in a BST is the deepest node that has both `v` and `w` as descendants. **Implementation Requirements:** 1. Implement the function `find_lca` which accepts the following parameters: * `root`: The root node of the Binary Search Tree. * `v`: The first node. * `w`: The second node. 2. The function should return the node representing the LCA. # Input * The function `find_lca` will be called with: - `root`: a Node object representing the root of the BST. - `v`: a Node object representing the first node. - `w`: a Node object representing the second node. # Output * The function should return a Node object representing the LCA of the nodes `v` and `w`. # Constraints * The BST will contain unique integer values. * `root`, `v`, and `w` will always be valid Node objects within the tree. * You may assume that each node has attributes `val`, `left`, and `right`. # Example Given the following BST: _______6______ / ___2__ ___8__ / / 0 _4 7 9 / 3 5 * Example 1: * Input: root (Node with val 6), v (Node with val 2), w (Node with val 8) * Output: Node with val 6 * Example 2: * Input: root (Node with val 6), v (Node with val 2), w (Node with val 4) * Output: Node with val 2 # Notes * It\'s guaranteed that the nodes `v` and `w` are part of the tree. * The function should avoid recursion to ensure constant space complexity. # Function Signature: ```python def find_lca(root, v, w): :type root: Node :type v: Node :type w: Node :rtype: Node pass ```","solution":"class Node: def __init__(self, val): self.val = val self.left = None self.right = None def find_lca(root, v, w): Find the Lowest Common Ancestor (LCA) of two given nodes in the BST. :param root: The root node of the Binary Search Tree. :param v: The first node. :param w: The second node. :return: The node representing the LCA. current = root while current: # If both v and w are greater than current node, LCA must be in the right subtree if v.val > current.val and w.val > current.val: current = current.right # If both v and w are less than current node, LCA must be in the left subtree elif v.val < current.val and w.val < current.val: current = current.left else: # This is the split point where v and w are on different sides return current"},{"question":"You work as a software engineer for a tech firm, and one day your manager assigns you to build an application that can dynamically manage sets of connected nodes in a network. The application should support these operations quickly even as the network grows in size. You decide to employ the Disjoint Set (Union-Find) data structure for this purpose. However, the network is dynamic: new nodes and connections are added over time. Heuristics like path compression and union by size are crucial to ensure efficient operations. **Objective**: Implement an extended Union-Find class in Python providing the necessary methods to manage the network and an additional method to count the number of connected components after each operation. **Function Signature**: ```python class Union: def __init__(self): pass def add(self, element): pass def root(self, element): pass def unite(self, element1, element2): pass def num_islands(positions): pass ``` # Specifications 1. **Union Class**: * **init**: Initializes the data structure. * **add**: Add a new node to the network. * **root**: Finds the representative of the set containing the given node. * **unite**: Unites the sets containing the two given nodes. * **count**: Returns the current number of connected components in the network. 2. **num_islands Function**: * **input**: * A list of positions where each position is a pair [x, y]. * **output**: * A list of integers where each integer represents the number of connected components after each add operation. # Example: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] Output: [1, 1, 2, 3] Explanation: After each addLand operation, the number of connected components changes: 1. [0, 0] => 1 island 2. [0, 1] => 1 island (joins with [0, 0]) 3. [1, 2] => 2 islands 4. [2, 1] => 3 islands ``` # Constraints: - Nodes in positions are within a grid of size m x n. - Connections are only allowed horizontally or vertically. # Performance Requirements: - Ensure near-constant time complexity for find and union operations using heuristics like path compression and union by size.","solution":"class Union: def __init__(self): self.parent = {} self.size = {} self.component_count = 0 def add(self, element): if element not in self.parent: self.parent[element] = element self.size[element] = 1 self.component_count += 1 def root(self, element): if self.parent[element] != element: self.parent[element] = self.root(self.parent[element]) # path compression return self.parent[element] def unite(self, element1, element2): root1 = self.root(element1) root2 = self.root(element2) if root1 != root2: if self.size[root1] < self.size[root2]: self.parent[root1] = root2 self.size[root2] += self.size[root1] else: self.parent[root2] = root1 self.size[root1] += self.size[root2] self.component_count -= 1 def count(self): return self.component_count def num_islands(positions): union_find = Union() directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] results = [] for x, y in positions: if (x, y) not in union_find.parent: union_find.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) in union_find.parent: union_find.unite((x, y), (nx, ny)) results.append(union_find.count()) return results"},{"question":"You are given a list of non-negative integers. Your task is to sort this list using the radix sort algorithm. # Function Signature ```python def radix_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr` (List[int]): A list of non-negative integers. # Output - (List[int]): A list sorted in ascending order. # Constraints - Constraints: - `1 <= len(arr) <= 10^5` - `0 <= arr[i] <= 10^9` # Performance Requirements - The solution should optimize for time complexity within the provided constraints. # Expected Behavioral Requirements - The function should correctly handle edge cases such as empty lists and lists with one element. # Implementation Notes - Use the radix sort method to sort the list based on the position of digits. - Distribute numbers into buckets based on each digit place and then reassemble the list. - Continue until sorting by the digit place of the maximum number. # Example Example 1 ```python arr = [170, 45, 75, 90, 802, 24, 2, 66] print(radix_sort(arr)) # Output: [2, 24, 45, 66, 75, 90, 170, 802] ```","solution":"from typing import List def radix_sort(arr: List[int]) -> List[int]: def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if len(arr) == 0: return [] max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Red-Black Tree Implementation and Extension Scenario You are part of a team developing a high-performance database, and you are responsible for implementing an efficient self-balancing binary search tree to handle dynamic insertions, deletions, and lookups. The provided Red-Black Tree code offers basic functionalities, but you need to extend it to support additional operations crucial for the database indexing system. Task Create a Red-Black Tree class that supports the existing functionalities (insertion, deletion, and in-order traversal) and add the following features: 1. **Contains Method**: Implement a method `contains(val)` that checks if a given value exists within the tree. 2. **Range Query**: Implement a method `range_query(low, high)` that returns all values within the given range [low, high] inclusive. 3. **Validate**: Implement a method `validate()` to check if the tree is a valid Red-Black Tree. Specifications & Constraints * **Input and Output**: * **contains(val)**: * **Input**: A single integer `val`. * **Output**: `True` if the value exists in the tree, `False` otherwise. * **range_query(low, high)**: * **Input**: Two integers `low` and `high`. * **Output**: A list of integers in ascending order within the range [low, high]. * **validate()**: * **Output**: `True` if the tree meets all Red-Black Tree properties, `False` otherwise. * **Performance Requirements**: * `contains(val)`: O(log n) * `range_query(low, high)`: O(k + log n), where k is the number of values in the given range. * `validate()`: Should verify all Red-Black properties efficiently with minimal overhead. * **Edge Cases**: * Tree is empty. * Single node in tree. * Range queries where low > high or low == high. Example ```python rb = RBTree() values = [20, 15, 25, 10, 5, 1, 30, 35, 22] for val in values: node = RBNode(val, is_red=True) rb.insert(node) assert rb.contains(10) == True assert rb.contains(50) == False assert rb.range_query(5, 22) == [5, 10, 15, 20, 22] assert rb.range_query(15, 15) == [15] assert rb.validate() == True node = RBTree() assert node.validate() == True ```","solution":"class RBNode: def __init__(self, data, color, parent=None, left=None, right=None): self.data = data self.color = color # True for Red, False for Black self.parent = parent self.left = left self.right = right class RBTree: def __init__(self): self.NIL_LEAF = RBNode(data=None, color=False) self.root = self.NIL_LEAF def insert(self, node): node.left = node.right = self.NIL_LEAF self._insert_node(node) def contains(self, val): return self._contains(self.root, val) def _contains(self, root, val): if root == self.NIL_LEAF: return False if val < root.data: return self._contains(root.left, val) elif val > root.data: return self._contains(root.right, val) else: return True def range_query(self, low, high): result = [] self._range_query(self.root, low, high, result) return result def _range_query(self, root, low, high, result): if root != self.NIL_LEAF: if low < root.data: self._range_query(root.left, low, high, result) if low <= root.data <= high: result.append(root.data) if high > root.data: self._range_query(root.right, low, high, result) def validate(self): def is_red_black_tree(node): if node == self.NIL_LEAF: return True, 0 left_is_valid, left_black_height = is_red_black_tree(node.left) right_is_valid, right_black_height = is_red_black_tree(node.right) if not left_is_valid or not right_is_valid or left_black_height != right_black_height: return False, 0 if node.color and ((node.left and node.left.color) or (node.right and node.right.color)): return False, 0 return True, left_black_height + (0 if node.color else 1) if not self.root.color and is_red_black_tree(self.root)[0]: return True return False def _insert_node(self, node): if self.root == self.NIL_LEAF: self.root = node node.color = False node.parent = None else: self._insert_node_helper(self.root, node) self._fix_insert(node) def _insert_node_helper(self, root, node): if root != self.NIL_LEAF: if node.data < root.data: if root.left != self.NIL_LEAF: self._insert_node_helper(root.left, node) else: root.left = node node.parent = root else: if root.right != self.NIL_LEAF: self._insert_node_helper(root.right, node) else: root.right = node node.parent = root def _fix_insert(self, node): while node != self.root and node.parent.color: if node.parent == node.parent.parent.left: uncle = node.parent.parent.right if uncle.color: node.parent.color = False uncle.color = False node.parent.parent.color = True node = node.parent.parent else: if node == node.parent.right: node = node.parent self._rotate_left(node) node.parent.color = False node.parent.parent.color = True self._rotate_right(node.parent.parent) else: uncle = node.parent.parent.left if uncle.color: node.parent.color = False uncle.color = False node.parent.parent.color = True node = node.parent.parent else: if node == node.parent.left: node = node.parent self._rotate_right(node) node.parent.color = False node.parent.parent.color = True self._rotate_left(node.parent.parent) self.root.color = False def _rotate_left(self, node): temp = node.right node.right = temp.left if temp.left != self.NIL_LEAF: temp.left.parent = node temp.parent = node.parent if node.parent: if node == node.parent.left: node.parent.left = temp else: node.parent.right = temp else: self.root = temp temp.left = node node.parent = temp def _rotate_right(self, node): temp = node.left node.left = temp.right if temp.right != self.NIL_LEAF: temp.right.parent = node temp.parent = node.parent if node.parent: if node == node.parent.left: node.parent.left = temp else: node.parent.right = temp else: self.root = temp temp.right = node node.parent = temp # Example usage: # rb = RBTree() # values = [20, 15, 25, 10, 5, 1, 30, 35, 22] # for val in values: # node = RBNode(val, True) # rb.insert(node) # assert rb.contains(10) is True # assert rb.contains(50) is False # assert rb.range_query(5, 22) == [5, 10, 15, 20, 22] # assert rb.range_query(15, 15) == [15] # assert rb.validate() is True"},{"question":"You are tasked with enhancing a text editor\'s find feature by implementing an efficient string searching function. The function should locate all starting indices of a given pattern within a provided text using the Knuth-Morris-Pratt (KMP) algorithm. # Function Specification ```python def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]: Given two sequences, text and pattern, return the list of start indexes in text where the pattern matches using the Knuth-Morris-Pratt algorithm. Args: text: The primary sequence within which to search for the pattern. pattern: The sequence to be searched for within the text. Returns: List of starting indices within the text where the pattern matches. Example: >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] If idx is in the list, text[idx : idx + M] matches with pattern. Constraints: - The function should handle texts and patterns of length up to 10^5. - The function should consider edge cases such as empty text or pattern. pass ``` # Guidelines 1. **Input/Output**: * Input: * `text`: A sequence (string or list) where the pattern is to be searched. * `pattern`: A sequence (string or list) that needs to be found in the text. * Output: A list of integers representing the starting indices. 2. **Constraints**: * The lengths of text and pattern are at most 100,000 characters. * Handle cases where either text or pattern or both might be empty. 3. **Requirements**: * Implement the Knuth-Morris-Pratt (KMP) algorithm to achieve efficient searching. * Ensure the solution works within the given constraints of time and space. 4. **Edge Cases**: * The text or pattern being empty. * Patterns longer than the text. * Characters in the pattern not present in the text. # Testing Ensure: - The function returns the correct indices for the provided examples. - Handles edge cases effectively, such as empty text or pattern. - Performs efficiently for large inputs.","solution":"from typing import List, Sequence def knuth_morris_pratt(text: Sequence, pattern: Sequence) -> List[int]: Given two sequences, text and pattern, return the list of start indexes in text where the pattern matches using the Knuth-Morris-Pratt algorithm. Args: text: The primary sequence within which to search for the pattern. pattern: The sequence to be searched for within the text. Returns: List of starting indices within the text where the pattern matches. Example: >>> knuth_morris_pratt(\'hello there hero!\', \'he\') [0, 7, 12] def compute_lps(pattern: Sequence) -> List[int]: Computes the Longest Prefix which is also Suffix array (LPS) used in KMP algorithm. length = 0 lps = [0] * len(pattern) i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not text or not pattern: return [] n, m = len(text), len(pattern) lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"Scenario You are developing an application that monitors the temperature recorded by sensors and calculates a moving average over a specified period. This application needs to provide the average temperature for recent recordings efficiently. Task Implement a class `TemperatureMonitor` that calculates the moving average of the temperatures in a sliding window of fixed size. You need to implement the following methods: 1. `__init__(self, size: int)`: Initialize the TemperatureMonitor with a specified window size. 2. `add_temperature(self, temp: float) -> float`: Add a new temperature reading and return the current moving average. Requirements * The `__init__` method initializes your data structure with the window size. * The `add_temperature` method: * Adds the new temperature reading. * Returns the current moving average of the temperatures in the window. * You must use a deque (double-ended queue) for efficient operations. Input and Output Formats * The `__init__` method takes an integer `size` as input. * The `add_temperature` method takes a float `temp` as input and returns a float representing the current moving average. Constraints * The window size (`size`) will be at least 1 and at most 10000. * Temperature (`temp`) readings will be floating-point numbers within the range of -100.0 to 100.0. * The system should handle up to 100000 temperature readings efficiently. Example ```python monitor = TemperatureMonitor(3) print(monitor.add_temperature(23.5)) # Output: 23.5 print(monitor.add_temperature(24.0)) # Output: 23.75 print(monitor.add_temperature(22.0)) # Output: 23.166666666666668 print(monitor.add_temperature(25.0)) # Output: 23.666666666666668 ``` Notes 1. Make sure your implementation handles edge cases such as minimum and maximum window sizes. 2. Consider the efficiency of your code, particularly how well it handles up to 100000 temperature readings.","solution":"from collections import deque class TemperatureMonitor: def __init__(self, size: int): Initializes the TemperatureMonitor with a specified window size. self.size = size self.temps = deque(maxlen=size) self.sum = 0.0 def add_temperature(self, temp: float) -> float: Adds a new temperature reading and returns the current moving average. if len(self.temps) == self.size: self.sum -= self.temps.popleft() self.temps.append(temp) self.sum += temp return self.sum / len(self.temps)"},{"question":"You are given a continuous sequence formed by concatenating all positive integers: \\"12345678910111213...\\". This infinite sequence contains each digit exactly once based on the position derived by counting up naturally. # Task Write a function `find_nth_digit(n)` that returns the nth digit in this sequence. # Requirements: - The function should have the following signature: ```python def find_nth_digit(n: int) -> int: ``` - **Input**: A single integer `n` (1 ≤ n ≤ 10^18), representing the position of the digit to be fetched. - **Output**: Return the digit found at position `n` as an integer. # Constraints - You need to ensure that your function efficiently handles large values of `n`. - The function must maintain a time complexity of O(log n) and a space complexity of O(1). # Examples 1. `find_nth_digit(3)` should return `3` (since the sequence \\"123…\\", the 3rd digit is `3`). 2. `find_nth_digit(11)` should return `0` (as sequence continues \\"12345678910…\\", the 11th digit is `0`). 3. `find_nth_digit(15)` should return `2` (sequence: \\"123456789101112131415…\\", the 15th digit is `2` from number `12`). # Hints - You need to determine the length of the digit `n` falls into and adjust your calculations to locate the exact digit within attributed digit length ranges. - Carefully consider transition points between numbers of different lengths (e.g., from single digit (1-9), to double digits (10-99), etc.). Good luck and happy coding!","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the infinite sequence of concatenated integers. length = 1 # The length of numbers we are currently considering count = 9 # Number of integers with the current length start = 1 # The first integer with the current length # Step 1: Identify the length of numbers where the nth digit is located while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Step 2: Find the exact number where the nth digit lies start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"# Question: You are given a list of integers and an integer N. Your task is to write a function `limit_occurrences(lst, N)` that modifies the list such that each integer appears at most N times without changing the order of elements. **Input** - `lst`: A list of integers `lst`, `1 <= len(lst) <= 10^6` - `N`: An integer `N`, `0 <= N <= 10^6` **Output** - A list that contains each integer in `lst` at most `N` times while retaining their original order. **Constraints** - If `N` is 0, return an empty list. - The elements in the list and `N` will have such values that it is guaranteed the program will run within time limits. **Function Signature** ```python def limit_occurrences(lst: List[int], N: int) -> List[int]: pass ``` **Example** ```python print(limit_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 2)) # Output: [1, 2, 3, 1, 2, 3] print(limit_occurrences([1, 1, 1, 1, 1], 2)) # Output: [1, 1] print(limit_occurrences([20, 37, 20, 21], 1)) # Output: [20, 37, 21] print(limit_occurrences([], 100)) # Output: [] ``` **Explanation** 1. In the first example, the number 1 and 2 appear more than 2 times, so we trim their occurrences while retaining the order. 2. In the second example, the number 1 appears more than 2 times, so we trim its occurrences. 3. In the third example, the numbers 20, 37, and 21 appear at most 1 time, hence no need for trimming. 4. In the fourth example, an empty list should return an empty list. Implement the function to achieve the desired functionality efficiently.","solution":"from typing import List def limit_occurrences(lst: List[int], N: int) -> List[int]: Modifies the list such that each integer appears at most N times without changing the order of elements. if N == 0: return [] count_dict = {} result = [] for number in lst: if number not in count_dict: count_dict[number] = 0 if count_dict[number] < N: result.append(number) count_dict[number] += 1 return result"},{"question":"**Context**: Cycle sort is a memory-efficient sorting algorithm that operates in O(1) extra space, but it has a time complexity of O(N^2). It works by finding cycles in the permutation of the array and placing elements in their correct positions by iterating through these cycles. **Objective**: Given an array of integers, your task is to implement the cycle sort algorithm. **Function Signature**: ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr`: A list of integers (`List[int]`), where 1 <= len(arr) <= 10^5 and -10^9 <= arr[i] <= 10^9. **Output**: - Returns a list of integers (`List[int]`), which is the sorted version of the input list. **Constraints**: - You must sort the array in-place (i.e., without using extra space for another array). - The function should maintain the time complexity of cycle sort (O(N^2)). **Examples**: ```python # Example 1: arr = [4, 6, 3, 2, 8] print(cycle_sort(arr)) # Output: [2, 3, 4, 6, 8] # Example 2: arr = [1, 1, 1, 1] print(cycle_sort(arr)) # Output: [1, 1, 1, 1] # Example 3: arr = [9, 7, 5, 3, 1] print(cycle_sort(arr)) # Output: [1, 3, 5, 7, 9] ``` **Performance Requirements**: - The implementation must use no more than O(1) additional space (besides the input array). - The solution should adhere to the quadratic time complexity of O(N^2). **Notes**: - Ensure handling of edge cases like already sorted arrays and arrays with duplicate elements. - Test thoroughly to avoid infinite loops or incorrect sorting.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts the array using cycle sort algorithm n = len(arr) for cycle_start in range(n - 1): item = arr[cycle_start] pos = cycle_start # Find the position where we put the element for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue # Skip duplicated elements while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] # Rotate rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Linked List Cycle Detection Problem Statement You are given a linked list. Write a function to determine if the list contains a cycle. A cycle occurs when a node\'s next reference points back to a previous node in the list, thus creating a loop. Function Signature ```python def has_cycle(head: SinglyLinkedListNode) -> bool: ``` Input - `head`: A reference to the head of a singly linked list. Output - Return `True` if there is a cycle in the linked list, otherwise `False`. Constraints - Don\'t modify the linked list. - Aim for an O(n) time complexity solution. - Use O(1) additional space. Example ```plaintext Example 1: Input: head = [3 -> 2 -> 0 -> -4] (where -4 points back to 2) Output: True Example 2: Input: head = [1 -> 2] (where 2 points back to 1) Output: True Example 3: Input: head = [1] Output: False ``` Explanation In Example 1, the linked list contains a cycle because the node with the value `-4` points back to a previous node with value `2`. Similarly, in Example 2, `2` points back to `1` forming a cycle. In Example 3, there is no cycle in the list. Note To solve this problem, you can use Floyd’s Tortoise and Hare algorithm which is efficient in both time and space complexity.","solution":"class SinglyLinkedListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def has_cycle(head: SinglyLinkedListNode) -> bool: Determine if the given linked list contains a cycle. Args: head (SinglyLinkedListNode): The head of the linked list. Returns: bool: True if the linked list contains a cycle, False otherwise. if not head or not head.next: return False slow, fast = head, head.next while fast and fast.next: if slow == fast: return True slow = slow.next fast = fast.next.next return False"},{"question":"# Linear Search with additional constraints **Context**: You are developing a software to manage an inventory system. Within this system, there is a need to find the position of certain items based on their unique identifiers. However, because the inventory can have some specific constraints like duplicated elements and unsorted data, the search algorithm needs to handle these efficiently. **Task**: Implement a function `linear_search_with_duplicates` that extends the functionality of a typical linear search. It should return all indices of the occurrences of the search query in the array. If the element is not found, return an empty list. **Function Signature**: ```python def linear_search_with_duplicates(array: List[int], query: int) -> List[int]: pass ``` **Input**: * an array of integers `array` where 1 ≤ len(array) ≤ 10^5. * an integer `query` which is the element to be searched. **Output**: * a list of integers representing the indices of all occurrences of `query` in the array. If the element is not found, return an empty list. **Constraints**: * The array can have duplicate elements. * The array is not sorted. * The solution should handle large inputs efficiently. **Example**: ```python print(linear_search_with_duplicates([2, 3, 5, 3, 2, 4], 3)) # Output: [1, 3] print(linear_search_with_duplicates([1, 2, 3, 4, 5], 6)) # Output: [] ``` **Note**: Focus on writing efficient, readable, and well-documented code. Consider edge cases such as empty arrays and multiple instances of the query within the array.","solution":"from typing import List def linear_search_with_duplicates(array: List[int], query: int) -> List[int]: Performs a linear search to find all occurrences of query in the array. :param array: List of integers to search within. :param query: Integer to search for. :return: List of indices where the query occurs in the array. result = [] for idx, value in enumerate(array): if value == query: result.append(idx) return result"},{"question":"# Question: Format License Key You are given a string `key` which consists of alphanumeric characters and dashes. The string is grouped into one or more dash-separated groups. You are also given an integer `k`. The goal is to reformat the input string `key` such that each group contains exactly `k` characters, except for possibly the first group, which can be shorter but must contain at least one character. Write a function `format_license_key(key, k)` to achieve this. The function should return the reformatted string. Input - `key`: A string containing only alphanumeric characters and dashes `-`. The length of `key` is at most 10,000. - `k`: An integer indicating the size of each group after formatting. `1 <= k <= 10,000`. Output - A formatted string with alphanumeric characters grouped into sections of size `k`, separated by dashes. Example ``` Input: key = \\"2-4A0r7-4k\\", k = 4 Output: \\"24A0-R74K\\" Input: key = \\"2-4A0r7-4k\\", k = 3 Output: \\"24-A0R-74K\\" Input: key = \\"---\\", k = 2 Output: \\"\\" ``` Constraints - The input string may be empty or consist only of dashes. - The function should handle both lowercase and uppercase alphanumeric characters. Performance Requirements - The function should run in O(n) time, where n is the length of the input string. - The memory usage should be consistent with storing the input and processing it linearly.","solution":"def format_license_key(key, k): # Remove all dashes and convert to uppercase clean_key = key.replace(\'-\', \'\').upper() # Calculate the length of the first group first_group_length = len(clean_key) % k or k # Initialize the reformatted key with the first group reformatted_key = clean_key[:first_group_length] # Add the remaining groups for i in range(first_group_length, len(clean_key), k): reformatted_key += \'-\' + clean_key[i:i+k] return reformatted_key"},{"question":"You are given a binary array. Your task is to find the index of the zero which, when replaced with a one, will maximize the length of the longest contiguous subarray of ones. If no zero is present, return -1. # Function Signature ```python def find_optimal_replacement_index(arr: List[int]) -> int: ``` # Input - An array `arr` of binary integers (0s and 1s). # Output - An integer representing the index of the zero that, when replaced with a one, results in the longest contiguous sequence of ones. - If no zero exists in the array, return -1. # Constraints - The array length is at most `10^5`. - The array elements are either 0 or 1. # Example ```python # Example 1 assert find_optimal_replacement_index([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]) == 3 # Example 2 assert find_optimal_replacement_index([1, 1, 1, 1, 1]) == -1 # Example 3 assert find_optimal_replacement_index([0, 1, 1, 0, 1, 1, 1]) == 3 ``` # Note You must ensure the solution is efficient in both time and space complexity. Aim for a linear time complexity solution (O(n)).","solution":"from typing import List def find_optimal_replacement_index(arr: List[int]) -> int: Finds the index of the zero that, when replaced by one, produces the longest contiguous subarray of ones. Parameters: arr (List[int]): A list of binary integers. Returns: int: Index of the zero to be replaced. If no zero exists, returns -1. max_len = 0 zero_index = -1 # Index of the zero to flip to achieve the longest sequence current_zero_index = -1 # Index of the current zero we are considering left = 0 # left pointer for right in range(len(arr)): if arr[right] == 0: if current_zero_index != -1: # Move left pointer to one right of the previous zero position left = current_zero_index + 1 current_zero_index = right current_len = right - left + 1 if current_len > max_len: max_len = current_len zero_index = current_zero_index return zero_index"},{"question":"# Priority Queue: Advanced Task Scheduler Context You run a computing service that schedules various computational tasks. Each task has a distinct importance level (priority). You need to maintain a data structure where tasks can be added and the task with the highest priority can be retrieved and removed efficiently. To aid in this, you will implement a priority queue using a linear array, building on the provided class stubs. Your implementation must support the following operations: 1. `push(item, priority)`: Adds a task with a given priority. 2. `pop()`: Removes and returns the task with the highest priority. 3. `peek()`: Returns the task with the highest priority without removing it. 4. `is_empty()`: Checks if the priority queue is empty. Input and Output Formats You will be implementing the additional methods to the provided `PriorityQueue` class. * **`push(item, priority)`**: * **Input**: `item` is a string representing the task, `priority` is an integer. * **Output**: None. * **`pop()`**: * **Output**: The `item` with the highest priority, or `None` if the queue is empty. * **`peek()`**: * **Output**: The `item` with the highest priority, or `None` if the queue is empty. * **`is_empty()`**: * **Output**: `True` if the queue is empty, otherwise `False`. Constraints * `Priority` values are unique integers. * Task names (`item`) are strings with a maximum length of 100 characters. * The priority queue can hold up to 10^4 tasks. Performance Requirements * All methods should be performant for up to 10^4 tasks. * Specifically, `push` should handle insertion in O(n), and `pop` and `peek` in O(1). # Task Implement the following methods in the `PriorityQueue` class: ```python # Add method stubs here for clarity def peek(self): Return the task with the highest priority without removing it. pass def is_empty(self): Return True if the queue is empty, False otherwise. pass ``` Example Interaction: ```python pq = PriorityQueue() pq.push(\\"task1\\", 3) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 4) print(pq.peek()) # Output: \\"task3\\" print(pq.pop()) # Output: \\"task3\\" print(pq.pop()) # Output: \\"task1\\" print(pq.is_empty()) # Output: False print(pq.pop()) # Output: \\"task2\\" print(pq.is_empty()) # Output: True ```","solution":"class PriorityQueue: def __init__(self): self.queue = [] def push(self, item, priority): Adds a task with a given priority. :param item: task name (string) :param priority: priority of the task (integer) self.queue.append((priority, item)) self.queue.sort(reverse=True, key=lambda x: x[0]) def pop(self): Removes and returns the task with the highest priority. :return: task name (string) or None if the queue is empty if self.queue: return self.queue.pop(0)[1] else: return None def peek(self): Returns the task with the highest priority without removing it. :return: task name (string) or None if the queue is empty if self.queue: return self.queue[0][1] else: return None def is_empty(self): Checks if the priority queue is empty. :return: True if the queue is empty, otherwise False return len(self.queue) == 0"},{"question":"# Question: Efficient Calculation of Euler\'s Totient Function You are tasked with implementing a function to compute Euler\'s Totient Function, ϕ(n), which counts the number of integers from 1 to n that are coprime with n. Your implementation should be efficient to handle inputs up to 10^9. Requirements: 1. Implement the function `euler_totient(n)` which takes a single integer `n` as its input and returns an integer, the value of ϕ(n). 2. Ensure your implementation has a time complexity of O(sqrt(n)) and a space complexity of O(1). Constraints: * 1 ≤ n ≤ 10^9 Input: * A single integer `n`. Output: * A single integer, the value of ϕ(n). Example: * Input: `n = 9` * Output: `ϕ(9) = 6` * Input: `n = 10` * Output: `ϕ(10) = 4` Explanation: In the first example, the numbers coprime with 9 are {1, 2, 4, 5, 7, 8}, so ϕ(9) = 6. In the second example, the numbers coprime with 10 are {1, 3, 7, 9}, so ϕ(10) = 4. **Note:** Ensure your implementation handles edge cases, such as when `n` is a prime number or a product of many prime factors.","solution":"def euler_totient(n): Computes Euler\'s Totient Function ϕ(n), which is the number of integers from 1 to n that are coprime with n. Parameters: n (int): The input integer n for which ϕ(n) is to be computed. Returns: int: The value of ϕ(n). if n == 1: return 1 result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result"},{"question":"A robot is initially positioned at (0, 0) on a 2D plane. It can move up, down, left, or right. The moves are represented by a string where each character corresponds to a move: - \'U\' for moving up, - \'D\' for moving down, - \'L\' for moving left, - \'R\' for moving right. You need to write a function that determines if the sequence of moves will result in the robot returning to its original position. # Function Signature: ```python def does_robot_return(moves: str) -> bool: pass ``` # Input: * **moves** (str): A string representing the sequence of moves. The length of the moves string will not exceed 10,000 characters. # Output: * **bool**: Return `True` if the sequence of moves results in the robot returning to the starting position, otherwise `False`. # Constraints: * The input string will only contain the characters \'U\', \'D\', \'L\', and \'R\'. # Example: ```python # Example 1 move_sequence = \\"URURDLDL\\" print(does_robot_return(move_sequence)) # Output: True # Example 2 move_sequence = \\"URDL\\" print(does_robot_return(move_sequence)) # Output: False # Example 3 move_sequence = \\"UUDD\\" print(does_robot_return(move_sequence)) # Output: True ``` Ensure your implementation returns the correct boolean result for the given input moves.","solution":"def does_robot_return(moves: str) -> bool: Determines if the sequence of moves will result in the robot returning to its original position. Parameters: moves (str): A string representing the sequence of moves. Returns: bool: True if the sequence of moves results in the robot returning to the starting position, otherwise False. x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"You are given a grid of size `m x n`, initially filled with water (`0`). You will receive a list of positions where land (`1`) is added one by one. After each addition, we need to determine the number of islands in the grid. An island is defined as a group of horizontally or vertically connected lands. Implement the functions required as described below: 1. **Class Definition**: Define a class `DisjointSetUnion` that implements the Union-Find data structure with path compression and union by size. 2. **Function to Count Islands**: Implement the function `count_number_of_islands(grid_size: Tuple[int, int], positions: List[Tuple[int, int]]) -> List[int]`. This function will return the number of islands after each position is processed. Class `DisjointSetUnion` This class should support the following methods: - `add(element: Tuple[int, int])`: Adds a new set containing the single element. - `find(element: Tuple[int, int]) -> Tuple[int, int]`: Finds the root of the set containing `element` with path compression. - `unite(element1: Tuple[int, int], element2: Tuple[int, int])`: Unites the sets containing `element1` and `element2`. Function `count_number_of_islands` - **Input**: - `grid_size`: A tuple `(m, n)` representing the size of the grid. - `positions`: A list of tuples representing the positions where land is added. - **Output**: A list of integers representing the number of islands after each land addition. # Constraints 1. The size of the grid `m` and `n` will be between `1` and `1000`. 2. The number of positions will not exceed `m * n`. # Example ```python grid_size = (3, 3) positions = [(0, 0), (0, 1), (1, 2), (2, 1)] assert count_number_of_islands(grid_size, positions) == [1, 1, 2, 3] ``` Scenario You are implementing a function that could be used in a geographic information system to track the formation of islands in a water body when new land masses emerge dynamically.","solution":"from typing import List, Tuple class DisjointSetUnion: def __init__(self): self.parent = {} self.rank = {} def add(self, element: Tuple[int, int]): if element not in self.parent: self.parent[element] = element self.rank[element] = 0 def find(self, element: Tuple[int, int]) -> Tuple[int, int]: if self.parent[element] != element: self.parent[element] = self.find(self.parent[element]) return self.parent[element] def unite(self, element1: Tuple[int, int], element2: Tuple[int, int]): root1 = self.find(element1) root2 = self.find(element2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def count_number_of_islands(grid_size: Tuple[int, int], positions: List[Tuple[int, int]]) -> List[int]: dsu = DisjointSetUnion() island_count = 0 result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] added_land = set() for pos in positions: if pos in added_land: result.append(island_count) continue added_land.add(pos) dsu.add(pos) island_count += 1 for direction in directions: neighbor = (pos[0] + direction[0], pos[1] + direction[1]) if neighbor in added_land: if dsu.find(pos) != dsu.find(neighbor): dsu.unite(pos, neighbor) island_count -= 1 result.append(island_count) return result"},{"question":"# Rabin-Karp Pattern Search Enhancement You are given a text and a pattern. Using the Rabin-Karp algorithm\'s sliding window and rolling hash concept, create a function to find all occurrences of the pattern in the text, rather than just the first one. This function should return a list of starting indices where the pattern occurs in the text. You should consider both average and worst-case performance scenarios for your solution. Function Signature: ```python def find_all_occurrences(pattern: str, text: str) -> list: pass ``` Input: * **pattern** (str): The substring pattern to be searched in the text. Assumed to contain only lowercase English letters. * **text** (str): The string in which to search for the pattern. Assumed to contain only lowercase English letters. Output: * **List of integers**: Starting indices of all occurrences of the pattern in the text. If the pattern is not found, return an empty list. Constraints: * 1 ≤ len(pattern) ≤ len(text) ≤ 10^6 Example: ```python print(find_all_occurrences(\\"abc\\", \\"ababcabc\\")) # Output: [2, 5] print(find_all_occurrences(\\"a\\", \\"aaaaa\\")) # Output: [0, 1, 2, 3, 4] print(find_all_occurrences(\\"cat\\", \\"concatenation\\")) # Output: [3] ``` Points to Consider: * Ensure your implementation handles potential hash collisions. * Your solution should efficiently handle the worst-case scenario in terms of performance and memory usage. * Pay attention to possible edge cases such as empty pattern or text, or when the pattern is larger than the text.","solution":"def find_all_occurrences(pattern: str, text: str) -> list: Uses the Rabin-Karp algorithm to find all occurrences of a pattern in a text. Returns a list of starting indices where the pattern matches the substrings of the text. if not pattern or not text or len(pattern) > len(text): return [] base = 256 # Base value used for the hash calculation prime = 101 # A prime number to mod the hash values pat_len = len(pattern) txt_len = len(text) pat_hash = 0 txt_hash = 0 h = 1 result = [] # The value of h would be \\"pow(d, M-1) % q\\". for i in range(pat_len - 1): h = (h * base) % prime # Calculate the hash value of the pattern and the first window of the text for i in range(pat_len): pat_hash = (base * pat_hash + ord(pattern[i])) % prime txt_hash = (base * txt_hash + ord(text[i])) % prime # Slide the pattern over text one by one for i in range(txt_len - pat_len + 1): # Check the hash values of the current window of text and the pattern. # If the hash values match then only check for characters one by one if pat_hash == txt_hash: # Check for characters one by one if text[i:i + pat_len] == pattern: result.append(i) # Calculate hash value for next window of text: if i < txt_len - pat_len: txt_hash = (base * (txt_hash - ord(text[i]) * h) + ord(text[i + pat_len])) % prime # We might get negative value of txt_hash, converting it to positive if txt_hash < 0: txt_hash = txt_hash + prime return result"},{"question":"# Problem Description As a software engineer working on a cross-platform system, you are tasked with converting integers to a byte array and vice versa, ensuring compatibility between systems with different endianness (big endian and little endian). The byte order is significant in networking and file storage systems, where the same integer might be represented differently across different platforms. # Function Requirements 1. **Convert Integer to Byte Array**: - `def int_to_bytes(num: int, order: str) -> bytes:`: Convert an integer to a byte array according to the specified byte order (\'big\' or \'little\'). 2. **Convert Byte Array to Integer**: - `def bytes_to_int(bytestr: bytes, order: str) -> int:`: Convert a byte array back to an integer according to the specified byte order (\'big\' or \'little\'). # Input and Output * **Input**: - `int_to_bytes(num: int, order: str) -> bytes` - `num`: An integer value to be converted. - `order`: A string specifying the byte order, either \'big\' or \'little\'. - `bytes_to_int(bytestr: bytes, order: str) -> int` - `bytestr`: A byte array to be converted back to an integer. - `order`: A string specifying the byte order, either \'big\' or \'little\'. * **Output**: - `int_to_bytes` - A byte array (`bytes`) that represents the integer in the specified byte order. - `bytes_to_int` - An integer value corresponding to the byte array in the specified byte order. # Constraints * `0 <= num < 2^64` * `order` can only be \'big\' or \'little\'. * Byte array length will depend on the size of the integer. # Example ```python # Example 1 num = 305419896 order = \'big\' bytes_result = int_to_bytes(num, order) # returns b\'x12x34x56x78\' # Example 2 bytestr = b\'x12x34x56x78\' order = \'big\' int_result = bytes_to_int(bytestr, order) # returns 305419896 # Example 3 num = 305419896 order = \'little\' bytes_result = int_to_bytes(num, order) # returns b\'xV4x12\' # Example 4 bytestr = b\'xV4x12\' order = \'little\' int_result = bytes_to_int(bytestr, order) # returns 305419896 ``` # Coding Implement the functions `int_to_bytes` and `bytes_to_int` that meet the above requirements.","solution":"def int_to_bytes(num: int, order: str) -> bytes: Convert an integer to a byte array according to the specified byte order (\'big\' or \'little\'). if order not in (\'big\', \'little\'): raise ValueError(\\"Order must be either \'big\' or \'little\'\\") # Determine the number of bytes needed to represent the integer byte_length = (num.bit_length() + 7) // 8 or 1 return num.to_bytes(byte_length, byteorder=order) def bytes_to_int(bytestr: bytes, order: str) -> int: Convert a byte array back to an integer according to the specified byte order (\'big\' or \'little\'). if order not in (\'big\', \'little\'): raise ValueError(\\"Order must be either \'big\' or \'little\'\\") return int.from_bytes(bytestr, byteorder=order)"},{"question":"# Full Binary Tree Construction from Traversals Objective You are given two arrays that represent the preorder and postorder traversals of a full binary tree. Construct the binary tree and return its inorder traversal. A full binary tree is defined as a binary tree in which every node has either 0 or 2 children. Function Signature ```python def construct_tree(pre: List[int], post: List[int]) -> List[int]: pass ``` Input - `pre`: A list of integers representing the preorder traversal of the tree. - `post`: A list of integers representing the postorder traversal of the tree. Output - Return a list of integers representing the inorder traversal of the constructed tree. Constraints - Both `pre` and `post` are non-empty and contain at most 1000 elements. - The elements of `pre` and `post` are unique and represent valid traversal orders of a full binary tree. Scenario/Context Consider a data recovery system where a full binary tree structure was lost but we have reliable preorder and postorder traversal sequences stored. Rebuilding the tree is critical for reconstructing the hierarchical data and for subsequent processing. Example ```python pre = [1, 2, 4, 8, 9, 5, 3, 6, 7] post = [8, 9, 4, 5, 2, 6, 7, 3, 1] assert construct_tree(pre, post) == [8, 4, 9, 2, 5, 1, 6, 3, 7] ``` Notes - You must not use any helper libraries for tree data structures. - Optimize your approach to achieve better performance.","solution":"from typing import List def construct_tree(pre: List[int], post: List[int]) -> List[int]: pre_index = [0] # Use a list to simulate passing an integer by reference post_position = {v: i for i, v in enumerate(post)} def build(low, high): if low > high or pre_index[0] >= len(pre): return None root_val = pre[pre_index[0]] pre_index[0] += 1 root = TreeNode(root_val) if pre_index[0] >= len(pre) or low == high: return root next_val = pre[pre_index[0]] mid = post_position[next_val] if low <= mid < high: root.left = build(low, mid) root.right = build(mid + 1, high - 1) return root class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) tree_root = build(0, len(post) - 1) return inorder_traversal(tree_root)"},{"question":"# Binary Search in a Rotated Sorted Array In this exercise, you will implement a function to perform a binary search on a rotated sorted array. A rotated sorted array refers to an array that is first sorted in ascending order, then rotated (or shifted) by an unknown number of positions. For example, `[3, 4, 5, 1, 2]` is a rotated version of `[1, 2, 3, 4, 5]`. # Function Signature: ```python def search_rotated_array(array: List[int], target: int) -> int: pass ``` # Input: 1. `array`: A list of integers, which is a rotated sorted array. It may contain duplicates. 2. `target`: An integer representing the value to search for in the array. # Output: * Return the index of the target if it is found; otherwise, return `-1`. # Constraints: * The array has no particular size limit but expect typical array sizes to be within the range of 0 leq len(array) leq 10^5. * The search must run efficiently with logarithmic time complexity, i.e., O(log n). * The array can contain duplicate values. # Example: ```python # Example 1: array = [4,5,6,7,0,1,2] target = 0 print(search_rotated_array(array, target)) # Output: 4 # Example 2: array = [4,5,6,7,0,1,2] target = 3 print(search_rotated_array(array, target)) # Output: -1 # Example 3: array = [1] target = 0 print(search_rotated_array(array, target)) # Output: -1 ``` # Requirements: 1. You must implement an efficient search algorithm that runs in O(log n) time. 2. Ensure your implementation handles edge cases, such as empty arrays or arrays with a single element. 3. Follow the binary search principles but accommodate the rotation in the array. **Hint**: Consider that one of the subarrays (either left or right side of the midpoint) will still remain sorted despite rotation. Use this property to minimize the search space effectively.","solution":"def search_rotated_array(array, target): Searches for a target value in a rotated sorted array. :param array: List[int] - The rotated sorted array. :param target: int - The target value to search for. :return: int - The index of the target if found; otherwise, -1. if not array: return -1 left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid # Check if left part is sorted if array[left] <= array[mid]: if array[left] <= target < array[mid]: right = mid - 1 else: left = mid + 1 # Otherwise, right part must be sorted else: if array[mid] < target <= array[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"**Question Title**: Implement and Test a Randomized Set Data Structure **Context**: A randomized set is a data structure that supports quickly inserting, deleting, and retrieving elements in random order. Your task is to implement this data structure and write several tests to ensure it functions correctly. **Task**: Implement a `RandomizedSet` class that supports the following operations: - **insert(val)**: Inserts a value `val` to the set if it is not already present. Returns `True` if the value was inserted, and `False` otherwise. - **remove(val)**: Removes a value `val` from the set if it is present. Returns `True` if the value was removed, and `False` otherwise. - **get_random()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned from the set. The methods should maintain average O(1) time complexity. # Functions to Implement: 1. `def insert(self, val: int) -> bool` 2. `def remove(self, val: int) -> bool` 3. `def get_random(self) -> int` # Constraints: - Elements of the set will be integers ranging from -10^6 to 10^6. - At most 2 * 10^5 calls will be made to `insert`, `remove`, and `get_random`. # Example Usage: ```python random_set = RandomizedSet() # Inserts 1 to the set. Returns True as 1 was inserted successfully. print(random_set.insert(1)) # Returns False as 2 does not exist in the set. print(random_set.remove(2)) # Inserts 2 to the set, returns True. Set now contains [1, 2]. print(random_set.insert(2)) # get_random should return either 1 or 2 randomly. print(random_set.get_random()) # Removes 1 from the set, returns True. Set now contains [2]. print(random_set.remove(1)) # get_random should return 2. print(random_set.get_random()) ``` **Testing Instructions**: - Write test cases to validate your implementation. - Consider edge cases including removing from an empty set, inserting duplicates, and checking random element probabilities.","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> bool: if val not in self.dict: self.dict[val] = len(self.list) self.list.append(val) return True return False def remove(self, val: int) -> bool: if val in self.dict: last_element = self.list[-1] idx_to_remove = self.dict[val] self.list[idx_to_remove] = last_element self.dict[last_element] = idx_to_remove self.list.pop() del self.dict[val] return True return False def get_random(self) -> int: return random.choice(self.list)"},{"question":"Problem Statement You are required to implement a function that improves the efficiency of the provided path-finding algorithms for very large graphs. Specifically, you will focus on finding the shortest path in an unweighted graph using an iterative approach rather than recursive to handle larger and denser graphs efficiently. **Function Signature** ```python def find_shortest_path_iterative(graph, start, end): Find the shortest path between two nodes using an iterative strategy. :param graph: a dictionary representing the adjacency list of the graph. :param start: the start node. :param end: the end node. :return: list representing the shortest path from start to end, or None if no path exists. ``` **Inputs** - `graph` (dict): An adjacency list representation of an unweighted graph where keys are node identifiers and values are lists of neighbors. - `start` (any): The starting node identifier. - `end` (any): The destination node identifier. **Outputs** - `list`: The shortest path from the start node to the end node as a list of node identifiers. Return `None` if no such path exists. **Constraints** - The graph can have a large number of nodes (up to 10^5). - The graph is unweighted, therefore assume all edge weights are equal. **Performance Requirements** - The solution should be able to handle sparse and dense graphs, optimizing for time complexity. **Hint** Consider using an iterative algorithm like Breadth-First Search (BFS) which is well-suited for finding the shortest path in an unweighted graph. **Example** ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } assert find_shortest_path_iterative(graph, \'A\', \'F\') == [\'A\', \'C\', \'F\'] assert find_shortest_path_iterative(graph, \'A\', \'D\') == [\'A\', \'B\', \'D\'] assert find_shortest_path_iterative(graph, \'A\', \'G\') is None ```","solution":"from collections import deque def find_shortest_path_iterative(graph, start, end): Find the shortest path between two nodes using an iterative strategy. :param graph: a dictionary representing the adjacency list of the graph. :param start: the start node. :param end: the end node. :return: list representing the shortest path from start to end, or None if no path exists. if start not in graph or end not in graph: return None queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == end: return path if current_node not in visited: visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited and neighbor not in path: queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Edit Distance Calculation Given two words `A` and `B`, your task is to write a function `min_operations` to compute the minimum number of operations required to transform word `A` into word `B`. An operation is defined as insertion, deletion, or substitution of a single character. Function Signature ```python def min_operations(word_a: str, word_b: str) -> int: pass ``` Input * `word_a` (str): The first string with length `N` (0 ≤ N ≤ 10^3) * `word_b` (str): The second string with length `M` (0 ≤ M ≤ 10^3) Output * Returns an integer representing the minimum number of operations required to transform `word_a` into `word_b`. Constraints * All characters in the strings are lowercase English letters. # Example ```python print(min_operations(\\"food\\", \\"money\\")) # Output: 4 print(min_operations(\\"\\", \\"\\")) # Output: 0 print(min_operations(\\"a\\", \\"\\")) # Output: 1 print(min_operations(\\"\\", \\"abc\\")) # Output: 3 print(min_operations(\\"intention\\", \\"execution\\")) # Output: 5 ``` Scenarios 1. **Empty Strings**: Both input strings are empty. 2. **Single Character to Empty**: One of the strings has one character, and the other is empty. 3. **General Case**: Two non-empty strings with different lengths. Performance Requirements The solution should have a time and space complexity within O(n*m), ensuring it handles the upper limit of string sizes efficiently. Good luck!","solution":"def min_operations(word_a: str, word_b: str) -> int: Computes the minimum number of operations required to transform word_a into word_b. An operation is defined as insertion, deletion, or substitution of a single character. n, m = len(word_a), len(word_b) # dp[i][j] will hold the minimum distance to convert word_a[0:i] to word_b[0:j] dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize dp for transforming from/to empty string for i in range(1, n + 1): dp[i][0] = i # Cost of deletions for j in range(1, m + 1): dp[0][j] = j # Cost of insertions # Fill the dp table for i in range(1, n + 1): for j in range(1, m + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed if characters are the same else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Substitution return dp[n][m]"},{"question":"# Question: Implement Efficient Sorting Algorithm Scenario You are working on improving a legacy system where a highly inefficient Bogo Sort algorithm was previously used. Your task is to replace it with a more efficient sorting algorithm while ensuring it meets certain performance constraints. Task * Write a function `efficient_sort(arr: List[int]) -> List[int]` in Python that sorts a list of integers in non-decreasing order. * Your implementation should use a more efficient algorithm like Quick Sort or Merge Sort. * Ensure the algorithm runs efficiently for input sizes up to 10,000 elements. Input Format * A list of integers `arr` where `1 <= len(arr) <= 10^4`. Output Format * Return a list of integers sorted in non-decreasing order. Constraints * The integers in the input list will be in the range `-10^6` to `10^6`. Performance Requirements * Your implementation should have an average-case time complexity of O(n log n). Example ```python # Example 1 arr = [3, 1, 2, 4] print(efficient_sort(arr)) # Output: [1, 2, 3, 4] # Example 2 arr = [10, -1, 2, 5, 0] print(efficient_sort(arr)) # Output: [-1, 0, 2, 5, 10] ```","solution":"from typing import List def efficient_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using Merge Sort. Parameters: arr (List[int]): List of integers to sort. Returns: List[int]: Sorted list of integers in non-decreasing order. if len(arr) <= 1: return arr # Split the array into halves mid = len(arr) // 2 left_half = efficient_sort(arr[:mid]) right_half = efficient_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted lists into one sorted list. Parameters: left (List[int]): First sorted list. right (List[int]): Second sorted list. Returns: List[int]: Merged and sorted list. sorted_list = [] i = j = 0 # Traverse both lists and insert the smallest element from left or right while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 # Append any remaining elements sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list"},{"question":"# Run-Length Encoding and Decoding You are tasked with implementing a run-length encoding and decoding system for data compression. This system will involve two main functions: one for encoding data and another for decoding it. **Function 1**: `encode_rle` Input - A string `input` where the data needs to be compressed using run-length encoding. Output - A string representing the compressed data. **Function 2**: `decode_rle` Input - A run-length encoded string `input`. Output - The decompressed string which should be identical to the original data provided to `encode_rle`. # Constraints - The input strings have lengths `0 <= len(input) <= 10^6`. - Characters in input are all printable ASCII characters. - You must handle large inputs efficiently. # Example Encoding ```python assert encode_rle(\\"aaaabbbcca\\") == \\"4a3b2c1a\\" assert encode_rle(\\"\\") == \\"\\" assert encode_rle(\\"abc\\") == \\"1a1b1c\\" assert encode_rle(\\"aabbcc\\") == \\"2a2b2c\\" ``` Decoding ```python assert decode_rle(\\"4a3b2c1a\\") == \\"aaaabbbcca\\" assert decode_rle(\\"\\") == \\"\\" assert decode_rle(\\"1a1b1c\\") == \\"abc\\" assert decode_rle(\\"2a2b2c\\") == \\"aabbcc\\" ``` Implement the `encode_rle` and `decode_rle` functions ensuring efficiency and correctness. Remember to consider edge cases and potential performance optimizations necessary to handle large inputs.","solution":"def encode_rle(input): Encode the input string using run-length encoding. if not input: return \\"\\" encoded_str = [] i = 0 length = len(input) while i < length: count = 1 while i + 1 < length and input[i] == input[i + 1]: i += 1 count += 1 encoded_str.append(f\\"{count}{input[i]}\\") i += 1 return \\"\\".join(encoded_str) def decode_rle(input): Decode the run-length encoded input string. if not input: return \\"\\" decoded_str = [] length = len(input) i = 0 while i < length: count_str = [] while i < length and input[i].isdigit(): count_str.append(input[i]) i += 1 count = int(\\"\\".join(count_str)) if i < length: decoded_str.append(input[i] * count) i += 1 return \\"\\".join(decoded_str)"},{"question":"**Scenario**: You are tasked with building a navigation feature for a mapping application. To optimize the searching and traversal of locations, the system should convert a sorted list of location IDs into a height-balanced Binary Search Tree (BST). A height-balanced BST is important to ensure that the depth of the tree is minimized, which in turn optimizes the search times for the locations. **Objective**: Write a function to convert a sorted array of location IDs into a height-balanced BST. **Function Signature**: ```python def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: pass ``` **Input**: - `nums`: a list of integers, `nums`, where each element represents a location ID and is sorted in ascending order. `1 <= len(nums) <= 10^4`. **Output**: - The function should return the root node of the height-balanced BST formed from the sorted array. **Constraints**: - Elements in the array are distinct. - The tree should be height-balanced. **Examples**: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: # Your code goes here # Example 1: # Input: nums = [-10, -3, 0, 5, 9] # Output: A height-balanced BST with structure similar to: # 0 # / # -3 9 # / / # -10 5 # Example 2: # Input: nums = [1, 3] # Output: A height-balanced BST with structure similar to: # 3 # / # 1 ``` **Explanation**: In the first example, calling the function with input `[-10, -3, 0, 5, 9]` should return a height-balanced BST where `0` is the root, `-3` and `9` are the left and right children of `0` respectively, `-10` is the left child of `-3`, and `5` is the left child of `9`.","solution":"from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sorted_array_to_bst(nums: List[int]) -> Optional[TreeNode]: Converts a sorted array of integers into a height-balanced binary search tree. :param nums: List[int] - A sorted list of integers. :return: Optional[TreeNode] - The root node of the height-balanced binary search tree. def helper(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = helper(left, mid - 1) node.right = helper(mid + 1, right) return node return helper(0, len(nums) - 1)"},{"question":"# One Edit Distance Challenge # Problem Context In software development and text processing, it\'s often necessary to determine how similar two pieces of text are. One common task is to check if one text can be converted into another by a single edit operation – which could be an insertion, deletion, or substitution of a single character. # Task Write a function `is_one_edit_distance` to determine if two given strings `s` and `t` are exactly one edit distance apart. # Function Signature ```python def is_one_edit_distance(s: str, t: str) -> bool: ``` # Input * `s`: A string with length `n` (0 <= n <= 10^4). * `t`: A string with length `m` (0 <= m <= 10^4). # Output * Return `True` if `s` can be converted to `t` by exactly one single edit operation (insert, delete, or replace one character). * Return `False` otherwise. # Examples ```python assert is_one_edit_distance(\\"ab\\", \\"acb\\") == True assert is_one_edit_distance(\\"apple\\", \\"aple\\") == True assert is_one_edit_distance(\\"apple\\", \\"apple\\") == False assert is_one_edit_distance(\\"peace\\", \\"peacefull\\") == False assert is_one_edit_distance(\\"\\", \\"a\\") == True ``` # Constraints * Ensure the function operates within O(min(len(s), len(t))) time complexity. * Minimize additional space usage, keeping it to O(1). # Notes * Consider the edge cases where one or both strings are empty. * Handle the scenario where strings are identical or have a length difference greater than one immediately. Design your solution to be efficient and clear, and make sure to handle all edge cases effectively.","solution":"def is_one_edit_distance(s: str, t: str) -> bool: len_s, len_t = len(s), len(t) if abs(len_s - len_t) > 1: return False if len_s > len_t: return is_one_edit_distance(t, s) # Ensure s is the shorter one # After the above check, we know len_s <= len_t for i in range(len_s): if s[i] != t[i]: if len_s == len_t: return s[i+1:] == t[i+1:] # Check replace operation else: return s[i:] == t[i+1:] # Check insert operation in t or delete in s return len_s + 1 == len_t # Check append operation"},{"question":"# Scenario You are tasked with implementing a simulation for a board game using Markov Chains. Your goal is to simulate a series of moves on the game board, starting from a given initial state and following the predefined state transition probabilities. # Task Implement a function `simulate_game` that uses Markov Chains to simulate moves in the game. # Function Signature ```python def simulate_game(chain: dict, initial_state: str, num_moves: int) -> list: Simulates a game starting from the initial state and performing the specified number of moves. :param chain: A dictionary representing the Markov chain transitions. :param initial_state: The state where the game starts. :param num_moves: The number of moves to simulate. :return: A list of states representing the successive states of the game during the simulation. ``` # Constraints - State transition probabilities should sum to 1 for each state. - States may have multiple possible next states with associated probabilities. - The function should simulate exactly `num_moves` moves starting from `initial_state`. # Input - `chain`: A dictionary where keys are states and values are dictionaries of possible next states with transition probabilities. - `initial_state`: A string representing the initial state. - `num_moves`: An integer representing the number of moves to simulate. # Output - Return a list of strings representing the sequence of states after each move. # Example ```python # Example chain chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } # Simulate 4 moves starting from state \'A\' result = simulate_game(chain, \'A\', 4) # Let\'s assume the random transition resulted in the following sequence: # [\'A\', \'B\', \'B\', \'A\'] print(result) # Output: [\'A\', \'B\', \'B\', \'A\'] ``` # Notes - You can use Python\'s `random` module to generate random numbers for state transitions. - Ensure to handle cases where the state transition probabilities might not sum precisely to 1 due to floating-point arithmetic.","solution":"import random def simulate_game(chain: dict, initial_state: str, num_moves: int) -> list: Simulates a game starting from the initial state and performing the specified number of moves. :param chain: A dictionary representing the Markov chain transitions. :param initial_state: The state where the game starts. :param num_moves: The number of moves to simulate. :return: A list of states representing the successive states of the game during the simulation. current_state = initial_state states_sequence = [current_state] for _ in range(num_moves): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) current_state = random.choices(next_states, probabilities)[0] states_sequence.append(current_state) return states_sequence"},{"question":"# Scenario: You have been hired by a logistics company to manage its parcel allocation system. Parcels are allocated based on their priority, with higher priorities handled first. To streamline this process, you decide to use a binary heap (min heap) to manage and quickly access the parcel with the highest priority. # Task: Implement a `BinaryHeap` class to efficiently manage the parcel priorities. Your implementation should support the following operations: 1. `insert(priority)`: Insert a new parcel with the given priority into the heap. 2. `remove_min()`: Retrieve and remove the parcel with the highest priority (minimum value). ```python class BinaryHeap: def __init__(self): Initialize a new instance of a binary heap. # Your code here def insert(self, priority): Insert a new element into the binary heap. :param priority: int - Priority of the parcel to be inserted. # Your code here def remove_min(self): Remove and return the minimum element from the binary heap. :return: int - The removed element with the highest priority (smallest value). # Your code here ``` # Constraints: * The priority values will be integers. * Duplicate priority values are allowed. * The number of operations (insertions + removals) will not exceed 10^5. * Function `insert` and `remove_min` should execute in O(log N) time. # Input and Output Formats: * There will be no standard input/output. Instead, you will directly interact with the `BinaryHeap` class methods. # Example: ```python heap = BinaryHeap() heap.insert(4) heap.insert(7) heap.insert(2) assert heap.remove_min() == 2 heap.insert(1) assert heap.remove_min() == 1 assert heap.remove_min() == 4 assert heap.remove_min() == 7 ``` # Performance Requirements: The `insert` and `remove_min` operations should be efficient, functioning within O(log N) time complexity to handle up to 10^5 operations effectively.","solution":"class BinaryHeap: def __init__(self): Initialize a new instance of a binary heap. self.heap = [] def insert(self, priority): Insert a new element into the binary heap. :param priority: int - Priority of the parcel to be inserted. self.heap.append(priority) self._bubble_up(len(self.heap) - 1) def remove_min(self): Remove and return the minimum element from the binary heap. :return: int - The removed element with the highest priority (smallest value). if not self.heap: return None self._swap(0, len(self.heap) - 1) min_element = self.heap.pop() self._bubble_down(0) return min_element def _bubble_up(self, index): Move the element at the given index up to its correct position in the heap. parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self._swap(index, parent_index) self._bubble_up(parent_index) def _bubble_down(self, index): Move the element at the given index down to its correct position in the heap. left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 smallest = index if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self._swap(index, smallest) self._bubble_down(smallest) def _swap(self, i, j): Swap the elements at indices i and j in the heap. self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"# Question: Efficient Power Computation Problem Statement You have to implement a function that computes the result of a number raised to a power, a^n, using binary exponentiation. Your function should also support an optional modulo operation. Function Signature ```python def efficient_power(a: int, n: int, mod: int = None) -> int: pass ``` Input * `a` (int): The base integer. * `n` (int): The exponent integer (0 ≤ n ≤ 10^9). * `mod` (int, optional): The modulus integer. If provided, your function should return the result modulo `mod`. If not provided, return the exact result of a^n. Output * Return an integer which is the result of a^n (or (a^n) % mod if `mod` is provided). Constraints - You can assume that `a` and `n` are non-negative integers. - The function must run in O(log n) time complexity. - Space complexity should be O(1) for the iterative approach. Example ```python print(efficient_power(2, 10)) # Output: 1024 print(efficient_power(3, 5)) # Output: 243 print(efficient_power(2, 10, 1000)) # Output: 24 print(efficient_power(5, 0)) # Output: 1 ``` Requirements - Implement both an iterative and recursive version of the function within `efficient_power`. The function should choose the iterative method by default, but a comment or setting can allow switching to the recursive version for academic purposes. - Ensure that your function handles edge cases, such as when n is 0 or 1. - Perform modulo operations safely within your calculations to avoid overflow with large numbers.","solution":"def efficient_power(a: int, n: int, mod: int = None) -> int: Computes a^n using binary exponentiation. Supports optional modulo operations. def iterative_power(a, n, mod): result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: result = result * base if mod is None else (result * base) % mod base = base * base if mod is None else (base * base) % mod n //= 2 return result return iterative_power(a, n, mod) # If needed, add a recursive version for academic purposes (not set as default operation in this implementation): def efficient_power_recursive(a: int, n: int, mod: int = None) -> int: Computes a^n using recursive binary exponentiation. Supports optional modulo operations. def recursive_power(a, n, mod): if n == 0: return 1 half_power = recursive_power(a, n // 2, mod) half_power = half_power * half_power if mod is None else (half_power * half_power) % mod return half_power if n % 2 == 0 else (half_power * a if mod is None else (half_power * a) % mod) return recursive_power(a, n, mod)"},{"question":"Implement a function `exchange_sort(arr)` in Python that sorts an array of integers using the Exchange Sort algorithm. Your task is to ensure the function correctly sorts the array while handling various edge cases. # Requirements - **Input**: A list of integers `arr` where ( 0 leq text{len(arr)} leq 10^3 ). - **Output**: A list of integers sorted in ascending order. - **Constraints**: - The function should handle arrays of various lengths, including empty arrays and arrays with a single element. - The algorithm should perform in-place sorting, modifying the input array directly with O(1) extra space usage. - The solution should align with O(n^2) time complexity. # Example ```python # Example 1 input_array = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] output_array = exchange_sort(input_array) print(output_array) # Expected Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] # Example 2 input_array = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] output_array = exchange_sort(input_array) print(output_array) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Example 3 input_array = [] output_array = exchange_sort(input_array) print(output_array) # Expected Output: [] # Example 4 input_array = [1] output_array = exchange_sort(input_array) print(output_array) # Expected Output: [1] ``` # Function Signature ```python def exchange_sort(arr): # Your implementation here ``` # Note Ensure your code is well-commented, highlighting the logic and steps taken to achieve the solution. Properly handle edge cases as discussed to ensure the function is robust and reliable.","solution":"def exchange_sort(arr): Sorts an array of integers in ascending order using the Exchange Sort algorithm. The sorting is done in-place. n = len(arr) # Traverse through all elements of the array for i in range(n): # Last i elements are already in place for j in range(i + 1, n): # Swap if the element found is greater than the next element if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Hamming Weight Calculation with Bit Manipulation Context You work at a tech company developing specialized hardware simulators. One crucial part of the simulation involves counting the number of \'1\' bits in an unsigned integer, which is a frequent operation across different components. You\'ve decided to use Brian Kernighan\'s Algorithm for this purpose due to its efficiency with sparse bit patterns. Problem Statement Write a function that takes an unsigned integer and returns the number of \'1\' bits it has (Hamming weight). Function Signature ```python def count_ones(n: int) -> int: pass ``` Input * A single integer `n` where 0 <= n <= 2^31 - 1. Output * An integer representing the number of \'1\' bits in the binary representation of the input integer. Constraints * The input integer will be within the range 0 to 2^31 - 1. * You should optimize the function for time complexity, particularly by leveraging bit manipulation techniques. Performance Requirements * The function should have a time complexity of O(k), where k is the number of \'1\' bits in the binary representation of the input integer. Example 1. Example: `count_ones(11)` should return `3` because the binary representation of 11 is `00000000000000000000000000001011`, which has three \'1\' bits. 2. Example: `count_ones(128)` should return `1` because the binary representation of 128 is `00000000000000000000000010000000`. Good luck and make sure to test your implementation with edge cases such as `0` and `2^31 - 1`!","solution":"def count_ones(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the input integer. :param n: an unsigned integer :return: the number of \'1\' bits count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Scenario An e-commerce data analytics team needs to frequently look up the popularity ranking of products from a pre-sorted list of product IDs to respond quickly to customer inquiries. To enhance the lookup operations, they have decided to use a ternary search algorithm. # Prompt Implement a `product_ranking_query` function that efficiently finds the position of a given product ID in a pre-sorted list of product IDs using the ternary search algorithm. # Function Signature ```python def product_ranking_query(product_list: List[int], product_id: int) -> int: :param product_list: A list of product IDs sorted in ascending order. :param product_id: The product ID to search for in the list. :return: The index of the product ID in the list if found, otherwise return -1. ``` # Input and Output - **Input**: - `product_list`: A list of integers where each integer is a product ID sorted in ascending order. (1 <= len(product_list) <= 10^5) - `product_id`: An integer representing the product ID to search for. (0 <= product_id <= 10^6) - **Output**: - Returns an integer representing the index of the `product_id` in the `product_list` if found, otherwise `-1`. # Example ```python product_list = [1001, 1002, 1003, 1004, 1005] product_id = 1004 print(product_ranking_query(product_list, product_id)) # Output: 3 product_id = 1010 print(product_ranking_query(product_list, product_id)) # Output: -1 ``` # Constraints - The product_list will always be sorted in ascending order. - Ensure an efficient implementation with respect to time and space complexity. # Note The function should handle all necessary edge cases, such as empty lists and scenarios where the product ID is not present in the list.","solution":"from typing import List def product_ranking_query(product_list: List[int], product_id: int) -> int: Finds the index of the given product_id in the sorted product_list using ternary search. :param product_list: A list of product IDs sorted in ascending order. :param product_id: The product ID to search for in the list. :return: The index of the product ID in the list if found, otherwise return -1. def ternary_search(left: int, right: int, product_id: int) -> int: if left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if product_list[mid1] == product_id: return mid1 if product_list[mid2] == product_id: return mid2 if product_id < product_list[mid1]: return ternary_search(left, mid1 - 1, product_id) elif product_id > product_list[mid2]: return ternary_search(mid2 + 1, right, product_id) else: return ternary_search(mid1 + 1, mid2 - 1, product_id) return -1 return ternary_search(0, len(product_list) - 1, product_id)"},{"question":"Problem Statement: Implement a function that uses the Max-Heap Sort algorithm to sort an array of integers in ascending order, but with a twist. You should also integrate a feature to find and return the kth largest element in the array during the sorting process. Detailed Requirements: - Implement a function `heap_sort_kth_largest(arr: List[int], k: int) -> Tuple[List[int], int]` that: * Takes a list of integers `arr`. * Takes an integer `k` representing the kth largest element to return. * Returns a tuple containing the sorted list in ascending order and the kth largest element in the array. - You must use the Max-Heap Sort technique provided in the snippets to achieve the solution. Input and Output Formats: - **Input**: A list of integers `arr` and an integer `k`. - **Output**: A tuple `(sorted_arr, kth_largest)` where `sorted_arr` is the sorted array and `kth_largest` is the kth largest element. Constraints: - You may assume all elements in the array are distinct. - 1 ≤ len(arr) ≤ 10^5 - 1 ≤ k ≤ len(arr) Example Usage: ```python arr = [3, 2, 3, 1, 2, 4, 5, 5, 6] k = 4 # Expected output would be sorted array and 4th largest element (which is 4) sorted_arr, kth_largest = heap_sort_kth_largest(arr, k) print(sorted_arr) # Expected: [1, 2, 2, 3, 3, 4, 5, 5, 6] print(kth_largest) # Expected: 4 ``` Provide a complete implementation of the function as specified.","solution":"from typing import List, Tuple def heapify(arr: List[int], n: int, i: int): Helper function to maintain the max-heap property. largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) def heap_sort_kth_largest(arr: List[int], k: int) -> Tuple[List[int], int]: Function to sort the array using max-heap sort and return the sorted array along with the k-th largest element. n = len(arr) # Build max heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # Extract elements from heap one by one for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) # Return sorted array and kth largest element (n-k because array is in ascending order) return arr, arr[-k]"},{"question":"# Factorial Calculation with Custom Constraints Scenario You are tasked with writing a function that calculates the factorial of a non-negative integer `n`. Your function must support an optional modulo operation to prevent overflow. This custom constraint ensures your result remains within a specified range. # Task Write a function `custom_factorial(n, mod=None)` that computes the factorial of a given non-negative integer `n`. Additionally, if a positive integer `mod` is provided, the function should return the factorial modulo `mod`. # Input - `n`: A non-negative integer (`0 ≤ n ≤ 10^6`). - `mod`: An optional positive integer for the modulo operation (if provided). # Output - Return the factorial of `n`, potentially modulo `mod`. # Function Signature ```python def custom_factorial(n, mod=None): ``` # Constraints - `n` is a non-negative integer. - `mod` is either `None` or a positive integer. # Performance Requirements - Your solution should handle very large values of `n` efficiently. # Examples ```python assert custom_factorial(5) == 120 assert custom_factorial(5, 3) == 0 assert custom_factorial(10, 7) == 0 assert custom_factorial(0, 7) == 1 ``` # Hints 1. To avoid integer overflow, incorporate intermediate modulo operations if `mod` is provided. 2. For large values of `n`, prefer an iterative approach to avoid recursion limits.","solution":"def custom_factorial(n, mod=None): Computes the factorial of a non-negative integer n. Optionally returns the result modulo `mod` if provided. Parameters: n (int): Non-negative integer representing the number to compute the factorial of. mod (int, optional): A positive integer for the modulo operation, defaults to None. Returns: int: The factorial of n, potentially modulo `mod`. if n == 0 or n == 1: return 1 % mod if mod else 1 result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result"},{"question":"You are working on optimizing the computation of Fibonacci numbers for a large dataset. Given a number `n`, your task is to write a function `optimized_fib` that finds the n-th Fibonacci number efficiently. # Constraints 1. You should handle an input range where 0 ≤ n ≤ 10^6. 2. Your solution must run within a reasonable time frame even for large values of `n`. # Input and Output Formats The function should have the following signature: ```python def optimized_fib(n: int) -> int: # Implementation ``` **Input**: - `n`: an integer representing the position in the Fibonacci sequence. **Output**: - Returns the n-th Fibonacci number as an integer. # Examples ```python print(optimized_fib(10)) # Output: 55 print(optimized_fib(50)) # Output: 12586269025 print(optimized_fib(1000000)) # Output: (large number) ``` # Performance Requirements Your implementation should aim for an optimal combination of time and space efficiency, exceeding naive recursion approaches and dynamically storing previously computed values where necessary. # Additional Notes - Focus on iterative or space-optimized dynamic programming techniques over recursive methods due to input range requirements. - Ensure robust input checking and handle edge cases appropriately for seamless execution.","solution":"def optimized_fib(n: int) -> int: Optimized computation of the n-th Fibonacci number using matrix exponentiation. This approach ensures that the calculation is done in O(log n) time. Args: n (int): The position in the Fibonacci sequence. Returns: int: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 def matrix_mult(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_pow(matrix, exponent): result = [[1, 0], [0, 1]] # Identity Matrix base = matrix while exponent > 0: if exponent % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) exponent //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n - 1) return result_matrix[0][0]"},{"question":"**Task**: Design an efficient solution to find the index of a target value in a sorted array using binary search. **Scenario**: You are building a system for a large library to quickly locate books based on their unique identifier numbers. Given that these identifiers are stored in a sorted list, implement a function that efficiently finds the position of a given identifier using binary search. **Function Signature**: ```python def find_book_index(book_ids: List[int], target_id: int) -> int: ``` **Input**: - `book_ids`: A list of integers representing unique book identifiers sorted in ascending order. - `target_id`: An integer representing the unique identifier of the book to find. **Output**: - Return the index of `target_id` in `book_ids` if it exists; otherwise, return -1. **Constraints**: - `len(book_ids) <= 10^6` - `-10^9 <= book_ids[i], target_id <= 10^9` **Example**: ```python assert find_book_index([1, 3, 5, 7, 9], 7) == 3 assert find_book_index([1, 3, 5, 7, 9], 2) == -1 assert find_book_index([], 1) == -1 assert find_book_index([10], 10) == 0 ``` **Requirements**: - **Efficiency**: Your solution should have a time complexity of O(log(n)) and use no extra space except for minimal overhead. - **Edge Cases**: Handle cases where the list is empty, the target is not present, and the list contains minimal or maximal values.","solution":"from typing import List def find_book_index(book_ids: List[int], target_id: int) -> int: Finds the index of the target_id in the sorted list book_ids using binary search. Parameters: book_ids (List[int]): List of sorted unique book identifiers. target_id (int): The identifier of the book to find. Returns: int: The index of the target_id in the book_ids list if found, otherwise -1. left, right = 0, len(book_ids) - 1 while left <= right: mid = (left + right) // 2 if book_ids[mid] == target_id: return mid elif book_ids[mid] < target_id: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Shortest Path in Weighted Graphs Dijkstra\'s Algorithm is a well-known method for finding the shortest paths from a source vertex to all other vertices in a graph with non-negative weights. Given the following implementation of Dijkstra\'s Algorithm, adapt it to work efficiently with large sparse graphs by utilizing a priority queue. # Problem Description You are given a connected graph represented as an adjacency list, and the number of vertices in the graph. Your task is to implement an optimized version of the `dijkstra` method that returns the shortest distances from the source vertex to all other vertices using a priority queue. # Input 1. An integer `V` which represents the number of vertices. 2. A list of edges `edges`, where each edge is represented by a tuple in the form (u, v, w) indicating an edge from vertex `u` to vertex `v` with weight `w`. 3. An integer `src` representing the source vertex. # Output * A list of integers where the i-th element represents the shortest distance from the source vertex to the i-th vertex. If a vertex is unreachable, the distance should be `float(\\"inf\\")`. # Function Signature ```python def dijkstra(V: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: pass ``` # Constraints 1. `1 <= V <= 1000` 2. `1 <= number of edges <= 10000` 3. `0 <= w <= 10000` 4. `0 <= u, v < V` # Example ```python V = 5 edges = [ (0, 1, 10), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 1, 4), (2, 3, 8), (2, 4, 2), (3, 4, 7), (4, 3, 9) ] src = 0 print(dijkstra(V, edges, src)) # Output: [0, 7, 3, 9, 5] ``` * The distances are returned in the order of vertices from 0 to V-1. * Distances to unreachable vertices should be `float(\\"inf\\")`. # Notes * Think about how priority queues can make the algorithm more efficient. * Your solution should handle edge cases such as graphs with no edges or a vertex with no connection to others.","solution":"import heapq from typing import List, Tuple def dijkstra(V: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: # Create an adjacency list from edges graph = [[] for _ in range(V)] for u, v, w in edges: graph[u].append((v, w)) # Initialize distances with infinity distances = [float(\\"inf\\")] * V distances[src] = 0 # Priority queue to maintain nodes to be processed priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > distances[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(priority_queue, (distance, v)) return distances"},{"question":"# Problem Description You are given a sorted array of integers `nums` and an integer `target`. Write a function `find_range` that finds the starting and ending positions of the `target` value. If the target is not found in the array, return `[-1, -1]`. The function should have the following signature: ```python def find_range(nums: List[int], target: int) -> List[int] ``` Input - `nums` (List[int]): A list of integers sorted in ascending order. - `target` (int): The integer whose range needs to be found. Output - A list containing two integers. The first integer is the starting position and the second is the ending position of the `target` value in the list. If the target is not found in the array, return `[-1, -1]`. Constraints - The array could be empty. - The elements in the array are sorted in ascending order. - The elements within the array and the target value could be any integer in the inclusive range from `-10^9` to `10^9`. Scenario Consider an ordered log of timestamps recorded as whole numbers. You need to identify the interval during which a specific event (`target timestamp`) was logged consecutively. Examples ```python find_range([5,7,7,8,8,8,10], 8) # Output: [3, 5] find_range([5,7,7,8,8,8,10], 11) # Output: [-1, -1] find_range([1,1,1,1,1,1,1], 1) # Output: [0, 6] find_range([], 7) # Output: [-1, -1] ``` Notes: - Implement the solution aimed at maintaining time complexity as logarithmic as possible. - Consider edge cases like an empty array and scenarios where the target appears multiple or no times.","solution":"from typing import List def find_range(nums: List[int], target: int) -> List[int]: def find_left(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] >= target: right = mid - 1 else: left = mid + 1 return left def find_right(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_idx = find_left(nums, target) right_idx = find_right(nums, target) if left_idx <= right_idx and right_idx < len(nums) and nums[left_idx] == target and nums[right_idx] == target: return [left_idx, right_idx] else: return [-1, -1]"},{"question":"# Stack Pair-Swap Function Implementation Task Write a function `swap_stack_pairs` which takes a stack as input and swaps each pair of successive elements starting from the bottom of the stack. Use an auxiliary storage structure of your choice (either a stack or a queue) to help facilitate the swapping process. Input * An integer list `stack` representing the stack with elements to be swapped. The list follows the LIFO order where the last element in the list represents the top of the stack. Output * The function should return a modified list representing the stack after pairs have been swapped. Constraints * Do not use any built-in functions that directly perform pair swapping. * Aim to minimize additional space and time complexity. * Handle both even and odd number of elements correctly. Example ```python def swap_stack_pairs(stack): # Your implementation here # Example Test Case stack = [3, 8, 17, 9, 1, 10] print(swap_stack_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] stack = [3, 8, 17, 9, 1] print(swap_stack_pairs(stack)) # Output: [8, 3, 9, 17, 1] ``` Explanation In the first example, the pairs (3, 8), (17, 9), and (1, 10) are swapped resulting in `[8, 3, 9, 17, 10, 1]`. In the second example with an odd number of elements, only pairs (3, 8) and (17, 9) are swapped, leaving 1 in its original position.","solution":"def swap_stack_pairs(stack): Swaps each successive pair of elements in the input stack. n = len(stack) for i in range(0, n - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"You are provided with a graph, represented as an adjacency list (a dictionary where keys are node identifiers and values are lists of adjacent nodes). Implement a function that efficiently finds the longest path between two nodes in an acyclic directed graph (DAG). If multiple longest paths exist, any one of them is a valid output. # Input * `graph` (a dictionary): The graph\'s adjacency list representation. * `start` (any hashable type): The starting node identifier. * `end` (any hashable type): The ending node identifier. # Output * A list of nodes representing the longest path from `start` to `end`. If no such path exists, return an empty list. # Constraints 1. The graph is a directed acyclic graph (DAG). 2. Node identifiers are unique and comparable. 3. The graph can be very large; your solution should be optimized for performance. 4. The path should include the `start` and `end` nodes. # Performance Requirements Your implementation should aim to have a time complexity of O(V + E) and should efficiently manage memory use. # Function Signature ```python def find_longest_path(graph, start, end): pass ``` # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } start = \'A\' end = \'F\' # Possible Longest Path: [\'A\', \'B\', \'E\', \'F\'] # Length: 4 steps find_longest_path(graph, start, end) ``` Output: ```python [\'A\', \'B\', \'E\', \'F\'] ``` # Edge Cases to Consider 1. `start` or `end` not in the graph. 2. Disconnected graph or no path from `start` to `end`. # Hints * Consider performing a topological sort of the graph to help in finding the longest path efficiently. * Dynamic programming or memoization may help keep track of longest paths to nodes already processed.","solution":"def find_longest_path(graph, start, end): def topological_sort(graph): def dfs(node): visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor) ordering.append(node) visited = set() ordering = [] for node in graph: if node not in visited: dfs(node) return ordering[::-1] def longest_path_dag(graph, start, end, ordering): dist = {node: float(\'-inf\') for node in graph} dist[start] = 0 path = {node: [] for node in graph} path[start] = [start] for node in ordering: if dist[node] != float(\'-inf\'): for neighbor in graph.get(node, []): if dist[node] + 1 > dist[neighbor]: dist[neighbor] = dist[node] + 1 path[neighbor] = path[node] + [neighbor] return path[end] if dist[end] != float(\'-inf\') else [] if start not in graph or end not in graph: return [] ordering = topological_sort(graph) return longest_path_dag(graph, start, end, ordering)"},{"question":"# Question: Implement a Custom Sorting Algorithm You are given an array of integers which may include negative values. You need to sort this array using a method similar to counting sort. Given below are the requirements for the custom sorting algorithm you need to implement: 1. Write a function `custom_counting_sort(arr: List[int]) -> List[int]` that sorts integers in the given array. 2. Assume the input array can have integers with values ranging between -1000000 to 1000000. 3. Your solution should aim at efficiency and should handle large arrays efficiently. # Function Signature ```python from typing import List def custom_counting_sort(arr: List[int]) -> List[int]: # Your code here ``` # Input * `arr` (List[int]): A list of integers, which could include negative values and can be empty. # Output * Returns a list of integers sorted in ascending order. # Constraints * The list, `arr` shall have at most 10^6 elements. * Each element in the array is an integer within the range [-1000000, 1000000]. # Example ```python arr = [-10, 20, 10, -20, 0, 10] print(custom_counting_sort(arr)) # Output: [-20, -10, 0, 10, 10, 20] ``` # Notes * Ensure your algorithm correctly handles edge cases like an array of all identical elements or an empty array. * Think about efficient memory usage and optimize space complexity wherever possible. * Make sure to account for the presence of negative integers in the array.","solution":"from typing import List def custom_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) # Adjust based on the range of numbers offset = -min_val counting_range = max_val - min_val + 1 count = [0] * counting_range # Populate the count array for num in arr: count[num + offset] += 1 # Generate the sorted array sorted_arr = [] for index in range(counting_range): sorted_arr.extend([index - offset] * count[index]) return sorted_arr"},{"question":"# Heap Sort Optimization Task Problem Statement You are provided with two different versions of heap sort algorithms: one using a max heap (`max_heap_sort`) and the other using a min heap (`min_heap_sort`). These algorithms sort an array in ascending order, and both have time complexity O(n log(n)). Your task is to combine these algorithms to implement a single `heap_sort` function which can sort an array in ascending order using either a max heap or a min heap, based on a boolean parameter. You will need to address any potential edge cases, optimize performance where possible, and ensure that the algorithm runs in the expected time complexity. Function Signature ```python def heap_sort(arr, use_max_heap=True, simulation=False): Sorts an array in ascending order using heap sort. Parameters: - arr: List[int] - the array to be sorted. - use_max_heap: bool - if True, use max heap for sorting; if False, use min heap. - simulation: bool - if True, print the array after each operation to show simulation. Returns: - List[int] - the sorted array. pass ``` # Example ```python # Example usage arr = [3, 2, 1, 5, 6, 4] print(heap_sort(arr, use_max_heap=True)) # Using max heap: [1, 2, 3, 4, 5, 6] print(heap_sort(arr, use_max_heap=False)) # Using min heap: [1, 2, 3, 4, 5, 6] ``` Constraints * The input array can have up to 10^6 elements. * Each element in the array is an integer in the range [-10^9, 10^9]. Requirements * The function must run in O(n log(n)) time. * The function must be able to handle edge cases, such as empty arrays and arrays with a single element, correctly. * The function must be optimized for performance where possible.","solution":"def heap_sort(arr, use_max_heap=True, simulation=False): Sorts an array in ascending order using heap sort. Parameters: - arr: List[int] - the array to be sorted. - use_max_heap: bool - if True, use max heap for sorting; if False, use min heap. - simulation: bool - if True, print the array after each operation to show simulation. Returns: - List[int] - the sorted array. def heapify(arr, n, i, max_heap): if max_heap: largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest, max_heap) else: smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] < arr[smallest]: smallest = left if right < n and arr[right] < arr[smallest]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] heapify(arr, n, smallest, max_heap) if simulation: print(arr) n = len(arr) # Build a max heap or min heap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i, use_max_heap) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0, use_max_heap) if not use_max_heap: arr.reverse() return arr"},{"question":"Question: Implement an Alternative Bitonic Sort **Scenario**: Chris is a software engineer working on parallel processing capabilities of a data-intensive application. Tasked with sorting massive datasets efficiently, Chris decided to leverage the bitonic sort algorithm due to its high parallelizability. However, he also needs the algorithm to handle input sizes that are not necessarily powers of 2. **Problem**: Write a function `alternative_bitonic_sort` that sorts an array of integers using an alternative approach inspired by bitonic sort. This function should handle arrays of any size. # Input: - An array of integers `arr` with length `n`. - A boolean `reverse` which when set to `True`, indicates the array should be sorted in descending order; otherwise, it should be sorted in ascending order. # Output: - A sorted array of integers. # Constraints: 1. The function should correctly handle arrays of any length. 2. Time complexity should be kept as low as possible, though it may vary from the classic bitonic sort due to handling of non-power of two sizes. # Performance Requirement: - For input sizes that are powers of two, aim for O(n log(n)²) time complexity, matching the classic bitonic sort in a non-parallel scenario. - For other input sizes, the time complexity may be higher, but aim to keep it close to O(n log(n) log(n)). # Example: ```python def alternative_bitonic_sort(arr, reverse=False): # Your implementation here # Example usage: print(alternative_bitonic_sort([3, 7, 2, 1, 5, 4], False)) # Output: [1, 2, 3, 4, 5, 7] print(alternative_bitonic_sort([3, 7, 2, 1, 5, 4], True)) # Output: [7, 5, 4, 3, 2, 1] ``` Explain your approach and the rationale behind your design decisions in the function comments or a separate document.","solution":"def alternative_bitonic_sort(arr, reverse=False): Perform alternative bitonic sort on an array of integers. Parameters: arr (list): The array of integers to sort. reverse (bool): If True, the array will be sorted in descending order. Otherwise, it will be sorted in ascending order. Returns: list: The sorted array. def compare_and_swap(arr, i, j, direction): if direction == (arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort(arr, low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort(arr, low, k, 1) # ascending order bitonic_sort(arr, low + k, k, 0) # descending order bitonic_merge(arr, low, cnt, direction) n = len(arr) if n <= 1: return arr k = 1 while k < n: k *= 2 extended_arr = arr + [float(\'inf\')] * (k - n) # Handle non power of 2 lengths bitonic_sort(extended_arr, 0, k, 1 if not reverse else 0) if not reverse: return list(filter(lambda x: x != float(\'inf\'), extended_arr)) else: return list(filter(lambda x: x != float(\'inf\') and x != float(\'-inf\'), extended_arr))"},{"question":"# Task Implement a Python function that classifies a given vector `x` by finding the nearest neighbor in a training set `tSet`. You need to ensure robustness against varying vector lengths, non-dictionary training sets, and include enhancements to handle empty training sets or identical distances. # Function Signature ```python def classify_nearest_neighbor(x: Tuple[int, ...], tSet: Dict[Tuple[int, ...], int]) -> int: pass ``` # Input - `x` (Tuple[int, ...]): A target vector to classify. - `tSet` (Dict[Tuple[int, ...], int]): A dictionary where keys are vectors and values are their corresponding class labels. # Output - `int`: The class label of the nearest neighbor. # Constraints - The vectors in `x` and `tSet` will have non-negative integer components. - `1 <= len(x) <= 1000` - `0 <= len(tSet.keys()) <= 1000` - Class labels are non-negative integers. # Requirements 1. The function should handle possible edge cases: - Empty training set `tSet`. - Vectors of differing lengths. - Multiple nearest neighbors with the same distance. 2. Improve the distance computation mechanism to handle large numbers efficiently. 3. Ensure the function computational performance is optimized. # Example Usage ```python # Example tSet = { (1, 2, 3): 0, (4, 5, 6): 1, (7, 8, 9): 2 } x = (1, 2, 4) print(classify_nearest_neighbor(x, tSet)) # Expected Output: 0 tSet = {} x = (1, 2, 4) print(classify_nearest_neighbor(x, tSet)) # Expected Output: -1 (indicates no neighbors to compare) ``` # Notes - Avoid using built-in functions or external libraries for distance calculations except for basic utilities. - Consider including handling scenarios with multiple nearest neighbors having the same distance, either returning the first one encountered or employing a consistent strategy.","solution":"from typing import Tuple, Dict import math def classify_nearest_neighbor(x: Tuple[int, ...], tSet: Dict[Tuple[int, ...], int]) -> int: Classifies a given vector x by finding the nearest neighbor in a training set tSet. Parameters: - x: A target vector to classify. - tSet: A dictionary where keys are vectors and values are their corresponding class labels. Returns: - The class label of the nearest neighbor. # If the training set is empty, return -1 as an indicator of no neighbors. if not tSet: return -1 def euclidean_distance(v1: Tuple[int, ...], v2: Tuple[int, ...]) -> float: Computes the Euclidean distance between two vectors v1 and v2. Assumes vectors are of the same length. return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) closest_label = -1 closest_distance = float(\'inf\') for vec, label in tSet.items(): # Ensure vectors are of the same length before computing distance. if len(vec) == len(x): dist = euclidean_distance(x, vec) if dist < closest_distance: closest_distance = dist closest_label = label elif dist == closest_distance: # Implement any strategy for tie-breaking here if needed. pass return closest_label"},{"question":"# Scenario You are working on a text processing library that decodes compressed text data. The data follows a specific encoding rule where substrings are repeated a certain number of times, and these repetitions can be nested. # Question Implement a function `decode_string(s)` that takes a single string `s` containing encoded data formatted as `k[encoded_string]` and returns its decoded string. In this context: - `k` is a non-negative integer indicating the number of repetitions. - `encoded_string` can be any valid string without whitespace and well-formed brackets. # Input * `s` (str): A valid encoded string (1 <= len(s) <= 30). # Output * Returns (str): Decoded string as per the given rules. # Constraints * Input string is always well-formed (no extra whitespaces, proper bracket structure). * Original data does not contain any digits except for repetition numbers. # Examples ```python decode_string(\\"3[a]2[bc]\\") # Should return \\"aaabcbc\\" decode_string(\\"3[a2[c]]\\") # Should return \\"accaccacc\\" decode_string(\\"2[abc]3[cd]ef\\") # Should return \\"abcabccdcdcdef\\" ```","solution":"def decode_string(s): Decodes the given encoded string s. Args: s (str): The encoded string. Returns: str: The decoded string. stack = [] current_num = 0 current_str = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str, current_num = \\"\\", 0 elif char == \']\': previous_str, num = stack.pop() current_str = previous_str + current_str * num else: current_str += char return current_str"},{"question":"Finding Strongly Connected Components **Context**: You are working on a social media analysis tool designed to detect clusters of users who interact with each other in a mutually interconnected manner. These clusters are known in graph theory as Strongly Connected Components (SCCs). Given a directed graph representing the social media network, your task is to implement Kosaraju’s algorithm to find and count all SCCs in the graph. **Task**: Write a function `find_sccs(V, edges)` to identify and count all strongly connected components in a directed graph. **Function Signature**: ```python def find_sccs(V: int, edges: List[Tuple[int, int]]) -> int: pass ``` **Input**: * `V` (int): The number of vertices in the graph labeled from `0` to `V-1`. * `edges` (List[Tuple[int, int]]): A list of directed edges where each edge is represented as a tuple `u, v` indicating a directed edge from vertex `u` to vertex `v`. **Output**: * Returns (int): The number of strongly connected components in the graph. **Constraints**: * `1 <= V <= 1000` * `0 <= len(edges) <= 5000` * Graph vertices are non-negative integers. **Sample Input**: ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] ``` **Sample Output**: ```python 2 ``` **Explanation**: In the above example, the graph has 2 strongly connected components: `{0, 1, 2, 3}` and `{4, 5}`. **Notes**: 1. Ensure that your implementation handles isolated nodes and disconnected graphs. 2. Optimize for time and space, respecting the given constraints.","solution":"from typing import List, Tuple def find_sccs(V: int, edges: List[Tuple[int, int]]) -> int: from collections import defaultdict, deque def dfs(v, adj, visited, stack): visited[v] = True for neighbor in adj[v]: if not visited[neighbor]: dfs(neighbor, adj, visited, stack) stack.append(v) def reverse_graph(V, edges): reverse_adj = defaultdict(list) for u, v in edges: reverse_adj[v].append(u) return reverse_adj def fill_order(V, adj): visited = [False] * V stack = [] for i in range(V): if not visited[i]: dfs(i, adj, visited, stack) return stack def dfs_util(v, adj, visited): visited[v] = True for neighbor in adj[v]: if not visited[neighbor]: dfs_util(neighbor, adj, visited) adj = defaultdict(list) for u, v in edges: adj[u].append(v) stack = fill_order(V, adj) reverse_adj = reverse_graph(V, edges) visited = [False] * V scc_count = 0 while stack: v = stack.pop() if not visited[v]: dfs_util(v, reverse_adj, visited) scc_count += 1 return scc_count"},{"question":"# Bitonic Sort Challenge You are tasked to implement the Bitonic Sort algorithm in Python, a parallel sorting algorithm designed for sorting sequences efficiently where the sequence length is a power of 2. This algorithm constructs a bitonic sequence and recursively sorts and merges these sequences. A bitonic sequence is a sequence that monotonically increases and then decreases, or can be cyclic permutations of such a sequence. Implement the function `bitonic_sort` that accepts an array of integers and an optional boolean flag `reverse` which indicates if the array should be sorted in ascending order (`reverse=False`, default) or descending order (`reverse=True`). Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` Parameters - `arr` (List[int]): A list of integers where the length of the list is a power of 2 (e.g., 2, 4, 8, 16, ...). - `reverse` (bool): An optional boolean. If True, the list will be sorted in descending order. If False, the list will be sorted in ascending order. Default is False. Returns - List[int]: A list of integers sorted in the specified order. Constraints - The length of `arr` will always be a power of 2. - `arr` can contain negative integers. Example ```python assert bitonic_sort([4, 2, 7, 1], False) == [1, 2, 4, 7] assert bitonic_sort([4, 2, 7, 1], True) == [7, 4, 2, 1] assert bitonic_sort([10, -1, 3, 7, 5, 4, 6, 2], False) == [-1, 2, 3, 4, 5, 6, 7, 10] assert bitonic_sort([10, -1, 3, 7, 5, 4, 6, 2], True) == [10, 7, 6, 5, 4, 3, 2, -1] ``` Note - Ensure handling edge cases such as empty arrays or arrays with single elements. - Raise `ValueError` if the array size is not a power of 2, though the initial constraints guarantee this won\'t be an input case.","solution":"from typing import List def bitonic_merge(arr: List[int], low: int, cnt: int, reverse: bool): if cnt > 1: k = cnt // 2 for i in range(low, low + k): if (arr[i] > arr[i + k]) == (not reverse): arr[i], arr[i + k] = arr[i + k], arr[i] bitonic_merge(arr, low, k, reverse) bitonic_merge(arr, low + k, k, reverse) def bitonic_sort_rec(arr: List[int], low: int, cnt: int, reverse: bool): if cnt > 1: k = cnt // 2 bitonic_sort_rec(arr, low, k, True) bitonic_sort_rec(arr, low + k, k, False) bitonic_merge(arr, low, cnt, reverse) def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: if (len(arr) & (len(arr) - 1)) != 0: raise ValueError(\\"Size of input array must be a power of 2\\") bitonic_sort_rec(arr, 0, len(arr), reverse) return arr"},{"question":"# Question: Efficient Factorial Calculation with Limit Check Suppose you are creating software that needs to perform combinatorial calculations for a variety of scenarios, including permutations and combinations. One critical function is the ability to compute factorial values efficiently. Write a function `efficient_factorial(n, threshold)` that calculates the factorial of a non-negative integer `n`. Your function should also ensure that the factorial value does not exceed a given threshold value. If at any step the product exceeds this threshold, return -1 immediately instead of calculating further. Function Signature: ```python def efficient_factorial(n: int, threshold: int) -> int: pass ``` Input: * `n` (int): a non-negative integer up to which the factorial is to be computed. * `threshold` (int): a positive integer that caps the maximum allowed factorial result for `n`. Output: * Return the factorial value if it does not exceed the threshold. * If the factorial value exceeds the threshold at any intermediate step, return -1. Examples: ```python assert efficient_factorial(5, 200) == 120 # 5! = 120 is within threshold assert efficient_factorial(5, 100) == -1 # 5! = 120 exceeds threshold 100 assert efficient_factorial(0, 1000) == 1 # 0! = 1 is always within threshold assert efficient_factorial(3, 6) == 6 # 3! = 6 matches the threshold assert efficient_factorial(4, 24) == 24 # 4! = 24 matches the threshold assert efficient_factorial(4, 23) == -1 # 4! = 24 exceeds threshold 23 ``` Constraints: * 0 <= `n` <= 100 * 1 <= `threshold` <= 10^18 Notes: * Input validation is not required. Assume valid input adhering to the constraints. * Consider efficient ways to halt the calculation early if the threshold is exceeded.","solution":"def efficient_factorial(n: int, threshold: int) -> int: Calculates the factorial of a non-negative integer n ensuring it does not exceed a given threshold. Parameters: n (int): A non-negative integer representing the number to compute the factorial for. threshold (int): A positive integer that caps the maximum allowed factorial result for n. Returns: int: The factorial value if it does not exceed the threshold, else -1. result = 1 for i in range(1, n + 1): result *= i if result > threshold: return -1 return result"},{"question":"# Question: Implement an extended version of the Rabin-Miller primality test algorithm that not only checks if a number is probably prime but also provides a list of witnesses (randomly chosen values) used during the test process. Your task is to implement the `detailed_is_prime(n, k)` function, fulfilling the following requirements: 1. **Function Signature**: `def detailed_is_prime(n: int, k: int) -> Tuple[bool, List[int]]` 2. **Input**: - `n`: an integer representing the number to be tested for primality (`5 <= n <= 10^9`). - `k`: an integer representing the number of iterations or witnesses to test (`1 <= k <= 100`). 3. **Output**: - A tuple containing: - A boolean: `True` if `n` is probably prime, `False` if `n` is definitely composite. - A list of `k` integer witnesses used during the test. 4. **Constraints**: - Handle special cases where `n` is less than 5 directly. - Return the specific witnesses for debugging and evaluation purposes. # Example ```python detailed_is_prime(31, 3) # Expected output (example): (True, [3, 14, 25]) # Explanation: 31 is probably prime, and 3, 14, and 25 are the witnesses used. detailed_is_prime(15, 2) # Expected output (example): (False, [4, 10]) # Explanation: 15 is definitely composite, and 4, 10 are the witnesses used. ``` **Notes**: - Ensure that the witnesses returned are within the range [2, n-2] as described in the original algorithm. - In the case of `n < 5`, return a consistent set of witnesses applicable to such small numbers (although trivial, still useful for learning and assessment). Good luck!","solution":"import random from typing import Tuple, List def detailed_is_prime(n: int, k: int) -> Tuple[bool, List[int]]: if n <= 1: return (False, []) if n <= 3: return (True, []) if n % 2 == 0: return (False, []) # Find d such that n-1 = d * 2^r r, d = 0, n - 1 while d % 2 == 0: r += 1 d //= 2 def is_composite(a): x = pow(a, d, n) if x == 1 or x == n - 1: return False for _ in range(r - 1): x = pow(x, 2, n) if x == n - 1: return False return True witnesses = [] for _ in range(k): a = random.randint(2, n - 2) witnesses.append(a) if is_composite(a): return (False, witnesses) return (True, witnesses)"},{"question":"# Question: Implement an Enhanced Insertion Sort Given an array of integers, implement an enhanced insertion sort algorithm that not only sorts the array but also detects and returns the number of swaps performed to sort the array. The algorithm should include an optimization to early exit if the array becomes sorted during the process, significantly improving performance for nearly sorted arrays. Function Signature ```python def enhanced_insertion_sort(arr: List[int]) -> Tuple[List[int], int]: ``` Input - A list of integers, `arr` (0 ≤ len(arr) ≤ 1000 and -10^9 ≤ arr[i] ≤ 10^9). Output - A tuple containing: - The sorted list of integers. - An integer representing the number of swaps performed to sort the array. Constraints - The algorithm should use in-place sorting, i.e., it should not use additional memory proportional to the input size. Performance Requirements - The function should strive to minimize the number of swaps and iterations, particularly for nearly sorted arrays. # Examples Example 1: ```python Input: [4, 3, 2, 1] Output: ([1, 2, 3, 4], 6) Explanation: The array is sorted in a total of 6 swaps. ``` Example 2: ```python Input: [1, 2, 3, 4, 5] Output: ([1, 2, 3, 4, 5], 0) Explanation: The array is already sorted, so no swaps are performed. ``` # Additional Notes - For an array that is already sorted, the algorithm should complete in O(n) time. - Consider using an early termination check if no swaps were made during a complete pass of the array.","solution":"from typing import List, Tuple def enhanced_insertion_sort(arr: List[int]) -> Tuple[List[int], int]: n = len(arr) if n == 0: return (arr, 0) swaps = 0 for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 swaps += 1 arr[j + 1] = key return (arr, swaps)"},{"question":"You are tasked with writing a function to filter words that can be typed using letters from only one row on a QWERTY keyboard. Given a list of words, return the words that can be typed using letters of one row exclusively. The keyboard rows are defined as follows: 1. Top Row: \\"qwertyuiop\\" 2. Middle Row: \\"asdfghjkl\\" 3. Bottom Row: \\"zxcvbnm\\" # Function Signature ```python def find_keyboard_row(words): :type words: List[str] :rtype: List[str] ``` # Input - `words`: List of strings with length n, each string consists of lowercase and uppercase English letters. # Output - List of strings containing the words that can be typed using just one row of the keyboard. # Constraints - The input words list should contain at most 10^4 words. - The length of each word should be between 1 and 20. # Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` # Additional Notes - Ensure that your function handles different cases (upper and lower) correctly by converting the words to a uniform case for the set operations. - Consider performance in terms of both time and space complexities.","solution":"def find_keyboard_row(words): Returns the words that can be typed using letters from only one row of a QWERTY keyboard. top_row = set(\\"qwertyuiop\\") middle_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") def can_be_typed(word, row_set): return all(char in row_set for char in word) result = [] for word in words: lower_word = word.lower() if can_be_typed(lower_word, top_row) or can_be_typed(lower_word, middle_row) or can_be_typed(lower_word, bottom_row): result.append(word) return result"},{"question":"Suppose you are working with hierarchical data representing organizational roles and tasks. The data is structured in a nested dictionary, where each manager has a list of employees/tasks, and this can also follow for sub-tasks or further subordinates. Design and implement a function `tree_search(tree, target)` that takes in a nested dictionary (`tree`) and a target string (`target`). The function should search the tree hierarchically and return a boolean indicating if the target string is found at any level in the tree. The search should be case-insensitive. Input: - `tree`: A dictionary where keys are strings and values are lists of strings or integers. - `target`: A string representing the target element to search within the tree. Output: - A boolean (`True` or `False`) indicating whether the target string is found in the tree. Constraints: - The tree structure may contain mixed types (strings and integers) within the lists. - The search should be case-insensitive, so \\"adam\\" and \\"Adam\\" should be considered equivalent. - You should not modify the original tree in any form. Example: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } # Example Function Call print(tree_search(tree, \'sports\')) # Output: True print(tree_search(tree, \'science\')) # Output: False ``` Additional Notes: - Ensure that your function handles nested structures properly. - Focus on efficient traversal and minimizing unnecessary computations.","solution":"def tree_search(tree, target): Recursively searches through a nested dictionary to find the target string. Args: tree (dict): The nested dictionary representing the organizational roles and tasks. target (str): The target string to search within the tree. Returns: bool: True if the target string is found, False otherwise. target = target.lower() # Case-insensitive search def search_subtree(subtree): if isinstance(subtree, dict): for key in subtree: if search_subtree(subtree[key]): return True elif isinstance(subtree, list): for item in subtree: if isinstance(item, str) and item.lower() == target: return True elif isinstance(item, (dict, list)): if search_subtree(item): return True return False return search_subtree(tree)"},{"question":"You are given a class definition for an undirected graph node and its shallow copy method. This node has a label and a list of neighbors. Your task is to write a function to clone this graph using recursive, iterative depth-first search (DFS), and breadth-first search (BFS). You must implement the BFS version. The function should take a node of the graph and return a new deep cloned graph. # Function Signature ```python def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Input * `node` (UndirectedGraphNode): This is the entry node of the graph that you need to clone. # Output * Returns (UndirectedGraphNode): The root node of the cloned graph. # Constraints * Node labels are unique. * A graph can contain cycles. * The graph might have a self-loop. # Example ```python # Example to illustrate the structure of the graph nodes node = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node.neighbors = [node1, node2] node1.neighbors = [node] node2.neighbors = [node, node2] cloned_graph = clone_graph_bfs(node) # Validate through DF/BFS traversal that cloned_graph is an exact independent copy of the original node graph ``` # Explanation 1. Initialization of the clone should only start with the input node. 2. Use BFS for graph traversal and for cloning each node only once. 3. Maintain a mapping of original nodes to their clones for reference.","solution":"class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None from collections import deque # Dictionary to save the cloned nodes. node_map = {node: UndirectedGraphNode(node.label)} # Queue to perform BFS. queue = deque([node]) while queue: current_node = queue.popleft() for neighbor in current_node.neighbors: if neighbor not in node_map: # Clone and add new neighbor node to the map node_map[neighbor] = UndirectedGraphNode(neighbor.label) queue.append(neighbor) # Assign neighbors to the clones node_map[current_node].neighbors.append(node_map[neighbor]) # Return the clone of the initial node return node_map[node]"},{"question":"You are given the task of implementing the factorial calculation for a number `n`. You should provide two methods: one using an iterative approach and the other using a recursive approach. Both methods should also support an optional parameter to return the factorial modulo `mod`, if provided. # Function Signatures: ```python def factorial_iter(n: int, mod: int = None) -> int: pass def factorial_recur(n: int, mod: int = None) -> int: pass ``` # Constraints: - `n` will be a non-negative integer (0 <= n <= 10^4). - `mod` will be an optional positive integer if provided. # Requirements: 1. **Iterative Method (`factorial_iter`)**: * Calculate the factorial of `n` iteratively. * If `mod` is provided, return `(n! % mod)`. 2. **Recursive Method (`factorial_recur`)**: * Calculate the factorial of `n` recursively. * If `mod` is provided, return `(n! % mod)`. # Edge Cases: - When `n` is 0, both methods should return 1. - If the `mod` is provided, it should be a positive integer. - Ensure your functions handle large values efficiently considering computational and space constraints. # Examples: ```python factorial_iter(5) # Output: 120 factorial_iter(5, 3) # Output: 0 (since 120 % 3 == 0) factorial_recur(5) # Output: 120 factorial_recur(5, 3) # Output: 0 (since 120 % 3 == 0) factorial_iter(0) # Output: 1 factorial_recur(0, 1000) # Output: 1 ``` Ensure that your solution is optimized for performance and handles the provided constraints effectively.","solution":"def factorial_iter(n: int, mod: int = None) -> int: result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result def factorial_recur(n: int, mod: int = None, result: int = 1) -> int: if n == 0: return result % mod if mod else result new_result = result * n if mod: new_result %= mod return factorial_recur(n - 1, mod, new_result)"},{"question":"# Postorder Traversal of a Binary Tree You are tasked with implementing the postorder traversal of a binary tree without using recursion. Implement a function named `postorder_iterative` that takes the root of a binary tree and returns a list of node values in postorder. Function Signature ```python def postorder_iterative(root: Node) -> List[int]: ``` Input - `root`: The root node of a binary tree, which may be `None` (representing an empty tree). Each node has the following structure: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Output - Return a list of integers representing the tree\'s nodes in postorder. Constraints - The number of nodes in the tree will not exceed 10,000. - Node values will be integers in the range `[-10^5, 10^5]`. Example Input Tree: ``` 1 / 2 3 / 4 5 ``` Postorder Traversal (left-right-root): `[4, 5, 2, 3, 1]` ```python # For the above tree, the function result = postorder_iterative(tree_root) # should return: print(result) # Output: [4, 5, 2, 3, 1] ``` Performance Requirements - The implementation should use O(n) time complexity. - The space complexity should be O(n) considering worst-case scenarios. Scenario Consider a binary tree where each node represents a directory in a file system. The postorder traversal would help in scenarios like deleting a directory along with its subdirectories or evaluating space usage. Implement the above function to assist with such operations programmatically.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> list: Returns the postorder traversal of a binary tree using iterative approach. if root is None: return [] stack, result = [], [] while stack or root: if root: stack.append(root) result.append(root.val) root = root.right else: node = stack.pop() root = node.left return result[::-1]"},{"question":"# Knapsack Problem with Resource Constraints You are tasked with solving the knapsack problem with a slight twist. # Background A courier company needs to determine the maximum profit they can achieve given the capacity of their delivery truck and the items (packages) they can carry. Each package has a weight and a value associated with it, and the goal is to maximize the total value of the packages in the truck without exceeding the truck\'s weight capacity. # Problem Specification **Function Signature:** ```python def get_max_profit(items: List[Tuple[int, int]], capacity: int) -> int: ``` **Input Format:** - `items`: A list of tuples where each tuple contains two integers, `value` and `weight`, representing the value and weight of each item, respectively. - `capacity`: An integer representing the maximum weight capacity of the truck. **Output Format:** - Returns an integer representing the maximum value that can be achieved without exceeding the weight capacity. **Constraints:** - 1 <= len(items) <= 1000 - 1 <= value, weight, capacity <= 1000 # Example Given the following items and capacity: - `capacity = 5` - `items = [(60, 5), (50, 3), (70, 4), (30, 2)]` The function should return `80`, as the optimal selection would be the items valued at 50 and 30 with a combined weight of 5. # Edge Cases to Consider - If the capacity is zero, the result should also be zero. - Items with zero weight or value should be properly handled. - If all items are too heavy to fit in the knapsack, the result should be zero. **Task:** Implement the `get_max_profit` function to solve the knapsack problem based on dynamic programming principles.","solution":"from typing import List, Tuple def get_max_profit(items: List[Tuple[int, int]], capacity: int) -> int: This function solves the knapsack problem using dynamic programming. Given a list of items represented as (value, weight) and a maximum capacity, it returns the maximum value that can be achieved without exceeding the capacity. # Create a list to store the maximum profit for each capacity dp = [0] * (capacity + 1) # Iterate over all items for value, weight in items: # Iterate over the capacities in reverse for cap in range(capacity, weight - 1, -1): dp[cap] = max(dp[cap], dp[cap - weight] + value) return dp[capacity]"},{"question":"# Challenging Coding Assessment Question Objective Write a function that removes duplicate nodes from a singly linked list but must maintain the overall relative order of nodes. Input Format - A pointer to the head node of a singly linked list, where each node contains an integer value. Output Format - A modified linked list where all duplicate values are removed, keeping all unique elements. Constraints - Consider that nodes contain only non-negative integers. - You are not allowed to use any data structures with significant extra space, such as an additional hash set or list. Performance Requirements - Aim for a solution with linear time complexity O(N) and constant space complexity O(1), if possible. Example For the given linked list: 1 -> 2 -> 3 -> 2 -> 4 -> 3 Your function should modify the list to: 1 -> 2 -> 3 -> 4 # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicate_nodes(head: ListNode) -> ListNode: # Your implementation here pass ``` # Implementation Hints - You may want to use a nested loop to compare each node with every other subsequent node. - Ensure that you carefully handle the deletion of nodes to maintain the relative order. # Testing Your Solution To test your function, you can create linked list nodes and call `remove_duplicate_nodes` with the head node. Print the resulting linked list to verify duplicates are removed.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicate_nodes(head: ListNode) -> ListNode: Removes duplicates from a linked list while maintaining the order of the nodes. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head"},{"question":"Background You work as a software engineer at a company that develops tools for mathematical computations, and you need to implement a utility that computes the greatest common divisor (GCD) using Euclid\'s Algorithm and the least common multiple (LCM) of two integers. Given two non-negative integers `a` and `b`, some of your mathematical tools rely on accurate calculations of GCD and LCM for various functionalities within the software. Task Implement the following two functions in Python: 1. **`gcd(a: int, b: int) -> int`**: Computes the greatest common divisor of integers `a` and `b` using Euclid\'s Algorithm. 2. **`lcm(a: int, b: int) -> int`**: Computes the least common multiple of integers `a` and `b` using the relationship between GCD and LCM. Function Signatures - `def gcd(a: int, b: int) -> int` - `def lcm(a: int, b: int) -> int` Input Constraints - Both `a` and `b` are non-negative integers. - 1 ≤ a, b ≤ 10^9 Expected Output 1. `gcd(a, b)` should return an integer value representing the greatest common divisor of `a` and `b`. 2. `lcm(a, b)` should return an integer value representing the least common multiple of `a` and `b`. Examples 1. `gcd(48, 18)` should return `6` 2. `lcm(48, 18)` should return `144` Notes - Handle edge cases such as one of the inputs being zero. - Ensure to use the Euclidean approach for GCD calculation and derive the LCM accordingly. Performance Requirements The functions must run efficiently within the constraints provided, considering that the inputs can be as large as 10^9.","solution":"def gcd(a: int, b: int) -> int: Computes the greatest common divisor (GCD) of two integers using Euclid\'s Algorithm. while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Computes the least common multiple (LCM) of two integers using the relationship between GCD and LCM. if a == 0 or b == 0: return 0 return (a * b) // gcd(a, b)"},{"question":"Tree Height Calculation # Problem Statement Given the root of a binary tree, write a function `calculate_tree_height(root)` that calculates and returns the height of the tree. The height is defined as the number of levels from root to the deepest leaf. # Input and Output Formats * **Input**: The function receives the parameter `root` which is the root node of the binary tree. * **Output**: The function should return an integer representing the height of the tree. # Constraints * The value of the nodes is not important for calculating the height. * The tree can be empty (i.e., `root` can be None), in which case the height is 0. * The tree can have varying numbers of nodes and levels. # Performance Requirements * Your function should have a time complexity of O(n), where n is the number of nodes in the tree. * Space complexity should be O(h), where h is the height of the tree. # Example Consider the following binary tree as input: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The function should return 4, as the longest path from root to leaf has 4 nodes. # Function Signature ```python class Node: def __init__(self, value): self.value = value self.left = None self.right = None def calculate_tree_height(root): # Your code here ``` # Notes * The class `Node` is provided for defining the structure of a tree node. # Testing Use the following unittest framework to test your implementation: ```python import unittest class TestSuite(unittest.TestCase): def setUp(self): self.tree = Node(9) self.tree.left = Node(6) self.tree.right = Node(12) self.tree.left.left = Node(3) self.tree.left.right = Node(8) self.tree.left.right.left = Node(7) self.tree.right.left = Node(10) self.tree.right.right = Node(15) self.tree.right.right.right = Node(18) def test_calculate_tree_height(self): self.assertEqual(4, calculate_tree_height(self.tree)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def calculate_tree_height(root): Calculate the height of the binary tree. :param root: TreeNode, root of the binary tree. :return: int, height of the tree. if root is None: return 0 else: left_height = calculate_tree_height(root.left) right_height = calculate_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Moving Average Calculation Objective You are tasked to implement a class `MovingAverage`, which calculates the moving average of the last `size` values of a stream of integers. # Requirements * **Class Name**: `MovingAverage` * **Method**: `def next(self, val: int) -> float` # Functionality * Your class should initialize with: - An integer `size`, which determines the number of latest integers to compute the moving average. - A method `next` that adds a new integer to the moving average calculation and returns the updated average as a float. * The method should handle: - Continuous stream of integers. - Accurate moving average calculation based on the last `size` integers. - Handling of edge cases where fewer than `size` integers have been received. # Constraints * The integer values are guaranteed to be within the range `[-1000, 1000]`. * `next` method will be called at least once. # Example ```python # Example usage: m = MovingAverage(3) print(m.next(1)) # Output: 1.0 (since the only number is 1) print(m.next(10)) # Output: 5.5 (since the average of [1, 10] is (1+10)/2) print(m.next(3)) # Output: 4.67 (since the average of [1, 10, 3] is (1+10+3)/3) print(m.next(5)) # Output: 6.0 (since the average of [10, 3, 5] is (10+3+5)/3) ``` # Notes * You may use Python\'s `deque` from the `collections` module for the implementation to ensure efficient operations. * Ensure your implementation handles cases where the received integers are fewer than the window size.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize your data structure here. self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: self.window.append(val) self.window_sum += val if len(self.window) > self.size: self.window_sum -= self.window.popleft() return self.window_sum / len(self.window)"},{"question":"In mechanical engineering, certain designs use cylindrical symmetry such that the components appear the same from various angles, specifically 180 degrees. Implement a function to verify strobogrammatic symmetry properties in digital readouts (comprising numbers). Task Write a function `is_strobogrammatic(num: str) -> bool` that determines whether a given number is strobogrammatic. The input number is represented as a string of digits. Input * `num` (str): A string representing the number (1 ≤ len(num) ≤ 10^4) Output * `bool`: Return `True` if the number is strobogrammatic, `False` otherwise. Constraints * You may assume the input consists only of numeric digits. * The length of num will be at least 1 and no more than 10,000 digits. Examples Example 1: ``` Input: \\"69\\" Output: True Explanation: The number 69 rotated 180 degrees is still 69. ``` Example 2: ``` Input: \\"88\\" Output: True Explanation: The number 88 rotated 180 degrees is still 88. ``` Example 3: ``` Input: \\"962\\" Output: False Explanation: The number 962 rotated 180 degrees is not the same. ``` # Note 1. Your solution should handle large inputs up to the order of magnitude mentioned efficiently. 2. Make sure to check both small and large edge cases. 3. Maintain clean and readable code, focusing on logical verification of strobogrammatic property using appropriate data structures or string operations.","solution":"def is_strobogrammatic(num): Determines whether a given number is strobogrammatic. A number is strobogrammatic if it looks the same when rotated 180 degrees. Args: num (str): A string representing the number. Returns: bool: True if the number is strobogrammatic, False otherwise. # Valid strobogrammatic pairs strobogrammatic_pairs = { \'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\' } left, right = 0, len(num) - 1 while left <= right: if num[left] not in strobogrammatic_pairs or num[right] not in strobogrammatic_pairs: return False if strobogrammatic_pairs[num[left]] != num[right]: return False left += 1 right -= 1 return True"},{"question":"# Integer Partitioning You have been tasked to determine the number of ways an integer `n` can be partitioned into sums of smaller positive integers. This process of breakdown is known as integer partitioning. Implement the dynamic programming algorithm to compute the number of such partitions. Function Signature ```python def int_partition(n: int) -> int: ``` # Input - `n` (integer, 1 <= n <= 100): Positive integer to be partitioned. # Output - An integer representing the number of partitions for the given integer `n`. # Constraints - 1 <= n <= 100 # Examples **Example 1:** ```plaintext Input: 4 Output: 5 Explanation: 4 can be partitioned as follows: 4=4 4=3+1 4=2+2 4=2+1+1 4=1+1+1+1 ``` **Example 2:** ```plaintext Input: 7 Output: 15 Explanation: 7 can be partitioned as follows: 7=7 7=6+1 7=5+2 7=5+1+1 7=4+3 7=4+2+1 7=4+1+1+1 7=3+3+1 7=3+2+2 7=3+2+1+1 7=3+1+1+1+1 7=2+2+2+1 7=2+2+1+1+1 7=2+1+1+1+1+1 7=1+1+1+1+1+1+1 ``` **Example 3:** ```plaintext Input: 1 Output: 1 Explanation: 1 can only be partitioned as 1 itself. ``` # Notes - Focus on implementing an efficient dynamic programming solution. - Take into consideration space optimization techniques if possible.","solution":"def int_partition(n: int) -> int: Given a positive integer n, returns the number of ways to partition n. # Table to store results of subproblems dp = [0] * (n + 1) dp[0] = 1 # base case # Fill the table for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"**Scenario**: You are given two DNA sequences represented as strings that consist of lowercase letters. Your task is to determine the length of the longest common subsequence (LCS) between these two sequences. The LCS is the longest sequence that can be derived from both strings by deleting some (or no) characters without changing the order of the remaining characters. **Task**: Implement a function `find_lcs_length(dna1, dna2)` that takes two string inputs and returns an integer representing the length of their LCS. Function Signature ```python def find_lcs_length(dna1: str, dna2: str) -> int: pass ``` Input * `dna1`: A string of length M, where 1 ≤ M ≤ 1000. * `dna2`: A string of length N, where 1 ≤ N ≤ 1000. Output * An integer representing the length of the longest common subsequence. Constraints * The input strings are guaranteed to only contain lowercase alphabets. Example ```python # Example 1 dna1 = \'aggtab\' dna2 = \'gxtxayb\' print(find_lcs_length(dna1, dna2)) # Output: 4 # Explanation: The LCS is \'gtab\', which has length 4. # Example 2 dna1 = \'abcdgh\' dna2 = \'aedfhr\' print(find_lcs_length(dna1, dna2)) # Output: 3 # Explanation: The LCS is \'adh\', which has length 3. ``` **Hints**: 1. Use dynamic programming to break the problem into simpler subproblems. 2. Create a 2D table to store intermediate results for substrings of `dna1` and `dna2`.","solution":"def find_lcs_length(dna1: str, dna2: str) -> int: Function to find the length of longest common subsequence (LCS) between two DNA sequences. :param dna1: string, first DNA sequence :param dna2: string, second DNA sequence :return: int, length of the longest common subsequence m = len(dna1) n = len(dna2) # Create a 2D list (m+1) x (n+1) to store lengths of longest common subsequence. lcs_table = [[0] * (n + 1) for _ in range(m + 1)] # Build the table in bottom-up fashion for i in range(1, m + 1): for j in range(1, n + 1): if dna1[i - 1] == dna2[j - 1]: lcs_table[i][j] = lcs_table[i - 1][j - 1] + 1 else: lcs_table[i][j] = max(lcs_table[i - 1][j], lcs_table[i][j - 1]) # The length of LCS is the bottom right element of the table return lcs_table[m][n]"},{"question":"You are given a graph represented as a dictionary where keys are node identifiers and values are lists of neighboring nodes. Your task is to implement a function to find the shortest path by using a Breadth-First Search (BFS) algorithm to improve the performance for this specific case. # Function Signature ```python def bfs_shortest_path(graph: dict, start: str, end: str) -> list: pass ``` # Input * `graph` (dictionary): Represents the graph, keys are nodes, and values are lists of neighboring nodes. * `start` (string): The starting node. * `end` (string): The destination node. # Output * A list representing the shortest path from `start` to `end`. If no path is found, return an empty list. # Constraints * Assume that `start` and `end` are valid keys in the graph. * The graph is unweighted. * There may not be a path between `start` and `end`. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(bfs_shortest_path(graph, \'A\', \'F\')) # Output should be: [\'A\', \'C\', \'F\'] ``` # Notes * Use a queue to manage the BFS exploration process. * Keep track of visited nodes to avoid cycles. * Maintain a path dictionary to reconstruct the path once the end node is reached.","solution":"from collections import deque def bfs_shortest_path(graph: dict, start: str, end: str) -> list: Use BFS to find the shortest path in an unweighted graph from start to end. Args: graph (dict): Graph represented as an adjacency list. start (str): The starting node. end (str): The destination node. Returns: list: The shortest path from start to end. If no path exists, returns an empty list. if start == end: return [start] queue = deque([[start]]) visited = set() while queue: path = queue.popleft() node = path[-1] if node in visited: continue for neighbor in graph.get(node, []): new_path = list(path) new_path.append(neighbor) if neighbor == end: return new_path queue.append(new_path) visited.add(node) return []"},{"question":"Given the following `OrderedStack` class that maintains stack elements in sorted order with the highest value at the top and the lowest at the bottom, you are required to extend the functionality by implementing additional methods. # Task 1. **Implement a method `find_min` that returns the minimum element of the stack without removing any element.** If the stack is empty, the method should raise an `IndexError` with the message `\\"Stack is empty\\"`. 2. **Implement a method `sorted_elements` that returns a list of elements in the stack in ascending order.** This should not alter the stack\'s order. If the stack is empty, it should return an empty list. # Requirements - Do not use any built-in sorting functions. - Ensure the existing functionality of `OrderedStack` is preserved. # Input/Output - **find_min**: Should have constant time complexity O(1). - **sorted_elements**: Should have linear time complexity O(n). # Sample Implementation ```python class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self is_empty() or item > self.peek(): self.push_t(item) else: while item < self.peek() and not self.is_empty(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): return self.items[len(self.items) - 1] def size(self): return len(self.items) # Implement find_min def find_min(self): pass # Implement sorted_elements def sorted_elements(self): pass ``` # Example Usage ```python stack = OrderedStack() stack.push(30) stack.push(10) stack.push(20) print(stack.sorted_elements()) # Output: [10, 20, 30] print(stack.find_min()) # Output: 10 stack.pop() print(stack.find_min()) # Output: 10 stack.pop() print(stack.find_min()) # Output: 30 stack.pop() # stack.find_min() should raise an IndexError with the message \\"Stack is empty\\" ``` # Constraints - Can assume only numeric values will be used. - No built-in sorting functions allowed.","solution":"class OrderedStack: def __init__(self): self.items = [] def is_empty(self): return self.items == [] def push_t(self, item): self.items.append(item) def push(self, item): temp_stack = OrderedStack() if self.is_empty() or item >= self.peek(): self.push_t(item) else: while not self.is_empty() and item < self.peek(): temp_stack.push_t(self.pop()) self.push_t(item) while not temp_stack.is_empty(): self.push_t(temp_stack.pop()) def pop(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items.pop() def peek(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[-1] def size(self): return len(self.items) def find_min(self): if self.is_empty(): raise IndexError(\\"Stack is empty\\") return self.items[0] def sorted_elements(self): return self.items[:]"},{"question":"# Question: Encoding and Decoding of Strings You are required to implement an encoding-decoding algorithm using string manipulation techniques. Your task is to write two functions, `encode` and `decode`, to fulfill the following requirements: 1. The `encode` function should take a list of strings and return a single string that represents the encoded form. 2. The `decode` function should take an encoded string and return the original list of strings. Specifications: - **encode(strs: List[str]) -> str**: - **Input**: A list of strings, `strs`. - **Output**: A single encoded string. - **decode(s: str) -> List[str]**: - **Input**: An encoded string, `s`. - **Output**: The original list of strings. Example: ```python # Example 1 strs = [\\"hello\\", \\"world\\"] encoded_str = encode(strs) # encoded_str should be \\"5:hello5:world\\" decoded_list = decode(encoded_str) # decoded_list should be [\\"hello\\", \\"world\\"] # Example 2 strs = [\\"a\\", \\"\\"] encoded_str = encode(strs) # encoded_str should be \\"1:a0:\\" decoded_list = decode(encoded_str) # decoded_list should be [\\"a\\", \\"\\"] ``` Constraints: - Each string in the list contains only lowercase and uppercase alpha characters. - The length of each string is between 0 and 1000. - The total length of all strings does not exceed 10^5. Solution Requirements: - The solution should efficiently handle the constraints while correctly handling all edge cases. - Pay attention to time and space complexity implications.","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings into a single string. Each string is encoded as \'<length>:<string>\'. encoded_str = \'\'.join(f\'{len(s)}:{s}\' for s in strs) return encoded_str def decode(s: str) -> List[str]: Decodes a single string back into a list of strings. decoded_list = [] i = 0 while i < len(s): # Find the position of the \':\' separator colon_pos = s.find(\':\', i) # The length of the string is between the position of i and colon_pos length = int(s[i:colon_pos]) i = colon_pos + 1 # Extract the string based on the obtained length decoded_str = s[i:i + length] decoded_list.append(decoded_str) # Move the index to the end of the extracted string i += length return decoded_list"},{"question":"# Hailstone Sequence Explorations You are tasked with implementing a function to create the hailstone sequence for any given positive integer `n`. **Function Signature**: ```python def custom_hailstone(n: int) -> List[int]: ``` **Input**: - `n`: A positive integer `n` (1 ≤ n ≤ 10^6) **Output**: - A list of integers representing the hailstone sequence starting from `n` and ending with `1`. # Additional Requirements: 1. **Error Handling**: The function should raise a `ValueError` if the input `n` is less than 1. 2. **Performance**: Optimize the function to handle the upper limit efficiently. # Constraints: 1. The input `n` will always be a positive integer. 2. Performance considerations for inputs up to 1,000,000. # Example: ```python print(custom_hailstone(5)) # Expected output: [5, 16, 8, 4, 2, 1] print(custom_hailstone(10)) # Expected output: [10, 5, 16, 8, 4, 2, 1] ``` # Scenario: The mathematician needs an efficient method to generate and analyze hailstone sequences for research, and your optimal implementation will aid in large-scale computational analysis. Make sure to account for performance and possible large intermediate values within the given constraints.","solution":"def custom_hailstone(n: int): Returns the hailstone sequence starting from n and ending with 1. Parameters: n (int): The starting positive integer Returns: List[int]: Hailstone sequence Raises: ValueError: If n is less than 1 if n < 1: raise ValueError(\\"Input must be a positive integer greater than or equal to 1.\\") sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) return sequence"},{"question":"# Path Split Function with Enhanced Error Handling Given a path (either a URL or a filesystem path), write a function that splits the path into two parts: 1. The directory path. 2. The file name. Your function should handle the following requirements: - Support both \'/\' and \'\' as path separators. - Ensure that no part is empty. - Return a tuple with the directory part and the file name part. Function Signature: ```python def enhanced_split(path: str) -> (str, str): pass ``` Input: - `path` (str): A string representing a path, which may be a URL or a filesystem path. Output: - (str, str): A tuple containing the directory path and the file name. Constraints: - The path will always contain at least one separator and one file name. - Assume valid string inputs that represent typical paths or URLs. Example: ```python assert enhanced_split(\'https://algorithms/unix/test.py\') == (\'https://algorithms/unix\', \'test.py\') assert enhanced_split(\'algorithmsunixtest.py\') == (\'algorithmsunix\', \'test.py\') assert enhanced_split(\'C:UsersAdminDocumentsfile.txt\') == (\'C:UsersAdminDocuments\', \'file.txt\') ``` # Notes: - Carefully handle the differences between Unix-like and Windows paths. - If there\'s an inconsistency with the provided path (i.e., using both separators interchangeably), prioritize \'/\' over \'\'.","solution":"def enhanced_split(path: str) -> (str, str): Splits the given path into the directory path and the file name. Supports both Unix-like and Windows paths, ensuring no part is empty. # Normalize path by replacing backslashes with forward slashes normalized_path = path.replace(\'\', \'/\') # Find the last separator last_separator_index = normalized_path.rfind(\'/\') # Ensure there is a file name and directory part if last_separator_index == -1 or last_separator_index == len(path) - 1: raise ValueError(\\"No valid file name or directory part found in the path.\\") # Split the path into directory and file name directory = normalized_path[:last_separator_index] file_name = normalized_path[last_separator_index + 1:] if not directory or not file_name: raise ValueError(\\"No valid file name or directory part found in the path.\\") return directory, file_name"},{"question":"**Scenario**: You are working with a system that processes a series of events, represented as a linked list of timestamps. You must ensure that these events are in chronological order before processing them further. **Task**: Write a function `is_sorted(head)` that checks if the linked list is sorted in non-decreasing order. If the list is empty or consists of a single element, it should return `True`. **Function Signature**: ```python def is_sorted(head): # implementation ``` # Input * The function receives a single parameter: * `head` (`ListNode`): The head of the linked list. Each node is of the class: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Output * The function should return a Boolean: * `True` if the list is sorted in non-decreasing order. * `False` otherwise. # Constraints * The number of nodes in the linked list is in the range `[0, 10^4]`. * `-10^9 <= Node.val <= 10^9`. # Example ```python # Example 1: # Input: [1, 2, 3, 4] # Output: True # Example 2: # Input: [1, 2, -1, 3] # Output: False # Example 3: # Input: [] # Output: True # Example 4: # Input: [5] # Output: True ``` # Performance Requirements * The function should run in O(n) time complexity. * The function should use O(1) extra space.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Checks if the linked list is sorted in non-decreasing order. :param head: The head node of the linked list. :return: True if the linked list is sorted in non-decreasing order, False otherwise. if head is None or head.next is None: return True current = head while current.next is not None: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Scenario You are tasked with updating a library\'s inventory system. The library tracks the number of times each book has been borrowed, and you need to sort this list to determine the least and most popular books. Implement a function that uses the comb sort algorithm to sort this list. # Instructions * **Function to Implement:** `def comb_sort(arr: List[int]) -> List[int]:` * **Input:** A list of integers `arr` representing the number of times books have been borrowed. * **Output:** A sorted list in ascending order. * **Constraints:** * The list can be empty or contain up to 10^6 elements. * Each element in the list is an integer between 0 and 10^4. * **Performance Requirements:** Attempt to minimize the number of comparisons and data movements to avoid performance bottlenecks, especially for larger lists.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the comb sort algorithm. def get_next_gap(gap): # Shrink gap by a shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Coding Assessment Question You are required to write a function to serialize and deserialize a Binary Search Tree (BST). Serialization is the process of converting a tree into a sequential format (e.g., string, list) that can be stored or transmitted, and deserialization is the process of restoring the tree from that format. # Function Signature ```python def serialize(root: Node) -> str: Serializes a BST to a single string. :param root: The root node of the BST. :return: A string representation of the BST. def deserialize(data: str) -> Node: Deserializes a string back to a BST. :param data: The string representation of the BST. :return: The root node of the BST. ``` # Input * **serialize**: - A root node of a BST. * **deserialize**: - A string representing the serialized BST. # Output * **serialize**: - A single string representing the BST. * **deserialize**: - The root node of the deserialized BST. # Examples Given the following BST, ``` 100 / 50 150 / / 25 75 125 175 ``` * Running `serialize(n1)` should return a string, let\'s say `\'100,50,25,null,null,75,null,null,150,125,null,null,175,null,null\'`. * Subsequently, running `deserialize(\'100,50,25,null,null,75,null,null,150,125,null,null,175,null,null\')` should reconstruct the tree and return its root node. # Constraints * The function should handle large BSTs efficiently. * Ensure that the serialized string is as compact as possible without losing any structural information of the BST. * Assume tree values are unique. # Notes 1. Use preorder traversal (Root-Left-Right) for serialization and subsequent deserialization, maintaining the BST properties. 2. `null` or `None` should be used in serialized string to represent absent children. # Hints (Optional) * For the `serialize` function, you can use a delimiter (e.g., comma) to differentiate between nodes. * For the `deserialize` function, a helper function can be used that processes the corresponding preorder sequence and constructs the BST recursively.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def serialize(root: Node) -> str: def pre_order(node: Node): if not node: return [\\"null\\"] return [str(node.val)] + pre_order(node.left) + pre_order(node.right) return \',\'.join(pre_order(root)) def deserialize(data: str) -> Node: def helper(nodes): val = next(nodes) if val == \\"null\\": return None node = Node(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node node_list = iter(data.split(\',\')) return helper(node_list)"},{"question":"# Pattern Matching with Bijection Implement a backtracking solution that checks if a string `str` matches a given pattern `pattern`. The goal is to determine if there is a bijection between characters in `pattern` and non-empty substrings in `string`. Function Signature ```python def pattern_match(pattern, string): :type pattern: str :type string: str :rtype: bool ``` Inputs and Outputs - `input`: (string `pattern`, string `str`) - `output`: (boolean) Example 1. **Input**: pattern = \\"abab\\", str = \\"redblueredblue\\" **Output**: True **Explanation**: The pattern \\"abab\\" matches the string \\"redblueredblue\\" because \'a\' can map to \\"red\\" and \'b\' maps to \\"blue\\". 2. **Input**: pattern = \\"aaaa\\", str = \\"asdasdasdasd\\" **Output**: True **Explanation**: The pattern \\"aaaa\\" matches the string \\"asdasdasdasd\\" because \'a\' maps to \\"asd\\". 3. **Input**: pattern = \\"aabb\\", str = \\"xyzabcxyzabc\\" **Output**: False **Explanation**: The pattern \\"aabb\\" does not match the string \\"xyzabcxyzabc\\" because there is no consistent mapping. Constraints - `pattern` and `str` consist only of lowercase English letters. - The length of `pattern` and `str` is at most 20. Your task is to implement the `pattern_match` function by leveraging a backtracking strategy to validate the bijection between characters in `pattern` and non-empty substrings in `string`. Performance Requirements - The solution should efficiently handle edge cases and be optimized for backtracking scenarios where repetitive calculations can be minimized.","solution":"def pattern_match(pattern, string): def is_match(p, s, p_map, s_map): if not p: return not s p_char = p[0] if p_char in p_map: mapped_str = p_map[p_char] if s.startswith(mapped_str): return is_match(p[1:], s[len(mapped_str):], p_map, s_map) else: return False for i in range(1, len(s) - len(p) + 2): # length of mapped_str should be at least len(pattern) mapped_str = s[:i] if mapped_str in s_map: continue p_map[p_char] = mapped_str s_map[mapped_str] = p_char if is_match(p[1:], s[i:], p_map, s_map): return True del p_map[p_char] del s_map[mapped_str] return False return is_match(pattern, string, {}, {})"},{"question":"# Matrix Inversion Coding Challenge Introduction Matrix inversion is a fundamental concept in linear algebra, where the goal is to find a matrix B that serves as the inverse of a given matrix A. When multiplied by A, matrix B yields the identity matrix. Task Implement a function `invert_matrix(m: List[List[float]]) -> List[List[float]]` that returns the inverse of an n x n matrix. For your solution to be considered correct, it must handle the inversion by calculating minors, cofactors, adjugate, and the determinant. Requirements - Your function must handle matrices of size 2x2 and larger. - Return a special error matrix [[-1]], [[-2]], [[-3]], or [[-4]] for respective error cases: - Non-square matrix: [[-2]] - Empty or 1x1 matrix: [[-3]] - Singular matrix (determinant = 0): [[-4]] - Not a matrix (non-uniform row sizes): [[-1]] Input/Output - **Input:** A list of lists `m`, where each inner list represents a row in the matrix. - **Output:** A list of lists representing the inverse of the given matrix. Constraints - The matrix will contain floating-point numbers. - Size of the matrix (n x n) is guaranteed to be at least 2 x 2 but constrained to n ≤ 10 for performance considerations. Example ```python # Example Matrix (2x2) matrix = [ [2, 5], [1, 3] ] # Expected Output # [ # [3, -5], # [-1, 2] # ] ``` Write your function `invert_matrix` in Python.","solution":"from typing import List def determinant(matrix: List[List[float]], n: int) -> float: if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): submatrix = [[matrix[i][j] for j in range(n) if j != c] for i in range(1, n)] det += ((-1) ** c) * matrix[0][c] * determinant(submatrix, n - 1) return det def get_matrix_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def invert_matrix(m: List[List[float]]) -> List[List[float]]: n = len(m) if n == 0 or len(m[0]) != n: return [[-2]] if n > 1 else [[-3]] try: if not all(len(row) == n for row in m): return [[-1]] det = determinant(m, n) if det == 0: return [[-4]] if n == 2: return [ [m[1][1] / det, -1 * m[0][1] / det], [-1 * m[1][0] / det, m[0][0] / det] ] cofactors = [] for r in range(n): cofactor_row = [] for c in range(n): minor = get_matrix_minor(m, r, c) cofactor = ((-1) ** (r + c)) * determinant(minor, n - 1) cofactor_row.append(cofactor) cofactors.append(cofactor_row) adjugate = [[cofactors[r][c] for r in range(n)] for c in range(n)] inverse = [[adjugate[r][c] / det for c in range(n)] for r in range(n)] return inverse except Exception as e: return [[-1]]"},{"question":"# Longest Common Prefix Implementation Context: You are tasked with building a search engine feature that finds the longest common prefix among a list of search terms to provide suggestions. Efficiently finding this prefix will help in improving the performance of the suggestions engine. Problem Statement: Write a function `find_longest_common_prefix` that identifies the longest common prefix string amongst an array of strings. **Function Signature**: ```python def find_longest_common_prefix(strs: List[str]) -> str: ``` **Input**: - A list of strings `strs` (1 <= len(strs) <= 200, 1 <= len(str) <= 200). - The array may contain strings with lowercase and uppercase letters but no other characters. **Output**: - A string representing the longest common prefix. If no common prefix exists, return an empty string. **Constraints**: - The algorithm should work efficiently, minimizing redundant comparisons. - Consider edge cases like empty arrays, arrays with a single string, or completely different strings. Examples: 1. Example 1: ```plaintext Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" ``` 2. Example 2: ```plaintext Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" Explanation: There is no common prefix among the input strings. ``` Performance Requirements: - The solution should preferably complete within a reasonable time frame for up to 200 strings.","solution":"from typing import List def find_longest_common_prefix(strs: List[str]) -> str: Returns the longest common prefix among the list of strings. If there is no common prefix, returns an empty string. if not strs: return \\"\\" # Start from the prefix being the first string prefix = strs[0] # Iterate through each string in the list for string in strs[1:]: while string[:len(prefix)] != prefix: # Reduce the prefix by one character from the end prefix = prefix[:-1] # If the prefix is empty, no common prefix exists if not prefix: return \\"\\" return prefix"},{"question":"You are required to implement a function `count_digits(number: int) -> int` that determines the number of digits in the given integer. # Input: - An integer `number` in the range of `-10^18` to `10^18`. # Output: - An integer representing the number of digits in the input number. # Constraints: - The input can be negative, zero, or positive. # Examples: 1. `count_digits(12345)` should return `5` 2. `count_digits(-987654321)` should return `9` 3. `count_digits(0)` should return `1` # Function Signature: ```python def count_digits(number: int) -> int: pass ``` Notes: - You must not use string conversions to determine the count of digits. - Consider edge cases including zero and negative numbers.","solution":"def count_digits(number: int) -> int: Returns the number of digits in the given integer. :param number: The integer to count digits of. :return: The count of digits in the integer. if number == 0: return 1 count = 0 number = abs(number) while number > 0: number //= 10 count += 1 return count"},{"question":"# Maximum Flow Network Problem with Hidden Nodes You are tasked with designing a flow network where each node represents a server, and each edge represents a direct connection between two servers with specific bandwidth limits. Given an adjacency matrix of a flow network where `graph[i][j]` represents the capacity of the connection from server `i` to server `j`. Your goal is to calculate the maximum possible flow from the source server (node 0) to the sink server (the last node). # Function Signature ```python def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: pass ``` # Input * `adjacency_matrix`: A 2D list where `adjacency_matrix[i][j]` is a non-negative integer representing the capacity from node `i` to node `j`. # Output * An integer representing the maximum flow from the source (node 0) to the sink (last node). # Constraints * The graph is a square matrix with dimensions N x N where 1 <= N <= 100. * Capacities are non-negative integers less than or equal to 1,000. # Example Given the following adjacency matrix representing a flow network: ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] ``` The output should be: ```python 23 ``` # Scenario Imagine you are networking an office building and need to facilitate the highest possible data throughput from the main server (source) in the control room to the backup server (sink) in the IT room. Use the given algorithm to determine the maximum data flow that the network can support between these two servers.","solution":"from typing import List def bfs(graph: List[List[int]], s: int, t: int, parent: List[int]) -> bool: visited = [False] * len(graph) queue = [] queue.append(s) visited[s] = True while queue: u = queue.pop(0) for ind, val in enumerate(graph[u]): if visited[ind] == False and val > 0: queue.append(ind) visited[ind] = True parent[ind] = u if ind == t: return True return False def maximum_flow_bfs(adjacency_matrix: List[List[int]]) -> int: source = 0 sink = len(adjacency_matrix) - 1 parent = [-1] * len(adjacency_matrix) max_flow = 0 while bfs(adjacency_matrix, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, adjacency_matrix[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] adjacency_matrix[u][v] -= path_flow adjacency_matrix[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Graph Cycle Detection Challenge Background In software systems, detecting cycles in a directed graph is essential for preventing issues like deadlocks. Imagine you\'re developing a system that manages resources for processes. To ensure there are no deadlocks, you need an algorithm to determine if there are any cycles in the resource allocation graph. Task Write a function `detect_cycle(graph: Dict[str, List[str]]) -> bool` that determines if a given directed graph contains a cycle. Input - `graph`: A dictionary representing the directed graph where keys are the vertices (processes), and values are lists of adjacent vertices (dependencies). Output - Return `True` if the graph contains a cycle; `False` otherwise. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle(graph)) # Should return True ``` Constraints - The graph will have a maximum of 10^4 vertices and 10^5 edges. Requirements - Efficient detection with O(V + E) time complexity. - Handle all edge cases, such as self-loops and disconnected components.","solution":"def detect_cycle(graph): Detects if there is a cycle in the given directed graph. :param graph: Dictionary representing the directed graph with vertices as keys and the list of adjacent vertices as values. :return: True if the graph contains a cycle, otherwise False. def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for vertex in graph.keys(): if vertex not in visited: if dfs(vertex): return True return False"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: The algorithm presented is a recursive search within a Binary Search Tree (BST). The primary aim is to locate the value in the BST that is closest to a given target value. * **Complexity**: - **Time Complexity**: O(h), where h is the height of the tree. In the worst case, especially for unbalanced trees, this could be O(n), where n is the number of nodes in the tree. - **Space Complexity**: O(h) due to the recursion stack, with a worst-case of O(n) for completely unbalanced trees. * **Principles**: - BST properties ensure that for any given node: - All values in the left subtree are smaller. - All values in the right subtree are larger. - The algorithm recursively navigates the tree based on comparing the target value with the current node value. # Characteristics & Applications * **Properties**: The algorithm uses the inherent properties of BST for an efficient search. It approximates the closest node by comparing and recursively calling function on child nodes until leaf nodes are reached. * **Common Use Cases**: - Situations where approximations are needed, such as in nearest neighbor searches. - Applications requiring closest value retrieval, like rounding values within a set or value mapping tasks. * **Strengths/Limitations**: - **Strengths**: Efficient search in a balanced BST and reduced time complexity compared to a full linear search. - **Limitations**: Decreased performance for unbalanced trees; improvements in balanced trees, AVL trees, or Red-Black trees mitigate this issue. # Implementation Challenges * **Edge Cases**: - Empty tree (though the problem statement mentions the tree is non-empty). - Trees where all values are either significantly smaller or larger than the target. * **Performance Bottlenecks**: - Depth of the tree affecting recursion depth. * **Error Scenarios**: Incorrect handling of pointers or base cases leading to infinite recursion or return of incorrect values. * **Optimization Points**: - Avoiding unnecessary recursive calls. - Implementing iterative solutions to manage memory overhead due to recursive calls. <|Analysis End|> <|Question Begin|> # Closest Value in a Binary Search Tree You are given a non-empty Binary Search Tree (BST) and a target value as a floating point number. Write a function to find the value in the BST that is closest to the given target value. Function Signature: ```python def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int ``` Input: - `root`: a TreeNode which represents the root of the BST. TreeNode is defined as: ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None ``` - `target`: a floating point number representing the target value. Output: - Returns an integer representing the value in the BST that is closest to the target value. # Constraints: - The BST is guaranteed to be non-empty. - There will be only one unique value in the BST that is closest to the target. # Example: Consider the following BST: ``` 4 / 2 5 / 1 3 ``` If given `target = 3.714286`, the function should return `4`. # Additional Notes: - Ensure that edge cases like minimum and maximum tree values that are significantly different from the target are handled appropriately. - Optimize the solution to handle large trees efficiently in terms of both time and space complexity. Implement the function `closest_value` considering the challenges discussed above.","solution":"class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def closest_value(root, target): Returns the value in the BST that is closest to the target. :type root: TreeNode :type target: float :rtype: int def closest(node, target, closest_val): if node is None: return closest_val if abs(node.val - target) < abs(closest_val - target): closest_val = node.val if target < node.val: return closest(node.left, target, closest_val) else: return closest(node.right, target, closest_val) return closest(root, target, root.val)"},{"question":"In this exercise, you are required to implement Bubble Sort and modify it to handle a unique edge case: sorting a nearly sorted list where only two elements are out of place. # Task Write a function `custom_bubble_sort` that sorts a given list using Bubble Sort. Your modified Bubble Sort should be optimized to detect if the list is nearly sorted with at most two elements out of their correct places and handle this case efficiently without performing unnecessary comparisons. # Function Signature ```python def custom_bubble_sort(arr: List[int], simulation: bool=False) -> List[int]: ``` # Input - `arr`: A list of integers. - `simulation`: A boolean flag indicating whether to print the state of the list after each iteration. Defaults to `False`. # Output - Returns a list of integers sorted in non-decreasing order. # Examples ```python print(custom_bubble_sort([3, 2, 1])) # Output: [1, 2, 3] print(custom_bubble_sort([1, 2, 5, 4, 3])) # Output: [1, 2, 3, 4, 5] print(custom_bubble_sort([1, 3, 2, 4, 5], simulation=True)) # Output: # iteration 1 : 1 2 3 4 5 # [1, 2, 3, 4, 5] ``` # Constraints - The input list contains `n` integers, where 0 <= n <= 1000. - The values of the integers are between -10^6 and 10^6. - List may contain duplicated elements. - Could assume the list may be nearly sorted, i.e., at most two elements are out of place. # Notes - Your function should be optimal for the nearly sorted case, reducing unnecessary comparisons. - If the `simulation` flag is set to `True`, print the list after each iteration.","solution":"from typing import List def custom_bubble_sort(arr: List[int], simulation: bool=False) -> List[int]: n = len(arr) if n <= 1: return arr swapped = True iteration = 0 while swapped: swapped = False for i in range(1, n): if arr[i-1] > arr[i]: arr[i-1], arr[i] = arr[i], arr[i-1] swapped = True if simulation: iteration += 1 print(f\'iteration {iteration} : {\\" \\".join(map(str, arr))}\') # If no elements were swapped, the array is sorted if not swapped: break # Move the boundary of the unsorted subarray n -= 1 return arr"},{"question":"Given an integer range from `low` to `high`, write a function that returns a list of all the numbers in the range `[low, high]` where the sum of its digits, raised to the power of their respective positions, equals the number itself. # Function Signature ```python def sum_dig_pow(low: int, high: int) -> list: pass ``` # Input Format * `low`: An integer representing the lower bound of the range (inclusive). (1 ≤ low ≤ 10^5) * `high`: An integer representing the upper bound of the range (inclusive). (low ≤ high ≤ 10^5) # Output Format * Returns a list of integers satisfying the described property. # Constraints * Ensure the function works efficiently even for the maximum input bounds. * Valid numbers should be within the specified range `[low, high]`. # Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(90, 150) == [135] ``` # Notes 1. The function should handle the range [1, 10^5] efficiently. 2. Edge cases such as single-digit ranges and ranges with no valid numbers should be processed correctly. # Scenario Imagine you are in charge of developing a numerical validation feature for a mathematical puzzle game. The feature should help validate numbers within a varying range to ensure they meet a specific property before being accepted as valid inputs in the game. Implement this function to help with this task.","solution":"def sum_dig_pow(low: int, high: int) -> list: Returns a list of numbers in the range [low, high] where the sum of its digits, raised to the power of their respective positions, equals the number itself. def is_valid_number(n): digits = [int(d) for d in str(n)] total = sum(digit ** (index + 1) for index, digit in enumerate(digits)) return total == n return [n for n in range(low, high + 1) if is_valid_number(n)]"},{"question":"# Selection Sort with Custom Comparator Objective: You are given the task of modifying the Selection Sort algorithm to support a custom comparator function. This comparator function will allow sorting based on different criteria, making the algorithm more flexible and applicable to a wider variety of scenarios. Problem Statement: Implement the `selection_sort_custom` function that sorts an array using the Selection Sort algorithm but with the added feature of a custom comparator. The comparator will take two arguments and return a negative value if the first argument should come before the second, zero if they are equal, and a positive value if the first argument should come after the second. Signature: ```python def selection_sort_custom(arr, cmp): ``` Input: * `arr`: a list of elements to be sorted. * `cmp`: a comparator function that takes two elements and returns an integer based on the comparison. Output: * The function should return the sorted array. Constraints: * Elements of `arr` can be of any type as long as the comparator function can handle comparisons between them. * The comparator function will always return an integer. * Sorting should be in-place, i.e., the original array should be modified and returned. Performance Requirements: * Time Complexity: O(n^2) * Space Complexity: O(1) (in-place sorting) Example: ```python def comparator(a, b): return a - b # Example comparator for ascending order arr = [64, 25, 12, 22, 11] sorted_arr = selection_sort_custom(arr, comparator) print(sorted_arr) # Output: [11, 12, 22, 25, 64] ``` Additional Notes: * Consider edge cases such as empty arrays and arrays with duplicate elements. * Ensure that the implementation maintains the general method displayed in the provided Selection Sort snippet but includes the custom comparator.","solution":"def selection_sort_custom(arr, cmp): Sorts an array using the Selection Sort algorithm with a custom comparator. Parameters: arr (list): The list to be sorted. cmp (function): Comparator function taking two elements and returning a negative value if the first argument should come before the second, zero if they are equal, and a positive value if the first argument should come after the second. Returns: list: The sorted list. n = len(arr) for i in range(n): min_idx = i for j in range(i + 1, n): if cmp(arr[j], arr[min_idx]) < 0: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr"},{"question":"Design a Randomized Set Data Structure Design a RandomizedSet data structure that supports the following operations in average O(1) time complexity: 1. **insert(val)**: Inserts an item `val` to the set if not already present. 2. **remove(val)**: Removes an item `val` from the set if present. 3. **random_element()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. # Function Signatures ```python class RandomizedSet: def __init__(self): # Initialize any necessary data structures here. pass def insert(self, val: int) -> bool: # Implement the insertion of val. pass def remove(self, val: int) -> bool: # Implement the removal of val. pass def random_element(self) -> int: # Implement the retrieval of a random element. pass ``` # Input and Output Formats * `insert(val: int) -> bool`: Inserts `val` into the set and returns `True` if the element was inserted successfully. Returns `False` if the element already exists. * `remove(val: int) -> bool`: Removes `val` from the set and returns `True` if the element was removed successfully. Returns `False` if the element does not exist. * `random_element() -> int`: Returns a random element from the set. Every element must have an equal probability of being chosen. # Constraints - Operations must be implemented with average time complexity of O(1). - The set must handle values between -10^6 and 10^6. - The set must handle up to 10^5 operations. # Examples ```python # Example 1 rset = RandomizedSet() assert rset.insert(1) == True assert rset.insert(2) == True assert rset.insert(1) == False assert rset.remove(1) == True assert rset.remove(3) == False rset.random_element() # Should return 2, since 1 was removed. # Example 2 rset = RandomizedSet() for i in range(1, 6): assert rset.insert(i) == True print(rset.random_element()) # Return a random element between 1 to 5 ``` # Explanation - In **Example 1**, the initial insertion of `1` and `2` are successful. Trying to insert `1` again fails because it already exists. Removing `1` is successful but trying to remove `3` fails as it does not exist. The random element returned is `2` because `1` was removed. - In **Example 2**, we populate the set with numbers from 1 to 5 and a random element is returned.","solution":"import random class RandomizedSet: def __init__(self): Initialize any necessary data structures here. self.vals = [] self.val_to_index = {} def insert(self, val: int) -> bool: Implement the insertion of val. if val in self.val_to_index: return False self.val_to_index[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: Implement the removal of val. if val not in self.val_to_index: return False index = self.val_to_index[val] last_element = self.vals[-1] self.vals[index] = last_element self.val_to_index[last_element] = index self.vals.pop() del self.val_to_index[val] return True def random_element(self) -> int: Implement the retrieval of a random element. return random.choice(self.vals)"},{"question":"# Binary Search Challenge for Last Occurrence **Scenario**: A search engine\'s backend must efficiently manage a sorted log of query times when specific searches were made. To optimize reporting, you need to provide the last occurrence of certain query times in their list. **Task**: Write a Python function `last_occurrence` that takes in a sorted list of integers `array` and an integer `query` and returns the index of the last occurrence of `query` in `array`. If `query` is not present, the function should return `-1`. **Function Signature**: ```python def last_occurrence(array: List[int], query: int) -> int: ``` **Input**: 1. `array` (List[int]): A list of integers sorted in increasing order. 2. `query` (int): The integer value to find the last occurrence of. **Output**: * Returns the index (int) of the last occurrence of `query` in `array`. * Returns `-1` if `query` is not found in `array`. **Constraints**: * The list is non-empty and sorted in increasing order. * Array length can be up to 10^6. * The integer elements are within the range `-10^9` to `10^9`. **Examples**: *Example 1*: ```python array = [1, 2, 2, 2, 3, 4, 5] query = 2 last_occurrence(array, query) # Output: 3 ``` *Example 2*: ```python array = [1, 3, 5, 7, 9] query = 4 last_occurrence(array, query) # Output: -1 ``` *Example 3*: ```python array = [7, 7, 7, 7, 7, 7] query = 7 last_occurrence(array, query) # Output: 5 ``` **Note**: * Ensure your solution is optimized for the constraints provided. * Properly handle and test edge cases.","solution":"from typing import List def last_occurrence(array: List[int], query: int) -> int: Return the index of the last occurrence of query in array. If not found, return -1. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid # found a match, keep searching on the right low = mid + 1 elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"Objective Design and implement a function that can insert multiple keys into a B-Tree, followed by a find operation to verify if a specific key exists. This will assess your understanding of B-Tree operations, including handling tree balance and search efficiency. # Problem Statement You are provided with a BTree class and a Node class representing a B-Tree. Your task is to extend this BTree class with a method to batch insert multiple keys efficiently. After inserting the keys, you need to check if a particular key can be found in the B-Tree. # Instructions: 1. Implement `batch_insert` function in the BTree class that takes a list of keys and inserts them into the B-Tree. 2. Implement the `find_key` function that checks if a specific key is present in the B-Tree. # Constraints: * The number of keys to be inserted in the batch can be up to 10,000. * Key values can range between -100,000 and 100,000. * You need to ensure the batch insertion operation maintains the balanced property of the B-Tree. # Example: ```python # Initialize BTree with degree 3 btree = BTree(t_val=3) # Batch insert keys keys_to_insert = [10, 20, 5, 6, 12, 30, 7, 17] btree.batch_insert(keys_to_insert) # Check if 12 exists in the B-Tree assert btree.find_key(12) == True # Check if 40 exists in the B-Tree assert btree.find_key(40) == False ``` # Expected Function Signature: ```python class BTree: ... def batch_insert(self, keys: List[int]) -> None: ... def find_key(self, key: int) -> bool: ... ``` # Note: Ensure that your code handles all edge cases, maintains the balance of the B-Tree, and performs efficiently within the given constraints.","solution":"class Node: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys, initialized as empty self.children = [] # List of child pointers, initialized as empty class BTree: def __init__(self, t_val): self.root = Node(t_val, True) # Initial root node self.t = t_val # Minimum degree def batch_insert(self, keys): for key in keys: self.insert(key) def insert(self, k): root = self.root if len(root.keys) == (2 * self.t) - 1: # If root is full, then tree grows in height s = Node(self.t, False) s.children.insert(0, root) self._split_child(s, 0) self._insert_non_full(s, k) self.root = s else: self._insert_non_full(root, k) def _insert_non_full(self, x, k): i = len(x.keys) - 1 if x.leaf: x.keys.append(0) while i >= 0 and k < x.keys[i]: x.keys[i + 1] = x.keys[i] i -= 1 x.keys[i + 1] = k else: while i >= 0 and k < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == (2 * self.t) - 1: self._split_child(x, i) if k > x.keys[i]: i += 1 self._insert_non_full(x.children[i], k) def _split_child(self, x, i): t = self.t y = x.children[i] z = Node(t, y.leaf) x.children.insert(i + 1, z) x.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t) - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[0:t] def find_key(self, k, x=None): if not x: x = self.root i = 0 while i < len(x.keys) and k > x.keys[i]: i += 1 if i < len(x.keys) and k == x.keys[i]: return True if x.leaf: return False return self.find_key(k, x.children[i])"},{"question":"# Objective You are tasked with implementing a comb sort algorithm for an integer array with additional functionalities and constraints. # Scenario You are given an unsorted list of integers, and you need to implement the comb sort algorithm to sort this list in ascending order. Additionally, you must keep track of and return the number of swaps made during the sort. # Requirements Implement a function `comb_sort_with_swap_count` that sorts a list of integers and counts the number of swaps performed. # Function Signature ```python def comb_sort_with_swap_count(arr: List[int]) -> Tuple[List[int], int]: pass ``` # Input * **arr**: List of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. # Output * A tuple consisting of: - The sorted list of integers. - The number of swaps made during the sorting process. # Constraints * The sorting must be done using the comb sort algorithm. * You need to count the number of swaps performed during the sorting. # Example ```python arr = [5, 3, 1, 4, 2] sorted_arr, swap_count = comb_sort_with_swap_count(arr) print(sorted_arr) # Output: [1, 2, 3, 4, 5] print(swap_count) # Output: Varies depending on the swaps made ``` # Notes 1. Ensure the algorithm is optimized for time complexity to handle the upper limit of the input size. 2. Test your implementation against edge cases such as already sorted arrays and arrays with duplicate elements.","solution":"from typing import List, Tuple def comb_sort_with_swap_count(arr: List[int]) -> Tuple[List[int], int]: Sorts the given list of integers using the comb sort algorithm and counts the number of swaps made. Parameters: arr (List[int]): The list of integers to be sorted. Returns: Tuple[List[int], int]: A tuple containing the sorted list of integers and the number of swaps made. def get_next_gap(gap): # Shrink gap by a shrink factor gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True swap_count = 0 while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] # Swap positions swap_count += 1 swapped = True return arr, swap_count"},{"question":"# Scenario You are working for a company that deals with processing and sorting large sets of data. They often require sorting operations that are efficient and can handle large volumes of data effectively. Recently, they have encountered performance issues with their existing sorting algorithm, and they have tasked you with implementing an efficient heap-based sorting solution. # Task Implement the function `optimized_heap_sort(arr, mode=\'max\', simulation=False)` that will sort an array `arr` using heap sort. Your function should support both max-heap and min-heap based sorting based on the `mode` parameter: - If `mode` is `\'max\'`, use a max-heap for sorting. - If `mode` is `\'min\'`, use a min-heap for sorting. Your solution should also support a simulation mode that prints each iteration of the heapify process as illustrated in the provided code snippets. # Requirements: * **Function Signature**: ```python def optimized_heap_sort(arr: list, mode: str = \'max\', simulation: bool = False) -> list: ``` * **Input**: * `arr`: List of integers to be sorted. * `mode`: String that specifies the type of heap (\'max\' or \'min\'). Default is \'max\'. * `simulation`: Boolean value that, if true, prints the iteration steps. Default is False. * **Output**: A list of integers sorted in ascending order. # Constraints: * `arr` can have up to 10^6 elements. * Each element of `arr` lies between -10^6 and 10^6. * The function should have a time complexity of O(n log(n)) and a space complexity of O(1). # Example: ```python # Sample Input arr = [5, 3, 8, 4, 2, 7, 1] sorted_arr = optimized_heap_sort(arr, mode=\'max\', simulation=True) print(sorted_arr) # Output should be [1, 2, 3, 4, 5, 7, 8] # Sample Input arr = [5, 3, 8, 4, 2, 7, 1] sorted_arr = optimized_heap_sort(arr, mode=\'min\', simulation=False) print(sorted_arr) # Output should be [1, 2, 3, 4, 5, 7, 8] ``` * Consider edge cases such as empty arrays and arrays with repeated elements. * Make sure the implementation avoids unnecessary operations or memory usage.","solution":"def optimized_heap_sort(arr, mode=\'max\', simulation=False): Sorts an array using heap sort. Parameters: arr (list): The list to be sorted. mode (str): \'max\' to use Max-Heap or \'min\' to use Min-Heap for sorting. simulation (bool): If True, prints the heap on each iteration. Returns: list: Sorted list in ascending order. n = len(arr) # Utility functions to heapify a subtree with root at index i def heapify_max(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] if simulation: print(f\'Heapify Max-Heap step: {arr}\') heapify_max(arr, n, largest) def heapify_min(arr, n, i): smallest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[smallest] > arr[left]: smallest = left if right < n and arr[smallest] > arr[right]: smallest = right if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] if simulation: print(f\'Heapify Min-Heap step: {arr}\') heapify_min(arr, n, smallest) # Build heap # Choose the type of heap based on mode heapify_func = heapify_max if mode == \'max\' else heapify_min for i in range(n//2 - 1, -1, -1): heapify_func(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify_func(arr, i, 0) # The array is in non-decreasing order if mode is \'max\', # and non-increasing order if mode is \'min\'. Reverse if it is \'min\'. if mode == \'min\': arr.reverse() return arr"},{"question":"# Scenario: You are given a list of integers. Your goal is to sort this list in ascending order using the selection sort algorithm. To better understand and visualize the sorting process, you will implement a function with an optional parameter that prints each iteration of the sorting process. # Task: Implement the `selection_sort` function which sorts a list of integers using the selection sort algorithm. The function should also be able to simulate the sorting process by printing the list at each iteration if a simulation flag is set to True. # Function Signature: ```python def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Input: * `arr`: A list of integers, where 0 ≤ len(arr) ≤ 1000 and -10000 ≤ arr[i] ≤ 10000. * `simulation`: A boolean flag that if set to True, prints the list at each iteration of the sorting process. # Output: * The function should return a list of integers sorted in ascending order. * If `simulation` is set to True, the function should print the list at each iteration of the sorting process. # Example: ```python print(selection_sort([64, 25, 12, 22, 11], True)) ``` **Output:** ``` iteration 0: 64 25 12 22 11 iteration 1: 11 25 12 22 64 iteration 2: 11 12 25 22 64 iteration 3: 11 12 22 25 64 iteration 4: 11 12 22 25 64 [11, 12, 22, 25, 64] ``` # Constraints: 1. The function should handle empty lists and lists with one element gracefully. 2. Attention should be paid to ensure the algorithm works within the provided constraints on input size and values.","solution":"from typing import List def selection_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"# B-Tree Operations: Search, Insert, and Delete You are required to implement key operations for a B-Tree of minimum degree `t`. The B-Tree should be implemented to support dynamic insertions and deletions, maintaining its properties throughout. Given the B-Tree class definition, finish implementing the following methods: 1. `search(key)` 2. `insert_key(key)` 3. `remove_key(key)` # Requirements: 1. **Search**: Implement the `search(key)` function to find whether a given key exists in the B-Tree or not. 2. **Insert**: Implement the `insert_key(key)` operation such that it maintains the B-Tree properties after insertion. 3. **Delete**: Implement the `remove_key(key)` operation to remove a specified key, ensuring the B-Tree remains balanced post-deletion. # Function Signatures: ```python class BTree: # Other class methods and properties ... def search(self, key: int) -> bool: Searches for a key in the B-Tree. :param key: Integer to search for in the tree. :return: True if key exists, False otherwise. pass def insert_key(self, key: int) -> None: Inserts a key into the B-Tree. :param key: Integer key to be inserted. :return: None pass def remove_key(self, key: int) -> bool: Removes a key from the B-Tree. :param key: Integer key to be removed. :return: True if the key was successfully removed, False otherwise. pass ``` # Inputs and Outputs: **Input**: - `search(key)`: key (integer) - `insert_key(key)`: key (integer) - `remove_key(key)`: key (integer) **Output**: - `search(key)`: Returns `True` if key is found in the B-Tree, otherwise `False`. - `insert_key(key)`: No output, modifies the B-Tree. - `remove_key(key)`: Returns `True` if the key is successfully removed, otherwise `False`. # Constraints: 1. The B-Tree should handle up to `10^5` elements. 2. All keys are unique integers. 3. Keys can be any integer within the range [-10^6, 10^6]. # Examples: ```python # Example usage btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(30) print(btree.search(10)) # True print(btree.search(15)) # False btree.remove_key(10) print(btree.search(10)) # False print(btree.search(20)) # True ``` Make sure to handle all edge cases such as inserting into a full tree, deleting from an empty tree, and performing operations on a tree that causes it to grow in height.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree self.leaf = leaf # True if leaf node self.keys = [] # Array of keys self.children = [] # Array of children def search(self, key): i = 0 while i < len(self.keys) and key > self.keys[i]: i += 1 if i < len(self.keys) and key == self.keys[i]: return True if self.leaf: return False return self.children[i].search(key) def insert_non_full(self, key): i = len(self.keys) - 1 if self.leaf: self.keys.append(0) while i >= 0 and key < self.keys[i]: self.keys[i + 1] = self.keys[i] i -= 1 self.keys[i + 1] = key else: while i >= 0 and key < self.keys[i]: i -= 1 i += 1 if len(self.children[i].keys) == 2 * self.t - 1: self.split_child(i) if key > self.keys[i]: i += 1 self.children[i].insert_non_full(key) def split_child(self, i): t = self.t y = self.children[i] z = BTreeNode(t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t: (2 * t - 1)] y.keys = y.keys[0: (t - 1)] if not y.leaf: z.children = y.children[t: (2 * t)] y.children = y.children[0: (t)] def remove(self, key): t = self.t i = 0 while i < len(self.keys) and self.keys[i] < key: i += 1 if i < len(self.keys) and self.keys[i] == key: if self.leaf: self.keys.pop(i) return True if len(self.children[i].keys) >= t: pred = self.get_pred(i) self.keys[i] = pred return self.children[i].remove(pred) if len(self.children[i + 1].keys) >= t: succ = self.get_succ(i) self.keys[i] = succ return self.children[i + 1].remove(succ) self.merge(i) return self.children[i].remove(key) if self.leaf: return False return self.children[i].remove(key) def get_pred(self, idx): current = self.children[idx] while not current.leaf: current = current.children[len(current.children) - 1] return current.keys[len(current.keys) - 1] def get_succ(self, idx): current = self.children[idx + 1] while not current.leaf: current = current.children[0] return current.keys[0] def merge(self, idx): child = self.children[idx] sibling = self.children[idx + 1] child.keys.append(self.keys[idx]) for k in sibling.keys: child.keys.append(k) if not child.leaf: for c in sibling.children: child.children.append(c) self.keys.pop(idx) self.children.pop(idx + 1) class BTree: def __init__(self, t_val): self.root = BTreeNode(t_val, True) self.t = t_val def search(self, key): return self.root.search(key) def insert_key(self, key): if len(self.root.keys) == 2 * self.t - 1: new_root = BTreeNode(self.t, False) new_root.children.append(self.root) new_root.split_child(0) self.root = new_root self.root.insert_non_full(key) def remove_key(self, key): if not self.root: return False if self.root.remove(key): if len(self.root.keys) == 0: if not self.root.leaf: self.root = self.root.children[0] return True return False"},{"question":"You are tasked with determining the minimal number of bits you need to flip to convert an integer A to an integer B. Bit manipulation is a common technique in fields such as cryptography, error detection, and data compression. This task will help you practice working with bitwise operations and counting algorithms. # Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: # Write your code here ``` # Input Format * Two non-negative integers, A and B (0 ≤ A, B ≤ 2^31 - 1). # Output Format * A single integer representing the number of bit flips required to convert A to B. # Constraints * Both A and B will be within the range of [0, 2^31 - 1]. # Example Example 1 * Input: A = 29, B = 15 * Output: 2 * Explanation: - Integer 29 in binary is 11101. - Integer 15 in binary is 01111. - To transform 29 into 15, flip the 5th and 3rd bits (count = 2). Example 2 * Input: A = 10, B = 20 * Output: 4 * Explanation: - Integer 10 in binary is 1010. - Integer 20 in binary is 10100. - To transform 10 into 20, flip the necessary bits (count = 4). # Notes * Think about how the XOR operation can help you determine which bits differ. * Utilize efficient algorithms to count the number of set bits in an integer.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bits needed to be flipped to convert integer a to integer b. xor_result = a ^ b # XOR will have bits set where a and b differ flips = 0 # Count the number of set bits in XOR result while xor_result: flips += xor_result & 1 # Check if the least significant bit is 1 xor_result >>= 1 # Shift right by one bit return flips"},{"question":"# Insertion Sort Implementation Challenge You are asked to implement the Insertion Sort algorithm. The algorithm sorts an array by repeatedly inserting each element into its proper position in the sorted portion of the array. # Task Write a function `insertion_sort` that takes a list of integers and returns a new list that is sorted in ascending order. Function Signature: ```python def insertion_sort(nums: List[int]) -> List[int]: ``` Input: * `nums` (List[int]): A list of integers that need to be sorted. Output: * (List[int]): A new list containing the sorted integers in ascending order. # Constraints: * The list can contain up to 1000 integers. * Each integer in the list is between -10^6 and 10^6. # Example: ```python assert insertion_sort([12, 11, 13, 5, 6]) == [5, 6, 11, 12, 13] assert insertion_sort([6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6] assert insertion_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] ``` # Requirements: 1. Implement the Insertion Sort algorithm. 2. Do not use Python\'s built-in sorting functions. 3. An explanation with inline comments demonstrating understanding of how Insertion Sort works is encouraged. # Additional Challenge (Optional): * Analyze and include comments on the best and worst-case time complexities in your solution.","solution":"def insertion_sort(nums): Sorts a list of integers in ascending order using the Insertion Sort algorithm. Args: nums (List[int]): A list of integers to be sorted. Returns: List[int]: A new list containing the sorted integers in ascending order. # Copy the list to avoid modifying the original list sorted_list = nums[:] # Traverse through 1 to len(sorted_list) for i in range(1, len(sorted_list)): key = sorted_list[i] j = i - 1 # Move elements of sorted_list[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and key < sorted_list[j]: sorted_list[j + 1] = sorted_list[j] j -= 1 sorted_list[j + 1] = key return sorted_list"},{"question":"**Question: Implement a \\"Dual Heap Sort\\" Function** You are required to implement a function that sorts an array using both min heap and max heap algorithms. The function should take an array and sort it twice: once using max heap sort and once using min heap sort. The function should combine the results of both sorts into a final single sorted array that conforms to heap sorting properties in ascending order. Function Signature ```python def dual_heap_sort(arr): pass ``` Input Format * `arr`: A list of integers to be sorted. Constraints are as follows: * 1 <= len(arr) <= 1000 * `arr` can contain both positive and negative integers. Output Format * Returns a list of integers sorted in ascending order. Example ```python print(dual_heap_sort([5, 3, 8, 4, 2])) # Expected Output: [2, 3, 4, 5, 8] print(dual_heap_sort([-1, 2, 0, -5, 3])) # Expected Output: [-5, -1, 0, 2, 3] ``` Constraints * Performance should be kept within O(n log(n)) for both max heap and min heap sorts. * No additional space should be used beyond the input array for sorting (in-place sorting). Requirements 1. **Implementation**: * Write a max-heap sort function to sort the input array. * Write a min-heap sort function to sort the input array. * Combine both sorts properly to yield the final sorted array. 2. **Error Handling**: * Handle edge cases such as empty arrays or arrays with a single element. 3. **Performance**: * Ensure the implementation is efficient in terms of both time and space complexity.","solution":"def dual_heap_sort(arr): import heapq # Helper function to turn an array into a max heap (in-place) def build_max_heap(arr): n = len(arr) for i in range(n // 2 - 1, -1, -1): heapify_max(arr, i, n) # Helper function to heapify a subtree rooted at index i def heapify_max(arr, i, n): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[largest] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify_max(arr, largest, n) # Max heap sort def max_heap_sort(arr): build_max_heap(arr) for i in range(len(arr) - 1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify_max(arr, 0, i) # Min heap sort def min_heap_sort(arr): heapq.heapify(arr) return [heapq.heappop(arr) for _ in range(len(arr))] # Make a copy of the original array for min heap sort arr_copy = arr[:] # Perform both sorts max_heap_sort(arr) # Since the array is heapified in descending order, reverse it arr.reverse() # Perform min heap sort arr_min_sorted = min_heap_sort(arr_copy) # Since only the min heap sort ensures return of a sorted array return arr_min_sorted"},{"question":"# Flatten Nested Arrays You are given a function `flatten` that takes in an array (potentially containing nested arrays) and flattens it, returning a one-dimensional array. This problem requires you to confirm and validate your understanding of recursion and handling nested data structures, along with attention to edge cases and performance. Your task is to write a Python function `flatten` that recursively flattens a provided n-dimensional array into a 1-dimensional array. Function Signature ```python def flatten(input_arr): # Your code here ``` Input - `input_arr`: A list which may contain nested lists. Output - A single list that contains all elements of the input lists \\"flattened\\" into a single list. Constraints - The elements of the arrays can be integers, floats, strings, or even other arrays. - The depth of the nested structure is unknown. - The solution should primarily focus on correctness and handle reasonable levels of nesting within typical scenarios. Example ```python flatten([1, [2, 3, [4, 5]], 6]) # Output: [1, 2, 3, 4, 5, 6] flatten([1, [], [3, [4, []]], 5]) # Output: [1, 3, 4, 5] flatten([[[1]], [[2]], []]) # Output: [1, 2] ``` # Additional Requirements 1. **Edge Cases** should be considered, such as: - Empty arrays and empty nested arrays. - Arrays with mixed type elements. 2. **Performance** should be evaluated for large input arrays to ensure efficiency. 3. **Recursion Depth**: Solutions should handle typical depth without hitting maximum recursion depth in Python.","solution":"def flatten(input_arr): Flattens a nested list into a one-dimensional list. Args: input_arr (list): A potentially nested list. Returns: list: A flattened one-dimensional list. flat_list = [] def _flatten_helper(sub_list): for item in sub_list: if isinstance(item, list): _flatten_helper(item) else: flat_list.append(item) _flatten_helper(input_arr) return flat_list"},{"question":"**Description**: Write a function `remove_min_improved(stack: list) -> list` that removes the smallest value from a given stack (represented as a Python list). **Input**: * A list `stack` representing a stack of integers. The top of the stack is the last element of the list. **Output**: * A list representing the stack after removing the smallest value. **Constraints**: * The stack will contain at most `10^5` elements. * The values in the stack will be in the range `[-10^9, 10^9]`. * If the stack is empty, return an empty stack. **Example**: ```python stack = [2, 8, 3, -6, 7, 3] print(remove_min_improved(stack)) # Output: [2, 8, 3, 7, 3] stack = [] print(remove_min_improved(stack)) # Output: [] stack = [1] print(remove_min_improved(stack)) # Output: [] ``` **Performance Requirements**: * The function should aim to be efficient in both time and space complexity. **Hints**: * Consider whether multiple stack operations can be optimized by reducing redundant passes.","solution":"def remove_min_improved(stack: list) -> list: Removes the smallest value from the stack. Parameters: stack (list): A list representing the stack. Returns: list: The stack after removing the smallest value. if not stack: return stack # Find the minimum value in the stack min_value = min(stack) # Remove the first occurrence of the minimum value stack.remove(min_value) return stack"},{"question":"You are required to implement two functions `insert_one_bit` and `insert_mult_bits` to insert single or multiple bits at a specific position in the binary representation of a given integer. insert_one_bit **Function Signature**: `def insert_one_bit(num: int, bit: int, pos: int) -> int` Given a non-negative integer `num`, a bit value `bit` (which can be either 0 or 1), and an integer position `pos`, your task is to insert the given bit at the specified position in the binary representation of `num`. **Example**: ``` insert_one_bit(21, 1, 2) -> 45 # (21 is \'10101\' in binary; inserting 1 at position 2 gives \'101101\' which is 45) insert_one_bit(21, 0, 2) -> 41 # (21 is \'10101\' in binary; inserting 0 at position 2 gives \'101001\' which is 41) insert_one_bit(21, 1, 5) -> 53 # (21 is \'10101\' in binary; inserting 1 at position 5 gives \'110101\' which is 53) ``` insert_mult_bits **Function Signature**: `def insert_mult_bits(num: int, bits: int, length: int, pos: int) -> int` Given a non-negative integer `num`, a set of bits represented by the integer `bits`, the length of the bits `length`, and an integer position `pos`, your task is to insert the given bits at the specified position in the binary representation of `num`. **Example**: ``` insert_mult_bits(5, 7, 3, 1) -> 47 # (5 is \'101\' in binary; inserting \'111\' at position 1 gives \'101111\' which is 47) insert_mult_bits(5, 7, 3, 0) -> 47 # (5 is \'101\' in binary; inserting \'111\' at position 0 gives \'101111\' which is 47) insert_mult_bits(5, 7, 3, 3) -> 61 # (5 is \'101\' in binary; inserting \'111\' at position 3 gives \'111101\' which is 61) ``` # Constraints * 0 ≤ num ≤ 2^31 - 1 * bit is either 0 or 1. * length should be less than or equal to the maximum available bits in an integer (typically, less than 32). * The position should be within the valid range of binary length + 1 (to allow insertion at the end). # Requirements 1. Ensure to handle edge cases such as inserting at the beginning or the end of the number. 2. Efficiently handle large numbers within the provided constraints.","solution":"def insert_one_bit(num: int, bit: int, pos: int) -> int: Inserts a single bit at a specified position in the binary representation of a number. :param num: The integer number. :param bit: The bit value (either 0 or 1). :param pos: The position to insert the bit. :return: The integer result after inserting the bit. # Shift the bits after pos to the left and add the new bit. left = num >> pos left = (left << pos+1) | (bit << pos) | (num & ((1 << pos) - 1)) return left def insert_mult_bits(num: int, bits: int, length: int, pos: int) -> int: Inserts multiple bits at a specified position in the binary representation of a number. :param num: The integer number. :param bits: The integer representing the bits to insert. :param length: The length of the bits to insert. :param pos: The position to insert the bits. :return: The integer result after inserting the bits. left = num >> pos left = (left << (pos + length)) | (bits << pos) | (num & ((1 << pos) - 1)) return left"},{"question":"# Question: In-Order Traversal with Modifications In a Binary Search Tree (BST), general operations are performed sequentially and often required traversing the tree. For this problem, you are tasked to implement a modified version of in-order traversal which additionally yields an average of the parent and current node values. Requirements 1. **Input**: A binary tree consisting of integer values (Node class defined as shown). 2. **Output**: List of tuples where each tuple consists of (node_value, average_value), and average_value is the computed average of the node and its parent. Constraints: * Tree nodes can have negative, zero, or positive integer values. * If the node is a root, represent its average_value same as the node_value. * Assume given BST is valid and does not contain duplicate values. Example Tree: ``` 100 / 50 150 / / 25 75 125 175 ``` Example Output: ``` [(25, 37.5), (50, 75.0), (75, 62.5), (100, 100.0), (125, 137.5), (150, 125.0), (175, 162.5)] ``` Function Signature: ```python def modified_inorder(root: Node) -> List[Tuple[int, float]]: pass ``` Your task is to implement the function `modified_inorder` that performs this modified in-order traversal to produce the output as described.","solution":"from typing import List, Tuple, Optional, Union class Node: def __init__(self, key: int): self.left: Optional[Node] = None self.right: Optional[Node] = None self.val: int = key def modified_inorder(root: Node) -> List[Tuple[int, Union[int, float]]]: result = [] def inorder(node: Optional[Node], parent_val: Optional[int]): if node is None: return # Traverse the left subtree inorder(node.left, node.val) # Compute the average with parent value if parent_val is not None: average = (node.val + parent_val) / 2.0 else: average = node.val result.append((node.val, average)) # Traverse the right subtree inorder(node.right, node.val) # Call the helper function with the root and no parent inorder(root, None) return result"},{"question":"# Problem: K-th to Last Element in a Linked List You are given a singly linked list and a number `k`. Your task is to write a function that finds the k-th to last element of the linked list and returns its value. Implement the following function: ```python def kth_to_last(head, k): # Your code here # Define Node class here as well ``` # Input: - The head of the linked list (node). - An integer `k` such that `0 <= k < length of the list`. # Output: - The value of the k-th to last element in the linked list. # Constraints: 1. The linked list has at least one node. 2. `k` is always a valid integer within the range. # Example: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head, k): # Your code here def test(): # Create sample linked list A -> B -> C -> D -> E a = Node(\\"A\\") b = Node(\\"B\\") c = Node(\\"C\\") d = Node(\\"D\\") e = Node(\\"E\\") a.next = b b.next = c c.next = d d.next = e # Find k-th to last elements assert kth_to_last(a, 0).val == \\"E\\" # E is the 0-th to last element assert kth_to_last(a, 2).val == \\"C\\" # C is the 2-th to last element assert kth_to_last(a, 4).val == \\"A\\" # A is the 4-th to last element test() ``` # Notes: - Write the function `kth_to_last` to find the k-th to last element optimally. - Ensure to handle possible edge cases such as a single element list or k equal to the length of the list minus one. - Pay attention to algorithm complexity and aim for a solution that runs in O(n) time with O(1) additional space.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head, k): # Initialize two pointers; both start at the head first_pointer = head second_pointer = head # Move the first pointer k steps ahead for _ in range(k): first_pointer = first_pointer.next # Move both pointers until the first pointer reaches the end while first_pointer and first_pointer.next: first_pointer = first_pointer.next second_pointer = second_pointer.next # Now the second_pointer points to the k-th to last element return second_pointer"},{"question":"# Question You have been given an array of integers where every element appears twice except for one, which appears only once. Your task is to write a function that identifies and returns that single unique element. **Constraints**: * You must implement an algorithm with linear runtime complexity. * You must not use extra memory. **Function Signature**: ```python def find_unique_number(nums: List[int]) -> int: This function returns the unique number that appears only once in the array. :param nums: List[int] - an array of integers :return: int - the unique integer that appears once ``` **Input**: * A list of integers `nums`, where (2 <= len(nums) <= 10^5) and every element appears twice except for one. **Output**: * The single integer that appears once. **Example**: ```plaintext Input: [4, 1, 2, 1, 2] Output: 4 Input: [2, 2, 3, 3, 4, 4, 5] Output: 5 ``` **Explanation**: In the first example: - XOR of all elements results in 4. This is because XORing all repeating elements cancel them out (e.g., 1 XOR 1 = 0; 2 XOR 2 = 0). In the second example: - XOR of all elements results in 5 (Even pairings will cancel out each other). Assume the input meets the specified constraints and does not require additional validation checks.","solution":"from typing import List def find_unique_number(nums: List[int]) -> int: This function returns the unique number that appears only once in the array. :param nums: List[int] - an array of integers :return: int - the unique integer that appears once result = 0 for num in nums: result ^= num return result"},{"question":"# Question: Implement an Enhanced Binary Search You are given a sorted array of integers. Implement a function that performs a binary search to locate a given target value. The function should handle the following: 1. If the target value is present, return the index of the first occurrence of the target. 2. If the target value is absent, return the index where it could be inserted to maintain the sorted order. Function Signature: ```python def enhanced_binary_search(array: List[int], target: int) -> int: ``` Input: * `array` (List[int]): A list of integers sorted in ascending order. * `target` (int): The target integer value you are searching for. Output: * `int`: The index of the first occurrence of the target value if found; otherwise, the index where the target can be inserted to maintain sorted order. Constraints: * The array can have up to 10^6 elements. * The elements in the array and the target values are integers, possibly negative. Example: ```python assert enhanced_binary_search([1, 3, 5, 6], 5) == 2 assert enhanced_binary_search([1, 3, 5, 6], 2) == 1 assert enhanced_binary_search([1, 3, 5, 6], 7) == 4 assert enhanced_binary_search([1, 3, 5, 6], 0) == 0 ``` Performance Requirements: * Your solution\'s time complexity should be O(log(n)). * Your solution should handle large inputs efficiently within the provided constraints.","solution":"from typing import List def enhanced_binary_search(array: List[int], target: int) -> int: left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: # To find the first occurrence, continue searching in the left half if mid == left or array[mid - 1] < target: return mid right = mid - 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"Scenario You have been hired to enhance data processing in a medical research lab. The lab gathers a high volume of sensor readings from equipment used in experiments. To ensure the integrity of the data reviewed by scientists, you need to filter out the readings that fall outside a designated safe range. Task Write a Python function `filter_readings` that takes three arguments: - `readings` (list of integers): A list of sensor readings. - `lower_bound` (optional integer): An optional parameter indicating the lower bound of the range. If not provided, it defaults to `None`. - `upper_bound` (optional integer): An optional parameter indicating the upper bound of the range. If not provided, it defaults to `None`. The function should return a new list containing only the sensor readings that fall within the inclusive range specified by `lower_bound` and `upper_bound`. If `lower_bound` is `None`, it should not impose a lower limit. Similarly, if `upper_bound` is `None`, it should not impose an upper limit. Constraints - The `readings` list can contain 0 to 10^5 elements. - Each reading is an integer in the range -10^6 to 10^6. Example ```python def filter_readings(readings, lower_bound=None, upper_bound=None): pass # Example Test Case readings = [15, 22, 8, 34, 45, 5, 10] lower_bound = 10 upper_bound = 30 assert filter_readings(readings, lower_bound, upper_bound) == [15, 22, 10] ``` Notes - Edge cases such as empty lists or readings that do not fall within the range should be handled gracefully. - Optimize for time complexity to ensure the function performs efficiently even with large input sizes. - Ensure the function does not modify the original list of readings.","solution":"def filter_readings(readings, lower_bound=None, upper_bound=None): Filters the list of sensor readings to include only those within the optional inclusive lower and upper bounds. :param readings: List of integers, the sensor readings. :param lower_bound: Optional integer, the lower bound of the range. :param upper_bound: Optional integer, the upper bound of the range. :return: A new list containing only the readings within the inclusive range. if lower_bound is None: lower_bound = float(\'-inf\') if upper_bound is None: upper_bound = float(\'inf\') return [reading for reading in readings if lower_bound <= reading <= upper_bound]"},{"question":"# Next Greatest Letter Problem Context: You are working on a module that needs to efficiently find the next greatest letter in a list. Given a list of sorted characters (`letters`) containing only lowercase letters, and a target letter (`target`), you must identify the smallest element in the list that is larger than the given target. The list is circular, meaning if the target is greater than or equal to the last element in the list, the smallest element (starting from the beginning of the list) will be your answer. Task: Write a function `next_greatest_letter` that accomplishes this. You are required to implement this function using the binary search technique for optimal performance. Function Signature: ```python def next_greatest_letter(letters: List[str], target: str) -> str: pass ``` Input: * `letters` - a list of sorted lowercase letters, e.g., [\\"c\\", \\"f\\", \\"j\\"] * `target` - a lowercase letter, e.g., \\"a\\" Output: * Return the smallest element in the list that is larger than the given target. Constraints: * The list `letters` will have at least 2 characters. * All characters in `letters` are sorted in non-decreasing order. * `letters` contains only lowercase English letters. * Target is a lowercase English letter. Examples: ```python letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" # Output: \\"c\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" # Output: \\"f\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" # Output: \\"f\\" letters = [\\"a\\", \\"b\\"] target = \\"z\\" # Output: \\"a\\" ``` Performance Requirements: The solution should be optimized to run with a time complexity of O(log N), where N is the length of the list `letters`.","solution":"from typing import List def next_greatest_letter(letters: List[str], target: str) -> str: lo, hi = 0, len(letters) - 1 while lo <= hi: mid = (lo + hi) // 2 if letters[mid] > target: hi = mid - 1 else: lo = mid + 1 return letters[lo % len(letters)]"},{"question":"**Context**: You work as a software engineer at a company that processes large datasets. You frequently encounter situations where you need to merge multiple sorted datasets into a single sorted dataset. One common way to do this efficiently is to use a priority queue (min-heap). **Problem**: Write a function `merge_k_sorted_linked_lists` that takes a list of `k` sorted linked lists and merges them into a single sorted linked list. # Function Signature: ```python def merge_k_sorted_linked_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` # Input: * `lists`: A list of `k` singly linked lists, each sorted in ascending order. Each linked list could have zero or more nodes. # Output: * Returns the head of a single sorted linked list combining all the individual lists. # Constraints: * `k >= 0` (If k=0, return `None`). * The total number of elements across all lists will not exceed 10^6. # Examples: Example 1: ```python # Given the lists # [ # 1->4->5, # 1->3->4, # 2->6 # ] # Your function should return: # 1->1->2->3->4->4->5->6 ``` Example 2: ```python # Given the lists # [ # 5, # 1->2->3->4, # 6->7->8->9 # ] # Your function should return: # 1->2->3->4->5->6->7->8->9 ``` # Requirements: * Ensure the solution is efficient with time complexity O(n log k) and space complexity O(k), where `n` is the total number of nodes in all the linked lists combined. # Performance: Your solution should efficiently merge even when the linked lists are large in number. # Additional Notes: * Please ensure that the merged list maintains the original relative order of elements with equal keys from the input lists. * Verify that your solution handles edge cases where lists may be empty.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, x): self.val = x self.next = None def merge_k_sorted_linked_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None # A list to keep the min-heap of nodes min_heap = [] # Initialize the heap with the head of each list for i in range(len(lists)): if lists[i]: heapq.heappush(min_heap, (lists[i].val, i, lists[i])) # Dummy head for the final merged linked list dummy = ListNode(0) current = dummy while min_heap: # Get the smallest node val, idx, node = heapq.heappop(min_heap) current.next = node current = current.next # If there is a next node in the list, push it to the heap if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"# RSA Key Generation and Encryption/Decryption Objective: Write a Python function that generates RSA keys, encrypts, and decrypts a given message using the generated keys. Your implementation should correctly handle prime generation, modular arithmetic, and ensure valid encryption and decryption procedures. Function Signature: ```python def rsa_keygen_encrypt_decrypt(k: int, data: int, seed: int = None) -> dict: Generates RSA keys, encrypts, and decrypts a number. Parameters: k (int): Number of bits for modulus n. data (int): The number to be encrypted and decrypted. seed (int, optional): The seed for random prime generation. Returns: dict: A dictionary with the following keys: - \'n\': The modulus. - \'e\': The encryption exponent. - \'d\': The decryption exponent. - \'encrypted\': The encrypted data. - \'decrypted\': The decrypted data. ``` Requirements: 1. Generate RSA keys: a modulus `n`, an encryption exponent `e`, and a decryption exponent `d`. 2. Encrypt the given `data` using `e` and `n`. 3. Decrypt the encrypted data using `d` and `n`. 4. Return the keys and the results in a dictionary. Constraints: - `k` should be in the range [8, 1024] for practical purposes. - `data` should be a non-negative integer less than `n`. - Maintain optimal performance for generating large primes and calculating modular inverses. Example: ```python result = rsa_keygen_encrypt_decrypt(16, 42, seed=12345) print(result) # Output might be something like: # { # \'n\': ..., # \'e\': ..., # \'d\': ..., # \'encrypted\': ..., # \'decrypted\': 42 # } ``` Notes: - Use efficient methods for prime generation and modular inverse calculation. - Ensure all input validations and error handling are implemented.","solution":"import random from sympy import isprime, mod_inverse def generate_large_prime(bits: int, seed: int = None) -> int: if seed is not None: random.seed(seed) while True: candidate = random.getrandbits(bits) candidate |= (1 << bits - 1) | 1 if isprime(candidate): return candidate def rsa_keygen_encrypt_decrypt(k: int, data: int, seed: int = None) -> dict: # Generate two large primes p and q p = generate_large_prime(k // 2, seed) q = generate_large_prime(k // 2, seed + 1 if seed is not None else None) # Calculate modulus n = p * q n = p * q # Calculate Euler\'s Totient function phi(n) = (p-1)*(q-1) phi = (p - 1) * (q - 1) # Choose encryption exponent e, typically 65537 e = 65537 while gcd(e, phi) != 1: e += 2 # Calculate decryption exponent d, the modular inverse of e mod phi d = mod_inverse(e, phi) # Encrypt the data using the public key (e, n) encrypted = pow(data, e, n) # Decrypt the data using the private key (d, n) decrypted = pow(encrypted, d, n) return { \'n\': n, \'e\': e, \'d\': d, \'encrypted\': encrypted, \'decrypted\': decrypted } def gcd(a, b): while b: a, b = b, a % b return a"},{"question":"# Bucket Sort Implementation Challenge Implement a function `optimized_bucket_sort` in Python that sorts an array of integers using the bucket sort technique. You should improve upon the given code to ensure better performance and reliability while considering edge cases and potential bottlenecks. Your implementation must handle inputs efficiently across various scenarios, including arrays of different sizes and distributions. # Function Signature ```python def optimized_bucket_sort(arr: List[int]) -> List[int]: ``` # Input 1. `arr`: A list of integers, `1 <= len(arr) <= 10^5`. # Output - A list of integers sorted in ascending order. # Constraints - You are allowed to use only the standard library. - You must avoid using Python\'s built-in sort functions directly. # Examples ```python assert optimized_bucket_sort([4, 3, 1, 2, 0, 5]) == [0, 1, 2, 3, 4, 5] assert optimized_bucket_sort([4, 3]) == [3, 4] assert optimized_bucket_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Notes - Ensure that your implementation is designed to handle large datasets effectively. - Carefully consider and handle edge cases, such as lists with repeated elements and lists with elements of varying magnitudes. - Provide a brief explanation of any optimizations or deviations from the original algorithm.","solution":"from typing import List def insertion_sort(bucket: List[int]) -> List[int]: for i in range(1, len(bucket)): up = bucket[i] j = i - 1 while j >= 0 and bucket[j] > up: bucket[j + 1] = bucket[j] j -= 1 bucket[j + 1] = up return bucket def optimized_bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return arr min_value, max_value = min(arr), max(arr) bucket_range = (max_value - min_value) / len(arr) + 1 buckets = [[] for _ in range(len(arr))] for i in range(len(arr)): bucket_index = int((arr[i] - min_value) // bucket_range) buckets[bucket_index].append(arr[i]) sorted_arr = [] for bucket in buckets: insertion_sort(bucket) sorted_arr.extend(bucket) return sorted_arr"},{"question":"# Question You are implementing a text editor feature to search for a word within a document. Your job is to create an efficient function using the Rabin-Karp algorithm to find the first occurrence of a pattern (word) in a string (text). # Detailed Requirements Implement a function `find_substring(word: str, text: str) -> int`. Your function should take: - `word`: A non-empty substring, which needs to be searched in the `text` (1 ≤ length of `word` ≤ 10^4). - `text`: A string where the search is performed (1 ≤ length of text ≤ 10^6). # Function Specifications - The function should return the **0-based index** of the first occurrence of `word` in `text`. - Return `-1` if `word` does not exist in `text`. - Consider the text contains only lowercase English letters. # Constraints & Performance - You should aim for an average-case time complexity of O(m + n), where `m` is the length of `word` and `n` is the length of `text`. Example Scenarios ```python # Example 1 word = \\"abc\\" text = \\"abxabcabcaby\\" # Expected Output: 3 # Example 2 word = \\"aaaa\\" text = \\"baaaabaaaab\\" # Expected Output: 1 # Example 3 word = \\"xyz\\" text = \\"abcdef\\" # Expected Output: -1 ```","solution":"def find_substring(word, text): Implements the Rabin-Karp algorithm to find the first occurrence of a word in a given text. Parameters: word (str): The substring to be searched. text (str): The text where the search is performed. Returns: int: The 0-based index of the first occurrence of the word in the text, or -1 if the word does not exist in the text. if not word or not text: return -1 d = 256 # number of characters in the input alphabet q = 101 # a prime number m = len(word) n = len(text) h = 1 p = 0 # hash value for the pattern t = 0 # hash value for the text substring if m > n: return -1 # The value of h would be \\"pow(d, m-1)%q\\" for i in range(m-1): h = (h * d) % q # Calculate the hash value of the pattern and first window of text for i in range(m): p = (d * p + ord(word[i])) % q t = (d * t + ord(text[i])) % q # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of the current window of text and pattern if p == t: # Check for characters one by one if text[i:i + m] == word: return i # Calculate hash value for next window of text if i < n - m: t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q t = (t + q) % q return -1"},{"question":"**Scenario**: You are part of a team analyzing election data. Each candidate in an election is represented by a unique integer ID in a voter list. Your task is to generate a frequency distribution of votes each candidate received. # Task: Write a function called `count_votes` that takes a list of integers representing votes and returns a dictionary where the keys are candidate IDs and the values are the counts of votes each candidate received. # Function Signature: ```python def count_votes(vote_list: list) -> dict: ``` # Input: - `vote_list` (list): A list of integers where each integer represents a vote for a candidate. # Output: - A dictionary where the keys are integers (candidate IDs) and the values are integers representing the number of votes each candidate received. # Constraints: - The input list can have between 0 and 10^6 elements. - Each candidate ID is a positive integer. - You may assume all integers in the vote_list are valid candidate IDs. # Example: ```python # Example 1 vote_list = [3, 3, 2, 1] # Expected Output: {1: 1, 2: 1, 3: 2} # Example 2 vote_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` # Performance Requirements: Your solution should handle the worst-case scenario efficiently within linear time complexity, O(n). # Implementation Note: Consider edge cases, including but not limited to an empty list and a list of identical or unique elements.","solution":"def count_votes(vote_list): Returns a dictionary where the keys are candidate IDs and the values are the counts of votes each candidate received. vote_count = {} for vote in vote_list: if vote in vote_count: vote_count[vote] += 1 else: vote_count[vote] = 1 return vote_count"},{"question":"# Minimum Path Cost in a Graph **Objective**: Write a function to find the minimum cost to reach the last station from the first station in a given cost matrix representing a Directed Acyclic Graph (DAG). **Function Signature**: ```python def find_min_cost(cost: List[List[int]]) -> int: pass ``` **Input**: - `cost`: A 2D list where `cost[i][j]` contains the cost of moving from station i to station j, for `i < j`. For `i >= j`, `cost[i][j]` is irrelevant and could be considered as -1 or INF (infinity). **Output**: - An integer representing the minimum cost to reach the last station from the first station. **Example**: ```python cost = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert find_min_cost(cost) == 65 cost = [ [0, 10, 75, 94], [-1, 0, 35, 50], [-1, -1, 0, 80], [-1, -1, -1, 0] ] assert find_min_cost(cost) == 60 ``` **Constraints**: 1. All costs `cost[i][j]` for `i < j` should be non-negative integers. 2. The size of the input matrix `N` is such that (1 leq N leq 100). **Performance Requirements**: - The solution should have a time and space complexity of (O(N^2)) and (O(N)), respectively. **Edge Cases**: - Consider cases where there are large costs which might force the algorithm to take an alternative longer path in terms of number of stations but with a lower overall cost. - Handle cases where there might be no valid paths (this should return infinity or a suitably large number representing unreachable). Implement the function using the principles of dynamic programming described above.","solution":"from typing import List def find_min_cost(cost: List[List[int]]) -> int: Return the minimum cost to reach the last station from the first station in a given DAG represented by a cost matrix. N = len(cost) # Initialize dist[] array with infinite cost dist = [float(\'inf\')] * N # Start point cost is zero dist[0] = 0 # Update dist[] for every station following topological order for i in range(N): for j in range(i + 1, N): if cost[i][j] != -1 and dist[j] > dist[i] + cost[i][j]: dist[j] = dist[i] + cost[i][j] return dist[N-1]"},{"question":"You are required to implement the merge sort algorithm to demonstrate your understanding of sorting techniques and recursive algorithms. Merge sort should efficiently sort an array of integers in non-decreasing order. # Function Signature ```python def merge_sort(arr: list) -> list: pass ``` # Constraints * The function should accept a list of integers with a length of `n` where `1 <= n <= 10^5`. * The integers can be both positive and negative. # Input and Output * **Input**: A list of integers `arr`. * **Output**: A sorted list of integers in non-decreasing order. # Example ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([1]) [1] >>> merge_sort([]) [] ``` # Requirements 1. Ensure that the sorting algorithm uses merge sort principles. 2. Consider edge cases such as empty arrays and arrays with one element. 3. Target O(n log n) time complexity. 4. Minimize additional space usage as much as possible.","solution":"def merge_sort(arr: list) -> list: if len(arr) <= 1: return arr def merge(left, right): merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Capture any remaining elements in the sublists merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged # Recursive case mid = len(arr) // 2 left_sorted = merge_sort(arr[:mid]) right_sorted = merge_sort(arr[mid:]) return merge(left_sorted, right_sorted)"},{"question":"Enhanced Primality Check Function Background As part of a cybersecurity module, you are to implement a function that verifies the primality of a number and further extends the functionality by checking a range of numbers. Given the importance of prime numbers in encryption algorithms, understanding and implementing an efficient primality test is crucial. Problem Statement Write a function `range_prime_check(start, end)` that returns a list of all prime numbers between the given `start` and `end` (inclusive). Ensure that your implementation leverages an efficient approach to avoid excessive computations, drawing from the provided primality test method for individual numbers. Function Signature ```python def range_prime_check(start: int, end: int) -> List[int]: pass ``` Input * `start` (int): The beginning of the range (inclusive). * `end` (int): The end of the range (inclusive). Output * A list of integers representing all the prime numbers within the specified range. If there are no prime numbers in the range, return an empty list. Constraints * `1 <= start <= end <= 10^6` * Use the provided prime-checking function as a reference for testing individual numbers. Example ```python assert range_prime_check(10, 20) == [11, 13, 17, 19] assert range_prime_check(20, 30) == [23, 29] assert range_prime_check(1, 1) == [] assert range_prime_check(2, 2) == [2] ``` Notes * Consider edge cases such as the smallest range where `start` = `end`. * Optimize for the given constraint range, avoiding redundant checks.","solution":"from typing import List def is_prime(n: int) -> bool: Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def range_prime_check(start: int, end: int) -> List[int]: Returns a list of all prime numbers between `start` and `end` (inclusive). primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) return primes"},{"question":"# Generate Prime Numbers Efficiently **Scenario**: You are a software developer working on optimizing an application that requires frequent generation of prime numbers for various \\"challenge\\" puzzles in a game. Efficient algorithms will save computational time and enhance the gaming experience. **Objective**: Write a function that uses an optimized version of the Sieve of Eratosthenes to generate all prime numbers less than a given integer \'n\'. The algorithm should skip even numbers to save memory and computation. **Function Signature**: ```python def get_primes(n: int) -> List[int]: ``` **Input**: * An integer \'n\' (0 ≤ n ≤ 10^6): The upper limit to generate prime numbers. **Output**: * A list of all prime numbers less than \'n\'. **Constraints**: * Your solution should efficiently handle upper limits up to 1,000,000. * Proper error handling for non-positive integers (0 and negative values). **Performance Requirements**: * The implementation should be efficient both in terms of time and space complexity. **Example**: 1. Input: `get_primes(10)` Output: `[2, 3, 5, 7]` 2. Input: `get_primes(2)` Output: `[ ]` 3. Input: `get_primes(1)` Output: `[ ]` 4. Input: `get_primes(30)` Output: `[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]` **Detailed Description**: * Initialize a boolean sieve array representing potential prime candidates (excluding evens). * Mark non-primes iteratively using the property of primes. * Collect and return the prime numbers less than the given integer. **Edge Cases**: * When `n` is 0 or 1, the result should be an empty list. * Verify input is a positive integer; otherwise, raise an appropriate error. **Note**: Focus on optimizing space and time complexity by skipping even numbers except 2 and sorting the logic in a structured manner.","solution":"from typing import List def get_primes(n: int) -> List[int]: Generates all prime numbers less than a given integer \'n\' using an optimized version of the Sieve of Eratosthenes. Parameters: n (int): The upper limit to generate prime numbers. Returns: List[int]: A list of all prime numbers less than \'n\'. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False primes = [num for num, is_prime in enumerate(sieve) if is_prime] return primes"},{"question":"# Remove Duplicates from a Singly Linked List Objective You are given an implementation to remove duplicate nodes from a singly linked list. Your task is to create a new function, `remove_dups_optimized`, which removes duplicates in an optimized manner, ensuring efficient time and space complexity. Problem Statement Implement a function `remove_dups_optimized` to remove duplicate elements from a singly linked list. Function Signature ```python def remove_dups_optimized(head: Node) -> None: # your code here ``` Input * `head`: A `Node` object that represents the head of the singly linked list. Output * The function should modify the linked list in place to remove duplicates. The linked list should retain the original order but contain no duplicate elements. Constraints * Each node in the linked list contains a string value. * The linked list can contain up to (10^4) nodes. Examples ```python # Example 1 # Linked List: A -> A -> B -> C -> D -> C -> F -> G # After removing duplicates: A -> B -> C -> D -> F -> G # Input a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups_optimized(a1) # Output # The linked list should now be A -> B -> C -> D -> F -> G # Use a function like print_linked_list to verify the results ``` Performance Requirements * The implementation should have a time complexity of O(N) and space complexity of O(N).","solution":"class Node: def __init__(self, value): self.value = value self.next = None def remove_dups_optimized(head: Node) -> None: Removes duplicate elements from a singly linked list. if not head: return current = head seen = set([current.value]) while current.next: if current.next.value in seen: current.next = current.next.next else: seen.add(current.next.value) current = current.next def print_linked_list(head: Node): Utility function to print the contents of the linked list. elements = [] current = head while current: elements.append(current.value) current = current.next return \\" -> \\".join(elements)"},{"question":"# Question: 1-Sparse Stream Algorithm Implementation In a given sequence of operations, each represented by a tuple (number, sign), we need to determine whether this sequence is 1-sparse. A sequence is defined as 1-sparse if, after cancelling out elements, exactly one unique number remains. Write a function `is_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]` that takes in a stream of tuples and outputs the unique number if the stream is 1-sparse or `None` otherwise. Function Signature ```python from typing import List, Tuple, Optional def is_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: pass ``` Expected Input - **stream**: A list of tuples where each tuple contains an integer and a sign (\'+\' or \'-\'). Expected Output - An integer representing the unique number (if 1-sparse). - `None` if the stream is not 1-sparse. Constraints - Stream elements are non-negative integers. - Stream length up to 10^5. - Input values can be large but fit within standard 32-bit integers. Examples 1. **Example 1**: ```python stream = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] print(is_one_sparse(stream)) # Output: 4 ``` 2. **Example 2**: ```python stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] print(is_one_sparse(stream)) # Output: 2 ``` 3. **Example 3**: ```python stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] print(is_one_sparse(stream)) # Output: None ``` Performance Requirements Your solution should ensure efficiency, given a large input size with time complexity ideally at O(n * b), where n is the length of the stream and b is the bit representation length.","solution":"from typing import List, Tuple, Optional from collections import defaultdict def is_one_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: count = defaultdict(int) for number, sign in stream: if sign == \'+\': count[number] += 1 elif sign == \'-\': count[number] -= 1 unique_numbers = [num for num, cnt in count.items() if cnt != 0] if len(unique_numbers) == 1: return unique_numbers[0] return None"},{"question":"# ZigZag Iterator for Multiple Lists Context Your task is to generalize the ZigZagIterator, making it capable to handle an arbitrary number of input lists. The iterator should pick elements from each list in a round-robin fashion until all lists are exhausted. Consider the situation where you are merging various input streams for processing them alternately. Function Implementation Implement a class `ZigZagIterator` that supports the following operations: - **Initialization**: Accepts an arbitrary number of lists. - **next()**: Returns the next element in zigzag order. - **has_next()**: Returns a boolean indicating whether there are more elements to iterate. Constraints - Each list can contain between 0 and 1000 elements. - The number of lists can range from 2 to 10. - Elements within the lists are integers. - The operations `next()` and `has_next()` should take O(1) time on average. Input/Output Formats # Initialization ```python iterator = ZigZagIterator(list1, list2, ..., listN) ``` * `list1, list2, ..., listN`: Lists of integers. # Methods ```python element = iterator.next() ``` * Returns the next integer. ```python has_elements = iterator.has_next() ``` * Returns a boolean indicating if there are more elements to iterate. Example Scenario ```python lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] iterator = ZigZagIterator(*lists) output = [] while iterator.has_next(): output.append(iterator.next()) print(output) # Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` Edge Cases and Considerations 1. Some of the lists may be empty. 2. The lists may have different lengths. 3. Consider the performance implications of `pop` and `append` operations.","solution":"from collections import deque class ZigZagIterator: def __init__(self, *lists): Initialize your data structure here. :type lists: List[List[int]] self.queue = deque() for lst in lists: if lst: self.queue.append(deque(lst)) def next(self): :rtype: int if self.has_next(): current_list = self.queue.popleft() result = current_list.popleft() if current_list: self.queue.append(current_list) return result raise Exception(\\"No more elements\\") def has_next(self): :rtype: bool return bool(self.queue)"},{"question":"URL Query Parameter Stripping and Deduplication You are working on a web analytics project and need to sanitize URLs by removing duplicate query parameters and optionally stripping out specified parameters. The task is to implement a function that achieves this in an efficient manner. Task Implement the function `sanitize_url(url: str, params_to_strip: list = None) -> str` that performs the following operations: 1. Removes any duplicate query string parameters from the URL, keeping the first occurrence. 2. Removes any query string parameters specified in the `params_to_strip` list. Input * `url` (string): The URL to sanitize, which can include or exclude query parameters. * `params_to_strip` (list): An optional list of query parameters to be removed from the URL. Output * Returns the sanitized URL as a string with the specified parameters removed and no duplicate parameters. Constraints * The input URL may or may not contain query parameters. * The `params_to_strip` list can be empty or contain parameters to be removed from the URL. * Parameter and value pairs must be separated by `&` and values assigned by `=`. * Assume input URLs are well-formed and valid. Example 1. `sanitize_url(\'www.example.com?a=1&b=2&a=2\')` returns `\'www.example.com?a=1&b=2\'` 2. `sanitize_url(\'www.example.com?a=1&b=2&a=2\', [\'b\'])` returns `\'www.example.com?a=1\'` 3. `sanitize_url(\'www.example.com\')` returns `\'www.example.com\'` Notes * The order of query parameters should be preserved. * If a URL has no query parameters, the URL should be returned as is.","solution":"from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse def sanitize_url(url: str, params_to_strip: list = None) -> str: Sanitizes the URL by removing duplicate query parameters and optionally stripping out specified parameters. Args: url (str): The URL to sanitize. params_to_strip (list): A list of query parameters to be removed. Returns: str: The sanitized URL. if params_to_strip is None: params_to_strip = [] parsed_url = urlparse(url) query_params = parse_qsl(parsed_url.query, keep_blank_values=True) seen_params = set() sanitized_params = [] for key, value in query_params: if key not in seen_params and key not in params_to_strip: sanitized_params.append((key, value)) seen_params.add(key) new_query_string = urlencode(sanitized_params) sanitized_url = urlunparse(parsed_url._replace(query=new_query_string)) return sanitized_url"},{"question":"# Question: Counting Sort with Constraints You are given an array of integers, `arr`, where each integer within the array can range from any small negative value to a positive value. However, the values may have a significant difference and the array may contain negative numbers. Your task is to implement the `counting_sort` function that sorts the given array using the Counting Sort algorithm. # Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: A list of integers of length `n` (0 <= n <= 10^6). # Output * A sorted list of integers. # Constraints * The elements of the array can be both negative and positive. * Sorting should be done in non-decreasing order. * Aim to achieve time complexity of O(n + k) where `k` is the range of elements in the array. # Example ```python assert counting_sort([4, 2, -3, 6, 2, -5, 3, -1]) == [-5, -3, -1, 2, 2, 3, 4, 6] assert counting_sort([0, 5, -1, 3, 1, 4, 2, 0]) == [-1, 0, 0, 1, 2, 3, 4, 5] ``` # Explanation The function should handle: 1. Arrays with negative numbers by transforming them to positives, sorting, and transforming back. 2. Empty arrays and arrays with single unique values efficiently. 3. Optimally consider the range of input to manage memory use.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: Sorts the given array using the Counting Sort algorithm. if not arr: return [] min_elem = min(arr) max_elem = max(arr) range_of_elements = max_elem - min_elem + 1 # Initialize the count array count_arr = [0] * range_of_elements # Store the count of each element for num in arr: count_arr[num - min_elem] += 1 # Calculate the cumulative count for i in range(1, range_of_elements): count_arr[i] += count_arr[i - 1] # Place the elements into the output array output_arr = [0] * len(arr) for num in reversed(arr): output_arr[count_arr[num - min_elem] - 1] = num count_arr[num - min_elem] -= 1 return output_arr"},{"question":"# Segment Tree Coding Challenge A company is developing a real-time dashboard for monitoring metrics. They need a data structure to process multiple types of metrics, such as summation, maximum, and complex pair-wise updates. You have been tasked with implementing a segment tree that supports these requirements efficiently. Write a SegmentTree class based on the provided specification to support the following functionalities: 1. **Constructor**: Initialize the segment tree with a given array and a function. 2. **Build Tree**: Construct the segment tree. 3. **Update**: Update an element in the array. 4. **Query**: Perform a range query to retrieve information based on the function provided. Your implementation should ensure that all operations are efficient and handle various edge cases. # Function Signatures ```python class SegmentTree: def __init__(self, arr, function): Initialize the SegmentTree with the given array and commutative function. :param arr: List of initial elements :param function: A commutative function to combine elements def update(self, p, v): Update the element at index p to value v. :param p: Index to update :param v: New value for the element at index p def query(self, l, r): Perform a range query from index l to r using the provided function. :param l: Start index of the range :param r: End index of the range :return: Result of the query on the range ``` # Input/Output Examples ```python # Example 1: mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Example 2: mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Example 3: mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` # Constraints and Requirements 1. The function provided to the SegmentTree should be commutative. 2. The input array length N is such that 1 ≤ N ≤ 10^5. 3. Queries and updates should run within O(log N) time complexity. 4. Initializing the tree should be done in O(N) time complexity.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.func = function self.tree = [None] * (2 * self.n) self.build_tree() def build_tree(self): # Initialize tree with the original array values for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Build the tree by calculating internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, v): # Update the tree p += self.n self.tree[p] = v while p > 1: p //= 2 self.tree[p] = self.func(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): res = None l += self.n r += self.n+1 while l < r: if l % 2 == 1: res = self.tree[l] if res is None else self.func(res, self.tree[l]) l += 1 if r % 2 == 1: r -= 1 res = self.tree[r] if res is None else self.func(res, self.tree[r]) l //= 2 r //= 2 return res"},{"question":"# Unique Binary Search Trees Calculation Objective Write a function that calculates the number of structurally unique Binary Search Trees (BSTs) that can be constructed using `n` distinct nodes, where the nodes are labeled from 1 to `n`. Input * An integer `n` (1 ≤ n ≤ 19), representing the number of distinct nodes labeled from 1 to `n`. Output * An integer representing the number of structurally unique BSTs that can be formed with `n` nodes. Constraints * The function should efficiently calculate the result, leveraging dynamic programming or other efficient methods. * Optimize the solution for the upper limit of the input range. Performance * Target the solution to run within reasonable time for `n` up to 19. Example ```python assert num_trees(3) == 5 # Explanation: There are 5 unique BST structures. assert num_trees(1) == 1 # Explanation: There\'s only one structure (single node). ``` Function Signature ```python def num_trees(n: int) -> int: pass ``` **Additional Context**: This problem ties into combinatorial mathematics and is closely related to the Catalan numbers. Dynamic programming is a practical approach to solve this problem by breaking it down into simpler subproblems.","solution":"def num_trees(n: int) -> int: Compute the number of unique BSTs that can be formed with n distinct nodes. # Base case if n == 0 or n == 1: return 1 # Dynamic programming table to store the results for subproblems dp = [0] * (n + 1) # There is one unique BST with 0 or 1 nodes dp[0] = dp[1] = 1 # Fill the DP table for i in range(2, n + 1): for j in range(1, i + 1): dp[i] += dp[j - 1] * dp[i - j] return dp[n]"},{"question":"# Problem Description You are given a string of lowercase English characters. Write a function `first_unique_char(s)` that finds the index of the first non-repeating character in it. If it doesn\'t exist, return -1. # Function Signature ```python def first_unique_char(s: str) -> int: ``` # Input - `s` (1 ≤ |s| ≤ 10^5): A string of lowercase English characters. # Output - An integer representing the index of the first non-repeating character, or -1 if none exists. # Example ```python print(first_unique_char(\\"leetcode\\")) # Returns: 0 print(first_unique_char(\\"loveleetcode\\")) # Returns: 2 print(first_unique_char(\\"aabb\\")) # Returns: -1 ``` # Constraints - The function should run in linear time, O(n). - It should use constant extra space, O(1). # Scenario You are developing a text editor, and one of the features is to quickly highlight the first unique character typed by the user. This optimization ensures an efficient user experience, especially for large texts. # Additional Information - Consider edge cases such as strings of length 1, repeating characters, and mixed cases with repeated and unique characters. - Optimize your implementation for both time and space. # Notes - Use a dictionary to store the frequency of each character. - Traverse the string again to find the first character with a frequency of 1.","solution":"def first_unique_char(s: str) -> int: Finds the index of the first non-repeating character in a string. If no unique character exists, returns -1. # Dictionary to store frequency of each character char_count = {} # First pass to populate the frequency dictionary for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass to find the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"# Minimum Delete Operations to Make Strings Equal **Objective**: Given two strings `word1` and `word2`, write a function to find the minimum number of steps required to make both strings equal by deleting characters. Implement a solution that uses dynamic programming. **Description**: You are required to implement the function `min_delete_operations(word1: str, word2: str) -> int` that calculates the minimum number of delete operations needed to make `word1` and `word2` the same. **Input**: * `word1` - a string of length n (1 <= n <= 1000) * `word2` - a string of length m (1 <= m <= 1000) **Output**: * An integer representing the minimum number of delete operations. **Constraints**: * The strings will contain only lowercase English letters. **Examples**: 1. **Input**: `word1 = \\"sea\\", word2 = \\"eat\\"` **Output**: `2` **Explanation**: You need one step to make `word1` to `ea` and another step to make `word2` to `ea`. 2. **Input**: `word1 = \\"leetcode\\", word2 = \\"etco\\"` **Output**: `4` **Explanation**: You need four operations to convert `word1` to `etco`. **Performance Requirements**: * The solution must be efficient with a time complexity of O(n*m) and a space complexity of O(n*m). **Implementation Template**: ```python def min_delete_operations(word1, word2): # Implement the dynamic programming solution here pass ``` Implement the above function considering the edge cases and ensuring optimized performance.","solution":"def min_delete_operations(word1: str, word2: str) -> int: n, m = len(word1), len(word2) # Create a 2D dp array where dp[i][j] will store the minimum number of # delete operations needed to make word1[0..i-1] and word2[0..j-1] equal. dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize the first row and column. for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the dp array using the optimal substructure. for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1 return dp[n][m]"},{"question":"Context You are tasked with helping a text processing engine to optimize performance by identifying unique characters in strings efficiently. Given your knowledge of algorithms and data structures, you are to refactor the provided inefficient solution to achieve better time complexity. Problem Implement a function `first_unique_char_optimized(s)` that finds the first non-repeating character in a string `s` and returns its index. If no unique character exists, return -1. Ensure the solution adheres to the following constraints and is optimized for performance. Solution Constraints and Requirements * **Input**: A string `s` (1 ≤ len(s) ≤ 10^5), consisting of lowercase English letters. * **Output**: An integer representing the index of the first non-repeating character, or -1 if no such character exists. * **Performance**: The expected time complexity should be O(N) using appropriate data structures. Function Signature ```python def first_unique_char_optimized(s: str) -> int: pass ``` # Examples 1. **Input**: `\\"leetcode\\"` **Output**: `0` 2. **Input**: `\\"loveleetcode\\"` **Output**: `2` 3. **Input**: `\\"aabbcc\\"` **Output**: `-1` Additional Information * Carefully consider edge cases, such as strings with all repeating characters or very large strings. * Optimize the solution for both time and space complexity.","solution":"def first_unique_char_optimized(s: str) -> int: Finds the index of the first non-repeating character in a string. If no such character exists, return -1. from collections import Counter # Count the occurrences of each character in the string char_count = Counter(s) # Iterate over the string and find the first character with a count of 1 for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"You are given a 2D grid of size `n x n` initially filled with water (0). You perform a series of operations where you add a piece of land (1) at a given position. Each time you add a land, it can connect with adjacent lands horizontally or vertically to form an island. Your task is to implement the function `num_islands(positions: List[List[int]], n: int) -> List[int]` that takes as input: - A list `positions` of tuple (i, j) representing the positions where land is added. - An integer `n` representing the size of the grid. The function should return a list of integers representing the number of islands after each addLand operation. # Requirements: * You must use the Union-Find data structure to manage and track the connected components efficiently. * Consider edge cases like invalid positions or multiple lands being added to the same position. * The operations should be optimized using path compression and union by size to ensure efficient performance. # Constraints: 1. 0 <= positions.length <= 10^4 2. 0 <= n <= 1000 3. 0 <= i, j < n # Example: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] n = 3 # Expected Output: [1, 1, 2, 3] Explanation: Initially: 0 0 0 0 0 0 0 0 0 Operation #1: addLand(0, 0) Grid: 1 0 0 0 0 0 0 0 0 Number of islands = 1 Operation #2: addLand(0, 1) Grid: 1 1 0 0 0 0 0 0 0 Number of islands = 1 Operation #3: addLand(1, 2) Grid: 1 1 0 0 0 1 0 0 0 Number of islands = 2 Operation #4: addLand(2, 1) Grid: 1 1 0 0 0 1 0 1 0 Number of islands = 3 ``` Write your implementation for the function `num_islands`.","solution":"from typing import List class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n self.count = 0 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) # Path compression return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def add_land(self): self.count += 1 def get_count(self): return self.count def num_islands(positions: List[List[int]], n: int) -> List[int]: if n <= 0: return [] uf = UnionFind(n * n) # Create UnionFind for grid cells grid = [[0] * n for _ in range(n)] num_islands_list = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for pos in positions: r, c = pos if grid[r][c] == 1: # Already land num_islands_list.append(uf.get_count()) continue grid[r][c] = 1 current_id = r * n + c uf.add_land() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 1: neighbor_id = nr * n + nc uf.union(current_id, neighbor_id) num_islands_list.append(uf.get_count()) return num_islands_list"},{"question":"# Password Strengthening Challenge Louise is trying to create a password for her new account, but she\'s unsure if it meets the necessary strength criteria. A password is considered strong if it satisfies all the following conditions: 1. It is at least 6 characters long. 2. It contains at least one digit. 3. It contains at least one lowercase English letter. 4. It contains at least one uppercase English letter. 5. It contains at least one special character from this set: `!@#%^&*()-+`. Given the current password string that Louise typed, can you determine the minimum number of additional characters required to make her password strong? # Specific Instructions: - You need to implement the function `strong_password(n, password)` to compute the result. - **Input**: - `n` (integer): The length of the password typed by Louise. - `password` (string): The password typed by Louise. - **Output**: - A single integer representing the minimum number of characters she needs to add to make the password strong. # Constraints: - The password can consist of any combination of characters from the following sets: lowercase letters (`a-z`), uppercase letters (`A-Z`), digits (`0-9`), and special characters (`!@#%^&*()-+`). - You need to ensure the optimal solution in terms of both time and space complexity. # Examples: **Example 1:** ```python # Input n = 3 password = \\"Ab1\\" # Output print(strong_password(n, password)) # 3 # Explanation # Louise can add characters, for instance, \\"hk\\", to make the password \\"Ab1hk\\", which meets all criteria and is 6 characters long. # Adding fewer than 3 characters will not suffice since the length must reach at least 6. ``` **Example 2:** ```python # Input n = 11 password = \\"#Algorithms\\" # Output print(strong_password(n, password)) # 1 # Explanation # Louise\'s password \\"#Algorithms\\" requires only one digit to become strong. ``` ```python def strong_password(n, password): count_error = 0 # Return the minimum number of characters to make the password strong if any(i.isdigit() for i in password) == False: count_error = count_error + 1 if any(i.islower() for i in password) == False: count_error = count_error + 1 if any(i.isupper() for i in password) == False: count_error = count_error + 1 if any(i in \'!@#%^&*()-+\' for i in password) == False: count_error = count_error + 1 return max(count_error, 6 - n) ```","solution":"def strong_password(n, password): Determines the minimum number of characters needed to make the password strong. required_length = 6 required_chars = 0 # Check for presence of at least one digit if not any(char.isdigit() for char in password): required_chars += 1 # Check for presence of at least one lowercase letter if not any(char.islower() for char in password): required_chars += 1 # Check for presence of at least one uppercase letter if not any(char.isupper() for char in password): required_chars += 1 # Check for presence of at least one special character if not any(char in \'!@#%^&*()-+\' for char in password): required_chars += 1 # Calculate the additional characters needed to reach the required length of 6 additional_length_needed = max(0, required_length - n) return max(required_chars, additional_length_needed)"},{"question":"# Binary Heap Operations You are required to implement a `BinaryHeap` class representing a min-heap with the following functionalities: 1. **Initialization**: Initialize the binary heap. 2. **Insert**: Insert a given integer into the min-heap. 3. **Remove Min**: Remove and return the smallest element from the min-heap. 4. **Peek Min**: Return (without removing) the smallest element from the min-heap. 5. **Heapify**: Build a heap from an unordered array. # Requirements - The class must be implemented from scratch without using Python’s built-in heapq module. - You need to handle edge cases such as inserting into an empty heap, removing from an empty heap, and duplicate elements. - Maintain efficient performance for the operations: Insert and Remove Min operations should be O(log N). # Input and Output Formats 1. **Insert Operation**: A single integer to be inserted. 2. **Remove Min Operation**: No input value. 3. **Peek Min Operation**: No input value. 4. **Heapify Operation**: A list of integers. # Constraints - Integers will be in the range -10^6 to 10^6. - The number of operations will not exceed 10^5. # Function Signature ```python class BinaryHeap: def __init__(self): # initialize your heap def insert(self, val: int): # Insert a value into the heap def remove_min(self) -> int: # Remove and return the smallest element from the heap def peek_min(self) -> int: # Return (without removing) the smallest element from the heap def heapify(self, alist: list): # Build a heap from an unordered list ``` # Examples Example 1 ```python bh = BinaryHeap() bh.insert(10) bh.insert(5) bh.insert(30) print(bh.peek_min()) # should return 5 print(bh.remove_min()) # should return 5 print(bh.peek_min()) # should return 10 bh.insert(2) print(bh.peek_min()) # should return 2 ``` Example 2 ```python bh = BinaryHeap() bh.heapify([7, 1, 5, 2, 10]) print(bh.peek_min()) # should return 1 print(bh.remove_min()) # should return 1 print(bh.remove_min()) # should return 2 print(bh.remove_min()) # should return 5 ``` Implement the `BinaryHeap` class and its required methods so that it adheres to the provided example behaviors and handles constraints effectively.","solution":"class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val: int): self.heap.append(val) self._sift_up(len(self.heap) - 1) def remove_min(self) -> int: if not self.heap: raise IndexError(\\"remove_min() from empty heap\\") min_val = self.heap[0] last_val = self.heap.pop() if self.heap: self.heap[0] = last_val self._sift_down(0) return min_val def peek_min(self) -> int: if not self.heap: raise IndexError(\\"peek_min() from empty heap\\") return self.heap[0] def heapify(self, alist: list): self.heap = alist[:] for i in range(len(self.heap) // 2 - 1, -1, -1): self._sift_down(i) def _sift_up(self, idx): while idx > 0: parent_idx = (idx - 1) // 2 if self.heap[idx] < self.heap[parent_idx]: self.heap[idx], self.heap[parent_idx] = self.heap[parent_idx], self.heap[idx] idx = parent_idx else: break def _sift_down(self, idx): while 2 * idx + 1 < len(self.heap): smallest_child_idx = 2 * idx + 1 right_child_idx = 2 * idx + 2 if right_child_idx < len(self.heap) and self.heap[right_child_idx] < self.heap[smallest_child_idx]: smallest_child_idx = right_child_idx if self.heap[idx] > self.heap[smallest_child_idx]: self.heap[idx], self.heap[smallest_child_idx] = self.heap[smallest_child_idx], self.heap[idx] idx = smallest_child_idx else: break"},{"question":"You need to write a function to find all unique triplets in a given list of integers that sum to zero. Your implementation should be efficient both in terms of time and space complexity and it must handle duplicates efficiently. Function Signature ```python def find_triplets(nums: List[int]) -> Set[Tuple[int, int, int]]: Finds all unique triplets in the array which gives the sum of zero. :param nums: List[int] - List of integers :return: Set[Tuple[int, int, int]] - Set of unique triplets (each triplet is a tuple of three integers) ``` Input - A list of integers `nums` with length `n` (0 ≤ n ≤ 10^4). Each integer\'s value is between -10^5 to 10^5. Output - A set of tuples, each containing three integers such that their sum is zero. Each tuple represents a unique triplet. Constraints - The triplets should be unique. - The order of output does not matter. Example ```python assert find_triplets([-1, 0, 1, 2, -1, -4]) == {(-1, 0, 1), (-1, -1, 2)} assert find_triplets([0, 0, 0, 0]) == {(0, 0, 0)} ``` Notes - Make sure to consider edge cases such as arrays with fewer than 3 elements and arrays with no valid triplets. - Ensure your algorithm handles duplicates correctly and efficiently in terms of both time complexity and memory usage.","solution":"from typing import List, Set, Tuple def find_triplets(nums: List[int]) -> Set[Tuple[int, int, int]]: nums.sort() # Sort the numbers first result = set() n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i-1]: continue # Skip duplicate elements for i left, right = i + 1, n - 1 while left < right: s = nums[i] + nums[left] + nums[right] if s == 0: result.add((nums[i], nums[left], nums[right])) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicate elements for left while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicate elements for right left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return result"},{"question":"# Atbash Cipher Challenge Context: The Atbash cipher is a classical encryption technique where each letter of the alphabet is mapped to its reverse. This means \'a\' becomes \'z\', \'b\' becomes \'y\', and so forth. The cipher is case sensitive and retains non-alphabetic characters (spaces, punctuation, etc.) unchanged. Task: Implement a function `atbash_cipher(input_string: str) -> str` that returns the Atbash cipher transformation of the given input string. Input: - `input_string` (1 ≤ |input_string| ≤ 10^5): A string consisting of printable ASCII characters. Output: - A string that represents the Atbash cipher translation of the input string. Examples: ```python assert atbash_cipher(\\"Hello World!\\") == \\"Svool Dliow!\\" assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Python\\") == \\"Kbgslm\\" assert atbash_cipher(\\"1234! @#%\\") == \\"1234! @#%\\" ``` Constraints: - Handle both uppercase and lowercase letters appropriately. - Maintain non-alphabetic characters unchanged. - Optimize for large input sizes.","solution":"def atbash_cipher(input_string: str) -> str: Encrypts the input string using the Atbash cipher. def translate(char): if \'a\' <= char <= \'z\': return chr(219 - ord(char)) elif \'A\' <= char <= \'Z\': return chr(155 - ord(char)) return char return \'\'.join(translate(char) for char in input_string)"},{"question":"# Coding Challenge You are given a singly linked list where each node contains a string value representing a character. Implement a function `remove_duplicates_optimized(head)` that removes duplicate nodes from the list while maintaining the first occurrence of each character. Function Signature ```python def remove_duplicates_optimized(head: Node) -> None: pass ``` # Input - `head`: A `Node` object representing the head of a singly linked list. Each node has a `val` attribute containing a string character and a `next` attribute pointing to the next node. # Output - The function modifies the linked list in place with no return value. All duplicate nodes should be removed. # Constraints 1. The list can have up to 10^5 nodes. 2. The list values are single character strings (a-z, A-Z). # Performance Requirements - Aim to achieve a time complexity of O(N) and a space complexity of O(N). # Example ```python # A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates_optimized(a1) print_linked_list(a1) # Expected Output: A -> B -> C -> D -> F -> G ``` # Additional Notes - Consider the requirements on time and space complexity when designing your solution. - Make sure to handle edge cases appropriately in your implementation.","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def remove_duplicates_optimized(head: Node) -> None: if head is None: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Factorization Algorithm * **Type**: Number Factorization * **Main Purpose**: The algorithm identifies all possible combinations of factors of an integer n that are greater than 1 and less than n. # Complexity * **Time Complexity**: O(n log n), since for each number, it checks each integer up to the square root. * **Space Complexity**: O(n log n) due to the storage requirements for the combinations and the call stack (in the recursive version). # Principles * **Operational Steps**: 1. Iterate through possible factors starting from 2. 2. For each factor that divides the number without a remainder, record the factor and recursively or iteratively apply the same process to the quotient. 3. Collect all combinations of factors that produce the given number. # Characteristics & Applications * **Properties**: It only considers factors that are greater than 1 and less than the target number. Uses both iterative and recursive approaches. * **Common Use Cases**: Prime factorization, divisibility problems, problems requiring the analysis of number compositions. * **Strengths/Limitations**: * **Strengths**: Efficient in factorizing smaller numbers, straightforward to implement both iteratively and recursively. * **Limitations**: May become less efficient for large numbers due to excessive factor combination generation and recursive depth. # Implementation Challenges * **Edge Cases**: - When n = 1 or a prime number (no factors other than 1 and itself). - When n is a perfect power (e.g., 16 = 2^4). * **Performance Bottlenecks**: Large values of n may lead to high memory usage and stack overflow in recursive versions. * **Error Scenarios**: Improper handling of nested factor combinations, especially in recursive approach. * **Optimization Points**: Use memoization to store and reuse previously calculated factors, Tail recursion optimization to manage deeper recursion. <|Analysis End|> <|Question Begin|> # Factor Combinations Problem **Objective**: Write a Python function that takes an integer n and returns all possible combinations of its factors, excluding 1 and the number itself. **Function Signature**: `def get_factor_combinations(n: int) -> List[List[int]]` # Inputs * **n**: An integer (1 <= n <= 10^6). # Outputs * **List[List[int]]**: A list of lists, where each list contains a combination of factors of n. # Constraints * Factors should be greater than 1 and less than n. **Examples**: ``` Input: 1 Output: [] Input: 37 Output: [] Input: 12 Output: [ [2, 6], [2, 2, 3], [3, 4] ] Input: 32 Output: [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` **Additional Notes**: 1. Ensure that your code handles large values within the given constraints efficiently. 2. Consider edge cases such as primes and numbers with repeated factors. 3. Your implementation can be either iterative or recursive, but make sure to handle recursion depths appropriately. <| Question End|>","solution":"from typing import List def get_factor_combinations(n: int) -> List[List[int]]: def helper(start, n): result = [] i = start while i * i <= n: if n % i == 0: if i <= n // i: result.append([i, n // i]) for rest in helper(i, n // i): result.append([i] + rest) i += 1 return result return helper(2, n) if n > 1 else []"},{"question":"Scenario and Context You are designing a gaming system that requires maintaining a dynamic collection of player IDs. The collection must allow you to quickly add new players, remove absent players, and select a random player for spotlight events efficiently. Task Implement a data structure `GamePlayerSet`, which supports the following operations: * `add_player(player_id: int) -> bool`: Adds a player ID to the set if it is not already present. Returns `True` if the player was added, `False` otherwise. * `remove_player(player_id: int) -> bool`: Removes a player ID from the set if it is present. Returns `True` if the player was removed, `False` otherwise. * `select_random() -> int`: Returns a random player ID from the current set of players. Each player ID should have an equal probability of being returned. # Function Signatures ```python class GamePlayerSet: def __init__(self): # Your initialization here def add_player(self, player_id: int) -> bool: # Implementation here def remove_player(self, player_id: int) -> bool: # Implementation here def select_random(self) -> int: # Implementation here ``` # Constraints * Each `player_id` is a unique integer within the range: (-10^9 <= player_id <= 10^9). * Operations will be called in any order. * You need to ensure that all operations are performed with an average time complexity of O(1). # Example Usage ```python game_set = GamePlayerSet() print(game_set.add_player(1)) # Output: True print(game_set.add_player(2)) # Output: True print(game_set.add_player(1)) # Output: False print(game_set.remove_player(1)) # Output: True print(game_set.select_random()) # Output: 2 or any other player still in the set ``` # Performance Requirements Make sure all primary operations (`add_player`, `remove_player`, `select_random`) are handled with an average time complexity of O(1).","solution":"import random class GamePlayerSet: def __init__(self): self.player_set = set() self.player_list = [] def add_player(self, player_id: int) -> bool: if player_id in self.player_set: return False self.player_set.add(player_id) self.player_list.append(player_id) return True def remove_player(self, player_id: int) -> bool: if player_id not in self.player_set: return False self.player_set.remove(player_id) self.player_list.remove(player_id) return True def select_random(self) -> int: if not self.player_list: raise ValueError(\\"No players available to select.\\") return random.choice(self.player_list)"},{"question":"You are given a string `s` and two other strings `part1` and `part2`. Write a function `is_merge` to determine if `s` can be formed by merging `part1` and `part2` while maintaining the order of characters in both `part1` and `part2`. Your function should return `True` if `s` is a valid merge, and `False` otherwise. Input and Output Formats * **Input**: * `s` (a string with length `len_s`) * `part1` (a string with length `len_part1`) * `part2` (a string with length `len_part2`) * **Output**: * Returns `True` if `s` can be formed by merging `part1` and `part2`. * Returns `False` otherwise. Constraints: * Strings can contain any printable ASCII characters. * Length of `s`, `part1`, and `part2` will not exceed 1000 characters. Performance Requirements: * Attempt to optimize for both time and space complexity for potential large input sizes. Scenario: Imagine you are developing a text processing tool that validates if a constructed string `s` can be decomposed into two source strings `part1` and `part2` without rearranging the characters within `part1` and `part2`. # Example: ```python # Example 1 s = \\"codewars\\" part1 = \\"cdw\\" part2 = \\"oears\\" is_merge(s, part1, part2) # Expected output: True # Example 2 s = \\"abcd\\" part1 = \\"abc\\" part2 = \\"d\\" is_merge(s, part1, part2) # Expected output: True # Example 3 s = \\"abcd\\" part1 = \\"ab\\" part2 = \\"ce\\" is_merge(s, part1, part2) # Expected output: False ``` # Function Signature: ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` Please ensure your code handles edge cases effectively and is optimized for both time and space complexity.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: len_s, len_part1, len_part2 = len(s), len(part1), len(part2) if len_s != len_part1 + len_part2: return False dp = [[False] * (len_part2 + 1) for _ in range(len_part1 + 1)] dp[0][0] = True for i in range(len_part1 + 1): for j in range(len_part2 + 1): if i > 0 and s[i + j - 1] == part1[i - 1] and dp[i - 1][j]: dp[i][j] = True if j > 0 and s[i + j - 1] == part2[j - 1] and dp[i][j - 1]: dp[i][j] = True return dp[len_part1][len_part2]"},{"question":"You are tasked with implementing a robust maximum flow algorithm for a given flow network represented as an adjacency matrix. **Objective**: Write a function `max_flow_algorithms` that computes the maximum flow from the source node `s` to the sink node `t` using the following algorithms: - Ford-Fulkerson algorithm using DFS - Edmonds-Karp algorithm using BFS - Dinic\'s algorithm **Input**: - `capacity` (List[List[int]]): A 2D list where `capacity[i][j]` represents the capacity of the edge from node `i` to node `j`. A value of `0` means no edge. - `s` (int): Index of the source node. - `t` (int): Index of the sink node. - `method` (str): Algorithm method to use (\\"ford_fulkerson\\", \\"edmonds_karp\\", or \\"dinic\\"). **Output**: - `result` (int): The maximum flow possible from `s` to `t`. **Function Signature**: ```python def max_flow_algorithms(capacity: List[List[int]], s: int, t: int, method: str) -> int: pass ``` **Constraints**: - `0 <= s, t < len(capacity)` - All capacities are non-negative integers. - Capacity matrix `capacity` has dimensions NxN where `2 <= N <= 100`. **Requirements**: 1. Handle edge cases, such as no path from `s` to `t`, and disconnected components. 2. Optimize for large graphs and ensure memory efficiency. 3. Implement proper flow conservation throughout the network. # Example ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] s = 0 t = 5 # Using Ford-Fulkerson print(max_flow_algorithms(capacity, s, t, \\"ford_fulkerson\\")) # Output: 23 # Using Edmonds-Karp print(max_flow_algorithms(capacity, s, t, \\"edmonds_karp\\")) # Output: 23 # Using Dinic\'s Algorithm print(max_flow_algorithms(capacity, s, t, \\"dinic\\")) # Output: 23 ``` **Note**: - Ensure to include extensive comments and documentation within the code to explain the logic. - Validate the inputs and handle any edge cases effectively.","solution":"from collections import deque def max_flow_algorithms(capacity, s, t, method): def bfs(cap, s, t, parent): visited = [False] * len(cap) queue = deque([s]) visited[s] = True while queue: u = queue.popleft() for v, capacity in enumerate(cap[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == t: return True return False def dfs(cap, s, t, flow, visited): if s == t: return flow visited[s] = True for v, capacity in enumerate(cap[s]): if not visited[v] and capacity > 0: min_flow = min(flow, capacity) result = dfs(cap, v, t, min_flow, visited) if result > 0: cap[s][v] -= result cap[v][s] += result return result return 0 def ford_fulkerson(cap, s, t): max_flow = 0 while True: visited = [False] * len(cap) flow = dfs(cap, s, t, float(\'inf\'), visited) if flow == 0: break max_flow += flow return max_flow def edmonds_karp(cap, s, t): max_flow = 0 parent = [-1] * len(cap) while bfs(cap, s, t, parent): path_flow = float(\'inf\') v = t while v != s: u = parent[v] path_flow = min(path_flow, cap[u][v]) v = u v = t while v != s: u = parent[v] cap[u][v] -= path_flow cap[v][u] += path_flow v = u max_flow += path_flow return max_flow def dinic_bfs(level, cap, s, t): queue = deque([s]) level[s] = 0 while queue: u = queue.popleft() for v, capacity in enumerate(cap[u]): if level[v] < 0 and capacity > 0: level[v] = level[u] + 1 queue.append(v) return level[t] >= 0 def dinic_dfs(cap, ptr, level, u, t, flow): if u == t: return flow while ptr[u] < len(cap): v = ptr[u] if level[v] == level[u] + 1 and cap[u][v] > 0: min_flow = min(flow, cap[u][v]) result = dinic_dfs(cap, ptr, level, v, t, min_flow) if result > 0: cap[u][v] -= result cap[v][u] += result return result ptr[u] += 1 return 0 def dinic(cap, s, t): max_flow = 0 n = len(cap) level = [-1] * n while dinic_bfs(level, cap, s, t): ptr = [0] * n while True: flow = dinic_dfs(cap, ptr, level, s, t, float(\'inf\')) if flow == 0: break max_flow += flow level = [-1] * n return max_flow cap_copy = [row[:] for row in capacity] if method == \\"ford_fulkerson\\": return ford_fulkerson(cap_copy, s, t) elif method == \\"edmonds_karp\\": return edmonds_karp(cap_copy, s, t) elif method == \\"dinic\\": return dinic(cap_copy, s, t) else: raise ValueError(\\"Invalid method specified\\")"},{"question":"# Question: Regular Expression Matching You are to implement a function that performs regular expression matching with support for `.` and `*`. The matching should cover the entire input string (not partial). Function Signature: ```python def is_match(s: str, p: str) -> bool: # your code here ``` Input: - `s` (str): The input string to be matched. - `p` (str): The pattern string containing the regex rules. Output: - Returns `True` if the input string matches the pattern; otherwise, returns `False`. Example: ```python print(is_match(\\"aa\\", \\"a\\")) # Output: False print(is_match(\\"aa\\", \\"aa\\")) # Output: True print(is_match(\\"aaa\\", \\"aa\\")) # Output: False print(is_match(\\"aa\\", \\"a*\\")) # Output: True print(is_match(\\"aa\\", \\".*\\")) # Output: True print(is_match(\\"ab\\", \\".*\\")) # Output: True print(is_match(\\"aab\\", \\"c*a*b\\")) # Output: True ``` Constraints: 1. Input strings `s` and `p` may contain only lowercase alphabetic characters and the special characters `.` and `*`. 2. The function must match the entire input string, not just a substring. Requirements: - Optimize for both time and space where possible. - Consider and handle edge cases like empty strings and patterns. - Ensure clarity in your code structure and inline comments.","solution":"def is_match(s: str, p: str) -> bool: Return True if the input string s matches the pattern p. \'.\' Matches any single character. \'*\' Matches zero or more of the preceding element. The entire input string s must be matched by the pattern p. # Function to check if character s matches character pattern p at respective positions def matches(si, pi): if si == len(s): return False if p[pi] == \'.\': return True return s[si] == p[pi] m, n = len(s), len(p) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for pi in range(1, n + 1): if p[pi - 1] == \'*\': dp[0][pi] = dp[0][pi - 2] for si in range(1, m + 1): for pi in range(1, n + 1): if p[pi - 1] == \'*\': dp[si][pi] = dp[si][pi - 2] or (matches(si - 1, pi - 2) and dp[si - 1][pi]) else: dp[si][pi] = matches(si - 1, pi - 1) and dp[si - 1][pi - 1] return dp[m][n]"},{"question":"# Scenario You are maintaining a list of scores for a game that must always be sorted in ascending order. Players constantly obtain new scores, and you need to efficiently insert each new score into the sorted list. # Problem Statement Write a function `insert_sorted_score(scores, new_score)` that takes in: - `scores` (a list of integers): a sorted list of scores. - `new_score` (an integer): a new score to be added to the scores list. This function should insert the `new_score` into its correct position in the sorted list `scores`. To achieve this in an efficient manner, make use of the `search_insert` function provided for finding the correct insertion point. # Input - `scores`: List of integers where each integer is a score, and the list is in ascending order. - `new_score`: An individual integer representing a new score to be added. # Output Return the updated list with the new score inserted in the correct position. # Constraints - The initial list `scores` will be sorted in ascending order and will contain between 0 and 1000 scores. - The `new_score` will be an integer between 0 and 10000. - Your solution should aim to insert the new score in O(log n) time for finding the position in the list. # Example ```python scores = [55, 78, 89, 92] new_score = 85 insert_sorted_score(scores, new_score) ``` Expected Output: `[55, 78, 85, 89, 92]` # Solution Template ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insert_sorted_score(scores, new_score): # Implement your solution here. pass # Example usage: scores = [55, 78, 89, 92] new_score = 85 print(insert_sorted_score(scores, new_score)) # Output: [55, 78, 85, 89, 92] ```","solution":"def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def insert_sorted_score(scores, new_score): position = search_insert(scores, new_score) scores.insert(position, new_score) return scores # Example usage: scores = [55, 78, 89, 92] new_score = 85 print(insert_sorted_score(scores, new_score)) # Output: [55, 78, 85, 89, 92]"},{"question":"# Scenario You are given a list of numbers and a maximum occurrence limit `N`. Your task is to create a function that processes the list and returns a new list where each number appears at most `N` times while preserving the order of their first occurrences. # Function Signature ```python def limit_occurrences(lst: List[int], N: int) -> List[int]: Parameters: lst (List[int]): The input list of numbers. N (int): The maximum allowed occurrences for each number. Returns: List[int]: A new list where each number appears at most N times. ``` # Input * `lst`: a list of integers. * `N`: a non-negative integer specifying the maximum allowed occurrences. # Output * Return a list of integers where each integer appears at most `N` times. # Constraints * The input list can be of length up to `10^5`. * Each integer in the list can range from `-10^6` to `10^6`. * The value of `N` can range from `0` to `10^5`. # Examples ```python assert limit_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert limit_occurrences([20, 37, 20, 21], 1) == [20, 37, 21] assert limit_occurrences([1, 1, 1, 1], 0) == [] assert limit_occurrences([], 2) == [] ``` # Performance Requirements * The function should have a time complexity of O(n) to handle larger lists efficiently.","solution":"def limit_occurrences(lst, N): Returns a new list where each number appears at most N times. Parameters: lst (List[int]): The input list of numbers. N (int): The maximum allowed occurrences for each number. Returns: List[int]: A new list where each number appears at most N times. from collections import defaultdict count = defaultdict(int) result = [] for number in lst: if count[number] < N: result.append(number) count[number] += 1 return result"},{"question":"Implement Variants of Searching Algorithms Context You are tasked with implementing a search algorithm that has a similar structure to Jump Search but can adapt to blocks of varying sizes dynamically. Your job is to extend the current Jump Search to support variable block sizes and dynamically compute the best block size based on the array elements. Objective Write a function `jump_search_variable_block` that searches for a target element in a **sorted** array. While the core idea of dividing the array into blocks and performing a linear search within the blocks remains the same, your task is to: 1. Dynamically determine the block size. 2. Enhance the search to handle more edge cases and provide optimized performance. Function Signature ```python def jump_search_variable_block(arr, target): # Implement your logic here ``` Input Format - `arr`: List of integers, sorted in non-decreasing order. - `target`: Integer value to search. Output Format - Return the index of the target if found, otherwise return -1. Constraints - Array elements should be between -10^5 to 10^5. - Array length should not exceed 10^6. - The target value will also be an integer ranging within the array element limits. Example ```python example_array = [1, 3, 5, 7, 9, 11, 13, 15, 17] target = 15 print(jump_search_variable_block(example_array, target)) # Output should be 7 ``` Requirements 1. Your function should handle edge cases effectively, like an empty array or the target being outside the range of array elements. 2. You should provide an efficient mechanism for dynamically determining the block size. 3. The function implementation should optimize searching within the block for better performance. Note - Do not use any built-in search functions like Python\'s `index` or `bisect` methods. - Strive for clarity and efficiency in your implementation. Explanation of your dynamic block size determination logic is encouraged in code comments.","solution":"import math def jump_search_variable_block(arr, target): Searches for a target element in a sorted array using dynamic block size. Returns the index of the target if found, otherwise returns -1. n = len(arr) if n == 0: return -1 # Determine block size dynamically as the square root of the array length block_size = int(math.sqrt(n)) # Finding the block where the element is present (if it is present) start = 0 end = block_size while start < n and arr[min(end, n) - 1] < target: start = end end += block_size if start >= n: return -1 # Linear search within the block for the target element for i in range(start, min(end, n)): if arr[i] == target: return i return -1"},{"question":"**Scenario**: You are part of a software team working on a navigation system for a city\'s transportation network which is represented as a directed graph. Each intersection is a vertex, and directed road segments are edges. To determine the connectivity between intersections, your team needs to compute the transitive closure of this graph. **Problem Statement**: Write a function `compute_transitive_closure` that takes the number of intersections (vertices) and a list of directed roads (edges). The function should return the transitive closure matrix of the graph, indicating which intersections can reach which other intersections. **Function Signature**: ```python def compute_transitive_closure(vertex_count: int, edges: List[Tuple[int, int]]) -> List[List[int]]: pass ``` **Input and Output Format**: * **Input**: * `vertex_count` (int): The number of intersections (nodes in the graph). * `edges` (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed road (source, target). * **Output**: * `closure` (List[List[int]]): A 2D list where closure[i][j] is 1 if there is a path from intersection i to intersection j, otherwise 0. **Constraints**: * 1 <= vertex_count <= 100 * 0 <= len(edges) <= vertex_count * (vertex_count - 1) * Intersections are 0-indexed. **Example**: ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] # The graph can be visualized as: # 0 -> 1 -> 2 -> 3 # Output should be: # [ # [1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1] # ] print(compute_transitive_closure(vertex_count, edges)) ``` **Notes**: * You should implement the algorithm to compute the transitive closure using DFS as described. * Ensure your code handles the specified edge cases and constraints efficiently.","solution":"from typing import List, Tuple def compute_transitive_closure(vertex_count: int, edges: List[Tuple[int, int]]) -> List[List[int]]: # Initialize the adjacency matrix and the transitive closure matrix adj_matrix = [[0] * vertex_count for _ in range(vertex_count)] closure = [[0] * vertex_count for _ in range(vertex_count)] # Fill the adjacency matrix based on the provided edges for (src, tgt) in edges: adj_matrix[src][tgt] = 1 # Initialize the transitive closure matrix with the adjacency matrix values for i in range(vertex_count): for j in range(vertex_count): closure[i][j] = adj_matrix[i][j] # Set the diagonal to 1, as each vertex can reach itself for i in range(vertex_count): closure[i][i] = 1 # Apply the Floyd-Warshall algorithm to compute the transitive closure for k in range(vertex_count): for i in range(vertex_count): for j in range(vertex_count): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure"},{"question":"# Question: Implement a `resize` method for the `SeparateChainingHashTable` class that adjusts the hash table size dynamically. Your method should create a new hash table with a specified larger size and rehash all existing key-value pairs into this new table. # Requirements: - Implement a `resize` method in the `SeparateChainingHashTable`. - Your method should accept a new size (an integer) as input. - Create a new table with this size, rehashing all existing keys to their new positions. - Ensure that all key-value pairs are correctly transferred to the new table. - Maintain the consistency and integrity of the table after resizing. # Input: - Integer `new_size`, the new size of the hash table (greater than the current number of elements). # Output: - None (the method modifies the existing hash table). # Constraints: - The new size must be greater than the current number of elements stored in the hash table. # Example: ```python ht = SeparateChainingHashTable(size=3) ht.put(\\"one\\", 1) ht.put(\\"two\\", 2) ht.put(\\"three\\", 3) ht.resize(6) print(ht.get(\\"one\\")) # Output: 1 print(ht.get(\\"two\\")) # Output: 2 print(ht.get(\\"three\\")) # Output: 3 ``` In this example, the hash table is resized from size 3 to 6, and all keys are rehashed accordingly.","solution":"class SeparateChainingHashTable: def __init__(self, size): self.size = size self.table = [[] for _ in range(size)] self.count = 0 def hash(self, key): return hash(key) % self.size def put(self, key, value): idx = self.hash(key) for kvp in self.table[idx]: if kvp[0] == key: kvp[1] = value return self.table[idx].append([key, value]) self.count += 1 def get(self, key): idx = self.hash(key) for kvp in self.table[idx]: if kvp[0] == key: return kvp[1] return None def resize(self, new_size): if new_size <= self.count: raise ValueError(\\"New size must be greater than the number of elements\\") old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value)"},{"question":"# Matrix Multiplication Implementation # Background: Matrix multiplication is a fundamental operation in many scientific and engineering fields. It involves taking two matrices, a multiplicand (matrix A) and a multiplier (matrix B), and producing a new matrix (result) where each element is the dot product of a row in matrix A and a column in matrix B. # Task: Write a function `matrix_multiply` to perform matrix multiplication. Your function should take two 2-dimensional lists of integers and return their product as a 2-dimensional list of integers. # Function Signature: ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: ``` # Input: * `multiplicand`: a list of lists `m x p` where each sub-list represents a row in the matrix. * `multiplier`: a list of lists `p x n` where each sub-list represents a row in the matrix. # Output: * A list of lists `m x n` representing the product matrix. # Constraints: * Each row in both matrices will have the same length. * Integers in the matrices will be in the range -1000 to 1000. * Ensure the number of columns in `multiplicand` matches the number of rows in `multiplier` for valid matrix multiplication. # Example: ```python # Example 1 multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] # Result # [ # [58, 64], # [139, 154] # ] print(matrix_multiply(multiplicand, multiplier)) # Example 2 multiplicand = [ [2, 1], [0, 3] ] multiplier = [ [1], [-1] ] # Result # [ # [1], # [-3] # ] print(matrix_multiply(multiplicand, multiplier)) ``` # Edge Cases: * Ensure that the function handles incompatible matrices by raising an appropriate exception. * Implement the function to handle empty matrix inputs gracefully, returning an empty matrix in such cases. Note: The provided solution should focus on clarity and correctness, even though optimizations like Strassen’s algorithm could be discussed in class discussions or follow-up assignments.","solution":"def matrix_multiply(multiplicand, multiplier): Multiply two matrices and return the result. # Check if multiplication is possible if not multiplicand or not multiplier or len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Incompatible matrices for multiplication.\\") # Dimensions of the result matrix m, p, n = len(multiplicand), len(multiplicand[0]), len(multiplier[0]) # Initialize result matrix with zeros result = [[0 for _ in range(n)] for __ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(n): for k in range(p): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Minimum Cost Path in a Directed Graph You are given a matrix representing the cost of moving from one station to another. Your task is to implement a function that calculates the minimum cost to travel from the zeroth station to the last station. Here, you will be using a dynamic programming approach. Function Signature ```python def min_cost(cost: List[List[int]]) -> int: ``` Input - **cost**: A List[List[int]] (2D List) where `cost[i][j]` represents the cost of moving from station `i` to station `j` for `i < j`. If `i >= j`, the value is irrelevant and can be ignored (represented by -1 or infinity). Output - An integer representing the minimum cost to travel from station 0 to the last station. Example ```python cost = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] # Expected output: 65, since the path is 0 -> 1 -> 3 with cost 15 + 50 = 65 assert min_cost(cost) == 65 ``` Constraints - You can assume that `1 <= N <= 100` where `N` is the number of stations. - All costs are non-negative integers. Additional Notes - Ensure that your solution adheres to time and space complexity requirements. - Handle edge cases carefully, such as sparse connections or high costs. - Think about the implications of cost updates and avoid unnecessary recomputation for better performance.","solution":"from typing import List def min_cost(cost: List[List[int]]) -> int: Calculate the minimum cost to travel from station 0 to the last station using a dynamic programming approach. N = len(cost) # Initialize the dp array where dp[i] will hold the minimum cost to reach station i from station 0 dp = [float(\'inf\')] * N dp[0] = 0 # Start at station 0, so the cost to reach 0 is 0 # Fill the dp array for i in range(N): for j in range(i + 1, N): if cost[i][j] != -1 and dp[i] != float(\'inf\'): dp[j] = min(dp[j], dp[i] + cost[i][j]) return dp[N-1]"},{"question":"# Question In this task, you are required to implement a modified version of the Heap Sort algorithm. Instead of sorting the entire array, your version will sort only the first `k` smallest elements in an array using a min-heap. This is commonly known as the \\"Partial Heap Sort.\\" Your task is to write a function `partial_heap_sort(k, arr)` that takes an integer `k` and an array `arr` as input, and returns the first `k` smallest elements of the array, sorted in ascending order. # Function Signature ```python def partial_heap_sort(k: int, arr: list[int]) -> list[int]: pass ``` # Input - An integer `k` where (1 leq k leq) length of `arr` - A list of integers `arr` with a length (n) where (1 leq n leq 10^5) # Output - A list of `k` smallest integers from `arr`, sorted in ascending order. # Constraints - Ensure your solution has a time complexity of (O(n log n)) or better. - The provided array can contain duplicate elements. # Example ```python print(partial_heap_sort(2, [3, 2, 5, 1, 4])) # Output: [1, 2] print(partial_heap_sort(3, [9, 4, 7, 3, 8, 6, 2])) # Output: [2, 3, 4] ``` # Notes - You may assume that the helper methods required to implement the min-heap and the heapify process are similar to those provided in the original code snippets, but you should focus only on sorting the first `k` elements instead of the entire array. - Include edge case handling in your implementation.","solution":"import heapq def partial_heap_sort(k, arr): Returns the first k smallest elements in arr, sorted in ascending order, using a min-heap. if k <= 0 or not arr: return [] min_heap = [] for num in arr: heapq.heappush(min_heap, num) sorted_elements = [heapq.heappop(min_heap) for _ in range(k)] return sorted_elements"},{"question":"# Zigzag Traversal of Multiple Lists Problem Statement You are provided with the skeleton of a `ZigZagIterator` class. However, this implementation is specifically designed for two lists. Your task is to generalize this iterator to handle multiple lists and iterate over them in a zigzag manner. Requirements 1. Implement a class `ZigZagIteratorK` that takes multiple lists upon initialization. 2. Ensure methods `next()` and `has_next()` are implemented correctly. Constraints * You can assume the list of lists is a non-empty list. * Each individual list may vary in length, including being empty. Function Signature ```python class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] pass def next(self) -> int: :rtype: int pass def has_next(self) -> bool: :rtype: bool pass ``` Example ```python # Given the following lists l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9, 10, 11] # The expected output should be in a zigzag manner it = ZigZagIteratorK([l1, l2, l3]) result = [] while it.has_next(): result.append(it.next()) print(result) # Output should be [1, 3, 7, 2, 4, 8, 5, 9, 6, 10, 11] ``` Complete the implementation of the `ZigZagIteratorK` class.","solution":"from collections import deque from typing import List class ZigZagIteratorK: def __init__(self, lists: List[List[int]]): Initialize your data structure here. :type lists: List[List[int]] self.queue = deque([(lst, 0) for lst in lists if lst]) def next(self) -> int: :rtype: int lst, idx = self.queue.popleft() if idx + 1 < len(lst): self.queue.append((lst, idx + 1)) return lst[idx] def has_next(self) -> bool: :rtype: bool return bool(self.queue)"},{"question":"# Question: Implement a Flexible Base Conversion System You are tasked with creating a flexible base conversion system. Your goal is to implement two functions, `int_to_base` and `base_to_int`, that can handle the conversion of integers to a given base and vice versa, for bases from 2 to a maximum of 62. Function 1: `int_to_base(num: int, base: int) -> str` * **Input**: * `num` (int): A decimal number to be converted. * `base` (int): The base to convert to, ranging from 2 to 62. * **Output**: * A string representing the number in the specified base. * **Constraints**: * Bases are limited to a range from 2 to 62. * Ensure the output string uses the characters from `0-9`, `A-Z`, and `a-z` for bases beyond 36. Function 2: `base_to_int(number_str: str, base: int) -> int` * **Input**: * `number_str` (str): A string representing the number in the given base. * `base` (int): The base of the number, ranging from 2 to 62. * **Output**: * An integer representing the number in base 10. * **Constraints**: * Bases are limited to a range from 2 to 62. * Ensure the input string contains valid characters for the specified base. Example: * `int_to_base(255, 16)` should return `\'FF\'`. * `int_to_base(-255, 16)` should return `\'-FF\'`. * `base_to_int(\'FF\', 16)` should return `255`. * `base_to_int(\'-FF\', 16)` should return `-255`. Notes: 1. Account for possible edge cases such as zero and negative numbers. 2. Ensure your implementation is efficient and adheres to the specified constraints. Implement these two functions in Python: ```python def int_to_base(num: int, base: int) -> str: # Your implementation here pass def base_to_int(number_str: str, base: int) -> int: # Your implementation here pass ``` Good luck!","solution":"def int_to_base(num: int, base: int) -> str: if base < 2 or base > 62: raise ValueError(\\"Base must be between 2 and 62\\") if num == 0: return \'0\' characters = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\" result = [] negative = num < 0 num = abs(num) while num > 0: result.append(characters[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(result[::-1]) def base_to_int(number_str: str, base: int) -> int: if base < 2 or base > 62: raise ValueError(\\"Base must be between 2 and 62\\") characters = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\" char_to_value = {char: idx for idx, char in enumerate(characters)} number_str = number_str.strip() if len(number_str) == 0: raise ValueError(\\"Empty string is not a valid number\\") negative = number_str[0] == \'-\' if negative: number_str = number_str[1:] num = 0 for char in number_str: if char not in char_to_value or char_to_value[char] >= base: raise ValueError(f\\"Invalid character \'{char}\' for base {base}\\") num = num * base + char_to_value[char] return -num if negative else num"},{"question":"You are tasked with implementing an efficient sorting algorithm named \\"Insertion Sort\\". Insertion Sort works similarly to sorting playing cards in your hand, one card at a time from left to right. **Insertion Sort Algorithm**: 1. Start with the first element as a sorted list, leaving the rest as unsorted. 2. Take the next element from the unsorted portion and insert it into the correct position in the sorted portion. 3. Repeat until all elements are sorted. # Requirements: 1. **Input**: - A list of integers `arr`. 2. **Output**: - A list of sorted integers. # Constraints: 1. The length of `arr` (denoted `n`) will be in the range [1, 10^4]. 2. Each element in `arr` will be an integer such that -10^9 <= arr[i] <= 10^9. # Performance: 1. Target a time complexity of O(n^2) and a space complexity of O(1). # Example: ```python def insertion_sort(arr): # Your code here # Test case print(insertion_sort([4, 2, 7, 1, 3])) # Output: [1, 2, 3, 4, 7] print(insertion_sort([])) # Output: [] print(insertion_sort([5, 5, 5, 5])) # Output: [5, 5, 5, 5] ``` Implement the `insertion_sort` function considering the provided algorithm and constraints. Please ensure that your solution is efficient and handles edge cases properly.","solution":"def insertion_sort(arr): Sorts a list of integers using the insertion sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: A sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Huffman Coding Implementation You are tasked with implementing the core parts of Huffman Coding: character frequency analysis, tree creation, and encoding/decoding functions. Given the following functions and their expected input and output, write the necessary code to complete the Huffman Coding process. Part 1: Frequency Analysis Implement the function to calculate the frequency of each character in the input data. ```python def calculate_frequencies(data: str) -> dict: Calculate the frequency of each character in the input data. :param data: A string containing the input data. :return: A dictionary with characters as keys and their frequencies as values. # Your implementation here ``` Part 2: Huffman Tree Using the calculated frequencies, build the Huffman tree. ```python def build_huffman_tree(frequencies: dict) -> Node: Build the Huffman tree using the character frequencies. :param frequencies: A dictionary with characters as keys and their frequencies as values. :return: The root node of the Huffman tree. # Your implementation here ``` Part 3: Generating Codes Generate the Huffman codes for each character from the Huffman tree. ```python def generate_codes(tree: Node) -> dict: Generate Huffman codes for each character from the Huffman tree. :param tree: The root node of the Huffman tree. :return: A dictionary with characters as keys and their Huffman codes as values. # Your implementation here ``` Part 4: Encoding Data Encode the input data using the generated Huffman codes. ```python def encode_data(data: str, codes: dict) -> str: Encode the input data using the Huffman codes. :param data: A string containing the input data. :param codes: A dictionary with characters as keys and their Huffman codes as values. :return: A string of encoded data. # Your implementation here ``` Part 5: Decoding Data Decode the encoded data back into the original data using the Huffman tree. ```python def decode_data(encoded_data: str, tree: Node) -> str: Decode the encoded data using the Huffman tree. :param encoded_data: A string of encoded data. :param tree: The root node of the Huffman tree. :return: The original data as a string. # Your implementation here ``` Constraints and Requirements 1. Assume the input data contains only ASCII characters. 2. The frequency calculation must be efficient, handling large datasets within reasonable time limits. 3. The Huffman tree construction and code generation must correctly handle characters with both unique and identical frequencies. 4. Encoding and decoding processes must be highly efficient and accurate. Example ```python data = \\"this is an example for huffman encoding\\" # Step 1: Calculate Frequencies frequencies = calculate_frequencies(data) print(frequencies) # {\'t\': 1, \'h\': 2, \'i\': 2, \'s\': 2, \' \': 6, \'a\': 3, \'n\': 4, \'e\': 2, \'x\': 1, \'m\': 2, \'p\': 1, \'l\': 1, \'f\': 2, \'o\': 1, \'r\': 1, \'u\': 1, \'c\': 1, \'d\': 1, \'g\': 1} # Step 2: Build Huffman Tree tree = build_huffman_tree(frequencies) # Step 3: Generate Codes codes = generate_codes(tree) print(codes) # {\' \': \'11\', \'a\': \'101\', \'d\': \'10010\', \'c\': \'100110\' ... } # Step 4: Encode Data encoded_data = encode_data(data, codes) print(encoded_data) # \'11001010111011100111110010011001100101101111100101100010\' # Step 5: Decode Data decoded_data = decode_data(encoded_data, tree) print(decoded_data) # \'this is an example for huffman encoding\' ``` Complete all the above steps to achieve a working Huffman Coding implementation.","solution":"import heapq from collections import Counter, defaultdict from typing import Dict, Any class Node: def __init__(self, char: str = None, freq: int = 0): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq def calculate_frequencies(data: str) -> Dict[str, int]: Calculate the frequency of each character in the input data. :param data: A string containing the input data. :return: A dictionary with characters as keys and their frequencies as values. return dict(Counter(data)) def build_huffman_tree(frequencies: Dict[str, int]) -> Node: Build the Huffman tree using the character frequencies. :param frequencies: A dictionary with characters as keys and their frequencies as values. :return: The root node of the Huffman tree. min_heap = [Node(char, freq) for char, freq in frequencies.items()] heapq.heapify(min_heap) while len(min_heap) > 1: left = heapq.heappop(min_heap) right = heapq.heappop(min_heap) merged = Node(freq=left.freq + right.freq) merged.left = left merged.right = right heapq.heappush(min_heap, merged) return min_heap[0] if min_heap else None def generate_codes(tree: Node) -> Dict[str, str]: Generate Huffman codes for each character from the Huffman tree. :param tree: The root node of the Huffman tree. :return: A dictionary with characters as keys and their Huffman codes as values. codes = {} def _generate_codes(node: Node, current_code: str): if not node: return if node.char is not None: codes[node.char] = current_code _generate_codes(node.left, current_code + \\"0\\") _generate_codes(node.right, current_code + \\"1\\") _generate_codes(tree, \\"\\") return codes def encode_data(data: str, codes: Dict[str, str]) -> str: Encode the input data using the Huffman codes. :param data: A string containing the input data. :param codes: A dictionary with characters as keys and their Huffman codes as values. :return: A string of encoded data. return \'\'.join(codes[char] for char in data) def decode_data(encoded_data: str, tree: Node) -> str: Decode the encoded data using the Huffman tree. :param encoded_data: A string of encoded data. :param tree: The root node of the Huffman tree. :return: The original data as a string. decoded_output = [] current_node = tree for bit in encoded_data: current_node = current_node.left if bit == \\"0\\" else current_node.right if current_node.char is not None: decoded_output.append(current_node.char) current_node = tree return \'\'.join(decoded_output)"},{"question":"You are required to implement a function `improved_quick_sort` that sorts an array of integers using an optimized version of the Quick Sort algorithm. The optimization should include the following: 1. Implement the median-of-three method to improve pivot selection. 2. For small subarrays (size ≤ 10), implement Insertion Sort instead of Quick Sort to enhance performance. # Function Signature ```python def improved_quick_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. # Output * A new list of integers sorted in ascending order. # Constraints * The solution should have an average time complexity of O(n log(n)) and should handle the worst-case scenario efficiently. * You must implement the Quick Sort algorithm with the specified optimizations. # Example ```python improved_quick_sort([3, 6, 8, 10, 1, 2, 1]) # Output: [1, 1, 2, 3, 6, 8, 10] improved_quick_sort([1, 2, 3, 4, 5]) # Output: [1, 2, 3, 4, 5] improved_quick_sort([5, 4, 3, 2, 1]) # Output: [1, 2, 3, 4, 5] ``` # Notes * Pay close attention to the selection of the pivot, as using a static pivot (e.g., first or last element) might lead to poor performance on some datasets. * Ensure that the base case for recursion is defined correctly to avoid infinite recursion or excessive stack depth.","solution":"from typing import List def improved_quick_sort(arr: List[int]) -> List[int]: def median_of_three(low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def insertion_sort(low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def quick_sort(low, high): if low < high: if high - low + 1 <= 10: insertion_sort(low, high) else: pivot_index = median_of_three(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = j = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] quick_sort(low, i - 1) quick_sort(i + 1, high) quick_sort(0, len(arr) - 1) return arr"},{"question":"# Keyboard Row Membership Given a list of words, return the words that can be typed using letters of the alphabet on only one row of an American keyboard. Objective Implement a function `find_keyboard_row(words)` that achieves this task. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: # implementation ``` Input `words`: A list of strings, where each string is a word consisting of English letters. Output Returns a list of words that can be typed using letters of the alphabet on only one row of an American keyboard. Constraints * The words in the input list can contain both uppercase and lowercase letters. * The function should be case insensitive when determining if a word can be typed using one keyboard row. * Do not include words in the result if they contain non-alphabetic characters. Example ```python Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] ``` # Notes to implementers: * Ensure that the algorithm accounts for edge cases such as an empty list or words with mixed case. * Handle performance issues by ensuring the algorithm runs efficiently for a typical dataset.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: # Define the rows of the keyboard row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: # Convert the word to lowercase lower_word = set(word.lower()) # Check if the word can be typed using one of the rows if lower_word.issubset(row1) or lower_word.issubset(row2) or lower_word.issubset(row3): result.append(word) return result"},{"question":"# Task Write a function `lcm_bitwise(a: int, b: int) -> int` that calculates the least common multiple (LCM) of two non-negative integers using bitwise operations for the GCD calculation. The function should handle edge cases and invalid inputs appropriately. # Input - Two non-negative integers ( a ) and ( b ). # Output - A single integer representing the LCM of ( a ) and ( b ). # Constraints - (0 leq a, b leq 10^9) - If both (a) and (b) are zero, LCM is undefined. Your function should handle this case by raising an appropriate error. # Performance Requirements - The solution should efficiently handle the calculation even for large integers close to the upper limit of the constraints. # Example ```python lcm_bitwise(12, 15) -> 60 lcm_bitwise(0, 5) -> 0 lcm_bitwise(0, 0) -> ValueError(\\"LCM is undefined for both inputs being zero.\\") ``` Implement the function `lcm_bitwise` based on the provided constraints and requirements.","solution":"def gcd_bitwise(a: int, b: int) -> int: Calculate the GCD using the bitwise method. if a == 0: return b if b == 0: return a # Remove all common factors of 2 using bitwise operations shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def lcm_bitwise(a: int, b: int) -> int: Calculate the LCM using bitwise GCD calculation. if a == 0 and b == 0: raise ValueError(\\"LCM is undefined for both inputs being zero.\\") if a == 0 or b == 0: return 0 gcd_value = gcd_bitwise(a, b) return (a // gcd_value) * b"},{"question":"Comb Sort Enhancement You are tasked with enhancing the Comb Sort algorithm to handle large datasets more efficiently by integrating an alternative approach for smaller gaps to optimize performance. Implement a modified version of the Comb Sort algorithm that switches to Insertion Sort when the gap becomes less or equal to 3 for improved performance on nearly sorted lists. Input * A list of integers `arr` (where 1 <= len(arr) <= 10^4 and all elements are in the range [-10^6, 10^6]). Output * A sorted list of integers. Function Signature * `def enhanced_comb_sort(arr: List[int]) -> List[int]:` Constraints * You must use the comb sort methodology for initial sorting and switch to insertion sort when the gap becomes less or equal to 3. * Your solution should handle all edge cases efficiently. Example ```python # Input arr = [5, 2, 9, 1, 5, 6] # Output [1, 2, 5, 5, 6, 9] # Input arr = [100, 100, -1, 0, 1, -1] # Output [-1, -1, 0, 1, 100, 100] ``` Notes * Consider additional edge cases such as empty lists or lists with a single element. * Ensure your solution adheres to the constraints and optimizes performance for large, nearly-sorted datasets.","solution":"from typing import List def insertion_sort(arr: List[int], start: int, end: int) -> None: for i in range(start + 1, end + 1): key = arr[i] j = i - 1 while j >= start and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def enhanced_comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) if gap <= 3: insertion_sort(arr, 0, n - 1) break swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"You are asked to extend the classic FizzBuzz problem with an additional complexity. In this version of FizzBuzz, you need to handle multiple lists of numbers, each with potentially different rules. # Problem Description Write a function `advanced_fizzbuzz(n, rules)` that processes a list of numbers from 1 to n following a set of custom substitution rules. Function Signature ```python def advanced_fizzbuzz(n: int, rules: List[Tuple[int, str]]) -> List[Union[int, str]]: ``` Parameters - `n` (int): The upper limit of the range (inclusive). Must be a positive integer greater than or equal to 1. - `rules` (List[Tuple[int, str]]): A list of tuples, each containing an integer divisor and a string. For example, [(3, \'Fizz\'), (5, \'Buzz\')] means multiples of 3 should be replaced with \'Fizz\' and multiples of 5 should be replaced with \'Buzz\'. The list can contain multiple rules, and order of application does not matter. Returns - List[Union[int, str]]: A list of numbers from 1 to n, with specified substitutions applied. Behavior - For each number from 1 through n: - Apply the provided replacement rules in the given order. - If a number is divisible by multiple divisors provided in the rules, combine their corresponding strings in the order they are provided. - If no rules are applicable for a number, include the number itself in the output. # Constraints - 1 ≤ n ≤ 10^5 - The length of rules list will not exceed 100. - Each divisor in the rules will be a positive integer greater than 1. # Example Input ```python n = 15 rules = [(3, \'Fizz\'), (5, \'Buzz\')] ``` Output ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` Explanation - Numbers divisible by 3 are replaced with \'Fizz\'. - Numbers divisible by 5 are replaced with \'Buzz\'. - Numbers divisible by both 3 and 5 are replaced with \'FizzBuzz\'. # Additional Notes - Ensure your implementation handles edge cases, such as input n less than 1 by raising an appropriate error. - Optimize your function to handle the upper limits efficiently.","solution":"from typing import List, Tuple, Union def advanced_fizzbuzz(n: int, rules: List[Tuple[int, str]]) -> List[Union[int, str]]: result = [] for i in range(1, n + 1): substitution = \\"\\" for divisor, word in rules: if i % divisor == 0: substitution += word result.append(substitution if substitution else i) return result"},{"question":"Bit Manipulator You have been given a series of functions that allow you to manipulate individual bits of an integer. Your task is to implement a function that uses these bit manipulation functions to perform complex bit-wise operations on a list of integers. Function Specifications You need to implement the following function: ```python def bit_manipulator(nums, operations): Perform a series of bit operations on a list of integers. Args: nums (list of int): List of integers to be manipulated. operations (list of dict): List of operations to perform, where each operation is a dictionary. Each dictionary will have: - \'type\': One of [\'get\', \'set\', \'clear\', \'update\'] indicating the operation type. - \'index\': Index of the integer in `nums` to perform the operation on. - \'bit_index\': The bit index to manipulate. - \'value\': (optional) The value to set/update the bit with (only used in set/update operations). Returns: list of int: The updated list of integers after performing all the operations. pass ``` Instructions 1. Implement the bit manipulation operations using the provided functions: `get_bit`, `set_bit`, `clear_bit`, and `update_bit`. 2. Update the list `nums` as per the operations provided. 3. Ensure your solution handles edge cases such as out-of-bounds bit indices. Example ```python # Provided helper functions def get_bit(num, i): return (num & (1 << i)) != 0 def set_bit(num, i): return num | (1 << i) def clear_bit(num, i): mask = ~(1 << i) return num & mask def update_bit(num, i, bit): mask = ~(1 << i) return (num & mask) | (bit << i) # Your function implementation def bit_manipulator(nums, operations): # Your code here pass # Example usage nums = [5, 3] operations = [ {\'type\': \'set\', \'index\': 0, \'bit_index\': 1}, {\'type\': \'clear\', \'index\': 1, \'bit_index\': 0}, {\'type\': \'update\', \'index\': 0, \'bit_index\': 0, \'value\': 0} ] print(bit_manipulator(nums, operations)) # Output: [7, 2] -> Explanation: # - Set bit 1 on 5 (101 -> 111) -> 7 # - Clear bit 0 on 3 (011 -> 010) -> 2 # - Update bit 0 on 7 to 0 (111 -> 110) -> 6 ``` Constraints - The list `nums` will contain at most 100 integers. - `nums` contains non-negative integers (0 to 1,000,000). - Each integer in `nums` is a 32-bit integer. - The list `operations` will contain at most 100 operations. - The `bit_index` for any operation will be in the range [0, 31]. Ensure your solution is efficient and handles all edge cases properly.","solution":"def get_bit(num, i): return (num & (1 << i)) != 0 def set_bit(num, i): return num | (1 << i) def clear_bit(num, i): mask = ~(1 << i) return num & mask def update_bit(num, i, bit): mask = ~(1 << i) return (num & mask) | (bit << i) def bit_manipulator(nums, operations): for operation in operations: op_type = operation[\'type\'] index = operation[\'index\'] bit_index = operation[\'bit_index\'] if op_type == \'get\': # get_bit function is usually not used to modify the number # Therefore, it doesn\'t affect `nums` array pass elif op_type == \'set\': nums[index] = set_bit(nums[index], bit_index) elif op_type == \'clear\': nums[index] = clear_bit(nums[index], bit_index) elif op_type == \'update\': value = operation[\'value\'] nums[index] = update_bit(nums[index], bit_index, value) return nums"},{"question":"# Graph Traversal Algorithms **Context**: You are given a network of cities connected by roads. This network is represented as a graph where each city is a node and each road between cities is an edge. You need to explore these cities to ensure each city can be visited from a given starting city. Implement a function to verify if all cities (nodes) can be visited when either a DFS or BFS traversal is applied from a given starting city. **Your Task**: Write two functions `dfs_traverse_all(graph, start)` and `bfs_traverse_all(graph, start)` that perform DFS and BFS respectively to traverse all possible cities from the starting city and return `True` if all cities are visited, otherwise return `False`. Function Signature ```python def dfs_traverse_all(graph: dict, start: str) -> bool: pass def bfs_traverse_all(graph: dict, start: str) -> bool: pass ``` Input Format - `graph`: A dictionary where keys are nodes, and values are lists of neighboring nodes. It represents an undirected graph. - `start`: A string representing the starting node for traversal. Output Format - Return `True` if all nodes are visited, otherwise `False`. Example ```python graph = { \'A\': [\'B\', \'C\', \'D\'], \'B\': [\'A\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'A\'], \'E\': [\'B\'], \'F\': [\'C\'] } dfs_traverse_all(graph, \'A\') # Output: True bfs_traverse_all(graph, \'A\') # Output: True ``` Constraints - The graph will contain at least one node. - The graph can have cycles. - Graph connectivity is not guaranteed. **Additional Notes**: - Ensure to handle graphs where not all nodes are reachable from the start node. - Optimize the code to handle larger graphs efficiently.","solution":"def dfs_traverse_all(graph, start): visited = set() def dfs(node): if node not in visited: visited.add(node) for neighbor in graph.get(node, []): dfs(neighbor) dfs(start) return len(visited) == len(graph) def bfs_traverse_all(graph, start): visited = set() queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return len(visited) == len(graph)"},{"question":"**Problem Statement:** You are given a list of unique integers, nums, where nums is a permutation of the numbers in the range [0, n]. One integer is missing from this range. Your task is to write a function that identifies the missing integer. If the sequence is already complete (all numbers from 0 to n are present), your function should return n+1 as the next integer in the sequence. # Function Signature: ```python def find_missing_number(nums: List[int]) -> int: ``` # Inputs: * `nums`: A list of unique integers where each integer is in the range [0, n] and the difference between consecutive integers cannot be more than 1. # Output: * Return the missing integer from the list of numbers. If the list is complete, return the next integer in the sequence. # Constraints: * The list `nums` will always contain unique integers. * The length of `nums` will be in the range from 0 to 10^6. # Examples: 1. **Input**: `nums = [4, 1, 3, 0, 6, 5, 2]` **Output**: `7` 2. **Input**: `nums = [0, 1, 3]` **Output**: `2` 3. **Input**: `nums = [0, 1, 2, 3]` **Output**: `4` # Constraints: * You should provide a solution that runs in O(n) time and uses O(1) extra space. * Ensure your code accounts for all edge cases, such as empty input lists or complete sequences.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Identifies the missing integer from a permutation of the numbers in the range [0, n]. If the sequence is complete, it returns n+1 as the next integer in the sequence. n = len(nums) total_sum = n * (n + 1) // 2 actual_sum = sum(nums) missing_number = total_sum - actual_sum return missing_number"},{"question":"# Problem Description You are given a data structure `ResizableHashTable` that implements a hash table with dynamic resizing. Your task is to enhance the data structure by adding a method to check the load factor and updating the resize policy based on a specified threshold. # Requirements 1. **Method:** `def load_factor(self) -> float` - Returns the current load factor of the hash table. 2. **Enhanced Resize Policy:** - Resize the table when the load factor exceeds a specified threshold (e.g., 0.75) or falls below another threshold (e.g., 0.2). # Input and Output Formats * **Method `load_factor`:** - **Input:** None - **Output:** A float representing the load factor. * **Enhanced Resizing:** (update the existing methods) - The hash table should double in capacity if the load factor exceeds 0.75. - The hash table should halve in capacity if the load factor falls below 0.2 but should not go below the `MIN_SIZE`. # Constraints - Ensure the capacity of the hash table is always a positive number and at least `MIN_SIZE`. - Handle potential edge cases such as the hash table being empty or nearly full. - Optimize for average-case performance. # Example ```python # Example usage htable = ResizableHashTable() # Insert key-value pairs htable.put(1, \'A\') htable.put(2, \'B\') htable.put(3, \'C\') # Load factor should be (3/8) = 0.375 print(htable.load_factor()) # Output: 0.375 # Continue to insert to trigger resize htable.put(4, \'D\') htable.put(5, \'E\') htable.put(6, \'F\') # Load factor should be (6/8) = 0.75 print(htable.load_factor()) # Output: 0.75 # Further insert to trigger resize htable.put(7, \'G\') # Load factor should be recalculated based on the new size after resizing print(htable.load_factor()) # Output will depend on the new capacity # Remove keys to possibly trigger a downsize del htable[7] del htable[6] del htable[5] # Load factor should reflect the new state potentially triggering a downsize print(htable.load_factor()) # Output will depend on the new capacity ``` # Implementation Integrate this logic into the existing `ResizableHashTable` class.","solution":"class ResizableHashTable: MIN_SIZE = 8 def __init__(self, initial_capacity=8): self.size = 0 self.capacity = max(initial_capacity, self.MIN_SIZE) self.table = [None] * self.capacity def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): if self.size >= self.capacity * 0.75: self._resize(self.capacity * 2) idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.capacity self.table[idx] = (key, value) self.size += 1 def get(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.capacity return None def __delitem__(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.size -= 1 self._rehash_from(idx) if self.size <= self.capacity * 0.2 and self.capacity > self.MIN_SIZE: new_capacity = max(self.capacity // 2, self.MIN_SIZE) if new_capacity != self.capacity: self._resize(new_capacity) return idx = (idx + 1) % self.capacity def _rehash_from(self, start_idx): idx = (start_idx + 1) % self.capacity while self.table[idx] is not None: key, value = self.table[idx] self.table[idx] = None self.size -= 1 self.put(key, value) idx = (idx + 1) % self.capacity def load_factor(self) -> float: return self.size / self.capacity def _resize(self, new_capacity): old_table = self.table self.capacity = new_capacity self.table = [None] * self.capacity self.size = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def __repr__(self): return f\'ResizableHashTable(size={self.size}, capacity={self.capacity}, table={self.table})\'"},{"question":"# Sudoku Solver You are tasked with solving a Sudoku puzzle using a more efficient approach that minimizes redundant calculations. Your algorithm should utilize Depth-first Search (DFS) combined with backtracking principles while keeping performance in mind. **Implementation Requirements**: 1. Utilize the provided `Sudoku` class framework to complete the solver. 2. Ensure the solver implements DFS and handles backtracking properly when dead ends are encountered. 3. Optimize the solver by always selecting the cell with the fewest potential values first to reduce branching. **Input**: * A 2D list `board` of size 9x9 representing a Sudoku puzzle. Empty cells are denoted by the character \'.\'. * Example: ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] ``` **Output**: * The same `board` list with all cells filled following Sudoku rules such that each row, each column, and each of the nine 3x3 sub-boxes contains the digits 1 to 9 exactly once. * Example: ```python solved_board = [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ``` **Constraints**: * The function should respect the Sudoku rules. * Only valid Sudoku boards (with at least one solution) should be input. **Coding Task**: 1. Complete the `Sudoku` class with a method `solve()` that modifies the input board to become a solved Sudoku puzzle. 2. Make sure to handle and backtrack appropriately, ensuring performance while exploring the solution space. 3. Document any assumptions or edge cases you’ve considered in your solution.","solution":"class Sudoku: def __init__(self, board): self.board = board def solve(self): self._dfs() def _find_empty(self): for i in range(9): for j in range(9): if self.board[i][j] == \'.\': return i, j return None def _is_valid(self, num, pos): row, col = pos # Check row for i in range(9): if self.board[row][i] == num and col != i: return False # Check column for i in range(9): if self.board[i][col] == num and row != i: return False # Check box box_x = (row // 3) * 3 box_y = (col // 3) * 3 for i in range(box_x, box_x + 3): for j in range(box_y, box_y + 3): if self.board[i][j] == num and (i, j) != pos: return False return True def _dfs(self): empty = self._find_empty() if not empty: return True row, col = empty for num in map(str, range(1, 10)): if self._is_valid(num, (row, col)): self.board[row][col] = num if self._dfs(): return True self.board[row][col] = \'.\' return False"},{"question":"# Question: Is Valid Parentheses? **Scenario**: You are part of a development team working on a text editor that helps developers ensure their code contains matching parentheses, braces, and brackets. Your task is to implement a function to check if a string containing just the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'` and `\']\'` is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. **Function Signature**: ```python def is_valid(s: str) -> bool: ``` **Input**: - A single string `s` containing only the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'` and `\']\'`. (1 ≤ length of `s` ≤ 10^4) **Output**: - Returns `True` if the string is valid, otherwise `False`. **Constraints**: - Consider only the characters mentioned above. - Ensure the solution runs efficiently even with the maximum length of `s`. **Example**: ```python assert is_valid(\\"()\\") == True assert is_valid(\\"()[]{}\\") == True assert is_valid(\\"(]\\") == False assert is_valid(\\"([)]\\") == False assert is_valid(\\"{[]}\\") == True assert is_valid(\\"\\") == True # Edge case: empty string is valid assert is_valid(\\"]\\") == False # Edge case: misorder ``` **Performance Requirements**: - The function should run in O(n) time complexity and use O(n) space complexity where n is the length of the input string. Implement a function that meets the above requirements.","solution":"def is_valid(s: str) -> bool: Determine if the input string of parentheses is valid. # Dictionary to match opening and closing brackets matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} # Stack to keep track of the opening brackets stack = [] for char in s: if char in matching_bracket: # Pop the topmost element if it exists, otherwise use a dummy value top_element = stack.pop() if stack else \'#\' # If the mapping for the current closing bracket doesn\'t match the stack\'s top element, return False if matching_bracket[char] != top_element: return False else: # Push the opening bracket onto the stack stack.append(char) # If the stack is empty, then we have matched all the brackets correctly return not stack"},{"question":"**Problem Statement:** You are given a string `s`, and your task is to reverse the string without using any built-in functions (excluding the slicing syntax). Implement a function `your_reverse(s: str) -> str` that achieves the result efficiently. Do not use Python\'s standard library functions like `reversed()` or slice notation for reverse (`[::-1]`). Instead, use either an iterative or a recursive approach. # Input * A string `s` (1 ≤ |s| ≤ 10^5) # Output * A string which is the reverse of the input string `s`. # Constraints * You must handle input strings with different characters including letters, digits, symbols, and spaces. * Your solution should be efficient in terms of time and space complexity. * Avoid using Python built-in methods for reverse operations except for basic slicing indexing. # Example ```python assert your_reverse(\\"abcd\\") == \\"dcba\\" assert your_reverse(\\"hello world\\") == \\"dlrow olleh\\" assert your_reverse(\\"A man, a plan, a canal, Panama\\") == \\"amanaP ,lanac a ,nalp a ,nam A\\" assert your_reverse(\\"1234567890\\") == \\"0987654321\\" assert your_reverse(\\"\\") == \\"\\" assert your_reverse(\\"a\\") == \\"a\\" ``` # Notes Think of the most efficient way to reverse the string keeping in mind the constraints, and remember to handle all possible types of characters in the string carefully. Your function should not just cater to alphabetic characters but should handle all Unicode characters valid in strings.","solution":"def your_reverse(s: str) -> str: Reverse the input string using an iterative approach without using any built-in functions for reversing or slicing for reverse. # Initialize an empty list to store characters reversed_chars = [] # Iterate over the string from the end to the start for i in range(len(s) - 1, -1, -1): reversed_chars.append(s[i]) # Join the list into a string and return return \'\'.join(reversed_chars)"},{"question":"# Task Implement a function `min_deletions_to_equal_strings(word1, word2)` to determine the minimum number of deletion steps required to make two strings identical using the Longest Common Subsequence approach. # Input * **word1**: A non-empty string (1 <= len(word1) <= 1000). * **word2**: A non-empty string (1 <= len(word2) <= 1000). # Output Return an integer representing the minimum number of deletions required. # Example ```python input_word1 = \\"sea\\" input_word2 = \\"eat\\" print(min_deletions_to_equal_strings(input_word1, input_word2)) # Output: 2 ``` # Constraints * Strings can contain any alphanumeric characters. * The solution should efficiently handle strings up to a length of 1000. # Performance Requirements * Your solution should have a time complexity of O(n * m) and a space complexity of O(n * m). Extra credit for optimizing space complexity. * Handle edge cases efficiently, such as empty strings or completely dissimilar strings. # Scenario Imagine you are working on a text comparison tool that aims to highlight differences between various document versions. To achieve this, one of the tasks is to determine how many deletions are needed to standardize two different document versions to the same content. Implement an efficient function to compute this.","solution":"def min_deletions_to_equal_strings(word1, word2): Returns the minimum number of deletions required to make two strings identical. def longest_common_subsequence(word1, word2): n = len(word1) m = len(word2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] lcs_length = longest_common_subsequence(word1, word2) deletions_required = len(word1) + len(word2) - 2 * lcs_length return deletions_required"},{"question":"# Question: Find the Single Number Given an array of integers where every element appears exactly three times except for one element, which appears exactly once, write a function `single_number` to find that single element. Your algorithm should run in linear time and use a constant amount of extra space. Input * `nums`: A list of integers, where each integer appears exactly three times except for one integer which appears exactly once. Output * Return the single integer which appears only once. Constraints * The algorithm must run in O(n) time complexity. * The algorithm must use O(1) extra space. Example ```python def single_number(nums): # Your implementation here # Example Usage print(single_number([2,2,3,2])) # Output: 3 print(single_number([0,1,0,1,0,1,99])) # Output: 99 ``` Explanation 1. You should extract the integer which appears only once by leveraging bitwise operations as described in the provided solution structure. 2. Implement a function that manages to track bits appearing once and twice across the entirety of the input array to isolate the unique number.","solution":"def single_number(nums): Given an array where every element appears exactly three times except for one element which appears exactly once, find the single element. The algorithm should run in linear time and use a constant amount of extra space. once, twice = 0, 0 for num in nums: once = (once ^ num) & ~twice twice = (twice ^ num) & ~once return once"},{"question":"You are given a sorted list of unique integers and a target integer. Your task is to implement the `interpolation_search` function, which determines the index of the target integer in the list using the principles of interpolation search. If the target integer is not present in the list, the function should return -1. # Function Signature: ```python from typing import List def interpolation_search(array: List[int], search_key: int) -> int: pass ``` # Input: - A sorted list of integers `array` with length `n` (1 ≤ n ≤ 10^6). - An integer `search_key`. # Output: - An integer representing the index of `search_key` in `array` if it exists, otherwise -1. # Examples: ``` assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ``` # Constraints: - The array is sorted in strictly increasing order. - The function should have an average time complexity of O(log2(log2 n)). # Performance Requirements: - Efficient handling of large arrays up to 10^6 elements is required. - Aim to minimize the number of comparisons necessary to locate the search key. Note: Ensure edge cases such as single-element arrays and non-existing search keys are addressed appropriately. Consider the potential for performance degradation with non-uniformly distributed arrays and how to handle such scenarios effectively.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search on a sorted list to find the index of search_key. Returns the index of search_key if found, otherwise -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Calculate the probe position using interpolation formula pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # Condition of target found if array[pos] == search_key: return pos # If search_key is larger, search in the right part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the left part else: high = pos - 1 return -1"},{"question":"# Coding Challenge: Determine if a Stack is Sorted in Ascending Order Problem Statement You are required to implement the function `is_sorted(stack)` that accepts a stack (implemented as a list in Python) and returns `True` if the elements in the stack are sorted in ascending order from the bottom of the stack to the top, and `False` otherwise. A stack in Python can be represented using a list where: - The last element of the list is considered the top of the stack. - The first element of the list is considered the bottom of the stack. Specifications: # Input: - An input stack of integers, where the bottom of the stack is represented by the first element of the list and the top of the stack is the last element. - Example: `stack = [1, 2, 3, 4, 5, 6]` # Output: - Return `True` if the elements in the stack are sorted in ascending order from bottom to top. - Return `False` otherwise. # Constraints: - The input stack can have a maximum length of 10^5. - The elements in the stack are integers in the range from -10^9 to 10^9. # Example Cases: - **Case 1**: - Input: `stack = [1, 2, 3, 4, 5, 6]` - Output: `True` - Explanation: All elements are in ascending order from bottom to top. - **Case 2**: - Input: `stack = [6, 3, 5, 1, 2, 4]` - Output: `False` - Explanation: The elements are not in ascending order. - **Case 3**: - Input: `stack = []` - Output: `True` - Explanation: An empty stack is considered sorted by definition. # Edge Cases: - Ensure handling for an empty stack. - Single element stack should return `True`. - Stack with all equal elements should return `True`. Function Signature: ```python def is_sorted(stack: list) -> bool: # Implementation here ``` Note: Your implementation should aim to minimize both time and space complexity. Consider potential optimizations and edge cases while writing your solution.","solution":"def is_sorted(stack: list) -> bool: Determine if the stack is sorted in ascending order from the bottom to top. Args: stack (list): The stack represented as a list. Returns: bool: True if sorted in ascending order, False otherwise. for i in range(1, stack.__len__()): if stack[i] < stack[i - 1]: return False return True"},{"question":"# Question You are tasked with writing a function that processes a list of integers to ensure no number appears more than a specified number of times while maintaining the order of elements. # Function Signature ```python def enforce_limits(values: List[int], max_occurrences: int) -> List[int]: ``` # Input - **values**: A list of integers (`List[int]`). It can be very large. - **max_occurrences**: An integer (`int`). This indicates the maximum number of times any value should appear in the output list. # Output - Returns a list of integers (`List[int]`) adhering to the rule. # Constraints - The input list can contain up to (10^6) elements. - Each integer in the list can be in the range from -1,000,000 to 1,000,000. - `max_occurrences` is guaranteed to be a non-negative integer (`0 <= max_occurrences <= 10^6`). # Requirements * Ensure the resulting list maintains the original order of elements. * Any integer appears in the result list no more than `max_occurrences` times. * Your implementation should be optimized for large lists, considering both time and space complexity. # Example 1. **Input**: `values = [1, 2, 3, 1, 2, 1, 2, 3, 3, 3]`, `max_occurrences = 2` **Output**: `[1, 2, 3, 1, 2, 3]` 2. **Input**: `values = []`, `max_occurrences = 3` **Output**: `[]` 3. **Input**: `values = [1,1,1,1,1]`, `max_occurrences = 1` **Output**: `[1]` 4. **Input**: `values = [5, 5, 5, -1, -1, 0, 0, 0]`, `max_occurrences = 2` **Output**: `[5, 5, -1, -1, 0, 0]` **Note**: Ensure that you avoid inefficient solutions with high time complexity (like (O(N^2))) for large input cases. Aim for an (O(N)) solution by employing appropriate data structures.","solution":"from typing import List def enforce_limits(values: List[int], max_occurrences: int) -> List[int]: Returns a list where no element appears more than max_occurrences times, maintaining the order of the provided list. if max_occurrences == 0: return [] from collections import defaultdict occurrence_counter = defaultdict(int) result = [] for value in values: if occurrence_counter[value] < max_occurrences: result.append(value) occurrence_counter[value] += 1 return result"},{"question":"# Scenario You are given a 2D matrix representing a minefield. To defuse the minefield without setting off any mines, a robot has to traverse the field in a specific pattern - a clockwise spiral starting from the top-left corner. Write a function `spiral_traversal` that takes a 2D matrix as input and returns a list containing the elements of the matrix in the spiral order. # Task Implement the following function: ```python def spiral_traversal(matrix: List[List[int]]) -> List[int]: pass ``` # Input * `matrix`: A list of lists of integers representing the 2D matrix (minefield). You can assume the matrix has `m` rows and `n` columns, where `1 <= m, n <= 1000`. # Output * Returns a list of integers representing the elements of the matrix in spiral order. # Example Example 1: Input: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output: ```python [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Example 2: Input: ```python matrix = [ [1], [2], [3] ] ``` Output: ```python [1, 2, 3] ``` # Constraints * The number of elements in the matrix will not exceed 1,000,000. Your function should be efficient, with a time complexity of O(m * n), and should not use excessive additional space beyond storing the result.","solution":"from typing import List def spiral_traversal(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] top, left = 0, 0 bottom, right = m - 1, n - 1 while top <= bottom and left <= right: # Traverse from left to right for j in range(left, right + 1): result.append(matrix[top][j]) top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: # Traverse from right to left for j in range(right, left - 1, -1): result.append(matrix[bottom][j]) bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"# Question: Implementations and Optimization of Stooge Sort You are tasked with writing a function to sort an array using Stooge Sort and then proposing an optimized version of the function. Part 1: Implement Stooge Sort Implement the Stooge Sort function as described. Your function should take an array of integers and sort it in ascending order using the recursive Stooge Sort algorithm. **Function Signature**: ```python def stoogesort(arr: List[int], l: int, h: int) -> None: Sorts the portion of the array arr from index l to index h using Stooge Sort. ``` **Inputs & Outputs**: - **Input**: - `arr` : a list of integers, `arr[i]` (1 <= len(arr) <= 1000); individual integers can range from -10^6 to 10^6. - `l`: the starting index. - `h`: the ending index. - **Output**: - The function should sort the array in place; thus it returns `None`. **Example**: ```python arr = [5, 6, 2, 1, 3] stoogesort(arr, 0, len(arr)-1) print(arr) # Output: [1, 2, 3, 5, 6] ``` Part 2: Propose an Optimized Version Provide a brief explanation of how you could optimize the sorting process or suggest an alternative algorithm with better performance characteristics. Provide the pseudo-code or actual code for the optimized version.","solution":"from typing import List def stoogesort(arr: List[int], l: int, h: int) -> None: Sorts the portion of the array arr from index l to index h using Stooge Sort. if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) def optimized_sort(arr: List[int]) -> None: An optimized sorting algorithm. Here, we use the quicksort algorithm for optimization. def quicksort(arr: List[int], low: int, high: int) -> None: if low < high: pi = partition(arr, low, high) quicksort(arr, low, pi - 1) quicksort(arr, pi + 1, high) def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quicksort(arr, 0, len(arr) - 1)"},{"question":"# Find All Factor Combinations Write a function `find_factor_combinations(n: int) -> List[List[int]]` that returns all unique combinations of factors of a given positive integer `n`. Each combination should consist of factors (greater than 1 and less than n) that multiply to `n`. The function should return an empty list if no such combinations exist. Input: * An integer `n` where ( 2 leq n leq 10^6 ). Output: * A list of lists, where each inner list contains integers representing a unique combination of factors of `n`. Constraints: * Factors must be in the range greater than 1 and less than `n`. * You must handle both iterative and recursive approaches for the solution. Examples: Input: `1` Output: `[]` Input: `12` Output: ``` [ [2, 6], [2, 2, 3], [3, 4] ] ``` Input: `32` Output: ``` [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` Notes: * The combination [2, 2, 2, 2, 2] is a valid factor combination for 32 because ( 2 times 2 times 2 times 2 times 2 = 32 ). * For `n = 1`, the output must be an empty list since 1 has no valid factors greater than 1 and less than itself. * Ensure to provide separate functions for iterative and recursive solutions.","solution":"from typing import List def find_factor_combinations(n: int) -> List[List[int]]: Returns all unique combinations of factors of the given positive integer n. Each combination consists of factors greater than 1 and less than n that multiply to n. def helper(start, n): results = [] i = start while i * i <= n: if n % i == 0: results.append([i, n // i]) for rest in helper(i, n // i): results.append([i] + rest) i += 1 return results if n <= 1: return [] return helper(2, n)"},{"question":"# RSA Key Generation and Encryption/Decryption Implementation Using the principles of the RSA algorithm, implement a solution to generate an RSA key pair based on provided bit length `k`. Then, develop functions to encrypt and decrypt messages. Input: 1. `k` (int): The bit length for the modulus (n). 2. `data` (int): The number to encrypt using the generated keys. Output: A list `[n, e, d, encrypted, decrypted]` where: * `n` is the product of the two primes. * `e` is the public exponent. * `d` is the private exponent. * `encrypted` is the encrypted form of `data`. * `decrypted` is the original `data` after decryption. Function Requirements: * `def generate_key(k: int) -> tuple:` - Calculates (n), (e), and (d) as explained. - Returns a tuple `(n, e, d)`. * `def encrypt(data: int, e: int, n: int) -> int:` - Encrypts `data` using public key `(e, n)`. * `def decrypt(data: int, d: int, n: int) -> int:` - Decrypts `data` using private key `(d, n)`. Constraints: - `k` should be a positive integer greater than 1. - `data` should be a non-negative integer smaller than (n). # Example: ```python def rsa_operations(k, data): n, e, d = generate_key(k) encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) return [n, e, d, encrypted, decrypted] # Test k = 8 data = 20 print(rsa_operations(k, data)) # Example Output might be: [n, e, d, encrypted, decrypted] reflecting the input, encryption and decryption. ``` Write the solutions for `generate_key`, `encrypt`, and `decrypt` based on the given details.","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(k): Generate an odd integer randomly p = random.getrandbits(k) # Apply a mask to set MSB and LSB to 1 p |= (1 << k - 1) | 1 return p def generate_prime_number(k): Generate a prime number of k bits p = 4 # Keep generating while the number is not prime while not isprime(p): p = generate_prime_candidate(k) return p def generate_key(k): Generate the public and private keys. k : int : bit length of the modulus n Returns a tuple (n, e, d) p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): Encrypts the data using the public key (e, n) data : int : the plaintext to encrypt e : int : the public exponent n : int : the modulus Returns an integer which is the ciphertext. return pow(data, e, n) def decrypt(encrypted_data, d, n): Decrypts the data using the private key (d, n) encrypted_data : int : the ciphertext to decrypt d : int : the private exponent n : int : the modulus Returns an integer which is the plaintext. return pow(encrypted_data, d, n) def rsa_operations(k, data): n, e, d = generate_key(k) encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) return [n, e, d, encrypted, decrypted]"},{"question":"Strong Password Validator **Scenario**: Louise is trying to create an account on a new website, but she is unsure if her password is strong enough. The website has a password policy that requires every password to be \\"strong\\". **Task**: Write a function `strong_password(n: int, password: str) -> int` that determines the minimum number of characters Louise must add to make her password strong based on the given rules. **Rules for a Strong Password**: 1. The password must have at least 6 characters. 2. It must contain at least one digit (`0-9`). 3. It must contain at least one lowercase English letter (`a-z`). 4. It must contain at least one uppercase English letter (`A-Z`). 5. It must contain at least one special character from the set (`!@#%^&*()-+`). **Input**: - The first line contains an integer `n` denoting the length of the password. - The second line contains a string of `n` characters, the password typed by Louise. **Output**: - Return an integer representing the minimum number of characters Louise needs to add to make her password strong. **Sample Input 1**: ``` strong_password(3, \\"Ab1\\") ``` **Expected Output**: ``` 3 ``` *Explanation*: The password is of length 3 which is less than 6. Also, it contains all required character types. So, the most significant need is to achieve a minimum length of 6. Adding any 3 characters accomplishes this goal. **Sample Input 2**: ``` strong_password(11, \\"#Algorithms\\") ``` **Expected Output**: ``` 1 ``` *Explanation*: The password is of length 11 but lacks a digit. Adding a single digit makes the password strong. **Function Signature**: ```python def strong_password(n: int, password: str) -> int: pass ``` Implement `strong_password` function considering the above rules and constraints, ensuring optimal performance with clear validation checks for each password criterion.","solution":"def strong_password(n: int, password: str) -> int: Determines the minimum number of characters to add to make the password strong. import re # Initialize the required types of characters with False has_digit = False has_lower = False has_upper = False has_special = False special_characters = \\"!@#%^&*()-+\\" # Check already existing characters type in password for char in password: if char.isdigit(): has_digit = True elif char.islower(): has_lower = True elif char.isupper(): has_upper = True elif char in special_characters: has_special = True # Count how many types are missing missing_types = int(not has_digit) + int(not has_lower) + int(not has_upper) + int(not has_special) return max(6 - n, missing_types)"},{"question":"# Problem: You are given a singly linked list and a positive integer `k`. Write a function that returns the kth-to-last element of the linked list. To successfully complete this task, follow these instructions: # Core Task: Implement the function `kth_to_last(head: Node, k: int) -> Node` where: - **head**: Reference to the first node of a singly linked list, where a node is defined as follows: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` - **k**: A positive integer representing the position from the end (1-based index). # Constraints: - Ensure `k` is a positive integer. - Handle cases where `k` is greater than the length of the linked list by raising an `IndexError`. - The linked list could be as long as 10^6 nodes. # Example: ```python # Create the linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # The 4th-to-last element should be D assert kth_to_last(a1, 4).val == \\"D\\" ``` # Performance Requirements: - The function should run in O(n) time complexity. - The function should use O(1) space complexity besides the input linked list. # Function Signature: ```python class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: pass ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head: Node, k: int) -> Node: if k <= 0: raise ValueError(\\"k must be a positive integer\\") # Initialize two pointers slow = fast = head # Advance fast pointer by k steps for _ in range(k): if not fast: raise IndexError(\\"k is greater than the length of the list\\") fast = fast.next # Move both pointers until fast reaches the end while fast: slow = slow.next fast = fast.next # slow will now be pointing to the kth-to-last node return slow"},{"question":"You are working with a social network where nodes represent users, and directed edges (edges with direction) define \\"follows\\" relationships between users. You need to determine who can potentially reach whom either directly or indirectly through multiple connections. This task can be achieved by computing the transitive closure of the directed graph representing the network. # Function Signature ```python def compute_transitive_closure(vertex_count, edges): Compute the transitive closure matrix of a directed graph. :param vertex_count: (int) Number of vertices in the graph :param edges: (List[Tuple[int, int]]) A list of directed edges represented as tuples (source, target) :return: (List[List[int]]) The transitive closure matrix ``` # Input * **vertex_count**: An integer (1 <= vertex_count <= 1000), the number of vertices in the graph. * **edges**: A list of tuples, where each tuple (source, target) represents a directed edge from the source vertex to the target vertex. The number of edges is at most 10000. # Output * Return a 2D list (List[List[int]]) representing the transitive closure matrix. The element at index [i][j] should be 1 if there is a path from vertex i to vertex j, otherwise it should be 0. # Constraints * Ensure the solution handles disconnected nodes. * Optimize to avoid recursion depth issues for large graphs. # Example ```python vertex_count = 4 edges = [(0, 1), (1, 2), (2, 3)] expected_result = [ [1, 1, 1, 1], [0, 1, 1, 1], [0, 0, 1, 1], [0, 0, 0, 1] ] assert compute_transitive_closure(vertex_count, edges) == expected_result ``` # Requirements 1. Implement the function using an iterative approach to handle large input sizes effectively. 2. Ensure that the adjacency list and closure matrix are correctly initialized and updated during the computation.","solution":"def compute_transitive_closure(vertex_count, edges): Compute the transitive closure matrix of a directed graph. :param vertex_count: (int) Number of vertices in the graph :param edges: (List[Tuple[int, int]]) A list of directed edges represented as tuples (source, target) :return: (List[List[int]]) The transitive closure matrix # Initialize the adjacency matrix with zeros closure_matrix = [[0] * vertex_count for _ in range(vertex_count)] # Fill the matrix with initial edge values for u, v in edges: closure_matrix[u][v] = 1 # A node is reachable from itself for i in range(vertex_count): closure_matrix[i][i] = 1 # Floyd-Warshall algorithm to compute transitive closure for k in range(vertex_count): for i in range(vertex_count): for j in range(vertex_count): closure_matrix[i][j] = closure_matrix[i][j] or (closure_matrix[i][k] and closure_matrix[k][j]) return closure_matrix"},{"question":"# Question: Implement Enhanced Run-Length Encoding with Error Handling Scenario: During a data compression project, you need to employ Run-Length Encoding (RLE) to compress large datasets efficiently. Traditional RLE has been working well, but you encounter certain issues with large data that contains frequent single occurrences and very large runs. You are required to implement a more robust RLE that can handle these cases efficiently while maintaining the correctness of the compression and decompression process. In addition, you need to add checks for invalid inputs during decoding to ensure the robustness of your implementation. Task: 1. **Implement `encode_rle` function**: - **Input**: A string consisting of ASCII characters. - **Output**: A compressed string using RLE. - **Constraints**: - Consecutive runs of characters should be encoded as \\"count\\" + \\"character\\". - Handles very large runs efficiently. 2. **Implement `decode_rle` function**: - **Input**: An RLE compressed string. - **Output**: The original decompressed string. - **Constraints**: - Should correctly decode compliant RLE strings. - Checks for and handles invalid encoding formats, raising an appropriate exception. Requirements: 1. Performance should be considered, aiming for O(n) time complexity for both functions. 2. Both functions should handle edge cases gracefully. 3. Include robust error handling in `decode_rle`. # Sample Usage: ```python # Input data = \\"AAAABBBCCDAA\\" encoded = encode_rle(data) # Output should be \\"4A3B2C1D2A\\" print(encoded) # Input encoded_data = \\"4A3B2C1D2A\\" decoded = decode_rle(encoded_data) # Output should be \\"AAAABBBCCDAA\\" print(decoded) # Handling invalid input try: decode_rle(\\"2A3\\") except ValueError as e: print(e) # Output should be an error message indicating invalid format. ``` # Function Signatures: ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ```","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 previous_char = input[0] for char in input[1:]: if char == previous_char: count += 1 else: encoded.append(f\\"{count}{previous_char}\\") count = 1 previous_char = char encoded.append(f\\"{count}{previous_char}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = \\"\\" for char in input: if char.isdigit(): count += char elif char.isalpha(): if not count: raise ValueError(\\"Invalid RLE encoding format: No preceding number for the character.\\") decoded.append(char * int(count)) count = \\"\\" else: raise ValueError(\\"Invalid character in RLE string.\\") if count: raise ValueError(\\"Invalid RLE encoding format: Ends with digits.\\") return \\"\\".join(decoded)"},{"question":"Coding Assessment Question # Context: You are given two singly linked lists which may or may not intersect. Your task is to find and return the node at which the two lists intersect. If the two linked lists have no intersection at all, return `None`. The lists intersect at a single node, and from that node onwards, they share the same next nodes. # Function Signature: ```python def find_intersection(h1: Node, h2: Node) -> Node: ``` # Input: - `h1` (Node): The head node of the first linked list. - `h2` (Node): The head node of the second linked list. Both nodes may be empty. # Output: - The function should return the intersecting node if the lists intersect, or `None` if there is no intersection. # Constraints: - The nodes in the input lists are guaranteed to be singly linked (i.e., each node points to at most one subsequent node). - Do not modify the input lists. - Expected time complexity is O(N), where N is the total number of nodes in both lists. - Expected space complexity is O(1). # Examples: **Example 1:** Given the linked lists: 1 -> 2 -> 3 -> 7 -> 8 -> 9 6 / `find_intersection(1, 6)` should return the node with value 7. **Example 2:** Given the linked lists: 1 -> 2 -> 3 -> 4 5 -> 6 `find_intersection(1, 5)` should return `None` as there is no intersection. # Implementation: Define the `Node` class if necessary, and implement the `find_intersection` function. # Hints: 1. You may use two pointers and ensure they start traversing at nodes equidistant from the end. 2. You need to traverse each list at least once to determine their lengths. # Testing: - Provide a test suite that tests different scenarios, including edge cases like empty lists, lists without intersection, lists intersecting at the head, and lists of different lengths.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def find_intersection(h1: Node, h2: Node) -> Node: # Helper function to get the length of the list def get_length(head: Node) -> int: length = 0 while head: length += 1 head = head.next return length # Get the lengths of both lists len1 = get_length(h1) len2 = get_length(h2) # Point longer list\'s head and shorter list\'s head to corresponding head nodes if len1 > len2: for _ in range(len1 - len2): h1 = h1.next else: for _ in range(len2 - len1): h2 = h2.next # Move both pointers until they collide or reach end while h1 and h2: if h1 == h2: return h1 h1 = h1.next h2 = h2.next return None"},{"question":"# Problem Description You are tasked to implement a function to compute the power of a number using binary exponentiation. The function should handle both regular and modular exponentiation. # Function Specification Function Name: `power_function` Input: - `base` (int): The base value, `a`, of the exponentiation. - `exponent` (int): The exponent value, `n`, for exponentiation. - `modulo` (int, optional): An optional value for modular exponentiation. Default is `None`. Output: - Returns the result of the exponentiation as an integer. Constraints: - `0 <= a <= 10^9` - `0 <= n <= 10^9` - If `modulo` is provided: `1 <= modulo <= 10^9` Performance Requirement: - The solution should run in O(log n) time complexity and must optimize space usage. # Example Example 1 ```python base = 2 exponent = 10 power_function(base, exponent) # Output: 1024 ``` Example 2 ```python base = 2 exponent = 10 modulo = 1000 power_function(base, exponent, modulo) # Output: 24 ``` # Scenario Consider a scenario where you need to encrypt a message using RSA algorithm where large exponentiation with a modulus is necessary. This function will help you compute large powers efficiently and will be crucial in various cryptographic algorithms. Note: - You should ensure that the implementation minimizes space usage. - Think about edge cases like when the base or the exponent is zero.","solution":"def power_function(base, exponent, modulo=None): Computes the power of a number using binary exponentiation. If the modulo is provided, it computes the result under modulo. Args: base (int): The base value of the exponentiation. exponent (int): The exponent value for exponentiation. modulo (int, optional): An optional value for modular exponentiation. Default is None. Returns: int: The result of the exponentiation. result = 1 base = base % modulo if modulo else base while exponent > 0: if exponent % 2 == 1: # If exponent is odd result = (result * base) % modulo if modulo else result * base exponent = exponent >> 1 # Divide exponent by 2 base = (base * base) % modulo if modulo else base * base return result"},{"question":"**Question**: You are given a binary tree, and you need to write a function to find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. # Function Signature ```python def max_depth(root: TreeNode) -> int: pass ``` # Input - `root`: `TreeNode` - The root of the binary tree. # Output - An integer representing the maximum depth of the binary tree. # Constraints - The number of nodes in the tree is between `0` and `10^4`. - The value of each node is between `-1000` and `1000`. # Example **Example 1**: ```python Input: 3 / 9 20 / 15 7 Output: 3 ``` Explanation: The maximum depth is 3 as highlighted: 3 -> 20 -> 15. **Example 2**: ```python Input: 1 / 2 / 3 / 4 Output: 4 ``` Explanation: The maximum depth is 4 as highlighted: 1 -> 2 -> 3 -> 4. # Notes - You can use the BFS approach discussed in the analysis to complete this task.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: Computes the maximum depth of a binary tree. :param root: TreeNode :return: Integer representing the maximum depth of the binary tree. if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"You are tasked with implementing an optimized version of the Bubble Sort algorithm to sort a list of integers that could potentially include special cases like an already sorted list or a list with all identical elements. Your implementation should account for these by minimizing unnecessary comparisons and swaps. **Requirements**: 1. Implement the function `optimized_bubble_sort(arr)` that sorts an array of integers in ascending order. 2. The function should leverage the fact that a fully sorted array does not require any further passes. 3. Your implementation should return the sorted array. # Input/Output - **Input**: - A single list `arr` containing n integers where `1 <= n <= 10^3` and each integer in range `-10^6 <= arr[i] <= 10^6`. - **Output**: - A single list containing the sorted integers. # Constraints - Your solution must have an average and worst-case time complexity of O(n^2). - The sorting must be done in-place. # Function Signature ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: ``` # Example **Example 1**: ```python input: [64, 34, 25, 12, 22, 11, 90] output: [11, 12, 22, 25, 34, 64, 90] ``` **Example 2**: ```python input: [5, 1, 4, 2, 8] output: [1, 2, 4, 5, 8] ``` # Notes - Make sure to handle edge cases such as an empty list or a list with all identical elements efficiently. - It is recommended to use a flag to terminate the process early if no swaps are performed in a full pass through the array.","solution":"from typing import List def optimized_bubble_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n): # Flag to check if any swap happens swapped = False # Traverse the array from 0 to n-i-1 # The last i elements are already sorted for j in range(0, n-i-1): if arr[j] > arr[j+1]: # Swap if elements are out of order arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # If no two elements were swapped by inner loop, the list is sorted if not swapped: break return arr"},{"question":"Problem Statement You are given a non-negative number represented as a list of digits in big-endian order (most significant digit first). Your task is to increment this number by one and return the resulting list of digits. # Function Signature ```python def increment_number(digits: List[int]) -> List[int]: pass ``` # Input * A non-negative number represented as a list of digits (`List[int]`). * Each digit in the list is between 0 and 9 inclusive. No leading zeros (except for the number zero itself). # Output * Returns a list of digits representing the number incremented by one. # Constraints * The length of the input list will be between 1 and 1000. # Examples ```python >>> increment_number([1, 2, 3]) [1, 2, 4] >>> increment_number([9, 9, 9]) [1, 0, 0, 0] ``` # Explanation 1. In the first example, incrementing 123 by one results in 124. 2. In the second example, incrementing 999 results in 1000. # Requirements * The solution should handle carry-over throughout the digits as demonstrated. * Ensure the solution is optimal for time complexity (O(n)) and leverages in-place operations when possible. **Hint**: Consider processing the list of digits from the least significant to the most significant digit, managing the carry at each step.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increments the number represented by the list of digits by one. Parameters: digits (List[int]): A list of digits representing a non-negative number. Returns: List[int]: A list of digits representing the incremented number. n = len(digits) # Start from the least significant digit for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we have all 9\'s, we need an extra digit at the beginning return [1] + [0] * n"},{"question":"# Problem: Verify Structural and Value Equality of Two Binary Trees Given two binary trees, write a function to check if they are structurally identical and if the nodes have the same value. Function Signature ```python def is_same_tree(tree_p, tree_q): ``` Input - `tree_p`: The root node of the first binary tree (TreeNode or None). - `tree_q`: The root node of the second binary tree (TreeNode or None). Output - Return a Boolean value `True` if both binary trees are identical in structure and node values, otherwise return `False`. Constraints - Each tree node contains an integer value. - Both trees are binary trees; i.e., each node has at most two children. - Both input trees can be empty (i.e., `None`). Example ```python # Define TreeNode structure for clarity. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Create sample trees for comparison. # Tree 1 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) # Tree 2 root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) # Call your function: print(is_same_tree(root1, root2)) # Expected output: True # Another example with trees differing in structure. root3 = TreeNode(1) root3.left = TreeNode(2) root4 = TreeNode(1) root4.right = TreeNode(2) print(is_same_tree(root3, root4)) # Expected output: False ``` # Performance Requirements - The algorithm should have a time complexity of O(min(N, M)), where N and M are the number of nodes in the respective trees. - The space complexity should be O(min(height1, height2)), where height1 and height2 are the heights of the respective trees, due to recursive depth. Implement the function `is_same_tree` to solve the problem above.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p, tree_q): if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"# Scenario You are given a list of integers where every integer appears exactly twice except for one unique integer that appears only once. As a software developer, you\'re required to implement an efficient function to find that unique integer. Your function should operate in linear time and use constant space. This scenario mimics certain error detection systems where redundant checking is performed to single out errors. # Objective Implement a function `single_number(nums)` that identifies the single integer that does not conform to the duplication rule within a list. # Input - A list of integers: `nums` (1 <= len(nums) <= 10^5) - The list contains integers, where each integer appears twice except for one integer which appears once. # Output - Return the single integer that appears only once. # Constraints 1. Your solution should run in O(n) time complexity. 2. Your solution should use O(1) extra space. # Example ```python # Example 1 input: [4, 1, 2, 1, 2] output: 4 # Example 2 input: [2, 2, 3, 4, 4] output: 3 ``` **Note**: You do not need to handle cases where the list does not adhere to the problem constraints (like all elements appearing twice or no elements at all). # Boilerplate Code ```python def single_number(nums): Returns single number, if found. Else if all numbers appear twice, returns 0. :type nums: List[int] :rtype: int i = 0 for num in nums: i ^= num return i ``` Implement the function `single_number(nums)` to pass the given examples and constraints.","solution":"def single_number(nums): Returns the single integer that appears only once in the list. :type nums: List[int] :rtype: int result = 0 for num in nums: result ^= num return result"},{"question":"**Title**: Optimized Prime Counting in a Range **Objective**: Write a function that counts the number of prime numbers in a given range `[a, b]`. **Function Signature**: ```python def count_primes_in_range(a: int, b: int) -> int: Returns the number of prime numbers between a and b (inclusive). Parameters: a (int): The start of the range, inclusive. b (int): The end of the range, inclusive. Returns: int: The count of prime numbers within the specified range. ``` **Input**: - `a`: An integer, representing the start of the range. - `b`: An integer, representing the end of the range. - Constraints: - (0 leq a leq 10^6) - (0 leq b leq 10^6) - (a leq b) **Output**: - Return the number of prime numbers in the range `[a, b]` (inclusive). **Performance Requirements**: - Your solution should efficiently handle the provided range constraints. # Example: ```python assert count_primes_in_range(10, 20) == 4 # Primes are: 11, 13, 17, 19 assert count_primes_in_range(0, 10) == 4 # Primes are: 2, 3, 5, 7 assert count_primes_in_range(15, 15) == 0 # No prime numbers between 15 and 15 ``` # Additional Notes: - You can use the provided `prime_check` function to help determine if individual numbers are prime. - Implement an efficient solution that minimizes the number of checks necessary to determine the prime count in the range.","solution":"import math def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def count_primes_in_range(a: int, b: int) -> int: Returns the number of prime numbers between a and b (inclusive). count = 0 for num in range(a, b + 1): if is_prime(num): count += 1 return count"},{"question":"# Problem: Generating Fibonacci Squares Sequence You are given an integer `n` which represents the number of terms in a sequence where each term is the square of Fibonacci numbers. Your task is to implement a function that generates the first `n` terms of this sequence. The Fibonacci sequence is defined as: * `F(0) = 0` * `F(1) = 1` * `F(n) = F(n-1) + F(n-2)`, for n > 1 **Example**: If `n = 5`, the output should be `[0, 1, 1, 4, 9]`, this is because: - The first 5 Fibonacci numbers are [0, 1, 1, 2, 3] - The squares of these numbers are [0, 1, 1, 4, 9] # Function Signature ```python def fibonacci_squares(n: int) -> list: pass ``` # Input * An integer `n` where `1 ≤ n ≤ 20`. # Output * A list of `n` integers where each integer is the square of the corresponding Fibonacci number in the sequence. # Constraints * Your solution should aim for O(n) time complexity. * Your solution should aim for O(1) space complexity (not counting the output list). # Example Scenarios *Example 1*: ```python Input: n = 3 Output: [0, 1, 1] ``` *Explanation*: Fibonacci sequence for `n=3` is [0, 1, 1]. The squares of these numbers are [0, 1, 1]. *Example 2*: ```python Input: n = 6 Output: [0, 1, 1, 4, 9, 25] ``` *Explanation*: Fibonacci sequence for `n=6` is [0, 1, 1, 2, 3, 5]. The squares of these numbers are [0, 1, 1, 4, 9, 25].","solution":"def fibonacci_squares(n: int) -> list: Generate the first `n` terms of the sequence where each term is the square of Fibonacci numbers. :param n: The number of terms to generate. :return: A list containing the first `n` terms of the Fibonacci squares sequence. if n < 1: return [] if n == 1: return [0] # Initialize the first two Fibonacci numbers fib_0, fib_1 = 0, 1 # Initialize the resulting list with the squares of the first two Fibonacci numbers result = [fib_0**2, fib_1**2] for _ in range(2, n): next_fib = fib_0 + fib_1 result.append(next_fib**2) fib_0, fib_1 = fib_1, next_fib return result"},{"question":"To test your understanding of parsing and decoding encoded strings using a stack-based approach, complete the following task: # Task Write a function `decode_string(s)` that decodes an encoded input string `s`. The encoded string follows the rule: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly \'k\' times. The value `k` is always a positive integer. Assume the input string is always valid, meaning no extra white spaces, correctly formed brackets, and digits solely for repeat numbers. # Function Signature ```python def decode_string(s: str) -> str: pass ``` # Input - `s`: A single string `s` containing the encoded format. It is a non-empty string containing digits (`0-9`), alphabet characters (`a-z`), and square brackets (`[` and `]`). # Output - Returns a decoded string where any encoded substrings are expanded according to the rules. # Example ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` # Constraints - The input string will always be valid, as per the format described above. - The string does not contain any digits except for repeat counts. - No whitespace characters are present. # Explore Consider potential optimization for very large strings and highly nested sequences. Although the provided algorithm is optimal for constrained valid inputs, think about edge cases with deep nesting levels and large repeat counts.","solution":"def decode_string(s: str) -> str: Decodes the encoded string following the pattern: k[encoded_string]. Args: s (str): The encoded string. Returns: str: The decoded string. stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str = \'\' current_num = 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str # Example usage print(decode_string(\\"3[a]2[bc]\\")) # should output \\"aaabcbc\\" print(decode_string(\\"3[a2[c]]\\")) # should output \\"accaccacc\\" print(decode_string(\\"2[abc]3[cd]ef\\")) # should output \\"abcabccdcdcdef\\""},{"question":"# Minimum Spanning Tree Problem Context You are part of a network engineering team and have been given the task of designing a cost-efficient network for connecting various data centers. You have been provided with a list of potential direct connections between pairs of data centers, along with the cost of establishing each connection. Your goal is to ensure all data centers are connected with minimal total connection cost, forming a Minimum Spanning Tree (MST). Task Write a function `find_mst_cost(vertex_count, edges)` that takes the number of vertices (`vertex_count`) and a list of edges (`edges`) and returns the sum of the weights of the edges in the Minimum Spanning Tree (MST). Function Signature ```python def find_mst_cost(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: ``` Input - `vertex_count`: An integer representing the number of vertices in the graph. - `edges`: A list of tuples where each tuple `(u, v, weight)` represents an edge between vertex `u` and vertex `v` with the given `weight`. Output - Returns an integer representing the total weight of the MST. Constraints - (1 leq text{{vertex_count}} leq 10^5) - (0 leq text{{edges_count}} leq 2 times 10^5) Example ```python vertex_count = 5 edges = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] print(find_mst_cost(vertex_count, edges)) # Output: 14 vertex_count = 3 edges = [ (2, 1, 20), (3, 1, 20), (2, 3, 100) ] print(find_mst_cost(vertex_count, edges)) # Output: 40 ``` Notes - The vertices are 1-indexed. - Use Kruskal\'s algorithm to find the MST. - Make sure to handle edge cases and optimize for performance. - Ensure to implement path compression and union by rank in the disjoint set for efficient union-find operations.","solution":"def find_mst_cost(vertex_count, edges): Returns the sum of the weights of the edges in the Minimum Spanning Tree (MST). Params: vertex_count: int - Number of vertices in the graph. edges: List[Tuple[int, int, int]] - List of edges where each edge is represented as a tuple (u, v, weight). Returns: int - Total weight of the MST. parent = list(range(vertex_count + 1)) rank = [0] * (vertex_count + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 # Sort edges based on the weight edges.sort(key=lambda edge: edge[2]) mst_weight = 0 for u, v, weight in edges: if find(u) != find(v): union(u, v) mst_weight += weight return mst_weight"},{"question":"You are to design a data structure called `FixedStorageSet` which supports the following operations with average O(1) time complexity: 1. `add(val)`: Inserts an item `val` to the set if not already present. 2. `delete(val)`: Removes an item `val` from the set if present. 3. `select_random()`: Returns a random element from the current set of elements with uniform probability. 4. `has(val)`: Checks if an item `val` is present in the set. Your implementation should use a combination of a list and dictionary for efficient insertions and deletions as outlined below. # Input and Output * The main class should be named `FixedStorageSet`. * The `add(val)` method should return `True` if the item was added and `False` if it was already present. * The `delete(val)` method should return `True` if the item was removed and `False` if it was not present. * The `select_random()` method should return an element from the set with equal probability. * The `has(val)` method should return `True` if the item is present in the set and `False` otherwise. # Constraints * The set should store unique integers within the range of 32-bit signed integers. * You cannot use any additional libraries/functions that provide direct support for set operations other than those allowed in the guidelines. # Example ```python # Example Usage fsset = FixedStorageSet() result1 = fsset.add(10) # Should return True (10 was added) result2 = fsset.add(20) # Should return True (20 was added) result3 = fsset.add(10) # Should return False (10 already present) result4 = fsset.delete(20) # Should return True (20 was removed) result5 = fsset.delete(30) # Should return False (30 not present) result6 = fsset.has(10) # Should return True (10 is present) result7 = fsset.has(20) # Should return False (20 is not present) # select_random result can vary since it is random result8 = fsset.select_random() # Should return 10 since it is the only element ``` # Notes * Your solution should be efficient enough to handle a large number of operations in quick succession. * Make sure to handle edge cases such as removal of elements that do not exist and operations on an empty set.","solution":"import random class FixedStorageSet: def __init__(self): self.dict = {} self.list = [] def add(self, val): if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def delete(self, val): if val not in self.dict: return False last_element = self.list[-1] idx_to_delete = self.dict[val] self.list[idx_to_delete] = last_element self.dict[last_element] = idx_to_delete self.list.pop() del self.dict[val] return True def select_random(self): return random.choice(self.list) if self.list else None def has(self, val): return val in self.dict"},{"question":"**Context:** You are part of a software development team working on a project that involves analyzing binary trees for research. One of the tasks is to determine the maximum possible sum of values in any path of a given binary tree. A path in a binary tree is any sequence of nodes starting and ending at any nodes (including still the node itself), where each sequence of node connections goes along tree edges. **Task:** Write a function `max_path_sum` that finds the maximum path sum in a given binary tree. **Specifications:** - The binary tree is represented using nodes, where each node has an integer value and pointers to left and right children. - Implement the function `max_path_sum(root)` which takes in the root of the binary tree and returns the maximum path sum. **Input Format:** - The input is the root node of a binary tree. - Each node contains the following attributes: - `val`: an integer representing the node\'s value. - `left`: a pointer to the left child node or `None`. - `right`: a pointer to the right child node or `None`. **Output Format:** - The output should be a single integer representing the maximum path sum within the binary tree. **Constraints:** - The number of nodes in the tree will be in the range `[1, 3 * 10^4]`. - The values of the nodes could range from `-1000` to `1000`. **Example:** ``` Input: 1 / 2 3 Output: 6 Explanation: The maximum path sum is obtained through the path 2 -> 1 -> 3. Input: -10 / 9 20 / 15 7 Output: 42 Explanation: The maximum path sum is 15 -> 20 -> 7. ``` **Hint:** Utilize a depth-first traversal approach keeping track of the current path sums, and update a maximum value accordingly.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum path sum of the binary tree. def helper(node): nonlocal max_sum if not node: return 0 left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) current_sum = node.val + left_max + right_max max_sum = max(max_sum, current_sum) return node.val + max(left_max, right_max) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Next Perfect Square Problem Statement You are given a number, `n`. Your task is to determine if `n` is a perfect square, and if it is, return the next perfect square. If `n` is not a perfect square, return -1. A perfect square is an integer that is the square of an integer. For example, 1, 4, 9, 16, 25 are perfect squares. Your function should be named `find_next_square`. The function should take one parameter: - `n` (an integer, 0 ≤ n ≤ 10^9) The function should return: - The next perfect square if `n` is a perfect square. - `-1` if `n` is not a perfect square. Input Format - A single integer `n`. Output Format - A single integer representing the next perfect square or -1 if `n` is not a perfect square. Example **Example 1:** ``` Input: 121 Output: 144 ``` **Example 2:** ``` Input: 122 Output: -1 ``` **Example 3:** ``` Input: 0 Output: 1 ``` Constraints - Consider edge cases such as negative numbers, which should return -1 according to the problem requirements. - The input value will always be within the range 0 ≤ n ≤ 10^9. - Focus on maintaining the precision of floating-point operations. Performance Requirements - The solution must execute in constant time, O(1).","solution":"import math def find_next_square(n): Returns the next perfect square if n is a perfect square, otherwise returns -1. if n < 0: return -1 sqrt_n = math.isqrt(n) if sqrt_n * sqrt_n == n: return (sqrt_n + 1) * (sqrt_n + 1) else: return -1"},{"question":"**Context**: You are building a utility function for a text editor that needs to interpret encoded strings where certain patterns need to be expanded. The patterns follow the rule `k[encoded_string]`, where `encoded_string` inside the square brackets should be repeated exactly `k` times. Your task is to implement a function that decodes such strings into their expanded form. **Function Signature**: ```python def decode_string(s: str) -> str: Decodes an encoded string as per the specified pattern. Parameters: s (str): The encoded string. Returns: str: The decoded string. ``` **Input**: * A single string `s`, which may contain digits, square brackets, and lowercase alphabetic characters. * The string is always valid, i.e., it follows the encoding rules and has well-formed brackets. **Output**: * Return the decoded string. **Constraints**: * 1 <= len(s) <= 30 (for simplicity, assume short strings for testing). **Example**: ```python s = \\"3[a]2[bc]\\" assert decode_string(s) == \\"aaabcbc\\" s = \\"3[a2[c]]\\" assert decode_string(s) == \\"accaccacc\\" s = \\"2[abc]3[cd]ef\\" assert decode_string(s) == \\"abcabccdcdcdef\\" ``` **Requirements**: 1. Implement the function with efficient time and space complexity. 2. Ensure it correctly handles nested patterns. **Hints**: 1. Use a stack to manage the strings and repetition counts efficiently. 2. Accumulate numbers to handle multi-digit repetition counts.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \']\': last_string, repeat = stack.pop() current_string = last_string + repeat * current_string else: current_string += char return current_string"},{"question":"# Question You are given a set of real number intervals. Your task is to implement a function `find_gaps(intervals)` that identifies and returns all gaps between these intervals. The intervals may overlap or touch each other. A gap is defined as a range of numbers where no intervals are present. # Input * `intervals`: a list of tuples, where each tuple consists of two integers representing the start and end of an interval, inclusive. # Output * Return a list of tuples, each representing the start and end of a gap between the intervals. If no gaps are present, return an empty list. # Constraints * All input intervals will be valid, i.e., the start value will always be less than or equal to the end value. * Intervals may be non-overlapping, overlapping, or touching. * The number of intervals, `n`, will be between 1 and 10^4. # Example **Input**: ```python intervals = [(1, 3), (5, 7), (2, 4), (8, 10)] ``` **Output**: ```python [(4, 5), (7, 8)] ``` # Function Signature ```python def find_gaps(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` # Explanation In the given example, the intervals after merging are [(1, 4), (5, 7), (8, 10)]. The gaps between these merged intervals are [(4, 5), (7, 8)]. # Notes * Make sure your function handles edge cases, such as overlapping intervals, intervals that touch each other, and the absence of gaps. * Try to optimize the function to handle larger inputs efficiently.","solution":"from typing import List, Tuple def find_gaps(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # Sort the intervals by their start value intervals.sort() # Merge overlapping or contiguous intervals merged_intervals = [] start, end = intervals[0] for current_start, current_end in intervals[1:]: if current_start <= end: end = max(end, current_end) else: merged_intervals.append((start, end)) start, end = current_start, current_end merged_intervals.append((start, end)) # Find gaps between merged intervals gaps = [] for i in range(1, len(merged_intervals)): previous_end = merged_intervals[i-1][1] current_start = merged_intervals[i][0] if previous_end < current_start: gaps.append((previous_end, current_start)) return gaps"},{"question":"Given an array of integers, implement a function that uses the counting sort algorithm to sort the array. The function should be optimized for arrays that may contain negative numbers and must handle a variety of edge cases including the presence of negative values in the array. # Function Signature ```python def counting_sort_with_negatives(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: List[int] - A list of integers, which may include negative numbers. The length of the list does not exceed 10^6, and the values of the elements range from -10^6 to 10^6. # Output * Returns the sorted list of integers. # Constraints * The function should handle arrays containing negative numbers efficiently. * You must implement the counting sort algorithm. * Optimize for both time and space complexity considering the given constraints. # Examples **Example 1:** ```python Input: arr = [4, 2, -3, 6, -1, 0, -7] Output: [-7, -3, -1, 0, 2, 4, 6] ``` **Example 2:** ```python Input: arr = [2, 1, 2, -1, 3] Output: [-1, 1, 2, 2, 3] ``` **Example 3:** ```python Input: arr = [] Output: [] ``` # Instructions 1. Implement the function `counting_sort_with_negatives(arr: List[int]) -> List[int]`. 2. Ensure your solution handles negative numbers and edge cases correctly. 3. Aim for optimal performance given the constraints on input size and range.","solution":"from typing import List def counting_sort_with_negatives(arr: List[int]) -> List[int]: if not arr: return [] # Find the minimum and maximum value in the array min_val, max_val = min(arr), max(arr) # Initialize count array count_range = max_val - min_val + 1 count = [0] * count_range # Populate the count array for num in arr: count[num - min_val] += 1 # Output the sorted array sorted_index = 0 for i in range(count_range): while count[i] > 0: arr[sorted_index] = i + min_val sorted_index += 1 count[i] -= 1 return arr"},{"question":"**Problem Description**: Write a function to implement Shell Sort, which sorts a list of integers in ascending order. Students must use an efficient gap sequence and provide a detailed explanation of the chosen gap sequence and its complexity. **Function Signature**: ```python def shell_sort(arr: List[int]) -> List[int]: Sort a list of integers using Shell Sort algorithm. Params: arr (List[int]): List of integers to be sorted Returns: List[int]: Sorted list in ascending order. # Your code here ``` **Input**: * A list `arr` of integers where ( 0 leq text{len(arr)} leq 1000 ). * Each integer in `arr` is in the range ([-10^6, 10^6]). **Output**: * A list of integers sorted in ascending order. **Constraints**: * The function should handle lists with varying numbers of elements efficiently. * You must use the Shell Sort algorithm with a gap sequence of your choice. You should explain in comments why you chose the particular sequence. **Example**: ```python # Example instance print(shell_sort([22, 7, 2, -5, 0, 3, 91, 45, 6])) # Output: [-5, 0, 2, 3, 6, 7, 22, 45, 91] # Example with already sorted array print(shell_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] # Example with reverse sorted array print(shell_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] ``` **Scenario**: Imagine you are working on a system that requires sorting a mix of slightly sorted lists and completely random lists. Implement an efficient and adaptive sorting algorithm (Shell Sort) that can handle such scenarios with minimized performance overhead.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sort a list of integers using Shell Sort algorithm. Params: arr (List[int]): List of integers to be sorted Returns: List[int]: Sorted list in ascending order. n = len(arr) # Using Knuth\'s sequence: gap = 3x + 1 gap = 1 while gap < n // 3: gap = gap * 3 + 1 # Perform insertion sort with gaps while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 3 return arr"},{"question":"# Flatten Nested Arrays Given an array that may contain nested arrays, produce a single resultant array. The provided nested structure can contain elements that are integers, strings, or nested arrays of integers and strings. Input * A nested array containing integers, strings, and other nested arrays. Output * A single flattened list containing all the elements from the nested arrays in the same order. Example ```python Input: [1, [2, 3, [4, [5, 6], 7]], 8, [9, [10, 11]], \\"abc\\", [[\\"def\\", [\\"ghi\\"]]]] Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, \\"abc\\", \\"def\\", \\"ghi\\"] ``` Constraints * You must preserve the order of elements as they appear in the nested arrays. * Strings should remain intact and not be split into individual characters. * Utilize recursion to handle the nested structures. # Question Implement a function `flatten_array(nested_array: list) -> list` which takes a nested array as input and returns a single flattened list. ```python def flatten_array(nested_array: list) -> list: # Implement the function here pass # Example usage nested_array = [1, [2, 3, [4, [5, 6], 7]], 8, [9, [10, 11]], \\"abc\\", [[\\"def\\", [\\"ghi\\"]]]] print(flatten_array(nested_array)) # Output should be [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, \\"abc\\", \\"def\\", \\"ghi\\"] ``` **Note**: Be careful of the recursion depth for very deeply nested arrays.","solution":"def flatten_array(nested_array): Flattens a nested array of integers, strings, or nested arrays of integers and strings. Args: nested_array (list): The nested array to flatten. Returns: list: A single flattened list containing all the elements from the nested arrays. flattened_list = [] for item in nested_array: if isinstance(item, list): flattened_list.extend(flatten_array(item)) else: flattened_list.append(item) return flattened_list # Example usage nested_array = [1, [2, 3, [4, [5, 6], 7]], 8, [9, [10, 11]], \\"abc\\", [[\\"def\\", [\\"ghi\\"]]]] print(flatten_array(nested_array)) # Output should be [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, \\"abc\\", \\"def\\", \\"ghi\\"]"},{"question":"# Scenario: You are developing a search feature for a text editor that needs to highlight multiple occurrences of a word (pattern) within the loaded document (text). The text and pattern are case sensitive, and you must ensure a fast search to not interrupt the user experience. # Task: Implement a function `highlight_occurrences` using the Knuth-Morris-Pratt algorithm to find and highlight all occurrences of a given pattern in the text. # Function Signature: ```python def highlight_occurrences(text: str, pattern: str) -> str: ``` # Input: - `text`: A string representing the text where the search takes place. - `pattern`: A string pattern that needs to be found and highlighted in the text. # Output: - Return a new string where all occurrences of the pattern are enclosed in `<highlight></highlight>` tags. # Constraints: - The length of the text will not exceed 100,000 characters. - The length of the pattern will not exceed 10,000 characters. # Performance Requirements: - Time complexity should be O(N + M). # Example: ```python print(highlight_occurrences(\'hello there hero!\', \'he\')) ``` Output: ```plaintext \'<highlight>he</highlight>llo t<highlight>he</highlight>re <highlight>he</highlight>ro!\' ``` # Notes: 1. If the pattern is not found, return the original text. 2. Assume the `<highlight></highlight>` tags do not affect the position indices in terms of searching the patterns.","solution":"def highlight_occurrences(text: str, pattern: str) -> str: # Knuth-Morris-Pratt (KMP) Algorithm for Pattern Searching def compute_lps(pattern): Helper function to compute the longest prefix which is also suffix array (LPS) for the pattern lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps if not pattern: return text lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append((i - j, i)) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 # Highlight the occurrences in the text if not result: return text highlighted_text = [] prev_index = 0 for start, end in result: highlighted_text.append(text[prev_index:start]) highlighted_text.append(\'<highlight>\' + text[start:end] + \'</highlight>\') prev_index = end highlighted_text.append(text[prev_index:]) return \'\'.join(highlighted_text)"},{"question":"Scenario You are tasked with implementing a search function for a system that frequently handles data stored in arrays. The data is unsorted, and you need to find the specific item requested by various users. To ensure you have a sound understanding of basic search techniques, you have decided to implement a linear search algorithm. Problem Statement Write a function `linear_search(array, query)` that searches for the `query` element in the `array`. If `query` is found, return its index; otherwise, return -1. The search should be performed in a linear manner. # Function Signature ```python def linear_search(array, query): ``` Input - `array` (List of integers): An unsorted list of integers. - `query` (integer): The integer you need to search for in the `array`. Output - Return an integer indicating the index of the `query` in the `array`. If the `query` is not found, return -1. Constraints - You can assume that array can be of any size. - The elements of `array` and `query` will be valid integers. Example ```python >>> linear_search([34, 78, 21, 56, 47, 89], 56) 3 >>> linear_search([1, 2, 3, 4, 5], 6) -1 >>> linear_search([], 5) -1 ``` Additional Notes - Consider edge cases such as an empty array. - The function should handle arrays with duplicate elements by returning the index of the first occurrence of the `query`.","solution":"def linear_search(array, query): Searches for the query element in the array. If found, returns its index. Otherwise, returns -1. Parameters: array (List of integers): An unsorted list of integers. query (integer): The integer to search for in the array. Returns: int: The index of the query in the array or -1 if not found. for index, element in enumerate(array): if element == query: return index return -1"},{"question":"# Dijkstra\'s Algorithm Application in Network Routing Context You are developing a network routing application that determines the shortest path for data packets from one computer to another in a network represented by a directed graph. Each computer is a node, and the communication channels between them are edges with associated weights representing transmission time. Problem Statement Implement a function `find_shortest_paths(graph, src)` that uses Dijkstra\'s algorithm to find the shortest path from a specified source node to all other nodes in the given graph. The graph is represented as an adjacency matrix where `graph[i][j]` denotes the weight of the edge from node `i` to node `j`. A weight of 0 means there is no direct edge between the nodes. The source node is numbered 0 to V-1, where V is the number of vertices in the graph. Input * An adjacency matrix `graph` of size `V x V` (where `graph[i][j] >= 0`). * An integer `src` representing the source node. Output * A list of the shortest distances from the `src` node to each other node. Constraints * Number of vertices, V: 2 ≤ V ≤ 1000 * Edge weights: Non-negative integers Requirements * Must handle graphs with up to 1000 vertices within a reasonable time frame. * Should manage cases with isolated vertices and zero-weight edges effectively. # Example ```python graph = [ [0, 10, 0, 0, 0, 0], [10, 0, 5, 0, 0, 0], [0, 5, 0, 50, 20, 0], [0, 0, 50, 0, 30, 0], [0, 0, 20, 30, 0, 10], [0, 0, 0, 0, 10, 0] ] src = 0 print(find_shortest_paths(graph, src)) # Expected output: [0, 10, 15, 65, 35, 45] ``` You need to complete the body of the function `find_shortest_paths(graph, src)` to produce the shortest paths as shown in the example. Function Signature ```python def find_shortest_paths(graph: List[List[int]], src: int) -> List[int]: ```","solution":"import heapq from typing import List, Tuple def find_shortest_paths(graph: List[List[int]], src: int) -> List[int]: Uses Dijkstra\'s algorithm to find the shortest path from src node to all other nodes. :param graph: 2D list representing the adjacency matrix of the graph. :param src: Source node from where to calculate shortest paths. :return: List of shortest distances from source node to each node. V = len(graph) distances = [float(\'inf\')] * V distances[src] = 0 priority_queue = [(0, src)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # if the popped node\'s distance is not up-to-date in the priority queue if current_distance > distances[current_node]: continue for neighbor in range(V): if graph[current_node][neighbor] != 0: new_distance = current_distance + graph[current_node][neighbor] if new_distance < distances[neighbor]: distances[neighbor] = new_distance heapq.heappush(priority_queue, (new_distance, neighbor)) return distances"},{"question":"# Coding Challenge: Enhanced Interpolation Search Given an implementation of the interpolation search algorithm, your task is to enhance it by addressing potential drawbacks and improving efficiency. You will implement a refined version of the `interpolation_search` function called `enhanced_interpolation_search` that: 1. Fallbacks to binary search when data distribution is detected to be non-uniform. 2. Handles edge cases gracefully. 3. Optimizes performance for a range of real-world datasets. **Function Signature**: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: pass ``` # Input * `array` (List[int]): A sorted list of integers in non-decreasing order. * `search_key` (int): An integer value to search within the array. # Output * Returns the index of `search_key` if found, otherwise returns -1. # Constraints - Elements in `array` will be sorted in non-decreasing order. - The length of `array` will be between 0 and 10^6. - Each element in `array` will be between -10^9 and 10^9. # Examples: ```python # Example 1 print(enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)) # Output: 2 # Example 2 print(enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # Output: -1 # Example 3 print(enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)) # Output: -1 ``` # Performance Requirements 1. The implementation should have an average-case complexity of O(log log n) for uniformly distributed arrays and fallback gracefully to O(log n) if the distribution is skewed. 2. The space complexity should not exceed O(1). # Additional Considerations - Validate the input for typical edge cases such as empty arrays or identical elements. - Optimize the algorithm to avoid redundant calculations and minimize overhead. Good luck with your implementation!","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: if not array: return -1 low = 0 high = len(array) - 1 while low <= high and array[low] <= search_key <= array[high]: # Avoid division by zero and out of range access if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Probe position formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if pos >= len(array) or pos < 0: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 # Fall back to binary search if interpolation search is not efficient def binary_search(arr: List[int], key: int, low: int, high: int) -> int: while low <= high: mid = (low + high) // 2 if arr[mid] == key: return mid elif arr[mid] < key: low = mid + 1 else: high = mid - 1 return -1 return binary_search(array, search_key, low, high)"},{"question":"# Question You are provided with a stack of integers implemented using a list. Your task is to implement a `restore_and_check_sorted` function that: 1. Checks if the elements in the stack are sorted in ascending order from bottom to top. 2. Ensures that the original stack is restored after the check. Function Signature ```python def restore_and_check_sorted(stack: list) -> bool: # Your code here ``` Input: * `stack`: A list of integers, where the last element of the list represents the top of the stack. Output: * Returns `True` if the stack is sorted in ascending order from bottom to top; otherwise, returns `False`. Constraints: * You may assume that the elements in the stack are unique. * The maximum size of the stack is 10^5. Example: ```python stack1 = [6, 3, 5, 1, 2, 4] print(restore_and_check_sorted(stack1)) # Output: False print(stack1) # Output: [6, 3, 5, 1, 2, 4] - original stack restored stack2 = [1, 2, 3, 4, 5, 6] print(restore_and_check_sorted(stack2)) # Output: True print(stack2) # Output: [1, 2, 3, 4, 5, 6] - original stack restored ``` Notes: * Consider edge cases such as an empty stack or a stack with a single element. * Efficient restoration of the original stack state is crucial. * Aim to achieve the desired functionality with optimal time and space complexity.","solution":"def restore_and_check_sorted(stack: list) -> bool: Checks if the elements in the stack are sorted in ascending order from bottom to top. After the check, restores the original stack. Parameters: stack : list A list of integers where the last element represents the top of the stack. Returns: bool True if the stack is sorted in ascending order from bottom to top, False otherwise. temp_stack = [] is_sorted = True previous_element = None # Check sorting and move elements to temp_stack while stack: current_element = stack.pop() if previous_element is not None and previous_element < current_element: is_sorted = False previous_element = current_element temp_stack.append(current_element) # Restore the original stack while temp_stack: stack.append(temp_stack.pop()) return is_sorted"},{"question":"Implementing Cocktail Shaker Sort You are tasked with implementing a sorting algorithm known as Cocktail Shaker Sort. This algorithm is an extension of Bubble Sort and it sorts the array in both directions alternatively. In this challenge, you need to write a function to sort a given list of integers in ascending order using the Cocktail Shaker Sort algorithm. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Input * **arr**: A list of integers `arr[n]` where 0 ≤ n ≤ 10^3. Output * A list of integers sorted in ascending order. Constraints * Do not use built-in sort functions. * The array may contain negative integers and duplicates. Example ```python print(cocktail_shaker_sort([6, 3, 8, 5, -1, 7])) # Output: [-1, 3, 5, 6, 7, 8] print(cocktail_shaker_sort([1, 4, 2, 5, 3])) # Output: [1, 2, 3, 4, 5] print(cocktail_shaker_sort([])) # Output: [] print(cocktail_shaker_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(cocktail_shaker_sort([3, 1, 2, 3, 1, 2])) # Output: [1, 1, 2, 2, 3, 3] ``` # Requirements 1. You must implement the Cocktail Shaker Sort algorithm as described. 2. Ensure that your code handles edge cases like an already sorted array, an array with duplicate values, and an empty array appropriately. 3. Analyze and discuss the time and space complexity of your solution.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts the array in ascending order using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Traverse from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"You are working as a software engineer at a startup developing a new data processing pipeline involving linked lists. Your current task is to merge two pre-sorted linked lists into a single sorted linked list efficiently. Requirements 1. **Implement** a function called `mergeTwoSortedLists` that combines two sorted linked lists into one sorted linked list. 2. **Input**: Two singly linked lists `l1` and `l2`. - Each node in the linked list has the following structure: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` 3. **Output**: A singly linked list that is sorted and contains all elements from `l1` and `l2`. # Constraints * Both linked lists are sorted in ascending order. * The function should handle empty linked lists. * Aim for minimal space complexity, favoring an iterative approach over recursive. * You are not allowed to modify the original lists; create a new sorted list. # Example ```python # Merely for demonstrating structure; not to be used within solution # Helper function to print list def print_list(node): while node: print(node.val, end=\\" -> \\") node = node.next print(\\"None\\") # Setting up the example lists l1 = Node(1) l1.next = Node(2) l1.next.next = Node(4) l2 = Node(1) l2.next = Node(3) l2.next.next = Node(4) # Expected output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> None merged_list = mergeTwoSortedLists(l1, l2) print_list(merged_list) ``` # Performance Requirements * The solution should have a time complexity of O(n + m) and space complexity of O(1) excluding input and output space. # Function Signature ```python def mergeTwoSortedLists(l1: Node, l2: Node) -> Node: pass ``` Implement the function `mergeTwoSortedLists` based on the provided requirements and constraints.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def mergeTwoSortedLists(l1, l2): # Dummy node to provide a starting point dummy = Node(0) current = dummy # Traverse both lists while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If either list still has nodes, append them if l1: current.next = l1 if l2: current.next = l2 return dummy.next # The merged list, starting from the next node of dummy"},{"question":"You are given three different implementations to compute the n-th Fibonacci number: one using recursion, one using dynamic programming, and one using an iterative approach. Your task is to write a new implementation, using the most efficient method provided in terms of both time and space complexity, to compute the n-th Fibonacci number. # Function Signature ```python def fib_efficient(n: int) -> int: ``` # Input * A single integer `n` where 0 <= n <= 10^6. # Output * A single integer that represents the n-th Fibonacci number. # Constraints * You must use an iterative approach. * The function must run within O(n) time complexity and O(1) space complexity. # Example ```python assert fib_efficient(0) == 0 assert fib_efficient(1) == 1 assert fib_efficient(10) == 55 assert fib_efficient(100) == 354224848179261915075 ``` # Note Ensure that your solution handles the case for very large `n` efficiently, taking advantage of the expected time and space complexity constraints.","solution":"def fib_efficient(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. This implementation uses O(n) time complexity and O(1) space complexity. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: **Calculate Shortest Distance to Gates in a Grid** Given a 2D grid `rooms` where: - `-1` represents a wall. - `0` represents a gate. - `INF` (infinity, represented by `2147483647`) represents an empty room. Write a function `walls_and_gates(rooms: List[List[int]]) -> None` that modifies the grid in-place such that each empty room is filled with the distance to its nearest gate. If it is impossible to reach a gate, the room should remain as `2147483647`. # Constraints: - The input grid will have a maximum size of `10,000 x 10,000`. - Ensure the algorithm is optimized to prevent recursion limits and excessive memory usage. - The distance should be calculated in terms of the number of steps from the gate (considering up, down, left, right movements). # Input Format: - `rooms`: A 2D list of integers where each value is either `-1`, `0`, or `2147483647`. # Output Format: - The function returns nothing but modifies the input grid in place. # Example: Input: ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] ``` Output (in-place modification): ```python rooms = [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] ``` # Special Notes: - Consider using a BFS approach for optimal performance for larger grid sizes to avoid stack overflow issues. - Handle edge cases involving grids filled entirely with walls or where it\'s impossible to reach any gate.","solution":"from collections import deque from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: Modifies the grid in-place such that each empty room is filled with the distance to its nearest gate. if not rooms or not rooms[0]: return rows, cols = len(rooms), len(rooms[0]) queue = deque() # Initialize the queue with all the gates\' positions for r in range(rows): for c in range(cols): if rooms[r][c] == 0: queue.append((r, c)) # Directions for moving in the grid: up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc # Check if it is a valid position and is an empty room if 0 <= nr < rows and 0 <= nc < cols and rooms[nr][nc] == 2147483647: rooms[nr][nc] = rooms[r][c] + 1 queue.append((nr, nc))"},{"question":"Efficient Symbol Matching and Replacement **Problem Statement:** You are given an array of words and an array of symbols. Your task is to write a function that efficiently matches symbols within each word, marks the matched part with square brackets, and ensures that the longest matching symbol is selected if multiple matches are found. Function Signature: ```python def mark_symbols(words: list[str], symbols: list[str]) -> list[str]: pass ``` Input: - `words`: A list of strings where each string represents a word. (1 ≤ len(words[i]) ≤ 100) - `symbols`: A list of strings where each string represents a symbol. (1 ≤ len(symbols[i]) ≤ 50) Output: - A list of strings where each word has the longest matching symbol marked with square brackets. Constraints: - If two symbols have the same length and both match a segment in the word, match with the symbol that appears first in the `symbols` array. - If a word matches no symbol, it should remain unchanged. - Optimize for both time and space, aiming for an efficient solution. Example: ```python Input: words = [\'Amazon\', \'Microsoft\', \'Google\'], symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Hints: - Consider using a trie structure to represent the symbols for efficient lookup. - Ensure that you handle edge cases, such as overlapping symbols or symbols not present in words. **Task:** Implement the function `mark_symbols` that meets the above specifications and constraints.","solution":"def mark_symbols(words: list[str], symbols: list[str]) -> list[str]: class TrieNode: def __init__(self): self.children = {} self.word_end = False self.word = None def insert_symbol(root, symbol): node = root for char in symbol: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word_end = True node.word = symbol def search_longest_symbol(word, root): longest_symbol = \\"\\" win_index = -1 for i in range(len(word)): node = root current_index = i current_symbol = \\"\\" while current_index < len(word) and word[current_index] in node.children: current_symbol += word[current_index] node = node.children[word[current_index]] if node.word_end and len(current_symbol) > len(longest_symbol): longest_symbol = current_symbol win_index = i current_index += 1 return longest_symbol, win_index # Build the Trie root = TrieNode() for symbol in symbols: insert_symbol(root, symbol) result = [] # Process each word to find the longest symbol and mark it for word in words: longest_symbol, index = search_longest_symbol(word, root) if longest_symbol: marked_word = word[:index] + \\"[\\" + longest_symbol + \\"]\\" + word[index + len(longest_symbol):] else: marked_word = word result.append(marked_word) return result"},{"question":"**Problem Statement**: You are given a list of integers representing the stock prices of a company over time. Your task is to write a function that computes the maximum possible sum of a contiguous subarray. The function signature is provided below: ```python def find_max_contiguous_subarray_sum(prices: List[int]) -> int: This function computes the maximum possible sum of any contiguous subarray. :param prices: A list of integers representing daily stock prices. :return: An integer that is the maximum possible sum of a contiguous subarray. ``` # Input * The input will be a list of integers `prices` where 1 leq text{length of prices} leq 10^5. * Each integer in `prices` will be between -10^4 and 10^4. # Output * The output will be a single integer representing the maximum sum of any contiguous subarray. # Constraints * Optimize the function to have a **time complexity of O(n)** and a **space complexity of O(1)**. # Example ```python # Example 1 prices = [1, 2, -3, 4, 5, -7, 23] assert find_max_contiguous_subarray_sum(prices) == 25 # Example 2 prices = [-4, -3, -2, -1] assert find_max_contiguous_subarray_sum(prices) == -1 # Example 3 prices = [2, 1, -4, 3, -1, 2, 4, -5, 3] assert find_max_contiguous_subarray_sum(prices) == 8 ``` # Additional Notes * Ensure to consider edge cases like single-element arrays or arrays with all negative numbers. * The function should handle large lists efficiently under the given constraints.","solution":"from typing import List def find_max_contiguous_subarray_sum(prices: List[int]) -> int: This function computes the maximum possible sum of any contiguous subarray. :param prices: A list of integers representing daily stock prices. :return: An integer that is the maximum possible sum of a contiguous subarray. if not prices: return 0 max_sum = current_sum = prices[0] for price in prices[1:]: current_sum = max(price, current_sum + price) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Finding Primitive Roots A primitive root `g` of a prime number `p` is any number `g` such that every number `a` coprime to `p` can be expressed as some power of `g` modulo `p`. In other words, the order of `g` is `p-1` and `g` is a generator of the multiplicative group modulo `p`. Write a function `find_all_primitive_roots(p)` that takes a prime number `p` and returns a list of all primitive roots of `p`. # Input - `p` (2 <= p <= 10^5): An integer, which should be a prime number. # Output - A list of integers, where each integer is a primitive root of `p`, sorted in ascending order. # Constraints - The input integer `p` will always be a prime. - The returned list should be sorted in ascending order. # Example ```python def find_all_primitive_roots(p): # Your implementation here # Example usage result = find_all_primitive_roots(11) print(result) # Output: [2, 6, 7, 8] ``` # Notes - Ensure that your solution handles the edge case of the smallest prime `p = 2` correctly. - Consider the time complexity of your implementation, especially for larger values of `p`.","solution":"def find_all_primitive_roots(p): Finds all primitive roots of a prime number p. def gcd(a, b): while b: a, b = b, a % b return a def is_primitive_root(g, p): required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(g, powers, p) for powers in range(1, p)) return required_set == actual_set # Primitive root list to return primitive_roots = [g for g in range(1, p) if is_primitive_root(g, p)] return primitive_roots"},{"question":"You are given a binary array (an array consisting of only 0s and 1s). Your task is to create a function that determines the index of a zero that, when replaced by one, would create the longest sequence of consecutive ones in the array. If no zeros are in the array, the function should return -1. # Function Signature ```python def max_ones_index(arr: List[int]) -> int: ``` # Input Parameters * `arr`: A list of integers where each element is either 0 or 1. `1 <= len(arr) <= 10^5` # Output * Return the index of the zero that should be replaced to obtain the longest sequence of consecutive ones. * If no zero is present in the array, return -1. # Example ```python assert max_ones_index([1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]) == 3 assert max_ones_index([1, 1, 1, 1, 1, 1]) == -1 assert max_ones_index([0, 1, 1, 0, 1]) == 0 ``` # Constraints * Aim for an O(n) time complexity. * Handle edge cases such as: - Arrays with no zeros. - Arrays with a single zero either at the start, middle, or end. - Arrays composed entirely of zeros. - Arrays with consecutive sequences of zeros and ones. # Background Context You are tasked with solving this problem as part of an application for a large-scale data processing company that frequently deals with binary sequences. They need the solution to be efficient given the large input sizes, and they\'re looking for the most optimal zero replacement to maximize the length of the converted binary sequence.","solution":"from typing import List def max_ones_index(arr: List[int]) -> int: max_ones = 0 max_index = -1 current_ones_count = 0 previous_ones_count = 0 zero_index = -1 for i in range(len(arr)): if arr[i] == 1: current_ones_count += 1 else: if zero_index != -1: # If we have encountered a zero # Calculate total consecutive ones if this zero at zero_index is flipped total_ones = previous_ones_count + current_ones_count + 1 if total_ones > max_ones: max_ones = total_ones max_index = zero_index # Update previous_ones_count to be the current streak, and reset current_ones_count previous_ones_count = current_ones_count current_ones_count = 0 zero_index = i # Mark the current zero index # We need to check one more time at the end of the iteration if zero_index != -1: total_ones = previous_ones_count + current_ones_count + 1 if total_ones > max_ones: max_ones = total_ones max_index = zero_index return max_index"},{"question":"# Programming Challenge: Bogo Sort Simulation with Edge Case Handling Context Bogo Sort is a highly inefficient sorting algorithm that randomly shuffles the given array until it gets sorted. Although impractical, Bogo Sort is an interesting concept to demonstrate the implications of using randomness in algorithms. Task You are required to implement the `bogo_sort` function that takes an array of integers and sorts it using Bogo Sort. Additionally, you must handle the following edge cases explicitly: - An array that is already sorted. - An array with all identical elements. - An empty array. Include a feature to simulate the sorting process by printing each iteration if the `simulation` parameter is set to `True`. Function Signature ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the array using Bogo Sort. Args: - arr (List[int]): The array of integers to sort. - simulation (bool): Optional; whether to print the array in each iteration. Returns: - List[int]: The sorted array. ``` Input/Output Format - **Input**: A list of integers `arr` and an optional boolean `simulation`. - **Output**: A list of integers sorted in ascending order. Constraints 1. The input array `arr` can have up to a maximum of 10 elements. 2. Each element in the array is an integer in the range [-100, 100]. 3. The `simulation` parameter is `False` by default and, if set to `True`, prints each array state during shuffles. Performance Requirement Due to the nature of Bogo Sort, implement it considering the input size constraint (`n <= 10`). Example ```python # The following is an example of how the function can be used. arr = [3, 1, 2] sorted_arr = bogo_sort(arr, simulation=True) print(sorted_arr) # Expected: [1, 2, 3] ``` Notes - Ensure the implementation handles the mentioned edge cases. - Be mindful of the inefficiency and randomness of Bogo Sort, which may result in a large number of iterations.","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Helper function to check if the array is sorted. return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: Sorts the array using Bogo Sort. Args: - arr (List[int]): The array of integers to sort. - simulation (bool): Optional; whether to print the array in each iteration. Returns: - List[int]: The sorted array. while not is_sorted(arr): if simulation: print(arr) random.shuffle(arr) return arr"},{"question":"Problem Statement You are developing part of a larger tree processing module and need to implement post-order traversal for a binary tree. Your task is to complete the implementations of two functions, one that performs iterative post-order traversal and one that performs recursive post-order traversal. # Requirements Write two functions, `postorder_iterative` and `postorder_recursive`, that perform the post-order traversal on a given binary tree and return a list of node values in post-order sequence. # Function Signatures ```python def postorder_iterative(root: Node) -> List[int]: # your code here def postorder_recursive(root: Node) -> List[int]: # your code here ``` # Input - `root`: A `Node` representing the root of a binary tree. Each `Node` has the attributes: * `val`: Integer representing the node\'s value. * `left`: Reference to the left child `Node` or `None`. * `right`: Reference to the right child `Node` or `None`. # Output - Return a list of integers representing the post-order traversal of the binary tree. # Constraints - The number of nodes in the tree (n) can range from 0 to 10^4. - Each node\'s value is an integer within the range `[-10^5, 10^5]`. # Examples 1. **Example 1**: ```plaintext Input: 1 2 / 3 Output: [3, 2, 1] ``` 2. **Example 2**: ```plaintext Input: 1 Output: [1] ``` # Notes - Assume that the Node class is predefined as follows: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` - You must implement the traversal functions without changing the Node class or its attributes.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root: Node) -> list[int]: if root is None: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recursive(root: Node) -> list[int]: result = [] def dfs(node: Node): if node: dfs(node.left) dfs(node.right) result.append(node.val) dfs(root) return result"},{"question":"# Question: Enhanced Insertion Sort with Custom Comparator Description You are required to implement an enhanced version of the Insertion Sort algorithm that can sort any list of comparable elements using a custom comparator function. The custom comparator will be provided as a function that takes two elements and returns an integer: negative if the first element is \\"smaller,\\" zero if they are \\"equal,\\" and positive if the first element is \\"greater.\\" Function Signature ```python def custom_insertion_sort(arr: List[Any], comparator: Callable[[Any, Any], int], simulation: bool = False) -> List[Any]: Sorts arr using the insertion sort algorithm and a custom comparator function. Parameters: arr (List[Any]): The input list to be sorted. comparator (Callable[[Any, Any], int]): A custom comparator function. simulation (bool): If True, prints the array at each step of the sorting for debugging. Returns: List[Any]: The sorted list. ``` Input * `arr`: A list of comparable elements, e.g., integers, strings, or custom objects. * `comparator`: A function that takes two arguments and returns an integer: * `comparator(x, y) < 0` implies `x` is \\"less than\\" `y` * `comparator(x, y) == 0` implies `x` is \\"equal to\\" `y` * `comparator(x, y) > 0` implies `x` is \\"greater than\\" `y` * `simulation`: A boolean flag. If `True`, outputs the state of the list after each insertion iteration. Output * Returns the sorted list based on the custom comparator. Constraints * Assume the comparator function is always reliable and won\'t throw exceptions. * The list may contain elements of any data type that the comparator can handle. * Aim to maintain the algorithm\'s in-place sorting characteristic. Example ```python # Custom comparator function for sorting integers in descending order def descending_comparator(x, y): return y - x arr = [4, 2, 7, 1, 3] sorted_arr = custom_insertion_sort(arr, descending_comparator) print(sorted_arr) # Output: [7, 4, 3, 2, 1] ``` Notes 1. Handle different kinds of data properly using the comparator, maintaining the algorithm\'s stability if the comparator treats any two elements as equal. 2. Your implementation should print the list at each iteration if the `simulation` flag is set to `True`.","solution":"from typing import List, Any, Callable def custom_insertion_sort(arr: List[Any], comparator: Callable[[Any, Any], int], simulation: bool = False) -> List[Any]: Sorts arr using the insertion sort algorithm and a custom comparator function. Parameters: arr (List[Any]): The input list to be sorted. comparator (Callable[[Any, Any], int]): A custom comparator function. simulation (bool): If True, prints the array at each step of the sorting for debugging. Returns: List[Any]: The sorted list. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and comparator(arr[j], key) > 0: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(arr) return arr"},{"question":"Given a singly linked list, the task is to efficiently find the k-th to last element in the list. You should implement this functionality using a two-pointer technique as it\'s the most optimal method discussed. Please also take care of edge cases and error scenarios as outlined. # Function Details: Implement the function `kth_to_last(head, k)` where: * `head` is the head node of the singly linked list. * `k` is the integer representing the k-th last position in the list (0-indexed). # Expected Input and Output: * Input: The head of the singly linked list and an integer `k`. * Output: The node value at the k-th to last position in the list. # Constraints: * The linked list length will be at maximum `10^4` nodes. * `k` will be a non-negative integer. # Example: ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head, k): if not (head or k > -1): return False p1 = head p2 = head for i in range(1, k+1): if p1 is None: raise IndexError p1 = p1.next while p1: p1 = p1.next p2 = p2.next return p2.val def print_linked_list(head): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) # Example scenario # Creating nodes a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") # Linking nodes a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g print_linked_list(a1) # A -> A -> B -> C -> D -> C -> F -> G print(kth_to_last(a1, 4)) # Output: D ``` # Notes: * Handle cases where `k` is greater than the list length by raising an appropriate exception. * Ensure your solution is optimized for large input sizes.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def kth_to_last(head, k): Returns the value at the k-th to last position in the list. Args: head (Node): The head of the list. k (int): The k-th position from the end of the list (0-indexed). Returns: any: The value at the k-th to last position. Raises: IndexError: If the k is out of the bounds of the list length. if head is None: raise ValueError(\\"The list is empty\\") if k < 0: raise ValueError(\\"k must be a non-negative integer\\") p1 = head p2 = head # Move p1 k+1 steps ahead for _ in range(k + 1): if p1 is None: raise IndexError(\\"k is greater than the list length\\") p1 = p1.next # Move both pointers until p1 reaches the end while p1: p1 = p1.next p2 = p2.next return p2.val"},{"question":"Implement and Test Cycle Sort Background: Cycle Sort is an in-place comparison-based sorting algorithm that minimizes the number of memory writes. It is especially useful for sorting when write operations are expensive. This algorithm works by decomposing the permutation of elements into cycles and then rotating these cycles to place elements in their correct positions. Task: Implement the `cycle_sort` function. Given a list of integers, your task is to sort the elements in ascending order using the Cycle Sort algorithm. Function Signature: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Input: - `arr`: A list of integers of size `N` where `1 <= N <= 10^4`. Output: - Return the sorted list of integers in ascending order. Constraints: - The list may contain duplicate elements. - Perform the sorting in-place with a focus on reducing the number of writes. - Aim to use only O(1) extra space. Example: ```python # Example 1 input_arr = [3, 1, 5, 4, 2] print(cycle_sort(input_arr)) # Output: [1, 2, 3, 4, 5] # Example 2 input_arr = [1, 1, 1, 1] print(cycle_sort(input_arr)) # Output: [1, 1, 1, 1] # Example 3 input_arr = [] print(cycle_sort(input_arr)) # Output: [] ``` Considerations: - Ensure your implementation handles edge cases such as empty lists, lists with a single element, and lists with all identical elements. - Think about how to minimize the number of writes while ensuring correctness. Evaluation Criteria: - Correctness: The function must return correctly sorted arrays. - Efficiency: The implementation should minimize writes and handle large arrays within reasonable time limits. - Code Quality: The implementation should be clean, well-documented, and follow best practices.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) for start in range(n - 1): item = arr[start] pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 if pos == start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"# Scenario You are developing a software system that performs various numerical computations, and one of the tasks is to quickly determine how many digits an integer has. Efficiently calculating the number of digits in an integer is crucial for this part of the system to ensure it can handle numerous requests in real-time. # Task Implement a function `num_digits(n)` that takes an integer `n` and returns the number of digits in `n`. Your implementation should strive for optimal performance in both time and space. # Input * An integer `n` which can be positive, negative, or zero. # Output * The number of digits in the given integer `n`. # Constraints * The function should handle large integers efficiently. * The function should assume valid integer input and does not need to handle non-integer types. * The performance is critical; aim for O(1) time complexity. # Example ```python >>> num_digits(123) 3 >>> num_digits(-12345) 5 >>> num_digits(0) 1 ``` Implement the `num_digits` function to meet these requirements.","solution":"def num_digits(n): Returns the number of digits in the given integer n. return len(str(abs(n)))"},{"question":"# Question: Iterative and Recursive Binary Search Implementation You are required to implement two versions of the binary search algorithm - iterative and recursive. Your task is to write two functions, `binary_search_iterative` and `binary_search_recursive`, which search for a target value in a sorted array. Function Definitions: 1. `binary_search_iterative(array, target)` - **Input**: - `array`: A list of integers in ascending order. - `target`: An integer value to search for. - **Output**: - Return the index of `target` if found in the array. - Return `-1` if the target value is not in the array. 2. `binary_search_recursive(array, low, high, target)` - **Input**: - `array`: A list of integers in ascending order. - `low`: The starting index of the subarray. - `high`: The ending index of the subarray. - `target`: An integer value to search for. - **Output**: - Return the index of `target` if found in the subarray. - Return `-1` if the target value is not in the subarray. Constraints: - The input array will have at most (10^6) elements. - Each element in the array is an integer in the range ([-10^9, 10^9]). Examples: ```python # Example 1 array = [1, 2, 3, 4, 5] target = 3 print(binary_search_iterative(array, target)) # Output: 2 print(binary_search_recursive(array, 0, len(array)-1, target)) # Output: 2 # Example 2 array = [-5, -3, 0, 1, 4, 7, 10] target = 4 print(binary_search_iterative(array, target)) # Output: 4 print(binary_search_recursive(array, 0, len(array)-1, target)) # Output: 4 # Example 3 array = [] target = 0 print(binary_search_iterative(array, target)) # Output: -1 print(binary_search_recursive(array, 0, len(array)-1, target)) # Output: -1 ``` Note: - Ensure that your implementations handle edge cases such as an empty array or out-of-bound indices gracefully. - Consider optimizing the calculation of the mid-point for large arrays to avoid potential overflow issues.","solution":"def binary_search_iterative(array, target): Perform an iterative binary search on a sorted array. :param array: List[int] - List of integers in ascending order. :param target: int - The integer value to search for. :return: int - The index of target if found, else -1. low, high = 0, len(array) - 1 while low <= high: mid = low + (high - low) // 2 if array[mid] == target: return mid elif array[mid] < target: low = mid + 1 else: high = mid - 1 return -1 def binary_search_recursive(array, low, high, target): Perform a recursive binary search on a sorted array. :param array: List[int] - List of integers in ascending order. :param low: int - The starting index of the subarray. :param high: int - The ending index of the subarray. :param target: int - The integer value to search for. :return: int - The index of target if found, else -1. if low > high: return -1 mid = low + (high - low) // 2 if array[mid] == target: return mid elif array[mid] < target: return binary_search_recursive(array, mid + 1, high, target) else: return binary_search_recursive(array, low, mid - 1, target)"},{"question":"# Coding Challenge: Enhanced Cocktail Shaker Sort You are provided with a sorting algorithm called \\"Cocktail Shaker Sort\\" which is a bi-directional version of Bubble Sort. Your task is to enhance this sorting algorithm to efficiently handle large datasets more effectively. # Objective Implement an enhanced version of the Cocktail Shaker Sort algorithm in Python. The new algorithm should improve upon the original in terms of time complexity for large datasets while ensuring stability and maintaining the bi-directional traversal characteristic. # Input * An array `arr` of integers, where ( 1 leq text{arr.length} leq 10^5 ). * Each element in the array ( -10^6 leq arr[i] leq 10^6 ). # Output * An array of integers sorted in non-decreasing order. # Constraints * Your implementation should aim to reduce the overall time complexity. * Maintain the stability of the sorting algorithm. * The algorithm must still use bi-directional traversal for sorting. # Performance Requirements * The implementation should handle arrays up to ( 10^5 ) elements efficiently. # Example ```python Input: [3, 2, 1, 4, 5] Output: [1, 2, 3, 4, 5] Input: [10, -1, 2, 3, 4] Output: [-1, 2, 3, 4, 10] ``` # Implementation Hint You may consider integrating elements from other sorting algorithms such as insertion sort in smaller segments, or any other techniques that can reduce the time complexity.","solution":"def enhanced_cocktail_shaker_sort(arr): Enhanced version of the Cocktail Shaker Sort to handle large datasets efficiently. n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, break if not swapped: break # Reset the swapped flag so that it # can be used in the next stage swapped = False # Move the end point back by one, because # the last element is already in place end -= 1 # Traverse from right to left for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # Increase the starting point, because # the first element is already in place start += 1 return arr"},{"question":"# Modular Exponentiation Function In cryptographic systems and other computational algorithms, it is common to need the result of raising a number to a power and then taking the modulus of that result. Given the efficiency and commonality of such operations, it is essential to implement efficient algorithms. Write a function `modular_exponential(base, exponent, mod)` to calculate ((base^{exponent}) mod mod) using the efficient binary exponentiation method. Function Signature ```python def modular_exponential(base: int, exponent: int, mod: int) -> int: ``` Input * `base` (int): The base integer which can be positive, negative, or zero. * `exponent` (int): The exponent integer which must be non-negative. * `mod` (int): The modulus integer which must be positive. Output * Returns an integer which is the result of the modular exponentiation calculation. Constraints * (0 leq base leq 10^9) * (0 leq exponent leq 10^9) * (1 leq mod leq 10^9) Example ```python # Test Case 1 print(modular_exponential(2, 10, 1000)) # Expected output: 24 # Test Case 2 print(modular_exponential(3, 0, 7)) # Expected output: 1 # Test Case 3 print(modular_exponential(2, 5, 13)) # Expected output: 6 ``` Edge Cases * If `exponent` is 0, the function should return 1 regardless of the `base` (given non-zero mod). * Ensure that very large bases and exponents are handled within a reasonable time frame due to the efficient (O(log space n)) complexity.","solution":"def modular_exponential(base: int, exponent: int, mod: int) -> int: result = 1 base = base % mod # Update base if it is more than or equal to mod while exponent > 0: # If exponent is odd, multiply base with result if (exponent % 2) == 1: result = (result * base) % mod # Exponent must be even now exponent = exponent >> 1 # Divide exponent by 2 base = (base * base) % mod # Change base to base^2 % mod return result"},{"question":"# Power of Two Determination **Objective**: Write a function to determine if a given integer is a power of two. **Scenario**: A network administrator needs to verify if network bandwidth settings are correctly configured to powers of two. To aid this verification process, you need to implement a function that takes an integer and checks if it represents a power of two. Powers of two are numbers such as 1, 2, 4, 8, 16, etc. **Task**: Implement the following function: ```python def is_power_of_two(n): :type n: int :rtype: bool ``` **Input**: - `n` (integer): The number to check for being a power of two. - `0 <= n <= 2^31 - 1` **Output**: - `bool`: Return `True` if `n` is a power of two, otherwise return `False`. **Constraints**: - The function should handle the number `0` correctly, which is not a power of two. - Negative numbers should also return `False`. **Examples**: 1. Given `n = 1`, the function should return `True` (2^0). 2. Given `n = 16`, the function should return `True` (2^4). 3. Given `n = 18`, the function should return `False`, as 18 is not a power of two. 4. Given `n = 0`, the function should return `False`. **Performance Requirements**: - The solution should run in constant time, O(1).","solution":"def is_power_of_two(n): Checks if n is a power of two. :param n: int :return: bool if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"**Problem Statement:** Implement a modified version of the Comb Sort algorithm which includes optimizations for handling large data sets and utilizes a hybrid approach to improve performance towards the final iterations. Specifically, implement a switch to Insertion Sort once the gap is reduced to 1. **Function Signature**: ```python def optimized_comb_sort(arr: List[int]) -> List[int]: ``` **Input**: - A list of integers `arr` (0 <= len(arr) <= 10^5) **Output**: - A list of integers sorted in ascending order. **Constraints**: - You cannot use built-in sorting functions. - The shrink factor should be experimentally determined to be optimal (typical starting value: 1.3). - Performance requirements: The algorithm should handle large inputs efficiently, preferable under the O(N log N) complexity for average cases. **Notes**: - Consider edge cases like single-element arrays, already sorted arrays, and arrays with duplicate values. - Assure that the swapping and comparison steps are correctly implemented. - Switch to Insertion Sort when the gap is 1 for an improved performance. **Example**: ```python print(optimized_comb_sort([34, 8, 64, 51, 32, 21])) # Output: [8, 21, 32, 34, 51, 64] print(optimized_comb_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(optimized_comb_sort([9])) # Output: [9] print(optimized_comb_sort([])) # Output: [] ```","solution":"from typing import List def optimized_comb_sort(arr: List[int]) -> List[int]: def insertion_sort(arr: List[int]) -> List[int]: for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def comb_sort(arr: List[int]) -> List[int]: shrink_factor = 1.3 gap = len(arr) sorted = False while not sorted: gap = int(gap // shrink_factor) if gap > 1: sorted = False else: gap = 1 sorted = True # Assume this is the last stage for i in range(len(arr) - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr # First use comb sort to reduce the large gap. arr = comb_sort(arr) # Then switch to insertion sort when gap is 1 arr = insertion_sort(arr) return arr"},{"question":"# Merging Interval User IDs Context You are given the task of maintaining and managing ranges of user IDs who have access to a particular service. Each range is represented as an interval of consecutive user IDs. Your goal is to manage the intervals efficiently, especially considering operations where new intervals are added, potentially overlapping existing intervals. Problem Statement Write a function `add_and_merge_intervals` that takes a list of intervals (each represented as a list/tuple [start, end]) and a new interval to be added, merges this new interval with the existing intervals if they overlap, and returns the updated list of intervals without overlap. Function Signature ```python def add_and_merge_intervals(intervals:[[int, int]], new_interval:[int, int]) -> [[int, int]]: pass ``` Input Format * `intervals`: A list where each element is a list of two integers [start, end] representing the start and end of an interval. * `new_interval`: A list of two integers [start, end] to be merged with the list of intervals. Output Format * Returns a list of merged intervals. Constraints * All the intervals and the new interval are non-decreasing. Tasks 1. Sort the existing intervals based on starting points. 2. Merge the new interval into the list such that there are no overlapping intervals. Example ```python # Example 1: intervals = [[1, 3], [6, 9]] new_interval = [2, 5] output = add_and_merge_intervals(intervals, new_interval) print(output) # Expected output: [[1, 5], [6, 9]] # Example 2: intervals = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]] new_interval = [4, 8] output = add_and_merge_intervals(intervals, new_interval) print(output) # Expected output: [[1, 2], [3, 10], [12, 16]] ``` You can assume that the inputs are always valid (i.e., `end` >= `start` for all intervals).","solution":"def add_and_merge_intervals(intervals, new_interval): Merges a new interval into a list of existing intervals, ensuring no overlapping intervals. Parameters: intervals (list of list of int): List of existing intervals represented as [start, end]. new_interval (list of int): New interval to be added and merged represented as [start, end]. Returns: list of list of int: The updated list of intervals after merging. result = [] i = 0 start, end = new_interval # Add all intervals before the new interval while i < len(intervals) and intervals[i][1] < start: result.append(intervals[i]) i += 1 # Merge intervals that overlap with the new interval while i < len(intervals) and intervals[i][0] <= end: start = min(start, intervals[i][0]) end = max(end, intervals[i][1]) i += 1 # Add the merged interval result.append([start, end]) # Add all intervals after the merged interval while i < len(intervals): result.append(intervals[i]) i += 1 return result"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: This snippet uses a binary tree traversal algorithm to find the deepest node that is the left child of its parent node. * **Complexity**: * **Time Complexity**: O(n), where n is the number of nodes in the binary tree. This is because the algorithm needs to visit every node. * **Space Complexity**: O(h), where h is the height of the binary tree due to the recursion stack. * **Principles**: The core mechanism involves a depth-first traversal of the tree, keeping track of the depth of nodes and identifying the deepest left child node encountered. Characteristics & Applications * **Properties**: * Utilizes depth-first search (DFS). * Uses a class `DeepestLeft` to store the deepest left node and the depth at which it occurs. * Distinguishes between left children and right children during traversal. * **Common Use Cases**: * Finding specific nodes in large trees with specific properties. * Useful in tree-based searches where certain constraints (like being a left child) are important. * **Strengths/Limitations**: * **Strengths**: Simple implementation and effective for the given task within binary trees. * **Limitations**: DFS can be memory-intensive with deep trees due to recursive stack space. Implementation Challenges * **Edge Cases**: * Tree is empty (Root is None). * Tree has only one node. * **Performance Bottlenecks**: * Deep trees may cause stack overflow due to deep recursion. * **Error Scenarios**: * Incorrectly identifying nodes not fulfilling the \'left child\' criteria. * **Optimization Points**: * An iterative approach using a stack might be more memory efficient for extremely deep trees. <|Analysis End|> <|Question Begin|> # Find the Deepest Left Child Node in a Binary Tree Given a binary tree, write a function to find the deepest node that is the left child of its parent node. Input - The input will be the root of the binary tree. Output - The output should be the value of the deepest node that is the left child of its parent. - If there is no such node, return `None`. Constraints - The number of nodes in the binary tree will not exceed 10^5. - Each node\'s value will be unique. - The value of each node will be in the range `[1, 10^5]`. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DeepestLeft: def __init__(self): self.depth = 0 self.node = None def find_deepest_left(root): if not root: return None def helper(node, is_left, depth, res): if not node: return if is_left and depth > res.depth: res.depth = depth res.node = node helper(node.left, True, depth + 1, res) helper(node.right, False, depth + 1, res) result = DeepestLeft() helper(root, False, 0, result) return result.node.val if result.node else None # Example usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.right.right.right = TreeNode(7) print(find_deepest_left(root)) # Output: 4 ``` Implement the `find_deepest_left` function to solve the problem based on the above example usage.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DeepestLeft: def __init__(self): self.depth = 0 self.node = None def find_deepest_left(root): if not root: return None def helper(node, is_left, depth, res): if not node: return if is_left and depth > res.depth: res.depth = depth res.node = node helper(node.left, True, depth + 1, res) helper(node.right, False, depth + 1, res) result = DeepestLeft() helper(root, False, 0, result) return result.node.val if result.node else None"},{"question":"# FizzBuzz Adjacent Counting **Objective**: Develop a modified version of the classic FizzBuzz problem, called FizzBuzz Adjacent Counting. **Scenario**: In this variation, for each number, the rules for Fizz, Buzz, and FizzBuzz remain unchanged. However, after replacing values with \'Fizz\', \'Buzz\', or \'FizzBuzz\', the program should count each occurrence and return these counts along with the modified sequence. **Function Signature**: `def fizzbuzz_adjacent(n: int) -> Tuple[List[Union[int, str]], Dict[str, int]]:` **Task**: - Implement the function `fizzbuzz_adjacent` that takes an integer `n` (1 <= n <= 10^6). - The function should return two items: 1. A list containing the numbers from 1 to n where the numbers are replaced according to the rules of FizzBuzz. 2. A dictionary containing the counts of each string (\'Fizz\', \'Buzz\', \'FizzBuzz\') replacements made. **Rules for Replacement**: * Replace numbers divisible by 3 with \'Fizz\'. * Replace numbers divisible by 5 with \'Buzz\'. * Replace numbers divisible by both 3 and 5 with \'FizzBuzz\'. **Input**: * `n`: An integer representing the range [1, n]. **Output**: * A tuple where the first element is a list resulting from the FizzBuzz replacements and the second element is a dictionary of counts for \'Fizz\', \'Buzz\', and \'FizzBuzz\'. **Constraints**: * `1 <= n <= 10^6`. **Example**: ```python fizzbuzz_adjacent(15) # Output: ([1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'], # {\'Fizz\': 4, \'Buzz\': 2, \'FizzBuzz\': 1}) ``` # Evaluation Criteria: * Correctness: The function should correctly implement the rules for the FizzBuzz replacements and count occurrences. * Efficiency: The implementation should handle the upper constraint efficiently. * Edge Cases: The function should properly handle edge cases, such as the minimum value of n.","solution":"def fizzbuzz_adjacent(n: int): Generate a modified FizzBuzz sequence and count the occurrences of \'Fizz\', \'Buzz\', and \'FizzBuzz\'. Args: n (int): The end number (inclusive) in the range starting from 1. Returns: Tuple[List[Union[int, str]], Dict[str, int]]: A tuple containing the modified list and a dictionary of counts. result = [] counts = {\\"Fizz\\": 0, \\"Buzz\\": 0, \\"FizzBuzz\\": 0} for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") counts[\\"FizzBuzz\\"] += 1 elif i % 3 == 0: result.append(\\"Fizz\\") counts[\\"Fizz\\"] += 1 elif i % 5 == 0: result.append(\\"Buzz\\") counts[\\"Buzz\\"] += 1 else: result.append(i) return result, counts"},{"question":"Context: You are working on a system that needs to maximize contiguous runs of certain conditions. This problem specifically involves binary representations of integers, and your task is to manipulate bits to achieve the longest possible sequence of 1s. Objective: Write a function `flip_bit_longest_seq` that takes a non-negative integer as input and returns the length of the longest sequence of 1s that can be created by flipping exactly one bit from 0 to 1 in the binary representation of that integer. Function Signature: ```python def flip_bit_longest_seq(num: int) -> int: # implementation ``` Input: * `num` (int): A non-negative integer. Output: * An integer representing the length of the longest sequence of 1s obtainable by flipping exactly one bit from 0 to 1. Constraints: * The input number will be in the range [0, 2^31 - 1]. Example: ```python # Example 1 input = 1775 # Binary: 11011101111 output = 8 # Example 2 input = 15 # Binary: 1111 output = 5 ``` Notes: * Explain your implementation approach. * Consider any edge cases and handle them appropriately. * Aim for an efficient solution in terms of time and space complexity.","solution":"def flip_bit_longest_seq(num: int) -> int: Returns the length of the longest sequence of 1s that can be created by flipping exactly one bit from 0 to 1 in the binary representation of the given integer. if num == 0: return 1 current_length = 0 previous_length = 0 max_length = 1 # We can always flip at least one bit while num != 0: if (num & 1) == 1: # Current bit is 1 current_length += 1 else: # Current bit is 0 # Update to the max sequence length after flipping the bit previous_length = 0 if (num & 2) == 0 else current_length current_length = 0 # Compare the total length (current_length + previous_length + 1) max_length = max(max_length, previous_length + current_length + 1) # Shift right by 1 to process the next bit num >>= 1 return max_length"},{"question":"# Graph Cloning Problem You have been tasked with cloning an undirected graph. Each node in the graph contains a unique label and a list of its neighboring nodes. This task assesses your ability to understand and implement graph traversal and cloning algorithms. # Objectives Implement a function `clone_graph_recursive(node: UndirectedGraphNode) -> UndirectedGraphNode` that accepts a node of an undirected graph and returns a deep copy of the entire graph using a recursive depth-first search (DFS) approach. # Input * `node`: The starting node of an undirected graph. This node is represented as an instance of the `UndirectedGraphNode` class. If `node` is `None`, return `None`. # Output * The function should return the starting node of a cloned undirected graph. # Constraints * Each node\'s neighbors list may have zero (if it has no neighbors) or more elements. * You can assume each node has a unique label. * The graph may contain self-loops and cycles. # Example Consider the graph represented in the following format, where each `UndirectedGraphNode` has a unique label and a list of neighbor nodes: ```plaintext 1 / 0 -- 2 _/ ``` If the input node is labeled as `0`, the graph can be serialized as `{0,1,2#1,2#2,2}`. * If the input `node` with label `0` is passed to `clone_graph_recursive`, the output should be the deep copy of this graph, starting from a node with label `0`. # Notes 1. The `UndirectedGraphNode` and traversal functions are provided. 2. You must use a recursive DFS approach to traverse and clone the graph. 3. Use a dictionary to track already cloned nodes to handle cycles and avoid redundant copying. You have two classes and three functions given (do not modify): ```python import collections class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) def dfs(node, dic): for neighbor in node.neighbors: if neighbor not in dic: neighbor_copy = neighbor.shallow_copy() dic[neighbor] = neighbor_copy dic[node].add_neighbor(neighbor_copy) dfs(neighbor, dic) else: dic[node].add_neighbor(dic[neighbor]) ``` Implement only: ```python def clone_graph_recursive(node: UndirectedGraphNode) -> UndirectedGraphNode: pass ``` This function should utilize the `dfs` function and the `UndirectedGraphNode` class to clone the graph starting from the provided node.","solution":"def clone_graph_recursive(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None def dfs(node, visited): if node in visited: return visited[node] node_copy = UndirectedGraphNode(node.label) visited[node] = node_copy for neighbor in node.neighbors: node_copy.neighbors.append(dfs(neighbor, visited)) return node_copy return dfs(node, {})"},{"question":"# Question Write a Python function `extract_domain_name(url)` to extract the domain name from a given URL string using list splitting operations. Your function should not use any built-in libraries except for `.split()`. **Function Signature:** ```python def extract_domain_name(url: str) -> str: pass ``` **Input:** * A string `url` representing the URL. The string can assume some of the formats: * Standard: `http://www.example.com` * Without \'www\': `http://example.com` * Secure: `https://www.example.com` * Without protocol: `www.example.com` **Output:** * A string representing just the domain name without `www`, protocols, or any path. **Constraints:** 1. The URL will at least have a domain part. 2. The domain part will be non-empty. **Examples:** ```python assert extract_domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" assert extract_domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" assert extract_domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" assert extract_domain_name(\\"http://example.com\\") == \\"example\\" assert extract_domain_name(\\"www.example.com\\") == \\"example\\" ``` Provide a solution that directly implements string manipulations for handling various URL formats and extracting the correct domain name precisely as per the requirement.","solution":"def extract_domain_name(url: str) -> str: Extracts the domain name from a given URL string. # Remove the protocol part if \\"://\\" in url: url = url.split(\\"://\\")[1] # Remove \'www.\' prefix if present if url.startswith(\\"www.\\"): url = url[4:] # Split by \'/\' to remove any path, only keep the domain part domain = url.split(\'/\')[0] # Split by \'.\' and take the first part to get the domain name return domain.split(\'.\')[0]"},{"question":"# Scenario You are tasked with implementing a variation of Dijkstra\'s algorithm to compute the shortest path in a city\'s road network. The city has a specified number of intersections, and each intersection is connected to other intersections with roads of varying lengths. Given a starting intersection, your program should return the shortest distance from that intersection to all other intersections. # Task Implement a function `shortest_paths(n, roads, start)` that computes the shortest distance from the `start` intersection to every other intersection using Dijkstra\'s algorithm. # Function Signature ```python def shortest_paths(n, roads, start): Calculate the shortest paths from the start intersection to all other intersections. Parameters: n (int): The number of intersections in the city. roads (List[Tuple[int, int, int]]): A list of tuples (u, v, w), each representing a road from intersection u to intersection v with length w. start (int): The starting intersection. Returns: List[int]: A list where the i-th element is the shortest distance from the start intersection to intersection i. pass ``` # Input * `n` (1 ≤ n ≤ 1000): The number of intersections. * `roads`: A list of tuples where each tuple `(u, v, w)` represents a road from intersection `u` to intersection `v` with length `w` (0 ≤ u, v < n, 1 ≤ w ≤ 1000). * `start` (0 ≤ start < n): The starting intersection. # Output * Return a list `dist` where `dist[i]` is the shortest distance from the `start` intersection to intersection `i`. If there is no valid path to an intersection, the distance should be `float(\'inf\')`. # Constraints * The graph is directed and may have multiple roads between intersections. * No road has negative length. # Example ```python # Example 1 n = 5 roads = [(0, 1, 10), (0, 4, 5), (1, 2, 1), (4, 1, 3), (4, 2, 9), (4, 3, 2), (3, 2, 6), (2, 3, 4)] start = 0 assert shortest_paths(n, roads, start) == [0, 8, 9, 7, 5] # Example 2 n = 3 roads = [(0, 1, 4), (0, 2, 1), (2, 1, 2)] start = 0 assert shortest_paths(n, roads, start) == [0, 3, 1] ```","solution":"import heapq def shortest_paths(n, roads, start): Calculate the shortest paths from the start intersection to all other intersections. Parameters: n (int): The number of intersections in the city. roads (List[Tuple[int, int, int]]): A list of tuples (u, v, w), each representing a road from intersection u to intersection v with length w. start (int): The starting intersection. Returns: List[int]: A list where the i-th element is the shortest distance from the start intersection to intersection i. # Initialize distances with infinity dist = [float(\'inf\')] * n dist[start] = 0 # Priority queue for Dijkstra\'s algorithm pq = [(0, start)] # (distance, node) # Create an adjacency list adj = [[] for _ in range(n)] for u, v, w in roads: adj[u].append((v, w)) while pq: current_dist, u = heapq.heappop(pq) # If the distance is outdated, continue with the next element in the queue if current_dist > dist[u]: continue for v, w in adj[u]: if dist[u] + w < dist[v]: dist[v] = dist[u] + w heapq.heappush(pq, (dist[v], v)) return dist"},{"question":"# Question: Frequency Analysis of Words in Text In the field of text processing and analysis, it is often useful to understand the frequency distribution of words in a given text. For this task, you will implement a function that counts the occurrences of each word in a text and returns a dictionary representing this word histogram. Function Signature ```python def word_histogram(text: str) -> dict: Generate a histogram of word frequencies in the provided text. :param text: A string containing words separated by spaces. :return: A dictionary where keys are words and values are their respective frequencies. ``` Input Format * `text`: A string consisting of words separated by spaces. Words are to be considered case-insensitive. Output Format * Returns a dictionary where: * Keys are distinct words from the input text converted to lowercase. * Values are the number of times each word appears in the text. Constraints * The input text can include punctuation marks which should be ignored. * Words are considered case-insensitive (\\"Hello\\" and \\"hello\\" should be treated the same). * Assume words are separated by spaces only (no tabs or new lines). Example ```python text = \\"Hello world! Hello!\\" # The function should return {\'hello\': 2, \'world\': 1} text = \\"Data science is the future. data Science IS great!\\" # The function should return {\'data\': 2, \'science\': 2, \'is\': 2, \'the\': 1, \'future\': 1, \'great\': 1} ``` Performance Requirements The function should handle text lengths of up to 10^6 characters efficiently. Implementation Hints * Consider using string manipulation methods to preprocess and clean the text. * Use a dictionary to keep track of word frequencies. * Ensure case-insensitivity by converting the text to lowercase before processing.","solution":"import re from collections import defaultdict def word_histogram(text: str) -> dict: Generate a histogram of word frequencies in the provided text. :param text: A string containing words separated by spaces. :return: A dictionary where keys are words and values are their respective frequencies. # Convert the text to lowercase and use regex to split the text into words text = text.lower() words = re.findall(r\'bw+b\', text) # Create a dictionary to count the frequency of each word histogram = defaultdict(int) for word in words: histogram[word] += 1 return dict(histogram)"},{"question":"Question # Word Search II You are given a 2D grid of characters and a list of words. Your task is to implement a function `find_words` that searches for each word in the grid and returns a list of all words that can be found in the grid. **Function Signature**: ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: ``` # Input * `board`: A 2D list of characters (each character is a lowercase English letter). * `words`: A list of strings representing words to search for (each word is made of lowercase English letters). # Output * A list of strings containing all words from the input list that can be found in the grid. # Constraints * The grid (board) can contain up to `12 x 12 = 144` characters. * The list of words can contain up to 5000 words, each with a maximum length of 10 characters. * Words can be constructed by moving horizontally or vertically and cannot be reused within the same word’s path. * Each word in the output list must be in the input word list. # Example Example 1 ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] output = find_words(board, words) # Output should be [\\"oath\\", \\"eat\\"] ``` # Notes * You must avoid revisiting the same cell in one word path (i.e., while constructing a single word, you cannot use the same cell twice). * Your solution should efficiently handle the search within the constraints. # Explanation The function should start by building a Trie from the list of words to facilitate efficient word prefix checks. Then, it should use a recursive backtracking algorithm to search and construct words from the grid, and finally collect all valid words found in the board.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_word = False self.word = None class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_word = True node.word = word def find_words(board, words): def backtrack(x, y, parent): letter = board[x][y] curr_node = parent.children[letter] if curr_node.is_word: result.add(curr_node.word) # Add the word to the result set board[x][y] = \\"#\\" # Mark the cell as visited # Explore the neighbors in the grid (horizontal and vertical) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(board) and 0 <= ny < len(board[0]): if board[nx][ny] in curr_node.children: backtrack(nx, ny, curr_node) board[x][y] = letter # Unmark the cell # Optimization: remove the node if no longer needed if not curr_node.children: del parent.children[letter] result = set() trie = Trie() for word in words: trie.insert(word) for i in range(len(board)): for j in range(len(board[0])): if board[i][j] in trie.root.children: backtrack(i, j, trie.root) return list(result)"},{"question":"Scenario Alice and Bob are participating in a coding competition. One of the tasks involves calculating large powers of a number efficiently. They stumble upon the concept of binary exponentiation. Alice proposes using its iterative form for space efficiency, while Bob is intrigued by the recursive form due to clarity in implementation. The competition also introduces modular arithmetic to avoid overflow with large numbers. Task You are to implement two functions: `power_iter(a, n, mod)` and `power_recur(a, n, mod)`. * `power_iter(a, n, mod)` should use the iterative binary exponentiation method. * `power_recur(a, n, mod)` should use the recursive binary exponentiation method. Both functions should calculate `a^n` and return the result modulo `mod` if `mod` is provided. Requirements * **Input**: * `a` (base): An integer (1 <= a <= 10^9) * `n` (exponent): A non-negative integer (0 <= n <= 10^9) * `mod` (optional): A positive integer (`1 <= mod <= 10^9`) * **Output**: * Return the result of `a^n`. If `mod` is provided, return `(a^n) % mod`. Constraints * You must ensure optimal time and space complexities as specified in the algorithm analysis. * Handle edge cases: * When `n` is 0, should return 1 (since any number to the power of 0 is 1). * When `n` is 1, should return `a`. * Consider performance implications when `n` is large. Example Usage ```python # Examples print(power_iter(2, 10, 1000)) # Expected output: 24 print(power_recur(2, 10)) # Expected output: 1024 ``` Function Signature ```python def power_iter(a: int, n: int, mod: int = None) -> int: pass def power_recur(a: int, n: int, mod: int = None) -> int: pass ```","solution":"def power_iter(a, n, mod=None): Calculate a^n using iterative binary exponentiation. If mod is provided, compute (a^n) % mod. result = 1 base = a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result % mod if mod else result def power_recur(a, n, mod=None): Calculate a^n using recursive binary exponentiation. If mod is provided, compute (a^n) % mod. if n == 0: return 1 half = power_recur(a, n // 2, mod) half = (half * half) % mod if mod else half * half if n % 2 != 0: half = (half * a) % mod if mod else half * a return half"},{"question":"# Question: Optimize GCD and LCM Calculation with Additional Error Handling You are given a task to implement optimized and robust functions that compute the Greatest Common Divisor (GCD) and the Least Common Multiple (LCM) of two integers. You are also supposed to handle all potential error scenarios effectively, particularly for non-integer and zero inputs. Instruction: 1. **Function 1**: `optimized_gcd(a, b)` - Implement a function that computes the GCD of integers `a` and `b` utilizing bitwise operations for improved efficiency. It should also include thorough error handling: * Input: `a` and `b` as integers. * Output: GCD of integers `a` and `b`. * Constraints: `a` and `b` cannot both be zero; must handle negative integers. * Edge cases: Inputs should be validated to ensure they are integers and non-zero. 2. **Function 2**: `optimized_lcm(a, b)` - Implement a function that computes the LCM of the integers `a` and `b`. It should utilize the optimized GCD function and include thorough error handling: * Input: `a` and `b` as integers. * Output: LCM of integers `a` and `b`. * Constraints: `a` and `b` must be integers and non-zero (only one of them can be zero). * Edge cases: Inputs should be validated to ensure they are integers. Example: ```python optimized_gcd(8, 12) -> 4 optimized_lcm(8, 12) -> 24 optimized_gcd(-8, 12) -> 4 optimized_lcm(-8, 12) -> 24 optimized_gcd(8, 0) -> 8 # not raising error optimized_lcm(8, 0) -> ValueError(\\"One of the input arguments is zero\\") ``` Notes: - Make sure to handle negative inputs and throw appropriate exceptions for non-integer inputs or if both arguments are zero for GCD. - Document the implementation by briefing on the complexities involved and the benefits of the methods used. ```python def optimized_gcd(a, b): # Implement bitwise GCD with thorough error handling here def optimized_lcm(a, b): # Implement LCM computation using optimized GCD with strict error handling here ```","solution":"def optimized_gcd(a, b): Computes the GCD of two integers a and b using bitwise operations. Includes error handling for non-integer and invalid inputs. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Input values must be integers.\\") if a == 0 and b == 0: raise ValueError(\\"Both input values cannot be zero.\\") # Using the Iterative Euclidean Algorithm with bitwise operations a, b = abs(a), abs(b) if a == 0: return b if b == 0: return a shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b = b - a return a << shift def optimized_lcm(a, b): Computes the LCM of two integers a and b using the GCD function. Includes error handling for non-integer and invalid inputs. if not isinstance(a, int) or not isinstance(b, int): raise ValueError(\\"Input values must be integers.\\") if a == 0 or b == 0: raise ValueError(\\"Input values must be non-zero.\\") gcd = optimized_gcd(a, b) return abs(a * b) // gcd"},{"question":"# Question: Implement a Specific Variant of Heap Sort Scenario Imagine you are given a list of tasks with different priorities where higher numbers indicate higher priority. You need to reorder this list of tasks such that the highest priority task is always processed first. This is a perfect application of heap sort using a max heap. Problem Statement Write a function `custom_priority_heap_sort(tasks)` that sorts an array of integers `tasks` using a max-heap based heap sort algorithm. Function Signature ```python def custom_priority_heap_sort(tasks: List[int]) -> List[int]: pass ``` Input - `tasks`: A list of integers representing task priorities. (0 ≤ |tasks| ≤ 10^5, -10^9 ≤ task priority ≤ 10^9). Output - A list of integers sorted in descending order based on their priority. Constraints - The function must sort the tasks in place, i.e., using O(1) auxiliary space. - The function should have a time complexity of O(n log(n)). Example **Input**: `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]` **Output**: `[9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]` Additional Information - Ensure the function works efficiently even for edge cases, such as empty arrays or arrays with duplicate elements. - The algorithm must correctly handle negative and very large integer values. Hints - Use the provided pseudocode to guide your heapify and sorting logic. - Consider iterating from the last parent node to the root for efficient heap construction.","solution":"def custom_priority_heap_sort(tasks): def heapify(tasks, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 # Check if left child exists and is greater than root if left < n and tasks[largest] < tasks[left]: largest = left # Check if right child exists and is greater than largest so far if right < n and tasks[largest] < tasks[right]: largest = right # If largest is not root, swap with root and continue heapifying if largest != i: tasks[i], tasks[largest] = tasks[largest], tasks[i] heapify(tasks, n, largest) n = len(tasks) # Build a maxheap for i in range(n // 2 - 1, -1, -1): heapify(tasks, n, i) # Extract elements one by one for i in range(n - 1, 0, -1): # Swap the current root to end tasks[i], tasks[0] = tasks[0], tasks[i] # Call heapify on the reduced heap heapify(tasks, i, 0) # Reverse the list to sort in descending order tasks.reverse() return tasks"},{"question":"# Matrix Exponentiation Problem You are tasked with implementing a function to compute the matrix exponentiation of a given square matrix to a specified power. Function Signature ```python def matrix_power(matrix: list, power: int) -> list: ``` Input * `matrix` (list of list of int): A square matrix represented as a list of lists, where `matrix[i][j]` is the element in the i-th row and j-th column. * `power` (int): A non-negative integer representing the power to which the matrix should be raised. Output * Returns a list of lists representing the resulting matrix after exponentiation. Constraints * The dimension of the matrix will be between 1 and 50 (inclusive). * The elements of the matrix will be integers between -1000 and 1000 (inclusive). * `power` will be a non-negative integer between 0 and 1000 (inclusive). Performance Requirements * Your solution should efficiently handle large powers using matrix exponentiation by repeated squaring. # Example ```python matrix = [ [1, 2], [3, 4] ] power = 2 print(matrix_power(matrix, power)) # Output: [ # [7, 10], # [15, 22] # ] matrix = [ [1, 0], [0, 1] ] power = 5 print(matrix_power(matrix, power)) # Output: [ # [1, 0], # [0, 1] # ] ``` # Notes: - Ensure your function handles edge cases, such as raising a matrix to the power of zero. - Use helper functions provided in the code snippets above, or implement your own efficient matrix multiplication and identity matrix functions.","solution":"def identity_matrix(n): Generate an identity matrix of size n x n. return [[1 if i == j else 0 for j in range(n)] for i in range(n)] def matrix_multiply(A, B): Multiplies two square matrices A and B. n = len(A) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result def matrix_power(matrix, power): Computes the matrix raised to the specified power using matrix exponentiation by squaring. n = len(matrix) if power == 0: return identity_matrix(n) if power == 1: return matrix half_power = matrix_power(matrix, power // 2) half_power_squared = matrix_multiply(half_power, half_power) if power % 2 == 0: return half_power_squared else: return matrix_multiply(half_power_squared, matrix)"},{"question":"# Prime Number Generation with Custom Constraints As a seasoned programmer, your task is to implement a function that generates all prime numbers less than `n` using an optimized version of the Sieve of Eratosthenes, which skips even numbers. The implementation should handle typical edge cases and be efficient in both time and space complexity. Additionally, it should output the prime numbers in a specific format. Function Definition ```python def custom_primes(n: int) -> list: Generate all prime numbers less than \'n\' using an optimized Sieve of Eratosthenes. Args: n (int): The upper limit to find prime numbers less than this value. Returns: list: A list of all prime numbers less than \'n\'. # Your implementation here ``` Input - A single integer `n` (2 <= `n` <= 10^6). Output - A list of integer primes less than `n`. Constraints - Handle invalid inputs appropriately (e.g., negative numbers, non-integer types). - Optimize for time and space complexity. - Output primes in ascending order. Example Usage ```python print(custom_primes(10)) # Output: [2, 3, 5, 7] print(custom_primes(20)) # Output: [2, 3, 5, 7, 11, 13, 17, 19] ``` Evaluation Your implementation will be assessed based on: 1. Correctness: Ensure that the function returns all and only correct prime numbers. 2. Efficiency: Memory and time efficiency will be evaluated, especially for large inputs. 3. Robustness: Properly handle edge cases and invalid input validations. Implement your solution in the provided function definition.","solution":"def custom_primes(n: int) -> list: Generate all prime numbers less than \'n\' using an optimized Sieve of Eratosthenes. Args: n (int): The upper limit to find prime numbers less than this value. Returns: list: A list of all prime numbers less than \'n\'. if not isinstance(n, int) or n < 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False return [num for num in range(n) if sieve[num]]"},{"question":"# Interpolation Search Enhancement and Application Scenario: You are given a sorted array which might not have uniformly distributed values. Enhance the given interpolation search algorithm to handle cases where the array is not uniformly distributed effectively and handle any potential errors gracefully. Task: Write a function `enhanced_interpolation_search` that addresses the following: 1. Modify the interpolation search algorithm to avoid division by zero errors. 2. Ensure the algorithm returns `-1` if the search key is not found. 3. The array input is guaranteed to be sorted in non-decreasing order. Function Signature: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: ``` Input: - `array` (List[int]): A sorted list of integers in non-decreasing order. - `search_key` (int): An integer value to search in the array. Output: - An integer representing the index of `search_key` in the array. Return `-1` if the `search_key` is not found. Constraints: - Use (O(1)) additional space. - Optimize the solution to perform efficiently even when the array is not uniformly distributed. - Return -1 if there\'s an attempt to divide by zero. Examples: ```python # Example 1: array = [-25, -12, -1, 10, 12, 15, 20, 41, 55] search_key = -1 assert enhanced_interpolation_search(array, search_key) == 2 # Example 2: array = [5, 10, 12, 14, 17, 20, 21] search_key = -5 assert enhanced_interpolation_search(array, search_key) == -1 # Example 3: array = [10, 10, 10, 10, 10, 10, 10] search_key = 10 assert enhanced_interpolation_search(array, search_key) == 0 # Example 4: array = [1, 2, 3, 4, 5] search_key = 10 assert enhanced_interpolation_search(array, search_key) == -1 ```","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if array[low] == array[high]: # Check for corner case of division by zero return low if array[low] == search_key else -1 pos = low + ((high - low) * (search_key - array[low]) // (array[high] - array[low])) if pos < 0 or pos >= len(array): # Check for out of bounds return -1 if array[pos] == search_key: return pos elif array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"You are given a large sorted list of integers and multiple search keys. Your task is to implement the `ternary_search` function which will search for each key and return the index if the key is found, or -1 otherwise. The function must work efficiently even for large datasets. # Requirements Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: # Implement your code here ``` Parameters 1. **left (int)**: The starting index of the segment of the array to search within. 2. **right (int)**: The ending index of the segment of the array to search within. 3. **key (int)**: The element to search for. 4. **arr (List[int])**: A sorted list of integers. Return Value * **int**: The index of the `key` in `arr` if found. If `key` is not found, return `-1`. # Constraints 1. The array `arr` will have at most 10^6 elements. 2. All elements in `arr` will be between -10^9 and 10^9. 3. The number of search queries will be at most 10^5. # Performance Requirements * The implementation should handle large inputs within acceptable time limits due to the logarithmic time complexity characteristic of the ternary search. # Example ```python # Example usage: arr = [2, 3, 5, 9, 15, 18, 25, 30, 35, 40] print(ternary_search(0, len(arr) - 1, 9, arr)) # Output: 3 print(ternary_search(0, len(arr) - 1, 1, arr)) # Output: -1 ```","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on the sorted array arr to find the index of key. Parameters: left (int): The starting index of the segment to search within. right (int): The ending index of the segment to search within. key (int): The element to search for. arr (List[int]): The sorted list of integers. Returns: int: The index of key in arr if found; otherwise, -1. while left <= right: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Problem Statement Your task is to extend the given Binary Heap class by implementing a new method `heapify`. Given an arbitrary array, the `heapify` method should transform it into a valid min-heap. # Detailed Requirements 1. **Implement the `heapify` method**: - Input: An array of integers. - Output: The modified array should represent a valid min-heap. 2. **Use the existing methods**: - Utilize the methods `perc_down` and `min_child` to maintain the heap property while transforming the array. 3. **Constraints**: - The input array can be empty. - The input array can contain negative, zero, or positive integers. 4. **Performance**: - The `heapify` operation should run in O(n) time complexity. # Function Signature ```python class BinaryHeap: # existing methods def heapify(self, array: List[int]) -> List[int]: pass ``` # Example ```python # Initial array array = [4, 50, 7, 55, 90, 87] # Your heapify method should transform it like this heap = BinaryHeap() min_heap = heap.heapify(array) print(min_heap) # Output should represent the min-heap form, e.g., [4, 50, 7, 55, 90, 87] ``` # Instructions 1. Write the `heapify` method within the `BinaryHeap` class. 2. Ensure that the heap property is maintained after the transformation. 3. Use the provided methods in the class for efficiency. # Notes - Pay attention to edge cases, such as empty arrays and arrays with duplicate values. - Make use of the provided documentation and methods to assist in your implementation.","solution":"class BinaryHeap: def __init__(self): self.heap_list = [0] self.current_size = 0 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap_list[i] > self.heap_list[mc]: self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i] i = mc def min_child(self, i): if (i * 2 + 1) > self.current_size: return i * 2 else: if self.heap_list[i * 2] < self.heap_list[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def insert(self, k): self.heap_list.append(k) self.current_size += 1 self.perc_up(self.current_size) def perc_up(self, i): while i // 2 > 0: if self.heap_list[i] < self.heap_list[i // 2]: self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i] i = i // 2 def heapify(self, array): i = len(array) // 2 self.current_size = len(array) self.heap_list = [0] + array[:] while i > 0: self.perc_down(i) i -= 1 return self.heap_list[1:]"},{"question":"# Question As a data analyst, you\'ve encountered the need to sort datasets numerically in ascending order. While there are multiple sorting algorithms available, one of the fundamental learnings involves understanding and implementing a basic sorting algorithm from scratch. Task Write a function named `optimized_bubble_sort` in Python that implements an optimized bubble sort algorithm. This version should stop the sorting process early if it detects that the array has become sorted before completing all passes. This optimization should reduce unnecessary comparisons. Function Signature ```python def optimized_bubble_sort(arr: List[int]) -> List[int]: ``` Input * `arr` (List[int]): A list of integers that need to be sorted. Output * Returns a list of integers sorted in ascending order. Constraints * The length of the list (n) will be within the range [0, 10^3]. * The integers in the list will range from -10^3 to 10^3. Performance Requirement * Time complexity should still be considered as O(n^2) in the worst case. * Space complexity should be O(1). Example ```python assert optimized_bubble_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]) == [1, 1, 2, 3, 4, 5, 5, 6, 9] assert optimized_bubble_sort([10, 7, 3, 7, 2, 1, 0]) == [0, 1, 2, 3, 7, 7, 10] assert optimized_bubble_sort([]) == [] assert optimized_bubble_sort([5]) == [5] assert optimized_bubble_sort([2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2] ``` Note Ensure to use swap mechanism within the array and the optimized check for early loop termination to demonstrate the enhancement over the basic bubble sort.","solution":"from typing import List def optimized_bubble_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using an optimized bubble sort algorithm. Parameters: arr (List[int]): List of integers to sort. Returns: List[int]: Sorted list of integers in ascending order. n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: # No swaps mean the array is already sorted break return arr"},{"question":"# Implementation Task You are required to implement the `ResizableHashTable` class method `key_with_max_value` which returns the key with the highest value stored in the hash table. While implementing the method, consider the following: - If the table is empty, return `None`. - Maintain optimal performance even with multiple resize operations and collisions. - You can use all existing methods defined in the `HashTable` and `ResizableHashTable` classes. Function Signature ```python class ResizableHashTable(HashTable): ... def key_with_max_value(self): ... ``` Constraints - The key is an integer and the value is a numerical value (integer or float). - Keys are unique. Example ```python htable = ResizableHashTable() htable.put(1, 3) htable.put(2, 5) htable.put(3, 1) assert htable.key_with_max_value() == 2 htable.del_(2) assert htable.key_with_max_value() == 1 ``` **Note**: This task assesses the capability to leverage hash table functionalities to aggregate and compare values efficiently and to handle edge cases such as an empty table or concurrent insertions and deletions.","solution":"class HashTable: def __init__(self): self.table = {} def put(self, key, value): self.table[key] = value def get(self, key): return self.table.get(key, None) def del_(self, key): if key in self.table: del self.table[key] def size(self): return len(self.table) def keys(self): return list(self.table.keys()) class ResizableHashTable(HashTable): def __init__(self): super().__init__() def key_with_max_value(self): if len(self.table) == 0: return None max_key = max(self.table, key=lambda k: self.table[k]) return max_key # Example Usage htable = ResizableHashTable() htable.put(1, 3) htable.put(2, 5) htable.put(3, 1) print(htable.key_with_max_value()) # Should print 2 htable.del_(2) print(htable.key_with_max_value()) # Should print 1"},{"question":"# Question: Enhanced Counting Sort for Mixed Numbers Context You have been given an array of integers that may contain both negative and positive numbers. Your task is to implement an enhanced version of the Counting Sort algorithm that can handle this mixed range of integers efficiently. Objective Write a function `enhanced_counting_sort(arr)` that sorts an array of mixed integers using an enhanced counting sort algorithm. Function Signature ```python def enhanced_counting_sort(arr: List[int]) -> List[int]: ``` Input * `arr`: A list of integers, where -10^6 ≤ arr[i] ≤ 10^6. Output * Returns a new list of integers sorted in ascending order. Constraints * The array can have up to 10^6 elements. * The input array may contain duplicate elements. * The algorithm should run in linear time, O(n), where n is the number of elements. Example ```python >>> enhanced_counting_sort([4, 2, -3, 6, -1, 3]) [-3, -1, 2, 3, 4, 6] >>> enhanced_counting_sort([-5, 3, 0, 2, 1, -2, -1, 0]) [-5, -2, -1, 0, 0, 1, 2, 3] >>> enhanced_counting_sort([]) [] ``` Performance Requirements Ensure your implementation utilizes linear time O(n) and handles the wide range of values efficiently. Notes 1. Ensure that the implementation effectively handles negative numbers. 2. The function should maintain the stability of sorting. 3. Avoid using Python\'s built-in sorting functions to ensure the counting sort algorithm is demonstrated.","solution":"def enhanced_counting_sort(arr): Sorts an array of mixed integers (both negative and positive) using an enhanced counting sort algorithm. :param arr: List of integers :return: List of sorted integers if not arr: return [] # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Create a count array to store the count of each unique value range_of_elements = max_val - min_val + 1 count_arr = [0] * range_of_elements # Store the count of each element for num in arr: count_arr[num - min_val] += 1 # Store the cumulative count for i in range(1, len(count_arr)): count_arr[i] += count_arr[i - 1] # Build the output array output_arr = [0] * len(arr) for num in reversed(arr): output_arr[count_arr[num - min_val] - 1] = num count_arr[num - min_val] -= 1 return output_arr"},{"question":"# Context A local library uses a digital catalog system to track books. The system must manage book records by their unique ISBN numbers, enabling efficient addition, lookup, and deletion of catalogue entries. To meet these requirements, implement a specialized data structure that can maintain the library catalog with efficient operations. # Problem Statement Implement a `ResizableHashTable` in Python to manage a library catalog. The data structure should support `put`, `get`, and `del_` operations efficiently, and automatically resize when the load factor exceeds a given threshold. **Function Definitions**: 1. `put(self, key: int, value: any) -> None`: Insert or update the value at the given key. 2. `get(self, key: int) -> any`: Retrieve the value at the given key or return None if the key does not exist. 3. `del_(self, key: int) -> None`: Remove the key-value pair by the given key. 4. `__resize(self) -> None`: Handles the resizing logic internally. # Input and Output Formats * `put`: * **Input**: An integer key (ISBN number) and its associated value (book details). * **Output**: None * `get`: * **Input**: An integer key. * **Output**: The value associated with the given key or None if the key doesn’t exist. * `del_`: * **Input**: An integer key. * **Output**: None # Constraints * All keys are unique integers. * Initial size of the hash table is a small constant (e.g., 8). * The table should double its size when 2/3rd of its capacity is filled. # Performance Requirements * Average-case time complexity for `put`, `get`, and `del_` operations should be O(1). * Space complexity should be optimized to handle large inputs efficiently. **Library Management Scenario**: You are maintaining a library catalog where each book is identified by a unique ISBN number (integer). The library frequently updates its catalog with new books, retrieves book information, and occasionally removes books from the system. Implement the `ResizableHashTable` and provide its critical methods for managing the library catalog efficiently.","solution":"class ResizableHashTable: def __init__(self): self.initial_capacity = 8 self.load_factor = 2 / 3 self.size = 0 self.table = [None] * self.initial_capacity def put(self, key, value): if self.size / len(self.table) > self.load_factor: self.__resize() index = self.__hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % len(self.table) self.table[index] = (key, value) self.size += 1 def get(self, key): index = self.__hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % len(self.table) return None def del_(self, key): index = self.__hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.size -= 1 self.__rehash(index) return index = (index + 1) % len(self.table) def __resize(self): old_table = self.table new_capacity = len(old_table) * 2 self.table = [None] * new_capacity self.size = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def __rehash(self, index): next_index = (index + 1) % len(self.table) while self.table[next_index] is not None: key, value = self.table[next_index] self.table[next_index] = None self.size -= 1 self.put(key, value) next_index = (next_index + 1) % len(self.table) def __hash(self, key): return key % len(self.table)"},{"question":"**Scenario**: You are tasked with managing connections between servers in a data center. Initially, each server stands alone, unconnected to others. As servers are connected (either directly or indirectly), they form clusters, and each cluster behaves as a single unit. **Objective**: Implement a class `DataCenter` using the Union-Find data structure to manage and query server clusters efficiently. Your implementation should support adding servers, connecting servers, and querying whether two servers are in the same cluster. # Function Specifications 1. **`add_server(server_id: int) -> None`**: Adds a server with `server_id` to the data center. Each server_id is unique and assumes it hasn\'t been added before. 2. **`connect_servers(server1: int, server2: int) -> None`**: Connects the servers identified by `server1` and `server2`. If either of the servers is not present in the data center, it should be added first. 3. **`are_connected(server1: int, server2: int) -> bool`**: Returns `True` if the servers identified by `server1` and `server2` are in the same cluster, `False` otherwise. # Constraints - Server IDs are positive integers. - You may assume no duplicate connections are added. - Performance is crucial; aim for optimal time complexity. # Example Usage ```python dc = DataCenter() dc.add_server(1) dc.add_server(2) print(dc.are_connected(1, 2)) # Output: False dc.connect_servers(1, 2) print(dc.are_connected(1, 2)) # Output: True dc.add_server(3) dc.connect_servers(2, 3) print(dc.are_connected(1, 3)) # Output: True ``` # Implementation Goals - Use path compression and union by rank for efficient operations. - Ensure that all functions modify and query the data structure in nearly constant time.","solution":"class DataCenter: def __init__(self): self.parent = {} self.rank = {} def add_server(self, server_id: int) -> None: if server_id not in self.parent: self.parent[server_id] = server_id self.rank[server_id] = 0 def find(self, server: int) -> int: if self.parent[server] != server: self.parent[server] = self.find(self.parent[server]) return self.parent[server] def union(self, server1: int, server2: int) -> None: root1 = self.find(server1) root2 = self.find(server2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def connect_servers(self, server1: int, server2: int) -> None: if server1 not in self.parent: self.add_server(server1) if server2 not in self.parent: self.add_server(server2) self.union(server1, server2) def are_connected(self, server1: int, server2: int) -> bool: if server1 not in self.parent or server2 not in self.parent: return False return self.find(server1) == self.find(server2)"},{"question":"Background Suppose you are developing a text editor that features advanced edit capabilities. One of the most fundamental operations you need to implement is reversing strings efficiently. You have seen different methods for reversing a string, and now you need to utilize this to implement a feature in your editor. Problem Description Implement a function `reverse_text(text: str) -> str` that reverses the input string `text`. Your implementation should handle edge cases efficiently and prefer using the most performance-optimized approach. **Input**: - A string `text` consisting of printable ASCII characters (0 ≤ len(text) ≤ 10^5). **Output**: - A string that is the reversed version of the input `text`. **Constraints**: - You should aim for an optimal solution in terms of time and space complexity. - Avoid recursion because of potential stack overflow issues for long strings. Example Input: `text = \\"hello\\"` Output: `\\"olleh\\"` Input: `text = \\"A man, a plan, a canal, Panama!\\"` Output: `\\"!amanaP ,lanac a ,nalp a ,nam A\\"` Performance Requirements Your solution should work efficiently even for the largest input size (10^5 characters).","solution":"def reverse_text(text: str) -> str: Returns the reversed version of the input string `text`. return text[::-1]"},{"question":"# **Cholesky Decomposition Implementation** Objective Write a function named `cholesky_decomposition` that performs the Cholesky decomposition of a Hermitian positive-definite matrix. Function Signature ```python def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: ``` Input * `A`: A list of lists of floats representing an `n x n` Hermitian positive-definite matrix. Output * A list of lists of floats representing the lower triangular matrix (V) such that (A = V cdot V^T). * If the matrix (A) is not Hermitian positive-definite, return `None`. Constraints * ( n ) is the size of matrix (A) and (1 leq n leq 1000 ). * Numbers in the matrix (A) are guaranteed to be in the range of [-10^9, 10^9]. Performance Requirements * The algorithm should complete in a reasonable time for matrices up to size 1000x1000. * Memory usage should be optimized to respect the O(n^2) space complexity. Scenario You have a matrix representing the covariance of a set of variables and need to perform a Cholesky decomposition for further statistical analysis. You need to ensure that your implementation handles edge cases, such as non-Hermitian matrices, and optimally computes the result for large matrices. Example ```python A = [ [4.0, 12.0, -16.0], [12.0, 37.0, -43.0], [-16.0, -43.0, 98.0] ] expected_output = [ [2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [-8.0, 5.0, 3.0] ] result = cholesky_decomposition(A) assert result == expected_output ``` Description Your function will first ensure the input is a square matrix. By iterating through the matrix, you will fill the resultant lower triangular matrix based on the Cholesky decomposition process. Handle special cases where the conditions for Cholesky decomposition are not met by returning `None`.","solution":"from typing import List, Optional import math def cholesky_decomposition(A: List[List[float]]) -> Optional[List[List[float]]]: Performs the Cholesky decomposition of a Hermitian positive-definite matrix. n = len(A) # Initialize the result matrix with zeros V = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(i + 1): sum_k = sum(V[i][k] * V[j][k] for k in range(j)) if i == j: # Diagonal elements val = A[i][i] - sum_k if val <= 0: return None # Matrix is not positive-definite V[i][i] = math.sqrt(val) else: if V[j][j] == 0: return None # Singular matrix V[i][j] = (A[i][j] - sum_k) / V[j][j] return V"},{"question":"# Exponentiation Challenge **Context**: You are developing a feature for a scientific calculator application that needs to perform fast exponentiation. This feature must handle large numbers and supports both normal and modular exponentiation. The modulus operation helps prevent large intermediate results that may overflow storage capacities. **Task**: Implement two functions: `iterative_power` and `recursive_power` which calculate `a` raised to the power `n`. Additionally, support an optional parameter `mod` to return the result modulo `mod`. **Function Signatures**: ```python def iterative_power(a: int, n: int, mod: int = None) -> int: pass def recursive_power(a: int, n: int, mod: int = None) -> int: pass ``` **Parameters**: - `a`: A base integer. - `n`: A non-negative integer representing the exponent. - `mod`: An optional integer for modular exponentiation. **Constraints**: - `0 <= a <= 10^9` - `0 <= n <= 10^9` - `1 <= mod <= 10^9` (if specified) **Output**: - Returns the result of `a^n` for both functions. - If `mod` is specified, returns the result `a^n % mod`. **Requirements**: - Optimize for time complexity O(log(n)). - Ensure the functions handle large values efficiently. **Edge Cases to Consider**: - `a` and `n` both being zero (0^0 is typically defined as 1 in computing). - `mod` being zero or negative (which may need special handling or assume non-zero positive only). **Example**: ```python print(iterative_power(2, 10)) # Output: 1024 print(recursive_power(2, 10)) # Output: 1024 print(iterative_power(2, 10, 1000)) # Output: 24 print(recursive_power(2, 10, 1000)) # Output: 24 ```","solution":"def iterative_power(a: int, n: int, mod: int = None) -> int: result = 1 base = a if mod is None else a % mod while n > 0: if n % 2 == 1: # If n is odd result = (result * base) if mod is None else (result * base) % mod base = (base * base) if mod is None else (base * base) % mod n //= 2 return result def recursive_power(a: int, n: int, mod: int = None) -> int: if n == 0: return 1 half_power = recursive_power(a, n // 2, mod) half_power = (half_power * half_power) if mod is None else (half_power * half_power) % mod if n % 2 == 0: return half_power else: return (half_power * a) if mod is None else (half_power * a) % mod"},{"question":"Cycle Detection in a Directed Graph # Context You have been hired by a company to help develop a system for detecting potential deadlocks in their resource management framework. Processes and resources in this system can be represented as directed graphs, where nodes represent processes or resources, and edges represent dependency relationships. # Task Write a function `has_cycle(graph)` to determine whether the given directed graph contains a cycle. # Input - `graph`: A dictionary where the keys are vertices and the values are lists of vertices representing directed edges. For example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } ``` # Output - Return `True` if there is a cycle in the graph, `False` otherwise. # Constraints - The graph is a directed graph. - There are no multiple edges between two vertices. - Vertices are denoted as strings. - The graph is not necessarily connected. # Example ```python def has_cycle(graph): from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def is_in_cycle(graph, traversal_states, vertex): if traversal_states[vertex] == TraversalState.GRAY: return True traversal_states[vertex] = TraversalState.GRAY for neighbor in graph[vertex]: if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False traversal_states = {vertex: TraversalState.WHITE for vertex in graph} for vertex in graph: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(graph, traversal_states, vertex): return True return False # Example usage: graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(has_cycle(graph)) # Outputs: True ``` # Explanation of Example In this example, there is a cycle in the subgraph formed by vertices B, D, and E. The traversal starts from vertex A and eventually detects the cycle when visiting vertex E, which leads back to vertex B.","solution":"def has_cycle(graph): from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def is_in_cycle(graph, traversal_states, vertex): if traversal_states[vertex] == TraversalState.GRAY: return True traversal_states[vertex] = TraversalState.GRAY for neighbor in graph[vertex]: if traversal_states[neighbor] != TraversalState.BLACK: # Only recurse if the neighbor is not fully processed if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False traversal_states = {vertex: TraversalState.WHITE for vertex in graph} for vertex in graph: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(graph, traversal_states, vertex): return True return False # Example usage: graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(has_cycle(graph)) # Outputs: True"},{"question":"# String Reversal Challenge You are given a task to reverse a string using different approaches to demonstrate your understanding of various algorithm strategies. Write the following Python functions: 1. `recursive(s: str) -> str`: * Reverses the string `s` using a recursive method. 2. `iterative(s: str) -> str`: * Reverses the string `s` using an iterative approach. 3. `pythonic(s: str) -> str`: * Reverses the string `s` using built-in Python functions. 4. `ultra_pythonic(s: str) -> str`: * Reverses the string `s` using Python slicing. # Input & Output - **Input**: A string `s` (0 ≤ len(s) ≤ 10^5). - **Output**: A string which is the reversed form of `s`. # Examples ```python print(recursive(\\"hello\\")) # Output: \\"olleh\\" print(iterative(\\"world\\")) # Output: \\"dlrow\\" print(pythonic(\\"goodbye\\")) # Output: \\"eybdoog\\" print(ultra_pythonic(\\"abcdefgh\\")) # Output: \\"hgfedcba\\" ``` # Constraints - Recursively reverse the string for `recursive` method. - Use an iterative two-pointer approach for `iterative` method. - Use Python built-in functions for `pythonic` method. - Use Python slicing for `ultra_pythonic` method. # Performance Requirements - Aim for optimal performance considering the specified input length. - Handle edge cases such as empty strings and very large inputs efficiently.","solution":"def recursive(s: str) -> str: Reverses the string `s` using a recursive method. if len(s) <= 1: return s return s[-1] + recursive(s[:-1]) def iterative(s: str) -> str: Reverses the string `s` using an iterative approach. reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str) def pythonic(s: str) -> str: Reverses the string `s` using Python built-in functions. return \'\'.join(reversed(s)) def ultra_pythonic(s: str) -> str: Reverses the string `s` using Python slicing. return s[::-1]"},{"question":"# Scenario In a social network, users form connections like a linked list where each user\'s profile points to the next user they followed. However, sometimes due to mutual follows or spam accounts, a cycle can form where users start re-following in a loop. Detecting these cycles is crucial to prevent infinite loops in follow suggestions. # Problem Statement You are given a linked list representing user follows. Implement a function `detect_cycle` that determines if there is a cycle in the linked list. You must optimize the solution to use no extra space, beyond the pointers required. Function Signature ```python def detect_cycle(head: \'Node\') -> bool: :param head: The starting node of the linked list. :return: True if there is a cycle, False otherwise. ``` # Input - `head`: A `Node` object representing the head of the linked list or `None` if the list is empty. # Output - Return `True` if there is a cycle in the linked list, `False` otherwise. # Constraints - You cannot use extra space (i.e., no data structures like sets, dictionaries, or lists to store nodes). - The list length is up to 10^5 nodes. - Node values are integers but are not guaranteed to be unique. # Examples ```python # Example 1: # Input: head = [3,2,0,-4] with cycle from node with value -4 pointing back to node with value 2 # Output: True # Example 2: # Input: head = [1,2] with cycle from node with value 2 pointing back to node with value 1 # Output: True # Example 3: # Input: head = [1] with no cycle # Output: False ``` Notes - Consider edge cases: empty list, list with a single node, and very long lists without cycles.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def detect_cycle(head: \'Node\') -> bool: This function detects if there is a cycle in the linked list. :param head: The starting node of the linked list. :return: True if there is a cycle, False otherwise. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Queue-based Task Scheduling System You are tasked with implementing a simplified task scheduling system using a queue data structure. This system will receive tasks and execute them in the order they arrive (FIFO). Requirements 1. Implement a `TaskQueue` class using a dynamic array (similar to `ArrayQueue`). The queue must support the following methods: - `add_task(task: str) -> None`: Adds a new task to the queue. - `remove_task() -> str`: Removes the task at the front of the queue and returns the task description. - `get_next_task() -> str`: Returns the description of the task at the front without removing it. - `is_empty() -> bool`: Returns `True` if the queue has no tasks, `False` otherwise. - `task_count() -> int`: Returns the number of tasks currently in the queue. 2. The `TaskQueue` must properly handle resizing when the underlying capacity is exceeded. Start with an initial capacity of 5. 3. Raise an appropriate exception for `remove_task` and `get_next_task` if the queue is empty. Constraints * Max number of tasks in the queue at any time will not exceed `5000`. * Tasks are represented as strings containing up to `255` characters. Example ```python # Example usage queue = TaskQueue() queue.add_task(\\"Task1\\") queue.add_task(\\"Task2\\") print(queue.get_next_task()) # Output: \'Task1\' print(queue.remove_task()) # Output: \'Task1\' print(queue.task_count()) # Output: 1 print(queue.is_empty()) # Output: False ```","solution":"class TaskQueue: def __init__(self, initial_capacity=5): self._capacity = initial_capacity self._queue = [None] * self._capacity self._front = 0 self._rear = -1 self._size = 0 def add_task(self, task): if self._size == self._capacity: self._resize() self._rear = (self._rear + 1) % self._capacity self._queue[self._rear] = task self._size += 1 def remove_task(self): if self.is_empty(): raise IndexError(\\"remove_task from empty queue\\") task = self._queue[self._front] self._queue[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return task def get_next_task(self): if self.is_empty(): raise IndexError(\\"get_next_task from empty queue\\") return self._queue[self._front] def is_empty(self): return self._size == 0 def task_count(self): return self._size def _resize(self): old_queue = self._queue[:] self._capacity *= 2 self._queue = [None] * self._capacity for i in range(self._size): self._queue[i] = old_queue[(self._front + i) % len(old_queue)] self._front = 0 self._rear = self._size - 1"},{"question":"# ZigZag Iterator for Multiple Lists You are tasked with creating a `ZigZagIterator` class that can take an arbitrary number of lists and yield their elements in a zigzag (round-robin) manner. The iterator should iterate over the first element of each list, then the second element of each list, and so on. If a list runs out of elements before the others, it should be skipped in the subsequent rounds. Function Signatures: * `__init__(self, vectors: List[List[int]]) -> None`: Initializes the iterator with a list of integer lists. * `next(self) -> int`: Returns the next element in the zigzag order. * `has_next(self) -> bool`: Returns `True` if there are still elements to iterate over, `False` otherwise. Example: ```python vectors = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] it = ZigZagIterator(vectors) result = [] while it.has_next(): result.append(it.next()) # result would be [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Constraints: * Each list contains at most `1000` elements. * There are at most `1000` lists. Performance Requirements: Ensure that both `next` and `has_next` methods operate in O(1) time. Implement the `ZigZagIterator` class below: ```python class ZigZagIterator: def __init__(self, vectors: List[List[int]]) -> None: # Your code here def next(self) -> int: # Your code here def has_next(self) -> bool: # Your code here ```","solution":"from collections import deque class ZigZagIterator: def __init__(self, vectors): Initialize the ZigZagIterator with a list of lists. self.queue = deque() for vector in vectors: if vector: self.queue.appendleft(iter(vector)) def next(self): Return the next element in zigzag order. if self.has_next(): current_vector = self.queue.pop() next_element = next(current_vector) self.queue.appendleft(current_vector) return next_element raise StopIteration(\\"No more elements.\\") def has_next(self): Return True if there are still elements to iterate over, otherwise return False. # Clean up any exhausted iterators from the front while self.queue and not self.has_next_helper(self.queue[-1]): self.queue.pop() return bool(self.queue) def has_next_helper(self, iterator): Helper method to check if an iterator has a next element without advancing it. try: peek_element = next(iterator) self.queue[-1] = iter([peek_element] + list(iterator)) # Rebuild the iterator return True except StopIteration: return False"},{"question":"# Doubly Linked List Implementation and Operations Context: You are part of a project where you need to implement an efficient data structure to manage user commands in an application. To effectively manage undo and redo operations, you have chosen to use a doubly linked list. Task: Implement a doubly linked list with the following operations: 1. **Add to Head**: Add an element to the beginning of the list. 2. **Add to Tail**: Add an element to the end of the list. 3. **Remove Node**: Remove a given node (provided by its reference). 4. **Find Node**: Find a node by its value. Implement the `DoublyLinkedList` class with methods to support these operations. Specifications: * `class DoublyLinkedListNode` is provided for node creation. * You need to define the `DoublyLinkedList` class with the following methods: * `add_to_head(self, value)`: Adds a new node with the given value at the beginning of the list. * `add_to_tail(self, value)`: Adds a new node with the given value at the end of the list. * `remove_node(self, node)`: Removes the specified node from the list. * `find_node(self, value)`: Returns the node with the given value if it exists, otherwise returns `None`. Constraints: * The value for nodes will be integers. * Ensure efficient execution with minimal space overhead. * Handle all edge cases like empty lists and operations on singleton lists. Example: ```python # Example usage: dll = DoublyLinkedList() dll.add_to_head(10) dll.add_to_tail(20) node = dll.find_node(10) dll.remove_node(node) ``` Implement the `DoublyLinkedList` class and ensure the defined methods work as expected.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_to_head(self, value): new_node = DoublyLinkedListNode(value) if self.head is None: # If the list is empty, new node is both head and tail self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def add_to_tail(self, value): new_node = DoublyLinkedListNode(value) if self.tail is None: # If the list is empty, new node is both head and tail self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def remove_node(self, node): if node.prev is not None: node.prev.next = node.next else: # Node is the head self.head = node.next if node.next is not None: node.next.prev = node.prev else: # Node is the tail self.tail = node.prev # Clear the pointers in the removed node node.next = None node.prev = None def find_node(self, value): current = self.head while current is not None: if current.value == value: return current current = current.next return None"},{"question":"# Scenario: You have been hired to implement a predictive model for a text suggestion feature in a chat application. The predictive model uses a Markov chain to suggest the next character in a user\'s message based on the current character. # Task: Write a function implementing a Markov Chain that generates a sequence of characters given an initial character and a predefined transition dictionary. # Function Signature: ```python def generate_text(chain, initial_state, length): Generates a sequence of characters of a given length based on a Markov chain. Args: chain (dict): A dictionary representing the Markov chain where keys are characters and values are dictionaries of transition probabilities. initial_state (str): The starting character for the sequence generation. length (int): Length of the sequence to be generated. Returns: str: A string representing the sequence of characters generated by the Markov chain. ``` # Input Format: * `chain` - A dictionary representing the Markov chain\'s transition probabilities. * `initial_state` - A single character string representing the start character. * `length` - An integer representing the desired length of the output sequence. # Output Format: * Return a string that represents the generated sequence of characters. # Example: ```python chain = { \'A\': {\'A\': 0.5, \'B\': 0.5}, \'B\': {\'A\': 0.3, \'B\': 0.7} } initial_state = \'A\' length = 10 print(generate_text(chain, initial_state, length)) ``` **Expected Output:** ```python \'ABAABABABB\' # Note: The output will vary due to the stochastic nature of the Markov chain. ``` # Constraints: * The length of the generated text should be a positive integer `1 <= length <= 1000`. * The `chain` dictionary\'s probabilities for each key must sum to 1. * The initial state must be a key in the transition dictionary. # Performance Requirements: * Ensure that your solution runs efficiently within the given constraints.","solution":"import random def generate_text(chain, initial_state, length): Generates a sequence of characters of a given length based on a Markov chain. Args: chain (dict): A dictionary representing the Markov chain where keys are characters and values are dictionaries of transition probabilities. initial_state (str): The starting character for the sequence generation. length (int): Length of the sequence to be generated. Returns: str: A string representing the sequence of characters generated by the Markov chain. if initial_state not in chain or length <= 0: raise ValueError(\\"Invalid initial_state or length\\") current_state = initial_state result = [current_state] for _ in range(length - 1): next_state_probabilities = chain[current_state] next_states, probabilities = zip(*next_state_probabilities.items()) current_state = random.choices(next_states, probabilities)[0] result.append(current_state) return \'\'.join(result)"},{"question":"You are provided with a simplified version of a HashTable data structure using linear probing for collision resolution and a resizing mechanism. The current implementation resizes the table when the number of elements reaches 2/3 of the table size. Your task is to enhance this implementation by adding a `shrink` method that halves the hash table when the number of elements falls below 1/4 of the table size. This helps to optimize memory usage. # Task 1. Implement a `shrink` method within the `ResizableHashTable` that halves the table size when the load factor falls below 1/4. 2. Ensure that the `put` and `del_` methods call the `shrink` method appropriately after removing elements. 3. Modify the `put` method so that it does not attempt to add elements if the put operation can lead to an infinite rehash loop. # Function Specifications ResizableHashTable: * `put(self, key: int, value: int) -> None`: Inserts or updates a value in the table. * `del_(self, key: int) -> None`: Removes a value from the table. * `shrink(self) -> None`: Halves the table size while maintaining all current entries. # Example ```python hash_table = ResizableHashTable() hash_table.put(10, \'A\') hash_table.put(20, \'B\') hash_table.put(30, \'C\') hash_table.del_(20) # Now the table size should decrease if the load factor falls below 1/4. ``` # Constraints * The key and values are both integers. * Assume all operations on the hash table (initialization, insertion, deletion, and resizing) fit within the memory limits. * The number of elements can dynamically change but remains within practical upper bounds. # Notes * Ensure to handle edge cases where table size adjustments might lead to data loss. * Efficiently update references and maintain constant time complexity in average cases where possible. * Thoroughly test your implementation with various edge cases and typical scenarios.","solution":"class ResizableHashTable: def __init__(self): self.size = 8 self.count = 0 self.table = [None] * self.size def _hash(self, key): return key % self.size def _resize(self, new_size): old_table = self.table self.size = new_size self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def _rehash(self): self._resize(self.size * 2) def shrink(self): if self.size > 8 and self.count < self.size // 4: self._resize(self.size // 2) def put(self, key, value): if self.count >= 2 * self.size // 3: self._rehash() index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = (key, value) return index = (index + 1) % self.size self.table[index] = (key, value) self.count += 1 def del_(self, key): index = self._hash(key) initial_index = index while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 self._rehash_table_from_index((index + 1) % self.size) self.shrink() return index = (index + 1) % self.size if index == initial_index: break def _rehash_table_from_index(self, start_index): index = start_index while self.table[index] is not None: key, value = self.table[index] self.table[index] = None self.count -= 1 self.put(key, value) index = (index + 1) % self.size def get(self, key): index = self._hash(key) initial_index = index while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.size if index == initial_index: break return None"},{"question":"# Scenario: You are designing a system to help a store owner determine all possible ways to achieve a specific sales target using different product prices. The store owner can repeatedly choose the prices as needed. # Problem Statement: Write a function `combination_sum` that takes a list of positive integers `candidates` (representing the prices of products) and a single positive integer `target` (representing the sales target). The function should return a list of all unique combinations of the candidate numbers that add up to the target sum. Each candidate number can be chosen multiple times. # Function Signature: ```python def combination_sum(candidates: List[int], target: int) -> List[List[int]]: pass ``` # Input: * `candidates` (1 <= len(candidates) <= 30): list of positive integers without duplicates. * `target` (1 <= target <= 500): a positive integer. # Output: * A list of lists containing unique combinations of numbers that add up to `target`. # Constraints: * All numbers (including the target) will be positive integers. * The solution set must not contain duplicate combinations. # Example: ```python candidates = [2, 3, 6, 7] target = 7 result = combination_sum(candidates, target) ``` Expected output: ```python [ [7], [2, 2, 3] ] ``` # Additional Test Cases: ```python candidates = [2, 3] target = 2 result = combination_sum(candidates, target) # Expected output: [[2]] candidates = [2, 3, 5] target = 8 result = combination_sum(candidates, target) # Expected output: # [ # [2, 2, 2, 2], # [2, 3, 3], # [3, 5] # ] ``` # Performance Requirements: The algorithm should be optimized to handle the maximum constraint efficiently. Use backtracking and depth-first search while ensuring that the same numbers are reused logically to avoid redundant calculations.","solution":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: def backtrack(remaining: int, start: int, path: List[int], res: List[List[int]]): if remaining == 0: res.append(list(path)) return elif remaining < 0: return for i in range(start, len(candidates)): candidate = candidates[i] path.append(candidate) backtrack(remaining - candidate, i, path, res) path.pop() result = [] backtrack(target, 0, [], result) return result"},{"question":"You are given an array of integers where each integer represents a color: 0 for red, 1 for white, and 2 for blue. Your task is to sort the array so that all instances of the color red come first, followed by white, and then blue. Write a function `sort_colors(nums)` that takes an array of integers and sorts it in the order stated above. You should perform this sort in-place and without using any built-in sorting functions. Function Signature ```python def sort_colors(nums: List[int]) -> None: ``` Input - `nums`: A list of integers representing the colors red (0), white (1), and blue (2). The length of `nums` is at least 0 and at most 1000. Output - The function should modify the input array in-place to achieve the desired sorting order. Constraints - Do not use any built-in sorting functions. - Optimize for both time and space complexity. Example ```python # Example 1 nums = [2, 0, 1, 2, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] # Example 2 nums = [0] sort_colors(nums) print(nums) # Output: [0] # Example 3 nums = [2, 1, 1, 0, 2, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 1, 2, 2] ``` **Note**: The function should directly modify the list and should not return anything.","solution":"def sort_colors(nums): Sort the array in-place so that all instances of 0 (red) come first, followed by 1 (white), and then 2 (blue). low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[mid], nums[high] = nums[high], nums[mid] high -= 1"},{"question":"You need to implement a data structure that allows for averaging O(1) time complexity for insertion, deletion, and retrieval of a random element. This data structure should support the following operations: 1. `insert(val)`: Insert an element `val` into the set if not already present. 2. `remove(val)`: Remove an element `val` from the set if it is present. 3. `random_element()`: Return a random element from the set with each element having the same probability of being returned. # Constraints 1. It is guaranteed that no duplicated element will be passed to the insert method. 2. It is guaranteed that the remove method will only be called with elements that are present in the set. 3. Implement these operations with average O(1) time complexity. # Input and Output Format - `insert(val)`: * Input: An integer `val`. * Output: None. - `remove(val)`: * Input: An integer `val`. * Output: None. - `random_element()`: * Input: None. * Output: An integer representing the element randomly chosen from the set. # Example ```python rset = RandomizedSet() rset.insert(10) rset.insert(20) rset.remove(10) print(rset.random_element()) # Output: 20 ``` # Note For `random_element()`, assume a seeded random generator can be used if randomness is needed to be deterministic for testing purposes. # Implementation Implement the `RandomizedSet` class provided the following signature: ```python class RandomizedSet: def __init__(self): # Your initialization code here def insert(self, val: int) -> None: # Your code here def remove(self, val: int) -> None: # Your code here def random_element(self) -> int: # Your code here ```","solution":"import random class RandomizedSet: def __init__(self): self.data = [] self.idx_map = {} def insert(self, val: int) -> None: if val not in self.idx_map: self.data.append(val) self.idx_map[val] = len(self.data) - 1 def remove(self, val: int) -> None: if val in self.idx_map: last_element = self.data[-1] idx_to_remove = self.idx_map[val] self.data[idx_to_remove] = last_element self.idx_map[last_element] = idx_to_remove self.data.pop() del self.idx_map[val] def random_element(self) -> int: return random.choice(self.data)"},{"question":"# Question: Efficient Counting of Unique Islands You are given a grid representing a map where \'0\' represents water and \'1\' represents land. You need to implement an algorithm to count the number of islands after each addition of land. An island is formed by connecting adjacent lands horizontally or vertically. Assume the edges of the grid are surrounded by water. You are required to implement the class `IslandCounter` in Python which uses the Union-Find data structure for efficiently managing and counting the islands. # Class: `IslandCounter` - **Methods**: 1. **`__init__(self, n_rows: int, n_cols: int)`:** Constructs an empty grid with the dimensions `n_rows` X `n_cols`. 2. **`add_land(self, row: int, col: int) -> int`:** Adds land at position `(row, col)` and returns the number of islands after this operation. 3. **`count_islands(self) -> int`:** Returns the current number of islands. # Implementation Details: 1. `__init__` Method * Initialize an empty grid and the Union-Find data structure. 2. `add_land` Method * Convert water to land at the specified position. * Update the Union-Find data structure to merge adjacent lands, if any. * Return the current count of islands. 3. `count_islands` Method * Simply returns the current number of islands being managed by the Union-Find data structure. # Example: ```python ic = IslandCounter(3, 3) print(ic.add_land(0, 0)) # Output: 1 (since there is now 1 island at (0, 0)) print(ic.add_land(0, 1)) # Output: 1 (since (0, 0) and (0, 1) are connected forming a single island) print(ic.add_land(1, 2)) # Output: 2 (new land at (1, 2) is isolated) print(ic.add_land(2, 1)) # Output: 3 (new land at (2, 1) is isolated) print(ic.count_islands()) # Output: 3 ``` # Constraints: * The number of rows and columns is at most 1000. * `add_land` operations will be called at most 10^4 times. Implement the `IslandCounter` class accordingly.","solution":"class IslandCounter: def __init__(self, n_rows: int, n_cols: int): self.n_rows = n_rows self.n_cols = n_cols self.grid = [[0 for _ in range(n_cols)] for _ in range(n_rows)] self.parent = {} self.rank = {} self.island_count = 0 def find(self, idx): if self.parent[idx] != idx: self.parent[idx] = self.find(self.parent[idx]) # path compression return self.parent[idx] def union(self, idx1, idx2): root1 = self.find(idx1) root2 = self.find(idx2) if root1 != root2: # union by rank if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 self.island_count -= 1 def add_land(self, row: int, col: int) -> int: if self.grid[row][col] == 1: return self.island_count self.grid[row][col] = 1 idx = row * self.n_cols + col self.parent[idx] = idx self.rank[idx] = 0 self.island_count += 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < self.n_rows and 0 <= nc < self.n_cols and self.grid[nr][nc] == 1: neighbor_idx = nr * self.n_cols + nc self.union(idx, neighbor_idx) return self.island_count def count_islands(self) -> int: return self.island_count"},{"question":"# Priority Queue Implementation and Testing **Context**: As a software engineer in a tech firm, your task is to optimize the process of handling tasks that arrive with different levels of importance. To do this, you decide to implement a Priority Queue using an array. This data structure should help prioritize tasks efficiently. **Problem Statement**: You are required to implement a priority queue system for managing tasks. The Priority Queue should allow: 1. Inserting tasks with a given priority. 2. Extracting the highest priority task. **Requirements**: - Design a `PriorityQueue` class. - Implement the following methods: * `push(item: Any, priority: int) -> None`: Inserts an item into the priority queue with the specified priority. * `pop() -> Any`: Extracts and returns the item with the highest priority. * `size() -> int`: Returns the number of items in the priority queue. - Handle cases where: * Multiple items have the same priority. * `pop` is called on an empty queue (raise an `IndexError`). **Expected Input and Output**: - `push(item, priority)`: No output. - `pop()`: Returns the item with the highest priority. - `size()`: Returns the count of items in the priority queue as an integer. **Constraints**: - The priority is a non-negative integer. - The priority queue can contain up to 1000 items. **Performance Requirements**: - The `push` method should operate in O(n) time complexity. - The `pop` method should operate in O(1) time complexity. # Example Code ```python # Example of using the PriorityQueue pq = PriorityQueue() # Pushing items to the queue pq.push(\'task1\', priority=2) pq.push(\'task2\', priority=1) pq.push(\'task3\', priority=3) print(pq.size()) # Output: 3 # Extracting items based on priority print(pq.pop()) # Output: task1 (highest priority 2) print(pq.pop()) # Output: task2 (priority 1) print(pq.size()) # Output: 1 ``` **Edge Cases to Consider**: - Inserting multiple items with the same priority should maintain their relative FIFO order. - Popping from an empty queue should raise an `IndexError`. **Additional Note**: - Do not use the built-in `heapq` or other priority queue utilities. Implement everything from scratch.","solution":"class PriorityQueue: def __init__(self): self.queue = [] def push(self, item, priority): Insert an item with a given priority into the priority queue. self.queue.append((priority, item)) self.queue.sort(reverse=True, key=lambda x: x[0]) def pop(self): Extract and return the item with the highest priority. Raise IndexError if the queue is empty. if not self.queue: raise IndexError(\\"Pop from an empty priority queue\\") return self.queue.pop(0)[1] def size(self): Return the number of items in the priority queue. return len(self.queue)"},{"question":"Context: You are working on a data analysis tool that assists users in comprehending the distribution of numerical data by calculating the frequency of each unique value in a dataset. One fundamental component of your tool is the function that generates a histogram. Function Implementation: Implement a function called `get_histogram` that generates a histogram (frequency counter) from a given list of integer values. Function Signature: ```python def get_histogram(input_list: list) -> dict: ``` Parameters: - `input_list` (List[int]): A list containing integer values, potentially having duplicate entries. Returns: - A dictionary where each key is a unique integer from the input list and its corresponding value is the count of that integer in the list. Constraints: - The list will contain integers only. - The integers in the list will range from -10^6 to 10^6. - The length of the input list will not exceed 10^6. Examples: ```python # Example 1: input_list = [3, 3, 2, 1] # Expected Output: {1: 1, 2: 1, 3: 2} # Example 2: input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 3: input_list = [] # Expected Output: {} ``` Performance Requirements: - The function should have a time complexity of O(n), where n is the length of the input list. - The space complexity should be O(k), where k is the number of unique elements in the input list. Implement the `get_histogram` function to meet the above specifications.","solution":"def get_histogram(input_list: list) -> dict: Generates a histogram (frequency counter) from a given list of integer values. :param input_list: List containing integer values, potentially with duplicates. :return: Dictionary where keys are unique integers from the list and values are their counts. histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"# Priority Queue Implementation and Operations As a part of the software for a simulation system, you are tasked to implement an improved priority queue. This queue should allow adding and removing items based on their priority efficiently. You need to implement a priority queue that supports the following operations: 1. **Insert an item with a given priority.** 2. **Remove and return the item with the highest priority.** Function Signature: ```python class PriorityQueue: def __init__(self, items=None, priorities=None): # Initialize the priority queue def push(self, item, priority=None): # Insert an item with a given priority def pop(self): # Remove and return the item with the highest priority def size(self): # Return the size of the priority queue ``` # Constraints * The priorities of the items are integers. If no priority is given, the item\'s value is used as its priority. * You may assume the highest priority is the lowest numerical value. # Input and Output - The `push` method should insert the item with the given priority or use the item\'s value if no priority is specified. - The `pop` method should remove and return the item with the highest priority (lowest priority value). - The `size` method should return the current number of items in the priority queue. # Example ```python pq = PriorityQueue() pq.push(10, 1) pq.push(20, 3) pq.push(15, 2) print(pq.pop()) # Output: 10 (highest priority 1) print(pq.pop()) # Output: 15 (next highest priority 2) ``` # Additional Notes: 1. Handle cases where pop operation is called on an empty queue gracefully. 2. Ensure the priority queue maintains the correct order after each insertion.","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self.heap, (priority, item)) def pop(self): if self.size() == 0: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.heap)[1] def size(self): return len(self.heap)"},{"question":"In this task, you are required to implement an algorithm that processes a stack to switch successive pairs of elements starting from the bottom of the stack. Given a stack, you need to write a function `switch_pairs_optimal(stack)` that modifies the stack such that each pair of successive elements is switched. If the stack has an odd number of elements, the top element remains unchanged. You have two existing solutions: 1. Using an additional stack as auxiliary storage. 2. Using a queue as auxiliary storage. Your task is to develop a more space-efficient approach that uses minimal auxillary storage while keeping the time complexity as O(n). # Constraints * The stack can contain up to 1000 elements. * The elements of the stack are integers. * You can use built-in data structures but avoid excessive additional space usage. # Input The input will be a list representing the stack, where the last element in the list represents the top of the stack. Example: ```python stack = [3, 8, 17, 9, 1, 10] ``` # Expected Output The output should be the transformed stack where successive pairs are switched. Example: ```python stack = [8, 3, 9, 17, 10, 1] ``` # Function Signature ```python def switch_pairs_optimal(stack: list) -> list: # Your code here ``` # Example ```python def switch_pairs_optimal(stack: list) -> list: n = len(stack) for i in range(0, n - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack # Example usage: assert switch_pairs_optimal([3, 8, 17, 9, 1, 10]) == [8, 3, 9, 17, 10, 1] assert switch_pairs_optimal([3, 8, 17, 9, 1]) == [8, 3, 9, 17, 1] ``` # Additional Information - The stack is mutable: elements can be modified in place. - Ensure that you handle both odd and even lengths of the stack without errors.","solution":"def switch_pairs_optimal(stack: list) -> list: Modifies the stack such that each pair of successive elements is switched. If the stack has an odd number of elements, the top element remains unchanged. :param stack: List representing the stack where the last element is the top. :return: Modified stack with successive pairs switched. n = len(stack) for i in range(0, n - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack # Example usage: # assert switch_pairs_optimal([3, 8, 17, 9, 1, 10]) == [8, 3, 9, 17, 10, 1] # assert switch_pairs_optimal([3, 8, 17, 9, 1]) == [8, 3, 9, 17, 1]"},{"question":"# Question: Optimized String Reversal Implement a function `optimized_reverse` that efficiently reverses a given string. The solution should balance readability and performance, minimizing both time complexity and space complexity. Compare your approach to the provided algorithms and explain why your implementation is optimal. Input Format - A single string `s` with length in the range [0, 10^6]. Output Format - A string representing the reversed input. Constraints - The function should handle all typical edge cases efficiently. - Focus on both time and space complexity during implementation. Example ```python assert optimized_reverse(\\"hello\\") == \\"olleh\\" assert optimized_reverse(\\"abcdef\\") == \\"fedcba\\" assert optimized_reverse(\\"a\\") == \\"a\\" assert optimized_reverse(\\"\\") == \\"\\" ``` # Task * Implement the function `optimized_reverse`. * Compare your solution with the recursive, iterative, pythonic, and ultra-pythonic methods provided earlier. * Provide detailed analysis and justification for your approach, emphasizing efficiency. ```python def optimized_reverse(s): # Write your implementation here pass # You can add your test cases here to verify your solution works ```","solution":"def optimized_reverse(s): Efficiently reverses a given string. Parameters: s (str): The string to be reversed. Returns: str: The reversed string. # Using string slicing which is highly efficient in Python return s[::-1]"},{"question":"You are required to implement a class `TemperatureTracker` to manage temperature readings from multiple sensors. Your task is to calculate and monitor the moving average temperature using a sliding window approach. # Requirements 1. The class should be initialized with a specified window size indicating how many most recent readings to consider for calculating the moving average. 2. Method `record_temperature(self, temperature: float) -> None`: Records a new temperature reading. 3. Method `get_moving_average(self) -> float`: Returns the current moving average of the temperatures recorded within the window. # Input/Output Formats * `__init__(self, size: int)`: Initializes the `TemperatureTracker` with the specified window size. * `record_temperature(self, temperature: float)`: Records a temperature reading. * `get_moving_average(self) -> float`: Returns the moving average of the recorded temperatures. # Constraints * The temperature readings can be real numbers (float). * The number of temperature recordings will not exceed 10^6. * The window size will be a positive integer less than or equal to 10^5. # Example ```python if __name__ == \'__main__\': tracker = TemperatureTracker(3) tracker.record_temperature(75.5) print(tracker.get_moving_average()) # Output: 75.5 tracker.record_temperature(80.1) print(tracker.get_moving_average()) # Output: 77.8 (which is (75.5 + 80.1) / 2) tracker.record_temperature(78.0) print(tracker.get_moving_average()) # Output: 77.86667 (which is (75.5 + 80.1 + 78.0) / 3) tracker.record_temperature(82.3) print(tracker.get_moving_average()) # Output: 80.13333 (which is (80.1 + 78.0 + 82.3) / 3) ``` # Additional Context Make sure to handle scenarios where the number of recorded temperatures is less than the window size.","solution":"from collections import deque class TemperatureTracker: def __init__(self, size: int): Initializes the TemperatureTracker with the specified window size. self.size = size self.temperatures = deque() self.sum = 0.0 def record_temperature(self, temperature: float) -> None: Records a new temperature reading. self.temperatures.append(temperature) self.sum += temperature if len(self.temperatures) > self.size: self.sum -= self.temperatures.popleft() def get_moving_average(self) -> float: Returns the current moving average of the temperatures recorded within the window. return self.sum / len(self.temperatures) if self.temperatures else 0.0"},{"question":"# Comb Sort Implementation Challenge Context Comb Sort is a comparison-based sorting algorithm designed to improve upon Bubble Sort by dealing with small values towards the end of the list early. It uses a gap sequence that shrinks by a factor (usually 1.3) on each pass through the list. This helps to efficiently sort lists, particularly where there are values near the end that need to be moved towards the beginning early in the sorting process. Task Write a function `custom_comb_sort` that sorts a list of integers using the Comb Sort algorithm. Requirements 1. **Function Signature**: ```python def custom_comb_sort(arr: list[int]) -> list[int]: ``` 2. **Input**: A list of integers `arr` that needs to be sorted. * Constraints: * (1 leq text{len(arr)} leq 10^4) * (-10^9 leq arr[i] leq 10^9) 3. **Output**: The function should return a new list sorted in ascending order. 4. **Performance**: Aim for an average-case time complexity of better than O(N^2). Example ```python # Example 1 arr = [8, 4, 1, 56, 3, -44, 23, -6, 28, 0] print(custom_comb_sort(arr)) # Output: [-44, -6, 0, 1, 3, 4, 8, 23, 28, 56] # Example 2 arr = [5, 4, 3, 2, 1] print(custom_comb_sort(arr)) # Output: [1, 2, 3, 4, 5] ``` **Constraints** * Your solution should handle edge cases effectively, such as empty lists, lists with repeated elements, already sorted lists, or lists with a single element.","solution":"def custom_comb_sort(arr: list[int]) -> list[int]: def get_next_gap(gap): # Shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"**Task**: You are given a function `swap_pair(num)` that swaps odd and even bits in an integer with as few instructions as possible. Your task is to implement this function based on the given requirements and constraints. Function Signature ```python def swap_pair(num: int) -> int: # Your code here ``` Input * An integer `num`, where: * It can be 32-bit (signed or unsigned). Output * An integer representing the result after swapping odd and even bits. Constraints * The input integer will be in the range of a 32-bit signed integer (-2^31 to 2^31 - 1). Examples 1. **Input**: `num = 22` (in binary: `010110`) **Output**: `41` (in binary: `101001`) 2. **Input**: `num = 10` (in binary: `1010`) **Output**: `5` (in binary: `0101`) Scenario You are working on software for a microcontroller that directly manipulates hardware registers. An essential task is to swap each pair of adjacent bits in control registers to meet hardware requirements. Implement the `swap_pair` function to carry out this bitwise manipulation accurately and efficiently. Proceed with the function implementation and ensure it handles the bit-level operations correctly, taking into account the provided constraints. Utilize bitwise operations to swap adjacent bits efficiently.","solution":"def swap_pair(num: int) -> int: # Masks to isolate odd and even bits ODD_BITS_MASK = 0xAAAAAAAA # Mask with bits in odd positions set to 1 -> 10101010... EVEN_BITS_MASK = 0x55555555 # Mask with bits in even positions set to 1 -> 01010101... # Shift odd bits to the right to even positions and shift even bits to the left to odd positions odd_bits_shifted = (num & ODD_BITS_MASK) >> 1 even_bits_shifted = (num & EVEN_BITS_MASK) << 1 # Combine the shifted bits to get the final result return odd_bits_shifted | even_bits_shifted"},{"question":"You are given a matrix where each row is sorted in ascending order from left to right and each column is sorted in ascending order from top to bottom. Write a function `find_key_in_matrix` which takes a 2D matrix and a key and returns the position of the key in the matrix. # Function Signature ```python def find_key_in_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: # Your implementation here ``` # Input Details - `matrix`: A 2D list of integers where each row and each column are sorted in ascending order. - `key`: An integer you need to find in the matrix. # Output Details - Returns a tuple of two integers representing the row index and column index of the `key` in the matrix (both 0-indexed). - If the key is not present, return `(-1, -1)`. # Constraints - The number of rows and columns in the matrix will be between 1 and 10^3. - The elements in the matrix will be between -10^9 and 10^9. # Example Example 1: **Input**: ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] key = 5 ``` **Output**: ```python (1, 1) ``` Example 2: **Input**: ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] key = 20 ``` **Output**: ```python (-1, -1) ``` # Additional Notes - Ensure that your solution is efficient given the constraints, and justify your approach. - Consider edge cases such as an empty matrix or matrix with only one element. - You may assume the input matrix is always valid and adheres to the constraints.","solution":"from typing import List, Tuple def find_key_in_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"Context: You are working on a system that needs to save and restore the structure of a binary tree efficiently. The provided code snippets utilize pre-order traversal to serialize and deserialize a binary tree into/from a string format. You will build upon this system to enhance its robustness and add functionality. Task: Implement a function to compare two binary trees for structural and value equality. This function will be used to verify that serialization and subsequent deserialization of a binary tree results in an identical tree. Function Signature: ```python def is_same_tree(root1: TreeNode, root2: TreeNode) -> bool: pass ``` Input: - `root1`: The root node of the first binary tree. - `root2`: The root node of the second binary tree. Output: - Return `True` if both trees are structurally identical and have the same node values at each position. - Return `False` otherwise. Constraints: - Both `root1` and `root2` are instances of `TreeNode` or `None`. - Each tree node has an integer value accessible via `node.val`. Example: ```python # Example usage: root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) assert is_same_tree(root1, root2) == True root3 = TreeNode(1) root3.left = TreeNode(2) root4 = TreeNode(1) root4.right = TreeNode(2) assert is_same_tree(root3, root4) == False ``` Requirements: - The function should accurately handle all edge cases, such as empty trees or trees with single-sided children. - Efficiency is crucial. Aim for a time complexity of O(n), where n is the number of nodes in the larger of the two trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(root1: TreeNode, root2: TreeNode) -> bool: if not root1 and not root2: return True if not root1 or not root2: return False if root1.val != root2.val: return False return is_same_tree(root1.left, root2.left) and is_same_tree(root1.right, root2.right) # Example usage: root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) assert is_same_tree(root1, root2) == True root3 = TreeNode(1) root3.left = TreeNode(2) root4 = TreeNode(1) root4.right = TreeNode(2) assert is_same_tree(root3, root4) == False"},{"question":"You are provided with functions to compute the GCD using both Euclid\'s Algorithm and bitwise operations, compute the LCM, and find the number of trailing zeroes in the binary representation of an integer. Based on these functions, implement a function to determine the least common multiple (LCM) of a list of integers. The function should utilize the provided GCD implementations to ensure efficiency. # Function Signature ```python def list_lcm(nums): Given a list of positive integers, computes the least common multiple (LCM) of all the integers in the list. Parameters: nums (List[int]): A list of positive integers Returns: int: The LCM of the list of integers. pass ``` # Constraints * Each integer in the list is a positive integer. * The list contains at least two integers and at most 100 integers. * 1 <= nums[i] <= 10^6 for 1 <= i <= len(nums). # Performance Requirements * The function should be efficient with a time complexity preferably O(n * log(max(nums))), where n is the length of the list. # Example ```python list_lcm([4, 6]) => 12 list_lcm([2, 7, 3, 9, 4]) => 252 ``` # Notes * Use the given GCD functions to help define the LCM. * Consider edge cases such as handling varying list sizes and the presence of both small and large numbers.","solution":"from math import gcd from functools import reduce def lcm(x, y): Computes the Least Common Multiple (LCM) of two positive integers. return x * y // gcd(x, y) def list_lcm(nums): Given a list of positive integers, computes the least common multiple (LCM) of all the integers in the list. Parameters: nums (List[int]): A list of positive integers Returns: int: The LCM of the list of integers. return reduce(lcm, nums)"},{"question":"# Doubly Linked List Implementation You are required to implement a doubly linked list with the following operations: 1. **Append (Add at tail)**: Insert a new node with a specified value at the end of the list. 2. **Remove (Delete by value)**: Remove the first node that contains the specified value. 3. **Reverse**: Reverse the entire list. Function Signatures ```python class DoublyLinkedListNode: def __init__(self, value: int): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value: int): ``` **append method** * **Input**: An integer value to append. * **Output**: None. ```python def remove(self, value: int): ``` **remove method** * **Input**: An integer value to remove. * **Output**: Returns `True` if a node with the value is found and removed, else returns `False`. ```python def reverse(self): ``` **reverse method** * **Input**: None. * **Output**: Returns a reversed list. Example ```python dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.append(3) ``` * Before reversing: `1 <-> 2 <-> 3` * After reversing: `3 <-> 2 <-> 1` Constraints * None of the input operations should have constant space or time burdens, except traversal. * The list may start empty and manage up to 10^4 operations in a reasonable time.","solution":"class DoublyLinkedListNode: def __init__(self, value: int): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value: int): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove(self, value: int): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return True current = current.next return False def reverse(self): current = self.head prev_node = None while current: next_node = current.next current.next = prev_node current.prev = next_node prev_node = current current = next_node self.head, self.tail = self.tail, self.head"},{"question":"Problem Statement # Context You are working on a navigation system for a robot meant to traverse a complex warehouse floor. The warehouse is represented as a directed graph where each node represents a location or a junction, and each edge represents a path connecting two locations. # Objective Implement a function that finds all paths from the robot\'s starting location to its destination while avoiding any locations that are marked as restricted due to temporary obstacles. # Function Specification Your task is to write a function `find_restricted_paths(graph, start, end, restricted)` that finds all paths from a `start` node to an `end` node in a given directed graph, while avoiding the nodes listed in the `restricted` list. Input - `graph`: A dictionary representing the directed graph. The keys are node identifiers and values are lists of connected nodes. - `start`: The starting node identifier. - `end`: The destination node identifier. - `restricted`: A list of node identifiers representing restricted locations. Output - A list of lists, where each inner list represents a path from `start` to `end` that does not include any nodes from the `restricted` list. Each path is represented as a sequence of node identifiers. Constraints - The graph is guaranteed to be connected. - The `start` and `end` nodes will not be in the restricted list. - No duplicate edges exist. - The node identifiers are unique and non-negative integers. # Example ```python graph = { 0: [1, 2], 1: [2, 3], 2: [3], 3: [4], 4: [] } start = 0 end = 4 restricted = [2, 3] print(find_restricted_paths(graph, start, end, restricted)) # Expected Output: [] ``` # Note - In the given example, there are no paths from node 0 to node 4 avoiding nodes 2 and 3. - Ensure your solution handles efficiency well for larger graph structures.","solution":"def find_restricted_paths(graph, start, end, restricted): Finds all paths from start to end in the graph while avoiding restricted nodes. Args: - graph (dict): The directed graph represented as adjacency list. - start (int): The starting node identifier. - end (int): The destination node identifier. - restricted (list): List of node identifiers representing restricted locations. Returns: - List of lists, where each inner list is a path from start to end without restricted nodes. def dfs(current, path): if current in restricted: return if current == end: result.append(path[:]) return for neighbor in graph.get(current, []): if neighbor not in visited: visited.add(neighbor) path.append(neighbor) dfs(neighbor, path) path.pop() visited.remove(neighbor) result = [] visited = set([start]) dfs(start, [start]) return result"},{"question":"# Maximum Subarray Problem Problem Statement You are given an array of integers. Your task is to write a function `find_max_subarray_sum` that takes this array as input and returns the sum of the maximum sum subarray. Function Signature ```python def find_max_subarray_sum(array: List[int]) -> int: pass ``` Input - `array`: A list of integers `[-10^5 <= array[i] <= 10^5, 1 <= len(array) <= 10^5]`. Output - Returns an integer representing the sum of the maximum sum subarray. Examples ```python assert find_max_subarray_sum([1, 2, -3, 4, 5, -7, 23]) == 25 assert find_max_subarray_sum([-1, -2, -3, -4]) == -1 assert find_max_subarray_sum([3, 2, -1, 5, -2]) == 9 assert find_max_subarray_sum([1]) == 1 ``` # Requirements - Your solution should have a time complexity of O(n) and use constant extra space, O(1). - Handle edge cases such as arrays with all negative numbers or single element arrays gracefully. Constraints - The function should handle both small and very large arrays efficiently. - The input array can have both positive and negative integers, and all integers within the range `[-10^5, 10^5]`.","solution":"from typing import List def find_max_subarray_sum(array: List[int]) -> int: This function returns the sum of the maximum sum subarray using Kadane\'s algorithm. max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"Enhanced Linear Search for Multi-Array Structures Problem Description You are given multiple arrays that you need to search through sequentially to find a target value. Each array can be of different lengths and might contain any type of elements. Your task is to write a function that searches through each array in sequence and finds the first occurrence of the target value across all arrays. Function Signature ```python def multi_array_linear_search(arrays, query): Searches for the query in multiple arrays sequentially. Args: arrays (list of lists): A list containing multiple arrays to be searched. query (any type): The element to search for in the arrays. Returns: tuple: A tuple (array_index, element_index) where array_index represents the index of the array in which the query was found, and element_index represents the index within that array. Returns (-1, -1) if the element is not found in any of the arrays. pass ``` Input and Output Requirements * **Input**: * `arrays` - A list of lists, where each list can contain elements of any type. * `query` - The element to search for. * **Output**: * A tuple containing: * The index of the array where the query element is found. * The index within the specific array where the query element is found. * If the element is not found in any array, return (-1, -1). Constraints * The arrays may be empty. * Arrays can contain any type of elements, but all elements in a particular array will be of the same type. * The target element can appear multiple times but you need to return only the first occurrence. **Example** ```python arrays = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] query = 5 # Returns: (1, 1) since the element 5 is in the second array (index 1) at index 1. arrays = [[1, 2, 3], [], [7, 6, 5]] query = 5 # Returns: (2, 2) since 5 is found in the third array (index 2) at index 2. arrays = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] query = 10 # Returns: (-1, -1) since the element 10 is not found in any array. ``` Use the provided function signature to complete your solution.","solution":"def multi_array_linear_search(arrays, query): Searches for the query in multiple arrays sequentially. Args: arrays (list of lists): A list containing multiple arrays to be searched. query (any type): The element to search for in the arrays. Returns: tuple: A tuple (array_index, element_index) where array_index represents the index of the array in which the query was found, and element_index represents the index within that array. Returns (-1, -1) if the element is not found in any of the arrays. for array_index, array in enumerate(arrays): try: element_index = array.index(query) return array_index, element_index except ValueError: continue return -1, -1"},{"question":"Scenario: You are working for a logistics company managing deliveries in a city represented by a graph. The graph nodes represent locations, and edges represent routes between them. You need to provide quick route analysis tools to ensure the delivery team can plan their routes efficiently. Task: Implement a Python function called `calculate_paths` that uses the provided graph traversal functions to achieve three objectives: 1. Determine a path (if any) between two locations. 2. Find all possible paths between two locations. 3. Identify the shortest path between two locations (in terms of the number of edges). Function Signature: ```python def calculate_paths(graph: dict, start: str, end: str) -> dict: Calculate and return paths information between two nodes in a graph. Params: graph: A dictionary representing the graph (adjacency list). start: The starting node. end: The ending node. Returns: A dictionary containing: - \\"any_path\\": A list representing a valid path from start to end, or None if no path exists. - \\"all_paths\\": A list of lists, where each inner list represents a path from start to end. - \\"shortest_path\\": A list representing the shortest path from start to end, or None if no path exists. # Implementation here ``` Input Format: * `graph`: Dictionary representing the graph (adjacency list), where keys are node names, and values are lists of adjacent nodes. * `start` and `end`: Strings representing the start and end locations (nodes). Output Format: * Return a dictionary with three keys: * `\\"any_path\\"`: A list of nodes representing any valid path from start to end, or `None` if no path exists. * `\\"all_paths\\"`: A list containing all possible paths (`list of lists`) from start to end. * `\\"shortest_path\\"`: A list of nodes representing the shortest path from start to end, or `None` if no path exists. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } calculate_paths(graph, \'A\', \'F\') # Should return: # { # \\"any_path\\": [\'A\', \'B\', \'E\', \'F\'], # \\"all_paths\\": [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']], # \\"shortest_path\\": [\'A\', \'C\', \'F\'] # } ``` Constraints: * The graph will have at most 100 nodes. * The node names are case-sensitive and are unique. * There is no guarantee that a path between two nodes exists.","solution":"from collections import deque def calculate_paths(graph, start, end): def find_any_path(): if start == end: return [start] stack = [(start, [start])] while stack: (vertex, path) = stack.pop() for next in set(graph[vertex]) - set(path): if next == end: return path + [next] else: stack.append((next, path + [next])) return None def find_all_paths(): def recursive_dfs(current, end, path): path = path + [current] if current == end: return [path] paths = [] for node in graph.get(current, []): if node not in path: newpaths = recursive_dfs(node, end, path) for newpath in newpaths: paths.append(newpath) return paths return recursive_dfs(start, end, []) def find_shortest_path(): if start == end: return [start] queue = deque([(start, [start])]) while queue: (vertex, path) = queue.popleft() for next in set(graph[vertex]) - set(path): if next == end: return path + [next] else: queue.append((next, path + [next])) return None return { \\"any_path\\": find_any_path(), \\"all_paths\\": find_all_paths(), \\"shortest_path\\": find_shortest_path() }"},{"question":"You are part of a team working on finding circular dependencies in a set of tasks. Your task is to implement Kosaraju\'s algorithm to find the number of Strongly Connected Components (SCCs) in a directed graph. Task Implement a function `find_sccs(V, edges)` that takes: * `V`: an integer representing the number of vertices in the graph. * `edges`: a list of tuples (u, v) representing directed edges from vertex `u` to vertex `v`. Your function should return an integer representing the number of SCCs in the graph. Function Signature ```python def find_sccs(V: int, edges: List[Tuple[int, int]]) -> int: pass ``` Input: * An integer `V` (1 ≤ V ≤ 10^4), the number of vertices. * A list `edges` of tuples, each containing two integers `u` and `v` (0 ≤ u, v < V) representing a directed edge from `u` to `v`. The list will have at most 10^4 edges. Output: * An integer representing the number of strongly connected components in the graph. Example: ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] assert find_sccs(V, edges) == 2 # Explanation: Two SCCs, {0, 1, 2, 3} and {4, 5} ``` Constraints and Requirements: * The graph can have self-loops and multiple edges. * Implement Kosaraju\'s algorithm as described. * Aim for O(V + E) time complexity to ensure it handles large inputs efficiently.","solution":"from typing import List, Tuple def find_sccs(V: int, edges: List[Tuple[int, int]]) -> int: from collections import defaultdict, deque graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) visited = [False] * V finished_stack = [] # Step 1: Order the nodes by finish time in decreasing order using DFS def dfs(v): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor) finished_stack.append(v) for i in range(V): if not visited[i]: dfs(i) # Step 2: Transpose the graph visited = [False] * V scc_count = 0 # Step 3: In reverse finishing order, explore the reversed graph def reverse_dfs(v): visited[v] = True for neighbor in reverse_graph[v]: if not visited[neighbor]: reverse_dfs(neighbor) while finished_stack: node = finished_stack.pop() if not visited[node]: reverse_dfs(node) scc_count += 1 return scc_count"},{"question":"You are provided with a sorted array of integers and a target value. Your task is to implement the `ternary_search` function that searches for the target value in the array using the Ternary Search algorithm. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: ``` Input - An integer `left`, representing the starting index of the array (initially 0). - An integer `right`, representing the ending index of the array (initially len(arr)-1). - An integer `key`, representing the target value to search for. - A list of integers `arr`, which is sorted in ascending order. Output - Returns the index of the target value `key` if it exists in the array. - Returns `-1` if the `key` is not found in the array. Constraints - The input array `arr` will have at most (10^6) elements. - All elements in the array `arr` are unique. - The array `arr` can contain both negative and positive integers. Requirements - Your implementation should strive for O(log3(N)) time complexity. - You are not allowed to use built-in search functions (e.g., `index`, `find`, `binary_search`). Example ```python # Example 1: arr = [-10, -5, 0, 3, 8, 13, 17] key = 8 print(ternary_search(0, len(arr) - 1, key, arr)) # Output: 4 # Example 2: arr = [1, 2, 5, 7, 10, 12, 14, 18] key = 15 print(ternary_search(0, len(arr) - 1, key, arr)) # Output: -1 ``` Implementation Notes 1. Calculate mid1 and mid2 indices. 2. Compare the `key` with the elements at mid1 and mid2. 3. Adjust the search range accordingly based on the comparison results. 4. Ensure edge cases such as empty arrays or single-element arrays are handled.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: Perform a ternary search on the sorted array arr to find the index of key. while right >= left: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"Context You are developing a script to organize a directory of files for a project. One crucial step in this process is to ensure that all file paths are absolute paths. This will prevent any ambiguity or issues when files are moved or accessed from different working directories. Task Write a function `full_path(file: str) -> str` that takes a file path as input and returns its absolute path. The function should correctly handle typical file paths, including those that start with a tilde (`~`) to represent the user\'s home directory. Input * A string `file` representing the input file path, which may be relative, absolute, or include user directory symbols (`~`). Output * A string representing the absolute path of the input file. Constraints * The input path may be empty or invalid. * The length of the input path will not exceed 300 characters. Performance Requirements The function should be efficient with respect to time and space, ideally converting the path in linear time relative to the length of the input string. Example ```python # Input: \\"~/.config\\" # Output: \\"/home/user/.config\\" (depending on the user\'s home directory) ```","solution":"import os def full_path(file: str) -> str: Returns the absolute path of the given file path. Handles paths that start with \'~\' to represent the user\'s home directory. return os.path.abspath(os.path.expanduser(file))"},{"question":"You are required to implement a function `is_prime_efficient(n: int, k: int) -> bool` that determines whether a given integer n (>= 2) is probably prime using an optimized version of the Rabin-Miller primality test. # Input - **n**: The integer to test for primality (2 <= n <= 10^18). - **k**: Number of test iterations (1 <= k <= 50) to adjust the confidence level in the result. # Output - Returns `True` if n is probably prime, and `False` if n is composite. # Constraints - Ensure that the function handles very large numbers up to 10^18 efficiently. - The function should return within a reasonable time for the upper limits of n and k. # Performance Requirements - Optimize the function for performance, particularly focusing on efficient modular exponentiation and random witness selection. - Ensure edge cases such as small prime numbers and even numbers greater than 2 are handled correctly. # Examples 1. is_prime_efficient(561, 5) should return False (561 is a Carmichael number and composite). 2. is_prime_efficient(101, 5) should return True (101 is prime). 3. is_prime_efficient(2, 5) should return True (2 is prime). 4. is_prime_efficient(4, 5) should return False (4 is even and composite). # Additional Note Aim to minimize number-theoretic computations and avoid naive iterations or divisions beyond what is necessary for the optimized Rabin-Miller logic.","solution":"import random def is_prime_efficient(n: int, k: int) -> bool: Determine whether a given integer n is probably prime using the Rabin-Miller primality test. Parameters: n (int): The integer to test for primality. k (int): Number of test iterations to adjust the confidence level in the result. Returns: bool: True if n is probably prime, False if n is composite. def miller_rabin_test(d, n): a = random.randint(2, n - 2) x = pow(a, d, n) if x == 1 or x == n - 1: return True while d != n - 1: x = (x * x) % n d *= 2 if x == 1: return False if x == n - 1: return True return False if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False d = n - 1 while d % 2 == 0: d //= 2 for _ in range(k): if not miller_rabin_test(d, n): return False return True"},{"question":"# Context Imagine you\'re building a predictive text engine that uses a Markov Chain to suggest the next word in a sentence. The engine has to generate the next word based on the current word, considering the probability distribution of possible subsequent words. You need to implement the functions to handle this operation efficiently. # Task Your task is to implement the following functions in Python based on the provided Markov Chain framework: Function Definitions 1. `predict_next_word(chain: dict, current_word: str) -> str` - **Description**: Given a word transition dictionary (Markov Chain) and the current word, this function should return the next word according to the stochastic process. - **Input**: - `chain` (dict): A dictionary representing the Markov Chain, where keys are words and values are dictionaries of the subsequent words with their transition probabilities. - `current_word` (str): The current word whose next word needs to be predicted. - **Output**: - Returns a string representing the next word based on the transition probabilities. Returns `None` if the current word has no subsequent state defined. 2. `generate_sentence(chain: dict, starting_word: str, length: int) -> list` - **Description**: Generate a sequence of words starting from a given word using the Markov Chain for a specified length. - **Input**: - `chain` (dict): A dictionary representing the Markov Chain. - `starting_word` (str): The word to start the sequence from. - `length` (int): The number of words to generate in the sequence. - **Output**: - Returns a list of words representing the sequence generated. Provide efficient implementations for both functions with proper error handling. Constraints - You can assume the chain dictionary is well-formed with valid transition probabilities that sum up to 1. - The minimum length of the generated sequence will be 1. - The chain dictionary can have up to 1000 distinct words, and each word can have up to 100 subsequent words. # Example Input ```python chain = { \'hello\': {\'world\': 0.5, \'there\': 0.5}, \'world\': {\'hello\': 1.0}, \'there\': {\'world\': 1.0} } starting_word = \'hello\' length = 5 ``` Output ```python [\'hello\', \'there\', \'world\', \'hello\', \'world\'] ``` The output may vary based on the probabilistic choices made by the Markov Chain.","solution":"import random def predict_next_word(chain, current_word): Predict the next word based on the given Markov Chain and the current word. Args: chain (dict): A dictionary representing the Markov Chain. current_word (str): The current word whose next word needs to be predicted. Returns: str: The next word based on the transition probabilities. Returns None if the current word has no subsequent state. if current_word not in chain: return None next_words = chain[current_word] words, probabilities = zip(*next_words.items()) next_word = random.choices(words, probabilities)[0] return next_word def generate_sentence(chain, starting_word, length): Generate a sequence of words starting from a given word using the Markov Chain for a specified length. Args: chain (dict): A dictionary representing the Markov Chain. starting_word (str): The word to start the sequence from. length (int): The number of words to generate in the sequence. Returns: list: A list of words representing the sequence generated. sentence = [starting_word] current_word = starting_word for _ in range(length - 1): next_word = predict_next_word(chain, current_word) if next_word is None: break sentence.append(next_word) current_word = next_word return sentence"},{"question":"# Question: You are given an undirected graph represented by an adjacency list. Write a function `is_bipartite(adj_list)` which determines whether the graph is bipartite. A bipartite graph can be colored using two colors such that no two adjacent vertices have the same color. Function Signature: ```python def is_bipartite(adj_list: List[List[int]]) -> bool: ``` Input: - `adj_list`: A 2-dimensional list `adj_list`, where `adj_list[i]` contains a list of vertices adjacent to vertex `i`. Output: - A boolean value `True` if the graph is bipartite, otherwise `False`. Constraints: - The graph does not contain any self-loops. - The number of vertices (|V|) is between 1 and 1000. - The number of edges is between 0 and 5000. - The graph may have disconnected components. Performance Requirements: - The solution should operate within O(|E| + |V|) time complexity and O(|V|) space complexity. # Example: Example 1: Input: ``` adj_list = [ [1, 3], [0, 2], [1, 3], [0, 2] ] ``` Output: ``` True ``` Example 2: Input: ``` adj_list = [ [1, 2, 3], [0, 2], [0, 1, 3], [0, 2] ] ``` Output: ``` False ``` # Explanation: - In Example 1, the graph can be colored as follows: Vertex 0 - Color 0, Vertex 1 - Color 1, Vertex 2 - Color 0, Vertex 3 - Color 1. No two adjacent vertices have the same color, thus it is bipartite. - In Example 2, no possible 2-coloring exists that ensures no two adjacent vertices share the same color, thus it is not bipartite. Implement the function to check if the graph is bipartite.","solution":"from typing import List def is_bipartite(adj_list: List[List[int]]) -> bool: def bfs(node): queue = [node] colors[node] = 0 # Start coloring the first node with 0 while queue: current = queue.pop(0) for neighbor in adj_list[current]: if colors[neighbor] == -1: # If the neighbor has not been colored yet colors[neighbor] = 1 - colors[current] # Assign opposite color queue.append(neighbor) elif colors[neighbor] == colors[current]: # If neighbor has the same color return False return True n = len(adj_list) colors = [-1] * n # -1 indicates uncolored for i in range(n): if colors[i] == -1: # If the node has not been colored yet if not bfs(i): return False return True"},{"question":"Scenario You are a software engineer at a company that manages vast inventories of data. To maintain the efficiency of sorting operations on mid-sized datasets (e.g., records retrieved from a disk cache before detailed processing), your team decided to implement Shell Sort due to its simplicity and effectiveness on such datasets. Task Implement the shell sort algorithm in Python. Your function should take a list of integers and return a sorted list in ascending order. Requirements 1. **Function Signature**: ```python def shell_sort(arr: list[int]) -> list[int]: ``` 2. **Input**: * A list of integers `arr` with 0 <= len(arr) <= 10^4. 3. **Output**: * A list of integers sorted in ascending order. 4. **Constraints**: * You must implement the function in-place. * You can assume all elements of `arr` are within the range -10^9 <= arr[i] <= 10^9. 5. **Performance Requirements**: * The solution should execute within reasonable time limits for the provided constraints. * Prioritize ensuring the correctness and efficiency of the chosen gap sequence. Example Usage *Example 1*: ```python input: arr = [12, 34, 54, 2, 3] output: [2, 3, 12, 34, 54] ``` *Example 2*: ```python input: arr = [] output: [] ``` *Example 3*: ```python input: arr = [1] output: [1] ``` *Example 4*: ```python input: arr = [5, -1, 3, 0] output: [-1, 0, 3, 5] ```","solution":"def shell_sort(arr: list[int]) -> list[int]: This function sorts a list of integers in ascending order using the shell sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"# Question: Implement Enhanced Bubble Sort with Early Stopping You are provided with a basic implementation of the Bubble Sort algorithm which sorts a list of integers in ascending order. The algorithm also has an optional `simulation` parameter to visualize each iteration. Task Write an enhanced version of the `bubble_sort` function called `enhanced_bubble_sort` that achieves the following improvements: 1. Include an early stopping mechanism where the algorithm stops if it performs a complete pass without any swaps (already included in the provided code). 2. Further optimize the algorithm by stopping the inner loop earlier for already sorted sections towards the end of the list. 3. The function should still support the `simulation` parameter to visualize the inner workings of the sort. Function Signature ```python def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` Input - `arr`: A list of integers. - `simulation`: A boolean flag. If `True`, print the array at each iteration to visualize the sorting process. Default is `False`. Output - Return the sorted list in ascending order. Constraints - The list can contain between 0 and 1000 integers. - Each integer is in the range `-10^6 to 10^6`. Example ```python arr = [64, 34, 25, 12, 22, 11, 90] print(enhanced_bubble_sort(arr, True)) # Expected Output: # iteration 0 : 64 34 25 12 22 11 90 # iteration 1 : 34 64 25 12 22 11 90 # iteration 2 : 34 25 64 12 22 11 90 # iteration 3 : 34 25 12 64 22 11 90 # iteration 4 : 34 25 12 22 64 11 90 # iteration 5 : 34 25 12 22 11 64 90 # iteration 6 : 25 34 12 22 11 64 90 # iteration 7 : 25 12 34 22 11 64 90 # iteration 8 : 25 12 22 34 11 64 90 # iteration 9 : 25 12 22 11 34 64 90 # iteration 10 : 12 25 22 11 34 64 90 # iteration 11 : 12 22 25 11 34 64 90 # iteration 12 : 12 22 11 25 34 64 90 # iteration 13 : 12 11 22 25 34 64 90 # iteration 14 : 11 12 22 25 34 64 90 # [11, 12, 22, 25, 34, 64, 90] ```","solution":"from typing import List def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] # swap swapped = True if simulation: print(f\\"iteration {n*(n-i-1) + j} : {\' \'.join(map(str, arr))}\\") if not swapped: break return arr"},{"question":"**Context**: You are tasked with implementing a variant of the Hash Table data structure. Apart from the basic functionalities such as insertion, deletion, and retrieval, you are required to implement an additional feature to support `key expiration`. Each key should have a `time-to-live (TTL)` value, upon which the key should be automatically expired and removed from the hash table. **Features to Implement**: 1. **Insertion**: Insert a key-value pair with an optional TTL value. If TTL is provided, the key should expire after TTL milliseconds. 2. **Get**: Retrieve the value associated with the key if it hasn\'t expired. 3. **Deletion**: Remove the key-value pair manually. 4. **Automatic Expiration**: The expired keys should be removed automatically from the hash table. **Input and Output Formats**: * **Input**: - `put(key, value, ttl)`: * `key`: Integer - The key to be inserted. * `value`: The data to be stored. * `ttl`: Integer - Optional Time-to-live in milliseconds (negative or 0 should be treated as no expiration). - `get(key)`: * `key`: Integer - The key to retrieve. - `del_(key)`: * `key`: Integer -The key to delete. - `expired_cleanup()`: * This function should be called to remove all expired keys. * **Output**: - `put`: No output. - `get`: Returns the value associated with the key or `None` if the key is not present or has expired. - `del_`: No output. - `expired_cleanup`: No output. **Constraints**: * Maximum number of keys is limited to 10^5. * TTL values are between 1 to 86400000 milliseconds (24 hours). * Keys are unique integers. **Performance Requirements**: * Average time complexity for `put`, `get`, `del_`: O(1). * Automatic expiration check should not degrade performance significantly. **Implementation Details**: ```python import time class ExpiringHashTable(HashTable): def __init__(self): super().__init__() # Store TTL values and insertion times self._ttls = [self._empty] * self.size self._insert_times = [self._empty] * self.size def put(self, key, value, ttl=-1): # Store current time current_time = int(time.time() * 1000) # Current time in milliseconds initial_hash = hash_ = self.hash(key) while True: if self._keys[hash_] is self._empty or self._keys[hash_] is self._deleted: # can assign to hash_ index self._keys[hash_] = key self._values[hash_] = value self._ttls[hash_] = ttl if ttl > 0 else None self._insert_times[hash_] = current_time if ttl > 0 else None self._len += 1 return elif self._keys[hash_] == key: # key already exists here, assign over self._keys[hash_] = key self._values[hash_] = value self._ttls[hash_] = ttl if ttl > 0 else None self._insert_times[hash_] = current_time if ttl > 0 else None return hash_ = self._rehash(hash_) if initial_hash == hash_: # table is full raise ValueError(\\"Table is full\\") def get(self, key): self.expired_cleanup() return super().get(key) def del_(self, key): self.expired_cleanup() return super().del_(key) def expired_cleanup(self): current_time = int(time.time() * 1000) # Current time in milliseconds for i in range(self.size): if self._keys[i] is not self._empty and self._keys[i] is not self._deleted: if self._ttls[i] is not None and current_time - self._insert_times[i] > self._ttls[i]: # Key has expired self._keys[i] = self._deleted self._values[i] = self._deleted self._ttls[i] = self._empty self._insert_times[i] = self._empty self._len -= 1 def __resize(self): keys, values, ttls, insert_times = self._keys, self._values, self._ttls, self._insert_times self.size *= 2 # this will be the new size self._len = 0 self._keys = [self._empty] * self.size self._values = [self._empty] * self.size self._ttls = [self._empty] * self.size self._insert_times = [self._empty] * self.size for key, value, ttl, insert_time in zip(keys, values, ttls, insert_times): if key is not self._empty and key is not self._deleted: self.put(key, value, ttl) self._insert_times[self.hash(key)] = insert_time # Usage: hash_table = ExpiringHashTable() hash_table.put(1, \\"a\\", 5000) print(hash_table.get(1)) # Should print \\"a\\" if within 5 seconds time.sleep(5) print(hash_table.get(1)) # Should print None after 5 seconds ```","solution":"import time class ExpiringHashTable: def __init__(self): self._table = {} self._expiry_times = {} def put(self, key, value, ttl=-1): current_time = int(time.time() * 1000) # Current time in milliseconds self._table[key] = value if ttl > 0: expiry_time = current_time + ttl self._expiry_times[key] = expiry_time elif key in self._expiry_times: del self._expiry_times[key] def get(self, key): self.expired_cleanup() return self._table.get(key, None) def del_(self, key): self.expired_cleanup() if key in self._table: del self._table[key] if key in self._expiry_times: del self._expiry_times[key] def expired_cleanup(self): current_time = int(time.time() * 1000) # Current time in milliseconds expired_keys = [ key for key, expiry_time in self._expiry_times.items() if current_time >= expiry_time ] for key in expired_keys: del self._table[key] del self._expiry_times[key]"},{"question":"Graph Path Enumeration You are provided with a series of graph traversal functions that compute various types of paths between nodes in a graph. Your task is to implement an additional function to solve the following problem effectively. # Objective: Design a function `find_k_shortest_paths(graph, start, end, k)` that finds up to \'k\' shortest unique paths between two nodes in a graph. The function should return a list of paths sorted by their lengths, starting from the shortest. # Input and Output: - **Input**: - `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. - `start` & `end`: The identifiers of the start and end nodes respectively. - `k`: An integer representing the number of shortest paths desired. - **Output**: - A list of lists, where each inner list is a path (sequence of nodes) from `start` to `end`. # Constraints: - The graph is represented as an adjacency list, and all node identifiers are unique strings. - 1 <= k <= 10 - The provided graph may have cycles; handle them appropriately. # Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } start = \'A\' end = \'D\' k = 3 find_k_shortest_paths(graph, start, end, k) # Output: [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] ``` # Requirements: - Ensure your solution handles graphs where no paths exist between `start` and `end`. - Optimize the function to efficiently handle larger graphs, avoiding deep recursion if possible. - Incorporate relevant edge cases, including invalid nodes, cyclical paths, and disconnected subgraphs.","solution":"import heapq def find_k_shortest_paths(graph, start, end, k): Finds up to \'k\' shortest unique paths between start and end nodes in the graph and returns them sorted by their lengths. def bfs_paths(graph, start, end): A generator to find all paths between start and end using BFS. queue = [(start, [start])] while queue: (vertex, path) = queue.pop(0) for next in graph.get(vertex, []): if next in path: continue elif next == end: yield path + [next] else: queue.append((next, path + [next])) all_paths = list(bfs_paths(graph, start, end)) sorted_paths = sorted(all_paths, key=len) # sorting all paths by length return sorted_paths[:k] # returning up to k shortest paths"},{"question":"# Scenario Imagine you are organizing a trek and need to pack your backpack to maximize the value of the items you can carry without exceeding the backpack\'s weight capacity. Each item has a specific weight and value, and you can\'t split items. Write a function to determine the maximum value of items that can be placed in the backpack. # Function Signature ```python def optimize_backpack(items: List[Tuple[int, int]], capacity: int) -> int: items: List of tuples where each tuple represents an item, the first element is the value and the second element is the weight. capacity: Integer representing the maximum weight capacity of the backpack. Returns: Integer representing the maximum value that can be obtained without exceeding the capacity. ``` # Input * `items` List[Tuple[int, int]]: A list where each tuple contains two integers: the first integer is the value of the item, and the second integer is the weight of the item. * `capacity` int: An integer `0 <= capacity <= 1000`, representing the capacity constraint of the backpack. # Output * Integer representing the maximum value of items that can fit into the backpack without exceeding its weight capacity. # Constraints * Number of items, `n`: `0 <= n <= 100` * The value and weight of each item: each an integer in the range `[1, 1000]`. # Example ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert optimize_backpack(items, capacity) == 80 # Items with value 50 and 30 can be selected items = [(100, 3), (90, 2), (60, 1), (40, 2)] capacity = 5 assert optimize_backpack(items, capacity) == 190 # Items with value 100 and 90 can be selected items = [] capacity = 10 assert optimize_backpack(items, capacity) == 0 # No items to select from items = [(10, 2), (20, 3), (30, 5)] capacity = 0 assert optimize_backpack(items, capacity) == 0 # No capacity to carry any items ```","solution":"def optimize_backpack(items, capacity): Determine the maximum value of items that can be placed in the backpack without exceeding the capacity. Args: items (List[Tuple[int, int]]): List of items where each item is represented as a tuple (value, weight). capacity (int): Maximum weight capacity of the backpack. Returns: int: Maximum value that can be obtained without exceeding the capacity. n = len(items) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): value, weight = items[i - 1] if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"You are tasked with writing a function to assess whether numbers in a given list are prime numbers. The function should return a list of booleans corresponding to the primality of each number. This problem will evaluate your understanding of the primality test algorithm and your ability to handle edge cases and optimize performance for a list of numbers. # Function Signature ```python def list_prime_check(lst: List[int]) -> List[bool]: Determine the primality of each number in the input list. Args: lst (List[int]): A list of integers to be checked for primality. Returns: List[bool]: A list of booleans where each boolean corresponds to whether a number in the input list is prime. ``` # Input - A list of integers `lst`, where (0 leq text{len}(lst) leq 10^6) and (|text{lst}[i]| leq 10^9). # Output - A list of booleans of the same length as `lst`, where each boolean indicates if the corresponding integer in `lst` is a prime number (`True` if prime, `False` otherwise). # Requirements - The solution should aim for efficient computation, considering the given input constraints. - Pay attention to edge cases like negative numbers, zero, small primes, and limit cases (e.g., very large positive numbers). # Example ```python assert list_prime_check([10, 3, 2, 17, 20, -5]) == [False, True, True, True, False, False] ``` # Constraints - You must not use library functions for prime checking. - The code should be well-commented and readable. - Aim for a solution that runs in reasonable time for the upper limit of input constraints.","solution":"def list_prime_check(lst): Determine the primality of each number in the input list. Args: lst (List[int]): A list of integers to be checked for primality. Returns: List[bool]: A list of booleans where each boolean corresponds to whether a number in the input list is prime. def is_prime(n): Helper function to check if a single number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True return [is_prime(num) for num in lst]"},{"question":"You are tasked with writing a function to determine the height of a Binary Search Tree (BST). The height is the number of edges on the longest path from the root node to a leaf. An empty tree has height 0, a tree with one node (root) has height 1, and so on. # Function Signature ```python def height(root) -> int: pass ``` # Input - The `root` node of a BST. If the tree is empty, `root` will be `None`. # Output - An integer representing the height of the tree. # Constraints - You can assume the number of nodes in the tree is less than (10^5). - The values in the tree nodes are within the range [-10^9, 10^9]. # Example Given the following binary search tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` Calling `height` with the root node should return `4`. # Additional Requirements Implement the solution in a way that: - Handles the edge case of an empty tree. - Handles a tree with only a single node. - Consider the constraints of large tree sizes in regards to recursion depth. - You must write unit tests to validate your implementation using a variety of tree structures. Example Unit Test ```python import unittest class TestHeight(unittest.TestCase): def setUp(self): self.tree = bst() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) # other example tests with different tree structures if __name__ == \\"__main__\\": unittest.main() ``` You may use additional helper functions or classes as needed, but the primary function should be `height`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def height(root) -> int: if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"You have been tasked to implement an efficient sorting function for a list of integers using the Comb Sort algorithm. Comb Sort is an enhancement of Bubble Sort that uses a larger gap between elements being compared, which is gradually reduced until it becomes 1. It sorts the list by swapping out-of-order elements. Implement the function `comb_sort(arr: List[int]) -> List[int]` that sorts a given list of integers in ascending order using Comb Sort algorithm. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers with length `n` (0 <= n <= 10^5) # Output - Return the sorted list in ascending order. # Constraints - The list may contain duplicates. - The algorithm should be implemented in-place; hence, the extra space used should be O(1). - Aim for average-case time complexity of O(N log N). # Example ```python print(comb_sort([3, 6, 1, 2, 9, 7])) # Output: [1, 2, 3, 6, 7, 9] print(comb_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] print(comb_sort([7, 4, 4, 8, 1])) # Output: [1, 4, 4, 7, 8] print(comb_sort([])) # Output: [] print(comb_sort([1])) # Output: [1] ``` # Additional Requirements - Ensure your implementation is efficient and handles edge cases properly, such as: - Sorting an empty list. - Sorting a list where all elements are the same. - Sorting a list with one element. # Hints - Reduce the gap size using the shrink factor (typically 1.3) until it becomes 1. - Carefully handle the swapping of elements considering the shrinking gap.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: Sort the list using Comb Sort algorithm. def get_next_gap(gap): # Shrink gap by shrink factor 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"You are given an array of integers, and your task is to implement an efficient sorting algorithm based on the Comb Sort principles. The function `efficient_comb_sort` should refine the basic Comb Sort by integrating optimizations discussed in the analysis. # Function Signature ```python def efficient_comb_sort(arr: list[int]) -> list[int]: pass ``` # Input * `arr` (list): An unsorted list of integers. # Output * Returns a sorted list of integers. # Constraints * The list `arr` will contain between 0 and 10^6 elements. * Each integer in `arr` can be in the range from -10^6 to 10^6. # Requirements 1. **Optimization**: Improve the basic Comb Sort by choosing an optimal shrink factor tailored for typical datasets. 2. **Integration**: For the final pass, once the gap reduces to 1, combine with an insertion sort to efficiently finish the sorting. 3. **Edge Cases**: Handle empty arrays and arrays with one element effectively. # Example ```python arr1 = [5, 3, 4, 1, 2] arr2 = [12, 4, 11, 3, 5, 2, 1, 10] print(efficient_comb_sort(arr1)) # Output: [1, 2, 3, 4, 5] print(efficient_comb_sort(arr2)) # Output: [1, 2, 3, 4, 5, 10, 11, 12] ``` # Additional Notes * Consider performance optimizations and handle large input sizes efficiently. * Ensure you thoroughly test your code with edge cases like sorted arrays, arrays with duplicate elements, and very large arrays.","solution":"def efficient_comb_sort(arr): Efficiently sorts a list using an improved version of the Comb Sort algorithm. if not arr: return arr def insertion_sort(arr): n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr n = len(arr) gap = n shrink_factor = 1.3 sorted = False while not sorted: # Update the gap for the next comb gap = int(gap // shrink_factor) if gap <= 1: gap = 1 sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return insertion_sort(arr)"},{"question":"**Problem Statement:** You are given a Segment Tree data structure that supports range queries. Your task is to implement the `update` method, which efficiently updates a value in the original array and propagates the changes through the segment tree. # Function Signature: ```python def update(index: int, value: int) -> None: ``` # Input: * `index` (int): The index in the original array that needs to be updated. * `value` (int): The new value to be assigned to the `index` in the original array. # Output: * The function should not return any value. It should update the segment tree in place. # Constraints: * The index will always be valid (0 <= `index` < length of the original array). * The value will be a valid integer. # Example: ```python # Consider the initial array is [2, 4, 5, 3, 4] and the function is `max` mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(0, 4)) # Output should be 5 mytree.update(1, 6) # Update index 1 to the value 6 print(mytree.query(0, 4)) # Output should be 6 because we updated index 1 to 6 mytree.update(3, 7) # Update index 3 to the value 7 print(mytree.query(0, 4)) # Output should be 7 because we updated index 3 to 7 ``` # Performance Requirement: * The `update` function should operate in O(log N) time, where N is the number of elements in the original array. # Notes: * Ensure to handle edge cases like updating the first or last element of the array. * Consider using recursion or iteration as needed to update the values efficiently. Implement the `update` method in the `SegmentTree` class provided. ```python class SegmentTree: def __init__(self, arr, function): self.segment = [0 for x in range(3 * len(arr) + 3)] self.arr = arr self.fn = function self.make_tree(0, 0, len(arr) - 1) def make_tree(self, i, l, r): if l == r: self.segment[i] = self.arr[l] elif l < r: self.make_tree(2 * i + 1, l, int((l + r) / 2)) self.make_tree(2 * i + 2, int((l + r) / 2) + 1, r) self.segment[i] = self.fn( self.segment[2 * i + 1], self.segment[2 * i + 2]) def __query(self, i, L, R, l, r): if l > R or r < L or L > R or l > r: return None if L >= l and R <= r: return self.segment[i] val1 = self.__query(2 * i + 1, L, int((L + R) / 2), l, r) val2 = self.__query(2 * i + 2, int((L + R + 2) / 2), R, l, r) if val1 != None: if val2 != None: return self.fn(val1, val2) return val1 return val2 def query(self, L, R): return self.__query(0, 0, len(self.arr) - 1, L, R) def update(self, index, value): # Your implementation goes here pass ```","solution":"class SegmentTree: def __init__(self, arr, function): self.segment = [0 for x in range(3 * len(arr) + 3)] self.arr = arr self.fn = function self.make_tree(0, 0, len(arr) - 1) def make_tree(self, i, l, r): if l == r: self.segment[i] = self.arr[l] elif l < r: self.make_tree(2 * i + 1, l, int((l + r) / 2)) self.make_tree(2 * i + 2, int((l + r) / 2) + 1, r) self.segment[i] = self.fn( self.segment[2 * i + 1], self.segment[2 * i + 2]) def __query(self, i, L, R, l, r): if l > R or r < L or L > R or l > r: return None if L >= l and R <= r: return self.segment[i] val1 = self.__query(2 * i + 1, L, int((L + R) / 2), l, r) val2 = self.__query(2 * i + 2, int((L + R + 2) / 2), R, l, r) if val1 != None: if val2 != None: return self.fn(val1, val2) return val1 return val2 def query(self, L, R): return self.__query(0, 0, len(self.arr) - 1, L, R) def __update_util(self, i, l, r, index, value): if l == r: self.segment[i] = value self.arr[index] = value else: mid = (l + r) // 2 if index <= mid: self.__update_util(2 * i + 1, l, mid, index, value) else: self.__update_util(2 * i + 2, mid + 1, r, index, value) self.segment[i] = self.fn(self.segment[2 * i + 1], self.segment[2 * i + 2]) def update(self, index, value): self.__update_util(0, 0, len(self.arr) - 1, index, value)"},{"question":"# Scenario You are tasked with processing log entries from a server. Due to concerns about storage space and the relevance of the logs, you need to limit how many times each type of log entry appears in the final report. Write a function that processes a list of log entries and limits each unique entry to a specified maximum number of occurrences, while preserving their order. # Task Implement the function `limit_occurrences(logs: List[str], n: int) -> List[str]` that takes in a list of log entries (strings) and an integer (N). The function should return a new list with each log entry appearing at most (N) times, in the order they appeared. # Input - `logs`: A list of strings representing log entries. ( (1 leq text{len(logs)} leq 10^5) ) - `n`: An integer representing the maximum occurrences for each log entry. ( (0 leq n leq 10^5) ) # Output - A list of strings representing the filtered log entries. # Constraints - Maintain the original order of log entries. - Ensure each log entry appears at most (N) times in the output. # Examples ```python # Example 1: logs = [\\"error\\", \\"info\\", \\"error\\", \\"warning\\", \\"error\\", \\"info\\", \\"error\\", \\"warning\\"] n = 2 # Output: [\\"error\\", \\"info\\", \\"error\\", \\"warning\\", \\"info\\", \\"warning\\"] # Example 2: logs = [\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"a\\"] n = 1 # Output: [\\"a\\", \\"b\\", \\"c\\"] # Example 3: logs = [] n = 1 # Output: [] # Example 4: logs = [\\"log1\\"] n = 0 # Output: [] ``` # Requirements - The implementation must run efficiently, ideally in ( O(n) ) time. # Notes - You may use collections.defaultdict for counting log entries.","solution":"from collections import defaultdict from typing import List def limit_occurrences(logs: List[str], n: int) -> List[str]: Limit occurrences of each log entry to at most n times. Arguments: logs -- List of log entries. n -- Maximum number of occurrences for each log entry. Returns: A new list with each log entry appearing at most n times. entry_count = defaultdict(int) result = [] for log in logs: if entry_count[log] < n: result.append(log) entry_count[log] += 1 return result"},{"question":"Enhanced Linear Search with Boundary Check You are given an array of integers and a target value to search for. Implement a function that performs a linear search on the array but also includes boundary checks to avoid out-of-bound errors. You need to ensure that your function executes safely and efficiently, even with extreme inputs. Your task is to write a function `safe_linear_search` with the following signature: ```python def safe_linear_search(array: list[int], query: int) -> int: Return the index of the first occurrence of the query in the array, or -1 if not found. ``` Input/Output: - **Input:** - `array`: A list of integers where the search is to be conducted. It can be empty. - `query`: An integer value you want to find in the array. - **Output:** - An integer that is the index of the first occurrence of `query` in `array`. Returns -1 if the query is not found. # Example: ```python assert safe_linear_search([10, 23, 5, -4, 8, 23], 23) == 1 assert safe_linear_search([10, 23, 5, -4, 8, 23], 4) == -1 assert safe_linear_search([], 23) == -1 assert safe_linear_search([1, 2], 2) == 1 assert safe_linear_search([1, 2], 1) == 0 assert safe_linear_search([1, 2], 3) == -1 ``` Constraints: - The array can have up to (10^6) elements. - The elements of the array are integers in the range (-10^9) to (10^9). Task: Implement the `safe_linear_search` function ensuring that: 1. The function handles edge cases like empty arrays. 2. The function avoids any potential out-of-bound errors. 3. Your implementation should be efficient within the context of linear search, considering it\'s a scan-based approach.","solution":"def safe_linear_search(array: list[int], query: int) -> int: Return the index of the first occurrence of the query in the array, or -1 if not found. for index, value in enumerate(array): if value == query: return index return -1"},{"question":"Implementing and Testing Enhanced RandomizedSet Background You\'ve been provided with a custom data structure `RandomizedSet` that supports insertion, deletion, and random element retrieval all in average O(1) time. Your task is to enhance this class to track and return the most frequently accessed (randomly drawn) elements efficiently. Modify the class to store this frequency information and add an additional operation: - **most_frequent()**: Returns a list of the most frequently accessed elements. If multiple elements have the same frequency, return all of them. Implementation Requirements: 1. **Class Definition**: Modify the `RandomizedSet` class provided in the code snippet. 2. **New Method**: - Define the method `most_frequent` with no arguments. - It should return a list of the most frequently accessed elements. 3. **Ensure**: - Your implementation still supports `insert`, `remove`, and `random_element` operations in O(1) average time. - The `most_frequent` method should have an expected time complexity of O(1). Input and Output Formats: - **Expected Input**: Not applicable as this is a class-based implementation. - **Expected Output**: Not applicable, but you should be able to instantiate the class and call the methods with sample inputs to verify its functionality. Scenario: To validate your implementation, enhance the test function `__test` provided in the code snippet to: 1. Insert 100 unique random numbers into the set. 2. Perform 150 random element retrievals. 3. Remove 50 random elements. 4. Confirm the state of the set is as expected. 5. Call `most_frequent` and print the results. Constraints: - Assume the range of inserted elements is within typical integer values. - You are free to use Python\'s standard libraries. Example: ```python rset = RandomizedSet() rset.insert(1) rset.insert(2) print(rset.most_frequent()) # Assuming no elements have been accessed yet, this could return an empty list. rset.random_element() # Suppose it returns 1 print(rset.most_frequent()) # Should return [1] as it\'s the only accessed element. ```","solution":"import random from collections import defaultdict, Counter class RandomizedSet: def __init__(self): self.vals = [] self.vals_set = {} self.access_counter = Counter() def insert(self, val): if val in self.vals_set: return False self.vals.append(val) self.vals_set[val] = len(self.vals) - 1 return True def remove(self, val): if val in self.vals_set: last_element = self.vals[-1] idx = self.vals_set[val] self.vals[idx] = last_element self.vals_set[last_element] = idx self.vals.pop() del self.vals_set[val] if val in self.access_counter: del self.access_counter[val] return True return False def random_element(self): if not self.vals: return None val = random.choice(self.vals) self.access_counter[val] += 1 return val def most_frequent(self): if not self.access_counter: return [] max_freq = max(self.access_counter.values()) return [val for val, freq in self.access_counter.items() if freq == max_freq]"},{"question":"**Context**: You are tasked with creating a search function that efficiently finds the first occurrence of a specific element within a sorted array. This capability is essential for various applications such as database querying, computer graphics, and real-time systems where timely responses are critical. **Problem Statement**: Write a function `first_occurrence(array, query)` that searches for the first occurrence of a given element (`query`) in a sorted array (`array`). The array provided will be sorted in increasing order. If the `query` element is found, return its index. If not found, return `-1`. **Function Signature**: ```python def first_occurrence(array: list[int], query: int) -> int: pass ``` **Input**: - `array`: A list of integers, sorted in increasing order. - `query`: An integer to find in the array. **Output**: - Return the index of the first occurrence of `query` in `array` if present. - Return `-1` if `query` is not found. **Constraints**: - The array can have a length between 0 and 10^6. - Each element in the `array` can be an integer between -10^9 and 10^9. **Example**: ```python print(first_occurrence([1, 2, 2, 4, 5], 2)) # Output: 1 print(first_occurrence([1, 2, 3, 4, 5], 6)) # Output: -1 print(first_occurrence([], 2)) # Output: -1 print(first_occurrence([5, 5, 5, 5], 5)) # Output: 0 print(first_occurrence([1, 3, 3, 3, 5], 3)) # Output: 1 ``` **Performance Requirements**: - The solution should run with an expected time complexity of O(log n) and space complexity of O(1).","solution":"def first_occurrence(array: list[int], query: int) -> int: Finds the first occurrence of the query in the sorted array. If the query is found, returns its index. Otherwise, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # Continue to search in the left half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Context You are analyzing a dataset of temperatures recorded for a month at hourly intervals. To understand the temperature variations, you want to find the maximum temperature observed in every contiguous sub-array of a given length `k`. # Task Write a function `max_sliding_window(arr, k)` that takes an array `arr` of temperature readings and an integer `k`, and returns a list of the maximum temperatures in each sub-array of length `k`. # Input * `arr`: List of integers representing temperatures. (1 <= len(arr) <= 10^5) * `k`: Integer representing the length of the sub-array. (1 <= k <= len(arr)) # Output Return a list of integers representing the maximum temperatures of every sub-array of length `k`. # Constraints * The input parameters will always be valid. * The temperatures can be negative or positive. # Example ```python # Example 1 arr = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 # Output: [3, 3, 5, 5, 6, 7] # Example 2 arr = [9, 2, 3, 1, 8, 5, 6, 4] k = 4 # Output: [9, 8, 8, 8, 8] ``` # Note - For the example 1, the function calculates the maximum values in each window of length 3: * For window [1, 3, -1], max = 3 * For window [3, -1, -3], max = 3 * For window [-1, -3, 5], max = 5 * And so on...","solution":"from collections import deque def max_sliding_window(arr, k): Returns a list of maximum temperatures observed in each sub-array of length k from the given array of temperatures. if not arr or k == 0: return [] n = len(arr) if k == 1: return arr # Every element is a max in window of length 1. deq = deque() result = [] for i in range(n): # Remove elements not relevant to the current window if deq and deq[0] == i - k: deq.popleft() # Remove all elements less than the current element from the deque while deq and arr[deq[-1]] < arr[i]: deq.pop() # Add the current element index to the deque deq.append(i) # Append the maximum for the current window to the result if i >= k - 1: result.append(arr[deq[0]]) return result"},{"question":"# Question: Array-Represented Number Increment You are given a non-negative number represented as an array of its digits. The most significant digit is at the head of the list. Write a function `increment_number` that increments the number by one and returns the resulting array of digits. You need to handle cases where the number has multiple `9`s and ensure that carry overflows. # Constraints: * The input array consists of non-negative single-digit integers (0-9). * The array will not be empty. # Input: * List of digits representing the number `(digits: List[int])`. # Output: * List of digits representing the resulting number after incrementing by one. # Examples: ```python increment_number([1, 2, 3]) # Output: [1, 2, 4] increment_number([9]) # Output: [1, 0] increment_number([9, 9, 9]) # Output: [1, 0, 0, 0] ``` # Requirements: * Time Complexity: O(n), where n is the number of digits. * Space Complexity: O(1). # Tasks: 1. Write function `increment_number` that meets the requirements. 2. Handle edge cases such as arrays of `9`s. 3. Avoid creating a new list unnecessarily if it can be done in-place.","solution":"def increment_number(digits): Increment the number represented by the digits array by one. Args: digits (List[int]): Array of digits representing the number. Returns: List[int]: Resulting array of digits after incrementing by one. n = len(digits) # Traverse the digits from the end to start for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: digits[i] = 0 # If all digits were 9, we need an extra digit at the beginning return [1] + digits"},{"question":"# Question: Finding the Nearest Neighbor Context: You are a data scientist for a company that develops location-based services. Your current project involves optimizing the search for the nearest point of interest (POI) to any given user\'s location. To accomplish this, you\'ve decided to implement the Nearest Neighbor Algorithm. Task: Implement a function `nearest_poi` that takes a user\'s location given as a tuple of coordinates, and a dataset of POIs, represented as a dictionary where keys are tuples of coordinates and values are the names of the POIs. Function Signature: ```python def nearest_poi(user_location: tuple, poidb: dict) -> str: ``` Input: * **user_location**: A tuple with 2 or more integer/float coordinates representing the user\'s current location. * **poidb**: A dictionary where keys are tuples of 2 or more integer/float coordinates (each coordinate tuple representing a POI location), and values are strings (the names of the POIs). Output: * **Nearest POI**: A string representing the name of the POI nearest to the user\'s location. Constraints: * The length of the user location tuple and each coordinate tuple in POI dataset will be the same. * You may assume that there is at least one POI in the database. Example: ```python user_location = (1.0, 2.0) poidb = { (1.5, 2.5): \\"Cafe\\", (3.0, 4.0): \\"Library\\", (0.0, 1.0): \\"Gym\\" } assert nearest_poi(user_location, poidb) == \\"Cafe\\" user_location = (2, 3) poidb = { (5, 8): \\"Supermarket\\", (1, 2): \\"Park\\", (4, 5): \\"Office\\" } assert nearest_poi(user_location, poidb) == \\"Park\\" ``` Performance: * Time Complexity: The solution should aim to be efficient with a complexity of O(n * m), where \'n\' is the number of POIs, and \'m\' is the dimensionality of the points. * Space Complexity: The solution should utilize a fixed amount of space, O(1).","solution":"import math def nearest_poi(user_location, poidb): Finds the nearest Point of Interest (POI) to the user\'s location. Parameters ---------- user_location : tuple A tuple of coordinates representing the user\'s location. poidb : dict A dictionary where keys are tuples representing POI coordinates and values are strings representing POI names. Returns ------- closest_poi : str The name of the nearest POI to the user\'s location. # Calculate the Euclidean distance between two points def euclidean_distance(p1, p2): return math.sqrt(sum((p1_i - p2_i) ** 2 for p1_i, p2_i in zip(p1, p2))) closest_poi = None min_distance = float(\'inf\') for poi_coords, poi_name in poidb.items(): distance = euclidean_distance(user_location, poi_coords) if distance < min_distance: min_distance = distance closest_poi = poi_name return closest_poi"},{"question":"**Objective**: Write a function `calculate_totient_sum` that takes an integer x and returns the sum of Euler’s Totient function values for every integer from 1 to x inclusive. This will require understanding the principles of Euler\'s Totient function as analyzed. # Function Signature: ```python def calculate_totient_sum(x: int) -> int: pass ``` # Input: - An integer x (1 ≤ x ≤ 10^6). # Output: - An integer which is the sum of ϕ(i) for every i from 1 to x. # Example: ```python assert calculate_totient_sum(5) == 10 # Explanation: ϕ(1) = 1, ϕ(2) = 1, ϕ(3) = 2, ϕ(4) = 2, ϕ(5) = 4 # Sum = 1 + 1 + 2 + 2 + 4 = 10 assert calculate_totient_sum(10) == 32 # Explanation: ϕ(1) = 1, ϕ(2) = 1, ϕ(3) = 2, ϕ(4) = 2, ϕ(5) = 4, # ϕ(6) = 2, ϕ(7) = 6, ϕ(8) = 4, ϕ(9) = 6, ϕ(10) = 4 # Sum = 1 + 1 + 2 + 2 + 4 + 2 + 6 + 4 + 6 + 4 = 32 ``` # Constraints: - Ensure that the implementation is efficient and can handle the upper limit constraints (x ≤ 10^6). # Performance Requirements: - Must efficiently compute the totient function for large values of x within reasonable time limits due to the high upper constraint on x.","solution":"def calculate_totient_sum(x: int) -> int: # Initialize a list to store the totient values phi = list(range(x + 1)) # Implementing the totient function using a sieve approach for i in range(2, x + 1): if phi[i] == i: # i is a prime number for j in range(i, x + 1, i): phi[j] = phi[j] * (i - 1) // i # Summing up all the totient values from 1 to x return sum(phi)"},{"question":"# Remove Duplicates from a Singly Linked List In this task, you are given the head of a singly linked list. Your objective is to write a function that removes all duplicate values from the list such that only the first occurrence of each value remains. Implement the function `remove_duplicates(head: Node) -> Node` that modifies the linked list in place (i.e., without creating a copy) and returns the head of the modified list. The `Node` class is defined as follows: ```python class Node: def __init__(self, val=None): self.val = val self.next = None ``` # Input - `head`: The head node of the singly linked list. The list is not sorted and may contain any type of values as node data. # Output - Return the head node of the modified linked list with duplicates removed. # Constraints - The linked list can have up to (10^5) nodes. - The value of the nodes can be any data type. # Example ```python # Define nodes a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") # Link nodes a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Create function to remove duplicates and call it head = remove_duplicates(a1) # Convert list to string representation for verification print_linked_list(head) # Expected Output: A -> B -> C -> D -> F -> G ``` **Notes**: - You may assume that the input does not contain complex data structures requiring deep copies. - Ensure your solution handles typical edge cases like an empty list or lists with all nodes having non-unique values efficiently.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: if not head: return head current = head seen = set([current.val]) while current and current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head"},{"question":"# Binary Search Revisited You are required to implement the `binary_search` function in a unique and efficient way. This function should leverage the binary search algorithm to find the position of a target value in a sorted array. Additionally, implement a function `binary_search_range` to find the range (first and last occurrence) of a target value in a sorted array of integers. # Function Signature ```python def binary_search(array: List[int], query: int) -> int: pass def binary_search_range(array: List[int], query: int) -> Tuple[int, int]: pass ``` # Input * `array`: List of integers (sorted in ascending order). Example: [1, 2, 4, 4, 4, 5, 6] * `query`: Integer value to be searched for in the array. Example: 4 # Output * `binary_search`: Return the index of the query if found, otherwise return -1. * `binary_search_range`: Return a tuple with the start and end index of the query\'s range. If the query is not found, return (-1, -1). # Constraints * 1 ≤ len(array) ≤ 10^5 * -10^3 ≤ array[i], query ≤ 10^3 # Example ```python # Example for binary_search input: [1, 2, 3, 4, 5], 4 output: 3 input: [1, 2, 4, 4, 4, 5, 6], 4 output: 2 (or 3 or 4, any one of them) input: [1, 2, 3, 4, 5], 6 output: -1 # Example for binary_search_range input: [1, 2, 4, 4, 4, 5, 6], 4 output: (2, 4) input: [1, 2, 3, 4, 5], 6 output: (-1, -1) ``` # Notes * Implement `binary_search` using an iterative approach. * For `binary_search_range`, utilize the binary search method to find the leftmost and rightmost occurrences of the query value efficiently. * Ensure that the solution handles edge cases such as empty arrays and queries not present in the array.","solution":"from typing import List, Tuple def binary_search(array: List[int], query: int) -> int: left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: return mid elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1 def binary_search_range(array: List[int], query: int) -> Tuple[int, int]: def find_leftmost(array, query): left, right = 0, len(array) - 1 leftmost = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: leftmost = mid right = mid - 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return leftmost def find_rightmost(array, query): left, right = 0, len(array) - 1 rightmost = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: rightmost = mid left = mid + 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return rightmost leftmost_index = find_leftmost(array, query) rightmost_index = find_rightmost(array, query) if leftmost_index == -1 or rightmost_index == -1: return -1, -1 return leftmost_index, rightmost_index"},{"question":"# Scenario You are working on a robotics project where each robot explores a predefined binary tree of locations. Our goal is to determine the deepest location to the left, from the robot\'s point of view, that can be reached. You are tasked with implementing a function to find this location. # Task Implement the function `deepest_left_child(root)` that takes in the root node of a binary tree and returns the value of the deepest left child node. If there is no left child, the function should return `None`. # Function Signature ```python def deepest_left_child(root: TreeNode) -> int: pass ``` # Input * `root`: The root of the binary tree. # Output * The value of the deepest left child node. If there is no left child, return `None`. # Constraints * The binary tree will have no more than (10^4) nodes. * Node values are unique integers. # Example Given Binary Tree: ``` 1 / 2 3 / 4 5 6 7 ``` Function Call ```python deepest_left_child(root) # where `root` is the reference to the root of the above tree ``` Expected Output ``` 4 ``` # Explanation In the provided binary tree, the deepest node which is the left child of its parent is node `4`. # Notes * Consider edge cases like trees with only the root node or trees with no left children. * Aim for an efficient solution that handles large trees gracefully without stack overflow.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepest_left_child(root: TreeNode) -> int: if not root: return None from collections import deque queue = deque([(root, False)]) # (node, is_left) deepest_left_val = None while queue: node, is_left = queue.popleft() if is_left: deepest_left_val = node.val if node.right: queue.append((node.right, False)) if node.left: queue.append((node.left, True)) return deepest_left_val"},{"question":"Implement a CircularQueue using a fixed-size array. CircularQueue should be able to efficiently use a fixed-size array to offer O(1) time complexity for enqueue, dequeue, and peek operations without resizing. # Class definition: ```python class CircularQueue: def __init__(self, capacity: int): Initialize the CircularQueue with the given capacity. pass def enqueue(self, value: int) -> None: Insert the value into the queue. Raises OverflowError if the queue is full. pass def dequeue(self) -> int: Remove and return the front value of the queue. Raises IndexError if the queue is empty. pass def peek(self) -> int: Return the front value of the queue without removing it. Raises IndexError if the queue is empty. pass def is_empty(self) -> bool: Return True if the queue is empty, False otherwise. pass def is_full(self) -> bool: Return True if the queue is full, False otherwise. pass ``` # Requirements: 1. The implemented CircularQueue must use a single fixed-size array to store elements. 2. The queue should wrap around to the beginning of the array when reaching the end. 3. Methods `enqueue`, `dequeue`, and `peek` should all run in O(1) time. 4. Properly handle edge cases where the queue is either full or empty. 5. Raise `OverflowError` when trying to enqueue to a full queue and `IndexError` when trying to dequeue or peek from an empty queue. # Constraints: * The `capacity` is a positive integer (1 ≤ capacity ≤ 10^3). * All values in the queue are non-negative integers (0 ≤ value ≤ 10^3). # Example: ```python cq = CircularQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) print(cq.is_full()) # True print(cq.dequeue()) # 1 cq.enqueue(4) print(cq.peek()) # 2 print(cq.dequeue()) # 2 print(cq.dequeue()) # 3 print(cq.dequeue()) # 4 print(cq.is_empty()) # True ``` Ensure that the CircularQueue implementation supports the wrap-around behavior correctly and efficiently handles all edge cases as described.","solution":"class CircularQueue: def __init__(self, capacity: int): Initialize the CircularQueue with the given capacity. self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 def enqueue(self, value: int) -> None: Insert the value into the queue. Raises OverflowError if the queue is full. if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self) -> int: Remove and return the front value of the queue. Raises IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self) -> int: Return the front value of the queue without removing it. Raises IndexError if the queue is empty. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self) -> bool: Return True if the queue is empty, False otherwise. return self.size == 0 def is_full(self) -> bool: Return True if the queue is full, False otherwise. return self.size == self.capacity"},{"question":"You are given a function `split` which takes a path as input and splits it into two parts using the last occurrence of the \'/\' delimiter. Your task is to extend this function to handle a broader range of file path manipulations while preserving its original purpose and efficiency. Additionally, you should add more features to handle different delimiters and ensure the function behaves correctly for various edge cases. # Requirements: 1. Extend the function to handle Windows-style paths (using \'\' as the delimiter). 2. Ensure the function can handle paths without delimiters and paths ending in delimiters correctly. 3. Verify the function works for empty strings and single file names. # Function Signature ```python def enhanced_split(path: str, delimiter: str = \'/\') -> tuple: Splits the input path into two parts using the last occurrence of the specified delimiter. Args: path (str): The input file path. delimiter (str): The delimiter to split the path. Default is \'/\'. Returns: tuple: A tuple containing the directory path and the file name. pass ``` # Input * `path` (string): The file path which can be a URL, Unix-style or Windows-style path. * `delimiter` (string, optional): The delimiter used for splitting the path. Default is \'/\'. # Output * A tuple containing two strings: * First string: part of the path before the last delimiter. * Second string: part of the path after the last delimiter. # Constraints * The length of `path` will be between 0 and 10^4. * `delimiter` will be a single character. # Examples ```python # Example 1 path = \\"https://algorithms/unix/test.py\\" result = enhanced_split(path) # Expected output: (\\"https://algorithms/unix\\", \\"test.py\\") # Example 2 path = \\"C:UsersPublicDocumentsreport.docx\\" result = enhanced_split(path, delimiter=\'\') # Expected output: (\\"C:UsersPublicDocuments\\", \\"report.docx\\") # Example 3 path = \\"filename\\" result = enhanced_split(path) # Expected output: (\\"\\", \\"filename\\") # Example 4 path = \\"dir/\\" result = enhanced_split(path) # Expected output: (\\"dir\\", \\"\\") ``` # Notes You must ensure that the function behaves correctly for all specified cases including edge cases such as empty strings and paths without delimiters.","solution":"def enhanced_split(path: str, delimiter: str = \'/\') -> tuple: Splits the input path into two parts using the last occurrence of the specified delimiter. Args: path (str): The input file path. delimiter (str): The delimiter to split the path. Default is \'/\'. Returns: tuple: A tuple containing the directory path and the file name. last_delim_index = path.rfind(delimiter) if last_delim_index == -1: return (\\"\\", path) dir_path = path[:last_delim_index] file_name = path[last_delim_index + 1:] return (dir_path, file_name)"},{"question":"You are required to write a function `digit_count` that takes an integer and returns the number of its digits. Your solution should consider the edge cases effectively, ensuring the function is efficient and accurate. Your task is to write this function in Python. # Input * An integer `n` where `-10^18 <= n <= 10^18`. # Output * An integer representing the number of digits in the given input. # Example ```python print(digit_count(12345)) # Output: 5 print(digit_count(-12345)) # Output: 5 print(digit_count(0)) # Output: 1 ``` # Constraints * You may not use string conversion functions such as `str()` to determine the number of digits. * Your function should run in constant time O(1). * Consider edge cases such as negative numbers and zero. # Scenario Imagine you are developing a numerical analysis tool where determining the count of digits in a number is a frequent requirement. To ensure high performance, you need to implement this functionality in an optimal manner.","solution":"def digit_count(n): Returns the number of digits in the integer n. Considers the edge cases like zero and negative numbers. Args: n (int): The integer whose digits are to be counted. Range: -10^18 <= n <= 10^18 Returns: int: The number of digits in the integer. Examples: digit_count(12345) => 5 digit_count(-12345) => 5 digit_count(0) => 1 if n == 0: return 1 count = 0 n = abs(n) while n > 0: n = n // 10 count += 1 return count"},{"question":"# RandomizedSet Design Challenge **Scenario**: You are hired to develop a backend server feature for an online gaming platform that includes functionalities such as quick player addition, removal, and selecting a random player for a matchmaking system. Your task is to implement a data structure that efficiently supports these operations. **Task**: Write a class `RandomizedSet` that implements the following operations in average O(1) time: - `insert(val: int) -> bool`: Inserts an integer `val` into the data structure if it is not already present and returns `True`. Otherwise, returns `False`. - `remove(val: int) -> bool`: Removes an integer `val` from the data structure if present and returns `True`. Otherwise, returns `False`. - `get_random() -> int`: Returns a random element from the current elements in the data structure. Each element must have the same probability of being returned. **Constraints**: - Values for `val` are integers within the range `-10^6` to `10^6`. - At most `2 * 10^5` calls will be made to `insert`, `remove`, and `getRandom` combined. **Function Signature**: ```python class RandomizedSet: def __init__(self): # Initializes the RandomizedSet def insert(self, val: int) -> bool: # Inserts the value and returns True if inserted, False otherwise. def remove(self, val: int) -> bool: # Removes the value and returns True if removed, False otherwise. def get_random(self) -> int: # Returns a random value from the set. ``` **Example**: ```python rs = RandomizedSet() print(rs.insert(1)) # True print(rs.insert(2)) # True print(rs.insert(3)) # True print(rs.remove(1)) # True print(rs.remove(1)) # False print(rs.get_random()) # Could be 2 or 3 with equal probability print(rs.get_random()) # Could be 2 or 3 with equal probability ``` Write your `RandomizedSet` class and ensure it handles the various scenarios effectively.","solution":"import random class RandomizedSet: def __init__(self): self.vals = [] self.val_to_index = {} def insert(self, val: int) -> bool: if val in self.val_to_index: return False self.val_to_index[val] = len(self.vals) self.vals.append(val) return True def remove(self, val: int) -> bool: if val not in self.val_to_index: return False # Move the last element to the \'hole\' created by removed element last_element = self.vals[-1] idx_to_remove = self.val_to_index[val] self.vals[idx_to_remove] = last_element self.val_to_index[last_element] = idx_to_remove # Remove last element self.vals.pop() del self.val_to_index[val] return True def get_random(self) -> int: return random.choice(self.vals)"},{"question":"# Problem: Flatten Nested Arrays Using Recursion Context You are given an array that may contain nested arrays and your task is to produce a single resultant array. This problem is often encountered in data processing when handling JSON-like structures or preparing data for flat storage. Task Implement a function `flatten_array` that takes a single parameter: - `input_arr` (list): A potentially nested list of elements. The function should return the flattened list of elements. For simplicity, the elements of the input list will be limited to integers and nested lists of integers. Constraints - The elements will be integers or nested lists of integers. - You should not use any external libraries for flattening. - The recursion depth will be within Python\'s default recursion limit. Example **Input:** ```python input_arr = [1, [2, 3], [4, [5, 6]], 7, [[8, [9, 10]]]] ``` **Output:** ```python [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` Function Signature ```python def flatten_array(input_arr): pass ``` You must implement the function with the following signature: `def flatten_array(input_arr):`. # Evaluation Criteria 1. **Correctness**: The function should correctly flatten any nested list as per the given requirements. 2. **Efficiency**: The function should efficiently handle deep nesting within typical recursion limits. 3. **Readability**: Code should be clean, well-documented, and easy to follow. 4. **Edge Cases**: The solution should handle edge cases like empty lists and lists containing only non-lists.","solution":"def flatten_array(input_arr): Flattens a nested list of integers. Args: input_arr (list): A potentially nested list of elements. Returns: list: A flattened list of elements. flattened_list = [] for element in input_arr: if isinstance(element, list): flattened_list.extend(flatten_array(element)) else: flattened_list.append(element) return flattened_list"},{"question":"**Problem: Find First Occurrence in Sorted Array** You are given a sorted array of integers `array` and an integer `query`. The array is sorted in increasing order. Implement the function `first_occurrence(array, query)` that returns the index of the first occurrence of the `query` element in the `array`. # Input - `array`: A list of integers `[a1, a2,..., an]` which is sorted in increasing order. - `query`: An integer representing the element you\'re searching for in the array. # Output - Return the index of the first occurrence of the query element in the array. - If the `query` element is not found in the array, return `-1`. # Constraints - `1 ≤ len(array) ≤ 10^5` - `-10^9 ≤ array[i], query ≤ 10^9` # Examples **Example 1:** ```python array = [1, 2, 2, 2, 3, 4, 5] query = 2 first_occurrence(array, query) # Output: 1 ``` **Example 2:** ```python array = [5, 7, 7, 8, 8, 10] query = 8 first_occurrence(array, query) # Output: 3 ``` **Example 3:** ```python array = [1, 2, 3, 4, 5] query = 6 first_occurrence(array, query) # Output: -1 ``` Remember to consider edge cases such as arrays with one element and the query being out of bounds of the array values.","solution":"def first_occurrence(array, query): Returns the index of the first occurrence of the query element in the array. If the query element is not found in the array, returns -1. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid right = mid - 1 # look on the left side for the first occurrence elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Implement a Priority Queue using a Min-Heap A priority queue is a data structure similar to a regular queue but with an additional property: each element has a priority and elements are dequeued in order of their priority. Task Implement a priority queue using a min-heap. The min-heap should support the following operations with optimal performance: * `insert(item, priority)`: Inserts an item with the given priority. * `get_min()`: Returns the item with the minimum priority without removing it. * `remove_min()`: Removes and returns the item with the minimum priority. * `is_empty()`: Returns `True` if the priority queue is empty, otherwise `False`. Implementation Constraints * You should use a binary heap data structure. * All operations should work in O(log n) time complexity. Example ```python pq = MinHeapPriorityQueue() pq.insert(\\"task1\\", 2) pq.insert(\\"task2\\", 3) pq.insert(\\"task3\\", 1) print(pq.get_min()) # Output: \\"task3\\" print(pq.remove_min()) # Output: \\"task3\\" print(pq.get_min()) # Output: \\"task1\\" pq.remove_min() print(pq.get_min()) # Output: \\"task2\\" ``` Edge Cases * Calling `get_min` or `remove_min` on an empty priority queue should raise an exception. Implement the Class Signature Implement the `MinHeapPriorityQueue` class with the required methods. ```python class MinHeapPriorityQueue: def __init__(self): # Initialize an empty heap pass def insert(self, item, priority): # Insert an item with the given priority pass def get_min(self): # Return the minimum priority item pass def remove_min(self): # Remove and return the minimum priority item pass def is_empty(self): # Return whether the priority queue is empty pass ``` Implement these methods to correctly manage the elements and the heap properties.","solution":"import heapq class MinHeapPriorityQueue: def __init__(self): # Initialize an empty heap self.heap = [] def insert(self, item, priority): # Insert an item with the given priority heapq.heappush(self.heap, (priority, item)) def get_min(self): # Return the minimum priority item if self.is_empty(): raise IndexError(\\"get_min from an empty priority queue\\") return self.heap[0][1] def remove_min(self): # Remove and return the minimum priority item if self.is_empty(): raise IndexError(\\"remove_min from an empty priority queue\\") return heapq.heappop(self.heap)[1] def is_empty(self): # Return whether the priority queue is empty return len(self.heap) == 0"},{"question":"# Question: Implement the Atbash Cipher Context: The Atbash cipher is a classic substitution cipher where each letter in the given text is mapped to its reverse in the alphabet: \'a\' becomes \'z\', \'b\' becomes \'y\', etc. Uppercase letters are similarly mapped to uppercase letters, and non-letter characters remain unchanged. Task: Write a function `atbash` that accepts a single string `s` as input and returns its Atbash cipher translation. Function Signature: ```python def atbash(s: str) -> str: ``` Inputs: - `s` (string): The input string containing alphabetic and non-alphabetic characters. Outputs: - (string): The Atbash cipher text of the input string. Constraints: - The input string can include uppercase and lowercase characters, digits, punctuation, and whitespace. - The length of the input string is `1 <= len(s) <= 10^6`. Example: ```python assert atbash(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash(\\"Hello World!\\") == \\"Svool Dliow!\\" assert atbash(\\"12345\\") == \\"12345\\" assert atbash(\\"a1b2c3\\") == \\"z1y2x3\\" ``` Ensure that your implementation is efficient and handles large inputs up to 1 million characters within a reasonable time frame.","solution":"def atbash(s: str) -> str: Translates the input string using the Atbash cipher rules, where each letter in the given text is mapped to its reverse in the alphabet. result = [] for char in s: if char.isalpha(): if char.islower(): # Calculate mirrored character for lowercase letters result.append(chr(219 - ord(char))) # \'a\' (97) + \'z\' (122) == 219 else: # Calculate mirrored character for uppercase letters result.append(chr(155 - ord(char))) # \'A\' (65) + \'Z\' (90) == 155 else: # Non-alphabetic characters remain unchanged result.append(char) return \'\'.join(result)"},{"question":"In this coding question, you will implement a function to count the number of islands in a grid after multiple addLand operations using the Union-Find data structure. An island is a group of horizontally or vertically connected lands (1s). # Scenario You are given a 3x3 grid that initially contains only water (0s). You will receive a series of addLand operations, and for each operation, you need to determine the number of islands in the grid at that moment. Implement a function that performs the addLand operations and counts the number of islands. # Function Signature ```python def count_islands_operations(positions: List[Tuple[int, int]], grid_size: int = 3) -> List[int]: Given a list of positions to operate, count the number of islands after each addLand operation. Args: * positions (List[Tuple[int, int]]): List of tuple positions to process. * grid_size (int): The size of the grid (defaults to 3 for a 3x3 grid). Returns: * List[int]: List of island counts after each addLand operation. ``` # Input * `positions` - A list of pairs (tuples), each representing a position (row, column) in the grid where land (1) is added. * `grid_size` - An integer representing the size of the grid (default is 3). # Output * A list of integers where the i-th integer represents the number of islands after the i-th addLand operation. # Constraints * The grid size is fixed at 3x3. * Positions are within the grid boundaries (0 <= row, col < grid_size). # Example ```python input_positions = [(0, 0), (0, 1), (1, 2), (2, 1)] result = count_islands_operations(input_positions) print(result) # Output: [1, 1, 2, 3] ``` # Explanation * Initially: 0 0 0 0 0 0 0 0 0 * After addLand(0, 0): 1 0 0 0 0 0 0 0 0 -> Islands = 1 * After addLand(0, 1): 1 1 0 0 0 0 0 0 0 -> Islands = 1 * After addLand(1, 2): 1 1 0 0 0 1 0 0 0 -> Islands = 2 * After addLand(2, 1): 1 1 0 0 0 1 0 1 0 -> Islands = 3","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.count = 0 def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def setCount(self, newCount): self.count = newCount def getCount(self): return self.count def count_islands_operations(positions: List[Tuple[int, int]], grid_size: int = 3) -> List[int]: directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] grid = [[0] * grid_size for _ in range(grid_size)] uf = UnionFind(grid_size * grid_size) result = [] for r, c in positions: if grid[r][c] == 1: result.append(uf.getCount()) continue grid[r][c] = 1 index = r * grid_size + c uf.setCount(uf.getCount() + 1) for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < grid_size and 0 <= nc < grid_size and grid[nr][nc] == 1: uf.union(index, nr * grid_size + nc) result.append(uf.getCount()) return result"},{"question":"Given an `m x n` matrix where each row and each column is sorted in non-decreasing order, write a function `search_in_sorted_matrix` to determine if a given key exists in the matrix. If the key is found, return the 1-based indices of its position in the format `(row, column)`. If the key is not found, return `(-1, -1)`. # Function Signature ```python def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: pass ``` # Input * `matrix`: List of List of integers (m x n matrix), where `m` denotes the number of rows and `n` denotes the number of columns. Each row and each column of the matrix is sorted in non-decreasing order. * `key`: An integer to be searched in the matrix. # Output * Return a tuple of integers `(row_index, column_index)` where `row_index` and `column_index` are the 1-based indices of the key in the matrix if found. * Return `(-1, -1)` if the key is not found in the matrix. # Constraints * 1 <= m, n <= 10^3 * -10^9 <= matrix[i][j], key <= 10^9 # Example ```python assert search_in_sorted_matrix([ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ], 13) == (2, 3) assert search_in_sorted_matrix([ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ], 10) == (-1, -1) ``` # Explanation In the first example, the matrix contains the key `13` at row `2`, column `3` (1-based indices). In the second example, the key `10` is not found in the matrix, hence the output is `(-1, -1)`. # Notes * Ensure that your function handles edge cases, such as very small or very large matrices. * Avoid redundant operations to maintain the time complexity of O(m + n).","solution":"from typing import List, Tuple def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Tuple[int, int]: Searches for a key in a sorted matrix and returns 1-based indices if found, otherwise (-1, -1). if not matrix or not matrix[0]: return (-1, -1) m = len(matrix) n = len(matrix[0]) # Start from the top-right corner of the matrix row = 0 col = n - 1 while row < m and col >= 0: if matrix[row][col] == key: return (row + 1, col + 1) # return 1-based index elif matrix[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Scenario In a low-level network protocol, each packet consists of a 32-bit header where different fields are represented by specific bits. You need to write functions to manipulate these fields accurately within the header. The header fields include information such as flags and numerical values encoded in specific bit positions. # Task Create functions that will enable the extraction, setting, clearing, and updating of the specific bits in a 32-bit integer which represents the header of a network packet. # Functions to Implement 1. **get_field(header, i)**: Extract the bit at the `i`-th position of `header`. 2. **set_field(header, i)**: Set the bit at the `i`-th position of `header` to 1. 3. **clear_field(header, i)**: Clear the bit at the `i`-th position of `header`. 4. **update_field(header, i, value)**: Update the bit at the `i`-th position of `header` to `value` (either 0 or 1). # Input and Output Formats * Input: The input to each function will consist of: * `header`: a 32-bit integer. * `i`: Integer (`0 <= i < 32`), depicting the bit position. * `value` (for `update_field` only): Integer, `0` or `1`, representing the bit value to set. * Output: Each function should return an integer representing the updated header. # Constraints 1. `header` is a non-negative integer that fits within 32 bits. 2. `0 <= i < 32` 3. `value` (for `update_field`) is either `0` or `1`. # Example ```python header = 0b10101010 # 170 in decimal # Extract the 3rd bit bit = get_field(header, 3) print(bit) # Output: 1 # Set the 5th bit new_header = set_field(header, 5) print(bin(new_header)) # Output: \'0b10111010\' # Clear the 1st bit new_header = clear_field(header, 1) print(bin(new_header)) # Output: \'0b10101000\' # Update the 2nd bit to 1 new_header = update_field(header, 2, 1) print(bin(new_header)) # Output: \'0b10101110\' ```","solution":"def get_field(header, i): Extract the bit at the `i`-th position of `header`. return (header >> i) & 1 def set_field(header, i): Set the bit at the `i`-th position of `header` to 1. return header | (1 << i) def clear_field(header, i): Clear the bit at the `i`-th position of `header`. return header & ~(1 << i) def update_field(header, i, value): Update the bit at the `i`-th position of `header` to `value` (either 0 or 1). if value: return set_field(header, i) else: return clear_field(header, i)"},{"question":"You are working as a software developer at a company that develops educational tools. Your task is to implement a program that counts the number of possible combinations of elements in an array that add up to a given target. The elements in the array are positive integers, and each combination should be counted as different if the order of elements differs. # Function Specification Implement the following function: ```python def combination_sum(nums: List[int], target: int) -> int: Finds the number of possible combinations that add up to the target. Parameters: nums (List[int]): A list of positive integers without duplicates. target (int): The target sum for which combinations need to be found. Returns: int: The number of unique combinations that add up to the target. pass ``` # Input * `nums`: A list of positive integers, where `1 <= len(nums) <= 100` and `1 <= nums[i] <= 1000`. * `target`: A positive integer, where `1 <= target <= 1000`. # Output * An integer representing the number of unique combinations that add up to the target. # Constraints * Different sequences are counted as different combinations. # Performance Requirements * The implementation should efficiently handle cases where the length of `nums` is large, and the `target` value is relatively high. # Example ```python nums = [1, 2, 3] target = 4 # The possible combinations are: # (1, 1, 1, 1) # (1, 1, 2) # (1, 2, 1) # (1, 3) # (2, 1, 1) # (2, 2) # (3, 1) # Therefore, the output should be 7 result = combination_sum(nums, target) # Should return 7 ``` # Follow-up Questions: 1. If negative numbers are allowed in the given array, how does it change the problem? 2. What limitations or modifications would you need to introduce to handle negative numbers?","solution":"def combination_sum(nums, target): Finds the number of possible combinations that add up to the target. Parameters: nums (List[int]): A list of positive integers without duplicates. target (int): The target sum for which combinations need to be found. Returns: int: The number of unique combinations that add up to the target. # Initialize a list to store the count of combinations for each target from 0 to the target value dp = [0] * (target + 1) dp[0] = 1 # Base case: there\'s one way to get target 0 - use no elements # Iterate over all targets from 1 to target for t in range(1, target + 1): for num in nums: if t >= num: dp[t] += dp[t - num] return dp[target]"},{"question":"You are tasked with implementing a queue-based task scheduler for a web server, which handles incoming requests efficiently. The task scheduler will process tasks in the order they arrive using a queue data structure. Implement the queue using a **circular buffer** to ensure that operations remain efficient even with continuous addition and removal of elements. # Requirements 1. Implement a class `CircularBufferQueue` with the following methods: - `enqueue(item)`: Adds a new item to the rear of the queue. - `dequeue()`: Removes and returns the front item from the queue. Raise an `IndexError` with the message \\"Queue is empty\\" if the queue is empty. - `peek()`: Returns the front element without removing it. Raise an `IndexError` with the message \\"Queue is empty\\" if the queue is empty. - `isEmpty()`: Returns `True` if the queue is empty, and `False` otherwise. - `size()`: Returns the number of items in the queue. 2. Use the circular buffer technique to avoid the drawbacks of resizing in array-based implementations. # Input and Output Formats - **Input**: Sequence of method calls. - **Output**: Corresponding outputs for `dequeue`, `peek`, `isEmpty`, and `size` operations. # Example ```python q = CircularBufferQueue(5) q.enqueue(1) q.enqueue(2) print(q.dequeue()) # Output: 1 print(q.peek()) # Output: 2 print(q.size()) # Output: 1 print(q.isEmpty()) # Output: False q.dequeue() print(q.isEmpty()) # Output: True ``` # Constraints - Maximum capacity (N) of the queue is provided at the time of initialization. - All operations should be optimized for performance. # Note - You must handle all edge cases such as dequeuing from an empty queue or handling full capacity gracefully.","solution":"class CircularBufferQueue: def __init__(self, capacity): self.capacity = capacity self.buffer = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, item): if self.count == self.capacity: raise IndexError(\\"Queue is full\\") self.buffer[self.rear] = item self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self): if self.isEmpty(): raise IndexError(\\"Queue is empty\\") item = self.buffer[self.front] self.buffer[self.front] = None # Clear the slot self.front = (self.front + 1) % self.capacity self.count -= 1 return item def peek(self): if self.isEmpty(): raise IndexError(\\"Queue is empty\\") return self.buffer[self.front] def isEmpty(self): return self.count == 0 def size(self): return self.count"},{"question":"# Scenario You are developing a search feature for a large online library. Users frequently search for specific book IDs in a sorted list of book IDs to locate the first copy of a book. To enhance the user experience, you need to implement an efficient search algorithm to quickly find the first occurrence of a book ID in this sorted list. # Task Write a function `first_occurrence(array, query)` that takes in two parameters: - **array** (a list of integers): A sorted list of book IDs in increasing order. - **query** (an integer): The book ID to be searched for. The function should return the index of the first occurrence of the given book ID in the array. If the book ID is not present in the array or the array is empty, the function should return -1. # Input and Output Formats Input: - `array`: A sorted list of integers, with length n (0 <= n <= 10^6). - `query`: An integer, the book ID to find (1 <= query <= 10^6). Output: - An integer representing the index of the first occurrence of the `query` in the `array`, or -1 if the `query` is not present. # Constraints: - The input array is always sorted in increasing order. - The function should have a time complexity of O(log n) and a space complexity of O(1). # Example: ```python print(first_occurrence([1, 2, 2, 4, 4, 4, 5, 6], 4)) # Output: 3 print(first_occurrence([1, 2, 2, 4, 4, 4, 5, 6], 3)) # Output: -1 print(first_occurrence([], 3)) # Output: -1 print(first_occurrence([1, 2, 3, 4, 5], 1)) # Output: 0 ``` # Notes: - Ensure the function correctly handles edge cases: - An array with no elements. - Query element not in the array. - Query element appearing multiple times.","solution":"def first_occurrence(array, query): Return the index of the first occurrence of query in the sorted array. If query is not present in the array, return -1. left, right = 0, len(array) - 1 while left <= right: mid = left + (right - left) // 2 if array[mid] == query: if mid == 0 or array[mid - 1] != query: return mid right = mid - 1 elif array[mid] < query: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: Implement a Reliable Topological Sort Algorithm You are tasked with implementing a topological sort function which sorts vertices of a Directed Acyclic Graph (DAG) in linear order while handling potential cycles. The graph is represented as a dictionary where each key is a vertex, and its value is a list of vertices to which it has outgoing edges. You should not rely on the actual code snippets provided above, but instead craft a reliable and efficient solution based on your understanding of topological sort. Function Signature ```python def topological_sort(graph: Dict[int, List[int]]) -> List[int]: pass ``` Input * `graph`: A dictionary where keys are vertices ((0 le |V| le 10^5)) and values are lists of vertices. Output * Returns a list of vertices in topologically sorted order. * Raises a `ValueError` if the graph contains a cycle. Constraints * The graph will uniquely represent a DAG or cyclic graph. * Your algorithm should run with a complexity of ( O(V + E) ). Example ```python graph = { 0: [1, 2], 1: [3], 2: [3], 3: [] } print(topological_sort(graph)) # Output: [0, 2, 1, 3] or [0, 1, 2, 3] graph = { 0: [1], 1: [2], 2: [0] } print(topological_sort(graph)) # Raises a ValueError: cycle ``` Note - Ensure your solution is efficient and elegantly handles the mentioned error scenarios. - Write helper functions if necessary to maintain code clarity and modularity. - Use appropriate error handling to detect and report cycles.","solution":"from typing import List, Dict def topological_sort(graph: Dict[int, List[int]]) -> List[int]: Perform a topological sort on a directed acyclic graph (DAG). visited = set() temp_mark = set() stack = [] def visit(node): if node in temp_mark: raise ValueError(\\"Graph contains a cycle\\") if node not in visited: temp_mark.add(node) for neighbour in graph.get(node, []): visit(neighbour) temp_mark.remove(node) visited.add(node) stack.append(node) for node in graph: if node not in visited: visit(node) return stack[::-1]"},{"question":"# Inverting a Binary Tree **Objective**: Given a binary tree, write a function `invert_tree` to invert (or mirror) the tree. This involves swapping the left and right subtrees of every node. # Core Requirements: - **Function**: `invert_tree(root: Optional[TreeNode]) -> Optional[TreeNode]` - **Input**: A binary tree represented by its root node. Each tree node contains integer values. - **Output**: The root node of the inverted tree. # Constraints: - The binary tree node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - You need to return the root of the modified tree. # Performance: - The solution should aim to have O(n) time complexity and O(h) space complexity, where n is the number of nodes and h is the height of the tree. # Example: Example 1: ```plaintext Input: 4 / 2 7 / / 1 3 6 9 Output: 4 / 7 2 / / 9 6 3 1 ``` Example 2: ```plaintext Input: None Output: None ``` # Additional Notes: - Handle edge cases such as empty trees and trees with only one node. - Ensure the function handles balanced and unbalanced trees efficiently. - Avoid unnecessary swaps for nodes that already fulfill the mirroring condition. Implement the function `invert_tree`: ```python def invert_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: # Your implementation here pass ```","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: if root is None: return None # Swap the left and right subtrees root.left, root.right = root.right, root.left # Recursively invert the subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"# Secure Communication Using Diffie-Hellman Key Exchange In modern secure communication systems, two parties need to exchange cryptographic keys securely over an insecure channel. The Diffie-Hellman Key Exchange algorithm allows two parties to generate a shared secret key over such a channel without directly transmitting the key. Implement a Python function `diffie_hellman_secure_exchange(p: int, g: int) -> Union[int, bool]` that performs the Diffie-Hellman Key Exchange securely. Both `p` and `g` should be provided as inputs where `p` is a large prime number and `g` is a primitive root modulo `p`. The function should generate and exchange keys between two parties (Alice and Bob) and return the shared secret key if the keys match, or `False` otherwise. Input - `p`: An integer, a large prime number. - `g`: An integer, a primitive root modulo `p`. Output - The shared secret key (integer) if the key exchange is successful and the keys match. - `False` if the key exchange fails (due to invalid inputs or mismatched keys). Constraints - `p` should be a large prime number (greater than 1000). - `g` should be a valid primitive root modulo `p`. - Your solution should handle invalid inputs appropriately and ensure the shared key is computed securely. # Example ```python p = 23 g = 5 shared_key = diffie_hellman_secure_exchange(p, g) print(shared_key) # Output: Shared key (e.g., 2) or False ``` # Notes - You may assume the inputs provided in the example are for illustrative purposes and are not sufficiently secure for real-world cryptographic usage. - Ensure to handle the case where `p` is not a prime number or `g` is not a primitive root modulo `p`. - You may use helper functions for prime checking and primitive root verification.","solution":"import random def is_prime(n): Check if a number is prime using a simple method. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_primitive_root(g, p): Check if g is a primitive root modulo p. if not is_prime(p): return False required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(g, powers, p) for powers in range(1, p)) return required_set == actual_set def diffie_hellman_secure_exchange(p, g): Perform Diffie-Hellman Key Exchange and return the shared secret key. if not (is_prime(p) and is_primitive_root(g, p)): return False # Alice\'s private key (a) a = random.randint(1, p-1) # Bob\'s private key (b) b = random.randint(1, p-1) # Alice\'s public key (A) A = pow(g, a, p) # Bob\'s public key (B) B = pow(g, b, p) # Shared secret key (s) s_alice = pow(B, a, p) s_bob = pow(A, b, p) # Check if keys match return s_alice if s_alice == s_bob else False # Helper to compute gcd (used in is_primitive_root) def gcd(a, b): while b: a, b = b, a % b return a"},{"question":"# Scenario You are working on a machine learning project and need to compare the similarity between different feature vectors. One common metric for this task is cosine similarity, which quantifies the orientation similarity between two vectors. # Task Write a Python function named `cosine_similarity` that takes in two 1-dimensional lists (vectors) and returns the cosine similarity between them. Your function should raise a `ValueError` if the input vectors are not of the same length. Ensure that your function handles edge cases like division by zero (when one or both vectors have a magnitude of zero) gracefully. # Requirements 1. **Input Formats**: - Two lists: `vec1` and `vec2`, each containing n numerical elements. 2. **Output Formats**: - A floating-point number representing the cosine similarity between the two input vectors. 3. **Constraints**: - Both input lists must be non-empty and of the same length. - The elements of the lists can be any real numbers (positive, negative, or zero). # Function Signature ```python def cosine_similarity(vec1, vec2): pass ``` # Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([0, 0, 0], [1, 2, 3]) # Output: Should handle division by zero gracefully ``` # Additional Notes - Consider using helper functions if necessary to keep your code organized. - Provide thorough testing for edge cases, especially the ones that involve vectors with zero magnitude. - Document any assumptions or design choices you make.","solution":"import math def cosine_similarity(vec1, vec2): Calculates the cosine similarity between two vectors. Args: vec1 (list): The first vector. vec2 (list): The second vector. Returns: float: Cosine similarity between the two vectors. Raises: ValueError: If the vectors are not of the same length. if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length.\\") dot_product = sum(a * b for a, b in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(a * a for a in vec1)) magnitude_vec2 = math.sqrt(sum(b * b for b in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"Transform a stack by switching successive pairs of elements. **Objective** Implement a function `switch_pairs_stack` that switches every successive pair of elements in a stack. If the stack has an odd number of elements, the last element should remain unchanged. **Function Signature** ```python def switch_pairs_stack(stack: list) -> list: pass ``` **Input** * `stack` – a list of integers that represents a stack (0 ≤ len(stack) ≤ 10^4). **Output** * Return a new stack (list) with successive pairs switched. **Constraints** * The stack has a limited size of up to 10,000 elements. * The function should be efficient and avoid unnecessary computations. **Example** 1. Input: `stack = [3, 8, 17, 9, 1, 10]` Output: `[8, 3, 9, 17, 10, 1]` 2. Input: `stack = [3, 8, 17, 9, 1]` Output: `[8, 3, 9, 17, 1]` **Special Conditions** * An empty stack should return an empty list. * A single element stack should return the same single element. **Bonus** * Implement a version with just one auxiliary stack. * Implement a version with just one auxiliary queue. **Testing** Ensure your implementation passes the following test cases: ```python assert switch_pairs_stack([3, 8, 17, 9, 1, 10]) == [8, 3, 9, 17, 10, 1] assert switch_pairs_stack([3, 8, 17, 9, 1]) == [8, 3, 9, 17, 1] assert switch_pairs_stack([]) == [] assert switch_pairs_stack([10]) == [10] ```","solution":"def switch_pairs_stack(stack: list) -> list: Switches every successive pair of elements in a stack. If the number of elements is odd, the last element remains unchanged. Parameters: stack (list of integers): The input stack. Returns: list: The new stack with every successive pair switched. for i in range(0, len(stack) - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"You are tasked with manipulating the inventory system for a warehouse where each item is represented by a 32-bit integer. Each bit in this integer denotes a different characteristic of the item (e.g., its category, its status such as being perishable, fragile, heavy, etc.). Your objective is to implement a series of efficient bitwise functions to control these characteristics of inventory items. **Task**: Implement the following functions: 1. `get_bit(num: int, i: int) -> bool`: Retrieve the bit at the `i`-th position of `num`. 2. `set_bit(num: int, i: int) -> int`: Set the bit at the `i`-th position of `num` to `1`. 3. `clear_bit(num: int, i: int) -> int`: Clear the bit at the `i`-th position of `num` (set it to `0`). 4. `update_bit(num: int, i: int, bit: int) -> int`: Update the bit at the `i`-th position of `num` to `bit` (either `0` or `1`). # Input and Output formats **Input**: * An integer `num` (assume a 32-bit integer). * An integer `i` representing the bit index to manipulate. * For `update_bit`, an additional integer `bit` (0 or 1) to be set at position `i`. **Output**: * For `get_bit`, return a boolean indicating if the bit is `1` (True) or `0` (False). * For `set_bit`, `clear_bit`, and `update_bit`, return the new integer after modifying the bit. **Constraints**: * `0 <= i < 32` (bit indices lie within the range of a 32-bit integer). **Examples**: ```python # Example usage of get_bit print(get_bit(22, 1)) # Output: True # Example usage of set_bit print(set_bit(22, 3)) # Output: 30 # Example usage of clear_bit print(clear_bit(22, 2)) # Output: 18 # Example usage of update_bit print(update_bit(22, 1, 0)) # Output: 20 ``` # Performance Requirements All functions should operate within O(1) time complexity.","solution":"def get_bit(num: int, i: int) -> bool: Retrieve the bit at the `i`-th position of `num`. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Set the bit at the `i`-th position of `num` to `1`. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clear the bit at the `i`-th position of `num` (set it to `0`). return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Update the bit at the `i`-th position of `num` to `bit` (either `0` or `1`). mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"# Problem Description Write a function `get_unique_permutations(matrix)` that generates all unique permutations of the numbers given in a 2xN matrix. The matrix consists of two rows: the first row contains distinct numbers to be permuted, and the second row contains boolean values which indicate whether an element should be included (True) or excluded (False) from the permutation. Input - A 2xN matrix, where the first row contains N distinct integers and the second row contains N boolean values indicating whether to include the corresponding integer from the first row for permutation. Output - Return a list of lists containing all unique permutations of the selected integers. Constraints - The matrix will always have two rows. - It is guaranteed that N will be between `1` and `10` (inclusive). - Matrix elements are guaranteed to be integers for the first row and booleans for the second row. Example ```python matrix = [ [1, 2, 3], [True, False, True] ] Output: [ [1, 3], [3, 1] ] ``` Notes - The boolean in the second row of the matrix determines if the corresponding integer in the first row should be included in the permutation. - If all boolean values in the second row are False, the function should return an empty list. Function Signature ```python def get_unique_permutations(matrix): # Your code here ```","solution":"from itertools import permutations def get_unique_permutations(matrix): Generates all unique permutations of numbers in the matrix where the second row boolean value is True (indicating inclusion in the permutation). Parameters: - matrix: A 2xN matrix with the first row containing distinct integers and the second row containing booleans. Returns: - A list of lists containing all unique permutations of the selected integers. if len(matrix) != 2 or len(matrix[0]) != len(matrix[1]): raise ValueError(\\"Incorrect matrix dimensions\\") numbers = matrix[0] inclusion_flags = matrix[1] to_permute = [numbers[i] for i in range(len(numbers)) if inclusion_flags[i]] if not to_permute: return [] # Generate permutations and convert to a list of lists permutes = list(permutations(to_permute)) # Convert each tuple to a list result = [list(perm) for perm in permutes] return result"},{"question":"**Question**: Given two strings `s` and `t`, write a function `is_anagram(s, t)` to determine if `t` is an anagram of `s`. **Input**: - Two strings, `s` and `t`, containing only lowercase alphabets. **Output**: - Return `True` if `t` is an anagram of `s`, otherwise, return `False`. **Constraints**: - You may assume that both strings contain only lowercase English letters (`a-z`). **Scenario**: The problem at hand mimics a scenario in security where two different texts need to be verified as reshuffled versions of one another. In such contexts, it\'s vital to ascertain whether a potential security threat is merely a rearranged duplicate of a known safe text. Efficient checking ensures minimal processing time, preventing delays in higher security layers. **Performance Requirements**: - The function should run in O(n) time complexity and utilize constant space (O(1)) considering the size of alphabetic characters (limited to 26). Implement the function `is_anagram(s, t)` in Python: ```python def is_anagram(s, t): :type s: str :type t: str :rtype: bool # Implement your code here pass # Example Usage: # is_anagram(\\"anagram\\", \\"nagaram\\") should return True # is_anagram(\\"rat\\", \\"car\\") should return False ``` **Edge Cases to Consider**: - Strings of different lengths (should return `False`). - Both strings being empty (should return `True` since empty strings are anagrams by definition). - Strings with all identical characters (e.g., \\"aaa\\", \\"aaa\\"). Ensure your implementation efficiently handles the given constraints and edge cases.","solution":"def is_anagram(s, t): Determines if t is an anagram of s. :param s: str :param t: str :return: bool if len(s) != len(t): return False count_s = [0] * 26 count_t = [0] * 26 for char in s: count_s[ord(char) - ord(\'a\')] += 1 for char in t: count_t[ord(char) - ord(\'a\')] += 1 return count_s == count_t"},{"question":"# Gnome Sort Variant for Unique Element Arrays Background Gnome Sort is a simple comparison-based sorting algorithm that while easy to implement, performs poorly on large lists. Your task is to implement a variant of Gnome Sort that specifically sorts arrays of unique elements (i.e., no duplicates are present). Objective Write a function `gnome_sort_unique` that sorts a given list of unique integers using a variant of the Gnome Sort algorithm. Function Signature ```python def gnome_sort_unique(arr: List[int]) -> List[int]: pass ``` Input * A list, `arr`, of unique integers where ( 1 leq len(arr) leq 10^4 ). Output * Return a sorted list of integers in non-decreasing order. Constraints * The function must perform the Gnome Sort variant that shows understanding of sorting principles. * Optimize for edge cases like nearly sorted lists or reverse order lists. Performance Requirements * Despite its ( O(n^2) ) worse case, attempt to highlight good practices in handling input efficiently wherever possible. Example ```python assert gnome_sort_unique([34, 2, 78, 1, 58, 90, 19]) == [1, 2, 19, 34, 58, 78, 90] assert gnome_sort_unique([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert gnome_sort_unique([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert gnome_sort_unique([]) == [] ```","solution":"from typing import List def gnome_sort_unique(arr: List[int]) -> List[int]: index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: # Swap arr[index] and arr[index - 1] arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Problem: Optimized Counting Sort for Multiple Ranges You are tasked with implementing an enhanced version of the Counting Sort algorithm to handle arrays with diverse value ranges, ensuring efficient memory usage and maintaining stable sorting. Given an array of integers, your function should sort them in non-decreasing order. Function Signature ```python def optimized_counting_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr` (List[int]): A list of integers which can contain both positive and negative values. Output * Returns a list of integers sorted in non-decreasing order. Constraints * The input list can contain both positive and negative integers. * The length of the input list, `n`, will be in the range [0, 10^6]. * The range of integers in the input list can vary significantly. Performance Requirements * Maintain time complexity of O(n + k) where `k` is the range of the input values. * Optimize space complexity as much as possible. Example ```python assert optimized_counting_sort([3, -2, -1, 0, 2, 3, -3]) == [-3, -2, -1, 0, 2, 3, 3] assert optimized_counting_sort([10, -5, 0, 7, -10, 5]) == [-10, -5, 0, 5, 7, 10] ``` # Explanation In the provided solution, you need to enhance the Counting Sort algorithm to handle both positive and negative integers efficiently while minimizing the auxiliary space usage. Consider taking the following editorial steps: 1. Calculate the minimum and maximum values in the array to determine the range. 2. Offset the values to make them all positive (if necessary). 3. Construct the auxiliary count and output arrays accordingly. 4. Place each element in its correct position ensuring stability. 5. Convert the values back if previously offset. Remember to handle edge cases like empty input arrays and arrays with all identical elements.","solution":"from typing import List def optimized_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements output = [0] * len(arr) for num in arr: count[num - min_val] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"You are tasked with creating a Binary Search Tree (BST) and implementing core operations such as insertion, search, and deletion of nodes. Your implementation should handle the core properties of a BST and ensure efficient performance. # Requirements 1. **Insert a Node**: Implement a function `insert(self, root: TreeNode, key: int) -> TreeNode` which inserts a node with value `key` into the BST maintaining its properties. 2. **Search for a Node**: Implement a function `search(self, root: TreeNode, key: int) -> bool` which searches for a node with value `key` in the BST and returns a boolean indicating if it exists. 3. **Delete a Node**: Implement a function `delete(self, root: TreeNode, key: int) -> TreeNode` which deletes a node with value `key` from the BST and maintains its properties. # Input and Output Formats - **Insert**: - Input: `root` (the root of the BST, initially `None` for an empty tree), `key` (integer to insert) - Output: Modified `root` of the BST after insertion. - **Search**: - Input: `root` (the root of the BST), `key` (integer to search) - Output: Boolean, `True` if found, otherwise `False`. - **Delete**: - Input: `root` (the root of the BST), `key` (integer to delete) - Output: Modified `root` of the BST after deletion. # Constraints - The BST should handle a minimum of `0` and maximum of `10^4` nodes. - The value of nodes will be in the range of `-10^5` to `10^5`. # Example Scenarios 1. **Insert and Search**: - Insert `5`, `3`, `7` into an empty BST. - Search for `7` in the BST, which should return `True`. - Search for `4` in the BST, which should return `False`. 2. **Insertion and Deletion**: - Insert `8`, `4`, `12`, `2`, `6` into an empty BST. - Delete `8` from the BST. - Structure of the BST should be correctly maintained. # Note Make sure your implementation preserves the BST properties at all times and covers edge cases like insertion into an empty tree, deletion of a non-existent node, and handling of duplicate values appropriately.","solution":"class TreeNode: def __init__(self, key: int = 0, left=None, right=None): self.key = key self.left = left self.right = right class BST: def insert(self, root: TreeNode, key: int) -> TreeNode: if root is None: return TreeNode(key) if key < root.key: root.left = self.insert(root.left, key) elif key > root.key: root.right = self.insert(root.right, key) return root def search(self, root: TreeNode, key: int) -> bool: if root is None: return False if key == root.key: return True elif key < root.key: return self.search(root.left, key) else: return self.search(root.right, key) def delete(self, root: TreeNode, key: int) -> TreeNode: if root is None: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = self._min_value_node(root.right) root.key = min_larger_node.key root.right = self.delete(root.right, min_larger_node.key) return root def _min_value_node(self, root: TreeNode) -> TreeNode: current = root while current.left is not None: current = current.left return current"},{"question":"# Question: Find the Smallest Element Greater Than Target **Context**: In a sorted list of lowercase characters, your task is to find the smallest character that is strictly greater than a given target character. Note that the list is cyclic, meaning that if the target is larger than or equal to the last character in the list, the search should wrap around to the beginning. **Function Specification**: ```python def find_next_greatest_character(letters: List[str], target: str) -> str: Find the smallest character in the sorted list \'letters\' that is greater than the target character. Parameters: - letters (List[str]): A list of sorted, lowercase characters (size: 1 <= len(letters) <= 10^4) - target (str): A single lowercase character. Returns: - str: The smallest character greater than the target, considering the list wraps around. # Your implementation here ``` **Input**: - `letters`: A list of sorted, lowercase characters `[\'a\', \'b\', \'c\', ... , \'z\']`. - `target`: A single lowercase character. **Output**: - A single lowercase character from `letters` which is the smallest character greater than `target`. **Constraints**: - The given list `letters` will always be non-empty and contain only lowercase characters. - The returned character must be larger than the target, adhering to the cyclic wrap-around condition. **Example**: ```python letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"a\\" assert find_next_greatest_character(letters, target) == \\"c\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"c\\" assert find_next_greatest_character(letters, target) == \\"f\\" letters = [\\"c\\", \\"f\\", \\"j\\"] target = \\"d\\" assert find_next_greatest_character(letters, target) == \\"f\\" letters = [\\"a\\", \\"b\\"] target = \\"z\\" assert find_next_greatest_character(letters, target) == \\"a\\" ``` **Notes**: 1. You may consider constraints where the length of the list is sufficiently large to prefer an efficient solution. 2. Ensure proper handling of edge cases, such as targets that do not exist in the list, and wrapping-around scenarios.","solution":"from typing import List def find_next_greatest_character(letters: List[str], target: str) -> str: Find the smallest character in the sorted list \'letters\' that is greater than the target character. Parameters: - letters (List[str]): A list of sorted, lowercase characters. - target (str): A single lowercase character. Returns: - str: The smallest character greater than the target, considering the list wraps around. n = len(letters) left, right = 0, n - 1 # If target is greater or equal to the last character, wrap around the list if target >= letters[right]: return letters[0] # Binary search to find the smallest character greater than target while left < right: mid = (left + right) // 2 if letters[mid] > target: right = mid else: left = mid + 1 return letters[left]"},{"question":"# Exchange Sort Implementation # Scenario You are tasked with sorting a list of integers for a small set of data. Implement a sorting function using the Exchange Sort algorithm, a simple yet instructive sorting method. Despite its inefficiency on large datasets, it\'s perfect for understanding the mechanics of basic sorting techniques. # Task Write a function `exchange_sort(arr)` that takes a list of integers and returns a new list with the elements sorted in ascending order using the Exchange Sort algorithm. # Requirements 1. **Function Name**: `exchange_sort` 2. **Input Format**: A list of integers `arr` (0 <= len(arr) <= 1000, element values can be negative) 3. **Output Format**: A new list of integers sorted in ascending order 4. **Constraints**: - Should handle the empty list case properly. - Should work in place to maintain original space complexity. # Example ```python assert exchange_sort([]) == [] assert exchange_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert exchange_sort([1, 2, -1, -2, 0]) == [-2, -1, 0, 1, 2] ``` Implement the function `exchange_sort` adhering to the above requirements:","solution":"def exchange_sort(arr): Perform an Exchange Sort on the provided list. n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"Background You are working on an urban planning project, and you need to assess the connectivity of one part of the city grid. The city is represented as a 2D grid where: - \'1\' denotes buildings, - \'0\' denotes empty plots, - \'2\' denotes obstacles. Your task is to determine the shortest distance from all buildings to an empty plot. If it\'s impossible for an empty plot to be reached by all buildings, return -1. Problem Statement Implement a function `shortest_distance(grid)` which takes a 2D list of lists, `grid`, as input, where each element represents a part of the city. The function should return the shortest distance from an empty plot to all buildings cumulatively. If no such plot exists, return -1. Function Signature ```python def shortest_distance(grid: List[List[int]]) -> int: pass ``` Input - `grid`: A list of lists where each sublist represents a row in the grid and each element is an integer (0, 1, or 2) - 0: An empty plot - 1: A building - 2: An obstacle Output - Returns an integer representing the shortest distance from any empty plot to all buildings. Example ```python grid = [ [1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0] ] shortest_distance(grid) # should return 7 ``` Constraints - The grid will have at least one building. - The grid size will be at most 50x50. - Obstacles do not block any empty plot that needs to be reached. Notes - You may assume that the input is a valid grid with buildings, empty plots, and obstacles only. - The grid size and structure should be efficiently handled within provided constraints. Good luck!","solution":"import collections from typing import List def bfs(grid, start_x, start_y, distance, reach, buildings): rows, cols = len(grid), len(grid[0]) queue = collections.deque([(start_x, start_y, 0)]) visited = set([(start_x, start_y)]) while queue: x, y, dist = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: visited.add((nx, ny)) if grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) distance[nx][ny] += dist + 1 reach[nx][ny] += 1 def shortest_distance(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) distance = [[0] * cols for _ in range(rows)] reach = [[0] * cols for _ in range(rows)] buildings = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: buildings += 1 bfs(grid, i, j, distance, reach, buildings) shortest = float(\'inf\') for i in range(rows): for j in range(cols): if grid[i][j] == 0 and reach[i][j] == buildings: shortest = min(shortest, distance[i][j]) return shortest if shortest != float(\'inf\') else -1"},{"question":"Given two binary trees `s` and `t`, determine if `t` is a subtree of `s`. A subtree of `s` is a tree consisting of a node in `s` and all of that node\'s descendants. # Function Signature ```python def is_subtree(big: TreeNode, small: TreeNode) -> bool: ``` # Input - `big` (TreeNode): The root of the binary tree `s`. - `small` (TreeNode): The root of the binary tree `t`. # Output - `bool`: True if `t` is a subtree of `s`, False otherwise. # Constraints - The number of nodes in both trees will be in the range [1, 2000]. - The value of each node will be a unique integer in the range [-10^4, 10^4]. - Tree nodes are non-null. # Performance Requirements The solution should handle the case where `s` is significantly larger than `t` efficiently. Specifically, it should aim to avoid re-checking unnecessary parts of `s`. # Scenario Context Consider a large binary tree `s` representing an entire file directory (e.g., a filesystem) and a smaller binary tree `t` representing a directory structure you want to locate. The function should efficiently detect whether the smaller directory structure exists within the larger one. # Edge Cases to Consider 1. Full binary trees where every node has two children. 2. Skewed binary trees where each node has only one child. 3. Trees where `t` is deeply nested within `s`. # Example Cases 1. Given `s` and `t` as shown in Example 1, the output should be `True` because `t` is a subtree of `s`. 2. Given `s` and `t` as shown in Example 2, the output should be `False` because even though their roots match, `t` contains nodes not present in `s`. # Template ```python import collections class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_subtree(big: TreeNode, small: TreeNode) -> bool: # To be implemented pass def comp(p: TreeNode, q: TreeNode) -> bool: # Helper function if p is None and q is None: return True if p is not None and q is not None: return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right) return False ``` Implement the `is_subtree` function to correctly determine if `t` is a subtree of `s`.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def comp(p: TreeNode, q: TreeNode) -> bool: if p is None and q is None: return True if p is not None and q is not None: return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right) return False def is_subtree(big: TreeNode, small: TreeNode) -> bool: if not small: return True if not big: return False if comp(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small)"},{"question":"# Question: Implement Comb Sort Variants with Custom Shrink Factor You are asked to implement a customized version of the Comb Sort algorithm where the shrink factor is configurable. Your implementation should include functionality to sort arrays in both ascending and descending order. Specifications: * **Function Name**: `custom_comb_sort` * **Input**: * `arr`: A list of integers to sort. * `shrink_factor`: A floating-point number greater than 1 representing the shrink factor for the gap. * `order`: A string, either `\\"asc\\"` for ascending or `\\"desc\\"` for descending sort order. * **Output**: The function should return a sorted list of integers based on the specified order and shrink factor. Constraints: * The length of the array `arr` will be between 0 and 10^6. * All integers in `arr` will be within the range of -10^9 to 10^9. * `shrink_factor` will be a float such that `1.1 ≤ shrink_factor ≤ 3.0`. * `order` will be either `\\"asc\\"` or `\\"desc\\"`. Requirements: * Your algorithm should handle edge cases such as empty and single element arrays. * You must optimize for performance to ensure that it works efficiently even for large arrays. Example: ```python # Example 1: arr = [5, 2, 9, 1, 5, 6] shrink_factor = 1.3 order = \\"asc\\" print(custom_comb_sort(arr, shrink_factor, order)) # Output: [1, 2, 5, 5, 6, 9] # Example 2: arr = [3, -1, 0, 12, 8, 6] shrink_factor = 2.0 order = \\"desc\\" print(custom_comb_sort(arr, shrink_factor, order)) # Output: [12, 8, 6, 3, 0, -1] ```","solution":"def custom_comb_sort(arr, shrink_factor, order): def get_next_gap(gap): gap = int(gap / shrink_factor) if gap < 1: return 1 return gap def should_swap(a, b): if order == \'asc\': return a > b elif order == \'desc\': return a < b n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if should_swap(arr[i], arr[i + 1]): arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True return arr"},{"question":"Context: You have been presented with an intentionally inefficient sorting algorithm, Bogo Sort. Despite its impractical nature, it can be useful for understanding fundamental concepts about algorithm analysis and probabilistic methods. The following question tests your understanding of Bogo Sort by asking you to implement a related, more feasible algorithm. Task: Write a function that simulates the sorting process using Bogo Sort but with the additional constraint of returning the array in a given time limit if it is not sorted. The time limit will be simulated by a given number of iterations. # Function Signature: ```python def safe_bogo_sort(arr: List[int], max_iterations: int, simulation: bool = False) -> List[int]: Function to sort an array using Bogo Sort with enforced iteration limit. :param arr: List of integers to sort :param max_iterations: The maximum number of iterations before giving up :param simulation: If True, print each iteration\'s array (useful for debugging) :return: The sorted array (or the closest attempt after max_iterations) ``` # Input: - `arr`: A list of integers that you need to sort. - `max_iterations`: An integer defining the maximum number of times the array can be shuffled before the function gives up. - `simulation`: A boolean flag to print the array at each iteration. # Output: - The function should return the array sorted if possible within the maximum iterations, or the closest attempt if the iteration limit is reached. # Constraints: - The array length will be (1 leq n leq 100). - The elements will be in the range (-10^6 leq arr[i] leq 10^6). # Example: ```python # Example 1 arr = [3, 2, 1] max_iterations = 10 print(safe_bogo_sort(arr, max_iterations)) # Output might vary since the function is probabilistic, e.g., [1, 2, 3] if sorted within constraints. # Example 2 arr = [5, 4, 3, 2, 1] max_iterations = 1000 print(safe_bogo_sort(arr, max_iterations)) # Output should be [1, 2, 3, 4, 5] or the closest to sorted sequence depending on iterations allowed. ``` # Notes: - Ensure your solution is robust enough to handle the iteration constraint effectively. - Use Python\'s built-in `random.shuffle` method for shuffling the array. - Utilize the existing `is_sorted` function to check if your array is sorted after each shuffle.","solution":"from typing import List import random def is_sorted(arr: List[int]) -> bool: Returns True if the given array is sorted in ascending order, False otherwise. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def safe_bogo_sort(arr: List[int], max_iterations: int, simulation: bool = False) -> List[int]: Function to sort an array using Bogo Sort with enforced iteration limit. :param arr: List of integers to sort :param max_iterations: The maximum number of iterations before giving up :param simulation: If True, print each iteration\'s array (useful for debugging) :return: The sorted array (or the closest attempt after max_iterations) iteration = 0 while iteration < max_iterations: if is_sorted(arr): return arr random.shuffle(arr) if simulation: print(f\\"Iteration {iteration}: {arr}\\") iteration += 1 return arr"},{"question":"You are working on a spell checker application and need to implement a core functionality that determines the similarity between two words. The similarity is calculated based on the minimum number of operations (insertions, deletions, substitutions) needed to transform one word into another. This is known as the Edit Distance. Write a function `edit_distance(word_a, word_b)` that computes the edit distance between two given strings `word_a` and `word_b`. # Function Signature ```python def edit_distance(word_a: str, word_b: str) -> int: ``` # Input * `word_a` (1 <= len(word_a) <= 1000) — the first word. * `word_b` (1 <= len(word_b) <= 1000) — the second word. # Output * An integer representing the edit distance between the two words. # Constraints * All characters are lowercase English letters. * You should handle edge cases such as empty strings and single-character differences. # Example ```python assert edit_distance(\\"food\\", \\"money\\") == 4 assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"intention\\", \\"execution\\") == 5 assert edit_distance(\\"\\", \\"test\\") == 4 ``` # Performance Requirements The implementation should run in O(length_a * length_b) time and use O(length_a * length_b) space. # Additional Information Use a dynamic programming approach to construct a 2D table where `edit[i][j]` represents the edit distance between the first `i` characters of `word_a` and the first `j` characters of `word_b`.","solution":"def edit_distance(word_a: str, word_b: str) -> int: m, r = len(word_a), len(word_b) # Create a table to store results of subproblems dp = [[0 for x in range(r + 1)] for x in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(r + 1): if i == 0: dp[i][j] = j # Min. operations = j elif j == 0: dp[i][j] = i # Min. operations = i elif word_a[i-1] == word_b[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][r]"},{"question":"# Question: Postorder Traversal of a Binary Tree You are tasked with implementing postorder traversal of a binary tree. You need to complete two functions: one using an iterative approach and another using recursion. Function Signature ```python def postorder_iterative(root: Node) -> List[int]: pass def postorder_recursive(root: Node) -> List[int]: pass ``` Input * `root` (Node) - The root node of the binary tree. Each node has an integer value and pointers to left and right children (which might be None). Output * Returns a list of integers representing the values of nodes in postorder traversal. Constraints * The number of nodes in the tree is between 0 and 10^4. * Node values are integers. * The height of the tree will be <= 1000. Requirements 1. **Iterative Approach**: - Implement `postorder_iterative` method. - Use an explicit stack to achieve the postorder sequence. - Ensure the method works in O(n) time complexity. 2. **Recursive Approach**: - Implement `postorder_recursive` method. - Follow recursive paradigm to achieve the postorder sequence. - Ensure the method handles large depth trees efficiently. Example Input: ```python # Tree representation: # 1 # / # 2 3 # / # 4 5 root = Node(1) root.left = Node(2, Node(4), Node(5)) root.right = Node(3) ``` Output: ```python postorder_iterative(root) # should return [4, 5, 2, 3, 1] postorder_recursive(root) # should return [4, 5, 2, 3, 1] ``` Description 1. Create and populate a `Node` class as shown in the input example. 2. Implement and test both `postorder_iterative` and `postorder_recursive` methods. 3. Make sure to handle edge cases, such as empty trees or trees with only one node.","solution":"from typing import List, Optional class Node: def __init__(self, value: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.value = value self.left = left self.right = right def postorder_iterative(root: Optional[Node]) -> List[int]: if not root: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.value) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def postorder_recursive(root: Optional[Node]) -> List[int]: if not root: return [] return postorder_recursive(root.left) + postorder_recursive(root.right) + [root.value]"},{"question":"# Palindrome Checker Problem Your task is to implement a function that checks if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. You need to implement multiple variations of the palindrome checker to demonstrate your understanding of different approaches. Function Signatures 1. `is_palindrome(s: str) -> bool` 2. `is_palindrome_reverse(s: str) -> bool` 3. `is_palindrome_two_pointer(s: str) -> bool` 4. `is_palindrome_stack(s: str) -> bool` 5. `is_palindrome_deque(s: str) -> bool` Description 1. **is_palindrome(s: str) -> bool**: Use a basic two-pointer technique to implement the palindrome check. 2. **is_palindrome_reverse(s: str) -> bool**: Check if the string is a palindrome by reversing the string and comparing it with the original. 3. **is_palindrome_two_pointer(s: str) -> bool**: Use a two-pointer approach where you compare characters from front and back moving towards the center. 4. **is_palindrome_stack(s: str) -> bool**: Use a stack to perform the palindrome check by pushing half the string and then comparing it with the other half. 5. **is_palindrome_deque(s: str) -> bool**: Implement the checker using a deque to check if the string is a palindrome by comparing characters from both ends. Constraints - The string may contain non-alphanumeric characters. - The function should ignore cases. - You may assume the input string is a maximum of 10000 characters. Examples ```python assert is_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome(\\"race a car\\") == False assert is_palindrome(\\"\\") == True assert is_palindrome_reverse(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_reverse(\\"race a car\\") == False assert is_palindrome_reverse(\\"\\") == True assert is_palindrome_two_pointer(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_two_pointer(\\"race a car\\") == False assert is_palindrome_two_pointer(\\"\\") == True assert is_palindrome_stack(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_stack(\\"race a car\\") == False assert is_palindrome_stack(\\"\\") == True assert is_palindrome_deque(\\"A man, a plan, a canal: Panama\\") == True assert is_palindrome_deque(\\"race a car\\") == False assert is_palindrome_deque(\\"\\") == True ``` Please implement all five functions, ensuring they pass the provided test cases.","solution":"def is_palindrome(s: str) -> bool: Check if a given string is a palindrome considering only alphanumeric characters and ignoring cases using a basic two-pointer technique. s = \'\'.join(ch for ch in s if ch.isalnum()).lower() return s == s[::-1] def is_palindrome_reverse(s: str) -> bool: Check if a given string is a palindrome considering only alphanumeric characters and ignoring cases by reversing the string and comparing it with the original. s = \'\'.join(ch for ch in s if ch.isalnum()).lower() return s == s[::-1] def is_palindrome_two_pointer(s: str) -> bool: Check if a given string is a palindrome considering only alphanumeric characters and ignoring cases using a two-pointer approach where you compare characters from front and back moving towards the center. s = \'\'.join(ch for ch in s if ch.isalnum()).lower() left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True def is_palindrome_stack(s: str) -> bool: Check if a given string is a palindrome considering only alphanumeric characters and ignoring cases using a stack to perform the palindrome check by pushing half the string and then comparing it with the other half. from collections import deque s = \'\'.join(ch for ch in s if ch.isalnum()).lower() stack = deque() mid = len(s) // 2 for i in range(mid): stack.append(s[i]) if len(s) % 2 == 1: mid += 1 for i in range(mid, len(s)): if stack.pop() != s[i]: return False return True def is_palindrome_deque(s: str) -> bool: Check if a given string is a palindrome considering only alphanumeric characters and ignoring cases using a deque to check if the string is a palindrome by comparing characters from both ends. from collections import deque s = \'\'.join(ch for ch in s if ch.isalnum()).lower() d = deque(s) while len(d) > 1: if d.popleft() != d.pop(): return False return True"},{"question":"You are provided with a function `invert_matrix(m)` that inverts an `n x n` matrix. However, it does not handle all conditions efficiently and there might be potential improvements in performance and robustness. Your task is to modify/improve this function to make it more general, efficient, and robust. Specifically, you are to: 1. Ensure that the function can handle larger matrices more efficiently and correctly. 2. Determine whether the matrix can be inverted, and if not, handle this case gracefully. 3. Optimize the process, possibly by reducing redundant calculations or using more efficient libraries if deemed necessary. # Requirements - Input: An `n x n` nested list representing the matrix `A` (e.g., `[[a11, a12], [a21, a22]]`). - Constraints: - `2 <= n <= 200` - Matrix elements will be floating-point numbers within the range `-10^6` to `10^6`. - Output: An `n x n` nested list representing the inverted matrix `B`, or an error message if the matrix is non-invertible. # Function Signature `def invert_matrix(m: List[List[float]]) -> List[List[float]]:` # Example ```python # Example 1 A = [ [4, 7], [2, 6] ] output = invert_matrix(A) print(output) # Output should approximate to: # [ # [0.6, -0.7], # [-0.2, 0.4] # ] # Example 2 B = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] output = invert_matrix(B) print(output) # Output should approximate to: # [ # [-24, 18, 5], # [20, -15, -4], # [-5, 4, 1] # ] # Example 3 (Non-invertible case) C = [ [1, 2], [2, 4] ] output = invert_matrix(C) print(output) # Output should be [[\\"Matrix is singular and cannot be inverted\\"]] ``` # Notes - Your function should include all necessary validation for the dimensions and properties of the matrix. - Handle all potential edge cases, such as non-square matrices or singular matrices. - Consider efficiency trade-offs when implementing the inversion algorithm.","solution":"import numpy as np def invert_matrix(m): Returns the inverse of the matrix m if it is invertible. Otherwise, returns a descriptive error message. try: # Convert input matrix to numpy array matrix = np.array(m, dtype=np.float64) # Get the inverse using numpy inverted_matrix = np.linalg.inv(matrix) # Convert the result back to a nested list return inverted_matrix.tolist() except np.linalg.LinAlgError: return [[\\"Matrix is singular and cannot be inverted\\"]]"},{"question":"# Rabin-Miller Primality Test Enhancement Background One important application of large prime numbers is in the field of cryptography. Efficiently finding and verifying prime numbers is crucial. The Rabin-Miller primality test is a probabilistic test used to determine the primality of large numbers with high confidence. Task Your task is to implement the `is_prime` function using the Rabin-Miller test but with an added feature: allow the user to specify both the number ( k ) of iterations and a list of predefined witness values. If the list of witnesses is empty, use random values as in the traditional algorithm. Function Signature ```python def is_prime(n: int, k: int, witnesses: Optional[List[int]] = None) -> bool: ``` Input - `n` (int): The number to be tested for primality. - `k` (int): The number of iterations to run the test, increasing the confidence in the result. - `witnesses` (List[int], optional): A list of witness values to be used in the test. If not provided, random values will be used. Output Returns `True` if the number is probably prime, or `False` if it is definitely composite. Constraints - ( n geq 2 ) - ( k geq 1 ) Example ```python assert is_prime(17, 5) == True assert is_prime(100, 5) == False assert is_prime(561, 5, [2, 3, 5]) == False ``` Explanation - The first test checks if 17 is prime with 5 iterations, returning True. - The second test checks if 100 is composite with 5 iterations, returning False. - The third test specifically uses witnesses [2, 3, 5] to test 561, a known Carmichael number, and returns False. Note The function should handle special cases where ( n ) is less than 5 directly, as per the given analysis.","solution":"import random from typing import List, Optional def is_prime(n: int, k: int, witnesses: Optional[List[int]] = None) -> bool: if n <= 3: return n == 2 or n == 3 if n % 2 == 0: return False def miller_rabin_test(a, d, s, n): x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(s - 1): x = pow(x, 2, n) if x == n - 1: return True return False # Write n as d * 2^s + 1 s = 0 d = n - 1 while d % 2 == 0: d //= 2 s += 1 if witnesses is None: witnesses = [random.randint(2, n - 2) for _ in range(k)] else: witnesses = witnesses[:k] for a in witnesses: if not miller_rabin_test(a, d, s, n): return False return True"},{"question":"# Question: Implement a More Efficient Duplicate Removal Function Context You have been provided with an initial implementation of a duplicate removal algorithm. However, the current implementation is inefficient for large datasets due to its quadratic time complexity. Your task is to optimize the algorithm to improve its performance using more efficient data structures. Task Write a function `optimized_remove_duplicates` that takes an array (list) as input and returns a new array with duplicates removed while maintaining the original order of the first occurrences of each element. Requirements - Implement the function using hash sets (or dictionaries) to track seen elements for more efficient lookups. - Ensure the function works for arrays containing any combination of data types (integers, strings, booleans, etc.). - The function should have a time complexity of (O(n)). Function Signature ```python def optimized_remove_duplicates(array: list) -> list: pass ``` Input - `array` (list): An array of elements, possibly containing duplicates. Output - `list`: A new array with duplicates removed, preserving the order of first occurrences. Constraints - The array can contain a mix of integers, strings, booleans, and other hashable types. - The array length (n) (0 ≤ n ≤ 10^6). Example ```python assert optimized_remove_duplicates([1, 1 ,1 ,2 ,2 ,3 ,4 ,4 ,\\"hey\\", \\"hey\\", \\"hello\\", True, True]) == [1, 2, 3, 4, \'hey\', \'hello\'] assert optimized_remove_duplicates([]) == [] assert optimized_remove_duplicates([\\"a\\", \\"b\\", \\"a\\", \\"c\\", \\"b\\"]) == [\\"a\\", \\"b\\", \\"c\\"] assert optimized_remove_duplicates([True, False, True, False]) == [True, False] ``` Edge Cases - The function should return an empty list if the input array is empty. - The function should handle arrays with mixed types correctly.","solution":"def optimized_remove_duplicates(array: list) -> list: Removes duplicates from the array while maintaining the order of first occurrences of each element. seen = set() result = [] for elem in array: if elem not in seen: seen.add(elem) result.append(elem) return result"},{"question":"Objective You need to determine if a given input string of words follows the same pattern as provided by a pattern string. The relationship between pattern characters and words in the input string must form a bijective mapping. Function Signature ```python def word_pattern_match(pattern: str, input_string: str) -> bool: ``` Input - `pattern` (String): A pattern string composed of lowercase letters only. - `input_string` (String): An input string composed of words separated by a single space, using lowercase letters only. Output - **Boolean**: Return `True` if the input_string follows the same pattern as the pattern string; otherwise, return `False`. Constraints - 1 <= len(pattern) <= 1000 - 1 <= len(input_string) <= 10000 - Each word in input_string is separated by exactly one space. - Pattern contains only lowercase letters, input_string contains only lowercase letters and spaces. Examples ```python # Example 1 pattern = \\"abba\\" input_string = \\"dog cat cat dog\\" # Output: True # Example 2 pattern = \\"abba\\" input_string = \\"dog cat cat fish\\" # Output: False # Example 3 pattern = \\"aaaa\\" input_string = \\"dog cat cat dog\\" # Output: False # Example 4 pattern = \\"abba\\" input_string = \\"dog dog dog dog\\" # Output: False ``` Scenario Imagine you are developing a command interpreter that needs to check if given commands follow a specific pattern. Each command is a sequence of words separated by spaces, and you have a pattern string of characters. You need to implement a function to validate these commands against the supplied pattern.","solution":"def word_pattern_match(pattern: str, input_string: str) -> bool: Function to determine if input_string follows the same pattern as the pattern string. words = input_string.split() if len(words) != len(pattern): return False char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p in char_to_word: if char_to_word[p] != w: return False else: if w in word_to_char: return False char_to_word[p] = w word_to_char[w] = p return True"},{"question":"# Coding Challenge: Cosine Similarity Extension **Objective**: Given the function `cosine_similarity` that calculates the cosine similarity between two vectors, enhance it to handle edge cases more gracefully and to add the capability to compare multiple vectors against a single reference vector. **Function Definition**: * `enhanced_cosine_similarity(vec1, vec2s)` * **Input**: * `vec1`: A single reference vector (list of floats/integers). * `vec2s`: A list of vectors (list of list of floats/integers) to compare with `vec1`. * **Output**: * A list of float values representing the cosine similarity between `vec1` and each vector in `vec2s`. **Constraints**: * Both `vec1` and each vector in `vec2s` must have the same length. * If any vector in `vec2s` has a zero norm, return `None` for that vector\'s similarity score. * If `vec1` has a zero norm, raise a `ValueError`. **Example**: ```python vec1 = [1, 1, 1] vec2s = [[1, 2, -1], [0, 0, 0], [3, 3, 3]] print(enhanced_cosine_similarity(vec1, vec2s)) # Output: [0.47140452079103173, None, 1.0] ``` **Function Signature**: ```python def enhanced_cosine_similarity(vec1: list, vec2s: list) -> list: # Your code here pass ``` Implement the `enhanced_cosine_similarity` function based on the above requirements.","solution":"from typing import List import math def dot_product(vec1, vec2): return sum(x * y for x, y in zip(vec1, vec2)) def magnitude(vec): return math.sqrt(sum(x * x for x in vec)) def cosine_similarity_calculator(vec1, vec2): mag1 = magnitude(vec1) mag2 = magnitude(vec2) if mag1 == 0: raise ValueError(\\"The reference vector \'vec1\' has a zero norm.\\") if mag2 == 0: return None return dot_product(vec1, vec2) / (mag1 * mag2) def enhanced_cosine_similarity(vec1: List[float], vec2s: List[List[float]]) -> List[float]: similarities = [] for vec2 in vec2s: similarity = cosine_similarity_calculator(vec1, vec2) similarities.append(similarity) return similarities"},{"question":"Scenario You are given an array of integers where elements can be either negative, zero, or positive. Your task is to find all unique triplets in the array that sum to zero. This question will test your understanding of sorting an array, using the two-pointer technique, and handling duplicate entries effectively. Task Implement the `three_sum` function that consumes an array of integers and returns a set of unique triplets (as tuples) which sum up to zero. Input - An unsorted list of integers: `array` where `1 <= len(array) <= 10^4` and `-10^5 <= array[i] <= 10^5`. Output - A set of tuples, where each tuple contains three integers from the array such that their sum is zero and no duplicate triplets should be present. Function Signature ```python def three_sum(array: List[int]) -> Set[Tuple[int, int, int]]: pass ``` Constraints - The solution should be efficient in both time and space complexity. - Sorting the array is allowed and usage of additional data structures like sets or lists is acceptable. - Ensure that your solution avoids duplicate triplets in the result set. Example ```python # Example array = [-1, 0, 1, 2, -1, -4] assert three_sum(array) == {(-1, 0, 1), (-1, -1, 2)} array = [0, 0, 0, 0] assert three_sum(array) == {(0, 0, 0)} ``` Explanation - For the first example, the unique triplets that sum up to zero are (-1, 0, 1) and (-1, -1, 2). - For the second example, the only possible triplet is (0, 0, 0) avoiding duplicates. Notes - Carefully handle edge cases such as arrays with fewer than three elements. - Ensure no duplicate triplets in the result set.","solution":"from typing import List, Set, Tuple def three_sum(array: List[int]) -> Set[Tuple[int, int, int]]: array.sort() n = len(array) result = set() for i in range(n): if i > 0 and array[i] == array[i-1]: continue left, right = i + 1, n - 1 while left < right: current_sum = array[i] + array[left] + array[right] if current_sum == 0: result.add((array[i], array[left], array[right])) while left < right and array[left] == array[left + 1]: left += 1 while left < right and array[right] == array[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return result"},{"question":"You are tasked with extending the function to convert both IPv4 and IPv6 addresses into their respective binary representations. # Specifications: For IPv4: * Expected Input: A string representing an IPv4 address (e.g., \\"192.168.0.1\\"). * Expected Output: A string depicting the binary representation of the IPv4 address, maintaining the octet groupings (e.g., \\"11000000.10101000.00000000.00000001\\"). For IPv6: * Expected Input: A string representing an IPv6 address (e.g., \\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\\"). * Expected Output: A string depicting the binary representation of the IPv6 address, maintaining the grouping of bits into 16-bit hexadecimal chunks (e.g., \\"0010000000000001:0000110110111000:1000010110100011:0000000000000000:0000000000000000:1000101000101110:0000001101110000:0111001100110100\\"). # Constraints: 1. Valid IPv4 addresses range from \\"0.0.0.0\\" to \\"255.255.255.255\\". 2. Valid IPv6 addresses follow full, compressed, or mixed notations. 3. Assume the input will always be a valid IP address. # Function Signature: ```python def ip_to_binary(ip: str) -> str: pass ``` # Examples: 1. `ip_to_binary(\\"192.168.0.1\\")` should return `\\"11000000.10101000.00000000.00000001\\"` 2. `ip_to_binary(\\"0.0.0.0\\")` should return `\\"00000000.00000000.00000000.00000000\\"` 3. `ip_to_binary(\\"255.255.255.255\\")` should return `\\"11111111.11111111.11111111.11111111\\"` 4. `ip_to_binary(\\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\\")` should return `\\"0010000000000001:0000110110111000:1000010110100011:0000000000000000:0000000000000000:1000101000101110:0000001101110000:0111001100110100\\"` 5. `ip_to_binary(\\"::1\\")` should provide a proper binary representation based on the IPv6 notation. # Notes: - For simplicity, handle compressed IPv6 notations by expanding them before binary conversion. Utilize utilities to aid in this where necessary. - Consider efficiency in conversion by potentially optimizing binary operations using Python\'s core functionality.","solution":"import ipaddress def ip_to_binary(ip: str) -> str: if \':\' in ip: # IPv6 address ip_object = ipaddress.IPv6Address(ip) return \':\'.join(format(int(x, 16), \'016b\') for x in ip_object.exploded.split(\':\')) else: # IPv4 address ip_object = ipaddress.IPv4Address(ip) return \'.\'.join(format(int(x), \'08b\') for x in ip.split(\'.\'))"},{"question":"# Matrix Power Calculation **Context**: You are developing a library of linear algebra utilities for scientific computing. One of the necessary functions is efficient computation of the power of a square matrix. Your task is to implement a function that computes the power of a matrix using matrix exponentiation. **Problem Statement**: Implement a function `matrix_power(mat: list, n: int) -> list` that takes a square matrix `mat` of dimension `d x d` and a non-negative integer `n`, and returns the matrix raised to the power `n`. **Function Signature**: ```python def matrix_power(mat: list, n: int) -> list: pass ``` **Input**: - `mat`: A list of lists where each sublist is of length `d` and itself is `d` such that it represents a `d x d` matrix. The elements of the matrix are integers. - `n`: A non-negative integer representing the power to which the matrix should be raised. **Output**: - A list of lists representing the matrix `mat` raised to the power `n`. **Constraints**: - The matrix `mat` will always be square (d x d). - `0 <= n <= 10^9` - Elements in the matrix can be between -100 and 100. **Example**: ```python mat = [ [2, 0], [0, 2] ] n = 3 ``` **Output**: ```python [ [8, 0], [0, 8] ] ``` Remember to handle edge cases such as: - n = 0 (should return the identity matrix). - d = 1 (single element matrix). **Performance Requirement**: Ensure that your solution operates within the time complexity O(d^3 log(n)) to handle large powers efficiently.","solution":"def matrix_multiply(mat1, mat2): Multiplies two matrices mat1 and mat2. d = len(mat1) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += mat1[i][k] * mat2[k][j] return result def matrix_identity(d): Returns the identity matrix of dimension d x d. identity = [[0] * d for _ in range(d)] for i in range(d): identity[i][i] = 1 return identity def matrix_power(mat, n): Computes the power of a square matrix mat raised to the power n. d = len(mat) if n == 0: return matrix_identity(d) elif n == 1: return mat half_power = matrix_power(mat, n // 2) half_power_squared = matrix_multiply(half_power, half_power) if n % 2 == 0: return half_power_squared else: return matrix_multiply(half_power_squared, mat)"},{"question":"# Bogo Sort Challenge Bogo Sort, also known as permutation sort or stupid sort, is a highly inefficient sorting algorithm based on generating random permutations of its input until it finds one that is sorted. Although it is not used in practice, understanding the algorithm can highlight the importance of efficient algorithm design. Problem Statement You are given a list of integers. Your task is to write a function `bogo_sort(arr)` that sorts this list using the Bogo Sort algorithm. To facilitate understanding of the algorithm\'s inefficiency, you also need to execute the sorting several times and collect performance metrics including the total number of permutations tried and the time taken. Function Signature ```python def bogo_sort(arr: List[int]) -> Tuple[List[int], int, float]: Sorts an input list using Bogo Sort and returns a tuple consisting of the sorted list, the number of permutations tried, and the time taken in seconds. :param arr: List[int] - List of integers to sort. :return: Tuple[List[int], int, float] - Returns sorted list, number of permutations tried, and the time taken. ``` # Input * `arr`: List of integers with length ( 0 leq len(arr) leq 10 ) * **Constraints**: The input list can contain any integer values, both positive and negative. # Output * A tuple containing: * **sorted list**: List of integers sorted in non-decreasing order. * **number of permutations tried**: An integer representing how many random permutations were generated. * **time taken**: A float indicating the total time taken to sort the list in seconds. # Performance Requirements * For assessing student understanding, there are no specific performance requirements. However, exploring the inefficiency is part of the exercise. * The sorting should continue until the list is sorted, regardless of how long it takes. # Scenario Consider you are tasked with sorting a small dataset for which conventional sorting algorithms are unavailable, and the only option left is the Bogo Sort. Demonstrate how Bogo Sort works by implementing the sorting function and tracking the process metrics. # Example ```python input_list = [3, 1, 2] # Expected output - (sorted list, number of permutations tried, time taken in seconds) output = bogo_sort(input_list) # Possible output: ([1, 2, 3], 5, 0.004) ``` Notes - Run the function multiple times to observe variations in permutations tried and time taken. - Ensure that your implementation handles trivial cases like an already sorted list and an empty list.","solution":"import random import time from typing import List, Tuple def is_sorted(arr: List[int]) -> bool: Helper function to check if a list is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr: List[int]) -> Tuple[List[int], int, float]: Sorts an input list using Bogo Sort and returns a tuple consisting of the sorted list, the number of permutations tried, and the time taken in seconds. :param arr: List[int] - List of integers to sort. :return: Tuple[List[int], int, float] - Returns sorted list, number of permutations tried, and the time taken. permutations_tried = 0 start_time = time.time() while not is_sorted(arr): random.shuffle(arr) permutations_tried += 1 end_time = time.time() time_taken = end_time - start_time return arr, permutations_tried, time_taken"},{"question":"Context You\'re given a set of data points in a multi-dimensional space, and each point has an associated label. Your task is to implement a function that finds the label of the point in the training set that is nearest to a given query point using the Nearest Neighbor algorithm. Problem Statement Implement a function `nearest_neighbor(x, tSet)` that takes in: 1. `x` (tuple): A point in n-dimensional space. 2. `tSet` (dictionary): A dictionary representing the training set, where keys are tuples representing points in n-dimensional space and values are their associated labels. Your function should return the label of the point in `tSet` that is closest to the point `x`. Input - `x`: A tuple of floats/integers. Length of the tuple can vary but it will match the length of the tuples in `tSet`. - `tSet`: A dictionary where keys are tuples of floats/integers of the same length as `x` and values are labels (strings). Output - A string representing the label of the nearest point to `x`. Performance Requirements - The distance function should ensure minimal overhead, but assume basic linear search in nearest neighbor. Example ```python x = (2.5, 3.5) tSet = { (1.0, 2.0): \\"A\\", (3.0, 4.0): \\"B\\", (2.0, 3.0): \\"C\\" } print(nearest_neighbor(x, tSet)) # Output: \\"B\\" ``` Constraints - All vector points and query points will have a positive, non-zero length. - Training set `tSet` will contain at least one point. Function Signature ```python import math def nearest_neighbor(x: tuple, tSet: dict) -> str: # Your code here pass ```","solution":"import math def nearest_neighbor(x, tSet): Finds the label of the point in the training set that is nearest to the point x. Parameters: x (tuple): A point in n-dimensional space. tSet (dict): A dictionary where keys are tuples representing points in n-dimensional space and values are their associated labels. Returns: str: The label of the nearest point to x. def euclidean_distance(point1, point2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) closest_point = None min_distance = float(\'inf\') for point in tSet: distance = euclidean_distance(x, point) if distance < min_distance: min_distance = distance closest_point = point return tSet[closest_point]"},{"question":"# Coding Problem: Advanced Interpolation Search Implementation Problem Description: You are tasked with implementing an enhanced version of the interpolation search algorithm that can handle non-uniform distributions efficiently. Your algorithm should still aim to maintain O(log log n) efficiency in the average case but should include a fallback mechanism to avoid worst-case O(n) performance. Function Signature: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: :param array: A sorted list of integers. :param search_key: The key to be searched for in the array. :return: The index of the search_key if found, otherwise -1. Input: * `array`: A list of sorted integers in ascending order, with length `n`. * `search_key`: An integer key to be searched within the array. Output: * Return the index of `search_key` if found in the array; otherwise, return -1. Constraints: * The length of the array (n) is 1 <= n <= 10^5. * Elements of the array are between -10^9 and 10^9. Example Usage: ```python print(enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 14)) # Output: 3 print(enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # Output: -1 print(enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 5)) # Output: 0 print(enhanced_interpolation_search([], 1)) # Output: -1 ``` Notes: * You may assume the function will only be called with already sorted arrays as an input. * The function should handle edge cases including an empty array and very large or very small search keys relative to the array elements. * Consider including a fallback mechanism such as a transition to binary search when necessary to maintain efficiency.","solution":"def enhanced_interpolation_search(array, search_key): Returns the index of search_key in the sorted array if found, otherwise -1. if not array: return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 if abs(high - low) < 10: # Fallback to binary search if range is small return binary_search(array, low, high, search_key) return -1 def binary_search(array, low, high, search_key): while low <= high: mid = (low + high) // 2 if array[mid] == search_key: return mid elif array[mid] < search_key: low = mid + 1 else: high = mid - 1 return -1"},{"question":"# Question: Rotate a Singly-Linked List Problem Statement You are given a singly-linked list and an integer `k`. Your task is to rotate the list to the right by `k` places. Implementation Requirements Write a function `rotate_right(head: ListNode, k: int) -> ListNode` where: - `head` is the head node of a singly-linked list. - `k` is a non-negative integer representing the number of places to rotate the list to the right. The function should return the new head of the rotated list. Input - The `head` of a singly-linked list, where each node is defined as `ListNode(val: int, next: Optional[ListNode] = None)`. - A non-negative integer `k`. Output - The rotated list\'s head node. Constraints - The number of nodes in the list is in the range [0, 500]. - `-100 <= Node.val <= 100`. - `0 <= k <= 2 * 10^9`. Example **Example 1:** ``` Input: head = [1, 2, 3, 4, 5], k = 2 Output: [4, 5, 1, 2, 3] ``` Explanation: Rotating the list to the right by 2 places results in [4, 5, 1, 2, 3]. **Example 2:** ``` Input: head = [0, 1, 2], k = 4 Output: [2, 0, 1] ``` Explanation: Rotating the list to the right by 4 places results in [2, 0, 1]. Edge Cases - Handle when the list is empty (`head` is `None`). - Handle when `k % length_of_list == 0` (no change in list). - Handle single-element list. Performance Requirements Your solution should be efficient and work in O(N) time complexity, where N is the number of nodes in the list.","solution":"class ListNode: def __init__(self, val: int = 0, next: \'ListNode\' = None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # First, determine the length of the list length = 1 current = head while current.next: length += 1 current = current.next # Connect the end of the list to the head to make it circular current.next = head # Calculate the effective rotation k = k % length if k == 0: current.next = None return head steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"Implement a Multi-Commodity Max Flow Algorithm Scenario You work for a logistics company that optimizes the movement of goods through a network of warehouses and transport routes. Each path between warehouses has a certain capacity, and you need to compute the maximum number of different types of goods (commodities) that can be simultaneously transported from different sources to different sinks. Task Implement a function `multi_commodity_max_flow` that calculates the maximum flow for multiple commodities in a flow network using any of the provided algorithms: Ford-Fulkerson, Edmonds-Karp, or Dinic\'s Algorithm. Function Signature ```python def multi_commodity_max_flow(capacities, sources, sinks): Calculates the maximum flow for multiple commodities in a flow network. Parameters: capacities (List[List[int]]): A 2D array representing the capacities of each edge in the graph. sources (List[int]): A list of source nodes for each commodity. sinks (List[int]): A list of sink nodes for each commodity. Returns: int: The maximum flow that can be transported for all commodities. pass ``` Constraints * All capacities are non-negative integers. * The graph can have up to 500 vertices and 2000 edges. * Each source and sink pair corresponds to a single type of commodity. Input/Output Example ```python capacities = [ [0, 10, 10, 0, 0, 0], [0, 0, 2, 4, 8, 0], [0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 10], [0, 0, 0, 6, 0, 10], [0, 0, 0, 0, 0, 0] ] sources = [0, 1] sinks = [5, 4] max_flow = multi_commodity_max_flow(capacities, sources, sinks) print(max_flow) # Expected Output: 29 ``` Notes * Ensure your solution handles all provided constraints efficiently. * Consider using helper functions to facilitate creating augmenting paths. * Clearly document your code and explain the choice of algorithm if implementing more than one approach.","solution":"from collections import deque def bfs(capacities, source, sink, parent): Returns True if there is a path from source to sink in the residual graph. Also fills parent[] to store the path. visited = [False] * len(capacities) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(capacities[u]): if not visited[v] and capacity > 0: # Not visited and capacity > 0 means it\'s part of the residual graph queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def edmonds_karp(capacities, source, sink): Implementation of the Edmonds-Karp algorithm for finding the max flow. parent = [-1] * len(capacities) max_flow = 0 while bfs(capacities, source, sink, parent): # Find the maximum flow through the path found by BFS. path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, capacities[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] capacities[u][v] -= path_flow capacities[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow def multi_commodity_max_flow(capacities, sources, sinks): Calculates the maximum flow for multiple commodities in a flow network. Parameters: capacities (List[List[int]]): A 2D array representing the capacities of each edge in the graph. sources (List[int]): A list of source nodes for each commodity. sinks (List[int]): A list of sink nodes for each commodity. Returns: int: The maximum flow that can be transported for all commodities. total_flow = 0 for i in range(len(sources)): # Temporary copy of capacities for each commodity. temp_capacities = [row[:] for row in capacities] total_flow += edmonds_karp(temp_capacities, sources[i], sinks[i]) return total_flow"},{"question":"Scenario Imagine you have a nested dictionary that represents an organizational hierarchy, where each key is a top-level categorization (like different team leads), and the value is another dictionary containing team members and the projects they are working on with their respective priority levels. You are required to write a function `print_hierarchy(tree)` that takes this dictionary as input and prints its hierarchical structure similar to the `tree_print(tree)` function provided. Additionally, you need to ensure the function handles different levels of depth and mixed data types effectively. Function Signature ```python def print_hierarchy(tree: dict) -> None: pass ``` Input Format * A nested dictionary `tree`, where the top-level keys are strings representing different categories or team leads. * The values for these keys are dictionaries where again the keys are team members\' names or another nested dictionary. Output Format * Print the hierarchical structure level by level. Each main key (category/team lead) starts at a new line, followed by indentations for sub-level keys/values. Constraints * All keys in `tree` are strings. * Sub-elements might include strings, integers, or further dictionaries. Sample Input ```python tree = { \'a\': {\'Adam\': \'Book\', \'Book\': 4}, \'b\': { \'Bill\': {\'Computer\': 5, \'TV\': 6}, \'Jill\': {\'Sports\': 1} }, \'c\': {\'Bill\': {\'Sports\': 3}}, \'d\': { \'Adam\': {\'Computer\': 3}, \'Quin\': {\'Computer\': 3} }, \'e\': {\'Quin\': {\'Book\': 5, \'TV\': 2}}, \'f\': {\'Adam\': {\'Computer\': 7}} } ``` Sample Output ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 TV -> 2 f -> Adam -> Computer -> 7 ``` You should carefully consider edge cases and ensure all nested structures are handled gracefully.","solution":"def print_hierarchy(tree: dict) -> None: def print_nested_dict(current_dict, indent=0): for key, value in current_dict.items(): print(\' \' * indent * 2 + key, end=\' -> \') if isinstance(value, dict): print() print_nested_dict(value, indent + 1) else: print(value) print_nested_dict(tree)"},{"question":"# Context: You have been given the task to implement a function that performs a level order traversal (Breadth-First Search) on a given binary tree. The function should return values from each level in the form of lists collected in a parent list. This illustrates how we can query or visualize the hierarchical structure of trees level by level in various applications such as organizational data, tagging hierarchies in databases, etc. # Problem Statement: Given a binary tree, return the level order traversal of its nodes\' values. # Function Signature: ```python def level_order(root: Optional[TreeNode]) -> List[List[int]]: ``` # Input: - The `root` is a node of type `TreeNode` (a binary tree node). - `TreeNode` class has the following attributes: - `val` (int): the value of the node. - `left` (TreeNode): the left child of the node. - `right` (TreeNode): the right child of the node. # Output: - Return a list of lists, where each inner list contains the values of nodes at each level (from top to bottom). # Constraints: - Node values are integers. - The number of nodes in the tree can range from 0 to 10,000. # Example: Given Binary Tree: ``` 3 / 9 20 / 15 7 ``` ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) ``` Function call: ```python print(level_order(root)) ``` Expected output: ```python [[3], [9, 20], [15, 7]] ``` # Hint: Use a queue (FIFO data structure) to keep track of nodes and to traverse the tree level by level.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_values = [] for _ in range(level_length): node = queue.popleft() level_values.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_values) return result"},{"question":"# Roman Numeral Dependency Checker You are tasked with creating a utility that analyzes a list of Roman numeral dependencies in a project. Each projection module is represented by a Roman numeral and has dependencies on other modules (also represented by Roman numerals). A projection module cannot be installed unless all its dependencies are already installed. Your goal is to convert these Roman numerals into integers, identify any cycles in the dependencies (which would prevent correct installation), and provide an installation sequence that satisfies all dependencies. Implement a function `can_install_all_particles(modules, dependencies)` that performs this task. If all modules can be installed, the function should return a list of modules in the order they should be installed. If there are cyclic dependencies, return an empty list. Function Signature ```python def can_install_all_particles(modules: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: pass ``` Input * **modules**: A list of strings where each string is a Roman numeral representing a module. * **dependencies**: A list of tuples (A, B) where A and B are Roman numerals, indicating that module A depends on module B. Output * A list of strings representing the installation order of modules. * An empty list if there are cyclic dependencies. Constraints * All Roman numerals in the inputs are guaranteed to be valid and within the range from \\"I\\" to \\"MMCMXCIX\\" (1 to 3999 in integer representation). Example Input: ```python modules = [\\"I\\", \\"II\\", \\"III\\", \\"IV\\"] dependencies = [(\\"II\\", \\"I\\"), (\\"III\\", \\"II\\"), (\\"IV\\", \\"III\\")] ``` Output: ```python [\\"I\\", \\"II\\", \\"III\\", \\"IV\\"] ``` Input: ```python modules = [\\"I\\", \\"II\\", \\"III\\", \\"IV\\"] dependencies = [(\\"II\\", \\"I\\"), (\\"III\\", \\"II\\"), (\\"IV\\", \\"III\\"), (\\"I\\", \\"IV\\")] ``` Output: ```python [] ``` Guidelines 1. Convert Roman numerals to integers for ease of processing. 2. Use topological sorting to determine if a valid installation order exists. 3. Return an empty list if a cycle is detected in the dependency graph.","solution":"from typing import List, Tuple def roman_to_int(s: str) -> int: roman = {\'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000} result = 0 prev_value = 0 for char in reversed(s): value = roman[char] if value < prev_value: result -= value else: result += value prev_value = value return result def can_install_all_particles(modules: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: # Convert Roman numerals to integers module_dict = {module: roman_to_int(module) for module in modules} # Create adjacency list for topological sort adj_list = {module: [] for module in modules} indeg = {module: 0 for module in modules} for dep in dependencies: adj_list[dep[1]].append(dep[0]) indeg[dep[0]] += 1 # Perform topological sort using Kahn\'s algorithm from collections import deque zero_indeg_queue = deque([module for module, degree in indeg.items() if degree == 0]) topo_order = [] while zero_indeg_queue: current = zero_indeg_queue.popleft() topo_order.append(current) for neighbor in adj_list[current]: indeg[neighbor] -= 1 if indeg[neighbor] == 0: zero_indeg_queue.append(neighbor) if len(topo_order) == len(modules): return topo_order # Successfully found topological order else: return [] # Cycle detected"},{"question":"# Binary Tree Serialization and Deserialization with Constraints Context: You\'re developing a module for a database system that needs to efficiently serialize and deserialize binary trees. The binary tree\'s structure must be preserved accurately to ensure the integrity of the stored and retrieved data. Task: Write two functions, `serialize` and `deserialize`, for converting a binary tree into a string and vice versa. Function Signatures: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: pass def deserialize(data: str) -> TreeNode: pass ``` Input/Output: * The `serialize` function takes the root of a binary tree and returns a string representing the serialized tree. * The `deserialize` function takes a string representing a serialized binary tree and returns the root of the reconstructed tree. * If the input is an empty tree (i.e., `root` is None), the output should be an empty string for `serialize` and `None` for `deserialize`. Constraints: 1. The number of nodes in the tree will not exceed 10^4. 2. The serialized string will have an overall length within the range [1, 5 x 10^4]. 3. Node values are integers and will lie in the range [-10^5, 10^5]. Example: ```python # Example Binary Tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) # Serialize the tree serialized_data = serialize(root) print(serialized_data) # Output: \\"1 2 # # 3 4 # # 5 # #\\" # Deserialize the tree deserialized_root = deserialize(serialized_data) # The deserialized_root should represent the same tree structure as \'root\' ``` Performance Requirements: * Both `serialize` and `deserialize` functions should run in O(n) time complexity, where n is the number of nodes in the binary tree. * They should also use O(n) space complexity, considering the recursive stack and the space needed to store the serialized string. Write your code to implement these functions while ensuring it passes all possible edge cases and constraints provided.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def dfs(node): if not node: return \\"#\\" return f\\"{node.val} {dfs(node.left)} {dfs(node.right)}\\" return dfs(root) def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def dfs(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = dfs(nodes) node.right = dfs(nodes) return node nodes = iter(data.split()) return dfs(nodes)"},{"question":"# Question: Implement and Analyze Custom Interpolation Search Context: A software firm is building a library for high-performance search operations. They plan to utilize the Interpolation Search algorithm to improve search efficiency in large datasets that are uniformly distributed. They need a robust implementation and a detailed analysis to make informed decisions. Task: Implement the interpolation search algorithm and extend it to handle cases where the array might include negative numbers, very large positive numbers, or even be empty. Function Signature: ```python from typing import List def custom_interpolation_search(array: List[int], search_key: int) -> int: :param array: The sorted array in which to search. :param search_key: The key to search for in the array. :returns: The index of search_key if present, else -1. ``` Input and Output: * **Input**: * `array` should be a list of integers. * `search_key` should be an integer. * **Output**: * The function should return an integer index of `search_key` if found in the array, otherwise, it should return `-1`. Constraints: * The input array can be empty. * The array elements are in increasing order. * The input array may contain very large or very small integers. Requirements: 1. **Implementation**: Write a function that performs the interpolation search. 2. **Edge Cases**: Handle edge cases like empty arrays, arrays with uniformly distributed and non-uniformly distributed data. 3. **Efficiency**: The implementation should be efficient, leveraging the predictive capabilities of Interpolation Search. Example: ```python print(custom_interpolation_search([-100, -50, 0, 50, 100], 50)) # Output: 3 print(custom_interpolation_search([1, 100, 1000, 10000, 100000], 5000)) # Output: -1 print(custom_interpolation_search([], 5)) # Output: -1 print(custom_interpolation_search([0, 0, 0, 0, 0], 0)) # Output: 0 ``` Analysis Points: * Describe how your implementation handles edge cases and potential performance bottlenecks. * Discuss any assumptions made during the implementation. * Provide time and space complexity analysis of your implementation. * Explain how you can optimize the implementation further if needed.","solution":"from typing import List def custom_interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search on a sorted list for the search_key. :param array: The sorted array in which to search. :param search_key: The key to search for in the array. :returns: The index of search_key if present, else -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Avoid division by zero if array[low] == array[high]: if array[low] == search_key: return low else: return -1 # Probing the position with keeping uniform distribution in mind pos = low + ((search_key - array[low]) * (high - low) // (array[high] - array[low])) # Condition of target found if array[pos] == search_key: return pos # If search_key is larger, search in the upper part of the array if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part of the array else: high = pos - 1 return -1"},{"question":"# Problem Description You have been hired as a project manager where you have a list of projects defined by their start time, end time, and profit earned on completion. Your goal is to maximize the profit by selecting non-overlapping projects. # Task Implement a function `maximize_profit(projects: List[Tuple[int, int, int]]) -> int` to calculate the maximum possible profit achievable from non-overlapping projects. # Input * `projects` (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers [start, finish, profit] representing: - `start` – Start time of the project. - `finish` – Finish time of the project. - `profit` – Profit earned upon completing the project. # Output * Returns an integer value representing the maximum possible profit. # Constraints * Timestamps and profits are non-negative integers. * `0 <= start < finish <= 10^4` * `1 <= len(projects) <= 10^3` # Example ```python projects = [(1, 2, 50), (3, 5, 20), (6, 19, 100), (2, 100, 200)] print(maximize_profit(projects)) # Output: 250 ``` # Notes * Ensure that the function properly handles scenarios with overlapping and non-overlapping projects. * Apply efficient algorithms for sorting and finding non-conflicting projects to handle the input size within permissible limits.","solution":"from typing import List, Tuple def maximize_profit(projects: List[Tuple[int, int, int]]) -> int: # Sort the projects by their finish time projects.sort(key=lambda x: x[1]) # Function to find the last non-conflicting project def find_last_non_conflicting(index): for j in range(index - 1, -1, -1): if projects[j][1] <= projects[index][0]: return j return -1 n = len(projects) dp = [0] * n dp[0] = projects[0][2] for i in range(1, n): incl_profit = projects[i][2] l = find_last_non_conflicting(i) if l != -1: incl_profit += dp[l] dp[i] = max(incl_profit, dp[i - 1]) return dp[-1]"},{"question":"# Assessment Question: Implement a Custom Gnome Sort Imagine you are working on a sorting library and want to include the Gnome Sort algorithm as one of the available sorting methods. You need to implement this algorithm with a slight twist: instead of sorting in ascending order, the function should sort the array in **descending order**. Implement the function `gnome_sort_descending(arr)` that takes a list of integers `arr` and sorts it in descending order using the principles of Gnome Sort. Function Signature ```python def gnome_sort_descending(arr: list[int]) -> list[int]: ``` Input - `arr`: A list of integers to sort. (0 <= len(arr) <= 10^5) Output - Return the sorted list in descending order. Constraints - The list can have up to 100,000 elements. - Elements of the list are integers within the range -10^6 to 10^6. Performance Requirements - Even though Gnome Sort\'s worst-case time complexity is O(n^2), consider reviewing and handling average cases for practical input sizes. Example ```python assert gnome_sort_descending([5, 1, 4, 2, 8]) == [8, 5, 4, 2, 1] assert gnome_sort_descending([]) == [] assert gnome_sort_descending([1]) == [1] assert gnome_sort_descending([3, -1, 3, 0, 2]) == [3, 3, 2, 0, -1] ```","solution":"def gnome_sort_descending(arr: list[int]) -> list[int]: Sorts the list in descending order using the Gnome Sort algorithm. pos = 0 while pos < len(arr): if pos == 0 or arr[pos] <= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr"},{"question":"# Question: Implement an improved Cocktail Shaker Sort You are tasked with implementing an improved version of the Cocktail Shaker Sort. The provided implementation sorts a given list of integers in ascending order. Requirements: * Your function should be named `improved_cocktail_shaker_sort`. * Additional optimizations to enhance performance, such as early stopping in both passes, should be implemented. * Ensure proper handling of edge cases, including empty and single-element arrays. * The function should work efficiently within the time complexity constraints given. * **Input**: An unsorted list of integers, `arr`. * **Output**: A sorted list of integers, resulting from the improved cocktail shaker sort. Input Format: - A list of integers, `arr`, of length `n` where ( 0 leq n leq 10^4 ). Output Format: - A list of integers sorted in ascending order. Example: ```python improved_cocktail_shaker_sort([4, 3, 2, 1]) # Output: [1, 2, 3, 4] improved_cocktail_shaker_sort([1, 2, 3, 4, 5]) # Output: [1, 2, 3, 4, 5] improved_cocktail_shaker_sort([5, 1, 4, 2, 8]) # Output: [1, 2, 4, 5, 8] ```","solution":"def improved_cocktail_shaker_sort(arr): Improved Cocktail Shaker Sort to sort a list in ascending order. Args: arr (list): List of integers to sort. Returns: list: Sorted list of integers in ascending order. n = len(arr) if n <= 1: return arr start = 0 end = n - 1 swapped = True while swapped: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Backward pass for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True start += 1 return arr"},{"question":"Scenario You have been tasked with improving the search functionality in a legacy system. The system frequently performs lookups on a large, sorted list of integers. To optimize this process, you decide to implement a ternary search algorithm, which could potentially decrease the number of comparisons compared to the binary search algorithm currently in use. Objective Implement a function that performs a ternary search on a sorted list of integers. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: list) -> int: Find the given value (key) in a sorted array. Parameters: - left: int - The leftmost index of the array (typically 0 initially). - right: int - The rightmost index of the array (typically len(arr) - 1 initially). - key: int - The value to search for in the array. - arr: list - The sorted list of integers where the search is to be performed. Returns: - int: The index of the key if found, otherwise -1. ``` Input & Output - **Input**: - `left` (int): Starting index of the subarray to search. - `right` (int): Ending index of the subarray to search. - `key` (int): The integer value to be found. - `arr` (list): A list of sorted integers. - **Output**: - Returns the index of the `key` in `arr` if found; otherwise, returns -1. Constraints - The array `arr` contains only integers and is sorted in non-decreasing order. - The array can have up to `10^6` elements. - The elements in the array are within the range `-10^9` to `10^9`. - The `left` index will always be 0 at the initial call and `right` will be the last index of the array. Examples 1. Given an array `[1, 2, 3, 4, 5, 6, 7, 8, 9]`, `key` = 5, `left` = 0, `right` = 8: - Expected output: 4 (index of 5 in the array). 2. Given an array `[2, 3, 5, 8, 10, 14, 18]`, `key` = 7, `left` = 0, `right` = 6: - Expected output: -1 (7 is not in the array). Implement the `ternary_search` function following the provided signature above.","solution":"def ternary_search(left: int, right: int, key: int, arr: list) -> int: Find the given value (key) in a sorted array. Parameters: - left: int - The leftmost index of the array (typically 0 initially). - right: int - The rightmost index of the array (typically len(arr) - 1 initially). - key: int - The value to search for in the array. - arr: list - The sorted list of integers where the search is to be performed. Returns: - int: The index of the key if found, otherwise -1. while right >= left: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Scenario: In a busy library, books are often returned and placed on a holding shelf in no particular order. The librarian needs an efficient way to organize books back onto the main shelves. Given a list of book IDs representing the holding shelf, write a function to sort this list of IDs from lowest to highest using the Comb Sort algorithm. # Requirements: * **Function Signature**: ```python def organize_books(ids: List[int]) -> List[int]: ``` * **Input**: * `ids` (List[int]): a list of integer IDs of books, which can be empty or contain up to 10^4 non-negative integers. * **Output**: * A sorted list of integer IDs in ascending order. * **Constraints**: * You must use the Comb Sort algorithm as described. * **Performance Considerations**: * Aim for a solution that works within acceptable limits for both time and space complexity. # Example: ```python assert organize_books([101, 99, 125, 76, 89]) == [76, 89, 99, 101, 125] ``` # Detailed Requirements: 1. Begin with a given list of integers representing book IDs. 2. Implement the Comb Sort algorithm to sort these IDs. 3. Ensure the implementation handles all common edge cases like empty list, single-element list, and lists with duplicate values. 4. Use appropriate data structures and operations to guarantee correct and efficient sorting. # Additional Information: * Provide ample comments and documentation within your function. * Include a brief explanation of the comb sort algorithm at the beginning of your solution.","solution":"def organize_books(ids): Sorts a list of book IDs using the Comb Sort algorithm. Args: ids (List[int]): List of integer book IDs to be sorted. Returns: List[int]: Sorted list of book IDs in ascending order. def next_gap(gap): # Shrink gap by the shrink factor of 1.3 new_gap = (gap * 10) // 13 if new_gap < 1: return 1 return new_gap n = len(ids) gap = n swapped = True while gap != 1 or swapped: # Update the gap for the next comb gap = next_gap(gap) swapped = False # Compare all elements with the current gap for i in range(n - gap): if ids[i] > ids[i + gap]: ids[i], ids[i + gap] = ids[i + gap], ids[i] swapped = True return ids"},{"question":"Suppose you are working on a mathematical optimization project where you need to minimize the number of perfect squares that sum up to a given integer. You are provided with an integer and your task is to compute the smallest number of perfect squares whose sum equals the given integer. Implement a function `min_perfect_squares(n: int) -> int` that returns the minimum number of perfect squares that sum up to the given integer `n`. # Function Signature: ```python def min_perfect_squares(n: int) -> int: ... ``` # Input: * `n` (1 ≤ n ≤ 10,000): An integer specifying the number for which you need to find the minimum number of perfect squares. # Output: * Returns an integer between 1 to 4, representing the minimum number of perfect squares needed to sum up to `n`. # Examples: 1. `min_perfect_squares(9)` should return `1` because 9 = 3^2. 2. `min_perfect_squares(10)` should return `2` because 10 = 3^2 + 1^2. 3. `min_perfect_squares(12)` should return `3` because 12 = 2^2 + 2^2 + 2^2. 4. `min_perfect_squares(31)` should return `4` because 31 = 5^2 + 2^2 + 1^2 + 1^2. # Constraints: - You can assume `1 ≤ n ≤ 10,000`. # Performance Requirements: - Your solution should handle the largest possible input efficiently. # Notes: - You can use Python’s built-in `math` library for square root calculations. - Consider early optimization techniques by first checking if the number is a perfect square, if it can be expressed by the method detailed in Legendre\'s three-square theorem, or by other mathematical simplifications.","solution":"import math def min_perfect_squares(n: int) -> int: Returns the minimum number of perfect squares that sum up to n. # Check if n is a perfect square if int(math.sqrt(n))**2 == n: return 1 # Check the sum of two squares for i in range(1, int(math.sqrt(n)) + 1): if int(math.sqrt(n - i*i))**2 == (n - i*i): return 2 # Check the sum of three squares using Legendre\'s three-square theorem while n % 4 == 0: n //= 4 if n % 8 == 7: return 4 # If not 1, 2, or 4, then it must be 3 return 3"},{"question":"# Flatten Nested Arrays **Context**: In data processing, sometimes we encounter data structures in a nested format which are cumbersome to handle directly. Therefore, to ease the manipulation and analysis of such data, it\'s common to flatten these structures. **Problem Statement**: You are given an array that may contain nested arrays. Write a function to produce a flattened version of this array. The function should handle arbitrary levels of nesting and the order of elements should be preserved. **Function Signature**: ```python def flatten_array(input_arr: list) -> list: pass ``` **Input**: - A list `input_arr` that may contain nested lists. - The elements of these lists are integers, floats, or strings. **Output**: - A list containing all the elements of `input_arr` in a flattened single level. **Constraints**: - The input list can be very deeply nested. - Strings inside the list should be treated as a single element and not as iterable characters. - The function should preserve the order of the elements as they appear in the input list. **Example**: ```python assert flatten_array([1, [2, [3, 4]], 5]) == [1, 2, 3, 4, 5] assert flatten_array([\'a\', [\'b\', [\'c\']]]) == [\'a\', \'b\', \'c\'] assert flatten_array([[\'a\', [[[\'b\']]], [\'c\']]]) == [\'a\', \'b\', \'c\'] assert flatten_array([]) == [] assert flatten_array([1, \'abc\', [2, 3], [\'def\']]) == [1, \'abc\', 2, 3, \'def\'] ``` **Edge Cases**: - The input list is empty. - The input list contains different data types like integers, strings and nested lists. - There are no nested lists (the input list is already flat).","solution":"def flatten_array(input_arr): Flattens a nested array into a single list. output = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: output.append(element) flatten(input_arr) return output"},{"question":"You are required to implement a modified stack data structure called `OrderedStack` which keeps its elements sorted in ascending order (smallest at the bottom, largest at the top). The stack should support the following operations: 1. `push(item)`: Inserts an item into the stack while maintaining the sorted order. 2. `pop()`: Removes the top item from the stack and returns it. 3. `peek()`: Returns the top item without removing it. 4. `is_empty()`: Returns `True` if the stack is empty and `False` otherwise. 5. `size()`: Returns the number of items in the stack. # Requirements * Implement the `OrderedStack` class. * All operations should adhere to their corresponding complexities mentioned above. * Handle edge cases like empty stack operations gracefully. # Function Signature ```python class OrderedStack: def __init__(self): # Initializes an empty OrderedStack pass def is_empty(self) -> bool: # Returns True if the stack is empty, False otherwise pass def push(self, item: int): # Inserts an item into the stack while maintaining the ordered property pass def pop(self) -> int: # Removes and returns the top item from the stack pass def peek(self) -> int: # Returns the top item without removing it pass def size(self) -> int: # Returns the number of items in the stack pass ``` # Example ```python # Example usage stack = OrderedStack() stack.push(5) stack.push(1) stack.push(3) print(stack.size()) # Output: 3 print(stack.peek()) # Output: 5 print(stack.pop()) # Output: 5 print(stack.pop()) # Output: 3 print(stack.is_empty()) # Output: False print(stack.pop()) # Output: 1 print(stack.is_empty()) # Output: True ``` Your task is to implement the `OrderedStack` class that meets the above specifications.","solution":"class OrderedStack: def __init__(self): self.elements = [] def is_empty(self) -> bool: return len(self.elements) == 0 def push(self, item: int): if self.is_empty() or item >= self.elements[-1]: self.elements.append(item) else: temp_stack = [] while not self.is_empty() and self.elements[-1] > item: temp_stack.append(self.pop()) self.elements.append(item) while temp_stack: self.elements.append(temp_stack.pop()) def pop(self) -> int: if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.elements.pop() def peek(self) -> int: if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.elements[-1] def size(self) -> int: return len(self.elements)"},{"question":"**Problem Statement:** You are given a singly linked list and a reference to a node (except the tail) within that list. Your task is to delete the given node from the linked list without accessing the head of the list. You must update the linked list such that the given node is removed, and the before-and-after nodes are correctly connected. # Function Signature: ```python def delete_node(node: Node) -> None: ``` # Input: * `node` (Node): The node to be deleted from the singly linked list. It is guaranteed that the node is neither the tail nor None. # Output: * No return value. The function should modify the linked list in-place. # Constraints: * The node to be deleted is not the tail node. * There will be no empty input list according to the problem guarantees. # Performance Requirements: * **Time Complexity**: O(1). * **Space Complexity**: O(1). # Example: Suppose the linked list is represented as `1 -> 2 -> 3 -> 4`, and you are given the node `3`. **Input**: - List: `1 -> 2 -> 3 -> 4` - Node to delete: `3` **Output**: - List after deletion: `1 -> 2 -> 4` # Notes: * Ensure to handle edge cases where incorrect node positions could lead to exceptions for robustness, although the problem guarantees ensure valid input nodes. * The solution should only use the given node and the next node for the deletion process. **Example Test Cases:** 1. Validate with a regular list to delete a middle node. 2. Raise an error if trying to delete the tail node explicitly. 3. Ensure correct handling and not raising an error for provided valid non-tail nodes.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_node(node: Node) -> None: Deletes the given non-tail node from the linked list. # We do not have access to the head of the list, only the node to delete # Ensure the node is not the tail if node is None or node.next is None: raise ValueError(\\"Cannot delete the tail node or a non-existent node.\\") # Copy the data from the next node to the current node node.val = node.next.val # Bypass the next node node.next = node.next.next"},{"question":"# AVL Tree Validation **Context**: An AVL tree is a self-balancing binary search tree that provides O(log n) time complexity for search, insertion, and deletion operations. The fundamental property of an AVL tree is that the heights of the two child subtrees of any node differ by at most one. Rotations are applied to restore this property after any modification to the tree. **Task**: Implement a function to check whether a given binary tree is an AVL tree. Your function should verify the AVL tree properties, including the binary search tree property and the balance property. # Function Signature ```python def is_avl_tree(root: TreeNode) -> bool: pass ``` # Input - `root` (TreeNode): The root node of the binary tree to check. # Output - `bool`: Returns `True` if the tree is an AVL tree, otherwise `False`. # Constraints - The input tree can have up to `10**4` nodes. - Node values are unique integers. - An empty tree is considered an AVL tree. # Requirements - The solution should have a time complexity of O(n) where n is the number of nodes in the tree. - You are allowed to define auxiliary classes or functions if needed. # Example ```python class TreeNode: def __init__(self, key=0, left=None, right=None): self.key = key self.left = left self.right = right # Example Usage: # Constructing an example tree: # 3 # / # 1 5 # / # 4 6 root = TreeNode(3) root.left = TreeNode(1) root.right = TreeNode(5) root.right.left = TreeNode(4) root.right.right = TreeNode(6) print(is_avl_tree(root)) # Expected output: True # Example of a non-AVL tree (imbalanced): # 3 # # 5 # / # 4 # / # 2 root = TreeNode(3) root.right = TreeNode(5) root.right.left = TreeNode(4) root.right.left.left = TreeNode(2) print(is_avl_tree(root)) # Expected output: False ```","solution":"class TreeNode: def __init__(self, key=0, left=None, right=None): self.key = key self.left = left self.right = right def is_avl_tree(root: TreeNode) -> bool: def check_avl(node): if not node: return (True, 0) left_balanced, left_height = check_avl(node.left) right_balanced, right_height = check_avl(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = 1 + max(left_height, right_height) return (balanced, height) return check_avl(root)[0]"},{"question":"Context: You are working with a system that relies on bitwise manipulations for optimizing storage and retrieval operations. One of the tasks involves determining the \\"Hamming Weight\\" or the number of set bits (`1`s) in the binary representation of numbers. Implementing this efficiently is crucial for the system’s performance. Task: Write a function that accepts an unsigned integer as input and returns the number of `1` bits in its binary representation. Your implementation must use Brian Kernighan\'s Algorithm for optimal performance. Function Signature: ```python def hamming_weight(n: int) -> int: ``` Input: * A single unsigned integer `n`. Output: * An integer representing the number of `1` bits in the binary representation of `n`. Constraints: * 0 ≤ n ≤ 2^32 - 1 Example: ```python assert hamming_weight(11) == 3 # binary: 00000000000000000000000000001011 assert hamming_weight(128) == 1 # binary: 00000000000000000000000010000000 assert hamming_weight(5) == 2 # binary: 00000000000000000000000000000101 assert hamming_weight(0) == 0 # binary: 00000000000000000000000000000000 ``` Requirements: 1. **Correctness**: Your implementation should return the correct number of `1`s for all valid inputs. 2. **Efficiency**: Your solution should operate in O(k) time, where k is the number of `1` bits in the binary representation of `n`.","solution":"def hamming_weight(n: int) -> int: Returns the number of 1 bits in the binary representation of the input integer n. Uses Brian Kernighan\'s Algorithm to count the set bits. count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"Integer Decomposition Count You are given a positive integer `N`. Your task is to write a function `integer_decomposition_count(N)` that computes the number of different ways to decompose `N` into a sum of positive integers. Each decomposition must be treated as a combination of integers, ignoring the order of integers in the sum. Input - A single integer `N` (1 <= `N` <= 200). Output - A single integer representing the number of ways to decompose `N`. Example ```plaintext Input: 4 Output: 5 Input: 7 Output: 15 ``` Explanation - For N = 4, the decompositions are: [4], [3+1], [2+2], [2+1+1], [1+1+1+1]. - For N = 7, the decompositions are: [7], [6+1], [5+2], [5+1+1], [4+3], [4+2+1], [4+1+1+1], [3+3+1], [3+2+2], [3+2+1+1], [3+1+1+1+1], [2+2+2+1], [2+2+1+1+1], [2+1+1+1+1+1], [1+1+1+1+1+1+1]. # Constraints - You may assume N will not exceed 200. - The solution must be efficient enough to handle the upper constraint. # Function Signature ```python def integer_decomposition_count(N: int) -> int: pass ``` # Notes - Consider the edge case when `N = 1`. - Ensure to handle memoization appropriately to keep the function efficient.","solution":"def integer_decomposition_count(N): Returns the number of different ways to decompose N into a sum of positive integers. # create a table to store results of subproblems dp = [0] * (N + 1) # base case: there\'s exactly one way to decompose 0, which is using no parts at all dp[0] = 1 # consider sums using parts from 1 up to N for i in range(1, N + 1): for j in range(i, N + 1): dp[j] += dp[j - i] return dp[N]"},{"question":"# Fibonacci Sequence Calculation You are tasked with implementing a function that computes the n-th Fibonacci number. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, typically starting with 0 and 1. Thus, the sequence is: ``` 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... ``` The n-th Fibonacci number can be defined as follows: - F(0) = 0 - F(1) = 1 - For n > 1, F(n) = F(n-1) + F(n-2) Specifications: 1. **Function Name**: `fast_fibonacci` 2. **Input**: A single integer n (0 <= n <= 10^6) 3. **Output**: The n-th Fibonacci number Constraints: - The function must handle very large values of n efficiently. - Tailor the implementation to ensure it can compute values up to F(10^6) quickly and without excessive memory usage. Example: - Input: n = 10 - Output: 55 **Note**: Ensure the implementation follows optimal time and space complexity. Requirements: - You are expected to explain which approach you\'ve chosen (dynamic programming or iterative) and justify your decision. - Provide performance analysis of your solution.","solution":"def fast_fibonacci(n): Computes the n-th Fibonacci number using an iterative approach. Args: n (int): The position in the Fibonacci sequence to compute. Returns: int: The n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Matrix Chain Multiplication Optimization You work for a company specializing in computational photography, and you need to optimize a series of matrix operations involved in image transformations. The sheer size and number of these matrices necessitate an efficient multiplication approach to maintain performance. Task Write a function `optimal_matrix_order` that takes a list `p` of matrices dimensions and returns the minimum number of multiplications needed to multiply the chain. Additionally, implement a function `get_optimal_order` to output the optimal order of multiplications in a readable format. Function Signatures ```python def optimal_matrix_order(p: List[int]) -> int: # Calculates the minimum number of multiplications needed pass def get_optimal_order(p: List[int], s: List[List[int]], i: int, j: int) -> str: # Constructs the optimal order of matrix multiplication pass ``` Input - `p`: A list of integers where the `i`-th matrix has dimensions `p[i-1] x p[i]`. Output - `optimal_matrix_order`: Returns an integer, the minimum number of scalar multiplications needed. - `get_optimal_order`: Returns a string representation of the optimal multiplication order. Constraints - The length of `p` will be at least 2 and at most 100 (1 ≤ len(p) ≤ 100). Example ```python p = [30, 35, 15, 5, 10, 20, 25] min_operations = optimal_matrix_order(p) # Should return the minimum multiplications needed optimal_order = get_optimal_order(p, s, 1, len(p)-1) # Should return something like \\"((A1(A2A3))((A4A5)A6))\\" ``` Scenario You are given dimensions for matrices you need to multiply in sequence. Your task is to determine the order that requires the fewest scalar multiplications and to display this optimal multiplication sequence. Implement the functions with a focus on efficiency, keeping the discussed algorithmic and data structure principles in mind.","solution":"def optimal_matrix_order(p): Computes the minimum number of scalar multiplications needed to compute the matrix chain product. Parameters: p (List[int]): List of dimensions such that the i-th matrix has dimensions p[i-1] x p[i]. Returns: int: Minimum number of scalar multiplications needed. n = len(p) - 1 m = [[0] * (n + 1) for _ in range(n + 1)] s = [[0] * (n + 1) for _ in range(n + 1)] for l in range(2, n + 1): for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m[1][n], s def get_optimal_order(s, i, j): Constructs the optimal matrix multiplication order. Parameters: s (List[List[int]]): Auxiliary array with optimal split points. i (int): Starting index. j (int): Ending index. Returns: str: Optimal order of matrix multiplications. if i == j: return f\\"A{i}\\" else: return f\\"({get_optimal_order(s, i, s[i][j])}{get_optimal_order(s, s[i][j] + 1, j)})\\""},{"question":"# Flatten Nested Arrays Given a nested list of arbitrary depth, your task is to write a function `flatten_array` that flattens it into a single-level list. Your solution should focus on efficiently handling deeply nested structures while maintaining clarity and elegance. Function Signature: ```python def flatten_array(nested_list: list) -> list: pass ``` Input: - `nested_list`: a list, possibly containing other lists of arbitrary depth. Output: - A single-level list containing all the elements from the nested lists in the original order. Constraints: - Elements in the nested list may include any combination of integers, strings, and other lists. - Assume the input list is well-formed and does not contain itself directly as a sub-list (no cyclic references). Examples: ```python assert flatten_array([1, [2, 3], [4, [5, 6], 7], 8]) == [1, 2, 3, 4, 5, 6, 7, 8] assert flatten_array([\'a\', [\'b\', \'c\', [1, 2]], 3]) == [\'a\', \'b\', \'c\', 1, 2, 3] assert flatten_array([]) == [] assert flatten_array([[[[]]]]) == [] ``` Performance Requirements: The solution should efficiently handle: - Nested lists with depth up to 1000. - Total number of elements in all nested lists up to 1,000,000. Scenario: Imagine you\'re working with a complex data structure representing a company\'s organizational hierarchy, where departments can contain sub-departments at multiple levels. You need to create a flat list of all individual departments for analysis. Your function should be robust to handle various levels of nesting and efficiently return a list of all departments in the hierarchical order.","solution":"def flatten_array(nested_list): Flattens a nested list of arbitrary depth into a single-level list. flat_list = [] def flatten(nested): for element in nested: if isinstance(element, list): flatten(element) else: flat_list.append(element) flatten(nested_list) return flat_list"},{"question":"Coding Assessment Question **Objective**: Write a function to switch successive pairs of elements in a stack starting from the bottom, without using any additional data structures such as arrays, stacks, or queues. # Function Signature ```python def inplace_switch_pairs(stack): ``` # Input Format - The function takes a single argument: - `stack`: A list of integers representing a stack, where the last element of the list is at the top of the stack. # Output Format - The function modifies the input stack in-place and does not return any value. # Constraints - The stack will contain at most 10^5 elements. - Elements of the stack are integers and can be both positive and negative. # Example Scenario and Explanation Example 1 **Input**: ```python stack = [3, 8, 17, 9, 1, 10] inplace_switch_pairs(stack) ``` **Output**: ```python stack = [8, 3, 9, 17, 10, 1] ``` Example 2 **Input**: ```python stack = [3, 8, 17, 9, 1] inplace_switch_pairs(stack) ``` **Output**: ```python stack = [8, 3, 9, 17, 1] ``` Example 3 **Input**: ```python stack = [] inplace_switch_pairs(stack) ``` **Output**: ```python stack = [] ``` Example 4 **Input**: ```python stack = [1] inplace_switch_pairs(stack) ``` **Output**: ```python stack = [1] ``` # Notes - The function must modify the stack in-place. - You cannot use any additional data structures such as arrays, stacks, queues, etc. - You can make use of recursion or other techniques to achieve the desired result without additional storage.","solution":"def inplace_switch_pairs(stack): Switch successive pairs of elements in the stack starting from the bottom. n = len(stack) for i in range(0, n - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i]"},{"question":"# Context and Task You are tasked with creating a system to iterate over the elements of a Binary Search Tree (BST) in a sorted order. This should handle both initialization and traversal operations efficiently. # Problem Description Design a class called `BSTIterator` which allows traversal of BST elements in ascending order. The `BSTIterator` should provide two main functions: `has_next` and `next`. # Function Signatures - **Initialization**: `__init__(self, root: TreeNode)` - **Next Check**: `has_next(self) -> bool` - **Next Element**: `next(self) -> int` # Requirements 1. **Class Definition**: Define class `BSTIterator` with an initializer that accepts the root of a BST. 2. **In-order Traversal**: - `has_next` should return `True` if there are further elements, `False` otherwise. - `next` should return the next smallest element in the BST. 3. **Efficiency**: - The code should support the operations in O(1) average time for `next` and O(1) space beyond the size of the stack. # Constraints - Tree nodes contain unique integer values. - The tree can be unbalanced. # Expected Input/Output * **Input**: - `__init__` method: A root node of the BST. - `has_next` method: No parameters. - `next` method: No parameters. * **Output**: - `has_next` method: `True` or `False`. - `next` method: Next integer value in ascending order. # Example ```python # Assume the following BST structure: # 7 # / # 3 15 # / # 9 20 # Usage iterator = BSTIterator(root) iterator.next() # Returns 3 iterator.next() # Returns 7 iterator.has_next() # Returns True iterator.next() # Returns 9 iterator.has_next() # Returns True iterator.next() # Returns 15 iterator.has_next() # Returns True iterator.next() # Returns 20 iterator.has_next() # Returns False ``` # Hint Consider using a stack to keep track of nodes during the in-order traversal.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"You are given a binary search tree (BST) where each node has a unique integer value, a left child, and a right child. Your task is to transform this binary search tree into a sorted doubly linked list in place. Specifically: 1. The left child pointer of the tree node should be used as the predecessor pointer in the doubly linked list. 2. The right child pointer of the tree node should be used as the successor pointer in the doubly linked list. The resulting doubly linked list should be sorted in ascending order. You need to implement the function `bin_tree_to_list(root)` that performs this transformation. Additionally, implement a utility function `print_list(root)` to print the elements of the resultant doubly linked list from left to right. # Function Signatures ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: pass def print_list(root: TreeNode) -> None: pass ``` # Input * `root`: The root node of the binary search tree, could be `None` for an empty tree. # Output * The root of the doubly linked list (the smallest element in the BST). # Constraints * The tree nodes contain unique integer values. * The count of tree nodes will not exceed 10^4. # Performance Requirements * The solution should run in O(n) time complexity and O(h) space complexity, where n is the number of nodes in the tree and h is the height of the tree. # Example Input: ```python root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) ``` _Output_ (sorted doubly linked list): ``` 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` Function Calls: ```python new_root = bin_tree_to_list(root) print_list(new_root) ``` Output: ``` 1 2 3 4 5 ``` Make sure to consider edge cases like empty tree or single-node tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bin_tree_to_list(root: TreeNode) -> TreeNode: if not root: return None def in_order_traversal(node): nonlocal last, head if not node: return # traverse the left subtree in_order_traversal(node.left) if last: last.right = node node.left = last else: head = node last = node # traverse the right subtree in_order_traversal(node.right) last, head = None, None in_order_traversal(root) return head def print_list(root: TreeNode) -> None: node = root while node: print(node.val, end=\' \') node = node.right print()"},{"question":"# Interpolation Search Performance Challenge You are working for a data analytics company that needs efficient searching mechanisms in large, sorted datasets. One of your tasks is to enhance the performance of the search operations using interpolation search. Despite its efficiency in uniformly distributed arrays, you have noticed occasional performance drags due to the specifics of the dataset distributions used in your projects. **Task**: Your task is to implement an improved and robust `interpolation_search` function that carefully handles edge cases and optimizes searches for better performance. In particular, your function should handle: - Skewed distributions gracefully. - Avoid unnecessary recomputation. - Handle edge cases like an array with all identical elements or a very skewed range. # Expected Input and Output Formats * Input: - `array` (List[int]): A list of sorted integers (can contain duplicate and/or negative values). - `search_key` (int): The integer to search for within the array. * Output: - Return the index of `search_key` if found in the array. - If `search_key` is not in the array, return `-1`. # Constraints and Limitations - The array is guaranteed to be sorted in non-decreasing order. - The array may contain up to (10^6) elements. - Time complexity should aim for O(log(log n)) on average, but handle O(n) worst-case gracefully. # Example ```python def improved_interpolation_search(array: List[int], search_key: int) -> int: # Your implementation here pass # Example test case print(improved_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)) # Expected output: 2 print(improved_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # Expected output: -1 print(improved_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5)) # Expected output: -1 ``` # Notes - Ensure that your implementation correctly handles cases where all elements are the same. - Provide efficient handling for cases where the calculation would result in positions out of bounds. - Optimize for uniformly distributed data but ensure that non-uniform distributions do not degrade performance significantly.","solution":"def improved_interpolation_search(array, search_key): Implementation of improved interpolation search algorithm. Handles edge cases effectively. :param array: List of sorted integers. :param search_key: Integer to search for within the array. :return: Index of search_key if found, else -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 # Probing the position using the interpolation formula if array[high] == array[low]: pos = low else: pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Checking boundary in case pos goes out of bounds if pos < 0 or pos >= len(array): return -1 # If found at pos if array[pos] == search_key: return pos # If the target is larger, search in right subarray if array[pos] < search_key: low = pos + 1 # If the target is smaller, search in left subarray else: high = pos - 1 return -1"},{"question":"You are tasked with building a symbolic algebra system for handling polynomials and monomials. You\'ve been provided the `Monomial` and `Polynomial` classes. Your goal is to implement an advanced feature of simplifying a polynomial by combining like terms and reducing it to its simplest form. # Simplify Polynomial Implement a method `simplify` in the `Polynomial` class that combines like terms, removes zero coefficient monomials, and returns a simplified polynomial. # Function Signature ```python def simplify(self) -> Polynomial: ``` # Expected Input/Output - **Input**: - A Polynomial object containing multiple monomials. - **Output**: - A new Polynomial object with combined like terms and no zero-coefficient monomials. # Constraints - Monomials should be correctly added/subtracted based on their coefficients. - Zero-coefficient monomials should be removed. # Examples ```python p1 = Polynomial([Monomial({1: 2}, 3), Monomial({1: 2}, 2), Monomial({2: 1}, -2), Monomial({}, 0)]) p_simplified = p1.simplify() assert str(p_simplified) == \\"5(a_1)^2 - 2(a_2)\\" p2 = Polynomial([Monomial({3:1, 4:1}, -1), Monomial({3:1}, 1)]) p_simplified = p2.simplify() assert str(p_simplified) == \\"(a_3) - (a_3)(a_4)\\" ``` Note: Use the provided `Monomial` and `Polynomial` implementation to handle the monomial manipulations and polynomial adjustments appropriately.","solution":"from collections import defaultdict class Monomial: def __init__(self, variables, coefficient): Initialize a monomial with a dictionary of variables and their powers and a coefficient. :param variables: Dictionary where keys are variable indices and values are their powers. :param coefficient: Coefficient of the monomial. self.variables = variables self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __add__(self, other): if self.variables == other.variables: return Monomial(self.variables, self.coefficient + other.coefficient) raise ValueError(\\"Monomials with different variables cannot be added.\\") def __str__(self): if self.coefficient == 0: return \\"0\\" terms = [f\\"{self.coefficient}\\"] for var, pow in sorted(self.variables.items()): terms.append(f\\"(a_{var})^{pow}\\") return \\" * \\".join(terms) def is_zero(self): return self.coefficient == 0 class Polynomial: def __init__(self, monomials): Initialize a polynomial with a list of monomials. :param monomials: List of Monomial objects. self.monomials = monomials def simplify(self): Simplify the polynomial by combining like terms and removing zero coefficient monomials. :return: A new simplified Polynomial object. simplified_terms = defaultdict(int) for monomial in self.monomials: key = frozenset(monomial.variables.items()) simplified_terms[key] += monomial.coefficient result_monomials = [ Monomial(dict(key), coeff) for key, coeff in simplified_terms.items() if coeff != 0 ] return Polynomial(result_monomials) def __str__(self): if not self.monomials: return \\"0\\" return \\" + \\".join(str(monomial) for monomial in self.monomials)"},{"question":"# Question: Longest Increasing Subsequence with Concatenated Input Context: You are given two sequences of integers. Your task is to find the length of the longest increasing subsequence (LIS) of these two concatenated sequences. This problem will test your understanding of dynamic programming and optimized data structures such as segment trees to manage efficiently large inputs. Problem Description: Write a function `length_of_concatenated_lis(seq1, seq2)` that takes two lists of integers `seq1` and `seq2`, and returns an integer representing the length of the longest increasing subsequence in the concatenated sequence `seq1 + seq2`. Input Format: - `seq1`: A list of integers (1 <= len(seq1) <= 10^5, 0 <= seq1[i] <= 10^9) - `seq2`: A list of integers (1 <= len(seq2) <= 10^5, 0 <= seq2[i] <= 10^9) Output Format: - An integer indicating the length of the longest increasing subsequence. Constraints: - The function should be optimized to handle up to 200,000 elements in the concatenated sequence efficiently. - The solution should avoid O(n^2) complexity for larger inputs and lean towards O(n log n) if possible. Example: ```python def length_of_concatenated_lis(seq1, seq2): # Write your code here # Example Test Case seq1 = [10, 9, 2, 5, 3] seq2 = [7, 101, 18, 20] print(length_of_concatenated_lis(seq1, seq2)) # Output: 6 ``` Note: The concatenated list is `[10, 9, 2, 5, 3, 7, 101, 18, 20]` and the LIS is `[2, 3, 7, 18, 20]`. Constraints to Consider: 1. Efficiently manage large input sizes. 2. Consider using advanced data structures (segment trees) if needed. 3. Ensure handling edge cases such as empty or single-element sequences.","solution":"from bisect import bisect_left def length_of_concatenated_lis(seq1, seq2): Returns the length of the longest increasing subsequence in the concatenated list of seq1 and seq2. combined_seq = seq1 + seq2 if not combined_seq: return 0 lis = [] for num in combined_seq: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Number of Unique BSTs Binary Search Trees (BSTs) are tree data structures that allow for efficient insertion, deletion, and lookup operations. Given an integer `n`, the goal is to determine the number of structurally unique BSTs that can be formed using `n` distinct integers from 1 to `n`. **Objective**: - Implement a function `num_trees` that calculates the number of unique BSTs. **Function Signature**: ```python def num_trees(n: int) -> int: ``` **Input**: - `n` (integer): The number of nodes. **Output**: - Returns an integer representing the number of structurally unique BSTs that can be formed with `n` nodes. **Examples**: ```python print(num_trees(3)) # Output: 5 print(num_trees(4)) # Output: 14 print(num_trees(1)) # Output: 1 ``` **Constraints**: - The function should handle `n` up to 20 efficiently. **Explanation**: - The function should implement a dynamic programming approach where `dp[i]` represents the number of unique BSTs with `i` nodes. - Utilize the recurrence relation: ``` dp[i] = sum(dp[j] * dp[i-j-1] for j in range(i)) ``` - Initialize dp with base cases: `dp[0] = 1` (an empty tree) and `dp[1] = 1` (one node tree). **Note**: - Ensure the solution is optimized in terms of both time and space complexity.","solution":"def num_trees(n: int) -> int: if n == 0 or n == 1: return 1 dp = [0] * (n + 1) dp[0] = dp[1] = 1 for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n]"},{"question":"Problem Statement You are tasked with implementing a simple version control system for tracking changes in a register of 32-bit integers. Each bit in a register represents a flag that can be toggled, set, or cleared. This register will support several operations to manipulate individual bits effectively. Implement the following functions to manage this register: 1. **get_bit(num: int, i: int) -> bool**: Given a 32-bit integer `num` and an index `i`, return `True` if the ith bit is set to 1, otherwise return `False`. 2. **set_bit(num: int, i: int) -> int**: Given a 32-bit integer `num` and an index `i`, return the integer with the ith bit set to 1. 3. **clear_bit(num: int, i: int) -> int**: Given a 32-bit integer `num` and an index `i`, return the integer with the ith bit cleared to 0. 4. **update_bit(num: int, i: int, bit: int) -> int**: Given a 32-bit integer `num`, an index `i`, and a bit value (0 or 1), return the integer with the ith bit updated to the given value. Input and Output Formats - **Input**: Integer `num` (32-bit, can be negative), Integer `i` (0 <= i <= 31), for `update_bit` a bit value `bit` (0 or 1). - **Output**: - **get_bit**: Boolean value indicating the bit state. - **set_bit, clear_bit, update_bit**: Modified integer value. Constraints - The index `i` should be within the range [0, 31]. - The bit value for `update_bit` function should be either 0 or 1. - Handle any potential edge cases such as out-of-bound bit indices or invalid bit values gracefully. Example ```python # Demonstrating the functions with examples # Initial integer value num = 29 # Binary: 00000000000000000000000000011101 # Get bit at index 2 assert get_bit(num, 2) == True # Expected output: True # Set bit at index 5 assert set_bit(num, 5) == 61 # Expected output: 00000000000000000000000000111101, Decimal: 61 # Clear bit at index 3 assert clear_bit(num, 3) == 21 # Expected output: 00000000000000000000000000010101, Decimal: 21 # Update bit at index 0 to 0 assert update_bit(num, 0, 0) == 28 # Expected output: 00000000000000000000000000011100, Decimal: 28 ``` Task Implement the functions `get_bit`, `set_bit`, `clear_bit`, and `update_bit` based on the above specifications.","solution":"def get_bit(num: int, i: int) -> bool: Return True if the ith bit of num is set to 1, otherwise return False. if i < 0 or i > 31: raise ValueError(\\"Bit index must be in the range [0, 31].\\") return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Return the integer num with the ith bit set to 1. if i < 0 or i > 31: raise ValueError(\\"Bit index must be in the range [0, 31].\\") return num | (1 << i) def clear_bit(num: int, i: int) -> int: Return the integer num with the ith bit cleared to 0. if i < 0 or i > 31: raise ValueError(\\"Bit index must be in the range [0, 31].\\") return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Return the integer num with the ith bit updated to the given value (0 or 1). if i < 0 or i > 31: raise ValueError(\\"Bit index must be in the range [0, 31].\\") if bit not in [0, 1]: raise ValueError(\\"Bit value must be 0 or 1.\\") return (num & ~(1 << i)) | (bit << i)"},{"question":"# Anagram Checker with Mixed Case and Alphabet Consideration **Context**: Given two strings, determine if they are anagrams of each other. For the purpose of this problem, an anagram is defined as a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. The comparison should be case-insensitive, and non-alphabet characters should be ignored. **Task**: Implement a function `anagram_checker(s1, s2)` that: - Takes two strings as input. - Returns `True` if they are anagrams, ignoring case and non-alphabet characters; otherwise, returns `False`. **Function Signature**: ```python def anagram_checker(s1: str, s2: str) -> bool: pass ``` **Examples**: ```python print(anagram_checker(\\"apple\\", \\"pleap\\")) # Should return True print(anagram_checker(\\"apple\\", \\"cherry\\")) # Should return False print(anagram_checker(\\"Dormitory\\", \\"dirty room\\")) # Should return True print(anagram_checker(\\"Conversation\\", \\"Voices Rant On\\")) # Should return True print(anagram_checker(\\"Hello, World!\\", \\"Dolor, Well!\\")) # Should return False ``` **Constraints**: 1. The input strings can contain letters, spaces, punctuation marks, and other characters. 2. The function should be case-insensitive. 3. Non-alphabet characters should be ignored during the anagram check. **Performance Requirements**: 1. The solution should ideally run in O(n) time complexity, where n is the length of the strings after filtering non-alphabetic characters. 2. The number of supplementary data structures used should be minimized to adhere to an O(1) space complexity constraint beyond the storage for the filtered input strings.","solution":"def anagram_checker(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams, ignoring case and non-alphabet characters; otherwise, returns False. # Filter out non-alphabet characters and convert to lower case filtered_s1 = \'\'.join(filter(str.isalpha, s1)).lower() filtered_s2 = \'\'.join(filter(str.isalpha, s2)).lower() # Sort the filtered strings and compare return sorted(filtered_s1) == sorted(filtered_s2)"},{"question":"Scenario In data preprocessing, it is often required to filter data to remove outliers or noise by bounding values. You need to implement a function to perform this filtering efficiently. Task Implement a function `filter_values(arr, min_val=None, max_val=None)` which filters the input list `arr` such that the returned list contains only the values within the specified `min_val` and `max_val` range. Function Signature ```python def filter_values(arr: List[int], min_val: Optional[int] = None, max_val: Optional[int] = None) -> List[int]: ... ``` Input * `arr`: A list of integers `arr` (0 ≤ len(arr) ≤ 10^5) - the array to be filtered. * `min_val`: An optional integer `min_val` which sets the lower bound (defaults to None). * `max_val`: An optional integer `max_val` which sets the upper bound (defaults to None). Output * The function should return a list of integers containing elements from the original array that lie within the bounds (inclusive). Constraints * If `min_val` is not provided, consider the minimum value as negative infinity. * If `max_val` is not provided, consider the maximum value as positive infinity. * Ensure your solution is efficient and can handle the upper constraint on input size. Examples ```python # Example 1 arr = [1, 2, 3, 4, 5] min_val = None max_val = 3 print(filter_values(arr, min_val, max_val)) # Output: [1, 2, 3] # Example 2 arr = [10, 20, 30, 40, 50] min_val = 15 max_val = 35 print(filter_values(arr, min_val, max_val)) # Output: [20, 30] # Example 3 arr = [7, 8, 9, 10] min_val = 8 max_val = None print(filter_values(arr, min_val, max_val)) # Output: [8, 9, 10] # Example 4 arr = [] min_val = 5 max_val = 10 print(filter_values(arr, min_val, max_val)) # Output: [] ``` Additional Notes * Ensure your function handles edge cases gracefully, especially when bounds are `None`. * Aim for optimal performance given the constraints.","solution":"from typing import List, Optional def filter_values(arr: List[int], min_val: Optional[int] = None, max_val: Optional[int] = None) -> List[int]: Filters the input list `arr` such that the returned list contains only the values within the specified `min_val` and `max_val` range (inclusive). Args: - arr: List[int]: A list of integers to be filtered. - min_val: Optional[int]: An optional integer that sets the lower bound. - max_val: Optional[int]: An optional integer that sets the upper bound. Returns: - List[int]: A list of integers containing elements from the original array that lie within the bounds (inclusive). if min_val is None: min_val = float(\'-inf\') if max_val is None: max_val = float(\'inf\') return [x for x in arr if min_val <= x <= max_val]"},{"question":"# Diffie-Hellman with Improved Primality Check Implement a function `secure_diffie_hellman_key_exchange(a: int, p: int) -> bool` that performs the Diffie-Hellman key exchange protocol with improved security checks. Your implementation should include the following: 1. **Function**: `secure_diffie_hellman_key_exchange(a: int, p: int) -> bool` 2. **Inputs**: - `a` (int): A base integer (candidate primitive root of `p`). - `p` (int): A large prime number. 3. **Outputs**: - Returns `True` if the exchange is successful and Alice\'s and Bob\'s shared keys match. Returns `False` otherwise. 4. **Constraints**: - `1 < a < p` - `p` should be verified as a prime number. - `a` should be verified as a primitive root of `p`. # Requirements 1. **Prime Check**: Implement a robust prime-checking logic. 2. **Primitive Root Check**: Ensure `a` is a primitive root of `p`. 3. **Key Exchange**: Perform the standard Diffie-Hellman key exchange. 4. **Edge Cases**: Handle edge cases such as `p` not being prime or `a` not being a primitive root. # Performance - Ensure that the prime check and root verification are optimized for large values of `p`. - Aim for efficient modular exponentiation. # Example Given: - `a = 2` - `p = 11` Execution: ```python secure_diffie_hellman_key_exchange(a=2, p=11) ``` Output: - Returns `True` if the exchange is successful and calculated keys match. # Note You should implement the functions: - `prime_check(num: int) -> bool`: Checks if a number is prime. - `find_primitive_root(n: int) -> list`: Finds all primitive roots of `n`. - Additional helper functions as needed.","solution":"def prime_check(num: int) -> bool: Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primitive_root(n: int) -> list: Finds all primitive roots of n. if not prime_check(n): return [] phi = n - 1 factors = set() i = 2 while i * i <= phi: if phi % i == 0: factors.add(i) while phi % i == 0: phi //= i i += 1 if phi > 1: factors.add(phi) primitive_roots = [] for r in range(2, n): flag = True for factor in factors: if pow(r, (n-1) // factor, n) == 1: flag = False break if flag: primitive_roots.append(r) return primitive_roots def secure_diffie_hellman_key_exchange(a: int, p: int) -> bool: Performs the Diffie-Hellman key exchange protocol. Returns True if successful, False otherwise. if not (1 < a < p): return False if not prime_check(p): return False primitive_roots = find_primitive_root(p) if a not in primitive_roots: return False # Assuming Alice\'s private key alice_private_key = 4 alice_public_key = pow(a, alice_private_key, p) # Assuming Bob\'s private key bob_private_key = 3 bob_public_key = pow(a, bob_private_key, p) alice_shared_secret = pow(bob_public_key, alice_private_key, p) bob_shared_secret = pow(alice_public_key, bob_private_key, p) return alice_shared_secret == bob_shared_secret"},{"question":"# Problem: Linked List Node Deletion You are given access to a node in a singly linked list and tasked with writing a function to delete this node. The node you are given is guaranteed not to be the tail node. Function Signature ```python def delete_node(node: Node) -> None: pass ``` Input * `node`: The node within the singly linked list to be deleted. This node is guaranteed to be neither null nor the tail node. Output The function does not return anything. It modifies the linked list in place. Constraints * You cannot use any other linked list traversal functions. * The given node to delete is guaranteed to be neither null nor the tail node. Example Suppose the linked list is initially `1 -> 2 -> 3 -> 4` and you are given the node with value `3`. After calling `delete_node(node)`, the linked list should become `1 -> 2 -> 4`. Edge Cases * Ensure that trying to delete the tail node raises an appropriate error. * Ensure the function properly handles any null or invalid nodes if accessed in error. # Task * Implement the function `delete_node(node: Node) -> None`. * Write a suite of tests to validate that `delete_node` correctly deletes the specified node and manages edge cases appropriately.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def delete_node(node: Node) -> None: Deletes the given node from the linked list. The node to be deleted is guaranteed not to be the tail node. if node is None or node.next is None: raise ValueError(\\"Cannot delete the node because it is either None or the tail node\\") next_node = node.next node.value = next_node.value node.next = next_node.next"},{"question":"# Question: Validate Brackets in Complex Strings Context: In this exercise, you are required to validate brackets in strings that include letters and other non-bracket characters. This will test your understanding of stack-based algorithms and how to handle additional complexity. Problem Description: Given a string containing characters \'(\', \')\', \'{\', \'}\', \'[\', \']\', and alphabetic letters from \'a\' to \'z\', determine if the input string is valid. The brackets must close in the correct order, and non-bracket characters should be ignored. Input: - A single string `s` containing characters \'(\', \')\', \'{\', \'}\', \'[\', \']\', and alphabetic letters. Output: - Return `True` if the input string is valid, else return `False`. Constraints: - The length of the string will not exceed 10,000 characters. - The string can also be empty. - Only the parentheses, braces, and brackets should be validated while ignoring other characters. Example: ```python assert is_valid_with_chars(\\"a(b{c}d[e]f)\\") == True assert is_valid_with_chars(\\"a(b{c]d}e)\\") == False assert is_valid_with_chars(\\"[a+b]*(x+y)\\") == True ``` Requirements: - Implement a function `is_valid_with_chars(s: str) -> bool` that meets the specifications above. - Complexity requirements of O(n) time and O(n) space. - You must handle edge cases where the string is empty, contains only non-bracket characters, or has mismatched brackets.","solution":"def is_valid_with_chars(s): Determine if a string containing \'(\', \')\', \'{\', \'}\', \'[\', \']\', and alphabetic letters is valid. Valid strings have properly nested and matched brackets, ignoring other characters. stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False elif char in bracket_map.values(): stack.append(char) return not stack"},{"question":"# Simplify UNIX-style File Path You are given an absolute path for a file (Unix-style) and you need to simplify it. Task Write a function `simplify_path(path: str) -> str` that simplifies the given Unix-style file path. Requirements * The path must be simplified according to the following rules: - Any sequence of `/` characters is considered as a single `/`. - The special directories `.` and `..` mean the current directory and the parent directory respectively. `.` should have no effect and `..` should move one directory up unless at the root already. - Return the canonical path starting with a single `/`. Input and Output Formats **Input**: * A single string `path` containing the absolute path. **Output**: * Return the canonical path as a string. Examples *path*: \\"/home/\\", **Output**: \\"/home\\" *path*: \\"/a/./b/../../c/\\", **Output**: \\"/c\\" *path*: \\"/../\\", **Output**: \\"/\\" *path*: \\"/home//foo/\\", **Output**: \\"/home/foo\\" Constraints * The length of path is at most 3000. * path is a valid Unix-style path. **Performance requirements**: * Your code should have a time complexity of O(n), where n is the length of the path. * Space complexity should be O(n) in the worst case. Assume: * The input is always a valid string containing only printable ASCII characters. Good Luck!","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style absolute path. Args: path (str): The input Unix-style path. Returns: str: The simplified canonical path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Question: Improved Topological Sorting Algorithm You are given a `Directed Acyclic Graph (DAG)` represented as an adjacency list. Your task is to implement an efficient topological sorting algorithm that handles large graphs more gracefully by avoiding deep recursion and optimizing for both time and space. Function Signature ```python def optimized_top_sort(graph: Dict[Any, List[Any]]) -> List[Any]: ``` Input * `graph`: A dictionary representing the DAG where keys are the node identifiers and the values are lists of nodes directly reachable from the key node. Output * `List[Any]`: A list of nodes sorted in topological order. Constraints * Nodes in the graph are unique identifiers (integers, strings, etc.). * The graph contains no cycles by definition but your implementation should still handle and report cycles if present mistakenly. * The graph can contain up to 10,000 nodes and 50,000 edges. Performance Requirements * The solution must run in O(V + E) time complexity. * Space complexity must not exceed O(V). Examples 1. Given input graph: ```python { \'A\': [\'C\', \'D\'], \'B\': [\'D\'], \'C\': [\'E\'], \'D\': [\'F\'], \'E\': [\'F\'], \'F\': [] } ``` Possible topological orderings: `[\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']`, `[\'B\', \'A\', \'D\', \'C\', \'E\', \'F\']`, etc. 2. Given input graph with a cycle (for cycle detection demonstration purposes): ```python { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } ``` The function should raise a `ValueError` indicating a cycle in the graph. Notes * Implement the algorithm using an iterative approach to avoid deep recursion. * Ensure all vertices are covered including those with no outgoing edges. * Provide meaningful error messages for cycle detection.","solution":"from collections import deque, defaultdict from typing import Any, Dict, List def optimized_top_sort(graph: Dict[Any, List[Any]]) -> List[Any]: Perform an optimized topological sort on a directed acyclic graph (DAG). Parameters: graph (Dict[Any, List[Any]]): A dictionary representing the DAG where keys are node identifiers and values are lists of nodes directly reachable from the key node. Returns: List[Any]: A list of nodes sorted in topological order if no cycles are present. Raises: ValueError: If the graph contains a cycle. # Dictionary to count the number of incoming edges for each node in_degree = defaultdict(int) # Dictionary to build the adjacency list adjacency_list = defaultdict(list) # Fill in_degree and adjacency_list all_nodes = set(graph.keys()) for node, neighbors in graph.items(): for neighbor in neighbors: in_degree[neighbor] += 1 adjacency_list[node].append(neighbor) all_nodes.add(neighbor) # Initialize queue with nodes having zero in-degree zero_in_degree_queue = deque([node for node in all_nodes if in_degree[node] == 0]) topological_order = [] while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topological_order.append(node) # Decrease the in-degree of neighbors for neighbor in adjacency_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If topological sorting includes all nodes, return the order if len(topological_order) == len(all_nodes): return topological_order else: raise ValueError(\\"The graph has a cycle\\")"},{"question":"# Question: Cycle Detection in Directed Graph Objective: You are tasked with developing a function to detect if there is a cycle in a directed graph. This problem is akin to detecting deadlocks in a multi-threaded multiprocessing system or verifying that prerequisite tasks don\'t mutually depend on each other. Function Signature ```python def contains_cycle(graph: Dict[Any, List[Any]]) -> bool: ``` Input: * `graph` (Dict[Any, List[Any]]): A directed graph represented as an adjacency list where each key is a node and the value is a list of neighbors. Output: * Returns `True` if the graph contains a cycle, `False` otherwise. Constraints: * The graph does not contain self-loops unless explicitly specified. * The graph may have isolated nodes (nodes without any edges). Example: ```python graph_1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } graph_2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } graph_3 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } assert contains_cycle(graph_1) == True assert contains_cycle(graph_2) == False assert contains_cycle(graph_3) == True ``` Notes: * Process the graph using Depth-First Search (DFS). * Utilize a state tracking mechanism to identify visited nodes and detect cycles. * Consider edge cases such as disconnected graphs and graphs with multiple components.","solution":"def contains_cycle(graph): Detect if the directed graph contains a cycle. :param graph: Dict representing the adjacency list of the graph :return: True if the graph contains a cycle, False otherwise def dfs(node, visited, recursion_stack): Helper function to perform DFS and detect cycle. :param node: The current node being visited :param visited: Set containing all the visited nodes :param recursion_stack: Stack of nodes currently in the recursion stack :return: True if cycle is detected, False otherwise # Mark the current node as visited and add to recursion stack if node not in visited: visited.add(node) recursion_stack.add(node) # Visit all the neighbors for neighbor in graph.get(node, []): if neighbor not in visited and dfs(neighbor, visited, recursion_stack): return True elif neighbor in recursion_stack: return True # Remove the node from recursion stack after all its neighbors are processed recursion_stack.remove(node) return False visited = set() # To keep track of all the visited nodes recursion_stack = set() # To keep track of nodes in the current call stack # Check every node in the graph for node in graph: if node not in visited: if dfs(node, visited, recursion_stack): return True return False"},{"question":"You are tasked to implement a factorial function incorporating both iterative and recursive approaches, similar to the provided snippets. However, to test deeper comprehension, you are to extend the functionality to handle larger computations more efficiently by using memoization for the recursive approach. # Objective Design two functions: 1. `factorial_memo(n, mod=None)` - Calculates factorial recursively using memoization. 2. `factorial_iter(n, mod=None)` - Implements the iterative approach provided in the snippet. # Requirements 1. Both functions should calculate the factorial of a given non-negative integer `n`. 2. Support a modulo parameter `mod`. If `mod` is provided, return the result as `n! % mod`. 3. Raise a `ValueError` if: - `n` is not a non-negative integer. - `mod` is not a positive integer when provided. # Input and Output formats **Input**: - `n`: non-negative integer (0 ≤ n ≤ 100,000) - `mod`: positive integer (optional) **Output**: - Return `n!` if `mod` is not provided. - Return `n! % mod` if `mod` is provided. # Constraints and Performance Requirements - The recursive approach should use memoization to handle repetitive calculations efficiently. - Both solutions should be optimized to handle larger values within constraints. - Time complexity: O(n) - Space complexity for `factorial_memo`: O(n) due to recursion. # Function Signatures ```python def factorial_memo(n: int, mod: int = None) -> int: pass def factorial_iter(n: int, mod: int = None) -> int: pass ``` # Examples ```python # Example 1 print(factorial_memo(5)) # Output: 120 print(factorial_iter(5)) # Output: 120 # Example 2 print(factorial_memo(5, 3)) # Output: 0 print(factorial_iter(5, 3)) # Output: 0 # Example 3 print(factorial_memo(0)) # Output: 1 print(factorial_iter(0)) # Output: 1 ``` # Context You are a software engineer tasked with implementing efficient algorithms for computing factorial in a competitive programming setting where performance is crucial. The factorial calculations often have to deal with very large numbers, and hence modular arithmetic is used to keep numbers manageable and avoid overflow.","solution":"def factorial_memo(n: int, mod: int = None, _memo={0: 1}) -> int: Calculate the factorial of a non-negative integer n using a recursive approach with memoization. Args: n (int): Non-negative integer for which to calculate factorial. mod (int, optional): A positive integer, if specified compute n! % mod. Returns: int: The factorial of n or n! % mod if mod is specified. if not isinstance(n, int) or not (n >= 0): raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None: if not isinstance(mod, int) or mod <= 0: raise ValueError(\\"mod must be a positive integer.\\") if n in _memo: result = _memo[n] else: result = n * factorial_memo(n - 1, mod, _memo) if mod: result %= mod _memo[n] = result return result if not mod else result % mod def factorial_iter(n: int, mod: int = None) -> int: Calculate the factorial of a non-negative integer n using an iterative approach. Args: n (int): Non-negative integer for which to calculate factorial. mod (int, optional): A positive integer, if specified compute n! % mod. Returns: int: The factorial of n or n! % mod if mod is specified. if not isinstance(n, int) or not (n >= 0): raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None: if not isinstance(mod, int) or mod <= 0: raise ValueError(\\"mod must be a positive integer.\\") result = 1 for i in range(2, n + 1): result *= i if mod: result %= mod return result if not mod else result % mod"},{"question":"# Interpolation Search Extension You are tasked with extending the Interpolation Search algorithm to handle arrays where some elements could be non-integers (floating-point numbers) and strings, beyond just integer arrays. Your solution should aim to maintain or improve the performance characteristics of Interpolation Search while ensuring that it functions correctly with these new data types. # Required Implementation 1. **Function Signature**: Implement the function to handle different types of arrays appropriately. ```python def extended_interpolation_search(array: List[Union[int, float, str]], search_key: Union[int, float, str]) -> int: ``` 2. **Parameters**: * `array`: A sorted list of integers, floating-point numbers, or strings. The function should handle comparisons and positional calculations based on the type of the elements. * `search_key`: The key to be searched in the array, which could be an integer, floating-point number, or string. 3. **Return**: Index of `search_key` in `array` if found, else -1. 4. **Constraints**: * All elements in `array` are of the same type. * The array is pre-sorted in ascending order. * Strings in the array are all lowercase and composed of alphabetic characters only. # Example ```python # Integers print(extended_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1)) # Output: 2 print(extended_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55)) # Output: -1 # Floats print(extended_interpolation_search([1.1, 2.2, 3.3, 4.4, 5.5, 6.6], 4.4)) # Output: 3 print(extended_interpolation_search([1.0, 1.5, 2.0, 2.5, 4.0], 3.5)) # Output: -1 # Strings print(extended_interpolation_search([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"date\\")) # Output: 3 print(extended_interpolation_search([\\"alpha\\", \\"beta\\", \\"gamma\\"], \\"delta\\")) # Output: -1 ``` # Notes * Ensure type correctness and compare elements appropriately based on their type. * Consider edge cases, such as empty arrays or very small arrays. # Performance Requirements * The implementation should aim to maintain at least the average-case time complexity of O(log2(log2 n)) for uniformly distributed data types.","solution":"from typing import List, Union def extended_interpolation_search(array: List[Union[int, float, str]], search_key: Union[int, float, str]) -> int: lo = 0 hi = len(array) - 1 while lo <= hi and array[lo] <= search_key <= array[hi]: if lo == hi: if array[lo] == search_key: return lo return -1 # Interpolation formula adjustments for different types if isinstance(array[lo], (int, float)): pos = lo + int(((hi - lo) / (array[hi] - array[lo])) * (search_key - array[lo])) elif isinstance(array[lo], str): pos = lo + int(((hi - lo) / (ord(array[hi][0]) - ord(array[lo][0]))) * (ord(search_key[0]) - ord(array[lo][0]))) else: raise TypeError(\\"Unsupported element type in array\\") # Ensure pos is within bounds if pos < lo or pos > hi: return -1 if array[pos] == search_key: return pos if array[pos] < search_key: lo = pos + 1 else: hi = pos - 1 return -1"},{"question":"Scenario You are working on an application that deals with a list of user scores. You need to ensure these scores are sorted in ascending order to provide accurate rankings. After analyzing various sorting algorithms, you have decided to use the Cocktail Shaker Sort due to its effectiveness on nearly sorted data. Task Implement the `cocktail_shaker_sort` function, which sorts a given list of integers in ascending order using Cocktail Shaker Sort algorithm. Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: A list of integers `arr` (1 <= len(arr) <= 1000). Output * Returns a list of integers sorted in ascending order. Constraints * The elements in the list are within the range of -10^6 to 10^6. * Aim for a solution that respects the worst-case time complexity of O(n^2). * Ensure that the function handles edge cases gracefully, such as lists with one element or lists that are already sorted. Performance Requirements * Optimize the function to minimize unnecessary passes over the array, especially for already sorted or nearly sorted lists. Example ```python # Example 1 input: [3, 2, 3, 12, 4] output: [2, 3, 3, 4, 12] # Example 2 input: [7] output: [7] # Example 3 input: [10, 7, 8, 9, 1, 5] output: [1, 5, 7, 8, 9, 10] # Example 4 input: [] output: [] ``` * Write a function that operates in-place to modify the given list and returns the sorted list.","solution":"def cocktail_shaker_sort(arr): Sorts a list of integers in ascending order using the Cocktail Shaker Sort algorithm. if not arr: return arr n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"You are given a class `Graph` that models a directed graph and includes methods to determine if the graph is strongly connected. The code includes methods for adding edges, performing a Depth First Search (DFS), reversing the graph, and checking strong connectivity. # Problem Statement Write a function `add_multiple_edges` that adds multiple directed edges at once to the graph. Then, write a function `check_strong_connectivity` that uses the provided methods to verify if the graph formed by those edges is strongly connected. # Function Signatures ```python def add_multiple_edges(graph, edges): Adds multiple directed edges to the graph. Args: graph (Graph): An instance of the Graph class. edges (list of tuples): A list where each tuple (u, v) represents a directed edge from \'u\' to \'v\'. pass def check_strong_connectivity(vertex_count, edges): Checks if the graph with given vertex count and edges is strongly connected. Args: vertex_count (int): The number of vertices in the graph. edges (list of tuples): A list where each tuple (u, v) represents a directed edge from \'u\' to \'v\'. Returns: bool: True if the graph is strongly connected, False otherwise. pass ``` # Input and Output Format - `add_multiple_edges(graph, edges)`: Does not return anything. Adds all edges from the list to the graph. - `check_strong_connectivity(vertex_count, edges)`: - **Input**: - An integer `vertex_count` — the number of vertices. - A list of tuples `edges` representing directed edges. - **Output**: - A boolean value indicating whether the graph is strongly connected. # Constraints - 2 ≤ `vertex_count` ≤ 1000 - 1 ≤ |edges| ≤ 2000 # Example ```python if __name__ == \\"__main__\\": graph = Graph(5) edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] add_multiple_edges(graph, edges) print(graph.is_strongly_connected()) # Output: True assert check_strong_connectivity(5, edges) == True edges = [(0, 1), (1, 2), (3, 4)] assert check_strong_connectivity(5, edges) == False # Output: False ``` Your implementation should demonstrate a clear understanding of graph operations, specifically with strong connectivity and multiple edge additions.","solution":"class Graph: def __init__(self, vertices): self.vertices = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, u, v): self.graph[u].append(v) def _dfs(self, v, visited): visited[v] = True for i in self.graph[v]: if not visited[i]: self._dfs(i, visited) def _get_transpose(self): g = Graph(self.vertices) for i in range(self.vertices): for j in self.graph[i]: g.add_edge(j, i) return g def is_strongly_connected(self): # Step 1: Do DFS traversal of the original graph visited = [False] * self.vertices self._dfs(0, visited) if any(not x for x in visited): return False # Step 2: Get the transpose of the graph gr = self._get_transpose() # Step 3: Do DFS traversal of the transposed graph visited = [False] * self.vertices gr._dfs(0, visited) if any(not x for x in visited): return False return True def add_multiple_edges(graph, edges): Adds multiple directed edges to the graph. Args: graph (Graph): An instance of the Graph class. edges (list of tuples): A list where each tuple (u, v) represents a directed edge from \'u\' to \'v\'. for u, v in edges: graph.add_edge(u, v) def check_strong_connectivity(vertex_count, edges): Checks if the graph with given vertex count and edges is strongly connected. Args: vertex_count (int): The number of vertices in the graph. edges (list of tuples): A list where each tuple (u, v) represents a directed edge from \'u\' to \'v\'. Returns: bool: True if the graph is strongly connected, False otherwise. graph = Graph(vertex_count) add_multiple_edges(graph, edges) return graph.is_strongly_connected()"},{"question":"Extracting the nth Digit from a Sequential Concatenation **Scenario**: You\'re tasked with creating a function that can determine and return the nth digit from a long sequence of concatenated positive integers starting from 1 (i.e., \\"12345678910111213...\\"). This is particularly useful in contexts where digit placement within an ordered sequence needs extraction efficiently. **Function Signature**: ```python def find_nth_digit(n: int) -> int: This function finds and returns the nth digit in an infinitely long sequence of positive integers in a concatenated format. Args: n (int): the position of the digit to be found (1-indexed). Returns: int: the digit at the given position in the sequence. ``` # Input - An integer `n` (1 <= n <= 2^31 - 1), where `n` represents the position in the concatenated sequence. # Output - An integer representing the digit at the nth position in the concatenated number sequence. # Constraints - Handle the upper bound effectively to avoid performance issues. - Ensure precision in division calculations to avoid floating point errors. # Performance Requirements - The function should run in O(log(n)) time complexity. - The function should only use a constant amount of extra space. # Example ```python # Example 1 assert find_nth_digit(3) == 3 # The sequence \\"123\\" has \'3\' as the 3rd digit. # Example 2 assert find_nth_digit(11) == 0 # The sequence \\"12345678910\\", \'0\' is the 11th digit. ``` # Hints 1. Think about how numbers grow incrementally and how digit lengths change. 2. Consider using loops to progressively narrow down where the nth digit is located.","solution":"def find_nth_digit(n: int) -> int: Finds and returns the nth digit in an infinitely long sequence of positive integers in a concatenated format. Args: n (int): the position of the digit to be found (1-indexed). Returns: int: the digit at the given position in the sequence. digit_length = 1 count = 9 start = 1 while n > digit_length * count: n -= digit_length * count digit_length += 1 count *= 10 start *= 10 number = start + (n - 1) // digit_length digit_index = (n - 1) % digit_length return int(str(number)[digit_index])"},{"question":"# Robot Path Circle Validation Given a sequence of moves represented as a string, write a function `validate_robot_circle` that determines if the robot returns to the origin (0,0) after executing all moves. The moves are represented by characters \'R\' (right), \'L\' (left), \'U\' (up), and \'D\' (down). Your function should return `True` if the robot makes a circle and returns to the start point and `False` otherwise. Example: - **Example 1:** - Input: `\\"UD\\"` - Output: `True` - Explanation: The robot moves up and down, returning to the starting point. - **Example 2:** - Input: `\\"LL\\"` - Output: `False` - Explanation: The robot moves left twice, ending up at `(-2, 0)`, not the starting point. - **Example 3:** - Input: `\\"\\"` - Output: `True` - Explanation: No movement means the robot remains at the origin. Constraints: - The input will only contain the characters \'R\', \'L\', \'U\', \'D\'. # Function Signature ```python def validate_robot_circle(moves: str) -> bool: pass ``` # Requirements: - Implement the function `validate_robot_circle`. - The function should return `True` or `False`. - Time complexity should be O(n), where n is the length of the moves string. - Space complexity should be O(1).","solution":"def validate_robot_circle(moves: str) -> bool: Determines if the robot returns to the origin (0, 0) after executing all moves. Parameters: moves (str): a string representing the sequence of moves. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"# Coding Challenge: Right-Angled Triangle Side Length Calculation You need to write a function that, given the lengths of two sides of a right-angled triangle, determines the length of the third side using the Pythagorean theorem. Your function should handle different cases where either the opposite, adjacent, or hypotenuse side is unknown. Function Signature ```python def find_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: pass ``` Input - `opposite` (Union[float, str]): The length of the opposite side (a) or \\"?\\" if unknown. - `adjacent` (Union[float, str]): The length of the adjacent side (b) or \\"?\\" if unknown. - `hypotenuse` (Union[float, str]): The length of the hypotenuse (c) or \\"?\\" if unknown. Output - A string representing the unknown side\'s length, prefixed with its name (\\"Opposite = \\", \\"Adjacent = \\", or \\"Hypotenuse = \\"). Constraints - Only one of the inputs will be \\"?\\". - Any provided input will be a positive float value. - The function should raise a ValueError if it\'s impossible to calculate a valid third side (e.g., if the known sides don\'t form a valid right-angled triangle). Example ```python # Given adjacent = 3, hypotenuse = 5; opposite is unknown print(find_third_side(\\"?\\", 3.0, 5.0)) # Should return \\"Opposite = 4.0\\" # Given opposite = 6, hypotenuse = 10; adjacent is unknown print(find_third_side(6.0, \\"?\\", 10.0)) # Should return \\"Adjacent = 8.0\\" # Given opposite = 4, adjacent = 3; hypotenuse is unknown print(find_third_side(4.0, 3.0, \\"?\\")) # Should return \\"Hypotenuse = 5.0\\" ``` Edge Cases to Handle - Provide descriptive error messages for invalid geometries (e.g., negative lengths, unable to form a triangle). - Ensure correct parsing and operations even under potential floating-point precision issues.","solution":"import math from typing import Union def find_third_side(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: if opposite == \\"?\\": opposite = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite}\\" elif adjacent == \\"?\\": adjacent = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent}\\" elif hypotenuse == \\"?\\": hypotenuse = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse}\\" else: raise ValueError(\\"One side must be unknown.\\")"},{"question":"# Question You are given the implementation of a basic Hash Table and a Resizable Hash Table that resizes the hash table when the load factor exceeds 2/3. Your task is to enhance the Resizable Hash Table by implementing a more efficient rehashing technique using double hashing instead of linear probing. **Requirements:** - Implement a function `double_hash(self, old_hash, key)` that returns a new hash value leveraging double hashing technique. - Modify the methods `put`, `get`, `del_` to use `double_hash` for handling collisions. - Ensure the double hashing technique is more efficient by reducing clustering compared to linear probing. **Function Signatures:** ```python def double_hash(self, old_hash: int, key: int) -> int: # Your code here def put(self, key: int, value: any) -> None: # Your code here (modify to use double_hash) def get(self, key: int) -> any: # Your code here (modify to use double_hash) def del_(self, key: int) -> None: # Your code here (modify to use double_hash) ``` **Input and Output Description:** - `put(key, value)`: Insert the key-value pair into the hash table or update the existing key with the specified value. - `get(key)`: Returns the value associated with the key, or `None` if the key does not exist. - `del_(key)`: Removes the key-value pair from the hash table. **Constraints:** - Key values will be integers. - Assume the hash function provided uses `key % size`. **Notes:** - You may assume the provided `hash` method for initial hashing. - Double hashing should use a secondary hash function, such as `1 + (key % (self.size - 1))`.","solution":"class ResizableHashTable: def __init__(self, initial_size=8): self.size = initial_size self.table = [None] * self.size self.count = 0 def hash(self, key): return key % self.size def secondary_hash(self, key): return 1 + (key % (self.size - 1)) def double_hash(self, old_hash, key): return (old_hash + self.secondary_hash(key)) % self.size def put(self, key, value): if self.count >= 2 * self.size // 3: self._resize() index = self.hash(key) original_index = index for _ in range(self.size): if self.table[index] is None or self.table[index][0] == key: self.table[index] = (key, value) self.count += 1 return index = self.double_hash(index, key) if index == original_index: raise Exception(\\"Table is full, cannot insert\\") def get(self, key): index = self.hash(key) original_index = index for _ in range(self.size): if self.table[index] is None: return None if self.table[index][0] == key: return self.table[index][1] index = self.double_hash(index, key) if index == original_index: break return None def del_(self, key): index = self.hash(key) original_index = index for _ in range(self.size): if self.table[index] is None: return if self.table[index][0] == key: self.table[index] = None self.count -= 1 return index = self.double_hash(index, key) if index == original_index: break def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1])"},{"question":"# Rotate an Array You are given an array of integers and an integer \'k\'. Write a function to rotate the array to the right by \'k\' steps. This means that each element in the array will be shifted to the right by \'k\' positions, and the elements at the end of the array will wrap around to the beginning to fill in the positions. Function Signature: ```python def rotate_array(nums: List[int], k: int) -> None: ``` Input: * `nums` (List[int]): A list of integers representing the array. It can be of any length, including zero. * `k` (int): Number of positions to rotate the array. Output: * The function should modify the array in place and should not return anything. Constraints: * Do not use built-in functions like `list.rotate` or `collections.deque.rotate`. * Optimize for both time and space complexity. * Handle cases where k is greater than the length of the array by using `k % len(nums)`. Examples: ```python # Example 1 nums = [1,2,3,4,5,6,7] k = 3 rotate_array(nums, k) print(nums) # Output: [5,6,7,1,2,3,4] # Example 2 nums = [-1,-100,3,99] k = 2 rotate_array(nums, k) print(nums) # Output: [3,99,-1,-100] # Example 3 nums = [1, 2] k = 3 rotate_array(nums, k) print(nums) # Output: [2, 1] ``` Note: * The array should be modified in-place. * Ensure the solution handles large inputs efficiently. # Scenario: Imagine you are working on a cyclic data buffer where you have to frequently rotate the data to fit new incoming data while preserving the order. This function will help manage shifts efficiently.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> None: Rotates an array to the right by k steps in place. n = len(nums) if n == 0: return k %= n nums[:] = nums[-k:] + nums[:-k]"},{"question":"You are tasked with implementing a circular buffer (efficient array-based) queue. Circular buffer queues maintain a fixed size and overwrite old elements if the buffer is full. This is useful when you need a limited-size buffer that continuously receives new data while discarding old data automatically. Implement the `CircularBufferQueue` class, inheriting from `AbstractQueue`. Ensure that this class adheres to the following specifications: 1. **Initialization**: The queue should support a dynamic size specified at the time of creation. ```python def __init__(self, capacity: int): ``` 2. **Operations**: - `enqueue(value)`: Adds an item to the rear of the queue. If the queue is full, it should overwrite the oldest element. - `dequeue()`: Removes and returns the front item from the queue. - `peek()`: Returns (without removing) the front element of the queue. - `__len__()`: Returns the current size of the queue. - `__iter__()`: Iterator of the elements in the queue. 3. **Constraints**: - Use O(1) time complexity for `enqueue`, `dequeue`, and `peek`. - The buffer should handle integer values. # Function Signatures ```python class CircularBufferQueue(AbstractQueue): def __init__(self, capacity: int): pass def enqueue(self, value: int): pass def dequeue(self) -> int: pass def peek(self) -> int: pass def __iter__(self): pass ``` # Example ```python cbq = CircularBufferQueue(3) cbq.enqueue(1) cbq.enqueue(2) cbq.enqueue(3) print(list(cbq)) # Output: [1, 2, 3] cbq.enqueue(4) # Overwrites 1 print(list(cbq)) # Output: [2, 3, 4] front = cbq.dequeue() print(front) # Output: 2 print(list(cbq)) # Output: [3, 4] cbq.enqueue(5) print(cbq.peek()) # Output: 3 print(list(cbq)) # Output: [3, 4, 5] ```","solution":"class CircularBufferQueue: def __init__(self, capacity: int): self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def enqueue(self, value: int): self.buffer[self.tail] = value if self.size == self.capacity: self.head = (self.head + 1) % self.capacity # Overwrite else: self.size += 1 self.tail = (self.tail + 1) % self.capacity def dequeue(self) -> int: if self.size == 0: raise ValueError(\\"Queue is empty\\") value = self.buffer[self.head] self.buffer[self.head] = None # Clear the position self.head = (self.head + 1) % self.capacity self.size -= 1 return value def peek(self) -> int: if self.size == 0: raise ValueError(\\"Queue is empty\\") return self.buffer[self.head] def __len__(self): return self.size def __iter__(self): idx = self.head for _ in range(self.size): yield self.buffer[idx] idx = (idx + 1) % self.capacity"},{"question":"Scenario You are working on a file management application that needs to process various file paths and URLs. Your task is to implement a function that correctly splits a given path into its base directory and the filename/resource identifier. The path delimiter varies based on the operating system, so your implementation should handle different types of delimiters. Task Write a Python function `split_path(path: str, delimiter: str = \'/\') -> Tuple[str, str]` that splits a path based on the provided delimiter and returns a tuple containing the base directory and the file name. Input 1. `path` (str): A string representing the file path or URL. 2. `delimiter` (str): A string representing the delimiter used in the path (default is \'/\'). Output - A tuple containing two strings. 1. The base directory path. 2. The file name or resource identifier. Constraints - The path can be an empty string. - If the delimiter is not present, the entire path should be considered as the file name. - Consider the performance for long paths. Examples ```python # Example 1 input_path = \\"https://algorithms/unix/test.py\\" input_delimiter = \'/\' output = (\\"https://algorithms/unix\\", \\"test.py\\") # Example 2 input_path = \\"C:folder1folder2file.txt\\" input_delimiter = \'\' output = (\\"C:folder1folder2\\", \\"file.txt\\") # Example 3 input_path = \\"file.txt\\" input_delimiter = \'/\' output = (\\"\\", \\"file.txt\\") # Example 4 input_path = \\"folder1/folder2/\\" input_delimiter = \'/\' output = (\\"folder1/folder2\\", \\"\\") # Example 5 input_path = \\"\\" input_delimiter = \'/\' output = (\\"\\", \\"\\") ```","solution":"from typing import Tuple def split_path(path: str, delimiter: str = \'/\') -> Tuple[str, str]: Splits the path based on the provided delimiter and returns a tuple with the base directory and the file name. if delimiter not in path: return (\\"\\", path) base_dir, _, file_name = path.rpartition(delimiter) return (base_dir, file_name)"},{"question":"**Context**: In software development, managing file paths and URLs properly is crucial. Ensuring paths are concatenated without redundant slashes can help avoid errors in file access or navigation. We need a robust function to join parts of paths (either file paths or URLs). **Task**: Write a function `join_paths(base, suffix)` that takes two strings `base` and `suffix`, and returns a single, properly concatenated path. The function should ensure there is exactly one slash between the `base` and `suffix` parts, regardless of whether either part ends or begins with slashes. Additionally, implement edge-case handling: 1. If the `base` has leading or trailing spaces, deal with it appropriately. 2. If the `suffix` has leading slashes or trailing spaces, handle them properly. 3. If either `base` or `suffix` are empty, handle it by treating the other as the full path. **Function Signature**: ```python def join_paths(base: str, suffix: str) -> str: ``` **Constraints**: - The input strings `base` and `suffix` will have lengths up to 1000. - The inputs may include leading or trailing spaces. **Examples**: 1. `join_paths(\\"path/to/dir\\", \\"file\\")` should return `\\"path/to/dir/file\\"`. 2. `join_paths(\\"http://algorithms.com/\\", \\"part\\")` should return `\\"http://algorithms.com/part\\"`. 3. `join_paths(\\" /a/b/c/ \\", \\" d\\")` should return `\\"/a/b/c/d\\"`. 4. `join_paths(\\"\\", \\"file\\")` should return `\\"file\\"`. Ensure your function is efficient and correctly handles edge cases. Document your approach where necessary.","solution":"def join_paths(base: str, suffix: str) -> str: Joins the base path and suffix ensuring exactly one slash between them. Handles leading/trailing spaces and repeated slashes. # Strip leading/trailing spaces base = base.strip() suffix = suffix.strip() # Remove trailing slashes from base and leading slashes from suffix base = base.rstrip(\'/\') suffix = suffix.lstrip(\'/\') # If base is empty, return suffix and vice versa if not base: return suffix if not suffix: return base # Join with a single slash return base + \'/\' + suffix"},{"question":"**Objective**: Demonstrate understanding of string manipulation, set operations, and basic algorithm design. **Problem Statement:** You are given a list of words. Your task is to implement a function `find_keyboard_row` that returns the words which can be typed using the letters of the alphabet on only one row of an American keyboard. An American keyboard layout has the following rows: - Row 1: QWERTYUIOP - Row 2: ASDFGHJKL - Row 3: ZXCVBNM Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` Input - `words`: A list of strings representing the words. Each word contains only alphabetic characters (both uppercase and lowercase). Output - A list of strings. Each word from the input list that can be typed using letters on only one row of the keyboard should be included in the output list. Constraints - 1 <= len(words) <= 100 - Each word will have length in the range [1, 50] - All words consist of English letters. Example ```python print(find_keyboard_row([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"])) # Output: [\\"Alaska\\", \\"Dad\\"] print(find_keyboard_row([\\"omg\\", \\"TRY\\", \\"ask\\"])) # Output: [\\"TRY\\", \\"ask\\"] ``` Additional Requirements - The function should be case insensitive i.e. it should treat \'a\' and \'A\' as equivalent. - Words should be included in the output list in the same order as they appear in the input list. - The function should have a linear time complexity relative to the number and length of the words (O(n*k) where n is the number of words and k is the average length of the words).","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: # Define the keyboard rows as sets for easy lookup row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def is_single_row(word): # Convert the word to lowercase lower_word = word.lower() # Get the unique set of characters in the word unique_chars = set(lower_word) # Check if the unique characters are all in one of the rows return unique_chars <= row1 or unique_chars <= row2 or unique_chars <= row3 # Filter the words to include only those that can be typed on a single row return [word for word in words if is_single_row(word)]"},{"question":"# Question: You are required to implement a `KZigZagIterator` that generalizes the `ZigZagIterator` to handle an arbitrary number of input lists. Your iterator should iterate through the elements of the input lists in a round-robin fashion until all elements are exhausted. # Function Signature ```python class KZigZagIterator: def __init__(self, vectors: List[List[int]]): Initialize your data structure here. :param vectors: A list of lists, where each list contains integers. :type vectors: List[List[int]] def next(self) -> int: Returns the next element in the iteration. :rtype: int def has_next(self) -> bool: Returns whether the iteration has any elements left. :rtype: bool ``` # Constraints: - All elements within each list and across all lists are integers. - Lists can be of different lengths and some may be empty. - Your methods should handle calls to `next` until all elements in all lists have been returned. # Examples: ```python vectors = [[1, 2], [3, 4, 5, 6], [7, 8, 9]] iterator = KZigZagIterator(vectors) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` *Note*: Ensure your implementation is optimized with considerations of edge cases and performance bottlenecks discussed in the analysis.","solution":"from collections import deque from typing import List class KZigZagIterator: def __init__(self, vectors: List[List[int]]): Initialize your data structure here. :param vectors: A list of lists, where each list contains integers. :type vectors: List[List[int]] self.queue = deque((lst, 0) for lst in vectors if lst) # store lists along with their current index def next(self) -> int: Returns the next element in the iteration. :rtype: int if self.has_next(): lst, index = self.queue.popleft() result = lst[index] if index + 1 < len(lst): self.queue.append((lst, index + 1)) return result raise StopIteration(\\"No more elements in iterator\\") def has_next(self) -> bool: Returns whether the iteration has any elements left. :rtype: bool return bool(self.queue)"},{"question":"# Question: Hierarchical Data Organizer and Printer You are tasked with designing an algorithm to build a hierarchical data structure from a given list of relationships and create a function to print the structure nicely. You are given a list of relationships in the form of tuples. Each tuple contains a key-value pair followed by nested elements signifying parent-child relationships. Input 1. A list of tuples `relationships` where each tuple contains: * `parent`: a string representing the parent node. * `child`: a string representing the child node. * `value`: an integer representing the value associated with the child. Output * A neatly formatted hierarchical structure printed on the console, where each level of the hierarchy is indented for clarity. Constraints * There are no cycles in the hierarchy; each child has exactly one parent. * All relationships are valid and well-formed. Example ```python relationships = [ (\'a\', \'Adam\', \'Book\', 4), (\'b\', \'Bill\', \'Computer\', 5), (\'b\', \'Bill\', \'TV\', 6), (\'b\', \'Jill\', \'Sports\', 1), (\'c\', \'Bill\', \'Sports\', 3), (\'d\', \'Adam\', \'Computer\', 3), (\'d\', \'Quin\', \'Computer\', 3), (\'e\', \'Quin\', \'Book\', 5), (\'e\', \'Quin\', \'TV\', 2), (\'f\', \'Adam\', \'Computer\', 7), ] Expected output: a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Your Task 1. Write a function `build_tree(relationships)` that builds the hierarchical tree from the given list of relationships. 2. Write a function `print_tree(tree)` to print the tree in a readable format. 3. The output format should match the example exactly, ensuring each hierarchical level is clearly indented.","solution":"from collections import defaultdict def build_tree(relationships): Builds a tree from the given list of relationships. tree = defaultdict(lambda: defaultdict(dict)) for parent, child, grandchild, value in relationships: if child not in tree[parent]: tree[parent][child] = {} tree[parent][child][grandchild] = value return tree def print_tree(tree, indent=0): Prints the tree in a readable hierarchical format. for parent, children in tree.items(): print(f\\"{parent}\\") for child, grandchilds in children.items(): print(\\" \\" * (indent + 1) + f\\" -> {child}\\") for grandchild, value in grandchilds.items(): print(\\" \\" * (indent + 2) + f\\" -> {grandchild} -> {value}\\") # Example usage: relationships = [ (\'a\', \'Adam\', \'Book\', 4), (\'b\', \'Bill\', \'Computer\', 5), (\'b\', \'Bill\', \'TV\', 6), (\'b\', \'Jill\', \'Sports\', 1), (\'c\', \'Bill\', \'Sports\', 3), (\'d\', \'Adam\', \'Computer\', 3), (\'d\', \'Quin\', \'Computer\', 3), (\'e\', \'Quin\', \'Book\', 5), (\'e\', \'Quin\', \'TV\', 2), (\'f\', \'Adam\', \'Computer\', 7), ] tree = build_tree(relationships) print_tree(tree)"},{"question":"Coding Assessment Question # Context Your task is to implement a function to \\"stutter\\" a stack. In this context, stuttering a stack means duplicating every value in the stack. You will implement this functionality using an auxiliary data structure. # Question Implement a function `stutter_stack` to achieve the task using either an auxiliary stack or queue. The function must take a list representing a stack (bottom at index 0, top at the last index), and return a modified stack with every element duplicated. # Function Signature ```python def stutter_stack(stack: List[int]) -> List[int]: ``` # Input 1. `stack`: A list of integers representing the stack, where the bottom of the stack is at index 0, and the top is the last index. # Output - Returns a list of integers representing the stuttered stack. # Constraints - The stack can contain between 0 and 10^4 integers. - Each integer in the stack can be between -10^9 and 10^9. # Example ```python assert stutter_stack([3, 7, 1, 14, 9]) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] assert stutter_stack([]) == [] assert stutter_stack([5]) == [5, 5] ``` # Requirements - Your solution should efficiently handle large stacks. - Consider edge cases such as empty stacks and stacks with a single element. - Do not use any external libraries beyond Python\'s standard library. Write a function that `stutter_stack` function which should pass all the example test cases provided. You are encouraged to consider additional edge cases and ensure the accuracy and performance of your solution.","solution":"from typing import List def stutter_stack(stack: List[int]) -> List[int]: Returns a stack where every original value is duplicated. :param stack: A list of integers where the bottom of the stack is at index 0 and the top is the last index. :return: A list of integers with each element duplicated. stuttered_stack = [] for item in stack: stuttered_stack.append(item) stuttered_stack.append(item) return stuttered_stack"},{"question":"# Integer Base Conversion Functions You are required to implement two functions for integer base conversions: 1. `int_to_base(num: int, base: int) -> str`: * Takes an integer `num` and converts it to its string representation in the specified `base`. * The base can be any integer between 2 and 36 (inclusive). * If the number is negative, the result should also reflect the sign. * The function should support bases only up to 36 due to alphanumeric representation limitations (0-9, A-Z). 2. `base_to_int(str_to_convert: str, base: int) -> int`: * Takes a string `str_to_convert`, representing a number in the specified `base`, and converts it back to an integer. * The base can be any integer between 2 and 36 (inclusive). * The function should handle both positive and negative numbers, indicated by \'-\' at the start of the string. **Constraints:** * Input `num` for `int_to_base` can be any integer. * Input `str_to_convert` for `base_to_int` will be a valid string representation in the given base. * Base `base` will always lie between 2 and 36 (inclusive). # Example Input and Output ```python # Example 1 print(int_to_base(255, 16)) # Output: \\"FF\\" # Example 2 print(base_to_int(\\"FF\\", 16)) # Output: 255 # Example 3 print(int_to_base(-10, 3)) # Output: \\"-101\\" # Example 4 print(base_to_int(\\"-124\\", 5)) # Output: -39 ``` # Notes: 1. Ensure the implementation handles edge cases like zero and negative numbers correctly. 2. Performance considerations should be in place for handling large numbers efficiently. 3. Do not use Python’s built-in functions for direct base conversion (like `bin`, `hex`, or `int`).","solution":"def int_to_base(num: int, base: int) -> str: Converts an integer num to its string representation in the specified base. Args: num (int): The integer to convert. base (int): The base for conversion, between 2 and 36 (inclusive). Returns: str: The string representation of the number in the specified base. if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" result = \\"\\" sign = \\"\\" if num < 0: sign = \\"-\\" num = -num while num > 0: result = digits[num % base] + result num //= base return sign + result def base_to_int(str_to_convert: str, base: int) -> int: Converts a string representation in a specified base to its integer form. Args: str_to_convert (str): The string representation of the number. base (int): The base of the number string, between 2 and 36 (inclusive). Returns: int: The integer representation of the number in the specified base. digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = 1 if str_to_convert[0] == \'-\': sign = -1 str_to_convert = str_to_convert[1:] result = 0 for char in str_to_convert: result = result * base + digits.index(char) return sign * result"},{"question":"# N-Frequency Element Limiter Objective: Write a function `limit_element_frequency(lst, N)` that limits the frequency of each element in the given list `lst` to appear no more than `N` times. The original order of elements must be preserved. Input: - `lst` (list of integers): A non-empty list of integers. - `N` (integer): A non-negative integer representing the maximum frequency for each element. Output: - A list of integers with each number appearing at most `N` times. Constraints: - 0 ≤ N ≤ len(lst) - 1 ≤ len(lst) ≤ 10^5 - -10^9 ≤ lst[i] ≤ 10^9 Example: ```python assert limit_element_frequency([1,2,3,1,2,1,2,3], 2) == [1, 2, 3, 1, 2, 3] assert limit_element_frequency([20,37,20,21], 1) == [20, 37, 21] assert limit_element_frequency([], 1) == [] assert limit_element_frequency([1, 2, 3], 0) == [] ``` Requirements: 1. Your function must run in O(n) time complexity. 2. Use a dictionary to keep track of the counts of each element. Additional Notes: - Consider using Python\'s `collections.defaultdict` for efficient key-count management. - You should write additional test cases to cover the potential edge cases.","solution":"from collections import defaultdict def limit_element_frequency(lst, N): Limits the frequency of each element in lst to appear no more than N times while preserving the original order. Parameters: lst (list of int): The input list of integers. N (int): The maximum frequency for each element. Returns: list of int: A list with each number appearing at most N times. if N == 0: return [] element_count = defaultdict(int) result = [] for elem in lst: if element_count[elem] < N: result.append(elem) element_count[elem] += 1 return result"},{"question":"**Coding Assessment Question** # Problem Statement As a software developer, you\'re assigned to work on a project that requires analyzing large numbers. One of the frequent operations you need to perform is determining the number of digits in given integers quickly. Your task is to implement a function that can efficiently calculate the number of digits in an integer. # Function Signature ```python def num_digits(n: int) -> int: pass ``` # Input * An integer `n` which can be positive, negative, or zero. * `-10^18 <= n <= 10^18` # Output * An integer representing the number of digits in `n`. # Constraints * You must implement the function with a time complexity of O(1). * Consider edge cases such as when `n` is zero or negative. # Requirements * Use the built-in `math.log10` function for your solution. * Ensure your function handles zero and negative numbers correctly. # Example 1. Input: `n = 0` Output: `1` 2. Input: `n = 12345` Output: `5` 3. Input: `n = -1234` Output: `4` # Notes * The `math.log10` function calculates the base-10 logarithm of a number. * The number of digits of `n` can be obtained by applying `math.log10` to its absolute value and then adding 1, except when `n` is zero which should return 1. Write your solution in the function `num_digits` following the above guidelines.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the given integer n. Handles positive, negative, and zero values. if n == 0: return 1 return int(math.log10(abs(n))) + 1"},{"question":"# Question: GCD and LCM Calculator with Extended Constraints You are given a task to implement a function that computes the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) for two given non-negative integers `a` and `b`, using custom constraints and optimizations. Function Signature ```python def gcd_and_lcm(a: int, b: int) -> (int, int): Computes both GCD and LCM of two non-negative integers and returns them as a tuple. Special conditions: 1. If one or both inputs are non-positive, raise a ValueError with message: \\"Inputs must be positive integers.\\" 2. Utilize both Euclidean Algorithm and Bitwise optimizations for GCD computations. 3. Implement the LCM function using the GCD result. :param a: non-negative integer :param b: non-negative integer :return: A tuple (GCD, LCM) ``` Constraints - The inputs `a` and `b` are non-negative integers within the range of `1 ≤ a, b ≤ 10^18`. - You must handle edge cases, such as extremely large numbers, effectively and efficiently. - The computation should be optimized to handle the upper limits of the range in reasonable time. Input - Two non-negative integers `a` and `b`. Output - A tuple `(gcd, lcm)` where `gcd` is the greatest common divisor of `a` and `b`, and `lcm` is the least common multiple of `a` and `b`. Examples 1. **Example 1**: Input: `a = 21, b = 6` Output: `(3, 42)` Explanation: `GCD(21, 6) = 3` and `LCM(21, 6) = (21 * 6) / 3 = 42` 2. **Example 2**: Input: `a = 14, b = 5` Output: `(1, 70)` Explanation: `GCD(14, 5) = 1` and `LCM(14, 5) = (14 * 5) / 1 = 70` 3. **Example 3**: Input: `a = 100, b = 100` Output: `(100, 100)` Explanation: `GCD(100, 100) = 100` and `LCM(100, 100) = (100 * 100) / 100 = 100` Your implementation should be robust, efficient, and handle large input sizes gracefully.","solution":"def gcd_and_lcm(a: int, b: int) -> (int, int): Computes both GCD and LCM of two non-negative integers and returns them as a tuple. Special conditions: 1. If one or both inputs are non-positive, raise a ValueError with message: \\"Inputs must be positive integers.\\" 2. Utilize both Euclidean Algorithm and Bitwise optimizations for GCD computations. 3. Implement the LCM function using the GCD result. :param a: non-negative integer :param b: non-negative integer :return: A tuple (GCD, LCM) if a <= 0 or b <= 0: raise ValueError(\\"Inputs must be positive integers.\\") def gcd(x, y): while y: x, y = y, x % y return x gcd_value = gcd(a, b) lcm_value = (a * b) // gcd_value if gcd_value != 0 else 0 return gcd_value, lcm_value"},{"question":"# Nearest Neighbor Search Problem Assume you are working on a recommendation system that needs to find the nearest preferences of a user based on previous user data. **Objective**: Implement the `nearest_neighbor` function to return the label of the nearest neighbor. Function Signature ```python def nearest_neighbor(x: tuple, tSet: dict) -> any: ``` Input * `x`: A vector (tuple of floats/integers) representing the input user preferences. * `tSet`: A dictionary where keys are vectors (tuples of floats/integers) representing the previous user preferences, and values are labels (could be any type). Output * The label of the training vector that is closest to `x` according to Euclidean distance. Constraints * All vectors in `tSet` and `x` will have the same length. * The length of `tSet` will be at least 1. Example ```python tSet = { (1, 2): \\"A\\", (4, 5): \\"B\\", (1, 3): \\"A\\", (10, 12): \\"C\\" } x = (1,3) print(nearest_neighbor(x, tSet)) # Output should be \\"A\\" ``` Performance Considerations * Your solution should handle the input efficiently, particularly when `tSet` contains a large number of vectors. * Consider the impact of dimensionality on performance and provide notes on possible optimizations.","solution":"import math def nearest_neighbor(x: tuple, tSet: dict) -> any: Returns the label of the closest vector in tSet to the vector x. # Initialize variables to store the nearest neighbor and the minimum distance found so far nearest = None min_distance = float(\'inf\') # Calculate the Euclidean distance between vectors def euclidean_distance(vec1, vec2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(vec1, vec2))) # Iterate through the training set to find the closest vector for vec, label in tSet.items(): distance = euclidean_distance(x, vec) if distance < min_distance: min_distance = distance nearest = label return nearest"},{"question":"Context You are tasked with understanding and implementing graph algorithms for a new network analysis tool. One of the fundamental tasks is determining the reachability of nodes in a directed graph, i.e., establishing whether there\'s a path from node A to node B for all pairs of nodes. Challenge Given a directed graph represented by an adjacency list, you are to compute the transitive closure matrix indicating the connectivity of nodes. Task Implement the `compute_transitive_closure` function which accepts a directed graph represented as an adjacency list and returns its transitive closure. Function Signature ```python def compute_transitive_closure(adj_list): Computes the transitive closure of a directed graph Parameters: adj_list (dict): A dictionary where the keys are nodes and the values are lists of nodes that the key node has edges to. Returns: list[list[int]]: A 2D list representing the reachability matrix of the graph. ``` Input * `adj_list`: A dictionary representation of a directed graph, where the key is an integer node and the value is a list of integers representing nodes that the key node has edges to. * Assume nodes are zero-indexed and there are no duplicate edges. Output * A 2D list (list of lists) of size n x n, where `n` is the number of unique nodes in the graph. `output[i][j]` should be `1` if there\'s a path from node `i` to node `j`, otherwise `0`. Example ```python adj_list = { 0: [1], 1: [2], 2: [0, 3], 3: [2] } assert compute_transitive_closure(adj_list) == [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], ] ``` Constraints * The graph can have up to 1000 nodes. * Handle self-loops and disconnected components correctly. * Ensure solution runs efficiently within the given constraints. Notes * Use deep recursion protection or convert recursive DFS to iterative form if necessary.","solution":"def compute_transitive_closure(adj_list): Computes the transitive closure of a directed graph. Parameters: adj_list (dict): A dictionary where the keys are nodes and the values are lists of nodes that the key node has edges to. Returns: list[list[int]]: A 2D list representing the reachability matrix of the graph. def dfs(node, reachability_matrix, graph): for neighbor in graph.get(node, []): if not reachability_matrix[start][neighbor]: # If not already reachable reachability_matrix[start][neighbor] = 1 dfs(neighbor, reachability_matrix, graph) nodes = list(adj_list.keys()) n = len(nodes) # Initialize the reachability matrix with 0s reachability_matrix = [[0] * n for _ in range(n)] for node in nodes: # Each node should be reachable from itself reachability_matrix[node][node] = 1 # Performing DFS for each node to determine reachability for start in nodes: dfs(start, reachability_matrix, adj_list) return reachability_matrix"},{"question":"Scenario You are a software engineer assigned to debug an application tracking data anomalies. Given arrays with known structure, your task is to identify the unique anomalies that occur only once while all other elements occur exactly twice. Task Write a function `find_unique_elements` that takes an array `nums` and returns the two elements that appear only once. # Function Signature ```python def find_unique_elements(nums: List[int]) -> List[int]: pass ``` # Input * `nums`: A list of integers where exactly two elements appear only once and all the other elements appear exactly twice. # Output * A list of two integers representing the unique elements. The order of the result does not matter. # Constraints * Time Complexity: The solution should run in O(N) time. * Space Complexity: The solution should use O(1) additional space. * It is guaranteed that there are exactly two unique numbers in the list. * The list will contain at least two unique numbers and no zero elements. # Example ```python nums = [1, 2, 1, 3, 2, 5] find_unique_elements(nums) # expected output: [3, 5] or [5, 3] ``` # Notes 1. Make sure your solution handles all edge cases. 2. You are allowed to use bitwise operations and properties of XOR to achieve the desired time and space complexity.","solution":"from typing import List def find_unique_elements(nums: List[int]) -> List[int]: xor_all = 0 for num in nums: xor_all ^= num # Find a bit that is set in xor_all (indicating a difference between the two unique numbers) set_bit = 1 while (xor_all & set_bit) == 0: set_bit <<= 1 unique1, unique2 = 0, 0 for num in nums: if num & set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"# Question You have been tasked with developing a function that processes a list to limit the occurrences of each element to a specific maximum. This function should preserve the order of the elements from the original list. Function Signature ```python def limit_occurrences(lst: List[int], max_occurrences: int) -> List[int]: ``` Input * `lst`: A list of integers, where `1 <= len(lst) <= 10^5`. * `max_occurrences`: An integer representing the maximum number of times each element can appear in the result list, `1 <= max_occurrences <= 100`. Output * Returns a list of integers which contains each number from the original list at most `max_occurrences` times, maintaining the original order. Constraints * The function should aim for linear time complexity, O(n), where n is the length of the list. Example ```python # Example 1: lst = [1, 2, 3, 1, 2, 1, 2, 3] max_occurrences = 2 # The result should be [1, 2, 3, 1, 2, 3] # Example 2: lst = [1, 1, 1, 1] max_occurrences = 2 # The result should be [1, 1] # Example 3: lst = [1, 2, 3, 3, 3] max_occurrences = 1 # The result should be [1, 2, 3] print(limit_occurrences(lst, max_occurrences)) ```","solution":"from typing import List def limit_occurrences(lst: List[int], max_occurrences: int) -> List[int]: Limits the occurrences of each element in the list to a specific maximum, while preserving the order of elements from the original list. :param lst: List of integers (1 <= len(lst) <= 10^5) :param max_occurrences: Maximum number of times each element can appear in the result list (1 <= max_occurrences <= 100) :return: List of integers with limited occurrences and order preserved occurrences = {} result = [] for num in lst: if occurrences.get(num, 0) < max_occurrences: result.append(num) occurrences[num] = occurrences.get(num, 0) + 1 return result"},{"question":"# Context You\'re developing a simple search application. One module should allow users to search for an item within their collection. This collection is stored as an array. You need to find the position of an item in this collection. # Problem Write a function `find_item_position` which uses linear search to find the index of a given item in an array. # Function Signature ```python def find_item_position(array: List[int], target: int) -> int: pass ``` # Input * `array` - A list of integers which can include duplicates and may be unsorted. * `target` - Integer value representing the element to search for in the array. # Output * Return the index of the target in the array if found. * Return `-1` if the target is not found in the array. # Constraints * The length of the array will not exceed `10^4`. * Each element in the array is an integer between `-10^5` and `10^5`. # Examples ```python assert find_item_position([4, 2, 3, 1, 5], 3) == 2 assert find_item_position([4, 2, 3, 1, 5], 6) == -1 assert find_item_position([], 1) == -1 assert find_item_position([1, 2, 2, 3], 2) == 1 assert find_item_position([1, 2, 3], 1) == 0 ``` # Notes * The function should handle edge cases, such as empty arrays and targets that do not exist within the array. * The function should return the index of the first occurrence of the target if it appears multiple times in the array.","solution":"from typing import List def find_item_position(array: List[int], target: int) -> int: Uses linear search to find the index of a given item in an array. Returns the index of the target in the array if found, otherwise returns -1. for index, item in enumerate(array): if item == target: return index return -1"},{"question":"# Question You are given four different implementations of string reversal. Your task is to implement a string reversal function that combines the robustness of iterative approach with the conciseness of Pythonic methods. Specifically, you need to write a function that: 1. Reverses the string using an iterative two-pointer technique. 2. Uses Pythonic idioms where beneficial without compromising performance. Write a function `reverse_string_advanced(s)` that fulfills these requirements. Your function should not use slicing `[::-1]` directly, but you can use other built-in Python functionalities to aid your approach. Function Signature ```python def reverse_string_advanced(s: str) -> str: ``` Input Parameters * `s` (string): The input string. Output * Returns a new string that is the reverse of the input string `s`. Constraints * The input string can have a length up to (10^6) characters. # Example ```python assert reverse_string_advanced(\\"hello\\") == \\"olleh\\" assert reverse_string_advanced(\\"\\") == \\"\\" assert reverse_string_advanced(\\"abcd\\") == \\"dcba\\" assert reverse_string_advanced(\\"a\\") == \\"a\\" ``` # Performance Requirements * Your solution should handle strings up to (10^6) characters efficiently.","solution":"def reverse_string_advanced(s: str) -> str: Reverses the input string s using an iterative two-pointer technique with Pythonic idioms where beneficial without compromising performance. # Convert the string to a list to allow element swapping. str_list = list(s) left, right = 0, len(str_list) - 1 # Use a two-pointer technique to reverse the string. while left < right: # Swap the characters at the left and right positions. str_list[left], str_list[right] = str_list[right], str_list[left] # Move the pointers towards the center. left += 1 right -= 1 # Convert the list back to a string and return it. return \'\'.join(str_list)"},{"question":"# Inorder Tree Traversal Implementation Objective You are given a binary tree and you need to implement a function to perform in-order traversal of the tree. An inorder traversal visits the left subtree, then the root node, and then the right subtree. You need to return the values of the nodes in the inorder sequence. Input Format * The input is the root node of a binary tree. Output Format * Return a list of integers representing the values of nodes in inorder sequence. Constraints * You cannot use any built-in tree traversal utilities. * The tree can be of any size up to `10^5` nodes. * Nodes\' values are integers, and each integer value is unique. Function Signature ```python def inorder_traversal(root: Node) -> List[int]: pass ``` Example ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_traversal(n1) == [25, 50, 75, 100, 125, 150, 175] ``` Note: * Your code should handle cases where the tree is empty (the root node is `None`). * Your implementation should run efficiently even for larger trees.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[Node]) -> List[int]: result = [] def helper(node): if node: helper(node.left) result.append(node.val) helper(node.right) helper(root) return result"},{"question":"# Scenario Given the efficiency of Merge Sort, especially its stability and guaranteed O(n log n) time complexity, you are tasked with implementing a variant of the Merge Sort algorithm to sort arrays for a large-scale data processing application. While the basic algorithm works efficiently, you\'ll need to ensure that all edge cases are handled properly and minimize additional space usage where feasible. # Question Implement a function `merge_sort(arr)` that takes in a list of integers `arr` and sorts it in non-decreasing order using the Merge Sort algorithm. Ensure your implementation handles edge cases and is optimized for both efficiency and memory usage. **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` # Constraints: 1. The input array `arr` can be empty (0 ≤ len(arr) ≤ 10^5). 2. Each element in the array is an integer (−10^9 ≤ arr[i] ≤ 10^9). **Input**: * A list `arr` of integers. **Output**: * A list of the integers in `arr` sorted in non-decreasing order. # Example 1 **Input**: ```python arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] ``` **Output**: ```python [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Example 2 **Input**: ```python arr = [5, 3, 8, 4, 2] ``` **Output**: ```python [2, 3, 4, 5, 8] ``` # Example 3 **Input**: ```python arr = [] ``` **Output**: ```python [] ``` # Example 4 **Input**: ```python arr = [42] ``` **Output**: ```python [42] ``` # Performance Requirements Your solution should have a worst-case time complexity of O(n log n) and aim for an optimal space complexity.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged def merge_sort_helper(sub_arr: List[int]) -> List[int]: if len(sub_arr) <= 1: return sub_arr mid = len(sub_arr) // 2 left_half = merge_sort_helper(sub_arr[:mid]) right_half = merge_sort_helper(sub_arr[mid:]) return merge(left_half, right_half) return merge_sort_helper(arr)"},{"question":"# Context You are tasked with implementing a `BSTIterator` that allows for in-order traversal of a BST. In-order traversal of a BST visits nodes in increasing order of their values. The `BSTIterator` class should enable the iteration without using recursion. # Task Implement the `BSTIterator` class with the following methods: * `__init__(self, root)`: Initialize the iterator with the root node of the BST. * `has_next(self) -> bool`: Return `True` if the iteration has more elements, otherwise `False`. * `next(self) -> int`: Return the next smallest number in the BST. # Input and Output Formats *Input*: - `root`: A TreeNode representing the root of a BST. *Output*: - `has_next`: Returns a boolean indicating the presence of the next element. - `next`: Returns an integer which is the next smallest element in the BST. # Constraints * The nodes in the BST have distinct values. * `1 <= Number of nodes in the BST <= 10^5` * `0 <= Node value <= 10^6` # Performance * Your implementation should aim for: * `__init__` in O(h) time complexity, where h is the height of the tree. * O(1) space complexity beyond the stack used for the iteration process. # Example ```python # Define the TreeNode structure for reference class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Construct a BST # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Initialize BSTIterator iterator = BSTIterator(root) output = [] while iterator.has_next(): output.append(iterator.next()) print(output) # Output should be [3, 7, 9, 15, 20] ``` Make sure your implementation handles all edge cases and adheres to the performance requirements.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): Initialize the iterator with the root node of the BST. self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root: TreeNode): Helper function to add all leftmost nodes starting from the given node to the stack. while root: self.stack.append(root) root = root.left def has_next(self) -> bool: Return True if there are further nodes to visit, otherwise False. return len(self.stack) > 0 def next(self) -> int: Return the next smallest number in the BST. # The next element is at the top of the stack topmost_node = self.stack.pop() # If the node has a right child, we push all the leftmost nodes of that subtree into the stack if topmost_node.right: self._leftmost_inorder(topmost_node.right) # Return the value of the node return topmost_node.val"},{"question":"# Question: Binary Tree Traversal and Serialization Context To store binary trees in a compact format or to send them over networks, it\'s common to serialize them into a string format and then deserialize them back into their original tree structure. This avoids the complexity of more heavyweight data interchange formats like XML or JSON. Task Write two functions: `serialize_preorder` and `deserialize_preorder` for a binary tree that use pre-order traversal for serialization and deserialization. Function Specifications 1. **Function 1: serialize_preorder(root: TreeNode) -> str** * **Input**: * `root` - The root node of the binary tree (or None for an empty tree). * **Output**: * A string that represents the serialized tree. 2. **Function 2: deserialize_preorder(data: str) -> TreeNode** * **Input**: * `data` - The string representation of a serialized tree. * **Output**: * The root node of the deserialized binary tree (or None if the input represents an empty tree). * **Constraints**: The input data is guaranteed to be valid (formed by a correct serialization process). # Example ```python # Input tree: # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize_preorder(root) print(serialized) # Output: \\"1 2 # # 3 4 # # 5 # #\\" deserialized_root = deserialize_preorder(serialized) # The deserialized tree should match the structure of the original tree print(deserialize_preorder(serialized).val) # Output: 1 print(deserialize_preorder(serialized).left.val) # Output: 2 print(deserialize_preorder(serialized).right.val) # Output: 3 print(deserialize_preorder(serialized).right.left.val) # Output: 4 print(deserialize_preorder(serialized).right.right.val) # Output: 5 ``` Performance Requirements * Both functions should run in O(n) time complexity, where n is the number of nodes in the tree. * Try to minimize the space complexity, especially avoiding unnecessary variable creations. Notes * Handle edge cases such as empty trees gracefully. * Ensure your deserialization function can reconstruct the original tree structure exactly. * Avoid using any external libraries for tree manipulation. Good luck!","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize_preorder(root: TreeNode) -> str: Serializes a binary tree to a string using pre-order traversal. def _serialize(node: TreeNode) -> str: if not node: return \\"# \\" # Serialize current node, then recursively serialize left and right children return f\\"{node.val} \\" + _serialize(node.left) + _serialize(node.right) return _serialize(root).strip() def deserialize_preorder(data: str) -> TreeNode: Deserializes a string using pre-order traversal to a binary tree. def _deserialize(values) -> TreeNode: value = next(values) if value == \\"#\\": return None # Deserialize current node, then construct left and right children node = TreeNode(int(value)) node.left = _deserialize(values) node.right = _deserialize(values) return node values = iter(data.split()) return _deserialize(values)"},{"question":"Context You are working on a file management utility that takes user inputs for file paths and does various operations like moving, copying, or deleting files. To ensure the operations run smoothly, you need to standardize the file paths into an absolute format. Objective Implement a function that takes a relative or user-specific file path and returns its absolute path. The absolute path should resolve based on the current working directory and the user\'s home directory. # Function Signature ```python def resolve_path(file: str) -> str: ``` # Input - `file` (str): A string representing the file path. The file path may be relative (e.g., `../folder/file.txt`), or it may include a shorthand for the user\'s home directory (e.g., `~/file.txt`). # Output - Returns a string representing the absolute path of the input file. # Constraints - The input string will always be a valid file path, but it may not point to an existing file. - The path will not contain invalid characters, but it may contain relative parts or user directories. # Performance Requirements - The function should handle typical file paths efficiently without unnecessary overhead. # Example ```python # Example usage print(resolve_path(\'~/Documents/file.txt\')) # Might output: \'/home/username/Documents/file.txt\' print(resolve_path(\'../folder/file.txt\')) # Might output: \'/current/working/directory/folder/file.txt\' ``` # Additional Information - Assume you have access to a working `os` module in Python, which provides functions to deal with file paths. # Note Your function should not perform any file existence checks; it only needs to return the correct absolute path.","solution":"import os def resolve_path(file: str) -> str: Resolves the given file path to an absolute path, expanding user home and handling relative paths. Args: file (str): The file path (relative or including user home shorthand). Returns: str: The resolved absolute path. # Expand user home directory shortcut expanded_path = os.path.expanduser(file) # Resolve the absolute path absolute_path = os.path.abspath(expanded_path) return absolute_path"},{"question":"# Question Context You are given two arrays representing the preorder and postorder traversal of a **full binary tree**. Your task is to write a function that constructs the binary tree from these traversals and returns the inorder traversal of the constructed tree. # Challenge Implement a function `construct_tree(pre: list, post: list) -> list` which takes two lists, `pre` (preorder traversal) and `post` (postorder traversal), and returns the inorder traversal of the constructed binary tree. Constraints - The binary tree is a full binary tree (each node has 0 or 2 children). - Preorder and postorder arrays contain unique integers. - Arrays have a length `n` where `1 ≤ n ≤ 1000`. # Input - `pre` (List[int]): A list of integers representing the preorder traversal of the full binary tree. - `post` (List[int]): A list of integers representing the postorder traversal of the full binary tree. # Output - List[int]: A list of integers representing the inorder traversal of the constructed binary tree. Performance - Aim to optimize the solution such that the time complexity is better than or equal to O(n^2). # Example ```python pre = [1, 2, 4, 5, 3, 6, 7] post = [4, 5, 2, 6, 7, 3, 1] print(construct_tree(pre, post)) # Output: [4, 2, 5, 1, 6, 3, 7] ``` Use the following TreeNode class in your solution: ```python class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(pre, post): def buildTree(pre, post): if not pre or not post: return None root = TreeNode(pre[0]) if len(pre) == 1: return root L = post.index(pre[1]) + 1 root.left = buildTree(pre[1:L+1], post[:L]) root.right = buildTree(pre[L+1:], post[L:-1]) return root def inorderTraversal(root): return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else [] root = buildTree(pre, post) return inorderTraversal(root)"},{"question":"You are tasked to implement an algorithm that checks if two given strings are anagrams, but this time considering that the input strings may contain any characters (including uppercase letters, special characters, and spaces). Your function should be case-insensitive and ignore any non-alphabetical characters. # Function Signature ```python def enhanced_anagram(s1: str, s2: str) -> bool: ``` # Input: * `s1`: a string (1 ≤ len(s1) ≤ 10^5) * `s2`: a string (1 ≤ len(s2) ≤ 10^5) # Output: * Return `True` if both strings are anagrams of each other ignoring case and non-alphabetical characters, otherwise return `False`. # Constraints: * The function should be case-insensitive. * Ignore spaces, numbers, punctuation, and other special characters. * Optimize for both time and space complexity. # Examples: ```python assert enhanced_anagram(\\"apple\\", \\"pleap\\") == True assert enhanced_anagram(\\"apple\\", \\"Apple!!\\") == True assert enhanced_anagram(\\"ANAGRAM\\", \\"nag a ram!!!\\") == True assert enhanced_anagram(\\"Hello, World!\\", \\"dlroW olleH!\\") == True assert enhanced_anagram(\\"apple\\", \\"cherry\\") == False ``` # Hints: * Use a frequency count approach for alphabetical characters (ignoring case). * Consider using dictionaries to count the frequency.","solution":"def enhanced_anagram(s1: str, s2: str) -> bool: from collections import Counter import re # Regex to match all alphabetical characters in lower case. alpha_only = re.compile(\'[a-z]\') # Normalize the strings: lower case and filter alphabetical characters. filtered_s1 = alpha_only.findall(s1.lower()) filtered_s2 = alpha_only.findall(s2.lower()) # Get the frequency count of each character return Counter(filtered_s1) == Counter(filtered_s2)"},{"question":"# Scenario You\'re working on a video streaming platform\'s analytics team. One of your tasks involves retrieving user data from a sorted list of user activity timestamps which grows very fast. To speed up the search operation, particularly for recent user activity, you should implement the jump search algorithm. # Task Implement a function `search_activity(timestamps, target_timestamp)` that uses the Jump Search algorithm to find a specific timestamp in the sorted list of user activity timestamps. # Function Signature ```python def search_activity(timestamps: List[int], target_timestamp: int) -> int: :param timestamps: List[int] a sorted list of user activity timestamps. :param target_timestamp: int the specific timestamp to search for. :return: int the index of the specific timestamp if found, otherwise -1. ``` # Input / Output * **Input**: - `timestamps` (List[int]): A sorted list of integers representing the timestamps. - `target_timestamp` (int): The timestamp you want to find in the list. * **Output**: - An integer representing the index of `target_timestamp` in `timestamps` if found; otherwise, return -1. # Constraints * Assume the timestamps are sorted in non-decreasing order. * The length of the list can be very large (up to 10^6). * The maximum value for any timestamp is 10^9. # Example ```python timestamps = [1, 3, 5, 7, 9, 11, 13, 15] target_timestamp = 11 assert search_activity(timestamps, target_timestamp) == 5 target_timestamp = 4 assert search_activity(timestamps, target_timestamp) == -1 ``` # Note * Keep in mind the optimal time complexity O(√n) when implementing your function. * Think through edge cases such as the target being the first or the last element, or not present at all.","solution":"from math import sqrt from typing import List def search_activity(timestamps: List[int], target_timestamp: int) -> int: :param timestamps: List[int] a sorted list of user activity timestamps. :param target_timestamp: int the specific timestamp to search for. :return: int the index of the specific timestamp if found, otherwise -1. n = len(timestamps) if n == 0: return -1 # Block size to be jumped step = int(sqrt(n)) # Finding the block where element is present (if it is present) prev = 0 while timestamps[min(step, n)-1] < target_timestamp: prev = step step += int(sqrt(n)) if prev >= n: return -1 # Doing a linear search for target_in_block in the found block while timestamps[prev] < target_timestamp: prev += 1 if prev == min(step, n): return -1 # If the element is found if timestamps[prev] == target_timestamp: return prev return -1"},{"question":"# Subsets Generation Challenge In this exercise, you are tasked with implementing a function to generate all possible subsets of a given set of distinct integers. The solution set must not include duplicate subsets and should encompass all subsets, including the empty set. Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: pass ``` Input * `nums` (List[int]): A list of distinct integers. Output * List[List[int]]: A list of lists, where each inner list is a subset of the input list. Constraints * Elements in the subset should be in non-decreasing order (sorted). * The function should be able to handle up to 10 distinct integers in the input list. Example Input: ```python nums = [1, 2, 3] ``` Output: ```python [ [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] ] ``` Performance Requirements * The solution should handle the expected maximum input size efficiently within a reasonable time frame. # Scenario Imagine you are preparing a tool for a web application that helps users generate all possible combinations of a given set of items. Each item is represented by a unique integer. You want to generate all possible subsets to provide comprehensive options for the users to choose from. Implementation Tips 1. Use a backtracking approach to recursively generate subsets. 2. Consider an iterative approach that builds subsets incrementally. 3. Ensure subsets are non-decreasing and avoid duplicates. Implement the `generate_subsets` function to meet the requirements outlined.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of a list of distinct integers. nums.sort() # Ensure the input list is sorted subsets = [] def backtrack(start: int, path: List[int]): subsets.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() backtrack(0, []) return subsets"},{"question":"# Question You are tasked with implementing a more efficient variant of a hash table that minimizes the performance impact of frequent resizing operations. The provided `ResizableHashTable` class dynamically resizes when the load factor reaches 2/3, resulting in potential computational delays. To address this, you need to implement a `CuckooHashTable` that provides more consistent performance by organizing keys into multiple hash tables and displacing keys between them. Implement the `CuckooHashTable` class with the following methods: 1. `__init__(self)`: Initializes the tables and necessary attributes. 2. `put(self, key, value)`: Inserts or updates the key-value pair. If insertion fails, triggers rehashing. 3. `get(self, key)`: Returns the value associated with the key, or `None` if the key does not exist. 4. `del_(self, key)`: Deletes the key-value pair from the table. # Implementation Requirements * Use two hash tables to handle key-value pairs. * If a key displacement cycle exceeds a certain limit (e.g., a threshold of 10 displacements), trigger a rehash. * Define two distinct hash functions for the two tables. * Rehashing should resize the tables when necessary, redistributing all key-value pairs. Input and Output Formats * **Input** for `put(self, key, value)`: - `key`: An integer representing the key. - `value`: The value associated with the key. * **Output** for `put(self, key, value)`: - None * **Input** for `get(self, key)`: - `key`: An integer representing the key. * **Output** for `get(self, key)`: - The value associated with the key, or `None` if the key doesn\'t exist. * **Input** for `del_(self, key)`: - `key`: An integer representing the key. * **Output** for `del_(self, key)`: - None # Constraints * Assume keys are always non-negative integers. * Ensure your implementation handles edge cases such as inserting duplicate keys and deleting non-existent keys. # Example Usage ```python cuckoo = CuckooHashTable() cuckoo.put(10, \'value1\') assert cuckoo.get(10) == \'value1\' cuckoo.put(20, \'value2\') assert cuckoo.get(20) == \'value2\' cuckoo.put(10, \'value10\') assert cuckoo.get(10) == \'value10\' cuckoo.del_(10) assert cuckoo.get(10) == None ```","solution":"class CuckooHashTable: def __init__(self, size=11): self.size = size self.table1 = [None] * self.size self.table2 = [None] * self.size self.threshold = 10 def hash1(self, key): return key % self.size def hash2(self, key): return (key // self.size) % self.size def put(self, key, value): loop_count = 0 max_loops = self.threshold current_key = key current_val = value while loop_count < max_loops: pos1 = self.hash1(current_key) if self.table1[pos1] is None: self.table1[pos1] = (current_key, current_val) return else: (current_key, current_val), self.table1[pos1] = self.table1[pos1], (current_key, current_val) pos2 = self.hash2(current_key) if self.table2[pos2] is None: self.table2[pos2] = (current_key, current_val) return else: (current_key, current_val), self.table2[pos2] = self.table2[pos2], (current_key, current_val) loop_count += 1 self.rehash() self.put(key, value) def get(self, key): pos1 = self.hash1(key) if self.table1[pos1] is not None and self.table1[pos1][0] == key: return self.table1[pos1][1] pos2 = self.hash2(key) if self.table2[pos2] is not None and self.table2[pos2][0] == key: return self.table2[pos2][1] return None def del_(self, key): pos1 = self.hash1(key) if self.table1[pos1] is not None and self.table1[pos1][0] == key: self.table1[pos1] = None return pos2 = self.hash2(key) if self.table2[pos2] is not None and self.table2[pos2][0] == key: self.table2[pos2] = None def rehash(self): old_table1 = self.table1 old_table2 = self.table2 self.size = 2 * self.size self.table1 = [None] * self.size self.table2 = [None] * self.size for pair in old_table1 + old_table2: if pair is not None: self.put(pair[0], pair[1])"},{"question":"# Pattern Matching with Bijection Given a pattern and a string, your task is to implement a function `pattern_match(pattern, string)` to determine if the string follows the same pattern. Following means that there is a one-to-one correspondence between the letters in the pattern and non-empty substrings in the string. Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: ``` Input * `pattern`: A string representing the pattern, consisting of only lowercase letters (1 <= len(pattern) <= 50). * `string`: A string that needs to be checked against the pattern, consisting of only lowercase letters (1 <= len(string) <= 50). Output * Return `True` if the string follows the pattern. * Otherwise, return `False`. Examples 1. `pattern_match(\\"abab\\", \\"redblueredblue\\")` should return `True`. 2. `pattern_match(\\"aaaa\\", \\"asdasdasdasd\\")` should return `True`. 3. `pattern_match(\\"aabb\\", \\"xyzabcxyzabc\\")` should return `False`. Constraints * Both `pattern` and `string` only contain lowercase English letters. * The function should use a backtracking approach. * Consider edge cases like empty patterns or strings and ensure they are handled correctly. Notes * Ensure that your code handles potential performance issues. * Carefully manage the mapping between pattern characters and substrings.","solution":"def pattern_match(pattern, string): def backtrack(p_index, s_index, p_map, used): if p_index == len(pattern) and s_index == len(string): return True if p_index == len(pattern) or s_index == len(string): return False pattern_char = pattern[p_index] for end in range(s_index + 1, len(string) + 1): substr = string[s_index:end] if pattern_char not in p_map: if substr in used: continue p_map[pattern_char] = substr used.add(substr) if backtrack(p_index + 1, end, p_map, used): return True del p_map[pattern_char] used.remove(substr) elif p_map[pattern_char] == substr: if backtrack(p_index + 1, end, p_map, used): return True return False return backtrack(0, 0, {}, set())"},{"question":"# Problem: Number of Ways to Reach the Top You are helping to design a fitness application, which includes a feature allowing users to see how many different ways they can reach the top of a staircase given a specific number of steps. Each time a user can either climb 1 or 2 steps. To build this feature, implement a function that computes the number of distinct ways to reach the top of the staircase. Write a function `countWays(steps: int) -> int` that takes an integer `steps` representing the number of steps to the top and returns the number of distinct ways to climb to the top. # Input * A single integer `steps` (1 ≤ `steps` ≤ 10^5). # Output * A single integer representing the number of distinct ways to climb to the top. # Constraints * The function must run within a reasonable time for inputs up to 10^5. * The implementation should be optimized in terms of space complexity. # Examples * Example 1: * Input: `steps = 2` * Output: `2` * Explanation: There are two ways to reach the top (1 step + 1 step, 2 steps). * Example 2: * Input: `steps = 3` * Output: `3` * Explanation: There are three ways to reach the top (1 step + 1 step + 1 step, 1 step + 2 steps, 2 steps + 1 step). # Implementation Notes * Consider using a space-optimized approach that uses a constant amount of extra space. * Ensure the function handles base cases and larger inputs efficiently. # Your Task Implement the function `countWays` to solve the problem as described.","solution":"def countWays(steps: int) -> int: Returns the number of distinct ways to climb to the top of the staircase with the given number of steps. if steps == 1: return 1 if steps == 2: return 2 # Initialize the base values for the Fibonacci-like series prev2 = 1 # number of ways to climb 1 step prev1 = 2 # number of ways to climb 2 steps for i in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"**Cooley-Tukey FFT Implementation** Given an array of complex values, implement the Cooley-Tukey Fast Fourier Transform (FFT) algorithm that can compute the discrete Fourier transform (DFT) of the input efficiently. The input array\'s size will always be an integer power of 2. # Function Signature ```python def fft(x: List[complex]) -> List[complex]: pass ``` # Arguments - **x**: List[complex], an array of complex numbers representing the input signal with a size of (2^k), where (k) is a non-negative integer. # Returns - **List[complex]**: An array of complex numbers representing the discrete Fourier transform of the input signal. # Constraints 1. The length of the input list `x` will always be an integer power of 2 (e.g., 2, 4, 8, 16, ...). 2. The magnitude of complex numbers in the input list will not exceed (10^3). # Performance Requirements - Your implementation should run in (O(N log N)) time complexity where (N) is the length of the input list. # Example ```python input_signal = [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] output_signal = fft(input_signal) # Should return a list close to [8+8j, 2j, 2-2j, -2+0j] assert len(output_signal) == len(input_signal) ```","solution":"from typing import List import cmath def fft(x: List[complex]) -> List[complex]: N = len(x) if N <= 1: return x even = fft(x[0::2]) odd = fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"Problem Statement Design a data structure that supports the addition of words and the ability to search for a word in two ways: 1. A literal search where the exact word is looked for. 2. A search with a regular expression containing the wildcard character `.` where `.` can match any single letter. Requirements # Method Definitions 1. `addWord(self, word: str) -> None`: Adds a word into the data structure. 2. `search(self, word: str) -> bool`: Searches for a word in the data structure and returns `true` if the word is found, `false` otherwise. The word can contain the wildcard character `.`. # Constraints * Words consist of lowercase English letters (`a` to `z`). * The input and the total size of all words added will not exceed (10^5). * The length of each word will not exceed 100. # Examples ```python # Example Usage wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ``` # Performance Requirements * Your implementation should be efficient in terms of both time and space complexities. Aim to minimize the depth of recursion and optimize memory usage where possible. Notes 1. You do not need to handle input parsing. Assume the inputs provided to the methods are valid per the given constraints. 2. Focus on optimizing the search function, particularly handling the wildcard character efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, 0, self.root) def _search_in_node(self, word, index, node): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_in_node(word, index+1, child): return True else: if char in node.children: return self._search_in_node(word, index+1, node.children[char]) return False"},{"question":"# Scenario You are tasked with enhancing the functionality of a Red-Black tree implementation. Specifically, you want to add a method to compute the \\"Black-Height\\" of the tree, which is defined as the number of black nodes from the root to any nil node (including the root but excluding the nil node). # Task Implement a function `black_height` in the `RBTree` class that computes the Black-Height of the tree. This function should return an integer representing the black-height. # Function Details * `def black_height(self) -> int:` # Input * The function takes no input parameters and operates on the instance of the Red-Black tree. # Output * Return an integer representing the Black-Height of the Red-Black tree. # Constraints * Consider that the tree can be empty initially. * The tree may undergo insertions and deletions, and the black-height should be recalculated accurately as per the latest state of the tree. # Example ```python # Assuming the existing RBTree class implementation rb_tree = RBTree() nodes = [11, 2, 14, 1, 7, 15, 5, 8, 4] for value in nodes: rb_tree.insert(RBNode(value, 1)) print(rb_tree.black_height()) # Output should be the black-height of the current tree ``` # Notes * Perform necessary checks where required, such as checking if the tree is empty. * Ensure the implementation adheres to Red-Black tree properties.","solution":"class RBNode: def __init__(self, data, color, left=None, right=None, parent=None): self.data = data self.color = color # 1 for Red, 0 for Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def insert(self, key): # Detailed implementation of Red-Black Tree insert pass # Assume this method is implemented correctly def _black_height(self, node): if node == self.TNULL: return 1 left_black_height = self._black_height(node.left) right_black_height = self._black_height(node.right) if node.color == 0: # Node is black return max(left_black_height, right_black_height) + 1 else: return max(left_black_height, right_black_height) def black_height(self) -> int: if self.root == self.TNULL: return 0 return self._black_height(self.root)"},{"question":"# Primality Test and Sum of Primes Context In various applications ranging from cryptography to numerical analysis, efficient primality testing is essential. Given the importance of prime numbers, the ability to not only identify primes but also to work with their sums within a range has practical significance. Problem Statement You are tasked with implementing a function that identifies prime numbers and computes the sum of all primes within a given range [a, b] (inclusive). Requirements Implement the `sum_of_primes(a, b)` function which: 1. Accepts two integer parameters `a` and `b` (1 ≤ a ≤ b ≤ 10^6). 2. Computes and returns the sum of all prime numbers in the range from `a` to `b` inclusive. Input and Output Formats * **Input**: Two integers `a` and `b`. * **Output**: An integer representing the sum of prime numbers in the given range. Constraints * Ensure the function handles cases efficiently even for large ranges up to 10^6. * Optimize the prime-checking mechanism to avoid timeouts for upper limit inputs. Example ```python print(sum_of_primes(10, 20)) # Output: 60 (primes are 11, 13, 17, 19) print(sum_of_primes(1, 10)) # Output: 17 (primes are 2, 3, 5, 7) ``` Note: - Efficiency considerations should be made to ensure the solution performs well within the provided constraints.","solution":"def sum_of_primes(a, b): def sieve(n): Generate a list of primes up to n using the Sieve of Eratosthenes is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p] == True: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return is_prime # Generate prime numbers up to b is_prime = sieve(b) # Compute the sum of prime numbers in the range [a, b] prime_sum = 0 for num in range(max(2, a), b + 1): if is_prime[num]: prime_sum += num return prime_sum"},{"question":"**Extended GCD Function Implementation and Application** **Context**: In cryptography, particularly in RSA algorithm, it is often required to compute Bézout\'s coefficients as part of the key generation and decryption processes. Bézout\'s coefficients are the integers ( s ) and ( t ) for two given integers ( num1 ) and ( num2 ) such that: [ num1 cdot s + num2 cdot t = text{GCD}(num1, num2) ] You are tasked with implementing the extended Euclidean algorithm to find these coefficients. Moreover, given the output, you will use the coefficients to solve a follow-up problem. **Instructions**: 1. Implement the function `extended_gcd` that takes two integers as input and returns a tuple of three values ( (s, t, g) ) corresponding to Bézout\'s coefficients ( s ) and ( t ), and the GCD ( g ). 2. Using the `extended_gcd` function output, implement function `solve_for_linear_combination` that takes ( num1, num2 ), and an integer ( target ), and finds integers ( s\' ) and ( t\' ) such that: [ s\' = s cdot frac{target}{g}, quad t\' = t cdot frac{target}{g} ] and returns ( (s\', t\') ), where ( s ) and ( t ) are the Bézout\'s coefficients found by `extended_gcd`. **Function Signatures**: ```python def extended_gcd(num1: int, num2: int) -> (int, int, int): # Your implementation here def solve_for_linear_combination(num1: int, num2: int, target: int) -> (int, int): # Your implementation here ``` **Input**: - `extended_gcd(num1: int, num2: int)`: - `num1, num2`: Two integers. - `solve_for_linear_combination(num1: int, num2: int, target: int)`: - `num1, num2`: Two integers. - `target`: An integer such that ( text{GCD}(num1, num2) ) divides `target`. **Output**: - `extended_gcd` returns a tuple ( (s, t, g) ). - `solve_for_linear_combination` returns a tuple ( (s\', t\') ). **Constraints**: - All integers can fit in a standard 32-bit signed integer. - Assume valid inputs are given and both integers are non-zero. - For the `solve_for_linear_combination`, assume target is always divisible by GCD(num1, num2). **Example**: ```python # extended_gcd example s, t, g = extended_gcd(56, 15) # Should output: (s, t, g) such that 56*s + 15*t = g # solve_for_linear_combination example s_prime, t_prime = solve_for_linear_combination(56, 15, 5) # Should output: (s\', t\') such that 56*s\' + 15*t\' = 5 ``` **Performance Requirements**: - Your implementation should have a time complexity of ( O(log(min(num1, num2))) ).","solution":"def extended_gcd(num1, num2): Returns the Bézout\'s coefficients and GCD of num1 and num2. if num1 == 0: return (0, 1, num2) else: s, t, g = extended_gcd(num2 % num1, num1) return (t - (num2 // num1) * s, s, g) def solve_for_linear_combination(num1, num2, target): Solves for the coefficients s\' and t\' such that: num1 * s\' + num2 * t\' = target s, t, g = extended_gcd(num1, num2) factor = target // g return (s * factor, t * factor)"},{"question":"# Problem Description You are given a series of operations that manipulate specific bits within a given integer. Your task is to implement a function that will process a list of these operations and return the final modified integer. # Function Signature ```python def bit_manipulation(start_num: int, operations: List[Tuple[str, int, Optional[int]]]) -> int: Given a starting number and a list of operations, perform the operations in order and return the final modified number. :param start_num: An initial integer :param operations: A list of tuples representing operations. Each tuple consists of: - operation name (either \'get\', \'set\', \'clear\', \'update\') - the bit index - the optional new bit value (0 or 1) for the \'update\' operation :return: The final modified integer after all operations pass ``` # Input * `start_num` (int): The initial integer value. * `operations` (List[Tuple[str, int, Optional[int]]]): A list of operations, where each operation is a tuple: * The operation name (`\'get\'`, `\'set\'`, `\'clear\'`, or `\'update\'`). * The bit index (int) to manipulate. * The new bit value (0 or 1) for the `\'update\'` operation. This is `None` for other operations. # Output * Returns the final integer after performing all operations. # Example ```python start_num = 0b0101 # 5 in decimal operations = [ (\'set\', 1), # Set bit at index 1: Result -> 0b0111 (7 in decimal) (\'clear\', 2), # Clear bit at index 2: Result -> 0b0011 (3 in decimal) (\'update\', 0, 1) # Update bit at index 0 to 1: Result -> 0b0011 (3 in decimal) ] result = bit_manipulation(5, operations) print(bin(result)) # Output should be 0b0011 ``` # Constraints * 0 ≤ bit index < 32 * Each operation must be executed in the order provided. * The starting number and resultant number are guaranteed to be within the range of 32-bit signed integers. * You should implement the core bit manipulation functions (`get_bit`, `set_bit`, `clear_bit`, `update_bit`) as provided in the problem prompt.","solution":"from typing import List, Tuple, Optional def get_bit(num: int, bit_index: int) -> int: Get the value of the bit at the specified index. return (num >> bit_index) & 1 def set_bit(num: int, bit_index: int) -> int: Set the bit at the specified index to 1. return num | (1 << bit_index) def clear_bit(num: int, bit_index: int) -> int: Clear the bit at the specified index to 0. return num & ~(1 << bit_index) def update_bit(num: int, bit_index: int, new_value: int) -> int: Update the bit at the specified index to new_value (0 or 1). mask = ~(1 << bit_index) return (num & mask) | (new_value << bit_index) def bit_manipulation(start_num: int, operations: List[Tuple[str, int, Optional[int]]]) -> int: Given a starting number and a list of operations, perform the operations in order and return the final modified number. num = start_num for operation in operations: op_name = operation[0] bit_index = operation[1] if op_name == \'get\': get_bit(num, bit_index) elif op_name == \'set\': num = set_bit(num, bit_index) elif op_name == \'clear\': num = clear_bit(num, bit_index) elif op_name == \'update\': new_value = operation[2] num = update_bit(num, bit_index, new_value) return num"},{"question":"# Question: Reverse a Subsection of a Singly Linked List You are given a singly linked list and two integers `m` and `n`, such that 1 ≤ m ≤ n ≤ length of the list. Write a function `reverse_subsection(head, m, n)` that reverses the nodes from position `m` to `n` in place and returns the modified list. Function Signature ```python def reverse_subsection(head: ListNode, m: int, n: int) -> ListNode: # Your code here ``` # Input - `head`: The head node of the singly linked list. - `m` (int): Starting position (1-based index) for reversal. - `n` (int): Ending position (1-based index) for reversal. # Output - Returns the head of the modified list after reversing the nodes from `m` to `n`. # Constraints - The number of nodes in the list will be at most 500. - -10^4 ≤ Node.val ≤ 10^4. # Example ```plaintext Input: 1 -> 2 -> 3 -> 4 -> 5, m = 2, n = 4 Output: 1 -> 4 -> 3 -> 2 -> 5 ``` # Explanation - The sublist from position 2 to position 4 (2 -> 3 -> 4) is reversed to 4 -> 3 -> 2. The resulting list is 1 -> 4 -> 3 -> 2 -> 5. # Additional Notes Ensure that your function is efficient in both space and time, and handles edge cases such as: - The list being empty. - `m` and `n` covering the full length of the list. - `m` and `n` being equal (no reversal needed).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_subsection(head: ListNode, m: int, n: int) -> ListNode: if not head or m == n: return head # Dummy node to simplify the edge cases dummy = ListNode(0) dummy.next = head prev = dummy # Move `prev` to the node immediately before the section to be reversed for _ in range(m - 1): prev = prev.next # Start reversal reverse_start = prev.next curr = reverse_start.next # Reverse the sublist from position m to n for _ in range(n - m): reverse_start.next = curr.next curr.next = prev.next prev.next = curr curr = reverse_start.next return dummy.next"},{"question":"Context: You are tasked with implementing a utility function for a geometry software that can calculate the missing side length in a right-angled triangle when the lengths of the other two sides are known. Task: Implement a function `find_missing_side(opposite, adjacent, hypotenuse)` that takes in three parameters representing the lengths of the sides of a right-angled triangle. One of these parameters will be assigned the value `\'?\'` indicating that it is the unknown side. Your function should calculate and return the length of this unknown side. Input: - `opposite`: Length of the opposite side (number or `\'?\'`) - `adjacent`: Length of the adjacent side (number or `\'?\'`) - `hypotenuse`: Length of the hypotenuse (number or `\'?\'`) Output: - If the unknown side is the opposite side, the function should return: `\\"Opposite = <value>\\"`. - If the unknown side is the adjacent side, the function should return: `\\"Adjacent = <value>\\"`. - If the unknown side is the hypotenuse, the function should return: `\\"Hypotenuse = <value>\\"`. - If all sides are known, return: `\\"All sides are known!\\"`. Constraints: - Ensure all input values (excluding `\'?\'`) are positive numbers. - The length of the hypotenuse must always be the largest value. - Raise an error with a descriptive message if the input does not follow these constraints or does not form a valid triangle. Example: ```python def find_missing_side(opposite, adjacent, hypotenuse): # Your implementation here # Example 1 print(find_missing_side(\'?\', 3, 5)) # Opposite = 4.0 # Example 2 print(find_missing_side(3, \'?\', 5)) # Adjacent = 4.0 # Example 3 print(find_missing_side(3, 4, \'?\')) # Hypotenuse = 5.0 # Example 4 print(find_missing_side(3, 4, 5)) # All sides are known! ```","solution":"import math def find_missing_side(opposite, adjacent, hypotenuse): if opposite == \'?\' and adjacent != \'?\' and hypotenuse != \'?\': opposite = math.sqrt(hypotenuse ** 2 - adjacent ** 2) return f\\"Opposite = {opposite}\\" elif adjacent == \'?\' and opposite != \'?\' and hypotenuse != \'?\': adjacent = math.sqrt(hypotenuse ** 2 - opposite ** 2) return f\\"Adjacent = {adjacent}\\" elif hypotenuse == \'?\' and opposite != \'?\' and adjacent != \'?\': hypotenuse = math.sqrt(opposite ** 2 + adjacent ** 2) return f\\"Hypotenuse = {hypotenuse}\\" elif opposite != \'?\' and adjacent != \'?\' and hypotenuse != \'?\': return \\"All sides are known!\\" else: raise ValueError(\\"Invalid input. Ensure all given sides are positive numbers and one side is given as \'?\'.\\")"},{"question":"**Problem Statement:** Implement a modified version of the Quicksort algorithm that keeps track of the number of swaps performed while sorting an array. This will help in understanding how the partition function influences the number of swaps, which can be crucial in performance analysis. # Function Signature ```python def quick_sort_count_swaps(arr: list, simulation: bool = False) -> tuple: Sort the array using quick sort and return the sorted array along with the number of swaps performed. Args: arr (list): A list of integers to be sorted. simulation (bool): If True, print the array at each step. Returns: tuple: A tuple containing the sorted array and the number of swaps performed. ``` # Input * A list of integers (e.g., `[3, 6, 8, 10, 1, 2, 1]`), where 0 <= length of array <= 10^5. * An optional boolean parameter `simulation`, which if set to `True`, prints the array at each step of the sorting process. # Output * A tuple containing: * The sorted list of integers. * An integer count representing the number of swaps performed during the sorting process. # Example ```python arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr, swap_count = quick_sort_count_swaps(arr) print(sorted_arr) # Output should be [1, 1, 2, 3, 6, 8, 10] print(swap_count) # Output the number of swaps performed ``` # Constraints * The function should handle arrays with up to 10^5 elements efficiently. * The function should utilize the Quicksort approach and ensure counting the swaps appropriately during partitioning. * Ensure that edge cases such as an empty array or arrays with duplicate values are handled properly. * The number of recursive calls should be optimized to prevent stack overflow for very large arrays.","solution":"def quick_sort_count_swaps(arr, simulation=False): Sort the array using quick sort and return the sorted array along with the number of swaps performed. Args: arr (list): A list of integers to be sorted. simulation (bool): If True, print the array at each step. Returns: tuple: A tuple containing the sorted array and the number of swaps performed. swap_count = [0] # Using list to maintain reference consistency in nested function def partition(low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] swap_count[0] += 1 if simulation: print(arr) arr[i + 1], arr[high] = arr[high], arr[i + 1] swap_count[0] += 1 if simulation: print(arr) return i + 1 def quicksort(low, high): if low < high: pi = partition(low, high) quicksort(low, pi - 1) quicksort(pi + 1, high) quicksort(0, len(arr) - 1) return arr, swap_count[0]"},{"question":"# Queue Implementation and Analysis Context You have been given the task to implement a `Queue` data structure using two different internal mechanisms: a dynamic array and a linked list. Each implementation should adhere to the queue ADT as described below. After implementing the queue, you will additionally need to write a function that simulates a typical use case of a queue, demonstrating its usage and performance considerations. Task Your task is to implement the following: 1. **ArrayQueue**: - Initialize with an optional capacity parameter. - Implement the `enqueue`, `dequeue`, `peek`, `is_empty`, and `__len__` methods. 2. **LinkedListQueue**: - Implement the `enqueue`, `dequeue`, `peek`, `is_empty`, and `__len__` methods. 3. **Simulation Function**: - Write a function `simulate_queue_operations(queue_type, operations)` that accepts: - `queue_type`: A string, either `\\"array\\"` or `\\"linkedlist\\"`, denoting the type of queue to use. - `operations`: A list of operations to perform on the queue, where each operation is a tuple of the form `(\\"enqueue\\", value)` or `(\\"dequeue\\",)`. - The function should: - Initialize the appropriate queue. - Perform the operations in sequence. - Collect and return the results of each `dequeue` operation. Constraints - Enqueue and dequeue operations should handle edge cases appropriately such as queue full and queue empty scenarios. - Ensure optimal performance for typical usage scenarios. Example ```python # Initialize operations to simulate operations = [ (\\"enqueue\\", 10), (\\"enqueue\\", 20), (\\"dequeue\\",), (\\"enqueue\\", 30), (\\"peek\\",), # Should return 20 (\\"dequeue\\",), (\\"enqueue\\", 40) ] # Simulate operations on ArrayQueue print(simulate_queue_operations(\\"array\\", operations)) # Expected Output: [10, 20] # Simulate operations on LinkedListQueue print(simulate_queue_operations(\\"linkedlist\\", operations)) # Expected Output: [10, 20] ```","solution":"class ArrayQueue: def __init__(self, capacity=10): self.queue = [None] * capacity self.front = 0 self.rear = 0 self.size = 0 self.capacity = capacity def enqueue(self, value): if self.size == self.capacity: raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = value self.rear = (self.rear + 1) % self.capacity self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[self.front] def is_empty(self): return self.size == 0 def __len__(self): return self.size class Node: def __init__(self, value): self.value = value self.next = None class LinkedListQueue: def __init__(self): self.head = None self.tail = None self.size = 0 def enqueue(self, value): new_node = Node(value) if self.tail: self.tail.next = new_node self.tail = new_node if not self.head: self.head = new_node self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self.head.value self.head = self.head.next if not self.head: self.tail = None self.size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.head.value def is_empty(self): return self.size == 0 def __len__(self): return self.size def simulate_queue_operations(queue_type, operations): if queue_type == \'array\': queue = ArrayQueue() elif queue_type == \'linkedlist\': queue = LinkedListQueue() else: raise ValueError(\\"Invalid queue_type. Must be \'array\' or \'linkedlist\'.\\") results = [] for op in operations: if op[0] == \'enqueue\': queue.enqueue(op[1]) elif op[0] == \'dequeue\': results.append(queue.dequeue()) elif op[0] == \'peek\': results.append(queue.peek()) else: raise ValueError(\\"Invalid operation.\\") return results"},{"question":"# Tree Dictionary Printing Challenge Context You are designing an application to visualize hierarchical data stored in a dictionary. Each key in the dictionary represents a node in the tree, and its associated value is a list containing nested elements. Your task is to implement a function to correctly print the dictionary in a structured tree format. Problem Statement Write a function `tree_print(tree)` that takes a dictionary `tree` where: * Each key-value pair in the dictionary represents a node. * Keys are strings representing parent nodes. * Values are lists containing both strings (child nodes) and numbers (node values). Your function should print each node and its related children in a formatted tree structure: * Each key should be followed by an arrow `->` pointing to its elements. * Each subsequent element should be printed on a new line if it is not a string. # Function Signature ```python def tree_print(tree: dict) -> None: pass ``` # Expected Output * For the given `tree` dictionary: ```python tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6], \'b\': [\'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` The function should print the output as: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 b -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Additional Constraints * All keys and elements inside the list will be either strings or numbers. * You cannot use any external libraries for this task. Pure Python solutions only.","solution":"def tree_print(tree: dict) -> None: Function to print tree structure from a dictionary. Each key-value pair in the dictionary represents a node. Keys are strings representing parent nodes, and values are lists containing both strings (child nodes) and numbers (node values). The function prints each node and its related children in a formatted tree structure. for key, values in tree.items(): print(key, end=\\" -> \\") print(\\" -> \\".join(map(str, values)))"},{"question":"You are given two positive integers `n` and `k` (where `n` >= `k`). Your task is to write a function `calculate_binomial_coefficient(n, k)` that computes the binomial coefficient, C(n,k), using an iterative approach rather than recursion to avoid potential stack overflow issues for large inputs. Recall that the binomial coefficient C(n, k) is defined as the number of ways to choose `k` items from `n` items without regard to the order. # Input: * Two integers `n` and `k` such that `n >= k`. # Output: * A single integer representing the binomial coefficient C(n, k). # Constraints: * 0 <= `k` <= `n` <= 1000 # Example: ```python calculate_binomial_coefficient(5, 2) -> 10 calculate_binomial_coefficient(8, 2) -> 28 calculate_binomial_coefficient(10, 4) -> 210 ``` # Notes: * The solution should handle large values efficiently and avoid recursion. * Consider using an iterative approach or dynamic programming to optimize performance. * Be mindful of edge cases such as `k` being 0 or equal to `n`.","solution":"def calculate_binomial_coefficient(n, k): Returns the binomial coefficient C(n, k). if k > n: return 0 if k == 0 or k == n: return 1 # Optimization: C(n, k) is the same as C(n, n-k) k = min(k, n - k) result = 1 for i in range(k): result *= (n - i) result //= (i + 1) return result"},{"question":"# Context You are given a list of integers that may contain both negative and positive numbers. Your task is to sort the list in ascending order using the Exchange Sort algorithm. This is to test your understanding of basic sorting algorithms and their implementations. # Challenge Implement the `exchange_sort` function as described below. Follow the definition and ensure to handle edge cases properly. # Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: List of integers (`List[int]`) where -1000 <= `arr[i]` <= 1000. * The length of `arr` (n) is such that 0 <= n <= 1000. # Output * Returns a new sorted list (`List[int]`) with the elements of the input list arranged in ascending order. # Constraints * Your implementation must use in-place sorting and should have a time complexity of O(n^2). # Examples ```python assert exchange_sort([3, 1, 4, 1, 5]) == [1, 1, 3, 4, 5] assert exchange_sort([-2, -1, 0, 2, 1]) == [-2, -1, 0, 1, 2] assert exchange_sort([5]) == [5] assert exchange_sort([]) == [] assert exchange_sort([2, 2, 2]) == [2, 2, 2] ``` # Notes * Ensure your function returns a new sorted list and does not modify the input list. * Handle edge cases such as an empty list or a list with one element properly.","solution":"from typing import List def exchange_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the Exchange Sort algorithm. # Create a copy of the list to avoid modifying the original list sorted_arr = arr[:] # Length of the array n = len(sorted_arr) # Exchange Sort implementation for i in range(n): for j in range(i + 1, n): if sorted_arr[i] > sorted_arr[j]: # Swap elements sorted_arr[i], sorted_arr[j] = sorted_arr[j], sorted_arr[i] return sorted_arr"},{"question":"# Task Implement a function `exchange_sort(arr)` to sort an array of integers using the Exchange Sort algorithm. Ensure that your implementation is correct and handles different edge cases efficiently. # Input - An array `arr` of `n` integers where ( 1 leq n leq 10^4 ) and (-10^4 leq arr[i] leq 10^4 ). # Output - Return the sorted array in ascending order. # Constraints - The sorting should be done in-place. - The time complexity should not be a concern for this task; focus on correctness. - Ensure your implementation can handle edge cases like empty arrays or arrays with all identical elements. # Example ```python assert exchange_sort([4, 2, 6, 5, 1, 3]) == [1, 2, 3, 4, 5, 6] assert exchange_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert exchange_sort([9, -3, 5, 0, 2, 7, 6, -2]) == [-3, -2, 0, 2, 5, 6, 7, 9] assert exchange_sort([]) == [] assert exchange_sort([5, 5, 5, 5]) == [5, 5, 5, 5] ``` Ensure your solution is tested against various cases including edge cases like empty arrays and arrays with repeating numbers.","solution":"def exchange_sort(arr): Sort an array of integers using the Exchange Sort algorithm. Parameters: arr (list): A list of integers to be sorted. Returns: list: The sorted list in ascending order. n = len(arr) for i in range(n-1): for j in range(i+1, n): if arr[i] > arr[j]: # Swap arr[i] and arr[j] arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Path Finding Challenge in Graphs **Context**: You have been hired as a software engineer to develop a route optimization tool for a delivery service. The city map is represented as a graph where intersections are nodes and streets are edges between nodes. You are required to implement functions to help the delivery service find optimal paths. **Question**: Implement three functions in Python that help in pathfinding in graphs based on given requirements. Function 1: Path Existence Implement a function to check if there\'s a path between two intersections. ```python def exists_path(graph, start, end): Check if there exists a path between start and end nodes. Args: graph (dict): A dictionary representing the graph where keys are nodes, and values are lists of neighboring nodes. start: The starting node. end: The ending node. Returns: bool: True if there exists a path, False if not. pass ``` Function 2: Shortest Path Implement a function to find the shortest path between two intersections. ```python def shortest_path(graph, start, end): Computes the shortest path between start and end nodes. Args: graph (dict): A dictionary representing the graph. start: The starting node. end: The ending node. Returns: list: Shortest path as a list of nodes. pass ``` Function 3: All Paths Implement a function to find all paths between two intersections. ```python def all_paths(graph, start, end): Finds all paths between start and end nodes. Args: graph (dict): A dictionary representing the graph. start: The starting node. end: The ending node. Returns: list of lists: List containing all paths as lists of nodes. pass ``` # Constraints: 1. The graph is represented as an adjacency list using a dictionary. 2. Nodes are represented by unique identifiers (e.g., integers or strings). 3. The city map (graph) does not have negative weights. 4. The implementation must handle cases where no path exists gracefully. **Performance Requirements**: - Ensure your solutions are efficient and correctly handle large graphs to avoid significant performance issues or memory constraints. # Scenario: Use the provided graph structure to determine the paths for the following delivery routes: ```python city_map = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\', \'E\'], \'D\': [\'F\'], \'E\': [\'F\'], \'F\': [] } # Expected outputs: # exists_path(city_map, \'A\', \'F\') -> True # shortest_path(city_map, \'A\', \'F\') -> [\'A\', \'B\', \'D\', \'F\'] or other equivalent shortest path # all_paths(city_map, \'A\', \'F\') -> List of all possible paths from A to F ``` Implement and test these functions to enhance the delivery route optimization tool.","solution":"from collections import deque def exists_path(graph, start, end): Check if there exists a path between start and end nodes. Args: graph (dict): A dictionary representing the graph where keys are nodes, and values are lists of neighboring nodes. start: The starting node. end: The ending node. Returns: bool: True if there exists a path, False if not. if start == end: return True visited = set() queue = deque([start]) while queue: current = queue.popleft() if current == end: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False def shortest_path(graph, start, end): Computes the shortest path between start and end nodes. Args: graph (dict): A dictionary representing the graph. start: The starting node. end: The ending node. Returns: list: Shortest path as a list of nodes. if start == end: return [start] visited = set() queue = deque([(start, [start])]) while queue: current, path = queue.popleft() if current == end: return path if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] def all_paths(graph, start, end): Finds all paths between start and end nodes. Args: graph (dict): A dictionary representing the graph. start: The starting node. end: The ending node. Returns: list of lists: List containing all paths as lists of nodes. def dfs(current, path): if current == end: paths.append(path) return for neighbor in graph[current]: dfs(neighbor, path + [neighbor]) paths = [] dfs(start, [start]) return paths"},{"question":"# Binary Search Efficiency Improvement Scenario The binary search algorithm is an efficient method for finding an element in a sorted array. However, real-world applications often come with additional requirements, such as finding multiple positions in the case of duplicate values or ensuring robustness under various edge cases. Task Write a Python function `efficient_binary_search` that incorporates the basic binary search algorithm with additional enhancements: 1. **Find All Occurrences**: Modify the algorithm to find all positions (indices) of a given value in a sorted array, not just any one occurrence. 2. **Edge Case Handling**: Ensure the function robustly handles empty arrays and returns an appropriate response when the value is not found. 3. **Efficiency**: Maintain the original O(log(n)) complexity wherever possible. Function Definition ```python def efficient_binary_search(array, query): This function implements an enhanced binary search to find all occurrences of \'query\' in the sorted list \'array\'. :param array: List[int] - A sorted list of integers. :param query: int - The target value to search for. :return: List[int] - A list of indices where \'query\' is found in \'array\'. Returns an empty list if \'query\' is not found. # Your code here ``` Example ```python efficient_binary_search([1, 2, 2, 2, 3, 4, 5], 2) # Output: [1, 2, 3] efficient_binary_search([1, 3, 4, 5], 2) # Output: [] efficient_binary_search([], 2) # Output: [] ``` Constraints - Your solution should efficiently handle large arrays up to 10^6 elements. - Assume array is sorted in non-decreasing order. - The target value `query` is a valid integer. Notes: - Focus on maintaining the time complexity of O(log(n)) for the search operation. - Comment your code to explain the approach and individual steps.","solution":"def efficient_binary_search(array, query): This function implements an enhanced binary search to find all occurrences of \'query\' in the sorted list \'array\'. :param array: List[int] - A sorted list of integers. :param query: int - The target value to search for. :return: List[int] - A list of indices where \'query\' is found in \'array\'. Returns an empty list if \'query\' is not found. def binary_search_left(array, query): left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < query: left = mid + 1 else: right = mid return left def binary_search_right(array, query): left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] <= query: left = mid + 1 else: right = mid return left left_index = binary_search_left(array, query) right_index = binary_search_right(array, query) if left_index >= len(array) or array[left_index] != query: return [] return list(range(left_index, right_index))"},{"question":"# Fast Fourier Transform Algorithm You are given an array of complex numbers representing a discrete signal in the time domain. Your task is to compute the discrete Fourier transform (DFT) of this signal using the Cooley-Tukey Fast Fourier Transform (FFT) algorithm. Implement a function `fft(x)` that performs this transformation efficiently. Your implementation should use the divide and conquer approach as demonstrated by the Cooley-Tukey algorithm. Function Signature ```python def fft(x: List[complex]) -> List[complex]: pass ``` Input * `x`: List of complex numbers where the length of `x` is a power of 2 and 1 <= len(x) <= 1024. Output * Returns a list of complex numbers which is the discrete Fourier transform of the input. Example ```python # Example 1 input: [2.0+2j, 1.0+3j, 3.0+1j, 2.0+2j] output: [8+8j, 2j, 2-2j, -2+0j] # Example 2 input: [1.0, 0.0, 0.0, 0.0] output: [1+0j, 1+0j, 1+0j, 1+0j] ``` Constraints * The length of x is guaranteed to be a power of 2. * The inputs will be valid complex numbers. Guidelines 1. **Performance**: Ensure your implementation has a time complexity of O(N log N). 2. **Edge Cases**: Consider handling edge cases where the length of the array is small (e.g., 1 or 2). 3. **Precision**: Be mindful of precision issues that may arise from complex arithmetic.","solution":"from typing import List import cmath def fft(x: List[complex]) -> List[complex]: Performs the Fast Fourier Transform (FFT) using the Cooley-Tukey algorithm. N = len(x) if N <= 1: return x even = fft(x[0::2]) odd = fft(x[1::2]) T = [cmath.exp(-2j * cmath.pi * k / N) * odd[k] for k in range(N // 2)] return [even[k] + T[k] for k in range(N // 2)] + [even[k] - T[k] for k in range(N // 2)]"},{"question":"Given a list of distinct integers, write a function `permute(elements: List[int]) -> List[List[int]]` that returns all possible permutations of the elements in the list. The function should generate these permutations using a recursive approach without any imports. Input * A list of distinct integers `elements` (1 <= len(elements) <= 8, -10 <= elements[i] <= 10). Output * A list of lists, where each sublist is a unique permutation of the original list. Constraints * Do not use any external libraries like itertools. * The function must handle the edge cases, such as empty lists or lists with one element. # Function Signature ```python def permute(elements: List[int]) -> List[List[int]]: pass ``` # Example ```python # Example 1 print(permute([1, 2, 3])) # Output: # [ # [1, 2, 3], # [1, 3, 2], # [2, 1, 3], # [2, 3, 1], # [3, 1, 2], # [3, 2, 1] # ] # Example 2 print(permute([0, 1])) # Output: # [ # [0, 1], # [1, 0] # ] # Example 3 print(permute([1])) # Output: # [ # [1] # ] # Example 4 print(permute([])) # Output: # [ # [] # ] ``` # Constraints and Requirements * Your implementation should efficiently handle the factorial growth of permutations. * Ensure that your function is readable and maintainable. * Handle recursive depth properly to avoid stack overflow. * The time complexity should be O(n * n!) and space complexity should be O(n!).","solution":"from typing import List def permute(elements: List[int]) -> List[List[int]]: def _permute(subset: List[int], remaining: List[int], results: List[List[int]]): if not remaining: results.append(subset) else: for i in range(len(remaining)): _permute(subset + [remaining[i]], remaining[:i] + remaining[i+1:], results) results = [] _permute([], elements, results) return results"},{"question":"Context You\'ve been provided three arrays of integers and a target sum. Your task is to find all valid combinations of three integers, one from each array, such that their sum equals the target. This will test your understanding of backtracking and optimization techniques for combinatorial problems. Problem Statement You are given three arrays of integers `A`, `B`, and `C`, along with an integer `target`. Write a function `find_combinations` that finds all combinations of three integers (one from each array) that sum up to the target value. # Function Signature ```python def find_combinations(A: list, B: list, C: list, target: int) -> list: ``` # Input * `A`, `B`, `C` (lists of integers): The input arrays, each containing integers. You can assume the arrays have at least one element. * `target` (integer): The target sum value. # Output * A list of lists, where each inner list contains a unique combination of three integers that sum up to the target. # Constraints * Each array may contain duplicate integers. * The order of elements in the output does not matter. * Combination elements must be chosen such that one element comes from each of A, B, and C. * Optimize for efficiency with large input sizes. # Example ```python # Example 1 A = [1, 2, 3, 3] B = [2, 3, 3, 4] C = [2, 3, 3, 4] target = 7 print(find_combinations(A, B, C, target)) # Expected output: [[1, 2, 4], [1, 3, 3], [2, 2, 3], [1, 4, 2], [3, 2, 2]] ``` # Constraints * Time Complexity should ideally be better than O(N^3) for large array lengths. * Space Complexity should account for the recursive depth and resultant combinations. Notes - You should avoid generating duplicate combinations in your result output. - Consider edge cases such as empty arrays or arrays with all elements not contributing to the target sum. - Thoroughly test your implementation for correctness and efficiency.","solution":"def find_combinations(A, B, C, target): Finds all combinations of integers from arrays A, B, and C such that the sum equals the target. result = [] seen = set() for a in A: for b in B: for c in C: if a + b + c == target: triplet = tuple(sorted((a, b, c))) if triplet not in seen: seen.add(triplet) result.append(list(triplet)) return result"},{"question":"# Scenario You are a software engineer responsible for implementing data structure enhancement modules in a larger application. One of the key tasks is to manipulate complex linked lists containing nodes with both `next` and `random` pointers. Ensuring deep copy functionalities are implemented correctly is critical for the project\'s data isolation requirements. # Task Write a function `copy_linked_list_with_random_pointers` that, given a linked list where each node contains an additional `random` pointer pointing to any node in the list (or null), returns a deep copy of the list. # Function Signature ```python class RandomListNode: def __init__(self, label: int, next: \'RandomListNode\' = None, random: \'RandomListNode\' = None): self.label = label self.next = next self.random = random def copy_linked_list_with_random_pointers(head: RandomListNode) -> RandomListNode: # Implement your code here ``` # Input - `head`: A `RandomListNode` representing the head of the linked list. # Output - Must return a `RandomListNode` representing the head of the deep copied linked list. # Constraints - The number of nodes in the list will not exceed (10^4). - Each node\'s `labels` are positive integers and guaranteed to be unique. # Example 1 Input - `head`: A linked list with nodes having labels 1 -> 2 -> 3, where the `random` pointers form the following relationships: - Node with label 1\'s `random` pointer points to the node with label 3. - Node with label 2\'s `random` pointer points to the node with label 1. - Node with label 3\'s `random` pointer points to the node with label 2. Output The returned deep copied linked list must have the exact same structure as the input list: - Labels: 1 -> 2 -> 3 - `random` pointers: - Node with label 1\'s `random` pointer points to the node with label 3. - Node with label 2\'s `random` pointer points to the node with label 1. - Node with label 3\'s `random` pointer points to the node with label 2. # Example 2 Input - `head`: A linked list with a single node having a label 1, where the `random` pointer points to itself. Output The returned deep copied linked list must replicate the single node with: - Label: 1 - `random` pointer points to itself. # Performance Requirements - Optimal solutions should aim for O(n) time complexity and O(n) space complexity.","solution":"class RandomListNode: def __init__(self, label: int, next: \'RandomListNode\' = None, random: \'RandomListNode\' = None): self.label = label self.next = next self.random = random def copy_linked_list_with_random_pointers(head: RandomListNode) -> RandomListNode: if not head: return None # Step 1: Create the new nodes and insert them next to the original nodes current = head while current: new_node = RandomListNode(current.label) new_node.next = current.next current.next = new_node current = new_node.next # Step 2: Assign random pointers to the new nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the new nodes to form the duplicate list current = head new_head = head.next while current: new_node = current.next current.next = new_node.next if new_node.next: new_node.next = new_node.next.next current = current.next return new_head"},{"question":"**Maximum Flow Problem with Optimized Path Search** You are given a directed graph, represented by a `n x n` adjacency matrix, where `n` is the number of vertices. The matrix entries represent capacities between the vertices. Your task is to implement a function that calculates the maximum flow from the source (vertex 0) to the sink (vertex (n-1)) using an optimized path-searching technique. Your implementation should take into consideration the inefficiencies presented by the BFS method in dense graphs. # Function Signature ```python def maximum_flow_optimized(adjacency_matrix: List[List[int]]) -> int: pass ``` # Input - A 2D list `adjacency_matrix` (size ( n times n )), where: - `0 <= adjacency_matrix[i][j] <= 10^9` - `1 <= n <= 1000` - The value at `adjacency_matrix[i][j]` represents the capacity from vertex `i` to vertex `j`. # Output - An integer representing the maximum flow from the source to the sink. # Constraints - Source: Vertex 0 - Sink: Vertex ( n-1 ) # Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_flow_optimized(graph) == 23 ```","solution":"from typing import List def maximum_flow_optimized(adjacency_matrix: List[List[int]]) -> int: from collections import deque, defaultdict import sys n = len(adjacency_matrix) source = 0 sink = n - 1 parent = [-1] * n def bfs_residual(capacity: List[List[int]], source: int, sink: int) -> bool: visited = [False] * n queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v in range(n): if not visited[v] and capacity[u][v] > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False residual_capacity = [row[:] for row in adjacency_matrix] max_flow = 0 while bfs_residual(residual_capacity, source, sink): path_flow = sys.maxsize s = sink while s != source: path_flow = min(path_flow, residual_capacity[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] residual_capacity[u][v] -= path_flow residual_capacity[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"You are tasked with creating an efficient algorithm that can both sort and simulate the process of sorting using both Max-Heap and Min-Heap structures. This assignment will test your understanding of heap-based sorting algorithms and your ability to implement them correctly. Write two functions: 1. **heap_sort_max(arr, k)**: This function should simulate and sort an array in ascending order using the Max-Heap mechanism and print the state of the array every k iterations. 2. **heap_sort_min(arr, k)**: This function should sort an array in ascending order using the Min-Heap mechanism and simulate the state of the array every k iterations. Input: - `arr`: A list of integers. - `k`: An integer representing the interval at which the state of the array should be output. Output: - Both functions should return the sorted array. - During sorting, both functions should print the state of the array at every k iterations in the format `Iteration <iteration_number>: <array>`. Constraints: - 1 <= len(arr) <= 1000 - -10^6 <= arr[i] <= 10^6 - 1 <= k <= 1000 Example: ```python >>> arr = [4, 1, 3, 9, 7] >>> k = 2 >>> print(heap_sort_max(arr, k)) Iteration 2: [9, 7, 1, 4, 3] Iteration 4: [7, 4, 1, 3, 9] [1, 3, 4, 7, 9] >>> arr = [4, 1, 3, 9, 7] >>> k = 2 >>> print(heap_sort_min(arr, k)) Iteration 2: [1, 4, 3, 9, 7] Iteration 4: [1, 3, 4, 7, 9] [1, 3, 4, 7, 9] ``` Note: - You can use the helper functions from the provided sample if needed to implement the heapify and sorting logic.","solution":"def heap_sort_max(arr, k): import heapq def max_heapify(heap): return [-x for x in heap] def print_array(interval, array): if interval % k == 0: print(f\\"Iteration {interval}: {array}\\") arr = max_heapify(arr) heapq.heapify(arr) sorted_array = [] interval = 0 while arr: sorted_array.append(-heapq.heappop(arr)) interval += 1 print_array(interval, [-x for x in arr]) return sorted_array def heap_sort_min(arr, k): import heapq def print_array(interval, array): if interval % k == 0: print(f\\"Iteration {interval}: {array}\\") heapq.heapify(arr) sorted_array = [] interval = 0 while arr: sorted_array.append(heapq.heappop(arr)) interval += 1 print_array(interval, arr) return sorted_array"},{"question":"You are given a nested array (an array which may contain other arrays) of arbitrary depth. Write a function named `flatten_array` that takes this nested array and returns a flattened array. The output array should contain all the elements from the nested array, but should be one-dimensional (i.e., contain no other arrays). Your implementation should ensure it handles nested arrays suitably and considers edge cases properly. ```python def flatten_array(nested_array): # Your code goes here pass ``` # Input * `nested_array`: A list which can contain elements of various types, including other lists. # Output * Returns a single list (flattened) containing all elements from `nested_array` in the same order they appear. # Constraints - Do not use external libraries for flattening (e.g., numpy). - Handling deeply nested arrays within acceptable recursion limits is necessary. - Assume `nested_array` is a valid list or combination of lists. # Examples ```python # Example 1 print(flatten_array([1, [2, [3, 4], 5], 6])) # Output: [1, 2, 3, 4, 5, 6] # Example 2 print(flatten_array([[], [1, [], [2, [3]]], 4])) # Output: [1, 2, 3, 4] # Example 3 print(flatten_array([[\'a\', [\'b\'], [\'c\', [\'d\', \'e\']]], \'f\'])) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] ``` # Performance Requirement - Ensure that your solution runs efficiently to handle reasonably nested structures.","solution":"def flatten_array(nested_array): Flattens a nested array into a single list containing all elements. result = [] def _flatten(sub_array): for item in sub_array: if isinstance(item, list): _flatten(item) else: result.append(item) _flatten(nested_array) return result"},{"question":"Implement an Ordered Queue You have learned about the `OrderedStack` data structure, which maintains elements in order so that the highest value is always at the top and the lowest at the bottom. Now, extend this idea to implement an Ordered Queue. Objective Implement an `OrderedQueue` class such that elements are enqueued in order (smallest to largest). The front of the queue should always contain the smallest element. Requirements 1. Implement the methods `enqueue(item)`, `dequeue()`, `peek()`, `is_empty()`, and `size()`. 2. The `enqueue` method should insert elements such that the queue remains ordered. 3. The `dequeue` method should remove and return the front element. 4. The `peek` method should return the front element without removing it. 5. The `is_empty` method should return `True` if the queue is empty and `False` otherwise. 6. The `size` method should return the number of elements in the queue. # Constraints * Assume all elements are comparable (supporting `<`, `>`, `==`, etc.). * Do not use Python\'s built-in sorted functions or data structures. * Your implementation should handle edge cases such as operations on an empty queue. # Example ```python q = OrderedQueue() q.enqueue(5) q.enqueue(1) q.enqueue(3) print(q.peek()) # Output: 1 print(q.size()) # Output: 3 print(q.dequeue()) # Output: 1 print(q.dequeue()) # Output: 3 print(q.peek()) # Output: 5 print(q.is_empty()) # Output: False print(q.dequeue()) # Output: 5 print(q.is_empty()) # Output: True ``` # Implementation Tip You may choose to use a similar approach as the `OrderedStack` by utilizing temporary storage to maintain the order during `enqueue`.","solution":"class OrderedQueue: def __init__(self): self.queue = [] def enqueue(self, item): # Find the position where the item should be inserted to keep the order if not self.queue: self.queue.append(item) else: inserted = False for i in range(len(self.queue)): if item < self.queue[i]: self.queue.insert(i, item) inserted = True break if not inserted: self.queue.append(item) def dequeue(self): if self.is_empty(): raise IndexError(\\"dequeue from an empty queue\\") return self.queue.pop(0) def peek(self): if self.is_empty(): raise IndexError(\\"peek from an empty queue\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def size(self): return len(self.queue)"},{"question":"You are provided with a binary exponentiation function that efficiently computes the power of a number using both iterative and recursive approaches. Your task is to extend this functionality to handle negative exponents without compromising on the logarithmic time complexity. # Task Implement a modified version of the binary exponentiation functions that can handle negative exponents. The function should adhere to the same principles and provide the correct result for both positive and negative exponent values. # Input 1. `a` (integer): The base number. It may be positive or negative. 2. `n` (integer): The exponent. It may be positive, negative, or zero. 3. `mod` (integer, optional): A modulus value when provided should result in modular exponentiation. # Output Return the result of `a` raised to the power `n`. If `mod` is specified, return the result modulo `mod`. # Constraints 1. Implement both iterative and recursive approaches. 2. Ensure the time complexity remains O(log(n)) and handle both positive and negative exponents correctly. 3. If `mod` is provided, ensure proper application of modular arithmetic. # Function Signature ```python def power(a: int, n: int, mod: int = None) -> int: # your implementation here def power_recur(a: int, n: int, mod: int = None) -> int: # your implementation here ``` # Examples Example 1: ```plaintext Input: power(2, 3) Output: 8 Input: power_recur(2, 3) Output: 8 ``` Example 2: ```plaintext Input: power(2, -3) Output: 0.125 Input: power_recur(2, -3) Output: 0.125 ``` Example 3: ```plaintext Input: power(2, 3, 5) Output: 3 Input: power_recur(2, 3, 5) Output: 3 ``` # Notes * For negative exponents, return results as floating-point numbers if `mod` is not specified. * Handle power of zero scenarios appropriately (e.g., `0^0` is typically defined as 1).","solution":"def power(a: int, n: int, mod: int = None) -> int: Iterative binary exponentiation that handles negative exponents. if n == 0: return 1 if n < 0: a = 1 / a n = -n result = 1 base = a while n: if n % 2: result *= base if mod: result %= mod base *= base if mod: base %= mod n //= 2 return result if not mod else result % mod def power_recur(a: int, n: int, mod: int = None) -> int: Recursive binary exponentiation that handles negative exponents. if n == 0: return 1 if n < 0: return 1 / power_recur(a, -n, mod) half = power_recur(a, n // 2, mod) if mod: half %= mod result = half * half if mod: result %= mod if n % 2 != 0: result *= a if mod: result %= mod return result"},{"question":"# Description You are implementing a system that needs to efficiently check if numbers are prime as part of its operation. Your task is to write a function that determines whether a given number is prime. Additionally, you will write a utility function to list all prime numbers up to a given value using the prime checking function. # Task 1. Write a function named `is_prime(n)` that returns `True` if `n` is a prime number and `False` otherwise. 2. Write a function named `list_primes_up_to(m)` that: - Takes an integer `m` (where `m >= 2`) as input, - Returns a list of all prime numbers from 2 to `m`. # Requirements - **Input**: - An integer `n` for the `is_prime(n)` function. - An integer `m` for the `list_primes_up_to(m)` function where `m >= 2`. - **Output**: - Boolean values for `is_prime(n)`. - A list of integers for `list_primes_up_to(m)`. # Constraints - The functions should handle invalid inputs gracefully, ensuring only integers greater than 1 are processed for primality. - Ensure the performance is efficient especially for larger values of `m`. # Examples ```python assert is_prime(5) == True assert is_prime(15) == False assert list_primes_up_to(10) == [2, 3, 5, 7] assert list_primes_up_to(20) == [2, 3, 5, 7, 11, 13, 17, 19] ```","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def list_primes_up_to(m): Returns a list of all prime numbers from 2 to m. primes = [] for num in range(2, m + 1): if is_prime(num): primes.append(num) return primes"},{"question":"You are tasked with calculating the binomial coefficient C(n, k), which represents the number of ways to choose k elements from a set of n elements, using a recursive approach. This problem is commonly encountered in combinatorial mathematics. # Function Implementation Design the following function in Python: ```python def recursive_binomial_coefficient(n, k): Calculates the binomial coefficient, C(n, k), which is the number of ways to choose k elements from a set of n elements. Parameters: n (int): Total number of elements in the set (n >= 0). k (int): Number of elements to choose (0 <= k <= n). Returns: int: The binomial coefficient C(n, k). Raises: ValueError: If n < k. ``` # Constraints: * Ensure that the inputs are valid such that n >= k and k >= 0. * Optimize the recursive calls by leveraging properties of the binomial coefficient (e.g., C(n, k) = C(n, n-k) to reduce the problem size). # Performance Requirements: * The solution should handle large values of n and k efficiently. * The time complexity should be within O(k) for the given constraints. # Example ```python >>> recursive_binomial_coefficient(5, 0) 1 >>> recursive_binomial_coefficient(8, 2) 28 >>> recursive_binomial_coefficient(10, 5) 252 ``` # Edge Cases to Consider: * When k = 0, the result should be 1. * When n = k, the result should be 1. * When k > n, an exception should be raised. # Important Notes: * Emphasize the importance of the combinatorial identity C(n, k) = C(n, n-k) to reduce computational overhead. * Provide thorough input validation and handle potential errors gracefully.","solution":"def recursive_binomial_coefficient(n, k): Calculates the binomial coefficient, C(n, k), which is the number of ways to choose k elements from a set of n elements. Parameters: n (int): Total number of elements in the set (n >= 0). k (int): Number of elements to choose (0 <= k <= n). Returns: int: The binomial coefficient C(n, k). Raises: ValueError: If n < k or if k < 0. if k > n or k < 0: raise ValueError(\\"Invalid values for n and k. Ensure that 0 <= k <= n.\\") # Use combinatorial identity C(n, k) = C(n, n-k) if k > n - k: k = n - k # Base cases if k == 0 or k == n: return 1 # Recursive computation return recursive_binomial_coefficient(n - 1, k - 1) + recursive_binomial_coefficient(n - 1, k)"},{"question":"# Advanced Heap Sorting Challenge You are tasked with implementing the `kth_smallest_element_in_sorted_matrix` function which finds the kth smallest element in a sorted 2D matrix. The matrix is sorted such that each row and column is in ascending order. This problem will test your knowledge of heaps and sorting, similar to the `max_heap_sort` and `min_heap_sort` provided. Function Signature: ```python def kth_smallest_element_in_sorted_matrix(matrix: List[List[int]], k: int) -> int: pass ``` Input: - `matrix`: List of List of integers (NxN matrix) in which each row and each column is sorted in ascending order. - `k`: An integer representing the position (1-indexed) of the smallest element to find in the matrix. Output: - An integer representing the kth smallest element in the matrix. Constraints: - The matrix will have distinct elements within its rows and columns. - 1 <= N <= 500 - 1 <= matrix[i][j] <= 10^9 Example: ```python matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 assert kth_smallest_element_in_sorted_matrix(matrix, k) == 13 ``` Instructions: 1. Implement the function `kth_smallest_element_in_sorted_matrix` using a suitable heap-based approach. 2. Ensure your solution has an efficient time complexity and minimizes space usage. 3. Handle edge cases like: * A 1x1 matrix where the only element is the answer. * A k value corresponding to the last element in the NxN matrix. 4. Clearly comment your code or explain the logic where necessary for clarity. Good luck!","solution":"import heapq from typing import List def kth_smallest_element_in_sorted_matrix(matrix: List[List[int]], k: int) -> int: Finds the kth smallest element in a NxN sorted matrix. Parameters: matrix (List[List[int]]): NxN matrix where each row and column is sorted in ascending order. k (int): Position (1-indexed) of the smallest element to find in the matrix. Returns: int: The kth smallest element in the matrix. N = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(k, N)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k times for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < N: heapq.heappush(min_heap, (matrix[r][c+1], r, c+1)) return heapq.heappop(min_heap)[0]"},{"question":"# Task You are given a sorted array of integers and an integer value `target`. Your task is to implement a function `binary_search_with_duplication_handling` which returns the lowest index at which `target` occurs in the array. If `target` is not found in the array, return `-1`. # Input and Output * **Input:** - `array`: List of integers, sorted in ascending order. - `target`: An integer to search for. * **Output:** - Integer representing the lowest index of the target in the array, or `-1` if the target is not found. # Constraints * The array elements and the target can be any integer (positive or negative). * The array can contain duplicate elements. * The array size is between 1 and (10^5). # Example ```python assert binary_search_with_duplication_handling([2, 4, 4, 4, 9, 15, 19], 4) == 1 assert binary_search_with_duplication_handling([1, 2, 3, 5, 8, 10, 15], 6) == -1 assert binary_search_with_duplication_handling([], 5) == -1 assert binary_search_with_duplication_handling([5], 5) == 0 ``` # Function Signature ```python def binary_search_with_duplication_handling(array: List[int], target: int) -> int: # Your code here ```","solution":"def binary_search_with_duplication_handling(array, target): Returns the lowest index of target in the sorted array, or -1 if target is not found. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: result = mid right = mid - 1 # continue to search in the left half elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"Scenario You are part of a software engineering team responsible for maintaining a legacy codebase. The codebase contains a method called `bogo_sort` that is used to sort integer arrays. Due to its inefficiency and the impact it has on performance, your task is to demonstrate understanding of sorting algorithms by replacing `bogo_sort` with a more efficient sorting algorithm, such as Quick Sort. Task Implement a function `quick_sort` that sorts an integer array using the Quick Sort algorithm. # Function Signature ```python def quick_sort(arr: list) -> list: pass ``` # Input - `arr`: A list of integers (0 ≤ len(arr) ≤ 1000) # Output - Returns a new list of integers sorted in ascending order. # Constraints - The input array can be an empty list. - You may not use Python\'s built-in sort functions. # Performance Requirements - Time Complexity: Average O(n log n), Worst O(n^2) - Space Complexity: O(log n) due to recursion stack. # Example ```python # Example 1 input_array = [4, 2, 7, 1, 3] sorted_array = quick_sort(input_array) print(sorted_array) # Output: [1, 2, 3, 4, 7] # Example 2 input_array = [10, -1, 0, 5] sorted_array = quick_sort(input_array) print(sorted_array) # Output: [-1, 0, 5, 10] ``` Note: Ensure to account for edge cases such as an already sorted array and an array with repeated elements. Explanation Quick Sort is chosen due to its better average time complexity compared to Bogo Sort. The function should correctly implement the partitioning and recursive sorting processes inherent to Quick Sort.","solution":"def quick_sort(arr): Sorts an array of integers using the Quick Sort algorithm. Parameters: arr (list): List of integers (0 ≤ len(arr) ≤ 1000) Returns: list: A new list of integers sorted in ascending order. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"Context You are given a collection of numbers which could contain duplicates. Your task is to generate all possible unique permutations of these numbers and return them as a list of list where each inner list represents one permutation. Problem Statement Write a function `generate_unique_permutations(nums: List[int]) -> List[List[int]]` that returns all unique permutations of the input list `nums`. Function Signature ```python from typing import List def generate_unique_permutations(nums: List[int]) -> List[List[int]]: # Your code goes here ``` Input * `nums`: A list of integers which may contain duplicates. The list will have length in the range [0, 8]. Output * A list of lists, where each inner list is a unique permutation of the input list. Example ```python assert generate_unique_permutations([1,1,2]) == [ [1,1,2], [1,2,1], [2,1,1] ] assert generate_unique_permutations([1,2,3]) == [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] assert generate_unique_permutations([3, 3, 0, 3]) == [ [0, 3, 3, 3], [3, 0, 3, 3], [3, 3, 0, 3], [3, 3, 3, 0] ] ``` Constraints * Focus on the uniqueness of permutations. * No external library should be used to generate permutations. * Ensure your solution efficiently handles edge cases and is optimized for performance given the constraints. Notes * Permutations should be considered unique if they have different orderings of the same elements. * Order of permutations in the output list does not matter.","solution":"from typing import List def generate_unique_permutations(nums: List[int]) -> List[List[int]]: def backtrack(current, counter): if len(current) == len(nums): permutations.append(current[:]) return for num in counter: if counter[num] > 0: current.append(num) counter[num] -= 1 backtrack(current, counter) current.pop() counter[num] += 1 permutations = [] counter = {} for num in nums: counter[num] = counter.get(num, 0) + 1 backtrack([], counter) return permutations"},{"question":"# FizzBuzz with Custom Rules You\'re tasked with enhancing the classic FizzBuzz problem by incorporating custom rules defined using a function that checks for specific divisors. Implement a function `custom_fizzbuzz` that logs numbers from 1 to N, with replacements based on divisibility criteria provided via a dictionary. Task Description: Write a function `custom_fizzbuzz(n: int, rules: Dict[int, str]) -> List[str]` that: - Takes an integer `n` (1 ≤ n ≤ 10^6) as the upper limit. - Takes a dictionary `rules` where keys are integers (divisors) and values are strings (substitutes). For example: ```python rules = { 3: \\"Fizz\\", 5: \\"Buzz\\", 7: \\"Baz\\" } ``` The function should return a list of strings where: - Numbers divisible by any key in `rules` are replaced with the corresponding value(s). - If a number is divisible by more than one key, concatenate the corresponding values in the order they appear in the dictionary. - Numbers not divisible by any key remain unchanged. Input: - `n`: An integer (1 ≤ n ≤ 10^6) - `rules`: A dictionary of integer to string mappings. Output: - A list of strings with appropriate replacements. Example: ```python def custom_fizzbuzz(n, rules): # Your implementation here print(custom_fizzbuzz(15, {3: \\"Fizz\\", 5: \\"Buzz\\"})) # Output: [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\'] print(custom_fizzbuzz(20, {3: \\"Fizz\\", 5: \\"Buzz\\", 7: \\"Baz\\"})) # Output: [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'Baz\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'Baz\', \'FizzBuzz\', \'16\', \'17\', \'Fizz\', \'19\', \'Buzz\'] ``` Constraints: - Ensure the function runs efficiently for large values of `n`.","solution":"def custom_fizzbuzz(n, rules): Custom FizzBuzz function with rules. :param n: The upper limit to run FizzBuzz up to (inclusive). :param rules: A dictionary where keys are divisors and values are the corresponding substitutes. :return: A list of strings with appropriate replacements according to the rules. result = [] for num in range(1, n + 1): replacement = \\"\\" for divisor, substitute in rules.items(): if num % divisor == 0: replacement += substitute if not replacement: replacement = str(num) result.append(replacement) return result"},{"question":"Finding Two Unique Elements Objective You are required to implement a function that finds and returns the two unique elements in an array where every other element appears exactly twice. Context You are given an array of integers `nums`, where exactly two elements appear only once and all other elements appear exactly twice. Your objective is to find those two elements. The order of the result does not matter. Function Signature ```python def single_number3(nums): :type nums: List[int] :rtype: List[int] ``` Your function should take an array `nums` and return a list of two integers which are the unique elements in the array. Input * A list of integers `nums` with a minimum length of 2. * It is guaranteed that exactly two elements in the array will appear only once, and all other elements will appear exactly twice. Output * A list containing the two unique integers. Constraints * The function should have a time complexity of O(N). * The function should have a space complexity of O(1). Example ```python # Example input nums = [1, 2, 1, 3, 2, 5] # Expected output [3, 5] or [5, 3] ``` Edge Cases 1. The array has exactly 2 elements which are the unique elements. ```python nums = [4, 5] # Expected output: [4, 5] or [5, 4] ``` 2. The unique elements are the minimum and maximum integer values. ```python nums = [1, 1, -2147483648, 2147483647] # Expected output: [-2147483648, 2147483647] or [2147483647, -2147483648] ```","solution":"def single_number3(nums): Returns the two unique elements in an array where every other element appears exactly twice. # Step 1: XOR of all elements gives us the XOR of the two unique elements (a ^ b) xor_result = 0 for num in nums: xor_result ^= num # Step 2: Find a bit that differs between the two unique elements # The rightmost set bit in xor_result will be different for the two unique elements differing_bit = xor_result & -xor_result # Step 3: Partition the array into two groups and do XOR in each group unique1 = unique2 = 0 for num in nums: if num & differing_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2] # Example Usage #print(single_number3([1, 2, 1, 3, 2, 5])) # [3, 5] or [5, 3]"},{"question":"# Unique BST Calculation Problem Statement Given an integer `n`, write a function `calculate_unique_bsts(n)` that calculates the number of structurally unique Binary Search Trees (BSTs) that can be formed using values from 1 to `n`. Input - An integer `n` where `0 <= n <= 19`. Output - Return an integer representing the number of structurally unique BSTs that can be formed using values from 1 to `n`. Function Signature ```python def calculate_unique_bsts(n: int) -> int: ``` Constraints - The value of `n` will be such that the calculation remains feasible within typical execution limits. Examples 1. `calculate_unique_bsts(3)` should return `5`: - There are five structurally unique BSTs that can be created with numbers 1, 2, and 3. 2. `calculate_unique_bsts(4)` should return `14`: - The fourteen unique BSTs for numbers 1 to 4 include several permutations of these nodes where each combination maintains the BST property. Performance Requirements A solution must complete within a reasonable time frame for all given values of `n`, adhering to a quadratic time complexity bound. Here is the skeleton structure. Fill in the required logic: ```python def calculate_unique_bsts(n: int) -> int: # Create a list to store the number of unique BSTs for each count of nodes up to n dp = [0] * (n + 1) # Base cases: when n is 0 or 1 dp[0] = dp[1] = 1 # Fill the dp array using the dynamic programming approach for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n] ``` Provide a well-tested function that demonstrates understanding of dynamic programming principles. Include considerations for common edge cases.","solution":"def calculate_unique_bsts(n: int) -> int: Calculates the number of structurally unique Binary Search Trees (BSTs) that can be formed using values from 1 to n. if n == 0: return 0 # Create a list to store the number of unique BSTs for each count of nodes up to n dp = [0] * (n + 1) # Base cases: when there are no nodes or one node dp[0] = 1 dp[1] = 1 # Fill the dp array using the dynamic programming approach for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n]"},{"question":"Edit Distance with Space Optimization You are given two words, `word_a` and `word_b`. Your task is to compute the minimum number of operations needed to transform `word_a` into `word_b`. The allowed operations are insertions, deletions, and substitutions of characters. **Constraints**: - The lengths of `word_a` and `word_b` are at most 1000. - The strings consist of lowercase English letters only. However, to optimize space complexity, you are not allowed to use a 2D array. Instead, use a space-efficient approach that only uses two 1D arrays of length max(length of the words) to store the intermediate results. Write a function `edit_distance_optimized(word_a: str, word_b: str) -> int` that returns the minimum number of operations required to transform `word_a` into `word_b`. **Input:** ```python edit_distance_optimized(\\"intention\\", \\"execution\\") ``` **Output:** ```python 5 ``` **Explanation**: To convert \\"intention\\" to \\"execution\\": 1. intention -> exntention (substitute \'i\' with \'e\') 2. exntention -> exention (remove \'n\') 3. exention -> exection (substitute \'n\' with \'c\') 4. exection -> executio (substitute \'t\' with \'u\') 5. executio -> execution (insert \'n\') **Function Signature**: ```python def edit_distance_optimized(word_a: str, word_b: str) -> int: # Your code here ``` Remember to handle edge cases, such as when one or both strings are empty. Make sure your solution is efficient in terms of space complexity.","solution":"def edit_distance_optimized(word_a: str, word_b: str) -> int: len_a = len(word_a) len_b = len(word_b) if len_a == 0: return len_b if len_b == 0: return len_a previous_row = list(range(len_b + 1)) current_row = [0] * (len_b + 1) for i in range(1, len_a + 1): current_row[0] = i for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: current_row[j] = previous_row[j - 1] else: current_row[j] = 1 + min(previous_row[j - 1], current_row[j - 1], previous_row[j]) previous_row, current_row = current_row, previous_row return previous_row[-1]"},{"question":"You are given a string `s` that may contain alphanumeric characters and punctuation. Your task is to determine if `s` is a palindrome when considering only alphanumeric characters and ignoring cases. You must implement this using the stack-based approach provided. A string is considered a palindrome if it reads the same backward as forward after cleaning. **Function Signature:** ```python def is_palindrome_stack(s: str) -> bool: pass ``` # Input * A string `s` (0 ≤ len(s) ≤ 10^6). # Output * Return `True` if the string is a palindrome considering only alphanumeric characters and ignoring case, otherwise `False`. # Constraints * You must use a stack-based implementation to check for the palindrome. # Example Example 1 Input: ```python s = \\"A man, a plan, a canal: Panama\\" ``` Output: ```python True ``` Example 2 Input: ```python s = \\"race a car\\" ``` Output: ```python False ``` # Explanation * In Example 1, by ignoring cases and non-alphanumeric characters, the string reduces to \\"amanaplanacanalpanama\\", which is a palindrome. * In Example 2, after similar processing, it reduces to \\"raceacar\\", which is not a palindrome. # Additional Notes Consider edge cases such as: * An empty string which should return `True`. * Strings with only non-alphanumeric characters which should also be a valid palindrome as there are no characters to compare.","solution":"def is_palindrome_stack(s: str) -> bool: Determines if the given string is a palindrome considering only alphanumeric characters and ignoring cases, using a stack-based approach. # Filtering and converting the string to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Using stack to check for palindrome stack = [] for char in filtered_chars: stack.append(char) for char in filtered_chars: if char != stack.pop(): return False return True"},{"question":"# Question to Assess Understanding Context Given a dataset represented as an array of integers, you are tasked to determine which numbers appear most frequently in this dataset. If multiple numbers have the highest frequency, the algorithm should return all such numbers. Task Write a function `find_modes(arr)` that takes a list of integers `arr` as input and returns a list of integers representing the mode(s). The function should handle edge cases appropriately. Input - An array `arr` of integers (length n). Output - A list of integers representing the mode(s). Constraints - 1 <= n <= 10^6 - Each integer in the array will be in the range [-10^9, 10^9]. Requirements - Your solution should have an average time complexity of O(n). - The space complexity should be optimal for the problem constraints. Example ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([1, 1, 1, 2, 2, 3, 3, 3]) == [1, 3] assert find_modes([5, 5, 5, 1, 2, 3]) == [5] assert find_modes([1]) == [1] ``` Implementation Details - Handle edge cases such as empty arrays or arrays where all elements have the same frequency. - Ensure your implementation is robust and handles large input sizes within the given constraints.","solution":"def find_modes(arr): Returns the mode(s) of the array. The mode(s) are the number(s) that appear most frequently. from collections import Counter # Handle edge case of empty array if not arr: return [] # Count the frequency of each number in the array number_count = Counter(arr) # Find the maximum frequency max_frequency = max(number_count.values()) # Find all numbers with the maximum frequency modes = [num for num, count in number_count.items() if count == max_frequency] return modes"},{"question":"# Selection Sort Improvement Challenge You have been provided with a basic implementation of the selection sort algorithm. Although selection sort works, it performs inefficiently for large datasets due to its quadratic time complexity. Your task is to enhance the sorting functionality by using a more efficient algorithm, such as Merge Sort or Quick Sort, ensuring that the new implementation reduces the average time complexity to O(n log n). Function Signature ```python def optimized_sort(arr: List[int], simulation: bool = False) -> List[int]: pass ``` # Inputs and Outputs - The input is a list of integers `arr`. - The `simulation` flag is optional. If set to `True`, your function should print the array at each significant step of the implemented sorting algorithm, helping us to trace the changes in the array. - The output should be the sorted list of integers. # Constraints - You may assume that all elements in array `arr` are integers. - The length of `arr` is guaranteed to be between 0 and 10^6. # Example Input ```python arr = [64, 25, 12, 22, 11] simulation = True ``` Output ```python # Shows intermediate steps if simulation is True iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 iteration 4 : 11 12 22 25 64 [11, 12, 22, 25, 64] ``` Notes - While your implementation must avoid quadratic time complexity, please ensure to handle edge cases such as empty arrays and single-element lists appropriately. - Ensure your implementation is efficient in both time and space. Implement the function `optimized_sort` that achieves these criteria described above.","solution":"from typing import List def optimized_sort(arr: List[int], simulation: bool = False) -> List[int]: def quicksort(arr, low, high): if low < high: pi = partition(arr, low, high) if simulation: print(f\\"Partition at index {pi}: {arr}\\") quicksort(arr, low, pi - 1) quicksort(arr, pi + 1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] if simulation: print(f\\"Swapping elements at indices {i} and {j}: {arr}\\") arr[i+1], arr[high] = arr[high], arr[i+1] if simulation: print(f\\"Placing pivot at the correct position {i+1}: {arr}\\") return i + 1 if simulation: print(f\\"Initial array: {arr}\\") quicksort(arr, 0, len(arr) - 1) return arr"},{"question":"# Scenario You are working on a project handling large datasets related to user permissions. Each user\'s permissions are represented as a 32-bit integer where each bit signifies the presence (1) or absence (0) of a specific permission. Efficiently manipulating these bits is crucial for your application’s performance. # Task Implement the following functions to manage user permissions: 1. **`get_permission(user_permissions, permission_index)`**: Returns whether the user has a specific permission (0 or 1). 2. **`grant_permission(user_permissions, permission_index)`**: Grants a specific permission by setting the corresponding bit to 1. 3. **`revoke_permission(user_permissions, permission_index)`**: Revokes a specific permission by setting the corresponding bit to 0. 4. **`update_permission(user_permissions, permission_index, permission_value)`**: Updates a specific permission to the given value (0 or 1). **Function Definitions**: ```python def get_permission(user_permissions: int, permission_index: int) -> int: pass def grant_permission(user_permissions: int, permission_index: int) -> int: pass def revoke_permission(user_permissions: int, permission_index: int) -> int: pass def update_permission(user_permissions: int, permission_index: int, permission_value: int) -> int: pass ``` # Constraints * `0 <= user_permissions < 2^32` * `0 <= permission_index < 32` * `permission_value` is either 0 or 1 # Examples ```python # Example 1 user_permissions = 0b10101010 permission_index = 3 # get_permission print(get_permission(user_permissions, permission_index)) # returns 1 # Example 2 user_permissions = 0b10101010 permission_index = 1 # grant_permission print(grant_permission(user_permissions, permission_index)) # returns 0b10101011 # Example 3 user_permissions = 0b10101010 permission_index = 3 # revoke_permission print(revoke_permission(user_permissions, permission_index)) # returns 0b10100010 # Example 4 user_permissions = 0b10101010 permission_index = 3 permission_value = 1 # update_permission print(update_permission(user_permissions, permission_index, permission_value)) # returns 0b10101010 ```","solution":"def get_permission(user_permissions: int, permission_index: int) -> int: Returns whether the user has a specific permission (0 or 1). return (user_permissions >> permission_index) & 1 def grant_permission(user_permissions: int, permission_index: int) -> int: Grants a specific permission by setting the corresponding bit to 1. return user_permissions | (1 << permission_index) def revoke_permission(user_permissions: int, permission_index: int) -> int: Revokes a specific permission by setting the corresponding bit to 0. return user_permissions & ~(1 << permission_index) def update_permission(user_permissions: int, permission_index: int, permission_value: int) -> int: Updates a specific permission to the given value (0 or 1). if permission_value == 1: return grant_permission(user_permissions, permission_index) else: return revoke_permission(user_permissions, permission_index)"},{"question":"# Power of Two Check **Scenario**: You are part of a systems programming team responsible for low-level optimizations in a database management system. One of the tasks involves ensuring that system resources are allocated in sizes that are powers of two, to take advantage of certain hardware efficiencies and memory alignment optimizations. **Task**: Write a function `is_power_of_two(n)` that determines if a given integer `n` is a power of two. The function should return `True` if `n` is a power of two, and `False` otherwise. Your solution should leverage bitwise operations for optimal performance. Requirements: * **Function signature**: ```python def is_power_of_two(n: int) -> bool: ``` * **Input**: * An integer `n` where `1 <= n <= 10^18`. * **Output**: * Return `True` if `n` is a power of two, otherwise return `False`. Constraints: * Do not use loops or recursion. * Only use bitwise operations, mathematical operations, and/or boolean logic. * Handle possible edge cases such as `n = 0` or negative numbers by returning `False`. Examples: *Example 1*: ```python is_power_of_two(1) # Returns: True ``` *Example 2*: ```python is_power_of_two(2) # Returns: True ``` *Example 3*: ```python is_power_of_two(4) # Returns: True ``` *Example 4*: ```python is_power_of_two(5) # Returns: False ```","solution":"def is_power_of_two(n: int) -> bool: Determines if a given integer `n` is a power of two. Args: n: An integer, where `1 <= n <= 10^18`. Returns: True if `n` is a power of two, otherwise False. if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# In-order Traversal - Binary Tree Problem **Objective**: Implement the in-order traversal of a binary tree both iteratively and recursively. Context You have been given a binary tree represented through its root node. Your task is to traverse this tree in an in-order sequence (Left, Root, Right) and return the list of visited nodes\' values. Detailed Requirements 1. **Function A (Iterative)**: - **Function Signature**: `def inorder_iterative(root: Optional[Node]) -> List[int]:` - **Input**: Root node of the binary tree. - **Output**: List of integer values encountered in in-order traversal. - **Constraints**: - The tree can have up to 10^5 nodes. - Each node contains integer values. - The height of the tree may vary from 0 (empty tree) to potentially 10^5 (highly skewed tree). 2. **Function B (Recursive)**: - **Function Signature**: `def inorder_recursive(root: Optional[Node]) -> List[int]:` - **Input**: Root node of the binary tree. - **Output**: List of integer values encountered in in-order traversal. - **Constraints**: - Same as Function A. - Ensure that the recursive depth does not trigger stack overflow. Example Given a binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` - **In-order Traversal Result**: [25, 50, 75, 100, 125, 150, 175] Instructions 1. Implement `inorder_iterative` as specified above. 2. Implement `inorder_recursive` as specified above. 3. Ensure your solution handles the edge cases including but not limited to an empty tree or single-node tree. **Note**: Do not use any built-in libraries for tree data structures. You need to define the `Node` class and then implement the traversal functions. You can use the below `Node` class: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ```","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.val = val self.left = left self.right = right def inorder_iterative(root: Optional[Node]) -> List[int]: stack, result = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Optional[Node]) -> List[int]: def helper(node: Optional[Node], result: List[int]): if node: helper(node.left, result) result.append(node.val) helper(node.right, result) result = [] helper(root, result) return result"},{"question":"# Scenario In a competitive programming environment, you need to solve a problem where you are given two strings. One string is derived by randomly shuffling the other string and then adding a single additional character. Your task is to identify this extra character efficiently. # Task Write a function `find_extra_character(s, t)` which takes two strings `s` and `t` as input and returns the character that was added to `s` to form `t`. # Input Format - `s`: A string consisting of only lowercase letters, length n (1 ≤ n ≤ 10^5). - `t`: A string consisting of only lowercase letters and one additional letter compared to `s`, length n+1. # Output Format Return a single character which is the extra character added in `t`. # Constraints - Both input strings consist of only lowercase English letters. - The length of `t` is exactly one more than the length of `s`. # Examples 1. Input: ```plaintext s = \\"abcd\\" t = \\"abecd\\" ``` Output: ```plaintext \'e\' ``` 2. Input: ```plaintext s = \\"xyz\\" t = \\"xyzj\\" ``` Output: ```plaintext \'j\' ``` # Note - You must not use sorting or any technique that exceeds O(n) complexity. - Your solution should be efficient in terms of both time and space.","solution":"def find_extra_character(s, t): Identifies the extra character in the string t which is not in the string s. char_count = [0] * 26 for char in s: char_count[ord(char) - ord(\'a\')] -= 1 for char in t: char_count[ord(char) - ord(\'a\')] += 1 return chr(char_count.index(1) + ord(\'a\'))"},{"question":"# FizzBuzz Variations Objective Extend the functionality of the original FizzBuzz problem. Instead of only checking for multiples of 3 and 5, the solution should check for multiples against a provided list of divisor-rule pairs. Problem Statement Write a function `custom_fizzbuzz(n, rules)` that generates a list of integers from 1 to n where n is a positive integer, replacing numbers depending on the provided rules. Each rule consists of a pair `(d, word)` where: - `d` is a divisor. - `word` is the string to replace numbers divisible by `d`. If a number is divisible by multiple divisors in the rules, concatenate all respective words in their order of appearance in the rule list. Specifications - **Input**: - `n` (int): A positive integer greater than or equal to 1. - `rules` (List[Tuple[int, str]]): A list of tuples where each tuple consists of a divisor and a corresponding string. - **Output**: - `List[Union[int, str]]`: A list with numbers or corresponding strings according to the rules provided. - **Constraints**: - `1 <= n <= 1000` - `rules` will contain at most 10 pairs. - Divisors in `rules` will be positive integers. Example ```python def custom_fizzbuzz(n, rules): # Implementation goes here # Example 1 n = 15 rules = [(3, \\"Fizz\\"), (5, \\"Buzz\\")] print(custom_fizzbuzz(n, rules)) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] # Example 2 n = 10 rules = [(2, \\"Foo\\"), (3, \\"Bar\\")] print(custom_fizzbuzz(n, rules)) # Output: [1, \'Foo\', \'Bar\', \'Foo\', 5, \'FooBar\', 7, \'Foo\', \'Bar\', \'Foo\'] ``` Notes - Ensure the function handles invalid inputs gracefully. - Optimize for readability and maintainability. - Leverage list comprehensions where possible to simplify the code. Submission Complete the function `custom_fizzbuzz(n, rules)` and test it with multiple cases.","solution":"def custom_fizzbuzz(n, rules): result = [] for i in range(1, n + 1): word = \'\'.join([w for d, w in rules if i % d == 0]) result.append(word if word else i) return result"},{"question":"Context You\'re working on a numerical methods project that requires matrix decompositions for various purposes such as solving systems of linear equations. One such decomposition is Crout\'s matrix decomposition, which factors a given square matrix into lower and upper triangular matrices. Task Implement a function `crout_matrix_decomposition` that takes a square matrix ( mathbf{A} ) as input and returns the lower triangular matrix ( mathbf{L} ) and the upper triangular matrix ( mathbf{U} ). Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: pass ``` Input * A single input parameter: * `A`: A list of lists of floats representing an ( n times n ) square matrix. Output * A tuple containing two lists of lists of floats: * `L`: The lower triangular matrix. * `U`: The upper triangular matrix. Constraints * The matrix ( mathbf{A} ) will be a non-singular, square matrix. * The dimensions of the matrices involved will not exceed ( 100 times 100 ). * The diagonal elements of the matrix will not be zero. Example ```python # Example Usage: A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] L, U = crout_matrix_decomposition(A) # Expected Output # L = [ # [1.0, 0.0, 0.0], # [3.0, -2.0, 0.0], # [6.0, -5.0, 0.0] # ] # U = [ # [1.0, 2.0, 3.0], # [0.0, 1.0, 2.0], # [0.0, 0.0, 1.0] # ] ``` Edge Cases to Consider * Ensure you handle small numerical values on the diagonal by applying a small threshold value. * Verify the correctness of the decomposition by multiplying ( mathbf{L} ) and ( mathbf{U} ) to check if you recover ( mathbf{A} ), within an acceptable numerical error range.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) L = [[0.0] * n for i in range(n)] U = [[0.0] * n for i in range(n)] for i in range(n): # Upper Triangular Matrix U U[i][i] = 1.0 for j in range(i, n): sum_LU = sum(L[j][k] * U[k][i] for k in range(i)) L[j][i] = A[j][i] - sum_LU # Lower Triangular Matrix L for j in range(i + 1, n): sum_LU = sum(L[i][k] * U[k][j] for k in range(i)) U[i][j] = (A[i][j] - sum_LU) / L[i][i] return L, U"},{"question":"Find the N-th Digit in the Infinite Sequence of Numbers Objective: Write a Python function to find the n-th digit in the sequence of natural numbers starting from 1 and concatenated together (i.e., \\"123456789101112...\\"). Function Signature: ```python def find_nth_digit(n: int) -> int: pass ``` Input: - **n**: A positive integer (1 <= n <= 2 * 10^9) representing the position in the infinite sequence. Output: - Returns an integer representing the n-th digit. Example: ```python assert find_nth_digit(1) == 1 # The first digit in the sequence is \\"1\\". assert find_nth_digit(10) == 1 # The 10th digit in the sequence is the first \\"1\\" from \\"10\\". assert find_nth_digit(15) == 2 # The 15th digit in the sequence is the second \\"2\\" from \\"12\\". assert find_nth_digit(189) == 9 # The 189th digit is the last \\"9\\" of \\"99\\". assert find_nth_digit(190) == 1 # The 190th digit is the first \\"1\\" of \\"100\\". ``` Constraints: - Ensure that your solution is efficient and avoids unnecessary computations or memory usage. Notes: - The sequence is continuous and grows infinitely. - Consider edge cases such as very small or very large values of n. - Use mathematical calculations rather than string manipulations to enhance performance.","solution":"def find_nth_digit(n: int) -> int: # Step 1: determine the length of numbers (1-digit, 2-digit, 3-digit, etc.) where n-th digit lies length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Step 2: determine the exact number where the n-th digit is located start += (n - 1) // length # Step 3: determine the exact digit in the number s = str(start) return int(s[(n - 1) % length])"},{"question":"# Increment a Large Number Context You are tasked to implement a function that simulates adding one to a large non-negative integer, where the integer is given in the form of an array of digits. The array represents the number such that the most significant digit is at the front of the list. This problem is a common task in arbitrary-precision arithmetic and is often encountered in situations involving large-scale financial computations or implementations requiring very large number representations beyond standard data types. Problem Statement Implement a function `increment_number(digits: List[int]) -> List[int]` that takes an array of digits representing a non-negative large integer and returns a new array of digits representing the integer obtained by adding one to the initial number. # Input - `digits`: A list of integers where each integer is a digit (0-9) representing the large number, `0 <= digits[i] <= 9`. # Output - A list of integers where each integer is a digit (0-9) representing the incremented large number. # Constraints - The input list will have a length in the range [1, 10^4]. - The input list will not contain any leading zeros except for the number `0` itself. # Performance Requirements - The solution must run in O(n) time complexity. - The space complexity should be optimal, with O(1) extra space preferred when possible. Example 1. Input: `[1, 2, 3]` Output: `[1, 2, 4]` 2. Input: `[9]` Output: `[1, 0]` 3. Input: `[4, 3, 2, 1]` Output: `[4, 3, 2, 2]` 4. Input: `[0]` Output: `[1]` Notes - You must handle cases where the addition of one results in carrying over to the next most significant digit. - Consider in-place updates to optimize space usage where appropriate.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increments the given large number represented as a list of digits by one. Args: digits (List[int]): A list of integers where each integer is a digit (0-9) representing the large number. Returns: List[int]: A list of integers representing the incremented large number. n = len(digits) # Traverse the list from the end to the beginning for i in range(n-1, -1, -1): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits # If we are out of the loop, that means all digits were 9 return [1] + [0] * n"},{"question":"Context: You are working on a legacy system that uses stacks for its task management. Recently, there was a requirement to duplicate every task while maintaining their order for better tracking and redundancy. You are tasked with modifying the stack to contain two occurrences of each of its original elements. Task: Write a function `stutter(stack, use_queue=False)` that duplicates each element in the stack. If `use_queue` is `True`, use a queue to assist the operation; otherwise, use another stack. Function Signature: ```python def stutter(stack, use_queue=False): ``` Input: - `stack` (List): A list representing a stack where the last element is the top of the stack. - `use_queue` (Bool): A boolean flag to indicate which auxiliary data structure to use (default to `False`). Output: - The modified `stack` where each element from the original stack appears twice in the same order. Constraints: - The input stack may have up to 10^5 elements. - Each element in the stack is an integer. Examples: Example 1: ```python stack = [3, 7, 1, 14, 9] stutter(stack) print(stack) # [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Example 2: ```python stack = [3, 7, 1, 14, 9] stutter(stack, use_queue=True) print(stack) # [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Note: - Ensure your function handles edge cases such as an empty stack or stack with only one element efficiently.","solution":"from collections import deque def stutter(stack, use_queue=False): Modifies the input stack to contain two occurrences of each original element. Args: stack (list): A list representing the stack where the last element is the top of the stack. use_queue (bool): A boolean flag to indicate whether to use a queue (True) or another stack (False) as auxiliary storage. Returns: None: The stack is modified in-place. if use_queue: queue = deque() while stack: element = stack.pop() queue.appendleft(element) queue.appendleft(element) while queue: stack.append(queue.popleft()) else: aux_stack = [] while stack: element = stack.pop() aux_stack.append(element) aux_stack.append(element) while aux_stack: stack.append(aux_stack.pop())"},{"question":"# Radix Sort Implementation **Objective**: Implement a function for the Radix Sort algorithm that sorts an array of non-negative integers in ascending order. This function should allow an optional simulation mode that outputs each iteration\'s result. **Function Signature**: ```python def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input * `arr`: A list of non-negative integers. It\'s guaranteed that all the integers in the list are within the range [0, 10^9]. * `simulation`: A boolean flag (default is False). If True, at each iteration, the state of the array should be printed. # Output * A list of integers sorted in ascending order. # Constraints 1. The input list `arr` contains at most 10^6 elements. 2. The elements of `arr` are non-negative integers. 3. If `simulation` is True, print the state of the array in each iteration starting from the initial array. # Scenario You are hired to develop a data processing pipeline where you receive large arrays of numeric identifiers which need to be sorted efficiently and occasionally, you need to visualize the sorting process for debugging and verification purposes. # Example ```python >>> radix_sort([170, 45, 75, 90, 802, 24, 2, 66], simulation=True) iteration 0 : 170 45 75 90 802 24 2 66 iteration 1 : 170 90 802 2 24 45 75 66 iteration 2 : 802 2 24 45 66 170 75 90 [2, 24, 45, 66, 75, 90, 170, 802] >>> radix_sort([3, 6, 9, 1, 4, 7], simulation=False) [1, 3, 4, 6, 7, 9] ```","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool) -> None: n = len(arr) output = [0] * n count = [0] * 10 # Store count of occurrences in count[] for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] contains actual # position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[], so that arr now # contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] if simulation: print(f\'iteration (exp={exp}) : \' + \' \'.join(map(str, arr))) def radix_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr: return [] max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"# Question: Implement a B-Tree with Additional Features Consider the provided implementation of a B-tree. Avoiding the shared code, solve the following tasks to demonstrate your understanding: 1. **Traversal in Different Orders**: Implement functions to traverse the B-tree and return keys in pre-order and post-order. 2. **Find Key with Path**: Write a function to search for a given key and return the path taken through the nodes to reach this key. 3. **Node Depth**: Write a function `node_depth(key: int) -> int` to return the depth of the node containing the given key. Function Implementations: 1. **Pre-order and Post-order Traversal** ```python def pre_order_traversal(self) -> list: Traverses the B-tree in pre-order and returns the keys as a list. pass def post_order_traversal(self) -> list: Traverses the B-tree in post-order and returns the keys as a list. pass ``` 2. **Find Key with Path** ```python def find_key_with_path(self, key: int) -> list: Finds the key in the B-tree and returns the path as a list of nodes\' keys. pass ``` 3. **Node Depth** ```python def node_depth(self, key: int) -> int: Returns the depth of the node containing the given key. Depth of the root node is 0. pass ``` Input and Output Formats - The functions should be added to the BTree or Node classes as methods. - Pre-order and post-order traversal functions should return lists of keys. - `find_key_with_path` should return a list representing the path traced as an array of node keys. - `node_depth` should return the depth as an integer. Constraints 1. Your B-tree can have at most 1000 keys. 2. The B-tree will handle integer keys only. 3. Assume t_val (degree of the tree) will always be greater than 2 for this question. # Scenario Imagine you are designing a file system index using a B-tree data structure. Frequently, you might need to get efficiently the hierarchical path for a file, check if specific files exist, and list files in different order sequences. Your task is to enhance the provided B-tree code with functions to facilitate these operations.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # minimum degree (defines the range for the number of keys) self.leaf = leaf # true if leaf node, else false self.keys = [] # list of keys in this node self.children = [] # list of child BTreeNodes def traverse_pre_order(self): # Pre-order: Node -> Left -> Right result = [] result.extend(self.keys) for child in self.children: result.extend(child.traverse_pre_order()) return result def traverse_post_order(self): # Post-order: Left -> Right -> Node result = [] for child in self.children: result.extend(child.traverse_post_order()) result.extend(self.keys) return result def find_key_with_path(self, key): path = [] return self._find_key_with_path_helper(key, path) def _find_key_with_path_helper(self, key, path): for i in range(len(self.keys)): if key == self.keys[i]: path.append(self.keys[i]) return path if key < self.keys[i]: if len(self.children) > 0: path.append(self.keys[i]) return self.children[i]._find_key_with_path_helper(key, path) else: return None if len(self.children) > 0: path.append(self.keys[-1]) return self.children[-1]._find_key_with_path_helper(key, path) return None def node_depth(self, key, depth=0): for i in range(len(self.keys)): if key == self.keys[i]: return depth if key < self.keys[i]: if len(self.children) > 0: return self.children[i].node_depth(key, depth + 1) else: return -1 if len(self.children) > 0: return self.children[-1].node_depth(key, depth + 1) return -1 class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t def pre_order_traversal(self): return self.root.traverse_pre_order() def post_order_traversal(self): return self.root.traverse_post_order() def find_key_with_path(self, key): return self.root.find_key_with_path(key) def node_depth(self, key): return self.root.node_depth(key)"},{"question":"# Climbing Stairs Problem with a Twist: You are given an integer `steps` representing the number of steps to reach the top of a staircase. However, in addition to climbing 1 or 2 steps each time, you have an extra \\"jump\\" which allows you to climb exactly 3 steps at once. Your task is to write a function that computes the number of distinct ways to reach the top of the staircase. Function Signature ```python def climb_stairs_with_jump(steps: int) -> int: pass ``` Input * `steps` (1 <= steps <= 10^5): an integer representing the total number of steps. Output * An integer representing the number of distinct ways to reach the top. Constraints and Requirements * The output should be calculated efficiently in both time and space. Example ```python print(climb_stairs_with_jump(4)) # Output: 7 # Explanation: # There are 7 ways to climb to the top for 4 steps: # 1. 1 step + 1 step + 1 step + 1 step # 2. 1 step + 1 step + 2 steps # 3. 1 step + 2 steps + 1 step # 4. 2 steps + 1 step + 1 step # 5. 2 steps + 2 steps # 6. 1 step + 3 steps # 7. 3 steps + 1 step ``` # Your task: Implement the function `climb_stairs_with_jump` which follows the constraints and requirements mentioned.","solution":"def climb_stairs_with_jump(steps: int) -> int: if steps == 0: return 1 elif steps == 1: return 1 elif steps == 2: return 2 elif steps == 3: return 4 dp = [0] * (steps + 1) dp[0] = 1 dp[1] = 1 dp[2] = 2 dp[3] = 4 for i in range(4, steps + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[steps]"},{"question":"Implement a function to simplify a given polynomial by combining like terms and reducing it to its simplest form. # Function Signature: ```python def simplify_polynomial(polynomial: Polynomial) -> Polynomial: pass ``` # Input: - `polynomial`: An instance of the `Polynomial` class representing the polynomial to be simplified. # Output: - A simplified `Polynomial` object where all like terms are combined, and unnecessary zero coefficients are removed. # Constraints: - The input polynomial can contain a maximum of 100 monomials. - Coefficients can be integers, floats, or fractions. - Variables can be indexed by positive integers. # Example: ```python # Example polynomial input: 2(a_1) + 3(a_2) - 2(a_1) + (a_3)^0 + 5*(a_2)^2 poly = Polynomial([ Monomial({1: 1}, 2), Monomial({2: 1}, 3), Monomial({1: 1}, -2), Monomial({}, 1), Monomial({2: 2}, 5) ]) result = simplify_polynomial(poly) print(result) # Expected simplified output: Polynomial should combine the terms to result in something like: \\"3(a_2) + 5(a_2)^2 + 1\\" ``` # Additional Context: To achieve this, iterate over the monomials in the polynomial, group like terms by their variable sets, and sum up their coefficients. Ensure that any monomials resulting with a zero coefficient are excluded from the final polynomial representation. # Notes: - You can utilize the methods already defined in the `Monomial` and `Polynomial` classes provided in the code snippets. - Focus on ensuring the final result is in its simplest algebraic form, reducing any redundancies in the input polynomial. # Implementation Hints: - Use sets or dictionaries to track like terms by their variable compositions. - Ensure all operations consider potential edge cases, such as zero coefficients or no variables in monomials.","solution":"from collections import defaultdict from typing import List, Dict class Monomial: def __init__(self, variables: Dict[int, int], coefficient): self.variables = variables # dictionary mapping variable indices to their exponents self.coefficient = coefficient def __eq__(self, other): # Checks equality based on variables dictionary and coefficient return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): # Use frozenset of variable-item pairs for hashing, allowing storage in sets and dict keys return hash(frozenset(self.variables.items())) class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials def __eq__(self, other): return set(self.monomials) == set(other.monomials) def simplify_polynomial(polynomial: Polynomial) -> Polynomial: combined_terms = defaultdict(lambda: 0) for monomial in polynomial.monomials: frozenset_vars = frozenset(monomial.variables.items()) combined_terms[frozenset_vars] += monomial.coefficient simplified_monomials = [] for vars_set, coefficient in combined_terms.items(): if coefficient != 0: variables = dict(vars_set) simplified_monomials.append(Monomial(variables, coefficient)) return Polynomial(simplified_monomials)"},{"question":"You are given an array of integers and a target integer. Write a function to identify the indices of two numbers from the array that add up to the target value. Implement the function with linear time complexity. # Function Signature ```python def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: pass ``` # Input - `nums`: A list of integers, where each integer can be positive, negative, or zero (len(nums) >= 2). - `target`: An integer representing the target sum. # Output - A tuple containing the indices of the two numbers that add up to the target. If no such pair exists, return an empty tuple. # Constraints - You may assume that there is exactly one solution. # Example ```python assert find_pair_with_sum([2, 7, 11, 15], 9) == (0, 1) assert find_pair_with_sum([3, 2, 4], 6) == (1, 2) assert find_pair_with_sum([3, 3], 6) == (0, 1) ``` # Edge Cases - Ensure to handle cases where the input list has only two elements. - Handle the scenario where no two elements sum to the target (per problem constraints, this should not occur but good to handle for robustness).","solution":"from typing import List, Tuple def find_pair_with_sum(nums: List[int], target: int) -> Tuple[int, int]: Finds indices of the two numbers that add up to the given target. Args: nums: List of integers. target: The target integer sum. Returns: A tuple of indices of the two numbers that add up to the target. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return ()"},{"question":"Find the k-th Smallest Element in a Binary Search Tree **Scenario**: Tony, a software engineer, needs to retrieve the k-th smallest element from a large binary search tree (BST) for a unique set of search queries. He needs an efficient solution to handle this rapidly. You are tasked with writing a function for Tony that will carry out this operation with optimal performance. **Task**: Implement a function `find_kth_smallest` that finds the k-th smallest element in a given binary search tree. **Function Signature**: ```python def find_kth_smallest(root: Node, k: int) -> int: pass ``` **Input**: 1. `root` (`Node`) - The root node of the BST. 2. `k` (`int`) - An integer representing the position of the smallest element required (1-based index). **Output**: - Returns an integer representing the k-th smallest element in the BST. **Constraints**: - The BST can contain up to `10^4` nodes. - `1 <= k <= number of nodes in the tree`. - BST nodes contain integer values. **Requirements**: - The function should efficiently handle large and unbalanced trees. - Ensure your function handles edge cases as described in the analysis. **Example**: ```python # Example BST construction n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert find_kth_smallest(n1, 1) == 25 assert find_kth_smallest(n1, 2) == 50 ``` Feel free to include additional optimizations to improve performance, considering balanced and unbalanced tree structures. **Notes**: - Students should consider edge cases like k being larger than the number of nodes. - Encourage reasoning about handling unbalanced trees and recursion depth problems.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def find_kth_smallest(root: Node, k: int) -> int: Returns the k-th smallest element in the BST. def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.value] + inorder_traversal(node.right) # Perform an inorder traversal of the BST elements = inorder_traversal(root) # The k-th smallest element (1-based index) will be at index k-1 (0-based index) return elements[k-1]"},{"question":"Context You are developing a navigation system for a city with a network of roads. Some roads have negative travel times due to factors like shortcuts or beneficial one-way paths. You need to determine if there exists a feasible travel plan from any given location to all other locations within the city. Task Implement a function called `is_feasible_travel_plan` which utilizes the Bellman-Ford algorithm to determine if there are negative-weight cycles in the city\'s road network. If a negative-weight cycle exists reachable from the source location, return `False`; otherwise, return `True`. Function Signature ```python def is_feasible_travel_plan(graph: dict, source: str) -> bool: pass ``` Input - `graph`: A dictionary representing the road network with vertices and weighted edges. Example: ```python graph = { \'A\': {\'B\': 4, \'C\': 3}, \'B\': {\'C\': -2, \'D\': 2}, \'C\': {\'D\': 3}, \'D\': {\'B\': 1} } ``` - `source`: A string representing the starting location (vertex) in the graph. Output - Return a boolean value. `True` if there is no reachable negative-weight cycle from the source, otherwise `False`. Constraints - `(0 <= |V| <= 1000)`, where `|V|` is the number of vertices. - `(0 <= |E| <= 10000)`, where `|E|` is the number of edges. - Weights of edges can be negative or positive integers. Example ```python graph = { \'A\': {\'B\': 4, \'C\': 3}, \'B\': {\'C\': -2, \'D\': 2}, \'C\': {\'D\': 3}, \'D\': {\'B\': 1} } source = \'A\' print(is_feasible_travel_plan(graph, source)) # Output: True ``` Performance Requirements You must solve the problem within a time complexity of O(V * E) and ensure that your implementation handles graphs of varying sizes efficiently.","solution":"def is_feasible_travel_plan(graph, source): Determines if there is a negative-weight cycle reachable from the source in the given graph. Parameters: graph (dict): The graph represented as an adjacency list with edge weights. source (str): The starting location (vertex) in the graph. Returns: bool: True if there is no reachable negative-weight cycle from the source, otherwise False. # Initialize distances from the source distance = {vertex: float(\'inf\') for vertex in graph} distance[source] = 0 # Get all the edges in the graph edges = [] for u in graph: for v in graph[u]: edges.append((u, v, graph[u][v])) # Relax edges up to V-1 times, where V is the number of vertices V = len(graph) for _ in range(V - 1): for u, v, w in edges: if distance[u] != float(\'inf\') and distance[u] + w < distance[v]: distance[v] = distance[u] + w # Check for negative-weight cycles by trying to relax one more time for u, v, w in edges: if distance[u] != float(\'inf\') and distance[u] + w < distance[v]: return False return True"},{"question":"# File Path Resolver Context: You are working on a file management script that needs to handle various file paths provided by users. To ensure uniformity and avoid any confusion during file operations, you need to resolve all file paths to their absolute counterparts. Task: Write a Python function named `resolve_file_path` that takes a string input representing a file path, which may be relative or use the tilde notation for user directories. Your function should convert this to an absolute path. Function Signature: ```python def resolve_file_path(file: str) -> str: pass ``` Input Format: * A single string `file` representing the path to the file. Output Format: * A single string that is the absolute path of the provided file. Constraints: * The input string can contain user-directory notation (\'~\'). * Assume the input path might not exist, but it should still resolve to an absolute path. * Handle relative and absolute paths. Example: ```python assert resolve_file_path(\'~/documents/file.txt\') == \'/home/username/documents/file.txt\' assert resolve_file_path(\'./file.txt\') == \'/current/working/directory/file.txt\' ``` * Note: The actual output will vary depending on the system executing the function. Performance Expectations: * Efficient resolution of paths is expected. * Aim for clarity and readability in your implementation to handle potential edge cases.","solution":"import os def resolve_file_path(file: str) -> str: Converts the given file path to an absolute path. return os.path.abspath(os.path.expanduser(file))"},{"question":"# Question You are given an array of integers sorted in ascending order and an integer `target`. Your task is to implement the `ternary_search` function that will search for the `target` in the array using the ternary search algorithm. # Function Signature ```python def ternary_search(arr: List[int], target: int) -> int: ``` # Input * `arr`: A list of integers sorted in ascending order. (1 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9) * `target`: An integer to search for in the array. (-10^9 <= target <= 10^9) # Output * Return the index of the `target` in the array if found, otherwise return -1. # Constraints 1. The array is sorted in ascending order. 2. Perform the search with the minimum number of comparisons possible. # Example ```python assert ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 4 assert ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 10) == -1 assert ternary_search([-10, -5, 0, 3, 8, 12, 22], 3) == 3 assert ternary_search([5], 5) == 0 assert ternary_search([5], 10) == -1 ``` # Note Handle edge cases such as: * Empty array. * Array containing a single element. * Array with all elements same but not equal to the target.","solution":"from typing import List def ternary_search(arr: List[int], target: int) -> int: Perform a ternary search to find the index of `target` in `arr`. Returns the index of the `target` if found, otherwise returns -1. def search(low, high): if low > high: return -1 third = (high - low) // 3 mid1 = low + third mid2 = high - third if arr[mid1] == target: return mid1 if arr[mid2] == target: return mid2 if target < arr[mid1]: return search(low, mid1 - 1) elif target > arr[mid2]: return search(mid2 + 1, high) else: return search(mid1 + 1, mid2 - 1) return search(0, len(arr) - 1)"},{"question":"# Scenario You are working for a startup that specializes in network infrastructure. To optimize the cost of laying down cables between various network nodes, your team needs to use an efficient algorithm to find the Minimum Spanning Tree (MST) of the network graph. # Task Implement a function `find_minimum_spanning_tree(vertex_count, edge_list)` using Kruskal\'s Algorithm. Your function should take the number of vertices and a list of edges, where each edge is represented as a tuple (source, target, weight). Your task is to return the total weight of the MST for the network. # Input - `vertex_count` (int): The number of vertices in the graph. - `edge_list` (list of tuples): Each tuple contains three integers (source, target, weight) representing an edge between `source` and `target` with the given `weight`. # Output - (int): The total weight of the MST. # Constraints - 1 <= `vertex_count` <= 1000 - 0 <= `len(edge_list)` <= 100000 - Each edge weight is a positive integer. # Example Input ```python vertex_count = 5 edge_list = [ (0, 1, 3), (0, 2, 8), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 6) ] ``` Output ```python 14 ``` Explanation The MST includes the edges (2, 3, 2), (0, 1, 3), (2, 4, 4), and (1, 3, 5) with a total weight of 14. # Note - Ensure your solution achieves optimal performance by efficiently managing the union and find operations in the disjoint set. - Handle edge cases, such as graphs with no edges and self-loops.","solution":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def find_minimum_spanning_tree(vertex_count, edge_list): Using Kruskal\'s algorithm to find the weight of the minimum spanning tree. Parameters: - vertex_count: int - Number of vertices - edge_list: List[tuples] - List of edges represented as (source, target, weight) Returns: - int: Total weight of the minimum spanning tree # Sort the edges by their weight edge_list.sort(key=lambda x: x[2]) dsu = DisjointSet(vertex_count) mst_weight = 0 edges_used = 0 for edge in edge_list: u, v, weight = edge if dsu.find(u) != dsu.find(v): dsu.union(u, v) mst_weight += weight edges_used += 1 if edges_used == vertex_count - 1: break return mst_weight"},{"question":"In the evaluation software for network protocols, a key feature is converting integers between different byte order conventions and vice versa. Given the importance of this in real-time data processing systems, your task is to write such conversion functions. Task: Implement these conversion functions as described: 1. **big_endian_to_little_endian(num_bytes: bytes) -> bytes**: * Converts a given byte string from big-endian to little-endian format. * Input: `num_bytes` - a byte string in big-endian. * Output: a byte string in little-endian. 2. **little_endian_to_big_endian(num_bytes: bytes) -> bytes**: * Converts a given byte string from little-endian to big-endian format. * Input: `num_bytes` - a byte string in little-endian. * Output: a byte string in big-endian. 3. **int_to_bytes(num: int, endian: str=\'big\') -> bytes**: * Converts an integer to bytes based on the specified endianness. * Inputs: - `num`: an integer to convert. - `endian`: a string specifying the endianness (\'big\' or \'little\'). Defaults to \'big\'. * Output: a byte string representing the integer in the specified endianness. 4. **bytes_to_int(num_bytes: bytes, endian: str=\'big\') -> int**: * Converts a byte string to an integer based on the specified endianness. * Inputs: - `num_bytes`: a byte string to convert. - `endian`: a string specifying the endianness (\'big\' or \'little\'). Defaults to \'big\'. * Output: an integer representing the byte string in the specified endianness. # Constraints: * You may assume that the input integers are non-negative. * Byte strings will have at least 1 byte. * The integer values and byte strings will fit within typical memory limits. # Example: ```python # Example conversions: print(big_endian_to_little_endian(b\'x00x01\')) # Output: b\'x01x00\' print(little_endian_to_big_endian(b\'x01x00\')) # Output: b\'x00x01\' print(int_to_bytes(1, \'little\')) # Output: b\'x01\' print(bytes_to_int(b\'x01x00\', \'little\')) # Output: 1 ``` Implement the functions to ensure they are optimal and handle edge cases appropriately.","solution":"def big_endian_to_little_endian(num_bytes: bytes) -> bytes: Converts a given byte string from big-endian to little-endian format. return num_bytes[::-1] def little_endian_to_big_endian(num_bytes: bytes) -> bytes: Converts a given byte string from little-endian to big-endian format. return num_bytes[::-1] def int_to_bytes(num: int, endian: str=\'big\') -> bytes: Converts an integer to bytes based on the specified endianness. length = (num.bit_length() + 7) // 8 # number of bytes needed return num.to_bytes(length, endian) def bytes_to_int(num_bytes: bytes, endian: str=\'big\') -> int: Converts a byte string to an integer based on the specified endianness. return int.from_bytes(num_bytes, endian)"},{"question":"Scenario: You are tasked with implementing a robust self-balancing AVL Tree to manage a dynamic set of integer keys efficiently. Your implementation will be expected to handle insertions while maintaining the balance of the tree. Requirements: Implement the AVL Tree class with the following methods: - `insert(key: int) -> None`: Inserts an integer key into the AVL tree ensuring it remains balanced. - `in_order_traverse() -> List[int]`: Returns a list of all keys in the tree in in-order traversal order. - `get_balance_factor() -> int`: Returns the balance factor of the root node. If the tree is empty, return 0. **Constraints**: 1. The keys are unique positive integers. 2. Expect no more than `10^5` insertions. Input: - Series of integers to be inserted into the AVL Tree. Output: - The in-order traversal of the AVL tree after all insertions, and the balance factor of the root node. Example: Test Case 1: ```python avl = AvlTree() keys = [10, 20, 30, 40, 50, 25] for key in keys: avl.insert(key) print(avl.in_order_traverse()) # Expected Output: [10, 20, 25, 30, 40, 50] print(avl.get_balance_factor()) # Expected Output: 0 or another valid balance factor indicating a balanced tree ``` Test Case 2: ```python avl = AvlTree() keys = [5, 6, 3, 2, 4, 7] for key in keys: avl.insert(key) print(avl.in_order_traverse()) # Expected Output: [2, 3, 4, 5, 6, 7] print(avl.get_balance_factor()) # Expected Output: 0 or another valid balance factor indicating a balanced tree ``` Make sure your solution efficiently handles the updates to heights and balance factors, ensuring the AVL tree\'s properties are maintained after each insertion.","solution":"class AvlNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def insert(self, root, key): if not root: return AvlNode(key) elif key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, root): if not root: return 0 return root.height def get_balance(self, root): if not root: return 0 return self.get_height(root.left) - self.get_height(root.right) def in_order_traverse(self, root): result = [] self._in_order_traverse_helper(root, result) return result def _in_order_traverse_helper(self, root, result): if not root: return self._in_order_traverse_helper(root.left, result) result.append(root.key) self._in_order_traverse_helper(root.right, result) def get_balance_factor(self, root): return self.get_balance(root) # Interface for the AVL Tree class AvlTreeInterface: def __init__(self): self.tree = None self.avl = AvlTree() def insert(self, key): self.tree = self.avl.insert(self.tree, key) def in_order_traverse(self): return self.avl.in_order_traverse(self.tree) def get_balance_factor(self): return self.avl.get_balance_factor(self.tree)"},{"question":"# Problem: Topological Sort for Task Ordering **Context**: You\'ve been tasked with creating a schedule for project tasks. Each task may depend on other tasks being completed first. You will use topological sorting to determine a valid order of execution for the tasks. **Task**: Implement a function `topological_sort(graph: DirectedGraph) -> List[str]` that accepts a directed acyclic graph (DAG) represented by the `DirectedGraph` class provided. The function should return a list of node names in topologically sorted order. Function Signature: ```python from typing import List def topological_sort(graph: DirectedGraph) -> List[str]: pass ``` Input: - `graph`: An instance of `DirectedGraph` containing nodes and edges. The graph is assumed to be acyclic. Output: - A list of node names sorted in topological order. Constraints: - All node names are unique. - The graph has no cycles. - The graph may have multiple valid topological ordering. Example: ```python # Given the graph: # A -> B # A -> C # B -> D # C -> D graph_data = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } graph = DirectedGraph(graph_data) print(topological_sort(graph)) # Output could be [\'A\', \'B\', \'C\', \'D\'] or [\'A\', \'C\', \'B\', \'D\'] ``` Notes: - Ensure that the function handles all edge cases, such as nodes with no incoming or outgoing edges. - Do not assume the graph has a single connected component. - Aim for an efficient solution with time complexity O(V + E).","solution":"from typing import List, Dict class DirectedGraph: def __init__(self, graph_data: Dict[str, List[str]]): self.graph = graph_data def get_nodes(self): return list(self.graph.keys()) def get_neighbors(self, node: str): return self.graph.get(node, []) def topological_sort(graph: DirectedGraph) -> List[str]: from collections import deque, defaultdict in_degree = defaultdict(int) for node in graph.get_nodes(): in_degree[node] = 0 for node in graph.get_nodes(): for neighbor in graph.get_neighbors(node): in_degree[neighbor] += 1 queue = deque([node for node in in_degree if in_degree[node] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in graph.get_neighbors(node): in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(topological_order) == len(in_degree): return topological_order else: raise Exception(\\"Graph contains a cycle\\") # Example usage: # graph_data = { # \'A\': [\'B\', \'C\'], # \'B\': [\'D\'], # \'C\': [\'D\'], # \'D\': [] # } # graph = DirectedGraph(graph_data) # print(topological_sort(graph)) # Output could be [\'A\', \'B\', \'C\', \'D\'] or [\'A\', \'C\', \'B\', \'D\']"},{"question":"# Problem Description You are given `k` sorted linked lists, each representing a sequence of integers. Your task is to merge all the lists into one sorted linked list and return its head. Function Signature ```python def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode] ``` Input * `lists`: List of `k` linked lists (each list head is of type `ListNode`). The number of lists `k` can be up to `10^4`, and the total number of nodes across all lists can be up to `2 * 10^4`. Output * Return the head of the merged and sorted linked list. Constraints * Each linked list is already sorted in ascending order. * The length of each linked list is between 0 and 500. * The values of the list nodes range from `-10^4` to `10^4`. Performance Requirements * Your solution needs to handle the merging efficiently with time complexity `O(N log k)` and space complexity `O(k)`. # Scenario Consider a situation where you work with several sorted logs from different servers. Each server stores its log entries in chronological order. To perform an overall analysis, you need to merge these logs into a single sorted sequence. Example ```python # List 1: 1 -> 4 -> 5 # List 2: 1 -> 3 -> 4 # List 3: 2 -> 6 # Merge result: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 # instantiation of lists is assumed lists = [List1_head, List2_head, List3_head] result = merge_k_lists(lists) # expected output: single linked list starting with 1 -> 1 -> 2 -> ... ``` Notes * Focus on handling edge cases such as empty lists or lists containing duplicate values. * Optimize your algorithm to take advantage of priority queues to achieve the desired time complexity.","solution":"import heapq from typing import List, Optional class ListNode: def __init__(self, x=0, next=None): self.val = x self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap for i in range(len(lists)): if lists[i]: heapq.heappush(min_heap, (lists[i].val, i, lists[i])) # Dummy node to help with the merged result list dummy = ListNode() current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"Implement a Max-Heap **Scenario**: You are given an abstract class `AbstractHeap` and a concrete class `BinaryHeap` implementing a min-heap as described in the provided code snippet. We would like you to extend this implementation to create a max-heap, which works similarly but maintains the maximum element at the root. **Task**: Write a class `MaxHeap` that extends `AbstractHeap` and manages a max-heap. You must implement the methods `insert`, `remove_max`, `perc_up`, and `perc_down` to ensure the heap properties are maintained. **Specifications**: - **insert(val)**: Insert a new element into the heap. - **remove_max()**: Remove and return the maximum element from the heap. - **perc_up(i)**: Helper method to maintain the heap property by moving elements up. - **perc_down(i)**: Helper method to maintain the heap property by moving elements down. **Input Format**: - `insert(val)` will be called with an integer `val` to be inserted into the max-heap. - `remove_max()` will be called without arguments and will return the maximum element from the heap. **Output Format**: - `insert(val)` will return nothing. - `remove_max()` will return the maximum element from the heap. **Constraints**: - You may assume that `insert` and `remove_max` will be called alternately and at least one `insert` will precede any `remove_max`. **Example**: ```python heap = MaxHeap() heap.insert(10) heap.insert(4) heap.insert(15) heap.insert(20) print(heap.remove_max()) # Output: 20 print(heap.remove_max()) # Output: 15 heap.insert(5) print(heap.remove_max()) # Output: 10 ```","solution":"class MaxHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self.perc_up(len(self.heap) - 1) def remove_max(self): if len(self.heap) == 0: return None max_val = self.heap[0] self.heap[0] = self.heap[-1] self.heap.pop() if len(self.heap) > 0: self.perc_down(0) return max_val def perc_up(self, i): parent = (i - 1) // 2 while i > 0 and self.heap[i] > self.heap[parent]: self.heap[i], self.heap[parent] = self.heap[parent], self.heap[i] i = parent parent = (i - 1) // 2 def perc_down(self, i): while (2 * i + 1) < len(self.heap): max_child = self.get_max_child(i) if self.heap[i] < self.heap[max_child]: self.heap[i], self.heap[max_child] = self.heap[max_child], self.heap[i] i = max_child def get_max_child(self, i): if (2 * i + 2) >= len(self.heap): return 2 * i + 1 else: if self.heap[2 * i + 1] > self.heap[2 * i + 2]: return 2 * i + 1 else: return 2 * i + 2"},{"question":"Bipartite Graph Verification You are given a graph represented as an adjacency matrix. Implement a function `is_bipartite(adj_matrix: List[List[int]]) -> bool` that determines if the given graph is bipartite. # Input - `adj_matrix` (List[List[int]]): A 2D list representing the adjacency matrix of a graph where `adj_matrix[i][j]` is 1 if there is an edge from vertex `i` to vertex `j`, otherwise it is 0. There are no parallel edges or multiple edges for simplicity. # Output - Return `True` if the graph is bipartite. - Return `False` otherwise. # Constraints - The number of vertices `V` in the graph is at most 100. - The graph does not contain parallel edges or multiple edges, but may contain self-loops which indicate the graph is not bipartite. # Example ```python assert is_bipartite([[0, 1, 0], [1, 0, 1], [0, 1, 0]]) == True assert is_bipartite([[0, 1, 1], [1, 0, 1], [1, 1, 0]]) == False assert is_bipartite([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]) == True ``` # Explanation of the Example 1. In the first example, a simple path without any odd-length cycle is a bipartite graph. 2. In the second example, the graph has a cycle of length 3 which cannot be divided into two sets. 3. In the third example, all vertices can be divided into two sets such that no two vertices in any set are adjacent. # Note Consider different edge cases while implementing including: self-loops within the graph, disconnected graphs, and vertices with varying degrees.","solution":"from typing import List from collections import deque def is_bipartite(adj_matrix: List[List[int]]) -> bool: Determines if a given graph represented by an adjacency matrix is bipartite. V = len(adj_matrix) if V == 0: return True # Colors array, -1 indicates uncolored colors = [-1] * V for start in range(V): if colors[start] == -1: # Start BFS from each node to handle disconnected components. queue = deque([start]) colors[start] = 0 # Start coloring the first node with color 0 while queue: node = queue.popleft() for neighbor in range(V): if adj_matrix[node][neighbor] == 1: if colors[neighbor] == -1: # If the neighbor hasn\'t been colored colors[neighbor] = 1 - colors[node] # Color with the opposite color queue.append(neighbor) elif colors[neighbor] == colors[node]: # If the neighbor has the same color return False return True"},{"question":"# Context A company is developing a predictive typing feature where, based on the last word typed by a user, the system suggests the next word. The predictive typing algorithm employs a Markov Chain model. You have been tasked to expand this functionality by allowing the system to generate a sequence of words based on an initial word. # Task Write a function `predictive_typing(chain: dict, start_state: str, num_predictions: int) -> list` that generates a sequence of states (words) using a provided Markov chain model, starting from a given initial word (state) and producing a specified number of predictions. # Input * `chain` (dict): A dictionary representing the Markov Chain. Keys are current states, and values are dictionaries of transition probabilities. * `start_state` (str): The initial state to start generating predictions from. * `num_predictions` (int): The number of predictions to generate. # Output * Return a list of predicted states (words) of length `num_predictions`. # Constraints * `num_predictions` is a positive integer. * `start_state` is always a valid state present in the Markov chain. * The transition probabilities for each state always sum to 1. # Example ```python chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } predictive_typing(chain, \'A\', 5) ``` # Expected Output: The function should return a list such as `[\'A\', \'A\', \'E\', \'A\', \'E\']`, but it can vary due to randomness in state transitions. # Requirements 1. Implement the helper function `__choose_state(state_map)` to randomly select the next state based on given probabilities. 2. Implement the function `next_state(chain, current_state)` that retrieves the next state using the `chain` and `current_state`. 3. Implement the function `predictive_typing`.","solution":"import random def __choose_state(state_map): Helper function that randomly selects the next state based on given probabilities. states = list(state_map.keys()) probabilities = list(state_map.values()) next_state = random.choices(states, probabilities)[0] return next_state def next_state(chain, current_state): Retrieves the next state using the chain and the current state. if current_state not in chain: raise ValueError(f\\"Current state \'{current_state}\' is not in the Markov chain.\\") next_state = __choose_state(chain[current_state]) return next_state def predictive_typing(chain, start_state, num_predictions): Generates a sequence of states using a Markov chain model. current_state = start_state predictions = [] for _ in range(num_predictions): next_state_result = next_state(chain, current_state) predictions.append(next_state_result) current_state = next_state_result return predictions"},{"question":"You are given an integer `n`, and you need to write a function to determine the number of digits in `n`. The function should adhere to the following guidelines: * **Input**: A single integer `n` which can be positive, negative, or zero. * **Output**: An integer representing the number of digits in the absolute value of `n`. # Function Signature: ```python def count_digits(n: int) -> int: pass ``` # Constraints: - The integer `n` will be in the range of -10^18 to 10^18. - The function should execute in constant time, O(1). # Example: ```python assert count_digits(12345) == 5 assert count_digits(-67890) == 5 assert count_digits(0) == 1 assert count_digits(10000000) == 8 ``` # Notes: - Use the `math` module to simplify the computation. - Handle edge cases where the number is zero or negative properly. # Performance Requirements: - Your solution should be optimized to run in constant time.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the absolute value of n. if n == 0: return 1 return len(str(abs(n)))"},{"question":"You are given a number, and you need to find the next higher number that has the exact same set of digits as the original number. If no higher number exists with the same set of digits, return -1. # Function Signature ```python def next_bigger(num: int) -> int: # Your implementation here ``` # Input - `num` (1 ≤ num ≤ 10^18): An integer number given as input. # Output - An integer representing the next higher number with the same set of digits, or -1 if no such number exists. # Constraints - The given number will always be a positive integer. - The number can have up to 18 digits. # Example ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(1528452) == 1528524 assert next_bigger(138654) == 143568 assert next_bigger(54321) == -1 assert next_bigger(999) == -1 assert next_bigger(5) == -1 ``` # Notes 1. Your solution should handle edge cases such as single-digit numbers and numbers with repetitive digits. 2. You should ensure optimal performance with a time complexity of O(n). # Hints 1. Use a list to store the digits of the number. Traverse the list from right to left to find the first pair of digits where the left digit is smaller than the right digit. 2. Find the smallest digit on the right side of the violation point that is larger than the violating digit. 3. Reverse the portion of the list that comes after the original violation point.","solution":"def next_bigger(num: int) -> int: num_str = list(str(num)) n = len(num_str) # Start from the end of the number and find the first pair where num_str[i] < num_str[i+1] i = n - 2 while i >= 0 and num_str[i] >= num_str[i + 1]: i -= 1 # If no such pair exists, return -1 if i == -1: return -1 # Find the smallest digit on the right side of num_str[i] that is larger than num_str[i] j = n - 1 while num_str[j] <= num_str[i]: j -= 1 # Swap them num_str[i], num_str[j] = num_str[j], num_str[i] # Reverse the digits to the right of \'i\' to get the next bigger number num_str = num_str[:i+1] + num_str[i+1:][::-1] return int(\'\'.join(num_str))"},{"question":"# Binary Tree Paths Problem Given a binary tree, your task is to write a function `binary_tree_paths` that returns all possible paths from the root node to the leaf nodes. Each path should be represented as a string with nodes separated by the arrow (`->`) symbol. Function Signature ```python def binary_tree_paths(root) -> list: ``` Input * `root`: The root node of a binary tree. Each node contains an integer value and pointers to left and right children. Output * A list of strings, where each string represents a path from the root to a leaf. Constraints * The number of nodes in the tree will be in the range `[0, 1000]`. * The value of each node will be in the range `[-1000, 1000]`. # Example ```python # Example 1 # Input: # 1 # / # 2 3 # # 5 # Output: [\\"1->2->5\\", \\"1->3\\"] # Example 2 # Input: # 1 # Output: [\\"1\\"] ``` # Notes * A leaf node is a node with no children. * Each path should be added to the output list only when a leaf node is reached. * You may use helper functions to traverse the tree. Please implement the function `binary_tree_paths` to solve the problem.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root) -> list: Given the root of a binary tree, return all root-to-leaf paths in the binary tree. Each path is represented as a string with the node values separated by \\"->\\". def build_paths(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # If it\'s a leaf node paths.append(path) # Store path else: path += \\"->\\" # Append arrow for non-leaf nodes build_paths(node.left, path, paths) build_paths(node.right, path, paths) paths = [] build_paths(root, \\"\\", paths) return paths"},{"question":"Implement the function `contain_string(haystack, needle)` that finds the index of the first occurrence of the string `needle` in another string `haystack`. If `needle` does not exist in `haystack`, return `-1`. If the `needle` is an empty string, return `0`. The function should abide by the following constraints and performance requirements. # Input & Output Format **Input**: - `haystack`: a non-empty string (`1 ≤ len(haystack) ≤ 10^4`). - `needle`: a string that may be empty (`0 ≤ len(needle) ≤ 10^3`). **Output**: - Returns an integer representing the starting index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`. # Constraints - You are not allowed to use built-in string finding methods (e.g., `str.find` or `strpos`). # Example ```python # Example 1 haystack = \\"hello\\" needle = \\"ll\\" Output: 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" Output: -1 # Example 3 haystack = \\"hello\\" needle = \\"\\" Output: 0 ``` # Performance Requirements - The function should have a time complexity of O((N-M+1) * M) or better, where N is the length of `haystack` and M is the length of `needle`. - The function\'s space complexity should be O(1). # Special Notes - Handle edge cases such as when `needle` is an empty string, or when `needle` is longer than `haystack`.","solution":"def contain_string(haystack, needle): Finds the first occurrence of needle in haystack. If needle is an empty string, returns 0. If needle is not found, returns -1. haystack_len = len(haystack) needle_len = len(needle) if needle_len == 0: return 0 if needle_len > haystack_len: return -1 for i in range(haystack_len - needle_len + 1): if haystack[i:i+needle_len] == needle: return i return -1"},{"question":"You are given a directed graph with a number of vertices and edges. Your task is to implement a function `check_strong_connectivity` to determine if the graph is strongly connected. A graph is said to be strongly connected if there is a path between any pair of vertices in both directions. # Input: - An integer `n` representing the number of vertices in the graph, where vertices are labeled from `0` to `n-1`. - An array of tuples `edges` where each tuple `(u, v)` represents an edge from vertex `u` to vertex `v`. # Output: - Return `True` if the graph is strongly connected, `False` otherwise. # Constraints: - The graph can have up to `1000` vertices and `5000` edges. - Graph edges are directed. # Example: ```python def check_strong_connectivity(n, edges): # Implementation here # Example 1 print(check_strong_connectivity(4, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 1)])) # True # Example 2 print(check_strong_connectivity(3, [(0, 1), (1, 2)])) # False ``` # Explanation: - In Example 1, starting from any node, you can reach any other node either directly or indirectly, and vice versa after reversing the graph, hence it\'s strongly connected. - In Example 2, node `2` is not reachable from node `0` (and vice versa), hence it\'s not strongly connected. Your task is to write the implementation of the `check_strong_connectivity` function by leveraging the algorithm details and insights provided.","solution":"from collections import defaultdict, deque def check_strong_connectivity(n, edges): def bfs(start, graph): visited = [False] * n queue = deque([start]) visited[start] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return visited if n == 0: return True # Create adjacency list for the graph and its reverse graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) # Perform BFS from any node, here node 0 reachable_from_start = bfs(0, graph) # Check if all nodes are reachable from the start node if not all(reachable_from_start): return False # Perform BFS in the reverse graph to check if all nodes can reach the start node reachable_in_reverse = bfs(0, reverse_graph) # Check if all nodes can reach the start node if not all(reachable_in_reverse): return False return True"},{"question":"Problem Statement You are tasked with implementing a function to calculate the binomial coefficient (C(n, k)), which represents the number of ways to choose `k` elements from a set of `n` elements. You must optimize the function to handle large values of `n` and `k` efficiently. Function Signature ```python def optimized_binomial_coefficient(n: int, k: int) -> int: ``` Input - `n`: An integer (1 ≤ n ≤ 1000) - `k`: An integer (0 ≤ k ≤ n) Output - Returns an integer representing (C(n, k)). Constraints - Utilize iterative computation to avoid deep recursion and stack overflow. - Apply memoization or dynamic programming to store and reuse intermediate results. - Consider symmetry property ( C(n, k) = C(n, n-k)) for optimization. Example ```python assert optimized_binomial_coefficient(5, 0) == 1 assert optimized_binomial_coefficient(8, 2) == 28 assert optimized_binomial_coefficient(10, 5) == 252 assert optimized_binomial_coefficient(12, 6) == 924 ``` Hints - Use a 2D array to store intermediate results. - Start building the solution from the base cases up to the desired values using nested loops.","solution":"def optimized_binomial_coefficient(n: int, k: int) -> int: This function computes the binomial coefficient C(n, k) using dynamic programming. # Utilize the property C(n, k) = C(n, n - k) if k > n - k: k = n - k # Create a table to store intermediate results C = [0] * (k + 1) C[0] = 1 # Base case: C(n, 0) = 1 for i in range(1, n + 1): # Compute next row of the Pascal\'s triangle using the previous row for j in range(min(i, k), 0, -1): C[j] += C[j - 1] return C[k]"},{"question":"# Subtree Check in Binary Trees Given two binary trees, `big_tree` and `small_tree`, determine if `small_tree` is a subtree of `big_tree`. A subtree of `big_tree` is defined as any node in `big_tree` and all of its descendants in `big_tree` that match exactly with `small_tree`. Input Format * The input will consist of the root nodes of two binary trees, `big_tree` and `small_tree`. * Both trees are represented using the `TreeNode` class defined below: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Function Signature ```python def is_subtree(big_tree: TreeNode, small_tree: TreeNode) -> bool: pass ``` Output Format Return `True` if `small_tree` is a subtree of `big_tree`, otherwise return `False`. Constraints * The number of nodes in both `big_tree` and `small_tree` will be in the range `[1, 10^4]`. * The value of each node will be within the range `[-10^5, 10^5]`. * Follow-up: Optimize your solution if one tree is significantly larger than the other. Examples Example 1: ```plaintext Input: big_tree = [3,4,5,1,2] small_tree = [4,1,2] Output: True ``` Example 2: ```plaintext Input: big_tree = [3,4,5,1,2,null,null,0] small_tree = [4,1,2] Output: False ``` # Notes - Assume that the tree nodes are given in level order traversal for ease of understanding. - If you don\'t have direct input/output format to handle, consider using a helper function to deserialize the input list into a binary tree. Background This question tests your knowledge of tree data structures and your ability to implement tree traversal and comparison algorithms efficiently. You will need to handle edge cases carefully and ensure your solution meets the performance requirements for larger inputs.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big_tree: TreeNode, small_tree: TreeNode) -> bool: if not small_tree: return True if not big_tree: return False if is_same_tree(big_tree, small_tree): return True return is_subtree(big_tree.left, small_tree) or is_subtree(big_tree.right, small_tree) def is_same_tree(s: TreeNode, t: TreeNode) -> bool: if not s and not t: return True if s and t and s.val == t.val: return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right) return False"},{"question":"# Question: Binary Tree Codec Implementation Given a binary tree, implement functions to convert the binary tree to a string representation and restore the binary tree from that string. Function Signatures: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: pass def deserialize(data: str) -> TreeNode: pass ``` Input: * For `serialize`: * `root`: The root node of a binary tree of type `TreeNode`. * For `deserialize`: * `data`: A string representing the serialized binary tree. Output: * For `serialize`: A `str` representing the serialized binary tree. * For `deserialize`: The root node of the deserialized binary tree. Constraints: * The binary tree will have at most 10,000 nodes. * Node values should be integers between `-1000` and `1000`. * Node values are guaranteed to be unique. # Examples: 1. **Serialize**: * Input: ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) ``` * Output: `\\"1 2 # # 3 # #\\"` 2. **Deserialize**: * Input: `\\"1 2 # # 3 # #\\"` * Output: A binary tree with root value `1`, left child with value `2`, and right child with value `3`. # Notes: * The deserialized tree should match the originally serialized tree. * You should handle edge cases like an empty tree, tree with a single node, etc. Attempt to write code that efficiently performs the serialization and deserialization operations, ensuring it works within the provided constraints.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def preorder(node): if not node: return \\"#\\" return f\\"{node.val} {preorder(node.left)} {preorder(node.right)}\\" return preorder(root).strip() def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def build_tree(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = build_tree(nodes) node.right = build_tree(nodes) return node nodes = iter(data.split()) return build_tree(nodes)"},{"question":"**Problem Statement: Word Pattern Matching** You are tasked with writing a function `word_pattern` that checks if a given string `str` follows a specified pattern. Your function should ensure that there is a one-to-one correspondence between characters in the pattern and words in the string. # Function Signature ```python def word_pattern(pattern: str, str: str) -> bool: ``` # Input - `pattern`: A string containing only lowercase letters. - `str`: A string containing lowercase letters separated by a single space. # Output - Returns `True` if `str` follows the specified pattern. - Returns `False` otherwise. # Constraints - `pattern` contains only lowercase letters. - `str` contains only lowercase letters separated by a single space. # Requirements - Your solution must run in linear time, O(n), where n is the number of words in `str`. - It must also use linear space, O(n), where n is the number of distinct characters in the pattern and distinct words in `str`. # Examples - Example 1: ```python pattern = \\"abba\\" str = \\"dog cat cat dog\\" Output: True ``` - Example 2: ```python pattern = \\"abba\\" str = \\"dog cat cat fish\\" Output: False ``` - Example 3: ```python pattern = \\"aaaa\\" str = \\"dog cat cat dog\\" Output: False ``` - Example 4: ```python pattern = \\"abba\\" str = \\"dog dog dog dog\\" Output: False ``` # Detailed Description Given a pattern and a string `str`, determine if `str` follows the same pattern. For example, a pattern \\"abba\\" matched with a string \\"dog cat cat dog\\" should return `True`, as \'a\' maps to \'dog\' and \'b\' maps to \'cat\', and these mappings are consistent throughout. Make sure to handle the following: - Different lengths between `pattern` and the list of words in `str`. - Multiple characters in the pattern mapping to the same word. - Efficiently handle edge cases such as when the input strings are empty or when repeating characters map correctly.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: if word not in word_to_char: char_to_word[char] = word word_to_char[word] = char else: return False else: if char_to_word[char] != word: return False return True"},{"question":"Context In computer systems, some operations and data structures are optimized when they deal with sizes that are powers of two. For instance, many algorithms and data structures, such as hash tables, use arrays whose sizes are preferred to be powers of two for efficiency reasons. Task Write a function `is_power_of_two(n)` that determines if a given integer `n` is a power of two. Function Signature ```python def is_power_of_two(n: int) -> bool: Determine if the given integer is a power of two. :param n: An integer :return: True if n is a power of two, False otherwise ``` Input * **n** (integer): A single integer that needs to be evaluated ( `-2^31 <= n <= 2^31 - 1`). Output * **Return**: A boolean value - `True` if `n` is a power of two, `False` otherwise. Examples ```python assert is_power_of_two(1) == True # 2^0 = 1 assert is_power_of_two(16) == True # 2^4 = 16 assert is_power_of_two(18) == False # 18 is not a power of two assert is_power_of_two(-4) == False # Negative numbers cannot be power of two assert is_power_of_two(0) == False # 0 is not a power of two ``` Constraints * The function should handle edge cases including negative numbers and zero. * The solution should be optimized with a time complexity of O(1) and a space complexity of O(1).","solution":"def is_power_of_two(n: int) -> bool: Determine if the given integer is a power of two. :param n: An integer :return: True if n is a power of two, False otherwise if n <= 0: return False return (n & (n - 1)) == 0"},{"question":"# BST Iterator Implementation Challenge Given a binary search tree (BST), implement a class `BSTIterator` that supports the following operations in an efficient manner: 1. **`__init__(self, root: TreeNode)`:** Constructor which receives the root of the BST and initializes the iterator. 2. **`has_next(self) -> bool`:** Returns `True` if there are further nodes to be visited in ascending order, `False` otherwise. 3. **`next(self) -> int`:** Returns the next smallest element in the BST. # Constraints: * The number of nodes in the BST is in the range [0, 10^4]. * -10^5 <= Node.val <= 10^5 # Example: ```plaintext Input: [\\"BSTIterator\\", \\"next\\", \\"next\\", \\"has_next\\", \\"next\\", \\"has_next\\"] [[[7,3,15,null,null,9,20]], [], [], [], [], []] Output: [null, 3, 7, true, 9, true] Explanation: BSTIterator bstIterator = new BSTIterator([7,3,15,null,null,9,20]); bstIterator.next(); // return 3 bstIterator.next(); // return 7 bstIterator.has_next(); // return true bstIterator.next(); // return 9 bstIterator.has_next(); // return true ``` # Notes: 1. `next()` should return the elements in the ascending order, i.e., in-order traversal of the BST. 2. `has_next()` should return whether there are more elements available for traversal. 3. Consider edge-cases where the BST might be empty or contain only one element. Prepare your class implementation to handle the above scenario efficiently.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"# Jump Search Implementation Context You have been assigned a task to integrate an efficient searching mechanism in a large sorted dataset for a financial application. The dataset contains a list of transaction amounts, and you need to identify transactions of specific values promptly. Objective Implement the Jump Search algorithm to allow fast searching of target values within sorted arrays. Function Signature ```python def jump_search(arr: List[int], target: int) -> int: Perform a jump search on a sorted array to find the position of the target value. Parameters: - arr: List[int]: A sorted list of integers - target: int: The target value to search for Returns: - int: The index of the target value in the array, or -1 if the target is not present. ``` Input - `arr`: A list of integers where each element is sorted in non-decreasing order. (1 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9) - `target`: An integer representing the value to search for. (-10^9 ≤ target ≤ 10^9) Output - The function should return the index of the target value if found; otherwise, it should return -1. Constraints - The array `arr` is guaranteed to be sorted. - Aim to achieve a time complexity of O(√n). Example ```python # Example 1: arr = [1, 4, 7, 9, 15, 20, 25, 30, 35] target = 15 >>> print(jump_search(arr, target)) 4 # Example 2: arr = [1, 4, 7, 9, 15, 20, 25, 30, 35] target = 23 >>> print(jump_search(arr, target)) -1 # Example 3: arr = [2, 3, 5, 6, 8, 10, 12, 14] target = 3 >>> print(jump_search(arr, target)) 1 ``` Additional Notes - Ensure to handle edge cases such as an empty array or target value not being in the array. - Test with various sizes of arrays and target values to validate the performance and correctness of your implementation.","solution":"from math import sqrt from typing import List def jump_search(arr: List[int], target: int) -> int: Perform a jump search on a sorted array to find the position of the target value. Parameters: - arr: List[int]: A sorted list of integers - target: int: The target value to search for Returns: - int: The index of the target value in the array, or -1 if the target is not present. n = len(arr) if n == 0: return -1 # Calculate the optimal block size to be jumped step = int(sqrt(n)) # Finding the block where the element is present (if it is present) prev = 0 while arr[min(step, n)-1] < target: prev = step step += int(sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in the block beginning with prev. for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Path Simplification Challenge As a junior system administrator, you often work with Unix-style file paths, and need to ensure they are correctly normalized. To aid in this, write a Python function that simplifies given absolute Unix-style file paths to their canonical form. Implement the following function: ```python def simplify_path(path: str) -> str: # Your code here ``` Input: - A string `path` representing an absolute Unix-style path. Output: - A string representing the simplified canonical path. Constraints: - The input `path` is a valid Unix path. - `path` is an absolute path, thus it always starts with a \\"/\\". - The length of `path` does not exceed 3000 characters. Examples: 1. Given `path = \\"/home/\\"`, the function should return `\\"/home\\"`. 2. Given `path = \\"/a/./b/../../c/\\"`, the function should return `\\"/c\\"`. 3. Given `path = \\"/../\\"`, the function should return `\\"/\\"`. 4. Given `path = \\"/home//foo/\\"`, the function should return `\\"/home/foo\\"`. Remember to handle edge cases like: - Trailing slashes. - Extra dots and dot-dot directories. - Multiple consecutive slashes. Performance Requirements: - Your function should run in O(n) time complexity and use O(n) space complexity, where n is the length of the input path. Example: ```python print(simplify_path(\\"/home/\\")) # Output: \\"/home\\" print(simplify_path(\\"/../\\")) # Output: \\"/\\" print(simplify_path(\\"/home//foo/\\")) # Output: \\"/home/foo\\" print(simplify_path(\\"/a/./b/../../c/\\")) # Output: \\"/c\\" ``` Good luck! Assess your understanding of stack operations, string manipulation, and edge case handling.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style path to its canonical form. stack = [] components = path.split(\\"/\\") for component in components: if component == \\"\\" or component == \\".\\": continue elif component == \\"..\\": if stack: stack.pop() else: stack.append(component) return \\"/\\" + \\"/\\".join(stack)"},{"question":"# Coding Challenge: Implement Iterative Merge Sort Problem Statement: Implement an iterative version of the merge sort algorithm. The iterative approach uses a bottom-up methodology (non-recursive) to sort an array. This will help save space compared to the recursive method. Input: - An unsorted list of integers, `arr`, of length `n` where 1 ≤ n ≤ 10^5. Output: - A sorted list of integers in non-decreasing order. Constraints: - Space complexity should be optimized compared to the traditional recursive implementation (you can use O(n) extra space but not the recursion stack). - Your function must handle large arrays efficiently. Function Signature: ```python def iterative_merge_sort(arr: List[int]) -> List[int]: pass ``` Example: **Input:** ```python arr = [38, 27, 43, 3, 9, 82, 10] ``` **Output:** ```python [3, 9, 10, 27, 38, 43, 82] ``` Instructions: 1. Implement the `iterative_merge_sort` function following the bottom-up iterative approach. 2. Design a helper function if needed for merging steps. 3. Ensure your implementation passes the given example. 4. Consider all edge cases and performance constraints.","solution":"from typing import List def merge(arr: List[int], l: int, m: int, r: int): n1 = m - l + 1 n2 = r - m # Create temporary arrays L = arr[l:m+1] R = arr[m+1:r+1] i = 0 j = 0 k = l while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < n1: arr[k] = L[i] i += 1 k += 1 while j < n2: arr[k] = R[j] j += 1 k += 1 def iterative_merge_sort(arr: List[int]) -> List[int]: n = len(arr) curr_size = 1 while curr_size < n: left_start = 0 while left_start < n-1: mid = min(left_start + curr_size - 1, n-1) right_end = min(left_start + 2*curr_size - 1, n-1) merge(arr, left_start, mid, right_end) left_start += 2*curr_size curr_size = 2*curr_size return arr"},{"question":"# Word Storage and Search with Wildcards Context You are tasked with creating an efficient data structure that allows you to store words and search for them using patterns. In the search patterns, a \'.\' character can represent any letter. You will implement the `WordDictionary` class that supports adding words and searching for them efficiently. Description Implement a Python class `WordDictionary` with the following methods: 1. `addWord(self, word: str) -> None`: Adds a word to the data structure. 2. `search(self, word: str) -> bool`: Returns `True` if the word is in the data structure or if there is any string that matches the given pattern (with \'.\' as a wildcard), otherwise `False`. Requirements - The solution must be efficient for large datasets. - The search with \'.\' wildcard must handle multiple wildcards in various positions. Input - `addWord(\\"word\\")`: a string containing the word to be added. Words consist of lowercase English letters. - `search(\\"pattern\\")`: a string containing the pattern to be searched. Patterns consist of lowercase English letters and \'.\' as wildcards. Output - `addWord`: No return value. - `search`: Boolean indicating if the pattern matches any stored word. Constraints - The number of operations (add or search) would be up to `10^4`. - Words and patterns are limited to 50 characters. Example ```python wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") wd.addWord(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ```","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word: str) -> None: self.words.append(word) def search(self, word: str) -> bool: def matches(word, pattern): if len(word) != len(pattern): return False for w, p in zip(word, pattern): if p == \'.\': continue if w != p: return False return True for w in self.words: if matches(w, word): return True return False"},{"question":"# Graph Maximal Cliques Finder **Context**: You are given the task of analyzing social networks where communities are represented as graphs. In these graphs, each node represents a person, and an edge between two nodes indicates a direct relationship between the two people. One of the most insightful analyses is finding all the cliques, which are groups where every member knows every other member personally. **Problem Statement**: Given an undirected graph represented as an adjacency list, write a Python function to find all the maximal cliques in the graph. A maximal clique is a subset of vertices such that: 1. Every two distinct vertices are adjacent. 2. No additional vertices can be included in the subset without breaking the first condition. **Function Signature**: ```python def find_all_cliques(edges: dict) -> List[List[int]]: pass ``` **Input**: - edges: A dictionary where each key is a vertex, and the value is a set of connected vertices (e.g., `{\\"1\\": {\\"2\\", \\"3\\"}, \\"2\\": {\\"1\\", \\"3\\"}, \\"3\\": {\\"1\\", \\"2\\"}}`). **Output**: - Returns a list of lists, where each sublist represents a maximal clique of vertices. **Constraints**: - The graph can have up to 100 vertices. - The graph is undirected and may contain cycles. **Example**: ```python edges = { \\"1\\": {\\"2\\", \\"3\\"}, \\"2\\": {\\"1\\", \\"3\\"}, \\"3\\": {\\"1\\", \\"2\\", \\"4\\"}, \\"4\\": {\\"3\\"} } print(find_all_cliques(edges)) # Expected Output: [[1, 2, 3], [3, 4]] ``` **Performance Requirements**: - Aim to optimize your implementation to handle large graphs up to 100 vertices efficiently. **Provided Function for You**: You are equipped with the skeleton of the exact algorithm (Bron-Kerbosch) to start coding the solution.","solution":"from typing import List, Dict, Set def find_all_cliques(edges: Dict[str, Set[str]]) -> List[List[int]]: def bron_kerbosch(R, P, X): if not P and not X: cliques.append(R) while P: v = P.pop() bron_kerbosch(R.union({v}), P.intersection(edges[v]), X.intersection(edges[v])) X.add(v) cliques = [] vertices = set(edges.keys()) bron_kerbosch(set(), vertices, set()) return [list(clique) for clique in cliques]"},{"question":"Scenario: Analyzing Music Playlists You are tasked with designing a music playlist for a radio show. The show has specific segments of different musical themes, and you need to repeat certain theme segments until another theme merges perfectly as part of it. Given two segments, find the minimum number of times the first segment needs to be repeated so that the second segment becomes part of it. Problem Statement Write a function `repeat_string(A: str, B: str) -> int` that determines the minimum number of times a string `A` must be repeated such that `B` is a substring of the repeated string. If no such repetition is possible, the function should return `-1`. Input * `A`: a string (1 ≤ len(A) ≤ 10,000) * `B`: a string (1 ≤ len(B) ≤ 10,000) Output * An integer, representing the minimum number of repetitions of `A` needed for `B` to be a substring. Return `-1` if no such repetition can make `B` a substring. Constraints * The function should be optimized to handle upper limits of input sizes. * Performance should be considered, and solutions should avoid excessive memory usage. Example ```python assert repeat_string(\\"abcd\\", \\"cdabcdab\\") == 3 assert repeat_string(\\"a\\", \\"aa\\") == 2 assert repeat_string(\\"abc\\", \\"ac\\") == -1 assert repeat_string(\\"abc\\", \\"cabcabca\\") == 4 ``` Testing 1. The function should handle edge cases where `A` equals `B`. 2. The function should handle cases where `B` is longer than `A`. 3. The function should efficiently handle large strings.","solution":"def repeat_string(A: str, B: str) -> int: Determines the minimum number of times a string A must be repeated such that B is a substring of the repeated string. na, nb = len(A), len(B) # If B is already a substring of A if B in A: return 1 # Calculate the minimum times A needs to be repeated to exceed the length of B min_repeats = (nb + na - 1) // na # Equivalent to ceil(nb / na) # Check if B can be a substring of the repeated string repeated_a = A * min_repeats if B in repeated_a: return min_repeats repeated_a += A if B in repeated_a: return min_repeats + 1 return -1"},{"question":"Write a function `is_isomorphic_advanced(s, t)` to determine if two strings `s` and `t` are isomorphic. Two strings are isomorphic if the characters in one string can be replaced to get the other string while preserving the character order. Each character in the original string must map to exactly one character in the other string, and no two characters can map to the same character, but a character may map to itself. Input: - Two strings, `s` and `t`, both with lengths between 0 and 10^4. Output: - Return `True` if the strings `s` and `t` are isomorphic. - Return `False` otherwise. Constraints: - The function should handle and return appropriate results for edge cases such as empty strings. - Ensure efficient use of space and time. Scenario: Imagine you\'re building a system that checks whether two encoding schemes are exactly the same in terms of character relationships. This function could be a critical component of such a system. Consider optimizing the function to handle large strings and avoid cases where multiple characters map to the same target. Examples: 1. Example 1: - Input: `s = \\"egg\\"`, `t = \\"add\\"` - Output: `True` 2. Example 2: - Input: `s = \\"foo\\"`, `t = \\"bar\\"` - Output: `False` 3. Example 3: - Input: `s = \\"paper\\"`, `t = \\"title\\"` - Output: `True`","solution":"def is_isomorphic_advanced(s, t): Determines if two strings s and t are isomorphic. if len(s) != len(t): return False mapping_s_t = {} mapping_t_s = {} for char_s, char_t in zip(s, t): if (char_s in mapping_s_t and mapping_s_t[char_s] != char_t) or (char_t in mapping_t_s and mapping_t_s[char_t] != char_s): return False mapping_s_t[char_s] = char_t mapping_t_s[char_t] = char_s return True"},{"question":"# Subset Generation (High-Performance Version) Context Given a set of distinct integers, students are required to generate all possible subsets of these integers. The problem demands an efficient solution, especially for larger input sizes. Task Write a Python function `optimized_subsets(nums: List[int]) -> List[List[int]]` that generates all possible subsets of the given list of distinct integers `nums`. Your implementation should strive for efficiency with respect to both time and space. Requirements 1. **Input Format**: A list of distinct integers `nums` (0 <= len(nums) <= 20), where each integer `num` satisfies -10 <= num <= 10. 2. **Output Format**: A list containing all possible subsets of the input list. Each subset should be represented as a list containing integers, and the order of subsets does not matter. 3. **Constraints**: * The returned result must contain no duplicate subsets. * Aim for optimal performance given the constraints on input size. Example ```python assert optimized_subsets([1, 2, 3]) == [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] assert optimized_subsets([0]) == [[], [0]] assert optimized_subsets([]) == [[]] ``` # Additional Requirements 1. **Performance Assessment**: Given the constraints, ensure the implementation is efficient and suitable for the given size limits. 2. **Edge Cases**: * Empty input list. * Single element input list.","solution":"from typing import List def optimized_subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of the given list of distinct integers. Args: nums: List[int] - A list of distinct integers Returns: List[List[int]] - A list containing all possible subsets of the input list. subsets = [[]] # Start with the empty subset for num in nums: # For each number, add it to all existing subsets to form new subsets new_subsets = [subset + [num] for subset in subsets] subsets.extend(new_subsets) return subsets"},{"question":"You are provided with a non-negative integer represented as a list of digits, where each element in the list corresponds to a single digit of the number in big-endian order (most significant digit first). Your task is to implement a function that increments this number by one and returns the resulting list of digits. Input: * A list of non-negative single digits `[d_0, d_1, ..., d_{n-1}]`, where `0 <= d_i <= 9` and the list is non-empty. Output: * A list of digits representing the incremented number. # Requirements: 1. The function should handle lists with multiple digits. 2. The function should manage transitions of carry-over correctly (e.g., incrementing 999 should result in 1000). # Constraints: * You must ensure the solution works within O(n) time complexity. * Modifications to input and in-place updating are allowed. * Consider edge cases including: * Single digit inputs such as [0], [9]. * Overflow handling where all digits are 9. # Function Signature ```python def plus_one(digits: List[int]) -> List[int]: ``` Example: ```python assert plus_one([1, 2, 3]) == [1, 2, 4] assert plus_one([9]) == [1, 0] assert plus_one([9, 9, 9]) == [1, 0, 0, 0] ``` You should implement and test the function based on the given specifications and constraints.","solution":"from typing import List def plus_one(digits: List[int]) -> List[int]: Increments the number represented by the list of digits by one and returns the resulting list of digits. # Start from the least significant digit (end of the list) and work backwards n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we have not returned from the loop, it means all digits were 9 return [1] + [0] * n"},{"question":"You have a large, sorted array and need to find the position of a specific target value within it. You decide to use the Jump Search algorithm because it provides an optimal balance between simplicity and performance for this scenario. # Objective Implement the `jump_search` function to locate the position of a given target value in a sorted array using the Jump Search algorithm. # Function Signature ```python def jump_search(arr: List[int], target: int) -> int: ``` # Input - `arr`: A list of `n` integers which are sorted in ascending order. - `target`: The integer value to search for in the array. # Output - Return the index of the target value in the array if found. - Return -1 if the target value is not found in the array. # Constraints - The array `arr` will always be sorted in non-decreasing order. - 1 <= len(arr) <= 10^6 - -10^9 <= arr[i], target <= 10^9 # Requirements - Implement the function to achieve a time complexity of O(√n). # Example ```python assert jump_search([1, 2, 5, 9, 15, 22, 30], 9) == 3 assert jump_search([3, 4, 7, 11, 25, 31], 6) == -1 assert jump_search([2, 5, 8, 12, 16, 23, 28, 36, 45], 23) == 5 ``` Note: Ensure your solution handles edge cases where the target is at the beginning, middle, end, or not in the array at all.","solution":"from math import sqrt from typing import List def jump_search(arr: List[int], target: int) -> int: Perform a Jump Search to find the position of `target` in the sorted array `arr`. :param arr: List of sorted integers :param target: Integer value to search for :return: Index of `target` in `arr` if found, else -1 n = len(arr) step = int(sqrt(n)) # Finding the block where the target may reside prev = 0 while arr[min(step, n)-1] < target: prev = step step += int(sqrt(n)) if prev >= n: return -1 # Linear search within the block for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"K-th Smallest Element in a Binary Search Tree Context You are given a Binary Search Tree (BST), and you need to find the k-th smallest element in this BST. Due to the inherent properties of a BST, an inorder traversal will yield the elements in ascending order. You will leverage this to efficiently find the k-th smallest element. Task Implement a function `kth_smallest` to find the k-th smallest element in a given BST. Function Signature ```python def kth_smallest(root: Node, k: int) -> int: pass ``` Input * `root`: The root node of the BST. It will be an instance of the `Node` class. * `k`: A positive integer representing the k-th smallest element to find. Output * Returns the value of the k-th smallest element in the BST. Constraints 1. The BST will have at least one node. 2. The value of k will always be valid and in the range from 1 to the total number of nodes in the BST. 3. All node values in the BST are unique. Performance Requirements * Ensure the solution has an average time complexity of O(n) and a space complexity of O(h). Example ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right # Construct the following BST: # 20 # / # 10 30 # / / # 5 15 25 35 root = Node(20) root.left = Node(10, Node(5), Node(15)) root.right = Node(30, Node(25), Node(35)) print(kth_smallest(root, 3)) # Output: 15 ``` Hints 1. Perform an inorder traversal to access the elements in sorted order. 2. Either use a stack to achieve an iterative solution or recursion to achieve a recursive solution.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: Node, k: int) -> int: Function to return the k-th smallest element in a BST. def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) generator = inorder(root) for _ in range(k): result = next(generator) return result"},{"question":"# Binary Tree Strahler Number Calculation Given the `TreeNode` class and the functions `serialize` and `deserialize`, your task is to extend these functionalities. Specifically, you need to implement the function `compute_strahler_number` that computes the Strahler number of a binary tree. The Strahler number is a measure of the complexity of branching in the tree, used traditionally in hydrology for river networks but applicable to binary trees as well. Definition: 1. The Strahler number of a leaf node is 1. 2. The Strahler number of an internal node depends on the Strahler numbers of its children: * If a node has no children, its Strahler number is 0 (i.e., it\'s an empty tree). * If all children have different Strahler numbers, the Strahler number of the node is 1 + the highest Strahler number of its children. * If two or more children have the same highest Strahler number, the Strahler number of the node is 1 + that highest number. Example: * For a tree with nodes structured as follows: ``` 4 / 2 5 / 1 3 ``` - The Strahler number of tree root (4) is 2. Input: * The function takes a single argument `root: TreeNode`. Output: * Returns an integer representing the Strahler number of the tree. Constraints: * Implement a recursive solution. * You can assume the `TreeNode` class and the previously given `serialize` and `deserialize` functions are defined in the same scope. # Function Signature: ```python def compute_strahler_number(root: TreeNode) -> int: pass ``` Example: ```python # Example Usage tree = TreeNode(4) tree.left = TreeNode(2) tree.right = TreeNode(5) tree.left.left = TreeNode(1) tree.left.right = TreeNode(3) # Serialize the tree serialized_tree = serialize(tree) # Deserialize the tree deserialized_tree = deserialize(serialized_tree) # Compute Strahler Number print(compute_strahler_number(deserialized_tree)) # Output should be 2 ``` You have to complete the function `compute_strahler_number`. Do not modify the given `TreeNode`, `serialize`, and `deserialize` implementations.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def compute_strahler_number(root: TreeNode) -> int: if not root: return 0 left_strahler = compute_strahler_number(root.left) right_strahler = compute_strahler_number(root.right) if left_strahler == right_strahler: if left_strahler == 0: # This case is when both children are None, essentially root is a leaf node itself return 1 return left_strahler + 1 return max(left_strahler, right_strahler) # Assuming serialize and deserialize functions are provided def serialize(root): Encodes a tree to a single string. if not root: return \'null\' serialized = [str(root.val)] queue = [root] while queue: node = queue.pop(0) if node.left: serialized.append(str(node.left.val)) queue.append(node.left) else: serialized.append(\'null\') if node.right: serialized.append(str(node.right.val)) queue.append(node.right) else: serialized.append(\'null\') return \',\'.join(serialized) def deserialize(data): Decodes your encoded data to tree. if not data or data == \'null\': return None nodes = data.split(\',\') root = TreeNode(int(nodes[0])) queue = [root] index = 1 while queue and index < len(nodes): node = queue.pop(0) if nodes[index] != \'null\': node.left = TreeNode(int(nodes[index])) queue.append(node.left) index += 1 if nodes[index] != \'null\': node.right = TreeNode(int(nodes[index])) queue.append(node.right) index += 1 return root"},{"question":"# Histogram Construction You are given a list of integers which may be disordered and contain duplicates. Your task is to implement a function that computes the histogram of the input list. A histogram in this context is a dictionary where each key is an integer from the list, and the corresponding value is the frequency (number of occurrences) of that integer in the list. Function Signature ```python def compute_histogram(input_list: list) -> dict: ``` # Input * `input_list`: A list of integers with a length ranging from 0 to 10^5. The values of the integers are between -10^9 and 10^9. # Output * Returns a dictionary where the keys are integers from the input list, and the values are the frequency counts of these integers. # Constraints * The input list can be empty. * The elements of the list are hashable. # Performance Requirements * Time complexity should be linear, O(n), where n is the length of the input list. * Space complexity should be considered, especially for lists with many unique elements. # Examples ```python assert compute_histogram([3, 3, 2, 1]) == {1: 1, 2: 1, 3: 2} assert compute_histogram([2, 3, 5, 5, 5, 6, 4, 3, 7]) == {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} assert compute_histogram([]) == {} assert compute_histogram([7, 7, 7, 7]) == {7: 4} ``` # Instructions: 1. Implement the `compute_histogram` function described above. 2. Ensure your implementation handles edge cases like an empty list or lists with all identical values. 3. Validate your solution with the provided examples and consider additional test cases to cover possible edge scenarios.","solution":"def compute_histogram(input_list: list) -> dict: Computes the histogram of the input list, where the keys are the integers from the list, and the values are their frequency counts. histogram = {} for item in input_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Question: Matrix Inversion You are required to implement a function `invert_matrix` that inverts a given n x n matrix using linear algebra principles. Function Signature: ```python def invert_matrix(m: List[List[float]]) -> List[List[float]]: pass ``` Input: - `m`: A list of lists representing an n x n matrix where n >= 2. Output: - An n x n matrix representing the inverse of the given matrix `m`. Constraints: - The input matrix will be a square matrix (same number of rows and columns). - The input matrix will be invertible (i.e., determinant is non-zero). Requirements: 1. If the input matrix is not a valid square matrix, return `[[-1]]`. 2. If the matrix is not invertible, return `[[-4]]`. 3. The solution should handle edge cases and recursively compute determinants as necessary. Example: ```python # Example 1: matrix = [ [4, 7], [2, 6] ] invert_matrix(matrix) # Expected Output: [[0.6, -0.7], [-0.2, 0.4]] # Example 2: matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] invert_matrix(matrix) # Expected Output: [[-24, 18, 5], [20, -15, -4], [-5, 4, 1]] ``` Notes: - Avoid any external libraries for matrix operations. - Include handling and error messages for cases: - Matrix is not square: `Invalid matrix: array is not a matrix` - Matrix with determinant zero: `Invalid matrix: matrix is square, but singular (determinant = 0)` Focus your implementation to correctly identify and handle all cases, ensuring efficient and correct matrix inversion for given input constraints.","solution":"from typing import List def determinant(matrix: List[List[float]], n: int) -> float: if n == 1: return matrix[0][0] if n == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 sign = 1 for i in range(n): sub_matrix = [] for j in range(1, n): row = [] for k in range(n): if k != i: row.append(matrix[j][k]) sub_matrix.append(row) det += sign * matrix[0][i] * determinant(sub_matrix, n-1) sign = -sign return det def get_cofactor(matrix: List[List[float]], p: int, q: int, n: int) -> List[List[float]]: cofactor = [] for i in range(n): if i != p: row = [] for j in range(n): if j != q: row.append(matrix[i][j]) cofactor.append(row) return cofactor def adjoint(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) if n == 1: return [[1]] adj = [] for i in range(n): adj_row = [] for j in range(n): cofactor = get_cofactor(matrix, i, j, n) sign = (-1)**(i+j) adj_row.append(sign * determinant(cofactor, n-1)) adj.append(adj_row) adj = list(map(list, zip(*adj))) return adj def invert_matrix(m: List[List[float]]) -> List[List[float]]: n = len(m) if not all(len(row) == n for row in m): return [[-1]] det = determinant(m, n) if det == 0: return [[-4]] adj = adjoint(m) inverse = [] for row in adj: inv_row = [x / det for x in row] inverse.append(inv_row) return inverse"},{"question":"# Linked List Rotation Challenge Objective: Implement a function `rotate_right(head, k)` that rotates a given singly linked list to the right by `k` places. Scenario: Imagine you are tasked with adjusting the order of customer service requests in a circular schedule where the latest k requests must be attended early by shifting them to the beginning of the list. Function Specifications: * **Input**: * `head` - The head node of the singly linked list. * `k` - A non-negative integer denoting the number of places you need to rotate. * **Output**: * Return the new head of the rotated singly linked list. Constraints: * The number of nodes in the list is non-negative. * The value of each node\'s value will be within the range of a typical integer. * `k` will range from 0 to 10^9. Example: * Given `head = 1->2->3->4->5->NULL` and `k = 2`, the function should return `4->5->1->2->3->NULL`. Explanation: * Rotate the linked list to the right by 2 places: * The list becomes `4->5->1->2->3->NULL`. * Given `head = 0->1->2->NULL` and `k = 4`, the function should return `2->0->1->NULL`. Explanation: * Rotate the linked list to the right by 4 places: * Since the list length is 3, rotating by 4 is effectively rotating by 4%3 = 1, so the list becomes `2->0->1->NULL`. Notes: * Be sure to handle edge cases such as empty lists and where `k` is greater than the length of the linked list. Implementation: Use the template provided below: ```python # Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head, k): :type head: ListNode :type k: int :rtype: ListNode if not head or not head.next: return head # Compute the length of the list current = head length = 1 while current.next: current = current.next length += 1 # Make the list circular current.next = head # Compute the effective number of rotations needed k = k % length # Traverse to the new tail and break the circle for i in range(length - k): current = current.next new_head = current.next current.next = None return new_head ```","solution":"# Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None def rotate_right(head, k): Rotate the linked list to the right by k places if not head or not head.next: return head # Compute the length of the list current = head length = 1 while current.next: current = current.next length += 1 # Make the list circular current.next = head # Compute the effective number of rotations needed k = k % length # Traverse to the new tail and break the circle for i in range(length - k): current = current.next new_head = current.next current.next = None return new_head"},{"question":"Question Using the Sieve of Eratosthenes, write a function `count_primes` that returns the count of all prime numbers less than a given integer `n`. Your solution should incorporate optimizations to handle only odd numbers, as discussed in the provided snippet. # Function Signature ```python def count_primes(n: int) -> int: ``` # Input: * `n` (integer): The number up to which we want to count prime numbers. `1 <= n <= 10^6` # Output: * The number of prime numbers less than `n`. # Constraints: * The function should handle large input sizes efficiently. * Ensure the function raises a `ValueError` when `n` is less than or equal to 0. # Example ```python assert count_primes(10) == 4 # (2, 3, 5, 7) assert count_primes(20) == 8 # (2, 3, 5, 7, 11, 13, 17, 19) assert count_primes(1) == 0 assert count_primes(0) == ValueError(\\"\'n\' must be a positive integer.\\") ``` Use the provided Sieve of Eratosthenes optimization strategy which excludes even numbers to create your function. Ensure optimal performance for large values of `n`.","solution":"def count_primes(n: int) -> int: Returns the count of all prime numbers less than a given integer n using the Sieve of Eratosthenes. if n <= 0: raise ValueError(\\"\'n\' must be a positive integer.\\") if n <= 2: return 0 # Create a boolean array \\"is_prime[0:n]\\" and initialize all entries as True. # A value in is_prime will finally be False if that index is not a prime. is_prime = [True] * n is_prime[0] = is_prime[1] = False # 0 and 1 are not primes. p = 2 while p * p < n: # If is_prime[p] is not changed, then it is a prime if is_prime[p]: # Updating all multiples of p to false for i in range(p * p, n, p): is_prime[i] = False p += 1 # Count all true entries in is_prime array return sum(is_prime)"},{"question":"# Scenario: You have been tasked with implementing a basic hash table for a new in-memory caching system. The hash table should support operations to `put` new key-value pairs, `get` values by their keys, and `delete` key-value pairs. To handle collisions, you will use **separate chaining** where each bucket contains a linked list of entries. # Function Implementation: You are required to implement additional functionality to dynamically resize the hash table when the load factor exceeds a certain threshold (e.g., 0.75) to maintain efficient operation times. This involves rehashing all existing entries into a larger table. # Requirements: 1. Implement a `resize` method that rehashes all existing entries into a new table of double the current size. 2. Ensure that the `put`, `get`, and `delete` methods appropriately interact with the `resize` method to maintain consistent behavior. Implement the Following Method: ```python class SeparateChainingHashTable(object): # Existing methods... def resize(self): Resize the hash table and rehash all current entries. pass # implement this method def put(self, key, value): # Update this method to handle resizing pass # implement this method ``` Expected Input and Output: - **put(key, value)**: Adds a key-value pair to the hash table. - **get(key)**: Retrieves the value associated with a key. - **delete(key)**: Removes a key-value pair from the hash table. Constraints: - The initial size of the table can be assumed to be 11. - The load factor threshold for resizing is 0.75. # Example: ```python table = SeparateChainingHashTable() table.put(\'apple\', 1) table.put(\'banana\', 2) print(table.get(\'apple\')) # Output: 1 print(table.get(\'banana\')) # Output: 2 table.put(\'apple\', 3) print(table.get(\'apple\')) # Output: 3 table.del_(\'banana\') print(table.get(\'banana\')) # Output: None # Perform multiple insertions to trigger resizing for i in range(20): table.put(f\'key{i}\', i) print(len(table)) # Output should be 20 (if resizing is implemented correctly) ``` # Notes: - Ensure efficient handling of edge cases and resizing logic. - Include appropriate comments and documentation within your code.","solution":"class SeparateChainingHashTable: def __init__(self, initial_capacity=11): self.capacity = initial_capacity self.size = 0 self.threshold = 0.75 self.table = [[] for _ in range(self.capacity)] def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): index = self._hash(key) bucket = self.table[index] for pair in bucket: if pair[0] == key: pair[1] = value return bucket.append([key, value]) self.size += 1 if self.size / self.capacity > self.threshold: self.resize() def get(self, key): index = self._hash(key) bucket = self.table[index] for pair in bucket: if pair[0] == key: return pair[1] return None def del_(self, key): index = self._hash(key) bucket = self.table[index] for pair in bucket: if pair[0] == key: bucket.remove(pair) self.size -= 1 return def resize(self): new_capacity = self.capacity * 2 new_table = [[] for _ in range(new_capacity)] self.capacity = new_capacity for bucket in self.table: for key, value in bucket: index = hash(key) % new_capacity new_table[index].append([key, value]) self.table = new_table def __len__(self): return self.size"},{"question":"# Shell Sort Enhancement **Context**: You\'re given a list containing integers that need to be sorted. However, the performance of the current Shell Sort implementation is not satisfactory for larger inputs. Enhance the Shell Sort algorithm to use the Hibbard sequence for gap reduction to improve its efficiency. **Objective**: Implement an enhanced version of Shell Sort using the Hibbard sequence for gap reduction in the sorting process. **Function Signature**: ```python def enhanced_shell_sort(arr: list) -> list: pass ``` **Expected Input**: * A list of integers (`arr`) which can be of any length (including zero). **Expected Output**: * A sorted list of integers in ascending order. **Constraints**: * You must use the Hibbard sequence for determining the gaps. **Performance Requirements**: * The solution should be optimized for average and worst-case scenarios. **Examples**: 1. `enhanced_shell_sort([64, 34, 25, 12, 22, 11, 90])` should return `[11, 12, 22, 25, 34, 64, 90]` 2. `enhanced_shell_sort([1, 2, 3, 4, 5])` should return `[1, 2, 3, 4, 5]` 3. `enhanced_shell_sort([])` should return `[]` # Additional Information: The Hibbard sequence is defined by (2^k - 1) where k is a positive integer.","solution":"def enhanced_shell_sort(arr): Implement enhanced Shell Sort using Hibbard sequence for gap reduction. # Calculate the Hibbard sequence gaps n = len(arr) gaps = [] k = 1 while (2**k - 1) < n: gaps.append(2**k - 1) k += 1 gaps.reverse() # Start with the biggest gap # Shell sort using Hibbard sequence gaps for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Question: Implement a HashTable with Quadratic Probing Design and implement a `QuadraticHashTable` class that extends the basic `HashTable` provided. Unlike linear probing, quadratic probing uses a quadratic function to resolve collisions. Specifically, if a collision occurs at position `i`, the next probe position should be computed by `(i + j^2) % table_size` where `j` is the probe attempt number. **Instructions**: - Implement the `hash` function to use the quadratic probing technique. - Adjust the `put`, `get`, and `del_` methods to accommodate the quadratic probing mechanism. - Ensure that the `ResizableHashTable` class is also extended to handle resizing using quadratic probing. You should implement the following class: ```python class QuadraticHashTable(HashTable): def _rehash(self, old_hash, attempt): Quadratic probing to handle collisions. # Implement quadratic rehash formula pass def put(self, key, value): # Extend the original put method to use quadratic rehash pass def get(self, key): # Extend the original get method to use quadratic rehash pass def del_(self, key): # Extend the original del_ method to use quadratic rehash pass ``` **Constraints**: - Keys are guaranteed to be non-negative integers. - The hash table should be resized to twice its size when it becomes more than 2/3 full. - Use table sizes that are powers of 2 to ensure efficient modulus operations. **Input/Output Specifications**: - `put(key, value)`: Inserts or updates the value for the given key. - `get(key) -> value`: Retrieves the value associated with the given key. - `del_(key)`: Deletes the key-value pair for the given key. **Performance Requirements**: - Maintain average-case O(1) time complexity for the main operations. - Ensure that the hash table handles resizing efficiently. **Scenario**: Assume you have a database of user IDs and their associated data. Due to frequent updates and lookups, you need a fast and reliable data structure to manage this mapping efficiently. Your `QuadraticHashTable` should allow for dynamic resizing and efficient collision handling to maintain performance.","solution":"class QuadraticHashTable: def __init__(self, size=8): Initialize the hash table with a specific size. The default size is set to 8. self.size = size self.table = [None] * self.size self.count = 0 def _hash(self, key): return key % self.size def _rehash(self, old_hash, attempt): Quadratic probing to handle collisions. return (old_hash + attempt**2) % self.size def put(self, key, value): if self.count >= 2/3 * self.size: self._resize() hash_value = self._hash(key) attempt = 0 while self.table[hash_value] is not None and self.table[hash_value][0] != key: attempt += 1 hash_value = self._rehash(hash_value, attempt) if self.table[hash_value] is None: self.count += 1 self.table[hash_value] = (key, value) def get(self, key): hash_value = self._hash(key) attempt = 0 while self.table[hash_value] is not None: if self.table[hash_value][0] == key: return self.table[hash_value][1] attempt += 1 hash_value = self._rehash(hash_value, attempt) return None def del_(self, key): hash_value = self._hash(key) attempt = 0 while self.table[hash_value] is not None: if self.table[hash_value][0] == key: self.table[hash_value] = None self.count -= 1 return True attempt += 1 hash_value = self._rehash(hash_value, attempt) return False def _resize(self): old_table = self.table new_size = self.size * 2 self.table = [None] * new_size self.size = new_size self.count = 0 for item in old_table: if item is not None: key, value = item self.put(key, value)"},{"question":"# Question: Remove Consecutive Duplicates from a Linked List Scenario Given a singly linked list, duplicates may exist. You need to write a function to modify the linked list such that all duplicates are removed, using **O(N)** time complexity and **O(N)** space complexity. Additionally, implement the same functionality with **O(N^2)** time complexity but using only **O(1)** extra space. Input * `head`: The head node of a singly linked list. Output The modified linked list where all duplicate elements are removed. Constraints * The values in the linked list nodes are comparable (e.g., integers, strings). * The linked list can have a length of up to 100,000 nodes. Function Signature ```python def remove_dups(head: Node) -> None: # Implement your solution using an O(N) approach with O(N) space complexity def remove_dups_without_set(head: Node) -> None: # Implement your solution using an O(N^2) approach with O(1) space complexity ``` Example ```python class Node(): def __init__(self, val = None): self.val = val self.next = None def print_linked_list(head): results = [] while head: results.append(str(head.val)) head = head.next print(\\" -> \\".join(results)) # Creating example linked list # A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) # Expected Output: A -> B -> C -> D -> F -> G print_linked_list(a1) remove_dups_without_set(a1) # Expected Output (No change as it\'s already unique): A -> B -> C -> D -> F -> G print_linked_list(a1) ``` Notes * Ensure the head and all subsequent nodes are adjusted appropriately after duplicates removal. * Highlight considerations for edge cases during implementation.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: Remove duplicates from linked list using O(N) time complexity with O(N) space complexity. if not head: return seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: Remove duplicates from linked list using O(N^2) time complexity with O(1) space complexity. current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"**Scenario**: You are tasked with analyzing real-time data streams for a financial analytics software. To identify trends effectively, you need to compute the moving average of stock prices efficiently using a sliding window mechanism. Your job is to implement a class that can calculate the moving average of the last `n` values in the stream. **Function Implementation**: Write a class `MovingAverage` that contains: 1. An `__init__` method that initializes the data structure given an integer `size`. 2. A `next` method that accepts an integer `val`, adds it to the stream, and returns the current moving average. **Expected Input and Output**: - **Input**: - `__init__(self, size: int)`: initializes the object with the window size. - `next(self, val: int) -> float`: computes and returns the moving average of the last `n` elements in the stream after adding the new value. - **Output**: - The actual floating point value of the current moving average. **Constraints**: - The window size `size` will be at least 1. - The value `val` to be added will be an integer. **Example**: ```python from __future__ import division from collections import deque class MovingAverage(object): def __init__(self, size): Initialize your data structure here. :type size: int self.queue = deque(maxlen=size) self.total = 0 # Maintain a running total def next(self, val): :type val: int :rtype: float if len(self.queue) == self.queue.maxlen: self.total -= self.queue[0] self.queue.append(val) self.total += val return self.total / len(self.queue) # Example usage: if __name__ == \'__main__\': m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.67 print(m.next(5)) # Output: 6.0 ``` You need to ensure your implementation is efficient and handles edge cases optimally.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize your data structure here. :type size: int self.size = size self.queue = deque(maxlen=size) self.total = 0 def next(self, val: int) -> float: :type val: int :rtype: float if len(self.queue) == self.size: self.total -= self.queue[0] self.queue.append(val) self.total += val return self.total / len(self.queue)"},{"question":"Scenario: You are given a list of items sold in a store on a particular day. Your task is to analyze this list and create a frequency histogram that tells how many times each item was sold. This will help the store manager understand the popularity of the items. Objective: Write a function `create_sales_histogram(sales_list: list) -> dict` that takes a list of sold items and returns a dictionary where the keys are the items sold, and the values are the counts of how many times each item was sold. Constraints: 1. The items in the sales list can be any hashable type (e.g., integers, strings). 2. The input list can be empty; in such case, return an empty dictionary. 3. The function should have O(n) time complexity, where n is the number of elements in the input list. 4. Assume the sales list will not contain null values. Input: - A list of items sold, `sales_list`, of length n (0 ≤ n ≤ 10^6). Output: - A dictionary where each key is an item from the sales list, and each value is the count of that item\'s occurrences in the sales list. Example: ```python sales_list_1 = [\'apple\', \'banana\', \'apple\', \'apple\', \'banana\', \'cherry\'] # Output: {\'apple\': 3, \'banana\': 2, \'cherry\': 1} sales_list_2 = [3, 1, 2, 3, 2, 3] # Output: {3: 3, 1: 1, 2: 2} sales_list_3 = [] # Output: {} ``` ```python def create_sales_histogram(sales_list: list) -> dict: Create a sales histogram :param sales_list: list of sold items :return histogram: dict with item counts in sales_list histogram = {} for item in sales_list: histogram[item] = histogram.get(item, 0) + 1 return histogram ```","solution":"def create_sales_histogram(sales_list: list) -> dict: Create a sales histogram. :param sales_list: A list of sold items. :return: A dictionary with the count of each item in the sales list. histogram = {} for item in sales_list: histogram[item] = histogram.get(item, 0) + 1 return histogram"},{"question":"# Stooge Sort Detailed Implementation Scenario You are given a list of integers and are asked to sort it using the Stooge Sort algorithm, a highly inefficient but conceptually simple recursive sorting algorithm. As part of a theoretical exercise, you need to implement this algorithm and analyze its performance on different types of inputs. Problem Statement Write a function `stooge_sort(arr)` that sorts a list of integers using the Stooge Sort algorithm. The function should modify the array in-place and return the sorted array. Input and Output - **Input**: A list of integers `arr` of length `n`. - **Output**: The same list, sorted in non-decreasing order. Constraints - 1 ≤ n ≤ 10^4 (Keep in mind that stooge sort is highly inefficient for larger lists) - Each integer in the array has an absolute value ≤ 10^9 Requirements - Implement the Stooge Sort algorithm as described. - Ensure that your function handles edge cases such as an empty array and arrays with identical elements correctly. - Analyze its performance on different sizes of input and provide a brief discussion on when this algorithm might be used (if ever) in real-world scenarios. Example ```python def stooge_sort(arr): def stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h-l + 1 > 2: t = (h-l + 1) // 3 stoogesort(arr, l, h-t) stoogesort(arr, l+t, h) stoogesort(arr, l, h-t) stoogesort(arr, 0, len(arr) - 1) return arr # Example usage: array = [1, 3, 64, 5, 7, 8] print(stooge_sort(array)) # Output: [1, 3, 5, 7, 8, 64] ``` Discussion 1. **Edge Cases**: Test your implementation with an empty array, a single-element array, and an array of identical elements. 2. **Performance Analysis**: Provide a brief analysis of the performance of Stooge Sort on different sizes of input data and discuss alternatives. 3. **Use Cases**: Identify realistic scenarios (if any) where Stooge Sort might be applicable or beneficial.","solution":"def stooge_sort(arr): def stoogesort(arr, l, h): if l >= h: return if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h-l + 1 > 2: t = (h-l + 1) // 3 stoogesort(arr, l, h-t) stoogesort(arr, l+t, h) stoogesort(arr, l, h-t) stoogesort(arr, 0, len(arr) - 1) return arr"},{"question":"# Maximum Flow in a Network with Capacity Scaling In network theory, finding the maximum flow through a network is a common problem with applications in various domains, such as traffic flow management and data routing. In this problem, you will implement a more advanced version of the Ford-Fulkerson method that optimizes the search for augmenting paths using capacity scaling. # Input You will be given an `n x n` adjacency matrix where `adjacency_matrix[i][j]` represents the capacity of an edge from node `i` to node `j`. The source node is always node `0`, and the sink node is always node `n-1`. # Output Your function should return the maximum flow from the source to the sink. # Constraints * Each node can have a capacity between `0` and `1000`. * The number of nodes `n` will be in the range `2 <= n <= 1000`. * Ensure that the graph remains connected and there\'s a feasible path from source to sink in most of the test cases. # Performance Requirements * Time Complexity: Aim for an improved solution compared to the `O(Ef)` approach using BFS. * Space Complexity: O(V^2) due to storage requirements of the adjacency matrix. # Function Signature ```python def maximum_flow_capacity_scaling(adjacency_matrix): pass ``` # Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_flow_capacity_scaling(graph) == 23 ``` # Notes 1. Implement the capacity scaling version of Ford-Fulkerson, which orders augmenting paths by available capacity. 2. Make sure to include checks for common edge cases, such as no path from source to sink, and try to optimize for worst-case performance.","solution":"def bfs(residual_graph, source, sink, parent): Breadth-First Search that also stores the path in parent list. Returns True if there\'s a path from source to sink. visited = [False] * len(residual_graph) queue = [source] visited[source] = True while queue: u = queue.pop(0) for ind, val in enumerate(residual_graph[u]): if not visited[ind] and val > 0: queue.append(ind) visited[ind] = True parent[ind] = u if ind == sink: return True return False def maximum_flow_capacity_scaling(adjacency_matrix): Computes the maximum flow in a network using capacity scaling version of Ford-Fulkerson method. n = len(adjacency_matrix) source = 0 sink = n - 1 # Create a residual graph and fill the residual graph with given capacities in the original graph as residual capacities. residual_graph = [[0] * n for _ in range(n)] for u in range(n): for v in range(n): residual_graph[u][v] = adjacency_matrix[u][v] max_flow = 0 # Calculate the maximum capacity in the graph to determine the initial delta value. max_capacity = max(max(row) for row in adjacency_matrix) delta = 1 while delta <= max_capacity: delta <<= 1 delta >>= 1 parent = [-1] * n # Capacity scaling loop while delta > 0: while bfs(residual_graph, source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] # Augment the flow along the path found by BFS v = sink while v != source: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow delta >>= 1 return max_flow"},{"question":"# Question Jump Search Algorithm Implementation Given a sorted array of integers and a target value, implement the Jump Search algorithm to efficiently find the index of the target value within the array. If the target values is not present in the array, return -1. Input: * A sorted list `arr` of integers where `1 <= len(arr) <= 10^6`. * An integer `target` to be searched in the sorted list where all integers in `arr` are in the range [-10^9, 10^9]. Output: * Return the index of the `target` value within the array or -1 if the element is not found. Example: ```python arr = [1, 2, 4, 5, 6, 8, 10, 12, 14, 18, 20] target = 14 # Output: 8 arr = [1, 2, 4, 5, 6, 8, 10, 12, 14, 18, 20] target = 7 # Output: -1 ``` Constraints: * Your implementation should be efficient with a time complexity of O(√n) in the worst case and space complexity of O(1). * Ensure robust handling of edge cases and invalid scenarios. Instructions: * Implement the function `jump_search(arr, target)` that returns the index of the `target` in the array or -1 if it does not exist. * You are not allowed to use any built-in search functions or libraries.","solution":"import math def jump_search(arr, target): n = len(arr) step = int(math.sqrt(n)) prev = 0 # Finding the block where the target is present (if it is present) while prev < n and arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target in block beginning with prev while prev < min(step, n): if arr[prev] == target: return prev prev += 1 return -1"},{"question":"# Question: Cocktail Shaker Sort Implementation and Analysis You are required to implement the Cocktail Shaker Sort algorithm to sort an array of integers. Your implementation should follow the principles of the given algorithm but also include additional checks and optimizations. Requirements: 1. Implement the function `cocktail_shaker_sort(arr: List[int]) -> List[int]` that takes a list of integers and returns the list sorted in ascending order. 2. Ensure that your implementation includes an optimization to handle the case where the array is already sorted. Constraints * The input list can have up to 10,000 integers. * Each integer in the list is between -10,000 and 10,000. Expected Input and Output Formats * **Input**: A list of integers, e.g., `[3, 4, 1, 5, 2]` * **Output**: A sorted list of integers, e.g., `[1, 2, 3, 4, 5]` Scenario You have been hired to optimize a legacy application where Bubble Sort is currently being used. After thorough assessment, you decided that a bidirectional approach such as Cocktail Shaker Sort would provide a slight performance improvement on average. Implement this sorting algorithm, ensuring efficiency and stability. You are also required to detect edge cases effectively and optimize your code to avoid unnecessary operations. Sample Input/Output ```python # sample input arr = [3, 3, 2, 1, 4, 5] # sample output sorted_arr = [1, 2, 3, 3, 4, 5] ``` Additional Requirements * Write a test function `test_cocktail_shaker_sort()` to validate your implementation with multiple test cases including edge cases such as an already sorted array, arrays with duplicate values, and arrays of different sizes (including empty arrays and single-element arrays).","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Cocktail Shaker Sort algorithm. n = len(arr) if n <= 1: # An empty list or single-element list is already sorted return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the array from left to right as in Bubble Sort for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing moved, then array is sorted. if not swapped: break swapped = False end -= 1 # Traverse the array from right to left for i in range(end, start, -1): if arr[i - 1] > arr[i]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"Problem Context In certain ancient cultures, number properties were often used for determining luck or prophecy. One such property is the concept of a \\"Magic Number\\". A number is said to be a magic number if summing the digits of the number and then recursively repeating this process for the resultant sum until the number becomes a single-digit number equal to 1. For this task, you are provided a set of integer numbers, and you are required to determine which of these numbers are magic numbers. Task Implement a function `find_magic_numbers(numbers: List[int]) -> List[int]` which accepts a list of integers and returns a list of all magic numbers from the input list. Input - `numbers`: A list of integers (e.g., `[50113, 1234, 199, 111, 45]`). Output - A list of integers containing only the magic numbers from the input list. Constraints - The input list can contain up to 1000 numbers. - Each number can have a maximum of 18 digits. - Numbers can be positive or zero. Example ```python find_magic_numbers([50113, 1234, 199, 111, 45]) ``` Output: ```python [50113, 1234, 199] ``` Performance Requirements - The function should run efficiently within the given constraints. - Special cases (e.g., very large numbers, edge cases at the limits of the input constraints) should be managed appropriately. Notes - Ensure the function only processes integer inputs. - Avoid unnecessary recomputations to ensure optimal performance. - Optimize your code to handle edge scenarios gracefully without running into performance bottlenecks. Additional Context - A single-digit number can only be a magic number if it is `1`.","solution":"def is_magic_number(n): Helper function to determine if a number is a magic number. while n >= 10: n = sum(int(digit) for digit in str(n)) return n == 1 def find_magic_numbers(numbers): Returns a list of magic numbers from the given list. return [number for number in numbers if is_magic_number(number)]"},{"question":"**Scenario**: You are working as a data analyst in a company that receives real-time data streams of transactions. Each transaction is represented as a pair where the first element is the transaction value and the second element is the transaction type (`+` for credit and `-` for debit). The challenge is to determine if these transactions, when completely processed, leave only a single unique non-zero transaction value (`1-sparse`). **Problem Statement**: Implement the function `one_sparse(array)`, which takes an array of tuples as input. Each tuple contains an integer value and a character (`+` or `-`). Your task is to determine if the stream is `1-sparse` and return the unique number if it is. If not, return `None`. **Function Signature**: ```python def one_sparse(array): # Implement your 1-sparse detection algorithm here ``` **Input Format**: * `array`: A list of tuples `[(value, sign), (value, sign), ...]`` - Each tuple contains: - `value`: An integer, representing the transaction value (0 <= value <= 2^31). - `sign`: A character, either `\'+\'` or `\'-\'`, representing the type of the transaction. **Output Format**: * An integer representing the unique remaining transaction value if the stream is `1-sparse`. * `None` if the stream is not `1-sparse`. **Constraints**: * All values in the stream are non-negative integers. * The length of the array will not exceed 10^6. **Requirements**: Ensure your solution\'s time complexity is O(N) and space complexity is O(1). **Examples**: ```python assert one_sparse([(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')]) == 4 assert one_sparse([(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')]) == 2 assert one_sparse([(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')]) == None assert one_sparse([(1,\'+\'), (1,\'-\')]) == None ``` **Note**: For simplicity, consider that the input stream will always have at least one transaction.","solution":"def one_sparse(array): Determines if the transaction stream is 1-sparse and returns the unique remaining transaction value if it is, otherwise returns None. balance = {} for value, sign in array: if sign == \'+\': if value in balance: balance[value] += 1 else: balance[value] = 1 elif sign == \'-\': if value in balance: balance[value] -= 1 if balance[value] == 0: del balance[value] else: balance[value] = -1 # Filter out values that have a zero count remaining_transactions = [value for value, count in balance.items() if count != 0] if len(remaining_transactions) == 1: return remaining_transactions[0] else: return None"},{"question":"You are to implement a function that multiplies two non-negative integers represented as strings, simulating manual long multiplication. This function should return the product as a string without using built-in high precision integer operations or converting the inputs directly to integers. # Function Signature ```python def multiply(num1: str, num2: str) -> str: pass ``` # Input * Two non-negative integers `num1` and `num2` are given as strings. * 1 ≤ len(num1), len(num2) ≤ 110, meaning each string\'s length is between 1 and 110. * Both num1 and num2 consist of digits only from \'0\' to \'9\'. * Both num1 and num2 do not contain any leading zeros. # Output * A string representing the product of `num1` and `num2`. # Examples 1. `multiply(\\"123\\", \\"456\\")` should return `\\"56088\\"`. 2. `multiply(\\"9\\", \\"99\\")` should return `\\"891\\"`. 3. `multiply(\\"0\\", \\"456\\")` should return `\\"0\\"`. # Constraints 1. You must not use any built-in BigInteger library or convert the inputs to integers directly. # Example Solution (Description) 1. Convert each character of the input strings to its digit using ASCII arithmetic. 2. Implement the elementary school method of multiplication (multiply each digit and accumulate the results). 3. Handle positional significance by maintaining track of units, tens, hundreds, etc. 4. Return the final accumulated sum as a string.","solution":"def multiply(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" # Initialize result list of zeros m, n = len(num1), len(num2) result = [0] * (m + n) # Reverse the strings to facilitate position multiplication num1, num2 = num1[::-1], num2[::-1] # Multiply each digit for i in range(m): for j in range(n): result[i + j] += int(num1[i]) * int(num2[j]) result[i + j + 1] += result[i + j] // 10 result[i + j] %= 10 # Remove leading zeroes while len(result) > 1 and result[-1] == 0: result.pop() # Convert result list back to string and reverse it result = result[::-1] return \'\'.join(map(str, result))"},{"question":"You are given a chain of matrices to multiply, and you need to determine the most efficient way to multiply these matrices together. The goal is to minimize the total number of scalar multiplications required. Implement the following functions: 1. `matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]`: This function should compute the minimum number of scalar multiplications needed and the optimal order to perform the multiplications. 2. `print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None`: This function should print the optimal parenthesization of the product. 3. **(Optional)** `main() -> None`: For testing purposes, implement this function to run the `matrix_chain_order` function with example input and print the results. Function Input and Output Formats - **matrix_chain_order** - **Input**: A list `p` of integers where the i-th matrix Ai has dimensions p[i-1] x p[i]. - **Output**: Returns two 2D lists, `matrix` and `sol`. `matrix[i][j]` will hold the minimum number of multiplications needed to compute the matrix Ai ... Aj, and `sol[i][j]` will hold the index k at which the optimal split occurs. - **print_optimal_solution** - **Input**: - `optimal_solution`: A 2D list (`sol` from the `matrix_chain_order` function). - `i, j`: The starting and ending indices of the subproblem. - **Output**: Prints the optimal order for parenthesization. # Constraints - You can assume the input size n will be ≤ 100. - All values in the list `p` will be positive integers. # Example ```python def main(): array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of multiplications is:\\", matrix[1][len(array)-1]) print(\\"The optimal order is:\\") print_optimal_solution(optimal_solution, 1, len(array)-1) if __name__ == \'__main__\': main() ``` # Explanation of Example Given matrices with dimensions 30x35, 35x15, 15x5, 5x10, 10x20, and 20x25, the function will output the minimum number of multiplications and the optimal order to achieve this.","solution":"from typing import List, Tuple def matrix_chain_order(p: List[int]) -> Tuple[List[List[int]], List[List[int]]]: n = len(p) - 1 matrix = [[0 for _ in range(n + 1)] for _ in range(n + 1)] sol = [[0 for _ in range(n + 1)] for _ in range(n + 1)] for length in range(2, n + 1): # length is the chain length for i in range(1, n - length + 2): j = i + length - 1 matrix[i][j] = float(\'inf\') for k in range(i, j): q = matrix[i][k] + matrix[k + 1][j] + p[i - 1] * p[k] * p[j] if q < matrix[i][j]: matrix[i][j] = q sol[i][j] = k return matrix, sol def print_optimal_solution(optimal_solution: List[List[int]], i: int, j: int) -> None: if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(optimal_solution, i, optimal_solution[i][j]) print_optimal_solution(optimal_solution, optimal_solution[i][j] + 1, j) print(\\")\\", end=\\"\\")"},{"question":"# **Question: Implement a Modified Sorting Algorithm** **Scenario**: You are working at a data processing company, and you are given a task to sort small or nearly sorted datasets efficiently. Due to the nature of the incoming data, simpler algorithms like Insertion Sort or Gnome Sort could be quite effective. However, considering the quadratic time complexity of Gnome Sort in the worst case, you need to adjust your method slightly. **Task**: Write a function `modified_gnome_sort` to sort an array of integers in non-decreasing order. Your function is expected to perform well on datasets that are already nearly sorted and be efficient even on larger unsorted datasets. # Function Signature ```python def modified_gnome_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr` (List[int]): An unsorted list of integers. # Output * (List[int]): The sorted list of integers in non-decreasing order. # Constraints 1. The input array can contain up to (10^4) elements. 2. Each integer in the array is in the range (-10^6) to (10^6). # Example ```python # Example 1: input_list = [3, 2, 5, 1, 4] print(modified_gnome_sort(input_list)) # Output: [1, 2, 3, 4, 5] # Example 2: input_list = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] print(modified_gnome_sort(input_list)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ``` # Performance Requirements While there is no strict time limit, your solution should be optimized to handle the constraints effectively and be significantly quicker on nearly sorted datasets compared to Gnome Sort. # Special Instructions Do not use built-in sorting functions or external libraries. Implement your sorting logic from scratch, using the principles observed in Gnome Sort with any necessary modifications to improve performance.","solution":"from typing import List def modified_gnome_sort(arr: List[int]) -> List[int]: This function sorts an array using a modified gnome sort algorithm which is efficient for nearly sorted arrays. n = len(arr) index = 0 while index < n: if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr"},{"question":"# Perfect Square and its Successor Problem Statement You are given an integer `n`. Your task is to determine if `n` is a perfect square. If it is, return the next perfect square in sequence. If it is not, return `-1`. A perfect square is an integer that is the square of an integer. For example, `1, 4, 9, 16...` are perfect squares. Function Signature Write a function `find_next_square(n: int) -> int` that fulfills the above requirements. Input * An integer `n` where `0 <= n <= 10^18`. Output * Return the next perfect square as an integer if input `n` is a perfect square. * Return `-1` if `n` is not a perfect square. Constraints * Ensure that calculations handle large inputs efficiently, especially for the upper constraint. Examples 1. Input: `n = 16` Output: `25` Explanation: `16` is a perfect square (4^2). The next perfect square is 5^2 = 25. 2. Input: `n = 20` Output: `-1` Explanation: `20` is not a perfect square. 3. Input: `n = 1` Output: `4` Explanation: `1` is a perfect square (1^2). The next perfect square is 2^2 = 4. 4. Input: `n = 0` Output: `1` Explanation: `0` is a perfect square (0^2). The next perfect square is 1^2 = 1. Notes * Carefully consider edge cases such as `0` and very large integers within the constraint range. * You may use any approach in Python to solve this problem, but take note of the efficiency of your solution.","solution":"import math def find_next_square(n: int) -> int: Determines if n is a perfect square. If it is, returns the next perfect square. Otherwise, returns -1. if n < 0: return -1 root = int(math.sqrt(n)) if root * root == n: return (root + 1) ** 2 else: return -1"},{"question":"# Priority Queue Problem Problem Statement You are required to implement a priority queue using a linear array as shown in the provided code snippet. However, instead of removing the element with the lowest priority, you are to modify the `pop` function such that it removes and returns the element with the highest priority. The insertion process should remain unchanged, i.e., it should insert elements in non-increasing order of priority. Function Signature ```python def pop(self): Remove and return the item with the highest priority. The rest of the class implementation remains unchanged. pass ``` Constraints: 1. The priority values are integers. 2. If two elements have the same priority, the element inserted first should come first. 3. The priority queue may contain up to (10^5) elements. Input & Output: * **Input**: * None directly. The priority queue\'s state will be modified by the `push` method and queried by the `pop` method. * **Output**: * The `pop` method should return the data part of the highest priority element and remove it from the queue. Example: ```python pq = PriorityQueue(items=[4, 5, 6], priorities=[1, 2, 3]) print(pq.pop()) # Return 6 (highest priority) print(pq.pop()) # Return 5 (next highest) pq.push(7, 2) print(pq.pop()) # Return 7 (highest priority) print(pq.pop()) # Return 4 (next highest) ``` Implementation Notes: * Consider edge cases where the queue is empty. * Ensure that the item with the highest priority is returned and removed from the list. * The `push` method should not be altered and should maintain the existing insertion logic.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): self.queue = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def push(self, item, priority): self.queue.append((item, priority)) self.queue.sort(key=lambda x: x[1], reverse=True) def pop(self): if not self.queue: raise IndexError(\\"pop from empty priority queue\\") return self.queue.pop(0)[0]"},{"question":"# Context Insertion Sort is a simple yet inefficient algorithm for sorting small lists. An efficient variant involves using binary search to find the correct position for insertion. You are required to implement this variant using the provided helper function `search_insert`. # Problem Write a function `binary_insertion_sort(arr)` that sorts a list of integers `arr` in ascending order. Function Definition ```python def binary_insertion_sort(arr: List[int]) -> List[int]: # Your implementation here ``` Input - `arr`: A list of integers with length `n` (0 <= n <= 10^5). Output - A new list containing the elements of `arr` sorted in ascending order. Constraints - You must use the provided `search_insert` function to determine the position for each insertion. - Your implementation should handle large inputs gracefully, avoiding performance degradation. Example ```python binary_insertion_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) # Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] binary_insertion_sort([7, 3, 9, 1, 0]) # Output: [0, 1, 3, 7, 9] ``` # Edge Cases - Handle empty input list. - Handle lists with duplicate values for thorough testing. # Core Focus This problem will test your understanding of: - Efficient searching in a sorted collection. - Enhancing traditional algorithms (Insertion Sort) with modern techniques (Binary Search). - Optimizing performance with given constraints.","solution":"from typing import List def search_insert(sorted_arr: List[int], value: int) -> int: Utility function to find the index at which `value` should be inserted in `sorted_arr` to keep it sorted. This uses binary search for efficiency. left, right = 0, len(sorted_arr) while left < right: mid = (left + right) // 2 if sorted_arr[mid] < value: left = mid + 1 else: right = mid return left def binary_insertion_sort(arr: List[int]) -> List[int]: Sorts the list of integers `arr` using the binary insertion sort method. if not arr: return [] sorted_arr = [] for value in arr: pos = search_insert(sorted_arr, value) sorted_arr.insert(pos, value) return sorted_arr"},{"question":"You have been provided with the implementation of the nearest neighbor algorithm, which classifies a given input vector based on the closest training data point. The Euclidean distance measure is used to determine the closeness of the input vector to each training point. **Your task is to extend the functionality to implement the k-Nearest Neighbors (k-NN) algorithm.** # Problem Definition Write a function `k_nearest_neighbors(x, tSet, k)` that classifies the input vector `x` by considering the `k` closest points in the training set `tSet`. Each point in the training set `tSet` is a tuple of feature values mapped to a class label. # Input - `x` (tuple): A vector representing the input data point to classify. - `tSet` (dict): A dictionary where each key is a tuple representing a training data point and each value is the corresponding class label. - `k` (int): The number of nearest neighbors to consider for classification. # Output - Return the most common class label among the `k` nearest neighbors. # Constraints - Assume `k` is always less than or equal to the number of points in the training set. - In case of a tie, return any one of the most common classes. # Example ```python training_set = { (2.0, 3.0): \'A\', (1.0, 1.0): \'B\', (1.5, 2.5): \'B\', (4.0, 4.0): \'A\', (3.0, 3.5): \'A\' } x = (1.0, 2.0) k = 2 print(k_nearest_neighbors(x, training_set, k)) # Output: \'B\' ``` # Implementation Details 1. Calculate the Euclidean distance from `x` to all points in `tSet`. 2. Identify the `k` points with the smallest distances. 3. Determine the most common label among these `k` points and return it. Implement the function `k_nearest_neighbors` following the definition above.","solution":"import math from collections import Counter def euclidean_distance(point1, point2): Calculate the Euclidean distance between two points. return math.sqrt(sum((a - b) ** 2 for a, b in zip(point1, point2))) def k_nearest_neighbors(x, tSet, k): Classify the input vector `x` by considering the `k` closest points in the training set `tSet`. Parameters: - x (tuple): Input vector to classify. - tSet (dict): Training set with data points as keys and class labels as values. - k (int): Number of nearest neighbors to consider. Returns: - The most common class label among the `k` nearest neighbors. # Calculate all distances and associate them with the corresponding labels distances = [(euclidean_distance(x, point), label) for point, label in tSet.items()] # Sort the distances distances.sort(key=lambda pair: pair[0]) # Get the labels of the k nearest neighbors nearest_labels = [label for _, label in distances[:k]] # Determine the most common label most_common_label = Counter(nearest_labels).most_common(1)[0][0] return most_common_label"},{"question":"# Quick Sort Assessment Task You are given the task of implementing an optimized version of the Quick Sort algorithm that addresses one of its key limitations. Students are required to handle arrays with duplicate elements efficiently, achieving better performance across a more variable input. Task Description: Implement the `quick_sort_optimized` function which sorts an array of integers using an improved pivot selection strategy to avoid worst-case performance. Ensure to handle arrays with duplicate values efficiently. Requirements: 1. An optimized pivot selection strategy should be used (e.g., median-of-three). 2. The algorithm should handle an array with duplicate values efficiently. 3. Your implementation should be in-place, i.e., it should not use any additional array. Function Signature: ```python def quick_sort_optimized(arr): pass ``` Input: * An array of integers `arr` to be sorted. (1 ≤ len(arr) ≤ 5*10^5). Output: * The function should return the array sorted in non-decreasing order. Example: ```python Input: [3, 6, 8, 10, 1, 2, 1] Output: [1, 1, 2, 3, 6, 8, 10] Input: [5, 3, 8, 4, 2, 7, 1, 10] Output: [1, 2, 3, 4, 5, 7, 8, 10] ``` Constraints: * You should not use any additional space for another array. * The algorithm should perform well even on large arrays up to 500,000 elements. * You should avoid recursion depth limits by optimizing your implementation where necessary.","solution":"def quick_sort_optimized(arr): Sorts the input array in-place using an optimized quick sort algorithm with median-of-three pivot selection and in-place partitioning. def median_of_three(a, b, c): if (arr[a] - arr[b]) * (arr[c] - arr[a]) >= 0: return a elif (arr[b] - arr[a]) * (arr[c] - arr[b]) >= 0: return b else: return c def partition(low, high): mid = (low + high) // 2 pivot_index = median_of_three(low, mid, high) # Swap pivot to end for partitioning arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def quick_sort_recursive(low, high): while low < high: pi = partition(low, high) if pi - low < high - pi: quick_sort_recursive(low, pi - 1) low = pi + 1 else: quick_sort_recursive(pi + 1, high) high = pi - 1 quick_sort_recursive(0, len(arr) - 1) return arr"},{"question":"# Question - Enhanced Binary Search: First and Last Position of Element in Sorted Array **Context**: Implement an enhanced version of Binary Search which not only finds the target element but also finds its first and last positions in the array. The input array is sorted in non-decreasing order. This is useful in scenarios like frequency counting of elements in a sorted array. **Task**: Write a function `find_first_and_last_position(array, target)` that finds the first and last positions of `target` in the sorted array `array`. **Function Signature**: ```python def find_first_and_last_position(array: List[int], target: int) -> Tuple[int, int]: ``` **Input**: * `array` – A list of integers sorted in non-decreasing order. * `target` – An integer to find in the array. **Output**: * A tuple of two integers representing the first and last positions of `target` in the array. If the target is not found, return `(-1, -1)`. **Constraints**: * The array length will be between `1` and `100,000`. * The elements of the array will be between `-10^6` and `10^6`. * The target value will be an integer between `-10^6` and `10^6`. **Examples**: ```python assert find_first_and_last_position([5, 7, 7, 8, 8, 10], 8) == (3, 4) assert find_first_and_last_position([5, 7, 7, 8, 8, 10], 6) == (-1, -1) assert find_first_and_last_position([], 0) == (-1, -1) assert find_first_and_last_position([1], 1) == (0, 0) ``` **Explanation**: 1. In the array `[5, 7, 7, 8, 8, 10]`, the target `8` occurs from index `3` to `4`. 2. In the array `[5, 7, 7, 8, 8, 10]`, the target `6` is not found, so it returns `(-1, -1)`. **Notes**: - Aim for an algorithm with a time complexity of O(log n). - Use binary search or a modified approach to achieve this.","solution":"from typing import List, Tuple def find_first_and_last_position(array: List[int], target: int) -> Tuple[int, int]: def binary_search(left: bool) -> int: low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] > target: high = mid - 1 elif array[mid] < target: low = mid + 1 else: result = mid if left: high = mid - 1 else: low = mid + 1 return result first_position = binary_search(True) last_position = binary_search(False) if first_position == -1 or last_position == -1: return (-1, -1) return (first_position, last_position)"},{"question":"Scenario You are given the task of optimizing a network of cities by connecting them with the minimum possible cable length. Each city is represented by a node, and each possible cable connection between two cities is represented by an edge with a given weight (cable length). Task Implement a function `find_minimum_spanning_tree(graph)` that takes a dictionary representing an undirected graph and returns the total weight of the minimum spanning tree (MST). Input Format * A dictionary `graph` where keys are nodes and values are lists of lists. Each inner list contains two elements: the weight of the edge and the adjacent node. Example: ```python graph = { \'a\': [[3, \'b\'], [8, \'c\']], \'b\': [[3, \'a\'], [5, \'d\']], \'c\': [[8, \'a\'], [2, \'d\'], [4, \'e\']], \'d\': [[5, \'b\'], [2, \'c\'], [6, \'e\']], \'e\': [[4, \'c\'], [6, \'d\']] } ``` Output Format * An integer representing the total weight of the minimum spanning tree. Constraints * The graph is connected and undirected. * The number of nodes and edges do not exceed 1000. * Edge weights are non-negative integers. Performance Requirements The solution should have a time complexity of O(E log V), where E is the number of edges and V is the number of vertices. Example ```python graph = { \'a\': [[3, \'b\'], [8, \'c\']], \'b\': [[3, \'a\'], [5, \'d\']], \'c\': [[8, \'a\'], [2, \'d\'], [4, \'e\']], \'d\': [[5, \'b\'], [2, \'c\'], [6, \'e\']], \'e\': [[4, \'c\'], [6, \'d\']] } print(find_minimum_spanning_tree(graph)) # Output: 14 ``` __Note__: Ensure your implementation handles all edge cases such as graphs with varying structure but staying within given constraints.","solution":"import heapq def find_minimum_spanning_tree(graph): Returns the total weight of the minimum spanning tree (MST) for the given graph. The graph is represented as a dictionary where keys are nodes and values are lists of lists. Each inner list contains two elements: the weight of the edge and the adjacent node. Args: graph (dict): The undirected graph. Returns: int: The total weight of the minimum spanning tree (MST). if not graph: return 0 # Start with an arbitrary node. Here we select the first node from the dictionary. start_node = list(graph.keys())[0] # Priority queue to select the edge with the minimum weight min_heap = [(0, start_node)] # (weight, node) visited = set() total_weight = 0 while min_heap: weight, node = heapq.heappop(min_heap) if node in visited: continue visited.add(node) total_weight += weight for edge_weight, neighbor in graph[node]: if neighbor not in visited: heapq.heappush(min_heap, (edge_weight, neighbor)) return total_weight"},{"question":"# Strobogrammatic Number Generation Given an integer n, write a function `generate_strobogrammatic_numbers(n)` that generates all strobogrammatic numbers of length n. Additionally, write a function `count_strobogrammatic_in_range(low, high)` that returns the count of strobogrammatic numbers within the given range as strings `low` and `high`. Function Signature ```python def generate_strobogrammatic_numbers(n: int) -> List[str]: pass def count_strobogrammatic_in_range(low: str, high: str) -> int: pass ``` Input * `n`: An integer representing the length of the numbers to generate (0 <= n). * `low`: A string representing the lower bound of the range. * `high`: A string representing the upper bound of the range. Output * The function `generate_strobogrammatic_numbers(n)` should return a list of strings containing all strobogrammatic numbers of length n. * The function `count_strobogrammatic_in_range(low, high)` should return an integer count of strobogrammatic numbers between the given range [low, high]. Constraints * 0 <= n <= 14 * The range given by low and high will have lengths less than or equal to 15 digits. Example ```python assert generate_strobogrammatic_numbers(2) == [\\"11\\", \\"69\\", \\"88\\", \\"96\\"] assert count_strobogrammatic_in_range(\\"50\\", \\"100\\") == 3 # \\"69\\", \\"88\\", \\"96\\" ``` **Note**: The strobogrammatic numbers should not have leading zeros except for the number \'0\'.","solution":"from typing import List def generate_strobogrammatic_numbers(n: int) -> List[str]: def helper(m, n): if m == 0: return [\\"\\"] if m == 1: return [\\"0\\", \\"1\\", \\"8\\"] prev = helper(m - 2, n) result = [] for num in prev: if m != n: # Prevent numbers starting with \'0\' unless n == 1 result.append(\\"0\\" + num + \\"0\\") result.append(\\"1\\" + num + \\"1\\") result.append(\\"6\\" + num + \\"9\\") result.append(\\"8\\" + num + \\"8\\") result.append(\\"9\\" + num + \\"6\\") return result return helper(n, n) def count_strobogrammatic_in_range(low: str, high: str) -> int: def compare_str_num(a, b): if len(a) != len(b): return len(a) - len(b) if a < b: return -1 elif a > b: return 1 return 0 result = 0 for length in range(len(low), len(high) + 1): for number in generate_strobogrammatic_numbers(length): if compare_str_num(low, number) <= 0 and compare_str_num(number, high) <= 0: result += 1 return result"},{"question":"# Question: Minimum Depth of Binary Tree Given a binary tree, write a function to find its minimum depth and a separate function to print its nodes. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children. Input A root node of the binary tree with the following structure: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Output 1. An integer representing the minimum depth of the tree. 2. The values of the tree nodes printed in pre-order traversal. Function Signatures Implement the following functions: ```python def min_depth(root: TreeNode) -> int: # Your code here def print_tree(root: TreeNode) -> None: # Your code here ``` Constraints * The number of nodes in the tree is in the range `[0, 10^5]`. * The values of the nodes are integers in the range `[-10^9, 10^9]`. Example ```python # Sample Tree Structure # 1 # / # 2 3 # / # 4 5 tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) # Function Calls print(min_depth(tree)) # Output: 2 print_tree(tree) # Output: # 1 # 2 # 4 # 5 # 3 ``` Note: - Ensure to handle edge cases such as empty trees and trees with a single node. - Consider both recursive and iterative approaches for depth calculation, and elaborate on their differences in a brief commentary if required.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def min_depth(root: TreeNode) -> int: if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_tree(root: TreeNode) -> None: if not root: return print(root.val) if root.left: print_tree(root.left) if root.right: print_tree(root.right)"},{"question":"# Topological Sort Assignment Context You are tasked with managing a directed task graph where each node represents a task and an edge from node U to node V represents that task U must be completed before task V. Given this structure, you are to find a valid order of tasks that satisfies all the dependencies. If the task graph has a cycle, indicating an impossible situation where dependencies cannot be resolved, you should raise an appropriate error. Problem Statement Write a function `find_topological_order(graph: Dict[int, List[int]]) -> List[int]` that accepts a directed graph represented as an adjacency list and returns a list of vertices in topological order. If the graph contains a cycle, raise a `ValueError` with the message \\"cycle\\". Input - `graph`: A dictionary where keys are integers representing vertices and values are lists of integers representing the vertices that the key vertex has directed edges to. Output - A list of integers representing the vertices in topological order. Constraints - The graph contains at most 10^4 vertices and 10^5 edges. - Vertices are labeled with unique integers within the range [0, 10^4 - 1]. Example ```python graph = { 0: [1, 2], 1: [2, 3], 2: [3], 3: [], 4: [1, 2], } print(find_topological_order(graph)) # Possible outputs: [0, 4, 1, 2, 3] or [4, 0, 1, 2, 3] graph_with_cycle = { 0: [1], 1: [2], 2: [0] } print(find_topological_order(graph_with_cycle)) # Raises ValueError(\\"cycle\\") ``` Implementation Notes - Utilize Depth-First Search (DFS) for an efficient implementation. - Pay attention to cycle detection to handle invalid graphs. - Consider both the recursive and iterative approaches discussed in the analysis.","solution":"def find_topological_order(graph): def visit(node): if temp_marks[node]: raise ValueError(\\"cycle\\") if not perm_marks[node]: temp_marks[node] = True for neighbor in graph.get(node, []): visit(neighbor) temp_marks[node] = False perm_marks[node] = True sorted_nodes.append(node) sorted_nodes = [] perm_marks = {node: False for node in graph} temp_marks = {node: False for node in graph} for node in graph: if not perm_marks[node]: visit(node) sorted_nodes.reverse() return sorted_nodes"},{"question":"You are given the task to implement a function for calculating the binomial coefficient C(n, k) in an optimized way using dynamic programming. Your function should avoid recursion depth issues and be capable of handling large values efficiently. # Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` # Input Format - `n`: a non-negative integer (0 ≤ n ≤ 10^3) indicating the total number of items. - `k`: a non-negative integer (0 ≤ k ≤ n) indicating the number of selected items. # Output Format - Returns an integer denoting the binomial coefficient C(n, k). # Constraints - Ensure the function handles edge cases where k is 0 or n equals k. - The function should have a time complexity of O(n*k) and space complexity that supports the given limits efficiently. # Example ```python >>> binomial_coefficient(5, 0) 1 >>> binomial_coefficient(8, 2) 28 >>> binomial_coefficient(20, 10) 184756 ``` # Explanation Use dynamic programming to build a table dp where dp[i][j] will store the binomial coefficient value C(i, j). Follow these steps: 1. Start with a base case where C(i, 0) = C(i, i) = 1. 2. Use the relation C(i, j) = C(i-1, j-1) + C(i-1, j) to fill the table. 3. Respect the constraints to avoid inefficient execution for large values.","solution":"def binomial_coefficient(n: int, k: int) -> int: Returns the binomial coefficient C(n, k). if k > n: return 0 if k == 0 or k == n: return 1 # Initialize a table to store intermediate results dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)] # Calculate value of Binomial Coefficient in bottom up manner for i in range(n + 1): for j in range(min(i, k) + 1): # Base cases if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][k]"},{"question":"You are tasked with writing a function to encode strings using the Atbash cipher. The Atbash cipher is a substitution cipher with a fixed key where all letters of the alphabet are mapped to their reverse equivalents (\'A\' to \'Z\', \'B\' to \'Y\', etc.). The function should maintain the case of the input characters and leave non-alphabet characters unchanged. # Input: 1. A single string `s` consisting of upper and lower case alphabetic characters, spaces, and punctuation marks. # Output: 1. A string representing the encoded message using the Atbash cipher. # Constraints: 1. The string length will not exceed 10^5. 2. The string may contain spaces and punctuation marks which should be preserved in their original position. # Example: Input: ``` Attack at dawn ``` Output: ``` Zggzxp zg wzdm ``` # Function Signature: ```python def atbash(s: str) -> str: pass ``` # Hint: Consider the ASCII values of characters and the fixed difference between corresponding characters in the original and reversed alphabet. For example, the distance between \'A\' and \'Z\' is the same as between \'a\' and \'z\'.","solution":"def atbash(s: str) -> str: Encodes the given string using the Atbash cipher. Parameters: s (str): Input string consisting of upper and lower case alphabetic characters, spaces, and punctuation marks. Returns: str: Encoded string with the Atbash cipher. def atbash_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) else: return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"# Question You have been given an absolute path for a file in a Unix-style file system. Your task is to write a function `simplify_path` that simplifies the given path as per the Unix file path rules. # Input * A single string `path` which represents the absolute path in a Unix-style file system. # Output * Return a simplified Unix-style absolute path. # Constraints * The input path will always start with a \'/\'. * The input path will only contain printable ASCII characters, excluding space (\' \'). # Examples ```python print(simplify_path(\\"/home/\\")) # Output: \\"/home\\" print(simplify_path(\\"/a/./b/../../c/\\")) # Output: \\"/c\\" print(simplify_path(\\"/../\\")) # Output: \\"/\\" print(simplify_path(\\"/home//foo/\\")) # Output: \\"/home/foo\\" ``` # Explanation 1. `\\"/home/\\"` simplifies to `\\"/home\\"`. 2. `\\"/a/./b/../../c/\\"` simplifies to `\\"/c\\"`. * \\"`.`\\" is the current directory, so it is ignored. * \\"`..`\\" indicates moving up one directory, so `\\"/a/./b/../../c/\\"` becomes `\\"/c\\"`. 3. `\\"/../\\"` simplifies to `\\"/\\"`, since the root directory `\\"/\\"` does not have a parent directory. 4. `\\"/home//foo/\\"` simplifies to `\\"/home/foo\\"`, ignoring the extra slashes. # Detailed Steps 1. Split the input path by `\'/\'` to process each component separately. 2. Use a stack to keep track of valid directory names. * Ignore empty strings resulting from consecutive slashes. * Ignore `\\".\\", as it refers to the current directory. * Pop from the stack if `\\"..\\",` is encountered and the stack is not empty. * Push valid directory names onto the stack. 3. Reconstruct the simplified path from the stack. # Function Signature ```python def simplify_path(path): :type path: str :rtype: str ```","solution":"def simplify_path(path): Simplifies the given Unix-style absolute path. :param path: str: The absolute path in a Unix-style file system. :return: str: The simplified Unix-style absolute path. components = path.split(\'/\') stack = [] for component in components: if component == \'\' or component == \'.\': continue elif component == \'..\': if stack: stack.pop() else: stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"# Scenario You are working on a large-scale machine learning project that frequently involves operations on very large and sparse vectors. To ensure efficient calculation and minimal memory usage, a specialized data structure and associated algorithms are required. # Task 1. **Data Structure Implementation**: Implement a data structure to store large sparse vectors efficiently. 2. **Dot Product Function**: Implement a function to compute the dot product between two sparse vectors. # Function Signature ```python class SparseVector: def __init__(self, vector: List[float]): # Initialize the sparse vector with the given list of floats pass def dotProduct(self, vec: \'SparseVector\') -> float: # Compute the dot product between this vector and another sparse vector pass ``` # Input - `vector`: A list of floats representing the vector, which may contain many zeros. - `vec`: Another instance of `SparseVector` for the dot product operation. # Output - The dot product of the two sparse vectors as a float. # Constraints - The number of elements in any vector does not exceed (10^7). - Elements in the vectors are floating-point numbers. # Example ```python v1 = SparseVector([1.0, 0.0, 0.0, 2.0, 3.0]) v2 = SparseVector([0.0, 2.0, 0.0, 1.0, 0.0]) print(v1.dotProduct(v2)) # Output should be 2.0 ``` # Description - Ensure that your data structure only stores the non-zero elements to save memory. - Your `dotProduct` function should efficiently compute the result without iterating over entire vectors that contain many zeros.","solution":"from typing import List, Dict class SparseVector: def __init__(self, vector: List[float]): # Initialize the sparse vector with the given list of floats self.sparse_vector = {i: v for i, v in enumerate(vector) if v != 0} def dotProduct(self, vec: \'SparseVector\') -> float: # Compute the dot product between this vector and another sparse vector result = 0.0 # Iterate through the non-zero elements of this vector for index, value in self.sparse_vector.items(): if index in vec.sparse_vector: result += value * vec.sparse_vector[index] return result"},{"question":"You are given a square matrix `A` of size `n x n`. Write a function `invert(matrix)` that computes the inverse of this matrix if it is invertible. If the matrix is not invertible, your function should return a matrix indicating the type of error. Function Signature: ```python def invert(matrix: List[List[float]]) -> List[List[float]]: ``` Requirements: 1. **Inputs**: - `matrix`: a list of lists of floats representing an `n x n` matrix. 2. **Outputs**: - Return the inverted `n x n` matrix if the original matrix is invertible. - If the matrix is not square, return `[[-2]]`. - If the matrix is too small (1x1 or empty), return `[[-3]]`. - If the matrix is singular (determinant is zero), return `[[-4]]`. Constraints: - 2 ≤ n ≤ 10. - The input matrix will only contain valid numerical entries. - Do not use any libraries to perform matrix inversion directly. Edge Cases to Consider: - Non-square input matrices. - Singular matrices with zero determinant. - Small matrices (e.g., 1x1 or empty matrix). Example: ```python # Example 1 matrix1 = [ [4, 7], [2, 6] ] assert invert(matrix1) == [ [0.6, -0.7], [-0.2, 0.4] ] # Example 2 matrix2 = [ [1, 2], [2, 4] ] assert invert(matrix2) == [[-4]] # Singular matrix # Example 3: matrix3 = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] assert invert(matrix3) == [ [-24, 18, 5], [20, -15, -4], [-5, 4, 1] ] # Example 4: matrix4 = [ [1] ] assert invert(matrix4) == [[-3]] # 1x1 matrix ``` Ensure your function is efficient and handles the provided edge cases appropriately.","solution":"from typing import List def invert(matrix: List[List[float]]) -> List[List[float]]: import copy # Check if the input is a square matrix if len(matrix) != len(matrix[0]): return [[-2]] n = len(matrix) # Check if the matrix is too small if n != len(matrix[0]) or n <= 1: return [[-3]] # Function to calculate the determinant of a matrix def determinant(m): if len(m) == 1: return m[0][0] if len(m) == 2: return m[0][0] * m[1][1] - m[0][1] * m[1][0] det = 0 for c in range(len(m)): det += ((-1) ** c) * m[0][c] * determinant(minor(m, 0, c)) return det # Function to calculate the minor matrix def minor(matrix, row, col): minor_matrix = copy.deepcopy(matrix) minor_matrix = minor_matrix[:row] + minor_matrix[row + 1:] for i in range(len(minor_matrix)): minor_matrix[i] = minor_matrix[i][:col] + minor_matrix[i][col + 1:] return minor_matrix det = determinant(matrix) # Check for singular matrix if det == 0: return [[-4]] # Function to calculate the cofactor matrix def cofactor(matrix): cofactors = [] for r in range(len(matrix)): cofactor_row = [] for c in range(len(matrix)): minor_mat = minor(matrix, r, c) cofactor_row.append(((-1) ** (r + c)) * determinant(minor_mat)) cofactors.append(cofactor_row) return cofactors # Function to transpose a matrix def transpose(matrix): transposed = [] for c in range(len(matrix[0])): transposed.append([row[c] for row in matrix]) return transposed # Calculate the cofactor matrix and its transpose (which is the adjugate matrix) cofactor_matrix = cofactor(matrix) adjugate_matrix = transpose(cofactor_matrix) # Calculate the inverse inverse_matrix = [] for r in range(len(adjugate_matrix)): inverse_row = [adjugate_matrix[r][c] / det for c in range(len(adjugate_matrix))] inverse_matrix.append(inverse_row) return inverse_matrix"},{"question":"# Coding Assessment: Separate Chaining Hash Table Objective Implement a method to resize the hash table dynamically when it becomes too full. Ensure that the elements are redistributed properly across the new table size. Problem Statement You are given a `SeparateChainingHashTable` class representing a hash table that uses separate chaining to handle collisions. Your task is to add dynamic resizing to this hash table. When the number of elements (`len(table)`) becomes greater than 70% of the table size (`size`), you should resize the table to twice its current size plus one (to ensure it\'s an odd number). This helps maintain the average-case time complexity. **Function to Implement**: ```python def resize(self): ... ``` **Resizing Steps**: 1. Calculate the new table size: `new_size = 2 * old_size + 1`. 2. Create a new empty table with the `new_size`. 3. Rehash and insert all existing elements from the old table into the new table. 4. Update the table reference to point to the new table. Requirements - Implement the `resize` method within the `SeparateChainingHashTable` class. - Ensure that all current elements are correctly rehashed and transferred to the new table. - Update the class attributes accordingly (`self.size` and `self._table`). Example ```python # Create a hash table and add elements to trigger resize table = SeparateChainingHashTable(size=11) for i in range(8): table.put(f\'key{i}\', f\'value{i}\') print(len(table)) # Output should be 8 before resize print(table.size) # Output should be 11 before resize ``` After adding the 8th element, the resize should be triggered: ```python print(len(table)) # Should still be 8 after resize print(table.size) # Should be updated to 23 after resize (2*11 + 1) ``` Constraints - The `resize` method should be optimized to maintain an average time complexity of O(n) for the resizing process. - The `put`, `get`, and `delete` methods should continue to function correctly after resizing. - Handle typical edge cases, such as empty insertions and duplicate keys.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self._table = [[] for _ in range(size)] self.count = 0 def _hash(self, key): return hash(key) % self.size def put(self, key, value): index = self._hash(key) bucket = self._table[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.count += 1 if self.count > 0.7 * self.size: self.resize() def get(self, key): index = self._hash(key) bucket = self._table[index] for k, v in bucket: if k == key: return v return None def delete(self, key): index = self._hash(key) bucket = self._table[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.count -= 1 return True return False def resize(self): old_table = self._table new_size = 2 * self.size + 1 self._table = [[] for _ in range(new_size)] self.size = new_size self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def __len__(self): return self.count"},{"question":"# Instructions You are required to implement a function to perform in-order traversal on a binary tree. You should choose either an iterative or a recursive approach. Your implementation should account for common edge cases, handle various tree structures, and perform efficiently. Function Signature ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Node) -> list: pass ``` # Input * `root` (Node): The root node of the binary tree. # Output * `list`: A list containing the values of the nodes in in-order. # Constraints * The number of nodes in the tree is between `0` and `10^5`. * Each node has a unique value that can be an integer between `-10^6` and `10^6`. # Performance Requirements * Your solution should have a time complexity of O(n) where n is the number of nodes in the tree. * The space complexity should be O(h) where h is the height of the binary tree. Examples 1. **Example 1:** ```python n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left, n1.right = n2, n3 n2.right = n4 n4.left = n5 assert inorder_traversal(n1) == [2, 5, 4, 1, 3] ``` 2. **Example 2:** ```python n1 = Node(1) assert inorder_traversal(n1) == [1] ``` 3. **Example 3:** ```python n1 = Node(1) n2 = Node(2) n3 = Node(3) n4 = Node(4) n5 = Node(5) n1.left, n1.right = n2, n3 n3.left, n3.right = n4, n5 assert inorder_traversal(n1) == [2, 1, 4, 3, 5] ``` **Note**: You can choose to use either a recursive or an iterative approach. Ensure your code handles all edge cases efficiently.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Node) -> list: Perform in-order traversal of a binary tree. Args: root (Node): The root node of the binary tree. Returns: list: A list of node values in in-order. result = [] stack = [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result"},{"question":"# Scenario You are developing a configuration management utility that reads configuration files from various paths specified by users. To ensure correctness, all paths should be transformed to their absolute forms before any operation. # Problem Statement Write a function `resolve_path` that takes a string representing a file path and returns its absolute path, properly expanding user shortcuts like `~`. # Function Signature ```python def resolve_path(file: str) -> str: ``` # Input - `file`: A string that represents a path to a file or directory. This can be relative, contain user shortcuts (`~`), or already be an absolute path. # Output - Returns a string that is the absolute path of the input file. # Constraints - The input string may be empty, and in such cases, should return an empty string. - Do not perform any file existence checks; simply transform and return the input path to its absolute form. # Examples ```python assert resolve_path(\\"~/myfolder\\") == \\"/home/username/myfolder\\" assert resolve_path(\\"folder/subfolder/file.txt\\") == \\"/current/working/directory/folder/subfolder/file.txt\\" assert resolve_path(\\"/absolute/path/to/file\\") == \\"/absolute/path/to/file\\" assert resolve_path(\\"\\") == \\"\\" ``` # Notes - Assume the current user\'s home directory expands correctly with `~`. - The function should not raise exceptions for any valid input string.","solution":"import os def resolve_path(file: str) -> str: Takes a string representing a file path and returns its absolute path, properly expanding user shortcuts like `~`. Parameters: - file: A string that represents a path to a file or directory. This can be relative, contain user shortcuts (`~`), or already be an absolute path. Returns: - A string that is the absolute path of the input file. if not file: return \\"\\" return os.path.abspath(os.path.expanduser(file))"},{"question":"# Question Context: You are tasked with evaluating a Binary Search Tree (BST) for various tree height measurements for a new balancing system. Your objective is to write a function to determine the height of a given Binary Search Tree. Function Signature: ```python def height(root: Optional[TreeNode]) -> int: pass ``` Input: * `root` (TreeNode): The root node of a Binary Search Tree. Output: * `int`: The height of the tree. Constraints: * The tree node can either be a valid TreeNode or None (representing an empty tree). * Tree node values are unique integers. Examples: Consider the following Binary Search Tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` For the example above, the function `height(root)` should return `4`. Testing: Each implementation will be tested using the unittest framework with the below tree setup and tests: ```python import unittest class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: current = self.root while True: if key < current.val: if current.left is None: current.left = TreeNode(key) break current = current.left else: if current.right is None: current.right = TreeNode(key) break current = current.right class TestSuite(unittest.TestCase): def setUp(self): self.tree = BST() self.tree.insert(9) self.tree.insert(6) self.tree.insert(12) self.tree.insert(3) self.tree.insert(8) self.tree.insert(10) self.tree.insert(15) self.tree.insert(7) self.tree.insert(18) def test_height(self): self.assertEqual(4, height(self.tree.root)) if __name__ == \'__main__\': unittest.main() ``` Construct your function ensuring it handles the edge cases mentioned in the analysis effectively.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def height(root: TreeNode) -> int: Calculate the height of a binary search tree. The height of a tree with only one node is 1. The height of an empty tree is 0. Parameters: root (TreeNode): The root node of the tree Returns: int: The height of the tree if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Stuttering a Stack You are tasked with transforming a stack such that each element in the stack is duplicated consecutively. Function Signature ```python def stutter_stack(stack: list) -> list: pass ``` # Input * A list of integers representing a stack, where the last element in the list is the top of the stack. # Output * The list representing the modified stack where each element is duplicated consecutively. # Constraints * The input stack will have at most (10^4) elements. * The elements of the stack are integer values. # Example ```python stack = [3, 7, 1, 14, 9] assert stutter_stack(stack) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] stack = [1] assert stutter_stack(stack) == [1, 1] stack = [] assert stutter_stack(stack) == [] ``` # Requirements 1. Implement a function `stutter_stack` to solve the problem. 2. The function should use only stacks (lists in Python) for auxiliary storage. 3. Aim for a solution with O(n) time complexity and O(n) space complexity where n is the size of the stack. 4. Consider edge cases such as empty stacks or stacks with one element.","solution":"def stutter_stack(stack: list) -> list: Given a stack, duplicate each element consecutively. Args: stack (list): A list of integers where the last element is the top of the stack. Returns: list: Modified stack with each element duplicated consecutively. # Create an auxiliary stack to store results aux_stack = [] while stack: # Pop the top element elem = stack.pop() # Push the element twice into the auxiliary stack aux_stack.append(elem) aux_stack.append(elem) # Reverse the auxiliary stack to get the original order while aux_stack: stack.append(aux_stack.pop()) return stack"},{"question":"You are given an unsigned 32-bit integer `n`. Write a function `count_ones(n)` that calculates and returns the number of \'1\' bits in the binary representation of `n` using Brian Kernighan\'s Algorithm. You need to demonstrate your understanding by providing an iterative implementation. # Function Signature ```python def count_ones(n: int) -> int: pass ``` # Input * A single unsigned 32-bit integer, `n` (0 <= n <= 2^32 - 1). # Output * An integer representing the number of \'1\' bits in the binary representation of the input number. # Constraints 1. The function should run in O(k) time, where k is the number of 1s in the binary representation of `n`. # Examples Example 1: ``` Input: 11 Output: 3 Explanation: The binary representation of 11 is 00000000000000000000000000001011 which has three \'1\' bits. ``` Example 2: ``` Input: 128 Output: 1 Explanation: The binary representation of 128 is 00000000000000000000000010000000 which has one \'1\' bit. ``` # Notes * You may not use any built-in Python functions that directly perform this operation. * Consider edge cases such as the smallest (0) and largest (2^32 - 1) possible values for inputs. # Function Implementation Implement the function as described above.","solution":"def count_ones(n: int) -> int: Counts the number of \'1\' bits in the binary representation of a given unsigned 32-bit integer using Brian Kernighan\'s Algorithm. count = 0 while n: n &= (n - 1) # clears the lowest set bit count += 1 return count"},{"question":"# Remove Duplicates from a Linked List You\'ve been given a singly linked list and tasked to write a function that removes all duplicate values from the list. Duplicate values should be only retained once with the sequence/order of the initial occurrence. Implement the function in two different ways: 1. Using a HashSet to store seen values. 2. Without utilizing any additional data structures, purely by modifying pointers. Input and Output Formats * Input: A linked list `Node` where each node contains: * `val`: A string representing the value of the node. * `next`: A reference to the next node in the linked list or None if it is the end of the list. * Output: The `head` of the modified linked list with duplicates removed. Function Signatures 1. Using HashSet: ```python def remove_dups(head: Node) -> Node: pass ``` 2. Without extra data structures: ```python def remove_dups_without_set(head: Node) -> Node: pass ``` Example Given the initial linked list: A -> A -> B -> C -> D -> C -> F -> G The list after removing duplicates should be: A -> B -> C -> D -> F -> G Constraints 1. The input linked list will have no more than 1000 nodes. 2. All node values are string data type and case-sensitive. # Task 1. Implement both `remove_dups` and `remove_dups_without_set` functions. 2. Include proper testing mechanisms to validate your implementation, checking various edge cases such as empty lists or entirely duplicate lists. 3. Ensure your solution is memory efficient for large inputs when using the non-hash set approach.","solution":"class Node: def __init__(self, val: str, next: \'Node\' = None): self.val = val self.next = next def remove_dups(head: Node) -> Node: if not head: return head seen = set() current = head seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next return head def remove_dups_without_set(head: Node) -> Node: if not head: return head current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next return head # Helper function to create a linked list from a list of values def create_linked_list(values): if not values: return None head = Node(values[0]) current = head for value in values[1:]: current.next = Node(value) current = current.next return head # Helper function to convert linked list to a list of values def linked_list_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result"},{"question":"You are tasked with implementing a variant of the Nearest Neighbor algorithm. Instead of using Euclidean distance, you will use Manhattan distance (also known as L1 distance). # Scenario You are given a dataset of points where each point has a label, and a test point for which you need to determine the closest point in the dataset based on Manhattan distance. # Function Definition Implement the function `nearest_neighbor_manhattan`: ```python def nearest_neighbor_manhattan(test_point, data_set): Finds the nearest neighbor of test_point in data_set using Manhattan distance. Parameters: test_point (tuple): A tuple representing the test point (x1, x2, ..., xn). data_set (dict): A dictionary where keys are tuples representing points (y1, y2, ..., yn), and values are labels (any type). Returns: The label of the nearest neighbor to test_point. Constraints: - All points and the test point are tuples of the same dimension. - data_set contains at least one point. - You may assume all components of the points are numeric. ``` # Example ```python test_point = (3, 4) data_set = { (1, 2): \'A\', (5, 5): \'B\', (1, 1): \'C\' } print(nearest_neighbor_manhattan(test_point, data_set)) # Output: \'A\' ``` # Constraints - The dimensionality of the points will not exceed 100. - The number of points will not exceed 10,000. # Notes - Remember to handle the constraints and edge cases carefully. - Ensure your function is efficient and can handle the upper limits of the constraints.","solution":"def manhattan_distance(point1, point2): Computes the Manhattan distance between two points. Parameters: point1 (tuple): The first point. point2 (tuple): The second point. Returns: int: The Manhattan distance between the two points. return sum(abs(a - b) for a, b in zip(point1, point2)) def nearest_neighbor_manhattan(test_point, data_set): Finds the nearest neighbor of test_point in data_set using Manhattan distance. Parameters: test_point (tuple): A tuple representing the test point (x1, x2, ..., xn). data_set (dict): A dictionary where keys are tuples representing points (y1, y2, ..., yn), and values are labels (any type). Returns: The label of the nearest neighbor to test_point. nearest_point = None shortest_distance = float(\'inf\') for point, label in data_set.items(): distance = manhattan_distance(test_point, point) if distance < shortest_distance: shortest_distance = distance nearest_point = point return data_set[nearest_point]"},{"question":"Implement a specialized variant of a Hash Table called `MaxLoadHashTable` with a predefined maximum load factor. This new version will automatically resize itself when it exceeds a specified load factor, rather than using the default 2/3 load factor. Function Specifications 1. **`__init__(self, max_load_factor=0.75, initial_size=8)`**: - Initializes the hash table with an initial size and a maximum load factor. 2. **`put(self, key, value)`**: - Inserts a key-value pair into the hash table. If the load factor exceeds the `max_load_factor`, the table should resize itself automatically. 3. **`__resize(self)`**: - Resizes the hash table to double its current size and rehashes all existing keys. Input/Output Format ``` - Input: (int key, any value) - Output: None for `put` method, N/A for `__resize` method (internal use only) ``` Constraints 1. The keys will be non-negative integers. 2. The initial size will be set to a minimum of 8 and can grow as per the resizing policy. 3. The maximum load factor should be a positive float less than 1. Example ```python # Example usage: ht = MaxLoadHashTable(max_load_factor=0.75) ht.put(1, \'one\') ht.put(13, \'thirteen\') ht.put(25, \'twenty-five\') # This should trigger a resize ``` # Note You should override inherited methods from the provided `HashTable` class to include the maximum load factor functionality.","solution":"class MaxLoadHashTable: def __init__(self, max_load_factor=0.75, initial_size=8): self.max_load_factor = max_load_factor self.size = initial_size self.table = [None] * initial_size self.count = 0 def put(self, key, value): if self.count / self.size >= self.max_load_factor: self.__resize() index = key % self.size while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.size if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def __resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(*item)"},{"question":"# Longest Common Prefix Coding Challenge Scenario You are working on an autocomplete feature in a text editor. To optimize the suggestions, you need to find the longest common prefix of an array of possible suggestions to quickly narrow down the options. Problem Statement Write a function `longest_common_prefix(strings: List[str]) -> str` that finds the longest common prefix string amongst an array of strings. If there is no common prefix, the function should return an empty string. Input - `strings`: A list of strings (`List[str]`) with a length `n`. Output - A single string representing the longest common prefix. If none exists, return an empty string (`\\"\\"`). Constraints - The array can be empty (`0 ≤ n ≤ 200`). - Strings consist of only lowercase English letters and may have length up to `1000`. - Time complexity expectation is O(S) where S is the sum of all characters in the input array. - Optimize for the best space complexity possible. Examples Example 1: ```python Input: [\\"flower\\",\\"flow\\",\\"flight\\"] Output: \\"fl\\" ``` Example 2: ```python Input: [\\"dog\\",\\"racecar\\",\\"car\\"] Output: \\"\\" Explanation: There is no common prefix among the input strings. ``` Example 3: ```python Input: [\\"interspecies\\", \\"interstellar\\", \\"interstate\\"] Output: \\"inters\\" ``` Example 4: ```python Input: [] Output: \\"\\" ``` Example 5: ```python Input: [\\"a\\"] Output: \\"a\\" ``` Implementation Notes - Consider edge cases such as single-element arrays and arrays of varying string lengths. - Ensure your solution is efficient and handles large inputs gracefully.","solution":"from typing import List def longest_common_prefix(strings: List[str]) -> str: Finds the longest common prefix string amongst an array of strings. If there is no common prefix, returns an empty string. if not strings: return \\"\\" # Start with the first string as the prefix prefix = strings[0] for s in strings[1:]: # Reduce the prefix length until it matches the start of the string s while not s.startswith(prefix) and prefix: prefix = prefix[:-1] if not prefix: return \\"\\" return prefix"},{"question":"**Question**: Implement a class `LimitedRandomizedSet` extending the functionality of the provided `RandomizedSet` to limit the maximum number of elements it can hold. The class should support: - `LimitedRandomizedSet(max_size)`: Initializes the set with a maximum size limit. - `insert(val)`: Inserts `val` into the set if it is not already present and if the set has not reached its size limit. - `remove(val)`: Removes `val` from the set if it is present. - `get_random()`: Returns a random element from the set. - `is_full()`: Returns `True` if the set has reached its size limit, otherwise `False`. - `is_empty()`: Returns `True` if the set is empty, otherwise `False`. # Constraints: - `0 <= val <= 10^6` - `0 < max_size <= 10^5` - Methods should still maintain O(1) average time complexity. - Return appropriate boolean values for `insert` and `remove` indicating success or failure. # Sample Input/Output: ```python limited_set = LimitedRandomizedSet(3) print(limited_set.insert(1)) # Output: True print(limited_set.insert(2)) # Output: True print(limited_set.insert(3)) # Output: True print(limited_set.insert(4)) # Output: False (since set is full) print(limited_set.is_full()) # Output: True print(limited_set.remove(2)) # Output: True print(limited_set.is_full()) # Output: False print(limited_set.is_empty()) # Output: False print(limited_set.get_random()) # Output: 1 or 3 (randomly) print(limited_set.remove(5)) # Output: False print(limited_set.is_empty()) # Output: False (still has 1 or 3) ``` **Note**: Ensure all methods are functioning as per the constraints and requirements listed above.","solution":"import random class LimitedRandomizedSet: def __init__(self, max_size): self.max_size = max_size self.data = {} self.items = [] def insert(self, val): if len(self.items) >= self.max_size or val in self.data: return False self.data[val] = len(self.items) self.items.append(val) return True def remove(self, val): if val not in self.data: return False last_element = self.items[-1] idx_to_remove = self.data[val] self.items[idx_to_remove] = last_element self.data[last_element] = idx_to_remove self.items.pop() del self.data[val] return True def get_random(self): return random.choice(self.items) def is_full(self): return len(self.items) >= self.max_size def is_empty(self): return len(self.items) == 0"},{"question":"Problem: Query System Using Trie # Context You are tasked to create a query system for an autocomplete feature of a search engine. The system should be able to insert words into its vocabulary, check if a word exists in its current vocabulary, and find if there is any word in the vocabulary that starts with a given prefix. # Instructions Implement a `QuerySystem` class that uses a Trie data structure. The class should have the following methods: 1. **`insert(word: str) -> None`**: Inserts a word into the trie. 2. **`search(word: str) -> bool`**: Returns `True` if the word is in the trie, `False` otherwise. 3. **`starts_with(prefix: str) -> bool`**: Returns `True` if there is any word in the trie that starts with the given prefix, `False` otherwise. # Constraints * Words consisting of lowercase English letters only. * Each method should operate in O(n) time complexity, where n is the length of the word or prefix. * The trie should be space-efficient. # Example Usage ```python qs = QuerySystem() qs.insert(\\"apple\\") print(qs.search(\\"apple\\")) # True print(qs.search(\\"app\\")) # False print(qs.starts_with(\\"app\\")) # True qs.insert(\\"app\\") print(qs.search(\\"app\\")) # True ``` Note: Ensure that your implementation efficiently handles the insertion and search of the words. # Performance Requirements * **Insertion**: O(n) per word, where n is the word length. * **Search**: O(n) per word, where n is the word length. * **Prefix Search**: O(n) per prefix, where n is the prefix length. * The implementation should avoid unnecessary memory usage and be optimized for performance.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class QuerySystem: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"Context Imagine you are tasked with cleaning and filtering data from a massive dataset where you only need to focus on a specific range of values. To achieve this, you must implement an efficient array filtering mechanism based on provided lower and upper bound constraints. Problem Statement Write a function `bounded_filter(arr, min_bound=None, max_bound=None)` that filters an array based on given lower and upper bounds. The function should return a new array containing only the elements that fall within the specified bounds. Function Signature ```python def bounded_filter(arr: [int], min_bound: int = None, max_bound: int = None) -> [int]: pass ``` Input - `arr`: A list of integers, where the list can be of length from 0 to 10^5. - `min_bound`: An integer or None (default is None), representing the lower bound for filtering. - `max_bound`: An integer or None (default is None), representing the upper bound for filtering. Output - Returns a list of integers that fall within the range `[min_bound, max_bound]` inclusive. Constraints - If `min_bound` is `None`, assume the minimum possible value is `-∞`. - If `max_bound` is `None`, assume the maximum possible value is `∞`. - If `min_bound` and `max_bound` are both `None`, the function should return the entire array. Example ```python # Example 1: input_array = [5, 15, 25, 35, 45] min_bound = 15 max_bound = 35 output = bounded_filter(input_array, min_bound, max_bound) print(output) # Output should be [15, 25, 35] # Example 2: input_array = [1, 3, 5, 7, 9] output = bounded_filter(input_array) print(output) # Output should be [1, 3, 5, 7, 9] # Example 3: input_array = [1, 2, 3, 4, 5] min_bound = 2 output = bounded_filter(input_array, min_bound) print(output) # Output should be [2, 3, 4, 5] ``` Notes - Consider edge cases like an empty input array, arrays with a single element, and fully inclusive limits. - The function should maintain O(n) time complexity and focus on clear, maintainable code.","solution":"def bounded_filter(arr, min_bound=None, max_bound=None): Filters an array based on given lower and upper bounds. Parameters: arr (list of int): The input array to be filtered. min_bound (int, optional): The lower bound for filtering. Defaults to None. max_bound (int, optional): The upper bound for filtering. Defaults to None. Returns: list of int: A new list of integers that fall within the specified bounds. if min_bound is None: min_bound = float(\'-inf\') if max_bound is None: max_bound = float(\'inf\') return [x for x in arr if min_bound <= x <= max_bound]"},{"question":"# Question Problem Statement You are given a string as input. Your task is to write a function that deletes any recurring character in the string and returns the new string without duplicate characters. The order of characters in the final output should be the same as their first occurrence in the input string. Input - A single string `input_string` containing only lowercase English alphabets, with a length in the range [1, 10^5]. Output - Return a string `output_string` containing the characters in the same order as their first appearance in the input string, but with all recurring characters removed. Constraints - The function should handle strings up to the maximum length of 100,000 characters efficiently. Examples 1. Input: `\\"banana\\"` Output: `\\"ban\\"` 2. Input: `\\"apple\\"` Output: `\\"aple\\"` 3. Input: `\\"abcdef\\"` Output: `\\"abcdef\\"` 4. Input: `\\"aabbcc\\"` Output: `\\"abc\\"` 5. Input: `\\"\\"` (an empty string) Output: `\\"\\"` (an empty string) Function Signature ```python def delete_reoccurring_characters(input_string: str) -> str: # Your implementation here ```","solution":"def delete_reoccurring_characters(input_string: str) -> str: Deletes recurring characters in the string and returns the new string without duplicates, preserving the order of first occurrence. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Single Number Finder Challenge Scenario Given an array of integers where every element appears exactly twice except for one unique element which appears once, write a function to find that unique element. The problem guarantees that there is one single unique number. Function Definition Implement the function `find_single_number(nums)` that: - **Input**: A list of integers `nums`, where every element appears exactly twice except for one element. - **Output**: The single unique element in the list. # Example ```python def test_find_single_number(): assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([2, 2, 1]) == 1 assert find_single_number([1]) == 1 test_find_single_number() ``` # Constraints * The function should have a linear runtime complexity. * The function should not use extra memory, i.e., the space complexity should be constant. # Further Notes - You should not use any in-built Python functions that drastically reduce the solution complexity unintentionally (e.g., collections.Counter). - If the list is empty, return `0`. - If the list contains only one element, return that element. - Do not explicitly mention nor rely on any example code. Focus on a proper and efficient function implementation. # Performance Requirement The expected performance requirement is O(n) time complexity and O(1) space complexity for the solution.","solution":"def find_single_number(nums): Returns the single unique number in the list where every other number appears exactly twice. # Using XOR operation to find the single unique number. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Ordered Stack Coding Assessment Context You are tasked with enhancing the data structure capabilities of a software application by implementing an ordered stack. This stack should always maintain its elements in sorted order, such that the highest value is at the top. Objective Implement an `OrderedStack` class with the following operations: * `__init__(self)`: Initialize an empty stack. * `is_empty(self) -> bool`: Return True if the stack is empty, False otherwise. * `push(self, item: int)`: Push a given item onto the stack and maintain order. * `pop(self) -> int`: Remove and return the top item of the stack. * `peek(self) -> int`: Return the top item of the stack without removing it. * `size(self) -> int`: Return the number of items in the stack. Input and Output Formats * `push(item)`: Takes an integer `item`. * `pop()`: Returns the top integer. * `peek()`: Returns the top integer. * `is_empty()`: Returns a boolean. * `size()`: Returns an integer. Constraints * You may assume that only integers will be pushed onto the stack. * Methods should handle edge cases such as popping from an empty stack gracefully by raising appropriate exceptions. Performance Requirements * `push` should maintain the ordered property within acceptable time complexity limits. * Focus on optimal time complexity for each operation wherever possible. Example ```python stack = OrderedStack() stack.push(3) stack.push(1) stack.push(5) print(stack.pop()) # Output: 5 print(stack.peek()) # Output: 3 print(stack.size()) # Output: 2 print(stack.is_empty()) # Output: False ``` Note Your implementation should ensure that the stack remains ordered, with the highest value at the top, after each `push` operation.","solution":"class OrderedStack: def __init__(self): self._stack = [] def is_empty(self) -> bool: return len(self._stack) == 0 def push(self, item: int): if self.is_empty(): self._stack.append(item) else: # Insert the item in a sorted position index = len(self._stack) for i, current_item in enumerate(self._stack): if item > current_item: index = i break self._stack.insert(index, item) def pop(self) -> int: if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self._stack.pop(0) def peek(self) -> int: if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self._stack[0] def size(self) -> int: return len(self._stack)"},{"question":"**Maximum Element in Stack** You are asked to implement a specialized stack data structure that supports retrieving the maximum element efficiently. Your stack should support the following operations: * `push(value)`: Push an integer value onto the stack. * `pop()`: Remove and return the top element of the stack. * `peek()`: Return the top element without removing it. * `get_max()`: Retrieve the maximum element present in the stack in O(1) time. # Input Format You need to implement a class that initializes without any input parameters and has four methods `push(value: int)`, `pop() -> int`, `peek() -> int`, and `get_max() -> int`. # Constraints - You can assume that all operations are valid (i.e., there will be no pop or get_max operations on an empty stack). - All integer inputs are within the 32-bit signed integer range. # Output Format Each method should return the appropriate value depending on its description. The `push` method should not return anything. # Example ```python # Example usage: stack = MaxStack() stack.push(2) stack.push(3) print(stack.get_max()) # Output: 3 print(stack.pop()) # Output: 3 print(stack.get_max()) # Output: 2 ``` # Implementation Notes * Your implementation should maintain a secondary stack to keep track of the maximum values (hint: consider a stack where each element holds the maximum value up to that point).","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, value: int): self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self) -> int: if self.stack: top_value = self.stack.pop() if top_value == self.max_stack[-1]: self.max_stack.pop() return top_value raise IndexError(\\"pop from empty stack\\") def peek(self) -> int: if self.stack: return self.stack[-1] raise IndexError(\\"peek from empty stack\\") def get_max(self) -> int: if self.max_stack: return self.max_stack[-1] raise IndexError(\\"get_max from empty stack\\")"},{"question":"# Scenario: You are a software developer engaged in a project that involves heavy combinatorial calculations. Your task is to implement a function that efficiently computes the binomial coefficient, `nCr`, for large values of n and r. Given the combinatorial explosion with naive methods, you need to utilize dynamic programming principles to optimize performance. # Problem Statement: Write a function `combination_optimized(n, r)` that computes the binomial coefficient using an optimized approach with dynamic programming. This function should handle inputs efficiently without running into performance bottlenecks. # Input: - `n` : non-negative integer (0 <= n <= 10^6) - `r` : non-negative integer (0 <= r <= n) # Output: - Returns an integer which is the value of nCr # Constraints: - 0 <= n <= 10^6 - 0 <= r <= n # Requirements: - You must use an iterative approach or memoization to ensure the computation is efficient. - Avoid stack overflow issues by limiting recursive calls. - Handle large inputs within reasonable time limits. # Example: ```python def combination_optimized(n, r): # Your implementation here # Example Usage # combination_optimized(5, 3) should return 10 print(combination_optimized(5, 3)) # Output: 10 # combination_optimized(10, 2) should return 45 print(combination_optimized(10, 2)) # Output: 45 ```","solution":"def combination_optimized(n, r): Computes the binomial coefficient, nCr, using dynamic programming for efficiency. if r > n: return 0 if r == 0 or r == n: return 1 r = min(r, n - r) # Take advantage of symmetry C = [0] * (r + 1) C[0] = 1 for i in range(1, n + 1): for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j - 1] return C[r]"},{"question":"Scenario You are assigned to develop a function for a warehouse management system that ensures the robotic arms\' stack arrangement is in the correct order. The system uses a stack to organize packages, and it is crucial to verify that the packages are sorted by their identifiers in ascending numerical order from bottom to top. Task Implement a function `is_properly_sorted(stack)` that accepts a list representing a stack of packages\' identifiers and returns `True` if the identifiers are in ascending order from bottom to top. If they are not in ascending order, the function should return `False`. Input Format * `stack`: A list of integers representing a stack with the bottom of the stack at the start of the list and the top of the stack at the end of the list. Output Format * Return `True` if the stack is sorted in ascending order from bottom (start of the list) to top (end of the list), otherwise `False`. Constraints * The stack may contain zero or more integers. * The integers can be either positive or negative. * The function should handle up to 100,000 integers in the stack efficiently. Example ```python # Example 1 stack = [1, 2, 3, 4, 5, 6] print(is_properly_sorted(stack)) # Output: True # Example 2 stack = [6, 3, 5, 1, 2, 4] print(is_properly_sorted(stack)) # Output: False # Example 3 stack = [] print(is_properly_sorted(stack)) # Output: True # Example 4 stack = [10, 10, 10] print(is_properly_sorted(stack)) # Output: True ``` Performance Requirement Ensure the function operates efficiently with a time complexity of O(n) for the number of elements in the stack and optimizes memory usage where possible.","solution":"def is_properly_sorted(stack): Returns True if the stack is in ascending order from bottom (start of the list) to top (end of the list). for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"# Scenario You are given a task to send a list of strings over a network connection where only a single string can be transmitted at a time. To achieve this, you need to encode the list of strings into a single string in a format that can be easily decoded back to the original list on the receiving side. # Task Your task is to implement two functions: `encode` and `decode`. Function 1: `encode` This function should take a list of strings as input and return a single encoded string. # Input: - A list of strings, `strs` (e.g., `[\\"hello\\", \\"world\\"]`). # Output: - A single string representing the encoded format (e.g., `\\"5:hello5:world\\"`). Function 2: `decode` This function should take an encoded string as input and return the original list of strings. # Input: - A single encoded string, `s` (e.g., `\\"5:hello5:world\\"`). # Output: - A list of strings (e.g., `[\\"hello\\", \\"world\\"]`). # Constraints: - Each string in the list may contain any printable ASCII character. - Ensure that your encoding format can uniquely encode and decode the list of strings. - Performance requirements should handle lists with up to 10^4 strings and total encoded string length up to 10^6 characters. # Example: ```python # Input strs = [\\"hello\\", \\"world\\"] encoded_string = encode(strs) # expected \\"5:hello5:world\\" # Output decoded_list = decode(encoded_string) # expected [\\"hello\\", \\"world\\"] ``` # Implementation: Implement the functions as follows: Functions: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Implement this def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Implement this ```","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str encoded_string = \\"\\" for s in strs: length = len(s) encoded_string += f\\"{length}:{s}\\" return encoded_string def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] decoded_list = [] i = 0 while i < len(s): # Find the position of the next colon j = s.find(\':\', i) # Read the length of the next string length = int(s[i:j]) # Extract the string of the given length from the position right after the colon decoded_list.append(s[j+1:j+1+length]) # Move the pointer to the end of the current string segment i = j + 1 + length return decoded_list"},{"question":"# Question: Given two strings `s` and `t` where `t` is generated by shuffling string `s` and adding one more letter at a random position, write a function to find the letter that was added to `t`. Function Signature: ```python def find_difference(s: str, t: str) -> str: pass ``` # Input: * `s` (a string with length n, 1 ≤ n ≤ 10^5) * `t` (a string with length n+1) # Output: * A single character representing the added letter. # Constraints: 1. Both `s` and `t` consist of lowercase English letters only. 2. The length of `t` is exactly one more than the length of `s`. # Example: Input: ```python s = \\"abcd\\" t = \\"abecd\\" ``` Output: ```python \'e\' ``` # Explanation: By XORing all characters in both strings `s` and `t`, all characters that appear in both strings will cancel out, leaving only the additional character. # Performance Requirements: - The solution should run in linear time O(n) and use constant extra space. # Scenario: Consider a scenario where you have a set of items identified by unique single character IDs. If one item is misidentified (added) in a subsequent inventory check, this function will help you pinpoint the incorrect item efficiently.","solution":"def find_difference(s: str, t: str) -> str: Finds the letter that was added to t. result = 0 for char in s + t: result ^= ord(char) return chr(result)"},{"question":"You are given an integer `n`. Your task is to write a function `min_perfect_squares(n)` that returns the smallest number of perfect square numbers which sum to `n`. # Input: - An integer `n` where (1 leq n leq 10^5). # Output: - An integer between 1 and 4, representing the smallest number of perfect square numbers which sum to `n`. # Function Signature: ```python def min_perfect_squares(n: int) -> int: ... ``` # Example: - Input: `n = 12` - Output: `3` - Explanation: 12 can be represented as (2^2 + 2^2 + 2^2). # Constraints: 1. If `n` is a perfect square, return `1`. 2. If `n` satisfies the form (4^a(8b + 7)), return `4`. 3. Otherwise, check combinations of one and two squares to determine 2 or 3. # Notes: - Ensure your function handles edge cases like small numbers effectively. - You might find using steps involving mathematical square root properties useful. - Consider performance implications when dealing with the upper range of inputs. Good luck!","solution":"import math def min_perfect_squares(n: int) -> int: Returns the smallest number of perfect square numbers which sum to n. if n <= 0: return 0 # Check if n itself is a perfect square if int(math.isqrt(n)) ** 2 == n: return 1 # Check if n can be expressed as the sum of two squares for i in range(1, int(math.isqrt(n)) + 1): remainder = n - i * i if int(math.isqrt(remainder)) ** 2 == remainder: return 2 # Check if n can be expressed as the sum of three squares # Legendre\'s three-square theorem exception: n cannot be written as sum of three squares if n is of the form 4^a(8b+7) while n % 4 == 0: # reducing n by removing factors of 4 n //= 4 if n % 8 == 7: return 4 return 3"},{"question":"# ZigZag Iterator Design You are tasked with implementing a ZigZag Iterator to iterate over multiple input lists in a round-robin fashion. This iterator should return one element from each list in turn before cycling back to the first list. Upon depletion of elements in a list, it is simply skipped in subsequent rounds until all lists are exhausted. Requirements: 1. Implement a class `ZigZagIterator` that supports the following methods: - **`__init__(self, lists: List[List[int]])`**: Initialize the data structure with a list of integer lists. - **`next(self) -> int`**: Return the next element in the ZigZag order. - **`has_next(self) -> bool`**: Return whether there are more elements to return. Constraints: - Each list in `lists` can have between `0` and `1000` elements. - The total number of lists provided is between `1` and `100`. - Do not use any built-in iterator utilities apart from basic list operations. Example: ```python lists = [ [1, 2], [3, 4, 5, 6], [7, 8, 9] ] zag_it = ZigZagIterator(lists) result = [] while zag_it.has_next(): result.append(zag_it.next()) print(result) # Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Implement the `ZigZagIterator` class to fulfill the above requirements.","solution":"class ZigZagIterator: def __init__(self, lists): self.data = [lst for lst in lists if lst] # Filter out empty lists self.queue = [] self.index_map = [0] * len(self.data) # Track current index for each list for i in range(len(self.data)): self.queue.append(i) def next(self): if self.queue: current_list_index = self.queue.pop(0) current_list = self.data[current_list_index] res = current_list[self.index_map[current_list_index]] self.index_map[current_list_index] += 1 if self.index_map[current_list_index] < len(current_list): self.queue.append(current_list_index) return res def has_next(self): return bool(self.queue)"},{"question":"# Problem You have been given a list of integers and an associative binary function. Your task is to implement a segment tree for this list, which supports efficient range queries using the given function. You need to implement three methods: 1. `__init__(self, arr: List[int], function: Callable[[int, int], int])`: Constructor for initializing the segment tree. 2. `query(self, L: int, R: int) -> int`: Method for querying the result of the function over the range `[L, R]`. 3. `update(self, index: int, value: int)`: Method to update the element at `index` with `value`. # Input 1. List of integers `arr` with length `N` 2. An associative binary function `function` 3. Range indices `L` and `R` for querying 4. Index `index` and value `value` for updates # Output 1. Return the result of the function for the range query as an integer. # Constraints 1. 1 <= N <= 10^5 2. 1 <= arr[i] <= 10^9 3. 0 <= L <= R < N 4. 0 <= index < N 5. -10^9 <= value <= 10^9 # Example ```python from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): pass def query(self, L: int, R: int) -> int: pass def update(self, index: int, value: int): pass # Example usage: def sum_fn(x, y): return x + y arr = [1, 3, 5, 7, 9, 11] st = SegmentTree(arr, sum_fn) print(st.query(1, 3)) # Output: 15 (3 + 5 + 7) st.update(1, 10) print(st.query(1, 3)) # Output: 22 (10 + 5 + 7) ``` # Notes * You must handle the construction, query, and update functions efficiently. * The binary function provided will always be associative. * Ensure that edge cases are handled, such as querying an empty range or updating at the bounds of the array.","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]): self.n = len(arr) self.func = function self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr: List[int]): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: int): # Update the leaf node pos = index + self.n self.tree[pos] = value # Update internal nodes while pos > 1: pos //= 2 self.tree[pos] = self.func(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, L: int, R: int) -> int: L += self.n R += self.n + 1 result = None # for the purpose of knowing initial state while L < R: if L % 2 == 1: result = self.tree[L] if result is None else self.func(result, self.tree[L]) L += 1 if R % 2 == 1: R -= 1 result = self.tree[R] if result is None else self.func(result, self.tree[R]) L //= 2 R //= 2 return result"},{"question":"# Array Value Filtering Function Problem Statement You are given an array of integers and optionally some minimum and maximum limits. Your task is to filter the array to include only the values that fall within these specified limits (inclusive). If no minimum limit is provided, you should assume the smallest value in the array as the minimum limit. If no maximum limit is provided, you should assume the largest value in the array as the maximum limit. Function Signature ```python def filter_array(arr: list, min_limit: int = None, max_limit: int = None) -> list: pass ``` Input * `arr`: A list of integers (0 <= len(arr) <= 10^6). * `min_limit`: An optional integer specifying the minimum limit (None means no limit). * `max_limit`: An optional integer specifying the maximum limit (None means no limit). Output * A list of integers that fall within the specified range `[min_limit, max_limit]`. Constraints * If the list is empty, return an empty list. * If `min_limit` is greater than `max_limit`, return an empty list. * You must not use any additional data structures that change the overall time complexity beyond O(n). Example ```python assert filter_array([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filter_array([10, 20, 30, 40, 50], 15, 35) == [20, 30] assert filter_array([1, 2, 3, 4, 5], 3, 6) == [3, 4, 5] assert filter_array([], 0, 10) == [] assert filter_array([25, 50, 75, 100], 80, 90) == [] ``` Background Imagine you are developing a data pre-processing library used to clean up datasets. Users specify ranges to filter their data for better analysis and visualization. Your goal is to implement an efficient function to serve this purpose.","solution":"def filter_array(arr, min_limit=None, max_limit=None): Filters the array to include only values within the specified range [min_limit, max_limit]. Parameters: - arr: list of integers - min_limit: optional integer; minimum limit (inclusive) - max_limit: optional integer; maximum limit (inclusive) Returns: - a list of integers within the specified range if not arr: return [] if min_limit is None: min_limit = min(arr) if max_limit is None: max_limit = max(arr) if min_limit > max_limit: return [] return [x for x in arr if min_limit <= x <= max_limit]"},{"question":"You are given a set of candidate numbers (C) (without duplicates) and a target number (T). Your task is to write a function `find_combinations(candidates, target)` which returns all unique combinations where the candidate numbers sum to T. You can use each number in the set as many times as needed. Input Format * `candidates`: List of positive integers. * `target`: A positive integer. Output Format The function should return a list of lists, where each list represents a unique combination of candidate numbers that sum to the target. The solutions should not contain duplicate combinations. Constraints * All numbers (including the target) are positive integers. * The solution set must not contain duplicate combinations. Example Scenario John is designing a meal plan. He needs to ensure that each meal meets a minimum calorie count exactly. He has a list of dishes with their calorie counts and wants to determine all possible combinations of dishes for each meal. Given the list of dishes `[2, 3, 6, 7]` and a meal target of `7` calories, possible combinations are: * `[7]` (just one dish) * `[2, 2, 3]` (multiple dishes) He needs to identify all possible ways this can be achieved. # Function Signature ```python def find_combinations(candidates: List[int], target: int) -> List[List[int]]: # your code here ``` # Additional Requirements * Your solution should be efficient in terms of both time and space complexity. * Consider potential edge cases, such as when `candidates` is empty or the `target` is smaller than the smallest number in candidates.","solution":"from typing import List def find_combinations(candidates: List[int], target: int) -> List[List[int]]: def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(candidates)): backtrack(i, target - candidates[i], path + [candidates[i]]) result = [] candidates.sort() backtrack(0, target, []) return result"},{"question":"# Question Context As a software engineer working on an embedded system, you\'re required to implement various operations on a control register, which is a 32-bit integer. The control register uses individual bits to represent different settings, flags, and status indicators. Task Implement a class `ControlRegister` with methods to manage the bits in a given 32-bit integer. Your class should include the following methods: 1. **get_bit(num: int, i: int) -> bool**: Return the bit value (0 or 1) at position `i`. 2. **set_bit(num: int, i: int) -> int**: Set the bit at position `i` to 1 and return the new integer value. 3. **clear_bit(num: int, i: int) -> int**: Clear the bit at position `i` (set to 0) and return the new integer value. 4. **update_bit(num: int, i: int, bit: int) -> int**: Update the bit at position `i` to the given bit (0 or 1) and return the new integer value. Specifications 1. Input: - `num` is a 32-bit integer. - `i` is an integer representing the position of the bit (0-indexed from the least significant bit). - `bit` is either 0 or 1. 2. Output: - For `get_bit`: Return `True` if the bit is 1, otherwise `False`. - For the other methods: Return the modified integer after the bit operation. 3. Constraints: - Assume `num` is a valid 32-bit integer. - Assume `i` is within the range [0, 31]. Example ```python # Example control = ControlRegister() num = 23 # Binary: 10111 print(control.get_bit(num, 0)) # Output: True (1) print(control.set_bit(num, 1)) # Output: 23 (10111) print(control.clear_bit(num, 0)) # Output: 22 (10110) print(control.update_bit(num, 2, 1)) # Output: 27 (11011) print(control.update_bit(num, 3, 0)) # Output: 15 (01111) ``` Please implement and submit your `ControlRegister` class.","solution":"class ControlRegister: @staticmethod def get_bit(num: int, i: int) -> bool: Return the bit value (0 or 1) at position i. return (num & (1 << i)) != 0 @staticmethod def set_bit(num: int, i: int) -> int: Set the bit at position i to 1 and return the new integer value. return num | (1 << i) @staticmethod def clear_bit(num: int, i: int) -> int: Clear the bit at position i (set to 0) and return the new integer value. return num & ~(1 << i) @staticmethod def update_bit(num: int, i: int, bit: int) -> int: Update the bit at position i to the given bit (0 or 1) and return the new integer value. return (num & ~(1 << i)) | (bit << i)"}]'),S={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},C={class:"card-container"},F={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,c,a,s){const f=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>a.searchQuery=o),placeholder:"Search..."},null,512),[[_,a.searchQuery]]),a.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>a.searchQuery="")}," ✕ ")):u("",!0)]),t("div",C,[(n(!0),i(b,null,v(s.displayedPoems,(o,m)=>(n(),w(f,{key:m,poem:o},null,8,["poem"]))),128)),s.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+h(a.searchQuery)+'". ',1)):u("",!0)]),s.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:a.isLoading,onClick:e[2]||(e[2]=(...o)=>s.loadMore&&s.loadMore(...o))},[a.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const P=p(S,[["render",j],["__scopeId","data-v-aad86917"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/55.md","filePath":"drive/55.md"}'),B={name:"drive/55.md"},H=Object.assign(B,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,H as default};
