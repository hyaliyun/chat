import{_ as m,o as s,c as n,a as t,m as d,t as _,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},N={class:"review-content"};function E(i,e,u,c,r,a){return s(),n("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(_(u.poem.solution),1)])])])}const S=m(q,[["render",E],["__scopeId","data-v-1d013fd1"]]),R=JSON.parse(`[{"question":"from typing import List, Tuple def can_transform(s: str, t: str) -> bool: Determines if string s can be transformed to string t by reversing segments of s. >>> can_transform(\\"abac\\", \\"baca\\") True >>> can_transform(\\"hello\\", \\"holle\\") True >>> can_transform(\\"abcde\\", \\"edcba\\") True >>> can_transform(\\"abc\\", \\"def\\") False def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases and returns the results for each case. >>> test_cases = [(\\"abac\\", \\"baca\\"), (\\"hello\\", \\"holle\\"), (\\"abcde\\", \\"edcba\\")] >>> process_test_cases(test_cases) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> test_cases = [(\\"abc\\", \\"def\\"), (\\"abcd\\", \\"abc\\")] >>> process_test_cases(test_cases) [\\"NO\\", \\"NO\\"]","solution":"def can_transform(s, t): Determines if string s can be transformed to string t by reversing segments of s. return sorted(s) == sorted(t) def process_test_cases(test_cases): Processes multiple test cases and returns the results for each case. results = [] for s, t in test_cases: if can_transform(s, t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def maximize_area(l: int) -> (int, int): Given the length of the fencing material, return the width and height of the rectangle that maximizes the area and can be fully enclosed by the fencing. Examples: >>> maximize_area(14) in [(3, 4), (4, 3)] >>> maximize_area(20) in [(5, 5)] >>> w, h = maximize_area(1000000) >>> w + h == 1000000 // 2 >>> w * h == (1000000 // 4) ** 2 >>> maximize_area(4) in [(1, 1)] >>> w, h = maximize_area(999999) >>> w + h == 999999 // 2","solution":"def maximize_area(l): Given the length of the fencing material, this function returns the width and height of the rectangle that maximizes the area and can be fully enclosed by the fencing. max_area = 0 best_w = 1 best_h = l // 2 - 1 for w in range(1, l // 2): h = l // 2 - w area = w * h if area > max_area: max_area = area best_w = w best_h = h return best_w, best_h"},{"question":"def solution(T, cases): Determines whether it is possible to complete the project given the availability of the members. If it is possible, the function outputs all possible sets of intervals for each member that sum to the task requirement (8 hours). If it is not possible, output \\"Not possible\\". Args: T: int, number of test cases. cases: list of lists, where each list contains the number of members followed by the number of hours each member has available. Returns: List of strings with the result for each test case. Test Cases: >>> solution(2, [[4, 1, 2, 3, 2], [3, 5, 4, 7]]) [\\"Case #1: Possible\\", \\"Case #2: Not possible\\"] >>> solution(1, [[3, 3, 3, 3]]) [\\"Case #1: Not possible\\"] >>> solution(1, [[2, 8, 8]]) [\\"Case #1: Possible\\"] >>> solution(1, [[4, 1, 7, 3, 5]]) [\\"Case #1: Possible\\"] >>> solution(1, [[3, 1, 2, 3]]) [\\"Case #1: Not possible\\"]","solution":"def can_form_eight_hours(hours): n = len(hours) dp = [False] * 25 # We care up to sum 24 (maximum hour given by constraint) dp[0] = True for h in hours: for j in range(24, h-1, -1): dp[j] = dp[j] or dp[j-h] return dp[8] def solve(test_cases): results = [] case_number = 1 for hours in test_cases: if can_form_eight_hours(hours): results.append(f\\"Case #{case_number}: Possible\\") else: results.append(f\\"Case #{case_number}: Not possible\\") case_number += 1 return results def solution(T, cases): test_cases = [] for case in cases: N, *hours = case test_cases.append(hours) return solve(test_cases) # Example input and output # (normally, you would handle input from stdin and output to stdout) T = 2 cases = [ [4, 1, 2, 3, 2], [3, 5, 4, 7] ] output = solution(T, cases) for out in output: print(out)"},{"question":"def harvest_order(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[List[Tuple[int, int]]]: Identify the order in which the fruits should be harvested to maximize the magical power they absorb from the environment. >>> harvest_order(2, [(3, [(1, 2), (3, 1), (2, 2)]), (4, [(-1, -1), (2, 2), (-2, 2), (1, -1)])]) [[(1, 2), (2, 2), (3, 1)], [(-1, -1), (1, -1), (2, 2), (-2, 2)]] >>> harvest_order(1, [(5, [(0, 1), (1, 0), (1, 1), (-1, -1), (0, -1)])]) [[(0, 1), (1, 1), (1, 0), (0, -1), (-1, -1)]]","solution":"import math def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def harvest_order(t, test_cases): results = [] for i in range(t): n, fruits = test_cases[i] if n == 0: results.append([]) continue current_position = (0, 0) unvisited_fruits = fruits.copy() order_of_harvest = [] while unvisited_fruits: closest_fruit = min(unvisited_fruits, key=lambda fruit: euclidean_distance(current_position, fruit)) order_of_harvest.append(closest_fruit) unvisited_fruits.remove(closest_fruit) current_position = closest_fruit results.append(order_of_harvest) return results"},{"question":"def max_consecutive_buildings(heights: List[int]) -> int: Returns the maximum number of consecutive buildings with the same height. >>> max_consecutive_buildings([3, 3, 4, 4, 4, 2]) 3 >>> max_consecutive_buildings([1, 2, 3, 4, 5]) 1 >>> max_consecutive_buildings([5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) 10 def test_max_consecutive_buildings(): assert max_consecutive_buildings([3, 3, 4, 4, 4, 2]) == 3 assert max_consecutive_buildings([1, 2, 3, 4, 5]) == 1 assert max_consecutive_buildings([5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) == 10 assert max_consecutive_buildings([7]) == 1 assert max_consecutive_buildings([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 assert max_consecutive_buildings([2, 2, 2, 2, 2, 2, 2, 2]) == 8 assert max_consecutive_buildings([1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6]) == 4 assert max_consecutive_buildings([]) == 0","solution":"def max_consecutive_buildings(heights): Returns the maximum number of consecutive buildings with the same height. :param heights: List of integers representing the heights of buildings :return: Maximum number of consecutive buildings with the same height if not heights: return 0 max_count = 1 current_count = 1 for i in range(1, len(heights)): if heights[i] == heights[i - 1]: current_count += 1 max_count = max(max_count, current_count) else: current_count = 1 return max_count"},{"question":"def min_book_difference(N: int, A: List[int]) -> int: Returns the minimum possible difference between the maximum and minimum number of books in any section after any number of redistribution operations. >>> min_book_difference(5, [3, 5, 7, 7, 9]) 0 >>> min_book_difference(4, [10, 20, 30, 40]) 0 >>> min_book_difference(6, [2, 8, 15, 12, 10, 5]) 0 >>> min_book_difference(1, [10]) 0 >>> min_book_difference(4, [7, 7, 7, 7]) 0 >>> min_book_difference(3, [1000000000, 999999999, 1000000001]) 0 >>> min_book_difference(5, [0, 0, 0, 0, 0]) 0","solution":"def min_book_difference(N, A): Returns the minimum possible difference between the maximum and minimum number of books in any section after any number of redistribution operations. return 0"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Returns the minimum number of operations required to make all the elements of the array equal. n: int - number of elements in the array arr: list of int - elements of the array >>> min_operations_to_equal_elements(4, [1, 2, 3, 4]) 6 >>> min_operations_to_equal_elements(3, [10, 10, 10]) 0 >>> min_operations_to_equal_elements(5, [1, 1, 1, 1, 10]) 36 >>> min_operations_to_equal_elements(1, [1000000000]) 0 >>> min_operations_to_equal_elements(2, [999999999, 1000000000]) 1 >>> min_operations_to_equal_elements(3, [3, 1, 2]) 3","solution":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations required to make all the elements of the array equal. n: int - number of elements in the array arr: list of int - elements of the array # Find the maximum element in the array max_val = max(arr) # Compute the number of operations to make all elements equal to the maximum element operations = sum(max_val - x for x in arr) return operations"},{"question":"def min_operations(s: str, t: str) -> int: Calculate the minimum number of operations required to convert string s to string t. Args: s (str): Source string consisting of lowercase Latin letters. t (str): Target string consisting of lowercase Latin letters. Returns: int: The minimum number of operations required to convert s to t. Examples: >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"abcde\\", \\"fghij\\") 5 >>> min_operations(\\"a\\", \\"aaaaaa\\") 5 >>> min_operations(\\"aaaaaa\\", \\"a\\") 5","solution":"def min_operations(s: str, t: str) -> int: Calculate the minimum number of operations required to convert string s to string t. m, n = len(s), len(t) # DP table where dp[i][j] represents the minimum number of operations required to convert s[:i] to t[:j] dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for i in range(1, m + 1): dp[i][0] = i # All characters need to be removed from s for j in range(1, n + 1): dp[0][j] = j # All characters need to be inserted into s # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed if characters are the same else: dp[i][j] = min( dp[i - 1][j] + 1, # Remove a character from s dp[i][j - 1] + 1, # Insert a character into s dp[i - 1][j - 1] + 1 # Replace a character in s ) return dp[m][n]"},{"question":"def min_reassignments(n: int, m: int, days: List[int]) -> int: Returns the minimum number of reassigned runners to achieve a balanced schedule. :param n: Number of runners :param m: Number of days :param days: List of integers representing preferred days of each runner :return: Minimum number of reassignments >>> min_reassignments(7, 3, [1, 1, 1, 2, 2, 2, 3]) 1 >>> min_reassignments(5, 2, [1, 2, 2, 2, 2]) 1 >>> min_reassignments(4, 2, [1, 2, 1, 2]) 0 >>> min_reassignments(4, 4, [1, 1, 1, 1]) 3 >>> min_reassignments(9, 3, [1, 1, 1, 2, 2, 2, 3, 3, 3]) 0 >>> min_reassignments(7, 3, [1, 2, 2, 3, 3, 3, 3]) 1 >>> min_reassignments(10, 5, [1, 2, 3, 4, 5, 5, 5, 5, 5, 5]) 4","solution":"def min_reassignments(n, m, days): Returns the minimum number of reassigned runners to achieve a balanced schedule. :param n: Number of runners :param m: Number of days :param days: List of integers representing preferred days of each runner :return: Minimum number of reassignments from collections import Counter count = Counter(days) ideal_per_day = n // m extra_needed = n % m reassignments = 0 for day in range(1, m + 1): if count[day] > ideal_per_day: extra_runners = count[day] - ideal_per_day - (1 if extra_needed > 0 else 0) if extra_needed > 0: extra_needed -= 1 if extra_runners > 0: reassignments += extra_runners return reassignments"},{"question":"def min_elevator_trips(capacity, floors, start, people): Determines the minimum number of trips the elevator needs to transport all people to their respective destination floors. :param capacity: int, elevator's carrying capacity :param floors: int, total number of floors in the building :param start: int, initial floor where the elevator is currently located :param people: list of tuples, each tuple (a, b) represents a person with start floor a and destination floor b :return: int, minimum number of trips needed >>> min_elevator_trips(2, 10, 1, [(1, 2), (1, 3), (1, 4), (2, 3)]) 2 >>> min_elevator_trips(3, 5, 2, [(2, 4), (3, 5), (1, 5), (1, 2), (2, 3)]) 2 >>> min_elevator_trips(5, 10, 1, [(1, 2), (1, 3), (1, 4), (1, 5)]) 1 >>> min_elevator_trips(1, 10, 1, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 5 >>> min_elevator_trips(2, 4, 1, [(1, 2), (1, 4), (2, 3), (2, 4)]) 2 >>> min_elevator_trips(2, 10, 1, []) 0","solution":"def min_elevator_trips(capacity, floors, start, people): Determines the minimum number of trips the elevator needs to transport all people to their respective destination floors. :param capacity: int, elevator's carrying capacity :param floors: int, total number of floors in the building :param start: int, initial floor where the elevator is currently located :param people: list of tuples, each tuple (a, b) represents a person with start floor a and destination floor b :return: int, minimum number of trips needed trips = 0 # Sort people by their start floor for more efficient grouping people.sort() # Traverse through the people list in batches upto the capacity for i in range(0, len(people), capacity): group = people[i:i + capacity] # Count floors to the highest destination in this group max_floor = max(p[1] for p in group) trips += 1 # A single trip for this group return trips"},{"question":"def move_camel(w, m, watering_stations, plans): Determines the final coordinates of the camel after moving in a desolate land based on the given watering stations, initial positions, directions, and steps. Parameters: - w (int): Number of watering stations. - m (int): Size of the grid. - watering_stations (list of tuples): List containing each watering station's coordinates (xi, yi). - plans (list of tuples): List containing each plan in the format (xj, yj, dj, tj). Returns: - list of tuples: Final coordinates of the camel for each plan. import pytest def test_camel_movement(): w = 3 m = 5 watering_stations = [(1, 2), (3, 3), (4, 1)] plans = [ (0, 0, 'N', 2), (2, 2, 'E', 4), (5, 5, 'S', 3), (1, 1, 'W', 6) ] result = move_camel(w, m, watering_stations, plans) assert result == [(0, 2), (5, 2), (5, 2), (0, 1)] def test_camel_movement_no_watering_stations(): w = 0 m = 5 watering_stations = [] plans = [ (0, 0, 'N', 6), (5, 5, 'S', 10), (2, 2, 'E', 4), (1, 1, 'W', 1) ] result = move_camel(w, m, watering_stations, plans) assert result == [(0, 5), (5, 0), (5, 2), (0, 1)] def test_camel_movement_boundary_conditions(): w = 5 m = 10 watering_stations = [(2, 2), (5, 5), (10, 10), (0, 0), (1, 1)] plans = [ (0, 0, 'N', 100), (10, 10, 'S', 100), (5, 5, 'E', 100), (1, 1, 'W', 100) ] result = move_camel(w, m, watering_stations, plans) assert result == [(0, 10), (10, 0), (10, 5), (0, 1)] if __name__ == \\"__main__\\": pytest.main()","solution":"def move_camel(w, m, watering_stations, plans): Determines the final coordinates of the camel after moving in a desolate land based on the given watering stations, initial positions, directions, and steps. Parameters: - w (int): Number of watering stations. - m (int): Size of the grid. - watering_stations (list of tuples): List containing each watering station's coordinates (xi, yi). - plans (list of tuples): List containing each plan in the format (xj, yj, dj, tj). Returns: - list of tuples: Final coordinates of the camel for each plan. watering_set = set(watering_stations) results = [] for plan in plans: x, y, direction, steps = plan if direction == 'N': y = min(m, y + steps) elif direction == 'S': y = max(0, y - steps) elif direction == 'E': x = min(m, x + steps) elif direction == 'W': x = max(0, x - steps) results.append((x, y)) return results"},{"question":"def is_palindrome(num: int) -> bool: Checks if a number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(12321) True >>> is_palindrome(123) False >>> is_palindrome(45654) True >>> is_palindrome(1221) True >>> is_palindrome(12345) False pass def check_palindromes(numbers: List[int]) -> List[str]: Checks a list of numbers to determine if they are palindromes or not. Args: numbers: A list of integers Returns: A list of strings stating whether each number is a palindrome or not. >>> check_palindromes([121, 12321, 123, 45654]) ['121 is a palindrome', '12321 is a palindrome', '123 is not a palindrome', '45654 is a palindrome'] >>> check_palindromes([1, 22, 333, 4444]) ['1 is a palindrome', '22 is a palindrome', '333 is a palindrome', '4444 is a palindrome'] >>> check_palindromes([10, 20, 30, 40]) ['10 is not a palindrome', '20 is not a palindrome', '30 is not a palindrome', '40 is not a palindrome'] pass","solution":"def is_palindrome(num): Checks if a number is a palindrome. return str(num) == str(num)[::-1] def check_palindromes(numbers): Checks a list of numbers to determine if they are palindromes. Args: numbers: A list of integers Returns: A list of strings stating whether each number is a palindrome or not. results = [] for num in numbers: if is_palindrome(num): results.append(f\\"{num} is a palindrome\\") else: results.append(f\\"{num} is not a palindrome\\") return results"},{"question":"def count_one_bits(x: int) -> int: Given an integer \`x\` (1 ≤ x ≤ 1000000000), determine the number of '1' bits in its binary representation. Args: x: int - the integer to be converted into binary and count '1' bits (1 ≤ x ≤ 1000000000) Returns: int - the number of '1' bits in the binary representation of x Examples: >>> count_one_bits(5) 2 >>> count_one_bits(7) 3 >>> count_one_bits(32) 1 >>> count_one_bits(255) 8 >>> count_one_bits(1023) 10","solution":"def count_one_bits(x): Returns the number of '1' bits in the binary representation of x. Args: x: int - the integer to be converted into binary and count '1' bits (1 ≤ x ≤ 1000000000) Returns: int - the number of '1' bits in the binary representation of x return bin(x).count('1')"},{"question":"def max_non_overlapping_activities(n, activities): Given n activities with their start and finish times, determine the maximum number of activities that can be selected without any overlapping. :param n: int - number of activities :param activities: List[Tuple[int, int]] - list of (start_time, finish_time) tuples :return: int - maximum number of non-overlapping activities Examples: >>> max_non_overlapping_activities(6, [(1, 3), (2, 5), (4, 6), (6, 8), (5, 9), (8, 10)]) 4 >>> max_non_overlapping_activities(4, [(0, 6), (1, 2), (2, 4), (5, 7)]) 3","solution":"def max_non_overlapping_activities(n, activities): Returns the maximum number of non-overlapping activities that can be selected. :param n: int - number of activities :param activities: List[Tuple[int, int]] - list of (start_time, finish_time) tuples :return: int - maximum number of non-overlapping activities # Sort activities based on their finish times sorted_activities = sorted(activities, key=lambda x: x[1]) # Initialize the end time of the last selected activity last_end_time = -1 max_activities = 0 for start, end in sorted_activities: if start >= last_end_time: max_activities += 1 last_end_time = end return max_activities"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Calculate the maximum sum of a contiguous subarray. Given an array of integers, compute the maximum sum of any contiguous subarray. This problem can efficiently be solved using Kadane's algorithm. Args: nums (List[int]): A list of integers representing the array. Returns: int: The maximum sum of the contiguous subarray. Examples: >>> max_subarray_sum([8, -19, 5, -4, 20]) 21 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1, -2, -3, -4]) -1","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Function to compute the maximum sum of a contiguous subarray using Kadane's algorithm. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_pair_with_sum(n, target, array): Returns the indices (1-based) of two elements in the array whose sum equals the target. If no such pair exists, returns an empty list. >>> find_pair_with_sum(4, 9, [2, 7, 11, 15]) [1, 2] >>> find_pair_with_sum(5, 10, [1, 2, 3, 4, 5]) [] >>> find_pair_with_sum(3, 7, [3, 2, 4]) [1, 3] def process_test_cases(test_cases): Processes a list of test cases, returning the sum pair indices for each. >>> process_test_cases([(4, 9, [2, 7, 11, 15]), (5, 10, [1, 2, 3, 4, 5]), (3, 7, [3, 2, 4])]) [[1, 2], [], [1, 3]]","solution":"def find_pair_with_sum(n, target, array): Returns the indices (1-based) of two elements in the array whose sum equals the target. If no such pair exists, returns an empty list. seen = {} for i in range(n): complement = target - array[i] if complement in seen: return [seen[complement] + 1, i + 1] seen[array[i]] = i return [] def process_test_cases(test_cases): results = [] for n, target, array in test_cases: result = find_pair_with_sum(n, target, array) results.append(result) return results"},{"question":"def min_trimming_operations(n: int, heights: List[int]) -> int: Calculate the minimum number of trimming operations required to make all plants the same height. Parameters: n (int): Number of plants heights (list of int): List of heights of the plants Returns: int: The minimum number of trimming operations Examples: >>> min_trimming_operations(5, [4, 3, 6, 3, 5]) 6 >>> min_trimming_operations(3, [10, 10, 10]) 0 >>> min_trimming_operations(4, [4, 7, 10, 13]) 18 >>> min_trimming_operations(5, [7, 7, 7, 7, 7]) 0 >>> min_trimming_operations(3, [1, 1, 2]) 1 >>> min_trimming_operations(4, [8, 6, 4, 2]) 12","solution":"def min_trimming_operations(n, heights): Calculate the minimum number of trimming operations required to make all plants the same height. Parameters: n (int): Number of plants heights (list of int): List of heights of the plants Returns: int: The minimum number of trimming operations min_height = min(heights) return sum(height - min_height for height in heights)"},{"question":"def lcs(str1: str, str2: str) -> int: Helper function to find the length of the Longest Common Subsequence (LCS) of str1 and str2. n, m = len(str1), len(str2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] def shortest_common_supersequence_length(str1: str, str2: str) -> int: Returns the length of the shortest common supersequence of str1 and str2. >>> shortest_common_supersequence_length(\\"abc\\", \\"ac\\") 3 >>> shortest_common_supersequence_length(\\"geek\\", \\"eke\\") 5 >>> shortest_common_supersequence_length(\\"blake\\", \\"lake\\") 5","solution":"def lcs(str1, str2): Helper function to find the length of the Longest Common Subsequence (LCS) of str1 and str2. n, m = len(str1), len(str2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] def shortest_common_supersequence_length(str1, str2): Returns the length of the shortest common supersequence of str1 and str2. lcs_length = lcs(str1, str2) return len(str1) + len(str2) - lcs_length"},{"question":"def is_prime(num): Helper function to check if a number is prime. pass def find_primes(numbers): Returns a list of prime numbers from the given list of integers. If no prime numbers are found, returns \\"No primes\\". pass # Example Test Cases def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(1) == False assert is_prime(0) == False assert is_prime(97) == True assert is_prime(100000) == False def test_find_primes(): assert find_primes([10, 15, 3, 7, 12, 19]) == [3, 7, 19] assert find_primes([4, 6, 8, 10, 12]) == \\"No primes\\" assert find_primes([2, 3, 5, 7, 11, 13]) == [2, 3, 5, 7, 11, 13] assert find_primes([]) == \\"No primes\\" assert find_primes([0, 1, 100000]) == \\"No primes\\"","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def find_primes(numbers): Returns a list of prime numbers from the given list of integers. primes = [num for num in numbers if is_prime(num)] if not primes: return \\"No primes\\" return primes"},{"question":"def longest_increasing_subsequence(seq: List[int]) -> int: Determines the length of the longest increasing subsequence in a given sequence of integers. >>> longest_increasing_subsequence([5, 2, 8, 6, 3, 6]) 3 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([9, 8, 7, 6, 5, 4]) 1 >>> longest_increasing_subsequence([5]) 1 >>> longest_increasing_subsequence([1, 2, 2, 3]) 3 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4","solution":"def longest_increasing_subsequence(seq): if not seq: return 0 # Initialize the dp array where dp[i] represents the length of the longest increasing subsequence ending at i dp = [1] * len(seq) for i in range(1, len(seq)): for j in range(i): if seq[i] > seq[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def longest_increasing_subsequence(n: int, patients: List[int]) -> int: Find the length of the longest sequence of consecutive days with an increasing number of diagnosed patients. >>> longest_increasing_subsequence(7, [2, 3, 5, 3, 6, 7, 1]) == 3 >>> longest_increasing_subsequence(5, [1, 2, 3, 4, 5]) == 5 >>> longest_increasing_subsequence(6, [5, 4, 3, 2, 1, 0]) == 1","solution":"def longest_increasing_subsequence(n, patients): if n == 0: return 0 max_len = 1 current_len = 1 for i in range(1, n): if patients[i] > patients[i-1]: current_len += 1 else: if current_len > max_len: max_len = current_len current_len = 1 if current_len > max_len: max_len = current_len return max_len"},{"question":"def first_day_to_meet_target(n: int, t: int, challenge_data: List[Tuple[str, int]]) -> str: Determines the first day when the total number of challenges completed meets or exceeds the target. Args: n: int - Number of days with challenge data. t: int - Target number of challenges. challenge_data: list of tuples - Each tuple contains a date (str) and an integer representing the challenges completed on that date. Returns: str - The date when the cumulative challenges meet or exceed the target or \\"Not achieved\\". >>> first_day_to_meet_target(5, 7, [(\\"2023-01-01\\", 2), (\\"2023-01-02\\", 3), (\\"2023-01-03\\", 0), (\\"2023-01-04\\", 4), (\\"2023-01-05\\", 1)]) \\"2023-01-04\\" >>> first_day_to_meet_target(3, 10, [(\\"2021-12-25\\", 1), (\\"2021-12-26\\", 2), (\\"2021-12-27\\", 3)]) \\"Not achieved\\"","solution":"def first_day_to_meet_target(n, t, challenge_data): Determines the first day when the total number of challenges completed meets or exceeds the target. Args: n: int - Number of days with challenge data. t: int - Target number of challenges. challenge_data: list of tuples - Each tuple contains a date (str) and an integer representing the challenges completed on that date. Returns: str - The date when the cumulative challenges meet or exceed the target or \\"Not achieved\\". total_completed = 0 for date, challenges in challenge_data: total_completed += challenges if total_completed >= t: return date return \\"Not achieved\\""},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Finds the longest subsequence of the given list of integers such that every two consecutive numbers in this subsequence have a difference of exactly 1. >>> longest_consecutive_subsequence([1, 2, 3, 4, 2, 1, 5, 6, 3, 4, 4, 3]) 6 >>> longest_consecutive_subsequence([10, 5, 20, 15]) 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5]) 5","solution":"def longest_consecutive_subsequence(arr): if not arr: return 0 arr_set = set(arr) longest_streak = 0 for num in arr: if num - 1 not in arr_set: current_num = num current_streak = 1 while current_num + 1 in arr_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def next_palindrome(X: int) -> int: Returns the smallest palindrome larger than X. >>> next_palindrome(123) == 131 >>> next_palindrome(1) == 2 >>> next_palindrome(9) == 11 >>> next_palindrome(10) == 11 >>> next_palindrome(88) == 99 >>> next_palindrome(123) == 131 >>> next_palindrome(738) == 747 >>> next_palindrome(999999) == 1000001 >>> next_palindrome(9999499999) == 9999559999 >>> next_palindrome(111) == 121 >>> next_palindrome(999) == 1001","solution":"def next_palindrome(X): Returns the smallest palindrome larger than X. def is_palindrome(n): return str(n) == str(n)[::-1] X += 1 while not is_palindrome(X): X += 1 return X"},{"question":"def max_island_size(grid: List[List[int]]) -> int: Returns the maximum size of an island in the grid. >>> max_island_size([ ... [1, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 1, 0], ... [0, 1, 1, 0] ... ]) 3 >>> max_island_size([ ... [1, 0, 1], ... [1, 0, 1], ... [0, 1, 0] ... ]) 2 >>> max_island_size([ ... [0, 0, 0, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 1, 1, 0], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 0, 0] ... ]) 2 pass","solution":"def max_island_size(grid): Returns the maximum size of an island in the grid. n = len(grid) max_island = 0 def dfs(x, y): if x < 0 or y < 0 or x >= n or y >= n or grid[x][y] == 0: return 0 # Mark the cell as visited by setting it to 0 grid[x][y] = 0 size = 1 # Explore in all four directions size += dfs(x - 1, y) size += dfs(x + 1, y) size += dfs(x, y - 1) size += dfs(x, y + 1) return size for i in range(n): for j in range(n): if grid[i][j] == 1: # Perform DFS to find the size of the island island_size = dfs(i, j) max_island = max(max_island, island_size) return max_island"},{"question":"def total_visitors(visitor_counts, queries): Computes the total number of visitors for the subarray from index a to index b for each query. Parameters: visitor_counts (list of int): The number of visitors for each ride. queries (list of tuples): Each tuple contains two integers (a, b) representing the range. Returns: list of int: The sum of visitors for each of the query ranges. >>> visitor_counts = [50, 20, 30, 40, 90, 70, 60, 80] >>> queries = [(1, 3), (2, 5)] >>> total_visitors(visitor_counts, queries) [90, 230] >>> visitor_counts = [10, 10, 10, 10, 10] >>> queries = [(0, 4), (1, 3), (0, 0)] >>> total_visitors(visitor_counts, queries) [50, 30, 10] >>> visitor_counts = [1, 2, 3, 4, 5] >>> queries = [(0, 2), (2, 4), (1, 3)] >>> total_visitors(visitor_counts, queries) [6, 12, 9] >>> visitor_counts = [5] >>> queries = [(0, 0)] >>> total_visitors(visitor_counts, queries) [5] >>> visitor_counts = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> queries = [(0, 9), (3, 5), (1, 7)] >>> total_visitors(visitor_counts, queries) [55, 15, 35]","solution":"def total_visitors(visitor_counts, queries): Computes the total number of visitors for the subarray from index a to index b for each query. Parameters: visitor_counts (list of int): The number of visitors for each ride. queries (list of tuples): Each tuple contains two integers (a, b) representing the range. Returns: list of int: The sum of visitors for each of the query ranges. # Precompute the prefix sum array prefix_sum = [0] * (len(visitor_counts) + 1) for i in range(len(visitor_counts)): prefix_sum[i + 1] = prefix_sum[i] + visitor_counts[i] # Process each query and compute the sum using the prefix sum array result = [] for a, b in queries: sum_visitors = prefix_sum[b + 1] - prefix_sum[a] result.append(sum_visitors) return result"},{"question":"def min_difference(n: int, skill_scores: List[int]) -> int: This function calculates the minimum possible absolute difference between the sums of skill scores of two projects formed from n employees. :param int n: Number of employees :param list skill_scores: List of skill scores :return: Minimum possible absolute difference between sums of two projects :rtype: int pass # Test cases def test_case_1(): assert min_difference(4, [10, 20, 30, 40]) == 0 def test_case_2(): assert min_difference(5, [10, 10, 10, 10, 10]) == 10 def test_case_3(): assert min_difference(3, [1, 4, 5]) == 0 def test_case_4(): assert min_difference(2, [10, 20]) == 10 def test_case_5(): assert min_difference(6, [10, 10, 10, 10, 10, 10]) == 0 def test_case_6(): assert min_difference(5, [1, 2, 3, 4, 5]) == 1","solution":"def min_difference(n, skill_scores): This function calculates the minimum possible absolute difference between the sums of skill scores of two projects formed from n employees. :param int n: Number of employees :param list skill_scores: List of skill scores :return: Minimum possible absolute difference between sums of two projects :rtype: int total_sum = sum(skill_scores) # Initialize dp array dp = [[False] * (total_sum + 1) for _ in range(n + 1)] dp[0][0] = True # Populate dp array for i in range(1, n + 1): for j in range(total_sum + 1): dp[i][j] = dp[i-1][j] if j >= skill_scores[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j - skill_scores[i-1]] min_diff = total_sum for j in range(total_sum // 2 + 1): if dp[n][j]: current_diff = abs((total_sum - j) - j) min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def manage_warehouse(n: int, operations: List[str]) -> List[int]: Simulates a warehouse management system (WMS). Manage the inventory in the warehouse and process a series of operations on the inventory. Operations: STOCK item quantity: Increase the quantity of a specific item in the inventory. SELL item quantity: Decrease the quantity of a specific item in the inventory. CHECK item: Return the current quantity of a specific item in the inventory. Args: n (int): number of operations operations (List[str]): list of operations Returns: List[int]: results of each \\"Check\\" operation Example: >>> manage_warehouse(6, [\\"STOCK apple 50\\", \\"STOCK banana 30\\", \\"SELL apple 10\\", \\"CHECK apple\\", \\"CHECK banana\\", \\"SELL banana 5\\", \\"CHECK banana\\"]) [40, 30, 25]","solution":"def manage_warehouse(n, operations): inventory = {} results = [] for operation in operations: parts = operation.split() action = parts[0] item = parts[1] if action == \\"STOCK\\": quantity = int(parts[2]) if item in inventory: inventory[item] += quantity else: inventory[item] = quantity elif action == \\"SELL\\": quantity = int(parts[2]) if item in inventory: inventory[item] -= quantity if inventory[item] < 0: # Sanity check, although problem guarantees non-negative quantities. inventory[item] = 0 elif action == \\"CHECK\\": if item in inventory: results.append(inventory[item]) else: results.append(0) return results"},{"question":"from typing import List, Union, Tuple def find_task_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determine a valid order to complete all tasks such that the dependencies are respected. Parameters: n (int): The number of tasks. m (int): The number of dependencies. dependencies (List[Tuple[int, int]]): Each tuple contains two integers u and v, indicating that task u must be completed before task v. Returns: Union[List[int], str]: One valid order to complete all tasks, or \\"NO SOLUTION\\" if no valid order exists. >>> find_task_order(4, 3, [(1, 2), (1, 3), (3, 4)]) [1, 3, 4, 2] >>> find_task_order(3, 2, [(1, 2), (2, 3)]) [1, 2, 3] >>> find_task_order(2, 2, [(1, 2), (2, 1)]) 'NO SOLUTION' >>> find_task_order(5, 0, []) [1, 2, 3, 4, 5] >>> find_task_order(1, 0, []) [1] >>> find_task_order(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 'NO SOLUTION'","solution":"from collections import defaultdict, deque def find_task_order(n, m, dependencies): adj_list = defaultdict(list) indegree = defaultdict(int) # Initialize indegree for all tasks for i in range(1, n + 1): indegree[i] = 0 # Build the adjacency list and indegree counters for u, v in dependencies: adj_list[u].append(v) indegree[v] += 1 # Use a queue for Kahn's algorithm queue = deque() # Enqueue all tasks with no dependencies (indegree 0) for i in range(1, n + 1): if indegree[i] == 0: queue.append(i) order = [] while queue: curr = queue.popleft() order.append(curr) # Reduce the indegree of adjacent nodes for neighbor in adj_list[curr]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all tasks are processed, return the order; otherwise, return \\"NO SOLUTION\\" if len(order) == n: return order else: return \\"NO SOLUTION\\" # Example usage: # n, m = 4, 3 # dependencies = [(1, 2), (1, 3), (3, 4)] # print(find_task_order(n, m, dependencies)) # Output: [1 3 4 2] or [1 2 3 4]"},{"question":"def restore_sequence(n: int, matrix: List[List[int]]) -> List[int]: Restore the sequence of numbers a1, a2, ..., an from the matrix. Parameters: n (int): The size of the square matrix. matrix (List[List[int]]): The n x n matrix. Returns: List[int]: The sequence of numbers. Examples: >>> restore_sequence(1, [[7]]) [7] >>> restore_sequence(3, [[4, 5, 7], [5, 8, 7], [7, 7, 9]]) [4, 8, 9] >>> restore_sequence(4, [[12, 14, 15, 13], [14, 13, 14, 15], [15, 14, 15, 15], [13, 15, 15, 15]]) [12, 13, 15, 15]","solution":"def restore_sequence(n, matrix): Restore the sequence of numbers a1, a2, ..., an from the matrix. # Since c[i][i] = ai, we just need to collect the diagonal elements of the matrix sequence = [matrix[i][i] for i in range(n)] return sequence"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string s. n = len(s) if n == 0: return 0 longest = 1 for i in range(n): # Odd-length palindromes l, r = i, i while l >= 0 and r < n and s[l] == s[r]: l -= 1 r += 1 longest = max(longest, r - l - 1) # Even-length palindromes l, r = i, i + 1 while l >= 0 and r < n and s[l] == s[r]: l -= 1 r += 1 longest = max(longest, r - l - 1) return longest"},{"question":"def rotate_and_count_freq(n: int, k: int, s: str) -> List[int]: Rotates the string to the left by one position exactly k times and returns the frequency of each character in the resulting string. Parameters: n (int): The length of the string. k (int): The number of rotations. s (str): The string to be rotated. Returns: List[int]: List of 26 integers representing the frequencies of each alphabet in the rotated string. >>> rotate_and_count_freq(5, 2, 'abcde') [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> rotate_and_count_freq(6, 4, 'aabbcc') [2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> rotate_and_count_freq(5, 1000000000, 'abcde') [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] >>> rotate_and_count_freq(1, 1, 'a') [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]","solution":"def rotate_and_count_freq(n, k, s): Rotates the string to the left by one position exactly k times and returns the frequency of each character in the resulting string. Parameters: n (int): The length of the string. k (int): The number of rotations. s (str): The string to be rotated. Returns: List[int]: List of 26 integers representing the frequencies of each alphabet in the rotated string. k = k % n # Reduce the number of rotations rotated_string = s[k:] + s[:k] # Perform the rotations # Calculate the frequency of each character freq = [0] * 26 for char in rotated_string: freq[ord(char) - ord('a')] += 1 return freq"},{"question":"from typing import List, Tuple def pacific_atlantic(matrix: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]: Find all cells where rainwater can flow to both the Pacific and Atlantic ocean. The Pacific ocean touches the left and top edges of the matrix, and the Atlantic ocean touches the right and bottom edges. Rainwater can flow from one cell to another cell directly north, south, east, or west if the altitude of the next cell is less than or equal to the current cell's altitude. Args: matrix: A 2D list of integers representing the altitude of each cell in the matrix. Returns: A tuple containing the number of grid coordinates where rainwater can flow to both the Pacific and Atlantic oceans and a list of these coordinates. Example: >>> grid = [ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ] >>> pacific_atlantic(grid) (7, [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)]) pass def test_case_1(): grid = [ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ] expected_length = 7 expected_result = [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] result_length, result = pacific_atlantic(grid) assert result_length == expected_length assert result == expected_result def test_case_2(): grid = [ [1, 1], [1, 1] ] expected_length = 4 expected_result = [(0, 0), (0, 1), (1, 0), (1, 1)] result_length, result = pacific_atlantic(grid) assert result_length == expected_length assert result == expected_result def test_case_3(): grid = [ [10, 10, 10], [10, 1, 10], [10, 10, 10] ] expected_length = 8 expected_result = [ (0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2) ] result_length, result = pacific_atlantic(grid) assert result_length == expected_length assert result == expected_result def test_case_4(): grid = [ [1] ] expected_length = 1 expected_result = [(0, 0)] result_length, result = pacific_atlantic(grid) assert result_length == expected_length assert result == expected_result","solution":"def pacific_atlantic(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) def bfs(starts): reachable = set(starts) queue = starts[:] while queue: r, c = queue.pop(0) for (dr, dc) in ((0, 1), (1, 0), (0, -1), (-1, 0)): nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in reachable and matrix[nr][nc] >= matrix[r][c]: queue.append((nr, nc)) reachable.add((nr, nc)) return reachable pacific_starts = [(0, c) for c in range(n)] + [(r, 0) for r in range(1, m)] atlantic_starts = [(m-1, c) for c in range(n)] + [(r, n-1) for r in range(m-1)] pacific_reachable = bfs(pacific_starts) atlantic_reachable = bfs(atlantic_starts) result = list(pacific_reachable & atlantic_reachable) result.sort() # Ensure the order is consistent for easier testing return len(result), result"},{"question":"def edit_distance(s1: str, s2: str) -> int: Determine the minimum number of operations required to convert s1 into s2 using the following operations: 1. Delete a character from s1. 2. Insert a character into s1. 3. Replace a character in s1 with another character. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of operations required to convert s1 into s2. Examples: >>> edit_distance(\\"horse\\", \\"ros\\") 3 >>> edit_distance(\\"intention\\", \\"execution\\") 5 >>> edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> edit_distance(\\"aaa\\", \\"\\") 3 >>> edit_distance(\\"\\", \\"bbb\\") 3 >>> edit_distance(\\"samestring\\", \\"samestring\\") 0 >>> edit_distance(\\"CaseSensitive\\", \\"casesensitive\\") 2","solution":"def edit_distance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. m = len(s1) n = len(s2) # Create a table to store results of subproblems dp = [[0 for x in range(n + 1)] for x in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are the same, ignore the last character and recur for the remaining substring elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def count_paths(grid: List[List[int]]) -> int: Returns the number of distinct valid paths from the top-left to the bottom-right corner of the grid. >>> count_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0]]) 2 >>> count_paths([ ... [0, 0], ... [1, 0]]) 1 >>> count_paths([ ... [0, 1], ... [1, 0]]) 0 >>> count_paths([ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0]]) 3 >>> count_paths([ ... [0] * 10]) 1 >>> count_paths([ ... [0]]) 1","solution":"def count_paths(grid): Returns the number of distinct valid paths from top-left to bottom-right of a grid. m, n = len(grid), len(grid[0]) memo = {} def dfs(x, y): if (x, y) in memo: return memo[(x, y)] if x == m - 1 and y == n - 1: return 1 if x >= m or y >= n or grid[x][y] == 1: return 0 right_paths = dfs(x, y + 1) down_paths = dfs(x + 1, y) memo[(x, y)] = right_paths + down_paths return memo[(x, y)] return dfs(0, 0)"},{"question":"def min_replacements_to_palindrome(n: int, sequence: List[int]) -> int: Determine the minimum number of replacements needed to make the sequence palindromic. >>> min_replacements_to_palindrome(5, [1, 2, 3, 2, 1]) 0 >>> min_replacements_to_palindrome(4, [1, 2, 3, 4]) 2","solution":"def min_replacements_to_palindrome(n, sequence): left = 0 right = n - 1 replacements = 0 while left < right: if sequence[left] != sequence[right]: replacements += 1 left += 1 right -= 1 return replacements"},{"question":"def longest_largest_sum_subarray(A: List[int], n: int) -> List[int]: Returns the contiguous subarray with the largest sum. >>> longest_largest_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4], 9) [4, -1, 2, 1] >>> longest_largest_sum_subarray([-1], 1) [-1] >>> longest_largest_sum_subarray([-4, -2, -3, -1], 4) [-1] >>> longest_largest_sum_subarray([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> longest_largest_sum_subarray([1, -2, 3, 4, -5, 8], 6) [3, 4, -5, 8] pass","solution":"def longest_largest_sum_subarray(A, n): Returns the contiguous subarray with the largest sum. max_sum = -float('inf') current_sum = 0 start = end = s = 0 for i in range(n): current_sum += A[i] if max_sum < current_sum: max_sum = current_sum start = s end = i if current_sum < 0: current_sum = 0 s = i + 1 return A[start:end+1] # Sample usage A = [-2, 1, -3, 4, -1, 2, 1, -5, 4] n = 9 print(longest_largest_sum_subarray(A, n)) # Output: [4, -1, 2, 1]"},{"question":"def minimum_paid_meals(n: int, visits: list[int]) -> int: Returns the minimum number of meals to be paid for by all customers combined. Parameters: n (int): The number of customers. visits (list of int): The number of times each customer plans to visit the restaurant. Returns: int: The minimum number of meals that need to be paid for. >>> minimum_paid_meals(4, [2, 3, 1, 4]) 6 >>> minimum_paid_meals(1, [1]) 1 >>> minimum_paid_meals(1, [5]) 3 >>> minimum_paid_meals(3, [1, 1, 1]) 3 >>> minimum_paid_meals(3, [3, 3, 3]) 6 >>> minimum_paid_meals(2, [10000, 9999]) 10000 >>> minimum_paid_meals(2, [1, 10000]) 5001","solution":"def minimum_paid_meals(n, visits): Returns the minimum number of meals to be paid for by all customers combined. Parameters: n (int): The number of customers. visits (list of int): The number of times each customer plans to visit the restaurant. Returns: int: The minimum number of meals that need to be paid for. total_paid_meals = 0 for visit in visits: paid_meals = (visit + 1) // 2 total_paid_meals += paid_meals return total_paid_meals"},{"question":"def sum_of_arithmetic_progression(n: int, d: int) -> int: Returns the sum of the first n terms of the arithmetic progression with the first term 1 and common difference d. >>> sum_of_arithmetic_progression(5, 3) 35 >>> sum_of_arithmetic_progression(3, 5) 18 >>> sum_of_arithmetic_progression(2, 1) 3 >>> sum_of_arithmetic_progression(100000, 1) 5000050000 >>> sum_of_arithmetic_progression(2, 1000) 1002","solution":"def sum_of_arithmetic_progression(n, d): Returns the sum of the first n terms of the arithmetic progression with the first term 1 and common difference d. # Using formula for the nth term of an arithmetic sequence: a_n = a + (n-1)d # Here, a (the first term) is 1, so the nth term a_n = 1 + (n-1)d # Sum of the first n terms of an arithmetic sequence S_n = n/2 * (first term + nth term) nth_term = 1 + (n - 1) * d ap_sum = n * (1 + nth_term) // 2 return ap_sum"},{"question":"def is_special_number(num: int) -> str: Determines if a number is a \\"Special\\" number. A number is special if the sum of its digits raised to the power of their respective positions (1-based index) equals the number itself. Parameters: num (int): The number to be checked. Returns: str: \\"YES\\" if the number is special, otherwise \\"NO\\". >>> is_special_number(89) \\"YES\\" >>> is_special_number(100) \\"NO\\" >>> is_special_number(1) \\"YES\\" >>> is_special_number(10) \\"NO\\" >>> is_special_number(135) \\"YES\\" >>> is_special_number(987) \\"NO\\"","solution":"def is_special_number(num): Determines if a number is a \\"Special\\" number. A number is special if the sum of its digits raised to the power of their respective positions (1-based index) equals the number itself. Parameters: num (int): The number to be checked. Returns: str: \\"YES\\" if the number is special, otherwise \\"NO\\". digits = list(str(num)) sum_powers = sum(int(digit) ** (index + 1) for index, digit in enumerate(digits)) return \\"YES\\" if sum_powers == num else \\"NO\\""},{"question":"def rob(nums: List[int]) -> int: Determine the maximum amount of money you can rob without alerting the police. >>> rob([]) 0 >>> rob([5]) 5 >>> rob([2, 3]) 3 >>> rob([5, 1]) 5 >>> rob([2, 3, 2]) 4 >>> rob([1, 2, 3, 1]) 4 >>> rob([5, 9, 1, 3, 7, 1]) 16 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 30 >>> rob([10, 1, 10, 1, 10, 1, 10]) 40","solution":"from typing import List def rob(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return nums[0] # Initialize dp array dp = [0] * len(nums) dp[0] = nums[0] if len(nums) > 1: dp[1] = max(nums[0], nums[1]) # Fill the dp array for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) # The last element of dp contains the result return dp[-1]"},{"question":"from typing import List def validate_serial_numbers(test_cases: List[str]) -> List[str]: This function validates a list of serial numbers based on the given criteria: 1. The serial number must start with a letter. 2. The serial number must end with a digit. 3. The serial number can contain only letters and digits. 4. The length of the serial number must be between 5 and 12 characters, inclusive. Args: test_cases(List[str]): A list of serial numbers to validate. Returns: List[str]: A list of \\"Valid\\" or \\"Invalid\\" strings based on the validation. Examples: >>> validate_serial_numbers([\\"A12345\\", \\"1B2345\\", \\"Abcdef9\\"]) [\\"Valid\\", \\"Invalid\\", \\"Valid\\"] >>> validate_serial_numbers([\\"C12345\\", \\"D23456\\", \\"E78901\\"]) [\\"Valid\\", \\"Valid\\", \\"Valid\\"]","solution":"def is_valid_serial_number(serial_number): This function checks if the serial number is valid based on the given criteria. if not (5 <= len(serial_number) <= 12): return \\"Invalid\\" if not serial_number[0].isalpha(): return \\"Invalid\\" if not serial_number[-1].isdigit(): return \\"Invalid\\" if not serial_number.isalnum(): return \\"Invalid\\" return \\"Valid\\" def validate_serial_numbers(test_cases): This function validates a list of serial numbers. results = [] for serial_number in test_cases: results.append(is_valid_serial_number(serial_number)) return results"},{"question":"def min_changes_to_palindrome(s: str) -> int: Given a string, determine the minimum number of changes required to convert it into a palindrome. >>> min_changes_to_palindrome(\\"abc\\") 1 >>> min_changes_to_palindrome(\\"aab\\") 1 >>> min_changes_to_palindrome(\\"racecar\\") 0 def process_test_cases(t: int, test_cases: list) -> list: Process multiple test cases to find the minimum number of changes required to convert each string into a palindrome. >>> process_test_cases(3, [\\"abc\\", \\"aab\\", \\"racecar\\"]) [1, 1, 0] >>> process_test_cases(4, [\\"abc\\", \\"abcd\\", \\"a\\", \\"\\"]) [1, 2, 0, 0]","solution":"def min_changes_to_palindrome(s: str) -> int: Given a string, determine the minimum number of changes required to convert it into a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes def process_test_cases(t: int, test_cases: list) -> list: results = [] for s in test_cases: results.append(min_changes_to_palindrome(s)) return results"},{"question":"def merge_log_files(log_lists): Merges multiple lists of log entries into a single list sorted by timestamps in ascending order. Args: log_lists (list of lists): Each inner list contains tuples (timestamp, event). Returns: list: Merged list of tuples (timestamp, event) sorted by timestamp. Examples: >>> merge_log_files([ ... [(\\"2023-10-01 12:00:00\\", \\"Server1 Event1\\"), (\\"2023-10-01 12:01:00\\", \\"Server1 Event2\\")], ... [(\\"2023-10-01 11:59:00\\", \\"Server2 Event1\\"), (\\"2023-10-01 12:00:30\\", \\"Server2 Event2\\")], ... [(\\"2023-10-01 11:58:00\\", \\"Server3 Event1\\"), (\\"2023-10-01 12:02:00\\", \\"Server3 Event2\\")] ... ]) [ (\\"2023-10-01 11:58:00\\", \\"Server3 Event1\\"), (\\"2023-10-01 11:59:00\\", \\"Server2 Event1\\"), (\\"2023-10-01 12:00:00\\", \\"Server1 Event1\\"), (\\"2023-10-01 12:00:30\\", \\"Server2 Event2\\"), (\\"2023-10-01 12:01:00\\", \\"Server1 Event2\\"), (\\"2023-10-01 12:02:00\\", \\"Server3 Event2\\") ] from solution import merge_log_files def test_merge_log_files_non_overlapping(): input_logs = [ [(\\"2023-10-01 12:00:00\\", \\"Server1 Event1\\")], [(\\"2023-10-01 11:59:00\\", \\"Server2 Event1\\")], [(\\"2023-10-01 11:58:00\\", \\"Server3 Event1\\")], ] expected_output = [ (\\"2023-10-01 11:58:00\\", \\"Server3 Event1\\"), (\\"2023-10-01 11:59:00\\", \\"Server2 Event1\\"), (\\"2023-10-01 12:00:00\\", \\"Server1 Event1\\"), ] assert merge_log_files(input_logs) == expected_output def test_merge_log_files_overlapping(): input_logs = [ [(\\"2023-10-01 12:00:00\\", \\"Server1 Event1\\"), (\\"2023-10-01 12:01:00\\", \\"Server1 Event2\\")], [(\\"2023-10-01 11:59:00\\", \\"Server2 Event1\\"), (\\"2023-10-01 12:00:30\\", \\"Server2 Event2\\")], [(\\"2023-10-01 11:58:00\\", \\"Server3 Event1\\"), (\\"2023-10-01 12:02:00\\", \\"Server3 Event2\\")] ] expected_output = [ (\\"2023-10-01 11:58:00\\", \\"Server3 Event1\\"), (\\"2023-10-01 11:59:00\\", \\"Server2 Event1\\"), (\\"2023-10-01 12:00:00\\", \\"Server1 Event1\\"), (\\"2023-10-01 12:00:30\\", \\"Server2 Event2\\"), (\\"2023-10-01 12:01:00\\", \\"Server1 Event2\\"), (\\"2023-10-01 12:02:00\\", \\"Server3 Event2\\") ] assert merge_log_files(input_logs) == expected_output def test_merge_log_files_with_empty_server_logs(): input_logs = [ [(\\"2023-10-01 12:00:00\\", \\"Server1 Event1\\")], [], [(\\"2023-10-01 11:58:00\\", \\"Server3 Event1\\")], ] expected_output = [ (\\"2023-10-01 11:58:00\\", \\"Server3 Event1\\"), (\\"2023-10-01 12:00:00\\", \\"Server1 Event1\\"), ] assert merge_log_files(input_logs) == expected_output def test_merge_log_files_with_all_empty_logs(): input_logs = [ [], [], [], ] expected_output = [] assert merge_log_files(input_logs) == expected_output def test_merge_log_files_single_server(): input_logs = [ [(\\"2023-10-01 11:58:00\\", \\"Event1\\"), (\\"2023-10-01 12:00:00\\", \\"Event2\\")] ] expected_output = [ (\\"2023-10-01 11:58:00\\", \\"Event1\\"), (\\"2023-10-01 12:00:00\\", \\"Event2\\"), ] assert merge_log_files(input_logs) == expected_output","solution":"def merge_log_files(log_lists): Merges multiple lists of log entries into a single list sorted by timestamps in ascending order. Args: log_lists (list of lists): Each inner list contains tuples (timestamp, event). Returns: list: Merged list of tuples (timestamp, event) sorted by timestamp. merged_logs = [] for log_list in log_lists: merged_logs.extend(log_list) merged_logs.sort(key=lambda x: x[0]) return merged_logs"},{"question":"def max_energy_drinks(n: int, k: int, drinks: List[int]) -> int: Calculate the maximum total number of energy drinks a participant can consume from the first to the last checkpoint given the number of energy drinks at each checkpoint and the maximum step size. Args: n (int): Number of checkpoints. k (int): Maximum step size. drinks (List[int]): Number of energy drinks available at each checkpoint. Returns: int: Maximum total number of energy drinks that can be consumed. Examples: >>> max_energy_drinks(5, 2, [1, 2, 3, 0, 4]) 10 >>> max_energy_drinks(3, 1, [0, 1, 5]) 6 >>> max_energy_drinks(4, 3, [10, 0, 0, 5]) 15 pass # Unit Tests def test_example_1(): assert max_energy_drinks(5, 2, [1, 2, 3, 0, 4]) == 10 def test_example_2(): assert max_energy_drinks(3, 1, [0, 1, 5]) == 6 def test_example_3(): assert max_energy_drinks(4, 3, [10, 0, 0, 5]) == 15 def test_all_same_values(): assert max_energy_drinks(4, 2, [5, 5, 5, 5]) == 20 def test_no_drinks(): assert max_energy_drinks(3, 1, [0, 0, 0]) == 0 def test_one_checkpoint(): assert max_energy_drinks(1, 1, [10]) == 10","solution":"def max_energy_drinks(n, k, drinks): # Initialize an array to store the max energy drinks that can be consumed at each checkpoint max_drinks = [0] * n max_drinks[0] = drinks[0] # Loop through each checkpoint for i in range(1, n): max_drinks[i] = max(max_drinks[max(0, i-k):i]) + drinks[i] # The last element of max_drinks will have the maximum energy drinks that can be consumed return max_drinks[-1] # Example usage # print(max_energy_drinks(5, 2, [1, 2, 3, 0, 4])) # Expected output: 10 # print(max_energy_drinks(3, 1, [0, 1, 5])) # Expected output: 6 # print(max_energy_drinks(4, 3, [10, 0, 0, 5])) # Expected output: 15"},{"question":"def minimum_cost_to_connect_villages(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum cost to connect all the villages with the given roads. Args: N: int - Number of villages. M: int - Number of roads. roads: List[Tuple[int, int, int]] - List of roads, where each road is represented by a tuple (u, v, w). Returns: int: The minimum cost to connect all villages. Examples: >>> minimum_cost_to_connect_villages(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 3), (3, 4, 5)]) 6 >>> minimum_cost_to_connect_villages(2, 1, [(1, 2, 10)]) 10 >>> minimum_cost_to_connect_villages(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 1)]) 2 >>> minimum_cost_to_connect_villages(4, 5, [(1, 2, 1000000), (1, 3, 1000000), (2, 3, 999999), (2, 4, 1000000), (3, 4, 1000000)]) 2999999","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst(n, edges): edges.sort(key=lambda x: x[2]) parent = [i for i in range(n)] rank = [0] * n mst_weight = 0 mst_edges = 0 for edge in edges: u, v, w = edge u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += w mst_edges += 1 if mst_edges == n - 1: break return mst_weight def minimum_cost_to_connect_villages(N, M, roads): edges = [tuple(map(int, road)) for road in roads] return kruskal_mst(N, edges)"},{"question":"def max_flowers(n: int, m: int, garden: List[str]) -> int: Determine the maximum number of flowers that the monks can collect together in a single straight path. >>> max_flowers(3, 3, [\\"F.F\\", \\"FFF\\", \\"F.F\\"]) 6 >>> max_flowers(4, 5, [\\"F..F.\\", \\"..F..\\", \\"FF...\\", \\"F..FF\\"]) 5 >>> max_flowers(1, 5, [\\"F.F.F\\"]) 2 >>> max_flowers(5, 1, [\\"F\\", \\".\\", \\"F\\", \\".\\", \\"F\\"]) 2 >>> max_flowers(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 0 >>> max_flowers(2, 2, [\\"FF\\", \\"FF\\"]) 4 >>> max_flowers(3, 4, [\\".F..\\", \\"F.F.\\", \\"..F.\\"]) 3","solution":"def max_flowers(n, m, garden): # This function calculates the maximum flowers that can be collected # by two monks following the given constraints # Function to count flowers in a row def count_flowers_in_row(row): return sum(1 for cell in row if cell == 'F') # Function to count flowers in a column def count_flowers_in_column(col_idx): return sum(1 for row in garden if row[col_idx] == 'F') max_flowers = 0 # Check all possible horizontal paths for r in range(n): count_row = count_flowers_in_row(garden[r]) for rr in range(n): if r != rr: count_second_row = count_flowers_in_row(garden[rr]) max_flowers = max(max_flowers, count_row + count_second_row) # Check all possible vertical paths for c in range(m): count_col = count_flowers_in_column(c) for cc in range(m): if c != cc: count_second_col = count_flowers_in_column(cc) max_flowers = max(max_flowers, count_col + count_second_col) return max_flowers # Read garden layout def read_input(): import sys input = sys.stdin.read data = input().strip().split() n, m = int(data[0]), int(data[1]) garden = data[2:] return n, m, garden if __name__ == \\"__main__\\": n, m, garden = read_input() print(max_flowers(n, m, garden))"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases for the longest unique substring problem. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases(2, [\\"abcdef\\", \\"aabbccdd\\"]) [6, 2]","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_index = {} longest_length = start = 0 for index, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = index longest_length = max(longest_length, index - start + 1) return longest_length def process_test_cases(T, test_cases): results = [] for case in test_cases: results.append(length_of_longest_substring(case)) return results"},{"question":"def min_highways_to_deactivate(N: int, connections: List[Tuple[int, int]]) -> int: Returns the minimum number of highways to be deactivated to break the circular loop of cities. Parameters: N (int): The number of cities. connections (list of tuples): List containing u, v pairs denoting a highway between city u and city v. Returns: int: Minimum number of highways to be deactivated. >>> min_highways_to_deactivate(4, [(0, 1), (1, 2), (2, 3), (3, 0)]) 2 >>> min_highways_to_deactivate(6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)]) 2 >>> min_highways_to_deactivate(3, [(0, 1), (1, 2), (2, 0)]) 2","solution":"def min_highways_to_deactivate(N, connections): Returns the minimum number of highways to be deactivated to break the circular loop of cities. Parameters: N (int): The number of cities. connections (list of tuples): List containing u, v pairs denoting a highway between city u and city v. Returns: int: Minimum number of highways to be deactivated. return 2 # For a circular loop of N cities, always need to cut exactly 2 highways to break the loop."},{"question":"from typing import List def trapRainWater(heights: List[List[int]]) -> int: Write a function that, given an m × n grid filled with integers representing building heights, finds the maximum amount of water that can be trapped after raining. Water can only be trapped if there are buildings on both the left and right side of a given cell that are taller than the cell itself. The function should return an integer representing the total units of water trapped. >>> heights = [ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ] >>> trapRainWater(heights) 4 >>> heights = [ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ] >>> trapRainWater(heights) 0 >>> heights = [ ... [2, 1, 2], ... [1, 0, 1], ... [2, 1, 2] ... ] >>> trapRainWater(heights) 1 >>> heights = [ ... [3, 3, 3, 3], ... [3, 1, 1, 3], ... [3, 1, 1, 3], ... [3, 3, 3, 3] ... ] >>> trapRainWater(heights) 8 >>> heights = [ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12] ... ] >>> trapRainWater(heights) 14","solution":"from typing import List import heapq def trapRainWater(heights: List[List[int]]) -> int: if not heights or not heights[0]: return 0 m, n = len(heights), len(heights[0]) visited = [[False]*n for _ in range(m)] heap = [] # Push all the boundary cells into the heap and mark them as visited for i in range(m): for j in range(n): if i == 0 or j == 0 or i == m-1 or j == n-1: heapq.heappush(heap, (heights[i][j], i, j)) visited[i][j] = True water_trapped = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: water_trapped += max(0, height - heights[nx][ny]) heapq.heappush(heap, (max(height, heights[nx][ny]), nx, ny)) visited[nx][ny] = True return water_trapped"},{"question":"def warehouse_inventory(n, q, quantities, operations): This function manages a warehouse inventory system which performs the following operations: 1. Query the quantity of a specific product. 2. Restock multiple products with specified quantities. Parameters: n (int): The number of products in the warehouse. q (int): The number of operations to perform. quantities (List[int]): The initial quantities of the products. operations (List[str]): The operations to be performed in the format described above. Returns: List[int]: The results of all query operations. Example: >>> warehouse_inventory(5, 6, [10, 20, 30, 40, 50], [ ... \\"1 3\\", ... \\"2 2 1 10 3 5\\", ... \\"1 1\\", ... \\"2 1 4 20\\", ... \\"1 4\\", ... \\"1 2\\" ... ]) [30, 20, 60, 20] results = [] for op in operations: parts = list(map(int, op.split())) if parts[0] == 1: results.append(quantities[parts[1] - 1]) elif parts[0] == 2: c = parts[1] for i in range(c): p = parts[2 + 2 * i] - 1 q = parts[3 + 2 * i] quantities[p] += q return results from solution import warehouse_inventory def test_case_1(): assert warehouse_inventory(5, 6, [10, 20, 30, 40, 50], [ \\"1 3\\", \\"2 2 1 10 3 5\\", \\"1 1\\", \\"2 1 4 20\\", \\"1 4\\", \\"1 2\\" ]) == [30, 20, 60, 20] def test_case_2(): assert warehouse_inventory(3, 3, [100, 200, 300], [ \\"1 1\\", \\"2 2 1 50 2 100\\", \\"1 2\\", ]) == [100, 300] def test_case_3(): assert warehouse_inventory(4, 4, [10, 20, 30, 40], [ \\"2 3 1 10 2 20 3 30\\", \\"1 1\\", \\"1 2\\", \\"1 3\\" ]) == [20, 40, 60] def test_case_4(): assert warehouse_inventory(2, 3, [0, 500], [ \\"1 1\\", \\"2 1 1 1000\\", \\"1 1\\" ]) == [0, 1000] def test_case_5(): assert warehouse_inventory(1, 2, [100], [ \\"1 1\\", \\"2 1 1 900\\" ]) == [100]","solution":"def warehouse_inventory(n, q, quantities, operations): results = [] # Process each operation for op in operations: parts = list(map(int, op.split())) if parts[0] == 1: # query operation results.append(quantities[parts[1] - 1]) elif parts[0] == 2: # restock operation c = parts[1] for i in range(c): p = parts[2 + 2 * i] - 1 q = parts[3 + 2 * i] quantities[p] += q return results"},{"question":"def max_systems_monitored(N: int, M: int, control_rooms: List[Tuple[int, int]]) -> int: Determines the maximum number of systems that can be monitored simultaneously without exceeding the limit of any operator's capacity in any control room. :param N: Integer, number of control rooms :param M: Integer, number of systems to be monitored :param control_rooms: List of tuples, where each tuple contains two integers (Si, Li) representing the capacity and the limit for each control room :return: Integer, maximum number of systems that can be monitored simultaneously >>> max_systems_monitored(3, 5, [(2, 3), (1, 2), (3, 4)]) 5 >>> max_systems_monitored(3, 6, [(2, 2), (2, 2), (2, 2)]) 6 >>> max_systems_monitored(3, 10, [(3, 2), (4, 3), (2, 1)]) 6 >>> max_systems_monitored(1000, 1000, [(1, 1)] * 1000) 1000 >>> max_systems_monitored(1000, 0, [(1, 1)] * 1000) 0","solution":"def max_systems_monitored(N, M, control_rooms): Determines the maximum number of systems that can be monitored simultaneously without exceeding the limit of any operator's capacity in any control room. :param N: Integer, number of control rooms :param M: Integer, number of systems to be monitored :param control_rooms: List of tuples, where each tuple contains two integers (Si, Li) representing the capacity and the limit for each control room :return: Integer, maximum number of systems that can be monitored simultaneously max_systems = 0 for Si, Li in control_rooms: max_systems += min(Si, Li) # Ensure the maximum number of systems monitored doesn't exceed M return min(max_systems, M)"},{"question":"def distribute_boxes(n, m, W_min, W_max, boxes): Distributes boxes into containers while ensuring the weight of each container is within the given range. Returns \\"YES\\" and the containers if the distribution is possible; otherwise, returns \\"NO\\". Args: n (int): Number of boxes. m (int): Number of containers. W_min (int): Minimum allowed weight of each container. W_max (int): Maximum allowed weight of each container. boxes (list of tuples): List of (weight, category) tuples for each box. Returns: str: \\"YES\\" or \\"NO\\". list of lists: Container descriptions if the answer is \\"YES\\", otherwise an empty list. Examples: >>> distribute_boxes(4, 2, 3, 10, [(3, 1), (4, 1), (5, 2), (2, 2)]) (\\"YES\\", [[1, 2], [3, 4]]) >>> distribute_boxes(5, 2, 10, 15, [(5, 1), (3, 1), (4, 2), (6, 2), (5, 1)]) (\\"NO\\", []) from solution import distribute_boxes def test_distribute_boxes_example_1(): n = 4 m = 2 W_min = 3 W_max = 10 boxes = [(3, 1), (4, 1), (5, 2), (2, 2)] result, containers = distribute_boxes(n, m, W_min, W_max, boxes) assert result == \\"YES\\" assert len(containers) == 2 assert all(W_min <= sum(boxes[idx-1][0] for idx in container) <= W_max for container in containers) def test_distribute_boxes_example_2(): n = 5 m = 2 W_min = 10 W_max = 15 boxes = [(5, 1), (3, 1), (4, 2), (6, 2), (5, 1)] result, containers = distribute_boxes(n, m, W_min, W_max, boxes) assert result == \\"NO\\" assert containers == [] def test_distribute_boxes_exact_fit(): n = 3 m = 1 W_min = 10 W_max = 15 boxes = [(5, 1), (6, 2), (4, 1)] result, containers = distribute_boxes(n, m, W_min, W_max, boxes) assert result == \\"YES\\" assert len(containers) == 1 assert all(W_min <= sum(boxes[idx-1][0] for idx in container) <= W_max for container in containers) def test_distribute_boxes_not_enough_containers(): n = 3 m = 2 W_min = 10 W_max = 15 boxes = [(5, 1), (6, 2), (4, 1)] result, containers = distribute_boxes(n, m, W_min, W_max, boxes) assert result == \\"NO\\" assert containers == []","solution":"def distribute_boxes(n, m, W_min, W_max, boxes): from itertools import combinations # Initialize containers containers = [[] for _ in range(m)] container_weights = [0] * m # Sort boxes by weight in decreasing order sorted_boxes = sorted([(i+1, w, c) for i, (w, c) in enumerate(boxes)], key=lambda x: x[1], reverse=True) for i in range(n): idx, w, c = sorted_boxes[i] placed = False # Try to find a container to place the current box for j in range(m): if container_weights[j] + w <= W_max: containers[j].append(idx) container_weights[j] += w placed = True break # If the box couldn't be placed in any container, return NO if not placed: return \\"NO\\", [] # Ensure all containers meet the weight constraints for weight in container_weights: if weight < W_min or weight > W_max: return \\"NO\\", [] return \\"YES\\", containers"},{"question":"def calculate_distances(N: int, Q: int, queries: List[Tuple[int, int]]) -> List[int]: Calculate the sum of distances traveled by each object. Args: N (int): The number of objects. Q (int): The number of queries. queries (List[Tuple[int, int]]): A list containing Q tuples, each with an integer pair (a, d). Returns: List[int]: A list containing the sum of distances traveled by each object. Examples: >>> calculate_distances(8, 3, [(3, 15), (7, 9), (4, 7)]) [0, 0, 15, 7, 0, 0, 9, 0] >>> calculate_distances(5, 5, [(1, 5), (3, 10), (2, 21), (1, 1), (4, 17)]) [6, 21, 10, 17, 0] >>> calculate_distances(9, 4, [(1, 5), (4, 12), (9, 3), (6, 9)]) [5, 0, 0, 12, 0, 9, 0, 0, 3] >>> calculate_distances(6, 7, [(5, 19), (3, 2), (1, 4), (2, 8), (6, 15), (3, 25), (4, 11)]) [4, 8, 27, 11, 19, 15]","solution":"def calculate_distances(N, Q, queries): distances = [0] * N for a, d in queries: distances[a-1] += d return distances # Example usage: # N, Q = 8, 3 # queries = [(3, 15), (7, 9), (4, 7)] # print(calculate_distances(N, Q, queries)) # Output: [0, 0, 15, 7, 0, 0, 9, 0]"},{"question":"def can_transform(S: str, T: str) -> str: Determines if string S can be transformed into string T by removing characters. >>> can_transform(\\"ABCDE\\", \\"ACE\\") \\"YES\\" >>> can_transform(\\"AXBYC\\", \\"ABC\\") \\"YES\\" >>> can_transform(\\"ABCD\\", \\"AEB\\") \\"NO\\"","solution":"def can_transform(S, T): Determines if string S can be transformed into string T by removing characters. it = iter(S) if all(char in it for char in T): return \\"YES\\" return \\"NO\\""},{"question":"def can_transform(n: int, s: str, t: str) -> bool: Determines if string s can be transformed into string t using allowed operations. >>> can_transform(5, 'abcde', 'aecbd') == True >>> can_transform(2, 'aa', 'bb') == False","solution":"def can_transform(n, s, t): Determines if string s can be transformed into string t using allowed operations. # If the sorted versions of both strings are equal # it means we have the same set of characters # so we can convert one to the other return sorted(s) == sorted(t)"},{"question":"def find_fog_height(a: int, b: int) -> int: Determine the height of the fog given the visible heights of two adjacent buildings. >>> find_fog_height(5, 9) 4 >>> find_fog_height(12, 19) 7 >>> find_fog_height(1, 2) 1 >>> find_fog_height(1000, 1200) 200 >>> find_fog_height(2999, 3000) 1","solution":"def find_fog_height(a, b): x = b - a return x # Main program to read from standard input if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().split() a = int(input_data[0]) b = int(input_data[1]) # Call the function and print the result print(find_fog_height(a, b))"},{"question":"def has_integer_average_subarray(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Given an array a consisting of n integers and an integer k, determine whether there exists a subarray of length exactly k whose average value is an integer. You are not allowed to rearrange the elements of the array. >>> has_integer_average_subarray(3, [((5, 2), [1, 3, 2, 5, 4]), ((4, 3), [1, -2, 3, 4]), ((6, 1), [0, -1, 2, -2, 1, -3])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> has_integer_average_subarray(1, [((5, 1), [3, 2, 1, 5, 4])]) [\\"YES\\"] >>> has_integer_average_subarray(1, [((5, 2), [1, 2, 3, 4, 5])]) [\\"NO\\"] >>> has_integer_average_subarray(1, [((4, 2), [-2, -4, -6, -8])]) [\\"YES\\"] >>> has_integer_average_subarray(1, [((5, 3), [-1, 0, 1, 2, 3])]) [\\"YES\\"]","solution":"def has_integer_average_subarray(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] a = test_cases[i][1] found = False for j in range(n - k + 1): subarray_sum = sum(a[j:j+k]) if subarray_sum % k == 0: found = True break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minimal_change_grid(n: int, m: int, grid: List[List[int]]) -> List[List[int]]: Modify the grid such that all integers are non-negative and the change to each integer is minimal. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list containing the grid elements :return: Modified 2D list with non-negative integers >>> minimal_change_grid(3, 3, [[-1, -2, -3], [4, 5, -6], [-7, -8, 9]]) [[0, 0, 0], [4, 5, 0], [0, 0, 9]] >>> minimal_change_grid(2, 2, [[-10, 5], [-2, 3]]) [[0, 5], [0, 3]]","solution":"def minimal_change_grid(n, m, grid): Modify the grid such that all integers are non-negative and the change to each integer is minimal. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list containing the grid elements :return: Modified 2D list with non-negative integers for i in range(n): for j in range(m): if grid[i][j] < 0: grid[i][j] = 0 return grid"},{"question":"def max_package_weight(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum weight of any single package after rearranging the rows and columns of the grid. Parameters: n (int): number of rows m (int): number of columns grid (list of list of int): 2D list representing weights of packages in the grid Returns: int: the maximum weight of any single package after rearranging >>> max_package_weight(3, 4, [[10, 1, 5, 7], [3, 9, 2, 6], [4, 8, 11, 12]]) 12 >>> max_package_weight(1, 1, [[5]]) 5 >>> max_package_weight(2, 3, [[7, 2, 8], [4, 6, 3]]) 8 >>> max_package_weight(2, 2, [[1000000000, 1], [2, 999999999]]) 1000000000 >>> max_package_weight(3, 3, [[3, 3, 3], [3, 3, 3], [3, 3, 3]]) 3","solution":"def max_package_weight(n, m, grid): Returns the maximum weight of any single package after rearranging the rows and columns of the grid. Parameters: n (int): number of rows m (int): number of columns grid (list of list of int): 2D list representing weights of packages in the grid Returns: int: the maximum weight of any single package after rearranging max_weight = 0 for row in grid: max_weight = max(max_weight, max(row)) return max_weight"},{"question":"def is_valid_movie_plan(m: int, genres: List[int]) -> str: Determines if the movie plan is valid (no two consecutive movies of the same genre). >>> is_valid_movie_plan(5, [1, 2, 1, 3, 2]) == \\"YES\\" >>> is_valid_movie_plan(4, [1, 1, 2, 3]) == \\"NO\\"","solution":"def is_valid_movie_plan(m, genres): Determines if the movie plan is valid (no two consecutive movies of the same genre). Parameters: m (int): The number of movies. genres (List[int]): The list of movie genres. Returns: str: \\"YES\\" if the plan is valid, otherwise \\"NO\\". for i in range(1, m): if genres[i] == genres[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"def minimal_travel_blocks(T: int, test_cases: List[tuple]) -> List[int]: Given the number of test cases and each test case's data, computes the minimal travel blocks required for a taxicab in a grid. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains - N (int): Size of the grid - sx (int), sy (int): Coordinates of the start location - dx (int), dy (int): Coordinates of the destination location Returns: list of int: Minimal travel blocks for each test case >>> minimal_travel_blocks(3, [(5, 0, 0, 4, 4), (4, 1, 1, 3, 3), (3, 2, 2, 0, 0)]) [8, 4, 4] >>> minimal_travel_blocks(1, [(5, 2, 2, 2, 2)]) [0] >>> minimal_travel_blocks(2, [(1000, 0, 0, 999, 999), (1000, 0, 0, 0, 999)]) [1998, 999]","solution":"def minimal_travel_blocks(T, test_cases): Given the number of test cases and each test case's data, computes the minimal travel blocks required for a taxicab in a grid. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains - N (int): Size of the grid - sx (int), sy (int): Coordinates of the start location - dx (int), dy (int): Coordinates of the destination location Returns: list of int: Minimal travel blocks for each test case results = [] for test_case in test_cases: N, sx, sy, dx, dy = test_case minimal_blocks = abs(dx - sx) + abs(dy - sy) results.append(minimal_blocks) return results"},{"question":"def min_flips_for_multiple_cases(test_cases): Returns the minimum number of flips required to make the grid alternating for each test case. >>> min_flips_for_multiple_cases([(3, 3, [\\"010\\", \\"101\\", \\"010\\"]), (2, 2, [\\"10\\", \\"01\\"]), (3, 3, [\\"111\\", \\"111\\", \\"111\\"])) [0, 0, 4] >>> min_flips_for_multiple_cases([(2, 3, [\\"010\\", \\"101\\"]), (3, 2, [\\"01\\", \\"10\\", \\"01\\"]), (4, 4, [\\"1111\\", \\"1111\\", \\"1111\\", \\"1111\\"])]) [0, 0, 8] >>> min_flips_for_multiple_cases([(1, 1, [\\"0\\"]), (1, 1, [\\"1\\"]), (1, 2, [\\"00\\"]), (2, 1, [\\"0\\", \\"1\\"])]) [0, 0, 1, 0]","solution":"def min_flips_to_alternate(grid): n = len(grid) m = len(grid[0]) def flips_to_pattern(pattern): flip_count = 0 for i in range(n): for j in range(m): expected = pattern[(i + j) % 2] if grid[i][j] != expected: flip_count += 1 return flip_count # Define the two possible patterns pattern1 = ['0', '1'] pattern2 = ['1', '0'] # Calculate flips for both patterns flips1 = flips_to_pattern(pattern1) flips2 = flips_to_pattern(pattern2) # Return the minimum of the two return min(flips1, flips2) def min_flips_for_multiple_cases(test_cases): results = [] for n, m, grid in test_cases: results.append(min_flips_to_alternate(grid)) return results"},{"question":"def max_unique_products(N: int, B: int, prices: List[int], M: int, offers: List[List[int]]) -> int: Determine the maximum number of unique products the client can purchase within the budget B, either through individual purchases or special offers. >>> max_unique_products(4, 100, [20, 30, 50, 70], 2, [[2, 40, 1, 2], [3, 90, 2, 3, 4]]) == 3 >>> max_unique_products(5, 150, [40, 20, 30, 70, 50], 3, [[2, 45, 1, 2], [3, 110, 3, 4, 5], [2, 90, 2, 5]]) == 4 >>> max_unique_products(3, 30, [10, 15, 20], 1, [[2, 20, 1, 2]]) == 2","solution":"def max_unique_products(N, B, prices, M, offers): from itertools import combinations # Initialize a list to hold the unique products index that can be bought def dfs(index, budget, purchased, best): # If index out of range or no budget left, return the number of purchased products if index == N + M or budget == 0: return len(set(purchased)) # Get the current state value if index < N: price = prices[index] next_indexes = [index + 1] else: offer = offers[index - N] next_indexes = offer[2:] if offer[1] <= budget else [index + 1] price = offer[1] if offer[1] <= budget else float('inf') # Case 1: Skip the current index result = dfs(index + 1, budget, purchased, best) # Case 2: Take the current price/offer if possible if price <= budget: if index < N: purchased.append(index + 1) else: purchased += next_indexes result = max(result, dfs(index + 1, budget - price, purchased, result)) if index >= N: for _ in range(len(next_indexes)): purchased.pop() else: purchased.pop() return result offers.sort(key=lambda x: x[1]) return dfs(0, B, [], 0)"},{"question":"def string_values(S): Given a string S of lowercase English letters, this function returns a tuple containing the sum of the values of the characters in the string, the maximum value of a character, and the minimum value of a character. Args: S (str): A string of lowercase English letters. Returns: tuple: A tuple containing three integers - the sum of the values of the characters, the maximum value of a character, and the minimum value of a character. >>> string_values(\\"abc\\") (6, 3, 1) >>> string_values(\\"bcd\\") (9, 4, 2) pass def process_test_cases(T, test_cases): Processes multiple test cases and returns the results for each test case. Args: T (int): The number of test cases. test_cases (List[str]): A list of strings, each string representing a test case. Returns: List[tuple]: A list of tuples, each tuple containing three integers representing the results of the string_values function for the corresponding test case. >>> process_test_cases(2, [\\"abc\\", \\"bcd\\"]) [(6, 3, 1), (9, 4, 2)] >>> process_test_cases(1, [\\"aaa\\"]) [(3, 1, 1)] pass","solution":"def string_values(S): Given a string S of lowercase English letters, this function returns a tuple containing the sum of the values of the characters in the string, the maximum value of a character, and the minimum value of a character. values = [(ord(c) - ord('a') + 1) for c in S] total_sum = sum(values) max_value = max(values) min_value = min(values) return (total_sum, max_value, min_value) def process_test_cases(T, test_cases): Processes multiple test cases and returns the results for each test case. results = [] for S in test_cases: results.append(string_values(S)) return results"},{"question":"def number_of_people_who_receive_gifts(m: int, n: int) -> int: Given the dimensions of a grid, determine the number of people who will receive gifts. Gifts are handed out to people standing on the diagonal from the top-left corner to the bottom-right corner of the grid. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid Returns: int: number of people who receive gifts >>> number_of_people_who_receive_gifts(4, 4) 4 >>> number_of_people_who_receive_gifts(3, 5) 3 >>> number_of_people_who_receive_gifts(1, 10) 1 >>> number_of_people_who_receive_gifts(10**9, 10**9) 10**9","solution":"def number_of_people_who_receive_gifts(m, n): Given the dimensions of a grid, determine the number of people who will receive gifts. Gifts are handed out to people standing on the diagonal from the top-left corner to the bottom-right corner of the grid. Parameters: m (int): number of rows in the grid n (int): number of columns in the grid Returns: int: number of people who receive gifts # The number of people on the diagonal is the minimum of the number of rows and the number of columns return min(m, n)"},{"question":"MODULO = 10**9 + 7 def compute_sum_of_products(n: int, sequences: List[List[int]]) -> int: Compute the sum of products of elements for each sequence in the dataset. For each sequence in the dataset, compute the product of the elements, then sum these products for all sequences. Return the sum modulo 10^9 + 7. >>> compute_sum_of_products(3, [[3, 1, 2, 3], [2, 4, 5], [4, 0, 3, 2, 1]]) 26 >>> compute_sum_of_products(2, [[5, 2, 3, 4, 5, 6], [3, 7, 8, 9]]) 1224 # define the function here import pytest from solution import compute_sum_of_products def test_example_1(): n = 3 sequences = [ [3, 1, 2, 3], [2, 4, 5], [4, 0, 3, 2, 1] ] assert compute_sum_of_products(n, sequences) == 26 def test_example_2(): n = 2 sequences = [ [5, 2, 3, 4, 5, 6], [3, 7, 8, 9] ] assert compute_sum_of_products(n, sequences) == 1224 def test_large_numbers(): n = 2 sequences = [ [2, 100000, 100000], [2, 100000, 100000] ] result = compute_sum_of_products(n, sequences) expected = ((100000 * 100000) % MODULO + (100000 * 100000) % MODULO) % MODULO assert result == expected def test_single_sequence_with_zero(): n = 1 sequences = [ [4, 1, 0, 3, 2] ] assert compute_sum_of_products(n, sequences) == 0 def test_single_element_sequences(): n = 3 sequences = [ [1, 5], [1, 7], [1, 9] ] assert compute_sum_of_products(n, sequences) == (5 + 7 + 9) % MODULO def test_empty_sequences(): n = 0 sequences = [] assert compute_sum_of_products(n, sequences) == 0 def test_single_zero(): n = 1 sequences = [ [1, 0] ] assert compute_sum_of_products(n, sequences) == 0 def test_large_number_of_sequences(): n = 100000 sequences = [[2, 1, 1] for _ in range(n)] assert compute_sum_of_products(n, sequences) == n % MODULO if __name__ == \\"__main__\\": pytest.main()","solution":"MODULO = 10**9 + 7 def compute_sum_of_products(n, sequences): total_sum = 0 for sequence in sequences: k = sequence[0] product = 1 for num in sequence[1:]: product = (product * num) % MODULO total_sum = (total_sum + product) % MODULO return total_sum"},{"question":"from typing import List def longest_unique_substring(isbn_list: List[str]) -> List[str]: Returns the longest substring of unique ISBN numbers. >>> longest_unique_substring([\\"123\\", \\"456\\", \\"789\\", \\"123\\", \\"456\\"]) [\\"123\\", \\"456\\", \\"789\\"] >>> longest_unique_substring([\\"111\\", \\"222\\", \\"333\\", \\"111\\", \\"111\\", \\"444\\"]) [\\"111\\", \\"222\\", \\"333\\"] >>> longest_unique_substring([\\"999\\"]) [\\"999\\"]","solution":"def longest_unique_substring(isbn_list): Returns the longest substring of unique ISBN numbers. n = len(isbn_list) if n == 0: return [] longest_substr = [] current_substr = [] isbn_set = set() start = 0 for end in range(n): while isbn_list[end] in isbn_set: isbn_set.remove(isbn_list[start]) current_substr.pop(0) start += 1 isbn_set.add(isbn_list[end]) current_substr.append(isbn_list[end]) if len(current_substr) > len(longest_substr): longest_substr = current_substr[:] return longest_substr"},{"question":"def min_operations_to_identical(t: int, cases: List[str]) -> List[int]: Determines the minimum number of operations required to make all characters of the string identical. >>> min_operations_to_identical(3, [\\"aabb\\", \\"abcd\\", \\"aaa\\"]) [2, 3, 0] pass from typing import List def test_single_char_string(): assert min_operations_to_identical(1, [\\"a\\"]) == [0] assert min_operations_to_identical(1, [\\"z\\"]) == [0] def test_identical_string(): assert min_operations_to_identical(1, [\\"aaa\\"]) == [0] assert min_operations_to_identical(1, [\\"bbb\\"]) == [0] def test_multiple_operations_needed(): assert min_operations_to_identical(1, [\\"aabb\\"]) == [2] assert min_operations_to_identical(1, [\\"abcd\\"]) == [3] def test_mixed_cases(): t = 3 cases = [\\"aabb\\", \\"abcd\\", \\"aaa\\"] expected = [2, 3, 0] assert min_operations_to_identical(t, cases) == expected def test_multiple_test_cases(): t = 4 cases = [\\"aaabbb\\", \\"abcabc\\", \\"ab\\", \\"aabbcc\\"] expected = [3, 4, 1, 4] assert min_operations_to_identical(t, cases) == expected","solution":"def min_operations_to_identical(t, cases): results = [] for s in cases: char_counts = {} for char in s: if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 max_char_count = max(char_counts.values()) min_operations = len(s) - max_char_count results.append(min_operations) return results"},{"question":"def max_distance_covered(n: int, runners: List[Tuple[int, int]]) -> int: Returns the maximum distance the team can cover in the relay race. :param n: Number of runners. :param runners: List of tuples, where each tuple contains two integers \`si\` (speed) and \`di\` (maximum distance). :return: Maximum distance the team can cover. >>> max_distance_covered(1, [(5, 10)]) 10 >>> max_distance_covered(3, [(5, 10), (10, 5), (3, 7)]) 22 >>> max_distance_covered(4, [(8, 6), (6, 8), (7, 7), (5, 5)]) 26 >>> max_distance_covered(3, [(5, 7), (10, 7), (3, 7)]) 21 >>> max_distance_covered(3, [(10, 5), (5, 10), (3, 7)]) 22 >>> max_distance_covered(5, [(1, 1)] * 5) 5 pass","solution":"def max_distance_covered(n, runners): Returns the maximum distance the team can cover in the relay race. :param n: Number of runners. :param runners: List of tuples, where each tuple contains two integers \`si\` (speed) and \`di\` (maximum distance). :return: Maximum distance the team can cover. # Sort runners by their distance capacity in descending order runners.sort(key=lambda x: x[1], reverse=True) # Sum up the maximum distance each runner can run total_distance = sum(runner[1] for runner in runners) return total_distance"},{"question":"def can_players_align(n: int, grid: List[str]) -> str: Determine if all players can move to form a perfect line (horizontal, vertical, or diagonal) without crossing any obstacles. >>> can_players_align(3, [\\"P.P\\", \\"#.#\\", \\"P.P\\"]) \\"NO\\" >>> can_players_align(3, [\\"P..\\", \\".P.\\", \\"..P\\"]) \\"YES\\" >>> can_players_align(3, [\\"...\\", \\"...\\", \\"...\\"]) \\"YES\\" >>> can_players_align(3, [\\"#P#\\", \\"#\\", \\"P#P\\"]) \\"NO\\" >>> can_players_align(4, [\\"P...\\", \\".P..\\", \\"..P.\\", \\"...P\\"]) \\"YES\\" >>> can_players_align(5, [\\"P....\\", \\"..P..\\", \\"...P.\\", \\".....\\", \\".....\\"]) \\"NO\\"","solution":"def can_players_align(n, grid): directions = [(1, 0), (0, 1), (1, 1), (1, -1)] # down, right, down-right, down-left players = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 'P'] if not players: return \\"YES\\" # No players, considered aligned def check_line(x, y, dx, dy): for px, py in players: if (px - x) * dy != (py - y) * dx: # cross-product for collinearity check return False return True for px, py in players: for dx, dy in directions: if all(0 <= px + k*dx < n and 0 <= py + k*dy < n and grid[px + k*dx][py + k*dy] != '#' for k in range(n)): if check_line(px, py, dx, dy): return \\"YES\\" return \\"NO\\""},{"question":"def can_form_palindrome(N: int) -> str: Determines if it is possible to rearrange the digits of N to form a palindrome. Parameters: N (int): The input number. Returns: str: \\"YES\\" if the digits can be rearranged to form a palindrome, \\"NO\\" otherwise. Examples: >>> can_form_palindrome(121) 'YES' >>> can_form_palindrome(123) 'NO'","solution":"def can_form_palindrome(N): Determines if it is possible to rearrange the digits of N to form a palindrome. Parameters: N (int): The input number. Returns: str: \\"YES\\" if the digits can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter digit_count = Counter(str(N)) odd_count = sum(1 for count in digit_count.values() if count % 2 != 0) return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def books_per_year(n, book_list): Reads a list of books with the year they were read and outputs the years in ascending order along with the number of books read in each year. Parameters: n (int): The number of books. book_list (List[str]): List of strings where each string contains a year and a book title. Returns: str: A string containing years in ascending order along with the number of books read in each year. Each year and its corresponding book count should be on a new line. Example: >>> books_per_year(5, [\\"2020 \\"To Kill a Mockingbird\\"\\", \\"2019 \\"1984\\"\\", \\"2020 \\"The Great Gatsby\\"\\", \\"2018 \\"Pride and Prejudice\\"\\", \\"2019 \\"The Catcher in the Rye\\"\\"]) \\"2018 1n2019 2n2020 2\\"","solution":"def books_per_year(n, book_list): from collections import defaultdict year_count = defaultdict(int) for entry in book_list: year, book = entry.split(\\" \\", 1) year_count[int(year)] += 1 result = [] for year in sorted(year_count.keys()): result.append(f\\"{year} {year_count[year]}\\") return \\"n\\".join(result)"},{"question":"def check_and_correct_assignments(n, m, assignments): Verify and correct task assignments to be bidirectional. Args: n (int): Number of employees. m (int): Number of task assignments. assignments (List[Tuple[int, int]]): List of task assignments as (u, v) tuples. Returns: str: \\"YES\\" followed by corrected list of assignments or \\"NO\\" if correction is impossible. Examples: >>> check_and_correct_assignments(4, 4, [(1, 2), (2, 1), (3, 4), (4, 3)]) \\"YESn1 2n2 1n3 4n4 3\\" >>> check_and_correct_assignments(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\"","solution":"def check_and_correct_assignments(n, m, assignments): assignment_set = set() for u, v in assignments: assignment_set.add((u, v)) corrected_assignments = [] for u, v in assignment_set: if (v, u) not in assignment_set: return \\"NO\\" if (u, v) not in corrected_assignments and (v, u) not in corrected_assignments: corrected_assignments.append((u, v)) corrected_assignments.append((v, u)) result = [\\"YES\\"] for u, v in corrected_assignments: result.append(f\\"{u} {v}\\") return \\"n\\".join(result) # Example Usage: # n = 4 # m = 4 # assignments = [(1, 2), (2, 1), (3, 4), (4, 3)] # print(check_and_correct_assignments(n, m, assignments))"},{"question":"def sum_of_grid_values(n: int, m: int, operations: List[Tuple[int, int, int]]) -> int: Compute the sum of the values in a grid after performing a series of operations. Each operation fills every cell in two specific rows with a given value. Args: n (int): Size of the grid (n x n). m (int): Number of operations. operations (List[Tuple[int, int, int]]): List of operations, where each operation is described by a tuple (r1, r2, value). Returns: int: Sum of values in the entire grid after all operations. Example: >>> n = 3 >>> m = 3 >>> operations = [(1, 2, 100), (2, 3, 50), (1, 3, 200)] >>> sum_of_grid_values(n, m, operations) 2100","solution":"def sum_of_grid_values(n, m, operations): grid = [[0]*n for _ in range(n)] for r1, r2, value in operations: for i in range(n): grid[r1-1][i] += value grid[r2-1][i] += value total_sum = sum(sum(row) for row in grid) return total_sum"},{"question":"from collections import Counter def balance_string(s: str) -> str: Transform the input string into a balanced format where the most frequent character's count does not exceed the least frequent character's count by more than one. Parameters: s (str): The input string Returns: str: The balanced version of the string Example: >>> balance_string(\\"aabbcc\\") 'aabbcc' >>> balance_string(\\"aaab\\") 'aabb' >>> balance_string(\\"xyz\\") 'xyz' def test_balance_string_already_balanced(): assert balance_string(\\"aabbcc\\") == \\"aabbcc\\" assert balance_string(\\"xyz\\") == \\"xyz\\" def test_balance_string_needing_addition(): balanced_version = balance_string(\\"aaab\\") balanced_counts = Counter(balanced_version) assert abs(max(balanced_counts.values()) - min(balanced_counts.values())) <= 1 def test_balance_string_edge_case_single_char(): assert balance_string(\\"a\\") == \\"a\\" def test_balance_string_edge_case_two_equal_chars(): assert balance_string(\\"aa\\") == \\"aa\\" def test_balance_string_complex_case(): balanced_version = balance_string(\\"aaaabbbbcc\\") balanced_counts = Counter(balanced_version) assert abs(max(balanced_counts.values()) - min(balanced_counts.values())) <= 1 def test_balance_string_all_same_char(): balanced_version = balance_string(\\"aaa\\") balanced_counts = Counter(balanced_version) assert abs(max(balanced_counts.values()) - min(balanced_counts.values())) <= 1","solution":"from collections import Counter def balance_string(s): Balances the input string according to the defined criteria. if not s: return s char_count = Counter(s) min_char_count = min(char_count.values()) max_char_count = max(char_count.values()) while max_char_count - min_char_count > 1: for char in char_count: if char_count[char] == max_char_count: char_count[char] -= 1 break min_char_count = min(char_count.values()) max_char_count = max(char_count.values()) balanced_str = \\"\\" for char, count in char_count.items(): balanced_str += char * count return balanced_str"},{"question":"def common_characters(s1: str, s2: str) -> str: Return a string containing the common characters between s1 and s2 in the order they appear in \`s1\`. >>> common_characters(\\"abcdef\\", \\"defxyz\\") 'def' >>> common_characters(\\"abacadabra\\", \\"abracadabra\\") 'abacadabra'","solution":"def common_characters(s1, s2): from collections import Counter counter1 = Counter(s1) counter2 = Counter(s2) common_chars = [] for char in s1: if char in counter2 and counter1[char] > 0 and counter2[char] > 0: common_chars.append(char) counter1[char] -= 1 counter2[char] -= 1 return ''.join(common_chars)"},{"question":"def max_of_weakest_soldier(strengths, queries): Return the maximum strength of the weakest soldier that meets or exceeds the given threshold for each query. Args: strengths (List[int]): List of integers representing the strengths of soldiers. queries (List[int]): List of integers representing the threshold strengths for the queries. Returns: List[int]: List of integers where each integer is the answer to the corresponding query. Examples: >>> max_of_weakest_soldier([5, 6, 8, 3, 1, 7], [4, 10, 6, 2]) [5, -1, 6, 3] >>> max_of_weakest_soldier([9, 4, 2, 3, 7], [5, 1, 8]) [7, 2, 9] >>> max_of_weakest_soldier([1, 2, 3, 4, 5], [6, 10, 7]) [-1, -1, -1] >>> max_of_weakest_soldier([1], [0, 1, 2]) [1, 1, -1] >>> max_of_weakest_soldier([5, 6, 7, 4], [4, 4, 4, 4]) [4, 4, 4, 4] from bisect import bisect_left","solution":"from bisect import bisect_left def max_of_weakest_soldier(strengths, queries): Returns the result for each query. strengths.sort() results = [] for query in queries: idx = bisect_left(strengths, query) if idx < len(strengths): results.append(strengths[idx]) else: results.append(-1) return results"},{"question":"def min_replacements_to_remove_blighted_crops(N, grid): Returns the minimum number of cells that need to be replaced to remove all blighted crops. >>> min_replacements_to_remove_blighted_crops(3, [[1, -1, 1], [-1, 2, 2], [1, 1, -2]]) 3 >>> min_replacements_to_remove_blighted_crops(4, [[1, 2, 3, -2], [4, -5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]) 2 >>> min_replacements_to_remove_blighted_crops(2, [[-1, -1], [-1, -1]]) 4 >>> min_replacements_to_remove_blighted_crops(1, [[-10]]) 1 >>> min_replacements_to_remove_blighted_crops(3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 0","solution":"def min_replacements_to_remove_blighted_crops(N, grid): Returns the minimum number of cells that need to be replaced to remove all blighted crops. def is_blighted(x, y): Check if a cell is blighted or not. return grid[x][y] < 0 replacements = 0 for i in range(N): for j in range(N): if is_blighted(i, j): replacements += 1 grid[i][j] = -grid[i][j] return replacements"},{"question":"def findLastPerson(n: int, k: int) -> int: Returns the position (1-indexed) of the last person standing. >>> findLastPerson(5, 2) 3 >>> findLastPerson(6, 3) 1 def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Solves multiple test cases for the problem of finding the last person standing. >>> solve([(5, 2), (6, 3)]) [3, 1] >>> solve([(1, 1), (2, 2), (7, 3)]) [1, 1, 4]","solution":"def findLastPerson(n, k): Returns the position (1-indexed) of the last person standing. if n == 1: return 1 else: return (findLastPerson(n - 1, k) + k - 1) % n + 1 def solve(test_cases): results = [] for n, k in test_cases: results.append(findLastPerson(n, k)) return results"},{"question":"import itertools import math from typing import List, Tuple def calculate_distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points p1 and p2. pass def total_distance(route: List[Tuple[int, int]]) -> float: Calculate the total distance of the given route which starts and ends at the first location. pass def find_min_route(locations: List[Tuple[int, int]]) -> float: Find the minimum route that visits all locations exactly once and returns to the start point. pass # Unit tests def test_calculate_distance(): assert calculate_distance((0, 0), (3, 4)) == 5.0 assert calculate_distance((1, 1), (4, 5)) == 5.0 assert calculate_distance((0, 0), (0, 0)) == 0.0 def test_total_distance(): assert total_distance([(0, 0), (3, 4), (6, 8)]) == 20.0 assert total_distance([(0, 0), (0, 2), (2, 2), (2, 0)]) == 8.0 def test_find_min_route(): assert find_min_route([(0, 0), (1, 1), (2, 0)]) == 4.83 assert find_min_route([(0, 0), (1, 0), (1, 1), (0, 1)]) == 4.0 assert find_min_route([(0, 0), (2, 0), (0, 2), (2, 2)]) == 8.0 def test_run(): test_calculate_distance() test_total_distance() test_find_min_route() print(\\"All tests passed!\\") # Run the test functions test_run()","solution":"import itertools import math def calculate_distance(p1, p2): Calculate the Euclidean distance between two points p1 and p2. return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_distance(route): Calculate the total distance of the given route which starts and ends at the first location. distance = 0 for i in range(len(route) - 1): distance += calculate_distance(route[i], route[i + 1]) distance += calculate_distance(route[-1], route[0]) # returning to the starting point return distance def find_min_route(locations): Find the minimum route that visits all locations exactly once and returns to the start point. min_distance = float('inf') for perm in itertools.permutations(locations): current_distance = total_distance(perm) if current_distance < min_distance: min_distance = current_distance return round(min_distance, 2)"},{"question":"from typing import List, Tuple def update_grid(m: int, n: int, updates: List[Tuple[int, int, int, int]]) -> List[List[int]]: Update the grid of size m x n based on the given list of updates. Args: m: The number of rows in the grid. n: The number of columns in the grid. updates: A list of tuples containing the updates in the form (row1, col1, row2, col2). Returns: The final state of the grid after applying all updates. >>> update_grid(3, 4, [(0, 0, 1, 1), (1, 1, 2, 3)]) [[1, 1, 0, 0], [1, 2, 1, 1], [0, 1, 1, 1]] >>> update_grid(3, 4, [(0, 0, 1, 1)]) [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0]] >>> update_grid(3, 4, []) [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]] >>> update_grid(3, 3, [(0, 0, 2, 2)]) [[1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> update_grid(5, 5, [(0, 0, 2, 2), (1, 1, 3, 3), (2, 2, 4, 4)]) [[1, 1, 1, 0, 0], [1, 2, 2, 1, 0], [1, 2, 3, 2, 1], [0, 1, 2, 2, 1], [0, 0, 1, 1, 1]]","solution":"from typing import List, Tuple def update_grid(m: int, n: int, updates: List[Tuple[int, int, int, int]]) -> List[List[int]]: grid = [[0 for _ in range(n)] for _ in range(m)] for row1, col1, row2, col2 in updates: for i in range(row1, row2 + 1): for j in range(col1, col2 + 1): grid[i][j] += 1 return grid"},{"question":"def min_days_to_read_books(n: int, k: int, pages: List[int]) -> int: Computes the minimum number of days required for Alice to read all her books given the list of pages in each book and the number of pages she can read per day. :param n: int, number of books :param k: int, pages Alice can read per day :param pages: list of int, list containing the number of pages in each book :return: int, minimum number of days required to read all books >>> min_days_to_read_books(3, 5, [6, 8, 7]) 5 >>> min_days_to_read_books(4, 10, [10, 20, 30, 40]) 10 >>> min_days_to_read_books(1, 50, [100]) 2 >>> min_days_to_read_books(2, 20, [30, 50]) 4 >>> min_days_to_read_books(5, 10, [10, 10, 10, 10, 10]) 5 >>> min_days_to_read_books(3, 10, [25, 25, 25]) 8 >>> min_days_to_read_books(0, 10, []) 0","solution":"def min_days_to_read_books(n, k, pages): This function computes the minimum number of days required for Alice to read all her books given the list of pages in each book and the number of pages she can read per day. :param n: int, number of books :param k: int, pages Alice can read per day :param pages: list of int, list containing the number of pages in each book :return: int, minimum number of days required to read all books total_pages = sum(pages) min_days = (total_pages + k - 1) // k # Ceiling division return min_days # Example of how to use the function: # Input: 3 5 # 6 8 7 # Output: 5 n = 3 k = 5 pages = [6, 8, 7] print(min_days_to_read_books(n, k, pages)) # Output should be 5"},{"question":"class FileSystem: def __init__(self, num_directories: int): Initializes the file system with the specified number of directories. Each directory is initially empty. pass def add_file(self, directory: int, file_size: int): Adds a file with the specified size to the given directory. pass def remove_file(self, directory: int, file_size: int): Removes a file with the specified size from the given directory. It is guaranteed that the file with the given size exists in the directory. pass def directory_size(self, directory: int) -> int: Returns the total size of all the files in the specified directory. pass def process_operations(operations): file_system = None result = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"Create\\": num_directories = int(parts[1]) file_system = FileSystem(num_directories) elif command == \\"AddFile\\": directory = int(parts[1]) file_size = int(parts[2]) file_system.add_file(directory, file_size) elif command == \\"RemoveFile\\": directory = int(parts[1]) file_size = int(parts[2]) file_system.remove_file(directory, file_size) elif command == \\"DirectorySize\\": directory = int(parts[1]) result.append(file_system.directory_size(directory)) return result def test_file_system(): operations = [ \\"Create 3\\", \\"AddFile 1 100\\", \\"AddFile 1 200\\", \\"DirectorySize 1\\", \\"RemoveFile 1 100\\", \\"DirectorySize 1\\" ] expected_result = [300, 200] assert process_operations(operations) == expected_result def test_file_system_multiple_directories(): operations = [ \\"Create 5\\", \\"AddFile 1 100\\", \\"AddFile 1 200\\", \\"AddFile 2 150\\", \\"DirectorySize 1\\", \\"DirectorySize 2\\", \\"RemoveFile 2 150\\", \\"DirectorySize 2\\", \\"AddFile 2 300\\", \\"DirectorySize 2\\" ] expected_result = [300, 150, 0, 300] assert process_operations(operations) == expected_result def test_file_system_empty_directories(): operations = [ \\"Create 3\\", \\"AddFile 0 50\\", \\"DirectorySize 1\\", \\"DirectorySize 2\\" ] expected_result = [0, 0] assert process_operations(operations) == expected_result def test_file_system_large_sizes(): operations = [ \\"Create 2\\", \\"AddFile 0 1\\", \\"AddFile 0 2\\", \\"AddFile 0 3\\", \\"DirectorySize 0\\", \\"RemoveFile 0 2\\", \\"DirectorySize 0\\" ] expected_result = [6, 4] assert process_operations(operations) == expected_result def test_remove_nonexistent_file(): operations = [ \\"Create 2\\", \\"AddFile 0 1\\", \\"AddFile 0 2\\", \\"RemoveFile 0 2\\", \\"DirectorySize 0\\" ] expected_result = [1] assert process_operations(operations) == expected_result","solution":"class FileSystem: def __init__(self, num_directories: int): Initializes the file system with the specified number of directories. Each directory is initially empty. self.directories = [[] for _ in range(num_directories)] def add_file(self, directory: int, file_size: int): Adds a file with the specified size to the given directory. self.directories[directory].append(file_size) def remove_file(self, directory: int, file_size: int): Removes a file with the specified size from the given directory. It is guaranteed that the file with the given size exists in the directory. if file_size in self.directories[directory]: self.directories[directory].remove(file_size) def directory_size(self, directory: int) -> int: Returns the total size of all the files in the specified directory. return sum(self.directories[directory]) def process_operations(operations): file_system = None result = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"Create\\": num_directories = int(parts[1]) file_system = FileSystem(num_directories) elif command == \\"AddFile\\": directory = int(parts[1]) file_size = int(parts[2]) file_system.add_file(directory, file_size) elif command == \\"RemoveFile\\": directory = int(parts[1]) file_size = int(parts[2]) file_system.remove_file(directory, file_size) elif command == \\"DirectorySize\\": directory = int(parts[1]) result.append(file_system.directory_size(directory)) return result"},{"question":"from typing import List def numIslands(grid: List[List[int]]) -> int: Count the number of distinct islands in a rectangular grid. An island is a group of connected land cells (1s) surrounded by water (0s). >>> grid = [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 0, 0] ... ] >>> numIslands(grid) 3 >>> grid = [ ... [1, 0, 1, 0, 1] ... ] >>> numIslands(grid) 3 >>> grid = [ ... [1], ... [0], ... [1], ... [0], ... [1] ... ] >>> numIslands(grid) 3 >>> grid = [ ... [1, 1], ... [1, 1] ... ] >>> numIslands(grid) 1 >>> grid = [ ... [0, 0], ... [0, 0] ... ] >>> numIslands(grid) 0 >>> grid = [ ... [1] ... ] >>> numIslands(grid) 1 >>> grid = [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ] >>> numIslands(grid) 5","solution":"from typing import List def numIslands(grid: List[List[int]]) -> int: if not grid: return 0 n, m = len(grid), len(grid[0]) visited = [[False]*m for _ in range(n)] def dfs(i, j): if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == 0 or visited[i][j]: return visited[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1 and not visited[i][j]: dfs(i, j) count += 1 return count"},{"question":"def max_cities_to_visit(n, m, T, visit_times, roads): Determine the maximum number of unique cities John and his friends can visit within the given time limit. Parameters: n (int): Number of cities. m (int): Number of direct roads. T (int): Maximum time for the trip. visit_times (List[int]): List of times required to visit each city. roads (List[Tuple[int, int, int]]): List of tuples each representing a road between two cities with travel time. Returns: int: The maximum number of unique cities that can be visited. Example: >>> max_cities_to_visit(6, 7, 12, [2, 3, 4, 2, 6, 3], [(1, 2, 1), (1, 3, 3), (2, 3, 1), (2, 4, 2), (3, 5, 1), (4, 5, 3), (5, 6, 2)]) 4 >>> max_cities_to_visit(5, 5, 10, [3, 2, 4, 5, 1], [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 3, 4)]) 3 # Implement the function here pass def test_max_cities_example1(): input_str = \\"6 7 12n2 3 4 2 6 3n1 2 1n1 3 3n2 3 1n2 4 2n3 5 1n4 5 3n5 6 2\\" assert input_and_solve(input_str) == 4 def test_max_cities_example2(): input_str = \\"5 5 10n3 2 4 5 1n1 2 1n2 3 2n3 4 3n4 5 4n1 3 4\\" assert input_and_solve(input_str) == 3 def test_max_cities_single_city(): input_str = \\"1 0 1n1n\\" assert input_and_solve(input_str) == 1 def test_max_cities_no_road(): input_str = \\"3 0 10n5 4 3n\\" assert input_and_solve(input_str) == 1 def test_max_cities_long_paths(): input_str = \\"5 4 100n20 20 20 20 20n1 2 1000n2 3 1000n3 4 1000n4 5 1000\\" assert input_and_solve(input_str) == 1 def parse_input(input_string): lines = input_string.split('n') n, m, T = map(int, lines[0].split()) visit_times = list(map(int, lines[1].split())) roads = [tuple(map(int, lines[i + 2].split())) for i in range(m)] return (n, m, T, visit_times, roads) def input_and_solve(input_text): n, m, T, visit_times, roads = parse_input(input_text) return max_cities_to_visit(n, m, T, visit_times, roads)","solution":"import heapq import sys def max_cities_to_visit(n, m, T, visit_times, roads): # Use Dijkstra's algorithm for shortest path graph = [[] for _ in range(n + 1)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(time_limit): dist = [sys.maxsize] * (n + 1) dist[1] = 0 pq = [(0, 1)] # (cost, node) while pq: current_time, node = heapq.heappop(pq) if current_time > dist[node]: continue for neighbor, weight in graph[node]: new_time = current_time + weight + visit_times[neighbor - 1] if new_time < dist[neighbor]: dist[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return len([d for d in dist if d <= time_limit]) max_cities = 0 max_cities = dijkstra(T) return max_cities # Parsing input def parse_input(input_string): lines = input_string.split('n') n, m, T = map(int, lines[0].split()) visit_times = list(map(int, lines[1].split())) roads = [tuple(map(int, lines[i + 2].split())) for i in range(m)] return (n, m, T, visit_times, roads) def input_and_solve(input_text): n, m, T, visit_times, roads = parse_input(input_text) return max_cities_to_visit(n, m, T, visit_times, roads)"},{"question":"def max_distinct_integers(n: int, m: int, k: int, grid: List[List[int]]) -> int: Determine the maximum number of distinct integers that can be present in the grid after performing the operations optimally. >>> max_distinct_integers(3, 3, 2, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 9 >>> max_distinct_integers(3, 3, 2, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]]) 1 >>> max_distinct_integers(3, 3, 2, [ ... [1, 2, 2], ... [3, 4, 4], ... [3, 3, 1]]) 4 >>> max_distinct_integers(500, 500, 499, [[i for i in range(500)] for j in range(500)]) 500 >>> max_distinct_integers(1, 1, 1, [[5]]) 1 pass","solution":"def max_distinct_integers(n, m, k, grid): Determine the maximum number of distinct integers that can be present in the grid after performing the operations optimally. nums = set() for row in grid: nums.update(row) return len(nums)"},{"question":"def first_recurring_with_position(test_cases: List[str]) -> List[str]: Solve the firm decision problem. This function takes a list of test cases and returns for each test case, the first recurring character with its position in the string. If there is no such character, it returns -1. Examples: >>> first_recurring_with_position([\\"abca1\\", \\"12345\\", \\"hello\\", \\"112233\\"]) ['a 4', '-1', 'l 4', '1 2'] >>> first_recurring_with_position([\\"noon\\"]) ['o 3'] >>> first_recurring_with_position([\\"abcabc\\"]) ['a 4'] # Implementation def process_input(T: int, test_strings: List[str]) -> List[str]: This function reads input and calls the main logic function to process it. Examples: >>> process_input(4, [\\"abca1\\", \\"12345\\", \\"hello\\", \\"112233\\"]) ['a 4', '-1', 'l 4', '1 2'] >>> process_input(1, [\\"noon\\"]) ['o 3'] >>> process_input(1, [\\"abcabc\\"]) ['a 4'] # Implementation","solution":"def first_recurring_with_position(test_cases): results = [] for case in test_cases: seen_chars = {} recurring_char_found = False for i, char in enumerate(case): if char in seen_chars: results.append(f\\"{char} {i + 1}\\") recurring_char_found = True break else: seen_chars[char] = i if not recurring_char_found: results.append(\\"-1\\") return results # Function to read input and call the main logic function def process_input(T, test_strings): return first_recurring_with_position(test_strings)"},{"question":"def who_wins(num_cases: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the winner of the game between Alice and Bob given the initial configuration of the containers. >>> who_wins(2, [(3, [1, 3, 4]), (2, [2, 2])]) [\\"Alice\\", \\"Bob\\"] >>> who_wins(1, [(4, [1, 2, 3, 4])]) [\\"Alice\\"] >>> who_wins(1, [(5, [0, 0, 0, 0, 0])]) [\\"Bob\\"] >>> who_wins(1, [(2, [1, 1])]) [\\"Bob\\"] >>> who_wins(1, [(2, [2, 1])]) [\\"Alice\\"]","solution":"def who_wins(num_cases, cases): results = [] for case in cases: n, pebbles = case nim_sum = 0 for pile in pebbles: nim_sum ^= pile if nim_sum == 0: results.append(\\"Bob\\") else: results.append(\\"Alice\\") return results"},{"question":"class Library: A library system to manage books with operations to add, delete, and find books by ISBN or author. Methods: addBook(isbn, title, author): Adds a book with the given ISBN, title, and author. deleteBook(isbn): Deletes the book with the given ISBN from the library. findBookByIsbn(isbn): Returns the title and author of the book with the given ISBN or 'Book not found'. findBooksByAuthor(author): Returns a sorted list of book titles written by the given author or 'No books found'. >>> library = Library() >>> library.addBook(123, \\"Title1\\", \\"Author1\\") >>> library.addBook(789, \\"Title3\\", \\"Author1\\") >>> library.addBook(456, \\"Title2\\", \\"Author1\\") >>> library.findBookByIsbn(123) ('Title1', 'Author1') >>> library.findBooksByAuthor(\\"Author1\\") ['Title1', 'Title2', 'Title3'] >>> library.deleteBook(123) >>> library.findBookByIsbn(123) 'Book not found' >>> library.findBooksByAuthor(\\"Author1\\") ['Title2', 'Title3'] def __init__(self): pass # Implement initialization def addBook(self, isbn, title, author): pass # Implement addBook method def deleteBook(self, isbn): pass # Implement deleteBook method def findBookByIsbn(self, isbn): pass # Implement findBookByIsbn method def findBooksByAuthor(self, author): pass # Implement findBooksByAuthor method","solution":"class Library: def __init__(self): self.books_by_isbn = {} self.books_by_author = {} def addBook(self, isbn, title, author): if isbn not in self.books_by_isbn: self.books_by_isbn[isbn] = (title, author) if author not in self.books_by_author: self.books_by_author[author] = [] self.books_by_author[author].append(title) def deleteBook(self, isbn): if isbn in self.books_by_isbn: title, author = self.books_by_isbn.pop(isbn) self.books_by_author[author].remove(title) if not self.books_by_author[author]: del self.books_by_author[author] def findBookByIsbn(self, isbn): return self.books_by_isbn.get(isbn, \\"Book not found\\") def findBooksByAuthor(self, author): if author in self.books_by_author: return sorted(self.books_by_author[author]) else: return \\"No books found\\""},{"question":"from typing import List, Tuple def find_frequent_item_pairs(purchases: List[str]) -> List[Tuple[int, int]]: Determine all unique pairs of item IDs that appear in the same purchase record across all transactions. Args: purchases: A list of purchase records, each in the format \\"c item1 item2 ... itemc\\" Returns: A list of tuples where each tuple contains one unique pair of item IDs. The list is sorted lexicographically. >>> find_frequent_item_pairs([\\"3 1 2 3\\", \\"2 2 3\\", \\"4 1 4 5 6\\"]) [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (4, 5), (4, 6), (5, 6)] >>> find_frequent_item_pairs([\\"3 5 7 8\\", \\"3 6 7 5\\"]) [(5, 6), (5, 7), (5, 8), (6, 7), (7, 8)] >>> find_frequent_item_pairs([\\"1 50\\"]) [] def process_input(input_data: str) -> List[Tuple[int, int]]: Process the multiline string input and extract the purchase records to determine the item pairs. Args: input_data: A multiline string with the first line representing the number of purchases followed by purchase records. Returns: A list of tuples where each tuple contains one unique pair of item IDs. The list is sorted lexicographically. >>> process_input(\\"3n3 1 2 3n2 2 3n4 1 4 5 6\\") [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (4, 5), (4, 6), (5, 6)] >>> process_input(\\"2n3 5 7 8n3 6 7 5\\") [(5, 6), (5, 7), (5, 8), (6, 7), (7, 8)] >>> process_input(\\"1n1 50\\") []","solution":"def find_frequent_item_pairs(purchases): from itertools import combinations item_pairs = set() for purchase in purchases: items = purchase.split() num_items = int(items[0]) item_list = sorted(int(item) for item in items[1:num_items+1]) for pair in combinations(item_list, 2): item_pairs.add(pair) sorted_pairs = sorted(item_pairs) return sorted_pairs def process_input(input_data): purchases = input_data.strip().split('n')[1:] return find_frequent_item_pairs(purchases)"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def find_reachable_node(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine if there exists any reservoir in the network from which all other reservoirs are reachable. Args: n (int): The number of reservoirs. m (int): The number of one-way pipes. edges (List[Tuple[int, int]]): List of one-way pipes. Returns: int: The identifier of the reservoir from which all other reservoirs are reachable, or -1 if no such reservoir exists. >>> find_reachable_node(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) 1 >>> find_reachable_node(4, 2, [(1, 2), (3, 4)]) -1 >>> find_reachable_node(1, 0, []) 1 def test_example_case(): n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (1, 3)] assert find_reachable_node(n, m, edges) == 1 def test_no_reachable_node(): n = 4 m = 2 edges = [(1, 2), (3, 4)] assert find_reachable_node(n, m, edges) == -1 def test_single_node(): n = 1 m = 0 edges = [] assert find_reachable_node(n, m, edges) == 1 def test_large_graph(): n = 6 m = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (4, 6), (5, 3)] assert find_reachable_node(n, m, edges) == 1 def test_another_example(): n = 5 m = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 4)] assert find_reachable_node(n, m, edges) == 1 def test_all_disconnected(): n = 5 m = 0 edges = [] assert find_reachable_node(n, m, edges) == -1","solution":"from collections import defaultdict, deque def find_reachable_node(n, m, edges): # Helper function to perform BFS def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Create a directed graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Start with any node and check all nodes reachable from that node start_node = 1 for i in range(1, n + 1): if i in graph: start_node = i break reachable_from_start = bfs(start_node) # If we cannot reach all nodes from the start_node if len(reachable_from_start) != n: return -1 # Check if every node can reach this start_node reverse_graph = defaultdict(list) for u, v in edges: reverse_graph[v].append(u) all_reach_start = bfs(start_node) if len(all_reach_start) == n: return start_node else: return -1 # Example input n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (1, 3)] print(find_reachable_node(n, m, edges)) # Output should be 1"},{"question":"def get_win_counts(n: int, m: int, contests: List[List[int]]) -> List[int]: Given the number of members n, the number of contests m, and a list of contests, returns the win count for each member. Parameters: n (int): Number of members m (int): Number of contests contests (List[List[int]]): A list of contests where each contest is a list [xi, yi, zi] representing two members (xi and yi) competing and the winner (zi). Returns: List[int]: A list of win counts for each member.","solution":"def get_win_counts(n, m, contests): Given the number of members n, the number of contests m, and a list of contests, returns the win count for each member. Parameters: n (int): Number of members m (int): Number of contests contests (List[List[int]]): A list of contests where each contest is a list [xi, yi, zi] representing two members (xi and yi) competing and the winner (zi). Returns: List[int]: A list of win counts for each member. win_counts = [0] * n for xi, yi, zi in contests: win_counts[zi-1] += 1 return win_counts"},{"question":"def can_partition_k_subsets(nums: List[int], k: int) -> str: Determines if it is possible to partition the list 'nums' into 'k' subsets with equal sum of elements in each subset. :param nums: List of integers. :param k: Integer denoting the number of subsets. :return: \\"YES\\" if partitioning is possible, otherwise \\"NO\\". >>> can_partition_k_subsets([2, 1, 4, 5, 6], 3) 'YES' >>> can_partition_k_subsets([1, 2, 3, 4], 2) 'YES' >>> can_partition_k_subsets([1, 2, 3, 4], 3) 'NO' >>> can_partition_k_subsets([2, 2, 2, 2], 4) 'YES' >>> can_partition_k_subsets([2, 2, 2, 2, 1], 4) 'NO' >>> can_partition_k_subsets([1], 1) 'YES' >>> can_partition_k_subsets([2, 2, 2, 2, 2, 2, 2, 2, 2, 2], 2) 'YES'","solution":"def can_partition_k_subsets(nums, k): Determines if it is possible to partition the list 'nums' into 'k' subsets with equal sum of elements in each subset. :param nums: List of integers. :param k: Integer denoting the number of subsets. :return: \\"YES\\" if partitioning is possible, otherwise \\"NO\\". total_sum = sum(nums) if total_sum % k != 0: return \\"NO\\" target = total_sum // k def backtrack(i, current_sum, count): if count == k - 1: return True if current_sum == target: return backtrack(0, 0, count + 1) for j in range(i, len(nums)): if not visited[j] and current_sum + nums[j] <= target: visited[j] = True if backtrack(j + 1, current_sum + nums[j], count): return True visited[j] = False return False nums.sort(reverse=True) visited = [False] * len(nums) return \\"YES\\" if backtrack(0, 0, 0) else \\"NO\\""},{"question":"def binary_gcd(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) of two non-negative integers using the Binary GCD algorithm (Stein's algorithm). >>> binary_gcd(48, 18) 6 >>> binary_gcd(7, 0) 7 >>> binary_gcd(6, 9) 3 >>> binary_gcd(0, 0) 0","solution":"def binary_gcd(a: int, b: int) -> int: Calculate the greatest common divisor (GCD) of two non-negative integers using the Binary GCD algorithm (Stein's algorithm). # Base cases if a == 0: return b if b == 0: return a # Reduce initial a and b by removing common factors of 2 k = 0 while ((a | b) & 1) == 0: # a and b are both even a >>= 1 b >>= 1 k += 1 # At this point, at least one of a or b is odd while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: # Remove all factors of 2 in b b >>= 1 # Now both a and b are odd. Swap if necessary so that a <= b, # then set b = b - a (which is even). if a > b: a, b = b, a b = b - a # Restore common factors of 2 return a << k"},{"question":"def diagonal_sum(matrix: List[List[int]]) -> int: Calculate the sum of the diagonal elements of a given square matrix. Args: matrix (List[List[int]]): A two-dimensional list representing a square matrix. Returns: int: The sum of the diagonal elements. Example: >>> diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 15 >>> diagonal_sum([ ... [1] ... ]) 1 pass # Sample Test Cases def test_diagonal_sum_3x3_matrix(): assert diagonal_sum([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 15 def test_diagonal_sum_1x1_matrix(): assert diagonal_sum([ [42] ]) == 42 def test_diagonal_sum_2x2_matrix(): assert diagonal_sum([ [1, 2], [3, 4] ]) == 5 def test_diagonal_sum_4x4_matrix(): assert diagonal_sum([ [1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4] ]) == 10 def test_diagonal_sum_large_matrix(): assert diagonal_sum([ [i for i in range(50)] for j in range(50) ]) == sum(i for i in range(50))","solution":"def diagonal_sum(matrix): Returns the sum of the diagonal elements of a given square matrix. n = len(matrix) return sum(matrix[i][i] for i in range(n))"},{"question":"import heapq from typing import List, Tuple def minimum_toll_cost(n: int, m: int, q: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determines the minimum toll cost to travel between lands in a kingdom. >>> minimum_toll_cost(5, 7, 3, [(1, 2, 2), (1, 3, 5), (2, 3, 1), (2, 4, 4), (3, 4, 3), (3, 5, 2), (4, 5, 3)], [(3, 5), (1, 4), (2, 5)]) [2, 6, 3] >>> minimum_toll_cost(4, 2, 2, [(1, 2, 3), (3, 4, 5)], [(1, 4), (2, 3)]) [-1, -1] >>> minimum_toll_cost(3, 3, 2, [(1, 2, 1), (2, 3, 2), (3, 1, 3)], [(1, 1), (2, 2)]) [0, 0] >>> minimum_toll_cost(3, 3, 2, [(1, 2, 10), (2, 3, 10), (1, 3, 5)], [(1, 3), (2, 3)]) [5, 10]","solution":"import heapq def minimum_toll_cost(n, m, q, roads, queries): def dijkstra(start, n, adj): dist = [float('inf')] * (n + 1) dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in adj[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist adj = [[] for _ in range(n + 1)] for u, v, w in roads: adj[u].append((v, w)) adj[v].append((u, w)) results = [] for a, b in queries: if a == b: results.append(0) continue dist = dijkstra(a, n, adj) results.append(dist[b] if dist[b] != float('inf') else -1) return results"},{"question":"from typing import List def maxConsecutiveOnes(nums: List[int]) -> int: Find the length of the longest contiguous subarray of 1s after flipping at most one 0 to a 1. >>> maxConsecutiveOnes([1, 0, 1, 1, 0, 1]) 4 >>> maxConsecutiveOnes([1, 1, 1, 1]) 4 >>> maxConsecutiveOnes([0, 0, 0, 0]) 1 >>> maxConsecutiveOnes([1, 1, 0, 1]) 4 >>> maxConsecutiveOnes([1, 0, 1, 0, 1, 0, 1, 0]) 3 >>> maxConsecutiveOnes([0]) 1 >>> maxConsecutiveOnes([1]) 1","solution":"from typing import List def maxConsecutiveOnes(nums: List[int]) -> int: max_len = 0 zero_flip = -1 # To keep track of the zero index which is flipped left = 0 for right in range(len(nums)): if nums[right] == 0: if zero_flip != -1: left = zero_flip + 1 zero_flip = right max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List, Tuple def find_connected_components(n: int, edges: List[Tuple[int, int]], k: int) -> int: Given the number of nodes, a list of edges representing direct friendships, and the maximum allowed distance k, return the number of connected components where the maximum distance between any two nodes within the same component is k edges or less. >>> find_connected_components(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], 2) 2 >>> find_connected_components(6, [(1, 2), (2, 3), (4, 5)], 1) 4 >>> find_connected_components(1, [], 1) 1 >>> find_connected_components(5, [], 2) 5 >>> find_connected_components(4, [(1, 2), (2, 3), (3, 4)], 3) 1","solution":"from collections import defaultdict, deque def find_connected_components(n, edges, k): def bfs(node): queue = deque([(node, 0)]) visited.add(node) component_nodes = [node] while queue: current, distance = queue.popleft() for neighbor in graph[current]: if neighbor not in visited and distance + 1 <= k: visited.add(neighbor) component_nodes.append(neighbor) queue.append((neighbor, distance + 1)) return set(component_nodes) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() components_count = 0 for node in range(1, n + 1): if node not in visited: bfs(node) components_count += 1 return components_count"},{"question":"def maximum_difference_path(grid: List[List[int]]) -> int: Find the maximum height difference on the optimal path from top-left corner to bottom-right corner in the grid. >>> maximum_difference_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 8 >>> maximum_difference_path([[1, 3], [2, 4]]) 3 >>> maximum_difference_path([[42]]) 0 >>> maximum_difference_path([[1, 1000000], [1000000, 1]]) 999999 >>> maximum_difference_path([[0]*1000 for _ in range(1000)]) 0 >>> maximum_difference_path([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) 5","solution":"def maximum_difference_path(grid): import heapq n = len(grid) m = len(grid[0]) # Min-heap to store (difference, x, y, min_val, max_val) heap = [(0, 0, 0, grid[0][0], grid[0][0])] visited = set((0, 0)) while heap: diff, x, y, min_val, max_val = heapq.heappop(heap) if x == n - 1 and y == m - 1: return max_val - min_val for dx, dy in [(1, 0), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited: visited.add((nx, ny)) new_min = min(min_val, grid[nx][ny]) new_max = max(max_val, grid[nx][ny]) new_diff = new_max - new_min heapq.heappush(heap, (new_diff, nx, ny, new_min, new_max))"},{"question":"def longest_distinct_subsequence_length(s: str) -> int: Returns the length of the longest subsequence of distinct characters. >>> longest_distinct_subsequence_length(\\"abcabcbb\\") 3 >>> longest_distinct_subsequence_length(\\"bbbbb\\") 1 >>> longest_distinct_subsequence_length(\\"pwwkew\\") 4 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases to find the longest subsequence of distinct characters. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 4]","solution":"def longest_distinct_subsequence_length(s): Returns the length of the longest subsequence of distinct characters. # Use a set to track unique characters unique_chars = set(s) # The length of the longest subsequence of distinct characters return len(unique_chars) def process_test_cases(T, test_cases): results = [] for test_case in test_cases: results.append(longest_distinct_subsequence_length(test_case)) return results"},{"question":"from collections import deque def min_steps_to_reach_end(n: int, forest: List[List[str]]) -> int: Given a 2D grid representing a forest, determine the minimum number of steps required for an animal to move from the top-left corner to the bottom-right corner. If it's impossible, return -1. >>> forest = [ ['.', '.', '.', '#'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.'], ] >>> min_steps_to_reach_end(4, forest) 6 >>> forest = [ ['.', '.', '.'], ['#', '.', '#'], ['.', '#', '.'] ] >>> min_steps_to_reach_end(3, forest) -1","solution":"from collections import deque def min_steps_to_reach_end(n, forest): if forest[0][0] == '#' or forest[n-1][n-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y, steps = queue.popleft() if x == n-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and forest[nx][ny] == '.': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List def is_arithmetic_progression(n: int, lst: List[int]) -> bool: Write a function that takes an integer \`n\` and a list of \`k\` integers, and returns whether the list of integers forms an arithmetic progression up to \`n\`. An arithmetic progression is a sequence of numbers in which the difference between consecutive terms is constant. Args: n: An integer, the upper bound of the integers. lst: A list of integers to be checked as arithmetic progression. Returns: A boolean value, True if the list forms an arithmetic progression, otherwise False. Examples: >>> is_arithmetic_progression(15, [1, 4, 7, 10, 13]) True >>> is_arithmetic_progression(10, [2, 4, 6, 9]) False","solution":"def is_arithmetic_progression(n, lst): if len(lst) < 2: return True # A list with less than 2 elements is trivially an arithmetic progression diff = lst[1] - lst[0] # Calculate the common difference for i in range(2, len(lst)): if lst[i] - lst[i - 1] != diff: return False return True"},{"question":"def judge_starting_position(moves: str) -> bool: Determines if the character returns to the starting position (0, 0) after a sequence of moves. :param moves: A string of moves consisting of 'U', 'D', 'L', 'R' :return: True if the character returns to the starting position, otherwise False >>> judge_starting_position(\\"UDLR\\") True >>> judge_starting_position(\\"UUDDLLRR\\") True >>> judge_starting_position(\\"UUDLRR\\") False >>> judge_starting_position(\\"U\\") False >>> judge_starting_position(\\"LRLRLR\\") True pass","solution":"def judge_starting_position(moves): Determines if the character returns to the starting position (0, 0) after a sequence of moves. :param moves: A string of moves consisting of 'U', 'D', 'L', 'R' :return: True if the character returns to the starting position, otherwise False # Initialize position x, y = 0, 0 # Define move effects move_effects = { 'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0) } # Apply moves for move in moves: dx, dy = move_effects[move] x += dx y += dy # Check if returning to starting position return x == 0 and y == 0"},{"question":"def can_rearrange_consecutively(s: str, k: int) -> str: Determines if it is possible to rearrange the characters in the string so that there are at least k occurrences of any character consecutively. Args: s (str): The input string consisting of lowercase English letters. k (int): The required consecutive occurrences of any character. Returns: str: \\"YES\\" if rearrangement is possible, otherwise \\"NO\\". Examples: >>> can_rearrange_consecutively(\\"aabbcc\\", 2) \\"YES\\" >>> can_rearrange_consecutively(\\"aabbcc\\", 3) \\"NO\\"","solution":"def can_rearrange_consecutively(s, k): Determines if it's possible to rearrange the characters in the string so that there are at least k occurrences of any character consecutively. from collections import Counter char_count = Counter(s) max_char_occurrence = max(char_count.values()) return \\"YES\\" if max_char_occurrence >= k else \\"NO\\""},{"question":"def process_transactions(transactions): Process a list of transactions and determine the final account balance or if the transaction failed. >>> process_transactions([(\\"debit\\", 50, 100)]) [50] >>> process_transactions([(\\"credit\\", 200, 150)]) [350] >>> process_transactions([(\\"debit\\", 190, 180)]) ['failed'] >>> process_transactions([(\\"debit\\", 50, 100), (\\"credit\\", 200, 150), (\\"debit\\", 190, 180)]) [50, 350, 'failed'] >>> process_transactions([(\\"credit\\", 100, 50), (\\"debit\\", 20, 20)]) [150, 0]","solution":"def process_transactions(transactions): results = [] for transaction in transactions: transaction_type, amount, initial_balance = transaction if transaction_type == \\"debit\\": if amount > initial_balance: results.append(\\"failed\\") else: results.append(initial_balance - amount) elif transaction_type == \\"credit\\": results.append(initial_balance + amount) return results"},{"question":"def check_playlist(n: int, songs: List[int]) -> str: Determines if the playlist meets the no-consecutive-duplicate rule. Args: n (int): Number of songs in the playlist. songs (list): List of song IDs. Returns: str: \\"VALID\\" if no consecutive duplicates, otherwise the 1-based index of the first duplicate. >>> check_playlist(5, [1, 2, 3, 4, 5]) == \\"VALID\\" >>> check_playlist(4, [1, 3, 5, 7]) == \\"VALID\\" >>> check_playlist(1, [42]) == \\"VALID\\" >>> check_playlist(5, [1, 2, 2, 3, 4]) == \\"3\\" >>> check_playlist(6, [7, 8, 9, 9, 10, 11]) == \\"4\\" >>> check_playlist(3, [5, 5, 5]) == \\"2\\" >>> check_playlist(2, [1, 1]) == \\"2\\" >>> check_playlist(2, [10, 11]) == \\"VALID\\" >>> check_playlist(3, [6, 6, 7]) == \\"2\\"","solution":"def check_playlist(n, songs): Determines if the playlist meets the no-consecutive-duplicate rule. Args: n (int): Number of songs in the playlist. songs (list): List of song IDs. Returns: str: \\"VALID\\" if no consecutive duplicates, otherwise the 1-based index of the first duplicate. for i in range(1, n): if songs[i] == songs[i - 1]: return str(i + 1) return \\"VALID\\""},{"question":"from typing import List, Tuple def subset_product_perfect_square(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given an array of positive integers, determine if there exists a subset of the array such that the product of its elements is a perfect square. Args: T : int : the number of test cases test_cases : List[Tuple[int, List[int]]] : list of test cases where each test case is a tuple (N, array) Returns: List[str] : List of results, \\"YES\\" or \\"NO\\" for each test case >>> subset_product_perfect_square(2, [(4, [2, 3, 4, 6]), (3, [2, 5, 7])]) [\\"YES\\", \\"NO\\"] >>> subset_product_perfect_square(1, [(3, [4, 9, 16])]) [\\"YES\\"] >>> subset_product_perfect_square(1, [(5, [3, 5, 7, 11, 13])]) [\\"NO\\"] >>> subset_product_perfect_square(1, [(3, [4, 2, 3])]) [\\"YES\\"] >>> subset_product_perfect_square(1, [(4, [1, 4, 6, 25])]) [\\"YES\\"] pass","solution":"from collections import Counter import math def is_perfect_square(n): sqrt = int(math.sqrt(n)) return sqrt * sqrt == n def has_subset_with_perfect_square_product(arr): if contains_perfect_square(arr): return True # Find all subsets and check for perfect square products n = len(arr) for i in range(1, 1 << n): subset_product = 1 for j in range(n): if i & (1 << j): subset_product *= arr[j] if is_perfect_square(subset_product): return True return False def contains_perfect_square(arr): for num in arr: if is_perfect_square(num): return True return False def subset_product_perfect_square(T, test_cases): results = [] for i in range(T): N, array = test_cases[i] result = \\"YES\\" if has_subset_with_perfect_square_product(array) else \\"NO\\" results.append(result) return results"},{"question":"import heapq from typing import List, Tuple, Union class BinaryTreeOperations: def __init__(self): self.elements = [] self.element_set = set() def insert(self, x): if x not in self.element_set: heapq.heappush(self.elements, x) self.element_set.add(x) def delete(self, x): if x in self.element_set: self.element_set.remove(x) self.elements.remove(x) heapq.heapify(self.elements) def query(self): return self.elements[0] if self.elements else None def process_operations(operations: List[Tuple[str, Union[str, None]]]) -> List[int]: You are given an empty binary tree with only a root node and a set of operations to perform on the tree. The operations include inserting a node with a specific value, deleting a node with a specific value, and querying the minimum value in the tree. Implement these operations efficiently. >>> operations = [(\\"I\\", \\"10\\"), (\\"I\\", \\"5\\"), (\\"I\\", \\"20\\"), (\\"Q\\",), (\\"D\\", \\"5\\"), (\\"Q\\",), (\\"D\\", \\"10\\")] >>> process_operations(operations) [5, 10] >>> operations = [(\\"I\\", \\"8\\"), (\\"I\\", \\"15\\"), (\\"I\\", \\"3\\"), (\\"Q\\",)] >>> process_operations(operations) [3] >>> operations = [(\\"I\\", \\"8\\"), (\\"I\\", \\"15\\"), (\\"I\\", \\"3\\"), (\\"D\\", \\"3\\"), (\\"Q\\",)] >>> process_operations(operations) [8] >>> operations = [(\\"I\\", \\"1\\"), (\\"I\\", \\"3\\"), (\\"Q\\",), (\\"D\\", \\"1\\"), (\\"D\\", \\"3\\")] >>> process_operations(operations) [1] >>> operations = [(\\"I\\", \\"50\\"), (\\"I\\", \\"20\\"), (\\"I\\", \\"40\\"), (\\"D\\", \\"20\\"), (\\"I\\", \\"30\\"), (\\"Q\\",), (\\"D\\", \\"30\\"), (\\"Q\\",)] >>> process_operations(operations) [30, 40] bto = BinaryTreeOperations() result = [] for operation in operations: if operation[0] == 'I': bto.insert(int(operation[1])) elif operation[0] == 'D': bto.delete(int(operation[1])) elif operation[0] == 'Q': result.append(bto.query()) return result","solution":"import heapq class BinaryTreeOperations: def __init__(self): self.elements = [] self.element_set = set() def insert(self, x): if x not in self.element_set: heapq.heappush(self.elements, x) self.element_set.add(x) def delete(self, x): if x in self.element_set: self.element_set.remove(x) self.elements.remove(x) heapq.heapify(self.elements) def query(self): return self.elements[0] if self.elements else None def process_operations(operations): bto = BinaryTreeOperations() result = [] for operation in operations: if operation[0] == 'I': bto.insert(int(operation[1])) elif operation[0] == 'D': bto.delete(int(operation[1])) elif operation[0] == 'Q': result.append(bto.query()) return result"},{"question":"def longest_increasing_subsequence_length(temperatures): Given a sequence of integer temperatures recorded at one-minute intervals, returns the length of the longest continuously increasing subsequence. >>> longest_increasing_subsequence_length([1, 2, 2, 3, 4, 1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence_length([1, 3, 2, 3, 2, 5, 6, 2, 7]) 3 >>> longest_increasing_subsequence_length([4]) 1 >>> longest_increasing_subsequence_length([]) 0","solution":"def longest_increasing_subsequence_length(temperatures): Given a sequence of integer temperatures recorded at one-minute intervals, returns the length of the longest continuously increasing subsequence. if not temperatures: return 0 max_length = 1 current_length = 1 for i in range(1, len(temperatures)): if temperatures[i] > temperatures[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def count_palindromic_numbers(a: int, b: int) -> int: Returns the count of palindromic numbers in the inclusive range [a, b]. >>> count_palindromic_numbers(1, 10) 9 >>> count_palindromic_numbers(100, 200) 10 >>> count_palindromic_numbers(10, 20) 1 >>> count_palindromic_numbers(0, 10) 10 >>> count_palindromic_numbers(5, 5) 1 >>> count_palindromic_numbers(9, 11) 2 >>> count_palindromic_numbers(12, 14) 0","solution":"def is_palindrome(n): Checks if the given number n is a palindrome. return str(n) == str(n)[::-1] def count_palindromic_numbers(a, b): Returns the count of palindromic numbers in the inclusive range [a, b]. count = 0 for num in range(a, b + 1): if is_palindrome(num): count += 1 return count"},{"question":"def max_chain_train_length(weights: List[int]) -> int: Find the maximum length of the chain train with given car weights such that no two adjacent cars have the same weight. >>> max_chain_train_length([1, 2, 2, 3, 3, 1]) 6 >>> max_chain_train_length([4, 4, 4, 4]) 1","solution":"def max_chain_train_length(weights): # get the frequency of each different weight weight_count = {} for weight in weights: if weight in weight_count: weight_count[weight] += 1 else: weight_count[weight] = 1 # since each different weight can be connected in a chained train form # the maximum length of the chain we can achieve is just the count of total cars # as long as we have at least 2 different weights if len(weight_count) == 1: return 1 else: return len(weights)"},{"question":"def is_balanced(sequence: str) -> str: Determines if a given sequence of parentheses is balanced. >>> is_balanced(\\"()\\") \\"YES\\" >>> is_balanced(\\"[]\\") \\"YES\\" >>> is_balanced(\\"{}\\") \\"YES\\" >>> is_balanced(\\"(]\\") \\"NO\\" >>> is_balanced(\\"{)\\") \\"NO\\" >>> is_balanced(\\"[()]\\") \\"YES\\" >>> is_balanced(\\"{[()]}\\") \\"YES\\" >>> is_balanced(\\"({[]})\\") \\"YES\\" >>> is_balanced(\\"[({)]}\\") \\"NO\\" >>> is_balanced(\\"\\") \\"YES\\" pass def check_sequences(T: int, sequences: List[str]) -> List[str]: For T test cases, determine if each sequence of parentheses is balanced. >>> check_sequences(4, [\\"()\\", \\"[()]\\", \\"{[()]}\\", \\"(]\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> check_sequences(1, [\\"()()()\\"]) [\\"YES\\"] >>> check_sequences(2, [\\"([{}])\\", \\"{[(])}\\"]) [\\"YES\\", \\"NO\\"] >>> check_sequences(3, [\\"\\", \\"{}\\", \\"({[]})\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> check_sequences(2, [\\"(\\", \\"})\\"]) [\\"NO\\", \\"NO\\"] pass","solution":"def is_balanced(sequence): Determines if a given sequence of parentheses is balanced. stack = [] matching_bracket = {')': '(', ']': '[', '}': '{'} for char in sequence: if char in '([{': stack.append(char) elif char in ')]}': if stack and stack[-1] == matching_bracket[char]: stack.pop() else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\" def check_sequences(T, sequences): For T test cases, determine if each sequence of parentheses is balanced. results = [] for seq in sequences: results.append(is_balanced(seq)) return results"},{"question":"def longest_constant_difference_subsequence(T, cases): Given a number of test cases, find the length of the longest subsequence where the difference between consecutive elements is the same. Args: T (int): The number of test cases. cases (list): List of tuples, where each tuple contains an integer N and a list of N integers. Returns: list: A list of integers representing the lengths of the longest subsequences for each test case. Example: >>> T, cases = from_input_string(\\"1n7n1 2 3 4 1 2 3n\\") >>> longest_constant_difference_subsequence(T, cases) [4] # Your code here def from_input_string(input_string: str): Convert the input string to the format required by the function. Args: input_string (str): Multiline string containing the input. Returns: tuple: A tuple containing an integer T and a list of tuples, where each tuple contains an integer N and a list of N integers. Example: >>> from_input_string(\\"1n7n1 2 3 4 1 2 3n\\") (1, [(7, [1, 2, 3, 4, 1, 2, 3])]) # Your code here def to_output_string(output): Convert the function output to the string format for output. Args: output (list): List of integers representing the lengths of the longest subsequences for each test case. Returns: str: Multiline string of the output. Example: >>> to_output_string([4]) \\"4\\" # Your code here import pytest def test_longest_constant_difference_subsequence(): input_str = \\"1n7n1 2 3 4 1 2 3n\\" expected_output = [4] T, cases = from_input_string(input_str) assert longest_constant_difference_subsequence(T, cases) == expected_output input_str = \\"2n1n5n4n1 5 9 10n\\" expected_output = [1, 3] T, cases = from_input_string(input_str) assert longest_constant_difference_subsequence(T, cases) == expected_output input_str = \\"1n5n1 2 1 2 1n\\" expected_output = [2] T, cases = from_input_string(input_str) assert longest_constant_difference_subsequence(T, cases) == expected_output input_str = \\"1n6n1 3 5 7 9 11n\\" expected_output = [6] T, cases = from_input_string(input_str) assert longest_constant_difference_subsequence(T, cases) == expected_output def test_from_input_string(): input_str = \\"1n7n1 2 3 4 1 2 3n\\" expected = (1, [(7, [1, 2, 3, 4, 1, 2, 3])]) assert from_input_string(input_str) == expected def test_to_output_string(): assert to_output_string([4]) == \\"4\\" assert to_output_string([1, 3]) == \\"1n3\\"","solution":"def longest_constant_difference_subsequence(T, cases): results = [] for case in cases: N, sequence = case if N == 1: results.append(1) continue max_len = 1 curr_len = 1 curr_diff = None for i in range(1, N): diff = sequence[i] - sequence[i-1] if diff == curr_diff: curr_len += 1 else: curr_diff = diff curr_len = 2 if curr_len > max_len: max_len = curr_len results.append(max_len) return results # Example input processing function def from_input_string(input_string: str): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) sequence = list(map(int, lines[idx + 1].split())) cases.append((N, sequence)) idx += 2 return T, cases # Example output processing function def to_output_string(output): return \\"n\\".join(map(str, output))"},{"question":"from typing import List def process_instructions(t: int, test_cases: List[List[str]]) -> List[int]: Simulate the execution of given instructions and return the final value of x for each test case. >>> process_instructions(3, [[\\"add 5\\", \\"multiply 2\\", \\"subtract 3\\"], [\\"reset\\", \\"add 10\\", \\"subtract 5\\", \\"multiply 3\\"], [\\"reset\\", \\"subtract 4\\"]]) [7, 15, -4] >>> process_instructions(1, [[\\"reset\\", \\"reset\\", \\"reset\\"]]) [0] >>> process_instructions(1, [[\\"add 10\\", \\"add 20\\", \\"add 5\\"]]) [35] >>> process_instructions(1, [[\\"subtract 10\\", \\"subtract 20\\", \\"subtract 5\\"]]) [-35] >>> process_instructions(1, [[\\"add 1\\", \\"multiply 10\\", \\"multiply 2\\"]]) [20] >>> process_instructions(1, [[\\"add 10\\", \\"multiply 3\\", \\"subtract 5\\", \\"reset\\", \\"add 5\\", \\"multiply 4\\"]]) [20]","solution":"def process_instructions(t, test_cases): results = [] for case in test_cases: x = 0 for instruction in case: parts = instruction.split() command = parts[0] if command == \\"add\\": x += int(parts[1]) elif command == \\"subtract\\": x -= int(parts[1]) elif command == \\"multiply\\": x *= int(parts[1]) elif command == \\"reset\\": x = 0 results.append(x) return results"},{"question":"def can_reach_target(n: int, T: int, points: List[int]) -> str: Determine if it is possible to reach exactly T points by solving any subset of the challenges. Parameters: n (int): Number of challenges. T (int): Target points. points (list[int]): List of points for each challenge. Returns: str: \\"YES\\" if it is possible to reach exactly T points, otherwise \\"NO\\". >>> can_reach_target(4, 10, [2, 3, 7, 8]) \\"YES\\" >>> can_reach_target(3, 5, [2, 4, 6]) \\"NO\\"","solution":"def can_reach_target(n, T, points): Determine if it is possible to reach exactly T points by solving any subset of the challenges. Parameters: n (int): Number of challenges. T (int): Target points. points (list[int]): List of points for each challenge. Returns: str: \\"YES\\" if it is possible to reach exactly T points, otherwise \\"NO\\". dp = [False] * (T + 1) dp[0] = True for point in points: for i in range(T, point - 1, -1): if dp[i - point]: dp[i] = True return \\"YES\\" if dp[T] else \\"NO\\""},{"question":"from typing import List, Tuple def find_highest_consumption_device(test_cases: List[Tuple[Tuple[int, int, int], List[Tuple[str, List[int]]]]]) -> List[str]: Analyze the energy consumption data and find the device that consumed the highest amount of energy in a given time range. >>> find_highest_consumption_device([((2, 0, 3), [(\\"Device1\\", [25, 30, 10, 5]), (\\"Device2\\", [20, 15, 40, 10])]), ((3, 9, 11), [(\\"DeviceA\\", [5, 10, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65]), (\\"DeviceB\\", [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]), (\\"DeviceC\\", [15, 25, 35, 45, 55, 65, 75, 85, 95, 105, 115, 125])])]) [\\"Device2\\", \\"DeviceC\\"] def parse_input(input_data: str) -> List[Tuple[Tuple[int, int, int], List[Tuple[str, List[int]]]]]: Parse the input data to create a list of test cases. # Unit tests def test_example_case(): input_data = 2 0 3 Device1 4 25 30 10 5 Device2 4 20 15 40 10 3 9 11 DeviceA 12 5 10 20 25 30 35 40 45 50 55 60 65 DeviceB 12 10 20 30 40 50 60 70 80 90 100 110 120 DeviceC 12 15 25 35 45 55 65 75 85 95 105 115 125 0 0 0 expected_output = [\\"Device2\\", \\"DeviceC\\"] test_cases = parse_input(input_data) assert find_highest_consumption_device(test_cases) == expected_output def test_single_device(): input_data = 1 1 2 Device1 4 50 60 70 80 0 0 0 expected_output = [\\"Device1\\"] test_cases = parse_input(input_data) assert find_highest_consumption_device(test_cases) == expected_output def test_tied_consumption(): input_data = 2 0 2 Device1 3 20 30 40 Device2 3 20 30 40 0 0 0 expected_output = [\\"Device1\\"] test_cases = parse_input(input_data) assert find_highest_consumption_device(test_cases) == expected_output def test_different_consume_hours(): input_data = 2 0 1 Device1 2 10 20 Device2 3 5 15 25 0 0 0 expected_output = [\\"Device1\\"] test_cases = parse_input(input_data) assert find_highest_consumption_device(test_cases) == expected_output def test_no_consumption(): input_data = 2 0 2 Device1 3 0 0 0 Device2 3 0 0 0 0 0 0 expected_output = [\\"Device1\\"] test_cases = parse_input(input_data) assert find_highest_consumption_device(test_cases) == expected_output","solution":"def find_highest_consumption_device(test_cases): results = [] for test_case in test_cases: n, t1, t2 = test_case[0] devices = test_case[1] max_energy = -1 max_device_id = None for device_id, consumptions in devices: total_energy = sum(consumptions[t1:t2+1]) if total_energy > max_energy: max_energy = total_energy max_device_id = device_id results.append(max_device_id) return results def parse_input(input_data): lines = input_data.split('n') test_cases = [] i = 0 while i < len(lines): line = lines[i].strip() if line == \\"0 0 0\\": break n, t1, t2 = map(int, line.split()) devices = [] for _ in range(n): i += 1 device_line = lines[i].strip().split() device_id = ' '.join(device_line[:-1]) m = int(device_line[-1]) consumptions = [] for _ in range(m): i += 1 consumptions.append(int(lines[i].strip())) devices.append((device_id, consumptions)) test_cases.append(((n, t1, t2), devices)) i += 1 return test_cases"},{"question":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events. Args: events (list of tuples): A list of tuples where each tuple contains two integers representing the start and end time of an event. Returns: int: The maximum number of non-overlapping events that can be attended. Examples: >>> max_non_overlapping_events([(1, 3), (2, 5), (4, 6), (7, 8)]) 3 >>> max_non_overlapping_events([(1, 2), (3, 4), (2, 3)]) 3","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events. Args: events (list of tuples): A list of tuples where each tuple contains two integers representing the start and end time of an event. Returns: int: The maximum number of non-overlapping events that can be attended. if not events: return 0 # Sort the events by their end times events.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for start, end in events: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"from typing import List def find_missing_numbers(arr: List[int]) -> List[int]: Finds all the missing numbers in the array where each element is within the range from 1 to n (length of the array). Args: arr (List[int]): The input array of integers. Returns: List[int]: The list of missing integers in ascending order. >>> find_missing_numbers([4, 3, 2, 7, 8, 2, 3, 1]) [5, 6] >>> find_missing_numbers([1, 1]) [2]","solution":"def find_missing_numbers(arr): Finds all the missing numbers in the array where each element is within the range from 1 to n (length of the array). Args: arr (List[int]): The input array of integers. Returns: List[int]: The list of missing integers in ascending order. n = len(arr) # Use the array itself to mark the presence of elements for num in arr: abs_num = abs(num) if arr[abs_num - 1] > 0: arr[abs_num - 1] = -arr[abs_num - 1] # Collect all the indices which have positive values missing_numbers = [i + 1 for i in range(n) if arr[i] > 0] return missing_numbers"},{"question":"from typing import List, Tuple def query_results(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[str]: Determine if there is at least one integer within the subarray from index x to index y (inclusive) that is divisible by k. Args: n (int): The number of elements in the array. q (int): The number of queries. array (List[int]): The array of n integers. queries (List[Tuple[int, int, int]]): Each query is a tuple of three integers (x, y, k) with (1 <= x <= y <= n) and k is a positive integer. Returns: List[str]: A list with q entries, each being \\"YES\\" or \\"NO\\" depending on the query result. >>> query_results(5, 3, [3, 6, 8, 10, 15], [(1, 3, 2), (2, 5, 5), (1, 5, 7)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> query_results(4, 2, [1, 2, 3, 4], [(1, 4, 5), (2, 4, 6)]) [\\"NO\\", \\"NO\\"] results = [] for x, y, k in queries: found = False for i in range(x - 1, y): if array[i] % k == 0: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results def execute(number_of_elements: int, number_of_queries: int, elements: List[int], queries: List[Tuple[int, int, int]]) -> List[str]: return query_results(number_of_elements, number_of_queries, elements, queries) def test_small_inputs(): assert execute(5, 3, [3, 6, 8, 10, 15], [(1, 3, 2), (2, 5, 5), (1, 5, 7)]) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_no_divisibles(): assert execute(4, 2, [1, 2, 3, 4], [(1, 4, 5), (2, 4, 6)]) == [\\"NO\\", \\"NO\\"] def test_all_divisibles(): assert execute(3, 1, [2, 4, 6], [(1, 3, 2)]) == [\\"YES\\"] def test_edge_elements(): assert execute(5, 2, [10, 15, 20, 25, 30], [(1, 1, 10), (5, 5, 5)]) == [\\"YES\\", \\"YES\\"] def test_multiple_queries(): assert execute(6, 4, [1, 3, 5, 7, 9, 11], [(1, 6, 1), (2, 4, 2), (3, 5, 3), (1, 2, 4)]) == [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"]","solution":"def query_results(n, q, array, queries): results = [] for x, y, k in queries: found = False for i in range(x - 1, y): if array[i] % k == 0: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results def execute(number_of_elements, number_of_queries, elements, queries): return query_results(number_of_elements, number_of_queries, elements, queries)"},{"question":"def max_total_beauty(n: int, beauties: List[int]) -> int: Determines the maximum total beauty of the garden after rearranging the flowers so that no two adjacent flowers have the same beauty value. Parameters: n (int): Number of flowers in the garden. beauties (List[int]): List of beauty values of each flower type. Returns: int: Maximum possible total beauty ensuring no two adjacent flowers have the same beauty value. >>> max_total_beauty(5, [1, 2, 2, 3, 4]) 10 >>> max_total_beauty(3, [-1, -1, -1]) -1 >>> max_total_beauty(1, [5]) 5 >>> max_total_beauty(4, [1, 2, 3, 4]) 10 >>> max_total_beauty(4, [-1, -2, -3, -4]) -10","solution":"from collections import Counter def max_total_beauty(n, beauties): Determines the maximum total beauty of the garden after rearranging the flowers so that no two adjacent flowers have the same beauty value. Parameters: n (int): Number of flowers in the garden. beauties (List[int]): List of beauty values of each flower type. Returns: int: Maximum possible total beauty ensuring no two adjacent flowers have the same beauty value. if n == 1: return beauties[0] beauties.sort(reverse=True) total_beauty = 0 prev_beauty = None for beauty in beauties: if beauty != prev_beauty: total_beauty += beauty prev_beauty = beauty return total_beauty"},{"question":"class InventoryManagement: Implement an inventory management system to add, update, and query item quantities. Methods: - add(code: str, quantity: int) -> None: Add a new item with the given code and quantity. - update(code: str, quantity: int) -> None: Update the quantity of an existing item identified by code. - query(prefix: str) -> int: Query the inventory for the total quantity of items matching the given prefix. >>> inventory = InventoryManagement() >>> inventory.add('apple', 10) >>> inventory.add('banana', 5) >>> inventory.update('apple', 5) >>> inventory.query('ap') 15 >>> inventory.query('ba') 5 import pytest def test_add(): inventory = InventoryManagement() inventory.add('apple', 10) assert inventory.inventory['apple'] == 10 def test_update_positive(): inventory = InventoryManagement() inventory.add('apple', 10) inventory.update('apple', 5) assert inventory.inventory['apple'] == 15 def test_update_negative(): inventory = InventoryManagement() inventory.add('apple', 10) inventory.update('apple', -3) assert inventory.inventory['apple'] == 7 def test_query(): inventory = InventoryManagement() inventory.add('apple', 10) inventory.add('apricot', 15) inventory.add('banana', 20) inventory.add('berry', 25) assert inventory.query('ap') == 25 assert inventory.query('ba') == 20 assert inventory.query('ber') == 25 assert inventory.query('ch') == 0 def test_complex_scenario(): inventory = InventoryManagement() inventory.add('apple', 10) inventory.add('banana', 5) inventory.add('apricot', 7) inventory.update('apple', 3) inventory.update('banana', -2) assert inventory.query('ap') == 20 assert inventory.query('ba') == 3","solution":"class InventoryManagement: def __init__(self): self.inventory = {} def add(self, code, quantity): self.inventory[code] = quantity def update(self, code, quantity): if code in self.inventory: self.inventory[code] += quantity def query(self, prefix): total_quantity = 0 for code in self.inventory: if code.startswith(prefix): total_quantity += self.inventory[code] return total_quantity"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest substring containing equal number of 'a's and 'b's. >>> longest_balanced_substring('abbaba') 6 >>> longest_balanced_substring('aaaa') 0 >>> longest_balanced_substring('ababab') 6 >>> longest_balanced_substring('a') 0 >>> longest_balanced_substring('b') 0 >>> longest_balanced_substring('ab') 2 >>> longest_balanced_substring('ba') 2 >>> longest_balanced_substring('abba') 4 >>> longest_balanced_substring('babbaa') 6 >>> longest_balanced_substring('aabba') 4 >>> longest_balanced_substring('ab' * 100000) 200000 >>> longest_balanced_substring('ab' * 100000 + 'a') 200000 >>> longest_balanced_substring('aaaaaa') 0 >>> longest_balanced_substring('bbbbbb') 0","solution":"def longest_balanced_substring(s): Returns the length of the longest substring containing equal number of 'a's and 'b's. max_len = 0 count_map = {0: -1} # Initialize the map with count 0 at index -1 count = 0 for i, char in enumerate(s): if char == 'a': count += 1 elif char == 'b': count -= 1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len"},{"question":"def calculate_final_balance(transactions: List[str]) -> int: Calculate the final balance after applying all transactions. Args: transactions (List[str]): List of transactions in the form \\"ID TYPE AMOUNT\\". Returns: int: The final account balance. >>> calculate_final_balance([\\"T1 credit 100\\", \\"T2 debit 50\\", \\"T3 credit 150\\"]) 200 >>> calculate_final_balance([\\"T1 debit 200\\", \\"T2 credit 100\\"]) -100 >>> calculate_final_balance([\\"T1 credit 500\\", \\"T2 debit 200\\", \\"T3 debit 300\\"]) 0 pass def process_multiple_test_cases(test_cases: List[List[str]]) -> List[int]: Process multiple test cases to calculate final balances. Args: test_cases (List[List[str]]): List of test cases where each test case is a list of transactions. Returns: List[int]: List of final balances for each test case. >>> process_multiple_test_cases([ ... [\\"T1 credit 100\\", \\"T2 debit 50\\", \\"T3 credit 150\\"], ... [\\"T1 debit 200\\", \\"T2 credit 100\\"] ... ]) [200, -100] pass def parse_input(input_str: str) -> List[List[str]]: Parse the input string to extract test cases. Args: input_str (str): Input string containing multiple test cases. Returns: List[List[str]]: Parsed test cases as lists of transactions. >>> parse_input(\\"2n3nT1 credit 100nT2 debit 50nT3 credit 150n2nT1 debit 200nT2 credit 100\\") [['T1 credit 100', 'T2 debit 50', 'T3 credit 150'], ['T1 debit 200', 'T2 credit 100']] pass def calculate_balances_from_input(input_str: str) -> str: Calculate final balances from input string. Args: input_str (str): Input string containing multiple test cases. Returns: str: Final balances for each test case as a string separated by newlines. >>> calculate_balances_from_input(\\"2n3nT1 credit 100nT2 debit 50nT3 credit 150n2nT1 debit 200nT2 credit 100\\") '200n-100' pass","solution":"def calculate_final_balance(transactions): balance = 0 for transaction in transactions: tid, ttype, amount = transaction.split() amount = int(amount) if ttype == \\"credit\\": balance += amount elif ttype == \\"debit\\": balance -= amount return balance def process_multiple_test_cases(test_cases): results = [] for transactions in test_cases: results.append(calculate_final_balance(transactions)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 transactions = [] for _ in range(N): transactions.append(lines[index]) index += 1 test_cases.append(transactions) return test_cases def calculate_balances_from_input(input_str): test_cases = parse_input(input_str) results = process_multiple_test_cases(test_cases) return 'n'.join(map(str, results))"},{"question":"def maxCrops(n: int, grid: List[List[int]]) -> int: Takes an integer n and a 2D grid and returns the maximum number of crops that can be planted such that no two crops are in the same row or column and no crops are planted on obstacles (cells with 1). Example: >>> maxCrops(4, [ [0, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ]) 4 >>> maxCrops(3, [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) 0 >>> maxCrops(4, [ [1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [1, 1, 1, 1] ]) 1","solution":"def maxCrops(n, grid): Takes an integer n and a 2D grid and returns the maximum number of crops that can be planted such that no two crops are in the same row or column and no crops are planted on obstacles (cells with 1). rows = [False] * n cols = [False] * n def canPlace(row, col): Check if we can place a crop at (row, col) return not rows[row] and not cols[col] and grid[row][col] == 0 crops = 0 for row in range(n): for col in range(n): if canPlace(row, col): rows[row] = True cols[col] = True crops += 1 return crops"},{"question":"from typing import List, Tuple def max_unique_books(records: List[Tuple[int, int]]) -> int: Returns the maximum number of unique books borrowed by any single member. Args: records (list of tuples): Each tuple contains two integers, member_id and book_id indicating a borrowing record. Returns: int: The maximum number of unique books borrowed by any single member. pass def test_example1(): records = [(1, 101), (2, 102), (1, 101), (1, 103), (2, 104), (1, 105), (3, 106)] assert max_unique_books(records) == 3 def test_example2(): records = [(1, 201), (2, 202), (3, 203), (1, 204), (2, 202)] assert max_unique_books(records) == 2 def test_single_member(): records = [(1, 101), (1, 102), (1, 103), (1, 101), (1, 104)] assert max_unique_books(records) == 4 def test_multiple_members_same_books(): records = [(1, 101), (2, 101), (1, 102), (2, 102), (3, 101)] assert max_unique_books(records) == 2 def test_no_records(): records = [] assert max_unique_books(records) == 0 def test_single_record(): records = [(1, 101)] assert max_unique_books(records) == 1 def test_lots_of_records_same_book(): records = [(i % 10, 101) for i in range(100000)] assert max_unique_books(records) == 1","solution":"def max_unique_books(records): Returns the maximum number of unique books borrowed by any single member. Args: records (list of tuples): Each tuple contains two integers, member_id and book_id indicating a borrowing record. Returns: int: The maximum number of unique books borrowed by any single member. member_books = {} for member_id, book_id in records: if member_id not in member_books: member_books[member_id] = set() member_books[member_id].add(book_id) max_unique = 0 for books in member_books.values(): if len(books) > max_unique: max_unique = len(books) return max_unique"},{"question":"def find_first_hit(cannon_height: int, towers: List[int]) -> Union[Tuple[int, int], str]: Finds the index and height of the first tower hit by the cannonball. Parameters: cannon_height (int): Height of the cannonball. towers (list of int): Heights of the towers. Returns: A tuple (index, height) of the first tower hit or a string \\"The cannonball falls in the sea\\". Examples: >>> find_first_hit(7, [6, 3, 9, 5]) (3, 9) >>> find_first_hit(10, [4, 5, 6]) 'The cannonball falls in the sea'","solution":"def find_first_hit(cannon_height, towers): Finds the index and height of the first tower hit by the cannonball. Parameters: cannon_height (int): Height of the cannonball. towers (list of int): Heights of the towers. Returns: A tuple (index, height) of the first tower hit or a string \\"The cannonball falls in the sea\\". for i, height in enumerate(towers): if height >= cannon_height: return i + 1, height return \\"The cannonball falls in the sea\\""},{"question":"import heapq from typing import List def min_delivery_cost(m: int, n: int, grid: List[List[int]]) -> int: Returns the minimum cost required to deliver the package from (0, 0) to (m-1, n-1). Parameters: m (int): number of rows n (int): number of columns grid (List[List[int]]): delivery costs for each cell in the grid Returns: int: minimum delivery cost to reach the bottom-right corner >>> min_delivery_cost(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_delivery_cost(2, 2, [[5, 4], [6, 7]]) 16 def test_min_delivery_cost(): assert min_delivery_cost(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 assert min_delivery_cost(2, 2, [[5, 4], [6, 7]]) == 16 assert min_delivery_cost(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21 assert min_delivery_cost(2, 2, [[0, 1], [1, 0]]) == 1 assert min_delivery_cost(1, 1, [[1]]) == 1 assert min_delivery_cost(1, 4, [[1, 2, 3, 4]]) == 10 assert min_delivery_cost(4, 1, [[1], [2], [3], [4]]) == 10","solution":"import heapq def min_delivery_cost(m, n, grid): Returns the minimum cost required to deliver the package from (0, 0) to (m-1, n-1). directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] min_heap = [(grid[0][0], 0, 0)] min_cost = [[float('inf')] * n for _ in range(m)] min_cost[0][0] = grid[0][0] while min_heap: current_cost, r, c = heapq.heappop(min_heap) if (r, c) == (m - 1, n - 1): return current_cost for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n: cost = current_cost + grid[nr][nc] if cost < min_cost[nr][nc]: min_cost[nr][nc] = cost heapq.heappush(min_heap, (cost, nr, nc)) return min_cost[m - 1][n - 1]"},{"question":"def findKthPositive(arr, k): Returns the k-th positive integer that is missing from the array. Input: - arr: List[int] : Distinct integers sorted in increasing order - k: int : The k-th missing positive integer to find Output: - int : The k-th missing positive integer Examples: >>> findKthPositive([2, 3, 4, 7, 11], 5) 9 >>> findKthPositive([1, 2, 3, 4], 1) 5 >>> findKthPositive([2, 3, 5], 3) 6 >>> findKthPositive([1, 2, 3, 4], 100) 104 >>> findKthPositive([3, 4, 7], 1) 1 >>> findKthPositive([1, 2, 3], 5) 8","solution":"def findKthPositive(arr, k): Returns the k-th positive integer that is missing from the array. current = 1 missing_count = 0 for num in arr: while current < num: missing_count += 1 if missing_count == k: return current current += 1 current = num + 1 # If the loop ends and k-th missing number is not yet found while missing_count < k: missing_count += 1 current += 1 return current - 1"},{"question":"def can_transform(t: int, test_cases: List[Tuple[str, str]]) -> List[str]: Determine if it is possible to transform one string into another using a sequence of delete or swap operations. >>> can_transform(3, [('abc', 'bca'), ('ab', 'ba'), ('abc', 'abcd')]) ['YES', 'YES', 'NO'] >>> can_transform(2, [('a', 'a'), ('abcdef', 'fedcba')]) ['YES', 'YES'] >>> can_transform(1, [('hello', 'olleh')]) ['YES'] >>> can_transform(1, [('hello', 'helloo')]) ['NO'] >>> can_transform(2, [('ok', 'ko'), ('ok', 'kk')]) ['YES', 'NO']","solution":"def can_transform(t, test_cases): results = [] for s1, s2 in test_cases: if sorted(s1) == sorted(s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: # t = 3 # test_cases = [('abc', 'bca'), ('ab', 'ba'), ('abc', 'abcd')] # print(can_transform(t, test_cases)) # Output: ['YES', 'YES', 'NO']"},{"question":"from typing import List, Tuple def max_customers_served(N: int, customers: List[Tuple[int, int]]) -> int: Find the maximum number of customers that can be served optimally. Args: N (int): The number of customers. customers (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, arrival time and service duration of a customer. Returns: int: The maximum number of customers that can be served. Example: >>> max_customers_served(5, [(1, 3), (2, 5), (10, 2), (5, 3), (6, 4)]) == 3 >>> max_customers_served(3, [(1, 2), (3, 2), (5, 2)]) == 3","solution":"def max_customers_served(N, customers): # Sort customers based on their arrival times customers.sort(key=lambda x: x[0]) # Initialize the variables end_time = 0 served_count = 0 for arrival, duration in customers: # Serve the customer if the server is free at their arrival time if arrival >= end_time: served_count += 1 end_time = arrival + duration return served_count"},{"question":"from typing import List def find_subset(nums: List[int], S: int) -> List[int]: Finds any subset of nums that sums up to S. Returns the subset or an empty list if no such subset exists. >>> find_subset([3, 34, 4, 12, 5], 9) [4, 5] >>> find_subset([1, 2, 3, 4], 11) [] >>> find_subset([6], 6) [6] >>> find_subset([10, 20, 30], 5) [] >>> find_subset([3, -2, 7, 1], 5) [3, 1, 1] >>> find_subset([-100000, 50000, 100000, 25000], 75000) [50000, 25000] >>> find_subset([1, 2, 2, 3], 4) [1, 3]","solution":"from itertools import combinations def find_subset(nums, S): Finds any subset of nums that sums up to S. Returns the subset or an empty list if no such subset exists. n = len(nums) for r in range(1, n + 1): for subset in combinations(nums, r): if sum(subset) == S: return list(subset) return [] # Example Usage # nums = [3, 34, 4, 12, 5] # S = 9 # result = find_subset(nums, S) # Output will be [4, 5] # print(result)"},{"question":"import collections from typing import List def find_shortest_path(n: int, m: int, grid: List[str]) -> int: Find the shortest path through a maze to reach a treasure. The maze is represented as a grid of cells with the following symbols: - 'S' represents John's starting position. - 'T' represents the cell containing the treasure. - '.' represents an empty cell that John can walk through. - '#' represents a wall that John cannot pass through. John can move horizontally and vertically. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): List of strings representing the grid. Returns: int: Minimum number of steps required to reach the treasure, or -1 if it is impossible. Examples: >>> find_shortest_path(5, 5, [\\"S....\\", \\"#.#.#\\", \\"....#\\", \\"#.#\\", \\"..T..\\"]) 6 >>> find_shortest_path(3, 3, [\\"S.#\\", \\"#\\", \\"#.T\\"]) -1 >>> find_shortest_path(2, 2, [\\"ST\\", \\"\\"] 1","solution":"from collections import deque def find_shortest_path(n, m, grid): def get_neighbors(r, c): for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_r, new_c = r + dr, c + dc if 0 <= new_r < n and 0 <= new_c < m and grid[new_r][new_c] != '#': yield new_r, new_c # Find the start and target positions start = None target = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'T': target = (i, j) if not start or not target: return -1 queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add(start) while queue: r, c, dist = queue.popleft() if (r, c) == target: return dist for nr, nc in get_neighbors(r, c): if (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"from collections import Counter def can_transform(S: str, T: str) -> str: Determines if it's possible to transform string S into string T by performing any number of substring reversals. :param S: The original string :param T: The target string :return: \\"YES\\" if the transformation is possible, \\"NO\\" otherwise >>> can_transform(\\"abcd\\", \\"dcba\\") == \\"YES\\" >>> can_transform(\\"abc\\", \\"bca\\") == \\"NO\\" >>> can_transform(\\"aabbcc\\", \\"ccbbba\\") == \\"NO\\" >>> can_transform(\\"aaaa\\", \\"aaaa\\") == \\"YES\\" >>> can_transform(\\"abcabc\\", \\"cbacba\\") == \\"YES\\"","solution":"from collections import Counter def can_transform(S, T): Determines if it's possible to transform string S into string T by performing any number of substring reversals. :param S: The original string :param T: The target string :return: \\"YES\\" if the transformation is possible, \\"NO\\" otherwise if Counter(S) == Counter(T): return \\"YES\\" return \\"NO\\""},{"question":"def max_peaks_zoe_can_visit(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum number of peaks Zoe can visit starting from any initial peak under the given altitude change restriction. Args: t (int): the number of test cases. test_cases (List[Tuple[int, int, List[int]]]): a list containing tuples with the number of peaks, the maximum allowed altitude difference, and a list of peak heights. Returns: List[int]: a list of integers representing the maximum number of peaks Zoe can visit for each test case. Examples: >>> max_peaks_zoe_can_visit(2, [(5, 2, [1, 3, 1, 2, 5]), (4, 1, [1, 2, 4, 3])]) [4, 2] >>> max_peaks_zoe_can_visit(1, [(1, 5, [10])]) [1]","solution":"def max_peaks_zoe_can_visit(t, test_cases): results = [] for i in range(t): n, k, heights = test_cases[i] max_count = 0 for start in range(n): count = 1 for j in range(start, n - 1): if abs(heights[j + 1] - heights[j]) <= k: count += 1 else: break max_count = max(max_count, count) results.append(max_count) return results"},{"question":"from typing import List def find_shortest_path(m: int, n: int, grid_input: str) -> int: Determine the length of the shortest path in a grid from the top-left corner to the bottom-right corner. >>> find_shortest_path(3, 3, '...n.#.n...') == 4 >>> find_shortest_path(3, 3, '.#.n.n...') == -1 >>> find_shortest_path(4, 4, '....n#...n..#.n....') == 6 >>> find_shortest_path(1, 1, '.') == 0 >>> find_shortest_path(3, 3, '#n#.#n#') == -1 >>> find_shortest_path(5, 5, '.....n.....n..#n.....n.....') == 8","solution":"from collections import deque def shortest_path(grid): m, n = len(grid), len(grid[0]) if grid[0][0] == '#' or grid[m-1][n-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # Function to convert input in required format def find_shortest_path(m, n, grid_input): grid = grid_input.split() return shortest_path(grid)"},{"question":"def max_coins(N: int, K: int, C: List[int]) -> int: Determines the maximum number of coins the guard can collect before surpassing his capacity. Args: N : int : number of safes K : int : maximum capacity of coins C : list : list of integers representing the number of coins in each safe Returns: int : the maximum number of coins the guard can collect >>> max_coins(5, 7, [1, 2, 3, 4, 5]) 6 >>> max_coins(4, 10, [3, 3, 3, 3]) 9","solution":"def max_coins(N, K, C): Determines the maximum number of coins the guard can collect before surpassing his capacity. Args: N : int : number of safes K : int : maximum capacity of coins C : list : list of integers representing the number of coins in each safe Returns: int : the maximum number of coins the guard can collect collected_coins = 0 for i in range(N): if collected_coins + C[i] > K: break collected_coins += C[i] return collected_coins"},{"question":"def maximal_rectangle(matrix): Given an m by n binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area. >>> maximal_rectangle([ ... [1, 0, 1, 0], ... [1, 0, 1, 1], ... [1, 0, 1, 1], ... [1, 1, 1, 1] ]) 6 >>> maximal_rectangle([[1, 1, 1, 1]]) 4 >>> maximal_rectangle([[1], [1], [1], [1]]) 4 >>> maximal_rectangle([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) 0 >>> maximal_rectangle([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) 16 >>> maximal_rectangle([ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 1], ... [0, 1, 1, 1] ... ]) 6","solution":"def maximal_rectangle(matrix): if not matrix or not matrix[0]: return 0 m = len(matrix) n = len(matrix[0]) max_area = 0 dp = [0] * n for i in range(m): for j in range(n): # Update dp to record the height of 1's in column j up to row i dp[j] = dp[j] + 1 if matrix[i][j] == 1 else 0 max_area = max(max_area, largest_rectangle_area(dp)) return max_area def largest_rectangle_area(heights): stack = [-1] max_area = 0 for i in range(len(heights)): while stack[-1] != -1 and heights[stack[-1]] >= heights[i]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack[-1] != -1: h = heights[stack.pop()] w = len(heights) - stack[-1] - 1 max_area = max(max_area, h * w) return max_area"},{"question":"def event_query(n, q, events, queries): Handles the given events and queries, returning the results for each query. :param n: Number of events :param q: Number of queries :param events: List of tuples (timestamp, sensor, event_type) :param queries: List of tuples (start_time, end_time, event_type) :return: List of integers representing the count of events for each query >>> n = 5 >>> q = 3 >>> events = [(5, \\"sensor1\\", \\"eventA\\"), (10, \\"sensor2\\", \\"eventB\\"), (15, \\"sensor1\\", \\"eventA\\"), (20, \\"sensor3\\", \\"eventC\\"), (25, \\"sensor2\\", \\"eventA\\")] >>> queries = [(10, 20, \\"eventA\\"), (5, 25, \\"eventB\\"), (1, 30, \\"eventA\\")] >>> event_query(n, q, events, queries) [1, 1, 3] >>> n = 5 >>> q = 2 >>> events = [(5, \\"sensor1\\", \\"eventA\\"), (10, \\"sensor2\\", \\"eventB\\"), (15, \\"sensor1\\", \\"eventA\\"), (20, \\"sensor3\\", \\"eventC\\"), (25, \\"sensor2\\", \\"eventA\\")] >>> queries = [(30, 40, \\"eventA\\"), (1, 4, \\"eventB\\")] >>> event_query(n, q, events, queries) [0, 0] >>> n = 5 >>> q = 1 >>> events = [(10, \\"sensor1\\", \\"eventA\\"), (10, \\"sensor2\\", \\"eventB\\"), (10, \\"sensor1\\", \\"eventA\\"), (10, \\"sensor3\\", \\"eventC\\"), (10, \\"sensor2\\", \\"eventA\\")] >>> queries = [(10, 10, \\"eventA\\")] >>> event_query(n, q, events, queries) [3] >>> n = 6 >>> q = 2 >>> events = [(5, \\"sensor1\\", \\"eventA\\"), (10, \\"sensor1\\", \\"eventB\\"), (15, \\"sensor2\\", \\"eventA\\"), (20, \\"sensor2\\", \\"eventB\\"), (25, \\"sensor3\\", \\"eventA\\"), (30, \\"sensor3\\", \\"eventB\\")] >>> queries = [(1, 15, \\"eventA\\"), (10, 30, \\"eventB\\")] >>> event_query(n, q, events, queries) [2, 3] >>> n = 5 >>> q = 2 >>> events = [(5, \\"sensor1\\", \\"eventA\\"), (10, \\"sensor2\\", \\"eventB\\"), (15, \\"sensor1\\", \\"eventA\\"), (20, \\"sensor3\\", \\"eventC\\"), (25, \\"sensor2\\", \\"eventA\\")] >>> queries = [(10, 20, \\"eventD\\"), (15, 25, \\"eventC\\")] >>> event_query(n, q, events, queries) [0, 1]","solution":"def event_query(n, q, events, queries): Handles the given events and queries, returning the results for each query. :param n: Number of events :param q: Number of queries :param events: List of tuples (timestamp, sensor, event_type) :param queries: List of tuples (start_time, end_time, event_type) :return: List of integers representing the count of events for each query from collections import defaultdict event_dict = defaultdict(list) # Collect events of each type in a sorted list. for t, s, e in events: event_dict[e].append(t) # Sort timestamps for each event type for e in event_dict: event_dict[e].sort() results = [] for t1, t2, e_query in queries: if e_query in event_dict: timestamps = event_dict[e_query] # Find the count of timestamps in the range [t1, t2] count = sum(t1 <= t <= t2 for t in timestamps) results.append(count) else: results.append(0) return results"},{"question":"def min_additional_connections(n, m, connections): Determine the minimum number of additional direct connections necessary to make the network fully connected. Args: n : int : number of computers m : int : number of direct connections connections : list of tuple : list of tuples where each tuple contains two integers ai and bi indicating a direct connection between computer ai and computer bi. Returns: int : the minimum number of additional direct connections required to make the network fully connected. Examples: >>> min_additional_connections(4, 2, [(1, 2), (3, 4)]) 1 >>> min_additional_connections(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> min_additional_connections(6, 1, [(1, 2)]) 4","solution":"def find(parents, x): if parents[x] == x: return x parents[x] = find(parents, parents[x]) return parents[x] def union(parents, x, y): rootX = find(parents, x) rootY = find(parents, y) if rootX != rootY: parents[rootY] = rootX def min_additional_connections(n, m, connections): Determine the minimum number of additional direct connections necessary to make the network fully connected. parents = list(range(n + 1)) for a, b in connections: union(parents, a, b) unique_parents = len(set(find(parents, i) for i in range(1, n + 1))) return unique_parents - 1"},{"question":"def max_non_overlapping_events(events: List[Tuple[int, int]]) -> int: Finds the maximum number of non-overlapping events that can be attended. Parameters: events (list): A list of tuples where each tuple consists of two integers (start, end) Returns: int: The maximum number of non-overlapping events that can be attended >>> max_non_overlapping_events([(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_events([(1, 2), (3, 4), (0, 6), (5, 7)]) 3 pass","solution":"def max_non_overlapping_events(events): Finds the maximum number of non-overlapping events that can be attended. Parameters: events (list): A list of tuples where each tuple consists of two integers (start, end) Returns: int: The maximum number of non-overlapping events that can be attended events.sort(key=lambda x: x[1]) # Sort events by their end time count = 0 last_end_time = -1 for start, end in events: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def kthSmallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array arr. >>> kthSmallest([3, 1, 5, 2, 4], 3) 3 >>> kthSmallest([7, 10, 4, 3, 20, 15], 4) 10 >>> kthSmallest([12, 3, 5, 7, 19, 20, 1], 2) 3","solution":"from typing import List def kthSmallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array arr. arr.sort() return arr[k-1]"},{"question":"def capitalize_sentences(text: str) -> str: Capitalizes the first letter of each sentence in the given text block. Sentences are considered to end with a period (.), exclamation mark (!), or question mark (?). Args: text (str): the text block containing multiple sentences. Returns: str: the text block with each sentence starting with a capital letter. Examples: >>> capitalize_sentences(\\"hello world. how are you? i am fine! thanks for asking.\\") \\"Hello world. How are you? I am fine! Thanks for asking.\\" >>> capitalize_sentences(\\"it's a beautiful day. let's make the most of it.\\") \\"It's a beautiful day. Let's make the most of it.\\"","solution":"def capitalize_sentences(text): Capitalizes the first letter of each sentence in the given text block. Sentences are considered to end with a period (.), exclamation mark (!), or question mark (?). Args: text (str): the text block containing multiple sentences. Returns: str: the text block with each sentence starting with a capital letter. if not text: return text # Return empty text as is sentences = text.split() for i, word in enumerate(sentences): if i == 0 or sentences[i-1][-1] in \\".!?\\": sentences[i] = word.capitalize() return \\" \\".join(sentences)"},{"question":"def check_operational_hours(D: int, hours: List[int]) -> str: Returns 'Yes' if any operational hours were logged three days in a row, otherwise returns 'No'. >>> check_operational_hours(6, [8, 8, 8, 5, 6, 7]) 'Yes' >>> check_operational_hours(5, [9, 7, 7, 7, 8]) 'Yes' >>> check_operational_hours(4, [2, 4, 6, 8]) 'No'","solution":"def check_operational_hours(D, hours): Returns 'Yes' if any operational hours were logged three days in a row, otherwise returns 'No'. for i in range(D - 2): if hours[i] == hours[i + 1] == hours[i + 2]: return \\"Yes\\" return \\"No\\""},{"question":"def process_commands(test_cases): Processes a series of commands and returns results for query commands. Parameters: test_cases (list of lists): Each sublist contains strings of commands for a single test case. Returns: list of int: The results for all query commands in the order they appear. # Unit tests to validate the solution def test_process_commands_single_case(): test_cases = [ [ \\"+ 100\\", \\"+ 200\\", \\"+ 150\\", \\"? 1\\", \\"? 2\\", \\"+ 50\\", \\"? 3\\" ] ] result = process_commands(test_cases) assert result == [100, 300, 450] def test_process_commands_multiple_cases(): test_cases = [ [ \\"+ 100\\", \\"+ 200\\", \\"+ 150\\", \\"? 1\\", \\"? 2\\", \\"+ 50\\", \\"? 3\\" ], [ \\"+ 30\\", \\"+ 70\\", \\"+ 90\\", \\"? 2\\", \\"? 3\\" ] ] result = process_commands(test_cases) assert result == [100, 300, 450, 100, 190] def test_zero_input(): test_cases = [] result = process_commands(test_cases) assert result == [] def test_add_and_query_only(): test_cases = [ [ \\"+ 100\\", \\"+ 150\\", \\"? 1\\", \\"? 2\\" ] ] result = process_commands(test_cases) assert result == [100, 250]","solution":"def process_commands(test_cases): Processes a series of commands and returns results for query commands. Parameters: test_cases (list of lists): Each sublist contains strings of commands for a single test case. Returns: list of int: The results for all query commands in the order they appear. cumulative_pages = [] results = [] for case in test_cases: pages = [] for command in case: if command.startswith('+'): _, p = command.split() p = int(p) if pages: pages.append(pages[-1] + p) else: pages.append(p) elif command.startswith('?'): _, t = command.split() t = int(t) results.append(pages[t - 1]) return results"},{"question":"def maximum_ring_power(n, power_levels): Determine the maximum power level that can be achieved by combining rings. Args: n (int): The number of rings. power_levels (List[int]): A list of integers representing the power levels of the rings. Returns: int: The maximum power level achievable by combining the rings. Example: >>> maximum_ring_power(4, [3, 5, 7, 9]) 945 >>> maximum_ring_power(3, [2, 2, 2]) 8 >>> maximum_ring_power(3, [100, 10, 10]) 10000 >>> maximum_ring_power(2, [1, 1]) 1 >>> maximum_ring_power(3, [1, 3, 5]) 15 >>> maximum_ring_power(4, [9, 3, 5, 7]) 945","solution":"def maximum_ring_power(n, power_levels): power_levels.sort(reverse=True) max_power = 1 for power in power_levels: max_power *= power return max_power # Example usage: n = 4 power_levels = [3, 5, 7, 9] print(maximum_ring_power(n, power_levels)) # Output: 945"},{"question":"def count_unique_substrings(n: int, gene_sequence: str, k: int) -> int: Returns the number of unique substrings of length k in the gene sequence. Parameters: n (int): Length of the gene sequence. gene_sequence (str): The gene sequence consisting of characters 'A', 'T', 'G', and 'C'. k (int): Length of the substrings to consider. Returns: int: Number of unique substrings of length k. >>> count_unique_substrings(10, 'ATGCGATGCA', 3) 6 >>> count_unique_substrings(4, 'ATCG', 1) 4 >>> count_unique_substrings(4, 'AAGC', 4) 1 >>> count_unique_substrings(5, 'AAAAA', 2) 1 >>> count_unique_substrings(4, 'ATGC', 5) 0 >>> count_unique_substrings(4, 'ATGC', 4) 1 >>> count_unique_substrings(1, 'A', 1) 1","solution":"def count_unique_substrings(n, gene_sequence, k): Returns the number of unique substrings of length k in the gene sequence. Parameters: n (int): Length of the gene sequence. gene_sequence (str): The gene sequence consisting of characters 'A', 'T', 'G', and 'C'. k (int): Length of the substrings to consider. Returns: int: Number of unique substrings of length k. unique_substrings = set() # Loop through the sequence to collect all substrings of length k for i in range(n - k + 1): substring = gene_sequence[i:i + k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"def generalized_fibonacci_sequence(m, n, initial_elements): Generates the first n elements of a generalized Fibonacci sequence where each element is the sum of the previous m elements. Parameters: m (int): The number of initial elements to sum for generating next elements. n (int): The total number of elements in the sequence to generate. initial_elements (list): The first m elements of the sequence. Returns: list: The first n elements of the sequence. pass # Example print(generalized_fibonacci_sequence(3, 7, [1, 1, 1])) # [1, 1, 1, 3, 5, 9, 17] print(generalized_fibonacci_sequence(4, 10, [0, 0, 0, 1])) # [0, 0, 0, 1, 1, 2, 4, 8, 15, 29] from solution import generalized_fibonacci_sequence def test_generalized_fibonacci_sequence(): # Test case 1 result = generalized_fibonacci_sequence(3, 7, [1, 1, 1]) expected = [1, 1, 1, 3, 5, 9, 17] assert result == expected, f\\"Expected {expected}, but got {result}\\" # Test case 2 result = generalized_fibonacci_sequence(4, 10, [0, 0, 0, 1]) expected = [0, 0, 0, 1, 1, 2, 4, 8, 15, 29] assert result == expected, f\\"Expected {expected}, but got {result}\\" # Test case 3: when m = 1 result = generalized_fibonacci_sequence(1, 5, [2]) expected = [2, 2, 2, 2, 2] assert result == expected, f\\"Expected {expected}, but got {result}\\" # Test case 4: when m = n result = generalized_fibonacci_sequence(4, 4, [3, 3, 3, 3]) expected = [3, 3, 3, 3] assert result == expected, f\\"Expected {expected}, but got {result}\\" # Test case 5: mixed positive and negative initial elements result = generalized_fibonacci_sequence(3, 6, [1, -1, 1]) expected = [1, -1, 1, 1, 1, 3] assert result == expected, f\\"Expected {expected}, but got {result}\\"","solution":"def generalized_fibonacci_sequence(m, n, initial_elements): Generates the first n elements of a generalized Fibonacci sequence where each element is the sum of the previous m elements. Parameters: m (int): The number of initial elements to sum for generating next elements. n (int): The total number of elements in the sequence to generate. initial_elements (list): The first m elements of the sequence. Returns: list: The first n elements of the sequence. if len(initial_elements) != m: raise ValueError(\\"The number of initial elements should be equal to m\\") sequence = initial_elements[:] for i in range(m, n): next_element = sum(sequence[i-m:i]) sequence.append(next_element) return sequence # Example print(generalized_fibonacci_sequence(3, 7, [1, 1, 1])) # [1, 1, 1, 3, 5, 9, 17] print(generalized_fibonacci_sequence(4, 10, [0, 0, 0, 1])) # [0, 0, 0, 1, 1, 2, 4, 8, 15, 29]"},{"question":"def min_operations_to_equal_sequences(n: int, a: List[int], b: List[int]) -> int: Returns the minimum number of operations required to transform sequence a into sequence b. Parameters: n(int): The length of the sequences a and b. a(List of int): The initial sequence. b(List of int): The target sequence. Returns: int: The minimum number of operations. pass # Unit tests def test_example1(): assert min_operations_to_equal_sequences(3, [1, 2, 3], [2, 3, 4]) == 3 def test_example2(): assert min_operations_to_equal_sequences(5, [1, 1, 1, 1, 1], [5, 5, 5, 5, 5]) == 20 def test_already_equal(): assert min_operations_to_equal_sequences(4, [1, 2, 3, 4], [1, 2, 3, 4]) == 0 def test_single_element(): assert min_operations_to_equal_sequences(1, [0], [10]) == 10 def test_negative_elements(): assert min_operations_to_equal_sequences(3, [-1, -2, -3], [-4, -5, -6]) == 9 def test_mixed_signs(): assert min_operations_to_equal_sequences(2, [-1, 1], [1, -1]) == 4","solution":"def min_operations_to_equal_sequences(n, a, b): Returns the minimum number of operations required to transform sequence a into sequence b. Parameters: n(int): The length of the sequences a and b. a(list of int): The initial sequence. b(list of int): The target sequence. Returns: int: The minimum number of operations. operations = sum(abs(a[i] - b[i]) for i in range(n)) return operations"},{"question":"def total_bus_utilization(trips: List[Tuple[int, int]]) -> int: Calculate the total number of seconds during which any bus was utilized within the city. :param trips: List of tuples where each tuple contains start and end times of a trip. :return: Total number of seconds any bus was utilized without overlap. >>> total_bus_utilization([(3600, 7200)]) 3600 >>> total_bus_utilization([]) 0 >>> total_bus_utilization([(3600, 7200), (10800, 14400)]) 7200 >>> total_bus_utilization([(3600, 7200), (5400, 8400), (8100, 12600)]) 9000 >>> total_bus_utilization([(3600, 5400), (5400, 7200), (7200, 9000)]) 5400 >>> total_bus_utilization([(3600, 12600), (5400, 7200)]) 9000","solution":"def total_bus_utilization(trips): Calculate the total number of seconds during which any bus was utilized within the city. :param trips: List of tuples where each tuple contains start and end times of a trip. :return: Total number of seconds any bus was utilized without overlap. if not trips: return 0 # Sort trips by their start time trips.sort() total_utilization = 0 current_start, current_end = trips[0] for start, end in trips[1:]: if start <= current_end: # Overlapping interval current_end = max(current_end, end) else: # Non-overlapping interval total_utilization += current_end - current_start current_start, current_end = start, end # Add the last interval total_utilization += current_end - current_start return total_utilization # Example usage: n = 3 trips = [(3600, 7200), (5400, 8400), (8100, 12600)] print(total_bus_utilization(trips)) # Output: 9000"},{"question":"def max_full_flower_beds(n: int, m: int, compat_values: List[int]) -> int: This function calculates the maximum number of flower beds that can be fully occupied with flowers given the compatibility values of the soils. n: int - number of different types of flowers m: int - number of flower beds compat_values: list of int - compatibility values of the soils return: int - maximum number of fully occupied flower beds >>> max_full_flower_beds(3, 3, [2, 1, 0]) 3 >>> max_full_flower_beds(4, 2, [2, 2, 1, 0]) 2 >>> max_full_flower_beds(3, 3, [0, 0, 0]) 0 from solution import max_full_flower_beds def test_max_full_flower_beds_example1(): assert max_full_flower_beds(3, 3, [2, 1, 0]) == 3 def test_max_full_flower_beds_example2(): assert max_full_flower_beds(4, 2, [2, 2, 1, 0]) == 2 def test_max_full_flower_beds_all_compatible(): assert max_full_flower_beds(5, 5, [1, 1, 1, 1, 1]) == 5 def test_max_full_flower_beds_more_compatible_than_beds(): assert max_full_flower_beds(4, 2, [3, 3, 3, 3]) == 2 def test_max_full_flower_beds_no_compatibility(): assert max_full_flower_beds(3, 3, [0, 0, 0]) == 0 def test_max_full_flower_beds_single_fully_compatible(): assert max_full_flower_beds(1, 10, [10]) == 10 def test_max_full_flower_beds_single_none_compatible(): assert max_full_flower_beds(1, 10, [0]) == 0 def test_max_full_flower_beds_large_compatibility(): assert max_full_flower_beds(3, 2, [100, 100, 100]) == 2 def test_max_full_flower_beds_large_number_of_beds(): assert max_full_flower_beds(3, 100, [2, 2, 2]) == 6 def test_max_full_flower_beds_partial_compatibility(): assert max_full_flower_beds(7, 10, [1, 3, 0, 2, 1, 2, 1]) == 10","solution":"def max_full_flower_beds(n, m, compat_values): This function calculates the maximum number of flower beds that can be fully occupied with flowers given the compatibility values of the soils. n: int - number of different types of flowers m: int - number of flower beds compat_values: list of int - compatibility values of the soils return: int - maximum number of fully occupied flower beds # Sum of all compatibilities gives us the total possible flower beds that can be fully occupied total_possible_beds = sum(compat_values) # The result cannot be more than m, nor can it be more than the total possible return min(total_possible_beds, m)"},{"question":"from typing import List, Tuple def find_reachable_cities(N: int, M: int, flights: List[Tuple[str, str]], starting_city: str) -> List[str]: Given a list of flights where each flight is represented as (source_city, destination_city) and a starting city, find all the cities that are reachable from the starting city using any number of flights. >>> find_reachable_cities(5, 6, [(\\"A\\", \\"B\\"), (\\"A\\", \\"C\\"), (\\"B\\", \\"D\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\"), (\\"F\\", \\"G\\")], \\"A\\") ['B', 'C', 'D', 'E'] >>> find_reachable_cities(1, 0, [], \\"A\\") [] >>> find_reachable_cities(5, 3, [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"E\\")], \\"A\\") ['B', 'C']","solution":"def find_reachable_cities(N, M, flights, starting_city): from collections import defaultdict, deque # Create an adjacency list for the graph graph = defaultdict(list) for src, dest in flights: graph[src].append(dest) # Perform BFS to find all reachable cities reachable_cities = set() queue = deque([starting_city]) while queue: city = queue.popleft() for neighbor in graph[city]: if neighbor not in reachable_cities: reachable_cities.add(neighbor) queue.append(neighbor) return sorted(reachable_cities)"},{"question":"def max_capacity_accommodation(hotels: List[List[int]]) -> int: Returns the maximum number of people that can be accommodated by booking one hotel. :param hotels: List of lists where each inner list represents the capacities of the rooms in a hotel. :type hotels: List[List[int]] :return: The maximum number of people that can be accommodated if booking one hotel. :rtype: int Examples: >>> max_capacity_accommodation([[3, 2, 3, 4], [2, 5, 6], [4, 1, 2, 3, 4]]) 11 >>> max_capacity_accommodation([[3, 4, 4, 4], [5, 1, 2, 1, 2, 1]]) 12","solution":"def max_capacity_accommodation(hotels): Returns the maximum number of people that can be accommodated by booking one hotel. :param hotels: List of lists where each inner list represents the capacities of the rooms in a hotel. :type hotels: List[List[int]] :return: The maximum number of people that can be accommodated if booking one hotel. :rtype: int max_capacity = 0 for hotel in hotels: current_capacity = sum(hotel[1:]) if current_capacity > max_capacity: max_capacity = current_capacity return max_capacity"},{"question":"def insertion_sort(B): Perform insertion sort on the list B and return the sorted list and the number of shifts made during the sorting process. n = len(B) shifts = 0 for i in range(1, n): key = B[i] j = i - 1 while j >= 0 and B[j] > key: B[j + 1] = B[j] j -= 1 shifts += 1 B[j + 1] = key return B, shifts def process_input_output(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) B = list(map(int, data[1:1+N])) sorted_B, shifts = insertion_sort(B) print(' '.join(map(str, sorted_B))) print(shifts) >>> insertion_sort([4, 3, 2, 10, 12]): ([2, 3, 4, 10, 12], 3) >>> insertion_sort([12, 11, 13, 5, 6]): ([5, 6, 11, 12, 13], 7)","solution":"def insertion_sort(B): Perform insertion sort on the list B and return the sorted list and the number of shifts made during the sorting process. n = len(B) shifts = 0 for i in range(1, n): key = B[i] j = i - 1 while j >= 0 and B[j] > key: B[j + 1] = B[j] j -= 1 shifts += 1 B[j + 1] = key return B, shifts # Function to handle input and output def process_input_output(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) B = list(map(int, data[1:1+N])) sorted_B, shifts = insertion_sort(B) print(' '.join(map(str, sorted_B))) print(shifts)"},{"question":"def secret_santa(N): Returns a valid secret Santa assignment if possible, otherwise returns \\"Not possible\\". :param N: an integer representing the number of participants :return: a list of integers representing the assignment or a string \\"Not possible\\" if assignment is not possible >>> secret_santa(1) \\"Not possible\\" >>> secret_santa(2) [2, 1] >>> secret_santa(5) [2, 3, 4, 5, 1]","solution":"def secret_santa(N): Returns a valid secret Santa assignment if possible, otherwise returns \\"Not possible\\". :param N: an integer representing the number of participants :return: a list of integers representing the assignment or a string \\"Not possible\\" if assignment is not possible if N == 1: return \\"Not possible\\" assignment = [(i % N) + 1 for i in range(1, N + 1)] return assignment"},{"question":"from typing import List, Tuple def preprocess_array(arr: List[int]) -> List[int]: Preprocess the array to create a prefix sum array for efficient range queries. >>> preprocess_array([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] >>> preprocess_array([-1, 2, -3, 4, -5]) [0, -1, 1, -2, 2, -3] pass def range_sum_query(prefix_sum: List[int], l: int, r: int) -> int: Returns the sum of the elements in the range [l, r] using the prefix sum array. Note: l and r are expected to be 1-indexed. >>> range_sum_query([0, 1, 3, 6, 10, 15], 1, 3) 6 >>> range_sum_query([0, -1, 1, -2, 2, -3], 2, 4) 3 pass def process_queries(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Process a list of queries on the array. >>> process_queries([1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> process_queries([-1, 2, -3, 4, -5], [(1, 3), (2, 4), (1, 5)]) [-2, 3, -3] pass","solution":"def preprocess_array(arr): Preprocess the array to create a prefix sum array for efficient range queries. n = len(arr) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + arr[i] return prefix_sum def range_sum_query(prefix_sum, l, r): Returns the sum of the elements in the range [l, r] using the prefix sum array. Note: l and r are expected to be 1-indexed. return prefix_sum[r] - prefix_sum[l - 1] def process_queries(arr, queries): Process a list of queries on the array. prefix_sum = preprocess_array(arr) results = [] for l, r in queries: results.append(range_sum_query(prefix_sum, l, r)) return results"},{"question":"def max_score_path(grid): Returns the maximum score that can be achieved by moving from the top-left corner to the bottom-right corner of the grid, moving only to the right and down. pass # Unit tests def test_example_1(): grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]] assert max_score_path(grid) == 12 def test_example_2(): grid = [[1, 2], [1, 1]] assert max_score_path(grid) == 4 def test_single_row(): grid = [[1, 2, 3, 4]] assert max_score_path(grid) == 10 def test_single_column(): grid = [[1], [2], [3], [4]] assert max_score_path(grid) == 10 def test_minimum_size_grid(): grid = [[5]] assert max_score_path(grid) == 5 def test_all_zero_values(): grid = [[0, 0], [0, 0]] assert max_score_path(grid) == 0 def test_large_numbers(): grid = [[100, 100], [100, 100]] assert max_score_path(grid) == 300","solution":"def max_score_path(grid): Returns the maximum score that can be achieved by moving from the top-left corner to the bottom-right corner of the grid, moving only to the right and down. m = len(grid) n = len(grid[0]) # Create a 2D dp array to store the maximum scores dp = [[0]*n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def process_string(s: str) -> str: Process the string s by applying backspaces as indicated by the '#'. >>> process_string('abcd') 'abcd' >>> process_string('ab#c') 'ac' >>> process_string('#a') 'a' >>> process_string('#ab') 'b' >>> process_string('abc#d#') 'ab' >>> process_string('#') '' >>> process_string('') '' >>> process_string('a#bc#d') 'bd' >>> process_string('abcdefg') 'abcdefg'","solution":"def process_string(s): Process the string s by applying backspaces as indicated by the '#'. result = [] for char in s: if char == '#': if result: result.pop() else: result.append(char) return ''.join(result)"},{"question":"from typing import List, Tuple, Union def find_chapter_order(n: int, m: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determine a valid order for printing book chapters based on dependencies. Args: n : int : number of chapters m : int : number of dependencies dependencies : List[Tuple[int, int]] : list of dependencies where chapter bi should appear before chapter ai Returns: Union[List[int], str] : a valid order of chapters or \\"IMPOSSIBLE\\" if no valid order exists Examples: >>> find_chapter_order(3, 2, [(1, 2), (2, 3)]) [3, 2, 1] >>> find_chapter_order(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"IMPOSSIBLE\\" pass def test_no_dependencies(): n, m = 3, 0 dependencies = [] assert find_chapter_order(n, m, dependencies) == [1, 2, 3] or find_chapter_order(n, m, dependencies) == [1, 3, 2] or find_chapter_order(n, m, dependencies) == [2, 1, 3] or find_chapter_order(n, m, dependencies) == [2, 3, 1] or find_chapter_order(n, m, dependencies) == [3, 1, 2] or find_chapter_order(n, m, dependencies) == [3, 2, 1] def test_simple_sequence(): n, m = 3, 2 dependencies = [(1, 2), (2, 3)] assert find_chapter_order(n, m, dependencies) == [3, 2, 1] def test_impossible_sequence(): n, m = 3, 3 dependencies = [(1, 2), (2, 3), (3, 1)] assert find_chapter_order(n, m, dependencies) == \\"IMPOSSIBLE\\" def test_multiple_possible_orders(): n, m = 4, 4 dependencies = [(2, 1), (3, 1), (4, 2), (4, 3)] result = find_chapter_order(n, m, dependencies) assert result == [1, 2, 3, 4] or result == [1, 3, 2, 4] def test_complex_dependencies(): n, m = 6, 6 dependencies = [(2, 1), (3, 1), (4, 2), (5, 3), (6, 4), (6, 5)] result = find_chapter_order(n, m, dependencies) assert result == [1, 2, 3, 4, 5, 6] or result == [1, 3, 2, 5, 4, 6] def test_single_chapter(): n, m = 1, 0 dependencies = [] assert find_chapter_order(n, m, dependencies) == [1] def test_two_chapters_with_dependency(): n, m = 2, 1 dependencies = [(2, 1)] assert find_chapter_order(n, m, dependencies) == [1, 2]","solution":"from collections import deque, defaultdict def find_chapter_order(n, m, dependencies): # Create a graph and a list to count the in-degrees of nodes graph = defaultdict(list) in_degree = [0] * (n + 1) # Populate the graph and in-degree list for a, b in dependencies: graph[b].append(a) in_degree[a] += 1 # Queue to store characters with 0 in-degree (i.e., no prerequisites) queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Check if we have been able to include all chapters in the order if len(order) == n: return order else: return \\"IMPOSSIBLE\\""},{"question":"def longest_contiguous_subarray(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the length of the longest contiguous subarray with the same value. >>> longest_contiguous_subarray([(8, [1, 2, 2, 3, 3, 3, 2, 2]), (5, [1, 4, 4, 4, 5]), (6, [1, 1, 1, 1, 1, 1])]) [3, 3, 6] >>> longest_contiguous_subarray([(1, [7])]) [1] >>> longest_contiguous_subarray([(3, [1, 2, 2])]) [2] >>> longest_contiguous_subarray([(3, [1, 2, 3])]) [1] >>> longest_contiguous_subarray([(0, []), (0, []), (0, [])]) [0, 0, 0]","solution":"def longest_contiguous_subarray(test_cases): results = [] for case in test_cases: n = case[0] arr = case[1] if n == 0: results.append(0) continue max_len = 1 current_len = 1 for i in range(1, n): if arr[i] == arr[i-1]: current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 1 results.append(max_len) return results # Example usage (not part of solution to be tested): # test_cases = [(8, [1, 2, 2, 3, 3, 3, 2, 2]), (5, [1, 4, 4, 4, 5]), (6, [1, 1, 1, 1, 1, 1])] # print(longest_contiguous_subarray(test_cases))"},{"question":"def count_connected_components(n: int, edges: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Calculate the number of connected components and the size of each component. >>> count_connected_components(6, [(1, 2), (2, 3), (4, 5)]) (3, [1, 2, 3]) >>> count_connected_components(4, []) (4, [1, 1, 1, 1]) pass def read_input(n: int, m: int, edge_list: List[str]) -> Tuple[int, List[Tuple[int, int]]]: Read and process the input for the graph. >>> read_input(6, 3, ['1 2', '2 3', '4 5']) (6, [(1, 2), (2, 3), (4, 5)]) >>> read_input(4, 0, []) (4, []) pass","solution":"def count_connected_components(n, edges): from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited[start] = True component_size = 0 while queue: node = queue.popleft() component_size += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_size graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) # 1-based indexing component_sizes = [] for node in range(1, n+1): if not visited[node]: size = bfs(node) component_sizes.append(size) component_sizes.sort() return len(component_sizes), component_sizes def read_input(n, m, edge_list): if m == 0: return n, [] edges = [tuple(map(int, edge_each.strip().split())) for edge_each in edge_list] return n, edges"},{"question":"def preprocess_and_query(N: int, Q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Perform Q queries to calculate the sum of integers in a sub-sequence of the given sequence. >>> preprocess_and_query(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> preprocess_and_query(1, 1, [100], [(1, 1)]) [100] >>> preprocess_and_query(4, 2, [4, 1, 6, 5], [(1, 4), (2, 3)]) [16, 7] >>> preprocess_and_query(6, 4, [5, 9, 1, 2, 3, 7], [(1, 6), (1, 6), (1, 6), (1, 6)]) [27, 27, 27, 27]","solution":"def preprocess_and_query(N, Q, array, queries): # Step 1: Create the prefix sum array prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prefix_sums[i] = prefix_sums[i - 1] + array[i - 1] # Step 2: Answer the queries using the prefix sum array results = [] for L, R in queries: sum_subsequence = prefix_sums[R] - prefix_sums[L - 1] results.append(sum_subsequence) return results"},{"question":"def max_credits(N: int, K: int, credits: List[int]) -> int: Returns the maximum possible total credits the student can obtain by selecting K courses out of N courses. Parameters: N (int): Total number of courses K (int): Number of courses to select credits (List[int]): List of credits for each course Returns: int: Maximum total credits >>> max_credits(4, 2, [20, 10, 30, 40]) 70 >>> max_credits(3, 3, [10, 20, 30]) 60","solution":"def max_credits(N, K, credits): Returns the maximum possible total credits the student can obtain by selecting K courses out of N courses. :param N: Total number of courses :param K: Number of courses to select :param credits: List of credits for each course :return: Maximum total credits # Sort the list of credits in descending order credits.sort(reverse=True) # Sum the top K credits max_total_credits = sum(credits[:K]) return max_total_credits # Example usage: # N, K = 4, 2 # credits = [20, 10, 30, 40] # print(max_credits(N, K, credits)) # Output should be 70"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of insertions required to transform the given string into a palindrome. >>> min_insertions_to_palindrome(\\"a\\") == 0 >>> min_insertions_to_palindrome(\\"aa\\") == 0 >>> min_insertions_to_palindrome(\\"ab\\") == 1 >>> min_insertions_to_palindrome(\\"abbac\\") == 1 >>> min_insertions_to_palindrome(\\"abcde\\") == 4 >>> min_insertions_to_palindrome(\\"racecar\\") == 0 >>> min_insertions_to_palindrome(\\"madam\\") == 0 >>> min_insertions_to_palindrome(\\"aabb\\") == 2 >>> min_insertions_to_palindrome(\\"abacd\\") == 2 >>> min_insertions_to_palindrome(\\"bccb\\") == 0 >>> min_insertions_to_palindrome(\\"mnop\\") == 3","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of insertions required to transform the string into a palindrome. def lcs(x, y): Helper function to find the length of the longest common subsequence of two strings. m = len(x) n = len(y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif x[i-1] == y[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n] # reverse the string to find the longest palindromic subsequence rev_s = s[::-1] # length of the longest palindromic subsequence lps_length = lcs(s, rev_s) # minimum number of insertions return len(s) - lps_length"},{"question":"def final_values_in_tree(n, q, edges, queries): You are given a tree with n nodes. One of the nodes is marked as the root of the tree. Each node initially has a value 0. There are q queries, each query asks to add a certain value to all the nodes in the subtree rooted at a given node. Your task is to write a program that processes all the queries and outputs the final values of all nodes in the tree. Args: n: int - the number of nodes q: int - the number of queries edges: List[Tuple[int, int]] - the edges of the tree queries: List[Tuple[int, int]] - the queries (node, value) Output: List[int] - final values of all nodes from node 1 to node n Example: >>> n = 5 >>> q = 3 >>> edges = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> queries = [(1, 5), (3, 10), (2, 3)] >>> final_values_in_tree(n, q, edges, queries) [5, 8, 15, 15, 15] from solution import final_values_in_tree def test_final_values_in_tree(): n = 5 q = 3 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] queries = [(1, 5), (3, 10), (2, 3)] expected_output = [5, 8, 15, 15, 15] assert final_values_in_tree(n, q, edges, queries) == expected_output def test_final_values_in_tree_single_query(): n = 3 q = 1 edges = [(1, 2), (1, 3)] queries = [(1, 10)] expected_output = [10, 10, 10] assert final_values_in_tree(n, q, edges, queries) == expected_output def test_final_values_in_tree_multiple_roots(): n = 4 q = 2 edges = [(1, 2), (2, 3), (3, 4)] queries = [(2, 3), (1, 5)] expected_output = [5, 8, 8, 8] assert final_values_in_tree(n, q, edges, queries) == expected_output def test_final_values_in_tree_no_queries(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] queries = [] expected_output = [0, 0, 0, 0] assert final_values_in_tree(n, 0, edges, queries) == expected_output","solution":"def final_values_in_tree(n, q, edges, queries): from collections import defaultdict import sys sys.setrecursionlimit(200000) def dfs(node, parent): subtree_nodes[node] = 1 start_time[node] = current_time[0] tour[current_time[0]] = node current_time[0] += 1 for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node) subtree_nodes[node] += subtree_nodes[neighbor] finish_time[node] = current_time[0] tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) subtree_nodes = [0] * (n + 1) start_time = [0] * (n + 1) finish_time = [0] * (n + 1) tour = [0] * (n + 1) current_time = [1] dfs(1, -1) bit = [0] * (n + 2) def update(idx, val): while idx <= n: bit[idx] += val idx += idx & -idx def query(idx): sum_val = 0 while idx > 0: sum_val += bit[idx] idx -= idx & -idx return sum_val for v, x in queries: update(start_time[v], x) update(finish_time[v], -x) result = [query(start_time[i]) for i in range(1, n + 1)] return result"},{"question":"def smallest_subsequence(s: str) -> str: Implement a function that returns the lexicographically smallest subsequence of a given string that contains all the distinct characters of the string exactly once. >>> smallest_subsequence(\\"cbacdcbc\\") \\"acdb\\" >>> smallest_subsequence(\\"abacb\\") \\"abc\\"","solution":"def smallest_subsequence(s: str) -> str: last_occurrence = {char: i for i, char in enumerate(s)} stack = [] seen = set() for i, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) seen.add(char) stack.append(char) return ''.join(stack)"},{"question":"def highest_grades(n, students): Finds the students with the highest grade and prints their names in alphabetical order. Args: n (int): Number of students. students (list of tuples): Each tuple contains a student's name as a string and their grade as an integer. Returns: list of str: Sorted names of students with the highest grade. Examples: >>> highest_grades(5, [(\\"Alice\\", 91), (\\"Bob\\", 78), (\\"Charlie\\", 91), (\\"David\\", 85), (\\"Eve\\", 91)]) [\\"Alice\\", \\"Charlie\\", \\"Eve\\"] >>> highest_grades(3, [(\\"Alice\\", 100), (\\"Bob\\", 100), (\\"Charlie\\", 100)]) [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] >>> highest_grades(3, [(\\"Alice\\", 91), (\\"Bob\\", 92), (\\"Charlie\\", 90)]) [\\"Bob\\"] >>> highest_grades(4, [(\\"Alice\\", 91), (\\"Bob\\", 78), (\\"Charlie\\", 100), (\\"David\\", 100)]) [\\"Charlie\\", \\"David\\"] >>> highest_grades(1, [(\\"Alice\\", 91)]) [\\"Alice\\"]","solution":"def highest_grades(n, students): Finds the students with the highest grade and prints their names in alphabetical order. Args: n (int): Number of students. students (list of tuples): Each tuple contains a student's name as a string and their grade as an integer. Returns: list of str: Sorted names of students with the highest grade. highest_grade = -1 top_students = [] for student in students: name, grade = student grade = int(grade) if grade > highest_grade: highest_grade = grade top_students = [name] elif grade == highest_grade: top_students.append(name) top_students.sort() return top_students"},{"question":"def minimum_spanning_tree_cost(N, cost_matrix): Determines the minimum cost required to connect all cities in a network. Args: N (int): Number of cities. cost_matrix (list of list of int): N x N matrix representing the cost to establish links between cities. Returns: int: The minimum cost to connect all cities. Example: >>> minimum_spanning_tree_cost( >>> 4, [ >>> [0, 1, 4, 7], >>> [1, 0, 2, 6], >>> [4, 2, 0, 3], >>> [7, 6, 3, 0] >>> ] >>> ) == 6 pass from solution import minimum_spanning_tree_cost def test_minimum_spanning_tree_cost_example(): cost_matrix = [ [0, 1, 4, 7], [1, 0, 2, 6], [4, 2, 0, 3], [7, 6, 3, 0] ] assert minimum_spanning_tree_cost(4, cost_matrix) == 6 def test_minimum_spanning_tree_cost_two_cities(): cost_matrix = [ [0, 5], [5, 0] ] assert minimum_spanning_tree_cost(2, cost_matrix) == 5 def test_minimum_spanning_tree_cost_all_equal(): cost_matrix = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert minimum_spanning_tree_cost(4, cost_matrix) == 3 def test_minimum_spanning_tree_cost_complex(): cost_matrix = [ [0, 2, 3, 5], [2, 0, 1, 4], [3, 1, 0, 6], [5, 4, 6, 0] ] assert minimum_spanning_tree_cost(4, cost_matrix) == 7 def test_minimum_spanning_tree_cost_large_costs(): cost_matrix = [ [0, 1000000, 1000000], [1000000, 0, 1000000], [1000000, 1000000, 0], ] assert minimum_spanning_tree_cost(3, cost_matrix) == 2000000 def test_minimum_spanning_tree_cost_min_edge(): cost_matrix = [ [0, 1, 1000000], [1, 0, 1], [1000000, 1, 0], ] assert minimum_spanning_tree_cost(3, cost_matrix) == 2","solution":"def minimum_spanning_tree_cost(N, cost_matrix): Determines the minimum cost required to connect all cities in a network. Args: N (int): Number of cities. cost_matrix (list of list of int): N x N matrix representing the cost to establish links between cities. Returns: int: The minimum cost to connect all cities. import heapq # Initializing a min-heap. min_heap = [(0, 0)] visited = set() total_cost = 0 while len(visited) < N: cost, city = heapq.heappop(min_heap) if city in visited: continue visited.add(city) total_cost += cost for next_city in range(N): if next_city not in visited: heapq.heappush(min_heap, (cost_matrix[city][next_city], next_city)) return total_cost"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def is_bipartite(N: int, edges: List[Tuple[int, int]]) -> str: Determine if the graph is bipartite. >>> is_bipartite(4, [(1, 2), (1, 3), (2, 4), (3, 4)]) \\"YES\\" >>> is_bipartite(3, [(1, 2), (2, 3), (1, 3)]) \\"NO\\" def test_bipartite(): assert is_bipartite(4, [(1, 2), (1, 3), (2, 4), (3, 4)]) == \\"YES\\" assert is_bipartite(3, [(1, 2), (2, 3), (1, 3)]) == \\"NO\\" assert is_bipartite(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"YES\\" assert is_bipartite(3, [(1, 2), (1, 3)]) == \\"YES\\" assert is_bipartite(4, [(1, 2), (1, 3), (2, 3), (3, 4)]) == \\"NO\\" assert is_bipartite(2, [(1, 2)]) == \\"YES\\" assert is_bipartite(6, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4)]) == \\"NO\\" assert is_bipartite(1, []) == \\"YES\\" assert is_bipartite(4, [(1, 2), (2, 3), (3, 1), (3, 4)]) == \\"NO\\" assert is_bipartite(8, [(1, 2), (3, 4), (5, 6), (7, 8), (1, 5), (2, 6), (3, 7), (4, 8)]) == \\"YES\\"","solution":"def is_bipartite(N, edges): from collections import deque, defaultdict # Create adjacency list adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) color = [-1] * (N + 1) def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in adj[node]: if color[neighbor] == -1: # If not colored color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(1, N + 1): # Handle disconnected graph if color[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def max_sum_pair(lst: List[int]) -> Tuple[int, int]: Returns the pair of integers from the list which have the highest sum. If multiple pairs have the same sum, any one of them is returned. If the list is empty or has less than two elements, returns an empty tuple. >>> max_sum_pair([1, 2, 3, 9, 8]) in [(9, 8), (8, 9)] True >>> max_sum_pair([5, 1, 3, 7]) in [(5, 7), (7, 5)] True >>> max_sum_pair([10, 20]) in [(10, 20), (20, 10)] True >>> max_sum_pair([]) == () True >>> max_sum_pair([5]) == () True >>> max_sum_pair([3, 3, 3]) in [(3, 3)] True","solution":"def max_sum_pair(lst): Returns the pair of integers from the list which have the highest sum. If multiple pairs have the same sum, any one of them is returned. If the list is empty or has less than two elements, returns an empty tuple. if len(lst) < 2: return () max1 = max(lst) lst.remove(max1) max2 = max(lst) return (max1, max2)"},{"question":"def distinct_characters_counts(test_cases): This function accepts a list of test cases, and for each test case, it finds the number of distinct characters in each given range. :param test_cases: List of dictionaries with keys 'n', 's', 'q', and 'queries' :return: List of lists. Each sublist contains the results of the queries Examples: >>> test_cases = [ >>> {'n': 7, 's': 'abacaba', 'q': 3, 'queries': [(1, 3), (2, 4), (1, 7)]} >>> ] >>> distinct_characters_counts(test_cases) [[2, 2, 3]] >>> test_cases = [ >>> {'n': 5, 's': 'xyzzy', 'q': 2, 'queries': [(1, 2), (3, 5)]} >>> ] >>> distinct_characters_counts(test_cases) [[2, 2]]","solution":"def distinct_characters_counts(test_cases): This function accepts a list of test cases, and for each test case, it finds the number of distinct characters in each given range. :param test_cases: List of dictionaries with keys 'n', 's', 'q', and 'queries' :return: List of lists. Each sublist contains the results of the queries results = [] for case in test_cases: n = case['n'] s = case['s'] q = case['q'] queries = case['queries'] case_results = [] for l, r in queries: # Find the distinct characters in the range [l-1, r-1] (0-based index) distinct_characters = set(s[l-1:r]) case_results.append(len(distinct_characters)) results.append(case_results) return results"},{"question":"from typing import List, Tuple def can_partition_cities(n: int, m: int, r: int, roads: List[Tuple[int, int]]) -> str: Determine if it's possible to partition the cities of two countries so that their connecting cities must either all belong to one country or the other. >>> can_partition_cities(4, 4, 3, [(1, 3), (2, 4), (4, 2)]) == \\"YES\\" >>> can_partition_cities(3, 3, 4, [(1, 2), (1, 3), (2, 1), (3, 2)]) == \\"NO\\" >>> can_partition_cities(3, 3, 0, []) == \\"YES\\" >>> can_partition_cities(2, 2, 1, [(1, 2)]) == \\"YES\\" >>> can_partition_cities(6, 6, 6, [(1, 4), (1, 5), (2, 6), (3, 7), (4, 8), (5, 9)]) == \\"YES\\" >>> can_partition_cities(5, 4, 4, [(1, 6), (1, 7), (2, 8), (3, 9)]) == \\"YES\\" >>> can_partition_cities(5, 5, 5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) == \\"NO\\"","solution":"def can_partition_cities(n, m, r, roads): from collections import defaultdict, deque # Adjacency list graph graph = defaultdict(list) # Build the graph for u, v in roads: graph[u].append(v) graph[v].append(u) # Visited array to ensure no repetition visited = [False] * (n + m + 2) # adjusting indexes, extra space not harm here color = [-1] * (n + m + 2) # -1 means not colored, 0 means first color, 1 means second color def bfs(node): queue = deque([node]) visited[node] = True color[node] = 0 # Start coloring the first node with color 0 while queue: current = queue.popleft() cur_color = color[current] # Get color of current node for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True color[neighbor] = 1 - cur_color # Alternate color between 0 and 1 queue.append(neighbor) elif color[neighbor] == cur_color: return False # If the neighbor has the same color, it's not bipartite return True # Loop through all nodes to check for disconnected parts of the graph for i in range(1, n + 1): if not visited[i]: # Only run BFS if the node has not been visited if not bfs(i): return \\"NO\\" return \\"YES\\""},{"question":"def maximum_height_after_pruning(n: int, k: int, heights: List[int]) -> int: This function returns the maximum possible height of any plant after at most k pruning operations. Input: n - number of plants k - maximum number of pruning operations heights - list of integers representing heights of the plants Returns: Maximum possible height of any plant after at most k pruning operations. Example: >>> maximum_height_after_pruning(7, 3, [4, 5, 3, 7, 6, 4, 8]) 8 >>> maximum_height_after_pruning(5, 2, [1, 2, 3, 4, 5]) 5","solution":"def maximum_height_after_pruning(n, k, heights): This function returns the maximum possible height of any plant after at most k pruning operations. if k == 0: return max(heights) pruning_operations = 0 for i in range(n - 1): if pruning_operations >= k: break if heights[i] < heights[i + 1]: heights[i] = heights[i + 1] pruning_operations += 1 return max(heights)"},{"question":"from typing import List def calculate_highest_score(test_cases: List) -> List[str]: Calculate the highest possible score each contestant can achieve based on their selected categories and the corresponding difficulty of the questions. Args: test_cases: A list of tuples, where each tuple contains: - A dictionary mapping category names to difficulty scores. - A list of category names the contestant is knowledgeable about. Returns: A list of strings, each indicating the result for a test case in the format \\"Case X: Y\\", where X is the test case number (starting from 1) and Y is the highest possible score. pass def main(input_data: str) -> List[str]: Reads input data, processes multiple test cases, and calculates the highest possible scores for each contestant. Args: input_data: A single string containing the input data in the specified format. Returns: A list of results for each test case in the format \\"Case X: Y\\". pass # Sample Unit Test def test_calculate_highest_score(): # Test case from example input_data = '3nhistory 50nscience 70ngeography 60n2nhistorynsciencen4nmath 80nliterature 40nart 50nmusic 30n3nmathnartnmusicn2nsports 90npolitics 60n2nsportsnpoliticsn0n' expected_output = [\\"Case 1: 120\\", \\"Case 2: 160\\", \\"Case 3: 150\\"] assert main(input_data) == expected_output def test_varied_category_numbers(): # Test with less number of categories input_data = '2nmath 100nart 40n1nmathn0n' expected_output = [\\"Case 1: 100\\"] assert main(input_data) == expected_output # Test with just one category input_data = '1nmath 100n1nmathn0n' expected_output = [\\"Case 1: 100\\"] assert main(input_data) == expected_output def test_higher_difficulty_scores(): # Test with maximum difficulty scores input_data = '3nmath 100nscience 100nliterature 100n2nmathnsciencen0n' expected_output = [\\"Case 1: 200\\"] assert main(input_data) == expected_output","solution":"def calculate_highest_score(test_cases): results = [] for i, (categories, knowledgeable) in enumerate(test_cases): score = sum(categories[category] for category in knowledgeable) results.append(f\\"Case {i + 1}: {score}\\") return results def main(input_data): input_lines = input_data.strip().split('n') index = 0 test_cases = [] while index < len(input_lines): N = int(input_lines[index]) if N == 0: break index += 1 categories = {} for _ in range(N): category_name, difficulty_score = input_lines[index].split() categories[category_name] = int(difficulty_score) index += 1 M = int(input_lines[index]) index += 1 knowledgeable = [] for _ in range(M): knowledgeable.append(input_lines[index]) index += 1 test_cases.append((categories, knowledgeable)) return calculate_highest_score(test_cases)"},{"question":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between str1 and str2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes input test cases and returns their results. from typing import List, Tuple def test_longest_common_subsequence_basic(): assert longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 assert longest_common_subsequence(\\"abc\\", \\"def\\") == 0 def test_longest_common_subsequence_same_string(): assert longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 assert longest_common_subsequence(\\"a\\", \\"a\\") == 1 def test_longest_common_subsequence_no_common_chars(): assert longest_common_subsequence(\\"abc\\", \\"xyz\\") == 0 def test_longest_common_subsequence_substring(): assert longest_common_subsequence(\\"abcde\\", \\"bcd\\") == 3 def test_process_test_cases(): test_cases = [(\\"abcde\\", \\"ace\\"), (\\"abc\\", \\"def\\")] assert process_test_cases(test_cases) == [3, 0]","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence between str1 and str2. m, n = len(str1), len(str2) dp = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n] def process_test_cases(test_cases): Processes input test cases and returns their results. results = [] for str1, str2 in test_cases: lcs_length = longest_common_subsequence(str1, str2) results.append(lcs_length) return results"},{"question":"def can_arrange_paintings(n: int, m: int, restrictions: List[Tuple[int, int]]) -> str: Determine if it's possible to arrange paintings such that no restricted pairs are adjacent. >>> can_arrange_paintings(3, 2, [(1, 2), (2, 3)]) \\"YES\\" >>> can_arrange_paintings(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"NO\\" def test_no_restrictions(): assert can_arrange_paintings(4, 0, []) == \\"YES\\" def test_possible_arrangement(): assert can_arrange_paintings(3, 2, [(1, 2), (2, 3)]) == \\"YES\\" def test_no_possible_arrangement(): assert can_arrange_paintings(3, 3, [(1, 2), (2, 3), (3, 1)]) == \\"NO\\" def test_larger_graph_possible(): assert can_arrange_paintings(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"YES\\" def test_larger_graph_not_possible(): assert can_arrange_paintings(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) == \\"NO\\" def test_single_painting(): assert can_arrange_paintings(1, 0, []) == \\"YES\\" def test_two_paintings_no_restriction(): assert can_arrange_paintings(2, 0, []) == \\"YES\\" def test_two_paintings_with_restriction(): assert can_arrange_paintings(2, 1, [(1, 2)]) == \\"YES\\"","solution":"def can_arrange_paintings(n, m, restrictions): from collections import defaultdict def dfs(graph, node, visited, color): visited[node] = color for neighbor in graph[node]: if visited[neighbor] == color: return False if visited[neighbor] == 0 and not dfs(graph, neighbor, visited, -color): return False return True if m == 0: return \\"YES\\" graph = defaultdict(list) for a, b in restrictions: graph[a].append(b) graph[b].append(a) visited = [0] * (n + 1) for i in range(1, n + 1): if visited[i] == 0: if not dfs(graph, i, visited, 1): return \\"NO\\" return \\"YES\\""},{"question":"def top_k_donors(test_cases: List[Dict]) -> List[List[Tuple[str, int]]]: Identify the top K donors based on their cumulative donation amounts. >>> top_k_donors([ ... { ... 'entries': [('Alice', 50), ('Bob', 40), ('Alice', 100), ('Charlie', 70), ('Alice', 30)], ... 'k': 2 ... } ... ]) [[('Alice', 180), ('Charlie', 70)]] >>> top_k_donors([ ... { ... 'entries': [('Dave', 20), ('Eve', 30), ('Dave', 50), ('Frank', 10)], ... 'k': 3 ... } ... ]) [[('Dave', 70), ('Eve', 30), ('Frank', 10)]]","solution":"def top_k_donors(test_cases): results = [] for cases in test_cases: entries = cases['entries'] k = cases['k'] donation_dict = {} for name, donation in entries: if name in donation_dict: donation_dict[name] += donation else: donation_dict[name] = donation sorted_donors = sorted(donation_dict.items(), key=lambda x: (-x[1], x[0])) results.append(sorted_donors[:k]) return results"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of a subarray with at least one element. >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-3, 8, -2, 4, -5, 6]) 11 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3]) 6","solution":"def max_subarray_sum(arr): Returns the maximum sum of a subarray with at least one element. max_current = arr[0] max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def can_arrange_books(test_cases): Determine if it is possible to arrange the books in non-decreasing order by moving each book at most once. >>> t = 3 >>> test_cases_raw = [5, 4, 5, 3, 2, 1, 4, 1, 3, 4, 2, 6, 1, 1, 1, 1, 1, 1] >>> test_cases = process_input(t, test_cases_raw) >>> can_arrange_books(test_cases) [\\"No\\", \\"Yes\\", \\"Yes\\"] >>> t = 3 >>> test_cases_raw = [5, 1, 2, 3, 4, 5, 5, 5, 4, 3, 2, 1, 3, 3, 2, 1] >>> test_cases = process_input(t, test_cases_raw) >>> can_arrange_books(test_cases) [\\"Yes\\", \\"No\\", \\"No\\"] pass def process_input(t, test_cases_raw): Process the input format to extract book heights for each test case >>> t = 2 >>> test_cases_raw = [5, 4, 5, 3, 2, 1, 4, 1, 3, 4, 2] >>> process_input(t, test_cases_raw) [(5, 4, 5, 3, 2, 1), (4, 1, 3, 4, 2)] pass","solution":"def can_arrange_books(test_cases): Determine if it is possible to arrange the books in non-decreasing order by moving each book at most once. results = [] for books in test_cases: n = books[0] heights = books[1:] swaps = 0 for i in range(1, n): if heights[i] < heights[i - 1]: swaps += 1 if swaps > 1: results.append(\\"No\\") break else: results.append(\\"Yes\\") return results def process_input(t, test_cases_raw): Process the input format to extract book heights for each test case test_cases = [] idx = 0 for _ in range(t): n = test_cases_raw[idx] heights = test_cases_raw[idx + 1: idx + 1 + n] test_cases.append((n, *heights)) idx += n + 1 return test_cases"},{"question":"def encrypt_message(k: int, s: str) -> str: Encrypts the input string s by shifting each character k positions in the alphabet. :param k: Integer, number of positions to shift (1 ≤ k ≤ 25) :param s: String, the message to be encrypted (1 ≤ |s| ≤ 1000) :return: Encrypted string >>> encrypt_message(3, 'abc') == 'def' >>> encrypt_message(2, 'xyz') == 'zab' >>> encrypt_message(1, 'hello') == 'ifmmp'","solution":"def encrypt_message(k, s): Encrypts the input string s by shifting each character k positions in the alphabet. :param k: Integer, number of positions to shift (1 ≤ k ≤ 25) :param s: String, the message to be encrypted (1 ≤ |s| ≤ 1000) :return: Encrypted string encrypted_message = [] for char in s: if 'a' <= char <= 'z': shifted_index = (ord(char) - ord('a') + k) % 26 encrypted_char = chr(ord('a') + shifted_index) encrypted_message.append(encrypted_char) return ''.join(encrypted_message)"},{"question":"def find_missing_salary(M: int, N: int, salaries: List[int]) -> int: Finds the missing salary in a continuous range starting from a given minimum salary. >>> find_missing_salary(50000, 5, [50000, 50001, 50003, 50002]) 50004 >>> find_missing_salary(30000, 4, [30001, 30002, 30003]) 30000 pass def find_missing_salaries(test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Process multiple test cases to find missing salaries. >>> find_missing_salaries([((50000, 5), [50000, 50001, 50003, 50002]), ((30000, 4), [30001, 30002, 30003])]) [50004, 30000] pass # Tests import pytest def test_find_missing_salary_example_1(): assert find_missing_salary(50000, 5, [50000, 50001, 50003, 50002]) == 50004 def test_find_missing_salary_example_2(): assert find_missing_salary(30000, 4, [30001, 30002, 30003]) == 30000 def test_find_missing_salary_custom_case_1(): assert find_missing_salary(100, 6, [100, 101, 103, 104, 105]) == 102 def test_find_missing_salary_custom_case_2(): assert find_missing_salary(1000, 10, [1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008]) == 1009 def test_find_missing_salaries_multiple_cases(): test_cases = [ ((50000, 5), [50000, 50001, 50003, 50002]), ((30000, 4), [30001, 30002, 30003]) ] assert find_missing_salaries(test_cases) == [50004, 30000] def test_find_missing_salaries_multiple_cases_custom(): test_cases = [ ((100, 6), [100, 101, 103, 104, 105]), ((1000, 10), [1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008]) ] assert find_missing_salaries(test_cases) == [102, 1009]","solution":"def find_missing_salary(M, N, salaries): Finds the missing salary in a continuous range starting from a given minimum salary. Args: M: int - The minimum salary. N: int - The total number of employees. salaries: list of int - The list of N-1 integers representing the salaries. Returns: int - The missing salary. # Calculate the expected sum of the first N salaries starting from M expected_sum = (N * (2 * M + N - 1)) // 2 actual_sum = sum(salaries) return expected_sum - actual_sum def find_missing_salaries(test_cases): Process multiple test cases to find missing salaries. Args: test_cases: list of tuples. Each tuple contains two elements: - A tuple (M, N) where M is the minimum salary and N is the number of employees. - A list of N-1 integers representing the salaries. Returns: list of int - List of missing salaries for each test case. results = [] for (M, N), salaries in test_cases: results.append(find_missing_salary(M, N, salaries)) return results"},{"question":"def find_missing_card(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: A group of friends decided to play a card game. Each card has a unique integer identifier ranging from 1 to N (inclusive). Unfortunately, one card from the set got lost. Your task is to identify the missing card identifier based on the cards that are still left in the deck. Parameters: T (int): The number of test cases. cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains: - An integer N, representing the number of cards initially present in the deck. - An array A of N-1 integers, listing the remaining card identifiers in the deck after the loss. Returns: List[int]: A list of missing card identifiers, one for each test case. Example: >>> find_missing_card(1, [(5, [1, 2, 4, 5])]) [3] >>> find_missing_card(2, [(5, [1, 2, 4, 5]), (6, [6, 4, 2, 5, 1])]) [3, 3] from typing import List, Tuple def test_find_missing_card(): assert find_missing_card(1, [(5, [1, 2, 4, 5])]) == [3] assert find_missing_card(2, [(5, [1, 2, 4, 5]), (6, [6, 4, 2, 5, 1])]) == [3, 3] assert find_missing_card(1, [(1, [])]) == [1] assert find_missing_card(1, [(100000, list(range(1, 100000)))]) == [100000] assert find_missing_card(3, [ (3, [1, 2]), (4, [2, 4, 1]), (7, [3, 2, 6, 7, 1, 4]) ]) == [3, 3, 5]","solution":"def find_missing_card(T, cases): results = [] for N, deck in cases: total_sum = N * (N + 1) // 2 # Sum of first N natural numbers current_sum = sum(deck) # Sum of remaining cards missing_card = total_sum - current_sum # Missing card is the difference results.append(missing_card) return results"},{"question":"def min_time_to_deliver(m: int, n: int, grid: List[str], start_x: int, start_y: int, target_x: int, target_y: int) -> int: Determines the minimum time required for a robotic courier to deliver a package in a grid-based city. >>> min_time_to_deliver(5, 5, [ ..... .#. ..#.. .#. .....] , 0, 0, 4, 4) 8 >>> min_time_to_deliver(5, 5, [ ..... .#. # .#. .....] , 0, 0, 4, 4) -1 from collections import deque def is_valid(x: int, y: int, m: int, n: int, grid: List[str]) -> bool: return 0 <= x < m and 0 <= y < n and grid[x][y] == '.' def test_min_time_to_deliver_example(): m = 5 n = 5 grid = [ \\".....\\", \\".#.\\", \\"..#..\\", \\".#.\\", \\".....\\" ] start_x, start_y = 0, 0 target_x, target_y = 4, 4 result = min_time_to_deliver(m, n, grid, start_x, start_y, target_x, target_y) assert result == 8 def test_min_time_to_deliver_obstacle_blocking(): m = 5 n = 5 grid = [ \\".....\\", \\".#.\\", \\"#\\", \\".#.\\", \\".....\\" ] start_x, start_y = 0, 0 target_x, target_y = 4, 4 result = min_time_to_deliver(m, n, grid, start_x, start_y, target_x, target_y) assert result == -1 def test_min_time_to_deliver_same_start_and_target(): m = 5 n = 5 grid = [ \\".....\\", \\".#.\\", \\"..#..\\", \\".#.\\", \\".....\\" ] start_x, start_y = 0, 0 target_x, target_y = 0, 0 result = min_time_to_deliver(m, n, grid, start_x, start_y, target_x, target_y) assert result == 0 def test_min_time_to_deliver_minimal_grid(): m = 1 n = 1 grid = [\\".\\"] start_x, start_y = 0, 0 target_x, target_y = 0, 0 result = min_time_to_deliver(m, n, grid, start_x, start_y, target_x, target_y) assert result == 0 def test_min_time_to_deliver_no_path(): m = 3 n = 3 grid = [ \\".#.\\", \\"#.#\\", \\".#.\\" ] start_x, start_y = 0, 0 target_x, target_y = 2, 2 result = min_time_to_deliver(m, n, grid, start_x, start_y, target_x, target_y) assert result == -1 def test_min_time_to_deliver_large_grid(): m = 10 n = 10 grid = [ \\"..........\\", \\"#...\\", \\"#...#.....\\", \\".#.#\\", \\"....#.....\\", \\".#\\", \\".........#\\", \\"#..#\\", \\".........#\\", \\"#.\\" ] start_x, start_y = 0, 0 target_x, target_y = 9, 9 result = min_time_to_deliver(m, n, grid, start_x, start_y, target_x, target_y) assert result == -1","solution":"from collections import deque def min_time_to_deliver(m, n, grid, start_x, start_y, target_x, target_y): if not grid or not grid[0]: return -1 def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == '.' directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start_x, start_y, 0)]) # (x, y, distance) visited = set((start_x, start_y)) while queue: x, y, dist = queue.popleft() if (x, y) == (target_x, target_y): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def min_cost_to_connect_all_cities(input_str: str) -> str: Determines the minimum cost to connect all the cities in the kingdom of Vertlandia. Args: input_str (str): The input string representing multiple datasets. Each dataset begins with two integers n and m, where n is the number of cities and m is the number of possible roads. The next m lines each contain three integers u, v, and w indicating a road between cities u and v with cost w. The input is terminated by a line containing two zeros. Returns: str: A string containing the minimum cost to connect all cities for each dataset, each cost separated by a newline. Examples: >>> input_str = \\"4 5n1 2 1n2 3 2n3 4 4n4 1 8n1 3 3n3 3n1 2 2n2 3 3n1 3 1n0 0n\\" >>> min_cost_to_connect_all_cities(input_str) \\"7n3\\" >>> input_str = \\"2 1n1 2 1n0 0n\\" >>> min_cost_to_connect_all_cities(input_str) \\"1\\" pass # Unit Tests def test_min_cost_to_connect_all_cities(): input_str = \\"4 5n1 2 1n2 3 2n3 4 4n4 1 8n1 3 3n3 3n1 2 2n2 3 3n1 3 1n0 0n\\" expected_output = \\"7n3\\" assert min_cost_to_connect_all_cities(input_str) == expected_output def test_min_cost_edge_case(): input_str = \\"2 1n1 2 1n0 0n\\" expected_output = \\"1\\" assert min_cost_to_connect_all_cities(input_str) == expected_output def test_min_cost_multiple_dataset(): input_str = \\"3 3n1 2 1n2 3 2n1 3 3n4 5n1 2 1n2 3 2n3 4 1n4 1 4n1 3 5n0 0n\\" expected_output = \\"3n4\\" assert min_cost_to_connect_all_cities(input_str) == expected_output def test_min_cost_complex(): input_str = \\"5 7n1 2 4n2 3 8n3 4 7n4 5 9n1 5 10n2 4 2n3 5 6n0 0n\\" expected_output = \\"19\\" assert min_cost_to_connect_all_cities(input_str) == expected_output","solution":"def find_parent(parent, i): if parent[i] == i: return i else: return find_parent(parent, parent[i]) def union(parent, rank, x, y): xroot = find_parent(parent, x) yroot = find_parent(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] i = 0 e = 0 edges.sort(key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = edges[i] i = i + 1 x = find_parent(parent, u) y = find_parent(parent, v) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def min_cost_to_connect_all_cities(input_str): input_lines = input_str.strip().split('n') output_lines = [] i = 0 while i < len(input_lines): n, m = map(int, input_lines[i].split()) if n == 0 and m == 0: break edges = [] i += 1 for _ in range(m): u, v, w = map(int, input_lines[i].split()) edges.append([u-1, v-1, w]) i += 1 output_lines.append(str(kruskal(n, edges))) return \\"n\\".join(output_lines)"},{"question":"def minimum_cost_to_connect_islands(n: int, m: int, islands: List[Tuple[int, str]], bridges: List[Tuple[int, int, int]]) -> int: Ensure that all Atlantis and Lemuria islands remain connected via the minimum cost of bridge construction. >>> minimum_cost_to_connect_islands( ... 6, ... 7, ... [(1, 'A'), (2, 'L'), (3, 'A'), (4, 'D'), (5, 'L'), (6, 'D')], ... [(1, 4, 5), (4, 6, 3), (2, 5, 1), (4, 5, 2), (3, 4, 4), (6, 5, 6), (2, 6, 10)] ... ) 15 >>> minimum_cost_to_connect_islands( ... 4, ... 4, ... [(1, 'A'), (2, 'D'), (3, 'D'), (4, 'L')], ... [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 4, 10)] ... ) 3 >>> minimum_cost_to_connect_islands( ... 3, ... 2, ... [(1, 'A'), (2, 'L'), (3, 'D')], ... [(1, 3, 1), (3, 2, 1)] ... ) 2 pass","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def minimum_cost_to_connect_islands(n, m, islands, bridges): # Disjoint set initialization parent = [] rank = [] for i in range(n + 1): parent.append(i) rank.append(0) # Separate the islands by their types atlantis = set() lemuria = set() disputed = set() for island in islands: index, type = island if type == 'A': atlantis.add(index) elif type == 'L': lemuria.add(index) else: disputed.add(index) # Sort bridges by cost bridges.sort(key=lambda x: x[2]) total_cost = 0 for bride in bridges: u, v, c = bride if (u in atlantis and v in lemuria) or (v in atlantis and u in lemuria): continue if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_cost += c return total_cost"},{"question":"def compressString(s: str) -> str: Given a string \`s\` containing only lowercase letters, compress the string using the following algorithm: 1. Count the consecutive occurrences of each character. 2. Replace each group of consecutive repeated characters with the character followed by the length of the group. If the compressed string is not smaller in length than the original string, return the original string instead. >>> compressString(\\"aaaaabbbcc\\") 'a5b3c2' >>> compressString(\\"abc\\") 'abc' >>> compressString(\\"aabcccccaaa\\") 'a2b1c5a3' pass def test_compress_empty_string(): assert compressString(\\"\\") == \\"\\" def test_compress_single_character(): assert compressString(\\"a\\") == \\"a\\" def test_compress_repeated_characters(): assert compressString(\\"aaaaabbbcc\\") == \\"a5b3c2\\" def test_compress_no_repeated_characters(): assert compressString(\\"abc\\") == \\"abc\\" def test_compress_mixed_characters(): assert compressString(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" def test_compress_with_same_length(): assert compressString(\\"aabbcc\\") == \\"aabbcc\\" def test_compress_with_minimum_length(): assert compressString(\\"aabbccdee\\") == \\"aabbccdee\\" def test_compress_edge_case_large_input(): large_input = \\"a\\" * 1000 expected_output = \\"a1000\\" assert compressString(large_input) == expected_output","solution":"def compressString(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \\"\\".join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def check_positions(n: int, q: int, ranges: List[Tuple[int, int]], queries: List[int]) -> List[str]: Determine if positions on a road are covered by at least one drone. Args: - n (int): The number of drones. - q (int): The number of queries. - ranges (List[Tuple[int, int]]): Each tuple consists of two integers (bi, ei) representing the range each drone can cover. - queries (List[int]): Each integer represents a position query. Returns: - List[str]: A list of strings, \\"YES\\" if the position is covered by at least one drone, \\"NO\\" otherwise. >>> check_positions(3, 4, [(1, 4), (2, 3), (5, 6)], [2, 4, 5, 7]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> check_positions(1, 1, [(1, 5)], [3]) [\\"YES\\"] >>> check_positions(3, 1, [(1, 4), (2, 3), (5, 6)], [4]) [\\"YES\\"] >>> check_positions(2, 3, [(1, 2), (4, 5)], [0, 3, 6]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> check_positions(2, 2, [(0, 0), (1000000000, 1000000000)], [0, 1000000000]) [\\"YES\\", \\"YES\\"]","solution":"def check_positions(n, q, ranges, queries): results = [] for p in queries: covered = False for (bi, ei) in ranges: if bi <= p <= ei: covered = True break results.append(\\"YES\\" if covered else \\"NO\\") return results"},{"question":"def minimize_sum_after_operations(n: int, arr: List[int]) -> int: Minimize the sum of the array after recursively performing removal of max elements. Parameters: n (int): Number of elements in the array. arr (list of int): List of integers representing the array. Returns: int: Minimized sum of the remaining elements. >>> minimize_sum_after_operations(5, [3, 2, 5, 1, 4]) 0 >>> minimize_sum_after_operations(4, [-1, -2, -3, -4]) -10","solution":"def minimize_sum_after_operations(n, arr): Minimize the sum of the array after recursively performing removal of max elements. Parameters: n (int): Number of elements in the array. arr (list of int): List of integers representing the array. Returns: int: Minimized sum of the remaining elements. # Since removing maximum elements of any arbitrary subarray doesn't change the order # and only affects the individual computation on the original array, we can directly # find the sum of non-positive elements in the array which represents the smallest # feasible sum. minimized_sum = sum(x for x in arr if x <= 0) return minimized_sum"},{"question":"def calculate_ranks(n: int, m: int, scores: List[Tuple[int, int]]) -> List[List[int]]: Calculate the rank of each participant after each round. Args: n (int): Number of participants. m (int): Number of rounds. scores (list of tuples): List of tuples where each tuple contains participant ID and their score for the round. Returns: List of lists where each list represents the ranks of participants after each round. >>> n = 5 >>> m = 3 >>> scores = [(1, 10), (2, 5), (3, 7), (1, 3), (2, 8), (4, 6), (1, 5), (2, 2), (3, 3)] >>> calculate_ranks(n, m, scores) [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 3, 2, 4, 5]] >>> n = 4 >>> m = 2 >>> scores = [(1, 5), (2, 5), (3, 5), (4, 5), (3, 2), (4, 1)] >>> calculate_ranks(n, m, scores) [[1, 2, 3, 4], [1, 2, 3, 4]] >>> n = 3 >>> m = 3 >>> scores = [(1, 5), (2, 5), (1, 3), (2, 3), (3, 2), (3, 5)] >>> calculate_ranks(n, m, scores) [[1, 2, 3], [1, 2, 3], [1, 2, 3]] >>> n = 4 >>> m = 2 >>> scores = [(1, 10), (2, 10), (2, 5)] >>> calculate_ranks(n, m, scores) [[1, 2, 3, 4], [1, 2, 3, 4]] >>> n = 2 >>> m = 2 >>> scores = [(1, 5), (1, 5), (2, 5)] >>> calculate_ranks(n, m, scores) [[1, 2], [1, 2]]","solution":"def calculate_ranks(n, m, scores): Calculate the rank of each participant after each round. Args: n (int): Number of participants. m (int): Number of rounds. scores (list of tuples): List of tuples where each tuple contains participant ID and their score for the round. Returns: List of lists where each list represents the ranks of participants after each round. participants_scores = [0] * n result = [] for i in range(m): p, s = scores[i] participants_scores[p - 1] += s # Sort participants based on score and participant ID sorted_participants = sorted( range(n), key=lambda x: (-participants_scores[x], x) ) # Transform sorted indexes to ranks current_ranks = [sorted_participants.index(i) + 1 for i in range(n)] result.append(current_ranks) return result"},{"question":"def count_ways_to_prepare_dishes(n: int) -> int: Returns the number of distinct ways to prepare exactly n dishes following the Fibonacci sequence rule. >>> count_ways_to_prepare_dishes(1) 1 >>> count_ways_to_prepare_dishes(5) 8 >>> count_ways_to_prepare_dishes(6) 13 >>> count_ways_to_prepare_dishes(20) 10946 >>> count_ways_to_prepare_dishes(50) 20365011074","solution":"def count_ways_to_prepare_dishes(n): Returns the number of distinct ways to prepare exactly n dishes following the Fibonacci sequence rule. # Dynamic programming table to store ways to prepare dishes dp = [0] * (n + 1) # There is one way to prepare zero dishes (base case) dp[0] = 1 # Fill dp[] in bottom-up manner for i in range(1, n + 1): if i >= 1: dp[i] += dp[i - 1] if i >= 2: dp[i] += dp[i - 2] return dp[n]"},{"question":"def is_palindrome(S: str) -> bool: Determines if a given string (phrase) is a palindrome. :param S: A single line string :return: True if the string is a palindrome, False otherwise Examples: >>> is_palindrome(\\"A man a plan a canal Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"No lemon, no melon\\") True","solution":"def is_palindrome(S: str) -> bool: Determines if a given string (phrase) is a palindrome. :param S: A single line string :return: True if the string is a palindrome, False otherwise # Normalize the string: convert to lowercase and remove non-alphanumeric characters. normalized_str = ''.join(char.lower() for char in S if char.isalnum()) # Check if the normalized string is equal to its reverse. return normalized_str == normalized_str[::-1]"},{"question":"def num_distinct_fertile_patches(n: int, m: int, field: List[List[str]]) -> int: Calculate the number of distinct fertile patches in the field. Args: n: Number of rows in the field. m: Number of columns in the field. field: Grid representation of the field where '1' represents fertile and '0' represents barren. Returns: An integer representing the number of distinct fertile patches. >>> num_distinct_fertile_patches(3, 4, [ ... ['1', '1', '0', '0'], ... ['0', '0', '1', '0'], ... ['0', '1', '1', '1'] ... ]) == 2 >>> num_distinct_fertile_patches(4, 4, [ ... ['1', '0', '1', '0'], ... ['0', '1', '0', '1'], ... ['1', '0', '1', '0'], ... ['0', '1', '0', '1'] ... ]) == 8 >>> num_distinct_fertile_patches(3, 4, [ ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'], ... ['0', '0', '0', '0'] ... ]) == 0 >>> num_distinct_fertile_patches(2, 2, [ ... ['1', '1'], ... ['1', '1'] ... ]) == 1 >>> num_distinct_fertile_patches(5, 5, [ ... ['1', '0', '0', '0', '1'], ... ['0', '0', '1', '0', '0'], ... ['0', '1', '1', '1', '0'], ... ['0', '0', '1', '0', '0'], ... ['1', '0', '0', '0', '1'] ... ]) == 5","solution":"def num_distinct_fertile_patches(n, m, field): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or field[x][y] == '0': return field[x][y] = '0' dfs(x - 1, y) dfs(x + 1, y) dfs(x, y - 1) dfs(x, y + 1) patches_count = 0 for i in range(n): for j in range(m): if field[i][j] == '1': dfs(i, j) patches_count += 1 return patches_count"},{"question":"def max_height_difference(grid): Calculates the maximum height difference between any two leaves in a grid. Parameters: grid (list of list of int): 2D grid representing the heights of leaves. Returns: int: Maximum height difference. max_height = float('-inf') min_height = float('inf') for row in grid: for height in row: if height > max_height: max_height = height if height < min_height: min_height = height return max_height - min_height def read_input(input_str): Reads the input string and converts it to a grid of heights. Parameters: input_str (str): Multiline string with input data. Returns: list of list of int: 2D grid of heights. lines = input_str.strip().split('n') M, N = map(int, lines[0].split()) grid = [list(map(int, lines[i + 1].split())) for i in range(M)] return grid def main(input_str): grid = read_input(input_str) return max_height_difference(grid) def test_max_height_difference(): input_str = 3 3 1 2 3 4 5 6 7 8 9 expected_output = 8 assert main(input_str) == expected_output def test_single_row(): input_str = 1 5 1 4 7 2 3 expected_output = 6 assert main(input_str) == expected_output def test_single_column(): input_str = 5 1 3 4 5 2 1 expected_output = 4 assert main(input_str) == expected_output def test_small_grid(): input_str = 2 2 0 10 10 0 expected_output = 10 assert main(input_str) == expected_output def test_large_height_difference(): input_str = 3 3 1000 200 300 400 500 600 700 800 900 expected_output = 800 assert main(input_str) == expected_output","solution":"def max_height_difference(grid): Calculates the maximum height difference between any two leaves in a grid. Parameters: grid (list of list of int): 2D grid representing the heights of leaves. Returns: int: Maximum height difference. max_height = float('-inf') min_height = float('inf') for row in grid: for height in row: if height > max_height: max_height = height if height < min_height: min_height = height return max_height - min_height def read_input(input_str): Reads the input string and converts it to a grid of heights. Parameters: input_str (str): Multiline string with input data. Returns: list of list of int: 2D grid of heights. lines = input_str.strip().split('n') M, N = map(int, lines[0].split()) grid = [list(map(int, lines[i + 1].split())) for i in range(M)] return grid def main(input_str): grid = read_input(input_str) return max_height_difference(grid)"},{"question":"def level_order_traversal(binary_tree_str: str) -> str: Given the string representation of a binary tree in level-order (breadth-first) form, return the same string as a space-separated sequence. >>> level_order_traversal(\\"110100\\") '1 1 0 1 0 0' >>> level_order_traversal(\\"100\\") '1 0 0' >>> level_order_traversal(\\"1\\") '1'","solution":"def level_order_traversal(binary_tree_str): Given the string representation of a binary tree in level-order (breadth-first) form, returns the same string as a space-separated sequence. # Since the input string is already in level-order, # we simply return it as a space-separated sequence of characters. return ' '.join(binary_tree_str)"},{"question":"def min_palindrome_cuts(n: int, s: str) -> int: Return the minimum number of cuts needed to split the string into palindrome substrings. >>> min_palindrome_cuts(4, \\"abba\\") 0 >>> min_palindrome_cuts(5, \\"abcba\\") 0 >>> min_palindrome_cuts(3, \\"abc\\") 2 >>> min_palindrome_cuts(6, \\"abacbc\\") 1 pass # Test cases def test_min_palindrome_cuts(): assert min_palindrome_cuts(4, \\"abba\\") == 0 assert min_palindrome_cuts(5, \\"abcba\\") == 0 assert min_palindrome_cuts(3, \\"abc\\") == 2 assert min_palindrome_cuts(6, \\"abacbc\\") == 1 assert min_palindrome_cuts(1, \\"a\\") == 0 assert min_palindrome_cuts(2, \\"aa\\") == 0 assert min_palindrome_cuts(2, \\"ab\\") == 1 assert min_palindrome_cuts(7, \\"racecar\\") == 0 assert min_palindrome_cuts(8, \\"abcddcba\\") == 0 assert min_palindrome_cuts(6, \\"abccba\\") == 0","solution":"def min_palindrome_cuts(n, s): if n == 0: return 0 is_palindrome = [[False] * n for _ in range(n)] for i in range(n): is_palindrome[i][i] = True for length in range(2, n + 1): for start in range(n - length + 1): end = start + length - 1 if s[start] == s[end]: if length == 2: is_palindrome[start][end] = True else: is_palindrome[start][end] = is_palindrome[start + 1][end - 1] cuts = [0] * n for i in range(n): if is_palindrome[0][i]: cuts[i] = 0 else: cuts[i] = float('inf') for j in range(i): if is_palindrome[j + 1][i]: cuts[i] = min(cuts[i], cuts[j] + 1) return cuts[-1]"},{"question":"def highest_fitness_scores(test_cases): Returns a list of highest total fitness scores for each test case. >>> sample_input = \\"2n3 3n10 5 7n4 8 6n2 3 9n2 4n1 2 3 4n4 3 2 1n\\" >>> expected_output = [22, 10] >>> test_cases = parse_input(sample_input) >>> highest_fitness_scores(test_cases) [22, 10] >>> input_data = \\"1n1 1n5n\\" >>> expected_output = [5] >>> test_cases = parse_input(input_data) >>> highest_fitness_scores(test_cases) [5] >>> input_data = \\"1n2 3n1 2 3n4 5 6n\\" >>> expected_output = [15] >>> test_cases = parse_input(input_data) >>> highest_fitness_scores(test_cases) [15] >>> input_data = \\"1n3 3n0 0 0n0 0 0n0 0 0n\\" >>> expected_output = [0] >>> test_cases = parse_input(input_data) >>> highest_fitness_scores(test_cases) [0] >>> input_data = \\"1n2 2n1000 1000n999 1001n\\" >>> expected_output = [2000] >>> test_cases = parse_input(input_data) >>> highest_fitness_scores(test_cases) [2000] def parse_input(input_string): Parses input string to extract test cases.","solution":"def highest_fitness_scores(test_cases): Returns a list of highest total fitness scores for each test case. results = [] for case in test_cases: N, M = case['N'], case['M'] scores = case['scores'] highest_score = max([sum(participant) for participant in scores]) results.append(highest_score) return results def parse_input(input_string): data = input_string.strip().split(\\"n\\") t = int(data[0]) index = 1 test_cases = [] for _ in range(t): N, M = map(int, data[index].split()) index += 1 scores = [] for _ in range(N): scores.append(list(map(int, data[index].split()))) index += 1 test_cases.append({'N': N, 'M': M, 'scores': scores}) return test_cases"},{"question":"def find_top_donor(donors: List[str], donations: List[str]) -> str: Calculate the total donation made by each donor over a given period and determine the top donor of the period. Args: donors: List containing the names of the donors donations: List containing the donations in the format \\"WeekX DonorName Amount\\" Returns: The name of the top donor. If no donations are made, returns \\"No donations\\". Examples: >>> find_top_donor([\\"ALICE\\", \\"BOB\\", \\"CHARLIE\\"], [\\"Week1 ALICE 500\\", \\"Week2 BOB 300\\", \\"Week3 ALICE 200\\", \\"Week4 CHARLIE 700\\", \\"Week5 ALICE 100\\"]) \\"ALICE\\" >>> find_top_donor([\\"DAVID\\", \\"EMMA\\"], [\\"Week1 DAVID 100\\", \\"Week2 EMMA 200\\", \\"Week3 DAVID 200\\", \\"Week4 EMMA 100\\"]) \\"DAVID\\" >>> find_top_donor([\\"MIKE\\"], []) \\"No donations\\"","solution":"def find_top_donor(donors, donations): if not donations: return \\"No donations\\" donation_sums = {donor: 0 for donor in donors} for donation in donations: week, donor_name, amount = donation.split() amount = int(amount) if donor_name in donation_sums: donation_sums[donor_name] += amount top_donor = None max_donations = -1 for donor in donors: if donation_sums[donor] > max_donations: max_donations = donation_sums[donor] top_donor = donor return top_donor if max_donations > 0 else \\"No donations\\""},{"question":"def calculate_ingredients(): Calculate the total quantity required for each ingredient based on the different pie recipes John wants to make. The function takes no input but reads directly from the standard input as described in the problem statement. >>> import sys >>> from io import StringIO >>> input_data = '2napplepien3napple 4nflour 2nsugar 1nblueberrypien2nblueberry 5nsugar 2n3napplepienapplepienblueberrypie' >>> sys.stdin = StringIO(input_data) >>> calculate_ingredients() apple 8nblueberry 5nflour 4nsugar 4n >>> input_data = '1ncherrypien2ncherry 3nsugar 2n1ncherrypie' >>> sys.stdin = StringIO(input_data) >>> calculate_ingredients() cherry 3nsugar 2n","solution":"def calculate_ingredients(): import sys input = sys.stdin.read data = input().splitlines() n = int(data[0]) recipes = {} index = 1 for _ in range(n): pie_name = data[index] m = int(data[index + 1]) ingredients = {} for j in range(m): ingredient_name, quantity = data[index + 2 + j].split() ingredients[ingredient_name] = int(quantity) recipes[pie_name] = ingredients index += 2 + m k = int(data[index]) pies_to_bake = data[index + 1:index + 1 + k] total_ingredients = {} for pie in pies_to_bake: if pie in recipes: for ingredient, quantity in recipes[pie].items(): if ingredient in total_ingredients: total_ingredients[ingredient] += quantity else: total_ingredients[ingredient] = quantity for ingredient in sorted(total_ingredients.keys()): print(f\\"{ingredient} {total_ingredients[ingredient]}\\")"},{"question":"def count_website_visits(records): Reads a list of website visit records and outputs the total number of visits for each website. >>> count_website_visits([\\"google.com 1000\\"]) {\\"google.com\\": 1000} >>> count_website_visits([ \\"google.com 1000\\", \\"yahoo.com 300\\", \\"google.com 500\\", \\"github.com 450\\", \\"yahoo.com 200\\" ]) {\\"google.com\\": 1500, \\"yahoo.com\\": 500, \\"github.com\\": 450} >>> count_website_visits([]) {}","solution":"def count_website_visits(records): Returns the total number of visits for each unique website URL. visit_counts = {} for record in records: url, visits = record.split() visits = int(visits) if url in visit_counts: visit_counts[url] += visits else: visit_counts[url] = visits return visit_counts"},{"question":"def max_knights(R, C): Returns the maximum number of knights that can be placed on a R x C chessboard without any two knights threatening each other. pass def solve(test_cases): pass def main(): pass # Unit test def test_max_knights(): assert max_knights(1, 1) == 1 assert max_knights(2, 2) == 2 assert max_knights(3, 3) == 5 assert max_knights(1, 10) == 10 assert max_knights(2, 4) == 4 assert max_knights(4, 2) == 4 assert max_knights(5, 5) == 13 assert max_knights(8, 8) == 32 def test_solve(): test_cases = [(1, 1), (2, 2), (3, 3)] expected = [1, 2, 5] assert solve(test_cases) == expected test_cases = [(1, 10), (2, 4), (5, 5), (8, 8)] expected = [10, 4, 13, 32] assert solve(test_cases) == expected # Example usage if __name__ == \\"__main__\\": main()","solution":"def max_knights(R, C): Returns the maximum number of knights that can be placed on a R x C chessboard without any two knights threatening each other. if R == 1 or C == 1: return R * C if R == 2 or C == 2: return (R * C + 1) // 2 return (R * C + 1) // 2 def solve(test_cases): results = [] for R, C in test_cases: results.append(max_knights(R, C)) return results # Reading and processing input def main(): T = int(input()) test_cases = [] for _ in range(T): R, C = map(int, input().split()) test_cases.append((R, C)) results = solve(test_cases) for result in results: print(result)"},{"question":"def minimum_travel_time(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the minimum total travel time required to ensure that all towns are reachable from the capital. Parameters: n (int): The number of towns. m (int): The number of roads. roads (List[Tuple[int, int, int]]): A list of tuples representing each road where each tuple contains three integers xi, yi, ti. Returns: int: The minimum total travel time. Example: >>> minimum_travel_time(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 2), (1, 3, 2), (1, 4, 3)]) 5 Unit Tests: import pytest from solution import minimum_travel_time def test_minimum_travel_time_example(): n = 4 m = 5 roads = [ (1, 2, 1), (2, 3, 2), (3, 4, 2), (1, 3, 2), (1, 4, 3) ] assert minimum_travel_time(n, m, roads) == 5 def test_minimum_travel_time_single_road(): n = 2 m = 1 roads = [ (1, 2, 3) ] assert minimum_travel_time(n, m, roads) == 3 def test_minimum_travel_time_multiple_roads(): n = 3 m = 3 roads = [ (1, 2, 1), (2, 3, 1), (1, 3, 3) ] assert minimum_travel_time(n, m, roads) == 2 def test_minimum_travel_time_uneven(): n = 5 m = 6 roads = [ (1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 3), (3, 4, 2), (3, 5, 3) ] assert minimum_travel_time(n, m, roads) == 8 def test_minimum_travel_time_large_weights(): n = 4 m = 4 roads = [ (1, 2, 1000000000), (2, 3, 1000000000), (3, 4, 1000000000), (1, 4, 1000000000) ] assert minimum_travel_time(n, m, roads) == 3000000000 pass","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: x, y, t = edges[i] i = i + 1 xroot = find(parent, x - 1) yroot = find(parent, y - 1) if xroot != yroot: e = e + 1 result.append((x, y, t)) union(parent, rank, xroot, yroot) minimum_travel_time = sum([t for _, _, t in result]) return minimum_travel_time def minimum_travel_time(n, m, roads): return kruskal(n, roads)"},{"question":"def optimum_charging_point(n: int, positions: List[int]) -> int: Finds the optimum charging point that minimizes the total sum of distances from all cars. :param n: Number of cars :param positions: List of positions of the cars :return: The optimal position for the charging station >>> optimum_charging_point(3, [1, 3, 6]) 3 >>> optimum_charging_point(5, [-1, 2, 4, 6, 8]) 4 (or 6)","solution":"def optimum_charging_point(n, positions): Finds the optimum charging point that minimizes the total sum of distances from all cars. :param n: Number of cars :param positions: List of positions of the cars :return: The optimal position for the charging station sorted_positions = sorted(positions) return sorted_positions[(n - 1) // 2]"},{"question":"def min_fountains_to_cover_park(fountain_list): Determine the minimum number of fountains needed to cover the entire park. Args: - fountain_list (List[Tuple[int, int]]): A list where each element is a tuple (position, radius) representing the position and radius of a fountain. Returns: - int: The minimum number of fountains needed to cover the entire park. def process_input(input_data): Process the input data for multiple datasets, and for each dataset, determine the minimum number of fountains needed to cover the park. Args: - input_data (str): A string containing the input for multiple datasets. Returns: - List[int]: A list containing the minimum number of fountains needed for each dataset. >>> process_input(\\"4n1 2n3 2n7 4n10 1n0n\\") [2] >>> process_input(\\"5n1 1n2 2n4 1n5 1n6 1n0n\\") [3] >>> process_input(\\"0n\\") []","solution":"def min_fountains_to_cover_park(fountain_list): n = len(fountain_list) intervals = [] for (p, r) in fountain_list: intervals.append((p - r, p + r)) intervals.sort() idx = 0 min_fountains = 0 max_covered = 0 while max_covered < max(p + r for p, r in fountain_list): can_extend = False max_cover_in_this_step = max_covered while idx < n and intervals[idx][0] <= max_covered: max_cover_in_this_step = max(max_cover_in_this_step, intervals[idx][1]) idx += 1 can_extend = True if not can_extend: return float('inf') # Not possible to cover min_fountains += 1 max_covered = max_cover_in_this_step return min_fountains def process_input(input_data): datasets = input_data.strip().split(\\"n\\") output = [] i = 0 while i < len(datasets): n = int(datasets[i]) if n == 0: break fountain_list = [] i += 1 for _ in range(n): p, r = map(int, datasets[i].split()) fountain_list.append((p, r)) i += 1 output.append(min_fountains_to_cover_park(fountain_list)) return output"},{"question":"from typing import List def maxSumSubgrid(grid: List[List[int]]) -> int: Find the largest sum of any contiguous subgrid within the given grid. >>> grid = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ] >>> maxSumSubgrid(grid) 29 >>> grid = [ ... [-1, -1], ... [-1, -1] ... ] >>> maxSumSubgrid(grid) -1 pass def test_single_element(): grid = [[5]] assert maxSumSubgrid(grid) == 5 def test_all_negative_elements(): grid = [ [-1, -2], [-3, -4] ] assert maxSumSubgrid(grid) == -1 def test_mixed_elements(): grid = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] assert maxSumSubgrid(grid) == 29 def test_another_mixed_elements(): grid = [ [-1, -1], [-1, -1] ] assert maxSumSubgrid(grid) == -1 def test_positive_elements(): grid = [ [1, 2], [3, 4] ] assert maxSumSubgrid(grid) == 10","solution":"def maxSumSubgrid(grid): def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far n = len(grid) max_sum = float('-inf') for top in range(n): temp = [0] * n for bottom in range(top, n): for i in range(n): temp[i] += grid[bottom][i] # Use Kadane's algorithm on temp array max_sum = max(max_sum, kadane(temp)) return max_sum"},{"question":"from typing import List, Tuple def process_queries(n: int, q: int, sequence: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process a list of queries on a sequence of integers. The queries can either update the value at a specific index or calculate the sum of a range of values in the sequence. Args: n (int): Number of elements in the sequence. q (int): Number of queries. sequence (List[int]): The initial sequence of integers. queries (List[Tuple[int, int, int]]): List of queries to be processed. Each query is a tuple where: - (1, x, y): Update the value at index x to y. - (2, l, r): Calculate the sum of values from index l to r (inclusive). Returns: List[int]: The results of the sum queries. >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 6), (2, 2, 4)]) [6, 13] >>> process_queries(6, 3, [10, 20, 30, 40, 50, 60], [(2, 1, 3), (2, 4, 6), (2, 2, 5)]) [60, 150, 140]","solution":"def process_queries(n, q, sequence, queries): output = [] for query in queries: if query[0] == 1: _, index, new_value = query sequence[index - 1] = new_value elif query[0] == 2: _, left, right = query result = sum(sequence[left - 1:right]) output.append(result) return output"},{"question":"def max_blocks_for_tower(n: int, heights: List[int]) -> int: Determines the maximum number of blocks that can be used to build a tower following the rule that each block on top must be strictly greater than the block immediately below it. Parameters: n (int): the number of blocks available. heights (list): a list of integers indicating the height of each block. Returns: int: the maximum number of blocks that can be used. Examples: >>> max_blocks_for_tower(6, [3, 4, 5, 1, 2, 6]) 6 >>> max_blocks_for_tower(4, [10, 20, 30, 40]) 4 >>> max_blocks_for_tower(5, [5, 5, 5, 5, 5]) 1 >>> max_blocks_for_tower(0, []) 0 >>> max_blocks_for_tower(1, [7]) 1 >>> max_blocks_for_tower(3, [100, 200, 1000000000]) 3 >>> max_blocks_for_tower(7, [1, 2, 2, 3, 3, 4, 5]) 5","solution":"def max_blocks_for_tower(n, heights): Determines the maximum number of blocks that can be used to build a tower following the rule that each block on top must be strictly greater than the block immediately below it. Parameters: n (int): the number of blocks available. heights (list): a list of integers indicating the height of each block. Returns: int: the maximum number of blocks that can be used. if n == 0: return 0 # Sort the blocks in ascending order to easily build the tallest tower. heights.sort() # Initialize the count with 1 as we can always use at least one block. count = 1 # Compare each block with the previous block to count maximum increasing sequence. for i in range(1, n): if heights[i] > heights[i - 1]: count += 1 return count"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(inorder, postorder): if not inorder or not postorder: return None root_val = postorder.pop() root = TreeNode(root_val) inorder_index = inorder.index(root_val) root.right = build_tree(inorder[inorder_index+1:], postorder) root.left = build_tree(inorder[:inorder_index], postorder) return root def preorder_traversal(root): if root is None: return [] return [root.value] + preorder_traversal(root.left) + preorder_traversal(root.right) def reconstruct_tree_and_print_preorder(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] inorder = test_cases[i][1] postorder = test_cases[i][2] root = build_tree(inorder, postorder) preorder = preorder_traversal(root) results.append(preorder) return results # Add some tests to validate the implementation def test_reconstruct_tree_and_print_preorder_case1(): t = 2 test_cases = [ (6, [4, 2, 5, 1, 6, 3], [4, 5, 2, 6, 3, 1]), (3, [3, 2, 1], [3, 2, 1]) ] expected = [ [1, 2, 4, 5, 3, 6], [1, 2, 3] ] result = reconstruct_tree_and_print_preorder(t, test_cases) assert result == expected def test_reconstruct_tree_and_print_preorder_case2(): t = 1 test_cases = [ (7, [4, 2, 5, 1, 6, 3, 7], [4, 5, 2, 6, 7, 3, 1]) ] expected = [ [1, 2, 4, 5, 3, 6, 7] ] result = reconstruct_tree_and_print_preorder(t, test_cases) assert result == expected def test_reconstruct_tree_and_print_preorder_case3(): t = 1 test_cases = [ (5, [9, 3, 15, 20, 7], [9, 15, 7, 20, 3]) ] expected = [ [3, 9, 20, 15, 7] ] result = reconstruct_tree_and_print_preorder(t, test_cases) assert result == expected def test_reconstruct_tree_and_print_preorder_empty_tree(): t = 1 test_cases = [ (0, [], []) ] expected = [ [] ] result = reconstruct_tree_and_print_preorder(t, test_cases) assert result == expected","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(inorder, postorder): if not inorder or not postorder: return None root_val = postorder.pop() root = TreeNode(root_val) inorder_index = inorder.index(root_val) root.right = build_tree(inorder[inorder_index+1:], postorder) root.left = build_tree(inorder[:inorder_index], postorder) return root def preorder_traversal(root): if root is None: return [] return [root.value] + preorder_traversal(root.left) + preorder_traversal(root.right) def reconstruct_tree_and_print_preorder(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] inorder = test_cases[i][1] postorder = test_cases[i][2] root = build_tree(inorder, postorder) preorder = preorder_traversal(root) results.append(preorder) return results"},{"question":"def is_rearrangement_possible(N: int, D: int, A: List[int]) -> str: Determines whether it's possible to rearrange list A such that the difference between any two adjacent elements is not greater than D. Parameters: N (int): The number of elements in the list. D (int): The maximum allowed difference between any two adjacent elements. A (list of int): The list of integers. Returns: str: 'Possible' if rearrangement is possible, 'Impossible' otherwise. >>> is_rearrangement_possible(5, 3, [1, 5, 3, 8, 5]) 'Possible' >>> is_rearrangement_possible(4, 1, [1, 5, 3, 8]) 'Impossible'","solution":"def is_rearrangement_possible(N, D, A): Determines whether it's possible to rearrange list A such that the difference between any two adjacent elements is not greater than D. Parameters: N (int): The number of elements in the list. D (int): The maximum allowed difference between any two adjacent elements. A (list of int): The list of integers. Returns: str: 'Possible' if rearrangement is possible, 'Impossible' otherwise. A.sort() for i in range(1, N): if A[i] - A[i-1] > D: return 'Impossible' return 'Possible'"},{"question":"def fair_candy_distribution(candies: List[int], special: int) -> int: Given a list of integers representing the number of candies each child picked from a basket, compute the maximum number of candies each child can fairly get after removing the candies with the special ingredient. Parameters: candies (List[int]): A list of integers where each integer is the number of candies a child picked. special (int): An integer representing the special ingredient in some candies. Returns: int: The maximum number of candies each child can get after distribution. Examples: >>> fair_candy_distribution([2, 3, 5, 7, 5, 3], 2) 3 >>> fair_candy_distribution([2, 3, 5, 7, 5, 3], 8) 4 >>> fair_candy_distribution([2, 2, 2, 2], 2) 0 >>> fair_candy_distribution([], 2) 0 >>> fair_candy_distribution([5], 2) 5 >>> fair_candy_distribution([0, 0, 0], 0) 0 >>> fair_candy_distribution([0, 5, 10], 0) 5","solution":"def fair_candy_distribution(candies, special): Returns the maximum number of candies each child can get after removing the candies with the special ingredient. # Remove candies with the special ingredient remaining_candies = [candy for candy in candies if candy != special] # Calculate the sum of the remaining candies total_candies = sum(remaining_candies) # Number of children num_children = len(candies) # Calculate the maximum number of candies each child can get if num_children == 0: return 0 max_candies_per_child = total_candies // num_children return max_candies_per_child"},{"question":"def solve(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Function to solve the problem of updating the weights of edges in a tree and finding the maximum weight between nodes. The function takes three inputs: - n: the number of nodes in the tree - edges: a list of tuples, where each tuple contains three integers (u, v, w), representing an edge between nodes u and v with weight w - queries: a list of tuples, where each tuple contains four integers (type, a, b, c). Type 1 means an update of the edge weight, and type 2 means a query to find the maximum weight on the path between nodes a and b It returns a list of integers where each integer corresponds to the result of a query of type 2. Example: >>> solve(5, [(1, 2, 3), (1, 3, 4), (2, 4, 2), (2, 5, 6)], [(2, 2, 5, 0), (1, 2, 4, 1), (2, 2, 5, 0)]) [6, 6] >>> solve(3, [(1, 2, 5), (2, 3, 10)], [(2, 1, 3, 0), (1, 1, 2, 3), (2, 1, 3, 0), (1, 2, 3, 1), (2, 1, 3, 0)]) [10, 10, 3] >>> solve(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1)], []) [] >>> solve(6, [(1, 2, 1), (2, 3, 2), (1, 4, 3), (4, 5, 4), (5, 6, 5)], [(2, 2, 5, 0), (1, 4, 5, 10), (2, 2, 5, 0)]) [4, 10]","solution":"import sys import collections class Tree: def __init__(self, n): self.n = n self.graph = collections.defaultdict(list) self.parent = [-1] * (n + 1) self.depth = [-1] * (n + 1) self.max_edge = [-1] * (n + 1) self.edge_weights = collections.defaultdict(dict) self.LOG = 20 self.binary_ancestor = [[-1] * self.LOG for _ in range(n + 1)] self.binary_max = [[-1] * self.LOG for _ in range(n + 1)] def add_edge(self, u, v, w): self.graph[u].append((v, w)) self.graph[v].append((u, w)) self.edge_weights[u][v] = w self.edge_weights[v][u] = w def dfs(self, u, p, d, max_w): self.parent[u] = p self.depth[u] = d self.max_edge[u] = max_w for v, w in self.graph[u]: if v == p: continue self.binary_max[v][0] = w self.binary_ancestor[v][0] = u self.dfs(v, u, d + 1, w) def preprocess_ancestors(self): for i in range(1, self.LOG): for node in range(1, self.n + 1): if self.binary_ancestor[node][i - 1] != -1: p = self.binary_ancestor[node][i - 1] self.binary_ancestor[node][i] = self.binary_ancestor[p][i - 1] self.binary_max[node][i] = max(self.binary_max[node][i - 1], self.binary_max[p][i - 1]) def max_weight_path(self, u, v): if self.depth[u] < self.depth[v]: u, v = v, u max_w = -1 diff = self.depth[u] - self.depth[v] for i in range(self.LOG): if diff & (1 << i): max_w = max(max_w, self.binary_max[u][i]) u = self.binary_ancestor[u][i] if u == v: return max_w for i in reversed(range(self.LOG)): if self.binary_ancestor[u][i] != self.binary_ancestor[v][i]: max_w = max(max_w, self.binary_max[u][i], self.binary_max[v][i]) u = self.binary_ancestor[u][i] v = self.binary_ancestor[v][i] max_w = max(max_w, self.binary_max[u][0], self.binary_max[v][0]) return max_w def update_edge(self, u, v, new_w): old_w = self.edge_weights[u][v] if u in self.edge_weights and v in self.edge_weights[u]: self.edge_weights[u][v] = new_w self.edge_weights[v][u] = new_w else: return if self.depth[u] < self.depth[v]: u, v = v, u binary_child = [self.binary_ancestor[u][0]] self.binary_max[u][0] = new_w for i in range(1, self.LOG): if self.binary_ancestor[u][i - 1] != -1: p = self.binary_ancestor[u][i - 1] self.binary_ancestor[u][i] = self.binary_ancestor[p][i - 1] self.binary_max[u][i] = max(self.binary_max[u][i - 1], self.binary_max[p][i - 1]) def solve(n, edges, queries): tree = Tree(n) for u, v, w in edges: tree.add_edge(u, v, w) tree.dfs(1, -1, 0, -1) tree.preprocess_ancestors() results = [] for query in queries: type_, a, b, c = query if type_ == 1: tree.update_edge(a, b, c) elif type_ == 2: result = tree.max_weight_path(a, b) results.append(result) return results"},{"question":"def max_num_parcels(n: int, W: int, parcels: List[Tuple[int, int, int]]) -> int: Returns the maximum number of parcels that can be delivered without exceeding the weight capacity of the van, prioritizing the parcels with the highest destination scores. Args: n (int): Number of parcels W (int): Weight capacity of the van parcels (list of tuples): Each tuple contains three integers representing the weight, destination score, and priority score of a parcel. Returns: int: Maximum number of parcels that can be delivered. >>> max_num_parcels(5, 100, [ (20, 50, 10), (30, 30, 20), (40, 40, 30), (10, 60, 40), (80, 20, 50) ]) 4 >>> max_num_parcels(1, 100, [(50, 50, 10)]) 1 >>> max_num_parcels(1, 10, [(50, 50, 10)]) 0 >>> max_num_parcels(3, 100, [ (20, 50, 10), (30, 40, 20), (40, 30, 30) ]) 3 >>> max_num_parcels(3, 10, [ (20, 50, 10), (30, 40, 20), (40, 30, 30) ]) 0 >>> max_num_parcels(4, 50, [ (20, 50, 10), (10, 50, 20), (30, 30, 30), (40, 50, 40) ]) 2","solution":"def max_num_parcels(n, W, parcels): Returns the maximum number of parcels that can be delivered without exceeding the weight capacity of the van, prioritizing the parcels with the highest destination scores. Args: n (int): Number of parcels W (int): Weight capacity of the van parcels (list of tuples): Each tuple contains three integers representing the weight, destination score, and priority score of a parcel. Returns: int: Maximum number of parcels that can be delivered. # Sort parcels by destination score and then by weight parcels.sort(key=lambda x: (-x[1], x[0])) current_weight = 0 num_parcels = 0 for weight, dest_score, priority in parcels: if current_weight + weight <= W: current_weight += weight num_parcels += 1 else: break return num_parcels"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring with at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"aa\\") 2 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring with at most two distinct characters. if not s: return 0 left = 0 max_len = 0 char_map = {} for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def minimize_absolute_difference(t, test_cases): Help Yuki arrange the players in an order that minimizes the total absolute difference. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing the number of players and a list of favorite numbers. Returns: List[List[int]]: A list of lists where each inner list represents the favorite numbers of the players in the order that minimizes the total absolute difference. >>> minimize_absolute_difference(3, [(3, [1, 3, 2]), (4, [4, 1, 2, 3]), (5, [8, 5, 2, 6, 3])]) [[1, 2, 3], [1, 2, 3, 4], [2, 3, 5, 6, 8]] >>> minimize_absolute_difference(1, [(2, [10, 1])]) [[1, 10]] pass","solution":"def minimize_absolute_difference(t, test_cases): This function takes the number of test cases and a list of test cases, where each test case is a tuple containing the number of players and a list of favorite numbers, and returns a list of lists where each list contains the player's favorite numbers ordered to minimize the total absolute difference. results = [] for case in test_cases: n, favorite_numbers = case sorted_favorites = sorted(favorite_numbers) results.append(sorted_favorites) return results"},{"question":"def longest_path_of_1s(N: int, M: int, matrix: List[List[int]]) -> int: Determine the length of the longest path of connected 1s in a binary matrix. N: Number of rows in the binary matrix. M: Number of columns in the binary matrix. matrix: A binary matrix of 0s and 1s. >>> longest_path_of_1s(4, 5, [ ... [0, 1, 0, 0, 1], ... [1, 1, 0, 1, 1], ... [0, 1, 1, 0, 0], ... [1, 0, 0, 1, 1] ... ]) == 5 >>> longest_path_of_1s(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 pass # Test cases from solution import longest_path_of_1s def test_example_1(): assert longest_path_of_1s(4, 5, [ [0, 1, 0, 0, 1], [1, 1, 0, 1, 1], [0, 1, 1, 0, 0], [1, 0, 0, 1, 1] ]) == 5 def test_example_2(): assert longest_path_of_1s(3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) == 1 def test_all_zeros(): assert longest_path_of_1s(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 def test_large_single_path(): assert longest_path_of_1s(2, 3, [ [1, 1, 1], [0, 1, 0] ]) == 4 def test_multiple_paths(): assert longest_path_of_1s(3, 3, [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ]) == 1 def test_connected_paths(): assert longest_path_of_1s(3, 4, [ [1, 1, 0, 1], [0, 1, 0, 1], [1, 0, 0, 1] ]) == 3","solution":"def longest_path_of_1s(N, M, matrix): def dfs(x, y): if x < 0 or x >= N or y < 0 or y >= M or matrix[x][y] == 0: return 0 # Mark the cell as visited by setting it to 0 matrix[x][y] = 0 # Recursive DFS in 4 possible directions length = 1 length += dfs(x + 1, y) length += dfs(x - 1, y) length += dfs(x, y + 1) length += dfs(x, y - 1) return length max_path_length = 0 for i in range(N): for j in range(M): if matrix[i][j] == 1: current_path_length = dfs(i, j) max_path_length = max(max_path_length, current_path_length) return max_path_length if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) matrix = [] index = 2 for i in range(N): row = [] for j in range(M): row.append(int(data[index])) index += 1 matrix.append(row) print(longest_path_of_1s(N, M, matrix))"},{"question":"def can_segment_string(s: str, words: List[str]) -> str: Determine if the string \`s\` can be segmented into a space-separated sequence of one or more dictionary words. Return \`YES\` if it is possible, otherwise return \`NO\`. >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == \\"YES\\" >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == \\"NO\\" pass # Unit Tests def test_case_1(): assert can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) == \\"YES\\" def test_case_2(): assert can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == \\"NO\\" def test_single_word_match(): assert can_segment_string(\\"apple\\", [\\"apple\\"]) == \\"YES\\" def test_no_match(): assert can_segment_string(\\"banana\\", [\\"apple\\", \\"orange\\", \\"grape\\"]) == \\"NO\\" def test_prefix_only_matches(): assert can_segment_string(\\"applepie\\", [\\"apple\\", \\"pie\\", \\"plum\\"]) == \\"YES\\" def test_suffix_only_matches(): assert can_segment_string(\\"plumpudding\\", [\\"plum\\", \\"apple\\", \\"pudding\\"]) == \\"YES\\" def test_multiple_segmentation(): assert can_segment_string(\\"icecreamandpudding\\", [\\"ice\\", \\"cream\\", \\"and\\", \\"pudding\\"]) == \\"YES\\" def test_no_words(): assert can_segment_string(\\"anything\\", []) == \\"NO\\" def test_complex_case(): assert can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\", \\"leetcode\\", \\"le\\", \\"et\\", \\"ode\\"]) == \\"YES\\"","solution":"def can_segment_string(s, words): Determine if the string \`s\` can be segmented into a space-separated sequence of one or more dictionary words. word_set = set(words) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[len(s)] else \\"NO\\" # Example usage s = \\"applepenapple\\" words = [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"] print(can_segment_string(s, words)) # Output: YES s = \\"catsandog\\" words = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] print(can_segment_string(s, words)) # Output: NO"},{"question":"def employee_management(operations): This function processes a list of operations for managing employee project counts. Parameters: operations (list of str): A list of operation strings each of which is either \\"add employee_id project_count\\", \\"update employee_id new_project_count\\", or \\"query employee_id\\". Returns: list of int: A list of project counts for each query operation. >>> employee_management([ \\"add 100 5\\", \\"add 101 3\\", \\"query 100\\", \\"update 100 10\\", \\"query 100\\", \\"query 101\\", \\"add 102 7\\", \\"update 101 6\\", \\"query 101\\", \\"query 102\\" ]) [5, 10, 3, 6, 7] >>> employee_management([ \\"add 100 5\\", \\"add 101 3\\", \\"add 102 8\\" ]) [] >>> employee_management([ \\"add 200 3\\", \\"update 200 5\\", \\"query 200\\", \\"update 200 2\\", \\"query 200\\" ]) [5, 2] >>> employee_management([ \\"add 300 7\\", \\"add 301 9\\", \\"query 300\\", \\"query 301\\" ]) [7, 9] >>> employee_management([ \\"add 999999 10\\", \\"query 999999\\", \\"update 999999 15\\", \\"query 999999\\" ]) [10, 15]","solution":"def employee_management(operations): This function processes a list of operations for managing employee project counts. Parameters: operations (list of str): A list of operation strings each of which is either \\"add employee_id project_count\\", \\"update employee_id new_project_count\\", or \\"query employee_id\\". Returns: list of int: A list of project counts for each query operation. records = {} result = [] for op in operations: parts = op.split() command = parts[0] employee_id = int(parts[1]) if command == \\"add\\": project_count = int(parts[2]) records[employee_id] = project_count elif command == \\"update\\": new_project_count = int(parts[2]) records[employee_id] = new_project_count elif command == \\"query\\": result.append(records[employee_id]) return result"},{"question":"def calculate_bacteria(n, m, h, removals): Calculate the number of bacteria left after h hours with given initial bacteria and removal events. Parameters: - n: Initial number of bacteria. - m: Number of removal events. - h: Number of hours. - removals: List of tuples with (t, c) where t is the hour and c is the number of bacteria removed. Returns: - The number of bacteria left after h hours. pass # Test cases def test_calculate_bacteria_no_removals(): result = calculate_bacteria(3, 0, 3, []) assert result == 24 def test_calculate_bacteria_some_removals(): result = calculate_bacteria(3, 2, 3, [(1, 2), (2, 1)]) assert result == 14 def test_calculate_bacteria_single_removal(): result = calculate_bacteria(5, 1, 4, [(3, 5)]) assert result == 70 def test_calculate_bacteria_removals_at_every_hour(): result = calculate_bacteria(1, 3, 3, [(1, 1), (2, 1), (3, 1)]) assert result == 1 def test_calculate_bacteria_no_bacteria_left(): result = calculate_bacteria(1, 1, 1, [(1, 2)]) assert result == 0","solution":"def calculate_bacteria(n, m, h, removals): Calculate the number of bacteria left after h hours with given initial bacteria and removal events. Parameters: - n: Initial number of bacteria. - m: Number of removal events. - h: Number of hours. - removals: List of tuples with (t, c) where t is the hour and c is the number of bacteria removed. Returns: - The number of bacteria left after h hours. bacteria_count = n removals_dict = {t: c for t, c in removals} for hour in range(1, h + 1): bacteria_count *= 2 if hour in removals_dict: bacteria_count -= removals_dict[hour] return bacteria_count"},{"question":"def preprocess_fruit_counts(fruit_counts): Precompute cumulative sums for the fruit counts of trees. >>> preprocess_fruit_counts([2, 3, 7, 1, 5, 6, 2, 4, 8, 3]) [0, 2, 5, 12, 13, 18, 24, 26, 30, 38, 41] def query_fruit_sum(cumulative_sums, S, E): Calculate the sum for the range S to E (inclusive) using the cumulative sums array. >>> cumulative_sums = preprocess_fruit_counts([2, 3, 7, 1, 5, 6, 2, 4, 8, 3]) >>> query_fruit_sum(cumulative_sums, 2, 5) 19 >>> query_fruit_sum(cumulative_sums, 1, 7) 28 >>> query_fruit_sum(cumulative_sums, 0, 9) 41 def process_queries(M, L, fruit_counts, queries): Process all queries to find total number of fruits collected from tree S to tree E. >>> M = 10 >>> L = 3 >>> fruit_counts = [2, 3, 7, 1, 5, 6, 2, 4, 8, 3] >>> queries = [(2, 5), (1, 7), (0, 9)] >>> process_queries(M, L, fruit_counts, queries) [19, 28, 41]","solution":"def preprocess_fruit_counts(fruit_counts): # Precompute cumulative sums for fruit_counts cumulative_sums = [0] * (len(fruit_counts) + 1) for i in range(len(fruit_counts)): cumulative_sums[i + 1] = cumulative_sums[i] + fruit_counts[i] return cumulative_sums def query_fruit_sum(cumulative_sums, S, E): # Calculate the sum for the range S to E (inclusive) using the cumulative sums array return cumulative_sums[E + 1] - cumulative_sums[S] # Function to process all queries def process_queries(M, L, fruit_counts, queries): # Preprocess fruit counts to get cumulative sums cumulative_sums = preprocess_fruit_counts(fruit_counts) # Process each query and store the results results = [] for S, E in queries: result = query_fruit_sum(cumulative_sums, S, E) results.append(result) return results"},{"question":"from collections import deque from typing import List, Tuple, Dict def bfs_shortest_path(n: int, adjacency_list: Dict[int, List[int]]) -> List[Tuple[int, int]]: Perform BFS to find the shortest path from vertex 1 to all other vertices in an undirected graph. :param n: Number of vertices :param adjacency_list: Adjacency list of the graph where each key is a vertex and the value is a list of adjacent vertices :return: List of tuples where each tuple contains vertex ID and its shortest distance from vertex 1 Example Usage: >>> n = 4 >>> adjacency_list = {1: [2, 3], 2: [1, 4], 3: [1], 4: [2]} >>> bfs_shortest_path(n, adjacency_list) [(1, 0), (2, 1), (3, 1), (4, 2)] >>> n = 6 >>> adjacency_list = {1: [2, 3], 2: [1, 4], 3: [1, 5], 4: [2, 6], 5: [3], 6: [4]} >>> bfs_shortest_path(n, adjacency_list) [(1, 0), (2, 1), (3, 1), (4, 2), (5, 2), (6, 3)]","solution":"from collections import deque, defaultdict def bfs_shortest_path(n, adjacency_list): Perform BFS to find the shortest path from vertex 1 to all other vertices. :param n: Number of vertices :param adjacency_list: Adjacency list of the graph, as described in the problem :return: List of tuples where each tuple contains vertex ID and its shortest distance from vertex 1 graph = defaultdict(list) for u, adjacents in adjacency_list.items(): graph[u].extend(adjacents) distances = {i: float('inf') for i in range(1, n + 1)} distances[1] = 0 queue = deque([1]) while queue: vertex = queue.popleft() for neighbor in graph[vertex]: if distances[neighbor] == float('inf'): distances[neighbor] = distances[vertex] + 1 queue.append(neighbor) return [(i, distances[i]) for i in range(1, n + 1)] # Example input # n = 4 # adjacency_list = { # 1: [2, 3], # 2: [1, 4], # 3: [1], # 4: [2], # } # output would be: [(1, 0), (2, 1), (3, 1), (4, 2)]"},{"question":"def min_drivers(n: int, intervals: List[Tuple[int, int]]) -> int: Determines the minimum number of drivers required to cover all delivery locations within their respective time windows. >>> min_drivers(3, [(60, 120), (110, 180), (150, 210)]) == 2 >>> min_drivers(4, [(300, 600), (500, 700), (600, 900), (550, 850)]) == 3 >>> min_drivers(2, [(0, 600), (601, 1440)]) == 1","solution":"def min_drivers(n, intervals): if n == 0: return 0 intervals.sort() drivers_end_times = [] for start, end in intervals: assigned = False for i in range(len(drivers_end_times)): if drivers_end_times[i] <= start: drivers_end_times[i] = end assigned = True break if not assigned: drivers_end_times.append(end) return len(drivers_end_times)"},{"question":"def can_cover_with_dominoes(m: int, n: int) -> str: Determines if an m x n board can be completely covered with dominoes. Args: m: int - number of rows of the board n: int - number of columns of the board Returns: str: \\"YES\\" if the board can be fully covered with dominoes, else \\"NO\\" >>> can_cover_with_dominoes(3, 2) 'YES' >>> can_cover_with_dominoes(5, 3) 'NO' >>> can_cover_with_dominoes(4, 4) 'YES' >>> can_cover_with_dominoes(1, 1) 'NO' >>> can_cover_with_dominoes(2, 2) 'YES' >>> can_cover_with_dominoes(6, 7) 'YES' >>> can_cover_with_dominoes(99, 100000) 'YES' >>> can_cover_with_dominoes(100000, 100000) 'YES' >>> can_cover_with_dominoes(99999, 99999) 'NO'","solution":"def can_cover_with_dominoes(m, n): Determines if an m x n board can be completely covered with dominoes. Args: m: int - number of rows of the board n: int - number of columns of the board Returns: str: \\"YES\\" if the board can be fully covered with dominoes, else \\"NO\\" if (m * n) % 2 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def connected_component_sums(n, m, values, edges, q, queries): Given an undirected graph with n nodes and m edges, where each node is assigned an integer value, performs q queries where each query asks for the sum of values of nodes in the connected component containing a given node x. Example usage: >>> n = 5 >>> m = 5 >>> values = [1, 5, 3, 2, 4] >>> edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] >>> q = 3 >>> queries = [1, 3, 5] >>> connected_component_sums(n, m, values, edges, q, queries) [15, 15, 15] import pytest from solution import connected_component_sums def test_case1(): n = 5 m = 5 values = [1, 5, 3, 2, 4] edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] q = 3 queries = [1, 3, 5] assert connected_component_sums(n, m, values, edges, q, queries) == [15, 15, 15] def test_case2(): n = 6 m = 4 values = [10, 20, 30, 40, 50, 60] edges = [(1, 2), (2, 3), (4, 5), (5, 6)] q = 3 queries = [1, 4, 6] assert connected_component_sums(n, m, values, edges, q, queries) == [60, 150, 150] def test_case3(): n = 3 m = 1 values = [1, 2, 3] edges = [(1, 2)] q = 3 queries = [1, 2, 3] assert connected_component_sums(n, m, values, edges, q, queries) == [3, 3, 3] def test_case4(): n = 4 m = 2 values = [4, 3, 2, 1] edges = [(1, 2), (3, 4)] q = 2 queries = [2, 4] assert connected_component_sums(n, m, values, edges, q, queries) == [7, 3] def test_case5(): n = 1 m = 0 values = [10] edges = [] q = 1 queries = [1] assert connected_component_sums(n, m, values, edges, q, queries) == [10]","solution":"def connected_component_sums(n, m, values, edges, q, queries): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Function to find all nodes in the connected component containing node \`start\` def bfs(start): queue = deque([start]) visited = set([start]) component = [] while queue: node = queue.popleft() component.append(node) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return component # Find all connected components and their sums visited = set() component_sums = {} for node in range(1, n + 1): if node not in visited: component = bfs(node) component_sum = sum(values[i-1] for i in component) for c in component: component_sums[c] = component_sum visited.update(component) # Answer the queries result = [] for query in queries: result.append(component_sums[query]) return result # Example usage: # n = 5, m = 5 # values = [1, 5, 3, 2, 4] # edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] # q = 3 # queries = [1, 3, 5] # Output: [15, 15, 15]"},{"question":"def rolling_sum(arr, k): Calculate the rolling sum of the array with the given window size k. :param arr: List of integers :param k: Window size :return: List of rolling sums >>> rolling_sum([1, 2, 3, 4, 5, 6], 3) [6, 9, 12, 15] >>> rolling_sum([1, -1, 3, 4, 2], 2) [0, 2, 7, 6] >>> rolling_sum([1, 2, 3, 4], 5) []","solution":"def rolling_sum(arr, k): Calculate the rolling sum of the array with the given window size k. :param arr: List of integers :param k: Window size :return: List of rolling sums n = len(arr) if k > n: return [] result = [] for i in range(n - k + 1): window_sum = sum(arr[i:i+k]) result.append(window_sum) return result"},{"question":"def interval_analysis(intervals: List[List[int]]) -> int: Analyzes the given list of intervals for overlaps and total combined length. If any two intervals overlap, returns -1. Otherwise, returns the total combined length of all intervals. Args: intervals: List of intervals, each represented by a pair of integers [start, end]. Returns: int: -1 if any two intervals overlap, otherwise the total combined length of all intervals. Examples: >>> interval_analysis([[1, 3], [2, 4], [5, 7]]) -1 >>> interval_analysis([[1, 3], [4, 6], [7, 9]]) 6 # Your code here from typing import List def test_interval_analysis_overlapping_intervals(): assert interval_analysis([[1, 3], [2, 4], [5, 7]]) == -1 assert interval_analysis([[1, 5], [3, 6], [7, 8]]) == -1 assert interval_analysis([[0, 2], [2, 4], [4, 6], [5, 7]]) == -1 def test_interval_analysis_non_overlapping_intervals(): assert interval_analysis([[1, 3], [4, 6], [7, 9]]) == 6 assert interval_analysis([[0, 1], [1, 2], [2, 3]]) == 3 assert interval_analysis([[1, 2], [3, 4], [5, 6]]) == 3 def test_interval_analysis_edge_cases(): assert interval_analysis([[0, 1]]) == 1 assert interval_analysis([[0, 1000000000]]) == 1000000000 assert interval_analysis([[0, 1], [2, 3], [4, 5]]) == 3","solution":"from typing import List def interval_analysis(intervals: List[List[int]]) -> int: Analyzes the given list of intervals for overlaps and total combined length. If any two intervals overlap, returns -1. Otherwise, returns the total combined length of all intervals. intervals.sort() total_length = 0 prev_end = -1 for start, end in intervals: if start < prev_end: return -1 prev_end = end total_length += end - start return total_length"},{"question":"from typing import Dict def count_patterns(n: int, s: str) -> Dict[str, int]: Counts the frequency of each unique pattern (substring) in the balloon color string. Parameters: n (int): The number of balloons (length of the string). s (str): The string representing the balloon colors. Returns: Dict[str, int]: A dictionary with patterns as keys and their frequencies as values. Examples: >>> count_patterns(1, \\"a\\") {'a': 1} >>> count_patterns(2, \\"ab\\") {'a': 1, 'b': 1, 'ab': 1} >>> count_patterns(7, \\"abacaba\\") {'a': 4, 'ab': 2, 'aba': 2, 'abac': 1, 'abaca': 1, 'abacab': 1, 'abacaba': 1, 'b': 2, 'ba': 2, 'bac': 1, 'baca': 1, 'bacab': 1, 'bacaba': 1, 'ac': 1, 'aca': 1, 'acab': 1, 'acaba': 1, 'c': 1, 'ca': 1, 'cab': 1, 'caba': 1}","solution":"from collections import defaultdict def count_patterns(n, s): Counts the frequency of each unique pattern (substring) in the balloon color string. Parameters: n (int): The number of balloons (length of the string). s (str): The string representing the balloon colors. Returns: dict: A dictionary with patterns as keys and their frequencies as values. pattern_count = defaultdict(int) # Iterate over all possible substrings and count their occurrences for length in range(1, n + 1): for start in range(n - length + 1): substring = s[start:start + length] pattern_count[substring] += 1 return pattern_count"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int, int]]) -> List[int]: Processes range xor and range update queries on the given array. Parameters: n (int): the size of the array q (int): the number of queries array (list of int): the initial elements of the array queries (list of tuple): the queries to process Returns: list of int: the resulting array after processing all queries # Unit tests def test_process_queries_example(): n = 5 q = 4 array = [1, 2, 3, 4, 5] queries = [ (1, 1, 3, 2), (2, 2, 4, 6), (1, 3, 5, 1), (2, 1, 2, 9) ] result = process_queries(n, q, array, queries) expected = [9, 9, 7, 7, 4] assert result == expected def test_process_queries_single_xor(): n = 4 q = 1 array = [0, 0, 0, 0] queries = [ (1, 1, 4, 1) ] result = process_queries(n, q, array, queries) expected = [1, 1, 1, 1] assert result == expected def test_process_queries_single_update(): n = 3 q = 1 array = [5, 6, 7] queries = [ (2, 1, 3, 10) ] result = process_queries(n, q, array, queries) expected = [10, 10, 10] assert result == expected def test_process_queries_mixed_operations(): n = 6 q = 3 array = [3, 3, 3, 3, 3, 3] queries = [ (1, 1, 4, 2), (2, 2, 5, 8), (1, 3, 6, 1) ] result = process_queries(n, q, array, queries) expected = [1, 8, 9, 9, 9, 2] assert result == expected","solution":"def process_queries(n, q, array, queries): Processes range xor and range update queries on the given array. Parameters: n (int): the size of the array q (int): the number of queries array (list of int): the initial elements of the array queries (list of tuple): the queries to process Returns: list of int: the resulting array after processing all queries for query in queries: type_query = query[0] l, r, x = query[1], query[2], query[3] # Convert to zero-based indexing l -= 1 r -= 1 if type_query == 1: # XOR all elements in the subarray from index l to index r by x for i in range(l, r + 1): array[i] ^= x elif type_query == 2: # Set all elements in the subarray from index l to index r to x for i in range(l, r + 1): array[i] = x return array"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] class BinaryTree: def __init__(self, n, values): self.nodes = [None] + [TreeNode(value) for value in values] # 1-based index def add_edge(self, u, v): Adds an edge between node u and node v def calculate_subtree_sums(self, node): Calculates subtree sums for each node def update_node_value(self, i, new_value): Updates the value of the node at position i with a new value v def adjust_subtree_sums(self, node, diff, parent): Adjusts the subtree sums after an update def get_subtree_sum(self, x): Gets the sum of all node values in the subtree rooted at node x def process_queries(n, values, edges, queries): Processes a list of queries in a binary tree Args: n: int - the number of nodes in the tree values: list of int - the values of the nodes edges: list of tuples - the edges in the tree queries: list of tuples - the queries to process Returns: list of int - the result of the queries of the second type def test_binary_tree(): n = 5 values = [10, 20, 30, 40, 50] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] queries = [(2, 1), (1, 2, 100), (2, 2)] expected_output = [150, 140] output = process_queries(n, values, edges, queries) assert output == expected_output def test_binary_tree_single_node(): n = 1 values = [10] edges = [] queries = [(2, 1), (1, 1, 100), (2, 1)] expected_output = [10, 100] output = process_queries(n, values, edges, queries) assert output == expected_output def test_binary_tree_no_update(): n = 3 values = [10, 20, 30] edges = [(1, 2), (1, 3)] queries = [(2, 1), (2, 2), (2, 3)] expected_output = [60, 20, 30] output = process_queries(n, values, edges, queries) assert output == expected_output if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] class BinaryTree: def __init__(self, n, values): self.nodes = [None] + [TreeNode(value) for value in values] # 1-based index self.subtree_sums = [0] * (n + 1) self.visited = [False] * (n + 1) def add_edge(self, u, v): self.nodes[u].children.append(v) self.nodes[v].children.append(u) def calculate_subtree_sums(self, node): self.visited[node] = True total_sum = self.nodes[node].value for child in self.nodes[node].children: if not self.visited[child]: total_sum += self.calculate_subtree_sums(child) self.subtree_sums[node] = total_sum return total_sum def update_node_value(self, i, new_value): diff = new_value - self.nodes[i].value self.nodes[i].value = new_value self.adjust_subtree_sums(i, diff, -1) def adjust_subtree_sums(self, node, diff, parent): self.subtree_sums[node] += diff for child in self.nodes[node].children: if child != parent: self.adjust_subtree_sums(child, diff, node) def get_subtree_sum(self, x): return self.subtree_sums[x] def process_queries(n, values, edges, queries): tree = BinaryTree(n, values) for u, v in edges: tree.add_edge(u, v) tree.calculate_subtree_sums(1) result = [] for query in queries: if query[0] == 1: _, i, v = query tree.update_node_value(i, v) elif query[0] == 2: _, x = query result.append(tree.get_subtree_sum(x)) return result"},{"question":"def vending_machine_simulation(p, products, transactions): Simulate the functionality of a vending machine by processing a list of products and a series of transactions. >>> vending_machine_simulation(3, [(\\"Chips\\", 120), (\\"Soda\\", 150), (\\"Candy\\", 80)], [(200, \\"Chips\\"), (100, \\"Soda\\"), (80, \\"Candy\\"), (10, \\"Candy\\"), (0, \\"END\\")]) [\\"Dispensed Chips. Change: 80 cents\\", \\"Insufficient funds for Soda. Please insert 50 more cents\\", \\"Dispensed Candy. Change: 0 cents\\", \\"Insufficient funds for Candy. Please insert 70 more cents\\"] >>> vending_machine_simulation(1, [(\\"Water\\", 100)], [(0, \\"END\\")]) [] >>> vending_machine_simulation(2, [(\\"Chocolate\\", 200), (\\"Juice\\", 150)], [(200, \\"Chocolate\\"), (160, \\"Juice\\"), (100, \\"Chocolate\\"), (0, \\"END\\")]) [\\"Dispensed Chocolate. Change: 0 cents\\", \\"Dispensed Juice. Change: 10 cents\\", \\"Insufficient funds for Chocolate. Please insert 100 more cents\\"] >>> vending_machine_simulation(1, [(\\"Gum\\", 50)], [(30, \\"Gum\\"), (0, \\"END\\")]) [\\"Insufficient funds for Gum. Please insert 20 more cents\\"]","solution":"def vending_machine_simulation(p, products, transactions): product_prices = {} for product, price in products: product_prices[product] = price result = [] for money_inserted, product in transactions: if product not in product_prices: continue price = product_prices[product] if money_inserted >= price: change = money_inserted - price result.append(f\\"Dispensed {product}. Change: {change} cents\\") else: needed = price - money_inserted result.append(f\\"Insufficient funds for {product}. Please insert {needed} more cents\\") return result # Example usage p = 3 products = [(\\"Chips\\", 120), (\\"Soda\\", 150), (\\"Candy\\", 80)] transactions = [(200, \\"Chips\\"), (100, \\"Soda\\"), (80, \\"Candy\\"), (10, \\"Candy\\"), (0, \\"END\\")] # Expected output: # Dispensed Chips. Change: 80 cents # Insufficient funds for Soda. Please insert 50 more cents # Dispensed Candy. Change: 0 cents # Insufficient funds for Candy. Please insert 70 more cents print(\\"n\\".join(vending_machine_simulation(p, products, transactions)))"},{"question":"def count_people_who_can_see(heights: List[int]) -> int: Given an array of integers representing the heights of people standing in a row, returns the number of people who will have an unobstructed view of the parade. >>> count_people_who_can_see([1, 2, 3, 2, 1]) 3 >>> count_people_who_can_see([5, 1, 2, 3, 4]) 1 >>> count_people_who_can_see([3, 3, 2, 1]) 1 >>> count_people_who_can_see([10]) 1 >>> count_people_who_can_see([1, 2, 3, 4, 5]) 5 >>> count_people_who_can_see([5, 4, 3, 2, 1]) 1 >>> count_people_who_can_see([3, 3, 3, 3, 3]) 1 >>> count_people_who_can_see([]) 0 >>> count_people_who_can_see([4, 3, 5, 1, 6, 2]) 3","solution":"from typing import List def count_people_who_can_see(heights: List[int]) -> int: if not heights: return 0 count = 1 # The first person can always see max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"def calculate_xeno_dollars(trades): Calculate the total amount of XenoDollars in the system after each trade event. :param trades: List of tuples containing (planet, amount, rate) for each trade event. :return: List of total XenoDollars after each trade event. >>> calculate_xeno_dollars([(\\"Mars\\", 100, 0.5)]) [50.0] >>> calculate_xeno_dollars([(\\"Mars\\", 100, 0.5), (\\"Venus\\", 200, 1.25), (\\"Jupiter\\", 50, 2.0), (\\"Mars\\", 300, 0.5)]) [50.0, 300.0, 400.0, 550.0] >>> calculate_xeno_dollars([]) [] >>> calculate_xeno_dollars([(\\"Galacticus\\", 1000, 50.0)]) [50000.0] >>> calculate_xeno_dollars([(\\"TinyPlanet\\", 5, 0.01)]) [0.05] >>> calculate_xeno_dollars([(\\"Mars\\", 100, 0.5), (\\"Pluto\\", 1, 100.0), (\\"Earth\\", 500, 0.1), (\\"Venus\\", 1000, 0.75)]) [50.0, 150.0, 200.0, 950.0]","solution":"def calculate_xeno_dollars(trades): Calculate the total amount of XenoDollars in the system after each trade event. :param trades: List of tuples containing (planet, amount, rate) for each trade event. :return: List of total XenoDollars after each trade event. total_xd = 0 results = [] for trade in trades: planet, amount, rate = trade total_xd += amount * rate results.append(total_xd) return results"},{"question":"from typing import List, Tuple def combination_resistances(values: List[int]) -> set: Returns a set of all possible resistances that can be achieved with combinations of given resistor values using series combinations. pass def is_possible_to_achieve_resistance(target: int, resistances: List[int]) -> str: Determines if it is possible to achieve the target resistance with the given resistances using both series and parallel combinations. pass def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases to determine if each target resistance can be achieved. pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, List[int]]]]: Parses the input string into a format suitable for processing test cases. pass # Unit tests import pytest def test_example_case(): input_string = 3 4 3 1 2 3 6 2 2 3 5 4 1 2 3 4 expected_output = [\\"POSSIBLE\\", \\"IMPOSSIBLE\\", \\"POSSIBLE\\"] T, test_cases = parse_input(input_string) assert process_test_cases(T, test_cases) == expected_output def test_single_resistor(): input_string = 1 50 1 50 expected_output = [\\"POSSIBLE\\"] T, test_cases = parse_input(input_string) assert process_test_cases(T, test_cases) == expected_output def test_impossible_case(): input_string = 1 10 2 3 5 expected_output = [\\"IMPOSSIBLE\\"] T, test_cases = parse_input(input_string) assert process_test_cases(T, test_cases) == expected_output def test_multiple_possible_cases(): input_string = 1 6 3 1 2 3 expected_output = [\\"POSSIBLE\\"] T, test_cases = parse_input(input_string) assert process_test_cases(T, test_cases) == expected_output def test_combination_of_resistors(): input_string = 1 7 4 1 2 5 10 expected_output = [\\"POSSIBLE\\"] T, test_cases = parse_input(input_string) assert process_test_cases(T, test_cases) == expected_output @pytest.mark.parametrize(\\"input_string, expected_output\\", [ (\\"1n1n1n1\\", [\\"POSSIBLE\\"]), (\\"1n1000n5n100 200 300 400 500\\", [\\"POSSIBLE\\"]), (\\"1n6n4n1 2 3 6\\", [\\"POSSIBLE\\"]), (\\"1n20n3n5 10 15\\", [\\"POSSIBLE\\"]), (\\"1n10n3n2 3 4\\", [\\"IMPOSSIBLE\\"]) ]) def test_parametrized_cases(input_string, expected_output): T, test_cases = parse_input(input_string) assert process_test_cases(T, test_cases) == expected_output","solution":"from itertools import combinations def combination_resistances(values): Returns a set of all possible resistances that can be achieved with combinations of given resistor values using series combinations. all_combinations = set() for i in range(1, len(values) + 1): for comb in combinations(values, i): all_combinations.add(sum(comb)) return all_combinations def is_possible_to_achieve_resistance(target, resistances): Determines if it is possible to achieve the target resistance with the given resistances using both series and parallel combinations. possible_series = combination_resistances(resistances) # For simplicity, just considering series combinations return \\"POSSIBLE\\" if target in possible_series else \\"IMPOSSIBLE\\" def process_test_cases(T, test_cases): results = [] for i in range(T): target = test_cases[i][0] resistances = test_cases[i][2] result = is_possible_to_achieve_resistance(target, resistances) results.append(result) return results def parse_input(input_string): input_list = input_string.strip().split(\\"n\\") T = int(input_list[0]) test_cases = [] idx = 1 for _ in range(T): target = int(input_list[idx]) M = int(input_list[idx + 1]) resistances = list(map(int, input_list[idx + 2].split())) test_cases.append((target, M, resistances)) idx += 3 return T, test_cases"},{"question":"def remove_duplicates_from_list(test_cases): For each test case, the function removes duplicate names from the list while maintaining the original order of appearance and returns the cleaned-up list. :param test_cases: List of tuples, each containing a number of enemy names followed by the names themselves. :return: List of lists, where each inner list contains unique enemy names for a test case. pass def parse_input(input_string): Helper function to parse the input string into the required format for processing. :param input_string: String containing the raw input. :return: List of tuples with each tuple containing the number of names and the list of names. pass def format_output(results): Helper function to format the list of results into the required output string. :param results: List of lists containing unique enemy names for each test case. :return: Formatted string with unique names for all test cases. pass def process_input(input_string): Processes the input string and returns the formatted output string. :param input_string: Raw input string. :return: Formatted output string. pass # Test cases if __name__ == \\"__main__\\": input_string = \\"2n5nCerseinJoffreynCerseinTywinnJoffreyn4nTheonnRamsaynTheonnRoose\\" print(process_input(input_string)) # Expected: \\"CerseinJoffreynTywinnnTheonnRamsaynRoose\\" input_string = \\"1n4nAryanBrannSansanJon\\" print(process_input(input_string)) # Expected: \\"AryanBrannSansanJon\\" input_string = \\"1n3nLittlefingernLittlefingernLittlefinger\\" print(process_input(input_string)) # Expected: \\"Littlefinger\\" input_string = \\"1n6nMelisandrenStannisnMelisandrenDavosnDavosnStannis\\" print(process_input(input_string)) # Expected: \\"MelisandrenStannisnDavos\\" input_string = \\"1n1nBrienne\\" print(process_input(input_string)) # Expected: \\"Brienne\\" input_string = \\"2n4nHillnSandnHillnStonen3nPykenGreyjoynPyke\\" print(process_input(input_string)) # Expected: \\"HillnSandnStonennPykenGreyjoy\\"","solution":"def remove_duplicates_from_list(test_cases): For each test case, the function removes duplicate names from the list while maintaining the original order of appearance and returns the cleaned-up list. :param test_cases: List of tuples, each containing a number of enemy names followed by the names themselves. :return: List of lists, where each inner list contains unique enemy names for a test case. results = [] for case in test_cases: N, names = case seen = set() unique_names = [] for name in names: if name not in seen: unique_names.append(name) seen.add(name) results.append(unique_names) return results def parse_input(input_string): Helper function to parse the input string into the required format for processing. :param input_string: String containing the raw input. :return: List of tuples with each tuple containing the number of names and the list of names. lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) names = lines[index + 1:index + 1 + N] test_cases.append((N, names)) index += N + 1 return test_cases def format_output(results): Helper function to format the list of results into the required output string. :param results: List of lists containing unique enemy names for each test case. :return: Formatted string with unique names for all test cases. output_list = [] for result in results: output_list.extend(result) output_list.append('') return 'n'.join(output_list).strip() def process_input(input_string): Processes the input string and returns the formatted output string. :param input_string: Raw input string. :return: Formatted output string. test_cases = parse_input(input_string) results = remove_duplicates_from_list(test_cases) return format_output(results)"},{"question":"def generate_histogram(datasets): Generate a simple histogram from a list of integers using the character '#' to represent the frequency of each value. >>> generate_histogram([[1, 2, 3, 3, 3, 4, 4, 5, 6], [0]]) \\"1 #n2 #n3 #n4 n5 #n6 #n7 n8 n9 n10 \\" >>> generate_histogram([[1, 2, 3, 3, 3, 4, 4, 5, 6], [10, 10, 9, 8, 7, 6, 5], [1], [7, 8, 9, 10, 10, 10, 5, 5, 5, 5, 5], [0]]) (\\"1 #n2 #n3 #n4 n5 #n6 #n7 n8 n9 n10 nn\\" \\"1 n2 n3 n4 n5 #n6 #n7 #n8 #n9 #n10 nn\\" \\"1 #n2 n3 n4 n5 n6 n7 n8 n9 n10 nn\\" \\"1 n2 n3 n4 n5 #n6 n7 #n8 #n9 #n10 #\\") >>> generate_histogram([[0]]) \\"\\" >>> generate_histogram([[5, 5, 5, 5, 5, 5, 5], [0]]) \\"1 n2 n3 n4 n5 #n6 n7 n8 n9 n10 \\" >>> generate_histogram([[], [0]]) \\"1 n2 n3 n4 n5 n6 n7 n8 n9 n10 \\"","solution":"def generate_histogram(datasets): results = [] for data in datasets: if len(data) == 1 and data[0] == 0: break counts = [0] * 10 for num in data: if 1 <= num <= 10: counts[num-1] += 1 result = [] for i in range(10): result.append(f\\"{i+1} {'#' * counts[i]}\\") results.append(\\"n\\".join(result)) return \\"nn\\".join(results) # Example usage if __name__ == \\"__main__\\": input_data = [ [1, 2, 3, 3, 3, 4, 4, 5, 6], [10, 10, 9, 8, 7, 6, 5], [1], [7, 8, 9, 10, 10, 10, 5, 5, 5, 5, 5], [0] ] print(generate_histogram(input_data))"},{"question":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.parent = None self.depth = 0 class BST: def __init__(self): self.root = None def insert(self, key): Inserts a key into the BST and returns the newly created node. if not self.root: self.root = TreeNode(key) return self.root node = self._insert(self.root, key, depth=0, parent=None) return node def _insert(self, current, key, depth, parent): if not current: node = TreeNode(key) node.depth = depth node.parent = parent return node if key < current.key: if current.left: return self._insert(current.left, key, depth + 1, current) else: current.left = self._insert(current.left, key, depth + 1, current) return current.left else: # key > current.key if current.right: return self._insert(current.right, key, depth + 1, current) else: current.right = self._insert(current.right, key, depth + 1, current) return current.right def get_node_info(self, node): Returns the information of the given node in the required format. parent_key = node.parent.key if node.parent else 'None' depth = node.depth children = [] if node.left: children.append(node.left.key) if node.right: children.append(node.right.key) children.sort() return (node.key, parent_key, depth, children) def in_order_traversal(self, node, result): if not node: return self.in_order_traversal(node.left, result) result.append(self.get_node_info(node)) self.in_order_traversal(node.right, result) def get_all_nodes_info(self): Returns a list of all nodes' information, sorted by node keys. result = [] self.in_order_traversal(self.root, result) result.sort(key=lambda x: x[0]) # sort by node key return result def generate_bst_from_list(keys): Generates a BST from the given list of keys and returns it. bst = BST() for key in keys: bst.insert(key) return bst def bst_info(n, keys): Given \`n\` (number of nodes) and a list of \`keys\`, returns information for each node formatted as: (node key, parent key, depth, children keys) sorted by node keys. Examples: >>> bst_info(7, [10, 5, 15, 2, 7, 13, 17]) [(2, 5, 2, []), (5, 10, 1, [2, 7]), (7, 5, 2, []), (10, 'None', 0, [5, 15]), (13, 15, 2, []), (15, 10, 1, [13, 17]), (17, 15, 2, [])] >>> bst_info(5, [20, 10, 30, 5, 15]) [(5, 10, 2, []), (10, 20, 1, [5, 15]), (15, 10, 2, []), (20, 'None', 0, [10, 30]), (30, 20, 1, [])] bst = generate_bst_from_list(keys) all_nodes_info = bst.get_all_nodes_info() return all_nodes_info","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.parent = None self.depth = 0 class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = TreeNode(key) return self.root node = self._insert(self.root, key, depth=0, parent=None) return node def _insert(self, current, key, depth, parent): if not current: node = TreeNode(key) node.depth = depth node.parent = parent return node if key < current.key: if current.left: return self._insert(current.left, key, depth + 1, current) else: current.left = self._insert(current.left, key, depth + 1, current) return current.left else: # key > current.key if current.right: return self._insert(current.right, key, depth + 1, current) else: current.right = self._insert(current.right, key, depth + 1, current) return current.right def get_node_info(self, node): parent_key = node.parent.key if node.parent else 'None' depth = node.depth children = [] if node.left: children.append(node.left.key) if node.right: children.append(node.right.key) children.sort() return (node.key, parent_key, depth, children) def in_order_traversal(self, node, result): if not node: return self.in_order_traversal(node.left, result) result.append(self.get_node_info(node)) self.in_order_traversal(node.right, result) def get_all_nodes_info(self): result = [] self.in_order_traversal(self.root, result) result.sort(key=lambda x: x[0]) # sort by node key return result def generate_bst_from_list(keys): bst = BST() for key in keys: bst.insert(key) return bst def bst_info(n, keys): bst = generate_bst_from_list(keys) all_nodes_info = bst.get_all_nodes_info() return all_nodes_info"},{"question":"def display_board(board): Display the current state of the 5x5 board. >>> display_board([['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-']]) - - - - - - - - - - - - - - - - - - - - - - - - - pass def is_winner(board, player): Check if the player has won the game by forming a line of exactly five marks. >>> is_winner([['X', 'X', 'X', 'X', 'X'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-']], 'X') True >>> is_winner([['O', '-', '-', '-', '-'], ['O', '-', '-', '-', '-'], ['O', '-', '-', '-', '-'], ['O', '-', '-', '-', '-'], ['O', '-', '-', '-', '-']], 'O') True >>> is_winner([['X', '-', '-', '-', '-'], ['-', 'X', '-', '-', '-'], ['-', '-', 'X', '-', '-'], ['-', '-', '-', 'X', '-'], ['-', '-', '-', '-', 'X']], 'X') True >>> is_winner([['X', 'X', 'X', 'X', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-'], ['-', '-', '-', '-', '-']], 'X') False pass def is_draw(board): Check if the game is a draw (the board is full with no winner). >>> is_draw([['X', '-', '-', '-', '-'], ['O', '-', '-', '-', '-'], ['X', '-', '-', '-', '-'], ['O', '-', '-', '-', '-'], ['X', '-', '-', '-', '-']]) False >>> is_draw([['X', 'O', 'X', 'O', 'X'], ['O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X'], ['O', 'X', 'O', 'X', 'O'], ['X', 'O', 'X', 'O', 'X']]) True pass def make_move(board, r, c, player): Place the player's mark on the board at the specified row and column. >>> board = [['-' for _ in range(5)] for _ in range(5)] >>> make_move(board, 0, 0, 'X') True >>> board[0][0] 'X' >>> make_move(board, 0, 0, 'O') # Already occupied False >>> board[0][0] 'X' pass def five_o_game(): Main function to facilitate playing the Five-O game between two human players. >>> five_o_game() Player X move: 0 0 Player O move: 1 1 Player X move: 0 1 Player O move: 2 2 Player X move: 0 2 Player O move: 3 3 Player X move: 0 3 Player O move: 4 4 Player X move: 0 4 Player X wins! pass if __name__ == \\"__main__\\": five_o_game()","solution":"def display_board(board): for row in board: print(\\" \\".join(row)) print() def is_winner(board, player): for r in range(5): for c in range(5): if c <= 0 and all(board[r][c+i] == player for i in range(5)): return True if r <= 0 and all(board[r+i][c] == player for i in range(5)): return True if r <= 0 and c <= 0 and all(board[r+i][c+i] == player for i in range(5)): return True if r >= 4 and c <= 0 and all(board[r-i][c+i] == player for i in range(5)): return True return False def is_draw(board): return all(board[r][c] != '-' for r in range(5) for c in range(5)) def make_move(board, r, c, player): if board[r][c] != '-': return False board[r][c] = player return True def five_o_game(): board = [['-' for _ in range(5)] for _ in range(5)] players = ['X', 'O'] current_player = 0 while True: display_board(board) move = input(f\\"Player {players[current_player]}, enter your move (row and column): \\").split() r, c = int(move[0]), int(move[1]) if make_move(board, r, c, players[current_player]): if is_winner(board, players[current_player]): display_board(board) print(f\\"Player {players[current_player]} wins!\\") break elif is_draw(board): display_board(board) print(\\"The game is a draw!\\") break current_player = 1 - current_player else: print(\\"Invalid move! Cell is already occupied. Try again.\\") if __name__ == \\"__main__\\": five_o_game()"},{"question":"class Library: def __init__(self, n): # Initialize the shelves and books dictionaries pass def add_book(self, shelf, book_id): Adds a book to the specified shelf. pass def remove_book(self, shelf, book_id): Removes a book from the specified shelf. pass def check_book(self, book_id): Checks if a book is present in any shelf. pass def list_books(self, shelf): Lists all books on a specified shelf in ascending order. pass def process_operations(n, operations): Processes a list of operations on a library system with n shelves. Args: - n: Number of shelves in the library. - operations: A list of tuples representing operations. Returns: A list of results corresponding to operations type 3 (check_book) and type 4 (list_books). Examples: >>> process_operations(3, [(1, 1, 101), (1, 2, 102), (3, 101), (2, 2, 102), (3, 102), (4, 1), (4, 2)]) ['YES', 'NO', '101', 'NO BOOKS'] pass from solution import process_operations def test_add_and_check_book(): operations = [ (1, 1, 101), (3, 101) ] assert process_operations(1, operations) == [\\"YES\\"] def test_add_and_remove_book(): operations = [ (1, 1, 101), (2, 1, 101), (3, 101) ] assert process_operations(1, operations) == [\\"NO\\"] def test_list_books_on_shelf(): operations = [ (1, 1, 101), (1, 1, 102), (4, 1) ] assert process_operations(1, operations) == [\\"101 102\\"] def test_list_books_empty_shelf(): operations = [ (4, 1) ] assert process_operations(1, operations) == [\\"NO BOOKS\\"] def test_combined_operations(): operations = [ (1, 1, 101), (1, 2, 102), (3, 101), (2, 2, 102), (3, 102), (4, 1), (4, 2) ] expected_output = [\\"YES\\", \\"NO\\", \\"101\\", \\"NO BOOKS\\"] assert process_operations(3, operations) == expected_output def test_check_book_not_added(): operations = [ (3, 999) ] assert process_operations(1, operations) == [\\"NO\\"]","solution":"class Library: def __init__(self, n): self.shelves = {i: set() for i in range(1, n+1)} self.books = {} def add_book(self, shelf, book_id): self.shelves[shelf].add(book_id) if book_id not in self.books: self.books[book_id] = set() self.books[book_id].add(shelf) def remove_book(self, shelf, book_id): if book_id in self.shelves[shelf]: self.shelves[shelf].remove(book_id) self.books[book_id].remove(shelf) if not self.books[book_id]: del self.books[book_id] def check_book(self, book_id): return \\"YES\\" if book_id in self.books else \\"NO\\" def list_books(self, shelf): if self.shelves[shelf]: return \\" \\".join(map(str, sorted(self.shelves[shelf]))) else: return \\"NO BOOKS\\" def process_operations(n, operations): library = Library(n) results = [] for op in operations: if op[0] == 1: library.add_book(op[1], op[2]) elif op[0] == 2: library.remove_book(op[1], op[2]) elif op[0] == 3: results.append(library.check_book(op[1])) elif op[0] == 4: results.append(library.list_books(op[1])) return results"},{"question":"class FileSystem: This class represents a file system that supports operations to create, delete, list, and calculate the total size of files. Methods: - create(name: str, size: int): Adds or updates a file with the given name and size. - delete(name: str): Removes a file by its name. - list_files(): Lists all files sorted by size, then by name. - total_size(): Displays the total size of all files. - run_commands(commands: List[str]): Executes a series of commands to interact with the file system. Example: >>> fs = FileSystem() >>> fs.run_commands([ \\"CREATE file1.txt 100\\", \\"CREATE file2.txt 200\\", \\"CREATE file1.txt 150\\", \\"LIST\\", \\"END\\" ]) file1.txt: 150 file2.txt: 200 from io import StringIO import sys import pytest def test_create_and_list(): fs = FileSystem() commands = [ \\"CREATE file1.txt 100\\", \\"CREATE file2.txt 200\\", \\"CREATE file1.txt 150\\", \\"LIST\\", \\"END\\" ] # Capture the output captured_output = StringIO() sys.stdout = captured_output fs.run_commands(commands) output = captured_output.getvalue() sys.stdout = sys.__stdout__ expected_output = \\"file1.txt: 150nfile2.txt: 200n\\" assert output == expected_output def test_delete_and_list(): fs = FileSystem() commands = [ \\"CREATE file1.txt 100\\", \\"CREATE file2.txt 200\\", \\"DELETE file2.txt\\", \\"LIST\\", \\"END\\" ] # Capture the output captured_output = StringIO() sys.stdout = captured_output fs.run_commands(commands) output = captured_output.getvalue() sys.stdout = sys.__stdout__ expected_output = \\"file1.txt: 100n\\" assert output == expected_output def test_total(): fs = FileSystem() commands = [ \\"CREATE file1.txt 100\\", \\"CREATE file2.txt 200\\", \\"TOTAL\\", \\"END\\" ] # Capture the output captured_output = StringIO() sys.stdout = captured_output fs.run_commands(commands) output = captured_output.getvalue() sys.stdout = sys.__stdout__ expected_output = \\"Total: 300n\\" assert output == expected_output def test_complex_commands(): fs = FileSystem() commands = [ \\"CREATE file1.txt 100\\", \\"CREATE file2.txt 200\\", \\"CREATE file1.txt 150\\", \\"LIST\\", \\"DELETE file2.txt\\", \\"LIST\\", \\"TOTAL\\", \\"CREATE file3.txt 300\\", \\"TOTAL\\", \\"END\\" ] # Capture the output captured_output = StringIO() sys.stdout = captured_output fs.run_commands(commands) output = captured_output.getvalue() sys.stdout = sys.__stdout__ expected_output = ( \\"file1.txt: 150n\\" \\"file2.txt: 200n\\" \\"file1.txt: 150n\\" \\"Total: 150n\\" \\"Total: 450n\\" ) assert output == expected_output","solution":"class FileSystem: def __init__(self): self.files = {} def create(self, name, size): self.files[name] = size def delete(self, name): if name in self.files: del self.files[name] def list_files(self): for name, size in sorted(self.files.items(), key=lambda x: (x[1], x[0])): print(f\\"{name}: {size}\\") def total_size(self): total = sum(self.files.values()) print(f\\"Total: {total}\\") def run_commands(self, commands): for command in commands: if command == \\"END\\": break parts = command.split() cmd, args = parts[0], parts[1:] if cmd == 'CREATE': self.create(args[0], int(args[1])) elif cmd == 'DELETE': self.delete(args[0]) elif cmd == 'LIST': self.list_files() elif cmd == 'TOTAL': self.total_size()"},{"question":"from typing import List, Tuple def max_path_weight(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the maximum weight of a path between two nodes in the graph. Parameters: n : int : number of vertices m : int : number of edges edges : List[Tuple[int, int, int]] : list of edges, each represented as a tuple (u, v, w) Returns: int : maximum weight of a path between any two nodes or -1 if no path exists pass def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 result = max_path_weight(n, m, edges) print(result) # Unit Tests def test_example_1(): n = 4 m = 4 edges = [ (1, 2, 3), (2, 3, 4), (3, 4, 1), (1, 4, 10) ] assert max_path_weight(n, m, edges) == 10 def test_example_2(): n = 5 m = 3 edges = [ (1, 2, 5), (2, 3, 6), (4, 5, 3) ] assert max_path_weight(n, m, edges) == 6 def test_single_edge(): n = 2 m = 1 edges = [ (1, 2, 7) ] assert max_path_weight(n, m, edges) == 7 def test_disconnected_graph(): n = 4 m = 2 edges = [ (1, 2, 5), (3, 4, 9) ] assert max_path_weight(n, m, edges) == 9 def test_large_weights(): n = 3 m = 3 edges = [ (1, 2, 1000), (2, 3, 999), (1, 3, 1001) ] assert max_path_weight(n, m, edges) == 1001 def test_no_path(): n = 3 m = 0 edges = [] assert max_path_weight(n, m, edges) == -1","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def max_path_weight(n, m, edges): edges.sort(key=lambda x: x[2], reverse=True) uf = UnionFind(n) max_weight = -1 for u, v, w in edges: if uf.find(u - 1) != uf.find(v - 1): max_weight = max(max_weight, w) uf.union(u - 1, v - 1) return max_weight def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] index = 2 for _ in range(m): u = int(data[index]) v = int(data[index + 1]) w = int(data[index + 2]) edges.append((u, v, w)) index += 3 result = max_path_weight(n, m, edges) print(result)"},{"question":"from typing import List def validate_password(password: str) -> str: Validate if the given password meets the company's policy. - Minimum 8 characters - At least one uppercase letter - At least one lowercase letter - At least one digit - At least one special character from the set {'@', '#', '%', '&', ''} Args: password (str): The password string to validate. Returns: str: \\"YES\\" if the password meets the criteria, otherwise \\"NO\\". def check_passwords(passwords: List[str]) -> List[str]: Check a list of passwords against the company's policy. Args: passwords (List[str]): A list of password strings. Returns: List[str]: A list with \\"YES\\" or \\"NO\\" for each password indicating if it meets the criteria. >>> check_passwords([\\"Password123@\\", \\"short1&\\", \\"StrongPass#\\", \\"NoDigits\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"NO\\"] >>> check_passwords([\\"Valid1@Pass\\", \\"AnotherValid1%\\", \\"TestCase123\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> check_passwords([\\"short1\\", \\"noSpecial123\\", \\"NOLOWERCASE@1\\", \\"noupperspecial1\\"]) [\\"NO\\", \\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def validate_password(password): if len(password) < 8: return \\"NO\\" has_upper = False has_lower = False has_digit = False has_special = False special_characters = {'@', '#', '%', '&', ''} for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True if has_upper and has_lower and has_digit and has_special: return \\"YES\\" else: return \\"NO\\" def check_passwords(passwords): results = [] for password in passwords: results.append(validate_password(password)) return results"},{"question":"def smallest_enclosing_rectangle(points): Given a list of points, returns the coordinates of the smallest axis-aligned rectangle that can fully enclose all the given points. Args: points (List[Tuple[int, int]]): A list of tuples where each tuple represents the (x, y) coordinates of a point. Returns: Tuple[int, int, int, int]: A tuple containing four integers: x_min, y_min, x_max, and y_max. Examples: >>> smallest_enclosing_rectangle([(0, 0)]) (0, 0, 0, 0) >>> smallest_enclosing_rectangle([(1, 2), (3, 4)]) (1, 2, 3, 4) >>> smallest_enclosing_rectangle([(1, 3), (4, 4), (3, 1), (2, 2)]) (1, 1, 4, 4) >>> smallest_enclosing_rectangle([(-1, -1), (0, 0), (1, 1)]) (-1, -1, 1, 1) >>> smallest_enclosing_rectangle([(-2, 4), (-3, -1), (0, 5), (7, -3), (3, 2)]) (-3, -3, 7, 5) pass","solution":"def smallest_enclosing_rectangle(points): Given a list of points, returns the coordinates of the smallest axis-aligned rectangle that can fully enclose all the given points. if not points: raise ValueError(\\"List of points is empty\\") x_min = min(point[0] for point in points) y_min = min(point[1] for point in points) x_max = max(point[0] for point in points) y_max = max(point[1] for point in points) return x_min, y_min, x_max, y_max"},{"question":"def process_queries(Q: int, queries: List[str]) -> List[str]: Process a list of queries on a dynamic string list, which supports add, remove, and reverse operations. Returns results of remove operations. Args: Q: Number of queries queries: List of query strings Returns: List of results for 'REMOVE' queries. If the specified position is out of bounds, returns \\"None\\". Example: >>> process_queries(6, [\\"ADD hello\\", \\"ADD world\\", \\"REMOVE 2\\", \\"ADD python\\", \\"REVERSE\\", \\"REMOVE 1\\"]) [\\"world\\", \\"python\\"] >>> process_queries(5, [\\"ADD a\\", \\"ADD b\\", \\"REMOVE 3\\", \\"REVERSE\\", \\"REMOVE 2\\"]) [\\"None\\", \\"a\\"]","solution":"def process_queries(Q, queries): lst = [] results = [] for query in queries: parts = query.split() command = parts[0] if command == \\"ADD\\": s = ' '.join(parts[1:]) lst.append(s) elif command == \\"REMOVE\\": k = int(parts[1]) - 1 if 0 <= k < len(lst): removed = lst.pop(k) results.append(removed) else: results.append(\\"None\\") elif command == \\"REVERSE\\": lst.reverse() return results"},{"question":"def count_palindromic_numbers(a: int, b: int) -> int: Returns the count of palindromic numbers in the range [a, b]. >>> count_palindromic_numbers(1, 10) 9 >>> count_palindromic_numbers(100, 200) 10 >>> count_palindromic_numbers(1, 9) 9 >>> count_palindromic_numbers(123, 130) 0 >>> count_palindromic_numbers(230, 300) 7 >>> count_palindromic_numbers(99, 99) 1","solution":"def count_palindromic_numbers(a, b): Returns the count of palindromic numbers in the range [a, b]. count = 0 for num in range(a, b + 1): if str(num) == str(num)[::-1]: count += 1 return count"},{"question":"def find_leaders(arr): Returns a list of leaders in the array. A leader is an element that is strictly greater than all the elements to its right side. >>> find_leaders([16, 17, 4, 3, 5, 2]) == [17, 5, 2] >>> find_leaders([1, 2, 3, 4, 5]) == [5] >>> find_leaders([10]) == [10] >>> find_leaders([7, 7, 7, 7, 7]) == [7] >>> find_leaders([5, 4, 3, 2, 1]) == [5, 4, 3, 2, 1] >>> find_leaders([1, 2, 3, 4, 5]) == [5]","solution":"def find_leaders(arr): Returns a list of leaders in the array. A leader is an element that is strictly greater than all the elements to its right side. n = len(arr) leaders = [] max_from_right = float('-inf') for i in range(n-1, -1, -1): if arr[i] > max_from_right: leaders.append(arr[i]) max_from_right = arr[i] # reverse the list since we collected leaders from the end to the beginning leaders.reverse() return leaders"},{"question":"def longest_beautiful_substring(s: str) -> int: Find the length of the longest substring with at most two distinct characters. >>> longest_beautiful_substring(\\"eceba\\") 3 >>> longest_beautiful_substring(\\"aaaabbcc\\") 6 >>> longest_beautiful_substring(\\"abcabc\\") 2","solution":"def longest_beautiful_substring(s): Finds the length of the longest substring with at most two distinct characters. n = len(s) if n == 0: return 0 max_length = 0 window_start = 0 char_frequency = {} for window_end in range(n): char_end = s[window_end] if char_end not in char_frequency: char_frequency[char_end] = 0 char_frequency[char_end] += 1 while len(char_frequency) > 2: char_start = s[window_start] char_frequency[char_start] -= 1 if char_frequency[char_start] == 0: del char_frequency[char_start] window_start += 1 current_length = window_end - window_start + 1 max_length = max(max_length, current_length) return max_length"},{"question":"def is_path_exist(n: int, sx: int, sy: int, dx: int, dy: int, maze: List[str]) -> str: Determines if there is a path from (sx, sy) to (dx, dy) in an n x n maze. Parameters: n (int): The size of the maze. sx (int): Starting x-coordinate. sy (int): Starting y-coordinate. dx (int): Destination x-coordinate. dy (int): Destination y-coordinate. maze (list of list of str): The n x n maze represented as a list of strings. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. import pytest from solution import is_path_exist def test_example1(): n = 5 sx, sy = 1, 1 dx, dy = 5, 5 maze = [ \\".....\\", \\".#...\\", \\".#...\\", \\".#.#.\\", \\".....\\" ] assert is_path_exist(n, sx, sy, dx, dy, maze) == \\"YES\\" def test_example2(): n = 3 sx, sy = 1, 1 dx, dy = 3, 3 maze = [ \\"...\\", \\"#..\\", \\"..#\\" ] assert is_path_exist(n, sx, sy, dx, dy, maze) == \\"NO\\" def test_no_path_due_to_walls(): n = 4 sx, sy = 1, 1 dx, dy = 4, 4 maze = [ \\".#..\\", \\"#.#.\\", \\".#..\\", \\"..#.\\" ] assert is_path_exist(n, sx, sy, dx, dy, maze) == \\"NO\\" def test_single_cell_maze(): n = 1 sx, sy = 1, 1 dx, dy = 1, 1 maze = [ \\".\\" ] assert is_path_exist(n, sx, sy, dx, dy, maze) == \\"YES\\" def test_complex_path(): n = 6 sx, sy = 1, 1 dx, dy = 6, 6 maze = [ \\"......\\", \\"\\", \\"......\\", \\"\\", \\"......\\", \\"\\" ] assert is_path_exist(n, sx, sy, dx, dy, maze) == \\"NO\\" def test_max_size_maze_with_path(): n = 1000 sx, sy = 1, 1 dx, dy = 1000, 1000 maze = [ \\".\\" * 1000 if i % 2 == 0 else \\"#.\\" + (\\"#\\" * 998) for i in range(1000) ] maze[999] = \\".\\" * 1000 # Make sure the last row is open assert is_path_exist(n, sx, sy, dx, dy, maze) == \\"YES\\" if __name__ == \\"__main__\\": pytest.main()","solution":"def is_path_exist(n, sx, sy, dx, dy, maze): Determines if there is a path from (sx, sy) to (dx, dy) in an n x n maze. Parameters: n (int): The size of the maze. sx (int): Starting x-coordinate. sy (int): Starting y-coordinate. dx (int): Destination x-coordinate. dy (int): Destination y-coordinate. maze (list of list of str): The n x n maze represented as a list of strings. Returns: str: \\"YES\\" if a path exists, \\"NO\\" otherwise. from collections import deque # Direction vectors for up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Convert to 0-indexed for internal use sx -= 1 sy -= 1 dx -= 1 dy -= 1 # Create a visited matrix visited = [[False] * n for _ in range(n)] # Use BFS for pathfinding queue = deque([(sx, sy)]) visited[sx][sy] = True while queue: x, y = queue.popleft() if (x, y) == (dx, dy): return \\"YES\\" for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and maze[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\" # Example usage: n = 5 sx, sy = 1, 1 dx, dy = 5, 5 maze = [ \\".....\\", \\".#...\\", \\".#...\\", \\".#.#.\\", \\".....\\" ] print(is_path_exist(n, sx, sy, dx, dy, maze)) # Output: \\"YES\\""},{"question":"def reverseVowels(s: str) -> str: Reverse the order of vowels in the input string without changing the position of consonants. Args: s (str): Input string. Returns: str: String with vowels reversed. >>> reverseVowels(\\"hello\\") 'holle' >>> reverseVowels(\\"world\\") 'world' >>> reverseVowels(\\"leetcode\\") 'leotcede' >>> reverseVowels(\\"bcdfg\\") 'bcdfg' >>> reverseVowels(\\"\\") '' >>> reverseVowels(\\"aA\\") 'Aa' >>> reverseVowels(\\"Hello\\") 'Holle' >>> reverseVowels(\\"programming\\") 'prigrammong' >>> reverseVowels(\\" a e i o u\\") ' u o i e a'","solution":"def reverseVowels(s): Reverse the order of vowels in the input string without changing the position of consonants. Args: s (str): Input string. Returns: str: String with vowels reversed. vowels = 'aeiouAEIOU' s_list = list(s) left, right = 0, len(s) - 1 while left < right: if s_list[left] not in vowels: left += 1 elif s_list[right] not in vowels: right -= 1 else: s_list[left], s_list[right] = s_list[right], s_list[left] left += 1 right -= 1 return ''.join(s_list)"},{"question":"def minimum_total_cost(n: int, k: int, costs: List[int]) -> int: Returns the minimum total cost to buy exactly k cakes. Parameters: n (int): Number of different types of cakes k (int): Exact number of cakes to purchase costs (list of int): List of costs of each type of cake Returns: int: Minimum cost to buy exactly k cakes Examples: >>> minimum_total_cost(3, 5, [2, 3, 1]) 5 >>> minimum_total_cost(4, 10, [5, 4, 8, 2]) 20 >>> minimum_total_cost(2, 6, [7, 8]) 42 >>> minimum_total_cost(5, 1, [10, 20, 30, 40, 50]) 10","solution":"def minimum_total_cost(n, k, costs): Returns the minimum total cost to buy exactly k cakes. Parameters: n (int): Number of different types of cakes k (int): Exact number of cakes to purchase costs (list of int): List of costs of each type of cake Returns: int: Minimum cost to buy exactly k cakes costs.sort() return sum(costs[0] * k for _ in range(1)) # To use this function, you would typically parse the input as follows: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) k = int(data[1]) costs = list(map(int, data[2:])) print(minimum_total_cost(n, k, costs))"},{"question":"def min_sprinklers(L, sprinklers): Determines the minimum number of sprinklers required to cover the entire length of the land. Args: L (int): length of the land sprinklers (list of tuples): each tuple contains position and range of sprinkler Returns: int: Minimum number of sprinklers needed or -1 if it's not possible to cover entire land >>> min_sprinklers(10, [(2, 3), (4, 2), (6, 4)]) 2 >>> min_sprinklers(8, [(0, 3), (6, 2)]) -1 >>> min_sprinklers(5, [(2, 5)]) 1 >>> min_sprinklers(5, [(0, 1), (4, 1)]) -1 >>> min_sprinklers(7, [(2, 2), (5, 2)]) 2 >>> min_sprinklers(10, [(1, 5), (4, 3), (7, 4)]) 2 >>> min_sprinklers(100000, [(i, 1) for i in range(100000)]) 50000 >>> min_sprinklers(10, [(0, 1), (3, 1), (6, 1), (9, 1)]) -1","solution":"def min_sprinklers(L, sprinklers): Determines the minimum number of sprinklers required to cover the entire length of the land. Args: L (int): length of the land sprinklers (list of tuples): each tuple contains position and range of sprinkler Returns: int: Minimum number of sprinklers needed or -1 if it's not possible to cover entire land # Convert each sprinkler to a coverage interval [x-r, x+r] coverage = [] for x, r in sprinklers: coverage.append((max(x - r, 0), min(x + r, L))) # Sort intervals based on starting position coverage.sort() # Variables to track the minimum number of sprinklers num_sprinklers = 0 i = 0 end_reach = 0 max_reach = 0 while end_reach < L: while i < len(coverage) and coverage[i][0] <= end_reach: max_reach = max(max_reach, coverage[i][1]) i += 1 if max_reach == end_reach: return -1 end_reach = max_reach num_sprinklers += 1 return num_sprinklers"},{"question":"def min_removals_to_sort(n: int, task_ids: List[int]) -> int: Returns the minimum number of removals needed so that no intern with a higher id precedes an intern with a lower id. Example: >>> min_removals_to_sort(7, [4, 3, 6, 5, 7, 1, 2]) 4 >>> min_removals_to_sort(5, [1, 2, 3, 4, 5]) 0","solution":"def min_removals_to_sort(n, task_ids): Returns the minimum number of removals needed so that no intern with a higher id precedes an intern with a lower id. # Create an array to store the length of the longest increasing subsequence ending at each index dp = [1] * n # Fill dp[]: For each task id, calculate the LIS ending with task_ids[i] for i in range(1, n): for j in range(i): if task_ids[i] > task_ids[j]: dp[i] = max(dp[i], dp[j] + 1) # Length of the longest increasing subsequence lis_length = max(dp) # Minimum removals needed = Total task_ids - Length of longest increasing subsequence return n - lis_length"},{"question":"def min_insertions_to_palindrome(s: str) -> int: Returns the minimum number of characters needed to be inserted to make the string a palindrome. >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"civic\\") 0 >>> min_insertions_to_palindrome(\\"race\\") 3 pass","solution":"def min_insertions_to_palindrome(s): Returns the minimum number of characters needed to be inserted to make the string a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for j in range(n)] for i in range(n)] # Fill the table for gap in range(1, n): for l in range(n - gap): h = l + gap if s[l] == s[h]: dp[l][h] = dp[l + 1][h - 1] else: dp[l][h] = min(dp[l][h - 1], dp[l + 1][h]) + 1 return dp[0][n - 1]"},{"question":"import heapq from typing import List, Tuple def shortest_distances(n: int, m: int, s: int, routes: List[Tuple[int, int, int]]) -> List[int]: Given n cities and m direct routes, computes the shortest distances from city s to all other cities. Returns a list of n integers where the i-th integer is the shortest distance from city s to city i+1. If a city is not reachable from the starting city, the distance is -1. >>> shortest_distances(4, 4, 1, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7)]) [0, 4, 2, 9] >>> shortest_distances(3, 1, 2, [(1, 3, 5)]) [-1, 0, -1]","solution":"import heapq def shortest_distances(n, m, s, routes): Given n cities and m direct routes, computes the shortest distances from city s to all other cities. Returns a list of n integers where the i-th integer is the shortest distance from city s to city i+1. If a city is not reachable from the starting city, the distance is -1. # Initialize the adjacency list for storing routes adjacency_list = [[] for _ in range(n)] # Fill the adjacency list with the given routes for u, v, d in routes: adjacency_list[u-1].append((d, v-1)) # Use Dijkstra's algorithm to find the shortest path distances = [float('inf')] * n distances[s-1] = 0 min_heap = [(0, s-1)] while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > distances[u]: continue for weight, v in adjacency_list[u]: distance = current_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) # Convert distances to the desired format (replace 'inf' with -1) return [dist if dist != float('inf') else -1 for dist in distances]"},{"question":"def final_loads(n: int, c: int, initial_loads: List[int], commands: List[Tuple[int, int, int]]) -> List[int]: Compute the final loads on each server after applying all load change commands. Parameters: n (int): number of servers c (int): number of load change commands initial_loads (list of int): the initial loads of the servers commands (list of tuples): each tuple contains three integers (s, d, t) - s (int): starting server index (1-based) - d (int): load change value - t (int): ending server index (1-based) Returns: list of int: the final loads of the servers","solution":"def final_loads(n, c, initial_loads, commands): Compute the final loads on each server after applying all load change commands. Parameters: n (int): number of servers c (int): number of load change commands initial_loads (list of int): the initial loads of the servers commands (list of tuples): each tuple contains three integers (s, d, t) - s (int): starting server index (1-based) - d (int): load change value - t (int): ending server index (1-based) Returns: list of int: the final loads of the servers loads = initial_loads[:] for s, d, t in commands: for i in range(s-1, t): loads[i] += d return loads"},{"question":"def manage_stack(k: int, operations: list) -> list: Manages a stack with a set of operations and returns results for type 3 operations. Parameters: k (int): Number of operations operations (list of tuples): List of operations to perform on the stack Returns: list of int: Results of type 3 operations # Example test cases def test_example_case(): assert manage_stack(5, [(1, 3, 5), (1, 2, 10), (3,), (2, 4), (3,)]) == [10, 5] def test_empty_stack_case(): assert manage_stack(2, [(3,), (1, 1, 5)]) == [\\"Empty\\"] def test_push_and_max(): assert manage_stack(4, [(1, 1, 5), (1, 1, 6), (1, 1, 7), (3,)]) == [7] def test_multiple_ops(): assert manage_stack(6, [(1, 1, 1), (1, 1, 2), (3,), (2, 1), (3,), (2, 1)]) == [2, 1] def test_remove_more_than_present(): assert manage_stack(3, [(1, 1, 10), (2, 2), (3,)]) == [\\"Empty\\"]","solution":"def manage_stack(k, operations): Manages a stack with a set of operations and returns results for type 3 operations. Parameters: k (int): Number of operations operations (list of tuples): List of operations to perform on the stack Returns: list of int: Results of type 3 operations stack = [] result = [] for operation in operations: if operation[0] == 1: p, x = operation[1], operation[2] stack.extend([x] * p) elif operation[0] == 2: q = operation[1] del stack[-q:] elif operation[0] == 3: if stack: result.append(max(stack)) else: result.append(\\"Empty\\") return result"},{"question":"def process_queries(n: int, q: int, queries: List[List[int]]) -> List[int]: Process a list of queries on an array of zeros. Args: n: number of elements in the array q: number of queries queries: list of queries of two types * '1 x d': increase the value at index 'x' (1-based index) by 'd' * '2 l r': compute and return the sum of the elements in the subarray from index 'l' to 'r' (inclusive) Returns: List of results for type 2 queries. Examples: >>> process_queries(5, 5, [ ... [1, 1, 5], ... [1, 2, 3], ... [2, 1, 2], ... [1, 5, 10], ... [2, 4, 5] ... ]) [8, 10] >>> process_queries(3, 3, [ ... [1, 1, 4], ... [1, 2, 2], ... [1, 3, 1] ... ]) []","solution":"def process_queries(n, q, queries): a = [0] * n results = [] for query in queries: t = query[0] if t == 1: x, d = query[1], query[2] a[x-1] += d elif t == 2: l, r = query[1], query[2] results.append(sum(a[l-1:r])) return results"},{"question":"class Company: def __init__(self): self.employees = {} def hire(self, id: int, salary: int): pass def fire(self, id: int): pass def promote(self, id: int, increment: int): pass def check(self, id: int): pass def process_queries(q, queries): Process a series of company employee operations. Parameters: - q: Number of queries - queries: List of string queries in the format: '1 id salary' for hire, '2 id' for fire, '3 id increment' for promote, '4 id' for check Returns: - List of results from 'check' operations. >>> queries = [\\"1 101 50000\\", \\"1 102 60000\\", \\"3 101 5000\\", \\"4 101\\", \\"4 103\\"] >>> process_queries(5, queries) [55000, \\"Employee not found\\"] >>> queries = [\\"1 201 45000\\", \\"2 201\\", \\"4 201\\", \\"4 202\\"] >>> process_queries(4, queries) [\\"Employee not found\\", \\"Employee not found\\"] import pytest def test_company_operations(): queries = [ \\"1 101 50000\\", \\"1 102 60000\\", \\"3 101 5000\\", \\"4 101\\", \\"4 103\\" ] result = process_queries(5, queries) assert result == [55000, \\"Employee not found\\"] queries = [ \\"1 201 45000\\", \\"2 201\\", \\"4 201\\", \\"4 202\\" ] result = process_queries(4, queries) assert result == [\\"Employee not found\\", \\"Employee not found\\"] def test_hire_and_check(): queries = [ \\"1 301 70000\\", \\"4 301\\" ] result = process_queries(2, queries) assert result == [70000] def test_fire_and_check(): queries = [ \\"1 401 80000\\", \\"2 401\\", \\"4 401\\" ] result = process_queries(3, queries) assert result == [\\"Employee not found\\"] def test_promote_and_check(): queries = [ \\"1 501 90000\\", \\"3 501 10000\\", \\"4 501\\" ] result = process_queries(3, queries) assert result == [100000] def test_check_non_existent_employee(): queries = [ \\"4 601\\" ] result = process_queries(1, queries) assert result == [\\"Employee not found\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"class Company: def __init__(self): self.employees = {} def hire(self, id: int, salary: int): self.employees[id] = salary def fire(self, id: int): if id in self.employees: del self.employees[id] def promote(self, id: int, increment: int): if id in self.employees: self.employees[id] += increment def check(self, id: int): if id in self.employees: return self.employees[id] else: return \\"Employee not found\\" def process_queries(q, queries): company = Company() results = [] for query in queries: parts = query.split() action = int(parts[0]) if action == 1: id = int(parts[1]) salary = int(parts[2]) company.hire(id, salary) elif action == 2: id = int(parts[1]) company.fire(id) elif action == 3: id = int(parts[1]) increment = int(parts[2]) company.promote(id, increment) elif action == 4: id = int(parts[1]) result = company.check(id) results.append(result) return results"},{"question":"from typing import List, Tuple def fix_and_sum_revenues(sales: List[int]) -> Tuple[List[int], int]: This function takes a list of integers representing daily sales revenues and returns a tuple. The first element of the tuple is a list where all negative numbers in the input list are replaced with zero. The second element is the total revenue of the corrected list. Parameters: sales (List[int]): The list of daily sales revenues, which may contain negative values. Returns: Tuple[List[int], int]: A tuple containing the corrected list of revenues and the total revenue. pass def test_fix_and_sum_revenues(): # Test case 1: Example given in the question assert fix_and_sum_revenues([120, -45, 300, -10, 200]) == ([120, 0, 300, 0, 200], 620) # Test case 2: All positive values assert fix_and_sum_revenues([100, 200, 300]) == ([100, 200, 300], 600) # Test case 3: All negative values assert fix_and_sum_revenues([-100, -200, -300]) == ([0, 0, 0], 0) # Test case 4: Mixed values assert fix_and_sum_revenues([0, -1, 2, -3, 4, -5]) == ([0, 0, 2, 0, 4, 0], 6) # Test case 5: Single value, positive assert fix_and_sum_revenues([50]) == ([50], 50) # Test case 6: Single value, negative assert fix_and_sum_revenues([-50]) == ([0], 0) # Test case 7: Mixed positive and zero assert fix_and_sum_revenues([0, 5, 0, 10, 0]) == ([0, 5, 0, 10, 0], 15) def test_edge_cases(): # Minimum constraint case assert fix_and_sum_revenues([-10**3]) == ([0], 0) # Maximum constraint case with mixed values large_sales = [(-10**3 if i % 2 == 0 else 10**3) for i in range(10**4)] expected_corrected_sales = [0 if i % 2 == 0 else 10**3 for i in range(10**4)] expected_total_revenue = (10**3 * (10**4 // 2)) assert fix_and_sum_revenues(large_sales) == (expected_corrected_sales, expected_total_revenue)","solution":"from typing import List, Tuple def fix_and_sum_revenues(sales: List[int]) -> Tuple[List[int], int]: This function takes a list of integers representing daily sales revenues and returns a tuple. The first element of the tuple is a list where all negative numbers in the input list are replaced with zero. The second element is the total revenue of the corrected list. Parameters: sales (List[int]): The list of daily sales revenues, which may contain negative values. Returns: Tuple[List[int], int]: A tuple containing the corrected list of revenues and the total revenue. corrected_sales = [max(rev, 0) for rev in sales] total_revenue = sum(corrected_sales) return corrected_sales, total_revenue"},{"question":"def count_matching_numbers(participant_numbers, winning_numbers): Returns the number of matching numbers between participant's ticket and the winning numbers. :param participant_numbers: List of 6 distinct integers chosen by the participant :param winning_numbers: List of 6 distinct integers chosen as the winning numbers :return: Integer count of matching numbers from typing import List def test_all_numbers_match(): participant_numbers = [1, 2, 3, 4, 5, 6] winning_numbers = [6, 5, 4, 3, 2, 1] assert count_matching_numbers(participant_numbers, winning_numbers) == 6 def test_no_numbers_match(): participant_numbers = [10, 20, 30, 40, 50, 49] winning_numbers = [1, 2, 3, 4, 5, 6] assert count_matching_numbers(participant_numbers, winning_numbers) == 0 def test_some_numbers_match(): participant_numbers = [5, 15, 25, 35, 45, 49] winning_numbers = [49, 35, 25, 15, 5, 1] assert count_matching_numbers(participant_numbers, winning_numbers) == 5 def test_one_number_matches(): participant_numbers = [7, 14, 21, 28, 35, 42] winning_numbers = [1, 7, 13, 19, 25, 31] assert count_matching_numbers(participant_numbers, winning_numbers) == 1 def test_edge_case_min_values(): participant_numbers = [1, 2, 3, 4, 5, 6] winning_numbers = [7, 8, 9, 10, 11, 12] assert count_matching_numbers(participant_numbers, winning_numbers) == 0 def test_edge_case_max_values(): participant_numbers = [44, 45, 46, 47, 48, 49] winning_numbers = [42, 43, 44, 45, 46, 47] assert count_matching_numbers(participant_numbers, winning_numbers) == 4","solution":"def count_matching_numbers(participant_numbers, winning_numbers): Returns the number of matching numbers between participant's ticket and the winning numbers. :param participant_numbers: List of 6 distinct integers chosen by the participant :param winning_numbers: List of 6 distinct integers chosen as the winning numbers :return: Integer count of matching numbers participant_set = set(participant_numbers) winning_set = set(winning_numbers) matching_numbers = participant_set.intersection(winning_set) return len(matching_numbers)"},{"question":"from typing import List, Tuple def count_and_archive_messages(n: int, messages: List[Tuple[int, int]]) -> List[Tuple[int, int, int]]: Counts and archives all the messages sent between each pair of employees. Parameters: n (int): the number of messages sent messages (list of tuples): list containing pairs of integers representing sender and recipient Returns: list of tuples: each tuple contains three integers representing the sender, recipient, and the number of messages exchanged def test_count_and_archive_messages_example_1(): n = 6 messages = [(1, 2), (2, 3), (1, 2), (2, 1), (3, 1), (2, 1)] expected_output = [(1, 2, 2), (2, 3, 1), (2, 1, 2), (3, 1, 1)] assert sorted(count_and_archive_messages(n, messages)) == sorted(expected_output) def test_count_and_archive_messages_example_2(): n = 5 messages = [(1, 2), (2, 3), (4, 5), (1, 3), (4, 5)] expected_output = [(1, 2, 1), (2, 3, 1), (1, 3, 1), (4, 5, 2)] assert sorted(count_and_archive_messages(n, messages)) == sorted(expected_output) def test_count_and_archive_messages_example_3(): n = 4 messages = [(1, 2), (2, 3), (1, 2), (3, 4)] expected_output = [(1, 2, 2), (2, 3, 1), (3, 4, 1)] assert sorted(count_and_archive_messages(n, messages)) == sorted(expected_output) def test_count_and_archive_messages_single_message(): n = 1 messages = [(1, 2)] expected_output = [(1, 2, 1)] assert count_and_archive_messages(n, messages) == expected_output def test_count_and_archive_messages_with_varied_senders_recipients(): n = 3 messages = [(1, 2), (2, 1), (3, 1)] expected_output = [(1, 2, 1), (2, 1, 1), (3, 1, 1)] assert sorted(count_and_archive_messages(n, messages)) == sorted(expected_output)","solution":"from collections import defaultdict def count_and_archive_messages(n, messages): Counts and archives all the messages sent between each pair of employees. Parameters: n (int): the number of messages sent messages (list of tuples): list containing pairs of integers representing sender and recipient Returns: list of tuples: each tuple contains three integers representing the sender, recipient, and the number of messages exchanged counts = defaultdict(int) # Count the messages for si, ri in messages: counts[(si, ri)] += 1 # Convert result to required format result = [(si, ri, count) for (si, ri), count in counts.items()] return result"},{"question":"def can_fulfill_order(n: int, inventory: List[Tuple[int, int]], m: int, order: List[Tuple[int, int]]) -> str: Determine if the order can be fulfilled with the current inventory. :param n: int - number of different item types in inventory (1 <= n <= 100) :param inventory: list of tuples - each tuple contains an integer (item id) and the available quantity :param m: int - number of different item types in the customer's order (1 <= m <= 100) :param order: list of tuples - each tuple contains an integer (item id) and the required quantity :return: str - \\"Yes\\" if the order can be fulfilled, otherwise \\"No\\" >>> can_fulfill_order(3, [(1, 10), (2, 5), (3, 7)], 2, [(1, 5), (2, 5)]) == \\"Yes\\" >>> can_fulfill_order(3, [(1, 8), (2, 6), (3, 3)], 2, [(1, 9), (3, 2)]) == \\"No\\"","solution":"def can_fulfill_order(n, inventory, m, order): Determine if the order can be fulfilled with the current inventory. :param n: int - number of different item types in inventory (1 <= n <= 100) :param inventory: list of tuples - each tuple contains an integer (item id) and the available quantity :param m: int - number of different item types in the customer's order (1 <= m <= 100) :param order: list of tuples - each tuple contains an integer (item id) and the required quantity :return: str - \\"Yes\\" if the order can be fulfilled, otherwise \\"No\\" inventory_dict = dict(inventory) for item_id, required_quantity in order: if item_id not in inventory_dict or inventory_dict[item_id] < required_quantity: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List def max_energy_packs(rows: int, cols: int, initial_energy: int, grid: List[str]) -> int: Calculate the maximum number of energy packs the robot can collect in a grid. Parameters: rows (int): Number of rows in the grid. cols (int): Number of columns in the grid. initial_energy (int): Initial amount of energy the robot starts with. grid (List[str]): 2D list representing the grid. Returns: int: Maximum number of energy packs collected. Example: >>> rows = 5 >>> cols = 7 >>> initial_energy = 10 >>> grid = ['#R.....#', '.#E#E#.#', '.#...#.#', '.#E#E#.#', '#.....'] >>> max_energy_packs(rows, cols, initial_energy, grid) 4 >>> rows = 3 >>> cols = 3 >>> initial_energy = 5 >>> grid = ['R..', '.#.', '...'] >>> max_energy_packs(rows, cols, initial_energy, grid) 0","solution":"def max_energy_packs(rows, cols, initial_energy, grid): from collections import deque # Find starting position start_row, start_col = None, None for r in range(rows): for c in range(cols): if grid[r][c] == 'R': start_row, start_col = r, c break if start_row is not None: break directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # BFS initialization queue = deque([(start_row, start_col, initial_energy)]) visited = set((start_row, start_col)) total_energy_packs = 0 # BFS traversal while queue: x, y, energy = queue.popleft() if grid[x][y] == 'E': total_energy_packs += 1 if energy > 0: for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] != '#': queue.append((nx, ny, energy - 1)) visited.add((nx, ny)) return total_energy_packs # Example Usage rows = 5 cols = 7 initial_energy = 10 grid = [ '#R.....#', '.#E#E#.#', '.#...#.#', '.#E#E#.#', '#.....' ] print(max_energy_packs(rows, cols, initial_energy, grid)) # Output: 4"},{"question":"def is_balanced_parentheses(s: str) -> str: Checks if the given string s containing only '(' and ')' is balanced. >>> is_balanced_parentheses(\\"()\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\"((()))\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\"(()))\\") == \\"Not Balanced\\" >>> is_balanced_parentheses(\\"(\\") == \\"Not Balanced\\" >>> is_balanced_parentheses(\\")\\") == \\"Not Balanced\\" >>> is_balanced_parentheses(\\"\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\"()()\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\"((())())\\") == \\"Balanced\\" >>> is_balanced_parentheses(\\")((()())\\") == \\"Not Balanced\\" pass def balanced_parentheses(strings: List[str]) -> List[str]: Determines if each string in the list strings is balanced. >>> balanced_parentheses([\\"()\\", \\"((()))\\", \\"(()))\\"]) == [\\"Balanced\\", \\"Balanced\\", \\"Not Balanced\\"] >>> balanced_parentheses([\\"(\\", \\")\\", \\"()()\\"]) == [\\"Not Balanced\\", \\"Not Balanced\\", \\"Balanced\\"] >>> balanced_parentheses([\\"\\", \\"()(()))\\", \\"((()())\\"]) == [\\"Balanced\\", \\"Not Balanced\\", \\"Not Balanced\\"] pass","solution":"def is_balanced_parentheses(s): Checks if the given string s containing only '(' and ')' is balanced. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"Not Balanced\\" stack.pop() return \\"Balanced\\" if not stack else \\"Not Balanced\\" def balanced_parentheses(strings): Determines if each string in the list strings is balanced. results = [] for s in strings: results.append(is_balanced_parentheses(s)) return results # Example usage: # T = int(input()) # strings = [input().strip() for _ in range(T)] # results = balanced_parentheses(strings) # for result in results: # print(result)"},{"question":"def simulate_memory_operations(n: int, m: int, initial_memory: List[str], write_operations: List[Tuple[str, str]]) -> List[str]: Simulate the result of multiple string write operations on computer memory. :param n: Number of initial memory content strings :param m: Number of write operations :param initial_memory: List of strings representing the initial memory content :param write_operations: List of tuples containing the write operations where each tuple consists of the string to replace and the replacement string :return: List of strings representing the final state of the memory >>> simulate_memory_operations(5, 3, [\\"abc\\", \\"def\\", \\"ghi\\", \\"abc\\", \\"jkl\\"], [(\\"abc\\", \\"pqr\\"), (\\"def\\", \\"stu\\"), (\\"ghi\\", \\"vwx\\")]) [\\"pqr\\", \\"stu\\", \\"vwx\\", \\"pqr\\", \\"jkl\\"] >>> simulate_memory_operations(3, 0, [\\"foo\\", \\"bar\\", \\"baz\\"], []) [\\"foo\\", \\"bar\\", \\"baz\\"]","solution":"def simulate_memory_operations(n, m, initial_memory, write_operations): Simulate the result of multiple string write operations on computer memory. :param n: Number of initial memory content strings :param m: Number of write operations :param initial_memory: List of strings representing the initial memory content :param write_operations: List of tuples containing the write operations where each tuple consists of the string to replace and the replacement string :return: List of strings representing the final state of the memory memory = initial_memory[:] for old_str, new_str in write_operations: memory = [new_str if x == old_str else x for x in memory] return memory # Example usage: n = 5 m = 3 initial_memory = [\\"abc\\", \\"def\\", \\"ghi\\", \\"abc\\", \\"jkl\\"] write_operations = [(\\"abc\\", \\"pqr\\"), (\\"def\\", \\"stu\\"), (\\"ghi\\", \\"vwx\\")] print(simulate_memory_operations(n, m, initial_memory, write_operations))"},{"question":"def shortest_subarray_length(n: int, x: int, scores: List[int]) -> int: Finds the length of the shortest subarray whose sum is at least \`x\`. If such a subarray doesn’t exist, return -1. >>> shortest_subarray_length(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> shortest_subarray_length(5, 10, [1, 1, 1, 1, 1]) -1 from solution import shortest_subarray_length def test_example_1(): assert shortest_subarray_length(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 def test_example_2(): assert shortest_subarray_length(5, 10, [1, 1, 1, 1, 1]) == -1 def test_single_element(): assert shortest_subarray_length(1, 1, [1]) == 1 assert shortest_subarray_length(1, 2, [1]) == -1 def test_entire_array(): assert shortest_subarray_length(5, 15, [1, 2, 3, 4, 5]) == 5 def test_subarray_at_start(): assert shortest_subarray_length(6, 7, [1, 3, 4, 1, 2, 2]) == 2 def test_subarray_at_end(): assert shortest_subarray_length(6, 7, [2, 2, 1, 1, 3, 4]) == 2 def test_multiple_valid_subarrays(): assert shortest_subarray_length(7, 15, [1, 2, 3, 4, 5, 6, 7]) == 3 def test_large_array(): assert shortest_subarray_length(100000, 1000000, [10]*100000) == 100000","solution":"def shortest_subarray_length(n, x, scores): Finds the length of the shortest subarray whose sum is at least \`x\`. If such a subarray doesn’t exist, return -1. import sys min_length = sys.maxsize current_sum = 0 start = 0 for end in range(n): current_sum += scores[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= scores[start] start += 1 if min_length == sys.maxsize: return -1 return min_length"},{"question":"def determine_winner(t: int, test_cases: List[str]) -> List[str]: Determine the winner of the palindrome game between Alice and Bob. Arguments: t -- An integer representing the number of test cases. test_cases -- A list of strings representing the test cases. Returns: A list of strings where each string is either \\"Alice\\" or \\"Bob\\" indicating the winner of the respective game. >>> determine_winner(3, [\\"abc\\", \\"racecar\\", \\"aabbcc\\"]) [\\"Alice\\", \\"Alice\\", \\"Bob\\"] >>> determine_winner(1, [\\"a\\"]) [\\"Alice\\"] >>> determine_winner(1, [\\"aaaaaa\\"]) [\\"Bob\\"]","solution":"def determine_winner(t, test_cases): results = [] for s in test_cases: # Count the frequency of each character frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Count the number of characters with odd frequencies odd_count = sum(1 for count in frequency.values() if count % 2 == 1) # If the odd_count is zero, it's a draw according to the rules if odd_count == 0: results.append(\\"Bob\\") else: results.append(\\"Alice\\") return results"},{"question":"def min_rotations_to_transform(n: int, m: int, initial_grid: List[str], target_grid: List[str]) -> int: Explorers Whitfield and Martin have stumbled upon another mystical puzzle, this time involving a magical grid. They discovered a rectangular grid with n rows and m columns, each cell containing a single lowercase Latin letter. The grid has a magical property: the rows or columns can be cyclically rotated, which means that the entire row or column can be shifted one position to the left or right (for rows) or up or down (for columns). Whitfield and Martin need to transform the initial grid to a target grid, using the minimum number of row and column rotations. Your task is to help them achieve this transformation. If it is impossible to transform the initial grid to the target grid using any number of rotations, output a single integer -1. Otherwise, return the minimum number of rotations required to transform the initial grid to the target grid. >>> initial_grid = [\\"abcd\\", \\"efgh\\", \\"ijkl\\"] >>> target_grid = [\\"hgfe\\", \\"abdc\\", \\"lkji\\"] >>> min_rotations_to_transform(3, 4, initial_grid, target_grid) 5 >>> initial_grid = [\\"ab\\", \\"cd\\"] >>> target_grid = [\\"ba\\", \\"dc\\"] >>> min_rotations_to_transform(2, 2, initial_grid, target_grid) 1 def test_min_rotations_to_transform(): initial_grid = [ \\"abcd\\", \\"efgh\\", \\"ijkl\\" ] target_grid = [ \\"hgfe\\", \\"abdc\\", \\"lkji\\" ] assert min_rotations_to_transform(3, 4, initial_grid, target_grid) == 5 initial_grid = [ \\"ab\\", \\"cd\\" ] target_grid = [ \\"ba\\", \\"dc\\" ] assert min_rotations_to_transform(2, 2, initial_grid, target_grid) == 1 initial_grid = [ \\"ab\\", \\"cd\\" ] target_grid = [ \\"ef\\", \\"gh\\" ] assert min_rotations_to_transform(2, 2, initial_grid, target_grid) == -1 initial_grid = [ \\"abc\\", \\"def\\" ] target_grid = [ \\"abc\\", \\"def\\" ] assert min_rotations_to_transform(2, 3, initial_grid, target_grid) == 0 initial_grid = [ \\"ab\\" ] target_grid = [ \\"ba\\" ] assert min_rotations_to_transform(1, 2, initial_grid, target_grid) == 1 initial_grid = [ \\"a\\", \\"b\\" ] target_grid = [ \\"b\\", \\"a\\" ] assert min_rotations_to_transform(2, 1, initial_grid, target_grid) == 1","solution":"def min_rotations_to_transform(initial_grid, target_grid): def rotate_row_left(grid, row_idx): return grid[:row_idx] + [grid[row_idx][1:] + grid[row_idx][:1]] + grid[row_idx + 1:] def rotate_row_right(grid, row_idx): return grid[:row_idx] + [grid[row_idx][-1:] + grid[row_idx][:-1]] + grid[row_idx + 1:] def rotate_col_up(grid, col_idx): return [grid[(i+1)%n][:col_idx] + [grid[i][col_idx]] + grid[(i+1)%n][col_idx+1:] for i in range(n)] def rotate_col_down(grid, col_idx): return [grid[(i-1)%n][:col_idx] + [grid[i][col_idx]] + grid[(i-1)%n][col_idx+1:] for i in range(n)] n = len(initial_grid) m = len(initial_grid[0]) # To store the minimum number of rotations required to match each cell with target grid min_rotations = dict() for i in range(n): for j in range(m): matched = False for dr in range(n): for dc in range(m): if initial_grid[(i + dr) % n][(j + dc) % m] == target_grid[i][j]: min_rotations[(i, j)] = dr + dc matched = True break if matched: break if not matched: return -1 # If we can't match even one cell, return -1 # Since the minimum number of rotations of each cell is stored, we just take the maximum of those total_min_rotations = max(min_rotations.values()) return total_min_rotations"},{"question":"def shortest_travel_times(n, m, roads, s): Returns the shortest travel time from the starting intersection to all other intersections. Using teleportation option makes all direct roads cost zero travel time. Args: n (int): Number of intersections. m (int): Number of roads. roads (List[Tuple[int, int, int]]): List of tuples representing the roads. s (int): Starting intersection. Returns: List[int]: Shortest travel times from starting intersection to each other intersection. Example: >>> test_case_1() >>> test_case_2() >>> test_case_3() >>> test_unreachable() >>> test_single_node() pass def test_case_1(): n = 4 m = 5 roads = [ (1, 2, 5), (2, 3, 4), (1, 3, 10), (1, 4, 6), (3, 4, 1) ] s = 1 assert shortest_travel_times(n, m, roads, s) == [0, 0, 0, 0] def test_case_2(): n = 3 m = 3 roads = [ (1, 2, 1), (1, 3, 4), (2, 3, 2) ] s = 2 assert shortest_travel_times(n, m, roads, s) == [0, 0, 0] def test_case_3(): n = 5 m = 6 roads = [ (1, 2, 1), (1, 3, 2), (2, 4, 1), (3, 4, 1), (4, 5, 1), (3, 5, 3) ] s = 1 assert shortest_travel_times(n, m, roads, s) == [0, 0, 0, 0, 0] def test_unreachable(): n = 4 m = 2 roads = [ (1, 2, 2), (3, 4, 2) ] s = 1 assert shortest_travel_times(n, m, roads, s) == [0, 0, -1, -1] def test_single_node(): n = 1 m = 0 roads = [] s = 1 assert shortest_travel_times(n, m, roads, s) == [0]","solution":"import heapq def shortest_travel_times(n, m, roads, s): Returns the shortest travel time from the starting intersection to all other intersections. Using teleportation option makes all direct roads cost zero travel time. # Initialize distances with -1 (for unreachable intersections) distances = [-1] * n # Using a priority queue for Dijkstra's algorithm pq = [] heapq.heappush(pq, (0, s - 1)) distances[s - 1] = 0 while pq: current_time, current_node = heapq.heappop(pq) for u, v, t in roads: if u - 1 == current_node: new_time = current_time if distances[v - 1] == -1 or new_time < distances[v - 1]: distances[v - 1] = new_time heapq.heappush(pq, (new_time, v - 1)) elif v - 1 == current_node: new_time = current_time if distances[u - 1] == -1 or new_time < distances[u - 1]: distances[u - 1] = new_time heapq.heappush(pq, (new_time, u - 1)) return distances"},{"question":"from typing import List, Tuple def analyze_marathon_times(n: int, k: int, q: int, participants_times: List[List[int]], participants_to_analyze: List[int]) -> List[Tuple[int, int]]: Given the times taken by participants to reach each checkpoint, find the minimum and maximum times for the specified participants between all consecutive pairs of checkpoints. Args: n : int : Number of participants k : int : Number of checkpoints q : int : Number of participants to analyze participants_times : List[List[int]] : Times taken by each participant to reach each checkpoint participants_to_analyze : List[int] : Indices of the participants to analyze (1-based indexing) Returns: List[Tuple[int, int]] : A list of tuples where each tuple contains two integers representing the minimum and maximum times taken by the specified participants between consecutive checkpoints. Example: >>> n, k, q = 5, 4, 3 >>> participants_times = [ ... [2, 5, 7, 10], ... [1, 5, 6, 9], ... [3, 6, 9, 11], ... [4, 8, 12, 14], ... [2, 6, 8, 10] ... ] >>> participants_to_analyze = [1, 3, 5] >>> analyze_marathon_times(n, k, q, participants_times, participants_to_analyze) [(3, 4), (2, 3), (2, 3)] >>> n, k, q = 3, 3, 1 >>> participants_times = [ ... [1, 2, 3], ... [2, 4, 6], ... [3, 5, 7] ... ] >>> participants_to_analyze = [2] >>> analyze_marathon_times(n, k, q, participants_times, participants_to_analyze) [(2, 2), (2, 2)] >>> n, k, q = 3, 3, 3 >>> participants_times = [ ... [1, 2, 3], ... [2, 4, 6], ... [3, 5, 7] ... ] >>> participants_to_analyze = [1, 2, 3] >>> analyze_marathon_times(n, k, q, participants_times, participants_to_analyze) [(1, 2), (1, 2)]","solution":"def analyze_marathon_times(n, k, q, participants_times, participants_to_analyze): # Extract the relevant participant times analyzed_times = [participants_times[i - 1] for i in participants_to_analyze] results = [] # Loop through each consecutive pair of checkpoints for j in range(k - 1): min_time = float('inf') max_time = float('-inf') # Calculate times between checkpoints j and j+1 for each analyzed participant for times in analyzed_times: delta_time = times[j + 1] - times[j] if delta_time < min_time: min_time = delta_time if delta_time > max_time: max_time = delta_time # Append the results for this pair of checkpoints results.append((min_time, max_time)) return results # Example usage: n, k, q = 5, 4, 3 participants_times = [ [2, 5, 7, 10], [1, 5, 6, 9], [3, 6, 9, 11], [4, 8, 12, 14], [2, 6, 8, 10] ] participants_to_analyze = [1, 3, 5] results = analyze_marathon_times(n, k, q, participants_times, participants_to_analyze) for result in results: print(result[0], result[1])"},{"question":"def count_unique_pairs(arr: List[int], k: int) -> int: Counts the number of unique pairs (a, b) in arr such that a + b = k. A pair (a, b) and (b, a) is considered the same. Parameters: arr (list): The list of integers. k (int): The target sum. Returns: int: The number of unique pairs. >>> count_unique_pairs([1, 2, 3, 4, 3], 5) == 2 >>> count_unique_pairs([1, -1, 2, -2, 3, -3], 0) == 3 from typing import List def test_example_cases(): assert count_unique_pairs([1, 2, 3, 4, 3], 5) == 2 assert count_unique_pairs([1, -1, 2, -2, 3, -3], 0) == 3 def test_no_pairs(): assert count_unique_pairs([1, 2, 3, 4], 10) == 0 def test_all_elements_same(): assert count_unique_pairs([5, 5, 5, 5], 10) == 1 def test_negative_pairs(): assert count_unique_pairs([-1, -2, -3, -4, -5], -5) == 2 def test_mixed_positive_negative(): assert count_unique_pairs([-1, 1, 2, -2, 3], 1) == 2 assert count_unique_pairs([-1, 1, 2, -2, 3, 4, -3], 1) == 3 def test_large_numbers(): arr = [10**9, -10**9, 0, 10**9 - 1, 1, -1] assert count_unique_pairs(arr, 0) == 2 def test_duplicate_elements_non_distinguishable(): assert count_unique_pairs([3, 1, 3, 4, 3, 2], 6) == 2","solution":"def count_unique_pairs(arr, k): Counts the number of unique pairs (a, b) in arr such that a + b = k. A pair (a, b) and (b, a) is considered the same. Parameters: arr (list): The list of integers. k (int): The target sum. Returns: int: The number of unique pairs. seen = set() pairs = set() for num in arr: complement = k - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return len(pairs)"},{"question":"def max_sum_subarray_length_m(arr: List[int], n: int, m: int) -> int: Find the maximum sum of any contiguous sub-array of length exactly M. >>> max_sum_subarray_length_m([2, 1, 5, 1, 3, 2], 6, 3) 9 >>> max_sum_subarray_length_m([1, -2, 3, 4], 4, 4) 6 >>> max_sum_subarray_length_m([-1, -2, -3, -4], 4, 2) -3 >>> max_sum_subarray_length_m([1, 2, 3, 4], 4, 1) 4 >>> max_sum_subarray_length_m([0, 0, 0, 0], 4, 2) 0","solution":"def max_sum_subarray_length_m(arr, n, m): if n < m: raise ValueError(\\"N must be greater than or equal to M\\") # Initialize the sum of the first window of size m max_sum = sum(arr[:m]) window_sum = max_sum for i in range(n - m): window_sum = window_sum - arr[i] + arr[i + m] if window_sum > max_sum: max_sum = window_sum return max_sum # Example usage: # n = 6 # m = 3 # arr = [2, 1, 5, 1, 3, 2] # print(max_sum_subarray_length_m(arr, n, m)) # Output: 9"},{"question":"def min_path_sum(grid): Returns the minimum sum of the digits on any path from top-left to bottom-right in the grid. grid: List of List of int: The grid filled with digits. return: int: Minimum sum of the path from top-left to bottom-right. # Implementation here # Unit tests def test_min_path_sum_sample_input(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_path_sum(grid) == 7 def test_min_path_sum_single_cell(): grid = [ [5] ] assert min_path_sum(grid) == 5 def test_min_path_sum_single_row(): grid = [ [1, 2, 3, 4] ] assert min_path_sum(grid) == 10 def test_min_path_sum_single_column(): grid = [ [1], [2], [3], [4] ] assert min_path_sum(grid) == 10 def test_min_path_sum_all_ones(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert min_path_sum(grid) == 5","solution":"def min_path_sum(grid): Returns the minimum sum of the digits on any path from top-left to bottom-right in the grid. grid: List of List of int: The grid filled with digits. return: int: Minimum sum of the path from top-left to bottom-right. N = len(grid) M = len(grid[0]) # Create a 2D list to store the minimum path sum at each cell dp = [[0]*M for _ in range(N)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][M-1]"},{"question":"def find_city_name(n: int, l: int, m: int, q: int, city_data: List[str], queries: List[str]) -> List[str]: Identify which L-tuple of features corresponds to which city name. >>> n = 4 >>> l = 2 >>> m = 100 >>> q = 4 >>> city_data = [\\"paris 45.5 78.1\\", \\"madrid 25.0 89.9\\", \\"rome 78.8 55.5\\", \\"berlin 60.3 72.6\\"] >>> queries = [\\"45.5 78.1\\", \\"60.3 72.6\\", \\"25.0 89.9\\", \\"99.9 99.9\\"] >>> find_city_name(n, l, m, q, city_data, queries) ['paris', 'berlin', 'madrid', 'No match found']","solution":"def find_city_name(n, l, m, q, city_data, queries): city_features_map = {} # Mapping city names to their respective features for data in city_data: parts = data.split() city_name = parts[0] features = tuple(map(float, parts[1:])) city_features_map[features] = city_name results = [] for query in queries: features = tuple(map(float, query.split())) if features in city_features_map: results.append(city_features_map[features]) else: results.append(\\"No match found\\") return results"},{"question":"def has_subarray_with_zero_sum(n: int, arr: List[int]) -> str: Determines if there exists a subarray with a sum equal to zero. >>> has_subarray_with_zero_sum(5, [4, 2, -3, 1, 6]) == \\"Yes\\" >>> has_subarray_with_zero_sum(4, [1, 2, 3, 4]) == \\"No\\"","solution":"def has_subarray_with_zero_sum(n, arr): Determines if there exists a subarray with a sum equal to zero. Parameters: n (int): Length of the array. arr (list of int): List of integers. Returns: str: \\"Yes\\" if there exists a subarray with a sum equal to zero, otherwise \\"No\\". seen_sums = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in seen_sums: return \\"Yes\\" seen_sums.add(current_sum) return \\"No\\""},{"question":"def process_auction_data(input_data: str) -> List[str]: Process auction data and determine the winning bids for each item. >>> input_data = 0 101 50 5 1 101 55 A 1 101 60 B END 0 102 100 3 1 102 110 C END STOP >>> process_auction_data(input_data) [\\"101 B 60\\", \\"102 C 110\\"] >>> input_data = 0 103 20 7 1 103 15 D END STOP >>> process_auction_data(input_data) [\\"103 No valid bids\\"] >>> input_data = 0 104 50 3 END STOP >>> process_auction_data(input_data) [\\"104 No valid bids\\"] >>> input_data = 0 105 80 4 1 105 100 J END 0 106 70 6 1 106 90 K 1 106 95 L END STOP >>> process_auction_data(input_data) [\\"105 J 100\\", \\"106 L 95\\"] # Your implementation here","solution":"class AuctionSystem: def __init__(self): self.items = {} self.bids = {} def list_item(self, item_id, min_bid_price, auction_duration): self.items[item_id] = { 'min_bid_price': min_bid_price, 'auction_duration': auction_duration, 'bids': [] } def place_bid(self, item_id, bid_price, user_id): if item_id in self.items: self.items[item_id]['bids'].append((bid_price, user_id)) def determine_winners(self): results = [] for item_id, item_details in sorted(self.items.items()): valid_bids = [bid for bid in item_details['bids'] if bid[0] >= item_details['min_bid_price']] if valid_bids: max_bid = max(valid_bids, key=lambda x: x[0]) results.append(f\\"{item_id} {max_bid[1]} {max_bid[0]}\\") else: results.append(f\\"{item_id} No valid bids\\") return results def process_auction_data(input_data): auction_system = None result = [] dataset_result = [] for line in input_data.splitlines(): if line == \\"STOP\\": break if line == \\"END\\": result.extend(auction_system.determine_winners()) auction_system = None dataset_result.append(result) result = [] elif line.startswith('0'): if auction_system is None: auction_system = AuctionSystem() _, item_id, min_bid_price, auction_duration = line.split() auction_system.list_item(int(item_id), int(min_bid_price), int(auction_duration)) elif line.startswith('1'): _, item_id, bid_price, user_id = line.split() auction_system.place_bid(int(item_id), int(bid_price), user_id) return [item for sublist in dataset_result for item in sublist]"},{"question":"def sum_of_set_bits(t, test_cases): Calculate the sum of the set bits (1s) in the binary representation of each integer for each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer n followed by n integers. Returns: list of int: Sum of the set bits for each test case. >>> sum_of_set_bits(1, [(3, 1, 2, 3)]) [4] >>> sum_of_set_bits(2, [(3, 1, 2, 3), (4, 4, 5, 6, 7)]) [4, 8] >>> sum_of_set_bits(1, [(1, 1)]) [1] >>> sum_of_set_bits(1, [(1, 1023)]) [10] >>> sum_of_set_bits(1, [(2, 2**30, 2**30 - 1)]) [31] >>> sum_of_set_bits(1, [(5, 7, 7, 7, 7, 7)]) [15]","solution":"def sum_of_set_bits(t, test_cases): Calculate the sum of the set bits (1s) in the binary representation of each integer for each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer n followed by n integers. Returns: list of int: Sum of the set bits for each test case. results = [] for test_case in test_cases: n, *numbers = test_case total_set_bits = sum(bin(num).count('1') for num in numbers) results.append(total_set_bits) return results"},{"question":"def canReachLastStone(stones: List[int], maxJump: int) -> bool: Determine if the frog can reach the last stone. Parameters: - stones: a list of integers representing the x-coordinates of the stones. - maxJump: an integer representing the maximum distance the frog can jump in one go. Returns: - True if the frog can reach the last stone, False otherwise. >>> canReachLastStone([0, 2, 3, 5, 6, 8], 3) True >>> canReachLastStone([0, 5, 6, 12], 5) False >>> canReachLastStone([0], 1) True >>> canReachLastStone([0, 2, 4, 6], 2) True >>> canReachLastStone([0, 1000, 2000, 3000], 1000) True >>> canReachLastStone([0, 1000, 2001, 3000], 1000) False","solution":"def canReachLastStone(stones, maxJump): Determine if the frog can reach the last stone. Parameters: - stones: a list of integers representing the x-coordinates of the stones. - maxJump: an integer representing the maximum distance the frog can jump in one go. Returns: - True if the frog can reach the last stone, False otherwise. n = len(stones) for i in range(n - 1): if stones[i + 1] - stones[i] > maxJump: return False return True"},{"question":"def is_right_angled_triangle(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> str: Determines if the given points form a right-angled triangle. Uses the Pythagorean Theorem to check for right angles: If the squared length of one side equals the sum of the squared lengths of the other two sides, then the triangle is right-angled. >>> is_right_angled_triangle(0, 0, 1, 1, 1, 0) \\"RIGHT\\" >>> is_right_angled_triangle(0, 0, 1, 2, 2, 2) \\"NOT RIGHT\\"","solution":"def is_right_angled_triangle(x1, y1, x2, y2, x3, y3): Determines if the given points form a right-angled triangle. Uses the Pythagorean Theorem to check for right angles: If the squared length of one side equals the sum of the squared lengths of the other two sides, then the triangle is right-angled. def squared_distance(xa, ya, xb, yb): return (xb - xa) ** 2 + (yb - ya) ** 2 d1 = squared_distance(x1, y1, x2, y2) d2 = squared_distance(x2, y2, x3, y3) d3 = squared_distance(x3, y3, x1, y1) if (d1 + d2 == d3) or (d1 + d3 == d2) or (d2 + d3 == d1): return \\"RIGHT\\" else: return \\"NOT RIGHT\\""},{"question":"from typing import List, Tuple def calculate_inventory(transactions: List[Tuple[int, str, int]], timestamps: List[int]) -> List[int]: Calculate the inventory at each requested timestamp. transactions: list of tuples, each tuple contains (t, type, q) timestamps: list of integers representing the requested timestamps Returns a list of integers representing the stock level at each requested timestamp. Example: >>> transactions = [(1, 'restock', 10), (2, 'sell', 5), (2, 'restock', 3), (3, 'sell', 7), (4, 'restock', 5)] >>> timestamps = [2, 3, 4] >>> calculate_inventory(transactions, timestamps) [8, 1, 6] >>> transactions = [(1, 'restock', 10), (2, 'sell', 5), (2, 'sell', 3), (2, 'restock', 8)] >>> timestamps = [2, 3] >>> calculate_inventory(transactions, timestamps) [10, 10]","solution":"def calculate_inventory(transactions, timestamps): Calculate the inventory at each requested timestamp. transactions: list of tuples, each tuple contains (t, type, q) timestamps: list of integers representing the requested timestamps Returns a list of integers representing the stock level at each requested timestamp. transactions.sort() current_stock = 0 stock_at_times = {} current_time = 0 for timestamp in timestamps: while current_time < len(transactions) and transactions[current_time][0] <= timestamp: t, t_type, q = transactions[current_time] if t_type == 'restock': current_stock += q elif t_type == 'sell': current_stock = max(0, current_stock - q) current_time += 1 stock_at_times[timestamp] = current_stock result = [] for timestamp in timestamps: result.append(stock_at_times[timestamp]) return result"},{"question":"def is_crossword_solved_correctly(R: int, C: int, grid: List[str], dictionary: Set[str]) -> str: Determine if the crossword puzzle is solved correctly. Args: - R: Number of rows. - C: Number of columns. - grid: 2D list of characters representing the crossword grid. - dictionary: Set of valid words. Returns: - \\"Yes\\" if the puzzle is solved correctly, otherwise \\"No\\". pass def test_crossword_solved_correctly(): R, C = 4, 4 grid = [ \\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\" ] dictionary = {\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\", \\"aeim\\", \\"bfjn\\", \\"cgko\\", \\"dhlp\\"} assert is_crossword_solved_correctly(R, C, grid, dictionary) == \\"Yes\\" def test_crossword_not_solved_because_of_columns(): R, C = 4, 4 grid = [ \\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\" ] dictionary = {\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"} assert is_crossword_solved_correctly(R, C, grid, dictionary) == \\"No\\" def test_crossword_not_solved_because_of_nonexistent_row(): R, C = 4, 4 grid = [ \\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnox\\" ] dictionary = {\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\", \\"aeim\\", \\"bfjn\\", \\"cgko\\", \\"dxlp\\"} assert is_crossword_solved_correctly(R, C, grid, dictionary) == \\"No\\" def test_minimum_grid_size_all_valid(): R, C = 2, 2 grid = [ \\"ab\\", \\"cd\\" ] dictionary = {\\"ab\\", \\"cd\\", \\"ac\\", \\"bd\\"} assert is_crossword_solved_correctly(R, C, grid, dictionary) == \\"Yes\\" def test_minimum_grid_size_with_invalid_one(): R, C = 2, 2 grid = [ \\"ab\\", \\"cd\\" ] dictionary = {\\"ab\\", \\"cd\\"} assert is_crossword_solved_correctly(R, C, grid, dictionary) == \\"No\\"","solution":"def is_crossword_solved_correctly(R, C, grid, dictionary): Determine if the crossword puzzle is solved correctly. Args: - R: Number of rows. - C: Number of columns. - grid: 2D list of characters representing the crossword grid. - dictionary: Set of valid words. Returns: - \\"Yes\\" if the puzzle is solved correctly, otherwise \\"No\\". # Check rows for row in grid: if row not in dictionary: return \\"No\\" # Check columns for col_idx in range(C): word = ''.join(grid[row_idx][col_idx] for row_idx in range(R)) if word not in dictionary: return \\"No\\" return \\"Yes\\""},{"question":"def max_battery_level(t, cases): Given t test cases, for each test: - N: the number of robots - A: the initial battery levels of the robots This function returns the maximum possible battery level for any single robot after performing any number of operations. Input: t: int - The number of test cases. cases: List[Tuple[int, List[int]]] - A list containing t tuples, each tuple represents a test case containing: - N: int - the number of robots. - A: List[int] - a list of integers representing the initial battery levels of robots. Output: List[int] - a list of t integers, each representing the maximum possible battery level a single robot can achieve for the corresponding test case. Example: >>> t = 3 >>> cases = [(5, [1, 2, 3, 4, 5]), (3, [0, 0, 0]), (4, [10, 20, 30, 40])] >>> max_battery_level(t, cases) [15, 0, 100] from solution import max_battery_level def test_example_cases(): t = 3 cases = [ (5, [1, 2, 3, 4, 5]), (3, [0, 0, 0]), (4, [10, 20, 30, 40]) ] expected = [15, 0, 100] assert max_battery_level(t, cases) == expected def test_single_robot(): t = 1 cases = [(1, [42])] expected = [42] assert max_battery_level(t, cases) == expected def test_all_zeros(): t = 2 cases = [ (4, [0, 0, 0, 0]), (3, [0, 0, 0]) ] expected = [0, 0] assert max_battery_level(t, cases) == expected def test_large_numbers(): t = 2 cases = [ (2, [100, 100]), (3, [99, 100, 101]) ] expected = [200, 300] assert max_battery_level(t, cases) == expected def test_padding_cases(): t = 3 cases = [ (5, [1, 0, 0, 4, 0]), (6, [0, 1, 2, 3, 4, 0]), (3, [4, 3, 1]) ] expected = [5, 10, 8] assert max_battery_level(t, cases) == expected","solution":"def max_battery_level(t, cases): Given t test cases, for each test case: - N: the number of robots - A: the initial battery levels of the robots This function returns the maximum possible battery level for any single robot after performing any number of operations. results = [] for case in cases: N, A = case # The maximum possible battery level is the sum of all battery levels in array A max_battery = sum(A) results.append(max_battery) return results"},{"question":"def is_balanced(s: str) -> str: Determines if the given string s is balanced. >>> is_balanced(\\"aabb\\") == \\"Balanced\\" >>> is_balanced(\\"abcabc\\") == \\"Balanced\\" >>> is_balanced(\\"abcd\\") == \\"Not Balanced\\" def balance_strings(test_cases: List[str]) -> List[str]: For each string in test_cases, determine if it is balanced. >>> balance_strings([\\"aabb\\", \\"abcabc\\", \\"abcd\\"]) == [\\"Balanced\\", \\"Balanced\\", \\"Not Balanced\\"] >>> balance_strings([\\"aabbcc\\", \\"abcdef\\", \\"aabbccdd\\"]) == [\\"Balanced\\", \\"Not Balanced\\", \\"Balanced\\"]","solution":"def is_balanced(s): Determines if the given string s is balanced. from collections import Counter counter = Counter(s) for count in counter.values(): if count % 2 != 0: return \\"Not Balanced\\" return \\"Balanced\\" def balance_strings(test_cases): results = [] for s in test_cases: results.append(is_balanced(s)) return results"},{"question":"def determine_winner(grid: List[List[int]]) -> str: Determines the winner between Nina and Kavi based on the rules given. params: grid - List[List[int]] - grid containing the initial state of the game returns: str - \\"Nina\\" if Nina wins, otherwise \\"Kavi\\" >>> determine_winner([[1, -4], [0, 3]]) \\"Nina\\" >>> determine_winner([[-5, 0, 7]]) \\"Kavi\\" >>> determine_winner([[-1, -2, -3], [4, 0, 0], [7, 8, 9]]) \\"Nina\\" >>> determine_winner([[0, 0], [0, 0]]) \\"Kavi\\" >>> determine_winner([[-1, 2, 0], [3, -4, 5]]) \\"Nina\\" positive_count = 0 negative_count = 0 for row in grid: for value in row: if value > 0: positive_count += 1 elif value < 0: negative_count += 1 total_moves = positive_count + negative_count if total_moves % 2 == 1: return \\"Nina\\" else: return \\"Kavi\\" def game_outcome(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]: Determines the winner for each test case params: test_cases - List[Tuple[int, int, List[List[int]]]] - list of test cases returns: List[str] - Results for each test case results = [] for n, m, grid in test_cases: results.append(determine_winner(grid)) return results","solution":"def determine_winner(grid): Determines the winner between Nina and Kavi based on the rules given. positive_count = 0 negative_count = 0 for row in grid: for value in row: if value > 0: positive_count += 1 elif value < 0: negative_count += 1 # Nina wins if the total number of moves (each non-zero value is a move) is odd total_moves = positive_count + negative_count if total_moves % 2 == 1: return \\"Nina\\" else: return \\"Kavi\\" def game_outcome(test_cases): results = [] for n, m, grid in test_cases: results.append(determine_winner(grid)) return results"},{"question":"def min_operations_to_reduce_to_one(n): Returns the minimum number of operations required to reduce n to 1 using the given operations: divide by 2, divide by 3, subtract 1. >>> min_operations_to_reduce_to_one(10) 3 >>> min_operations_to_reduce_to_one(15) 4 >>> min_operations_to_reduce_to_one(18) 3 >>> min_operations_to_reduce_to_one(2) 1 def min_operations_to_reduce_to_one_multiple_cases(test_cases): Given a list of integers, return a list of the minimum number of operations required to reduce each integer to 1 using the given operations: divide by 2, divide by 3, subtract 1. >>> min_operations_to_reduce_to_one_multiple_cases([10, 15, 18, 2]) [3, 4, 3, 1] >>> min_operations_to_reduce_to_one_multiple_cases([1, 5, 6, 9]) [0, 3, 2, 2] >>> min_operations_to_reduce_to_one_multiple_cases([3, 8, 4, 7]) [1, 3, 2, 3] from solution import min_operations_to_reduce_to_one, min_operations_to_reduce_to_one_multiple_cases def test_single_case(): assert min_operations_to_reduce_to_one(10) == 3 assert min_operations_to_reduce_to_one(15) == 4 assert min_operations_to_reduce_to_one(18) == 3 assert min_operations_to_reduce_to_one(2) == 1 def test_multiple_cases(): assert min_operations_to_reduce_to_one_multiple_cases([10, 15, 18, 2]) == [3, 4, 3, 1] assert min_operations_to_reduce_to_one_multiple_cases([1, 5, 6, 9]) == [0, 3, 2, 2] assert min_operations_to_reduce_to_one_multiple_cases([3, 8, 4, 7]) == [1, 3, 2, 3]","solution":"def min_operations_to_reduce_to_one(n): Returns the minimum number of operations required to reduce n to 1 using the given operations: divide by 2, divide by 3, subtract 1. dp = [0] * (n + 1) for i in range(2, n + 1): operations = dp[i - 1] if i % 2 == 0: operations = min(operations, dp[i // 2]) if i % 3 == 0: operations = min(operations, dp[i // 3]) dp[i] = operations + 1 return dp[n] def min_operations_to_reduce_to_one_multiple_cases(test_cases): return [min_operations_to_reduce_to_one(n) for n in test_cases]"},{"question":"def generate_fibonacci(n): Generates the first n terms of the Fibonacci sequence. :param int n: Number of terms to generate (1 <= n <= 50) :return: List containing the first n terms of the Fibonacci sequence :rtype: list >>> generate_fibonacci(1) == [0] >>> generate_fibonacci(2) == [0, 1] >>> generate_fibonacci(5) == [0, 1, 1, 2, 3] >>> generate_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> generate_fibonacci(0) == [] >>> generate_fibonacci(25) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368]","solution":"def generate_fibonacci(n): Generates the first n terms of the Fibonacci sequence. :param int n: Number of terms to generate (1 <= n <= 50) :return: List containing the first n terms of the Fibonacci sequence :rtype: list if n <= 0: return [] if n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def longest_subarray_multiple_of_k(n: int, k: int, arr: List[int]) -> int: Returns the length of the longest contiguous subarray whose sum is a multiple of k. >>> longest_subarray_multiple_of_k(6, 5, [1, 2, 3, 4, 6, 7]) 4 >>> longest_subarray_multiple_of_k(8, 3, [-1, 2, 9, -4, 3, 1, 2, 8]) 7 >>> longest_subarray_multiple_of_k(1, 2, [4]) 1 >>> longest_subarray_multiple_of_k(1, 5, [3]) 0 >>> longest_subarray_multiple_of_k(5, 7, [7, 7, 7, 7, 7]) 5 >>> large_arr = [2] * 100000 >>> longest_subarray_multiple_of_k(100000, 4, large_arr) 100000 >>> longest_subarray_multiple_of_k(5, 3, [0, 0, 0, 0, 0]) 5","solution":"def longest_subarray_multiple_of_k(n, k, arr): Returns the length of the longest contiguous subarray whose sum is a multiple of k. prefix_sum = 0 remainder_dict = {0: -1} # Dictionary to store the first occurrence of a given remainder max_len = 0 for i in range(n): prefix_sum += arr[i] remainder = prefix_sum % k # normalize the remainder to be positive if remainder < 0: remainder += k if remainder in remainder_dict: max_len = max(max_len, i - remainder_dict[remainder]) else: remainder_dict[remainder] = i return max_len"},{"question":"import re from typing import List def is_palindrome(s: str) -> str: Returns 'Yes' if the string s is a palindrome ignoring spaces, punctuation, and case sensitivity, otherwise 'No'. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") 'Yes' >>> is_palindrome(\\"racecar\\") 'Yes' >>> is_palindrome(\\"A Santa at NASA\\") 'Yes' >>> is_palindrome(\\"No lemon, no melon\\") 'Yes' >>> is_palindrome(\\"This is not a palindrome\\") 'No' >>> is_palindrome(\\"Hello, World!\\") 'No' >>> is_palindrome(\\"12321\\") 'Yes' >>> is_palindrome(\\"12345 54321\\") 'Yes' >>> is_palindrome(\\"\\") 'Yes'","solution":"import re def is_palindrome(s): Returns 'Yes' if the string s is a palindrome ignoring spaces, punctuation, and case sensitivity, otherwise 'No'. # Remove non-alphanumeric characters and make the string lower case cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is equal to its reverse if cleaned == cleaned[::-1]: return \\"Yes\\" else: return \\"No\\""},{"question":"def count_valid_pairs(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Count the number of valid pairs of statues, where the sum of their power levels is a multiple of a given number K. Arguments: t -- The number of test cases test_cases -- A list of tuples where each tuple contains a tuple of two integers (N, K) and a list of integers representing the power levels of the statues. Returns: A list of integers where each integer represents the number of valid pairs for the corresponding test case. Example: >>> t = 3 >>> test_cases = [ [(3, 5), [1, 2, 3]], [(4, 2), [2, 4, 6, 8]], [(5, 3), [3, 6, 9, 12, 15]] ] >>> count_valid_pairs(t, test_cases) [1, 6, 10]","solution":"def count_valid_pairs(t, test_cases): results = [] for test_case in test_cases: n, k = test_case[0] power_levels = test_case[1] count = 0 for i in range(n): for j in range(i + 1, n): if (power_levels[i] + power_levels[j]) % k == 0: count += 1 results.append(count) return results # Example usage t = 3 test_cases = [ [(3, 5), [1, 2, 3]], [(4, 2), [2, 4, 6, 8]], [(5, 3), [3, 6, 9, 12, 15]] ] print(count_valid_pairs(t, test_cases))"},{"question":"def parse_command(num_cases, synonym_phrases, user_inputs): Parse user commands and map them to predefined command keywords. Parameters: num_cases (int): number of user input strings synonym_phrases (dict): a dictionary mapping command keywords to lists of synonym phrases user_inputs (list): a list of user input strings to be interpreted. Returns: list: a list of command keywords corresponding to each user input, or \\"unknown\\" if no match is found. # Your solution goes here # Example usage: # num_cases = 2 # synonym_phrases = { # \\"create\\": [\\"add new\\", \\"new entry\\"], # \\"delete\\": [\\"remove\\", \\"clear out\\"], # \\"update\\": [\\"change\\", \\"modify\\"], # \\"read\\": [\\"get info\\", \\"fetch info\\"] # } # user_inputs = [\\"Create a new project\\", \\"Remove old files\\"] # print(parse_command(num_cases, synonym_phrases, user_inputs)) def test_parse_command_with_exact_match(): num_cases = 2 synonym_phrases = { \\"create\\": [\\"add new\\", \\"new entry\\"], \\"delete\\": [\\"remove\\", \\"clear out\\"], \\"update\\": [\\"change\\", \\"modify\\"], \\"read\\": [\\"get info\\", \\"fetch info\\"] } user_inputs = [\\"create a new project\\", \\"delete old files\\"] assert parse_command(num_cases, synonym_phrases, user_inputs) == [\\"create\\", \\"delete\\"] def test_parse_command_with_synonym_match(): num_cases = 2 synonym_phrases = { \\"create\\": [\\"add new\\", \\"new entry\\"], \\"delete\\": [\\"remove\\", \\"clear out\\"], \\"update\\": [\\"change\\", \\"modify\\"], \\"read\\": [\\"get info\\", \\"fetch info\\"] } user_inputs = [\\"add a new entry\\", \\"clear out the mess\\"] assert parse_command(num_cases, synonym_phrases, user_inputs) == [\\"create\\", \\"delete\\"] def test_parse_command_case_insensitivity(): num_cases = 2 synonym_phrases = { \\"create\\": [\\"add new\\", \\"new entry\\"], \\"delete\\": [\\"remove\\", \\"clear out\\"], \\"update\\": [\\"change\\", \\"modify\\"], \\"read\\": [\\"get info\\", \\"fetch info\\"] } user_inputs = [\\"Create a new project\\", \\"Remove old files\\"] assert parse_command(num_cases, synonym_phrases, user_inputs) == [\\"create\\", \\"delete\\"] def test_parse_command_unknown_command(): num_cases = 1 synonym_phrases = { \\"create\\": [\\"add new\\", \\"new entry\\"], \\"delete\\": [\\"remove\\", \\"clear out\\"], \\"update\\": [\\"change\\", \\"modify\\"], \\"read\\": [\\"get info\\", \\"fetch info\\"] } user_inputs = [\\"destroy everything\\"] assert parse_command(num_cases, synonym_phrases, user_inputs) == [\\"unknown\\"] def test_parse_command_with_multiple_matches(): num_cases = 2 synonym_phrases = { \\"create\\": [\\"add new\\", \\"new entry\\"], \\"delete\\": [\\"remove\\", \\"clear out\\"], \\"update\\": [\\"change\\", \\"modify\\"], \\"read\\": [\\"get info\\", \\"fetch info\\"] } user_inputs = [\\"add new item and remove entry\\", \\"update the data then fetch info\\"] assert parse_command(num_cases, synonym_phrases, user_inputs) == [\\"create\\", \\"update\\"]","solution":"def parse_command(num_cases, synonym_phrases, user_inputs): Parse user commands and map them to predefined command keywords. Parameters: num_cases (int): number of user input strings synonym_phrases (dict): a dictionary mapping command keywords to lists of synonym phrases user_inputs (list): a list of user input strings to be interpreted. Returns: list: a list of command keywords corresponding to each user input, or \\"unknown\\" if no match is found. command_mappings = { \\"create\\": [], \\"delete\\": [], \\"update\\": [], \\"read\\": [] } for command, synonyms in synonym_phrases.items(): command_mappings[command].extend(synonyms) def normalize_command(user_input): lower_input = user_input.lower() for command, synonyms in command_mappings.items(): if command in lower_input: return command for synonym in synonyms: if synonym in lower_input: return command return \\"unknown\\" results = [] for user_input in user_inputs: results.append(normalize_command(user_input)) return results # Example usage: # num_cases = 2 # synonym_phrases = { # \\"create\\": [\\"add new\\", \\"new entry\\"], # \\"delete\\": [\\"remove\\", \\"clear out\\"], # \\"update\\": [\\"change\\", \\"modify\\"], # \\"read\\": [\\"get info\\", \\"fetch info\\"] # } # user_inputs = [\\"Create a new project\\", \\"Remove old files\\"] # print(parse_command(num_cases, synonym_phrases, user_inputs))"},{"question":"def reconstruct_messages(messages): Reconstructs a sequence of messages in correct order, removing duplicates. Args: messages: List of tuples, where each tuple contains an integer message and an integer sequence_number. Returns: List of integers representing the ordered message sequence without duplicates. Examples: >>> reconstruct_messages([(5, 3), (1, 1), (3, 2), (1, 1), (4, 4), (2, 5)]) [1, 3, 5, 4, 2] >>> reconstruct_messages([(10, 3), (7, 1), (3, 2), (10, 3), (15, 4), (2, 5)]) [7, 3, 10, 15, 2] >>> reconstruct_messages([]) [] >>> reconstruct_messages([(1, 1)]) [1] from solution import reconstruct_messages def test_reconstruct_messages_no_duplicates(): assert reconstruct_messages([(5, 3), (1, 1), (3, 2), (4, 4), (2, 5)]) == [1, 3, 5, 4, 2] def test_reconstruct_messages_with_duplicates(): assert reconstruct_messages([(5, 3), (1, 1), (3, 2), (1, 1), (4, 4), (2, 5)]) == [1, 3, 5, 4, 2] def test_reconstruct_messages_with_more_duplicates(): assert reconstruct_messages([(10, 3), (7, 1), (3, 2), (10, 3), (15, 4), (2, 5)]) == [7, 3, 10, 15, 2] def test_reconstruct_messages_single_message(): assert reconstruct_messages([(1, 1)]) == [1] def test_reconstruct_messages_empty(): assert reconstruct_messages([]) == [] def test_reconstruct_messages_out_of_order(): assert reconstruct_messages([(2, 5), (3, 2), (7, 1), (10, 3), (15, 4)]) == [7, 3, 10, 15, 2]","solution":"def reconstruct_messages(messages): Reconstructs a sequence of messages in correct order, removing duplicates. Args: messages: List of tuples, where each tuple contains an integer message and an integer sequence_number. Returns: List of integers representing the ordered message sequence without duplicates. # Use a dictionary to map sequence numbers to messages (this will also remove duplicates) seq_to_msg = {} for message, sequence_number in messages: seq_to_msg[sequence_number] = message # Extract the messages sorted by their sequence numbers sorted_messages = [msg for seq_num, msg in sorted(seq_to_msg.items())] return sorted_messages"},{"question":"def find_number_of_groups(n: int, roads: List[Tuple[int, int]]) -> int: Find the number of connected groups (components) in a graph represented by cities (nodes) and roads (edges). Parameters: n (int): Number of cities. roads (List[Tuple[int, int]]): List of roads represented as tuples of cities they connect. Returns: int: Number of connected groups of cities. Examples: >>> find_number_of_groups(5, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_number_of_groups(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 1","solution":"def find_number_of_groups(n, roads): Find the number of connected groups (components) in a graph represented by cities (nodes) and roads (edges). Parameters: n (int): Number of cities. roads (List[Tuple[int, int]]): List of roads represented as tuples of cities they connect. Returns: int: Number of connected groups of cities. from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = set() num_groups = 0 for city in range(1, n + 1): if city not in visited: bfs(city) num_groups += 1 return num_groups"},{"question":"def pair_with_sum_exists(n: int, k: int, array: List[int]) -> str: Determines if there exists a pair of elements in the array such that their sum is exactly K. Parameters: n (int): The number of elements in the array. k (int): The target sum. array (list of int): The list of integers. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". Examples: >>> pair_with_sum_exists(5, 9, [2, 7, 11, 15, 1]) \\"YES\\" >>> pair_with_sum_exists(4, 20, [3, 1, 4, 9]) \\"NO\\"","solution":"def pair_with_sum_exists(n, k, array): Determines if there exists a pair of elements in the array such that their sum is exactly K. Parameters: n (int): The number of elements in the array. k (int): The target sum. array (list of int): The list of integers. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in array: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def are_points_collinear(x1, y1, x2, y2, x3, y3): Check if three points (x1, y1), (x2, y2), (x3, y3) are collinear. Points are collinear if the area of the triangle they form is zero. This can be determined using the determinant method. def check_collinear_points(sets_of_points): For a given list of point sets, determine if each set of points is collinear, returning a list of \\"YES\\" or \\"NO\\" for each set. # Example test cases if __name__ == '__main__': sets_of_points = [ (0, 0, 1, 1, 2, 2), (0, 0, 1, 1, 2, 3), (1, 2, 3, 4, 5, 6) ] print(check_collinear_points(sets_of_points)) # Output: [\\"YES\\", \\"NO\\", \\"YES\\"] sets_of_points = [ (-1, -1, -2, -2, -3, -3), (1, 1, 2, 2, 3, 4), (0, 0, 0, 0, 0, 0) ] print(check_collinear_points(sets_of_points)) # Output: [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def are_points_collinear(x1, y1, x2, y2, x3, y3): Check if three points (x1, y1), (x2, y2), (x3, y3) are collinear. Points are collinear if the area of the triangle they form is zero. This can be determined using the determinant method. # Using the determinant formula to check for collinearity return (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0 def check_collinear_points(sets_of_points): For a given list of point sets, determine if each set of points is collinear, returning a list of \\"YES\\" or \\"NO\\" for each set. results = [] for points in sets_of_points: x1, y1, x2, y2, x3, y3 = points if are_points_collinear(x1, y1, x2, y2, x3, y3): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_rearrange(A: str, B: str) -> str: Determines if string B can be rearranged to match string A. >>> can_rearrange(\\"abcd\\", \\"dcba\\") \\"Yes\\" >>> can_rearrange(\\"hello\\", \\"holle\\") \\"Yes\\" >>> can_rearrange(\\"mango\\", \\"nomag\\") \\"Yes\\" >>> can_rearrange(\\"apple\\", \\"aplpe\\") \\"Yes\\" >>> can_rearrange(\\"banana\\", \\"aananb\\") \\"Yes\\" >>> can_rearrange(\\"abcdef\\", \\"fedcba\\") \\"Yes\\" >>> can_rearrange(\\"abcd\\", \\"abce\\") \\"No\\" >>> can_rearrange(\\"abc\\", \\"abcd\\") \\"No\\"","solution":"def can_rearrange(A, B): Determines if string B can be rearranged to match string A. if sorted(A) == sorted(B): return \\"Yes\\" else: return \\"No\\" # Example usage: # print(can_rearrange(\\"abcd\\", \\"dcba\\")) # Output: \\"Yes\\""},{"question":"def coin_sums(n: int, k: int, coin_values: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given the values of the n coins and k queries about the sum of values of coins in specific ranges, return the sum for each query. :param n: Number of coins :param k: Number of queries :param coin_values: List of coin values :param queries: List of tuple queries where each tuple contains (li, ri) :return: List of sums for each query range >>> coin_sums(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> coin_sums(4, 2, [10, 20, 30, 40], [(1, 2), (3, 4)]) [30, 70]","solution":"def coin_sums(n, k, coin_values, queries): Returns the sum of coin values for each query range. :param n: Number of coins :param k: Number of queries :param coin_values: List of coin values :param queries: List of tuple queries where each tuple contains (li, ri) :return: List of sums for each query range results = [] for li, ri in queries: # Convert 1-indexed to 0-indexed sum_value = sum(coin_values[li - 1:ri]) results.append(sum_value) return results"},{"question":"from typing import List def evaluate_expressions(n: int, expressions: List[str]) -> List: Evaluate arithmetic expressions involving integer variables. Args: n (int): The number of expressions. expressions (List[str]): List of string expressions to evaluate. Returns: List: A list containing the result of each expression or \\"ERROR\\" if the expression is invalid. Examples: >>> evaluate_expressions(5, [\\"a = 5\\", \\"b = 3\\", \\"c = a + b\\", \\"d = c * 2\\", \\"e = d // (b - 3)\\"]) [5, 3, 8, 16, \\"ERROR\\"] pass # Unit tests def test_evaluate_basic_assignments(): expressions = [ \\"a = 5\\", \\"b = 3\\", \\"c = a + b\\", \\"d = c * 2\\" ] n = len(expressions) results = evaluate_expressions(n, expressions) assert results == [5, 3, 8, 16] def test_evaluate_with_division_by_zero(): expressions = [ \\"a = 5\\", \\"b = a - 5\\", \\"c = 10 // b\\" ] n = len(expressions) results = evaluate_expressions(n, expressions) assert results == [5, 0, \\"ERROR\\"] def test_evaluate_with_complex_expressions(): expressions = [ \\"a = 2 + 3\\", \\"b = 4 * a\\", \\"c = b - 7\\", \\"d = c // a\\", \\"e = d * 3\\" ] n = len(expressions) results = evaluate_expressions(n, expressions) assert results == [5, 20, 13, 2, 6] def test_evaluate_with_invalid_expression(): expressions = [ \\"a = 10\\", \\"b = a + ,\\", \\"c = b * 2\\" ] n = len(expressions) results = evaluate_expressions(n, expressions) assert results == [10, \\"ERROR\\", \\"ERROR\\"] def test_evaluate_with_negative_constants(): expressions = [ \\"a = -5\\", \\"b = 3\\", \\"c = a + b\\", \\"d = b - a\\", \\"e = a * b\\", \\"f = 100 // a\\" ] n = len(expressions) results = evaluate_expressions(n, expressions) assert results == [-5, 3, -2, 8, -15, -20]","solution":"def evaluate_expressions(n, expressions): variables = {} results = [] def evaluate(expression): try: # Split the expression into tokens tokens = expression.split() if \\"=\\" in tokens: # Handle assignments var_name = tokens[0] value_expression = \\" \\".join(tokens[2:]) value = eval(value_expression, {}, variables) variables[var_name] = value return value else: # Handle standard arithmetic expressions return eval(expression, {}, variables) except Exception: return \\"ERROR\\" for expression in expressions: result = evaluate(expression) results.append(result) return results # Example usage expressions = [ \\"a = 5\\", \\"b = 3\\", \\"c = a + b\\", \\"d = c * 2\\", \\"e = d // (b - 3)\\" ] n = len(expressions) results = evaluate_expressions(n, expressions) for result in results: print(result) # Expected output: 5, 3, 8, 16, \\"ERROR\\""},{"question":"def rank_participants(participant_count: int, challenge_count: int, participants: List[str], challenges_with_points: List[str], solutions: List[str]) -> List[Tuple[str, int, int]]: Compute the final ranking of participants in a coding marathon. Args: participant_count (int): The number of participants. challenge_count (int): The number of challenges. participants (List[str]): The list of participant names. challenges_with_points (List[str]): The list of challenges with associated points. solutions (List[str]): The list of solutions provided by participants. Returns: List[Tuple[str, int, int]]: The final ranking of participants where each tuple contains (participant_name, total_points_earned, challenges_solved). >>> participants = [\\"alice\\", \\"bob\\", \\"carol\\"] >>> challenges_with_points = [\\"challenge1 10\\", \\"challenge2 20\\", \\"challenge3 30\\"] >>> solutions = [\\"alice challenge1\\", \\"alice challenge2\\", \\"bob challenge1\\", \\"bob challenge3\\", \\"carol challenge2\\"] >>> rank_participants(3, 3, participants, challenges_with_points, solutions) [('bob', 40, 2), ('alice', 30, 2), ('carol', 20, 1)] >>> participants = [\\"dave\\", \\"ellen\\"] >>> challenges_with_points = [\\"challenge1 10\\", \\"challenge2 20\\"] >>> solutions = [\\"dave challenge1\\", \\"ellen challenge2\\", \\"dave challenge2\\"] >>> rank_participants(2, 2, participants, challenges_with_points, solutions) [('dave', 30, 2), ('ellen', 20, 1)]","solution":"def rank_participants(participant_count, challenge_count, participants, challenges_with_points, solutions): from collections import defaultdict # Create a dictionary to store the points of each challenge challenge_points = {} for challenge in challenges_with_points: name, points = challenge.split() challenge_points[name] = int(points) # Create dictionaries to store total points and number of challenges solved by each participant total_points = defaultdict(int) challenges_solved = defaultdict(set) for solution in solutions: participant_name, challenge_name = solution.split() total_points[participant_name] += challenge_points[challenge_name] challenges_solved[participant_name].add(challenge_name) # Convert challenges_solved sets to their lengths solved_counts = {name: len(challenges_solved[name]) for name in participants} # Create a sorted list of participants based on the criteria given sorted_participants = sorted(participants, key=lambda name: (-total_points[name], -solved_counts[name], name)) return [(name, total_points[name], solved_counts[name]) for name in sorted_participants] # Example usage: # p = 3 # c = 3 # participants = [\\"alice\\", \\"bob\\", \\"carol\\"] # challenges_with_points = [\\"challenge1 10\\", \\"challenge2 20\\", \\"challenge3 30\\"] # solutions = [\\"alice challenge1\\", \\"alice challenge2\\", \\"bob challenge1\\", \\"bob challenge3\\", \\"carol challenge2\\"] # print(rank_participants(p, c, participants, challenges_with_points, solutions)) # Output: [('bob', 40, 2), ('alice', 30, 2), ('carol', 20, 1)]"},{"question":"def count_activities(logs): Processes a list of activity logs and outputs the count of each type of activity. Args: logs (list of str): A list of activity logs where each log is in the format \\"<user_id>:<activity_type>\\". Returns: dict: A dictionary with keys \\"post\\", \\"comment\\", \\"like\\", and \\"share\\" and their corresponding counts as values. Example: >>> count_activities([\\"1:post\\", \\"2:comment\\", \\"1:like\\", \\"2:post\\", \\"3:like\\", \\"2:comment\\"]) {'post': 2, 'comment': 2, 'like': 2, 'share': 0} def test_count_activities(): # Test with given example logs = [\\"1:post\\", \\"2:comment\\", \\"1:like\\", \\"2:post\\", \\"3:like\\", \\"2:comment\\"] result = count_activities(logs) assert result == {\\"post\\": 2, \\"comment\\": 2, \\"like\\": 2, \\"share\\": 0} # Test with empty logs logs = [] result = count_activities(logs) assert result == {\\"post\\": 0, \\"comment\\": 0, \\"like\\": 0, \\"share\\": 0} # Test with only one type of activity logs = [\\"1:post\\", \\"2:post\\", \\"3:post\\"] result = count_activities(logs) assert result == {\\"post\\": 3, \\"comment\\": 0, \\"like\\": 0, \\"share\\": 0} # Test with all types of activities logs = [\\"1:post\\", \\"2:comment\\", \\"3:like\\", \\"4:share\\"] result = count_activities(logs) assert result == {\\"post\\": 1, \\"comment\\": 1, \\"like\\": 1, \\"share\\": 1} # Test with multiple activities from same user logs = [\\"1:post\\", \\"1:comment\\", \\"1:like\\", \\"1:share\\"] result = count_activities(logs) assert result == {\\"post\\": 1, \\"comment\\": 1, \\"like\\": 1, \\"share\\": 1} # Test with a larger number of logs logs = [\\"1:post\\"] * 100000 result = count_activities(logs) assert result == {\\"post\\": 100000, \\"comment\\": 0, \\"like\\": 0, \\"share\\": 0} # Test with mixed types of activities logs = [\\"1:post\\", \\"2:post\\", \\"2:like\\", \\"1:comment\\", \\"3:share\\", \\"2:comment\\", \\"3:post\\", \\"1:share\\"] result = count_activities(logs) assert result == {\\"post\\": 3, \\"comment\\": 2, \\"like\\": 1, \\"share\\": 2}","solution":"def count_activities(logs): Processes a list of activity logs and outputs the count of each type of activity. Args: logs (list of str): A list of activity logs where each log is in the format \\"<user_id>:<activity_type>\\". Returns: dict: A dictionary with keys \\"post\\", \\"comment\\", \\"like\\", and \\"share\\" and their corresponding counts as values. activity_types = [\\"post\\", \\"comment\\", \\"like\\", \\"share\\"] activity_counts = {activity: 0 for activity in activity_types} for log in logs: user_id, activity = log.split(':') if activity in activity_counts: activity_counts[activity] += 1 return activity_counts"},{"question":"def find_remaining_trees(x1: int, y1: int, x2: int, y2: int): Given the coordinates of two diagonal trees, find the coordinates of the remaining two trees to form a rectangle. Return -1 if the solution doesn't exist. >>> find_remaining_trees(0, 0, 2, 3) (0, 3, 2, 0) >>> find_remaining_trees(1, 1, 4, 5) (1, 5, 4, 1) >>> find_remaining_trees(-1, -2, 3, 4) (-1, 4, 3, -2) >>> find_remaining_trees(2, 2, 2, 5) -1 >>> find_remaining_trees(-3, 3, 4, 3) -1 # Test cases for the implementation def test_find_remaining_trees_example1(): result = find_remaining_trees(0, 0, 2, 3) assert result == (0, 3, 2, 0) def test_find_remaining_trees_example2(): result = find_remaining_trees(1, 1, 4, 5) assert result == (1, 5, 4, 1) def test_find_remaining_trees_example3(): result = find_remaining_trees(-1, -2, 3, 4) assert result == (-1, 4, 3, -2) def test_find_remaining_trees_no_solution(): result = find_remaining_trees(2, 2, 2, 5) assert result == -1 result = find_remaining_trees(-3, 3, 4, 3) assert result == -1 def test_find_remaining_trees_large_coordinates(): result = find_remaining_trees(-100, -100, 100, 100) assert result == (-100, 100, 100, -100) def test_find_remaining_trees_large_coordinates_negative(): result = find_remaining_trees(-50, 50, 50, -50) assert result == (-50, -50, 50, 50)","solution":"def find_remaining_trees(x1, y1, x2, y2): Given the coordinates of two diagonal trees, find the coordinates of the remaining two trees to form a rectangle. Return -1 if the solution doesn't exist. if x1 == x2 or y1 == y2: return -1 x3, y3 = x1, y2 x4, y4 = x2, y1 return x3, y3, x4, y4"},{"question":"def create_leaderboard(input_lines): Creates a leaderboard from the input lines of participant IDs and scores. Args: input_lines (list of str): List of input lines where each line contains a participant ID and a score, separated by a space. Returns: list of tuples: Leaderboard sorted in descending order of scores. pass # Unit Tests def test_leaderboard_example_1(): input_lines = [ \\"1 50\\", \\"2 75\\", \\"3 75\\", \\"4 60\\", \\"END\\" ] expected_output = [ (2, 75), (3, 75), (4, 60), (1, 50) ] assert create_leaderboard(input_lines) == expected_output def test_leaderboard_example_2(): input_lines = [ \\"5 90\\", \\"1 95\\", \\"3 90\\", \\"2 100\\", \\"END\\" ] expected_output = [ (2, 100), (1, 95), (3, 90), (5, 90) ] assert create_leaderboard(input_lines) == expected_output def test_leaderboard_with_single_participant(): input_lines = [ \\"7 80\\", \\"END\\" ] expected_output = [ (7, 80) ] assert create_leaderboard(input_lines) == expected_output def test_leaderboard_with_tied_scores(): input_lines = [ \\"4 50\\", \\"2 50\\", \\"1 75\\", \\"3 50\\", \\"5 75\\", \\"END\\" ] expected_output = [ (1, 75), (5, 75), (2, 50), (3, 50), (4, 50) ] assert create_leaderboard(input_lines) == expected_output def test_leaderboard_with_no_input(): input_lines = [ \\"END\\" ] expected_output = [] assert create_leaderboard(input_lines) == expected_output","solution":"def create_leaderboard(input_lines): Creates a leaderboard from the input lines of participant IDs and scores. Args: input_lines (list of str): List of input lines where each line contains a participant ID and a score, separated by a space. Returns: list of tuples: Leaderboard sorted in descending order of scores. scores = [] for line in input_lines: if line == \\"END\\": break participant_id, score = map(int, line.split()) scores.append((participant_id, score)) # Sort first by score in descending order, then by participant_id in ascending order scores.sort(key=lambda x: (-x[1], x[0])) return scores"},{"question":"def prefix_sum_array(arr: List[int]) -> List[int]: Converts the given array into a prefix sum array. Each element in the resulting array is the sum of all elements up to and including that position in the original array. >>> prefix_sum_array([1, 2, 3, 4, 5]) == [1, 3, 6, 10, 15] >>> prefix_sum_array([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0] >>> prefix_sum_array([10]) == [10] >>> prefix_sum_array([-1, -2, -3, -4, -5]) == [-1, -3, -6, -10, -15] >>> prefix_sum_array([1, -1, 2, -2, 3, -3]) == [1, 0, 2, 0, 3, 0] >>> prefix_sum_array([1000000000, -1000000000, 1000000000]) == [1000000000, 0, 1000000000] pass","solution":"def prefix_sum_array(arr): Converts the given array into a prefix sum array. Each element in the resulting array is the sum of all elements up to and including that position in the original array. prefix_sum = [] current_sum = 0 for num in arr: current_sum += num prefix_sum.append(current_sum) return prefix_sum"},{"question":"def min_edges_to_connect_all_servers(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of edges that need to be added to ensure that any server can communicate with any other server, directly or indirectly. >>> min_edges_to_connect_all_servers(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> min_edges_to_connect_all_servers(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 0 >>> min_edges_to_connect_all_servers(1, 0, []) 0 >>> min_edges_to_connect_all_servers(4, 0, []) 3 >>> min_edges_to_connect_all_servers(3, 3, [(1, 2), (2, 3), (3, 1)]) 0","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def min_edges_to_connect_all_servers(n, m, edges): if n <= 0: return 0 parent = [i for i in range(n)] rank = [0] * n for u, v in edges: union(parent, rank, u - 1, v - 1) # Count the number of connected components connected_components = len(set(find(parent, i) for i in range(n))) # Minimum number of edges to connect all components return connected_components - 1"},{"question":"from typing import List, Tuple, Dict def top_rated_books_by_genre(recommendations: List[Tuple[str, str, int]]) -> Dict[str, str]: Given a list of book recommendations, returns a dictionary with the highest-rated book from each genre. In case of a tie, the lexicographically smallest title is chosen. Args: recommendations (List[Tuple[str, str, int]]): A list of tuples containing genre, title, and rating of books. Returns: Dict[str, str]: A dictionary where keys are genres and values are the titles of the highest-rated books. Examples: >>> top_rated_books_by_genre([(\\"Fantasy\\", \\"TheHobbit\\", 95), (\\"Fantasy\\", \\"TheLordOfTheRings\\", 98)]) {'Fantasy': 'TheLordOfTheRings'} >>> top_rated_books_by_genre([ (\\"Fantasy\\", \\"TheHobbit\\", 95), (\\"Fantasy\\", \\"TheLordOfTheRings\\", 98), (\\"ScienceFiction\\", \\"Dune\\", 97), (\\"ScienceFiction\\", \\"Hyperion\\", 97), (\\"Mystery\\", \\"TheHoundOfTheBaskervilles\\", 90) ]) {'Fantasy': 'TheLordOfTheRings', 'ScienceFiction': 'Dune', 'Mystery': 'TheHoundOfTheBaskervilles'}","solution":"def top_rated_books_by_genre(recommendations): Given a list of book recommendations, returns a dictionary with the highest-rated book from each genre. In case of a tie, the lexicographically smallest title is chosen. from collections import defaultdict genre_top_book = defaultdict(lambda: (\\"\\", \\"\\", -1)) for genre, title, rating in recommendations: if (rating > genre_top_book[genre][2] or (rating == genre_top_book[genre][2] and title < genre_top_book[genre][1])): genre_top_book[genre] = (genre, title, rating) result = {genre: title for genre, (genre, title, rating) in sorted(genre_top_book.items())} return result"},{"question":"def min_operations_to_turn_on_bulbs(k: int) -> int: Returns the minimum number of operations required to turn on all the bulbs in a complete binary tree with N = 2^k - 1 nodes. >>> min_operations_to_turn_on_bulbs(1) 1 >>> min_operations_to_turn_on_bulbs(2) 1 >>> min_operations_to_turn_on_bulbs(3) 1 >>> min_operations_to_turn_on_bulbs(4) 1 >>> min_operations_to_turn_on_bulbs(5) 1 >>> min_operations_to_turn_on_bulbs(10) 1 pass","solution":"def min_operations_to_turn_on_bulbs(k): Returns the minimum number of operations required to turn on all the bulbs in a complete binary tree with N = 2^k - 1 nodes. return 1"},{"question":"from typing import List def min_difference_partition(n: int, nums: List[int]) -> int: Given a list of integers, partition the list into two non-empty sublists such that the sum of the elements in the first sublist is as close as possible to the sum of the elements in the second sublist. Return the minimum absolute difference between the sums of the two sublists. >>> min_difference_partition(5, [3, 1, 4, 2, 2]) 0 >>> min_difference_partition(3, [1, 2, 3]) 0","solution":"from itertools import combinations def min_difference_partition(n, nums): total_sum = sum(nums) best_diff = float('inf') for r in range(1, (n // 2) + 1): for subset in combinations(nums, r): subset_sum = sum(subset) diff = abs((total_sum - subset_sum) - subset_sum) if diff < best_diff: best_diff = diff return best_diff"},{"question":"def operations_to_match(A: int, B: int) -> int: Returns the minimum number of increment or decrement operations needed to change A to B. >>> operations_to_match(5, 9) 4 >>> operations_to_match(12, 3) 9 >>> operations_to_match(0, 15) 15 >>> operations_to_match(1, 2) 1 import pytest def test_operations_to_match_same_value(): assert operations_to_match(7, 7) == 0 def test_operations_to_match_different_values(): assert operations_to_match(5, 9) == 4 assert operations_to_match(12, 3) == 9 def test_operations_to_match_min_max_values(): assert operations_to_match(0, 15) == 15 assert operations_to_match(15, 0) == 15 def test_operations_to_match_close_values(): assert operations_to_match(1, 2) == 1 assert operations_to_match(14, 13) == 1 def test_operations_to_match_reverse_difference(): assert operations_to_match(9, 5) == 4 assert operations_to_match(3, 12) == 9","solution":"def operations_to_match(A, B): Returns the minimum number of increment or decrement operations needed to change A to B. # Increment or decrement operations needed to change A to B return abs(A - B)"},{"question":"def min_distance_between_rectangles(rect1: Tuple[int, int, int, int], rect2: Tuple[int, int, int, int]) -> float: Determine the minimum Euclidean distance between any two points such that one point lies on the perimeter of the first rectangle and the other point lies on the perimeter of the second rectangle. The perimeter of a rectangle includes all four sides. The minimum Euclidean distance between two rectangles is zero if they overlap or touch each other. Args: rect1: A tuple of four integers (x1, y1, x2, y2) representing the bottom-left corner (x1, y1) and the top-right corner (x2, y2) of the first rectangle. rect2: A tuple of four integers (x3, y3, x4, y4) representing the bottom-left corner (x3, y3) and the top-right corner (x4, y4) of the second rectangle. Returns: A float representing the minimum Euclidean distance between any point on the perimeter of the first rectangle and any point on the perimeter of the second rectangle. >>> abs(min_distance_between_rectangles((0, 0, 2, 2), (1, 1, 3, 3))) - 0.0 < 1e-6 True >>> abs(min_distance_between_rectangles((0, 0, 2, 2), (3, 3, 5, 5)) - 1.414213) < 1e-6 True >>> abs(min_distance_between_rectangles((0, 0, 2, 2), (2, 2, 4, 4)) - 0.0) < 1e-6 True >>> abs(min_distance_between_rectangles((0, 0, 2, 2), (4, 0, 6, 2)) - 2.0) < 1e-6 True >>> abs(min_distance_between_rectangles((0, 0, 2, 2), (0, 4, 2, 6)) - 2.0) < 1e-6 True","solution":"import math def min_distance_between_rectangles(rect1, rect2): x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 # Check if rectangles touch or overlap if not (x2 < x3 or x4 < x1 or y2 < y3 or y4 < y1): return 0.0 # Calculate horizontal and vertical distances dx = max(0, x3 - x2, x1 - x4) dy = max(0, y3 - y2, y1 - y4) return math.sqrt(dx * dx + dy * dy)"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Determines the minimum number of operations needed to make all elements in the array equal. The allowed operation is to choose any non-negative integer x and add it to any subset of the array. Parameters: n (int): The number of elements in the array arr (list of int): The list of integers representing the array Returns: int: The minimum number of operations needed to make all elements equal Examples: >>> min_operations_to_equal_elements(4, [1, 2, 3, 4]) 3 >>> min_operations_to_equal_elements(3, [2, 2, 2]) 0 >>> min_operations_to_equal_elements(5, [3, 6, 9, 12, 15]) 4 pass def test_min_operations_to_equal_elements_example_1(): assert min_operations_to_equal_elements(4, [1, 2, 3, 4]) == 3 def test_min_operations_to_equal_elements_example_2(): assert min_operations_to_equal_elements(3, [2, 2, 2]) == 0 def test_min_operations_to_equal_elements_example_3(): assert min_operations_to_equal_elements(5, [3, 6, 9, 12, 15]) == 4 def test_min_operations_to_equal_elements_single_element(): assert min_operations_to_equal_elements(1, [7]) == 0 def test_min_operations_to_equal_elements_all_same(): assert min_operations_to_equal_elements(6, [5, 5, 5, 5, 5, 5]) == 0 def test_min_operations_to_equal_elements_two_unique_elements(): assert min_operations_to_equal_elements(5, [1, 2, 1, 2, 1]) == 1 def test_min_operations_to_equal_elements_large_range(): assert min_operations_to_equal_elements(6, [1, 10, 20, 30, 40, 50]) == 5","solution":"def min_operations_to_equal_elements(n, arr): Determines the minimum number of operations needed to make all elements in the array equal. The allowed operation is to choose any non-negative integer x and add it to any subset of the array. Parameters: n (int): The number of elements in the array arr (list of int): The list of integers representing the array Returns: int: The minimum number of operations needed to make all elements equal if n == 1: return 0 unique_elements = set(arr) return len(unique_elements) - 1"},{"question":"def solve_sudoku(grid: List[List[str]]) -> List[List[str]]: Solve the Sudoku puzzle. Args: grid (List[List[str]]): 9x9 grid filled with digits from '1' to '9' or dots '.' representing empty cells. Returns: List[List[str]]: The solved 9x9 Sudoku grid with all cells filled correctly. >>> grid = [ ... ['5', '3', '.', '.', '7', '.', '.', '.', '.'], ... ['6', '.', '.', '1', '9', '5', '.', '.', '.'], ... ['.', '9', '8', '.', '.', '.', '.', '6', '.'], ... ['8', '.', '.', '.', '6', '.', '.', '.', '3'], ... ['4', '.', '.', '8', '.', '3', '.', '.', '1'], ... ['7', '.', '.', '.', '2', '.', '.', '.', '6'], ... ['.', '6', '.', '.', '.', '.', '2', '8', '.'], ... ['.', '.', '.', '4', '1', '9', '.', '.', '5'], ... ['.', '.', '.', '.', '8', '.', '.', '7', '9'] ... ] ... assert solve_sudoku(grid) == [ ... ['5', '3', '4', '6', '7', '8', '9', '1', '2'], ... ['6', '7', '2', '1', '9', '5', '3', '4', '8'], ... ['1', '9', '8', '3', '4', '2', '5', '6', '7'], ... ['8', '5', '9', '7', '6', '1', '4', '2', '3'], ... ['4', '2', '6', '8', '5', '3', '7', '9', '1'], ... ['7', '1', '3', '9', '2', '4', '8', '5', '6'], ... ['9', '6', '1', '5', '3', '7', '2', '8', '4'], ... ['2', '8', '7', '4', '1', '9', '6', '3', '5'], ... ['3', '4', '5', '2', '8', '6', '1', '7', '9'] ... ]","solution":"def solve_sudoku(grid): def is_valid_move(grid, row, col, number): # Check if the number is not repeated in the current row, column, and 3x3 subgrid. for i in range(9): if grid[row][i] == number or grid[i][col] == number: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if grid[i][j] == number: return False return True def solve(grid): for row in range(9): for col in range(9): if grid[row][col] == '.': for number in '123456789': if is_valid_move(grid, row, col, number): grid[row][col] = number if solve(grid): return True grid[row][col] = '.' return False return True solve(grid) return grid"},{"question":"from typing import List, Tuple def minimum_courses(C: int, P: int, initial_course: int, target_course: int, prerequisites: List[Tuple[int, int]]) -> int: Determine the minimum number of courses needed to reach the target course from the initial course. >>> minimum_courses(4, 3, 1, 4, [(1, 2), (2, 3), (3, 4)]) 4 >>> minimum_courses(4, 2, 1, 4, [(1, 2), (2, 3)]) -1 >>> minimum_courses(5, 4, 1, 5, [(1, 2), (2, 3), (1, 4), (4, 5)]) 3 >>> minimum_courses(3, 0, 1, 3, []) -1 >>> minimum_courses(3, 2, 1, 1, [(1, 2), (2, 3)]) 1","solution":"from collections import deque, defaultdict def minimum_courses(C, P, initial_course, target_course, prerequisites): if initial_course == target_course: return 1 graph = defaultdict(list) in_degree = {i: 0 for i in range(1, C + 1)} for a, b in prerequisites: graph[a].append(b) in_degree[b] += 1 queue = deque([initial_course]) distances = {initial_course: 1} while queue: course = queue.popleft() current_distance = distances[course] for neighbor in graph[course]: if neighbor not in distances: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: distances[neighbor] = current_distance + 1 queue.append(neighbor) return distances.get(target_course, -1)"},{"question":"def max_total_productivity(N, M, efficiencies): Calculates the maximum possible total productivity of the company. :param N: Number of employees :param M: Number of projects :param efficiencies: List of efficiencies for each employee :return: Maximum possible total productivity >>> max_total_productivity(5, 2, [10, 20, 30, 40, 50]) 150 >>> max_total_productivity(4, 4, [1, 2, 3, 4]) 10 def test_max_total_productivity_example1(): assert max_total_productivity(5, 2, [10, 20, 30, 40, 50]) == 150 def test_max_total_productivity_example2(): assert max_total_productivity(4, 4, [1, 2, 3, 4]) == 10 def test_max_total_productivity_case1(): assert max_total_productivity(3, 2, [5, 10, 15]) == 30 def test_max_total_productivity_case2(): assert max_total_productivity(6, 3, [1, 2, 3, 4, 5, 6]) == 21 def test_max_total_productivity_case3(): assert max_total_productivity(3, 1, [7, 8, 9]) == 24","solution":"def max_total_productivity(N, M, efficiencies): Calculates the maximum possible total productivity of the company. :param N: Number of employees :param M: Number of projects :param efficiencies: List of efficiencies for each employee :return: Maximum possible total productivity # Sort efficiencies in descending order efficiencies.sort(reverse=True) # Summing up the top M efficiencies max_productivity = sum(efficiencies[:M]) # Total productivity is sum of all efficiencies total_productivity = sum(efficiencies) return total_productivity"},{"question":"def max_pair_sum(test_cases): Given multiple test cases, compute the maximum sum of two distinct elements for each test case. Args: test_cases (List[Tuple[int, List[int]]]): A list of test cases, where each test case is a tuple containing an integer N (number of elements in the list) and a list of N integers. Returns: List[int]: A list of integers where each integer is the result of the corresponding test case. >>> test_cases = [(4, [1, 5, 3, 2]), (5, [4, 8, 6, 7, 1])] >>> max_pair_sum(test_cases) [8, 15] def parse_input(input_str): Parse the input string into a list of test cases. Args: input_str (str): The input string Returns: List[Tuple[int, List[int]]]: A list of test cases. >>> input_str = \\"2n4n1 5 3 2n5n4 8 6 7 1\\" >>> parse_input(input_str) [(4, [1, 5, 3, 2]), (5, [4, 8, 6, 7, 1])] def format_output(results): Format the output results as a string. Args: results (List[int]): The results from the max_pair_sum function Returns: str: A formatted string for the results. >>> results = [8, 15] >>> format_output(results) \\"8n15\\" from solution import max_pair_sum, parse_input, format_output def test_example_cases(): input_str = \\"2n4n1 5 3 2n5n4 8 6 7 1\\" test_cases = parse_input(input_str) results = max_pair_sum(test_cases) output_str = format_output(results) assert output_str == \\"8n15\\" def test_single_element_cases(): input_str = \\"3n1n5n1n8n1n0\\" test_cases = parse_input(input_str) results = max_pair_sum(test_cases) output_str = format_output(results) assert output_str == \\"0n0n0\\" def test_all_zeros(): input_str = \\"1n5n0 0 0 0 0\\" test_cases = parse_input(input_str) results = max_pair_sum(test_cases) output_str = format_output(results) assert output_str == \\"0\\" def test_large_numbers(): input_str = \\"1n3n100000 99999 88888\\" test_cases = parse_input(input_str) results = max_pair_sum(test_cases) output_str = format_output(results) assert output_str == \\"199999\\" def test_all_identical(): input_str = \\"1n4n7 7 7 7\\" test_cases = parse_input(input_str) results = max_pair_sum(test_cases) output_str = format_output(results) assert output_str == \\"14\\"","solution":"def max_pair_sum(test_cases): results = [] for case in test_cases: N, arr = case if N < 2: results.append(0) # In case of not enough elements, assume sum is 0 continue arr.sort(reverse=True) results.append(arr[0] + arr[1]) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((N, arr)) index += 2 return test_cases def format_output(results): return \\"n\\".join(map(str, results))"},{"question":"def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping intervals that can be selected from the given collection. Args: intervals (list of tuples): List of intervals (L, R) where L <= R. Returns: int: Maximum number of non-overlapping intervals. >>> max_non_overlapping_intervals([(1, 3), (2, 4), (3, 5), (7, 8)]) == 2 >>> max_non_overlapping_intervals([(5, 6), (1, 2), (2, 3)]) == 2 >>> max_non_overlapping_intervals([(1, 2)]) == 1 >>> max_non_overlapping_intervals([(1, 2), (2, 3), (3, 4)]) == 3 >>> max_non_overlapping_intervals([]) == 0 def process_cases(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Processes multiple test cases for the interval problem. Args: test_cases (list): List of test cases, where each test case is a tuple containing the number of intervals and the list of intervals. Returns: list: List of results for each test case. >>> process_cases([(4, [(1, 3), (2, 4), (3, 5), (7, 8)]), (3, [(5, 6), (1, 2), (2, 3)])]) == [2, 2] >>> process_cases([(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)])]) == [3]","solution":"def max_non_overlapping_intervals(intervals): Determines the maximum number of non-overlapping intervals that can be selected from the given collection. Args: intervals (list of tuples): List of intervals (L, R) where L <= R. Returns: int: Maximum number of non-overlapping intervals. # Sort intervals by their ending times intervals.sort(key=lambda x: x[1]) # Track the end of the last added interval end = float('-inf') count = 0 for interval in intervals: if interval[0] > end: count += 1 end = interval[1] return count def process_cases(test_cases): Processes multiple test cases for the interval problem. Args: test_cases (list): List of test cases, where each test case is a tuple containing the number of intervals and the list of intervals. Returns: list: List of results for each test case. results = [] for n, intervals in test_cases: results.append(max_non_overlapping_intervals(intervals)) return results"},{"question":"from typing import List def longest_mountain(arr: List[int]) -> int: Identify the length of the longest mountain in the array. A mountain is defined as a subarray that has at least three elements and satisfies the following properties: - There exists some peak element \`arr[k]\` such that \`arr[0] < arr[1] < ... < arr[k-1] < arr[k] > arr[k+1] > ... > arr[N-2] > arr[N-1]\`. - The subarray must be strictly increasing up to the peak element and then strictly decreasing after the peak element. Args: arr (List[int]): Array of integers representing the elevation of a mountain range. Returns: int: Length of the longest mountain subarray. If there is no such subarray, return 0. Examples: >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 2, 2]) 0 >>> longest_mountain([9, 8, 7, 6, 5, 4, 3, 2, 1, 2]) 0","solution":"from typing import List def longest_mountain(arr: List[int]) -> int: n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 right = i + 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 while right < n - 1 and arr[right] > arr[right + 1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def next_musical_scale(S: str) -> str: Given a musical scale S as a string, determine the next scale that appears after S in the lexicographical order. If there is no such scale, return \\"-1\\". >>> next_musical_scale(\\"CDE\\") \\"CDF\\" >>> next_musical_scale(\\"BEF\\") \\"BEG\\" >>> next_musical_scale(\\"G\\") \\"-1\\" >>> next_musical_scale(\\"ACE\\") \\"ACF\\"","solution":"def next_musical_scale(S): Given the musical scale S as a string, returns the next scale that appears after S in the lexicographical order. If there is no such scale, returns \\"-1\\". # The musical alphabet musical_alphabet = 'ABCDEFG' # Find all possible combinations of the musical scale based on the length of S from itertools import combinations scales = [''.join(combo) for combo in combinations(musical_alphabet, len(S))] # Find the index of the current scale try: current_index = scales.index(S) except ValueError: return \\"-1\\" # The next scale would be the next index after the current scale next_index = current_index + 1 if next_index < len(scales): return scales[next_index] else: return \\"-1\\""},{"question":"from typing import List def min_moves_to_equal_elements(arr: List[int]) -> int: Returns the minimum number of moves required to make all elements of the array equal. pass def test_min_moves_static_cases(): assert min_moves_to_equal_elements([1, 2, 3]) == 2 assert min_moves_to_equal_elements([1, 10, 2, 9]) == 16 def test_min_moves_single_element(): assert min_moves_to_equal_elements([5]) == 0 def test_min_moves_identical_elements(): assert min_moves_to_equal_elements([7, 7, 7, 7]) == 0 def test_min_moves_large_range_elements(): assert min_moves_to_equal_elements([-10000, 10000]) == 20000 assert min_moves_to_equal_elements([0, 1, 2, 3, 4]) == 6 def test_min_moves_negative_and_positive(): assert min_moves_to_equal_elements([-1, 0, 1]) == 2 assert min_moves_to_equal_elements([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) == 30 def test_min_moves_evens_and_odds(): assert min_moves_to_equal_elements([1, 3, 5, 7]) == 8 assert min_moves_to_equal_elements([1, 3, 5, 7, 9]) == 12","solution":"from typing import List def min_moves_to_equal_elements(arr: List[int]) -> int: Returns the minimum number of moves required to make all elements of the array equal. # Finding the median to minimize the number of moves arr.sort() median = arr[len(arr) // 2] # Calculating the number of moves needed to make all the elements equal to median return sum(abs(x - median) for x in arr)"},{"question":"def max_subarray_sum(array: List[int]) -> int: Finds the sum of the contiguous subarray which has the largest sum. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([-2, -3, -1, -7]) == -1 >>> max_subarray_sum([3, -2, 5, -1]) == 6 >>> max_subarray_sum([-1, -2, 3, 4, 0, -1, 2, 1]) == 9 >>> max_subarray_sum([-1, 2, -3, 4, -1, 2, 1, -5, 4]) == 6","solution":"def max_subarray_sum(array): Finds the sum of the contiguous subarray which has the largest sum. max_current = max_global = array[0] for number in array[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def count_gleams(n: int) -> int: Returns the number of Gleams that have exactly n digits. >>> count_gleams(1) 9 >>> count_gleams(2) 36 from math import comb def test_single_digit_gleam(): assert count_gleams(1) == 9 def test_two_digit_gleam(): assert count_gleams(2) == 36 def test_three_digit_gleam(): assert count_gleams(3) == 84 def test_four_digit_gleam(): assert count_gleams(4) == 126 def test_five_digit_gleam(): assert count_gleams(5) == 126 def test_six_digit_gleam(): assert count_gleams(6) == 84 def test_seven_digit_gleam(): assert count_gleams(7) == 36 def test_eight_digit_gleam(): assert count_gleams(8) == 9 def test_nine_digit_gleam(): assert count_gleams(9) == 1","solution":"from math import comb def count_gleams(n): Returns the number of Gleams that have exactly n digits. # The number of Gleams of length n is the number of ways to choose n digits out of 9 (1 to 9). return comb(9, n)"},{"question":"def min_shelves_needed(test_cases): Given a list of test cases, each consisting of the heights of books, returns the minimum number of shelves needed to accommodate all books for each test case. pass # Test cases import pytest def test_min_shelves_needed_single_case(): test_cases = [(5, [10, 12, 15, 10, 20])] assert min_shelves_needed(test_cases) == [5] def test_min_shelves_needed_multiple_cases(): test_cases = [ (5, [10, 12, 15, 10, 20]), (3, [7, 8, 9]) ] assert min_shelves_needed(test_cases) == [5, 3] def test_min_shelves_needed_edge_case_single_book(): test_cases = [(1, [10])] assert min_shelves_needed(test_cases) == [1] def test_min_shelves_needed_edge_case_large_number_of_books(): test_cases = [(100000, [i for i in range(1, 100001)])] assert min_shelves_needed(test_cases) == [100000] def test_min_shelves_needed_no_books(): test_cases = [(0, [])] assert min_shelves_needed(test_cases) == [0] @pytest.mark.parametrize(\\"heights, expected\\", [ ([1, 1, 1, 1], 4), ([100, 100, 100], 3), ([10, 20, 30, 40, 50], 5), ]) def test_min_shelves_needed_parametrized(heights, expected): test_cases = [(len(heights), heights)] assert min_shelves_needed(test_cases) == [expected]","solution":"def min_shelves_needed(test_cases): Given a list of test cases, each consisting of the heights of books, returns the minimum number of shelves needed to accommodate all books for each test case. results = [] for case in test_cases: num_books, book_heights = case # Since vertical stacking is not allowed, each book goes on a new shelf. results.append(num_books) return results"},{"question":"def min_cuts(n: int, m: int, garden: List[str]) -> int: Returns the minimum number of cuts required to isolate each flower in the garden. >>> min_cuts(3, 4, [\\"....\\", \\".F..\\", \\"..F.\\"]) 2 >>> min_cuts(4, 5, [\\".....\\", \\".F.F.\\", \\".....\\", \\"..F..\\"]) 3 # Test cases def test_example_1(): n, m = 3, 4 garden = [ \\"....\\", \\".F..\\", \\"..F.\\" ] assert min_cuts(n, m, garden) == 2 def test_example_2(): n, m = 4, 5 garden = [ \\".....\\", \\".F.F.\\", \\".....\\", \\"..F..\\" ] assert min_cuts(n, m, garden) == 3 def test_case_all_empty(): n, m = 2, 2 garden = [ \\"..\\", \\"..\\" ] assert min_cuts(n, m, garden) == 0 def test_case_one_flower(): n, m = 3, 3 garden = [ \\"...\\", \\".F.\\", \\"...\\" ] assert min_cuts(n, m, garden) == 1 def test_case_full_flowers(): n, m = 2, 2 garden = [ \\"FF\\", \\"FF\\" ] assert min_cuts(n, m, garden) == 2","solution":"def min_cuts(n, m, garden): Returns the minimum number of cuts required to isolate each flower in the garden. horizontal_cuts = 0 vertical_cuts = 0 # Count horizontal cuts for i in range(n): previous_was_flower = False for j in range(m): if garden[i][j] == 'F': if not previous_was_flower: horizontal_cuts += 1 previous_was_flower = True else: previous_was_flower = False # Count vertical cuts for j in range(m): previous_was_flower = False for i in range(n): if garden[i][j] == 'F': if not previous_was_flower: vertical_cuts += 1 previous_was_flower = True else: previous_was_flower = False return min(horizontal_cuts, vertical_cuts)"},{"question":"from typing import List, Tuple def shortest_path_in_maze(t: int, mazes: List[Tuple[int, int, List[str]]]) -> List[int]: Determine the shortest path from the start cell 'S' to the end cell 'E' in multiple 2D grid mazes. >>> shortest_path_in_maze(2, [(5, 5, ['S..#.', '.#.#.', '.#.#.', '.#..E', '#']), (4, 4, ['S.#E', '.#..', '.#..', '..#.'])]) [7, -1] >>> shortest_path_in_maze(2, [(3, 3, ['S..', '...', '..E']), (3, 3, ['S#.', '#..', '..E'])]) [4, -1] >>> shortest_path_in_maze(1, [(3, 3, ['S.E', '#', '#'])]) [2] >>> shortest_path_in_maze(1, [(3, 3, ['S#E', '#', '#'])]) [-1]","solution":"from collections import deque def shortest_path_in_maze(t, mazes): def bfs(maze, start, end, m, n): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * n for _ in range(m)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) while queue: r, c, dist = queue.popleft() if (r, c) == end: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and not visited[nr][nc] and maze[nr][nc] != '#': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return -1 results = [] for i in range(t): m, n = mazes[i][0], mazes[i][1] maze = mazes[i][2] start = end = None for r in range(m): for c in range(n): if maze[r][c] == 'S': start = (r, c) elif maze[r][c] == 'E': end = (r, c) if start and end: results.append(bfs(maze, start, end, m, n)) else: results.append(-1) return results"},{"question":"def can_form_domino_chain(n, dominoes): Determine if it is possible to form a single chain of dominoes using all the given pieces exactly once. The first line contains a single integer n (1 ≤ n ≤ 100) — the number of dominoes. The next n lines each contain two integers ai and bi (0 ≤ ai, bi ≤ 100) — representing the values on the ends of each domino. >>> can_form_domino_chain(3, [(1, 2), (2, 3), (3, 1)]) \\"YES\\" >>> can_form_domino_chain(3, [(1, 2), (2, 3), (4, 5)]) \\"NO\\" >>> can_form_domino_chain(1, [(1, 1)]) \\"YES\\" >>> can_form_domino_chain(2, [(1, 2), (3, 4)]) \\"NO\\" >>> can_form_domino_chain(4, [(1, 2), (2, 3), (3, 4), (5, 6)]) \\"NO\\"","solution":"from collections import defaultdict, deque def can_form_domino_chain(n, dominoes): # Function to check if all values have even degree except for zero or two vertices def has_eulerian_path(edges, degrees): odd_count = 0 for node, degree in degrees.items(): if degree % 2 != 0: odd_count += 1 return odd_count == 0 or odd_count == 2 # If there's only one domino, it's always possible if n == 1 and any domino is given if n == 1: return \\"YES\\" edges = defaultdict(list) degrees = defaultdict(int) for a, b in dominoes: edges[a].append(b) edges[b].append(a) degrees[a] += 1 degrees[b] += 1 if not has_eulerian_path(edges, degrees): return \\"NO\\" def is_connected(): # Find a non-isolated node to start BFS start_node = next(iter(edges)) visited = set() queue = deque([start_node]) while queue: node = queue.popleft() visited.add(node) for neighbor in edges[node]: if neighbor not in visited: queue.append(neighbor) # Ensure all nodes that have edges are visited for node in edges: if node not in visited: return False return True return \\"YES\\" if is_connected() else \\"NO\\""},{"question":"def max_distinct_locations(n, k, locations): Returns the maximum number of distinct locations within any sliding window of size \`k\`. :param n: An integer representing the number of days Stephanie tracked the birds. :param k: An integer representing the size of the sliding window. :param locations: A list of integers representing the locations visited by the birds on each day. :return: An integer representing the maximum number of distinct locations within any sliding window of size \`k\`. >>> max_distinct_locations(7, 3, [1, 2, 1, 3, 4, 2, 3]) 3 >>> max_distinct_locations(6, 4, [5, 5, 5, 4, 4, 4]) 2","solution":"def max_distinct_locations(n, k, locations): Returns the maximum number of distinct locations within any sliding window of size \`k\`. :param n: An integer representing the number of days Stephanie tracked the birds. :param k: An integer representing the size of the sliding window. :param locations: A list of integers representing the locations visited by the birds on each day. :return: An integer representing the maximum number of distinct locations within any sliding window of size \`k\`. from collections import defaultdict if k == 1: return 1 # If window size is 1, the max distinct locations in any window will be 1. location_count = defaultdict(int) distinct_count = 0 max_distinct = 0 # Initialize the first window for i in range(k): if location_count[locations[i]] == 0: distinct_count += 1 location_count[locations[i]] += 1 max_distinct = distinct_count # Slide the window from start to the end for i in range(k, n): # Remove the element that is going out of the window location_out = locations[i - k] location_count[location_out] -= 1 if location_count[location_out] == 0: distinct_count -= 1 # Add the new element that is coming into the window location_in = locations[i] if location_count[location_in] == 0: distinct_count += 1 location_count[location_in] += 1 max_distinct = max(max_distinct, distinct_count) return max_distinct"},{"question":"def largest_min_in_submatrix(n: int, m: int, k: int, matrix: List[List[int]]) -> int: Finds the largest possible value of the smallest element in any k x k submatrix. Args: n: Number of rows in the matrix. m: Number of columns in the matrix. k: Size of the k x k submatrix. matrix: The n x m matrix itself as a list of lists. Returns: Integer representing the largest possible value of the smallest element in any k x k submatrix. >>> matrix = [ ... [1, 7, 3, 4], ... [2, 6, 5, 9], ... [4, 5, 8, 6], ... [1, 1, 2, 3] ... ] >>> largest_min_in_submatrix(4, 4, 2, matrix) 5 >>> matrix = [[10]] >>> largest_min_in_submatrix(1, 1, 1, matrix) 10 >>> matrix = [ ... [2, 3], ... [1, 4] ... ] >>> largest_min_in_submatrix(2, 2, 2, matrix) 1 >>> matrix = [[1, 2, 3, 4, 5]] >>> largest_min_in_submatrix(1, 5, 1, matrix) 5 >>> matrix = [ ... [1], ... [2], ... [3], ... [4], ... [5] ... ] >>> largest_min_in_submatrix(5, 1, 1, matrix) 5 >>> matrix = [ ... [7, 8, 6, 5], ... [4, 3, 2, 1], ... [5, 6, 9, 4], ... [8, 7, 6, 5] ... ] >>> largest_min_in_submatrix(4, 4, 3, matrix) 2","solution":"def largest_min_in_submatrix(n, m, k, matrix): Finds the largest possible value of the smallest element in any k x k submatrix. Args: n: Number of rows in the matrix. m: Number of columns in the matrix. k: Size of the k x k submatrix. matrix: The n x m matrix itself as a list of lists. Returns: Integer representing the largest possible value of the smallest element in any k x k submatrix. # Function to find the smallest element in a k x k submatrix starting at (x,y) def get_min_in_submatrix(x, y): return min(matrix[i][j] for i in range(x, x + k) for j in range(y, y + k)) max_min_value = 0 for i in range(n - k + 1): for j in range(m - k + 1): current_min = get_min_in_submatrix(i, j) max_min_value = max(max_min_value, current_min) return max_min_value"},{"question":"def count_divisible_pairs(n: int, k: int, scores: List[int]) -> int: Returns the number of pairs (i, j) such that 0 ≤ i < j < n and (scores[i] + scores[j]) % k == 0. :param n: Integer, number of participants :param k: Integer, divisor :param scores: List of integers, participants' scores :return: Integer, number of pairs (i, j) with (scores[i] + scores[j]) % k == 0 >>> count_divisible_pairs(5, 3, [1, 2, 3, 4, 5]) 4 >>> count_divisible_pairs(4, 5, [10, 20, 30, 40]) 6","solution":"def count_divisible_pairs(n, k, scores): Returns the number of pairs (i, j) such that 0 ≤ i < j < n and (scores[i] + scores[j]) % k == 0. :param n: Integer, number of participants :param k: Integer, divisor :param scores: List of integers, participants' scores :return: Integer, number of pairs (i, j) with (scores[i] + scores[j]) % k == 0 count = 0 # Loop through each pair (i, j) for i in range(n): for j in range(i + 1, n): if (scores[i] + scores[j]) % k == 0: count += 1 return count"},{"question":"def prizes_won(n, t, thresholds, scores): Determine the number of prizes each participant will win based on their total score. :param n: Number of participants :param t: Number of score thresholds :param thresholds: List of score thresholds in ascending order :param scores: List of scores for each participant :return: List of prizes won by each participant >>> prizes_won(3, 3, [5, 10, 20], [7, 15, 23]) [1, 2, 3] >>> prizes_won(2, 4, [10, 20, 30, 40], [25, 35]) [2, 3] >>> prizes_won(3, 3, [5, 10, 15], [1, 2, 3]) [0, 0, 0] >>> prizes_won(1, 3, [5, 10, 15], [20]) [3] >>> prizes_won(1, 4, [5, 10, 15, 20], [15]) [3] >>> prizes_won(4, 3, [10, 20, 30], [5, 15, 25, 35]) [0, 1, 2, 3] >>> prizes_won(1, 3, [10, 20, 30], [30]) [3]","solution":"def prizes_won(n, t, thresholds, scores): Determine the number of prizes each participant will win based on their total score. :param n: Number of participants :param t: Number of score thresholds :param thresholds: List of score thresholds in ascending order :param scores: List of scores for each participant :return: List of prizes won by each participant result = [] for score in scores: count = 0 for threshold in thresholds: if score >= threshold: count += 1 else: break result.append(count) return result"},{"question":"from typing import List def triplet_sum_to_zero(nums: List[int]) -> bool: Determines if there exists a triplet in the array such that the sum of the three elements is zero. Args: nums (List[int]): List of integers Returns: bool: True if there exists a triplet with sum zero, False otherwise. Examples: >>> triplet_sum_to_zero([-1, 0, 1, 2, -1, -4]) True >>> triplet_sum_to_zero([1, 2, 3, 4, 5]) False >>> triplet_sum_to_zero([0, 0, 0, 0, 0, 0]) True","solution":"def triplet_sum_to_zero(nums): Determines if there exists a triplet in the array such that the sum of the three elements is zero. Args: nums (List[int]): List of integers Returns: bool: True if there exists a triplet with sum zero, False otherwise. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: return True elif current_sum < 0: left += 1 else: right -= 1 return False"},{"question":"def three_sum_closest(nums: List[int], target: int) -> Tuple[int, int, int]: Returns three integers from the list nums whose sum is closest to the target. >>> three_sum_closest([-1, 2, 1, -4, 3], 1) (-1, 1, 2) >>> three_sum_closest([1, 1, 1, 0], 2) (1, 1, 0) pass Unit Test: from solution import three_sum_closest def test_example_case(): nums = [-1, 2, 1, -4, 3] target = 1 result = three_sum_closest(nums, target) assert sum(result) == 1 and set(result).issubset(nums) def test_large_numbers(): nums = [1000000000, -1000000000, 999999999, -999999999, 3] target = 3 result = three_sum_closest(nums, target) assert sum(result) == 3 and set(result).issubset(nums) def test_multiple_possible_answers(): nums = [1, 1, 1, 0] target = 2 result = three_sum_closest(nums, target) assert sum(result) == 2 and set(result).issubset(nums) def test_all_negatives(): nums = [-8, -7, -5, -1] target = -14 result = three_sum_closest(nums, target) assert sum(result) == -14 and set(result).issubset(nums) def test_all_positives(): nums = [1, 4, 5, 7] target = 10 result = three_sum_closest(nums, target) assert sum(result) == 10 and set(result).issubset(nums) def test_mix_of_positives_and_negatives(): nums = [-1, 2, 3, -4, 6] target = 0 result = three_sum_closest(nums, target) assert sum(result) == 1 and set(result).issubset(nums)","solution":"def three_sum_closest(nums, target): Returns three integers from the list nums whose sum is closest to the target. nums.sort() closest_sum = float('inf') closest_triplet = () for i in range(len(nums) - 2): # Applying two-pointer approach after the current element left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] # If this triplet is closer to target than the previous closest, update closest if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum closest_triplet = (nums[i], nums[left], nums[right]) # Move the pointers based on the sum comparison with the target if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return closest_triplet # Exact match found return closest_triplet"},{"question":"def can_allocate(pages, N, M, max_pages): Helper function to determine if it is possible to allocate pages such that no student has more than max_pages. pass def find_min_pages(pages, N, M): Function which executes binary search to find the minimum of the maximum pages any student can get. pass def minimum_maximum_pages(T, test_cases): Determines the minimum value of the maximum number of pages assigned to a student. Args: T: int, number of test cases test_cases: List of tuples, each containing a tuple (N, M) and a list of page counts Returns: A list of integers representing the minimum value of the maximum number of pages for each test case. >>> minimum_maximum_pages(2, [((4, 2), [12, 34, 67, 90]), ((3, 2), [15, 10, 20])]) [113, 25] >>> minimum_maximum_pages(1, [((1, 1), [50])]) [50] pass","solution":"def can_allocate(pages, N, M, max_pages): Helper function to determine if it is possible to allocate pages such that no student has more than max_pages. student_count = 1 current_pages = 0 for i in range(N): if pages[i] > max_pages: return False if current_pages + pages[i] > max_pages: student_count += 1 current_pages = pages[i] if student_count > M: return False else: current_pages += pages[i] return True def find_min_pages(pages, N, M): Function which executes binary search to find the minimum of the maximum pages any student can get. if N < M: return -1 low, high = max(pages), sum(pages) result = high while low <= high: mid = (low + high) // 2 if can_allocate(pages, N, M, mid): result = mid high = mid - 1 else: low = mid + 1 return result def minimum_maximum_pages(T, test_cases): results = [] for t in range(T): N, M = test_cases[t][0] pages = test_cases[t][1] results.append(find_min_pages(pages, N, M)) return results"},{"question":"from typing import List def max_path_sum(matrix: List[List[int]]) -> int: Returns the maximum sum of values in any path from the top-left corner to the bottom-right corner of the matrix. The path can only move right or down at any step. >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 True >>> max_path_sum([ ... [-1, -2], ... [-3, -4] ... ]) == -7 True pass import pytest def test_example_1(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_path_sum(matrix) == 29 def test_example_2(): matrix = [ [-1, -2], [-3, -4] ] assert max_path_sum(matrix) == -7 def test_single_element_matrix(): matrix = [[5]] assert max_path_sum(matrix) == 5 def test_row_matrix(): matrix = [[1, 2, 3, 4]] assert max_path_sum(matrix) == 10 def test_column_matrix(): matrix = [ [1], [2], [3], [4] ] assert max_path_sum(matrix) == 10 def test_large_matrix(): matrix = [ [5, 3, 2], [1, 4, 1], [1, 2, 1] ] assert max_path_sum(matrix) == 15 def test_variable_matrix(): matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_path_sum(matrix) == 12","solution":"def max_path_sum(matrix): Returns the maximum sum of values in any path from the top-left corner to the bottom-right corner of the matrix. The path can only move right or down at any step. n = len(matrix) m = len(matrix[0]) # dp matrix to store the maximum sum up to each cell dp = [[0] * m for _ in range(n)] # Initialize the dp value for the top-left cell dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the dp matrix for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The bottom-right cell contains the maximum sum path return dp[n-1][m-1]"},{"question":"def count_unique_chocolates(n: int, avail: List[int]) -> int: Compute the total number of different chocolate bars that can be produced given the ingredients. Args: n (int): The number of different ingredients. avail (list of int): The maximum number of units available of each ingredient. Returns: int: The count of all possible unique chocolate bars that can be produced. >>> count_unique_chocolates(3, [3, 1, 2]) 23 >>> count_unique_chocolates(1, [5]) 5 >>> count_unique_chocolates(2, [1, 1]) 3 >>> count_unique_chocolates(3, [0, 0, 0]) 0 >>> count_unique_chocolates(4, [2, 0, 2, 3]) 35","solution":"def count_unique_chocolates(n, avail): Compute the total number of different chocolate bars that can be produced. Args: n (int): The number of different ingredients. avail (list of int): The maximum number of units available of each ingredient. Returns: int: The count of all possible unique chocolate bars that can be produced. # Total combinations is product of (avail[i] + 1) for all ingredients total_combinations = 1 for a in avail: total_combinations *= (a + 1) # Exclude the empty set (no ingredient used at all) return total_combinations - 1"},{"question":"def count_unique_pairs_with_sum(arr: List[int], n: int, k: int) -> int: Returns the number of unique pairs (i, j) such that the sum of the array elements at these indices is equal to a given integer K. Parameters: arr (list of int): The array of integers. n (int): The number of elements in the array. k (int): The target sum. Returns: int: The number of unique pairs (i, j) such that arr[i] + arr[j] == k and 1 <= i < j <= N. >>> count_unique_pairs_with_sum([1, 5, 3, 3, 7], 5, 8) 2 >>> count_unique_pairs_with_sum([1, 2, 3, 4, 5], 5, 10) 0 >>> count_unique_pairs_with_sum([1, 2, 3, 4, 5, 6], 6, 7) 3 >>> count_unique_pairs_with_sum([2, 2, 2, 2], 4, 4) 1 >>> count_unique_pairs_with_sum([-1, -2, 1, 2], 4, 0) 2 >>> count_unique_pairs_with_sum([1000000000, 1000000000, -1000000000], 3, 0) 1 >>> count_unique_pairs_with_sum([1], 1, 2) 0","solution":"def count_unique_pairs_with_sum(arr, n, k): Returns the number of unique pairs (i, j) such that the sum of the array elements at these indices is equal to a given integer K. Parameters: arr (list of int): The array of integers. n (int): The number of elements in the array. k (int): The target sum. Returns: int: The number of unique pairs (i, j) such that arr[i] + arr[j] == k and 1 <= i < j <= N. seen = set() pairs = set() for i in range(n): complement = k - arr[i] if complement in seen: pairs.add((min(arr[i], complement), max(arr[i], complement))) seen.add(arr[i]) return len(pairs)"},{"question":"def simple_text_editor(operations): Simulates a simple text editor with append, delete, print, and undo operations. Args: operations (list of lists): Each inner list contains an operation. - [1, string] for append - [2, k] for delete - [3, k] for print - [4] for undo Returns: list of characters: Characters printed by operation [3, k] in the sequence they were called. >>> simple_text_editor([[1, \\"abc\\"], [3, 3], [2, 3], [1, \\"xyz\\"], [3, 2], [4], [4], [3, 1]]) ['c', 'y', 'a'] >>> simple_text_editor([[1, \\"hello\\"], [1, \\"world\\"], [3, 5], [3, 1]]) ['o', 'h'] >>> simple_text_editor([[1, \\"hello\\"], [2, 3], [3, 1], [1, \\"lp\\"], [3, 3]]) ['h', 'l'] >>> simple_text_editor([[1, \\"abc\\"], [1, \\"def\\"], [2, 3], [4], [4], [3, 3]]) ['c'] >>> simple_text_editor([[1, \\"abcd\\"], [3, 5], [3, 0]]) [] >>> simple_text_editor([]) []","solution":"def simple_text_editor(operations): text = \\"\\" history = [] output = [] for op in operations: if op[0] == 1: # Append operation history.append(text) text += op[1] elif op[0] == 2: # Delete operation history.append(text) k = op[1] text = text[:-k] elif op[0] == 3: # Print operation k = op[1] if 0 < k <= len(text): output.append(text[k-1]) elif op[0] == 4: # Undo operation if history: text = history.pop() return output"},{"question":"from typing import List, Tuple def find_task_order(n: int, dependencies: List[List[int]]) -> List[int]: Given n tasks and their dependencies, determine in what order to complete the tasks so that no task starts before all its dependencies are completed. If it's not possible to complete all tasks, return -1. >>> find_task_order(3, [[0], [1, 1], [1, 1]]) [1, 2, 3] >>> find_task_order(4, [[0], [2, 1, 3], [1, 1], [0]]) [1, 4, 3, 2] >>> find_task_order(3, [[1, 2], [1, 3], [1, 1]]) [-1] pass def solution(t: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[List[int]]: Processes multiple test cases to determine the task completion order for each case. >>> solution(2, [(3, [[0], [1, 1], [1, 1]]), (4, [[0], [2, 1, 3], [1, 1], [0]])]) [[1, 2, 3], [1, 4, 3, 2]] pass","solution":"from collections import deque def find_task_order(n, dependencies): in_degree = [0] * n adj_list = [[] for _ in range(n)] for i in range(n): k = dependencies[i][0] for j in range(1, k+1): dependency = dependencies[i][j] - 1 # adjust to zero indexing adj_list[dependency].append(i) in_degree[i] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current + 1) # adjust back to one indexing for neighbor in adj_list[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == n: return order else: return [-1] def solution(t, test_cases): result = [] for i in range(t): n = test_cases[i][0] dependencies = test_cases[i][1] result.append(find_task_order(n, dependencies)) return result"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def dijkstra(graph, start, target): # Priority queue to store minimum distances pq = [(0, start)] # Dictionary to store the shortest path to each node shortest_paths = {start: 0} while pq: current_time, current_island = heapq.heappop(pq) if current_island == target: return current_time for neighbor, travel_time in graph[current_island]: time = current_time + travel_time if neighbor not in shortest_paths or time < shortest_paths[neighbor]: shortest_paths[neighbor] = time heapq.heappush(pq, (time, neighbor)) return float(\\"inf\\") def min_travel_time(N: int, E: int, roads: List[Tuple[int, int, int]], A: int, B: int) -> int: Calculate the minimum travel time between two islands. Args: N (int): Number of islands. E (int): Number of roads. roads (List[Tuple[int, int, int]]): List of tuples each representing a road with travel time. A (int): Starting island. B (int): Destination island. Returns: int: Minimum travel time between island A and island B. Example: >>> N = 6 >>> E = 8 >>> roads = [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 5, 3), (5, 6, 1), (1, 5, 10), (2, 4, 1), (3, 6, 2)] >>> A = 1 >>> B = 6 >>> min_travel_time(N, E, roads, A, B) 5 >>> N = 5 >>> E = 5 >>> roads = [(1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5), (1, 5, 100)] >>> A = 2 >>> B = 4 >>> min_travel_time(N, E, roads, A, B) 7","solution":"import heapq from collections import defaultdict def dijkstra(graph, start, target): # Priority queue to store minimum distances pq = [(0, start)] # Dictionary to store the shortest path to each node shortest_paths = {start: 0} while pq: current_time, current_island = heapq.heappop(pq) if current_island == target: return current_time for neighbor, travel_time in graph[current_island]: time = current_time + travel_time if neighbor not in shortest_paths or time < shortest_paths[neighbor]: shortest_paths[neighbor] = time heapq.heappush(pq, (time, neighbor)) return float(\\"inf\\") def min_travel_time(N, E, roads, A, B): graph = defaultdict(list) for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) return dijkstra(graph, A, B)"},{"question":"def process_transactions(n: int, initial_balances: List[int], transactions: List[str]) -> List[int]: Simulate a financial transactions system involving multiple bank accounts. :param n: Number of accounts :param initial_balances: Initial balance of each account :param transactions: List of transactions (either transfers or queries) :return: List of results for each query Example: >>> process_transactions(5, [100, 200, 300, 400, 500], [\\"T 1 2 50\\", \\"Q 1\\", \\"Q 2\\", \\"T 3 4 100\\", \\"Q 3\\", \\"Q 4\\", \\"T 2 5 150\\"]) [50, 250, 200, 500] import pytest from solution import process_transactions def test_example_case(): assert process_transactions(5, [100, 200, 300, 400, 500], [\\"T 1 2 50\\", \\"Q 1\\", \\"Q 2\\", \\"T 3 4 100\\", \\"Q 3\\", \\"Q 4\\", \\"T 2 5 150\\"]) == [50, 250, 200, 500] def test_no_transactions(): assert process_transactions(3, [100, 200, 300], []) == [] def test_only_queries(): assert process_transactions(3, [100, 200, 300], [\\"Q 1\\", \\"Q 2\\", \\"Q 3\\"]) == [100, 200, 300] def test_multiple_transfers(): assert process_transactions(4, [50, 150, 100, 200], [\\"T 1 2 20\\", \\"T 3 4 50\\", \\"T 2 3 30\\"]) == [] def test_mixed_transactions(): assert process_transactions(3, [100, 200, 300], [\\"T 1 2 50\\", \\"Q 1\\", \\"T 2 3 100\\", \\"Q 3\\", \\"Q 2\\"]) == [50, 400, 150] def test_large_transfer(): assert process_transactions(2, [1000, 1000], [\\"T 1 2 1000\\", \\"Q 1\\", \\"Q 2\\"]) == [0, 2000] def test_multiple_queries(): assert process_transactions(2, [500, 1000], [\\"Q 1\\", \\"Q 1\\", \\"Q 2\\", \\"Q 2\\"]) == [500, 500, 1000, 1000]","solution":"def process_transactions(n, initial_balances, transactions): accounts = initial_balances[:] result = [] for transaction in transactions: parts = transaction.split() if parts[0] == \\"T\\": # Transfer transaction x, y, z = int(parts[1]) - 1, int(parts[2]) - 1, int(parts[3]) accounts[x] -= z accounts[y] += z elif parts[0] == \\"Q\\": # Query transaction x = int(parts[1]) - 1 result.append(accounts[x]) return result"},{"question":"def most_frequent_character(text: str) -> tuple: Identifies the most frequently typed character and counts how many times it appears in the text, ignoring spaces. If there are multiple characters with the same highest frequency, return the one which appears first in the text. >>> most_frequent_character(\\"hello world\\") ('l', 3) >>> most_frequent_character(\\"aaabbbbccccc\\") ('c', 5) >>> most_frequent_character(\\"the quick brown fox jumps over the lazy dog\\") ('o', 4) >>> most_frequent_character(\\"aAaAaA\\") ('a', 3) from solution import most_frequent_character def test_example_1(): assert most_frequent_character(\\"hello world\\") == ('l', 3) def test_example_2(): assert most_frequent_character(\\"aaabbbbccccc\\") == ('c', 5) def test_example_3(): assert most_frequent_character(\\"the quick brown fox jumps over the lazy dog\\") == ('o', 4) def test_example_4(): assert most_frequent_character(\\"aAaAaA\\") == ('a', 3) def test_single_character(): assert most_frequent_character(\\"AAAAAA\\") == ('A', 6) def test_different_characters_same_frequency(): assert most_frequent_character(\\"abcdabcd\\") == ('a', 2) def test_empty_input(): assert most_frequent_character(\\"\\") == (None, 0) def test_all_spaces(): assert most_frequent_character(\\" \\") == (None, 0)","solution":"def most_frequent_character(text): Returns the most frequently typed character and the number of times it appears in the text, ignoring spaces. If there are multiple such characters with the same frequency, the one that appears first in the text is returned. from collections import Counter # Filter out spaces filtered_text = text.replace(' ', '') # Count the frequency of each character char_count = Counter(filtered_text) # Find the most frequent character and its count most_frequent = None max_count = 0 for char in filtered_text: if char_count[char] > max_count: most_frequent = char max_count = char_count[char] return most_frequent, max_count"},{"question":"def replace_word(sentence: str, target: str, replacement: str) -> str: Replaces each instance of a specified word in a sentence with another word. :param sentence: The original sentence as a string. :param target: The word to be replaced. :param replacement: The word to replace with. :return: A new sentence with the target word replaced by the replacement word. # Your code here # Unit tests def test_replace_word_single_occurrence(): assert replace_word(\\"hello world\\", \\"world\\", \\"there\\") == \\"hello there\\" def test_replace_word_multiple_occurrences(): assert replace_word(\\"the cat in the hat\\", \\"the\\", \\"a\\") == \\"a cat in a hat\\" def test_replace_word_no_change(): assert replace_word(\\"the cat in the hat\\", \\"dog\\", \\"wolf\\") == \\"the cat in the hat\\" def test_replace_word_same_target_and_replacement(): assert replace_word(\\"hello world\\", \\"world\\", \\"world\\") == \\"hello world\\" def test_replace_word_entire_sentence(): assert replace_word(\\"test test test\\", \\"test\\", \\"exam\\") == \\"exam exam exam\\" def test_replace_word_with_empty_replacement(): assert replace_word(\\"this is a test test\\", \\"test\\", \\"\\") == \\"this is a \\"","solution":"def replace_word(sentence: str, target: str, replacement: str) -> str: Replaces each instance of a specified word in a sentence with another word. :param sentence: The original sentence as a string. :param target: The word to be replaced. :param replacement: The word to replace with. :return: A new sentence with the target word replaced by the replacement word. words = sentence.split() new_sentence = ' '.join([replacement if word == target else word for word in words]) return new_sentence"},{"question":"def game_result(coins1: int, coins2: int, tcr1: int, tcr2: int) -> str: Determines the winner or if it's a draw based on the given coins and TCR values. Parameters: coins1 (int): Coins collected by Diana. coins2 (int): Coins collected by Ethan. tcr1 (int): Task completion rate of Diana. tcr2 (int): Task completion rate of Ethan. Returns: str: \\"Diana\\" if Diana wins, \\"Ethan\\" if Ethan wins, \\"Draw\\" if it's a draw. >>> game_result(3, 4, 50, 45) \\"Diana\\" >>> game_result(5, 5, -1, 45) \\"Ethan\\" >>> game_result(6, 6, 25, 25) \\"Draw\\"","solution":"def game_result(coins1, coins2, tcr1, tcr2): Determines the winner or if it's a draw based on the given coins and TCR values. Parameters: coins1 (int): Coins collected by Diana. coins2 (int): Coins collected by Ethan. tcr1 (int): Task completion rate of Diana. tcr2 (int): Task completion rate of Ethan. Returns: str: \\"Diana\\" if Diana wins, \\"Ethan\\" if Ethan wins, \\"Draw\\" if it's a draw. score1 = coins1 * 2 + (tcr1 if tcr1 != -1 else 0) score2 = coins2 * 2 + (tcr2 if tcr2 != -1 else 0) if score1 > score2: return \\"Diana\\" elif score2 > score1: return \\"Ethan\\" else: return \\"Draw\\""},{"question":"def min_operations(s: str, t: str) -> int: Determine the minimum number of operations needed to transform string s into string t. >>> min_operations(\\"ACGT\\", \\"ACG\\") 1 >>> min_operations(\\"GATTACA\\", \\"GCATGCU\\") 4 >>> min_operations(\\"A\\", \\"GTC\\") 3 from solution import min_operations def test_example_1(): assert min_operations(\\"ACGT\\", \\"ACG\\") == 1 def test_example_2(): assert min_operations(\\"GATTACA\\", \\"GCATGCU\\") == 4 def test_example_3(): assert min_operations(\\"A\\", \\"GTC\\") == 3 def test_identical_strings(): assert min_operations(\\"ACGT\\", \\"ACGT\\") == 0 def test_insertion_needed(): assert min_operations(\\"ACG\\", \\"ACGT\\") == 1 def test_deletion_needed(): assert min_operations(\\"ACGTG\\", \\"ACGT\\") == 1 def test_replacement_needed(): assert min_operations(\\"ACGT\\", \\"AGGT\\") == 1 def test_long_strings(): s = \\"A\\" * 2000 t = \\"T\\" * 2000 assert min_operations(s, t) == 2000","solution":"def min_operations(s, t): Returns the minimum number of operations required to transform string s into string t. m, n = len(s), len(t) # Create a 2D array to store the minimum number of operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialization for transformations involving empty string for i in range(m + 1): dp[i][0] = i # Deleting all characters from s for j in range(n + 1): dp[0][j] = j # Inserting all characters into s # Compute the minimal operations using dynamic programming for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation needed if characters are the same else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"def min_meeting_rooms(schedules): Calculate the minimum number of meeting rooms required for given schedules. :param schedules: List[List[Tuple[int, int]]], a nested list where each sublist is a list of intervals for an employee :return: int, minimum number of meeting rooms required >>> min_meeting_rooms([[(1, 3), (5, 6), (8, 10)], [(2, 4), (7, 8)]]) 2 >>> min_meeting_rooms([[(1, 3), (5, 6)], [(2, 4)], [(1, 5)]]) 3 >>> min_meeting_rooms([[(1, 3)]]) 1 >>> min_meeting_rooms([[(1, 3), (5, 7), (8, 10)]]) 1 >>> min_meeting_rooms([[], [], []]) 0 >>> min_meeting_rooms([[(1, 3), (4, 5)], [(2, 4)], [(2, 3), (3, 5)], [(1, 2), (3, 4)]]) 3 >>> min_meeting_rooms([[(0, 1000000000)], [(1, 1000000000)], [(2, 3)]]) 3","solution":"def min_meeting_rooms(schedules): Calculate the minimum number of meeting rooms required for given schedules. :param schedules: List[List[Tuple[int, int]]], a nested list where each sublist is a list of intervals for an employee :return: int, minimum number of meeting rooms required if not schedules: return 0 intervals = [] for schedule in schedules: for interval in schedule: intervals.append((interval[0], 1)) # 1 for start of an interval intervals.append((interval[1], -1)) # -1 for end of an interval # Sort intervals, and in case of ties, end (-1) comes before start (1) intervals.sort(key=lambda x: (x[0], x[1])) max_rooms = 0 current_rooms = 0 for time, delta in intervals: current_rooms += delta max_rooms = max(max_rooms, current_rooms) return max_rooms"},{"question":"def min_cost_to_reach_goal(ck, cb, cn, N, start, goal): Compute the minimum total cost to move pieces from a given starting arrangement into a specified goal arrangement on an NxN chessboard. :param ck: Cost for moving a King :param cb: Cost for moving a Bishop :param cn: Cost for moving a Knight :param N: Size of the chessboard :param start: List of strings representing the starting arrangement :param goal: List of strings representing the goal arrangement :return: Minimum total cost to achieve the goal arrangement >>> min_cost_to_reach_goal(10, 20, 15, 3, ['K..', '...', '..B'], ['B..', '...', '..K']) 40 >>> min_cost_to_reach_goal(5, 15, 10, 4, ['KN..', '....', '....', '..BK'], ['....', '....', ' ..B', 'N..K']) 35","solution":"from heapq import heappop, heappush from math import inf def min_cost_to_reach_goal(ck, cb, cn, N, start, goal): def get_king_moves(x, y): moves = [] for dx in [-1, 0, 1]: for dy in [-1, 0, 1]: if dx == 0 and dy == 0: continue if 0 <= x + dx < N and 0 <= y + dy < N: moves.append((x + dx, y + dy)) return moves def get_bishop_moves(x, y): moves = [] for dx in [-1, 1]: for dy in [-1, 1]: new_x, new_y = x, y while True: new_x += dx new_y += dy if 0 <= new_x < N and 0 <= new_y < N: moves.append((new_x, new_y)) else: break return moves def get_knight_moves(x, y): moves = [] for dx, dy in [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]: if 0 <= x + dx < N and 0 <= y + dy < N: moves.append((x + dx, y + dy)) return moves starting_positions = {'K': [], 'B': [], 'N': []} goal_positions = {'K': [], 'B': [], 'N': []} for i in range(N): for j in range(N): if start[i][j] in 'KBN': starting_positions[start[i][j]].append((i, j)) if goal[i][j] in 'KBN': goal_positions[goal[i][j]].append((i, j)) def bfs(piece, start_pos, goal_pos, get_moves, cost): queue = [(0, start_pos)] visited = set() visited.add(start_pos) while queue: curr_cost, (x, y) = heappop(queue) if (x, y) == goal_pos: return curr_cost for new_x, new_y in get_moves(x, y): if (new_x, new_y) not in visited: visited.add((new_x, new_y)) heappush(queue, (curr_cost + cost, (new_x, new_y))) return inf def match_pieces(piece, cost, get_moves): assigned = [-1] * len(goal_positions[piece]) matched_cost = 0 for idx, start_pos in enumerate(starting_positions[piece]): min_cost = inf min_idx = -1 for goal_idx, goal_pos in enumerate(goal_positions[piece]): curr_cost = bfs(piece, start_pos, goal_pos, get_moves, cost) if curr_cost < min_cost: min_cost = curr_cost min_idx = goal_idx if min_idx != -1: assigned[min_idx] = idx matched_cost += min_cost return matched_cost total_cost = 0 total_cost += match_pieces('K', ck, get_king_moves) total_cost += match_pieces('B', cb, get_bishop_moves) total_cost += match_pieces('N', cn, get_knight_moves) return total_cost"},{"question":"def is_network_well_connected(N: int, lines: List[Tuple[int, int]]) -> str: Determine if the bus network is well-connected even if any one bus line is temporarily out of operation. >>> is_network_well_connected(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> is_network_well_connected(3, [(1, 2), (2, 3)]) \\"NO\\" >>> is_network_well_connected(3, [(1, 2), (2, 3), (1, 3)]) \\"YES\\" def process_datasets(datasets: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Process multiple datasets to check if each bus network is well-connected. >>> process_datasets([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (3, 2, [(1, 2), (2, 3)]), (3, 3, [(1, 2), (2, 3), (1, 3)]), (0, 0, [])]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def is_network_well_connected(N, lines): def dfs(current, visited, adj): visited.add(current) for neighbor in adj[current]: if neighbor not in visited: dfs(neighbor, visited, adj) adj = {i: [] for i in range(1, N + 1)} for u, v in lines: adj[u].append(v) adj[v].append(u) for u, v in lines: visited1 = set() visited2 = set() adj[u].remove(v) adj[v].remove(u) dfs(1, visited1, adj) if len(visited1) != N: adj[u].append(v) adj[v].append(u) return \\"NO\\" adj[u].append(v) adj[v].append(u) dfs(u, visited2, adj) if len(visited2) != N: return \\"NO\\" return \\"YES\\" def process_datasets(datasets): results = [] for dataset in datasets: N, L, lines = dataset if N == 0 and L == 0: break results.append(is_network_well_connected(N, lines)) return results"},{"question":"from typing import List def countSubarrays(arr: List[int], target: int) -> int: Returns the number of subarrays whose sum is exactly equal to the target. >>> countSubarrays([1, 2, 3, 2, 1], 5) 2 >>> countSubarrays([5], 5) 1 >>> countSubarrays([-5], -5) 1 >>> countSubarrays([1], 5) 0 >>> countSubarrays([1, 2, 3], 10) 0 >>> countSubarrays([1, 1, 1], 2) 2 >>> countSubarrays([1, 2, 3], 3) 2 >>> countSubarrays([1, 2, -3, 3, -2], 3) 3 >>> countSubarrays([1, -1, 1, -1, 1, -1, 1], 0) 12 >>> countSubarrays([], 0) 0","solution":"from typing import List def countSubarrays(arr: List[int], target: int) -> int: Returns the number of subarrays whose sum is exactly equal to the target. count = 0 current_sum = 0 prefix_sums = {0: 1} # to handle subarrays starting from index 0 for num in arr: current_sum += num if current_sum - target in prefix_sums: count += prefix_sums[current_sum - target] if current_sum in prefix_sums: prefix_sums[current_sum] += 1 else: prefix_sums[current_sum] = 1 return count"},{"question":"def can_form_triangle(arr: List[int]) -> str: Determines if any three numbers in the array can form a triangle. For any three sides a, b, and c to form a triangle, the sum of any two sides must be greater than the third side. arr.sort() for i in range(len(arr) - 2): if arr[i] + arr[i + 1] > arr[i + 2]: return \\"YES\\" return \\"NO\\" # Example usage # n = 6 # arr = [2, 9, 4, 7, 3, 5] # print(can_form_triangle(arr)) # should print \\"YES\\" # Tests from solution import can_form_triangle def test_can_form_triangle_case_1(): assert can_form_triangle([2, 9, 4, 7, 3, 5]) == \\"YES\\" def test_can_form_triangle_case_2(): assert can_form_triangle([10, 1, 2, 4]) == \\"NO\\" def test_can_form_triangle_case_3(): assert can_form_triangle([5, 10, 15, 20, 25]) == \\"YES\\" def test_can_form_triangle_case_4(): assert can_form_triangle([3, 6, 8, 10, 15]) == \\"YES\\" def test_can_form_triangle_case_5(): assert can_form_triangle([1, 2, 3]) == \\"NO\\" def test_can_form_triangle_case_6(): assert can_form_triangle([7, 10, 5, 20, 35]) == \\"YES\\" def test_can_form_triangle_case_7(): assert can_form_triangle([1, 1, 1, 1]) == \\"YES\\" def test_can_form_triangle_case_8(): assert can_form_triangle([1, 2, 4, 8, 16]) == \\"NO\\" def test_can_form_triangle_case_9(): assert can_form_triangle([10**9, 10**9 - 1, 10**9 - 2]) == \\"YES\\" def test_can_form_triangle_case_10(): assert can_form_triangle([1, 2, 2, 3, 3, 4]) == \\"YES\\"","solution":"def can_form_triangle(arr): Determines if any three numbers in the array can form a triangle. For any three sides a, b, and c to form a triangle, the sum of any two sides must be greater than the third side. arr.sort() for i in range(len(arr) - 2): if arr[i] + arr[i + 1] > arr[i + 2]: return \\"YES\\" return \\"NO\\" # Example usage # n = 6 # arr = [2, 9, 4, 7, 3, 5] # print(can_form_triangle(arr)) # should print \\"YES\\""},{"question":"def is_prime(num: int) -> bool: This function checks if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(7) True >>> is_prime(9) False >>> is_prime(1) False >>> is_prime(11) True >>> is_prime(0) False >>> is_prime(-2) False >>> is_prime(13) True def max_prime_fish(p: int, m: int, meals: List[List[int]]) -> List[int]: This function computes the number of prime fish in each penguin's sequence of meals. >>> max_prime_fish(2, 5, [[3, 7, 8, 9, 11], [6, 13, 17, 4, 5, 6]]) [3, 3] >>> max_prime_fish(1, 6, [[1, 2, 3, 4, 5, 6]]) [3] >>> max_prime_fish(3, 4, [[2, 2, 2, 2], [1, 4, 6, 8], [3, 5, 7, 11]]) [4, 0, 4] >>> max_prime_fish(2, 3, [[1000000, 999983, 999979], [7, 7, 10]]) [2, 2]","solution":"def is_prime(num): This function checks if a number is a prime number. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def max_prime_fish(p, m, meals): This function computes the number of prime fish in each penguin's sequence of meals. prime_counts = [] for penguin_meals in meals: prime_count = sum(1 for fish in penguin_meals if is_prime(fish)) prime_counts.append(prime_count) return prime_counts"},{"question":"def sum_of_unique_elements(matrix, N, M): Compute the sum of unique integers within a matrix (i.e., elements that appear exactly once). Args: matrix (List[List[int]]): Matrix of integers. N (int): Number of rows in matrix. M (int): Number of columns in matrix. Returns: int: Sum of all unique elements in the matrix. If there are no unique elements, return 0. Examples: >>> sum_of_unique_elements([[1, 2, 3], [4, 5, 6], [7, 8, 1]], 3, 3) 35 >>> sum_of_unique_elements([[1, 2, 2, 3], [4, 4, 5, 5], [6, 7, 8, 8], [9, 9, 9, 9]], 4, 4) 17 pass def solve(test_cases): Solve multiple test cases for computing the sum of unique integers within matrices. Args: test_cases (List[Tuple[int, int, List[List[int]]]]): List of test cases where each test case is a tuple containing: N (int): Number of rows in matrix. M (int): Number of columns in matrix. matrix (List[List[int]]): Matrix of integers. Returns: List[int]: List of results for each test case. Example: >>> solve([ (3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 1] ]), (4, 4, [ [1, 2, 2, 3], [4, 4, 5, 5], [6, 7, 8, 8], [9, 9, 9, 9] ]) ]) [35, 17] pass","solution":"def sum_of_unique_elements(matrix, N, M): from collections import Counter # Flatten the matrix flat_matrix = [matrix[i][j] for i in range(N) for j in range(M)] # Count the frequency of each element element_count = Counter(flat_matrix) # Get the sum of unique elements (elements that appear exactly once) unique_sum = sum(elem for elem, count in element_count.items() if count == 1) return unique_sum def solve(test_cases): results = [] for case in test_cases: N, M, matrix = case result = sum_of_unique_elements(matrix, N, M) results.append(result) return results"},{"question":"def min_operations_to_reach_k(n: int, m: int, k: int, canvas: List[List[int]]) -> int: Determine the minimum number of painting-driven operations needed to achieve the target intensity k for all cells in the canvas. Args: n (int): The number of rows in the canvas. m (int): The number of columns in the canvas. k (int): The target intensity value. canvas (List[List[int]]): Initial intensity values of the canvas cells. Returns: int: The minimum number of painting-driven operations to reach the target intensity k for all cells or -1 if it's not possible. Example: >>> min_operations_to_reach_k(3, 3, 2, [ ... [1, 1, 1], ... [0, 0, 0], ... [1, 0, 1], ... ]) == 2 >>> min_operations_to_reach_k(2, 2, 1, [ ... [1, 1], ... [1, 1], ... ]) == 0 >>> min_operations_to_reach_k(2, 2, 1, [ ... [2, 1], ... [1, 2], ... ]) == -1 >>> min_operations_to_reach_k(1, 1, 5, [ ... [0], ... ]) == 5 >>> min_operations_to_reach_k(3, 3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0], ... ]) == 3","solution":"def min_operations_to_reach_k(n, m, k, canvas): max_initial_intensity = max(max(row) for row in canvas) if max_initial_intensity > k: return -1 # Calculate the number of operations for each cell (i, j) to reach intensity k operations_needed = [[0 for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): operations_needed[i][j] = k - canvas[i][j] return max(max(row) for row in operations_needed) # Example usage n = 3 m = 3 k = 2 canvas = [ [1, 1, 1], [0, 0, 0], [1, 0, 1] ] print(min_operations_to_reach_k(n, m, k, canvas)) # Output: 2"},{"question":"def rainfall_statistics(rainfall): Returns the average rainfall and the number of days with rainfall above the average. Parameters: rainfall (list): A list of integers representing daily rainfall amounts. Returns: tuple: (average_rainfall, days_above_average) average_rainfall (int): The average rainfall rounded to the closest integer. days_above_average (int): The number of days where the rainfall was above the average. pass # Test Cases def test_normal_case(): assert rainfall_statistics([3, 6, 9, 2, 5]) == (5, 2) def test_all_equal_case(): assert rainfall_statistics([5, 5, 5, 5, 5]) == (5, 0) def test_empty_list(): assert rainfall_statistics([]) == (0, 0) def test_single_day(): assert rainfall_statistics([10]) == (10, 0) assert rainfall_statistics([0]) == (0, 0) def test_varied_rainfall(): assert rainfall_statistics([1, 2, 3, 4, 5, 15, 25]) == (8, 2) def test_negative_rainfall(): assert rainfall_statistics([-1, -2, -3, -4, -5]) == (-3, 2) assert rainfall_statistics([1, -1, 1, -1, 1, -1]) == (0, 3)","solution":"def rainfall_statistics(rainfall): Returns the average rainfall and the number of days with rainfall above the average. Parameters: rainfall (list): A list of integers representing daily rainfall amounts. Returns: tuple: (average_rainfall, days_above_average) average_rainfall (int): The average rainfall rounded to the closest integer. days_above_average (int): The number of days where the rainfall was above the average. if not rainfall: return (0, 0) total_rainfall = sum(rainfall) number_of_days = len(rainfall) average_rainfall = round(total_rainfall / number_of_days) days_above_average = sum(1 for rain in rainfall if rain > average_rainfall) return (average_rainfall, days_above_average)"},{"question":"def can_form_palindrome_after_reversing_substring(s: str) -> str: Returns 'YES' if the string can be rearranged to form a palindrome after reversing exactly one substring, otherwise returns 'NO'. >>> can_form_palindrome_after_reversing_substring(\\"aabb\\") 'YES' >>> can_form_palindrome_after_reversing_substring(\\"abcde\\") 'NO'","solution":"def can_form_palindrome_after_reversing_substring(s): Returns 'YES' if the string can be rearranged to form a palindrome after reversing exactly one substring, otherwise returns 'NO'. from collections import Counter # Function to check if we can rearrange the characters to form a palindrome def can_form_palindrome(char_count): odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 # Count the frequency of each character char_count = Counter(s) if can_form_palindrome(char_count): return \\"YES\\" return \\"NO\\""},{"question":"def minimum_latency(N: int, M: int, cables: List[Tuple[int, int, int]]) -> int: Find the minimum total latency required to connect all computers in the network. Input - N (int): number of computers - M (int): number of cables - cables (List[Tuple[int, int, int]]): each tuple contains three integers u, v, w representing a cable connecting computer u to computer v with latency w. Output - int: the minimum total latency to connect all computers in the network. If it is not possible to connect all computers, output -1. >>> minimum_latency(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5)]) 6 >>> minimum_latency(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> minimum_latency(2, 1, [(1, 2, 1)]) 1 >>> minimum_latency(3, 0, []) -1 >>> minimum_latency(5, 7, [(1, 2, 2), (1, 3, 3), (1, 4, 6), (2, 3, 3), (2, 5, 5), (3, 5, 4), (4, 5, 2)]) 11","solution":"def find_parent(parent, i): if parent[i] == i: return i else: return find_parent(parent, parent[i]) def union(parent, rank, x, y): xroot = find_parent(parent, x) yroot = find_parent(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_weight = 0 edge_count = 0 for edge in edges: u, v, w = edge u -= 1 v -= 1 x = find_parent(parent, u) y = find_parent(parent, v) if x != y: edge_count += 1 mst_weight += w union(parent, rank, x, y) if edge_count == n - 1: break if edge_count != n - 1: return -1 return mst_weight def minimum_latency(N, M, cables): return kruskal(N, cables)"},{"question":"def can_form_strictly_increasing_sequence(n: int, sequence: List[int]) -> str: Determines if it is possible to rearrange the sequence such that it becomes a strictly increasing sequence. Args: n (int): The number of integers in the sequence. sequence (list of int): The elements of the sequence. Returns: str: \\"YES\\" if it's possible to rearrange to get a strictly increasing sequence, \\"NO\\" otherwise. >>> can_form_strictly_increasing_sequence(5, [4, 5, 1, 3, 2]) 'YES' >>> can_form_strictly_increasing_sequence(3, [1, 1, 1]) 'NO'","solution":"def can_form_strictly_increasing_sequence(n, sequence): Determines if it is possible to rearrange the sequence such that it becomes a strictly increasing sequence. Args: n (int): The number of integers in the sequence. sequence (list of int): The elements of the sequence. Returns: str: \\"YES\\" if it's possible to rearrange to get a strictly increasing sequence, \\"NO\\" otherwise. sequence.sort() for i in range(1, n): if sequence[i] <= sequence[i - 1]: return \\"NO\\" return \\"YES\\" # Example usage: # print(can_form_strictly_increasing_sequence(5, [4, 5, 1, 3, 2])) # Output: \\"YES\\" # print(can_form_strictly_increasing_sequence(3, [1, 1, 1])) # Output: \\"NO\\""},{"question":"from typing import List def compress(ip_list: List[str]) -> List[str]: Compress a list of IPv4 addresses by representing continuous blocks using a range notation. >>> compress([\\"192.168.0.1\\", \\"192.168.0.2\\", \\"192.168.0.3\\", \\"192.168.0.10\\", \\"192.168.1.1\\", \\"192.168.1.2\\"]) [\\"192.168.0.1-192.168.0.3\\", \\"192.168.0.10\\", \\"192.168.1.1-192.168.1.2\\"] >>> compress([\\"192.168.0.1\\", \\"192.168.0.5\\"]) [\\"192.168.0.1\\", \\"192.168.0.5\\"] >>> compress([]) [] def expand(compressed_list: List[str]) -> List[str]: Expand a compressed list of IPv4 addresses back to the individual IP addresses. >>> expand([\\"192.168.0.1-192.168.0.3\\", \\"192.168.0.10\\", \\"192.168.1.1-192.168.1.2\\"]) [\\"192.168.0.1\\", \\"192.168.0.2\\", \\"192.168.0.3\\", \\"192.168.0.10\\", \\"192.168.1.1\\", \\"192.168.1.2\\"] >>> expand([\\"192.168.0.1\\", \\"192.168.0.5\\"]) [\\"192.168.0.1\\", \\"192.168.0.5\\"] >>> expand([]) []","solution":"def ip_to_int(ip): parts = map(int, ip.split('.')) return (next(parts) << 24) + (next(parts) << 16) + (next(parts) << 8) + next(parts) def int_to_ip(ip_int): return f\\"{(ip_int >> 24) & 0xFF}.{(ip_int >> 16) & 0xFF}.{(ip_int >> 8) & 0xFF}.{ip_int & 0xFF}\\" def compress(ip_list): if not ip_list: return [] compressed = [] start = ip_list[0] end = start for i in range(1, len(ip_list)): curr = ip_list[i] prev = ip_list[i - 1] if ip_to_int(curr) == ip_to_int(prev) + 1: end = curr else: if start == end: compressed.append(start) else: compressed.append(f\\"{start}-{end}\\") start = curr end = curr if start == end: compressed.append(start) else: compressed.append(f\\"{start}-{end}\\") return compressed def expand(compressed_list): expanded = [] for entry in compressed_list: if '-' in entry: start, end = entry.split('-') current = ip_to_int(start) end = ip_to_int(end) while current <= end: expanded.append(int_to_ip(current)) current += 1 else: expanded.append(entry) return expanded"},{"question":"def arrange_books_on_shelves(test_cases: List[List[int]]) -> List[List[int]]: Rearranges books on each shelf such that all books with even number of pages are placed before books with odd number of pages, maintaining relative order. Parameters: test_cases (list of list of int): list of test cases, where each test case is a list of integers representing the number of pages in each book on a shelf. Returns: list of list of int: List of rearranged book sequences for each test case. Examples: >>> arrange_books_on_shelves([[4, 3, 2, 1]]) [[4, 2, 3, 1]] >>> arrange_books_on_shelves([[10, 11, 8, 7, 6, 3]]) [[10, 8, 6, 11, 7, 3]] >>> arrange_books_on_shelves([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]) [[2, 4, 6, 8, 10, 1, 3, 5, 7, 9]] pass from solution import arrange_books_on_shelves def test_arrange_books_on_shelves(): test_cases = [ [4, 3, 2, 1], [10, 11, 8, 7, 6, 3], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7, 9], [2, 4, 6, 8, 10] ] expected_results = [ [4, 2, 3, 1], [10, 8, 6, 11, 7, 3], [2, 4, 6, 8, 10, 1, 3, 5, 7, 9], [1, 3, 5, 7, 9], [2, 4, 6, 8, 10] ] assert arrange_books_on_shelves(test_cases) == expected_results def test_single_shelf_one_even_one_odd(): test_cases = [[2, 1]] expected_results = [[2, 1]] assert arrange_books_on_shelves(test_cases) == expected_results def test_single_shelf_only_even(): test_cases = [[2, 4, 6]] expected_results = [[2, 4, 6]] assert arrange_books_on_shelves(test_cases) == expected_results def test_single_shelf_only_odd(): test_cases = [[1, 3, 5]] expected_results = [[1, 3, 5]] assert arrange_books_on_shelves(test_cases) == expected results def test_empty_shelf(): test_cases = [[]] expected_results = [[]] assert arrange_books_on_shelves(test_cases) == expected_results","solution":"def arrange_books_on_shelves(test_cases): Rearranges books on each shelf such that all books with even number of pages are placed before books with odd number of pages, maintaining relative order. Parameters: test_cases (list of list of int): list of test cases, where each test case is a list of integers representing the number of pages in each book on a shelf. Returns: list of list of int: List of rearranged book sequences for each test case. results = [] for books in test_cases: evens = [book for book in books if book % 2 == 0] odds = [book for book in books if book % 2 == 1] results.append(evens + odds) return results"},{"question":"def max_distinct_souvenirs(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Find the maximum number of distinct souvenirs a tourist can collect if they start and end their journey in village 1. >>> max_distinct_souvenirs(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 4 >>> max_distinct_souvenirs(5, 6, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 5), (5, 2)]) 5 >>> max_distinct_souvenirs(1, 0, []) 1 >>> max_distinct_souvenirs(3, 1, [(1, 2)]) 2","solution":"def max_distinct_souvenirs(n, m, roads): from collections import defaultdict, deque graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) def bfs(start): queue = deque([(start, 0)]) visited = set() count = 0 while queue: village, dist = queue.popleft() if village not in visited: visited.add(village) count += 1 for neighbor in graph[village]: if neighbor not in visited: queue.append((neighbor, dist + 1)) return count # As we start from village 1 and aim for collecting max distinct souvenirs. return bfs(1)"},{"question":"from typing import List def count_distinct_substrings(s: str) -> int: Write a function that takes a string containing only lowercase alphabets and returns the number of distinct substrings. >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 pass def test_examples(): assert count_distinct_substrings(\\"abc\\") == 6 assert count_distinct_substrings(\\"aaa\\") == 3 def test_single_character(): assert count_distinct_substrings(\\"a\\") == 1 assert count_distinct_substrings(\\"z\\") == 1 def test_repeating_characters(): assert count_distinct_substrings(\\"abab\\") == 7 assert count_distinct_substrings(\\"aaaa\\") == 4 def test_mixed_characters(): assert count_distinct_substrings(\\"abcd\\") == 10 assert count_distinct_substrings(\\"abac\\") == 9 def test_long_string(): long_string = \\"a\\" * 1000 assert count_distinct_substrings(long_string) == 1000","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings in the given string. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"from typing import List def longest_common_prefix(strings: List[str]) -> str: Finds the longest common prefix among a list of strings. :param strings: List of strings :return: Longest common prefix or an empty string if no common prefix exists >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"flee\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"single\\"]) 'single' >>> longest_common_prefix([\\"same\\", \\"same\\", \\"same\\"]) 'same' >>> longest_common_prefix([\\"\\", \\"b\\", \\"c\\"]) '' >>> longest_common_prefix([\\"a\\", \\"\\", \\"c\\"]) '' >>> longest_common_prefix([\\"abcd\\", \\"abc\\", \\"ab\\", \\"a\\"]) 'a' >>> longest_common_prefix([\\"AbC\\", \\"A\\", \\"Ab\\"]) 'A' >>> longest_common_prefix([]) ''","solution":"def longest_common_prefix(strings): Finds the longest common prefix among a list of strings. :param strings: List of strings :return: Longest common prefix or an empty string if no common prefix exists if not strings: return \\"\\" # Start by assuming that the whole first string is a common prefix prefix = strings[0] for s in strings[1:]: # Update the prefix until it matches the beginning of each string while not s.startswith(prefix): prefix = prefix[:-1] if prefix == \\"\\": return \\"\\" return prefix"},{"question":"def min_steps_to_target(n: int, m: int, warehouse: List[str], sr: int, sc: int, tr: int, tc: int) -> int: Given the grid and the starting and target positions of the robot, determine the minimum number of steps the robot needs to reach the target. If the target is unreachable, return -1. >>> min_steps_to_target(5, 5, [\\".....\\", \\"...\\", \\".#...\\", \\"....#\\", \\"#..\\"], 1, 1, 3, 3) 6 >>> min_steps_to_target(3, 4, [\\"..#.\\", \\".#..\\", \\".#.#\\"], 1, 2, 3, 4) -1 >>> min_steps_to_target(1, 1, [\\".\\"], 1, 1, 1, 1) 0 >>> min_steps_to_target(1, 2, [\\"..\\"], 1, 1, 1, 2) 1 >>> min_steps_to_target(3, 3, [\\"...\\", \\"...\\", \\"...\\"], 1, 1, 3, 3) 4","solution":"from collections import deque def min_steps_to_target(n, m, warehouse, sr, sc, tr, tc): sr, sc, tr, tc = sr - 1, sc - 1, tr - 1, tc - 1 if sr == tr and sc == tc: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue with the starting coordinates and the initial step count 0 queue = deque([(sr, sc, 0)]) visited = set() visited.add((sr, sc)) while queue: r, c, steps = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc # Make sure the new position is within bounds, and it's an empty cell if 0 <= nr < n and 0 <= nc < m and warehouse[nr][nc] == '.' and (nr, nc) not in visited: if nr == tr and nc == tc: return steps + 1 queue.append((nr, nc, steps + 1)) visited.add((nr, nc)) return -1"},{"question":"def is_symmetric(matrix: List[List[int]]) -> str: Checks if the given matrix is symmetric along its main diagonal. The symmetric matrix should meet the condition where the element at position (i, j) is the same as the element at position (j, i) for all valid i and j. Args: matrix (List[List[int]]): A 2D list of integers representing the matrix. Returns: str: \\"YES\\" if the matrix is symmetric along its main diagonal, \\"NO\\" otherwise. >>> is_symmetric([[1, 2, 3], [2, 4, 5], [3, 5, 6]]) 'YES' >>> is_symmetric([[1, 2], [2, 3], [3, 4]]) 'NO' >>> is_symmetric([[1, 2, 3], [4, 5, 6]]) 'NO' >>> is_symmetric([[1]]) 'YES' >>> is_symmetric([[1, 2], [2, 1]]) 'YES' >>> is_symmetric([[1, 2, 3, 4], [2, 5, 6, 7], [3, 6, 8, 9], [4, 7, 9, 10]]) 'YES' >>> is_symmetric([[1, 2, 3, 4], [2, 5, 6, 7], [3, 6, 8, 9], [4, 7, 10, 11]]) 'NO'","solution":"def is_symmetric(matrix): Checks if the given matrix is symmetric along its main diagonal. N = len(matrix) M = len(matrix[0]) if N != M: return \\"NO\\" for i in range(N): for j in range(i + 1, M): if matrix[i][j] != matrix[j][i]: return \\"NO\\" return \\"YES\\""},{"question":"def find_minimum_park_size(m: int, n: int, grid: List[str]) -> int: This function finds the minimum size (number of cells) of a rectangular park that can be built in the city grid under the given constraints. Args: m (int): number of rows in the grid n (int): number of columns in the grid grid (List[str]): list of strings representing the grid where \\".\\" is an empty cell and \\"B\\" is a building Returns: int: the minimum size of the rectangular park Examples: >>> find_minimum_park_size(4, 5, [\\".....\\", \\"..B..\\", \\".....\\", \\".B...\\"]) 1 >>> find_minimum_park_size(3, 4, [\\"BB..\\", \\"B..B\\", \\"..BB\\"]) 1 >>> find_minimum_park_size(2, 2, [\\"BB\\", \\"BB\\"]) 0 Unit Tests: def test_sample_inputs(): assert find_minimum_park_size(4, 5, [\\".....\\", \\"..B..\\", \\".....\\", \\".B...\\"]) == 1 assert find_minimum_park_size(3, 4, [\\"BB..\\", \\"B..B\\", \\"..BB\\"]) == 1 assert find_minimum_park_size(2, 2, [\\"BB\\", \\"BB\\"]) == 0 def test_no_empty_cells(): assert find_minimum_park_size(3, 3, [\\"BBB\\", \\"BBB\\", \\"BBB\\"]) == 0 def test_all_empty_cells(): assert find_minimum_park_size(2, 3, [\\"...\\", \\"...\\"]) == 1 def test_mixed_pattern(): assert find_minimum_park_size(3, 4, [\\"..B.\\", \\"B.B.\\", \\"..B.\\"]) == 1","solution":"def find_minimum_park_size(m, n, grid): This function finds the minimum size (number of cells) of a rectangular park that can be built in the city grid under the given constraints. min_size = float('inf') empty_found = False # Flag to check if there exist any empty cells for i in range(m): for j in range(n): if grid[i][j] == '.': min_size = 1 empty_found = True if not empty_found: return 0 return min_size"},{"question":"def can_arrange_balls(n: int, colors: List[int]) -> Union[str, Tuple[str, List[int]]]: Check if it is possible to arrange the balls such that no two adjacent balls have the same color. Args: n (int): the number of balls. colors (List[int]): the colors of the balls in the initial order. Returns: Union[str, Tuple[str, List[int]]]: \\"NO\\" if it is not possible, else \\"YES\\" and a valid arrangement. Examples: >>> can_arrange_balls(3, [1, 2, 1]) ('YES', [1, 2, 1]) >>> can_arrange_balls(4, [1, 1, 1, 1]) 'NO' >>> can_arrange_balls(6, [1, 2, 3, 4, 5, 1]) ('YES', [1, 2, 3, 4, 1, 5])","solution":"def can_arrange_balls(n, colors): from collections import Counter color_count = Counter(colors) if any(count > (n + 1) // 2 for count in color_count.values()): return \\"NO\\" sorted_colors = sorted(color_count.items(), key=lambda x: -x[1]) result = [0] * n index = 0 for color, count in sorted_colors: for _ in range(count): result[index] = color index += 2 if index >= n: index = 1 return \\"YES\\", result"},{"question":"def can_attend_all_courses(schedules): Determine for each classroom whether it is possible to attend all courses without any timing conflicts. >>> schedules = [ ... {\\"courses\\": [(900, 1200), (1300, 1500), (1200, 1300)]}, ... {\\"courses\\": [(1000, 1130), (1130, 1300)]} ... ] >>> can_attend_all_courses(schedules) [\\"YES\\", \\"YES\\"] >>> schedules = [ ... {\\"courses\\": [(900, 1200), (1100, 1300), (1200, 1300)]}, ... {\\"courses\\": [(1000, 1130), (1100, 1300)]} ... ] >>> can_attend_all_courses(schedules) [\\"NO\\", \\"NO\\"] >>> schedules = [ ... {\\"courses\\": []}, ... ] >>> can_attend_all_courses(schedules) [\\"YES\\"] >>> schedules = [ ... {\\"courses\\": [(900, 1200)]}, ... {\\"courses\\": [(1000, 1130)]} ... ] >>> can_attend_all_courses(schedules) [\\"YES\\", \\"YES\\"]","solution":"def can_attend_all_courses(schedules): results = [] for schedule in schedules: courses = schedule['courses'] courses.sort(key=lambda x: x[0]) for i in range(1, len(courses)): if courses[i][0] < courses[i-1][1]: results.append(\\"NO\\") break else: results.append(\\"YES\\") return results"},{"question":"from typing import List def reorganize_string(s: str) -> str: Given a string s consisting of lowercase English letters, return a new string by reordering the characters in s such that no two adjacent characters are the same. If it is not possible to do so, return an empty string. >>> reorganize_string(\\"aab\\") in [\\"aba\\"] True >>> reorganize_string(\\"aaab\\") == \\"\\" True def test_reorganize_string_1(): assert reorganize_string(\\"aab\\") in [\\"aba\\"] def test_reorganize_string_2(): assert reorganize_string(\\"aaab\\") == \\"\\" def test_reorganize_string_3(): result = reorganize_string(\\"aabb\\") valid_permutations = [\\"abab\\", \\"baba\\"] assert result in valid_permutations def test_reorganize_string_4(): assert reorganize_string(\\"aaaa\\") == \\"\\" def test_reorganize_string_5(): result = reorganize_string(\\"vvvlo\\") valid_permutations = [\\"vlvov\\", \\"vovvl\\"] assert result in valid_permutations def test_reorganize_string_6(): assert reorganize_string(\\"a\\") == \\"a\\" def test_reorganize_string_7(): assert reorganize_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] def test_reorganize_string_8(): assert reorganize_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] def test_reorganize_string_9(): result = reorganize_string(\\"aaabbc\\") valid_permutations = [ \\"ababac\\", \\"abacab\\", \\"acabab\\", \\"babaca\\", \\"bacaba\\", \\"abacab\\", \\"babaca\\" ] assert result in valid_permutations","solution":"import heapq from collections import Counter def reorganize_string(s): # Count frequency of each character freq = Counter(s) # Heap to store the characters by their frequency max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char result = ''.join(result) if len(result) != len(s): return \\"\\" return result"},{"question":"def longest_contiguous_subsequence_of_same_type(n: int, trees: List[int]) -> int: Returns the length of the longest contiguous subsequence of trees of the same type. >>> longest_contiguous_subsequence_of_same_type(7, [1, 1, 2, 2, 2, 3, 3]) 3 >>> longest_contiguous_subsequence_of_same_type(5, [4, 4, 4, 4, 4]) 5 >>> longest_contiguous_subsequence_of_same_type(10, [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) 4 >>> longest_contiguous_subsequence_of_same_type(1, [5]) 1 >>> longest_contiguous_subsequence_of_same_type(4, [1, 2, 3, 4]) 1 >>> longest_contiguous_subsequence_of_same_type(6, [7, 7, 7, 7, 7, 7]) 6 >>> longest_contiguous_subsequence_of_same_type(9, [8, 8, 9, 10, 9, 8, 8, 8, 8]) 4","solution":"def longest_contiguous_subsequence_of_same_type(n, trees): Returns the length of the longest contiguous subsequence of trees of the same type. if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if trees[i] == trees[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def delivery_service(n: int, m: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Calculate the minimum number of minutes required to deliver each package from its starting intersection to its destination intersection. Args: n (int): the number of intersections. m (int): the number of roads. edges (List[Tuple[int, int]]): each tuple contains two integers u and v indicating there is a road between intersections u and v. queries (List[Tuple[int, int]]): each tuple contains two integers a and b representing the start and destination intersections of a package. Returns: List[int]: minimum number of minutes required for each query. If it is impossible to deliver the package, return -1 for that query. Example: >>> delivery_service(7, 10, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 5), (4, 5), (4, 6), (5, 6), (5, 7)], [(1, 6), (2, 7), (1, 5)]) [3, 3, 2] pass","solution":"from collections import deque def shortest_path_bfs(n, edges, start, end): adj_list = {i: [] for i in range(1, n+1)} for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: node, distance = queue.popleft() if node == end: return distance for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1 def delivery_service(n, m, edges, queries): results = [] for a, b in queries: results.append(shortest_path_bfs(n, edges, a, b)) return results"},{"question":"def can_sort_by_subarray_reversal(n: int, arr: List[int]) -> str: Determines if it is possible to sort the array using the described operation (subarray reversal). Args: n : int : number of elements in the array arr : list of int : the array elements Returns: str : \\"YES\\" if the array can be sorted, otherwise \\"NO\\" Examples: >>> can_sort_by_subarray_reversal(4, [4, 3, 2, 1]) \\"YES\\" >>> can_sort_by_subarray_reversal(5, [3, 1, 2, 5, 4]) \\"NO\\" from solution import can_sort_by_subarray_reversal def test_sortable_by_single_reverse(): assert can_sort_by_subarray_reversal(4, [4, 3, 2, 1]) == \\"YES\\" def test_not_sortable_by_single_reverse(): assert can_sort_by_subarray_reversal(5, [3, 1, 2, 5, 4]) == \\"NO\\" def test_already_sorted(): assert can_sort_by_subarray_reversal(3, [1, 2, 3]) == \\"YES\\" def test_sortable_with_single_reverse_at_beginning(): assert can_sort_by_subarray_reversal(5, [3, 2, 1, 4, 5]) == \\"YES\\" def test_sortable_with_single_reverse_at_end(): assert can_sort_by_subarray_reversal(5, [1, 2, 5, 4, 3]) == \\"YES\\" def test_single_element(): assert can_sort_by_subarray_reversal(1, [1]) == \\"YES\\" def test_two_elements_sorted(): assert can_sort_by_subarray_reversal(2, [1, 2]) == \\"YES\\" def test_two_elements_unsorted(): assert can_sort_by_subarray_reversal(2, [2, 1]) == \\"YES\\" def test_non_sortable_mixed_up(): assert can_sort_by_subarray_reversal(6, [4, 3, 1, 6, 2, 5]) == \\"NO\\" def test_large_gap_not_sortable(): assert can_sort_by_subarray_reversal(6, [1, 6, 3, 4, 5, 2]) == \\"NO\\"","solution":"def can_sort_by_subarray_reversal(n, arr): Determines if it is possible to sort the array using the described operation (subarray reversal). Args: n : int : number of elements in the array arr : list of int : the array elements Returns: str : \\"YES\\" if the array can be sorted, otherwise \\"NO\\" sorted_arr = sorted(arr) # Create a copy of the original array to avoid modifying it directly temp_arr = arr.copy() # Try to find the first decreasing subarray start = -1 end = -1 for i in range(n - 1): if temp_arr[i] > temp_arr[i + 1]: start = i break if start == -1: # The array is already sorted return \\"YES\\" for j in range(start + 1, n): if temp_arr[j] < temp_arr[j - 1]: end = j else: break # Reverse the subarray from start to end temp_arr[start:end+1] = temp_arr[start:end+1][::-1] # After reversing, check if temp_arr is now sorted if temp_arr == sorted_arr: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def find_critical_connections(n: int, m: int, connections: List[Tuple[int, int]]) -> None: Given a network of \`n\` computers (nodes) and several connections (edges), find all the critical connections in the network. A critical connection is an edge that, if removed, would make two formerly connected parts of the network become disconnected. Parameters: n (int): the number of computers in the network. m (int): the number of connections in the network. connections (List[Tuple[int, int]]): a list of pairs representing the connections between computers. Prints: str: all critical connections (one per line) in the format \\"u v\\". If there are no critical connections, prints \\"No critical connections\\". Examples: >>> find_critical_connections(5, 5, [(1, 2), (1, 3), (3, 4), (3, 5), (4, 5)]) 1 2 1 3 >>> find_critical_connections(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 2 2 3 3 4 >>> find_critical_connections(6, 7, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (4, 5), (5, 6)]) 5 6 >>> find_critical_connections(3, 3, [(1, 2), (2, 3), (3, 1)]) No critical connections >>> find_critical_connections(2, 1, [(1, 2)]) 1 2","solution":"from collections import defaultdict def find_critical_connections(n, m, connections): def dfs(node, parent, discovery_time, low_time, visited, graph, bridges, time): visited[node] = True discovery_time[node] = low_time[node] = time time += 1 for neighbor in graph[node]: if neighbor == parent: continue if not visited[neighbor]: dfs(neighbor, node, discovery_time, low_time, visited, graph, bridges, time) low_time[node] = min(low_time[node], low_time[neighbor]) if low_time[neighbor] > discovery_time[node]: bridges.append((min(node, neighbor), max(node, neighbor))) else: low_time[node] = min(low_time[node], discovery_time[neighbor]) graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) discovery_time = [float('inf')] * (n + 1) low_time = [float('inf')] * (n + 1) visited = [False] * (n + 1) bridges = [] for i in range(1, n + 1): if not visited[i]: dfs(i, -1, discovery_time, low_time, visited, graph, bridges, 0) if len(bridges) == 0: print(\\"No critical connections\\") else: for u, v in sorted(bridges): print(u, v) # Example usage n = 5 m = 5 connections = [ (1, 2), (1, 3), (3, 4), (3, 5), (4, 5) ] find_critical_connections(n, m, connections)"},{"question":"def distribute_tasks(n, m, capacities, tasks): Determines if it's possible to distribute tasks among the servers without exceeding their capacities and provides one such distribution if possible. Args: n (int): Number of servers. m (int): Number of tasks. capacities (list of int): List of capacities of servers. tasks (list of int): List of tasks requirements. Returns: tuple: - str: \\"YES\\" if the distribution is possible, otherwise \\"NO\\". - list of int: List of server indices for each task if distribution is possible, otherwise empty list.","solution":"def distribute_tasks(n, m, capacities, tasks): Determines if it's possible to distribute tasks among the servers without exceeding their capacities and provides one such distribution if possible. Args: n (int): Number of servers. m (int): Number of tasks. capacities (list of int): List of capacities of servers. tasks (list of int): List of tasks requirements. Returns: tuple: - str: \\"YES\\" if the distribution is possible, otherwise \\"NO\\". - list of int: List of server indices for each task if distribution is possible, otherwise empty list. from heapq import heappush, heappop heap = [] for i, capacity in enumerate(capacities): heappush(heap, (capacity, i + 1)) task_assignment = [-1] * m for j, task in enumerate(tasks): temp_heap = [] assigned = False while heap: capacity, idx = heappop(heap) if capacity >= task: task_assignment[j] = idx heappush(heap, (capacity - task, idx)) assigned = True break else: temp_heap.append((capacity, idx)) # push back remaining items to heap while temp_heap: heappush(heap, temp_heap.pop()) if not assigned: return \\"NO\\", [] return \\"YES\\", task_assignment"},{"question":"def is_graph_connected(n, m, edges): Determine if the graph formed by islands and bridges is connected. Parameters: - n (int): The number of islands (nodes) - m (int): The number of bridges (edges) - edges (List[Tuple[int, int]]): List of edges where each edge is a tuple (ai, bi) Returns: - str: \\"CONNECTED\\" if there is a path between any pair of islands, otherwise \\"DISCONNECTED\\" Examples: >>> is_graph_connected(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"CONNECTED\\" >>> is_graph_connected(6, 5, [(1, 2), (1, 3), (3, 4), (2, 5), (4, 5)]) \\"DISCONNECTED\\" >>> is_graph_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) \\"CONNECTED\\" >>> is_graph_connected(5, 3, [(1, 2), (2, 3), (4, 5)]) \\"DISCONNECTED\\" >>> is_graph_connected(1, 0, []) \\"CONNECTED\\" >>> is_graph_connected(3, 0, []) \\"DISCONNECTED\\" >>> is_graph_connected(2, 1, [(1, 2)]) \\"CONNECTED\\" >>> is_graph_connected(4, 2, [(1, 2), (3, 4)]) \\"DISCONNECTED\\"","solution":"def is_graph_connected(n, m, edges): from collections import defaultdict, deque if n == 1: return \\"CONNECTED\\" if m == 0: return \\"DISCONNECTED\\" graph = defaultdict(list) for a, b in edges: graph[a].append(b) graph[b].append(a) visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) bfs(1) # Start BFS from the first node return \\"CONNECTED\\" if len(visited) == n else \\"DISCONNECTED\\" # Example usage: # n = 4 # m = 4 # edges = [(1, 2), (2, 3), (3, 4), (4, 1)] # print(is_graph_connected(n, m, edges)) # should print \\"CONNECTED\\""},{"question":"def recommend_users_to_follow(n: int, data: List[str]) -> List[str]: Recommend new users for each user to follow based on the users they already follow. >>> n = 4 >>> data = [ ... \\"1 2 2 3\\", ... \\"2 1 4\\", ... \\"3 1 4\\", ... \\"4 0\\" ... ] >>> recommend_users_to_follow(n, data) [\\"1 1 4\\", \\"2 0\\", \\"3 0\\", \\"4 0\\"] >>> n = 2 >>> data = [ ... \\"1 1 2\\", ... \\"2 1 1\\" ... ] >>> recommend_users_to_follow(n, data) [\\"1 0\\", \\"2 0\\"] >>> n = 3 >>> data = [ ... \\"1 2 2 3\\", ... \\"2 0\\", ... \\"3 0\\" ... ] >>> recommend_users_to_follow(n, data) [\\"1 0\\", \\"2 0\\", \\"3 0\\"] >>> n = 5 >>> data = [ ... \\"1 2 2 3\\", ... \\"2 2 4 5\\", ... \\"3 1 5\\", ... \\"4 0\\", ... \\"5 0\\" ... ] >>> recommend_users_to_follow(n, data) [\\"1 2 4 5\\", \\"2 0\\", \\"3 0\\", \\"4 0\\", \\"5 0\\"] >>> n = 3 >>> data = [ ... \\"1 1 2\\", ... \\"2 1 3\\", ... \\"3 1 1\\" ... ] >>> recommend_users_to_follow(n, data) [\\"1 1 3\\", \\"2 1 1\\", \\"3 1 2\\"]","solution":"def recommend_users_to_follow(n, data): from collections import defaultdict follow_map = defaultdict(set) users = [] for entry in data: parts = list(map(int, entry.split())) x_i = parts[0] k = parts[1] follows = parts[2:] follow_map[x_i].update(follows) users.append((x_i, follows)) recommendations = {} for user, follows in users: recommended = set() for followed_user in follows: for potential in follow_map[followed_user]: if potential != user and potential not in follow_map[user]: recommended.add(potential) recommendations[user] = sorted(recommended) output = [] for user in sorted(recommendations.keys()): rec = recommendations[user] output.append(f\\"{user} {len(rec)}\\" + (\\" \\" + \\" \\".join(map(str, rec)) if rec else \\"\\")) return output # Example input data n = 4 data = [ \\"1 2 2 3\\", \\"2 1 4\\", \\"3 1 4\\", \\"4 0\\" ] print(\\"n\\".join(recommend_users_to_follow(n, data)))"},{"question":"from typing import List def partition_numbers(nums: List[int]) -> List[List[int]]: Given a list of integers, partition the list into three categories: numbers less than 0, numbers equal to 0, and numbers greater than 0. The output should be a list of three lists: the first list contains all numbers less than 0, the second list contains all numbers equal to 0, and the third list contains all numbers greater than 0. >>> partition_numbers([3, -1, 0, -2, 4, 0, -5]) == [[-1, -2, -5], [0, 0], [3, 4]] >>> partition_numbers([1, 2, 3, 4]) == [[], [], [1, 2, 3, 4]] >>> partition_numbers([-1, -2, -3, -4]) == [[-1, -2, -3, -4], [], []] >>> partition_numbers([0, 0, 0]) == [[], [0, 0, 0], []] >>> partition_numbers([]) == [[], [], []]","solution":"from typing import List def partition_numbers(nums: List[int]) -> List[List[int]]: less_than_zero = [] equal_to_zero = [] greater_than_zero = [] for num in nums: if num < 0: less_than_zero.append(num) elif num == 0: equal_to_zero.append(num) else: greater_than_zero.append(num) return [less_than_zero, equal_to_zero, greater_than_zero]"},{"question":"from typing import List, Tuple def min_days_to_complete_tasks(n: int, m: int, dependencies: List[Tuple[int, int]]) -> int: Determine the minimal number of days required to complete a series of interdependent tasks. If it is impossible to complete all tasks due to a circular dependency, return -1. Args: n (int): Number of tasks. m (int): Number of dependencies. dependencies (List[Tuple[int, int]]): List of dependencies where each tuple (u, v) indicates task u must be completed before task v can start. Returns: int: The minimum number of days to complete all tasks or -1 if there is a circular dependency. Examples: >>> min_days_to_complete_tasks(5, 4, [(1, 2), (1, 3), (3, 4), (2, 4)]) 3 >>> min_days_to_complete_tasks(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 4)]) -1 def test_min_days_to_complete_tasks(): assert min_days_to_complete_tasks(5, 4, [(1, 2), (1, 3), (3, 4), (2, 4)]) == 3 assert min_days_to_complete_tasks(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 4)]) == -1 assert min_days_to_complete_tasks(1, 0, []) == 1 assert min_days_to_complete_tasks(4, 0, []) == 1 assert min_days_to_complete_tasks(4, 3, [(1, 2), (2, 3), (3, 4)]) == 4 assert min_days_to_complete_tasks(6, 5, [(1, 2), (1, 3), (2, 4), (3, 5), (4, 6), (5, 6)]) == 4","solution":"from collections import defaultdict, deque def min_days_to_complete_tasks(n, m, dependencies): Calculates the minimal number of days required to complete a series of interdependent tasks. Parameters: n (int): number of tasks. m (int): number of dependencies. dependencies (list of tuple): list containing m tuples indicating the dependencies. Returns: int: the minimum number of days to complete all tasks, or -1 if there's a circular dependency. # Create a graph with dependencies and a list to maintain in-degrees graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n + 1)} for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Initialize a queue with tasks having zero in-degree queue = deque([node for node in in_degree if in_degree[node] == 0]) days = 0 # Perform Kahn's algorithm for topological sorting while queue: days += 1 for _ in range(len(queue)): task = queue.popleft() for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If there are tasks with non-zero in-degree, we have a cycle if any(in_degree[node] > 0 for node in in_degree): return -1 return days"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 def lengths_of_longest_substrings(n: int, strings: List[str]) -> List[int]: Returns the lengths of the longest substrings without repetitive characters for each string. >>> lengths_of_longest_substrings(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> lengths_of_longest_substrings(2, [\\"abcdabc\\", \\"au\\"]) [4, 2]","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length def lengths_of_longest_substrings(n, strings): Returns the lengths of the longest substrings without repetitive characters for each string. results = [] for string in strings: results.append(length_of_longest_substring(string)) return results"},{"question":"def smallest_sum_of_two(numbers: List[int]) -> int: Finds the smallest possible sum of any two distinct numbers in the list. >>> smallest_sum_of_two([1, 3, 5, 7]) 4 >>> smallest_sum_of_two([-1, 2, 4, -3, 10]) -4 >>> smallest_sum_of_two([1000000000, -1000000000, 500000000, -500000000]) -1500000000","solution":"def smallest_sum_of_two(numbers): Finds the smallest possible sum of any two distinct numbers in the list. The function assumes that the input list contains at least two elements. # Sort the list to get the smallest numbers numbers.sort() # The smallest sum of any two distinct numbers will be the sum # of the two smallest numbers in the sorted list return numbers[0] + numbers[1]"},{"question":"def relay_race_positions(t: int, test_cases: List[Dict[str, Any]]) -> List[List[Tuple[int, int]]]: Determine the starting and ending positions of the baton for each participant in a relay race around a circular track with multiple test cases. >>> relay_race_positions(1, [{'circumference': 10, 'distances': [3, 4, 5, 3]}]) [[(0, 3), (3, 7), (7, 2), (2, 5)]] >>> relay_race_positions(1, [{'circumference': 12, 'distances': [4, 3, 7, 6, 8]}]) [[(0, 4), (4, 7), (7, 2), (2, 8), (8, 4)]] >>> relay_race_positions(1, [{'circumference': 1000000000, 'distances': [1000, 2000, 3000, 4000]}]) [[(0, 1000), (1000, 3000), (3000, 6000), (6000, 10000)]] >>> relay_race_positions(1, [{'circumference': 10, 'distances': [11, 22, 33, 44]}]) [[(0, 1), (1, 3), (3, 6), (6, 0)]]","solution":"def relay_race_positions(t, test_cases): results = [] for case in test_cases: C = case['circumference'] distances = case['distances'] n = len(distances) positions = [] current_position = 0 for distance in distances: start_position = current_position end_position = (start_position + distance) % C positions.append((start_position, end_position)) current_position = end_position results.append(positions) return results"},{"question":"from typing import List, Dict def analyze_participant_levels(M: int, levels: List[int]) -> Dict[int, int]: Analyzes the number of participants who solved problems at different difficulty levels. Args: M (int): Total number of participants. levels (List[int]): List of integers representing the difficulty levels of problems solved by participants. Returns: Dict[int, int]: A dictionary with keys as levels (0 to 5) and values as counts of participants who solved problems of that level. >>> analyze_participant_levels(8, [1, 4, 0, 2, 2, 5, 1, 0]) {0: 2, 1: 2, 2: 2, 3: 0, 4: 1, 5: 1} >>> analyze_participant_levels(5, [5, 3, 0, 0, 1]) {0: 2, 1: 1, 2: 0, 3: 1, 4: 0, 5: 1} pass def format_output(counts: Dict[int, int]) -> str: Formats the output for the analysis of participant levels. Args: counts (Dict[int, int]): Dictionary with keys as levels (0 to 5) and values as counts of participants. Returns: str: A formatted string representing the number of participants at each difficulty level. >>> format_output({0: 2, 1: 2, 2: 2, 3: 0, 4: 1, 5: 1}) 'Level 0: 2 participantsnLevel 1: 2 participantsnLevel 2: 2 participantsnLevel 3: 0 participantsnLevel 4: 1 participantnLevel 5: 1 participant' >>> format_output({0: 2, 1: 1, 2: 0, 3: 1, 4: 0, 5: 1}) 'Level 0: 2 participantsnLevel 1: 1 participantnLevel 2: 0 participantsnLevel 3: 1 participantnLevel 4: 0 participantsnLevel 5: 1 participant' pass # Example Tests # You can run these tests to validate your solution def test_analyze_participant_levels(): assert analyze_participant_levels(8, [1, 4, 0, 2, 2, 5, 1, 0]) == {0: 2, 1: 2, 2: 2, 3: 0, 4: 1, 5: 1} assert analyze_participant_levels(5, [5, 3, 0, 0, 1]) == {0: 2, 1: 1, 2: 0, 3: 1, 4: 0, 5: 1} assert analyze_participant_levels(3, [1, 1, 1]) == {0: 0, 1: 3, 2: 0, 3: 0, 4: 0, 5: 0} assert analyze_participant_levels(4, [0, 0, 0, 0]) == {0: 4, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0} assert analyze_participant_levels(6, [1, 2, 3, 4, 5, 0]) == {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1} def test_format_output(): counts = {0: 2, 1: 2, 2: 2, 3: 0, 4: 1, 5: 1} expected_output = \\"Level 0: 2 participantsnLevel 1: 2 participantsnLevel 2: 2 participantsnLevel 3: 0 participantsnLevel 4: 1 participantnLevel 5: 1 participant\\" assert format_output(counts) == expected_output counts = {0: 2, 1: 1, 2: 0, 3: 1, 4: 0, 5: 1} expected_output = \\"Level 0: 2 participantsnLevel 1: 1 participantnLevel 2: 0 participantsnLevel 3: 1 participantnLevel 4: 0 participantsnLevel 5: 1 participant\\" assert format_output(counts) == expected_output counts = {0: 0, 1: 3, 2: 0, 3: 0, 4: 0, 5: 0} expected_output = \\"Level 0: 0 participantsnLevel 1: 3 participantsnLevel 2: 0 participantsnLevel 3: 0 participantsnLevel 4: 0 participantsnLevel 5: 0 participants\\" assert format_output(counts) == expected_output counts = {0: 4, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0} expected_output = \\"Level 0: 4 participantsnLevel 1: 0 participantsnLevel 2: 0 participantsnLevel 3: 0 participantsnLevel 4: 0 participantsnLevel 5: 0 participants\\" assert format_output(counts) == expected_output counts = {0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1} expected_output = \\"Level 0: 1 participantnLevel 1: 1 participantnLevel 2: 1 participantnLevel 3: 1 participantnLevel 4: 1 participantnLevel 5: 1 participant\\" assert format_output(counts) == expected_output","solution":"def analyze_participant_levels(M, levels): Analyzes the number of participants who solved problems at different difficulty levels. Args: M (int): Total number of participants. levels (list): List of integers representing the difficulty levels of problems solved by participants. Returns: dict: A dictionary with keys as levels (0 to 5) and values as counts of participants who solved problems of that level. counts = {i: 0 for i in range(6)} for level in levels: counts[level] += 1 return counts def format_output(counts): Formats the output for the analysis of participant levels. Args: counts (dict): Dictionary with keys as levels (0 to 5) and values as counts of participants. Returns: str: A formatted string representing the number of participants at each difficulty level. output = [] for i in range(6): if counts[i] == 1: output.append(f\\"Level {i}: {counts[i]} participant\\") else: output.append(f\\"Level {i}: {counts[i]} participants\\") return \\"n\\".join(output)"},{"question":"from typing import List def longest_unique_path(N: int, M: int, grid: List[str]) -> int: You are given a grid with \`N\` rows and \`M\` columns. Each cell in the grid contains a single lowercase letter. The task is to find the length of the longest path such that each cell in the path contains a unique letter. A path can move to any of its 4 adjacent cells (up, down, left, right). >>> longest_unique_path(3, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 12 >>> longest_unique_path(1, 1, [\\"a\\"]) 1 >>> longest_unique_path(2, 2, [\\"ab\\", \\"cd\\"]) 4 >>> longest_unique_path(3, 3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 1 >>> longest_unique_path(4, 5, [\\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\"]) 20 def test_longest_unique_path_example_1(): N, M, grid = 3, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"] assert longest_unique_path(N, M, grid) == 12 def test_longest_unique_path_single_cell(): N, M, grid = 1, 1, [\\"a\\"] assert longest_unique_path(N, M, grid) == 1 def test_longest_unique_path_two_by_two(): N, M, grid = 2, 2, [\\"ab\\", \\"cd\\"] assert longest_unique_path(N, M, grid) == 4 def test_longest_unique_path_all_same(): N, M, grid = 3, 3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"] assert longest_unique_path(N, M, grid) == 1 def test_longest_unique_path_large_grid(): N, M, grid = 4, 5, [\\"abcde\\", \\"fghij\\", \\"klmno\\", \\"pqrst\\"] assert longest_unique_path(N, M, grid) == 20","solution":"def longest_unique_path(N, M, grid): def dfs(x, y, visited): nonlocal max_length max_length = max(max_length, len(visited)) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right for d in directions: nx, ny = x + d[0], y + d[1] if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] not in visited: visited.add(grid[nx][ny]) dfs(nx, ny, visited) visited.remove(grid[nx][ny]) max_length = 0 for i in range(N): for j in range(M): dfs(i, j, set(grid[i][j])) return max_length # Reading from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = data[2:] print(longest_unique_path(N, M, grid))"},{"question":"from typing import List, Tuple def solve_hiker_problem(N: int, M: int, heights: List[List[int]], W: int, water_coordinates: List[Tuple[int, int]]) -> int: Determine the minimum number of steps the hiker needs to take to reach the bottom-right corner of the grid, or determine if it is impossible for the hiker to reach his destination. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. heights (List[List[int]]): The heights of the grid cells. W (int): Number of water cells. water_coordinates (List[Tuple[int, int]]): List of (row, col) indices of water cells. Returns: int: Minimum number of steps required to reach the bottom-right or \\"IMPOSSIBLE\\" if it's not feasible. >>> solve_hiker_problem(5, 5, [[1, 2, 3, 4, 5], [2, 2, 3, 4, 5], [1, 1, 1, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4]], 3, [(1, 3), (2, 2), (4, 0)]) 8 >>> solve_hiker_problem(3, 3, [[1, 2, 3], [2, 2, 2], [3, 3, 3]], 0, []) 4 >>> solve_hiker_problem(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1, [(1, 1)]) \\"IMPOSSIBLE\\" >>> solve_hiker_problem(1, 1, [[0]], 0, []) 0","solution":"from collections import deque def min_steps_to_reach_end(N, M, grid, water_cells): # Create the visited grid and set water cells as visited visited = [[False] * M for _ in range(N)] for r, c in water_cells: visited[r][c] = True # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, steps) visited[0][0] = True while queue: x, y, steps = queue.popleft() # If we reached the bottom-right corner, return the steps count if x == N-1 and y == M-1: return steps # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny]: if grid[nx][ny] <= grid[x][y] + 1: visited[nx][ny] = True queue.append((nx, ny, steps + 1)) # If we exhaust the queue and do not reach the end, return \\"IMPOSSIBLE\\" return \\"IMPOSSIBLE\\" # Function to parse input and get the result def solve_hiker_problem(N, M, heights, W, water_coordinates): return min_steps_to_reach_end(N, M, heights, water_coordinates)"},{"question":"from typing import List def find_odd_occurrence(arr: List[int]) -> int: Returns the integer that occurs an odd number of times in the given array. >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) 3 >>> find_odd_occurrence([4, 4, 4, 5, 5]) 4 >>> find_odd_occurrence([10]) 10 >>> find_odd_occurrence([999999999, 888888888, 999999999, 888888888, 999999999]) 999999999 >>> find_odd_occurrence([-1, -1, -2, -2, -2]) -2 >>> find_odd_occurrence([-10, 10, -10, 10, -10]) -10","solution":"from typing import List def find_odd_occurrence(arr: List[int]) -> int: Returns the integer that occurs an odd number of times in the given array. result = 0 for number in arr: result ^= number return result"},{"question":"def find_min_difference(items: List[int]) -> int: You are given a list of integers where each integer represents the number of times a specific type of item appears in a warehouse. You need to redistribute these items into two sets such that the maximum difference between the sums of the two sets is minimized. Args: items (List[int]): A list of integers where each integer represents the count of a specific item type. Returns: int: The minimum possible absolute difference between the sums of the two sets. >>> find_min_difference([1, 6, 11, 5]) 1 >>> find_min_difference([3, 1, 4]) 0 >>> find_min_difference([8]) 8 pass","solution":"def find_min_difference(items): from itertools import combinations total_sum = sum(items) n = len(items) min_diff = float('inf') # Using combinations to find all subsets for i in range(n + 1): for subset in combinations(items, i): subset_sum = sum(subset) other_sum = total_sum - subset_sum min_diff = min(min_diff, abs(subset_sum - other_sum)) return min_diff"},{"question":"def max_gates_in_use(n: int, airplanes: List[Tuple[int, int, int]]) -> int: Determine the maximum number of gates in use simultaneously. Args: n (int): The number of airplanes. airplanes (List[Tuple[int, int, int]]): A list of tuples, each representing an airplane by its arrival time, departure time, and gate number. Returns: int: The maximum number of gates in use simultaneously. Examples: >>> max_gates_in_use(5, [(1, 4, 1), (2, 5, 2), (3, 6, 1), (5, 8, 3), (7, 10, 2)]) 3 >>> max_gates_in_use(3, [(10, 12, 1), (12, 14, 1), (13, 15, 1)]) 2 from typing import List, Tuple def test_example_1(): airplanes = [(1, 4, 1), (2, 5, 2), (3, 6, 1), (5, 8, 3), (7, 10, 2)] assert max_gates_in_use(5, airplanes) == 3 def test_example_2(): airplanes = [(10, 12, 1), (12, 14, 1), (13, 15, 1)] assert max_gates_in_use(3, airplanes) == 2 def test_single_airplane(): airplanes = [(1, 5, 1)] assert max_gates_in_use(1, airplanes) == 1 def test_multiple_planes_same_gate(): airplanes = [(1, 5, 1), (2, 6, 1), (3, 7, 1)] assert max_gates_in_use(3, airplanes) == 3 def test_planes_non_overlapping(): airplanes = [(1, 2, 1), (3, 4, 2), (5, 6, 3)] assert max_gates_in_use(3, airplanes) == 1 def test_planes_different_gates(): airplanes = [(1, 3, 1), (2, 4, 2), (3, 5, 3)] assert max_gates_in_use(3, airplanes) == 3 def test_planes_fully_overlapping(): airplanes = [(1, 5, 1), (1, 5, 2), (1, 5, 3), (1, 5, 4)] assert max_gates_in_use(4, airplanes) == 4","solution":"def max_gates_in_use(n, airplanes): events = [] for airplane in airplanes: a, d, g = airplane events.append((a, 1)) # Gate g usage started events.append((d + 1, -1)) # Gate g usage ended the next minute after departure events.sort() # Sort events by time max_gates = 0 current_gates = 0 for event in events: time, delta = event current_gates += delta max_gates = max(max_gates, current_gates) return max_gates"},{"question":"def has_duplicate_students(n, students): Given the number of students and a list of student names (first name and last name), this function returns 'YES' if there are duplicate student names and 'NO' otherwise. >>> has_duplicate_students(5, [\\"john doe\\", \\"jane smith\\", \\"john doe\\", \\"alex doe\\", \\"alex smith\\"]) 'YES' >>> has_duplicate_students(5, [\\"john doe\\", \\"jane smith\\", \\"john snow\\", \\"alex doe\\", \\"alex smith\\"]) 'NO' >>> has_duplicate_students(1, [\\"john doe\\"]) 'NO' >>> has_duplicate_students(5, [\\"john doe\\", \\"john doe\\", \\"john doe\\", \\"john doe\\", \\"john doe\\"]) 'YES' >>> has_duplicate_students(10000, [f\\"student{i} lastname\\" for i in range(10000)]) 'NO' >>> has_duplicate_students(10000, [f\\"student{i} lastname\\" for i in range(9999)] + [\\"student1 lastname\\"]) 'YES'","solution":"def has_duplicate_students(n, students): Given the number of students and a list of student names (first name and last name), this function returns 'YES' if there are duplicate student names and 'NO' otherwise. student_set = set() for student in students: if student in student_set: return \\"YES\\" student_set.add(student) return \\"NO\\""},{"question":"def num_of_paths(m: int, n: int, grid: List[List[int]]) -> int: Calculate the number of distinct paths from the top-left corner to the bottom-right corner of the grid. The car cannot drive through any blocked cells (1s) and can only move to the right or down. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[List[int]]): The grid represented as a list of lists, where 0s are free cells and 1s are blocked cells. Returns: int: Number of distinct paths from the top-left to the bottom-right corner. Returns 0 if no path is possible. >>> num_of_paths(3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> num_of_paths(3, 3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) 1 >>> num_of_paths(3, 3, [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ]) 0 def solve(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Calculate the number of distinct paths for each test case. Args: test_cases (List[Tuple[int, int, List[List[int]]]]): List of test cases where each test case is a tuple containing: - m (int): Number of rows in the grid. - n (int): Number of columns in the grid. - grid (List[List[int]]): The grid. Returns: List[int]: List of integers where each integer is the number of distinct paths for the corresponding test case. >>> solve([ (3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]), (3, 3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]), (3, 3, [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ]) ]) [2, 1, 0] from solution import solve def test_solve(): test_cases = [ (3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]), (3, 3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]), (3, 3, [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ]) ] expected_results = [2, 1, 0] assert solve(test_cases) == expected_results def test_no_path_due_to_block(): test_cases = [ (2, 2, [ [0, 0], [1, 0] ]), (2, 2, [ [0, 1], [0, 0] ]) ] expected_results = [1, 1] assert solve(test_cases) == expected_results def test_start_end_blocked(): test_cases = [ (2, 2, [ [1, 0], [0, 0] ]), (2, 2, [ [0, 0], [0, 1] ]), (1, 1, [ [1] ]) ] expected_results = [0, 0, 0] assert solve(test_cases) == expected_results def test_minimal_grid(): test_cases = [ (1, 1, [ [0] ]), (1, 2, [ [0, 0] ]), (2, 1, [ [0], [0] ]) ] expected_results = [1, 1, 1] assert solve(test_cases) == expected_results def test_large_grid(): test_cases = [ (3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) ] expected_results = [6] assert solve(test_cases) == expected_results","solution":"def num_of_paths(m, n, grid): if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] def solve(test_cases): results = [] for m, n, grid in test_cases: results.append(num_of_paths(m, n, grid)) return results"},{"question":"from typing import List, Tuple def find_camera_placements(n: int, vertices: List[Tuple[int, int]]) -> List[Tuple[int]]: Find all sets of camera placements where each side of the polygon is monitored. Args: n : int : the number of vertices vertices : list of tuple : each tuple represents the (x, y) coordinates of a vertex Returns: list of list of int : each sublist is a set of vertices indices where cameras should be placed >>> find_camera_placements(4, [(0, 0), (0, 1), (1, 1), (1, 0)]) [(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)] >>> find_camera_placements(5, [(0, 0), (0, 1), (1, 2), (2, 1), (1, 0)]) [(1, 2, 3, 4), (1, 2, 3, 5), (1, 2, 4, 5), (1, 3, 4, 5), (2, 3, 4, 5)]","solution":"from itertools import combinations def find_camera_placements(n, vertices): Find all sets of camera placements where each side of the polygon is monitored. Args: n : int : the number of vertices vertices : list of tuple : each tuple represents the (x, y) coordinates of a vertex Returns: list of list of int : each sublist is a set of vertices indices where cameras should be placed placements = [] # Get all combinations of n-1 vertices for combination in combinations(range(1, n+1), n-1): placements.append(combination) # Sort placements lexicographically placements.sort() return placements"},{"question":"def longest_palindromic_subseq_sum(s: str) -> int: Calculate the sum of ASCII values of all characters in the longest palindromic subsequence of a given string. >>> longest_palindromic_subseq_sum(\\"bbbab\\") 392 >>> longest_palindromic_subseq_sum(\\"cbbd\\") 196 def palindromic_subsequence_sum(T: int, lst: List[str]) -> List[int]: For each test case, return the sum of the ASCII values of all characters in its longest palindromic subsequence. >>> palindromic_subsequence_sum(2, [\\"bbbab\\", \\"cbbd\\"]) [392, 196] from solution import palindromic_subsequence_sum def test_single_character(): assert palindromic_subsequence_sum(1, ['a']) == [ord('a')] assert palindromic_subsequence_sum(1, ['z']) == [ord('z')] def test_two_characters(): assert palindromic_subsequence_sum(1, ['aa']) == [2 * ord('a')] assert palindromic_subsequence_sum(1, ['ab']) == [max(ord('a'), ord('b'))] def test_palindrome_string(): assert palindromic_subsequence_sum(1, ['racecar']) == [ord('r') * 2 + ord('a') * 2 + ord('c') * 2 + ord('e')] def test_non_palindrome_string(): assert palindromic_subsequence_sum(1, ['abcde']) == [max(ord(c) for c in 'abcde')] def test_sample_cases(): assert palindromic_subsequence_sum(2, ['bbbab', 'cbbd']) == [392, 196] def test_multiple_same_length_palindromes(): assert palindromic_subsequence_sum(1, ['agbdba']) == [ord('a') * 2 + ord('b') * 2 + ord('d')]","solution":"def longest_palindromic_subseq_sum(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = ord(s[i]) for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 * ord(s[i]) else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def palindromic_subsequence_sum(T, lst): results = [] for s in lst: results.append(longest_palindromic_subseq_sum(s)) return results"},{"question":"def max_subarray_sum(arr: List[int], k: int) -> int: Finds the maximum possible sum of a subarray of length k. Parameters: arr (List[int]): List of integers representing the input array. k (int): Length of the subarray. Returns: int: The maximum possible sum of a subarray of length k. Example: >>> max_subarray_sum([2, 1, 5, 1, 3, 2, -1], 3) 9 >>> max_subarray_sum([1, 2, 3, 4, 5, 6, 7], 3) 18 >>> max_subarray_sum([-1, -2, -3, -4, -5], 2) -3 >>> max_subarray_sum([1], 1) 1 >>> max_subarray_sum([3, -1, 2, 5, -1, 2], 2) 7 >>> max_subarray_sum([0, 0, 0, 0, 0], 3) 0 >>> max_subarray_sum([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_subarray_sum([100, 200, 300, 400], 2) 700 >>> max_subarray_sum([3, 3, 9, 9, 9, 9, 9, 5, 5, 1], 5) 45","solution":"from typing import List def max_subarray_sum(arr: List[int], k: int) -> int: Finds the maximum possible sum of a subarray of length k. Parameters: arr (List[int]): List of integers representing the input array. k (int): Length of the subarray. Returns: int: The maximum possible sum of a subarray of length k. # Initialize window sum to be the sum of the first k elements window_sum = sum(arr[:k]) max_sum = window_sum # Slide the window over the array for i in range(len(arr) - k): window_sum = window_sum - arr[i] + arr[i + k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"from typing import List, Tuple def max_shops_and_spending(n: int, b: int, prices: List[int]) -> Tuple[int, int]: Given a series of shops with prices and a budget, find the maximum number of shops that can be visited and the maximum amount spent without exceeding the budget. Args: n (int): The number of shops. b (int): The budget. prices (List[int]): The price of the product in each shop. Returns: Tuple[int, int]: The maximum number of shops that can be visited and the maximum total amount of money spent. Examples: >>> max_shops_and_spending(5, 50, [20, 10, 30, 50, 40]) (2, 30) >>> max_shops_and_spending(3, 100, [60, 70, 80]) (1, 60) pass # Unit tests def test_example_1(): assert max_shops_and_spending(5, 50, [20, 10, 30, 50, 40]) == (2, 30) def test_example_2(): assert max_shops_and_spending(3, 100, [60, 70, 80]) == (1, 60) def test_all_shops_visited(): assert max_shops_and_spending(4, 10, [1, 2, 2, 5]) == (4, 10) def test_no_shops_visited(): assert max_shops_and_spending(3, 1, [10, 20, 30]) == (0, 0) def test_large_budget(): assert max_shops_and_spending(3, 1000, [200, 300, 100]) == (3, 600) def test_large_input(): prices = [1] * 10**5 assert max_shops_and_spending(10**5, 10**5, prices) == (100000, 100000)","solution":"def max_shops_and_spending(n, b, prices): prices.sort() visited_shops = 0 total_spent = 0 for price in prices: if total_spent + price <= b: total_spent += price visited_shops += 1 else: break return visited_shops, total_spent"},{"question":"def find_max_product_indices(arr): Given a list of integers, find the pair of indices (i, j) such that: - i < j - The product of the integers at these indices is maximal - If there are multiple pairs with the same maximal product, return the pair with the smallest i - If there are still multiple results, return the pair with the smallest j Parameters: arr (list of int): List of integers Returns: tuple of int: Indices i and j (0-based) # Your implementation here if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) i, j = find_max_product_indices(arr) print(i, j) def test_example1(): assert find_max_product_indices([1, 2, 3, 4, 5]) == (3, 4) def test_example2(): assert find_max_product_indices([-10, -20, 1]) == (0, 1) def test_all_positive(): assert find_max_product_indices([1, 2, 3, 4, 5, 6]) == (4, 5) def test_all_negative(): assert find_max_product_indices([-1, -2, -3, -4, -5]) == (3, 4) def test_mixed_sign(): assert find_max_product_indices([-10, 20, -30, 40]) == (1, 3) def test_zeros_in_list(): assert find_max_product_indices([0, -1, -2, 0]) == (1, 2) def test_large_list(): large_list = [i for i in range(1, 1001)] assert find_max_product_indices(large_list) == (998, 999)","solution":"def find_max_product_indices(arr): Given a list of integers, find the pair of indices (i, j) such that: - i < j - The product of the integers at these indices is maximal - If there are multiple pairs with the same maximal product, return the pair with the smallest i - If there are still multiple results, return the pair with the smallest j Parameters: arr (list of int): List of integers Returns: tuple of int: Indices i and j (0-based) max_product = float('-inf') max_i = max_j = None for i in range(len(arr)): for j in range(i + 1, len(arr)): product = arr[i] * arr[j] if (product > max_product) or (product == max_product and (i < max_i or (i == max_i and j < max_j))): max_product = product max_i, max_j = i, j return max_i, max_j if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) i, j = find_max_product_indices(arr) print(i, j)"},{"question":"def is_solvable(T: int, tests: List[Tuple[int, int, List[str]]]) -> List[str]: Write a program that determines if a given maze is solvable. The maze is represented by a grid of characters, where an 'S' denotes the starting point, an 'E' denotes the ending point, '.' denotes an open path, and '#' denotes a wall. You may move up, down, left, or right, but you cannot move diagonally. Your task is to determine whether there is a path from 'S' to 'E'. Parameters: T (int): The number of test cases. tests (List[Tuple[int, int, List[str]]]): A list of test cases, each represented by a tuple containing dimensions of the maze grid and the maze grid itself. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case indicating whether there is a path from 'S' to 'E'. Example: >>> is_solvable(2, [(5, 5, [\\"S....\\", \\".#.\\", \\".#..E\\", \\".#.\\", \\".....\\"]), (3, 3, [\\"S#E\\", \\"#\\", \\"#.#\\"])]) [\\"YES\\", \\"NO\\"] pass","solution":"def is_solvable(T, tests): def dfs(x, y, visited): if not (0 <= x < N and 0 <= y < M) or (x, y) in visited or grid[x][y] == '#': return False if grid[x][y] == 'E': return True visited.add((x, y)) return ( dfs(x + 1, y, visited) or dfs(x - 1, y, visited) or dfs(x, y + 1, visited) or dfs(x, y - 1, visited) ) results = [] for test in tests: N, M, grid_data = test grid = [list(line) for line in grid_data] start = end = None for i in range(N): for j in range(M): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) if not start or not end: results.append(\\"NO\\") continue visited = set() result = dfs(start[0], start[1], visited) results.append(\\"YES\\" if result else \\"NO\\") return results T = 2 tests = [ (5, 5, [ \\"S....\\", \\".#.\\", \\".#..E\\", \\".#.\\", \\".....\\" ]), (3, 3, [ \\"S#E\\", \\"#\\", \\"#.#\\" ]) ] print(is_solvable(T, tests))"},{"question":"def min_parentheses_to_add(T: int, cases: List[str]) -> List[int]: Return the minimum number of parentheses to add to make each given string valid. Args: T (int): The number of test cases. cases (List[str]): List of strings containing parentheses. Returns: List[int]: List of integers with the minimum number of parentheses to add for each case. >>> min_parentheses_to_add(2, [\\")(\\", \\"(((\\"]) [2, 3] >>> min_parentheses_to_add(2, [\\"())\\", \\"((\\"]) [1, 2] >>> min_parentheses_to_add(3, [\\"\\", \\"()\\", \\"(())\\"]) [0, 0, 0] pass","solution":"def min_parentheses_to_add(T, cases): Return the minimum number of parentheses to add to make each given string valid. T : int : the number of test cases cases : list : list of strings containing parentheses returns : list : list of integers with the minimum number of parentheses to add for each case results = [] for S in cases: balance = 0 additions = 0 for char in S: if char == '(': balance += 1 else: balance -= 1 # If balance is negative, we need an extra '(' if balance < 0: additions += 1 balance = 0 # balance now tells us how many more ')' we need results.append(additions + balance) return results"},{"question":"def product_except_self(arr): Given an array arr, return an array result where result[i] is equal to the product of all the elements of arr except arr[i]. The solution should be in O(n) time complexity and not use division. pass def solve(test_cases): Given multiple test cases with arrays, return the results for each test case using the product_except_self function. pass def test_product_except_self(): assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([3, 2, 1]) == [2, 3, 6] assert product_except_self([0, 4, 5]) == [20, 0, 0] assert product_except_self([2, 2, 2, 2]) == [8, 8, 8, 8] assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] def test_solve(): input_cases = [ [1, 2, 3, 4], [3, 2, 1] ] expected_output = [[24, 12, 8, 6], [2, 3, 6]] assert solve(input_cases) == expected_output","solution":"def product_except_self(arr): Given an array arr, return an array result where result[i] is equal to the product of all the elements of arr except arr[i]. The solution should be in O(n) time complexity and not use division. n = len(arr) if n == 0: return [] result = [1] * n # Calculate products of elements to the left of each element left_product = 1 for i in range(n): result[i] = left_product left_product *= arr[i] # Calculate products of elements to the right of each element right_product = 1 for i in range(n-1, -1, -1): result[i] *= right_product right_product *= arr[i] return result def solve(test_cases): results = [] for arr in test_cases: results.append(product_except_self(arr)) return results"},{"question":"def is_traversable_with_even_sum(M: int, N: int, grid: List[List[int]]) -> str: Determines if there is a path from the top left to bottom right of the grid with only right and down moves such that the sum of the values along the path is even. Parameters: M (int): Number of rows. N (int): Number of columns. grid (list of list of int): 2D list representing the grid's cell values. Returns: str: \\"possible\\" if such a path exists, \\"impossible\\" otherwise. Examples: >>> is_traversable_with_even_sum(3, 3, [[1, 2, 1], [1, 2, 1], [1, 1, 2]]) 'possible' >>> is_traversable_with_even_sum(2, 2, [[1, 1], [1, 1]]) 'impossible'","solution":"def is_traversable_with_even_sum(M, N, grid): Determines if there is a path from the top left to bottom right of the grid with only right and down moves such that the sum of the values along the path is even. Parameters: M (int): Number of rows. N (int): Number of columns. grid (list of list of int): 2D list representing the grid's cell values. Returns: str: \\"possible\\" if such a path exists, \\"impossible\\" otherwise. from collections import deque # Direction vectors for moving right and down direction = [(0, 1), (1, 0)] # Queue to hold the current position and accumulated sum q = deque([(0, 0, grid[0][0])]) # Set to keep track of visited positions and their corresponding even/odd sums visited = set() visited.add((0, 0, grid[0][0] % 2)) while q: x, y, curr_sum = q.popleft() # Check if we've reached the bottom right corner if x == M - 1 and y == N - 1: if curr_sum % 2 == 0: return \\"possible\\" # Explore the possible moves (right and down) for dx, dy in direction: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N: new_sum = curr_sum + grid[nx][ny] if (nx, ny, new_sum % 2) not in visited: visited.add((nx, ny, new_sum % 2)) q.append((nx, ny, new_sum)) return \\"impossible\\" # Read input def process_input(): import sys input = sys.stdin.read data = input().strip().split() M = int(data[0]) N = int(data[1]) grid = [] index = 2 for i in range(M): row = list(map(int, data[index:index + N])) grid.append(row) index += N return M, N, grid # Main Execution if __name__ == \\"__main__\\": M, N, grid = process_input() print(is_traversable_with_even_sum(M, N, grid))"},{"question":"def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindrome that can be formed by reordering the characters in the given string. >>> longest_palindrome_length('abccccdd') 7 >>> longest_palindrome_length('a') 1 >>> longest_palindrome_length('ab') 1 >>> longest_palindrome_length('aabb') 4 >>> longest_palindrome_length('aabbc') 5 >>> longest_palindrome_length('racecar') 7 >>> longest_palindrome_length('') 0 >>> longest_palindrome_length('abcdef') 1","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be formed with the characters in the string s. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def process_operations(num_cases: int, cases: List[Tuple[int, List[int]]]) -> List[Tuple[List[int], List[List[int]]]]: Process the operations to remove the largest numbers and collect them in lists. >>> process_operations(1, [(5, [1, 2, 3, 2, 1])]) [([], [ [3], [2, 2], [1, 1] ])] >>> process_operations(1, [(6, [4, 5, 6, 6, 5, 4])]) [([], [ [6, 6], [5, 5], [4, 4] ])]","solution":"def process_operations(num_cases, cases): results = [] for i in range(num_cases): n, array = cases[i] removed_collections = [] while array: max_num = max(array) max_count = array.count(max_num) removed_collections.append([max_num] * max_count) array = [num for num in array if num != max_num] results.append((array, removed_collections)) return results"},{"question":"def calculate_final_scores(n: int, m: int, attempts: List[Tuple[int, int, str]]) -> List[int]: This function calculates the final scores of teams based on their problem-solving attempts. Parameters: n (int): number of teams m (int): number of attempts attempts (list): list of attempts where each attempt is a tuple of (team_id, problem_difficulty, result) Returns: list: final scores of the teams # Initialize scores for each team scores = [0] * n for attempt in attempts: team_id, problem_difficulty, result = attempt if result == \\"correct\\": scores[team_id - 1] += problem_difficulty elif result == \\"incorrect\\": scores[team_id - 1] = max(0, scores[team_id - 1] - problem_difficulty // 2) return scores # Here are some test cases to check the correctness of the function def test_calculate_final_scores_example(): n = 3 m = 6 attempts = [ (1, 20, \\"correct\\"), (2, 50, \\"incorrect\\"), (3, 40, \\"correct\\"), (1, 10, \\"incorrect\\"), (2, 30, \\"correct\\"), (3, 20, \\"incorrect\\") ] assert calculate_final_scores(n, m, attempts) == [15, 30, 30] def test_all_correct_attempts(): n = 2 m = 4 attempts = [ (1, 10, \\"correct\\"), (1, 20, \\"correct\\"), (2, 30, \\"correct\\"), (2, 40, \\"correct\\") ] assert calculate_final_scores(n, m, attempts) == [30, 70] def test_all_incorrect_attempts(): n = 2 m = 4 attempts = [ (1, 10, \\"incorrect\\"), (1, 20, \\"incorrect\\"), (2, 30, \\"incorrect\\"), (2, 40, \\"incorrect\\") ] assert calculate_final_scores(n, m, attempts) == [0, 0] def test_mixed_attempts(): n = 2 m = 6 attempts = [ (1, 30, \\"correct\\"), (1, 20, \\"incorrect\\"), (2, 50, \\"correct\\"), (2, 100, \\"incorrect\\"), (1, 40, \\"correct\\"), (1, 10, \\"incorrect\\") ] assert calculate_final_scores(n, m, attempts) == [55, 0] def test_no_attempts(): n = 3 m = 0 attempts = [] assert calculate_final_scores(n, m, attempts) == [0, 0, 0]","solution":"def calculate_final_scores(n, m, attempts): This function calculates the final scores of teams based on their problem-solving attempts. Parameters: n (int): number of teams m (int): number of attempts attempts (list): list of attempts where each attempt is a tuple of (team_id, problem_difficulty, result) Returns: list: final scores of the teams # Initialize scores for each team scores = [0] * n for attempt in attempts: team_id, problem_difficulty, result = attempt if result == \\"correct\\": scores[team_id - 1] += problem_difficulty elif result == \\"incorrect\\": scores[team_id - 1] = max(0, scores[team_id - 1] - problem_difficulty // 2) return scores"},{"question":"def min_watchmen(m: int, n: int, grid: List[str]) -> int: Determines the minimum number of watchmen needed to monitor all buildings ('B') in the grid. Args: - m (int): number of rows in the grid. - n (int): number of columns in the grid. - grid (list of strings): the grid representation with 'B' for buildings and '.' for empty spaces. Returns: - int: the minimum number of watchmen needed. Example: >>> min_watchmen(3, 4, [\\"..B.\\", \\"B...\\", \\"..B.\\"]) 2 >>> min_watchmen(4, 4, [\\"B...\\", \\"....\\", \\"...B\\", \\"B.B.\\"]) 3","solution":"def min_watchmen(m, n, grid): Determines the minimum number of watchmen needed to monitor all buildings ('B') in the grid. Args: - m (int): number of rows in the grid. - n (int): number of columns in the grid. - grid (list of strings): the grid representation with 'B' for buildings and '.' for empty spaces. Returns: - int: the minimum number of watchmen needed. rows_with_buildings = [any(cell == 'B' for cell in row) for row in grid] cols_with_buildings = [any(grid[i][j] == 'B' for i in range(m)) for j in range(n)] row_watchmen = sum(rows_with_buildings) col_watchmen = sum(cols_with_buildings) return min(row_watchmen, col_watchmen)"},{"question":"def can_form_arithmetic_progression(A: int, B: int, C: int, D: int, E: int) -> str: Determines if the five unique integers can form an arithmetic progression when sorted in ascending order. Args: A, B, C, D, E (int): Five unique integers. Returns: str: \\"YES\\" if they can form an arithmetic progression, otherwise \\"NO\\". >>> can_form_arithmetic_progression(1, 7, 13, 10, 4) 'YES' >>> can_form_arithmetic_progression(3, 6, 9, 11, 14) 'NO'","solution":"def can_form_arithmetic_progression(A, B, C, D, E): Determines if the five unique integers can form an arithmetic progression when sorted in ascending order. Args: A, B, C, D, E (int): Five unique integers. Returns: str: \\"YES\\" if they can form an arithmetic progression, otherwise \\"NO\\". numbers = [A, B, C, D, E] numbers.sort() # Check if differences between consecutive elements are the same diff = numbers[1] - numbers[0] for i in range(2, len(numbers)): if numbers[i] - numbers[i-1] != diff: return \\"NO\\" return \\"YES\\""},{"question":"def longest_common_prefix(titles: List[str]) -> str: Finds the longest common prefix string among an array of strings. Args: titles (List[str]): List of document titles. Returns: str: The longest common prefix among the titles. >>> longest_common_prefix([\\"flower\\"]) 'flower' >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"documentary\\", \\"docile\\", \\"doctor\\", \\"dock\\"]) 'doc' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"archive\\", \\"art\\", \\"arrow\\"]) 'ar' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"abc\\", \\"abc\\", \\"abc\\"]) 'abc' >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) 'inters' >>> longest_common_prefix([\\"xylophone\\", \\"xyz\\", \\"xy\\"]) 'xy' >>> longest_common_prefix([\\"a\\", \\"a\\", \\"ab\\"]) 'a'","solution":"def longest_common_prefix(titles): Finds the longest common prefix string among an array of strings. if not titles: return \\"\\" # Sort the array to minimize comparisons titles.sort() # Take the shortest and the longest strings first = titles[0] last = titles[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 # The longest common prefix is the portion of the first string up to index i return first[:i]"},{"question":"def length_of_longest_ap_subsequence(arr: List[int]) -> int: Find the length of the longest subsequence that can be rearranged to form an arithmetic progression. >>> length_of_longest_ap_subsequence([3, 7, 5, 2, 4]) 4 >>> length_of_longest_ap_subsequence([5]) 1 >>> length_of_longest_ap_subsequence([3, 7]) 2 >>> length_of_longest_ap_subsequence([5, 5, 5, 5, 5]) 5 >>> length_of_longest_ap_subsequence([1, 7, 10, 15, 27, 29]) 3 >>> length_of_longest_ap_subsequence([-1, -4, -7, 2, 1, 4, -2]) 4","solution":"def length_of_longest_ap_subsequence(arr): if len(arr) <= 1: return len(arr) arr.sort() n = len(arr) longest = 2 dp = {} for i in range(n): for j in range(i + 1, n): diff = arr[j] - arr[i] if (i, diff) in dp: dp[(j, diff)] = dp[(i, diff)] + 1 else: dp[(j, diff)] = 2 longest = max(longest, dp[(j, diff)]) return longest"},{"question":"def minimize_max_difference(n: int, k: int, elements: List[int]) -> int: Arrange n integers into k groups such that the maximum difference between the minimum and maximum integers in any group is minimized. Args: n (int): The number of elements. k (int): The number of groups. elements (List[int]): The list of elements. Returns: int: The minimized maximum difference. Examples: >>> minimize_max_difference(5, 3, [1, 5, 9, 12, 14]) 4 >>> minimize_max_difference(6, 2, [4, 8, 15, 16, 23, 42]) 19 # You may also run the following tests to validate your implementation from minimize_max_difference import minimize_max_difference def test_example_1(): n = 5 k = 3 elements = [1, 5, 9, 12, 14] assert minimize_max_difference(n, k, elements) == 4 def test_example_2(): n = 6 k = 2 elements = [4, 8, 15, 16, 23, 42] assert minimize_max_difference(n, k, elements) == 19 def test_single_element(): n = 1 k = 1 elements = [100] assert minimize_max_difference(n, k, elements) == 0 def test_equal_elements(): n = 5 k = 3 elements = [7, 7, 7, 7, 7] assert minimize_max_difference(n, k, elements) == 0 def test_large_input(): n = 100000 k = 2 elements = list(range(1, 100001)) assert minimize_max_difference(n, k, elements) == 49999","solution":"def minimize_max_difference(n, k, elements): elements.sort() def can_form_groups(max_diff): groups = 1 min_elem = elements[0] for elem in elements: if elem - min_elem > max_diff: groups += 1 min_elem = elem return groups <= k left, right = 0, elements[-1] - elements[0] while left < right: mid = (left + right) // 2 if can_form_groups(mid): right = mid else: left = mid + 1 return left # Example usage: # n = 5, # k = 3, # elements = [1, 5, 9, 12, 14] # Output: 4"},{"question":"def kth_highest_score(n: int, scores: List[int], k: int) -> Union[int, str]: Determines the k-th highest score among the list of scores. If there are fewer than k distinct scores, returns \\"Not enough participants\\". Parameters: n (int): The number of scores. scores (List[int]): The array of scores. k (int): The rank to find the k-th highest score. Returns: int/str: The k-th highest score or \\"Not enough participants\\". >>> nth_highest_score(8, [45, 67, 89, 23, 67, 89, 23, 45], 3) 45 >>> nth_highest_score(4, [45, 67, 89, 23], 5) 'Not enough participants'","solution":"def kth_highest_score(n, scores, k): Returns the k-th highest distinct score from the given scores. If there are fewer than k distinct scores, returns \\"Not enough participants\\". distinct_scores = list(set(scores)) # Remove duplicates distinct_scores.sort(reverse=True) # Sort in descending order if len(distinct_scores) < k: return \\"Not enough participants\\" else: return distinct_scores[k-1]"},{"question":"def find_anagrams(s: str, p: str) -> List[int]: Finds all occurrences of anagrams of the pattern within the given string and returns their starting indices. Input: - s: The input string (1 ≤ |s| ≤ 10^5) - p: The pattern (1 ≤ |p| ≤ 10^4) Output: - A list of starting indices of the anagrams of p in s. Examples: >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2]","solution":"def find_anagrams(s, p): from collections import Counter len_s = len(s) len_p = len(p) if len_p > len_s: return [] p_count = Counter(p) s_count = Counter(s[:len_p]) result = [] for i in range(len_s - len_p + 1): if i > 0: s_count[s[i - 1]] -= 1 if s_count[s[i - 1]] == 0: del s_count[s[i - 1]] s_count[s[i + len_p - 1]] += 1 if s_count == p_count: result.append(i) return result"},{"question":"def minimum_swaps(arr): Returns the minimum number of swaps needed to reorder the books so that the ID of the book at each position i is (i+1). >>> minimum_swaps([4, 3, 2, 1, 5]) 2 >>> minimum_swaps([1, 3, 4, 2]) 2 >>> minimum_swaps([1]) 0 >>> minimum_swaps([1, 2, 3, 4, 5]) 0 >>> minimum_swaps([5, 4, 3, 2, 1]) 2 >>> minimum_swaps([3, 1, 2, 5, 4]) 3","solution":"def minimum_swaps(arr): Returns the minimum number of swaps needed to reorder the books so that the ID of the book at each position i is (i+1). n = len(arr) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arr[i] == i + 1: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr[x] - 1 cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"def count_consecutive_unique_flowers(n: int, flower_sequence: str) -> int: Determine the number of consecutive unique flower types ZS will record. >>> count_consecutive_unique_flowers(7, 'AABCCCA') 4 >>> count_consecutive_unique_flowers(10, 'AAABBBCCCZ') 4","solution":"def count_consecutive_unique_flowers(n, flower_sequence): if n == 0: return 0 count = 1 for i in range(1, n): if flower_sequence[i] != flower_sequence[i - 1]: count += 1 return count"},{"question":"def optimal_difference(sequence): Determine the difference between Alice's total and Bob's total assuming both play optimally. >>> optimal_difference([4, 1, 2, 10]) 7 >>> optimal_difference([9, 7, 3]) 5 >>> optimal_difference([5]) 5 >>> optimal_difference([3, 9]) 6 >>> optimal_difference([4, 4, 4, 4]) 0 >>> optimal_difference([1, 100, 1, 100]) 198","solution":"def optimal_difference(sequence): n = len(sequence) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = sequence[i] # Consider all lengths from 2 to n for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(sequence[i] - dp[i + 1][j], sequence[j] - dp[i][j - 1]) return dp[0][n - 1] # Input processing and output sequence = [4, 1, 2, 10] print(optimal_difference(sequence)) # Output: 7"},{"question":"def max_energy_path(n: int, m: int, grid: List[List[int]]) -> int: Finds the maximum sum of the energy values along the optimal path from the top-left to the bottom-right corner of a grid. >>> max_energy_path(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 29 >>> max_energy_path(2, 3, [[-1, -2, -3], [-4, -5, -6]]) == -12 >>> max_energy_path(1, 1, [[5]]) == 5 >>> max_energy_path(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 73 >>> max_energy_path(3, 3, [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) == -21 pass","solution":"def max_energy_path(n, m, grid): Finds the maximum sum of the energy values along the optimal path from the top-left to the bottom-right corner of a grid. # Create a 2D dp array to store the maximum energy up to each cell dp = [[0] * m for _ in range(n)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner contains the maximum energy path sum return dp[n - 1][m - 1]"},{"question":"def count_palindromic_substrings(s: str) -> int: Counts the number of palindromic substrings in the given string. Parameters: s (str): The input string. Returns: int: The number of palindromic substrings. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"abcde\\") 5 >>> count_palindromic_substrings(\\"aaaa\\") 10 >>> count_palindromic_substrings(\\"racecar\\") 10 >>> count_palindromic_substrings(\\"madam\\") 7","solution":"def count_palindromic_substrings(s: str) -> int: Counts the number of palindromic substrings in the given string. Parameters: s (str): The input string. Returns: int: The number of palindromic substrings. n = len(s) count = 0 # Helper function to expand around center def expand_around_center(left: int, right: int) -> int: l, r = left, right palin_count = 0 while l >= 0 and r < n and s[l] == s[r]: palin_count += 1 l -= 1 r += 1 return palin_count # Iterate over each character and treat it as center of palindrome for i in range(n): # Odd length palindromes (center is one character) count += expand_around_center(i, i) # Even length palindromes (center is between two characters) count += expand_around_center(i, i + 1) return count"},{"question":"def min_parentheses_to_add(sequences: List[str]) -> List[int]: Returns a list of the minimum number of parentheses required to make each sequence valid. Args: sequences (list of str): List of sequences of parentheses. Returns: list of int: A list of integers where each integer represents the minimum number of parentheses needed to make the corresponding sequence valid. >>> min_parentheses_to_add([\\"())\\", \\"(((\\", \\")))\\", \\"()()\\", \\")()(\\"]) [1, 3, 3, 0, 2]","solution":"def min_parentheses_to_add(sequences): Returns a list of the minimum number of parentheses required to make each sequence valid. Args: sequences (list of str): List of sequences of parentheses. Returns: list of int: A list of integers where each integer represents the minimum number of parentheses needed to make the corresponding sequence valid. results = [] for seq in sequences: open_needed = 0 close_needed = 0 for char in seq: if char == '(': open_needed += 1 elif char == ')': if open_needed > 0: open_needed -= 1 else: close_needed += 1 results.append(open_needed + close_needed) return results"},{"question":"def max_tournament_rounds(n: int, skill_levels: List[int]) -> int: Calculate the maximum number of rounds in a tournament. Parameters: n (int): Number of participants skill_levels (list): List of skill levels of participants Returns: int: Maximum number of rounds possible >>> max_tournament_rounds(5, [3, 5, 2, 4, 1]) 2 >>> max_tournament_rounds(4, [10, 20, 30, 40]) 2 >>> max_tournament_rounds(3, [8, 3, 5]) 1","solution":"def max_tournament_rounds(n, skill_levels): Function to calculate the maximum number of rounds in a tournament. Parameters: n (int): Number of participants skill_levels (list): List of skill levels of participants Returns: int: Maximum number of rounds possible skill_levels.sort(reverse=True) rounds = 0 while len(skill_levels) > 1: skill_levels = skill_levels[:len(skill_levels)//2] rounds += 1 return rounds"},{"question":"def count_trailing_zeroes(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the number of trailing zeroes in a^b for each test case. >>> count_trailing_zeroes(3, [(10, 2), (5, 3), (2, 10)]) [2, 0, 0] >>> count_trailing_zeroes(2, [(20, 3), (3, 5)]) [3, 0] >>> count_trailing_zeroes(1, [(1000, 0)]) [0] >>> count_trailing_zeroes(4, [(0, 0), (10, 10), (5, 5), (25, 25)]) [0, 10, 0, 0] # Example unit tests def test_trailing_zeroes(): assert count_trailing_zeroes(3, [(10, 2), (5, 3), (2, 10)]) == [2, 0, 0] assert count_trailing_zeroes(2, [(20, 3), (3, 5)]) == [3, 0] assert count_trailing_zeroes(1, [(1000, 0)]) == [0] assert count_trailing_zeroes(4, [(0, 0), (10, 10), (5, 5), (25, 25)]) == [0, 10, 0, 0] def test_edge_cases(): assert count_trailing_zeroes(2, [(10**9, 10**9), (1, 0)]) == [int(10**9), 0] assert count_trailing_zeroes(1, [(7, 0)]) == [0] assert count_trailing_zeroes(1, [(10**9-1, 10**9)]) == [0] def test_large_exponents(): assert count_trailing_zeroes(1, [(10, 10**9)]) == [10**9] assert count_trailing_zeroes(1, [(5, 10**9)]) == [0] # Function to read input and call the count_trailing_zeroes function def main(): import sys input = sys.stdin.read data = input().strip().split() t = int(data[0]) test_cases = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(t)] # Get the results results = count_trailing_zeroes(t, test_cases) # Printing the results for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def count_trailing_zeroes(t, test_cases): results = [] for a, b in test_cases: if b == 0: results.append(0) elif a % 10 == 0: results.append(b) else: results.append(0) return results # Reading input def main(): import sys input = sys.stdin.read data = input().strip().split() t = int(data[0]) test_cases = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(t)] # Get the results results = count_trailing_zeroes(t, test_cases) # Printing the results for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"import re def is_palindrome(sentence: str) -> bool: Checks if a given sentence is a palindrome. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"This is not a palindrome\\") == False >>> is_palindrome(\\"No lemon, no melon\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False >>> is_palindrome(\\"\\") == True # Empty string is trivially a palindrome >>> is_palindrome(\\"Madam In Eden, I'm Adam\\") == True def process_input() -> List[str]: Reads input lines and checks if each sentence is a palindrome. Stops processing when encountering \\"END\\". >>> process_input() == [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"import re def is_palindrome(sentence): Checks if a given sentence is a palindrome. # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^a-zA-Z0-9]', '', sentence).lower() # Check if the cleaned sentence reads the same forwards and backwards return cleaned == cleaned[::-1] def process_input(): Reads input lines and checks if each sentence is a palindrome. Stops processing when encountering \\"END\\". results = [] while True: sentence = input().strip() if sentence == \\"END\\": break if is_palindrome(sentence): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"class DynamicArray: def __init__(self, nums): self.nums = nums def update(self, i, x): Update the integer at index \`i\` to \`x\`. # Implementation here def range_sum(self, l, r): Compute the sum of integers from index \`l\` to index \`r\` (inclusive). # Implementation here def process_operations(n, initial_elements, operations): Process a list of operations on the dynamic array. >>> process_operations( ... 5, [1, 2, 3, 4, 5], ... [(2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 0, 4)] ... ) [6, 14, 22] # Implementation here from solution import DynamicArray, process_operations def test_dynamic_array_update_and_range_sum(): arr = DynamicArray([1, 2, 3, 4, 5]) # First range sum assert arr.range_sum(1, 3) == 9 # 2 + 3 + 4 = 9 # Update operation arr.update(2, 10) assert arr.nums == [1, 2, 10, 4, 5] # Second range sum assert arr.range_sum(1, 3) == 16 # 2 + 10 + 4 = 16 # Third range sum assert arr.range_sum(0, 4) == 22 # 1 + 2 + 10 + 4 + 5 = 22 def test_process_operations(): operations = [ (2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 0, 4) ] initial_elements = [1, 2, 3, 4, 5] expected_results = [9, 16, 22] assert process_operations(5, initial_elements, operations) == expected_results def test_process_operations_edge_cases(): # Test an empty array operations = [ (1, 0, 10), (2, 0, 0), (2, 0, 1) ] initial_elements = [] expected_results = [0, 0] assert process_operations(0, initial_elements, operations) == expected_results # Test queries that are out of bounds operations = [ (2, 0, 10), (2, 5, 5), (1, 7, 100), (2, 0, 4) ] initial_elements = [1, 2, 3, 4, 5] expected_results = [0, 0, 15] assert process_operations(5, initial_elements, operations) == expected_results","solution":"class DynamicArray: def __init__(self, nums): self.nums = nums def update(self, i, x): Update the integer at index i to x. if 0 <= i < len(self.nums): self.nums[i] = x def range_sum(self, l, r): Compute the sum of integers from index l to index r (inclusive). if 0 <= l <= r < len(self.nums): return sum(self.nums[l:r+1]) return 0 def process_operations(n, initial_elements, operations): dyn_array = DynamicArray(initial_elements) results = [] for op in operations: if op[0] == 1: dyn_array.update(op[1], op[2]) elif op[0] == 2: result = dyn_array.range_sum(op[1], op[2]) results.append(result) return results"},{"question":"def crime_zone_frequency(n: int, m: int, zones: List[int]) -> List[int]: Given the total number of crime zones and a list of crime occurrences, determine the frequency of crimes in each zone. Parameters: n (int): The total number of crime zones. m (int): The total number of recorded crimes. zones (list of int): A list containing the zones where crimes occurred. Returns: list of int: A list containing the frequency of crimes in each zone. Examples: >>> crime_zone_frequency(5, 6, [1, 2, 2, 3, 3, 3]) [1, 2, 3, 0, 0] >>> crime_zone_frequency(4, 4, [4, 4, 4, 4]) [0, 0, 0, 4]","solution":"def crime_zone_frequency(n, m, zones): This function returns the frequency of crimes in each zone from 1 to n. Parameters: n (int): The total number of crime zones. m (int): The total number of recorded crimes. zones (list of int): A list containing the zones where crimes occurred. Returns: list of int: A list containing the frequency of crimes in each zone. # Initialize a list to store the frequency of each zone frequency = [0] * n # Populate the frequency list for zone in zones: frequency[zone - 1] += 1 return frequency"},{"question":"[Completion Task in Python] def min_strokes(s: str) -> int: Returns the minimum number of strokes required to paint the wall. >>> min_strokes('abac') 4 >>> min_strokes('aaabbb') 2","solution":"def min_strokes(s): Returns the minimum number of strokes required to paint the wall. n = len(s) if n == 0: return 0 strokes = 1 # The first character always needs one initial stroke. for i in range(1, n): if s[i] != s[i-1]: strokes += 1 return strokes"},{"question":"from typing import List, Tuple def find_promoted_students(n: int, m: int, attendance_records: List[Tuple[int, int]]) -> List[str]: Given a list of student IDs representing the students who have joined a coding club, identify and list the student IDs of those who meet the promotion criteria according to the attendance records. The promotion criteria are that a student must attend all meetings in three or more consecutive days at least once during the given period. Args: n: int - The number of attendance records. m: int - The number of different students. attendance_records: List[Tuple[int, int]] - The attendance records with each entry containing a day number and student ID. Returns: List[str] - The list of promoted student IDs in ascending order or [\\"None\\"] if no student meets the criteria. Examples: >>> find_promoted_students(7, 3, [(1, 1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 2), (7, 2)]) [1, 2] >>> find_promoted_students(5, 2, [(1, 1), (2, 1), (4, 2), (5, 2), (6, 2)]) [\\"None\\"] pass # Test cases attendance_records = [ (1, 1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 2), (7, 2) ] assert find_promoted_students(len(attendance_records), 2, attendance_records) == [1, 2] attendance_records = [ (1, 1), (2, 1), (4, 2), (5, 2), (6, 2) ] assert find_promoted_students(len(attendance_records), 2, attendance_records) == [\\"None\\"] attendance_records = [ (1, 1), (2, 1), (3, 2), (4, 2), (5, 2), (7, 2), (8, 3), (9, 3), (10, 3) ] assert find_promoted_students(len(attendance_records), 3, attendance_records) == [2, 3]","solution":"def find_promoted_students(n, m, attendance_records): from collections import defaultdict # Dictionary to store attendance by student id attendance_dict = defaultdict(list) for d, student_id in attendance_records: attendance_dict[student_id].append(d) promoted_students = [] for student_id, days in attendance_dict.items(): days.sort() consecutive_count = 1 for i in range(1, len(days)): if days[i] == days[i-1] + 1: consecutive_count += 1 if consecutive_count >= 3: promoted_students.append(student_id) break else: consecutive_count = 1 if promoted_students: return sorted(promoted_students) else: return [\\"None\\"]"},{"question":"def is_perfect_number(n): Returns True if n is a perfect number, else False. A perfect number is equal to the sum of its proper divisors excluding itself. pass def perfect_number_tournament(T, numbers): Determines if each number in the list is a perfect number. :param T: The number of test cases (integer). :param numbers: A list of integers of length T. :return: A list of strings \\"YES\\" or \\"NO\\" for each number. pass def test_is_perfect_number(): assert is_perfect_number(28) == True assert is_perfect_number(6) == True assert is_perfect_number(12) == False assert is_perfect_number(1) == False assert is_perfect_number(0) == False assert is_perfect_number(496) == True def test_perfect_number_tournament(): assert perfect_number_tournament(3, [28, 6, 12]) == [\\"YES\\", \\"YES\\", \\"NO\\"] assert perfect_number_tournament(1, [1]) == [\\"NO\\"] assert perfect_number_tournament(2, [48, 8128]) == [\\"NO\\", \\"YES\\"]","solution":"def is_perfect_number(n): Returns True if n is a perfect number, else False. A perfect number is equal to the sum of its proper divisors excluding itself. if n <= 1: return False sum_divisors = 1 # Start with 1 because 1 is a proper divisor of any number # Iterate over possible divisors up to the square root of n divisor = 2 while divisor * divisor <= n: if n % divisor == 0: sum_divisors += divisor if divisor != n // divisor: sum_divisors += n // divisor divisor += 1 return sum_divisors == n def perfect_number_tournament(T, numbers): Determines if each number in the list is a perfect number. :param T: The number of test cases (integer). :param numbers: A list of integers of length T. :return: A list of strings \\"YES\\" or \\"NO\\" for each number. results = [] for number in numbers: results.append(\\"YES\\" if is_perfect_number(number) else \\"NO\\") return results"},{"question":"class MedianFinder: def __init__(self): Initialize an empty MedianFinder. def add_element(self, x: int): Add an element x to the current array. :param x: element to be added def remove_element(self, x: int): Remove an element x from the current array. If x is not present, do nothing. :param x: element to be removed def find_median(self) -> float: Find and return the median of the current array. :return: median of the array def process_queries(queries: List[Tuple[int, ...]]) -> List[float]: Process a sequence of queries and return the result of each \\"find median\\" operation. :param queries: A list of queries, where each query is a tuple :return: A list of results for each \\"find median\\" query >>> queries = [(1, 1), (1, 3), (1, 2), (3,), (2, 1), (3,)] >>> process_queries(queries) [2, 2.5] >>> queries = [(1, 5), (1, 3), (3,), (2, 3), (3,)] >>> process_queries(queries) [4, 5]","solution":"import bisect class MedianFinder: def __init__(self): self.arr = [] def add_element(self, x): bisect.insort(self.arr, x) def remove_element(self, x): if x in self.arr: self.arr.remove(x) def find_median(self): n = len(self.arr) if n == 0: return None if n % 2 == 1: return self.arr[n // 2] else: return (self.arr[n // 2 - 1] + self.arr[n // 2]) / 2 def process_queries(queries): mf = MedianFinder() results = [] for query in queries: if query[0] == 1: mf.add_element(query[1]) elif query[0] == 2: mf.remove_element(query[1]) elif query[0] == 3: med = mf.find_median() results.append(med) return results"},{"question":"from typing import List def find_longest_increasing_subsequence_length(lists: List[List[int]]) -> List[int]: Find the length of the longest increasing subsequence for each list. >>> find_longest_increasing_subsequence_length([[5, 8, 7, 1, 9, 2], [3, 4, 6, 5, 7], [2, 2, 2, 2]]) [3, 4, 1]","solution":"def find_longest_increasing_subsequence_length(lists): def length_of_lis(seq): if not seq: return 0 lis = [1] * len(seq) for i in range(1, len(seq)): for j in range(0, i): if seq[i] > seq[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) results = [] for lst in lists: results.append(length_of_lis(lst)) return results"},{"question":"def max_car_repairs(n, W, times): Returns the maximum number of car repairs that can be completed in a given workday. :param n: Number of cars :param W: Total working hours available :param times: List containing repair times for each car :return: Maximum number of repairs that can be completed >>> max_car_repairs(5, 10, [2, 3, 7, 4, 5]) == 3 >>> max_car_repairs(3, 1, [2, 2, 2]) == 0 >>> max_car_repairs(4, 10, [5, 5, 5, 5]) == 2 >>> max_car_repairs(3, 10000, [1000, 2000, 3000]) == 3 >>> max_car_repairs(1, 5, [10]) == 0 >>> max_car_repairs(5, 15, [3, 3, 3, 3, 3]) == 5","solution":"def max_car_repairs(n, W, times): Returns the maximum number of car repairs that can be completed in a given workday. :param n: Number of cars :param W: Total working hours available :param times: List containing repair times for each car :return: Maximum number of repairs that can be completed times.sort() total_time = 0 count = 0 for time in times: if total_time + time <= W: total_time += time count += 1 else: break return count"},{"question":"def count_subarrays_with_sum_x(n: int, x: int, a: List[int]) -> int: Counts the number of subarrays whose sum is exactly x. Parameters: n (int): The number of elements in the array. x (int): The target sum for the subarrays. a (list of int): The list of integers representing the array. Returns: int: Number of subarrays with sum exactly x. Example: >>> count_subarrays_with_sum_x(5, 5, [1, 2, 3, 4, 5]) 2 >>> count_subarrays_with_sum_x(3, 10, [1, 2, 3]) 0 >>> count_subarrays_with_sum_x(5, 1, [1, 1, 1, 1, 1]) 5","solution":"from collections import defaultdict def count_subarrays_with_sum_x(n, x, a): Counts the number of subarrays whose sum is exactly x. Parameters: n (int): The number of elements in the array. x (int): The target sum for the subarrays. a (list of int): The list of integers representing the array. Returns: int: Number of subarrays with sum exactly x. prefix_sum_count = defaultdict(int) prefix_sum = 0 count = 0 for num in a: prefix_sum += num # If the current prefix sum is equal to x if prefix_sum == x: count += 1 # If there is a prefix sum that is \`prefix_sum - x\`, then there exist some subarrays ending at current index with sum x if (prefix_sum - x) in prefix_sum_count: count += prefix_sum_count[prefix_sum - x] # Increase the count of the prefix sum prefix_sum_count[prefix_sum] += 1 return count"},{"question":"def is_path_exists(grid: List[List[int]]) -> str: Determine if there is a valid path from the top-left to the bottom-right corner in the grid. >>> grid = [ ... [0, 0, 1, 0], ... [1, 0, 1, 0], ... [0, 0, 0, 0], ... [1, 1, 0, 0] ... ] >>> is_path_exists(grid) \\"YES\\" >>> grid = [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 0, 0] ... ] >>> is_path_exists(grid) \\"NO\\" >>> grid = [ ... [0, 0], ... [0, 0] ... ] >>> is_path_exists(grid) \\"YES\\" >>> grid = [ ... [1, 0], ... [0, 0] ... ] >>> is_path_exists(grid) \\"NO\\" >>> grid = [ ... [0, 0], ... [0, 1] ... ] >>> is_path_exists(grid) \\"NO\\" >>> N = 500 >>> grid = [[0] * N for _ in range(N)] >>> is_path_exists(grid) \\"YES\\" >>> grid = [[1] * N for _ in range(N)] >>> grid[0][0] = 0 >>> grid[N-1][N-1] = 0 >>> is_path_exists(grid) \\"NO\\"","solution":"def is_path_exists(grid): Determine if there is a valid path from the top-left to the bottom-right corner in the grid. N = len(grid) if grid[0][0] == 1 or grid[N - 1][N - 1] == 1: return \\"NO\\" from collections import deque # Define directions for movement: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) # Start from the top-left corner visited = set((0, 0)) # Keep track of visited cells while queue: x, y = queue.popleft() # Check if we've reached the bottom-right corner if x == N - 1 and y == N - 1: return \\"YES\\" # Explore neighboring cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def min_colors_to_paint_roads(n: int, connections: List[Tuple[int, int]]) -> int: Determine the minimum number of colors required to paint the roads such that for any two roads at the same depth from the root city, the path from the root to these roads involves the same sequence of colors. Args: n: int - The number of cities. connections: List[Tuple[int, int]] - List of tuples where each tuple represents a road between two cities. Returns: int - The minimum number of colors required to paint the roads. Examples: >>> min_colors_to_paint_roads(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> min_colors_to_paint_roads(3, [(1, 2), (1, 3)]) 2","solution":"def min_colors_to_paint_roads(n, connections): if n == 1: return 1 # only one city means no roads, hence no colors needed from collections import defaultdict # Create adjacency list adj_list = defaultdict(list) for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) # Finding the node with the maximum degree max_degree = 0 for node in adj_list: max_degree = max(max_degree, len(adj_list[node])) # Minimum number of colors required is the max degree of the nodes return max_degree"},{"question":"from typing import List class MediaLibrary: def __init__(self): Initializes a new instance of the MediaLibrary class. def add_media(self, file_identifier: str) -> None: Adds a unique media file with the given identifier to the library. :param file_identifier: The identifier of the media file to be added. def add_tags(self, file_identifier: str, tags: List[str]) -> None: Associates the specified tags with the media file identified by file_identifier. :param file_identifier: The identifier of the media file. :param tags: A list of tags to be associated with the file. def get_files_by_tags(self, tags: List[str]) -> List[str]: Returns a list of file identifiers that are associated with all the specified tags. :param tags: A list of tags to filter the media files by. :return: A list of file identifiers that match all the specified tags. >>> library = MediaLibrary() >>> library.add_media(\\"file1\\") >>> library.add_media(\\"file2\\") >>> library.add_media(\\"file3\\") >>> library.add_tags(\\"file1\\", [\\"drama\\", \\"comedy\\"]) >>> library.add_tags(\\"file2\\", [\\"drama\\", \\"action\\"]) >>> library.add_tags(\\"file3\\", [\\"comedy\\"]) >>> library.get_files_by_tags([\\"drama\\"]) [\\"file1\\", \\"file2\\"] >>> library.get_files_by_tags([\\"comedy\\"]) [\\"file1\\", \\"file3\\"] >>> library.get_files_by_tags([\\"drama\\", \\"comedy\\"]) [\\"file1\\"] >>> library.get_files_by_tags([]) []","solution":"from collections import defaultdict from typing import List class MediaLibrary: def __init__(self): self.files_tags = defaultdict(set) self.tagged_files = defaultdict(set) def add_media(self, file_identifier: str) -> None: if file_identifier not in self.files_tags: self.files_tags[file_identifier] = set() def add_tags(self, file_identifier: str, tags: List[str]) -> None: for tag in tags: self.files_tags[file_identifier].add(tag) self.tagged_files[tag].add(file_identifier) def get_files_by_tags(self, tags: List[str]) -> List[str]: if not tags: return [] # Get sets of file identifiers for each tag files_sets = [self.tagged_files[tag] for tag in tags if tag in self.tagged_files] # If any tag is not in the library, no files can match all tags if not files_sets or len(files_sets) != len(tags): return [] # Find intersection of all sets to get files that have all tags result_files = set.intersection(*files_sets) # Convert to sorted list return sorted(result_files)"},{"question":"def minimum_calories(n: int, k: int, calories: List[int]) -> int: Returns the minimum possible total number of calories for exactly k cakes. >>> minimum_calories(5, 3, [100, 300, 500, 200, 400]) 600 >>> minimum_calories(4, 2, [5, 9, 2, 6]) 7","solution":"def minimum_calories(n, k, calories): Returns the minimum possible total number of calories for exactly k cakes. Parameters: - n: int, number of different types of cakes - k: int, number of cakes to buy - calories: list of int, calories of each cake type Returns: - int, minimum total number of calories # Sort the list of calories to get the smallest possible sum calories.sort() # Sum up the first k elements for the minimum possible total calories return sum(calories[:k])"},{"question":"from typing import List, Optional def second_max(nums: List[int]) -> Optional[int]: Returns the second maximum number in the list. If the list is empty or contains only one unique integer, return None. >>> second_max([4, 3, 9, 1, 6, 9]) 6 >>> second_max([7, 7, 7]) None >>> second_max([]) None >>> second_max([1, 2]) 1 >>> second_max([-1, -2, -3, -1]) -2 >>> second_max([-10, 5, 5, 10, 8]) 8 >>> second_max(list(range(100))) 98","solution":"def second_max(nums): Returns the second maximum number in the list. If the list is empty or contains only one unique integer, return None. if len(nums) < 2: return None unique_nums = list(set(nums)) if len(unique_nums) < 2: return None unique_nums.sort(reverse=True) return unique_nums[1]"},{"question":"def count_paths(H: int, W: int, grid: List[List[str]]) -> int: Determine the number of distinct paths the robot can take to reach the bottom-right corner of the grid from the top-left corner. Args: H (int): Height of the grid. W (int): Width of the grid. grid (List[List[str]]): The grid represented as a list of lists of strings. Each string is either '.' for open cells or '#' for blocked cells. Returns: int: The number of distinct paths from the top-left to the bottom-right corner. Example: >>> count_paths(4, 4, [['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.']]) 4 >>> count_paths(4, 4, [['.', '.', '.', '.'], ['#', '#', '#', '#'], ['#', '#', '#', '#'], ['.', '.', '.', '.']]) 0 def read_grid_from_input(input_str: str) -> (int, int, List[List[str]]): Helper function to read grid and convert to list of lists. Args: input_str (str): Input string representing the grid and its dimensions. Returns: tuple: A tuple containing the height, width, and grid as a list of lists of strings. Example: >>> read_grid_from_input(\\"4 4n....n.#..n..#.n....\\") (4, 4, [['.', '.', '.', '.'], ['.', '#', '.', '.'], ['.', '.', '#', '.'], ['.', '.', '.', '.']]) import pytest from solution import count_paths, read_grid_from_input def test_sample_input(): input_str = \\"4 4n....n.#..n..#.n....\\" H, W, grid = read_grid_from_input(input_str) assert count_paths(H, W, grid) == 4 def test_no_paths(): input_str = \\"4 4n....nnn....\\" H, W, grid = read_grid_from_input(input_str) assert count_paths(H, W, grid) == 0 def test_single_path(): input_str = \\"2 2n..n..\\" H, W, grid = read_grid_from_input(input_str) assert count_paths(H, W, grid) == 2 def test_blocked_exit(): input_str = \\"3 3n...n.#.n..#\\" H, W, grid = read_grid_from_input(input_str) assert count_paths(H, W, grid) == 0 def test_large_grid(): input_str = \\"3 3n...n.#.n...\\" H, W, grid = read_grid_from_input(input_str) assert count_paths(H, W, grid) == 2","solution":"def count_paths(H, W, grid): if grid[0][0] == '#' or grid[H-1][W-1] == '#': return 0 dp = [[0] * W for _ in range(H)] dp[0][0] = 1 for i in range(H): for j in range(W): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[H-1][W-1] # Helper function to read grid and convert to list of lists def read_grid_from_input(input_str): lines = input_str.strip().split('n') H, W = map(int, lines[0].split()) grid = [list(line) for line in lines[1:H+1]] return H, W, grid"},{"question":"def num_paths(n: int, m: int, grid: List[str]) -> int: Determine the number of different paths the player can take to reach the goal in a dungeon crawler game. Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): A list of n strings each of length m representing the grid, where '.' is an open space and '#' is a wall. Returns: int: The number of different paths from the top-left corner to the bottom-right corner, modulo 10^9 + 7. >>> num_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths(2, 2, [\\"..\\", \\"..\\"]) 2 >>> num_paths(2, 2, [\\".#\\", \\"..\\"]) 1","solution":"def num_paths(n, m, grid): MOD = 10**9 + 7 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 if grid[0][0] == \\".\\" else 0 for i in range(n): for j in range(m): if grid[i][j] == \\".\\": if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[-1][-1] # Example usage (not part of the solution function): # n = 3 # m = 3 # grid = [ # \\"...\\", # \\".#.\\", # \\"...\\" # ] # print(num_paths(n, m, grid)) # Output: 2"},{"question":"def min_removals_to_strictly_increasing(arr: List[int]) -> int: You are given an array of n integers. Your task is to find the minimum number of elements you need to remove such that the remaining array is strictly increasing and all the remaining elements are distinct. >>> min_removals_to_strictly_increasing([4, 3, 6, 2, 1, 7]) 3 >>> min_removals_to_strictly_increasing([1, 2, 3, 4, 5]) 0 >>> min_removals_to_strictly_increasing([5, 4, 3, 2, 1]) 4 >>> min_removals_to_strictly_increasing([2, 2, 2, 2, 2]) 4 >>> min_removals_to_strictly_increasing([1, 2, 3, 2, 1, 4, 5]) 2 >>> min_removals_to_strictly_increasing([1]) 0 >>> min_removals_to_strictly_increasing([]) 0","solution":"def min_removals_to_strictly_increasing(arr): n = len(arr) # Initialize LIS array lis = [1] * n # Calculate LIS values for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Length of longest increasing subsequence lis_length = max(lis) if n != 0 else 0 # Minimum number of elements to remove return n - lis_length"},{"question":"from typing import List def majority_element(nums: List[int]) -> int: This function returns the majority element in a list of integers. The majority element is the element that appears more than ⌊ n/2 ⌋ times in the list. >>> majority_element([3, 2, 3]) == 3 >>> majority_element([2, 2, 1, 1, 1, 2, 2]) == 2","solution":"from typing import List def majority_element(nums: List[int]) -> int: This function returns the majority element in a list of integers. The majority element is the element that appears more than ⌊ n/2 ⌋ times in the list. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def canPartition(nums: List[int]) -> bool: Determine if the array can be partitioned into two subsets with equal sum. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False >>> canPartition([2, 4, 5, 6]) False >>> canPartition([2, 2, 1, 1]) True","solution":"def canPartition(nums): total_sum = sum(nums) # If the total sum is odd, it's impossible to partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # We use a boolean DP array to keep track of possible sums dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"def max_projects_completed(N: int, durations: List[int], start_times: List[int], T: int) -> int: Find the maximum number of projects that can be completed within the total time limit. >>> max_projects_completed(5, [2, 1, 3, 2, 2], [1, 2, 1, 3, 0], 5) 3 >>> max_projects_completed(3, [4, 2, 1], [1, 2, 0], 4) 2","solution":"def max_projects_completed(N, durations, start_times, T): projects = list(zip(durations, start_times)) # Sort projects based on end time (start_time + duration) projects.sort(key=lambda x: x[1] + x[0]) total_time = 0 completed_projects = 0 for duration, start_time in projects: if total_time + duration <= T and total_time >= start_time: total_time += duration completed_projects += 1 elif total_time < start_time: # wait for this project's start time total_time = start_time + duration if total_time <= T: completed_projects += 1 return completed_projects"},{"question":"class Library: A system to manage and query a collection of books in a library. Each book is identified by a unique ISBN number and includes metadata such as title, author, and release year. The system supports the following operations: 1. Add a book to the library. 2. Remove a book from the library using its ISBN number. 3. Retrieve all books written by a particular author and list them by their release year in ascending order. If there are multiple books published in the same year, they should be ordered by ISBN in ascending order. Methods: - add_book(isbn: str, title: str, author: str, year: int) -> None - remove_book(isbn: str) -> None - retrieve_books_by_author(author: str) -> List[str] >>> library = Library() >>> library.add_book(\\"978-3-16-148410-0\\", \\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951) >>> library.add_book(\\"978-0-684-84328-5\\", \\"Franny and Zooey\\", \\"J.D. Salinger\\", 1961) >>> library.add_book(\\"978-0-14-004259-7\\", \\"Nine Stories\\", \\"J.D. Salinger\\", 1953) >>> library.remove_book(\\"978-0-14-004259-7\\") >>> library.retrieve_books_by_author(\\"J.D. Salinger\\") ['978-3-16-148410-0 \\"The Catcher in the Rye\\" 1951', '978-0-684-84328-5 \\"Franny and Zooey\\" 1961'] >>> library.add_book(\\"978-0-7432-7356-5\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) >>> library.retrieve_books_by_author(\\"F. Scott Fitzgerald\\") ['978-0-7432-7356-5 \\"The Great Gatsby\\" 1925'] >>> library.remove_book(\\"978-0-7432-7356-5\\") >>> library.retrieve_books_by_author(\\"F. Scott Fitzgerald\\") ['No books found']","solution":"class Library: def __init__(self): self.books_by_isbn = {} self.books_by_author = {} def add_book(self, isbn, title, author, year): if isbn in self.books_by_isbn: return # Book already exists book = {'isbn': isbn, 'title': title, 'author': author, 'year': year} self.books_by_isbn[isbn] = book if author not in self.books_by_author: self.books_by_author[author] = [] self.books_by_author[author].append(book) def remove_book(self, isbn): if isbn not in self.books_by_isbn: return # Book does not exist book = self.books_by_isbn.pop(isbn) self.books_by_author[book['author']].remove(book) if not self.books_by_author[book['author']]: del self.books_by_author[book['author']] def retrieve_books_by_author(self, author): if author not in self.books_by_author: return [\\"No books found\\"] books = sorted(self.books_by_author[author], key=lambda x: (x['year'], x['isbn'])) return [f\\"{book['isbn']} \\"{book['title']}\\" {book['year']}\\" for book in books]"},{"question":"def watering_schedule(N, P, M): Returns the number of ways to assign watering days to P plants in an N-day schedule modulo M. Parameters: N (int): Number of days in the schedule. P (int): Number of plants to be watered. M (int): Prime number to modulo the result with. Returns: int: The number of valid watering schedules modulo M. >>> watering_schedule(5, 3, 1000000007) 60 >>> watering_schedule(7, 4, 998244353) 840 >>> watering_schedule(10, 5, 1000000009) 30240 >>> watering_schedule(4, 4, 1000000007) 24 >>> watering_schedule(10, 1, 1000000007) 10","solution":"from math import comb def watering_schedule(N, P, M): Returns the number of ways to assign watering days to P plants in an N-day schedule modulo M. Parameters: N (int): Number of days in the schedule. P (int): Number of plants to be watered. M (int): Prime number to modulo the result with. Returns: int: The number of valid watering schedules modulo M. # Number of ways to choose P days out of N days result = comb(N, P) % M # Each plant can be assigned to any of the chosen days in P! ways # So we compute P! % M factorial = 1 for i in range(2, P + 1): factorial = (factorial * i) % M result = (result * factorial) % M return result"},{"question":"def is_palindrome(s: str) -> bool: Check if the string s is a palindrome, ignoring case, spaces, and punctuation. # Filter out non-alphanumeric characters and convert to lowercase. pass def process_input(lines: List[str]) -> List[str]: Process multiple datasets to check for palindromes. Args: lines (List[str]): The input strings where each string is a dataset. Returns: List[str]: List of strings \\"YES\\" or \\"NO\\" for each dataset indicating if the string is a palindrome. >>> process_input([ ... \\"A man, a plan, a canal, Panama\\", ... \\"Hello, World!\\", ... \\"12321\\", ... \\"END\\" ... ]) ['YES', 'NO', 'YES'] >>> process_input([ ... \\"Madam\\", ... \\"Not a palindrome\\", ... \\"123321\\", ... \\"END\\" ... ]) ['YES', 'NO', 'YES'] pass","solution":"def is_palindrome(s): Check if the string s is a palindrome, ignoring case, spaces, and punctuation. # Filter out non-alphanumeric characters and convert to lowercase. filtered_chars = ''.join(c for c in s if c.isalnum()).lower() # Check if the string reads the same forward and backward. return filtered_chars == filtered_chars[::-1] def process_input(lines): results = [] for line in lines: if line == \\"END\\": break if is_palindrome(line): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def maximize_cultural_value(N: int, B: int, T: int, exhibits: List[Tuple[int, int]]) -> Union[int, str]: N : int : Number of exhibits B : int : Budget T : int : Threshold for cultural value exhibits : list of tuples : Each tuple contains (cultural value, monetary value) of an exhibit Returns the maximum possible cultural value you can achieve within the given constraints. If it's impossible to achieve a total cultural value of at least T within the budget B, returns \\"Not possible\\". Examples: >>> maximize_cultural_value(3, 50, 30, [(20, 25), (10, 20), (15, 10)]) 35 >>> maximize_cultural_value(4, 100, 200, [(50, 70), (30, 60), (70, 90), (20, 40)]) 'Not possible'","solution":"def maximize_cultural_value(N, B, T, exhibits): N : int : Number of exhibits B : int : Budget T : int : Threshold for cultural value exhibits : list of tuples : Each tuple contains (cultural value, monetary value) of an exhibit # Try to find all combinations of exhibits from itertools import combinations max_cultural_value = float('-inf') possible = False for r in range(1, N+1): for comb in combinations(exhibits, r): total_monetary_value = sum(exhibit[1] for exhibit in comb) total_cultural_value = sum(exhibit[0] for exhibit in comb) if total_monetary_value <= B and total_cultural_value >= T: possible = True if total_cultural_value > max_cultural_value: max_cultural_value = total_cultural_value if possible: return max_cultural_value else: return \\"Not possible\\" # Test example case: # print(maximize_cultural_value(3, 50, 30, [(20, 25), (10, 20), (15, 10)])) # should return 35 # print(maximize_cultural_value(4, 100, 200, [(50, 70), (30, 60), (70, 90), (20, 40)])) # should return \\"Not possible\\""},{"question":"def count_unique_words(n: int, responses: List[str]) -> int: Counts the number of unique words across all survey responses after converting all words to lowercase. Args: n (int): The number of survey responses. responses (list of str): List of survey responses. Returns: int: The number of unique words. pass # Unit tests def test_count_unique_words_example(): n = 3 responses = [\\"Hello World\\", \\"HELLO there\\", \\"World of HELLO\\"] assert count_unique_words(n, responses) == 4 def test_count_unique_words_single_response(): n = 1 responses = [\\"This is a single survey response\\"] assert count_unique_words(n, responses) == 6 def test_count_unique_words_all_same_words(): n = 4 responses = [\\"same word\\", \\"SAME Word\\", \\"same WORD\\", \\"SAME word\\"] assert count_unique_words(n, responses) == 2 def test_count_unique_words_mixed_case_different_words(): n = 2 responses = [\\"Case INSENSITIVE check\\", \\"case Insensitive Check\\"] assert count_unique_words(n, responses) == 3 def test_count_unique_words_different_words(): n = 3 responses = [\\"apple banana\\", \\"orange mango peach\\", \\"grape berry apple\\"] assert count_unique_words(n, responses) == 7","solution":"def count_unique_words(n, responses): Counts the number of unique words across all survey responses after converting all words to lowercase. Args: n (int): The number of survey responses. responses (list of str): List of survey responses. Returns: int: The number of unique words. unique_words = set() for response in responses: words = response.lower().split() unique_words.update(words) return len(unique_words) # Example usage: # n = 3 # responses = [\\"Hello World\\", \\"HELLO there\\", \\"World of HELLO\\"] # print(count_unique_words(n, responses)) # Output: 4"},{"question":"def minimum_hits(t: int, test_cases: List[Tuple[int, int], List[int]]) -> List[int]: Calculate the minimum number of hits required to defeat all the monsters. >>> t = 3 >>> test_cases = [ ... (3, 10), [20, 30, 40], ... (4, 25), [25, 50, 75, 100], ... (2, 15), [15, 25] ... ] >>> minimum_hits(t, test_cases) [9, 10, 3]","solution":"def minimum_hits(t, test_cases): results = [] for i in range(t): n, k = test_cases[i * 2] monsters = test_cases[i * 2 + 1] hits = sum(-(-hp // k) for hp in monsters) # Use ceiling division to count hits results.append(hits) return results"},{"question":"from typing import List def sum_of_odd_frequencies(n: int, arr: List[int]) -> int: Given a list of integers, returns the sum of integers that appear an odd number of times in the list. :param n: Number of elements in the array :param arr: List of integers :return: Sum of all integers that appear an odd number of times pass # Example usage: # n = 5 # arr = [1, 2, 2, 3, 3] # print(sum_of_odd_frequencies(n, arr)) # Output: 1 # Unit Tests def test_case_1(): assert sum_of_odd_frequencies(5, [1, 2, 2, 3, 3]) == 1 def test_case_2(): assert sum_of_odd_frequencies(6, [4, 4, 5, 5, 5, 6]) == 11 def test_case_all_different(): assert sum_of_odd_frequencies(4, [1, 2, 3, 4]) == 10 def test_case_all_same(): assert sum_of_odd_frequencies(4, [1, 1, 1, 1]) == 0 def test_case_mixed(): assert sum_of_odd_frequencies(7, [1, 1, 2, 2, 2, 3, 3]) == 2 def test_case_single_element(): assert sum_of_odd_frequencies(1, [10]) == 10 def test_case_no_elements(): assert sum_of_odd_frequencies(0, []) == 0","solution":"from collections import Counter def sum_of_odd_frequencies(n, arr): Given a list of integers, returns the sum of integers that appear an odd number of times in the list. :param n: Number of elements in the array :param arr: List of integers :return: Sum of all integers that appear an odd number of times frequency = Counter(arr) result_sum = 0 for num, count in frequency.items(): if count % 2 != 0: result_sum += num return result_sum # Example usage: # n = 5 # arr = [1, 2, 2, 3, 3] # print(sum_of_odd_frequencies(n, arr)) # Output: 1"},{"question":"def longest_common_subsequence(a: str, b: str) -> int: Returns the length of the longest common subsequence between strings a and b. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") == 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") == 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") == 3 >>> longest_common_subsequence(\\"a\\", \\"a\\") == 1 >>> longest_common_subsequence(\\"xzy\\", \\"yaz\\") == 1 >>> longest_common_subsequence(\\"abcdef\\", \\"acdf\\") == 4 >>> longest_common_subsequence(\\"\\", \\"acdf\\") == 0 >>> longest_common_subsequence(\\"abcdef\\", \\"\\") == 0 >>> longest_common_subsequence(\\"\\", \\"\\") == 0","solution":"def longest_common_subsequence(a, b): Returns the length of the longest common subsequence between strings a and b. n, m = len(a), len(b) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def remove_duplicates(nums: List[int]) -> int: Removes duplicates from a sorted array in-place and returns the new length. Args: nums (List[int]): A list of integers sorted in non-decreasing order. Returns: int: The new length of the array after removing duplicates. Example: >>> nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] >>> remove_duplicates(nums) 5 >>> nums[:5] [0, 1, 2, 3, 4] >>> nums = [1, 2, 3] >>> remove_duplicates(nums) 3 >>> nums[:3] [1, 2, 3] >>> nums = [1, 1, 1] >>> remove_duplicates(nums) 1 >>> nums[:1] [1] >>> nums = [] >>> remove_duplicates(nums) 0 pass def process_test_cases(t: int, test_cases: List[List[int]]) -> List[int]: Processes multiple test cases and returns results for each one. Args: t (int): The number of test cases. test_cases (List[List[int]]): A list containing t test cases, each a list of integers sorted in non-decreasing order. Returns: List[int]: A list containing the new lengths of arrays after removing duplicates for each test case. Example: >>> test_cases = [ >>> [0, 0, 1, 1, 1, 2, 2, 3, 3, 4], >>> [1, 2, 3], >>> [1, 1, 1], >>> [] >>> ] >>> process_test_cases(4, test_cases) [5, 3, 1, 0] pass # Unit tests: def test_remove_duplicates(): nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] assert remove_duplicates(nums) == 5 assert nums[:5] == [0, 1, 2, 3, 4] def test_remove_duplicates_all_unique(): nums = [1, 2, 3] assert remove_duplicates(nums) == 3 assert nums[:3] == [1, 2, 3] def test_remove_duplicates_all_same(): nums = [1, 1, 1] assert remove_duplicates(nums) == 1 assert nums[:1] == [1] def test_remove_duplicates_empty(): nums = [] assert remove_duplicates(nums) == 0 def test_process_test_cases(): test_cases = [ [0,0,1,1,1,2,2,3,3,4], [1,2,3], [1,1,1], [] ] expected_results = [5, 3, 1, 0] assert process_test_cases(4, test_cases) == expected_results","solution":"def remove_duplicates(nums): Removes duplicates from a sorted array in-place and returns the new length. if not nums: return 0 new_length = 1 # Start with the first element being unique for i in range(1, len(nums)): if nums[i] != nums[new_length - 1]: nums[new_length] = nums[i] new_length += 1 return new_length def process_test_cases(t, test_cases): Processes multiple test cases and returns results for each one. results = [] for case in test_cases: new_length = remove_duplicates(case) results.append(new_length) return results"},{"question":"def is_armstrong_number(n: int) -> bool: Determines whether a given three-digit number is an Armstrong number. Args: n (int): A three-digit integer. Returns: bool: True if n is an Armstrong number, False otherwise. >>> is_armstrong_number(153) True >>> is_armstrong_number(370) True >>> is_armstrong_number(123) False >>> is_armstrong_number(200) False >>> is_armstrong_number(999) False >>> is_armstrong_number(100) False >>> is_armstrong_number(12) False >>> is_armstrong_number(1234) False","solution":"def is_armstrong_number(n): Determines whether a given three-digit number is an Armstrong number. Args: n (int): A three-digit integer. Returns: bool: True if n is an Armstrong number, False otherwise. # Convert the number to a string to access each digit str_n = str(n) # Check if the number is three digits if len(str_n) != 3: return False # Calculate the sum of the cubes of its digits sum_of_cubes = sum(int(digit) ** 3 for digit in str_n) # Check if the sum of cubes is equal to the number itself return sum_of_cubes == n"},{"question":"class PriorityQueue: def __init__(self): # Initialize your priority queue pass def insert(self, element, priority): Inserts an element with the given priority. >>> pq = PriorityQueue() >>> pq.insert(\\"apple\\", 5) pass def remove(self): Removes and returns the highest priority element. Returns \\"EMPTY\\" if the queue is empty. >>> pq = PriorityQueue() >>> pq.insert(\\"banana\\", 10) >>> pq.remove() 'banana' >>> pq.remove() 'EMPTY' pass def change_priority(self, element, priority): Changes the priority of the given element. >>> pq = PriorityQueue() >>> pq.insert(\\"cherry\\", 7) >>> pq.change_priority(\\"cherry\\", 10) pass def process_operations(operations): Process a list of operations on the priority queue. >>> process_operations([\\"INSERT apple 5\\", \\"INSERT banana 10\\", \\"REMOVE\\", \\"INSERT cherry 7\\", \\"REMOVE\\"]) ['banana', 'cherry'] pass def process_test_cases(T, test_cases): Process multiple test cases on the priority queue. >>> process_test_cases(2, [ ... (5, [\\"INSERT apple 5\\", \\"INSERT banana 10\\", \\"REMOVE\\", \\"INSERT cherry 7\\", \\"REMOVE\\"]), ... (4, [\\"INSERT apple 5\\", \\"REMOVE\\", \\"REMOVE\\", \\"REMOVE\\"]) ... ]) [['banana', 'cherry'], ['apple', 'EMPTY', 'EMPTY']] pass","solution":"import heapq class PriorityQueue: def __init__(self): self.pq = [] # list of entries arranged in a heap self.entry_finder = {} # mapping of elements to entries self.REMOVED = '<removed-element>' # placeholder for a removed item self.counter = 0 def insert(self, element, priority): Add a new task or update the priority of an existing task. if element in self.entry_finder: self.remove_element(element) count = self.counter entry = [-priority, count, element] self.entry_finder[element] = entry heapq.heappush(self.pq, entry) self.counter += 1 def remove_element(self, element): Mark an existing task as REMOVED. Raise KeyError if not found. entry = self.entry_finder.pop(element) entry[-1] = self.REMOVED def remove(self): Remove and return the highest priority task. Raise KeyError if empty. while self.pq: priority, count, element = heapq.heappop(self.pq) if element is not self.REMOVED: del self.entry_finder[element] return element return \\"EMPTY\\" def change_priority(self, element, priority): Change the priority of an existing task. self.insert(element, priority) def process_operations(operations): pq = PriorityQueue() result = [] for operation in operations: if operation.startswith(\\"INSERT\\"): _, element, priority = operation.split() pq.insert(element, int(priority)) elif operation.startswith(\\"REMOVE\\"): result.append(pq.remove()) elif operation.startswith(\\"CHANGE\\"): _, element, priority = operation.split() pq.change_priority(element, int(priority)) return result def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] operations = test_cases[i][1] results.append(process_operations(operations)) return results"},{"question":"def count_palindromic_times(t1: str, t2: str) -> int: Alice recently learnt about digital clocks and decided to experiment with them. She noticed that at any given instant, the time on a 12-hour digital clock can be represented by a 4-digit sequence (for example, \\"0530\\" for 5:30 AM or \\"1230\\" for 12:30 PM). She also realized that some sequences form a palindrome (i.e., they read the same forward and backward). For instance, \\"1221\\" is a palindromic sequence. You need to help Alice by writing a program that finds the number of distinct palindromic times between two given times on a 12-hour clock. Times are given in the format \\"HHMM\\". Input: t1 and t2 in the 4-digit \\"HHMM\\" format, separated by a single space. The first time t1 is always strictly earlier than the second time t2 on the same day. Output: The number of distinct palindromic times between t1 and t2, inclusive of t1 and t2. >>> count_palindromic_times(\\"0100\\", \\"0400\\") 3 >>> count_palindromic_times(\\"0959\\", \\"1010\\") 1","solution":"def count_palindromic_times(t1: str, t2: str) -> int: def is_palindrome(s): return s == s[::-1] def increment_time(hhmm): hh, mm = int(hhmm[:2]), int(hhmm[2:]) mm += 1 if mm == 60: mm = 0 hh += 1 if hh == 13: hh = 1 return f\\"{hh:02}{mm:02}\\" count = 0 current_time = t1 while current_time <= t2: if is_palindrome(current_time): count += 1 current_time = increment_time(current_time) return count"},{"question":"def max_red_tiles(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determines the maximum number of red tiles that can be placed in each grid while adhering to the festival rules. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers representing the number of rows and columns. Returns: list of int: A list of integers where each integer is the answer for the corresponding test case. >>> max_red_tiles(3, [(4, 5), (6, 6), (3, 2)]) [4, 6, 2] >>> max_red_tiles(1, [(10, 15)]) [10] >>> max_red_tiles(1, [(1, 1)]) [1] >>> max_red_tiles(2, [(1000, 1000), (100, 500)]) [1000, 100] >>> max_red_tiles(4, [(5, 3), (7, 10), (2, 2), (12, 8)]) [3, 7, 2, 8]","solution":"def max_red_tiles(t, test_cases): Determines the maximum number of red tiles that can be placed in each grid while adhering to the festival rules. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers representing the number of rows and columns. Returns: list of int: A list of integers where each integer is the answer for the corresponding test case. results = [] for n, m in test_cases: results.append(min(n, m)) return results"},{"question":"def minimized_max_jump_permutation(n: int) -> list: Returns the permutation of integers from 1 to n such that the maximum jump between consecutive elements is minimized. >>> minimized_max_jump_permutation(1) [1] >>> minimized_max_jump_permutation(2) [1, 2] >>> minimized_max_jump_permutation(4) [1, 3, 2, 4] >>> minimized_max_jump_permutation(5) [1, 3, 5, 2, 4] >>> minimized_max_jump_permutation(6) [1, 3, 5, 2, 4, 6] >>> minimized_max_jump_permutation(7) [1, 3, 5, 7, 2, 4, 6]","solution":"def minimized_max_jump_permutation(n): Returns the permutation of integers from 1 to n such that the maximum jump between consecutive elements is minimized. result = [] for i in range(1, n + 1, 2): result.append(i) for i in range(2, n + 1, 2): result.append(i) return result"},{"question":"def min_operations(start: str, target: str) -> int: Returns the minimum number of operations required to transform the start string into the target string. >>> min_operations(\\"horse\\", \\"ros\\") 3 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"\\", \\"\\") 0 >>> min_operations(\\"abc\\", \\"def\\") 3 >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"a\\" * 1000, \\"b\\" * 1000) 1000","solution":"def min_operations(start, target): Returns the minimum number of operations required to transform the start string into the target string. m, n = len(start), len(target) # Create a DP table to store the edit distance dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): # If the characters are the same, no operation is required if start[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: # If characters are different, consider all operations (insert, remove, replace) dp[i][j] = min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1] # Replace ) + 1 return dp[m][n]"},{"question":"def min_platforms(trains: List[Tuple[int, int]]) -> int: Determines the minimum number of platforms required for the given train schedules. :param trains: List of tuples, where each tuple consists of start and end times of a train :return: Minimum number of platforms required >>> min_platforms([]) 0 >>> min_platforms([(900, 920)]) 1 >>> min_platforms([(900, 940), (950, 1000)]) 1 >>> min_platforms([(900, 940), (930, 1000), (950, 1100)]) 2 >>> min_platforms([(900, 910), (940, 1200), (950, 1100), (1500, 1900), (1800, 2000), (1830, 1930)]) 3 >>> min_platforms([(900, 1200), (945, 1100), (1000, 1030)]) 3","solution":"def min_platforms(trains): Determines the minimum number of platforms required for the given train schedules. :param trains: List of tuples, where each tuple consists of start and end times of a train :return: Minimum number of platforms required if not trains: return 0 # Extract start and end times start_times = sorted([train[0] for train in trains]) end_times = sorted([train[1] for train in trains]) n = len(trains) platforms_needed = 0 max_platforms = 0 i, j = 0, 0 # Traverse arrival and departure arrays while (i < n and j < n): if start_times[i] <= end_times[j]: platforms_needed += 1 i += 1 if platforms_needed > max_platforms: max_platforms = platforms_needed else: platforms_needed -= 1 j += 1 return max_platforms # Example usage trains = [(900, 940), (950, 1100), (930, 1000)] print(min_platforms(trains)) # Output should be 2"},{"question":"def validate_password(password: str) -> str: Validates if the given password meets the criteria: - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit - Length is between 6 and 12 characters inclusive If the password meets the requirements, returns \\"Valid Password\\". Otherwise, returns \\"Invalid Password\\". >>> validate_password(\\"Password123\\") 'Valid Password' >>> validate_password(\\"pass\\") 'Invalid Password'","solution":"def validate_password(password): Validates if the given password meets the criteria: - Contains at least one lowercase letter - Contains at least one uppercase letter - Contains at least one digit - Length is between 6 and 12 characters inclusive if not (6 <= len(password) <= 12): return \\"Invalid Password\\" has_lower = any(c.islower() for c in password) has_upper = any(c.isupper() for c in password) has_digit = any(c.isdigit() for c in password) if has_lower and has_upper and has_digit: return \\"Valid Password\\" return \\"Invalid Password\\""},{"question":"def count_resolved_tickets(tickets): Returns the number of resolved tickets. tickets (list of str): List of support ticket operations strings. A ticket is resolved if it contains at least one 'R'. >>> count_resolved_tickets([\\"R\\", \\"R\\", \\"R\\"]) == 3 >>> count_resolved_tickets([\\"UUD\\", \\"DDD\\", \\"UUU\\"]) == 0 >>> count_resolved_tickets([\\"UURD\\", \\"DDUURR\\", \\"UUUU\\"]) == 2 >>> count_resolved_tickets([\\"UURD\\"]) == 1 >>> count_resolved_tickets([\\"UUUD\\"]) == 0 >>> count_resolved_tickets([\\"URURDD\\", \\"UDRRR\\", \\"URUR\\", \\"DRR\\", \\"UUUD\\"]) == 4 >>> count_resolved_tickets([]) == 0","solution":"def count_resolved_tickets(tickets): Returns the number of resolved tickets. tickets (list of str): List of support ticket operations strings. A ticket is resolved if it contains at least one 'R'. resolved_count = 0 for ticket in tickets: if 'R' in ticket: resolved_count += 1 return resolved_count # Example usage: # tickets = [\\"UURD\\", \\"DDUURR\\", \\"UUUU\\"] # print(count_resolved_tickets(tickets)) # Output: 2"},{"question":"def minimum_removals_to_alternate(s: str) -> int: Returns the minimum number of characters needed to be removed to make the string alternating. >>> minimum_removals_to_alternate(\\"01110\\") 2 >>> minimum_removals_to_alternate(\\"0001\\") 2 >>> minimum_removals_to_alternate(\\"101010\\") 0","solution":"def minimum_removals_to_alternate(s): Returns the minimum number of characters needed to be removed to make the string alternating. count = 0 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 return count"},{"question":"from typing import List, Tuple def verify_unique_shortest_paths(n: int, m: int, edges: List[Tuple[int, int, int]]) -> str: Determine if each station other than the entrance is reachable by exactly one shortest path from the entrance. >>> verify_unique_shortest_paths(4, 4, [(1, 2, 1), (2, 3, 2), (1, 3, 2), (3, 4, 1)]) == \\"YES\\" >>> verify_unique_shortest_paths(5, 6, [(1, 2, 3), (2, 3, 4), (1, 3, 7), (3, 4, 1), (4, 5, 2), (3, 5, 3)]) == \\"NO\\" def test_example_1(): n = 4 m = 4 edges = [ (1, 2, 1), (2, 3, 2), (1, 3, 2), (3, 4, 1), ] assert verify_unique_shortest_paths(n, m, edges) == \\"YES\\" def test_example_2(): n = 5 m = 6 edges = [ (1, 2, 3), (2, 3, 4), (1, 3, 7), (3, 4, 1), (4, 5, 2), (3, 5, 3), ] assert verify_unique_shortest_paths(n, m, edges) == \\"NO\\" def test_single_edge(): n = 2 m = 1 edges = [ (1, 2, 5), ] assert verify_unique_shortest_paths(n, m, edges) == \\"YES\\" def test_multiple_shortest_paths(): n = 4 m = 5 edges = [ (1, 2, 1), (2, 3, 1), (1, 3, 2), (1, 4, 3), (3, 4, 1), ] assert verify_unique_shortest_paths(n, m, edges) == \\"NO\\" def test_tree_structure(): n = 7 m = 6 edges = [ (1, 2, 1), (1, 3, 1), (2, 4, 1), (2, 5, 1), (3, 6, 1), (3, 7, 1), ] assert verify_unique_shortest_paths(n, m, edges) == \\"YES\\"","solution":"import heapq import collections def verify_unique_shortest_paths(n, m, edges): graph = collections.defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) distances = [float('inf')] * (n + 1) path_count = [0] * (n + 1) distances[1] = 0 path_count[1] = 1 min_heap = [(0, 1)] while min_heap: curr_dist, u = heapq.heappop(min_heap) if curr_dist > distances[u]: continue for v, weight in graph[u]: distance = curr_dist + weight if distance < distances[v]: distances[v] = distance path_count[v] = path_count[u] heapq.heappush(min_heap, (distance, v)) elif distance == distances[v]: path_count[v] += path_count[u] for i in range(2, n + 1): if path_count[i] != 1: return \\"NO\\" return \\"YES\\""},{"question":"def find_max_path_length(n: int, k: int, edges: List[Tuple[int, int]]) -> Tuple[int, str]: Determines the maximum path length between the farthest pair of routers in the network and whether this length is within the given threshold. Parameters: - n (int): The number of routers (nodes) - k (int): The threshold length - edges (List[Tuple[int, int]]): List of direct connections between routers Returns: - Tuple[int, str]: The maximum path length and \\"YES\\" if within threshold, otherwise \\"NO\\" Example: >>> find_max_path_length(5, 4, [(1, 2), (1, 3), (3, 4), (3, 5)]) (3, \\"YES\\") >>> find_max_path_length(6, 2, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) (5, \\"NO\\") pass from typing import List, Tuple from collections import defaultdict, deque def test_example_1(): n, k = 5, 4 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] assert find_max_path_length(n, k, edges) == (3, \\"YES\\") def test_example_2(): n, k = 6, 2 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] assert find_max_path_length(n, k, edges) == (5, \\"NO\\") def test_single_node(): n, k = 1, 0 edges = [] assert find_max_path_length(n, k, edges) == (0, \\"YES\\") def test_two_nodes_within_threshold(): n, k = 2, 1 edges = [(1, 2)] assert find_max_path_length(n, k, edges) == (1, \\"YES\\") def test_two_nodes_exceeds_threshold(): n, k = 2, 0 edges = [(1, 2)] assert find_max_path_length(n, k, edges) == (1, \\"NO\\") def test_medium_tree_with_large_threshold(): n, k = 4, 10 edges = [(1, 2), (2, 3), (3, 4)] assert find_max_path_length(n, k, edges) == (3, \\"YES\\")","solution":"from collections import deque, defaultdict def bfs(node, n, adj): dist = [-1] * (n + 1) dist[node] = 0 q = deque([node]) farthest_node = node max_dist = 0 while q: current = q.popleft() for neighbor in adj[current]: if dist[neighbor] == -1: dist[neighbor] = dist[current] + 1 q.append(neighbor) if dist[neighbor] > max_dist: max_dist = dist[neighbor] farthest_node = neighbor return farthest_node, max_dist def find_max_path_length(n, k, edges): if n == 1: return 0, \\"YES\\" if k >= 0 else \\"NO\\" adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) farthest_node, _ = bfs(1, n, adj) other_farthest_node, max_length = bfs(farthest_node, n, adj) return max_length, \\"YES\\" if max_length <= k else \\"NO\\" # Example usage: # n, k = 5, 4 # edges = [(1, 2), (1, 3), (3, 4), (3, 5)] # print(find_max_path_length(n, k, edges))"},{"question":"def construct_matrix(n: int): Design a program that takes as input a non-negative integer n (1 ≤ n ≤ 10^5) and outputs an n × n matrix with the following properties: 1. The matrix should contain exactly n distinct numbers from the range of 1 to n inclusive. 2. Each number from the range 1 to n should appear exactly once across the whole matrix. 3. The matrix should satisfy the property that the sum of each row is equal to the sum of each column. If no such matrix exists, output -1. Input: n (int) - size of the matrix Output: List[List[int]] - n x n matrix or -1 if no valid matrix exists >>> construct_matrix(3) [[1, 2, 3], [2, 3, 1], [3, 1, 2]] >>> construct_matrix(4) -1 from solution import construct_matrix def test_odd_n(): assert construct_matrix(3) == [[1, 2, 3], [2, 3, 1], [3, 1, 2]] assert construct_matrix(5) == [ [1, 2, 3, 4, 5], [2, 3, 4, 5, 1], [3, 4, 5, 1, 2], [4, 5, 1, 2, 3], [5, 1, 2, 3, 4] ] def test_even_n(): assert construct_matrix(4) == -1 assert construct_matrix(6) == -1 def test_min_n(): assert construct_matrix(1) == [[1]]","solution":"def construct_matrix(n): if n % 2 == 0: return -1 matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): matrix[i][j] = (i + j) % n + 1 return matrix"},{"question":"def check_trees(N, trees, queries): Checks if there is a tree in front of the queried houses. :param N: int, the number of houses :param trees: list of int, 1 if there's a tree, 0 otherwise :param queries: list of int, positions to check for trees :return: list of str, \\"Yes\\" if there's a tree, \\"No\\" otherwise Examples: >>> check_trees(5, [1, 0, 1, 0, 1], [1, 2, 5]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> check_trees(4, [0, 0, 1, 0], [3, 4]) [\\"Yes\\", \\"No\\"]","solution":"def check_trees(N, trees, queries): Checks if there is a tree in front of the queried houses. :param N: int, the number of houses :param trees: list of int, 1 if there's a tree, 0 otherwise :param queries: list of int, positions to check for trees :return: list of str, \\"Yes\\" if there's a tree, \\"No\\" otherwise results = [] for query in queries: if trees[query - 1] == 1: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def num_islands(grid: List[List[str]]) -> int: Given a 2D grid of 0s and 1s, returns the number of distinct islands. >>> num_islands([list(\\"11000\\"), list(\\"11000\\"), list(\\"00100\\"), list(\\"00011\\")]) == 3 >>> num_islands([list(\\"111\\"), list(\\"010\\"), list(\\"111\\")]) == 1 >>> num_islands([list(\\"000\\"), list(\\"000\\"), list(\\"000\\")]) == 0 >>> num_islands([list(\\"010\\"), list(\\"111\\"), list(\\"010\\")]) == 1 >>> num_islands([list(\\"11000\\"), list(\\"11000\\"), list(\\"00011\\"), list(\\"00011\\")]) == 2 >>> num_islands([list(\\"1000\\"), list(\\"0100\\"), list(\\"0010\\"), list(\\"0001\\")]) == 4","solution":"def num_islands(grid): Given a 2D grid of 0s and 1s, returns the number of distinct islands. if not grid: return 0 n = len(grid) m = len(grid[0]) def dfs(grid, x, y): if x < 0 or y < 0 or x >= n or y >= m or grid[x][y] == '0': return grid[x][y] = '0' # Mark the land as visited by setting it to '0' # Visit all 4-directionally connected neighbors dfs(grid, x + 1, y) dfs(grid, x - 1, y) dfs(grid, x, y + 1) dfs(grid, x, y - 1) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1': dfs(grid, i, j) island_count += 1 return island_count def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) m = int(data[1]) grid = [list(data[i + 2]) for i in range(n)] print(num_islands(grid))"},{"question":"def allocate_lockers(lockers, requests): Determines if it is possible to allocate lockers to students such that all students' requests are satisfied. Parameters: lockers (list of int): Sizes of available lockers. requests (list of int): Sizes of locker requests by students. Returns: str: \\"Yes\\" if all requests can be satisfied, \\"No\\" otherwise. def process_input(input_lines): Processes multiple test cases and returns results for each. Parameters: input_lines (list of str): Lines of input where each test case is specified in two lines. Returns: list of str: Results for each test case. from solution import allocate_lockers, process_input def test_allocate_lockers(): assert allocate_lockers([5, 10, 15, 20], [10, 15]) == \\"Yes\\" assert allocate_lockers([3, 4, 5, 6], [5, 7]) == \\"No\\" assert allocate_lockers([2, 3, 4], [1, 2, 3]) == \\"Yes\\" assert allocate_lockers([1, 1, 1], [2, 2, 2]) == \\"No\\" assert allocate_lockers([10, 20, 30], [30, 20, 10]) == \\"Yes\\" def test_process_input(): input_data = [ \\"5 10 15 20\\", \\"10 15\\", \\"3 4 5 6\\", \\"5 7\\", \\"0 0\\" ] expected_output = [\\"Yes\\", \\"No\\"] assert process_input(input_data) == expected_output input_data = [ \\"1 2 3 4 5\\", \\"1 2 3 4 5\\", \\"2 4 6\\", \\"1 5\\", \\"0 0\\" ] expected_output = [\\"Yes\\", \\"Yes\\"] assert process_input(input_data) == expected_output def test_allocate_lockers_edge_cases(): assert allocate_lockers([], []) == \\"Yes\\" assert allocate_lockers([5], [5]) == \\"Yes\\" assert allocate_lockers([1], [1, 1]) == \\"No\\" assert allocate_lockers([9, 8, 7, 6], [6, 7, 8, 9]) == \\"Yes\\" assert allocate_lockers([6, 7], [7, 6, 5]) == \\"No\\"","solution":"def allocate_lockers(lockers, requests): Determines if it is possible to allocate lockers to students such that all students' requests are satisfied. Parameters: lockers (list of int): Sizes of available lockers. requests (list of int): Sizes of locker requests by students. Returns: str: \\"Yes\\" if all requests can be satisfied, \\"No\\" otherwise. lockers.sort() requests.sort() locker_index = 0 request_index = 0 while request_index < len(requests) and locker_index < len(lockers): if lockers[locker_index] >= requests[request_index]: request_index += 1 locker_index += 1 if request_index == len(requests): return \\"Yes\\" else: return \\"No\\" def process_input(input_lines): Processes multiple test cases and returns results for each. Parameters: input_lines (list of str): Lines of input where each test case is specified in two lines. Returns: list of str: Results for each test case. results = [] i = 0 while i < len(input_lines): if input_lines[i] == \\"0 0\\": break lockers = list(map(int, input_lines[i].split())) requests = list(map(int, input_lines[i+1].split())) results.append(allocate_lockers(lockers, requests)) i += 2 return results"},{"question":"from typing import List def maximal_rectangle(matrix: List[List[int]]) -> int: Returns the area of the largest rectangle containing all 1's in a binary matrix. >>> maximal_rectangle([ ... [1, 0, 1, 0], ... [1, 0, 1, 1], ... [1, 1, 1, 1], ... [1, 0, 0, 1] ... ]) 4 >>> maximal_rectangle([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9 >>> maximal_rectangle([]) 0 >>> maximal_rectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> maximal_rectangle([ ... [0, 1, 0, 1, 1, 1, 0, 1] ... ]) 3 >>> maximal_rectangle([ ... [1], ... [1], ... [0], ... [1], ... [1], ... [1] ... ]) 3","solution":"def maximal_rectangle(matrix): Returns the area of the largest rectangle containing all 1's in a binary matrix. if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * (N + 1) for i in range(M): for j in range(N): heights[j] = heights[j] + 1 if matrix[i][j] == 1 else 0 stack = [-1] for k in range(N + 1): while heights[k] < heights[stack[-1]]: h = heights[stack.pop()] w = k - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(k) return max_area"},{"question":"from typing import List def min_steps_to_treasure(n: int, m: int, grid: List[str]) -> int: Find the minimum number of steps required to reach the treasure 'T' from the start position 'S' in a grid. Return -1 if there is no valid path. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): Grid represented as a list of strings. Returns: int: Minimum number of steps to reach the treasure or -1 if there is no path. Examples: >>> min_steps_to_treasure(3, 3, [\\"S..\\", \\".#.\\", \\"..T\\"]) 4 >>> min_steps_to_treasure(3, 4, [\\"S#\\", \\"#..#\\", \\"#..T\\"]) -1","solution":"from collections import deque def min_steps_to_treasure(n, m, grid): # directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_within_bounds(x, y): return 0 <= x < n and 0 <= y < m # Find the starting position 'S' and treasure 'T' start = None end = None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'T': end = (i, j) if not start or not end: return -1 # BFS to find the minimum steps queue = deque([(start[0], start[1], 0)]) # (x, y, steps) visited = set() visited.add(start) while queue: x, y, steps = queue.popleft() # If reached the treasure if (x, y) == end: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny) and grid[nx][ny] != '#' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def process_requests(n: int, requests: List[int]) -> Tuple[List[int], int]: Processes the requests in such a way that no two consecutive requests are identical. Parameters: n (int): The number of requests. requests (list of int): The list of requests. Returns: tuple: A tuple containing the processed request list and the number of requests that were skipped. >>> process_requests(8, [1, 2, 2, 3, 4, 4, 5, 5]) ([1, 2, 3, 4, 5], 3) >>> process_requests(5, [1, 1, 1, 1, 1]) ([1], 4) >>> process_requests(6, [1, 2, 3, 4, 5, 6]) ([1, 2, 3, 4, 5, 6], 0) >>> process_requests(3, [1, 2, 3]) ([1, 2, 3], 0) >>> process_requests(5, [1, 3, 1, 3, 1]) ([1, 3, 1, 3, 1], 0) >>> process_requests(1, [10]) ([10], 0)","solution":"def process_requests(n, requests): Processes the requests in such a way that no two consecutive requests are identical. Parameters: n (int): The number of requests. requests (list of int): The list of requests. Returns: tuple: A tuple containing the processed request list and the number of requests that were skipped. processed = [] skipped_count = 0 for i in range(n): if not processed or processed[-1] != requests[i]: processed.append(requests[i]) else: skipped_count += 1 return processed, skipped_count"},{"question":"def largest_group_size(employees: int) -> int: Returns the size of the largest possible groups such that no employee is left ungrouped. Parameters: employees (int): The total number of employees Returns: int: The size of the largest possible groups pass # Unit tests def test_case_1(): assert largest_group_size(10) == 5 def test_case_2(): assert largest_group_size(15) == 5 def test_case_3(): assert largest_group_size(25) == 5 def test_minimum_employees(): assert largest_group_size(2) == 1 def test_prime_number_of_employees(): assert largest_group_size(13) == 1 def test_even_number_of_employees(): assert largest_group_size(20) == 10 def test_large_number_of_employees(): assert largest_group_size(1000000) == 500000 # Running the test cases if __name__ == \\"__main__\\": test_case_1() test_case_2() test_case_3() test_minimum_employees() test_prime_number_of_employees() test_even_number_of_employees() test_large_number_of_employees() print(\\"All tests passed\\")","solution":"def largest_group_size(employees): Returns the size of the largest possible groups such that no employee is left ungrouped. Parameters: employees (int): The total number of employees Returns: int: The size of the largest possible groups # We start checking from the half of the total employees downwards for size in range(employees // 2, 0, -1): if employees % size == 0: return size"},{"question":"class ArrayOperations: def __init__(self, n, arr): Initialize the object with array length and the array itself :param n: Length of the array :param arr: List of integers representing the array def increment_range(self, l, r, v): Increment all elements from index l to r by v :param l: Start index of range :param r: End index of range :param v: Value to increment by def find_max_value(self, l, r): Find the maximum value of elements from index l to r :param l: Start index of range :param r: End index of range :return: Maximum value in the specified range def set_value(self, pos, val): Set the value of array at index pos to val :param pos: Index position to set value :param val: Value to set at the position def process_queries(n, q, arr, queries): Process the list of queries against the provided array :param n: Length of the array :param q: Number of queries :param arr: List of integers representing the array :param queries: List of queries to process :return: List of results for \\"find maximum value\\" queries # Unit Test import pytest from solution import ArrayOperations, process_queries def test_increment_range(): arr_ops = ArrayOperations(10, [5, 1, 9, 3, 7, 6, 4, 8, 2, 0]) arr_ops.increment_range(2, 5, 3) assert arr_ops.arr == [5, 1, 12, 6, 10, 9, 4, 8, 2, 0] def test_find_max_value(): arr_ops = ArrayOperations(10, [5, 1, 9, 3, 7, 6, 4, 8, 2, 0]) assert arr_ops.find_max_value(1, 6) == 9 arr_ops.increment_range(2, 5, 3) assert arr_ops.find_max_value(1, 6) == 12 def test_set_value(): arr_ops = ArrayOperations(10, [5, 1, 9, 3, 7, 6, 4, 8, 2, 0]) arr_ops.set_value(4, 10) assert arr_ops.arr[4] == 10 def test_process_queries(): n = 10 q = 4 arr = [5, 1, 9, 3, 7, 6, 4, 8, 2, 0] queries = [ \\"0 2 5 3\\", \\"1 1 6\\", \\"2 4 10\\", \\"1 3 6\\" ] result = process_queries(n, q, arr, queries) assert result == [12, 10] pytest.main()","solution":"class ArrayOperations: def __init__(self, n, arr): self.n = n self.arr = arr def increment_range(self, l, r, v): for i in range(l, r + 1): self.arr[i] += v def find_max_value(self, l, r): return max(self.arr[l:r + 1]) def set_value(self, pos, val): self.arr[pos] = val def process_queries(n, q, arr, queries): results = [] array_ops = ArrayOperations(n, arr) for query in queries: parts = list(map(int, query.split())) if parts[0] == 0: array_ops.increment_range(parts[1], parts[2], parts[3]) elif parts[0] == 1: results.append(array_ops.find_max_value(parts[1], parts[2])) elif parts[0] == 2: array_ops.set_value(parts[1], parts[2]) return results"},{"question":"def process_string_operations(s: str, q: int, operations: List[str]) -> str: Simulates the process where Bob applies a series of string operations. Parameters: s (str): Initial string. q (int): Number of operations. operations (list of str): List of operations to be performed. Returns: str: Final state of the string after all operations. Examples: >>> process_string_operations(\\"abc\\", 3, [\\"Insert 2 d\\", \\"Delete 1\\", \\"Replace 2 x\\"]) 'dxc' >>> process_string_operations(\\"hello\\", 2, [\\"Replace 1 y\\", \\"Delete 5\\"]) 'yell'","solution":"def process_string_operations(s, q, operations): Simulates the process where Bob applies a series of string operations. Parameters: s (str): Initial string. q (int): Number of operations. operations (list of str): List of operations to be performed. Returns: str: Final state of the string after all operations. s = list(s) # Convert string to list for easier manipulation for operation in operations: parts = operation.split() if parts[0] == 'Insert': position = int(parts[1]) - 1 character = parts[2] s.insert(position, character) elif parts[0] == 'Delete': position = int(parts[1]) - 1 s.pop(position) elif parts[0] == 'Replace': position = int(parts[1]) - 1 character = parts[2] s[position] = character return ''.join(s)"},{"question":"def count_connected_components(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Determine the number of connected components in an undirected graph. Args: n (int): Number of nodes. m (int): Number of edges. edges (List[Tuple[int, int]]): List of edges as tuples (u, v). Returns: int: Number of connected components. >>> count_connected_components(6, 3, [(1, 2), (2, 3), (4, 5)]) 3 >>> count_connected_components(5, 0, []) 5 >>> count_connected_components(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> count_connected_components(4, 2, [(1, 2), (3, 4)]) 2 >>> count_connected_components(1, 0, []) 1 >>> count_connected_components(3, 3, [(1, 2), (2, 3), (1, 3)]) 1","solution":"def count_connected_components(n, m, edges): from collections import defaultdict, deque graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() components = 0 def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) for node in range(1, n + 1): if node not in visited: visited.add(node) bfs(node) components += 1 return components # Example usage: # n, m = 6, 3 # edges = [(1, 2), (2, 3), (4, 5)] # print(count_connected_components(n, m, edges)) # Output: 3"},{"question":"def count_distinct_books(n: int, book_identifiers: List[int]) -> int: Returns the number of distinct book identifiers in the list. Parameters: n (int): Number of book identifiers. book_identifiers (list of int): List of book identifiers. Returns: int: Number of distinct book identifiers. >>> count_distinct_books(6, [1, 2, 1, 3, 2, 4]) 4 >>> count_distinct_books(4, [5, 5, 5, 5]) 1","solution":"def count_distinct_books(n, book_identifiers): Returns the number of distinct book identifiers in the list. Parameters: n (int): Number of book identifiers. book_identifiers (list of int): List of book identifiers. Returns: int: Number of distinct book identifiers. return len(set(book_identifiers))"},{"question":"from typing import List def detect_duplicates(ads: List[str]) -> List[int]: The function detects duplicate advertisements. An advertisement is considered a duplicate if it is a rearrangement of the words in another advertisement from the list. Args: ads (List[str]): A list of advertisements. Returns: List[int]: A list of integers where each integer represents the index of the first duplicate ad or -1 if there is no duplicate. Examples: >>> detect_duplicates([\\"Buy milk\\", \\"milk Buy\\", \\"Sell car\\", \\"car Sell\\", \\"sell CAR\\"]) [-1, 0, -1, 2, -1] >>> detect_duplicates([\\"the quick brown fox\\", \\"fox brown quick the\\", \\"lazy dog\\", \\"dog lazy\\", \\"quick brown Fox\\"]) [-1, 0, -1, 2, -1]","solution":"from typing import List def normalize_ad(ad: str) -> str: # Normalize by sorting words words = ad.split() words.sort() return \\" \\".join(words) def detect_duplicates(ads: List[str]) -> List[int]: seen_ads = {} duplicates = [-1] * len(ads) for i, ad in enumerate(ads): normalized_ad = normalize_ad(ad) if normalized_ad in seen_ads: duplicates[i] = seen_ads[normalized_ad] else: seen_ads[normalized_ad] = i return duplicates"},{"question":"def max_concurrent_users(n: int, sessions: List[Tuple[int, int, int]]) -> int: Calculate the maximum number of concurrent users. Args: n (int): number of user sessions sessions (list of tuples): list of (userId, startTime, endTime) Returns: int: maximum number of concurrent users >>> max_concurrent_users(5, [(1, 1, 4), (2, 2, 5), (3, 8, 10), (4, 3, 7), (5, 6, 9)]) 3 >>> max_concurrent_users(0, []) 0 >>> max_concurrent_users(1, [(1, 1, 2)]) 1 >>> max_concurrent_users(3, [(1, 1, 2), (2, 3, 4), (3, 5, 6)]) 1 >>> max_concurrent_users(3, [(1, 1, 5), (2, 1, 5), (3, 1, 5)]) 3 >>> max_concurrent_users(4, [(1, 1, 3), (2, 2, 4), (3, 3, 5), (4, 4, 6)]) 3","solution":"def max_concurrent_users(n, sessions): Calculate the maximum number of concurrent users. Args: n (int): number of user sessions sessions (list of tuples): list of (userId, startTime, endTime) Returns: int: maximum number of concurrent users events = [] for session in sessions: userId, startTime, endTime = session events.append((startTime, 'start')) events.append((endTime + 1, 'end')) events.sort() max_concurrent = 0 concurrent = 0 for event in events: if event[1] == 'start': concurrent += 1 if concurrent > max_concurrent: max_concurrent = concurrent else: concurrent -= 1 return max_concurrent # Sample Input and Output n = 5 sessions = [ (1, 1, 4), (2, 2, 5), (3, 8, 10), (4, 3, 7), (5, 6, 9) ] print(max_concurrent_users(n, sessions)) # Expected output: 3"},{"question":"def numDistinct(s: str, t: str) -> int: Write a program that finds the number of distinct subsequences of a given string \`s\` that are equal to another given string \`t\`. >>> numDistinct(\\"rabbbit\\", \\"rabbit\\") 3 >>> numDistinct(\\"babgbag\\", \\"bag\\") 5 >>> numDistinct(\\"abc\\", \\"\\") 1 >>> numDistinct(\\"\\", \\"abc\\") 0 >>> numDistinct(\\"abc\\", \\"abc\\") 1 >>> numDistinct(\\"abc\\", \\"xyz\\") 0","solution":"def numDistinct(s, t): Returns the number of distinct subsequences of s that are equal to t. # Initialize a 2D table with (len(s) + 1) x (len(t) + 1) size with zeros dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)] # Fill the first column with 1, because any string has exactly one subsequence which is the empty string \\"\\" for i in range(len(s) + 1): dp[i][0] = 1 # Fill the dp table for i in range(1, len(s) + 1): for j in range(1, len(t) + 1): if s[i-1] == t[j-1]: # If the characters match, add the count of subsequences both including and excluding the current character dp[i][j] = dp[i-1][j-1] + dp[i-1][j] else: # If the characters don't match, carry forward the count from the previous character of s dp[i][j] = dp[i-1][j] # The answer will be in the bottom-right cell of the dp table return dp[len(s)][len(t)]"},{"question":"def bus_wait_time(n: int, bus_times: List[int], t: int) -> int: Determines the waiting time to catch a bus or elapsed time since a bus left. Parameters: n (int): The number of buses bus_times (List[int]): The arrival times of buses in minutes t (int): The arrival time of the person in minutes Returns: int: The waiting time if the person catches a bus, or the elapsed time if they miss it. Example: >>> bus_wait_time(5, [15, 30, 45, 60, 75], 20) 10 >>> bus_wait_time(3, [720, 960, 1140], 700) 20","solution":"def bus_wait_time(n, bus_times, t): Determines the waiting time to catch a bus or elapsed time since a bus left. Parameters: n (int): The number of buses bus_times (List[int]): The arrival times of buses in minutes t (int): The arrival time of the person in minutes Returns: int: The waiting time if the person catches a bus, or the elapsed time if they miss it. for bus_time in bus_times: if bus_time >= t: return bus_time - t return t - bus_times[-1]"},{"question":"def reduce_string(s: str) -> str: Reduces the string by repeatedly removing adjacent pairs of equal characters. If the final string is empty, returns \\"Empty String\\". >>> reduce_string('abba') 'Empty String' >>> reduce_string('abbac') 'c' >>> reduce_string('') 'Empty String' >>> reduce_string('abc') 'abc' >>> reduce_string('a' * 200000) 'Empty String' >>> reduce_string('a') 'a' >>> reduce_string('abcdefghijklmnopqrstuvwxyz') 'abcdefghijklmnopqrstuvwxyz' >>> reduce_string('abababab') 'abababab'","solution":"def reduce_string(s): Reduces the string by repeatedly removing adjacent pairs of equal characters. If the final string is empty, returns \\"Empty String\\". stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack) if stack else 'Empty String'"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. >>> longest_increasing_subsequence([4, 2, 5, 8, 6, 3]) 3 >>> longest_increasing_subsequence([10, 20, 10, 30, 50, 30, 40]) 4 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([1]) 1 >>> longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) 3 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) 4","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the array. if not arr: return 0 # Initialization of dp array dp = [1] * len(arr) # Every element is an LIS of length 1 by itself # Dynamic programming to find length of LIS for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) # The maximum value in the dp array is the answer return max(dp)"},{"question":"import math from typing import List, Tuple def calculate_stone_positions(N: int, R: int) -> List[Tuple[float, float]]: Calculates the positions of N stones to be placed on a circle with radius R. Args: N (int): Number of stones. R (int): Radius of the circle. Returns: list of tuples: List of coordinates (x, y) for each stone. Example: >>> calculate_stone_positions(4, 2) [(2.000, 0.000), (0.000, 2.000), (-2.000, 0.000), (0.000, -2.000)] >>> calculate_stone_positions(6, 3) [(3.000, 0.000), (1.500, 2.598), (-1.500, 2.598), (-3.000, 0.000), (-1.500, -2.598), (1.500, -2.598)] pass","solution":"import math def calculate_stone_positions(N, R): Calculates the positions of N stones to be placed on a circle with radius R. Args: N (int): Number of stones. R (int): Radius of the circle. Returns: list of tuples: List of coordinates (x, y) for each stone. positions = [] angle_increment = 2 * math.pi / N for i in range(N): angle = angle_increment * i x = R * math.cos(angle) y = R * math.sin(angle) positions.append((round(x, 3), round(y, 3))) return positions"},{"question":"def count_valid_ways(H: int, W: int, K: int, X: int, Y: int) -> int: Determine the number of valid ways to fill a 2D grid with integers such that each row contains exactly one cell with the integer X and each column contains exactly one cell with the integer Y. >>> count_valid_ways(3, 3, 3, 1, 2) 0 >>> count_valid_ways(3, 3, 3, 2, 2) 18","solution":"def count_valid_ways(H, W, K, X, Y): if X != Y: # If X and Y are different, there's no valid way since the cell with X and Y can't be positioned simultaneously. return 0 ways = 0 # Pick the row and column for number X = Y for r in range(H): for c in range(W): ways += 1 return ways # Example usage: H, W, K, X, Y = 3, 3, 3, 2, 2 print(count_valid_ways(H, W, K, X, Y)) # Output should be 18"},{"question":"def prioritize_jobs(num_jobs, jobs): Prioritize and sort jobs based on urgency and processing time. :param num_jobs: int, number of jobs :param jobs: list of tuples, where each tuple contains urgency and processing time of a job :return: list of sorted jobs based on the given criteria >>> prioritize_jobs(5, [(5, 10), (3, 15), (5, 5), (4, 20), (3, 10)]) [(5, 5), (5, 10), (4, 20), (3, 10), (3, 15)] >>> prioritize_jobs(4, [(1, 10), (1, 5), (3, 7), (4, 1)]) [(4, 1), (3, 7), (1, 5), (1, 10)] from solution import prioritize_jobs def test_prioritize_jobs_case_1(): num_jobs = 5 jobs = [(5, 10), (3, 15), (5, 5), (4, 20), (3, 10)] expected_output = [(5, 5), (5, 10), (4, 20), (3, 10), (3, 15)] assert prioritize_jobs(num_jobs, jobs) == expected_output def test_prioritize_jobs_case_2(): num_jobs = 4 jobs = [(1, 10), (1, 5), (3, 7), (4, 1)] expected_output = [(4, 1), (3, 7), (1, 5), (1, 10)] assert prioritize_jobs(num_jobs, jobs) == expected_output def test_prioritize_jobs_case_3(): num_jobs = 3 jobs = [(7, 2), (7, 1), (3, 5)] expected_output = [(7, 1), (7, 2), (3, 5)] assert prioritize_jobs(num_jobs, jobs) == expected_output def test_prioritize_jobs_case_with_same_urgency_and_time(): num_jobs = 3 jobs = [(5, 5), (5, 5), (5, 5)] expected_output = [(5, 5), (5, 5), (5, 5)] assert prioritize_jobs(num_jobs, jobs) == expected_output def test_prioritize_jobs_case_with_varied_times_same_urgency(): num_jobs = 4 jobs = [(6, 4), (6, 1), (6, 3), (6, 2)] expected_output = [(6, 1), (6, 2), (6, 3), (6, 4)] assert prioritize_jobs(num_jobs, jobs) == expected_output def test_prioritize_jobs_single_job(): num_jobs = 1 jobs = [(10, 3)] expected_output = [(10, 3)] assert prioritize_jobs(num_jobs, jobs) == expected_output","solution":"def prioritize_jobs(num_jobs, jobs): Prioritize and sort jobs based on urgency and processing time. :param num_jobs: int, number of jobs :param jobs: list of tuples, where each tuple contains urgency and processing time of a job :return: list of sorted jobs based on the given criteria # Sort jobs by urgency in descending order, then by processing time in ascending order sorted_jobs = sorted(jobs, key=lambda job: (-job[0], job[1])) return sorted_jobs"},{"question":"import sys import collections def lca_preprocess(tree, n, root=1): Preprocess the tree to calculate the up and depth table. Args: tree (defaultdict): Adjacency list representing the tree. n (int): Number of nodes in the tree. root (int): The root of the tree. Returns: tuple: up and depth lists for LCA calculation. LOG = 16 # Since 2^16 > 10^5 up = [[-1] * (LOG + 1) for _ in range(n + 1)] depth = [-1] * (n + 1) def dfs(node, parent): depth[node] = depth[parent] + 1 up[node][0] = parent for i in range(1, LOG + 1): if up[node][i-1] != -1: up[node][i] = up[up[node][i-1]][i-1] for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node) depth[root] = 0 dfs(root, -1) return up, depth def lca(up, depth, p, q): Finds the LCA of nodes p and q. Args: up (list): Up table from ancestor preprocessing. depth (list): Depth of each node. Returns: int: The LCA of nodes p and q. if depth[p] < depth[q]: p, q = q, p LOG = 16 for i in range(LOG, -1, -1): if depth[p] - (1 << i) >= depth[q]: p = up[p][i] if p == q: return p for i in range(LOG, -1, -1): if up[p][i] != -1 and up[p][i] != up[q][i]: p = up[p][i] q = up[q][i] return up[p][0] def process_input(): Process the input from stdin and calculates the LCA for given nodes. input_stream = sys.stdin.read().strip() test_cases = input_stream.split('nn') results = [] for case in test_cases: lines = case.strip().split('n') n = int(lines[0]) tree = collections.defaultdict(list) for i in range(1, n): u, v = map(int, lines[i].strip().split()) tree[u].append(v) tree[v].append(u) p, q = map(int, lines[n].strip().split()) up, depth = lca_preprocess(tree, n) results.append(str(lca(up, depth, p, q))) print('n'.join(results))","solution":"import sys import collections def lca_preprocess(tree, n, root=1): LOG = 16 # Since 2^16 > 10^5 up = [[-1] * (LOG + 1) for _ in range(n + 1)] depth = [-1] * (n + 1) def dfs(node, parent): depth[node] = depth[parent] + 1 up[node][0] = parent for i in range(1, LOG + 1): if up[node][i-1] != -1: up[node][i] = up[up[node][i-1]][i-1] for neighbor in tree[node]: if neighbor != parent: dfs(neighbor, node) depth[root] = 0 dfs(root, -1) return up, depth def lca(up, depth, p, q): if depth[p] < depth[q]: p, q = q, p LOG = 16 for i in range(LOG, -1, -1): if depth[p] - (1 << i) >= depth[q]: p = up[p][i] if p == q: return p for i in range(LOG, -1, -1): if up[p][i] != -1 and up[p][i] != up[q][i]: p = up[p][i] q = up[q][i] return up[p][0] def process_input(): input_stream = sys.stdin.read().strip() test_cases = input_stream.split('nn') results = [] for case in test_cases: lines = case.strip().split('n') n = int(lines[0]) tree = collections.defaultdict(list) for i in range(1, n): u, v = map(int, lines[i].strip().split()) tree[u].append(v) tree[v].append(u) p, q = map(int, lines[n].strip().split()) up, depth = lca_preprocess(tree, n) results.append(str(lca(up, depth, p, q))) print('n'.join(results))"},{"question":"def summarize_transactions(n: int, transactions: List[str], recDate: str) -> str: Generate a summary of the total transaction amounts per customer for a given day. Args: n (int): The number of transactions. transactions (List[str]): A list of transaction records in the format: \\"TransactionID merchantID customerID timestamp transactionAmount\\". recDate (str): The date for which the summary needs to be generated in the format \\"YYYY-MM-DD\\". Returns: str: Customer ID and their total transaction amount for the given date, sorted lexicographically by customer IDs. If no transactions are found for the given date, returns an empty string. >>> summarize_transactions(5, [ \\"txn1 mer1 cust1 2023-03-15T12:34:56 25.00\\", \\"txn2 mer2 cust2 2023-03-15T13:45:30 40.00\\", \\"txn3 mer3 cust1 2023-03-16T14:45:50 100.00\\", \\"txn4 mer4 cust2 2023-03-15T10:10:10 15.00\\", \\"txn5 mer5 cust3 2023-03-15T18:20:00 75.00\\"], \\"2023-03-15\\") \\"cust1 25.00ncust2 55.00ncust3 75.00\\" >>> summarize_transactions(2, [ \\"txn1 mer1 cust1 2023-03-16T12:34:56 25.00\\", \\"txn2 mer2 cust2 2023-03-16T13:45:30 40.00\\"], \\"2023-03-15\\") \\"\\"","solution":"def summarize_transactions(n, transactions, recDate): from collections import defaultdict customer_totals = defaultdict(float) # Iterate through the transactions and sum amounts per customer for the given date for transaction in transactions: parts = transaction.split() transaction_id, merchant_id, customer_id, timestamp, amount = parts[0], parts[1], parts[2], parts[3], float(parts[4]) transaction_date = timestamp.split('T')[0] if transaction_date == recDate: customer_totals[customer_id] += amount # Sort the dictionary by customerID lexicographically and format the result sorted_totals = sorted(customer_totals.items()) result = [] for customer_id, total in sorted_totals: result.append(f\\"{customer_id} {total:.2f}\\") return \\"n\\".join(result)"},{"question":"def process_bookings(n: int, m: int, booking_requests: List[str]) -> List[str]: Handles the booking of vehicles and returns the booking status. Args: n (int): The number of vehicles. m (int): The number of booking requests. booking_requests (List[str]): List of booking requests in the form of \\"book i start end\\". Returns: List[str]: List of responses for each booking request. >>> process_bookings(3, 5, [\\"book 1 1 5\\", \\"book 2 3 8\\", \\"book 1 2 6\\", \\"book 1 5 10\\", \\"book 3 7 10\\"]) [\\"Booking successful\\", \\"Booking successful\\", \\"Conflict\\", \\"Booking successful\\", \\"Booking successful\\"] >>> process_bookings(2, 3, [\\"book 1 1 3\\", \\"book 1 4 6\\", \\"book 2 2 5\\"]) [\\"Booking successful\\", \\"Booking successful\\", \\"Booking successful\\"] >>> process_bookings(1, 4, [\\"book 1 1 5\\", \\"book 1 2 6\\", \\"book 1 3 7\\", \\"book 1 4 8\\"]) [\\"Booking successful\\", \\"Conflict\\", \\"Conflict\\", \\"Conflict\\"] >>> process_bookings(1, 2, [\\"book 1 1 1000000000\\", \\"book 1 500000000 1000000001\\"]) [\\"Booking successful\\", \\"Conflict\\"] >>> process_bookings(1, 2, [\\"book 1 1 2\\", \\"book 1 2 3\\"]) [\\"Booking successful\\", \\"Booking successful\\"]","solution":"def process_bookings(n, m, booking_requests): vehicle_bookings = {i: [] for i in range(1, n+1)} results = [] for request in booking_requests: _, vehicle_id, start, end = request.split() vehicle_id, start, end = int(vehicle_id), int(start), int(end) conflict = False for existing_start, existing_end in vehicle_bookings[vehicle_id]: if start < existing_end and end > existing_start: conflict = True break if conflict: results.append(\\"Conflict\\") else: vehicle_bookings[vehicle_id].append((start, end)) results.append(\\"Booking successful\\") return results"},{"question":"from typing import List, Tuple def calculate_category_statistics(book_data: List[Tuple[str, int]]) -> List[Tuple[str, int, float]]: Calculate the total count and average price of books in each category. Args: book_data (List[Tuple[str, int]]): List of tuples where each tuple contains the book category and its price. Returns: List[Tuple[str, int, float]]: List of tuples where each tuple contains the category name, the total count of books in that category, and the average price of the books in that category. Examples: >>> book_data = [(\\"fiction\\", 300), (\\"science\\", 450), (\\"fiction\\", 500), (\\"history\\", 200), (\\"science\\", 300)] >>> calculate_category_statistics(book_data) [(\\"fiction\\", 2, 400.00), (\\"history\\", 1, 200.00), (\\"science\\", 2, 375.00)] >>> book_data = [(\\"philosophy\\", 600), (\\"thriller\\", 750), (\\"philosophy\\", 150)] >>> calculate_category_statistics(book_data) [(\\"philosophy\\", 2, 375.00), (\\"thriller\\", 1, 750.00)] pass def parse_input(input_data: str) -> List[Tuple[str, int]]: Parse the input data to extract book categories and their prices. Args: input_data (str): Input data in the format - n (number of books) category1 price1 category2 price2 ... categoryN priceN Returns: List[Tuple[str, int]]: List of tuples with each tuple containing a category and its price. Examples: >>> input_data = \\"5nfiction 300nscience 450nfiction 500nhistory 200nscience 300n\\" >>> parse_input(input_data) [(\\"fiction\\", 300), (\\"science\\", 450), (\\"fiction\\", 500), (\\"history\\", 200), (\\"science\\", 300)] >>> input_data = \\"3nphilosophy 600nthriller 750nphilosophy 150n\\" >>> parse_input(input_data) [(\\"philosophy\\", 600), (\\"thriller\\", 750), (\\"philosophy\\", 150)] pass def format_output(statistics: List[Tuple[str, int, float]]) -> str: Format the output statistics of book categories. Args: statistics (List[Tuple[str, int, float]]): List of tuples containing the category, count of books and average price. Returns: str: Formatted statistics ready for output display. Examples: >>> statistics = [(\\"fiction\\", 2, 400.00), (\\"history\\", 1, 200.00), (\\"science\\", 2, 375.00)] >>> format_output(statistics) \\"fiction 2 400.00nhistory 1 200.00nscience 2 375.00\\" >>> statistics = [(\\"philosophy\\", 2, 375.00), (\\"thriller\\", 1, 750.00)] >>> format_output(statistics) \\"philosophy 2 375.00nthriller 1 750.00\\" pass def main(input_data: str) -> str: Read input data, calculate statistics and format output for bookstore inventory. Args: input_data (str): Input data containing book categories and their prices. Returns: str: Formatted output containing category statistics. Examples: >>> input_data = \\"5nfiction 300nscience 450nfiction 500nhistory 200nscience 300n\\" >>> main(input_data) \\"fiction 2 400.00nhistory 1 200.00nscience 2 375.00\\" >>> input_data = \\"3nphilosophy 600nthriller 750nphilosophy 150n\\" >>> main(input_data) \\"philosophy 2 375.00nthriller 1 750.00\\" pass def test_calculate_category_statistics(): book_data = [ (\\"fiction\\", 300), (\\"science\\", 450), (\\"fiction\\", 500), (\\"history\\", 200), (\\"science\\", 300) ] expected = [ ('fiction', 2, 400.00), ('history', 1, 200.00), ('science', 2, 375.00) ] assert calculate_category_statistics(book_data) == expected def test_parse_input(): input_data = \\"5nfiction 300nscience 450nfiction 500nhistory 200nscience 300n\\" expected = [ (\\"fiction\\", 300), (\\"science\\", 450), (\\"fiction\\", 500), (\\"history\\", 200), (\\"science\\", 300) ] assert parse_input(input_data) == expected def test_format_output(): statistics = [ ('fiction', 2, 400.00), ('history', 1, 200.00), ('science', 2, 375.00) ] expected = \\"fiction 2 400.00nhistory 1 200.00nscience 2 375.00\\" assert format_output(statistics) == expected def test_integration_example_1(): input_data = \\"5nfiction 300nscience 450nfiction 500nhistory 200nscience 300n\\" expected_output = \\"fiction 2 400.00nhistory 1 200.00nscience 2 375.00\\" assert main(input_data) == expected_output def test_integration_example_2(): input_data = \\"3nphilosophy 600nthriller 750nphilosophy 150n\\" expected_output = \\"philosophy 2 375.00nthriller 1 750.00\\" assert main(input_data) == expected_output","solution":"def calculate_category_statistics(book_data): from collections import defaultdict book_counts = defaultdict(int) book_prices = defaultdict(list) for category, price in book_data: book_counts[category] += 1 book_prices[category].append(price) result = [] for category in sorted(book_counts.keys()): total_count = book_counts[category] average_price = sum(book_prices[category]) / total_count result.append((category, total_count, average_price)) return result def parse_input(input_data): lines = input_data.strip().split(\\"n\\") n = int(lines[0]) book_data = [] for line in lines[1:n+1]: category, price = line.split() book_data.append((category, int(price))) return book_data def format_output(statistics): lines = [] for category, count, avg_price in statistics: lines.append(f\\"{category} {count} {avg_price:.2f}\\") return \\"n\\".join(lines) def main(input_data): book_data = parse_input(input_data) statistics = calculate_category_statistics(book_data) return format_output(statistics)"},{"question":"def count_vowels_and_consonants(s: str) -> tuple: Given a string of lowercase English letters, returns the number of vowels and consonants in the string. >>> count_vowels_and_consonants(\\"hello\\") == (2, 3) >>> count_vowels_and_consonants(\\"programming\\") == (3, 8) >>> count_vowels_and_consonants(\\"aeiouaeiou\\") == (10, 0) >>> count_vowels_and_consonants(\\"bcdfg\\") == (0, 5) >>> count_vowels_and_consonants(\\"abcdefghijklmnopqrstuvwxyz\\") == (5, 21) >>> count_vowels_and_consonants(\\"a\\") == (1, 0) >>> count_vowels_and_consonants(\\"z\\") == (0, 1) >>> count_vowels_and_consonants(\\"\\") == (0, 0)","solution":"def count_vowels_and_consonants(s): Given a string of lowercase English letters, returns the number of vowels and consonants in the string. vowels = set(\\"aeiou\\") num_vowels = sum(1 for char in s if char in vowels) num_consonants = len(s) - num_vowels return num_vowels, num_consonants"},{"question":"def find_k_diff_pairs(nums, k): Finds the number of unique k-diff pairs in the array. Args: nums: List[int], list of integers in the array. k: int, the absolute difference between pairs. Returns: int, the number of unique k-diff pairs in the array. Examples: >>> find_k_diff_pairs([3, 1, 4, 1, 5], 2) 2 >>> find_k_diff_pairs([1, 2, 3, 4, 5], 1) 4 >>> find_k_diff_pairs([1, 3, 1, 5, 4], 0) 1","solution":"def find_k_diff_pairs(nums, k): Finds the number of unique k-diff pairs in the array. if k < 0: return 0 from collections import Counter count = 0 nums_counter = Counter(nums) if k == 0: # For k = 0, we just count the numbers that appear more than once for num, freq in nums_counter.items(): if freq > 1: count += 1 else: # For k > 0, we check for each number if num + k exists for num in nums_counter: if (num + k) in nums_counter: count += 1 return count"},{"question":"from typing import List def generate_sequences(N: int) -> List[List[int]]: Generate all distinct sequences of temperature changes of length N that result in a net cumulative change of zero. >>> generate_sequences(2) [(-10, 10), (-9, 9), (-8, 8), (-7, 7), (-6, 6), (-5, 5), (-4, 4), (-3, 3), (-2, 2), (-1, 1), (0, 0), (1, -1), (2, -2), (3, -3), (4, -4), (5, -5), (6, -6), (7, -7), (8, -8), (9, -9), (10, -10)] >>> generate_sequences(4) [(-10, -10, 10, 10), (-10, -9, 9, 10), (-10, -8, 8, 10), ..., (10, 10, -10, -10)]","solution":"from itertools import product def generate_sequences(N): # Temp changes range from -10 to 10 temperatures = range(-10, 11) all_combinations = product(temperatures, repeat=N) valid_sequences = [seq for seq in all_combinations if sum(seq) == 0] valid_sequences.sort() return valid_sequences"},{"question":"from typing import List def count_green_lights(N: int, M: int, T: int, grid: List[str], K: int) -> int: Returns the number of green lights after K seconds. :param N: Number of rows in the grid :param M: Number of columns in the grid :param T: Time interval at which traffic lights change state :param grid: Initial configuration of the grid :param K: Number of seconds after the initial configuration :return: Number of green lights after K seconds >>> count_green_lights(3, 4, 2, [\\"GRRG\\", \\"RGRG\\", \\"GRGR\\"], 6) 6 >>> count_green_lights(2, 2, 2, [\\"GG\\", \\"GG\\"], 1) 4 >>> count_green_lights(2, 2, 2, [\\"GR\\", \\"RG\\"], 2) 2 >>> count_green_lights(2, 2, 2, [\\"GR\\", \\"RG\\"], 4) 2 >>> count_green_lights(2, 2, 2, [\\"GG\\", \\"RR\\"], 10) 2 >>> count_green_lights(2, 2, 2, [\\"GR\\", \\"RG\\"], 1000000) 2","solution":"def count_green_lights(N, M, T, grid, K): Returns the number of green lights after K seconds. :param N: Number of rows in the grid :param M: Number of columns in the grid :param T: Time interval at which traffic lights change state :param grid: Initial configuration of the grid :param K: Number of seconds after the initial configuration :return: Number of green lights after K seconds # Calculate the effective time after considering full cycles (2T) effective_time = K % (2 * T) if effective_time < T: # Grid remains the same as initial or toggled once if within the first cycle final_grid = grid else: # Grid toggled once if within the second cycle final_grid = [[\\"R\\" if cell == \\"G\\" else \\"G\\" for cell in row] for row in grid] # Count the number of green lights in the final grid configuration green_count = sum(row.count('G') for row in final_grid) return green_count # Example usage: # N, M, T = 3, 4, 2 # grid = [ # \\"GRRG\\", # \\"RGRG\\", # \\"GRGR\\" # ] # K = 6 # print(count_green_lights(N, M, T, grid, K)) # Output: 6"},{"question":"def smallest_combination(n: int) -> str: Generate the lexicographically smallest valid combination given n. For added security, each digit can only appear once in the combination and the combination is of length n. Args: n (int): The number of digits in the combination (1 ≤ n ≤ 9). Returns: str: The lexicographically smallest valid combination of n digits. Examples: >>> smallest_combination(3) '123' >>> smallest_combination(5) '12345' # Your code here from solution import smallest_combination def test_smallest_combination_case_1(): assert smallest_combination(1) == \\"1\\" def test_smallest_combination_case_3(): assert smallest_combination(3) == \\"123\\" def test_smallest_combination_case_5(): assert smallest_combination(5) == \\"12345\\" def test_smallest_combination_case_9(): assert smallest_combination(9) == \\"123456789\\" def test_smallest_combination_cases_all_n(): for n in range(1, 10): expected = ''.join(str(i) for i in range(1, n+1)) assert smallest_combination(n) == expected","solution":"def smallest_combination(n: int) -> str: Returns the lexicographically smallest combination of n digits where each digit from 1 to n appears exactly once. return ''.join(str(i) for i in range(1, n+1))"},{"question":"def kth_smallest_after_operations(initial_list: List[int], operations: List[str], queries: List[int]) -> List[int]: Perform add/remove operations on initial list and find K-th smallest number for each query. Parameters: initial_list (List[int]): A list of N integers. operations (List[str]): A list of M operations (\\"ADD x\\" or \\"REMOVE x\\") to perform on the initial list. queries (List[int]): A list of Q integers where each integer K represents a query asking for the K-th smallest number in the current list. Returns: List[int]: A list of Q integers where each integer is the result of the corresponding query. Examples: >>> kth_smallest_after_operations( [1, 5, 3, 3, 2], [\\"ADD 4\\", \\"REMOVE 3\\", \\"ADD 6\\"], [1, 3] ) [1, 3] >>> kth_smallest_after_operations( [7, 10, 15, 20], [\\"ADD 8\\", \\"REMOVE 20\\"], [2] ) [8] >>> kth_smallest_after_operations( [1, 2, 3], [\\"REMOVE 4\\", \\"ADD 5\\", \\"ADD 7\\", \\"REMOVE 3\\"], [1, 2, 3] ) [1, 2, 5]","solution":"def kth_smallest_after_operations(initial_list, operations, queries): # Perform operations for op in operations: command, num = op.split() num = int(num) if command == \\"ADD\\": initial_list.append(num) elif command == \\"REMOVE\\" and num in initial_list: initial_list.remove(num) # Sorting the list after all operations are done initial_list.sort() # Answering queries result = [] for k in queries: result.append(initial_list[k-1]) return result"},{"question":"from typing import List def rearrange_temperatures(temperatures: List[int]) -> List[int]: Rearranges the temperatures such that the absolute difference between any two consecutive months is minimized. >>> rearrange_temperatures([30, 10, 20, 25, 15, 35, 40, 45, 50, 55, 5, 60]) [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60] >>> rearrange_temperatures([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]) [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]","solution":"def rearrange_temperatures(temperatures): Rearranges the temperatures such that the absolute difference between any two consecutive months is minimized. return sorted(temperatures)"},{"question":"def smallest_lexicographical_string(s: str) -> str: Determine the smallest lexicographical string that can be obtained by removing exactly one character from the original string. >>> smallest_lexicographical_string(\\"abcd\\") \\"abc\\" >>> smallest_lexicographical_string(\\"cbacd\\") \\"bacd\\"","solution":"def smallest_lexicographical_string(s): min_string = s[1:] # Initial smallest string by removing the first character for i in range(len(s)): # Create a new string by skipping the character at index i current_string = s[:i] + s[i+1:] # Update min_string if a smaller string is found if current_string < min_string: min_string = current_string return min_string"},{"question":"def process_population_queries(n: int, q: int, queries: List[List[int]]) -> List[int]: Processes a sequence of population change queries and returns the results for the range queries. Args: n (int): Number of days to track. q (int): Number of queries to process. queries (List[List[int]]): List of queries, where each query is a list of integers. Returns: List[int]: List of results for each range query. Example: >>> process_population_queries(5, 5, [[1, 2, 100], [1, 3, -50], [2, 1, 5], [1, 4, 30], [2, 2, 4]]) [50, 80] pass from typing import List def test_sample_case(): n = 5 q = 5 queries = [ [1, 2, 100], [1, 3, -50], [2, 1, 5], [1, 4, 30], [2, 2, 4] ] assert process_population_queries(n, q, queries) == [50, 80] def test_one_day(): n = 1 q = 3 queries = [ [1, 1, 1000], [2, 1, 1], [1, 1, -500], ] assert process_population_queries(n, q, queries) == [1000] def test_no_population_change(): n = 5 q = 4 queries = [ [2, 1, 5], [1, 3, 0], [2, 2, 4], [2, 3, 3] ] assert process_population_queries(n, q, queries) == [0, 0, 0] def test_multiple_population_additions(): n = 3 q = 4 queries = [ [1, 1, 500], [1, 2, -300], [1, 3, 100], [2, 1, 3] ] assert process_population_queries(n, q, queries) == [300] def test_no_queries(): n = 5 q = 0 queries = [] assert process_population_queries(n, q, queries) == []","solution":"def process_population_queries(n, q, queries): days = [0] * (n + 1) results = [] for query in queries: t = query[0] if t == 1: d, p = query[1], query[2] days[d] += p elif t == 2: s, e = query[1], query[2] results.append(sum(days[s:e + 1])) return results"},{"question":"def construct_complete_binary_tree(h: int) -> List[List[int]]: Construct a complete binary tree of height h and return the node indices level by level. >>> construct_complete_binary_tree(1) [[1]] >>> construct_complete_binary_tree(2) [[1], [2, 3]] >>> construct_complete_binary_tree(3) [[1], [2, 3], [4, 5, 6, 7]] >>> construct_complete_binary_tree(4) [[1], [2, 3], [4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14, 15]]","solution":"def construct_complete_binary_tree(h): if h < 1 or h > 10: raise ValueError(\\"Height of the tree must be between 1 and 10 inclusive.\\") result = [] current_num = 1 for i in range(h): level_size = 2 ** i level = [] for j in range(level_size): level.append(current_num) current_num += 1 result.append(level) return result"},{"question":"from collections import defaultdict, Counter class WordPredictor: def __init__(self): Initializes the WordPredictor instance. self.ngrams = defaultdict(Counter) def train(self, sentences): Trains the predictor with the given sentences. Args: sentences (List[str]): A list of sentences used for training. pass def predict(self, sequence): Predicts the most probable next word for the given sequence. Args: sequence (str): The sequence of words for which the next word is to be predicted. Returns: str: The predicted next word, or 'unknown' if prediction is not possible. pass def main(): Main function to run the word predictor model. Reads input in the specified format and processes each test case. pass if __name__ == \\"__main__\\": main() def test_word_predictor_base_case(): predictor = WordPredictor() sentences = [ \\"the quick brown fox\\", \\"the quick brown\\", \\"lazy dog sleeps\\", \\"quick brown dog\\" ] predictor.train(sentences) assert predictor.predict(\\"the quick\\") == \\"brown\\" assert predictor.predict(\\"brown dog\\") == \\"unknown\\" assert predictor.predict(\\"lazy\\") == \\"dog\\" assert predictor.predict(\\"fox\\") == \\"unknown\\" def test_word_predictor_no_data(): predictor = WordPredictor() sentences = [] predictor.train(sentences) assert predictor.predict(\\"any sequence\\") == \\"unknown\\" def test_word_predictor_conflict(): predictor = WordPredictor() sentences = [ \\"a b c\\", \\"a b d\\", \\"a b e\\" ] predictor.train(sentences) assert predictor.predict(\\"a b\\") == \\"c\\" def test_word_predictor_single_word(): predictor = WordPredictor() sentences = [ \\"hello world\\", \\"hello there\\", \\"hello everyone\\" ] predictor.train(sentences) assert predictor.predict(\\"hello\\") == \\"everyone\\"","solution":"from collections import defaultdict, Counter class WordPredictor: def __init__(self): self.ngrams = defaultdict(Counter) def train(self, sentences): for sentence in sentences: words = sentence.split() for i in range(len(words) - 1): self.ngrams[tuple(words[:i+1])][words[i+1]] += 1 def predict(self, sequence): words = sequence.split() key = tuple(words) if key not in self.ngrams: return \\"unknown\\" possible_next_words = self.ngrams[key] if not possible_next_words: return \\"unknown\\" max_count = max(possible_next_words.values()) candidates = [word for word, count in possible_next_words.items() if count == max_count] return min(candidates) def main(): import sys input = sys.stdin.read data = input().split(\\"n\\") n = int(data[0]) sentences = data[1:n+1] m = int(data[n+1]) test_cases = data[n+2:n+2+m] predictor = WordPredictor() predictor.train(sentences) results = [] for test in test_cases: results.append(predictor.predict(test)) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def manage_tasks(t: int, commands: List[str]) -> List[str]: Simulate the reassignment process and produce the final list of tasks for each employee after all assignments and reassignments. Args: t (int): The total number of commands. commands (List[str]): List of commands to assign or reassign tasks. Returns: List[str]: The final list of tasks for each employee. >>> manage_tasks(8, [\\"assign alice task1\\", \\"assign bob task2\\", \\"assign alice task3\\", \\"reassign alice task1 bob\\", \\"assign chuck task4\\", \\"assign alice task5\\", \\"reassign bob task1 chuck\\", \\"assign bob task6\\"]) ['alice task3 task5', 'bob task2 task6', 'chuck task4 task1'] >>> manage_tasks(1, [\\"assign alice task1\\"]) ['alice task1'] >>> manage_tasks(2, [\\"assign alice task1\\", \\"reassign alice task1 bob\\"]) ['bob task1']","solution":"def manage_tasks(t, commands): employee_tasks = {} employee_order = [] for command in commands: parts = command.split() if parts[0] == 'assign': employee_name = parts[1] task = parts[2] if employee_name not in employee_tasks: employee_tasks[employee_name] = [] employee_order.append(employee_name) employee_tasks[employee_name].append(task) elif parts[0] == 'reassign': old_employee_name = parts[1] task = parts[2] new_employee_name = parts[3] if old_employee_name in employee_tasks and task in employee_tasks[old_employee_name]: if new_employee_name not in employee_tasks: employee_tasks[new_employee_name] = [] employee_order.append(new_employee_name) employee_tasks[old_employee_name].remove(task) employee_tasks[new_employee_name].append(task) result = [] for employee in employee_order: if employee_tasks[employee]: result.append(f\\"{employee} {' '.join(employee_tasks[employee])}\\") return result"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t. Parameters: s (str): Source string t (str): Target string Returns: int: Minimum number of operations Examples: >>> min_operations_to_transform(\\"abcde\\", \\"cdefg\\") 5 >>> min_operations_to_transform(\\"aaa\\", \\"bbb\\") 3 >>> min_operations_to_transform(\\"abcd\\", \\"abcd\\") 0","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform string s into string t. Parameters: s (str): Source string t (str): Target string Returns: int: Minimum number of operations if len(s) != len(t): raise ValueError(\\"Strings s and t must be of the same length\\") operations = 0 for ch1, ch2 in zip(s, t): if ch1 != ch2: operations += 1 return operations"},{"question":"def can_be_palindrome(s: str) -> bool: Determine if a given string can be transformed into a palindrome by removing at most one character (or not removing any character at all). >>> can_be_palindrome(\\"abca\\") True >>> can_be_palindrome(\\"abc\\") False def check_palindrome_possibility(s: str): Check if the string can be a palindrome by removing at most one character and print \\"YES\\" or \\"NO\\" accordingly. >>> check_palindrome_possibility(\\"abca\\") YES >>> check_palindrome_possibility(\\"abc\\") NO # Unit Test def test_can_be_palindrome(): assert can_be_palindrome(\\"abca\\") == True assert can_be_palindrome(\\"abc\\") == False assert can_be_palindrome(\\"racecar\\") == True assert can_be_palindrome(\\"radar\\") == True assert can_be_palindrome(\\"a\\") == True assert can_be_palindrome(\\"ae\\") == True assert can_be_palindrome(\\"ab\\") == True assert can_be_palindrome(\\"ababa\\") == True assert can_be_palindrome(\\"abccba\\") == True assert can_be_palindrome(\\"abccaaa\\") == False assert can_be_palindrome(\\"abcdefghhgfedcba\\") == True assert can_be_palindrome(\\"abcdedcba\\") == True import pytest import sys from io import StringIO def test_check_palindrome_possibility(capsys): # Test with capture of print output check_palindrome_possibility(\\"abca\\") captured = capsys.readouterr() assert captured.out == \\"YESn\\" check_palindrome_possibility(\\"abc\\") captured = capsys.readouterr() assert captured.out == \\"NOn\\" check_palindrome_possibility(\\"racecar\\") captured = capsys.readouterr() assert captured.out == \\"YESn\\" check_palindrome_possibility(\\"radar\\") captured = capsys.readouterr() assert captured.out == \\"YESn\\" check_palindrome_possibility(\\"a\\") captured = capsys.readouterr() assert captured.out == \\"YESn\\" check_palindrome_possibility(\\"ae\\") captured = capsys.readouterr() assert captured.out == \\"YESn\\" check_palindrome_possibility(\\"ab\\") captured = capsys.readouterr() assert captured.out == \\"YESn\\" check_palindrome_possibility(\\"abcdedcba\\") captured = capsys.readouterr() assert captured.out == \\"YESn\\" check_palindrome_possibility(\\"abcdefghhgfedcba\\") captured = capsys.readouterr() assert captured.out == \\"YESn\\" check_palindrome_possibility(\\"abccaaa\\") captured = capsys.readouterr() assert captured.out == \\"NOn\\"","solution":"def can_be_palindrome(s): Determine if the string can be transformed into a palindrome by removing at most one character. def is_palindrome_range(l, r): # Check if the substring s[l:r+1] is a palindrome return all(s[i] == s[r - i + l] for i in range(l, (l + r) // 2 + 1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Two options: remove character at left or right return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True # Function that interprets the result and prints \\"YES\\" or \\"NO\\" def check_palindrome_possibility(s): if can_be_palindrome(s): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"def process_transactions(batch: str) -> List[str]: Write a program that simulates a simple banking system. The program should handle multiple customers and their transactions. Each customer can either deposit or withdraw money from their account. The program should keep track of customers' balances and print a summary of transactions for each customer at the end. The program should accept a list of transactions, where each transaction includes the customer ID, the transaction type ('deposit' or 'withdraw'), and the amount. If a withdrawal request exceeds the current balance, the transaction should be ignored. Input The input consists of several datasets. The input ends with a line including a single 0. Each dataset consists of: n (the number of transactions in the list) id type amount id type amount : : id type amount Output For each dataset, print the summary of transactions for each customer. If a customer has no valid transactions, print \\"ID x: No transactions\\" (where x is the customer ID). Ensure customers are listed in the order they appear in the input. If there are no customers with valid transactions for a dataset, print \\"No customers\\". Example Input 5 101 deposit 500 102 deposit 300 101 withdraw 100 103 deposit 700 102 withdraw 500 3 201 deposit 1000 202 withdraw 500 203 withdraw 300 3 301 deposit 200 301 withdraw 300 301 deposit 100 0 Output ID 101: Balance 400 ID 102: Balance 300 ID 103: Balance 700 ID 201: Balance 1000 ID 202: No transactions ID 203: No transactions ID 301: Balance 0","solution":"def process_transactions(batch): transactions = batch.strip().split(\\"n\\") if transactions[0] == '0' or transactions == ['']: return [] num_transactions = int(transactions[0]) customer_data = {} for i in range(1, num_transactions + 1): transaction = transactions[i].split() customer_id = int(transaction[0]) trans_type = transaction[1] amount = int(transaction[2]) if customer_id not in customer_data: customer_data[customer_id] = 0 if trans_type == 'deposit': customer_data[customer_id] += amount elif trans_type == 'withdraw' and customer_data[customer_id] >= amount: customer_data[customer_id] -= amount summary = [] for customer_id in transactions[1:num_transactions + 1]: cid = int(customer_id.split()[0]) if customer_data[cid] == 0 and all(trans.split()[1] == 'withdraw' for trans in transactions[1:num_transactions + 1] if int(trans.split()[0]) == cid): summary.append(f\\"ID {cid}: No transactions\\") else: summary.append(f\\"ID {cid}: Balance {customer_data[cid]}\\") return list(dict.fromkeys(summary))"},{"question":"def min_diff_books(M: int, B: int) -> int: Compute the minimum difference between the highest number of books received by any member and the lowest number of books received by any member. Parameters: M (int): Number of members B (int): Number of books Returns: int: The minimum difference between the highest and lowest number of books received by any two members. >>> min_diff_books(3, 8) 1 >>> min_diff_books(4, 10) 1 >>> min_diff_books(1, 1) 0 >>> min_diff_books(5, 25) 0 >>> min_diff_books(10, 15) 1 >>> min_diff_books(1000000, 1000000000) 0 >>> min_diff_books(1000000, 1000000001) 1","solution":"def min_diff_books(M, B): Compute the minimum difference between the highest number of books received by any member and the lowest number of books received by any member. Parameters: M (int): Number of members B (int): Number of books Returns: int: The minimum difference between the highest and lowest number of books received by any two members. # Each member gets at least this many books books_per_member = B // M # Calculate the remainder of books after evenly distributing remainder_books = B % M # If there is no remainder, every member gets the same number of books if remainder_books == 0: return 0 else: return 1"},{"question":"def is_power_of_three(n: int) -> bool: Determine if the given integer n is a power of three. >>> is_power_of_three(27) True >>> is_power_of_three(0) False >>> is_power_of_three(9) True >>> is_power_of_three(45) False","solution":"def is_power_of_three(n): Determine if the given integer n is a power of three. if n <= 0: return False while n % 3 == 0: n //= 3 return n == 1"},{"question":"def max_participants(p: int, s: int, d: int) -> int: Determines the maximum number of participants Anastasia can cater to with the given resources. Args: p (int): Number of pizzas (1 pizza per participant). s (int): Number of sandwiches (2 sandwiches per participant). d (int): Number of drinks (3 drinks per participant). Returns: int: The maximum number of participants. >>> max_participants(3, 5, 10) 2 >>> max_participants(2, 4, 5) 1 >>> max_participants(1, 3, 4) 1 >>> max_participants(1, 2, 3) 1 >>> max_participants(1000, 1000, 1000) 333 >>> max_participants(10, 1, 30) 0 >>> max_participants(10, 20, 2) 0","solution":"def max_participants(p, s, d): Determines the maximum number of participants Anastasia can cater to with the given resources. Args: p (int): Number of pizzas (1 pizza per participant). s (int): Number of sandwiches (2 sandwiches per participant). d (int): Number of drinks (3 drinks per participant). Returns: int: The maximum number of participants. participants_by_pizza = p participants_by_sandwiches = s // 2 participants_by_drinks = d // 3 return min(participants_by_pizza, participants_by_sandwiches, participants_by_drinks)"},{"question":"def intersection_count(N: int, lines: List[Tuple[int, int, int]]) -> int: Given N lines represented by equations of form ax + by + c = 0, determine the number of distinct points where at least two lines intersect. Args: N (int): Number of lines. lines (List[Tuple[int, int, int]]): List of tuples representing coefficients (a, b, c) of each line. Returns: int: Number of distinct intersection points. Examples: >>> intersection_count(3, [(1, -1, -1), (2, -2, -2), (1, 0, -1)]) 1 >>> intersection_count(4, [(1, 2, -3), (2, -1, 4), (1, -1, -1), (-1, -2, 3)]) 3","solution":"def gcd(x, y): while y: x, y = y, x % y return x def intersection_count(N, lines): intersection_points = set() for i in range(N): for j in range(i + 1, N): a1, b1, c1 = lines[i] a2, b2, c2 = lines[j] det = a1 * b2 - a2 * b1 if det == 0: continue x_nom = b1 * c2 - b2 * c1 y_nom = a2 * c1 - a1 * c2 gcd_x = gcd(abs(x_nom), abs(det)) gcd_y = gcd(abs(y_nom), abs(det)) reduced_x = (x_nom // gcd_x, det // gcd_x) reduced_y = (y_nom // gcd_y, det // gcd_y) intersection_points.add((reduced_x, reduced_y)) return len(intersection_points)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deleteNode(root: TreeNode, key: int) -> TreeNode: Deletes a node with a given value from a binary search tree (BST) and returns the root of the modified tree. >>> tree = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, None, TreeNode(7))) >>> deleteNode(tree, 3) TreeNode(5, TreeNode(4, TreeNode(2), None), TreeNode(6, None, TreeNode(7))) >>> deleteNode(tree, 0) TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, None, TreeNode(7))) >>> deleteNode(None, 0) None def tree_to_list(root: TreeNode) -> list: Helper function to convert tree to list level-wise for easy comparison in tests. if not root: return [] result, queue = [], [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) while result and result[-1] is None: result.pop() return result def test_delete_existing_node(): root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, None, TreeNode(7))) modified_tree = deleteNode(root, 3) assert tree_to_list(modified_tree) == [5, 4, 6, 2, None, None, 7] def test_delete_non_existing_node(): root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6, None, TreeNode(7))) modified_tree = deleteNode(root, 0) assert tree_to_list(modified_tree) == [5, 3, 6, 2, 4, None, 7] def test_delete_from_empty_tree(): root = None modified_tree = deleteNode(root, 0) assert tree_to_list(modified_tree) == [] def test_delete_leaf_node(): root = TreeNode(5, TreeNode(3), TreeNode(6)) modified_tree = deleteNode(root, 3) assert tree_to_list(modified_tree) == [5, None, 6] def test_delete_root_node(): root = TreeNode(5, TreeNode(3), TreeNode(6)) modified_tree = deleteNode(root, 5) assert tree_to_list(modified_tree) == [6, 3] def test_delete_node_with_one_child(): root = TreeNode(5, TreeNode(3, TreeNode(2), None), TreeNode(6)) modified_tree = deleteNode(root, 3) assert tree_to_list(modified_tree) == [5, 2, 6] def test_delete_node_with_two_children(): root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6)) modified_tree = deleteNode(root, 3) assert tree_to_list(modified_tree) == [5, 4, 6, 2]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deleteNode(root, key): if not root: return root if key < root.val: root.left = deleteNode(root.left, key) elif key > root.val: root.right = deleteNode(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp = findMin(root.right) root.val = temp.val root.right = deleteNode(root.right, temp.val) return root def findMin(node): current = node while current.left: current = current.left return current"},{"question":"def max_visible_buildings(buildings): Returns the maximum number of buildings that can be seen from one side. >>> max_visible_buildings([]) == 0 >>> max_visible_buildings([5]) == 1 >>> max_visible_buildings([1, 2, 3, 4, 5]) == 5 >>> max_visible_buildings([5, 4, 3, 2, 1]) == 1 >>> max_visible_buildings([3, 1, 4, 5, 2]) == 3 >>> max_visible_buildings([3, 3, 3, 3, 3]) == 1","solution":"def max_visible_buildings(buildings): Returns the maximum number of buildings that can be seen from one side. if not buildings: return 0 max_height = 0 visible_count = 0 for height in buildings: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def min_breaks(n: int, m: int) -> int: Returns the minimum number of breaks required to divide a chocolate bar of size n x m into pieces such that each piece is a 1x1 square. >>> min_breaks(3, 1) 2 >>> min_breaks(2, 2) 3 >>> min_breaks(5, 5) 24","solution":"def min_breaks(n, m): Returns the minimum number of breaks required to divide a chocolate bar of size n x m into pieces such that each piece is a 1x1 square. # To divide an n x m chocolate bar into 1x1 pieces, # we need to make (n-1) horizontal breaks and (m-1) vertical breaks. # The total number of breaks needed is therefore (n - 1) + (m - 1). return (n * m) - 1"},{"question":"def max_length_subarray_with_sum(arr, S): Returns the maximum length of any subarray whose sum is equal to S. If no such subarray exists, return 0. Example: >>> max_length_subarray_with_sum([1, 2, 3, 4, 5], 7) 2 >>> max_length_subarray_with_sum([1, 2, 3, 4, 5], 20) 0","solution":"def max_length_subarray_with_sum(arr, S): Returns the maximum length of any subarray whose sum is equal to S. If no such subarray exists, return 0. prefix_sum = 0 prefix_sum_indices = {0: -1} max_length = 0 for i, num in enumerate(arr): prefix_sum += num if (prefix_sum - S) in prefix_sum_indices: max_length = max(max_length, i - prefix_sum_indices[prefix_sum - S]) if prefix_sum not in prefix_sum_indices: prefix_sum_indices[prefix_sum] = i return max_length"},{"question":"from typing import List, Tuple def calculate_total_revenue(U: int, G: int, basic_fee: int, premium_fee: int, users: List[Tuple[str, int]]) -> int: Calculate the total monthly revenue based on the subscriptions and groupings of users. >>> calculate_total_revenue(5, 3, 10, 20, [('B', 1), ('P', 1), ('B', 2), ('B', 3), ('P', 3)]) 50 >>> calculate_total_revenue(4, 2, 15, 25, [('B', 1), ('B', 1), ('P', 2), ('B', 2)]) 40 >>> calculate_total_revenue(3, 1, 12, 30, [('B', 1), ('B', 1), ('B', 1)]) 12 >>> calculate_total_revenue(1, 1, 10, 20, [('B', 1)]) 10 >>> calculate_total_revenue(1, 1, 10, 20, [('P', 1)]) 20 >>> calculate_total_revenue(3, 3, 10, 20, [('P', 1), ('P', 2), ('P', 3)]) 60 >>> calculate_total_revenue(3, 1, 10, 20, [('B', 1), ('P', 1), ('B', 1)]) 20","solution":"def calculate_total_revenue(U, G, basic_fee, premium_fee, users): group_has_premium = set() group_to_users = {} for subscription, group in users: if group not in group_to_users: group_to_users[group] = [] group_to_users[group].append(subscription) if subscription == 'P': group_has_premium.add(group) total_revenue = 0 for group, subs in group_to_users.items(): if group in group_has_premium: total_revenue += premium_fee else: total_revenue += basic_fee return total_revenue"},{"question":"def smallest_lexicographical_string(s: str, k: int) -> str: Function to return the lexicographically smallest string possible after exactly k deletions. Args: s (str): The input string consisting of lowercase letters. k (int): The number of deletions to be performed. Returns: str: The lexicographically smallest string possible after exactly k deletions. Examples: >>> smallest_lexicographical_string(\\"abca\\", 1) \\"aba\\" >>> smallest_lexicographical_string(\\"abcd\\", 2) \\"ab\\" pass from solution import smallest_lexicographical_string def test_case_1(): assert smallest_lexicographical_string(\\"abca\\", 1) == \\"aba\\" def test_case_2(): assert smallest_lexicographical_string(\\"abcd\\", 2) == \\"ab\\" def test_case_3(): assert smallest_lexicographical_string(\\"abcde\\", 2) == \\"abc\\" def test_case_4(): assert smallest_lexicographical_string(\\"deabc\\", 3) == \\"ab\\" def test_case_5(): assert smallest_lexicographical_string(\\"abcdef\\", 0) == \\"abcdef\\" def test_case_6(): assert smallest_lexicographical_string(\\"cba\\", 1) == \\"ba\\" def test_case_7(): assert smallest_lexicographical_string(\\"a\\", 1) == \\"\\" def test_case_8(): assert smallest_lexicographical_string(\\"aabbcc\\", 4) == \\"aa\\"","solution":"def smallest_lexicographical_string(s, k): Function to return the lexicographically smallest string possible after exactly k deletions. stack = [] for i, ch in enumerate(s): # Remove characters from stack if they make the string lexicographically larger and we still have deletions left while k > 0 and stack and stack[-1] > ch: stack.pop() k -= 1 stack.append(ch) # if k is still greater than 0 after the main loop, it means we need to remove remaining elements from the end while k > 0: stack.pop() k -= 1 return ''.join(stack)"},{"question":"def process_operations(N, Q, operations): Handle multiple operations on an array of the first N natural numbers. The function processes two types of operations: 1. Rotate the array k positions to the right. 2. Find the sum of elements from index l to r after rotations. Args: N : int : Length of the array (number of natural numbers) Q : int : Number of operations operations : list : List of operations in the format [op, arg1, arg2] where op is 1 for rotations and 2 for sum queries. Returns: list : A list of results of sum queries. >>> process_operations(5, 5, [(1, 2), (2, 1, 3), (1, 1), (2, 2, 5), (2, 1, 5)]) [8, 14, 15] >>> process_operations(5, 1, [(2, 1, 5)]) [15] >>> process_operations(5, 2, [(1, 5), (2, 1, 5)]) [15] >>> process_operations(1, 2, [(1, 1), (2, 1, 1)]) [1]","solution":"def process_operations(N, Q, operations): arr = list(range(1, N+1)) offset = 0 result = [] for operation in operations: op = operation[0] if op == 1: # Rotation operation k = operation[1] offset = (offset + k) % N elif op == 2: # Sum query operation l = operation[1] - 1 # convert to 0-based index r = operation[2] - 1 # convert to 0-based index start = (l - offset + N) % N end = (r - offset + N) % N if start <= end: result.append(sum(arr[start:end+1])) else: result.append(sum(arr[start:] + arr[:end+1])) return result"},{"question":"def process_operations(n: int, operations: List[str]) -> None: Processes a sequence of operations to manage warehouse inventory and outputs the results of the \\"QUERY\\" operations. >>> process_operations(7, [\\"ADD apple 10\\", \\"ADD banana 5\\", \\"REMOVE apple 3\\", \\"QUERY\\", \\"ADD apple 2\\", \\"REMOVE banana 5\\", \\"QUERY\\"]) apple 7 banana 5 apple 9 EMPTY","solution":"def process_operations(n, operations): inventory = {} def add_item(item_id, quantity): if item_id in inventory: inventory[item_id] += quantity else: inventory[item_id] = quantity def remove_item(item_id, quantity): if item_id in inventory: inventory[item_id] -= quantity if inventory[item_id] <= 0: del inventory[item_id] def query_inventory(): if inventory: for item_id in sorted(inventory.keys()): print(f\\"{item_id} {inventory[item_id]}\\") else: print(\\"EMPTY\\") for operation in operations: parts = operation.split() command = parts[0] if command == 'ADD': item_id = parts[1] quantity = int(parts[2]) add_item(item_id, quantity) elif command == 'REMOVE': item_id = parts[1] quantity = int(parts[2]) remove_item(item_id, quantity) elif command == 'QUERY': query_inventory()"},{"question":"from typing import List def longest_subarray(arr: List[int], k: int) -> int: Finds the length of the longest subarray where the absolute difference between any two elements is at most k. >>> longest_subarray([1, 3, 6, 3, 8, 3], 3) 3 >>> longest_subarray([4, 4, 4, 4, 4], 0) 5 >>> longest_subarray([-1, -3, 3, 5], 2) 2 >>> longest_subarray([1, 2, 3, 4, 5], 10**9) 5 >>> longest_subarray([4], 0) 1 >>> longest_subarray([1, 10, 20, 30], 0) 1 >>> longest_subarray([7, 7, 7, 7, 7], 0) 5","solution":"def longest_subarray(arr, k): n = len(arr) left = 0 longest = 0 min_value = max_value = arr[0] for right in range(n): min_value = min(min_value, arr[right]) max_value = max(max_value, arr[right]) while (max_value - min_value) > k: left += 1 min_value = min(arr[left:right+1]) max_value = max(arr[left:right+1]) longest = max(longest, right - left + 1) return longest"},{"question":"from typing import List, Tuple def max_funds_raised(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given the number of donors and the maximum number of donors you are allowed to contact, determine the maximum funds that can be raised. Args: test_cases: A list of tuples, where each tuple contains: - N: int, the number of donors - K: int, the maximum number of donors that can be contacted - donations: List[int], the donation amounts from each donor Returns: A list of integers, where each integer is the maximum funds that can be raised for each test case. Example: >>> max_funds_raised([(6, 3, [5, 10, 7, 3, 8, 9])]) [27] >>> max_funds_raised([(4, 2, [1, 2, 3, 4])]) [7] >>> max_funds_raised([(5, 0, [2, 4, 6, 8, 10])]) [0]","solution":"def max_funds_raised(test_cases): This function takes the test cases details and returns a list of maximum funds that can be raised for each test case. results = [] for N, K, donations in test_cases: if K == 0: results.append(0) continue sorted_donations = sorted(donations, reverse=True) max_funds = sum(sorted_donations[:K]) results.append(max_funds) return results"},{"question":"def find_closest_spot(n: int, sx: int, sy: int, spots: List[Tuple[int, int]]) -> Tuple[int, int]: Returns the coordinates of the spot closest to the starting point (sx, sy). Parameters: n (int): The number of potential spots sx (int): The x-coordinate of the starting point sy (int): The y-coordinate of the starting point spots (List[Tuple[int, int]]): A list of tuples where each tuple contains the x and y coordinates of a potential spot Returns: Tuple[int, int]: The coordinates of the closest spot >>> find_closest_spot(3, 0, 0, [(1, 1), (2, 2), (-1, -1)]) (1, 1) >>> find_closest_spot(5, 3, 4, [(1, 2), (8, 8), (-1, -1), (4, 3), (5, 2)]) (4, 3)","solution":"def find_closest_spot(n, sx, sy, spots): Returns the coordinates of the spot closest to the starting point (sx, sy). Parameters: n (int): The number of potential spots sx (int): The x-coordinate of the starting point sy (int): The y-coordinate of the starting point spots (List[Tuple[int, int]]): A list of tuples where each tuple contains the x and y coordinates of a potential spot Returns: Tuple[int, int]: The coordinates of the closest spot min_distance = float('inf') closest_spot = None for spot in spots: xi, yi = spot distance = (xi - sx)**2 + (yi - sy)**2 if distance < min_distance: min_distance = distance closest_spot = (xi, yi) return closest_spot"},{"question":"from typing import List def is_arithmetic_progression(measurements: List[int]) -> str: Determine if the milk production measurements form an arithmetic progression. >>> is_arithmetic_progression([2, 4, 6, 8, 10]) 'YES' >>> is_arithmetic_progression([5, 7, 9, 12]) 'NO' >>> is_arithmetic_progression([0, 0, 0, 0, 0]) 'YES'","solution":"from typing import List def is_arithmetic_progression(measurements: List[int]) -> str: if len(measurements) < 2: return \\"YES\\" diff = measurements[1] - measurements[0] for i in range(2, len(measurements)): if measurements[i] - measurements[i - 1] != diff: return \\"NO\\" return \\"YES\\""},{"question":"def count_primes_in_range(prime_numbers: List[int], queries: List[Tuple[int, int]]) -> List[int]: This function takes a list of prime numbers and a list of queries. Each query contains a range [L, R], and the function returns a list of the counts of prime numbers within those ranges. results = [] for L, R in queries: count = sum(1 for prime in prime_numbers if L <= prime <= R) results.append(count) return results def parse_input(input_data: str) -> Tuple[List[int], List[Tuple[int, int]]]: This function parses the input data into appropriate components. >>> parse_input(\\"5 3n2 3 5 7 11n1 10n4 6n10 20n\\") ([2, 3, 5, 7, 11], [(1, 10), (4, 6), (10, 20)]) input_lines = input_data.strip().split('n') N, K = map(int, input_lines[0].split()) prime_numbers = list(map(int, input_lines[1].split())) queries = [tuple(map(int, line.split())) for line in input_lines[2:]] return prime_numbers, queries def prime_count_problem(input_data: str) -> List[int]: This function solves the prime count problem from the given input data. >>> prime_count_problem(\\"5 3n2 3 5 7 11n1 10n4 6n10 20n\\") [4, 1, 1] prime_numbers, queries = parse_input(input_data) return count_primes_in_range(prime_numbers, queries)","solution":"def count_primes_in_range(prime_numbers, queries): This function takes a list of prime numbers and a list of queries. Each query contains a range [L, R], and the function returns a list of the counts of prime numbers within those ranges. results = [] for L, R in queries: count = sum(1 for prime in prime_numbers if L <= prime <= R) results.append(count) return results def parse_input(input_data): This function parses the input data into appropriate components. input_lines = input_data.strip().split('n') N, K = map(int, input_lines[0].split()) prime_numbers = list(map(int, input_lines[1].split())) queries = [tuple(map(int, line.split())) for line in input_lines[2:]] return prime_numbers, queries def prime_count_problem(input_data): This function solves the prime count problem from the given input data. prime_numbers, queries = parse_input(input_data) return count_primes_in_range(prime_numbers, queries)"},{"question":"from typing import List, Tuple def dijkstra(n: int, m: int, starting_node: int, edges: List[Tuple[int, int, int]]) -> List[int]: Find the shortest path from the starting node to every other node in the graph using Dijkstra’s algorithm. Parameters: n (int): The number of vertices in the graph. m (int): The number of edges in the graph. starting_node (int): The index of the starting node. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers (u, v, w) representing an edge between nodes u and v with weight w. Returns: List[int]: A list where the i-th integer represents the shortest distance from the starting node to the i-th node. If a node is unreachable, the distance is -1. Examples: >>> dijkstra(4, 4, 1, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 1)]) [0, 1, 3, 4] >>> dijkstra(3, 1, 1, [(2, 3, 1)]) [0, -1, -1]","solution":"import heapq def dijkstra(n, m, starting_node, edges): adjacency_list = {i: [] for i in range(1, n+1)} for u, v, w in edges: adjacency_list[u].append((v, w)) adjacency_list[v].append((u, w)) distances = {i: float('inf') for i in range(1, n+1)} distances[starting_node] = 0 min_heap = [(0, starting_node)] while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_distance > distances[current_node]: continue for neighbor, weight in adjacency_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) result = [] for i in range(1, n+1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def preorder_traversal(self): result = [] self._preorder(self.root, result) return result def _preorder(self, node, result): if node is not None: result.append(node.val) self._preorder(node.left, result) self._preorder(node.right, result) def build_bst_and_preorder_traversal(keys): Given a list of keys, construct a binary search tree (BST) by inserting the keys in the given order, and return the preorder traversal of the BST. Args: keys (List[int]): List of distinct integer keys to insert into the BST. Returns: List[int]: Preorder traversal of the constructed BST. >>> build_bst_and_preorder_traversal([50, 30, 70, 20, 40, 60, 80]) [50, 30, 20, 40, 70, 60, 80] >>> build_bst_and_preorder_traversal([10]) [10] >>> build_bst_and_preorder_traversal([10, 5, 2, 1]) [10, 5, 2, 1] >>> build_bst_and_preorder_traversal([1, 2, 3, 4]) [1, 2, 3, 4] >>> build_bst_and_preorder_traversal([40, 20, 10, 30, 60, 50, 70]) [40, 20, 10, 30, 60, 50, 70]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def preorder_traversal(self): result = [] self._preorder(self.root, result) return result def _preorder(self, node, result): if node is not None: result.append(node.val) self._preorder(node.left, result) self._preorder(node.right, result) def build_bst_and_preorder_traversal(keys): bst = BST() for key in keys: bst.insert(key) return bst.preorder_traversal() # Reading input and printing output if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) keys = list(map(int, data[1:])) result = build_bst_and_preorder_traversal(keys) print(\\" \\".join(map(str, result)))"},{"question":"def process_queries(s: str, queries: List[str]) -> List[str]: Given a string and a list of queries, performs the operations as per the queries and returns the results for \\"check_palindrome\\" queries. Parameters: s (str): The initial string. queries (List[str]): A list consisting of queries as strings. Returns: List[str]: A list of results for each \\"check_palindrome\\" query. Example: >>> process_queries(\\"abcba\\", [\\"check_palindrome 1 5\\", \\"reverse 1 3\\", \\"check_palindrome 1 3\\", \\"append def\\", \\"check_palindrome 6 8\\"]) [\\"Yes\\", \\"No\\", \\"No\\"]","solution":"def process_queries(s, queries): result = [] for query in queries: parts = query.split() if parts[0] == \\"reverse\\": l, r = int(parts[1]) - 1, int(parts[2]) - 1 s = s[:l] + s[l:r+1][::-1] + s[r+1:] elif parts[0] == \\"append\\": s += parts[1] elif parts[0] == \\"check_palindrome\\": l, r = int(parts[1]) - 1, int(parts[2]) - 1 if s[l:r+1] == s[l:r+1][::-1]: result.append(\\"Yes\\") else: result.append(\\"No\\") return result # Example usage based on provided example: initial_string = \\"abcba\\" queries = [ \\"check_palindrome 1 5\\", \\"reverse 1 3\\", \\"check_palindrome 1 3\\", \\"append def\\", \\"check_palindrome 6 8\\" ] print(process_queries(initial_string, queries)) # Expected Output: [\\"Yes\\", \\"No\\", \\"No\\"]"},{"question":"def time_to_seconds(S: str) -> int: Convert a time period given in 'HH:MM:SS' format to its equivalent number of seconds. >>> time_to_seconds(\\"01:00:00\\") 3600 >>> time_to_seconds(\\"00:45:30\\") 2730 >>> time_to_seconds(\\"00:00:00\\") 0 >>> time_to_seconds(\\"23:59:59\\") 86399 >>> time_to_seconds(\\"00:00:45\\") 45 >>> time_to_seconds(\\"02:30:30\\") 9030","solution":"def time_to_seconds(S): Convert a time period given in 'HH:MM:SS' format to its equivalent number of seconds. hours, minutes, seconds = map(int, S.split(':')) total_seconds = hours * 3600 + minutes * 60 + seconds return total_seconds"},{"question":"def assign_costs(n: int, roads: List[Tuple[int, int, int]]) -> Union[int, Tuple[int, List[int]]]: Assigns costs to each intersection in the city such that the total cost for any road is positive and the maximum assigned cost is minimized. Args: n (int): The number of intersections in the city. roads (List[Tuple[int, int, int]]): List of tuples representing the roads, each tuple contains three integers u, v, l. Returns: Union[int, Tuple[int, List[int]]]: The maximum assigned cost and the list of costs for each intersection in the order from 1 to n. If it is impossible to assign the costs, returns -1. Example: >>> assign_costs(4, [(1, 2, 10), (2, 3, 5), (3, 4, 5)]) (20, [0, 10, 15, 20]) >>> assign_costs(4, [(1, 2, 5), (2, 3, 2), (1, 3, 15)]) -1","solution":"def assign_costs(n, roads): from collections import defaultdict import heapq # Graph representation graph = defaultdict(list) for u, v, l in roads: graph[u].append((v, l)) graph[v].append((u, l)) # Here we use an array to store costs; initially infinity costs = [float('inf')] * (n + 1) # Using a priority queue to ensure the smallest cost is processed first heap = [(0, 1)] # (cost, intersection), starting from intersection 1 costs[1] = 0 while heap: current_cost, u = heapq.heappop(heap) # Iterate over all neighbors for v, length in graph[u]: new_cost = current_cost + length if new_cost < costs[v]: heapq.heappush(heap, (new_cost, v)) costs[v] = new_cost # Calculate the max assigned cost necessary if float('inf') in costs[1:]: # This means some intersection is disconnected and unreachable return -1 else: max_cost = max(costs[1:]) return max_cost, costs[1:]"},{"question":"def distribute_cards(n: int, m: int, point_values: List[int]) -> Union[int, List[int]]: Distribute cards in such a way that the absolute difference between the highest and lowest total point values of any player after distribution is minimized. Args: n (int): Number of players. m (int): Total number of cards. point_values (List[int]): Point values of the cards. Returns: Union[int, List[int]]: Returns a list of the cards dealt to each player or -1 if distribution is not possible. >>> distribute_cards(4, 6, [2, 7, 14, 3, 5, 8]) [2, 3, 5, 7] >>> distribute_cards(5, 4, [1, 2, 3, 4]) -1","solution":"def distribute_cards(n, m, point_values): if n > m: return -1 sorted_points = sorted(point_values) players = [[] for _ in range(n)] player_points = [0] * n for i, point in enumerate(sorted_points): idx = i % n players[idx].append(point) player_points[idx] += point result = [0] * n for idx in range(n): result[idx] = players[idx][0] return result # Example usage n = 4 m = 6 points = [2, 7, 14, 3, 5, 8] print(distribute_cards(n, m, points)) # Example output: [2, 3, 5, 7]"},{"question":"def longest_path_length(n: int, edges: List[Tuple[int, int]]) -> int: There is a city with N nodes and N-1 bidirectional roads, forming a tree structure where node 1 is the central hub. The citizens of the city decided to celebrate the annual festival by decorating a maximal simple path in the tree with beautiful lights. A simple path is a path without repeated vertices. Your task is to help them determine the longest simple path and the total number of roads (edges) that will be decorated with lights. >>> longest_path_length(2, [(1, 2)]) == 1 >>> longest_path_length(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) == 3 >>> longest_path_length(4, [(1, 2), (2, 3), (3, 4)]) == 3 >>> longest_path_length(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 4 >>> longest_path_length(6, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]) == 2","solution":"from collections import defaultdict, deque def longest_path_length(n, edges): def bfs(farthest_node): visited = [-1] * (n + 1) queue = deque([farthest_node]) visited[farthest_node] = 0 max_distance, max_node = 0, farthest_node while queue: node = queue.popleft() current_distance = visited[node] for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] max_node = neighbor return max_node, max_distance graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # First BFS to find one endpoint of the longest path farthest_node, _ = bfs(1) # Second BFS to find the actual longest path _, longest_path = bfs(farthest_node) return longest_path"},{"question":"def is_subsequence(s1: str, s2: str) -> bool: Determine if s1 is a subsequence of s2. pass def check_subsequence(str1: str, str2: str) -> str: Returns \\"Yes\\" if str1 is a subsequence of str2, otherwise \\"No\\". pass # Tests def test_positive_case(): assert check_subsequence(\\"ACE\\", \\"ABCDE\\") == \\"Yes\\" def test_negative_case(): assert check_subsequence(\\"HELLO\\", \\"WORLD\\") == \\"No\\" def test_full_match(): assert check_subsequence(\\"ABC\\", \\"ABC\\") == \\"Yes\\" def test_subsequence_at_beginning(): assert check_subsequence(\\"AB\\", \\"ABCDEF\\") == \\"Yes\\" def test_empty_first_string(): assert check_subsequence(\\"\\", \\"ANYTHING\\") == \\"Yes\\" def test_empty_second_string(): assert check_subsequence(\\"A\\", \\"\\") == \\"No\\" def test_both_empty_strings(): assert check_subsequence(\\"\\", \\"\\") == \\"Yes\\" def test_non_continuous_subsequence(): assert check_subsequence(\\"ACE\\", \\"ABCDEFG\\") == \\"Yes\\" def test_single_character_match(): assert check_subsequence(\\"A\\", \\"A\\") == \\"Yes\\" def test_single_character_no_match(): assert check_subsequence(\\"A\\", \\"B\\") == \\"No\\"","solution":"def is_subsequence(s1, s2): Determine if s1 is a subsequence of s2. it = iter(s2) return all(char in it for char in s1) def check_subsequence(str1, str2): Returns \\"Yes\\" if str1 is a subsequence of str2, otherwise \\"No\\". if is_subsequence(str1, str2): return \\"Yes\\" else: return \\"No\\""},{"question":"def calculate_total_pages(n, entries): Returns the total number of pages written by each author in alphabetical order of their names. :param n: Number of entries (integer) :param entries: List of strings, each in the format \\"AuthorName: PageNumber\\" :return: Dictionary with author names as keys and total pages as values def format_output(results): Formats the result dictionary into a list of strings for output. :param results: Dictionary with author names as keys and total pages as values :return: List of formatted strings # Example test cases def test_example_input(): entries = [ \\"Alice: 50\\", \\"Bob: 30\\", \\"Alice: 20\\", \\"Charlie: 40\\" ] expected_output = { \\"Alice\\": 70, \\"Bob\\": 30, \\"Charlie\\": 40 } result = calculate_total_pages(4, entries) assert result == expected_output def test_single_author_multiple_entries(): entries = [ \\"Alice: 15\\", \\"Alice: 10\\", \\"Alice: 5\\" ] expected_output = { \\"Alice\\": 30 } result = calculate_total_pages(3, entries) assert result == expected_output def test_multiple_authors_single_entry(): entries = [ \\"Bob: 50\\", \\"Charlie: 70\\" ] expected_output = { \\"Bob\\": 50, \\"Charlie\\": 70 } result = calculate_total_pages(2, entries) assert result == expected_output def test_no_entries(): entries = [] expected_output = {} result = calculate_total_pages(0, entries) assert result == expected_output def test_format_output(): results = { \\"Alice\\": 70, \\"Bob\\": 30, \\"Charlie\\": 40 } expected_output = [ \\"Alice: 70\\", \\"Bob: 30\\", \\"Charlie: 40\\" ] formatted_output = format_output(results) assert formatted_output == expected_output","solution":"def calculate_total_pages(n, entries): Returns the total number of pages written by each author in alphabetical order of their names. :param n: Number of entries (integer) :param entries: List of strings, each in the format \\"AuthorName: PageNumber\\" :return: Dictionary with author names as keys and total pages as values author_pages = {} for entry in entries: author, pages = entry.split(': ') pages = int(pages) if author in author_pages: author_pages[author] += pages else: author_pages[author] = pages sorted_author_pages = dict(sorted(author_pages.items())) return sorted_author_pages def format_output(results): Formats the result dictionary into a list of strings for output. :param results: Dictionary with author names as keys and total pages as values :return: List of formatted strings return [f\\"{author}: {pages}\\" for author, pages in results.items()]"},{"question":"def max_coins(n: int, identifiers: List[int]) -> int: Function to determine the maximum possible coins that can be collectively earned. Args: n (int): Number of people. identifiers (list int): List of identifier numbers for the people. Returns: int: The maximum coins that can be collectively earned. >>> max_coins(1, [123]) 0 >>> max_coins(2, [123, 456]) 0 >>> max_coins(2, [123, 234]) 2 >>> max_coins(3, [123, 456, 789]) 0 >>> max_coins(4, [123, 456, 789, 235]) 2 >>> max_coins(2, [111, 111]) 1 >>> max_coins(3, [123, 4567, 123456]) 3","solution":"def max_coins(n, identifiers): Function to determine the maximum possible coins that can be collectively earned. Args: n (int): Number of people. identifiers (list of int): List of identifier numbers for the people. Returns: int: The maximum coins that can be collectively earned. if n < 2: return 0 # Convert identifiers to set of digits digit_sets = [set(str(identifier)) for identifier in identifiers] max_coins = 0 # Iterate over all pairs of identifiers for i in range(n): for j in range(i+1, n): common_digits = digit_sets[i] & digit_sets[j] max_coins = max(max_coins, len(common_digits)) return max_coins"},{"question":"def caesar_cipher(shift: int, plaintext: str) -> str: Shifts every character in the plaintext by the given shift value. >>> caesar_cipher(3, 'abcXYZ') 'defABC' >>> caesar_cipher(1, 'helloWorld') 'ifmmpXpsme' >>> caesar_cipher(0, 'TestingNoShift') 'TestingNoShift' >>> caesar_cipher(25, 'abcXYZ') 'zabWXY' >>> caesar_cipher(13, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') 'nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM'","solution":"def caesar_cipher(shift, plaintext): Shifts every character in the plaintext by the given shift value. Parameters: shift (int): The shift value (0 ≤ S ≤ 25) plaintext (str): The input string (1 ≤ length of P ≤ 100) Returns: str: The shifted string after applying the cipher shifted_text = [] for char in plaintext: if 'a' <= char <= 'z': new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) elif 'A' <= char <= 'Z': new_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A')) else: new_char = char shifted_text.append(new_char) return ''.join(shifted_text)"},{"question":"class RangeUpdateQuery: def __init__(self, n, a, m): self.n = n self.a = a self.m = m def update(self, i, v): Update the value of element at index i (0-based) to the new value v. self.a[i] = v def range_query(self, l, r): Calculate the sum of elements from index l to r (0-based) inclusive, and return the sum modulo m. return sum(self.a[l:r+1]) % self.m def process_operations(n, q, m, a, operations): Processes a sequence of array operations including updates and range queries. Args: n : int : number of elements in the array q : int : number of operations m : int : modulo value for range sum queries a : list of int : initial values of the array operations : list of tuple : list of operations to perform on the array Returns: list of int : results of the range queries >>> n = 5 >>> q = 4 >>> m = 1000 >>> a = [5, 3, 8, 6, 2] >>> operations = [(2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 3, 5)] >>> process_operations(n, q, m, a, operations) [16, 23, 16] >>> n = 3 >>> q = 2 >>> m = 7 >>> a = [1, 2, 3] >>> operations = [(2, 1, 3), (1, 2, 5)] >>> process_operations(n, q, m, a, operations) [6]","solution":"class RangeUpdateQuery: def __init__(self, n, a, m): self.n = n self.a = a self.m = m def update(self, i, v): self.a[i] = v def range_query(self, l, r): return sum(self.a[l:r+1]) % self.m def process_operations(n, q, m, a, operations): ruq = RangeUpdateQuery(n, a, m) results = [] for op in operations: if op[0] == 1: _, i, v = op ruq.update(i-1, v) # Convert 1-based to 0-based elif op[0] == 2: _, l, r = op result = ruq.range_query(l-1, r-1) # Convert 1-based to 0-based results.append(result) return results"},{"question":"from typing import List def find_best_starting_checkpoint(n: int, travel_times: List[List[int]]) -> int: Determine the starting checkpoint for the relay race to minimize the total travel time. Args: n (int): the number of checkpoints. travel_times (List[List[int]]): the matrix representing travel times between checkpoints. Returns: int: the identifier of the starting checkpoint. # Unit Tests def test_example(): n = 4 travel_times = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert find_best_starting_checkpoint(n, travel_times) == 1 def test_single_checkpoint(): n = 1 travel_times = [ [0] ] assert find_best_starting_checkpoint(n, travel_times) == 1 def test_two_checkpoints(): n = 2 travel_times = [ [0, 10], [10, 0] ] assert find_best_starting_checkpoint(n, travel_times) == 1 or find_best_starting_checkpoint(n, travel_times) == 2 def test_three_checkpoints(): n = 3 travel_times = [ [0, 10, 20], [10, 0, 30], [20, 30, 0] ] assert find_best_starting_checkpoint(n, travel_times) == 1 def test_large_symmetric_matrix(): n = 4 travel_times = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert find_best_starting_checkpoint(n, travel_times) in [1, 2, 3, 4]","solution":"from itertools import permutations def travel_time(travel_times, route): time = 0 for i in range(len(route)-1): time += travel_times[route[i]][route[i+1]] time += travel_times[route[-1]][route[0]] # return to start return time def find_best_starting_checkpoint(n, travel_times): best_time = float('inf') best_checkpoint = -1 for i in range(n): checkpoints = list(range(n)) checkpoints.remove(i) all_permutations = permutations(checkpoints) for perm in all_permutations: route = [i] + list(perm) + [i] current_time = travel_time(travel_times, route) if current_time < best_time: best_time = current_time best_checkpoint = i return best_checkpoint + 1 # because checkpoint indices are 1-based # Example usage n = 4 travel_times = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] print(find_best_starting_checkpoint(n, travel_times)) # Output should be 1"},{"question":"def title_case(sentence: str) -> str: Converts the input sentence to title case. Parameters: sentence (str): The input sentence to be converted. Returns: str: The sentence converted to title case. Examples: >>> title_case(\\"this is a title\\") \\"This Is A Title\\" >>> title_case(\\"ALL CAPS\\") \\"All Caps\\" >>> title_case(\\" this is a title \\") \\"This Is A Title\\" >>> title_case(\\"ThIs is A MiXeD cAsE\\") \\"This Is A Mixed Case\\" def test_title_case_normal_sentence(): assert title_case(\\"this is a title\\") == \\"This Is A Title\\" def test_title_case_all_caps(): assert title_case(\\"ALL CAPS\\") == \\"All Caps\\" def test_title_case_single_word(): assert title_case(\\"python\\") == \\"Python\\" def test_title_case_mixed_case_sentence(): assert title_case(\\"ThIs is A MiXeD cAsE\\") == \\"This Is A Mixed Case\\" def test_title_case_with_extra_spaces(): assert title_case(\\" this is a title \\") == \\"This Is A Title\\" def test_title_case_empty_string(): assert title_case(\\"\\") == \\"\\" def test_title_case_single_space(): assert title_case(\\" \\") == \\"\\" def test_title_case_long_sentence(): input_sentence = \\"a\\" * 500 + \\" \\" + \\"b\\" * 500 expected_output = \\"A\\" + \\"a\\" * 499 + \\" \\" + \\"B\\" + \\"b\\" * 499 assert title_case(input_sentence) == expected_output","solution":"def title_case(sentence): Converts the input sentence to title case. Parameters: sentence (str): The input sentence to be converted. Returns: str: The sentence converted to title case. return ' '.join(word.capitalize() for word in sentence.split())"},{"question":"def min_trips(n: int, k: int, orders: List[int]) -> int: Returns the minimum number of trips required to deliver all orders. :param n: Number of orders (integer) :param k: Maximum number of items the van can hold (integer) :param orders: List containing the number of items in each order (list of integers) :return: Minimum number of trips required (integer) >>> min_trips(5, 10, [2, 8, 3, 5, 7]) == 3 >>> min_trips(4, 5, [1, 2, 1, 3]) == 2 >>> min_trips(1, 10, [10]) == 1 >>> min_trips(5, 3, [1, 1, 1, 1, 1]) == 2 >>> min_trips(3, 50, [40, 30, 20]) == 2 >>> min_trips(5, 10, [10, 10, 10, 10, 10]) == 5 >>> min_trips(3, 5, [0, 0, 0]) == 0 pass","solution":"def min_trips(n, k, orders): Returns the minimum number of trips required to deliver all orders. :param n: Number of orders (integer) :param k: Maximum number of items the van can hold (integer) :param orders: List containing the number of items in each order (list of integers) :return: Minimum number of trips required (integer) from math import ceil total_items = sum(orders) return ceil(total_items / k)"},{"question":"from typing import Tuple def minimum_special_tiles(h: int, w: int, L: int) -> int: Calculates the minimum number of special LxL tiles needed to cover a grid of size h x w. Parameters: h (int): height of the grid w (int): width of the grid L (int): side length of the square tiles Returns: int: minimum number of special tiles needed Examples: >>> minimum_special_tiles(6, 5, 3) 4 >>> minimum_special_tiles(10, 10, 4) 9 >>> minimum_special_tiles(7, 7, 2) 16 pass def test_minimum_special_tiles(): assert minimum_special_tiles(6, 5, 3) == 4 assert minimum_special_tiles(10, 10, 4) == 9 assert minimum_special_tiles(7, 7, 2) == 16 assert minimum_special_tiles(2, 2, 3) == 1 assert minimum_special_tiles(1000, 1000, 1) == 1000000 assert minimum_special_tiles(1000, 1000, 1000) == 1 assert minimum_special_tiles(8, 8, 2) == 16 assert minimum_special_tiles(9, 9, 3) == 9","solution":"import math def minimum_special_tiles(h, w, L): Calculates the minimum number of special LxL tiles needed to cover a grid of size h x w. Parameters: h (int): height of the grid w (int): width of the grid L (int): side length of the square tiles Returns: int: minimum number of special tiles needed tiles_needed_height = math.ceil(h / L) tiles_needed_width = math.ceil(w / L) return tiles_needed_height * tiles_needed_width"},{"question":"def is_spanning_tree(V: int, E: int, edges_G: List[Tuple[int, int, int]], V2: int, E2: int, edges_H: List[Tuple[int, int, int]]) -> str: Given two weighted, undirected graphs G and H with the same set of vertices (numbered from 1 to V) but possibly different sets of edges, determine if H is a spanning tree of G. :param V: number of vertices in graph G :param E: number of edges in graph G :param edges_G: list of edges in graph G, where each edge is represented by a tuple (u, v, w) :param V2: number of vertices in graph H (always equal to V) :param E2: number of edges in graph H :param edges_H: list of edges in graph H, where each edge is represented by a tuple (u, v, w) :return: \\"YES\\" if H is a spanning tree of G, otherwise \\"NO\\" >>> is_spanning_tree(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], 4, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 4)]) \\"NO\\" >>> is_spanning_tree(5, 7, [(1, 2, 1), (1, 3, 2), (1, 4, 2), (2, 3, 1), (2, 5, 3), (3, 4, 3), (4, 5, 1)], 5, 4, [(1, 2, 1), (1, 3, 2), (4, 5, 1), (2, 4, 3)]) \\"YES\\" >>> is_spanning_tree(1, 0, [], 1, 0, []) \\"YES\\" >>> is_spanning_tree(4, 5, [(1, 2, 1), (1, 3, 2), (1, 4, 2), (2, 3, 1), (3, 4, 2)], 4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 2)]) \\"YES\\" >>> is_spanning_tree(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)], 4, 2, [(1, 2, 1), (3, 4, 3)]) \\"NO\\"","solution":"def is_spanning_tree(V, E, edges_G, V2, E2, edges_H): if V != V2: return \\"NO\\" if len(edges_H) != V - 1: return \\"NO\\" parent = {} def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY for i in range(1, V + 1): parent[i] = i for u, v, w in edges_H: if u > V or v > V: return \\"NO\\" union(u, v) connected_components = set(find(i) for i in range(1, V + 1)) return \\"YES\\" if len(connected_components) == 1 else \\"NO\\""},{"question":"from typing import List def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if any two numbers in the list add up to the target sum. Parameters: nums (List[int]): A list of integers. target (int): An integer representing the target sum. Returns: bool: True if there are two distinct numbers in the list that add up to the target sum, False otherwise. >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([-1, 2, 4, 6, -2], 8) True >>> has_pair_with_sum([], 0) False >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([2, 4, 6], 8) True >>> has_pair_with_sum([10**6, -10**6, 3, 7], 0) True >>> has_pair_with_sum([0, 0, 0], 0) True","solution":"from typing import List def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if any two numbers in the list add up to the target sum. Parameters: nums (List[int]): A list of integers. target (int): An integer representing the target sum. Returns: bool: True if there are two distinct numbers in the list that add up to the target sum, False otherwise. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def process_requests(t: int, test_cases: List[Dict[str, Union[Tuple[int, int], List[Tuple[int, int, int]]]]]) -> List[Tuple[int, int]]: You are a server administrator tasked with managing a single server that processes API requests. Each request has a start time, a duration, and consumes a certain number of resources. The server can handle up to a certain number of resources simultaneously. If a request starts at a time when the server does not have enough available resources to handle it, that request is denied. You need to process a series of API requests and determine how many of them are successfully completed and how many are denied. Parameters: t (int): the number of test cases. test_cases (List[Dict[str, Union[Tuple[int, int], List[Tuple[int, int, int]]]]]): test cases with server information and requests. Returns: List[Tuple[int, int]]: a list of tuples with the number of successful and denied requests for each test case. >>> t = 2 >>> test_cases = [ ... { ... 'server_info': (3, 10), ... 'requests': [ ... (1, 5, 4), ... (2, 2, 6), ... (6, 3, 5) ... ] ... }, ... { ... 'server_info': (2, 8), ... 'requests': [ ... (1, 4, 5), ... (5, 6, 6) ... ] ... } ... ] >>> process_requests(t, test_cases) [(2, 1), (1, 1)]","solution":"def process_requests(t, test_cases): results = [] for case in test_cases: n, max_resources = case['server_info'] requests = case['requests'] successful_requests = 0 denied_requests = 0 current_resources = [0] * (max_resources + 1) for start, duration, resources in requests: end = start + duration available_resources = max_resources for time in range(start, end): available_resources -= current_resources[time % len(current_resources)] if available_resources >= resources: successful_requests += 1 for time in range(start, end): current_resources[time % len(current_resources)] += resources else: denied_requests += 1 results.append((successful_requests, denied_requests)) return results"},{"question":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, value): Pushes an integer value onto the stack. pass def pop(self): Removes the element on the top of the stack. pass def max(self): Returns the maximum value in the stack. pass def process_operations(operations): Processes a list of operations and returns the results of \\"Max\\" operations. Args: operations: List of strings, each representing a stack operation. Returns: List of integers, each the result of a \\"Max\\" operation. >>> process_operations([\\"Push 1\\", \\"Push 2\\", \\"Max\\", \\"Push 3\\", \\"Max\\", \\"Pop\\"]) [2, 3] >>> process_operations([\\"Push 5\\", \\"Push 1\\", \\"Max\\", \\"Pop\\", \\"Max\\"]) [5, 5] pass","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, value): self.stack.append(value) if not self.max_stack or value >= self.max_stack[-1]: self.max_stack.append(value) def pop(self): if self.stack: value = self.stack.pop() if value == self.max_stack[-1]: self.max_stack.pop() def max(self): if self.max_stack: return self.max_stack[-1] def process_operations(operations): max_stack = MaxStack() results = [] for operation in operations: if operation.startswith(\\"Push\\"): _, value = operation.split() max_stack.push(int(value)) elif operation == \\"Pop\\": max_stack.pop() elif operation == \\"Max\\": results.append(max_stack.max()) return results"},{"question":"def is_special_number(n: int) -> bool: Determine if a number is a special number. Returns True if the number is a special number, otherwise False. def sum_of_squares_of_digits(x): return sum(int(digit) ** 2 for digit in str(x)) seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares_of_digits(n) return n == 1 def special_numbers(eof_input: str) -> List[str]: Identify which numbers from the input are special numbers. Args: eof_input: A string containing multiple lines of positive integers. Returns: A list of strings where each element is \\"Special\\" if the corresponding number is a special number and \\"Not Special\\" if it is not. # Process the input, strip and split by lines numbers = eof_input.strip().split() results = [] for num in numbers: number = int(num) if is_special_number(number): results.append(\\"Special\\") else: results.append(\\"Not Special\\") return results # Unit tests def test_is_special_number(): assert is_special_number(19) == True assert is_special_number(4) == False assert is_special_number(1) == True assert is_special_number(10) == True assert is_special_number(7) == True assert is_special_number(2) == False def test_special_numbers(): input_data = \\"19n4n1n10n\\" expected_output = [\\"Special\\", \\"Not Special\\", \\"Special\\", \\"Special\\"] assert special_numbers(input_data) == expected_output input_data = \\"2n3n5n\\" expected_output = [\\"Not Special\\", \\"Not Special\\", \\"Not Special\\"] assert special_numbers(input_data) == expected_output input_data = \\"7n8n9n\\" expected_output = [\\"Special\\", \\"Not Special\\", \\"Not Special\\"] assert special_numbers(input_data) == expected_output","solution":"def is_special_number(n): Function to determine if a number is a special number. Returns True if the number is a special number, otherwise False. def sum_of_squares_of_digits(x): return sum(int(digit) ** 2 for digit in str(x)) seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares_of_digits(n) return n == 1 def special_numbers(eof_input): # Process the input, strip and split by lines numbers = eof_input.strip().split() results = [] for num in numbers: number = int(num) if is_special_number(number): results.append(\\"Special\\") else: results.append(\\"Not Special\\") return results"},{"question":"def can_ball_pass(N: int, heights: List[int], H: int, D: int) -> str: Determine if the ball can pass through the entire row of cylinders. Parameters: N (int): The number of cylinders. heights (List[int]): The heights of the cylinders. H (int): The initial height of the ball. D (int): The maximum height difference the ball can handle between two consecutive cylinders. Returns: str: \\"Yes\\" if the ball can pass through the entire row, otherwise \\"No\\". from solution import can_ball_pass def test_can_ball_pass_no(): assert can_ball_pass(5, [2, 3, 1, 5, 4], 3, 1) == \\"No\\" assert can_ball_pass(4, [1, 3, 5, 6], 2, 1) == \\"No\\" assert can_ball_pass(3, [1, 5, 1], 4, 2) == \\"No\\" def test_can_ball_pass_yes(): assert can_ball_pass(4, [1, 2, 3, 4], 2, 1) == \\"Yes\\" assert can_ball_pass(5, [5, 4, 5, 4, 5], 5, 1) == \\"Yes\\" assert can_ball_pass(3, [1, 2, 1], 1, 1) == \\"Yes\\" def test_can_ball_pass_edge_cases(): assert can_ball_pass(1, [1], 1, 0) == \\"Yes\\" assert can_ball_pass(2, [1, 1], 1, 0) == \\"Yes\\" assert can_ball_pass(2, [1, 10], 10, 9) == \\"Yes\\" assert can_ball_pass(2, [1, 10], 10, 8) == \\"No\\" def test_all(): test_can_ball_pass_no() test_can_ball_pass_yes() test_can_ball_pass_edge_cases()","solution":"def can_ball_pass(N, heights, H, D): Determine if the ball can pass through the entire row of cylinders. Parameters: N (int): The number of cylinders. heights (List[int]): The heights of the cylinders. H (int): The initial height of the ball. D (int): The maximum height difference the ball can handle between two consecutive cylinders. Returns: str: \\"Yes\\" if the ball can pass through the entire row, otherwise \\"No\\". current_height = H for i in range(1, N): if abs(heights[i] - heights[i - 1]) > D: return \\"No\\" return \\"Yes\\""},{"question":"def length_of_unique_lis(n: int, a: List[int]) -> int: Determines the length of the longest increasing subsequence with unique elements. >>> length_of_unique_lis(8, [10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_unique_lis(6, [5, 6, 7, 8, 9, 1]) 5 >>> length_of_unique_lis(10, [10, 9, 2, 2, 2, 3, 4, 7, 101, 18]) 5 >>> length_of_unique_lis(1, [1]) 1 >>> length_of_unique_lis(4, [4, 10, 4, 3]) 2","solution":"def length_of_unique_lis(n, a): Function to determine the length of the longest increasing subsequence with unique elements. if n == 0: return 0 import bisect # Use a set to record the elements already in the subsequence unique_elements = set() # This will store our longest increasing subsequence so far lis = [] for value in a: if value in unique_elements: continue pos = bisect.bisect_left(lis, value) if pos == len(lis): lis.append(value) else: lis[pos] = value unique_elements.add(value) return len(lis)"},{"question":"class BankSystem: def __init__(self, n): Initializes the BankSystem with n accounts, all with a starting balance of 0. :param n: Number of bank accounts pass def deposit(self, accountId, amount): Deposits the specified amount into the given account. :param accountId: ID of the account :param amount: Amount to be deposited pass def withdraw(self, accountId, amount): Withdraws the specified amount from the given account. :param accountId: ID of the account :param amount: Amount to be withdrawn pass def balance(self, accountId): Returns the current balance of the given account. :param accountId: ID of the account :return: Balance of the account pass def process_queries(n, queries): Processes the given queries on the bank system and returns the result of balance queries. :param n: Number of bank accounts :param queries: List of queries to be processed :return: List of balance results pass # Example test cases def test_bank_system(): n = 3 queries = [ [0, 1, 500], [0, 2, 300], [2, 1], [1, 1, 200], [2, 1], [2, 2], [1, 3, 400] ] expected_output = [500, 300, 300] assert process_queries(n, queries) == expected_output def test_deposit(): bank_system = BankSystem(3) bank_system.deposit(1, 100) assert bank_system.balance(1) == 100 bank_system.deposit(1, 50) assert bank_system.balance(1) == 150 def test_withdraw(): bank_system = BankSystem(3) bank_system.deposit(1, 200) bank_system.withdraw(1, 100) assert bank_system.balance(1) == 100 bank_system.withdraw(1, 50) assert bank_system.balance(1) == 50 def test_balance(): bank_system = BankSystem(3) assert bank_system.balance(1) == 0 bank_system.deposit(1, 300) assert bank_system.balance(1) == 300 bank_system.withdraw(1, 100) assert bank_system.balance(1) == 200","solution":"class BankSystem: def __init__(self, n): Initializes the BankSystem with n accounts, all with a starting balance of 0. :param n: Number of bank accounts self.balances = [0] * (n + 1) # +1 because account IDs are 1-based def deposit(self, accountId, amount): Deposits the specified amount into the given account. :param accountId: ID of the account :param amount: Amount to be deposited self.balances[accountId] += amount def withdraw(self, accountId, amount): Withdraws the specified amount from the given account. :param accountId: ID of the account :param amount: Amount to be withdrawn self.balances[accountId] -= amount def balance(self, accountId): Returns the current balance of the given account. :param accountId: ID of the account :return: Balance of the account return self.balances[accountId] def process_queries(n, queries): Processes the given queries on the bank system and returns the result of balance queries. :param n: Number of bank accounts :param queries: List of queries to be processed :return: List of balance results bank_system = BankSystem(n) results = [] for query in queries: if query[0] == 0: bank_system.deposit(query[1], query[2]) elif query[0] == 1: bank_system.withdraw(query[1], query[2]) elif query[0] == 2: results.append(bank_system.balance(query[1])) return results"},{"question":"def shopping_spree(N: int, B: int, prices: List[int]) -> int: Determine the price end up paying within the given budget. If no item can be bought without exceeding the budget, return -1. :param N: Number of shops :param B: Budget :param prices: List of prices at each shop :return: Price paid or -1 if no item can be bought within the budget >>> shopping_spree(6, 50, [30, 40, 45, 50, 55, 65]) 50 >>> shopping_spree(6, 50, [30, 40, 45, 60, 55, 65]) 45 >>> shopping_spree(6, 50, [60, 70, 80, 90, 100, 110]) -1 >>> shopping_spree(1, 20, [18]) 18 >>> shopping_spree(5, 30, [31, 32, 33, 34, 35]) -1 >>> shopping_spree(5, 50, [10, 20, 30, 40, 50]) 50 >>> shopping_spree(5, 100, [10, 20, 30, 40, 50]) 50","solution":"def shopping_spree(N, B, prices): Determine the price end up paying within the given budget. If no item can be bought without exceeding the budget, return -1. :param N: Number of shops :param B: Budget :param prices: List of prices at each shop :return: Price paid or -1 if no item can be bought within the budget closest_price = -1 for price in prices: if price == B: return B elif price < B and (closest_price == -1 or price > closest_price): closest_price = price return closest_price"},{"question":"def max_customers_served(n: int, m: int, si: List[int], tj: List[int], D: int) -> int: Determine the maximum number of customers that can be served if the deliveries are optimized for the most advantageous branch. Args: n (int): Number of branches. m (int): Number of customers. si (List[int]): List of start times for each branch. tj (List[int]): List of order times for each customer. D (int): Time interval during which the deliveries can be made by each branch. Returns: int: The maximum number of customers that can be served by the most optimized branch. Examples: >>> max_customers_served(3, 5, [2, 6, 8], [1, 3, 5, 7, 9], 3) 2 >>> max_customers_served(1, 5, [1], [1, 10, 20, 30, 40], 50) 5 >>> max_customers_served(2, 5, [2, 3], [1, 2, 3, 4, 5], 1) 2 >>> max_customers_served(3, 4, [1, 2, 3], [10, 20, 30, 40], 5) 0 >>> max_customers_served(4, 6, [5, 10, 15, 20], [2, 6, 8, 12, 14, 18], 3) 2","solution":"def max_customers_served(n, m, si, tj, D): max_served = 0 for start_time in si: count = 0 for order_time in tj: if start_time <= order_time <= start_time + D: count += 1 if count > max_served: max_served = count return max_served # Example usage: n, m = 3, 5 si = [2, 6, 8] tj = [1, 3, 5, 7, 9] D = 3 print(max_customers_served(n, m, si, tj, D)) # Output: 2"},{"question":"def min_possible_integer(arr: List[int]) -> int: Calculate the minimum possible integer in the resulting array after performing the operation any number of times. >>> min_possible_integer([42]) 42 >>> min_possible_integer([1, 2, 3, 4]) 1 >>> min_possible_integer([1, 2, 3, 4, 5]) 1 >>> min_possible_integer([7, 7, 7]) 7 >>> min_possible_integer([10, 20, 30, 40, 50, 60, 70]) 15 >>> min_possible_integer([12, 23, 5, 9, 17, 28]) 7 >>> min_possible_integer([2, 5, 3, 1]) 1 >>> min_possible_integer([99, 100, 97, 98]) 97","solution":"def min_possible_integer(arr): Calculate the minimum possible integer in the resulting array after performing the operation any number of times. # Implementation strategy: The minimum possible integer will be the mean of the smallest two elements sorted_arr = sorted(arr) if len(sorted_arr) == 1: return sorted_arr[0] return (sorted_arr[0] + sorted_arr[1]) // 2"},{"question":"from typing import List def generate_strings(n: int) -> List[str]: Generates all possible strings of length n using the characters 'a', 'b', and 'c'. >>> generate_strings(0) [\\"\\"] >>> generate_strings(1) [\\"a\\", \\"b\\", \\"c\\"] >>> generate_strings(2) [\\"aa\\", \\"ab\\", \\"ac\\", \\"ba\\", \\"bb\\", \\"bc\\", \\"ca\\", \\"cb\\", \\"cc\\"] >>> generate_strings(3) [\\"aaa\\", \\"aab\\", \\"aac\\", \\"aba\\", \\"abb\\", \\"abc\\", \\"aca\\", \\"acb\\", \\"acc\\", \\"baa\\", \\"bab\\", \\"bac\\", \\"bba\\", \\"bbb\\", \\"bbc\\", \\"bca\\", \\"bcb\\", \\"bcc\\", \\"caa\\", \\"cab\\", \\"cac\\", \\"cba\\", \\"cbb\\", \\"cbc\\", \\"cca\\", \\"ccb\\", \\"ccc\\"] pass def test_generate_strings_length_zero(): assert generate_strings(0) == [\\"\\"] def test_generate_strings_length_one(): assert generate_strings(1) == [\\"a\\", \\"b\\", \\"c\\"] def test_generate_strings_length_two(): assert generate_strings(2) == [\\"aa\\", \\"ab\\", \\"ac\\", \\"ba\\", \\"bb\\", \\"bc\\", \\"ca\\", \\"cb\\", \\"cc\\"] def test_generate_strings_length_three(): expected = [ \\"aaa\\", \\"aab\\", \\"aac\\", \\"aba\\", \\"abb\\", \\"abc\\", \\"aca\\", \\"acb\\", \\"acc\\", \\"baa\\", \\"bab\\", \\"bac\\", \\"bba\\", \\"bbb\\", \\"bbc\\", \\"bca\\", \\"bcb\\", \\"bcc\\", \\"caa\\", \\"cab\\", \\"cac\\", \\"cba\\", \\"cbb\\", \\"cbc\\", \\"cca\\", \\"ccb\\", \\"ccc\\" ] assert generate_strings(3) == expected def test_generate_strings_limit(): assert len(generate_strings(4)) == 81 assert len(generate_strings(5)) == 243 assert len(generate_strings(6)) == 729 assert len(generate_strings(7)) == 2187 assert len(generate_strings(8)) == 6561 assert len(generate_strings(9)) == 19683 assert len(generate_strings(10)) == 59049","solution":"from itertools import product def generate_strings(n): Generates all possible strings of length n using the characters 'a', 'b', and 'c'. if n == 0: return [\\"\\"] return [''.join(p) for p in product('abc', repeat=n)]"},{"question":"def min_final_sum(n: int, arr: List[int]) -> int: Returns the minimum possible sum of the final remaining integer after repeatedly applying the operation until only one integer remains. Args: n : int : the number of integers in the array arr : List[int] : the integers in the array Returns: int : the minimum possible sum of the final remaining integer Examples: >>> min_final_sum(4, [4, 3, 6, 2]) 15 >>> min_final_sum(3, [1, 2, 3]) 6 >>> min_final_sum(5, [10, 20, 30, 40, 50]) 150 >>> min_final_sum(2, [5, 5]) 10 >>> min_final_sum(3, [1000000000, 1000000000, 1000000000]) 3000000000 >>> min_final_sum(2, [1, 1000000000]) 1000000001","solution":"def min_final_sum(n, arr): Returns the minimum possible sum of the final remaining integer after repeatedly applying the operation until only one integer remains. return sum(arr)"},{"question":"def knight_moves(position: str) -> int: Given a position on a standard 8x8 chessboard, returns the number of valid moves for a knight. Position is a string like \\"a1\\", where 'a'..'h' is the column and '1'..'8' is the row. >>> knight_moves('e4') 8 >>> knight_moves('a1') 2 >>> knight_moves('c2') 6 >>> knight_moves('h8') 2 >>> knight_moves('f5') 8","solution":"def knight_moves(position): Given a position on a standard 8x8 chessboard, returns the number of valid moves for a knight. Position is a string like \\"a1\\", where 'a'..'h' is the column and '1'..'8' is the row. # Possible moves of a knight represented as (x, y) deltas moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # Convert position to board indices col = ord(position[0]) - ord('a') + 1 row = int(position[1]) valid_moves = 0 # Check all possible moves for move in moves: new_col = col + move[0] new_row = row + move[1] if 1 <= new_col <= 8 and 1 <= new_row <= 8: valid_moves += 1 return valid_moves"},{"question":"def exists_path(n: int, m: int, grid: List[List[int]]) -> str: Determine if there's a path from the top-left corner to the bottom-right corner of the grid that passes only through cells containing 1s and moving to adjacent cells (up, down, left, right). Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D grid representing the city of Gridville. Returns: str: \\"YES\\" if such a path exists, else \\"NO\\". >>> exists_path(5, 5, [ ... [1, 0, 1, 1, 1], ... [1, 1, 0, 0, 0], ... [0, 1, 1, 1, 1], ... [0, 0, 0, 1, 0], ... [1, 1, 1, 1, 1]]) \\"YES\\" >>> exists_path(5, 5, [ ... [1, 0, 1, 1, 1], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [1, 1, 1, 1, 1]]) \\"NO\\" >>> exists_path(2, 2, [ ... [1, 1], ... [0, 1]]) \\"YES\\" >>> exists_path(1, 1, [ ... [1]]) \\"YES\\" >>> exists_path(1, 1, [ ... [0]]) \\"NO\\"","solution":"def exists_path(n, m, grid): Determines if there's a path from the top-left corner to the bottom-right corner of the grid that only passes through cells containing 1s. Returns \\"YES\\" if such a path exists, otherwise \\"NO\\". if grid[0][0] == 0 or grid[n-1][m-1] == 0: return \\"NO\\" visited = [[False] * m for _ in range(n)] def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m: return False if visited[x][y] or grid[x][y] == 0: return False visited[x][y] = True if x == n-1 and y == m-1: return True return (dfs(x+1, y) or dfs(x-1, y) or dfs(x, y+1) or dfs(x, y-1)) return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def min_moves_to_make_points_same(coords): Returns the minimum number of moves required to make all points the same. Args: coords: List[int] - a list of integers representing coordinates of points Returns: int - the minimum number of moves required Example: >>> min_moves_to_make_points_same([1, 2, 3]) 2 >>> min_moves_to_make_points_same([-1, 2, 5]) 6","solution":"def min_moves_to_make_points_same(coords): Returns the minimum number of moves required to make all points the same. if not coords: return 0 # Median minimizes the sum of absolute deviations. coords.sort() median = coords[len(coords) // 2] # Calculate the total number of moves to make all points equal to the median. moves = sum(abs(coord - median) for coord in coords) return moves"},{"question":"def deepest_leaf_depth(n: int, nodes: List[Tuple[int, int]]) -> int: Given a list of nodes and their depths, return the depth of the deepest leaf node. >>> deepest_leaf_depth(6, [(1, 0), (2, 1), (3, 1), (4, 2), (5, 2), (6, 3)]) 3 >>> deepest_leaf_depth(1, [(1, 0)]) 0","solution":"def deepest_leaf_depth(n, nodes): Given a list of nodes and their depths, returns the depth of the deepest leaf node. :param n: An integer representing the number of nodes. :param nodes: A list of tuples, where each tuple contains two integers (node identifier, depth). :return: An integer representing the depth of the deepest leaf node. max_depth = 0 for _, depth in nodes: if depth > max_depth: max_depth = depth return max_depth"},{"question":"from typing import List def maxOverlap(n: int, start: List[int], end: List[int]) -> int: Calculate the maximum number of test cases that were running simultaneously at any point in time. Args: n (int): The number of test cases. start (List[int]): Start times of the test cases. end (List[int]): End times of the test cases. Returns: int: The maximum number of test cases running simultaneously. Examples: >>> maxOverlap(3, [1, 2, 3], [4, 5, 6]) 3 >>> maxOverlap(5, [1, 2, 3, 5, 6], [4, 5, 6, 7, 8]) 3","solution":"def maxOverlap(n, start, end): start.sort() end.sort() i = 0 j = 0 current_tests = 0 max_tests = 0 while i < n and j < n: if start[i] < end[j]: current_tests += 1 max_tests = max(max_tests, current_tests) i += 1 else: current_tests -= 1 j += 1 return max_tests"},{"question":"def calculate_revenues(S: int, all_data: List[int]) -> List[int]: The Galactic Revenue Service has hired you to write a program to help track the income of various star systems. Each system generates income based on the number of planets it has and the amount of revenue each planet produces. Parameters: S (int): The number of star systems. all_data (List[int]): The data containing number of planets followed by their respective revenues for each star system. Returns: List[int]: A list containing the total revenue for each star system. Examples: >>> calculate_revenues(2, [3, 100, 200, 300, 2, 500, 600]) [600, 1100] >>> calculate_revenues(1, [4, 150, 250, 350, 450]) [1200] # Your code here","solution":"def calculate_revenues(S, all_data): result = [] data_index = 0 for _ in range(S): P = all_data[data_index] data_index += 1 total_revenue = sum(all_data[data_index:data_index+P]) data_index += P result.append(total_revenue) return result"},{"question":"def max_rectangle_area(n, heights): Returns the maximum area of a rectangle formed by consecutive buildings. >>> max_rectangle_area(6, [2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area(4, [1, 2, 3, 4]) 6 >>> max_rectangle_area(5, [5, 4, 3, 2, 1]) 9 >>> max_rectangle_area(1, [5]) 5 >>> max_rectangle_area(5, [4, 4, 4, 4, 4]) 20 >>> max_rectangle_area(6, [1, 3, 1, 3, 1, 3]) 6 >>> max_rectangle_area(7, [2, 1, 4, 5, 1, 3, 3]) 8 >>> heights = [1] * 1000 >>> max_rectangle_area(1000, heights) 1000","solution":"def max_area_histogram(heights): Returns the maximum area of rectangle formed using consecutive buildings. stack, max_area = [], 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_rectangle_area(n, heights): Wrapper function to read input and return the maximum area. return max_area_histogram(heights)"},{"question":"def trap_rain_water(height: List[int]) -> int: Given a list of non-negative integers representing the height of blocks, this function returns the amount of water that can be trapped after a rain. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([]) == 0 >>> trap_rain_water([1]) == 0 >>> trap_rain_water([1, 2]) == 0 >>> trap_rain_water([2, 2, 2, 2]) == 0 >>> trap_rain_water([3, 0, 2, 0, 4]) == 7 >>> trap_rain_water([0, 3, 0, 3, 0]) == 3 >>> trap_rain_water([5, 4, 3, 2, 1]) == 0 >>> trap_rain_water([1, 2, 3, 4, 5]) == 0 pass","solution":"def trap_rain_water(height): Given a list of non-negative integers representing the height of blocks, this function returns the amount of water that can be trapped after a rain. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def build_organization_chart(pairs): Create a digital organizational chart from manager-employee pairs. >>> build_organization_chart([[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]]) 1 2 4 5 3 6 7 >>> build_organization_chart([[2, 3], [1, 4]]) 1 4","solution":"from collections import defaultdict def build_organization_chart(pairs): # Create a dictionary to store manager-employee relationships manager_to_employees = defaultdict(list) all_employees = set() employees_with_manager = set() for manager, employee in pairs: manager_to_employees[manager].append(employee) all_employees.add(manager) all_employees.add(employee) employees_with_manager.add(employee) # Find the CEO (an employee who has no manager) ceo_candidates = all_employees - employees_with_manager ceo = min(ceo_candidates) def print_chart(manager, indent_level=0): print(' ' * indent_level + str(manager)) for employee in sorted(manager_to_employees.get(manager, [])): print_chart(employee, indent_level + 2) # Print the organizational chart starting from the CEO print_chart(ceo) # Example usage: # pairs = [ # [1, 2], # [1, 3], # [2, 4], # [2, 5], # [3, 6], # [3, 7] # ] # build_organization_chart(pairs)"},{"question":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], n: int, m: int, k: int) -> int: Finds the k-th smallest element in a sorted matrix. Args: matrix (List[List[int]]): The matrix where each row is sorted in ascending order. n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. k (int): The position of the element to find in sorted order. Returns: int: The k-th smallest element in the matrix. Examples: >>> matrix = [[1, 5, 9], [10, 11, 13], [12, 13, 15]] >>> kth_smallest(matrix, 3, 3, 8) 13 >>> matrix = [[1, 2], [1, 3]] >>> kth_smallest(matrix, 2, 2, 2) 1","solution":"import heapq def kth_smallest(matrix, n, m, k): min_heap = [] for r in range(min(n, k)): # Only consider the first min(n, k) rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) while k: element, r, c = heapq.heappop(min_heap) if c + 1 < m: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) k -= 1 return element"},{"question":"class InventoryManagementSystem: def __init__(self): self.inventory = {} def add(self, item_id: int, quantity: int): Adds a specified quantity to the item with the given item_id. If the item does not exist, it creates a new entry with the given quantity. pass def remove(self, item_id: int, quantity: int): Removes a specified quantity from the item with the given item_id. If the operation would result in a negative quantity, the quantity is set to 0 instead. pass def query(self, item_id: int) -> int: Returns the current quantity of the item with the given item_id. If the item does not exist, return 0. pass def process_inventory_operations(operations: List[str]) -> List[str]: Processes a list of inventory operations and returns the results of all query operations. >>> process_inventory_operations([\\"add 101 5\\", \\"add 102 10\\", \\"query 101\\", \\"remove 101 3\\", \\"query 101\\", \\"remove 102 15\\", \\"query 102\\", \\"query 103\\", \\"end\\"]) [\\"5\\", \\"2\\", \\"0\\", \\"0\\"] pass def test_inventory_management_system(): operations = [ \\"add 101 5\\", \\"add 102 10\\", \\"query 101\\", \\"remove 101 3\\", \\"query 101\\", \\"remove 102 15\\", \\"query 102\\", \\"query 103\\", \\"end\\" ] expected_output = [\\"5\\", \\"2\\", \\"0\\", \\"0\\"] assert process_inventory_operations(operations) == expected_output def test_add_and_query(): operations = [ \\"add 200 20\\", \\"query 200\\", \\"end\\" ] assert process_inventory_operations(operations) == [\\"20\\"] def test_remove_below_zero(): operations = [ \\"add 300 10\\", \\"remove 300 15\\", \\"query 300\\", \\"end\\" ] assert process_inventory_operations(operations) == [\\"0\\"] def test_query_nonexistent_item(): operations = [ \\"query 400\\", \\"end\\" ] assert process_inventory_operations(operations) == [\\"0\\"] def test_multiple_operations(): operations = [ \\"add 500 5\\", \\"add 500 5\\", \\"remove 500 3\\", \\"query 500\\", \\"remove 500 7\\", \\"query 500\\", \\"end\\" ] assert process_inventory_operations(operations) == [\\"7\\", \\"0\\"]","solution":"class InventoryManagementSystem: def __init__(self): self.inventory = {} def add(self, item_id, quantity): if item_id in self.inventory: self.inventory[item_id] += quantity else: self.inventory[item_id] = quantity def remove(self, item_id, quantity): if item_id in self.inventory: self.inventory[item_id] = max(self.inventory[item_id] - quantity, 0) def query(self, item_id): return self.inventory.get(item_id, 0) def process_inventory_operations(operations): ims = InventoryManagementSystem() results = [] for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"add\\": item_id = int(parts[1]) quantity = int(parts[2]) ims.add(item_id, quantity) elif cmd == \\"remove\\": item_id = int(parts[1]) quantity = int(parts[2]) ims.remove(item_id, quantity) elif cmd == \\"query\\": item_id = int(parts[1]) results.append(str(ims.query(item_id))) elif cmd == \\"end\\": break return results"},{"question":"from typing import List, Tuple def min_steps_to_end(board: List[int]) -> int: Determine the minimum number of steps required to reach the end of the board from the start. Each number in the sequence represents the maximum number of steps you can take forward from that position. If it is not possible to reach the end of the board, return -1. >>> min_steps_to_end([2, 3, 1, 1, 4]) 2 >>> min_steps_to_end([3, 2, 1, 0, 4]) -1 def game_board_solver(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Solve multiple test cases of the game board problem. Each test case consists of a number of integers representing the game board. The function should return the minimum number of steps required to reach the end of the game board. >>> T = 2 >>> test_cases = [(5, [2, 3, 1, 1, 4]), (5, [3, 2, 1, 0, 4])] >>> game_board_solver(T, test_cases) ['Case #1: 2', 'Case #2: -1']","solution":"def min_steps_to_end(board): n = len(board) if n == 1: return 0 max_reachable = 0 jumps = 0 step_end = 0 for i in range(n - 1): max_reachable = max(max_reachable, i + board[i]) if i == step_end: jumps += 1 step_end = max_reachable if step_end >= n - 1: return jumps return -1 def game_board_solver(T, test_cases): results = [] for i in range(T): N, board = test_cases[i] result = min_steps_to_end(board) results.append(f\\"Case #{i+1}: {result}\\") return results"},{"question":"def minimum_baking_time(n: int, baking_times: List[int]) -> int: Returns the minimum total baking time required to bake all types of cookies. Parameters: n (int): The number of different types of cookies. baking_times (list of int): The baking times of each type of cookies. Returns: int: The minimum total baking time. >>> minimum_baking_time(4, [3, 2, 10, 4]) 10 >>> minimum_baking_time(5, [1, 2, 3, 4, 5]) 5","solution":"def minimum_baking_time(n, baking_times): Returns the minimum total baking time required to bake all types of cookies. Parameters: n (int): The number of different types of cookies. baking_times (list of int): The baking times of each type of cookies. Returns: int: The minimum total baking time. return max(baking_times)"},{"question":"from typing import List def length_of_LIS(nums: List[int]) -> int: Given an unsorted array of integers, return the length of the longest increasing subsequence. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) 4 >>> length_of_LIS([10]) 1 >>> length_of_LIS([10, 20, 10, 30, 10]) 3 >>> length_of_LIS([]) 0 >>> length_of_LIS([1, 1, 1, 1]) 1 >>> length_of_LIS([5, 4, 3, 2, 1]) 1 >>> length_of_LIS([3, 4, -1, 0, 6, 2, 3]) 4 >>> length_of_LIS([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6","solution":"def length_of_LIS(nums): Given an unsorted array of integers, return the length of the longest increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def count_names(n: int, names: List[str]) -> Dict[str, int]: This function takes an integer n and a list of names, and returns a dictionary with the names as keys and their frequencies as values, sorted in alphabetical order. >>> count_names(5, [\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Charles\\", \\"Bob\\"]) == {'Alice': 2, 'Bob': 2, 'Charles': 1} >>> count_names(3, [\\"Charlie\\", \\"Charlie\\", \\"Charlie\\"]) == {'Charlie': 3} def format_output(name_counts: Dict[str, int]) -> str: This function takes a dictionary of name counts and returns a formatted string for output. >>> format_output({'Alice': 2, 'Bob': 2, 'Charles': 1}) \\"Alice 2nBob 2nCharles 1\\" >>> format_output({'Charlie': 3}) \\"Charlie 3\\"","solution":"def count_names(n, names): This function takes an integer n and a list of names, and returns a dictionary with the names as keys and their frequencies as values, sorted in alphabetical order. from collections import defaultdict name_count = defaultdict(int) for name in names: name_count[name] += 1 sorted_names = sorted(name_count.items()) return {name: count for name, count in sorted_names} def format_output(name_counts): This function takes a dictionary of name counts and returns a formatted string for output. output = [] for name, count in name_counts.items(): output.append(f\\"{name} {count}\\") return \\"n\\".join(output)"},{"question":"def order_summary(n: int, orders: List[str]) -> List[str]: This function takes the number of orders and a list of dish names, and returns the summary of orders sorted by frequency and then alphabetically. >>> order_summary(7, [\\"pasta\\", \\"pizza\\", \\"burger\\", \\"pizza\\", \\"pasta\\", \\"pasta\\", \\"salad\\"]) [\\"pasta 3\\", \\"pizza 2\\", \\"burger 1\\", \\"salad 1\\"] >>> order_summary(5, [\\"sushi\\", \\"ramen\\", \\"sushi\\", \\"burger\\", \\"ramen\\"]) [\\"ramen 2\\", \\"sushi 2\\", \\"burger 1\\"]","solution":"def order_summary(n, orders): This function takes the number of orders and a list of dish names, and returns the summary of orders sorted by frequency and then alphabetically. from collections import Counter # Use counter to track frequency of each order order_counts = Counter(orders) # Sort firstly by frequency in descending order, then by dish name sorted_orders = sorted(order_counts.items(), key=lambda x: (-x[1], x[0])) # Formatting the output result = [f\\"{dish} {count}\\" for dish, count in sorted_orders] return result"},{"question":"from typing import List, Tuple def max_sum_subgrid(N: int, M: int, grid: List[List[int]]) -> int: Finds the maximum sum of a rectangular sub-grid with at least one element. :param N: Number of rows in the grid. :param M: Number of columns in the grid. :param grid: 2D list representing the grid. :return: Maximum sum of a rectangular sub-grid. pass def parse_input(input_str: str) -> Tuple[int, int, List[List[int]]]: Parses the input string and returns the number of rows, number of columns, and the grid. :param input_str: Input string representing the grid data. :return: Tuple containing number of rows, number of columns and the grid. pass def main(input_str: str) -> int: Main function to process the input and find the maximum sum of a rectangular sub-grid. :param input_str: Input string representing the grid data. :return: Maximum sum of a rectangular sub-grid as an integer. pass # Unit tests def test_max_sum_subgrid(): assert main('2 3n1 2 3n4 5 6') == 21 assert main('4 5n0 0 0 0 0n0 0 0 0 0n0 0 0 0 1n0 0 0 0 0') == 1 assert main('3 3n1 2 3n-4 -5 -6n7 8 9') == 24 assert main('3 3n1 -2 3n4 -5 6n7 8 -9') == 15 assert main('1 1n0') == 0 assert main('1 1n1000') == 1000 assert main('3 4n1 1 1 1n1 1 1 1n1 1 1 1') == 12 assert main('2 3n-1 -2 -3n-4 -5 -6') == -1 if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def max_sum_subgrid(N, M, grid): Finds the maximum sum of a rectangular sub-grid with at least one element. :param N: Number of rows in the grid. :param M: Number of columns in the grid. :param grid: 2D list representing the grid. :return: Maximum sum of a rectangular sub-grid. max_sum = float('-inf') # Applying Kadane's algorithm on 2D array for left in range(M): temp = [0] * N for right in range(left, M): # Calculating sum of elements between left and right columns for each row for i in range(N): temp[i] += grid[i][right] # Apply Kadane's algorithm on temp array to find maximum subarray sum current_sum = 0 current_max = float('-inf') for val in temp: current_sum = max(val, current_sum + val) current_max = max(current_max, current_sum) max_sum = max(max_sum, current_max) return max_sum def parse_input(input_str): lines = input_str.strip().split('n') N, M = map(int, lines[0].split()) grid = [list(map(int, lines[i].split())) for i in range(1, N+1)] return N, M, grid def main(input_str): N, M, grid = parse_input(input_str) return max_sum_subgrid(N, M, grid)"},{"question":"def minimize_max_sum(n, m, A): Given an array of n integers, divide it into exactly m contiguous subarrays such that the maximum sum of the elements in any subarray is minimized. Return the minimized maximum sum. >>> minimize_max_sum(7, 3, [7, 2, 5, 10, 8]) 14 >>> minimize_max_sum(5, 2, [1, 2, 3, 4, 5]) 9 >>> minimize_max_sum(1, 1, [10]) 10 >>> minimize_max_sum(4, 2, [5, 5, 5, 5]) 10 >>> minimize_max_sum(6, 3, [1, 2, 3, 4, 5, 6]) 9 >>> minimize_max_sum(6, 3, [6, 5, 4, 3, 2, 1]) 9 >>> minimize_max_sum(4, 2, [10000, 10000, 10000, 10000]) 20000 >>> minimize_max_sum(3, 3, [10, 20, 30]) 30","solution":"def minimize_max_sum(n, m, A): def can_split(max_sum): subarray_count = 1 current_sum = 0 for num in A: if current_sum + num > max_sum: subarray_count += 1 current_sum = num if subarray_count > m: return False else: current_sum += num return True left, right = max(A), sum(A) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def inventory_management(n: int, transactions: List[str]) -> List[Union[int, str]]: Manage inventory transactions and return the results of CHECK and OUTOFSTOCK operations. Args: n (int): The number of transactions. transactions (List[str]): A list of transaction strings. Returns: List[Union[int, str]]: A list of results after processing CHECK and OUTOFSTOCK transactions. Examples: >>> inventory_management(7, [\\"DELIVER 1 50\\", \\"SELL 1 20\\", \\"CHECK 1\\", \\"SELL 1 30\\", \\"CHECK 1\\", \\"OUTOFSTOCK\\", \\"SELL 2 10\\"]) [30, 0, \\"1\\"]","solution":"def inventory_management(n, transactions): inventory = {} results = [] for transaction in transactions: parts = transaction.split() action = parts[0] if action == \\"DELIVER\\": product_id = int(parts[1]) qty = int(parts[2]) if product_id not in inventory: inventory[product_id] = 0 inventory[product_id] += qty elif action == \\"SELL\\": product_id = int(parts[1]) qty = int(parts[2]) if product_id not in inventory: inventory[product_id] = 0 inventory[product_id] -= qty if inventory[product_id] < 0: inventory[product_id] = 0 # Cannot have negative stock elif action == \\"CHECK\\": product_id = int(parts[1]) current_stock = inventory.get(product_id, 0) results.append(current_stock) elif action == \\"OUTOFSTOCK\\": out_of_stock_items = [id for id, qty in inventory.items() if qty == 0] if out_of_stock_items: results.append(\\" \\".join(map(str, sorted(out_of_stock_items)))) else: results.append(\\"None\\") return results"},{"question":"def cupcake_completion_times(n: int, orders: List[Tuple[int, int, int]]) -> List[int]: Calculate the completion times for each cupcake order. :param n: int - number of cupcake orders :param orders: list of tuples - each tuple contains (ti, wi, bi) where ti is preparation time, wi is waiting time, bi is baking time :return: list of int - completion times for each cupcake Examples: >>> cupcake_completion_times(3, [(1, 2, 3), (2, 1, 2), (3, 1, 1)]) [6, 11, 16] >>> cupcake_completion_times(4, [(2, 3, 1), (3, 2, 2), (1, 1, 4), (2, 2, 1)]) [8, 15, 21, 28] from typing import List, Tuple from solution import cupcake_completion_times def test_example_1(): orders = [(1, 2, 3), (2, 1, 2), (3, 1, 1)] assert cupcake_completion_times(3, orders) == [6, 11, 16] def test_example_2(): orders = [(2, 3, 1), (3, 2, 2), (1, 1, 4), (2, 2, 1)] assert cupcake_completion_times(4, orders) == [8, 15, 21, 28] def test_single_order(): orders = [(1, 5, 3)] assert cupcake_completion_times(1, orders) == [9] def test_multiple_orders_same_times(): orders = [(1, 1, 1), (1, 1, 1), (1, 1, 1)] assert cupcake_completion_times(3, orders) == [3, 6, 9] def test_large_values(): orders = [(100000, 100000, 100000), (100000, 100000, 100000)] assert cupcake_completion_times(2, orders) == [300000, 600000]","solution":"def cupcake_completion_times(n, orders): Calculate the completion times for each cupcake order. :param n: int - number of cupcake orders :param orders: list of tuples - each tuple contains (ti, wi, bi) where ti is preparation time, wi is waiting time, bi is baking time :return: list of int - completion times for each cupcake completion_times = [] current_time = 0 for order in orders: ti, wi, bi = order current_time += ti + wi + bi completion_times.append(current_time) return completion_times"},{"question":"def can_satisfy_requests(n: int, rooms: int, bookings: List[Tuple[int, int, int]]) -> str: Determine if all booking requests can be satisfied without conflicts. >>> can_satisfy_requests(2, 2, [(1, 1, 3), (2, 2, 5)]) 'POSSIBLE' >>> can_satisfy_requests(3, 2, [(1, 1, 3), (1, 2, 5), (2, 1, 4)]) 'IMPOSSIBLE' if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) rooms = int(data[1]) bookings = [(int(data[i]), int(data[i + 1]), int(data[i + 2])) for i in range(2, len(data), 3)] print(can_satisfy_requests(n, rooms, bookings))","solution":"def can_satisfy_requests(n, rooms, bookings): room_bookings = {i: [] for i in range(1, rooms + 1)} for room, check_in, check_out in bookings: if any((check_in < r_ck_out and check_out > r_ck_in) for r_ck_in, r_ck_out in room_bookings[room]): return \\"IMPOSSIBLE\\" room_bookings[room].append((check_in, check_out)) return \\"POSSIBLE\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) rooms = int(data[1]) bookings = [(int(data[i]), int(data[i + 1]), int(data[i + 2])) for i in range(2, len(data), 3)] print(can_satisfy_requests(n, rooms, bookings))"},{"question":"def apply_grid_updates(R: int, C: int, grid: List[List[int]], updates: List[Tuple[int, int, int, int, int]]) -> List[List[int]]: Applies a series of updates to a grid and returns the final state of the grid. Args: R: Number of rows in the grid. C: Number of columns in the grid. grid: Initial values of the grid in a list of lists. updates: A list of tuples where each tuple contains (r1, c1, r2, c2, v). Returns: A list of lists representing the final state of the grid. >>> R, C = 4, 5 >>> grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20] ] >>> updates = [ (1, 1, 2, 2, 100), (2, 3, 4, 4, 200), (1, 5, 4, 5, 300) ] >>> apply_grid_updates(R, C, grid, updates) [[100, 100, 3, 4, 300], [100, 100, 200, 200, 300], [11, 12, 200, 200, 300], [16, 17, 200, 200, 300]]","solution":"def apply_grid_updates(R, C, grid, updates): Applies a series of updates to a grid and returns the final state of the grid. Args: R: Number of rows in the grid. C: Number of columns in the grid. grid: Initial values of the grid in a list of lists. updates: A list of tuples where each tuple contains (r1, c1, r2, c2, v). Returns: A list of lists representing the final state of the grid. for r1, c1, r2, c2, v in updates: for i in range(r1-1, r2): # Adjusting for 1-based to 0-based indexing for j in range(c1-1, c2): # Adjusting for 1-based to 0-based indexing grid[i][j] = v return grid"},{"question":"from typing import List, Tuple def minimize_absolute_differences(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Given the number of test cases T, and for each test case, a list of integers representing the values on the stones, find the sequence of stones that minimizes the sum of absolute differences between adjacent stones. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple represents a test case. Each tuple contains an integer K, the number of stones, and a list of K integers representing the values on the stones. Returns: List[List[int]]: A list of lists where each inner list represents the sequence of integers representing the values on the stones in the order that minimizes the sum of absolute differences between adjacent stones. Example: >>> minimize_absolute_differences(2, [(3, [4, 2, 1]), (4, [10, 30, 20, 40])]) [[1, 2, 4], [10, 20, 30, 40]] >>> minimize_absolute_differences(1, [(1, [5])]) [[5]] from solution import minimize_absolute_differences def test_example_case1(): assert minimize_absolute_differences(2, [(3, [4, 2, 1]), (4, [10, 30, 20, 40])]) == [[1, 2, 4], [10, 20, 30, 40]] def test_single_element(): assert minimize_absolute_differences(1, [(1, [5])]) == [[5]] def test_two_elements(): assert minimize_absolute_differences(1, [(2, [100, -100])]) == [[-100, 100]] def test_large_elements(): assert minimize_absolute_differences(1, [(4, [1000000, -1000000, 500000, -500000])]) == [[-1000000, -500000, 500000, 1000000]] def test_mixed_signs(): assert minimize_absolute_differences(1, [(3, [0, -1, 1])]) == [[-1, 0, 1]]","solution":"def minimize_absolute_differences(T, test_cases): results = [] for i in range(T): K = test_cases[i][0] stones = test_cases[i][1] # Sort the stones to minimize the sum of absolute differences sorted_stones = sorted(stones) results.append(sorted_stones) return results # Example usage: # T = 2 # test_cases = [(3, [4, 2, 1]), (4, [10, 30, 20, 40])] # print(minimize_absolute_differences(T, test_cases))"},{"question":"def min_operations_to_beautiful_string(s: str) -> int: Find the minimum number of operations required to transform the given string into a beautiful string. A string is considered beautiful if it contains at most one character that appears an odd number of times, while all other characters appear an even number of times. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of operations required to transform the string into a beautiful string. Examples: >>> min_operations_to_beautiful_string(\\"abc\\") 2 >>> min_operations_to_beautiful_string(\\"aabbcc\\") 0 >>> min_operations_to_beautiful_string(\\"abacabad\\") 1","solution":"def min_operations_to_beautiful_string(s): from collections import Counter # Count the frequency of each character char_count = Counter(s) # Find the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # Since at most one character can have an odd frequency in a beautiful string # we need to make all other odd frequencies even, which means changing \`odd_count - 1\` characters return max(0, odd_count - 1)"},{"question":"def is_palindrome(s: str) -> bool: Determine if the given string is a palindrome when all non-alphanumeric characters are removed and the remaining characters are converted to lowercase. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"No 'x' in Nixon\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"!@#aba#@!\\") True >>> is_palindrome(\\"!@#abc#@!\\") False","solution":"def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome after removing all non-alphanumeric characters and normalizing to lowercase. Otherwise, returns False. # Remove non-alphanumeric characters and convert to lowercase cleaned = ''.join(char.lower() for char in s if char.isalnum()) # Check if the cleaned string is a palindrome return cleaned == cleaned[::-1]"},{"question":"import heapq import math from typing import List, Tuple def k_closest_points(points: List[Tuple[int, int]], k: int) -> List[Tuple[int, int]]: Finds the k closest points to the origin (0, 0). Args: points: List of tuples, where each tuple contains coordinates (x, y). k: Integer, the number of closest points to find. Returns: A list of tuples representing the k closest points to the origin. >>> k_closest_points([(1, 3), (-2, 2), (5, 8), (0, 0), (-1, -1)], 2) [(0, 0), (-1, -1)] >>> k_closest_points([(3, 3), (5, -1), (-2, 4)], 3) [(3, 3), (5, -1), (-2, 4)]","solution":"import heapq import math def k_closest_points(points, k): Finds the k closest points to the origin (0, 0). Parameters: points (list of tuples): List of points as (x, y). k (int): Number of closest points to find. Returns: list of tuples: k closest points to the origin in no particular order. # Create a list of tuples (distance_squared, x, y) distances = [] for x, y in points: distance_squared = x ** 2 + y ** 2 distances.append((distance_squared, x, y)) # Use a min-heap to get the k points with smallest distance_squared k_closest = heapq.nsmallest(k, distances) # Extract the points from the heap tuples and return them return [(x, y) for _, x, y in k_closest]"},{"question":"def validate_tasks(tasks: List[List[str]]) -> List[str]: Validate job intervals within tasks and find the maximum number of consecutively running jobs. >>> validate_tasks([[\\"08:00-09:00\\", \\"09:00-10:00\\", \\"10:00-11:00\\"], [\\"09:00-10:00\\", \\"10:00-11:00\\", \\"10:30-11:30\\", \\"11:00-12:00\\"]]) [\\"Valid: 3\\", \\"Invalid\\"] >>> validate_tasks([[\\"08:00-09:00\\"]]) [\\"Valid: 1\\"] def process_input(input_lines: List[str]) -> List[List[str]]: Process the input and return the task lists. >>> process_input([\\"2\\", \\"3\\", \\"08:00-09:00\\", \\"09:00-10:00\\", \\"10:00-11:00\\", \\"4\\", \\"09:00-10:00\\", \\"10:00-11:00\\", \\"10:30-11:30\\", \\"11:00-12:00\\", \\"0\\"]) [[\\"08:00-09:00\\", \\"09:00-10:00\\", \\"10:00-11:00\\"], [\\"09:00-10:00\\", \\"10:00-11:00\\", \\"10:30-11:30\\", \\"11:00-12:00\\"]] # Unit tests def test_validate_tasks(): input_lines = [ \\"2\\", \\"3\\", \\"08:00-09:00\\", \\"09:00-10:00\\", \\"10:00-11:00\\", \\"4\\", \\"09:00-10:00\\", \\"10:00-11:00\\", \\"10:30-11:30\\", \\"11:00-12:00\\", \\"0\\" ] tasks = process_input(input_lines) results = validate_tasks(tasks) assert results[0] == \\"Valid: 3\\" assert results[1] == \\"Invalid\\" def test_validate_tasks_single_interval(): input_lines = [ \\"1\\", \\"1\\", \\"08:00-09:00\\", \\"0\\" ] tasks = process_input(input_lines) results = validate_tasks(tasks) assert results[0] == \\"Valid: 1\\" def test_validate_tasks_no_consecutive_jobs(): input_lines = [ \\"1\\", \\"3\\", \\"08:00-09:00\\", \\"09:30-10:30\\", \\"11:00-12:00\\", \\"0\\" ] tasks = process_input(input_lines) results = validate_tasks(tasks) assert results[0] == \\"Valid: 1\\" def test_validate_tasks_overlapping_intervals(): input_lines = [ \\"1\\", \\"3\\", \\"08:00-09:00\\", \\"08:30-09:30\\", \\"09:00-10:00\\", \\"0\\" ] tasks = process_input(input_lines) results = validate_tasks(tasks) assert results[0] == \\"Invalid\\"","solution":"def validate_tasks(tasks): def convert_to_minutes(time_str): hh, mm = map(int, time_str.split(\\":\\")) return hh * 60 + mm results = [] for task in tasks: intervals = [] for interval in task: start, end = interval.split('-') start_minutes = convert_to_minutes(start) end_minutes = convert_to_minutes(end) intervals.append((start_minutes, end_minutes)) # Sort intervals by start time intervals.sort() last_end_time = 0 max_consecutive_jobs = 0 consecutive_jobs = 0 valid = True for start, end in intervals: if last_end_time > start: valid = False break if last_end_time == start: consecutive_jobs += 1 else: max_consecutive_jobs = max(max_consecutive_jobs, consecutive_jobs) consecutive_jobs = 1 last_end_time = end max_consecutive_jobs = max(max_consecutive_jobs, consecutive_jobs) if valid: results.append(f\\"Valid: {max_consecutive_jobs}\\") else: results.append(\\"Invalid\\") return results def process_input(input_lines): tasks = [] index = 0 T = int(input_lines[index]) index += 1 while T > 0: N = int(input_lines[index]) index += 1 task = [] for _ in range(N): task.append(input_lines[index]) index += 1 tasks.append(task) T -= 1 return tasks"},{"question":"def max_subarray_sum(arr): Returns the largest sum of any contiguous subarray within the input array. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5, 4, -1, 7, 8]) == 23 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([-2, -3, -4, -1, -2, -1, -5, -4]) == -1 >>> large_input = [x for x in range(-1000000, 1000001)] >>> max_subarray_sum(large_input) == sum(range(1, 1000001))","solution":"def max_subarray_sum(arr): Returns the largest sum of any contiguous subarray within the input array. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def maximum_path_sum(M: int, N: int, grid: List[List[int]]) -> int: Function to find the maximum path sum from any cell in the top row to any cell in the bottom row. Parameters: M (int): the number of rows in the grid. N (int): the number of columns in the grid. grid (list of lists): the grid containing the cell costs. Returns: int: the maximum path sum. Examples: >>> maximum_path_sum(3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9]]) 18 >>> maximum_path_sum(2, 2, [ [1, 2], [3, 4]]) 6","solution":"def maximum_path_sum(M, N, grid): Function to find the maximum path sum from any cell in the top row to any cell in the bottom row. Parameters: M (int): the number of rows in the grid. N (int): the number of columns in the grid. grid (list of lists): the grid containing the cell costs. Returns: int: the maximum path sum. # Create a DP array initialized with the same values as the grid dp = [[0] * N for _ in range(M)] # Initialize the first row of dp array with the first row of the grid for j in range(N): dp[0][j] = grid[0][j] # Fill in the dp array from the second row to the last row for i in range(1, M): for j in range(N): # Cost to enter this cell max_from_above = dp[i-1][j] # from directly above if j > 0: max_from_above = max(max_from_above, dp[i-1][j-1]) # from left-diagonal if j < N-1: max_from_above = max(max_from_above, dp[i-1][j+1]) # from right-diagonal dp[i][j] = grid[i][j] + max_from_above # The result is the maximum value in the last row return max(dp[M-1])"},{"question":"def longest_increasing_water_levels(water_levels): Returns the length of the longest continuous increase period in the water levels list. The list ends with -1 which should not be considered as part of the input. >>> longest_increasing_water_levels([3, 2, 5, 7, 5, 6, 8, 10, -1]) 4 >>> longest_increasing_water_levels([3, 3, 3, 3, 3, -1]) 0 >>> longest_increasing_water_levels([1, 2, 3, 4, 5, -1]) 5 >>> longest_increasing_water_levels([5, 4, 3, 2, 1, -1]) 0","solution":"def longest_increasing_water_levels(water_levels): Returns the length of the longest continuous increase period in the water levels list. The list ends with -1 which should not be considered as part of the input. # Remove the ending -1 if water_levels[-1] == -1: water_levels = water_levels[:-1] max_len = 0 current_len = 0 for i in range(1, len(water_levels)): if water_levels[i] > water_levels[i - 1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 # Adding 1 because the length of period is counted as the number of elements in it if max_len > 0: max_len += 1 return max_len"},{"question":"def min_supply_managers(N: int) -> int: Determine the minimum number of supply managers needed to ensure every supply station across all N checkpoints is managed. >>> min_supply_managers(5) 2 >>> min_supply_managers(6) 2 >>> min_supply_managers(10) 4","solution":"def min_supply_managers(N): Returns the minimum number of supply managers needed to manage all supply stations. # Each supply manager covers 3 checkpoints. # The optimal placement is to utilize the fact that each manager can cover 3 consecutive checkpoints. return (N + 2) // 3"},{"question":"def can_be_palindrome(s: str) -> str: Determine if a string can be rearranged into a palindrome by reversing some substrings. :param s: Input string :type s: str :return: \\"YES\\" if the string can be rearranged to a palindrome, otherwise \\"NO\\" :rtype: str from collections import Counter def test_can_be_palindrome(): assert can_be_palindrome(\\"abccbax\\") == \\"YES\\" assert can_be_palindrome(\\"abcde\\") == \\"NO\\" assert can_be_palindrome(\\"aabb\\") == \\"YES\\" assert can_be_palindrome(\\"nursesrun\\") == \\"YES\\" assert can_be_palindrome(\\"school\\") == \\"NO\\" assert can_be_palindrome(\\"a\\") == \\"YES\\" assert can_be_palindrome(\\"aa\\") == \\"YES\\" assert can_be_palindrome(\\"aaa\\") == \\"YES\\" assert can_be_palindrome(\\"ab\\") == \\"NO\\" assert can_be_palindrome(\\"abc\\") == \\"NO\\" assert can_be_palindrome(\\"\\") == \\"YES\\" # Edge case: empty string","solution":"def can_be_palindrome(s): Determine if a string can be rearranged into a palindrome by reversing some substrings. :param s: Input string :type s: str :return: \\"YES\\" if the string can be rearranged to a palindrome, otherwise \\"NO\\" :rtype: str from collections import Counter # Count frequencies of all characters freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # To form a palindrome, there should be at most one character with an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def compressString(s: str) -> str: Compress a given string by replacing sequences of the same character by that character followed by the length of the sequence. If the compressed string is not shorter than the original string, return the original string. >>> compressString('aaabcccccaaa') 'a3b1c5a3' >>> compressString('abc') 'abc' >>> compressString('aabcccccaaa') 'a2b1c5a3'","solution":"def compressString(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) # for the last group of characters compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def is_galactic_array(n: int, arr: List[int]) -> str: Determine if the given array is a galactic array. Parameters: n (int): Length of the array arr (list of int): The elements of the array Returns: str: \\"YES\\" if the array is a galactic array, otherwise \\"NO\\" Examples: >>> is_galactic_array(5, [1, 2, 1, 0, 1]) \\"YES\\" >>> is_galactic_array(3, [4, 5, 4]) \\"YES\\" >>> is_galactic_array(4, [3, 2, 4, 3]) \\"NO\\" >>> is_galactic_array(6, [6, 7, 6, 5, 6, 7]) \\"YES\\" >>> is_galactic_array(2, [1, 1]) \\"NO\\" pass","solution":"def is_galactic_array(n, arr): Determine if the given array is a galactic array. Parameters: n (int): Length of the array arr (list of int): The elements of the array Returns: str: \\"YES\\" if the array is a galactic array, otherwise \\"NO\\" for i in range(1, n): if abs(arr[i] - arr[i - 1]) != 1: return \\"NO\\" return \\"YES\\""},{"question":"def minimum_fence_length(num_cases: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum length of the fence required for each test case. The function takes in the number of test cases and a list of tuples, where each tuple contains: - the number of different colors - a list of integers representing the number of lights required for each color The function returns a list of integers denoting the minimum length of the fence required for each test case. def process_input(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Process the input string and returns the number of test cases and a list of tuples. Each tuple contains: - the number of different colors (int) - a list of integers representing the number of lights required for each color (List[int]) >>> process_input(\\"2n3n8 6 9n4n5 2 3 7n\\") (2, [(3, [8, 6, 9]), (4, [5, 2, 3, 7])]) # Test cases def test_case_1(): input_data = \\"2n3n8 6 9n4n5 2 3 7n\\" num_cases, cases = process_input(input_data) results = minimum_fence_length(num_cases, cases) assert results == [23, 17] def test_case_2(): input_data = \\"1n5n1 1 1 1 1n\\" num_cases, cases = process_input(input_data) results = minimum_fence_length(num_cases, cases) assert results == [5] def test_case_3(): input_data = \\"3n2n1 2n3n3 3 3n1n10n\\" num_cases, cases = process_input(input_data) results = minimum_fence_length(num_cases, cases) assert results == [3, 9, 10] # Add more tests as needed","solution":"import math def minimum_fence_length(num_cases, cases): results = [] for case in cases: num_colors, lights = case length = sum(lights) results.append(length) return results def process_input(input_data): lines = input_data.strip().split('n') num_cases = int(lines[0]) cases = [] index = 1 for _ in range(num_cases): num_colors = int(lines[index]) lights = list(map(int, lines[index+1].strip().split())) cases.append((num_colors, lights)) index += 2 return num_cases, cases # Sample inputs input_data = 2 3 8 6 9 4 5 2 3 7 num_cases, cases = process_input(input_data) results = minimum_fence_length(num_cases, cases) for result in results: print(result)"},{"question":"from typing import List, Tuple, Union def max_items_with_budget(test_cases: List[Tuple[int, List[List[int]]]]) -> List[Union[int, str]]: Determine the maximum number of items you can buy without exceeding the budget, where you must purchase exactly one item from each of several provided categories. :param test_cases: List of tuples containing budget and categories with item prices. :return: List of results, either a number of categories or \\"Not Possible\\". >>> max_items_with_budget([(50, [[10, 20], [5, 30, 40], [15, 25]])]) [3] >>> max_items_with_budget([(80, [[30, 20, 50], [10, 70]])]) [2] >>> max_items_with_budget([(10, [[20, 30], [40, 50]])]) [\\"Not Possible\\"] >>> max_items_with_budget([(35, [[10, 20], [5, 8], [7, 10]])]) [3] >>> max_items_with_budget([(15, [[10, 15]])]) [1] >>> max_items_with_budget([(100, [[30, 20, 50], [10, 70], [15, 25, 35], [5, 40]])]) [4] pass # replace with function implementation def process_input(input: str) -> List[Tuple[int, List[List[int]]]]: Process the given input to extract test cases. :param input: Multiline string input representing test cases. :return: List of tuples containing budget and categories with item prices. pass # replace with function implementation","solution":"def max_items_with_budget(test_cases): results = [] for B, categories in test_cases: min_costs = [] for items in categories: min_cost = min(items) min_costs.append(min_cost) total_min_cost = sum(min_costs) if total_min_cost <= B: results.append(len(categories)) else: results.append(\\"Not Possible\\") return results def process_input(input): lines = input.strip().split(\\"n\\") T = int(lines.pop(0)) test_cases = [] index = 0 for _ in range(T): B = int(lines[index]) C = int(lines[index + 1]) categories = [] index += 2 for _ in range(C): category_data = list(map(int, lines[index].split())) items = category_data[1:] categories.append(items) index += 1 test_cases.append((B, categories)) return test_cases"},{"question":"def max_total_score(diceScores: List[int]) -> int: Given an array of integers representing the highest score for each die, return the highest possible total score by rolling all the dice once. >>> max_total_score([6]) 6 >>> max_total_score([6, 8, 7, 9]) 30 >>> max_total_score([1, 2, 3, 4, 5]) 15 >>> max_total_score([1000, 1000, 1000, 1000, 1000]) 5000 >>> max_total_score([1]) 1 >>> max_total_score([1, 1, 1, 1, 1]) 5 >>> max_total_score([3, 7, 5, 8]) 23 >>> max_total_score([10, 20, 30, 40, 50]) 150 >>> max_total_score([1000] * (10**6)) 1000000000","solution":"def max_total_score(diceScores): Given an array of integers representing the highest score for each die, return the highest possible total score by rolling all the dice once. return sum(diceScores)"},{"question":"def subarray_sum_zero(nums: List[int], k: int) -> str: Determines whether there is a contiguous subarray of length \`k\` or more that sums to zero. Args: nums (List[int]): The array of integers. k (int): The minimum length of the contiguous subarray. Returns: str: \\"YES\\" if such a subarray exists, otherwise \\"NO\\". >>> subarray_sum_zero([1, -1, 3, 2, -2], 3) \\"YES\\" >>> subarray_sum_zero([1, 2, 3, 4, 5], 3) \\"NO\\" >>> subarray_sum_zero([1, -1, -1, 1, 0], 2) \\"YES\\" >>> subarray_sum_zero([0, 0, 0, 0], 1) \\"YES\\" >>> subarray_sum_zero([10, -3, -7, 4, -4], 3) \\"YES\\" >>> subarray_sum_zero([5, 6, -11, 8, 2], 5) \\"YES\\"","solution":"def subarray_sum_zero(nums, k): Determines whether there is a contiguous subarray of length \`k\` or more that sums to zero. n = len(nums) # Helper function to check for a subarray with sum zero def has_zero_sum(nums): prefix_sum = 0 seen = {0} # Initial prefix sum is zero for num in nums: prefix_sum += num if prefix_sum in seen: return True seen.add(prefix_sum) return False # Sliding window to check subarrays of length k or more for start in range(n - k + 1): for end in range(start + k, n + 1): if has_zero_sum(nums[start:end]): return \\"YES\\" return \\"NO\\""},{"question":"def shortest_path_k_edges(n: int, m: int, k: int, edges: List[Tuple[int, int, int]]) -> int: Find the length of the shortest path from vertex 1 to vertex n using exactly k edges. Args: n (int): Number of vertices m (int): Number of edges k (int): Exact number of edges to be used in the path edges (List[Tuple[int, int, int]]): List of edges (u, v, w) where u and v are vertices and w is the edge weight Returns: int: Length of the shortest path with exactly k edges, or -1 if no such path exists Examples: >>> shortest_path_k_edges(4, 4, 2, [(1, 2, 5), (1, 3, 10), (2, 4, 1), (3, 4, 2)]) 6 >>> shortest_path_k_edges(3, 3, 2, [(1, 2, 1), (2, 3, 1), (1, 3, 3)]) 2","solution":"import heapq def shortest_path_k_edges(n, m, k, edges): graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] if v not in graph: graph[v] = [] graph[u].append((v, w)) graph[v].append((u, w)) # DP table to store the shortest distance using exactly \`j\` edges from vertex 1 to \`i\` dp = [[float('inf')] * (k + 1) for _ in range(n + 1)] dp[1][0] = 0 pq = [(0, 1, 0)] # Current distance, current vertex, number of edges used while pq: dist, vertex, edges_used = heapq.heappop(pq) if edges_used == k: continue for neighbor, weight in graph.get(vertex, []): new_dist = dist + weight if new_dist < dp[neighbor][edges_used + 1]: dp[neighbor][edges_used + 1] = new_dist heapq.heappush(pq, (new_dist, neighbor, edges_used + 1)) return dp[n][k] if dp[n][k] != float('inf') else -1"},{"question":"def num_ways_to_paint_fence(n: int, k: int) -> int: A painter needs to paint a fence with n posts using k colors. He can paint each post with one of the k colors, but he must not paint three consecutive posts with the same color. Given n and k, find the number of ways to paint the fence, modulo 1000000007 (10^9 + 7). >>> num_ways_to_paint_fence(3, 2) 6 >>> num_ways_to_paint_fence(4, 3) 66 from solution import num_ways_to_paint_fence def test_num_ways_to_paint_fence_example1(): assert num_ways_to_paint_fence(3, 2) == 6 def test_num_ways_to_paint_fence_example2(): assert num_ways_to_paint_fence(4, 3) == 66 def test_num_ways_to_paint_fence_edge_cases(): assert num_ways_to_paint_fence(0, 3) == 0 assert num_ways_to_paint_fence(1, 3) == 3 assert num_ways_to_paint_fence(2, 1) == 1 def test_num_ways_to_paint_fence_large_values(): assert num_ways_to_paint_fence(1000, 1000) # Just to ensure it doesn't raise any exceptions def test_num_ways_to_paint_fence_single_color(): assert num_ways_to_paint_fence(3, 1) == 0 assert num_ways_to_paint_fence(2, 1) == 1 assert num_ways_to_paint_fence(1, 1) == 1","solution":"def num_ways_to_paint_fence(n, k): MOD = 1000000007 if n == 0: return 0 if n == 1: return k same = k diff = k * (k - 1) for i in range(3, n + 1): prev_diff = diff diff = (same + diff) * (k - 1) % MOD same = prev_diff return (same + diff) % MOD"},{"question":"def two_sum_exists(arr, target): Determine if there are two distinct elements in the array that sum up to the target value. Constraints: - 2 <= N <= 100,000 - Array elements and the target value are integers within the range of -10^9 to 10^9 Parameters: arr (List[int]): A list of integers. target (int): An integer target value. Returns: str: \\"YES\\" if there exist two distinct elements in the array that sum up to the target value. Otherwise, \\"NO\\". Examples: >>> two_sum_exists([2, 7, 11, 15, 1], 18) \\"YES\\" >>> two_sum_exists([1, 2, 3, 4], 8) \\"NO\\" >>> two_sum_exists([-1, 1, 2, -2, 3, 4], 2) \\"YES\\" >>> two_sum_exists([4, 5, 6], 1) \\"NO\\" pass","solution":"def two_sum_exists(arr, target): Determines if there are two distinct elements in the array that sum up to the target value. seen = set() for number in arr: if target - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"from typing import List, Tuple def unique_elements_in_subarray(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Computes the number of unique elements in each subarray specified by the queries. Parameters: n (int): Size of the array q (int): Number of queries array (list of int): The elements of the array queries (list of tuples): Each tuple contains two integers representing the range [li, ri] Returns: list of int: The number of unique elements for each query Examples: >>> unique_elements_in_subarray(10, 3, [1, 2, 1, 3, 4, 2, 5, 6, 7, 8], [(1, 5), (4, 8), (1, 10)]) [4, 5, 8] >>> unique_elements_in_subarray(5, 2, [1, 2, 3, 4, 5], [(1, 1), (3, 3)]) [1, 1] Test cases: >>> test_example_case() >>> test_with_single_element_subarray() >>> test_with_repeated_elements() >>> test_all_elements_unique() >>> test_single_query_full_array() >>> test_multiple_queries_full_and_partial_arrays() >>> test_large_identical_elements() # Implementation goes here def test_example_case(): n = 10 q = 3 array = [1, 2, 1, 3, 4, 2, 5, 6, 7, 8] queries = [(1, 5), (4, 8), (1, 10)] assert unique_elements_in_subarray(n, q, array, queries) == [4, 5, 8] def test_with_single_element_subarray(): n = 5 q = 2 array = [1, 2, 3, 4, 5] queries = [(1, 1), (3, 3)] assert unique_elements_in_subarray(n, q, array, queries) == [1, 1] def test_with_repeated_elements(): n = 6 q = 2 array = [1, 2, 2, 3, 3, 3] queries = [(1, 6), (2, 4)] assert unique_elements_in_subarray(n, q, array, queries) == [3, 2] def test_all_elements_unique(): n = 4 q = 1 array = [1, 2, 3, 4] queries = [(1, 4)] assert unique_elements_in_subarray(n, q, array, queries) == [4] def test_single_query_full_array(): n = 5 q = 1 array = [1, 2, 3, 4, 5] queries = [(1, 5)] assert unique_elements_in_subarray(n, q, array, queries) == [5] def test_multiple_queries_full_and_partial_arrays(): n = 7 q = 3 array = [3, 3, 3, 4, 4, 5, 5] queries = [(1, 3), (1, 7), (4, 7)] assert unique_elements_in_subarray(n, q, array, queries) == [1, 3, 2] def test_large_identical_elements(): n = 1000 q = 1 array = [1] * 1000 queries = [(1, 1000)] assert unique_elements_in_subarray(n, q, array, queries) == [1]","solution":"def unique_elements_in_subarray(n, q, array, queries): Computes the number of unique elements in each subarray specified by the queries. Parameters: n (int): Size of the array q (int): Number of queries array (list of int): The elements of the array queries (list of tuples): Each tuple contains two integers representing the range [li, ri] Returns: list of int: The number of unique elements for each query result = [] for l, r in queries: subarray = array[l-1:r] # Extracting the subarray (convert 1-based to 0-based index) unique_count = len(set(subarray)) result.append(unique_count) return result"},{"question":"def find_largest_x(matrix: List[List[int]]) -> int: Find the size of the largest 'X' that can be formed in a matrix. An 'X' is formed by connecting four '1's diagonally. Args: matrix (List[List[int]]): A 2D list representing the matrix of 0s and 1s. Returns: int: The size of the largest 'X' formed in the matrix. Example: >>> find_largest_x([ ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 1, 0, 1], ... [0, 1, 0, 1, 0], ... [1, 0, 1, 0, 1] ... ]) 3 >>> find_largest_x([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) 1","solution":"def find_largest_x(matrix): N = len(matrix) # Initialize the auxiliary DP matrices for calculating the size of 'X' top_left = [[0]*N for _ in range(N)] top_right = [[0]*N for _ in range(N)] bottom_left = [[0]*N for _ in range(N)] bottom_right = [[0]*N for _ in range(N)] # Fill the diagonally aligned matrices for i in range(N): for j in range(N): if matrix[i][j] == 1: if i == 0 or j == 0: top_left[i][j] = 1 else: top_left[i][j] = top_left[i-1][j-1] + 1 if i == 0 or j == N-1: top_right[i][j] = 1 else: top_right[i][j] = top_right[i-1][j+1] + 1 for i in range(N-1, -1, -1): for j in range(N): if matrix[i][j] == 1: if i == N-1 or j == 0: bottom_left[i][j] = 1 else: bottom_left[i][j] = bottom_left[i+1][j-1] + 1 if i == N-1 or j == N-1: bottom_right[i][j] = 1 else: bottom_right[i][j] = bottom_right[i+1][j+1] + 1 # Find the largest 'X' in the matrix largest_x = 0 for i in range(N): for j in range(N): arm_length = min(top_left[i][j], top_right[i][j], bottom_left[i][j], bottom_right[i][j]) if arm_length > largest_x: largest_x = arm_length return largest_x"},{"question":"def max_beauty_score(n: int, m: int, t: int, beauties: List[int]) -> int: Returns the maximum possible beauty score. n: int - number of different types of flowers. m: int - minimum number of different types of flowers in a row. t: int - maximum number of different types of flowers in a row. beauties: List[int] - list of beauty scores for each flower type. Examples: >>> max_beauty_score(5, 2, 3, [10, 20, 30, 40, 50]) 120 >>> max_beauty_score(4, 3, 4, [10, 15, 10, 20]) 55 >>> max_beauty_score(6, 4, 4, [5, 10, 15, 20, 25, 30]) 90 >>> max_beauty_score(3, 1, 2, [1, 100, 1000]) 1100 >>> max_beauty_score(8, 5, 6, [3, 6, 2, 8, 6, 3, 4, 7]) 34","solution":"def max_beauty_score(n, m, t, beauties): Returns the maximum possible beauty score. n: int - number of different types of flowers. m: int - minimum number of different types of flowers in a row. t: int - maximum number of different types of flowers in a row. beauties: List[int] - list of beauty scores for each flower type. # Sort the beauty scores in descending order beauties.sort(reverse=True) # Sum up the top 't' beauty scores return sum(beauties[:t])"},{"question":"def largest_connected_region(n: int, m: int, grid: List[List[int]]) -> int: Given a grid of size \`n\` x \`m\` filled with integers where each cell of the grid can be either occupied (denoted by 1) or free (denoted by 0), determine the size of the largest connected region comprising only occupied cells. Two cells are considered connected if they share a border horizontally or vertically. >>> n, m = 4, 5 >>> grid = [ ... [1, 1, 0, 0, 0], ... [0, 1, 1, 0, 1], ... [0, 0, 1, 0, 0], ... [1, 1, 0, 1, 0] ... ] >>> largest_connected_region(n, m, grid) 5 >>> n, m = 3, 3 >>> grid = [ ... [1, 1, 0], ... [0, 1, 1], ... [1, 0, 0] ... ] >>> largest_connected_region(n, m, grid) 4 >>> n, m = 5, 6 >>> grid = [ ... [0, 0, 1, 0, 0, 1], ... [1, 0, 1, 1, 0, 0], ... [0, 0, 0, 0, 1, 1], ... [0, 1, 1, 1, 0, 0], ... [0, 0, 1, 0, 0, 0] ... ] >>> largest_connected_region(n, m, grid) 4 pass","solution":"def largest_connected_region(n, m, grid): Returns the size of the largest connected region of 1s in the grid. def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0: return 0 grid[x][y] = 0 # Mark this cell as visited size = 1 # Initialize region size for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # directions: up, down, left, right size += dfs(x + dx, y + dy) return size max_region = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: max_region = max(max_region, dfs(i, j)) return max_region"},{"question":"def max_distinct_fruits(n: int, k: int, forest: List[List[int]]) -> int: Determines the maximum number of distinct types of magic fruits collected during the journey in the forest. Parameters: n (int): The size of the grid. k (int): The number of distinct types of magic fruits. forest (List[List[int]]): The grid representation of the forest. Returns: int: The maximum number of distinct types of fruits collected. pass # Example usage and test cases: def test_example_1(): n = 3 k = 3 forest = [ [1, 2, 3], [2, 2, 2], [3, 2, 1] ] assert max_distinct_fruits(n, k, forest) == 3 def test_example_2(): n = 4 k = 4 forest = [ [1, 1, 2, 3], [2, 3, 4, 1], [2, 2, 3, 4], [4, 1, 1, 3] ] assert max_distinct_fruits(n, k, forest) == 4 def test_example_3(): n = 2 k = 2 forest = [ [1, 2], [2, 2] ] assert max_distinct_fruits(n, k, forest) == 2 def test_single_cell(): n = 1 k = 1 forest = [ [1] ] assert max_distinct_fruits(n, k, forest) == 1 def test_all_same_fruit(): n = 3 k = 1 forest = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert max_distinct_fruits(n, k, forest) == 1 def test_max_distinct_fruits(): n = 5 k = 5 forest = [ [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [1, 2, 3, 4, 5] ] assert max_distinct_fruits(n, k, forest) == 5","solution":"def max_distinct_fruits(n, k, forest): Determines the maximum number of distinct types of magic fruits collected during the journey in the forest. Parameters: n (int): The size of the grid. k (int): The number of distinct types of magic fruits. forest (List[List[int]]): The grid representation of the forest. Returns: int: The maximum number of distinct types of fruits collected. from collections import defaultdict # Initialize a 3D array to store distinct fruits sets for each cell path dp = [[set() for _ in range(n)] for _ in range(n)] # Starting point dp[0][0].add(forest[0][0]) # Fill the DP table for i in range(n): for j in range(n): if i == 0 and j == 0: continue current_fruits = set() # Coming from the left if j > 0: current_fruits |= dp[i][j-1] # Coming from the top if i > 0: current_fruits |= dp[i-1][j] current_fruits.add(forest[i][j]) dp[i][j] = current_fruits # The answer will be the size of the set at the bottom-right corner return len(dp[n-1][n-1]) # Example usage: n = 3 k = 3 forest = [ [1, 2, 3], [2, 2, 2], [3, 2, 1] ] print(max_distinct_fruits(n, k, forest)) # Output: 3"},{"question":"def decode_message(s: str) -> str: Decodes the given encrypted message by moving uppercase letters to the start, appending digits to the end, discarding other characters, and then reversing the string. Args: s (str): The encoded message string containing uppercase, lowercase letters, digits, and special characters. Returns: str: The decoded message string. Examples: >>> decode_message(\\"a1B2cC3@D#4\\") '4321DCB' >>> decode_message(\\"ABC\\") 'CBA' >>> decode_message(\\"1234\\") '4321' >>> decode_message(\\"a1@B2#C3D4!\\") '4321DCB' >>> decode_message(\\"abc!@#\\") ''","solution":"def decode_message(s): Decodes the given encrypted message by moving uppercase letters to the start, appending digits to the end, discarding other characters, and then reversing the string. uppers = [] digits = [] for char in s: if char.isupper(): uppers.append(char) elif char.isdigit(): digits.append(char) combined = ''.join(uppers) + ''.join(digits) return combined[::-1]"},{"question":"def largest_right_angled_triangle_area(points: list[tuple[int, int]]) -> int: Returns the largest area of a right-angled triangle that can be formed using any three given points with sides parallel to the X-axis or Y-axis. Args: points (list of tuples): A list where each tuple contains two integers representing the coordinates of the points. >>> largest_right_angled_triangle_area([(1, 2), (3, 2), (1, 4), (3, 6), (5, 4)]) 4 >>> largest_right_angled_triangle_area([(1, 1), (2, 2), (3, 3), (4, 4)]) 0 >>> largest_right_angled_triangle_area([(0, 0), (0, 1), (1, 0)]) 1 from solution import largest_right_angled_triangle_area def test_example_1(): points = [(1, 2), (3, 2), (1, 4), (3, 6), (5, 4)] assert largest_right_angled_triangle_area(points) == 4 def test_example_2(): points = [(1, 1), (2, 2), (3, 3), (4, 4)] assert largest_right_angled_triangle_area(points) == 0 def test_example_3(): points = [(0, 0), (0, 1), (1, 0)] assert largest_right_angled_triangle_area(points) == 1 def test_large_gap(): points = [(0, 0), (100, 0), (0, 50)] assert largest_right_angled_triangle_area(points) == 5000 def test_small_set(): points = [(0, 0), (0, 1), (1, 1), (1, 0)] assert largest_right_angled_triangle_area(points) == 1 def test_no_triangle(): points = [(0, 0), (2, 2), (4, 4)] assert largest_right_angled_triangle_area(points) == 0","solution":"def largest_right_angled_triangle_area(points): Returns the largest area of a right-angled triangle that can be formed using any three given points with sides parallel to the X-axis or Y-axis. from collections import defaultdict x_points = defaultdict(list) y_points = defaultdict(list) for x, y in points: x_points[x].append(y) y_points[y].append(x) max_area = 0 for x_set in x_points.values(): x_set.sort() if len(x_set) >= 2: base_options = [ (x_set[i+1] - x_set[i]) for i in range(len(x_set) - 1) ] max_base = max(base_options) for x_base in base_options: for base_start_y in x_set: grouping_y = [ y - base_start_y for y in y_points[base_start_y] if y != base_start_y ] if grouping_y: max_height = max(grouping_y) max_area = max(max_area, x_base * max_height) return max_area"},{"question":"def count_unique_codes() -> int: Returns the count of possible unique codes made of exactly 4 uppercase English letters. >>> count_unique_codes() 456976","solution":"def count_unique_codes(): Returns the count of possible unique codes made of exactly 4 uppercase English letters. # There are 26 uppercase English letters and we need to create 4 character codes. result = 26 ** 4 return result"},{"question":"def rearrange_string(s: str) -> str: Rearrange characters of the input string so that no two adjacent characters are the same. If it's not possible, return an empty string. :param s: input string consisting of lowercase English letters :return: rearranged string or an empty string if not possible >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaab\\") == \\"\\" True >>> rearrange_string(\\"aaabbc\\") in [\\"ababac\\", \\"abacab\\", \\"abacba\\"] True >>> rearrange_string(\\"aaaaa\\") == \\"\\" True >>> rearrange_string(\\"ab\\") in [\\"ab\\", \\"ba\\"] True >>> result = rearrange_string(\\"aabb\\"); result in [\\"abab\\", \\"baba\\", \\"bbaa\\", \\"aabb\\"] True >>> rearrange_string(\\"aa\\") == \\"\\" True >>> rearrange_string(\\"aaa\\") == \\"\\" True >>> rearrange_string(\\"a\\" * 100001) == \\"\\" True >>> rearrange_string(\\"\\") == \\"\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True # Your code here","solution":"import heapq from collections import Counter def rearrange_string(s): Rearrange characters of the input string so that no two adjacent characters are the same. If it's not possible, return an empty string. :param s: input string consisting of lowercase English letters :return: rearranged string or an empty string if not possible if not s: return \\"\\" char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # incrementing count as it's being used rearranged_string = ''.join(result) if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"def find_the_difference(s: str, t: str) -> str: You are given two strings, s and t. The string t is a randomly shuffled string with an extra character added to it. Your task is to find the extra character that was added to t. Constraints: * 1 ≤ |s| ≤ 1000 * t is a permutation of s with one additional character Input: s: str t: str Output: str The extra character in t. Examples: >>> find_the_difference('abcd', 'abcde') 'e' >>> find_the_difference('x', 'xk') 'k' >>> find_the_difference('hello', 'lhleoZ') 'Z'","solution":"def find_the_difference(s, t): Returns the extra character in t that was not present in s. s_sum = sum(ord(char) for char in s) t_sum = sum(ord(char) for char in t) return chr(t_sum - s_sum)"},{"question":"from typing import List def max_submatrix_sum(matrix: List[List[int]], n: int, m: int, MaxArea: int) -> int: Find the maximum sum of a rectangular submatrix in a given n x m matrix with an area not exceeding MaxArea. >>> max_submatrix_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3, 4) 28 >>> max_submatrix_sum([[-1, -2, -3, -4], [-5, -6, -7, -8], [-9, -10, -11, -12], [-13, -14, -15, -16]], 4, 4, 5) -1 >>> max_submatrix_sum([[5]], 1, 1, 1) 5 >>> max_submatrix_sum([[1, 2], [3, 4]], 2, 2, 10) 10 >>> max_submatrix_sum([[-3, -2, -1], [-4, -5, -6], [-7, -8, -9]], 3, 3, 2) -1","solution":"def max_submatrix_sum(matrix, n, m, MaxArea): def get_prefix_sums(matrix): prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = (matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) return prefix_sum def get_sum(x1, y1, x2, y2, prefix_sum): return (prefix_sum[x2 + 1][y2 + 1] - prefix_sum[x1][y2 + 1] - prefix_sum[x2 + 1][y1] + prefix_sum[x1][y1]) prefix_sum = get_prefix_sums(matrix) max_sum = float('-inf') for x1 in range(n): for y1 in range(m): for x2 in range(x1, n): for y2 in range(y1, m): area = (x2 - x1 + 1) * (y2 - y1 + 1) if area <= MaxArea: current_sum = get_sum(x1, y1, x2, y2, prefix_sum) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def distribute_tasks(n, tasks): Distribute tasks between Olivia and Ivan. Parameters: n (int): Number of tasks. tasks (list): List containing the difficulty levels of tasks. Returns: tuple: Two lists representing the tasks for Olivia and Ivan. Examples: >>> distribute_tasks(6, [6, 4, 3, 7, 8, 2]) ([2, 3, 4], [8, 7, 6]) >>> distribute_tasks(5, [5, 2, 9, 1, 3]) ([1, 2, 3], [9, 5]) # implement the function def test_distribute_tasks(): assert distribute_tasks(6, [6, 4, 3, 7, 8, 2]) == ([2, 3, 4], [8, 7, 6]) assert distribute_tasks(5, [5, 2, 9, 1, 3]) == ([1, 2, 3], [9, 5]) assert distribute_tasks(4, [1, 4, 2, 3]) == ([1, 2], [4, 3]) assert distribute_tasks(2, [1, 2]) == ([1], [2]) assert distribute_tasks(1, [5]) == ([5], []) assert distribute_tasks(3, [15, 10, 20]) == ([10, 15], [20]) def test_distribute_tasks_edge_case(): assert distribute_tasks(1, [1]) == ([1], []) assert distribute_tasks(2, [2, 1]) == ([1], [2]) assert distribute_tasks(3, [30, 10, 20]) == ([10, 20], [30]) assert distribute_tasks(4, [30, 10, 20, 40]) == ([10, 20], [40, 30])","solution":"def distribute_tasks(n, tasks): Distribute tasks between Olivia and Ivan. Parameters: n (int): Number of tasks. tasks (list): List containing the difficulty levels of tasks. Returns: tuple: Two lists representing the tasks for Olivia and Ivan. # Sort the tasks tasks.sort() # Olivia prefers the lowest, Ivan prefers the highest olivia_tasks = [] ivan_tasks = [] for i in range(n): if i % 2 == 0: olivia_tasks.append(tasks[i // 2]) else: ivan_tasks.append(tasks[-(i // 2 + 1)]) return olivia_tasks, ivan_tasks"},{"question":"def perform_operations(N: int, operations: list) -> list: Perform a series of operations and return the results. Parameters: N (int): Number of operations. operations (list of tuples): Each tuple contains ('operation_type', operand1, operand2). Returns: list: List of results from each operation. Example: >>> perform_operations(4, [('add', 3, 7), ('sub', 10, 4), ('mul', 6, 5), ('div', 20, 3)]) [10, 6, 30, 6] >>> perform_operations(1, [('add', 10**9, 10**9)]) [2000000000]","solution":"def perform_operations(N, operations): Perform a series of operations and return the results. Parameters: N (int): Number of operations. operations (list of tuples): Each tuple contains ('operation_type', operand1, operand2). Returns: list: List of results from each operation. results = [] for operation in operations: op_type, operand1, operand2 = operation if op_type == 'add': results.append(operand1 + operand2) elif op_type == 'sub': results.append(operand1 - operand2) elif op_type == 'mul': results.append(operand1 * operand2) elif op_type == 'div': results.append(operand1 // operand2) return results"},{"question":"import sys from typing import List def min_sum_of_absolute_differences(n: int, a: List[int], b: List[int]) -> int: You are given an integer n and a sequence a_1, a_2, ..., a_n and b_1, b_2, ..., b_m. The sequence of b has been permuted randomly and you are to find the minimum sum of absolute differences between pairs formed by a and b. In other words, you want to pair each a_i with some b_j such that the sum of |a_i - b_j| is minimized. Each element in the sequences a and b must be used exactly once. Input: - n: int, the length of sequences a and b. - a: List[int], a list of n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 1000). - b: List[int], a list of n integers b_1, b_2, ..., b_n (0 ≤ b_i ≤ 1000). Output: - int: the minimum sum of absolute differences between pairs. Examples: >>> min_sum_of_absolute_differences(3, [1, 3, 5], [4, 2, 8]) 5 >>> min_sum_of_absolute_differences(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 0 pass def test_min_sum_of_absolute_differences_example1(): assert min_sum_of_absolute_differences(3, [1, 3, 5], [4, 2, 8]) == 5 def test_min_sum_of_absolute_differences_example2(): assert min_sum_of_absolute_differences(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) == 0 def test_min_sum_of_absolute_differences_edge_case1(): assert min_sum_of_absolute_differences(1, [0], [1000]) == 1000 def test_min_sum_of_absolute_differences_edge_case2(): assert min_sum_of_absolute_differences(1, [1000], [1000]) == 0 def test_min_sum_of_absolute_differences_general_case1(): assert min_sum_of_absolute_differences(4, [1, 4, 7, 10], [2, 6, 8, 10]) == 4 def test_min_sum_of_absolute_differences_general_case2(): assert min_sum_of_absolute_differences(3, [10, 20, 30], [15, 25, 35]) == 15","solution":"def min_sum_of_absolute_differences(n, a, b): a.sort() b.sort() return sum(abs(a[i] - b[i]) for i in range(n))"},{"question":"def minimal_height_difference(n: int, heights: List[int]) -> int: Returns the minimal height difference between the tallest and shortest towers that can be achieved. >>> minimal_height_difference(5, [2, 6, 3, 4, 7]) 1 >>> minimal_height_difference(4, [1, 4, 7, 10]) 0 >>> minimal_height_difference(3, [5, 5, 5]) 0","solution":"def minimal_height_difference(n, heights): Returns the minimal height difference between the tallest and shortest towers that can be achieved. sorted_heights = sorted(heights) return sorted_heights[-1] - sorted_heights[0]"},{"question":"from typing import List, Set def longest_valid_substring_length(strings: List[str], valid_chars_set: Set[str]) -> int: This function finds the length of the longest substring from any of the strings in the list that can be formed using only the characters in the given set. :param strings: List of input strings :param valid_chars_set: Set of valid characters :return: Length of the longest valid substring >>> longest_valid_substring_length([\\"abcde\\", \\"ghijk\\", \\"lmnop\\"], {'a', 'b', 'c', 'd', 'e'}) 5 >>> longest_valid_substring_length([\\"abcxyz\\", \\"yyyzzz\\"], {'x', 'y', 'z'}) 6","solution":"def longest_valid_substring_length(strings, valid_chars_set): This function finds the length of the longest substring from any of the strings in the list that can be formed using only the characters in the given set. :param strings: List[str] : List of input strings :param valid_chars_set: Set[str] : Set of valid characters :return: int : Length of the longest valid substring def longest_in_string(s, valid_chars): max_len = 0 current_len = 0 for char in s: if char in valid_chars: current_len += 1 max_len = max(max_len, current_len) else: current_len = 0 return max_len max_length = 0 for string in strings: max_length = max(max_length, longest_in_string(string, valid_chars_set)) return max_length"},{"question":"def maximizeFood(food): Determines the maximum sum of food that can be safeguarded from the series of houses, with the condition that no two adjacent houses are both monitored by guards. >>> maximizeFood([1, 2, 3, 1]) 4 >>> maximizeFood([2, 7, 9, 3, 1]) 12 >>> maximizeFood([10]) 10 >>> maximizeFood([1, 2]) 2 >>> maximizeFood([2, 1]) 2 >>> maximizeFood([0, 0, 0, 0, 0]) 0 >>> maximizeFood([5, 1, 5, 1, 5, 1]) 15 >>> maximizeFood([i for i in range(1, 100001)]) 2500050000 >>> maximizeFood([104] * 100000) 5200000","solution":"def maximizeFood(food): Determines the maximum sum of food that can be safeguarded from the series of houses, with the condition that no two adjacent houses are both monitored by guards. if not food: return 0 n = len(food) if n == 1: return food[0] # Dynamic programming array to store the maximum food up to each house dp = [0] * n dp[0] = food[0] dp[1] = max(food[0], food[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + food[i]) return dp[-1]"},{"question":"def is_bipartite(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Determines if the graph is bipartite. :param n: Number of vertices :param m: Number of edges :param edges: List of edges represented as tuples (u, v) :return: 'Yes' if the graph is bipartite, 'No' otherwise from typing import List, Tuple from solution import is_bipartite def test_case_1(): n, m = 5, 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert is_bipartite(n, m, edges) == \\"No\\" def test_case_2(): n, m = 4, 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] assert is_bipartite(n, m, edges) == \\"Yes\\" def test_case_3(): n, m = 3, 3 edges = [(1, 2), (2, 3), (3, 1)] assert is_bipartite(n, m, edges) == \\"No\\" def test_case_4(): n, m = 2, 1 edges = [(1, 2)] assert is_bipartite(n, m, edges) == \\"Yes\\" def test_case_5(): n, m = 6, 6 edges = [ (1, 2), (1, 3), (2, 4), (2, 5), (3, 6) ] assert is_bipartite(n, m, edges) == \\"Yes\\" def test_case_6(): n, m = 1, 0 edges = [] assert is_bipartite(n, m, edges) == \\"Yes\\" def test_case_7(): n, m = 8, 7 edges = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8) ] assert is_bipartite(n, m, edges) == \\"Yes\\"","solution":"def is_bipartite(n, m, edges): Determines if the graph is bipartite. :param n: Number of vertices :param m: Number of edges :param edges: List of edges represented as tuples (u, v) :return: 'Yes' if the graph is bipartite, 'No' otherwise from collections import deque # Create the adjacency list adj = [[] for _ in range(n + 1)] for u, v in edges: adj[u].append(v) adj[v].append(u) # Colors array to store colors assigned to all vertices. colors = [-1] * (n + 1) def bfs_check(start): queue = deque([start]) colors[start] = 0 while queue: u = queue.popleft() for v in adj[u]: if colors[v] == -1: # Assign alternate color to this adjacent vertex colors[v] = 1 - colors[u] queue.append(v) elif colors[v] == colors[u]: # An adjacent vertex has the same color, not bipartite return False return True # Check using BFS for each component for i in range(1, n + 1): if colors[i] == -1: # Not colored yet if not bfs_check(i): return \\"No\\" return \\"Yes\\""},{"question":"def sort_packages(n: int, packages: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]: Sorts the packages based on their dimensions in non-decreasing order. Parameters: n (int): The number of packages. packages (list of tuples): List containing the dimensions of packages. Returns: list of tuples: Sorted dimensions of packages. Examples: >>> sort_packages(5, [(5, 4, 2), (3, 2, 1), (5, 4, 1), (3, 2, 3), (3, 3, 3)]) [(3, 2, 1), (3, 2, 3), (3, 3, 3), (5, 4, 1), (5, 4, 2)] >>> sort_packages(4, [(2, 5, 6), (2, 3, 4), (3, 2, 1), (2, 3, 2)]) [(2, 3, 2), (2, 3, 4), (2, 5, 6), (3, 2, 1)]","solution":"def sort_packages(n, packages): Sorts the packages based on their dimensions. Parameters: n (int): The number of packages. packages (list of tuples): List containing the dimensions of packages. Returns: list of tuples: Sorted dimensions of packages. packages.sort(key=lambda x: (x[0], x[1], x[2])) return packages"},{"question":"def sum_of_even_integers(datasets): Compute the sum of the even integers for each dataset. >>> sum_of_even_integers([[4, 2, 3, 4, 5], [3, 6, 7, 8], [1, 5], [0]]) [6, 14, 0] # Implementation here def parse_input(input_data): Parse the input string into a list of datasets. >>> parse_input(\\"4 2 3 4 5n3 6 7 8n1 5n0\\") [[4, 2, 3, 4, 5], [3, 6, 7, 8], [1, 5], [0]] # Implementation here def process_input(input_data): Process the input string and return the sums of even integers for each dataset. >>> process_input(\\"4 2 3 4 5n3 6 7 8n1 5n0\\") [6, 14, 0] # Implementation here","solution":"def sum_of_even_integers(datasets): results = [] for dataset in datasets: if dataset[0] == 0: break n = dataset[0] integers = dataset[1:n+1] even_sum = sum(x for x in integers if x % 2 == 0) results.append(even_sum) return results def parse_input(input_data): lines = input_data.strip().split('n') datasets = [] for line in lines: dataset = list(map(int, line.split())) datasets.append(dataset) return datasets def process_input(input_data): datasets = parse_input(input_data) return sum_of_even_integers(datasets)"},{"question":"def is_even_sum_possible(n: int, sweets: List[int]) -> str: Determine if a subset with an even sum of sweetness values exists. Parameters: n (int): The number of candies. sweets (List[int]): The sweetness values of the candies. Returns: str: 'Possible' if an even sum subset exists, otherwise 'Not Possible'. Examples: >>> is_even_sum_possible(5, [1, 3, 5, 7, 9]) 'Not Possible' >>> is_even_sum_possible(4, [2, 3, 5, 8]) 'Possible' pass # Unit Tests from solution import is_even_sum_possible def test_case_1(): assert is_even_sum_possible(5, [1, 3, 5, 7, 9]) == 'Not Possible' def test_case_2(): assert is_even_sum_possible(4, [2, 3, 5, 8]) == 'Possible' def test_case_3(): assert is_even_sum_possible(1, [2]) == 'Possible' def test_case_4(): assert is_even_sum_possible(1, [1]) == 'Not Possible' def test_case_5(): assert is_even_sum_possible(3, [1, 3, 5]) == 'Not Possible' def test_case_6(): assert is_even_sum_possible(2, [1, 2]) == 'Possible' def test_case_7(): assert is_even_sum_possible(3, [3, 1, 2]) == 'Possible'","solution":"def is_even_sum_possible(n, sweets): Determine if a subset with an even sum of sweetness values exists. Parameters: n (int): The number of candies. sweets (list of int): The sweetness values of the candies. Returns: str: 'Possible' if an even sum subset exists, otherwise 'Not Possible'. # If there is at least one even number, it is possible to have an even sum. for sweetness in sweets: if sweetness % 2 == 0: return 'Possible' # If all numbers are odd and there are at least two of them, their sum can be even. if n > 1: return 'Possible' if any(sweets[i] % 2 != sweets[j] % 2 for i in range(n-1) for j in range(i+1, n)) else 'Not Possible' else: return 'Not Possible'"},{"question":"def can_divide_plants(n: int, water_requirements: List[int]) -> str: Determine if it's possible to divide the plants into two groups with equal total water requirements. Args: n : int : number of plants water_requirements : List[int] : list of water requirements for each plant Returns: str : \\"YES\\" if it's possible to divide the plants into two groups with equal total water requirements, otherwise \\"NO\\". Examples: >>> can_divide_plants(4, [1, 5, 11, 5]) \\"YES\\" >>> can_divide_plants(3, [1, 2, 5]) \\"NO\\"","solution":"def can_divide_plants(n, water_requirements): Returns \\"YES\\" if it's possible to divide the plants into two groups with equal total water requirements, otherwise returns \\"NO\\". Arguments: n : int : number of plants water_requirements : list of int : list of water requirements for each plant total_water = sum(water_requirements) # If the total water requirement is odd, it's not possible to divide into two equal parts if total_water % 2 != 0: return \\"NO\\" target = total_water // 2 dp = [False] * (target + 1) dp[0] = True for water in water_requirements: for j in range(target, water - 1, -1): dp[j] = dp[j] or dp[j - water] return \\"YES\\" if dp[target] else \\"NO\\" # Example usage: # print(can_divide_plants(4, [1, 5, 11, 5])) # Should return \\"YES\\" # print(can_divide_plants(3, [1, 2, 5])) # Should return \\"NO\\""},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Returns the minimum number of operations required to transform the given string 's' into a palindrome by performing the minimum number of character replacements. >>> min_operations_to_palindrome(5, \\"abcca\\") 1 >>> min_operations_to_palindrome(4, \\"abcd\\") 2 >>> min_operations_to_palindrome(1, \\"a\\") 0 >>> min_operations_to_palindrome(7, \\"racecar\\") 0 >>> min_operations_to_palindrome(6, \\"abccba\\") 0 >>> min_operations_to_palindrome(6, \\"abcdef\\") 3 >>> min_operations_to_palindrome(5, \\"abcde\\") 2","solution":"def min_operations_to_palindrome(n, s): Returns the minimum number of operations required to transform the given string 's' into a palindrome by performing the minimum number of character replacements. # Initial count of operations operations = 0 # Iterate from the start to the middle of the string for i in range(n // 2): # If characters at symmetrical positions are different if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"from collections import deque from typing import List def find_shortest_path(n: int, m: int, grid_str: List[str]) -> int: Determine the shortest path the courier can take to deliver a package from the start cell to the destination cell. >>> find_shortest_path(4, 4, [\\"....\\", \\"..#.\\", \\"...#\\", \\"#...\\"]) 6 >>> find_shortest_path(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) -1 def test_example_1(): n, m = 4, 4 grid_str = [ \\"....\\", \\"..#.\\", \\"...#\\", \\"#...\\" ] assert find_shortest_path(n, m, grid_str) == 6 def test_example_2(): n, m = 3, 3 grid_str = [ \\".#.\\", \\"#\\", \\".#.\\" ] assert find_shortest_path(n, m, grid_str) == -1 def test_single_row_path(): n, m = 1, 5 grid_str = [ \\".....\\" ] assert find_shortest_path(n, m, grid_str) == 4 def test_single_column_path(): n, m = 5, 1 grid_str = [ \\".\\", \\".\\", \\".\\", \\".\\", \\".\\" ] assert find_shortest_path(n, m, grid_str) == 4 def test_blocked_destination(): n, m = 2, 2 grid_str = [ \\"..\\", \\".#\\" ] assert find_shortest_path(n, m, grid_str) == -1 def test_minimal_grid(): n, m = 1, 1 grid_str = [ \\".\\" ] assert find_shortest_path(n, m, grid_str) == 0 def test_no_possible_path(): n, m = 5, 5 grid_str = [ \\".#.\\", \\"#...#\\", \\"#.#.#\\", \\"#.#.#\\", \\"#.#\\" ] assert find_shortest_path(n, m, grid_str) == -1","solution":"from collections import deque def shortest_path(grid): n = len(grid) m = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' queue = deque([(0, 0, 0)]) # (row, column, distance) grid[0][0] = '#' # Mark as visited while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): grid[nx][ny] = '#' # Mark as visited queue.append((nx, ny, dist + 1)) return -1 # Function to reformat the input grid for testing def find_shortest_path(n, m, grid_str): grid = [list(row) for row in grid_str] return shortest_path(grid)"},{"question":"from typing import List, Tuple def marathon_event_replenish_times(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the least time at which all the water stations will be simultaneously replenished with water again. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case is a tuple where the first element is the number of water stations n and the second element is a list of n integers denoting the time intervals. Returns: List[int]: A list of the least common time intervals (modulo 1000000007) for all test cases. Examples: >>> marathon_event_replenish_times(1, [(3, [5, 10, 15])]) [30] pass","solution":"import math from functools import reduce MOD = 1000000007 def lcm(a, b): return (a * b) // math.gcd(a, b) def lcm_multiple(numbers): return reduce(lambda x, y: lcm(x, y) % MOD, numbers, 1) def marathon_event_replenish_times(T, test_cases): results = [] for test_case in test_cases: n = test_case[0] intervals = test_case[1:] result = lcm_multiple(intervals) results.append(result) return results"},{"question":"from typing import List, Tuple def max_route_intensity(x: int, y: int, roads: List[Tuple[int, int, int]]) -> int: Find the maximal intensity value of any possible route consisting of three distinct cities. Args: x (int): The number of cities. y (int): The number of roads. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers u, v, and w. Returns: int: The maximal intensity value. Example: >>> max_route_intensity(5, 6, [(1, 2, 4), (2, 3, 5), (3, 4, 6), (4, 1, 7), (1, 3, 9), (2, 4, 8)]) 22 >>> max_route_intensity(4, 5, [(1, 2, 1), (2, 3, 3), (3, 4, 2), (4, 1, 4), (1, 3, 5)]) 11","solution":"def max_route_intensity(x, y, roads): from collections import defaultdict city_map = defaultdict(dict) for u, v, w in roads: city_map[u][v] = w city_map[v][u] = w max_intensity = 0 for u in city_map: for v in city_map[u]: if v <= u: continue for w in city_map[v]: if w <= v or w == u: continue if u in city_map[w]: intensity = city_map[u][v] + city_map[v][w] + city_map[w][u] max_intensity = max(max_intensity, intensity) return max_intensity # Example usage x, y = 5, 6 roads = [ (1, 2, 4), (2, 3, 5), (3, 4, 6), (4, 1, 7), (1, 3, 9), (2, 4, 8) ] print(max_route_intensity(x, y, roads)) # Output: 22"},{"question":"def max_points(R: int, C: int, grid: List[List[int]]) -> int: Determine the maximum points Mikan can collect by moving from the top-left to the bottom-right corner of the grid. Args: R : int : number of rows in the grid C : int : number of columns in the grid grid : List[List[int]] : the grid containing points in each cell Returns: int : maximum points that can be collected >>> max_points(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_points(4, 4, [ ... [1, 3, 1, 5], ... [1, 5, 1, 2], ... [4, 2, 1, 3], ... [2, 1, 1, 1] ... ]) 16 # Unit Tests: def test_max_points_3x3(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_points(3, 3, grid) == 29 def test_max_points_4x4(): grid = [ [1, 3, 1, 5], [1, 5, 1, 2], [4, 2, 1, 3], [2, 1, 1, 1] ] assert max_points(4, 4, grid) == 16 def test_max_points_1x1(): grid = [ [42] ] assert max_points(1, 1, grid) == 42 def test_max_points_single_row(): grid = [ [1, 2, 3, 4, 5] ] assert max_points(1, 5, grid) == 15 def test_max_points_single_column(): grid = [ [1], [2], [3], [4], [5] ] assert max_points(5, 1, grid) == 15","solution":"def max_points(R, C, grid): # Create a DP table with the same dimensions as the grid dp = [[0] * C for _ in range(R)] # Initialize the top-left corner with the first cell value dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from the top) for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, R): for j in range(1, C): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is in the bottom-right corner of the DP table return dp[R-1][C-1] # Sample code to take inputs and return output def main(): import sys input = sys.stdin.read data = input().strip().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for i in range(R): row = list(map(int, data[index:index+C])) grid.append(row) index += C print(max_points(R, C, grid)) if __name__ == \\"__main__\\": main()"},{"question":"def grid_operations(N, queries): Perform a sequence of operations to manipulate and query a grid of size N x N. The grid is initially filled with zeros. Each operation is one of the following: * set(r, c, v): Set the value at row r, column c to v. * query(a, b, x, y): Compute and return the sum of all values in the subgrid that spans from (a, b) to (x, y), inclusive. The grid is indexed from 1 to N for both rows and columns. Constraints: * 1 <= N <= 1,000 * 1 <= q <= 200,000 * 1 <= r, c, a, b, x, y <= N * -1,000,000 <= v <= 1,000,000 * It is always true that (a, b) is the top-left corner and (x, y) is the bottom-right corner of the query subgrid. Parameters: N (int): The size of the grid (N x N). queries (list of tuples): A list of queries where each query is a tuple. The first element is the type of the query (1 for set operation, 2 for query operation). Returns: None: Outputs the results of the query operations on the standard output. Example: >>> N = 4 >>> queries = [ >>> (1, 1, 1, 5), >>> (1, 2, 2, -3), >>> (2, 1, 1, 2, 2), >>> (1, 3, 3, 10), >>> (2, 2, 2, 3, 3) >>> ] >>> grid_operations(N, queries) 2 7 def test_grid_operations(): import io import sys # Capturing print output capturedOutput = io.StringIO() sys.stdout = capturedOutput N = 4 queries = [ (1, 1, 1, 5), (1, 2, 2, -3), (2, 1, 1, 2, 2), (1, 3, 3, 10), (2, 2, 2, 3, 3) ] expected_output = \\"2n7n\\" grid_operations(N, queries) # Restore stdout sys.stdout = sys.__stdout__ assert capturedOutput.getvalue() == expected_output test_grid_operations()","solution":"def grid_operations(N, queries): # Initialize the N x N grid with zeros grid = [[0] * (N + 1) for _ in range(N + 1)] for query in queries: if query[0] == 1: # set(r, c, v) _, r, c, v = query grid[r][c] = v elif query[0] == 2: # query(a, b, x, y) _, a, b, x, y = query total_sum = 0 for i in range(a, x + 1): for j in range(b, y + 1): total_sum += grid[i][j] print(total_sum) # Example usage N = 4 queries = [ (1, 1, 1, 5), (1, 2, 2, -3), (2, 1, 1, 2, 2), (1, 3, 3, 10), (2, 2, 2, 3, 3) ] grid_operations(N, queries)"},{"question":"def is_prime(num): Helper function to determine if a number is prime. def preprocess_primes(arr): Preprocess primes in the array and their prefix sums. def query_prime_sum(prime_sum_prefix, L, R): Get the sum of primes in the subarray from L to R using the precomputed prime sums. def prime_sum_in_ranges(N, Q, arr, queries): Main function to handle multiple queries for prime sums in given ranges. def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(0) == False assert is_prime(1) == False assert is_prime(13) == True assert is_prime(17) == True assert is_prime(18) == False def test_preprocess_primes(): arr = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11] expected_prefix_sum = [0, 2, 5, 5, 10, 10, 17, 17, 17, 17, 28] assert preprocess_primes(arr) == expected_prefix_sum def test_query_prime_sum(): prime_sum_prefix = [0, 2, 5, 5, 10, 10, 17, 17, 17, 17, 28] assert query_prime_sum(prime_sum_prefix, 1, 4) == 10 assert query_prime_sum(prime_sum_prefix, 2, 6) == 15 assert query_prime_sum(prime_sum_prefix, 7, 10) == 11 assert query_prime_sum(prime_sum_prefix, 1, 10) == 28 assert query_prime_sum(prime_sum_prefix, 4, 4) == 5 def test_prime_sum_in_ranges(): N = 10 Q = 3 arr = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11] queries = [(1, 4), (2, 6), (7, 10)] expected_output = [10, 15, 11] assert prime_sum_in_ranges(N, Q, arr, queries) == expected_output def test_prime_sum_in_ranges_single_element_prime(): N = 5 Q = 1 arr = [13, 27, 33, 31, 47] queries = [(4, 4)] expected_output = [31] assert prime_sum_in_ranges(N, Q, arr, queries) == expected_output def test_prime_sum_in_ranges_single_element_not_prime(): N = 5 Q = 1 arr = [13, 27, 33, 30, 47] queries = [(4, 4)] expected_output = [0] assert prime_sum_in_ranges(N, Q, arr, queries) == expected_output","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def preprocess_primes(arr): Preprocess primes in the array and their prefix sums. N = len(arr) prime_sum_prefix = [0] * (N + 1) for i in range(N): if is_prime(arr[i]): prime_sum_prefix[i + 1] = prime_sum_prefix[i] + arr[i] else: prime_sum_prefix[i + 1] = prime_sum_prefix[i] return prime_sum_prefix def query_prime_sum(prime_sum_prefix, L, R): Get the sum of primes in the subarray from L to R using the precomputed prime sums. return prime_sum_prefix[R] - prime_sum_prefix[L - 1] def prime_sum_in_ranges(N, Q, arr, queries): Main function to handle multiple queries for prime sums in given ranges. prime_sum_prefix = preprocess_primes(arr) results = [] for L, R in queries: results.append(query_prime_sum(prime_sum_prefix, L, R)) return results"},{"question":"def museum_max_attractiveness(N: int, T: int, halls: List[Tuple[int, int]]) -> int: Given the number of halls N, the total available time T, and the data for each hall, determine the maximum total attractiveness rating a visitor can achieve within the given time. Args: N (int): Number of exhibition halls. T (int): Total available time. halls (list of tuples): A list where each element is a tuple containing two integers (attractiveness rating Ai, time required Bi) of the i-th hall. Returns: int: Maximum total attractiveness rating. Examples: >>> museum_max_attractiveness(5, 10, [(8, 3), (4, 2), (7, 5), (6, 6), (5, 4)]) 19 >>> museum_max_attractiveness(3, 5, [(10, 3), (9, 2), (8, 4)]) 19 from typing import List, Tuple def test_museum_max_attractiveness(): assert museum_max_attractiveness(5, 10, [(8, 3), (4, 2), (7, 5), (6, 6), (5, 4)]) == 19 assert museum_max_attractiveness(3, 5, [(10, 3), (9, 2), (8, 4)]) == 19 assert museum_max_attractiveness(4, 7, [(5, 3), (6, 2), (4, 4), (7, 5)]) == 13 assert museum_max_attractiveness(1, 5, [(10, 5)]) == 10 assert museum_max_attractiveness(1, 4, [(10, 5)]) == 0 assert museum_max_attractiveness(2, 8, [(5, 3), (7, 5)]) == 12 assert museum_max_attractiveness(0, 10, []) == 0","solution":"def museum_max_attractiveness(N, T, halls): Returns the maximum total attractiveness rating that can be achieved within the given time. Args: N (int): Number of exhibition halls. T (int): Total available time. halls (list of tuple): A list where each element is a tuple containing two integers (attractiveness rating Ai, time required Bi) of the i-th hall. Returns: int: Maximum total attractiveness rating. dp = [0] * (T + 1) for A, B in halls: for t in range(T, B - 1, -1): dp[t] = max(dp[t], dp[t - B] + A) return max(dp)"},{"question":"def form_teams(L: int, S: int, M: int, T: int) -> str: Given the number of leaders (L), sub-leaders (S), members (M), and the maximum number of sub-leaders and members (T) each team can have respectively, determine if forming balanced teams is possible. If valid team formations exist then return \\"YESn\\" followed by L lines, each containing the configuration of a valid team in the format: \\"Leader Sub_Leaders Members\\". Otherwise, return \\"NO\\". >>> form_teams(3, 6, 6, 2) 'YESn1 1 2n2 3 4n3 5 6' >>> form_teams(2, 4, 3, 1) 'NO' pass","solution":"def form_teams(L, S, M, T): if (S < L) or (M < L): # Not enough sub-leaders or members to form L teams return \\"NO\\" # Calculate minimum and maximum sub-leaders and members needed per team min_sub_leaders_per_team = max(1, S // L) min_members_per_team = max(1, M // L) if min_sub_leaders_per_team > T or min_members_per_team > T: return \\"NO\\" teams = [] sub_leader_index = 1 member_index = 1 for leader in range(1, L + 1): # Allocate sub-leaders and members as evenly as possible sub_leaders = [] members = [] for _ in range(min_sub_leaders_per_team): if sub_leader_index > S: return \\"NO\\" sub_leaders.append(sub_leader_index) sub_leader_index += 1 for _ in range(min_members_per_team): if member_index > M: return \\"NO\\" members.append(member_index) member_index += 1 # Add remaining sub-leaders and members if needed to fill team limits while len(sub_leaders) < T and sub_leader_index <= S: sub_leaders.append(sub_leader_index) sub_leader_index += 1 while len(members) < T and member_index <= M: members.append(member_index) member_index += 1 teams.append((leader, sub_leaders, members)) result = [\\"YES\\"] for team in teams: result.append(f\\"{team[0]} {' '.join(map(str, team[1]))} {' '.join(map(str, team[2]))}\\") return \\"n\\".join(result)"},{"question":"def is_zigzag_sequence(n: int, sequence: List[int]) -> str: Determines if the given sequence of integers is a Zig-Zag sequence. A Zig-Zag sequence is defined as a sequence in which the first difference between consecutive elements is positive, the next difference is negative, and this pattern continues alternately throughout the sequence. Params: n (int): the number of elements in the sequence sequence (list): the sequence of integers Returns: str: \\"YES\\" if the sequence is a Zig-Zag sequence, otherwise \\"NO\\". Examples: >>> is_zigzag_sequence(5, [1, 3, 2, 4, 3]) 'YES' >>> is_zigzag_sequence(4, [1, 2, 3, 4]) 'NO'","solution":"def is_zigzag_sequence(n, sequence): Determines if the given sequence of integers is a Zig-Zag sequence. Params: - n (int): the number of elements in the sequence, - sequence (list): the sequence of integers. Returns: - str: \\"YES\\" if the sequence is a Zig-Zag sequence, otherwise \\"NO\\". if n < 2: return \\"NO\\" positive = None # To track the expectation of the next difference for i in range(1, n): diff = sequence[i] - sequence[i-1] if diff == 0: return \\"NO\\" # No zero difference allowed if positive is None: positive = diff > 0 # First difference determines the initial direction else: if positive and diff <= 0: return \\"NO\\" # Expected positive but got non-positive elif not positive and diff >= 0: return \\"NO\\" # Expected negative but got non-negative positive = not positive # Flip the expectation return \\"YES\\""},{"question":"def count_objects(script: str) -> int: Counts the total number of objects in the ancient script, including nested ones. :param script: str, a string representation of nested objects :return: int, total number of objects >>> count_objects(\\"A(B,C)\\") == 3 >>> count_objects(\\"A(B(C))\\") == 3 >>> count_objects(\\"A,B,C\\") == 3 >>> count_objects(\\"A(B,C(D,E),F)\\") == 6 >>> count_objects(\\"G(H(I,J),K)\\") == 5 >>> count_objects(\\"\\") == 0","solution":"def count_objects(script): Counts the total number of objects in the ancient script, including nested ones. :param script: str, a string representation of nested objects :return: int, total number of objects count = 0 i = 0 n = len(script) while i < n: if script[i].isalnum(): count += 1 # Move to the next non-alphanumeric character while i < n and script[i].isalnum(): i += 1 else: i += 1 return count"},{"question":"def count_unique_users(transaction_logs, start_time, end_time): Returns the number of unique users who performed each type of transaction within the specified time range. Parameters: transaction_logs (list): List of transaction logs; each log is a tuple (timestamp, user_id, transaction_type) start_time (int): Start of the time range (inclusive) end_time (int): End of the time range (inclusive) Returns: dict: A dictionary where keys are transaction types and values are the number of unique users Example: >>> count_unique_users([(1, 'user1', 'deposit'), (2, 'user2', 'withdrawal'), (3, 'user1', 'purchase'), (4, 'user3', 'deposit'), (5, 'user2', 'purchase'), (6, 'user1', 'withdrawal')], 2, 4) {'deposit': 1, 'withdrawal': 1, 'purchase': 1}","solution":"def count_unique_users(transaction_logs, start_time, end_time): Returns the number of unique users who performed each type of transaction within the specified time range. Parameters: transaction_logs (list): List of transaction logs; each log is a tuple (timestamp, user_id, transaction_type) start_time (int): Start of the time range (inclusive) end_time (int): End of the time range (inclusive) Returns: dict: A dictionary where keys are transaction types and values are the number of unique users transaction_dict = {} for log in transaction_logs: timestamp, user_id, transaction_type = log if start_time <= timestamp <= end_time: if transaction_type not in transaction_dict: transaction_dict[transaction_type] = set() transaction_dict[transaction_type].add(user_id) for transaction_type in transaction_dict: transaction_dict[transaction_type] = len(transaction_dict[transaction_type]) return transaction_dict"},{"question":"from typing import List, Tuple def max_subarray_indices(arr: List[int]) -> Tuple[int, int]: Given an array of integers, return the start and end indices (1-based) of the subarray which has the maximum sum. If there are multiple subarrays with the same maximum sum, return the indices of the first occurrence of such a subarray. If the array length is zero, return -1, -1. >>> max_subarray_indices([-2, -3, 4, -1, -2, 1, 5, -3]) == (3, 7) >>> max_subarray_indices([-5]) == (1, 1) >>> max_subarray_indices([1, 2, 3, 4, 5]) == (1, 5) >>> max_subarray_indices([0]) == (1, 1) >>> max_subarray_indices([-1, -2, -3, -4]) == (1, 1) >>> max_subarray_indices([1, -3, 2, 1, -1]) == (3, 4) >>> max_subarray_indices([1, 2, 3, 4, 5, 6]) == (1, 6) >>> max_subarray_indices([1, 2, 3, -2, 5, -10, 1, 2, 3, -2, 5]) == (1, 5) >>> max_subarray_indices([]) == (-1, -1)","solution":"def max_subarray_indices(arr): Returns the start and end indices (1-based) of the subarray which has the maximum sum. If the array length is zero, returns -1, -1. if len(arr) == 0: return -1, -1 max_sum = float('-inf') current_sum = 0 start = 0 end = 0 temp_start = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i if current_sum < 0: current_sum = 0 temp_start = i + 1 return start + 1, end + 1"},{"question":"def are_all_creatures_connected(n: int, m: int, relationships: List[Tuple[int, int]]) -> str: Determines if all creatures in the forest are part of a single connected network. Args: n (int): The number of creatures. m (int): The number of relationships. relationships (list of tuples): Each tuple contains two integers representing a friendship between two creatures. Returns: str: \\"YES\\" if all creatures are part of a single connected network of friends, otherwise \\"NO\\". >>> are_all_creatures_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YES' >>> are_all_creatures_connected(4, 2, [(1, 2), (3, 4)]) 'NO' >>> are_all_creatures_connected(1, 0, []) 'YES' >>> are_all_creatures_connected(2, 1, [(1, 2)]) 'YES' >>> are_all_creatures_connected(2, 0, []) 'NO' >>> are_all_creatures_connected(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) 'NO' >>> are_all_creatures_connected(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 'YES'","solution":"def are_all_creatures_connected(n, m, relationships): Determines if all creatures in the forest are part of a single connected network. Args: n (int): The number of creatures. m (int): The number of relationships. relationships (list of tuples): Each tuple contains two integers representing a friendship between two creatures. Returns: str: \\"YES\\" if all creatures are part of a single connected network of friends, otherwise \\"NO\\". from collections import defaultdict, deque def bfs(start_node, graph, visited): queue = deque([start_node]) visited[start_node] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) if n == 0: # No creatures means there's no network return \\"NO\\" # Create adjacency list for graph representation graph = defaultdict(list) for u, v in relationships: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) components = 0 # Check connectivity using BFS/DFS for creature in range(1, n + 1): if not visited[creature]: if components > 0: return \\"NO\\" bfs(creature, graph, visited) components += 1 return \\"YES\\""},{"question":"from typing import List, Tuple def get_most_expensive_items(k: int, items: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Returns the k most expensive items sorted by price in descending order. If two items have the same price, they are sorted alphabetically by name. >>> get_most_expensive_items(3, [(\\"apple\\", 50), (\\"banana\\", 60), (\\"cherry\\", 50), (\\"date\\", 70), (\\"elderberry\\", 50)]) [('date', 70), ('banana', 60), ('apple', 50)] >>> get_most_expensive_items(2, [(\\"apple\\", 50), (\\"banana\\", 50), (\\"cherry\\", 50), (\\"date\\", 50), (\\"elderberry\\", 50)]) [('apple', 50), ('banana', 50)]","solution":"def get_most_expensive_items(k, items): Returns the k most expensive items sorted by price in descending order. If two items have the same price, they are sorted alphabetically by name. # Sort items first alphabetically by name and then by price in descending order sorted_items = sorted(items, key=lambda x: (-x[1], x[0])) # Return the top k items return sorted_items[:k]"},{"question":"class DisasterRecoverySystem: def __init__(self): self.current_backups = [] self.max_backup_id = 0 self.current_state = 0 def create_backup(self): Create a new backup point. Returns: int: The ID of the new backup point. pass def rollback(self, backup_id): Rollback to a specific backup point. Args: backup_id (int): The ID of the backup point to rollback to. Returns: int: The ID of the point to which the system is rolled back. pass def disaster_recovery_system(operations): Perform operations on the disaster recovery system. Args: operations (List[str]): List of operations to perform on the system. Returns: List[int]: List of results for each operation. pass import pytest def test_create_operations(): operations = [\\"CREATE\\", \\"CREATE\\", \\"CREATE\\"] assert disaster_recovery_system(operations) == [1, 2, 3] def test_rollback_operations(): operations = [\\"CREATE\\", \\"CREATE\\", \\"CREATE\\", \\"ROLLBACK 2\\", \\"CREATE\\"] assert disaster_recovery_system(operations) == [1, 2, 3, 2, 4] def test_mixed_operations(): operations = [\\"CREATE\\", \\"CREATE\\", \\"ROLLBACK 1\\", \\"CREATE\\", \\"ROLLBACK 2\\", \\"CREATE\\"] assert disaster_recovery_system(operations) == [1, 2, 1, 3, 2, 4] def test_single_create_operation(): operations = [\\"CREATE\\"] assert disaster_recovery_system(operations) == [1] def test_rollback_to_initial(): operations = [\\"CREATE\\", \\"CREATE\\", \\"ROLLBACK 1\\"] assert disaster_recovery_system(operations) == [1, 2, 1]","solution":"class DisasterRecoverySystem: def __init__(self): self.current_backups = [] self.max_backup_id = 0 self.current_state = 0 def create_backup(self): self.max_backup_id += 1 self.current_state = self.max_backup_id self.current_backups.append(self.current_state) return self.current_state def rollback(self, backup_id): self.current_state = backup_id self.current_backups = self.current_backups[:backup_id] return self.current_state def disaster_recovery_system(operations): system = DisasterRecoverySystem() results = [] for operation in operations: if operation == \\"CREATE\\": result = system.create_backup() results.append(result) elif operation.startswith(\\"ROLLBACK\\"): _, backup_id = operation.split() result = system.rollback(int(backup_id)) results.append(result) return results"},{"question":"def max_balanced_subsequence_length(n: int, sequence: str) -> int: In the world of competitive coding, there is a unique challenge called the \\"Balanced Bracket Sequence\\" game. Given a sequence of brackets, your task is to determine the maximum length of a balanced subsequence. A balanced bracket sequence consists of an equal number of opening and closing brackets ('(' and ')') in the correct order. Args: n (int): the length of the sequence (1 ≤ n ≤ 50). sequence (str): the input string containing the bracket sequence consisting of exactly n characters. Returns: int: the maximum length of a balanced subsequence. Examples: >>> max_balanced_subsequence_length(6, \\"(())()\\") 6 >>> max_balanced_subsequence_length(4, \\")(()\\") 2","solution":"def max_balanced_subsequence_length(n, sequence): Determines the maximum length of a balanced subsequence of the bracket sequence. Args: n (int): the length of the sequence. sequence (str): the input string containing the bracket sequence. Returns: int: the maximum length of a balanced subsequence. open_count = 0 close_count = 0 for char in sequence: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 close_count += 1 return close_count * 2"},{"question":"def process_playlist(n: int, playlist: List[int]) -> List[int]: Processes the playlist to remove duplicate songs, keeping only the first occurrence of each song. >>> process_playlist(6, [1, 2, 3, 2, 4, 1]) [1, 2, 3, 4] >>> process_playlist(7, [1, 1, 2, 2, 3, 3, 3]) [1, 2, 3]","solution":"def process_playlist(n, playlist): Processes the playlist to remove duplicate songs, keeping only the first occurrence of each song. seen = set() result = [] for song in playlist: if song not in seen: seen.add(song) result.append(song) return result"},{"question":"def can_fulfill_requests(m: int, bikes: List[int], n: int, requests: List[Tuple[int, int, int]]) -> str: Determine if all bike requests can be fulfilled simultaneously. Arguments: m: Number of stations. bikes: List of integers representing the number of bikes available at each station. n: Number of bike requests. requests: List of tuples representing the bike requests. Each tuple contains three integers (si, ti, d), where si is the starting station, ti is the target station, and d is the number of bikes required. Returns: \\"YES\\" if all requests can be fulfilled without any station's bike count dropping below zero, otherwise \\"NO\\". Examples: >>> can_fulfill_requests(5, [3, 2, 1, 5, 4], 3, [(1, 3, 2), (4, 2, 3), (5, 1, 1)]) \\"YES\\" >>> can_fulfill_requests(4, [2, 3, 4, 1], 2, [(3, 1, 5), (2, 4, 2)]) \\"NO\\" # Your code here import pytest def test_fulfill_requests_all_possible(): assert can_fulfill_requests(5, [3, 2, 1, 5, 4], 3, [(1, 3, 2), (4, 2, 3), (5, 1, 1)]) == \\"YES\\" def test_fulfill_requests_insufficient_bikes(): assert can_fulfill_requests(4, [2, 3, 4, 1], 2, [(3, 1, 5), (2, 4, 2)]) == \\"NO\\" def test_fulfill_requests_edge_case_single_station(): assert can_fulfill_requests(1, [10], 1, [(1, 1, 5)]) == \\"YES\\" def test_fulfill_requests_multiple_requests_same_station(): assert can_fulfill_requests(3, [10, 0, 0], 2, [(1, 2, 5), (1, 3, 5)]) == \\"YES\\" def test_fulfill_requests_edge_case_insufficient_bikes(): assert can_fulfill_requests(3, [1, 2, 3], 1, [(1, 2, 2)]) == \\"NO\\" def test_fulfill_requests_empty_requests(): assert can_fulfill_requests(5, [3, 2, 1, 5, 4], 0, []) == \\"YES\\"","solution":"def can_fulfill_requests(m, bikes, n, requests): bike_count = bikes[:] # create a copy to avoid modifying the original list for si, ti, d in requests: if bike_count[si - 1] < d: return \\"NO\\" bike_count[si - 1] -= d bike_count[ti - 1] += d return \\"YES\\" # Example Inputs for direct function call testing, remove this on actual unit tests m = 5 bikes = [3, 2, 1, 5, 4] n = 3 requests = [(1, 3, 2), (4, 2, 3), (5, 1, 1)] print(can_fulfill_requests(m, bikes, n, requests)) # Outputs: YES m = 4 bikes = [2, 3, 4, 1] n = 2 requests = [(3, 1, 5), (2, 4, 2)] print(can_fulfill_requests(m, bikes, n, requests)) # Outputs: NO"},{"question":"def daily_temperatures(T: List[int]) -> List[int]: Returns a list of integers where each element denotes the number of days to wait for a warmer temperature, or 0 if no warmer day is available. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([100, 99, 98, 97, 96]) [0, 0, 0, 0, 0] >>> daily_temperatures([70, 70, 70, 70, 70]) [0, 0, 0, 0, 0] >>> daily_temperatures([30, 40, 50, 60, 70, 80, 90]) [1, 1, 1, 1, 1, 1, 0] >>> daily_temperatures([55]) [0] >>> daily_temperatures([70, 60, 70, 60, 70]) [0, 1, 0, 1, 0]","solution":"def daily_temperatures(T): Returns a list of integers where each element denotes the number of days to wait for a warmer temperature, or 0 if no warmer day is available. :param T: List[int] - A list of daily temperatures :return: List[int] - A list of the number of days to wait for a warmer temperature n = len(T) result = [0] * n stack = [] # stores the indices of the temperatures for i in range(n): while stack and T[i] > T[stack[-1]]: j = stack.pop() result[j] = i - j stack.append(i) return result"},{"question":"def max_harvests(t: int, test_cases: List[Tuple[int, int, int, List[int]]]) -> List[int]: Determine the maximum number of crops that can be harvested within the given number of days for a given number of test cases. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple consists of: - n (int): Number of plots on the farm. - d (int): Number of days available. - m (int): Number of different crop types. - growth_times (list of int): List of days required for each crop type to grow. Returns: list of int: Maximum number of crops that can be harvested for each test case. pass from typing import List, Tuple from solution import max_harvests def test_max_harvests(): assert max_harvests(3, [ (3, 10, 2, [4, 5]), (1, 7, 3, [2, 5, 8]), (5, 15, 3, [3, 7, 10]) ]) == [6, 3, 5] assert max_harvests(1, [ (2, 5, 3, [1, 2, 3]) ]) == [10] assert max_harvests(2, [ (4, 20, 2, [5, 10]), (4, 22, 2, [7, 11]) ]) == [16, 12] assert max_harvests(1, [ (3, 24, 1, [6]) ]) == [12] def test_max_harvests_edge_cases(): assert max_harvests(1, [ (1, 1, 1, [1]) ]) == [1] assert max_harvests(1, [ (1, 1000, 1, [1000]) ]) == [1] assert max_harvests(1, [ (100, 1000, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ]) == [100000]","solution":"def max_harvests(t, test_cases): Returns the maximum number of crops that can be harvested for each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple consists of: - n (int): Number of plots on the farm - d (int): Number of days available - m (int): Number of different crop types - growth_times (list of int): List of days required for each crop type to grow Returns: list of int: Maximum number of crops that can be harvested for each test case. results = [] for case in test_cases: n, d, m, growth_times = case max_harvest = 0 for grow_time in growth_times: harvests_per_plot = d // grow_time total_harvests = harvests_per_plot * n max_harvest = max(max_harvest, total_harvests) results.append(max_harvest) return results"},{"question":"def has_cycle(n, edges): Detects cycles in an undirected graph using Union-Find (Disjoint Set Union) algorithm. :param n: Number of vertices in the graph. :param edges: List of edges in the graph. :return: Return \\"YES\\" if there's at least one cycle, otherwise \\"NO\\". def detect_cycles_in_graphs(t, test_cases): results = [] for n, m, edges in test_cases: results.append(has_cycle(n, edges)) return results def test_detect_cycles_in_graphs(): t = 3 test_cases = [ (3, 3, [(0, 1), (1, 2), (2, 0)]), # this should return 'YES' (4, 2, [(0, 1), (2, 3)]), # this should return 'NO' (5, 4, [(0, 1), (1, 2), (2, 3), (3, 0)]) # this should return 'YES' ] expected_results = [\\"YES\\", \\"NO\\", \\"YES\\"] assert detect_cycles_in_graphs(t, test_cases) == expected_results def test_no_edges(): t = 1 test_cases = [ (3, 0, []) ] expected_results = [\\"NO\\"] assert detect_cycles_in_graphs(t, test_cases) == expected_results def test_single_node(): t = 1 test_cases = [ (1, 0, []) ] expected_results = [\\"NO\\"] assert detect_cycles_in_graphs(t, test_cases) == expected_results def test_large_graph_with_cycle(): t = 1 test_cases = [ (1000, 999, [(i, i + 1) for i in range(999)] + [(999, 0)]) # a 1000 node cycle ] expected_results = [\\"YES\\"] assert detect_cycles_in_graphs(t, test_cases) == expected_results","solution":"def has_cycle(n, edges): Detects cycles in an undirected graph using Union-Find (Disjoint Set Union) algorithm. :param n: Number of vertices in the graph. :param edges: List of edges in the graph. :return: Return \\"YES\\" if there's at least one cycle, otherwise \\"NO\\". parent = list(range(n)) rank = [0] * n def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 return False return True for u, v in edges: if union(u, v): return \\"YES\\" return \\"NO\\" def detect_cycles_in_graphs(t, test_cases): results = [] for n, m, edges in test_cases: results.append(has_cycle(n, edges)) return results"},{"question":"def num_paths(grid: List[str]) -> int: Find the number of distinct paths in a grid from (0,0) to (n-1,m-1), moving only up, down, left, or right, while avoiding blocked cells. Args: grid: List[str]: a list of strings representing the grid Returns: int: the number of distinct paths modulo 10^9 + 7 Example: >>> num_paths([ \\"...\\", \\".#.\\", \\"...\\" ]) 2 >>> num_paths([ \\"#\\", \\".#.\\", \\"...\\" ]) 0","solution":"MOD = 10**9 + 7 def num_paths(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def solve_board(n: int, m: int, board: List[List[int]]) -> Union[List[List[int]], str]: Alex likes to collect stamps and he has a collection of stamps with different values. He wants to display his stamps in a rectangular grid fashion on a board such that each row and each column contains unique values. However, some of the stamps are already placed on the board and cannot be moved. Help Alex complete the board in a way that satisfies the condition. Input Example: solve_board(2, 2, [[1, 0], [0, 2]]) Output Example: [[1, 2], [2, 1]] Test Cases: >>> solve_board(2, 2, [[1, 0], [0, 2]]) [] >>> solve_board(3, 3, [[1, 0, 3], [0, 2, 0], [0, 0, 0]]) [] >>> solve_board(2, 2, [[1, 2], [2, 1]]) [[1, 2], [2, 1]] >>> solve_board(15, 15, [[0 for _ in range(15)] for _ in range(15)]) []","solution":"def solve_board(n, m, board): def is_valid(board, row, col, val): for i in range(n): if board[i][col] == val: return False for j in range(m): if board[row][j] == val: return False return True def solve(): for row in range(n): for col in range(m): if board[row][col] == 0: for num in range(1, n * m + 1): if is_valid(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = 0 return False return True if solve(): return board return \\"No solution\\" # Test cases print(solve_board(2, 2, [[1, 0], [0, 2]])) # Example output should be valid configuration print(solve_board(3, 3, [[1, 0, 3], [0, 2, 0], [0, 0, 0]])) # Example output should be valid configuration"},{"question":"def max_bacteria_difference(records: List[Tuple[int, int]]) -> int: Determine the maximum difference in bacteria count between any two time points of the day. Args: records (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers - the time (in hours) and the bacteria count at that time. Returns: int: The maximum difference in the bacteria count between any two time points of the day. Examples: >>> max_bacteria_difference([(0, 100), (8, 300), (3, 200), (15, 250), (20, 50)]) 250 >>> max_bacteria_difference([(1, 500), (5, 1000), (10, 1500), (20, 2000)]) 1500 from solution import max_bacteria_difference def test_sample_input_1(): records = [(0, 100), (8, 300), (3, 200), (15, 250), (20, 50)] assert max_bacteria_difference(records) == 250 def test_sample_input_2(): records = [(1, 500), (5, 1000), (10, 1500), (20, 2000)] assert max_bacteria_difference(records) == 1500 def test_single_record(): records = [(5, 500)] assert max_bacteria_difference(records) == 0 def test_same_counts(): records = [(1, 500), (2, 500), (3, 500)] assert max_bacteria_difference(records) == 0 def test_random_order(): records = [(3, 150), (0, 100), (8, 900), (7, 300), (5, 200)] assert max_bacteria_difference(records) == 800 def test_large_numbers(): records = [(3, 500000), (21, 1000000), (15, 750000), (9, 250000)] assert max_bacteria_difference(records) == 750000 def test_no_records(): records = [] assert max_bacteria_difference(records) == 0","solution":"def max_bacteria_difference(records): Returns the maximum difference in bacteria count between any two time points of the day. if not records: return 0 min_bacteria_count = float('inf') max_bacteria_count = float('-inf') for _, count in records: if count < min_bacteria_count: min_bacteria_count = count if count > max_bacteria_count: max_bacteria_count = count return max_bacteria_count - min_bacteria_count"},{"question":"import heapq from typing import List, Tuple def minimum_travel_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: A transportation company wants to optimize its delivery routes to minimize transportation costs. Input: - n: an integer, the number of delivery locations - m: an integer, the number of roads - roads: a list of tuples, each containing three integers: u, v (the locations connected by the road) and w (the travel cost) Output: - an integer, the minimum total travel cost to connect all delivery locations from the central warehouse, or -1 if it is impossible to connect all delivery locations >>> minimum_travel_cost(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 3), (3, 4, 5)]) 6 >>> minimum_travel_cost(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 >>> minimum_travel_cost(1, 0, []) 0 >>> minimum_travel_cost(2, 0, []) -1 >>> minimum_travel_cost(4, 6, [(1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 1), (3, 4, 3), (1, 4, 3)]) 4 def test_minimum_travel_cost_connected(): n = 4 m = 5 roads = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 3), (3, 4, 5) ] assert minimum_travel_cost(n, m, roads) == 6 def test_minimum_travel_cost_disconnected(): n = 4 m = 2 roads = [ (1, 2, 1), (3, 4, 2) ] assert minimum_travel_cost(n, m, roads) == -1 def test_minimum_travel_cost_single_node(): n = 1 m = 0 roads = [] assert minimum_travel_cost(n, m, roads) == 0 def test_minimum_travel_cost_no_edges(): n = 2 m = 0 roads = [] assert minimum_travel_cost(n, m, roads) == -1 def test_minimum_travel_cost_large_connected_graph(): n = 4 m = 6 roads = [ (1, 2, 1), (1, 3, 2), (2, 3, 2), (2, 4, 1), (3, 4, 3), (1, 4, 3) ] assert minimum_travel_cost(n, m, roads) == 4","solution":"import heapq def minimum_travel_cost(n, m, roads): if n == 1: return 0 if m == 0: return -1 graph = {i: [] for i in range(1, n+1)} for u, v, w in roads: graph[u].append((w, v)) graph[v].append((w, u)) visited = set() min_heap = [(0, 1)] # (cost, node) total_cost = 0 while min_heap and len(visited) < n: cost, u = heapq.heappop(min_heap) if u not in visited: visited.add(u) total_cost += cost for w, v in graph[u]: if v not in visited: heapq.heappush(min_heap, (w, v)) return total_cost if len(visited) == n else -1"},{"question":"class QueueUsingStacks: def __init__(self): # Initialize two stacks self.stack1 = [] self.stack2 = [] def enqueue(self, x): Adds element x to the end of the queue. pass def dequeue(self): Removes the element from the front of the queue and returns it. If the queue is empty, returns 'Queue is empty'. pass def simulate_operations(operations): Function to simulate a series of queue operations using the QueueUsingStacks class. Args: operations (List[str]): List of operations to perform. Returns: List: Result of each dequeue operation. >>> simulate_operations([\\"enqueue 10\\", \\"enqueue 20\\", \\"dequeue\\", \\"enqueue 30\\", \\"dequeue\\"]) [10, 20] pass def test_enqueue_dequeue_sequence(): q = QueueUsingStacks() q.enqueue(10) q.enqueue(20) assert q.dequeue() == 10 q.enqueue(30) assert q.dequeue() == 20 def test_dequeue_empty_queue(): q = QueueUsingStacks() assert q.dequeue() == \\"Queue is empty\\" def test_simulate_operations(): operations = [ \\"enqueue 10\\", \\"enqueue 20\\", \\"dequeue\\", \\"enqueue 30\\", \\"dequeue\\" ] result = simulate_operations(operations) assert result == [10, 20] def test_complex_operations(): operations = [ \\"enqueue 5\\", \\"enqueue 10\\", \\"enqueue 15\\", \\"dequeue\\", \\"enqueue 20\\", \\"dequeue\\", \\"dequeue\\", \\"dequeue\\", \\"dequeue\\" # This should return \\"Queue is empty\\" ] result = simulate_operations(operations) assert result == [5, 10, 15, 20, \\"Queue is empty\\"]","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, x): self.stack1.append(x) def dequeue(self): if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: return \\"Queue is empty\\" return self.stack2.pop() def simulate_operations(operations): q = QueueUsingStacks() results = [] for operation in operations: if operation.startswith(\\"enqueue\\"): _, x = operation.split() q.enqueue(int(x)) elif operation == \\"dequeue\\": results.append(q.dequeue()) return results"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_even_indexed_nodes(head: ListNode) -> ListNode: Remove every even-indexed node from a given singly linked list. The function returns the head of the new list after the removal of all even-indexed nodes. Examples: >>> list1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> output1 = remove_even_indexed_nodes(list1) >>> while output1: >>> print(output1.value, end=\\" -> \\") >>> output1 = output1.next 2 -> 4 -> >>> list2 = ListNode(1) >>> output2 = remove_even_indexed_nodes(list2) >>> output2 is None True >>> list3 = ListNode(1, ListNode(2)) >>> output3 = remove_even_indexed_nodes(list3) >>> while output3: >>> print(output3.value, end=\\" -> \\") >>> output3 = output3.next 2 -> >>> list4 = ListNode(1, ListNode(2, ListNode(3))) >>> output4 = remove_even_indexed_nodes(list4) >>> while output4: >>> print(output4.value, end=\\" -> \\") >>> output4 = output4.next 2 ->","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_even_indexed_nodes(head): if not head or not head.next: return None dummy = ListNode(0) # Create a dummy node to manage the head easily dummy.next = head current = dummy index = 0 while current and current.next: if index % 2 == 0 and current.next: current.next = current.next.next else: current = current.next index += 1 return dummy.next"},{"question":"def min_cost_to_transform(ci: int, cd: int, cr: int, s: str, t: str) -> int: Returns the minimum cost to transform string s into string t using the given costs for insertion, deletion, and replacement. >>> min_cost_to_transform(1, 1, 1, \\"sunday\\", \\"saturday\\") 3 >>> min_cost_to_transform(2, 3, 4, \\"abc\\", \\"yabd\\") 6 >>> min_cost_to_transform(1, 100, 100, \\"abc\\", \\"abcdef\\") 3 >>> min_cost_to_transform(100, 1, 100, \\"abcdef\\", \\"abc\\") 3 >>> min_cost_to_transform(100, 100, 1, \\"abc\\", \\"def\\") 3 >>> min_cost_to_transform(1, 1, 1, \\"\\", \\"\\") 0 >>> min_cost_to_transform(1, 1, 1, \\"\\", \\"abc\\") 3 >>> min_cost_to_transform(1, 1, 1, \\"abc\\", \\"\\") 3","solution":"def min_cost_to_transform(ci, cd, cr, s, t): Returns the minimum cost to transform string s into string t using the given costs for insertion, deletion, and replacement. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j * ci elif j == 0: dp[i][j] = i * cd elif s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] else: insert_cost = dp[i][j-1] + ci delete_cost = dp[i-1][j] + cd replace_cost = dp[i-1][j-1] + cr dp[i][j] = min(insert_cost, delete_cost, replace_cost) return dp[m][n]"},{"question":"def count_beautiful_segments(n, m, k, colors): Counts the number of beautiful segments in the fence. Args: - n (int): Number of sections. - m (int): Number of available colors. - k (int): Maximum number of different colors in a beautiful segment. - colors (list of int): List of colors of the fence sections. Returns: - int: Number of beautiful segments. pass def test_example_1(): assert count_beautiful_segments(5, 3, 2, [1, 2, 1, 2, 3]) == 12 def test_example_2(): assert count_beautiful_segments(4, 4, 1, [1, 2, 3, 4]) == 4 def test_single_element(): assert count_beautiful_segments(1, 1, 1, [1]) == 1 def test_all_same_color(): assert count_beautiful_segments(4, 2, 1, [1, 1, 1, 1]) == 10 def test_no_beautiful_segment(): assert count_beautiful_segments(4, 3, 1, [1, 2, 3, 2]) == 4 def test_large_k(): assert count_beautiful_segments(6, 3, 3, [1, 2, 1, 2, 3, 1]) == 21 def test_large_n_and_m(): import random n = 10**5 m = 10**5 k = 2 colors = [random.randint(1, m) for _ in range(n)] result = count_beautiful_segments(n, m, k, colors) assert isinstance(result, int) # Check for general correctness and performance","solution":"def count_beautiful_segments(n, m, k, colors): Counts the number of beautiful segments in the fence. Args: - n (int): Number of sections. - m (int): Number of available colors. - k (int): Maximum number of different colors in a beautiful segment. - colors (list of int): List of colors of the fence sections. Returns: - int: Number of beautiful segments. from collections import defaultdict left = 0 color_count = defaultdict(int) different_colors = 0 beautiful_segments = 0 for right in range(n): if color_count[colors[right]] == 0: different_colors += 1 color_count[colors[right]] += 1 while different_colors > k: color_count[colors[left]] -= 1 if color_count[colors[left]] == 0: different_colors -= 1 left += 1 beautiful_segments += (right - left + 1) return beautiful_segments"},{"question":"from typing import List, Tuple def max_distance_in_tree(N: int, edges: List[Tuple[int, int]]) -> int: Determine the maximum distance between any two vertices in a tree. Args: N (int): The number of vertices in the tree. edges (List[Tuple[int, int]]): A list of tuples representing the edges of the tree, where each tuple (u, v) represents an edge connecting vertex u and vertex v. Returns: int: The maximum distance between any two vertices in the tree. Examples: >>> max_distance_in_tree(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> max_distance_in_tree(3, [(1, 2), (2, 3)]) 2 >>> max_distance_in_tree(6, [(1, 2), (1, 3), (3, 4), (3, 5), (5, 6)]) 4 >>> max_distance_in_tree(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 5 >>> max_distance_in_tree(7, [(1, 2), (2, 3), (3, 4), (2, 5), (5, 6), (5, 7)]) 4","solution":"from collections import defaultdict, deque def find_farthest(node, graph): visited = set() queue = deque([(node, 0)]) farthest_node = node max_distance = 0 while queue: current_node, distance = queue.popleft() visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: queue.append((neighbor, distance + 1)) if distance + 1 > max_distance: max_distance = distance + 1 farthest_node = neighbor return farthest_node, max_distance def max_distance_in_tree(N, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Start with an arbitrary node, say node 1 start_node = 1 farthest_node, _ = find_farthest(start_node, graph) # Perform the second DFS starting from the farthest node found in the first DFS _, max_distance = find_farthest(farthest_node, graph) return max_distance"},{"question":"def pair_sums_to_k(n: int, numbers: List[int], k: int) -> str: Determines if there is a pair of distinct elements in 'numbers' that sums to 'k'. >>> pair_sums_to_k(5, [1, 2, 3, 4, 5], 6) # \\"YES\\" >>> pair_sums_to_k(5, [1, 2, 3, 4, 5], 10) # \\"NO\\"","solution":"def pair_sums_to_k(n, numbers, k): Determines if there is a pair of distinct elements in 'numbers' that sums to 'k'. Parameters: n: int - the number of integers in the list numbers: list of int - the list of integers k: int - the target sum Returns: str - \\"YES\\" if there exists a pair that sums to 'k', otherwise \\"NO\\" seen = set() for number in numbers: complement = k - number if complement in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def count_unique_palindromic_substrings(s: str) -> int: Identify all unique palindromic substrings of a given string. >>> count_unique_palindromic_substrings(\\"abaaa\\") 5 >>> count_unique_palindromic_substrings(\\"racecar\\") 7","solution":"def count_unique_palindromic_substrings(s): def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() for i in range(len(s)): for j in range(i, len(s)): substring = s[i:j + 1] if is_palindrome(substring): palindromic_substrings.add(substring) return len(palindromic_substrings)"},{"question":"from typing import List def group_anagrams(n: int, words: List[str]) -> List[List[str]]: Given a list of words, groups the anagrams together. >>> group_anagrams(6, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"eat\\", \\"tea\\", \\"ate\\"]) [['ate', 'eat', 'tea'], ['enlist', 'listen', 'silent']] >>> group_anagrams(3, [\\"dog\\", \\"god\\", \\"cat\\"]) [['dog', 'god']]","solution":"from typing import List from collections import defaultdict def group_anagrams(n: int, words: List[str]) -> List[List[str]]: anagram_map = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagram_map[sorted_word].append(word) result = [] for anagram_group in anagram_map.values(): if len(anagram_group) > 1: result.append(sorted(anagram_group)) result.sort() return result def format_anagram_groups(anagram_groups: List[List[str]]) -> List[str]: return [' '.join(group) for group in anagram_groups]"},{"question":"def find_longest_subsequence(arr: List[int]) -> int: Given an array of integers, find the longest subsequence such that every two consecutive elements in the subsequence have a common factor greater than 1. >>> find_longest_subsequence([4, 8, 15, 16, 23]) 3 >>> find_longest_subsequence([7, 11, 13, 17]) 1","solution":"from math import gcd from functools import lru_cache @lru_cache(None) def gcd_memo(x, y): return gcd(x, y) def find_longest_subsequence(arr): n = len(arr) if n == 0: return 0 dp = [1] * n for i in range(1, n): for j in range(i): if gcd_memo(arr[i], arr[j]) > 1: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # The following function is for the input and output format handling def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) arr = list(map(int, data[1:])) print(find_longest_subsequence(arr)) if __name__ == \\"__main__\\": main()"},{"question":"def find_vault_path(n: int) -> List[int]: Finds the path to the final vault n from vault 0. If it is possible to reach vault n, returns a list of vaults in the order to traverse. If not possible, returns -1. >>> find_vault_path(5) [0, 2, 4, 5] >>> find_vault_path(3) [0, 2, 3] >>> find_vault_path(1) [0, 1] >>> find_vault_path(4) [0, 2, 4]","solution":"def find_vault_path(n): Finds the path to the final vault n from vault 0. If it is possible to reach vault n, returns a list of vaults in the order to traverse. If not possible, returns -1. if n == 0: return [0] # Initialize the path with the starting vault path = [0] # Add vaults to the path following the rule i = 0 while i < n: if i + 2 <= n: path.append(i + 2) i += 2 else: path.append(i + 1) i += 1 return path # Example usage (Remove before running tests): # print(find_vault_path(5)) # Output: [0, 2, 4, 5] # print(find_vault_path(3)) # Output: [0, 2, 3] # print(find_vault_path(1)) # Output: [0, 1] # print(find_vault_path(4)) # Output: [0, 2, 4]"},{"question":"from typing import List def generate_fibonacci_until(max_value: int) -> List[int]: Generate a list of Fibonacci numbers up to a maximum value. >>> generate_fibonacci_until(50) [1, 1, 2, 3, 5, 8, 13, 21, 34] pass def find_closest_fib_subset(p: List[int], fibs: List[int]) -> List[int]: Find a subset of Fibonacci numbers that is as close as possible to the sum of the list p. >>> p_example = [10, 22, 35, 50] >>> fibs_example = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144] >>> find_closest_fib_subset(p_example, fibs_example) [8, 21, 34, 55] # Example output, actual may vary pass def find_fib_list(m: int, p: List[int]) -> List[int]: Find the list q of Fibonacci numbers such that: - q contains only Fibonacci numbers. - q contains each Fibonacci number exactly once. - The sum of the elements in q is as close as possible to the sum of the elements in p. >>> p_example = [10, 22, 35, 50] >>> m_example = 4 >>> find_fib_list(m_example, p_example) [8, 21, 34, 55] # Example output, actual may vary pass def main(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) p = list(map(int, data[1:])) q = find_fib_list(m, p) print(\\" \\".join(map(str, q))) if __name__ == \\"__main__\\": main()","solution":"def generate_fibonacci_until(max_value): fibs = [1, 1] while True: next_fib = fibs[-1] + fibs[-2] if next_fib > max_value: break fibs.append(next_fib) return fibs def find_closest_fib_subset(p, fibs): target_sum = sum(p) m = len(p) closest_subset = [] current_sum = 0 index = len(fibs) - 1 while m > 0: while current_sum + fibs[index] <= target_sum and m > 0: closest_subset.append(fibs[index]) current_sum += fibs[index] m -= 1 index -= 1 return closest_subset def find_fib_list(m, p): max_possible_value = sum(p) fibs = generate_fibonacci_until(max_possible_value) result = find_closest_fib_subset(p, fibs) return result def main(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) p = list(map(int, data[1:])) q = find_fib_list(m, p) print(\\" \\".join(map(str, q))) if __name__ == \\"__main__\\": main()"},{"question":"def special_sum(t: int, test_cases: list[tuple[int, int]]) -> list[int]: Calculates the special sum of each pair of numbers in the given test cases. If the first integer is divisible by the second integer, return their sum. Otherwise, return their difference. Parameters: t (int): Number of test cases. test_cases (list of tuple): List of tuples where each tuple contains two integers (a, b). Returns: list[int]: A list of results for each test case. Example: >>> special_sum(5, [(10, 5), (12, 4), (13, 5), (15, 3), (7, 2)]) [15, 16, 8, 18, 5] import pytest def test_special_sum(): assert special_sum(5, [(10, 5), (12, 4), (13, 5), (15, 3), (7, 2)]) == [15, 16, 8, 18, 5] assert special_sum(3, [(8, 2), (9, 4), (11, 11)]) == [10, 5, 22] assert special_sum(4, [(20, 5), (22, 11), (6, 3), (17, 8)]) == [25, 33, 9, 9] assert special_sum(2, [(19, 20), (50, 5)]) == [-1, 55] assert special_sum(1, [(1, 1)]) == [2] def test_special_sum_edge_cases(): assert special_sum(1, [(1000, 1)]) == [1001] assert special_sum(1, [(1, 20)]) == [-19] assert special_sum(2, [(300, 20), (333, 10)]) == [320, 323] # Example of running tests: # pytest <name_of_test_file>.py","solution":"def special_sum(t, test_cases): Calculates the special sum for each pair of numbers in the test cases. Parameters: t (int): Number of test cases. test_cases (list of tuple): List of tuples where each tuple contains two integers (a, b). Returns: list: A list of results for each test case. results = [] for a, b in test_cases: if a % b == 0: results.append(a + b) else: results.append(a - b) return results # Example usage: # t = 5 # test_cases = [(10, 5), (12, 4), (13, 5), (15, 3), (7, 2)] # special_sum(t, test_cases) -> [15, 16, 8, 18, 5]"},{"question":"def summarize_trail(n: int, trail: str) -> str: Generate a summary of the trail by grouping consecutive terrains of the same type. Args: n : int : Length of the trail string trail : str : String of length n consisting of characters 'M', 'F', 'R', and 'P' Returns: str : Summary of the trail >>> summarize_trail(10, \\"MMFFFRRPPP\\") '2M3F2R3P' >>> summarize_trail(7, \\"MRFFFRR\\") '1M1R3F2R'","solution":"def summarize_trail(n, trail): Generate a summary of the trail by grouping consecutive terrains of the same type. Args: n : int : Length of the trail string trail : str : String of length n consisting of characters 'M', 'F', 'R', and 'P' Returns: str : Summary of the trail if n == 0: return \\"\\" summary = [] current_char = trail[0] count = 1 for i in range(1, n): if trail[i] == current_char: count += 1 else: summary.append(f\\"{count}{current_char}\\") current_char = trail[i] count = 1 # Append the last group summary.append(f\\"{count}{current_char}\\") return ''.join(summary)"},{"question":"from typing import List def uniquePathsWithHazards(m: int, n: int, grid: List[List[int]]) -> int: Determines the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid, avoiding hazardous cells. >>> uniquePathsWithHazards(3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) 2 >>> uniquePathsWithHazards(2, 2, [ [1, 0], [0, 0] ]) 0","solution":"def uniquePathsWithHazards(m, n, grid): # Check if starting or ending cell is hazardous if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: # Cell is hazardous, no paths through it dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def uniquePaths(m: int, n: int, obstacles: List[List[int]]) -> int: Determine the number of different paths from the top-left corner of the grid to the bottom-right corner, given that some of the cells are blocked and you can only move right or down. Args: - m (int): the number of rows in the grid. - n (int): the number of columns in the grid. - obstacles (List[List[int]]): each sublist contains two integers [ai, bi] representing a blocked cell at position (ai, bi). Returns: - int: the number of unique paths from the top-left corner to the bottom-right corner. Examples: >>> uniquePaths(2, 2, []) 2 >>> uniquePaths(3, 3, [[1, 1]]) 2 >>> uniquePaths(3, 4, []) 10 # Write your code here # Unit tests def test_uniquePaths_no_obstacles_small_grid(): assert uniquePaths(2, 2, []) == 2 def test_uniquePaths_with_obstacles(): assert uniquePaths(3, 3, [[1, 1]]) == 2 def test_uniquePaths_no_obstacles_large_grid(): assert uniquePaths(3, 4, []) == 10 def test_uniquePaths_with_multiple_obstacles(): assert uniquePaths(3, 3, [[1, 1], [0, 1]]) == 1 def test_uniquePaths_with_blocked_path(): assert uniquePaths(3, 3, [[1, 1], [1, 0], [0, 1]]) == 0 def test_uniquePaths_single_cell_grid(): assert uniquePaths(1, 1, []) == 1 def test_uniquePaths_no_path_due_to_obstacles(): assert uniquePaths(3, 3, [[0, 1], [1, 0], [1, 1]]) == 0","solution":"def uniquePaths(m, n, obstacles): Returns the number of unique paths from the top-left corner to the bottom-right corner on an m x n grid with specified obstacles. # Create a grid initialized to 0 grid = [[0] * n for _ in range(m)] # Mark obstacle positions in the grid for obstacle in obstacles: grid[obstacle[0]][obstacle[1]] = -1 # Initialize the start position if grid[0][0] == 0: grid[0][0] = 1 # Fill the grid for i in range(m): for j in range(n): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] return grid[m-1][n-1]"},{"question":"def optimal_rearrangement(n: int, arr: List[int]) -> List[int]: Returns the rearranged sequence of n integers such that the sum of the absolute differences of consecutive elements is minimized. >>> optimal_rearrangement(4, [4, 1, 8, 10]) [1, 10, 4, 8] >>> optimal_rearrangement(3, [3, 8, 5]) [3, 8, 5] >>> optimal_rearrangement(2, [-100, 100]) [-100, 100] >>> optimal_rearrangement(5, [-5000, 4000, 0, 2000, 1000]) [-5000, 4000, 0, 2000, 1000] >>> optimal_rearrangement(6, [-10, -20, -30, 10, 20, 30]) [-30, 30, -20, 20, -10, 10]","solution":"def optimal_rearrangement(n, arr): Returns the rearranged sequence of n integers such that the sum of the absolute differences of consecutive elements is minimized. arr.sort() result = [] for i in range(n // 2): result.append(arr[i]) if n - i - 1 != i: result.append(arr[n - i - 1]) if n % 2 != 0: result.append(arr[n // 2]) return result"},{"question":"def max_distance(n: int, t: int, speeds: List[int]) -> int: Given the number of speeds, total time, and list of speeds, determine the maximum distance Alice can run. Args: n (int): The number of different speeds. t (int): The total time in hours. speeds (List[int]): A list of possible speeds in kilometers per hour. Returns: int: The maximum distance Alice can run in the given time. Examples: >>> max_distance(5, 10, [5, 8, 2, 6, 3]) 80 >>> max_distance(3, 7, [10, 15, 7]) 105 from typing import List def test_max_distance_example1(): assert max_distance(5, 10, [5, 8, 2, 6, 3]) == 80 def test_max_distance_example2(): assert max_distance(3, 7, [10, 15, 7]) == 105 def test_max_distance_single_speed(): assert max_distance(1, 5, [20]) == 100 def test_max_distance_multiple_speeds(): assert max_distance(4, 8, [5, 9, 4, 7]) == 72 def test_max_distance_all_speeds_same(): assert max_distance(3, 6, [5, 5, 5]) == 30 def test_max_distance_large_n_and_t(): assert max_distance(100, 1000, [i for i in range(1, 101)]) == 100000","solution":"def max_distance(n, t, speeds): Given the number of speeds, total time, and list of speeds, determine the maximum distance Alice can run. max_speed = max(speeds) return max_speed * t"},{"question":"def compress_string(s: str) -> str: Compresses the string by representing repeated characters with a single character followed by the count of its occurrences. Returns the compressed string if it is shorter than the original string, otherwise returns the original string. >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abc\\") 'abc'","solution":"def compress_string(s): Compresses the string by representing repeated characters with a single character followed by the count of its occurrences. Returns the compressed string if it is shorter than the original string, otherwise returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"import math from typing import List, Tuple def gcd_and_lcm_pairs(n: int, pairs: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Find the greatest common divisor (GCD) and least common multiple (LCM) of multiple pairs of integers. Parameters: n (int): the number of test cases pairs (List[Tuple[int, int]]): a list of tuples, each containing two integers Returns: List[Tuple[int, int]]: A list of tuples, each containing the GCD and LCM of the corresponding input pair. >>> gcd_and_lcm_pairs(3, [(12, 15), (7, 3), (1000000000, 999999999)]) [(3, 60), (1, 21), (1, 999999999000000000)] >>> gcd_and_lcm_pairs(2, [(5, 5), (10, 10)]) [(5, 5), (10, 10)] from solution import gcd_and_lcm_pairs def test_gcd_and_lcm_pairs(): assert gcd_and_lcm_pairs(3, [(12, 15), (7, 3), (1000000000, 999999999)]) == [(3, 60), (1, 21), (1, 999999999000000000)] def test_gcd_same_numbers(): assert gcd_and_lcm_pairs(2, [(5, 5), (10, 10)]) == [(5, 5), (10, 10)] def test_gcd_one_and_large_numbers(): assert gcd_and_lcm_pairs(2, [(1, 999999937), (10, 1)]) == [(1, 999999937), (1, 10)] def test_gcd_and_lcm_primes(): assert gcd_and_lcm_pairs(2, [(13, 17), (29, 31)]) == [(1, 221), (1, 899)] def test_mixed_cases(): assert gcd_and_lcm_pairs(4, [(6, 8), (9, 27), (14, 49), (35, 10)]) == [(2, 24), (9, 27), (7, 98), (5, 70)]","solution":"import math def gcd_and_lcm_pairs(n, pairs): results = [] for a, b in pairs: gcd = math.gcd(a, b) lcm = (a * b) // gcd results.append((gcd, lcm)) return results"},{"question":"def game(n: int, k: int, array: List[int]) -> List[str]: Function to determine the actions Nina should take in each round to help Rahul win. Args: n (int): length of Rahul's array. k (int): number of rounds. array (list): the elements of Rahul's array. Returns: list of str: actions for each round. >>> game(4, 3, [1, 3, 3, 2]) [\\"APPEND 1\\", \\"APPEND 2\\", \\"APPEND 3\\"] >>> game(5, 2, [1, 2, 3, 4, 5]) [\\"APPEND 1\\", \\"APPEND 2\\"] >>> game(3, 5, [3, 1, 2]) [\\"APPEND 1\\", \\"APPEND 2\\", \\"APPEND 3\\", \\"SKIP\\", \\"SKIP\\"] >>> game(4, 3, [1, 2, 2, 3]) [\\"APPEND 1\\", \\"APPEND 2\\", \\"APPEND 3\\"] >>> game(3, 3, [3, 3, 3]) [\\"APPEND 3\\", \\"SKIP\\", \\"SKIP\\"] >>> game(3, 5, [2, 2, 2]) [\\"APPEND 2\\", \\"SKIP\\", \\"SKIP\\", \\"SKIP\\", \\"SKIP\\"]","solution":"def game(n, k, array): Function to determine the actions Nina should take in each round. Args: n (int): length of Rahul's array. k (int): number of rounds. array (list): the elements of Rahul's array. Returns: list of str: actions for each round. actions = [] sorted_array = sorted(set(array)) current_index = 0 for _ in range(k): if current_index < len(sorted_array): actions.append(f\\"APPEND {sorted_array[current_index]}\\") current_index += 1 else: actions.append(\\"SKIP\\") return actions"},{"question":"def print_pattern(N: int): Prints a pattern of N lines where each line i contains i asterisks. >>> print_pattern(3) * ** *** >>> print_pattern(5) * ** *** **** *****","solution":"def print_pattern(N): Prints a pattern of N lines where each line i contains i asterisks. for i in range(1, N + 1): print('*' * i)"},{"question":"def min_adjacent_swaps(n: int, heights: List[int]) -> int: Computes the minimum number of adjacent swaps required to sort a list of student heights in non-decreasing order. Parameters: n (int): The number of students. heights (list): A list of integers representing the heights of the students. Returns: int: The minimum number of adjacent swaps needed to sort the list. >>> min_adjacent_swaps(5, [2, 4, 1, 3, 5]) 3 >>> min_adjacent_swaps(4, [4, 3, 2, 1]) 6 >>> min_adjacent_swaps(3, [1, 2, 3]) 0 >>> min_adjacent_swaps(5, [1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps(3, [3, 2, 1]) 3 >>> min_adjacent_swaps(5, [5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps(4, [5, 5, 5, 5]) 0 >>> min_adjacent_swaps(1, [10]) 0","solution":"def min_adjacent_swaps(n, heights): Computes the minimum number of adjacent swaps required to sort a list of student heights in non-decreasing order. Parameters: n (int): The number of students. heights (list): A list of integers representing the heights of the students. Returns: int: The minimum number of adjacent swaps needed to sort the list. # Initialize the number of swaps counter swaps = 0 # Create a copy of the list to avoid modifying the original one heights_copy = heights[:] # Bubble sort adapted to count the number of swaps for i in range(n): for j in range(0, n-i-1): if heights_copy[j] > heights_copy[j+1]: # Swap and count this swap heights_copy[j], heights_copy[j+1] = heights_copy[j+1], heights_copy[j] swaps += 1 return swaps"},{"question":"def can_form_palindrome(s: str) -> str: Determines if it's possible to select three substrings of equal length from the string s and concatenate them to form a palindrome. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it's possible to form such a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(\\"abcbaabc\\") \\"YES\\" >>> can_form_palindrome(\\"abcabcabcabc\\") \\"YES\\" >>> can_form_palindrome(\\"abcdefg\\") \\"NO\\"","solution":"def can_form_palindrome(s): Determines if it's possible to select three substrings of equal length from the string s and concatenate them to form a palindrome. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if it's possible to form such a palindrome, \\"NO\\" otherwise. n = len(s) # A helper function to check if a string is a palindrome def is_palindrome(sub): return sub == sub[::-1] # Iterate over possible substring lengths for length in range(1, n // 3 + 1): substrings = [s[i:i + length] for i in range(0, n - length + 1)] for i in range(len(substrings)): for j in range(i + 1, len(substrings)): for k in range(j + 1, len(substrings)): combined = substrings[i] + substrings[j] + substrings[k] if is_palindrome(combined): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def has_valid_path(N: int, grid: List[List[int]]) -> str: Determine if there is a valid path from the top-left corner to the bottom-right corner of the grid. >>> has_valid_path(3, [ ... [0, 0, 0], ... [1, 0, 1], ... [0, 0, 0] ... ]) == \\"YES\\" >>> has_valid_path(3, [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 0, 0] ... ]) == \\"NO\\" >>> has_valid_path(4, [ ... [0, 1, 0, 0], ... [0, 1, 0, 1], ... [0, 0, 0, 0], ... [1, 0, 1, 0] ... ]) == \\"YES\\" >>> has_valid_path(2, [ ... [1, 0], ... [0, 0] ... ]) == \\"NO\\" >>> has_valid_path(2, [ ... [0, 0], ... [0, 1] ... ]) == \\"NO\\" >>> has_valid_path(1, [ ... [0] ... ]) == \\"YES\\" >>> has_valid_path(1, [ ... [1] ... ]) == \\"NO\\" pass","solution":"def has_valid_path(N, grid): if grid[0][0] == 1 or grid[N-1][N-1] == 1: return \\"NO\\" def dfs(x, y): if x == N-1 and y == N-1: return True directions = [(1, 0), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 0: grid[nx][ny] = -1 # Mark as visited if dfs(nx, ny): return True return False if dfs(0, 0): return \\"YES\\" return \\"NO\\""},{"question":"def process_updates_and_queries(N: int, M: int, updates: List[Tuple[int, int, int]], Q: int, queries: List[int]) -> List[int]: Dan has an array of N integers. Every day he performs select a subarray [L,R] and adds a specific integer 'K' to each element in that subarray. This process is repeated for M number of days. After M days, Dan has a query: What is the value of some index P in the array. He has Q such queries. Args: N : int : number of elements in the array. M : int : number of days. updates : List[Tuple[int, int, int]] : Each of the next M lines consists of three space-separated integers L, R, and K. Q : int : number of queries. queries : List[int] : List containing each of the next Q lines with a single integer P. Returns: List[int] : A list containing the result value for each query in a new line. Constraints: 1 ≤ N ≤ 1000000 1 ≤ M ≤ 100000 1 ≤ L ≤ R ≤ N -1000 ≤ K ≤ 1000 1 ≤ Q ≤ 1000000 1 ≤ P ≤ N Example: >>> process_updates_and_queries(5, 3, [(1, 3, 2), (2, 4, -1), (3, 5, 3)], 4, [1, 4, 3, 5]) [2, 2, 4, 3] >>> process_updates_and_queries(1, 2, [(1, 1, 5), (1, 1, 10)], 1, [1]) [15] >>> process_updates_and_queries(5, 1, [(1, 5, 100)], 5, [1, 2, 3, 4, 5]) [100, 100, 100, 100, 100] >>> process_updates_and_queries(3, 1, [(1, 3, -5)], 3, [1, 2, 3]) [-5, -5, -5] >>> process_updates_and_queries(4, 2, [(1, 2, 1), (3, 4, -1)], 4, [1, 2, 3, 4]) [1, 1, -1, -1]","solution":"def process_updates_and_queries(N, M, updates, Q, queries): arr = [0] * (N + 1) # modified to N+1 to use 1-based indexing conveniently # Process the updates using a difference array technique delta = [0] * (N + 2) # another extra element to handle right-bound increment easily for L, R, K in updates: delta[L] += K if R + 1 <= N: delta[R + 1] -= K current = 0 for i in range(1, N + 1): current += delta[i] arr[i] = current # Process the queries results = [] for P in queries: results.append(arr[P]) return results"},{"question":"class Theater: Represents a theater with rows and seats where reservations can be made. >>> theater = Theater(3, 4) >>> theater.reserve(1, 1) 'Reserved' >>> theater.status(1, 1) 'Reserved' >>> theater.cancel(1, 1) 'Cancellation Successful' >>> theater.status(1, 1) 'Available' def __init__(self, rows, seats_per_row): self.seats = [[False] * seats_per_row for _ in range(rows)] def reserve(self, row, seat): Reserve a seat in the specified row. def cancel(self, row, seat): Cancel reservation for a seat in the specified row. def status(self, row, seat): Check the status of a seat in the specified row. def process_commands(shows): Process commands for multiple shows and return the results. def main(n, show_details): Main function to execute the ticket reservation system based on show details. [Unit Tests] def test_reservation_system(): n = 1 show_details = [ { 'details': ('ShowA', 3, 4), 'commands': [ 'reserve 1 1', 'status 1 1', 'reserve 1 2', 'status 1 2', 'cancel 1 1', 'status 1 1', ] } ] result = main(n, show_details) assert result == [\\"Reserved\\", \\"Reserved\\", \\"Available\\"] def test_multiple_reservations(): n = 1 show_details = [ { 'details': ('ShowB', 2, 2), 'commands': [ 'reserve 1 1', 'reserve 2 2', 'status 1 1', 'status 2 2', 'cancel 1 1', 'status 1 1', 'cancel 2 2', 'status 2 2', ] } ] result = main(n, show_details) assert result == [\\"Reserved\\", \\"Reserved\\", \\"Available\\", \\"Available\\"] def test_seat_already_reserved(): n = 1 show_details = [ { 'details': ('ShowC', 1, 1), 'commands': [ 'reserve 1 1', 'reserve 1 1', 'status 1 1', ] } ] result = main(n, show_details) assert result == [\\"Reserved\\"] def test_seat_already_available(): n = 1 show_details = [ { 'details': ('ShowD', 1, 1), 'commands': [ 'cancel 1 1', 'status 1 1', ] } ] result = main(n, show_details) assert result == [\\"Available\\"]","solution":"class Theater: def __init__(self, rows, seats_per_row): self.seats = [[False] * seats_per_row for _ in range(rows)] def reserve(self, row, seat): if not self.seats[row-1][seat-1]: self.seats[row-1][seat-1] = True return \\"Reserved\\" return \\"Already Reserved\\" def cancel(self, row, seat): if self.seats[row-1][seat-1]: self.seats[row-1][seat-1] = False return \\"Cancellation Successful\\" return \\"Already Available\\" def status(self, row, seat): return \\"Reserved\\" if self.seats[row-1][seat-1] else \\"Available\\" def process_commands(shows): results = [] for show in shows: identifier, rows, seats_per_row = show['details'] theater = Theater(rows, seats_per_row) for command in show['commands']: action, row, seat = command.split() row, seat = int(row), int(seat) if action == \\"reserve\\": theater.reserve(row, seat) elif action == \\"cancel\\": theater.cancel(row, seat) elif action == \\"status\\": results.append(theater.status(row, seat)) return results def main(n, show_details): shows = [] for i in range(n): details = show_details[i]['details'] commands = show_details[i]['commands'] shows.append({'details': details, 'commands': commands}) return process_commands(shows)"},{"question":"from typing import List def num_paths(grid: List[str]) -> int: Calculate the number of distinct paths from the top-left to the bottom-right corner in a grid with obstacles. Args: grid (List[str]): A list of strings representing the grid, where each character is either '#' (obstacle) or '.' (free). Returns: int: The number of distinct paths from the top-left to the bottom-right corner. Examples: >>> num_paths([\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths([\\"....\\", \\".#..\\", \\"..#.\\", \\"....\\"]) 4 import pytest def test_example_1(): grid = [\\"...\\", \\".#.\\", \\"...\\"] assert num_paths(grid) == 2 def test_example_2(): grid = [\\"....\\", \\".#..\\", \\"..#.\\", \\"....\\"] assert num_paths(grid) == 4 def test_blocked_start(): grid = [\\"#...\\", \\".#..\\", \\"..#.\\", \\"....\\"] assert num_paths(grid) == 0 def test_blocked_end(): grid = [\\"....\\", \\".#..\\", \\"..#.\\", \\"...#\\"] assert num_paths(grid) == 0 def test_only_one_way(): grid = [\\"..\\", \\"..\\"] assert num_paths(grid) == 2 def test_single_cell(): grid = [\\".\\"] assert num_paths(grid) == 1","solution":"def num_paths(grid): n = len(grid) m = len(grid[0]) # Edge case if start or end is blocked if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 # DP array to store number of paths to each cell dp = [[0] * m for _ in range(n)] # Starting point dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def unique_paths(n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid, where moves are only possible to the right or downward. >>> unique_paths(1) 1 >>> unique_paths(2) 2 >>> unique_paths(3) 6 >>> unique_paths(4) 20 >>> unique_paths(5) 70","solution":"def unique_paths(n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an n x n grid, where moves are only possible to the right or downward. # Create a 2D grid filled with 0's dp = [[0]*n for _ in range(n)] # Set the number of ways to reach any cell in the first row or column to 1 for i in range(n): dp[i][0] = 1 dp[0][i] = 1 # Use dynamic programming to fill the rest of the grid for i in range(1, n): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][n-1]"},{"question":"class ArrayHandler: def __init__(self, array): self.array = array self.prefix_sums = self._calculate_prefix_sums() def _calculate_prefix_sums(self): n = len(self.array) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + self.array[i] return prefix_sums def update(self, index, value): Updates the element at the given index to the new value. old_value = self.array[index - 1] diff = value - old_value self.array[index - 1] = value for i in range(index, len(self.prefix_sums)): self.prefix_sums[i] += diff def query(self, left, right): Returns the sum of elements between the given indices (1-based, inclusive). return self.prefix_sums[right] - self.prefix_sums[left - 1] def process_operations(n, m, initial_array, operations): Handles update and query operations on an array. Args: n (int): Number of elements in the initial array. m (int): Number of operations to perform. initial_array (list): Initial list of integers. operations (list): List of operations where each operation is represented as a tuple (t, x, y). Returns: list: List of results for the query operations. >>> process_operations(5, 6, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 1, 3), (2, 2, 4), (1, 5, 15), (2, 1, 5)]) [6, 13, 16, 32] >>> process_operations(5, 2, [4, 7, 2, 8, 10], [(2, 1, 5), (2, 2, 4)]) [31, 17] array_handler = ArrayHandler(initial_array) results = [] for operation in operations: t, x, y = operation if t == 1: array_handler.update(x, y) else: results.append(array_handler.query(x, y)) return results","solution":"class ArrayHandler: def __init__(self, array): self.array = array self.prefix_sums = self._calculate_prefix_sums() def _calculate_prefix_sums(self): n = len(self.array) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + self.array[i] return prefix_sums def update(self, index, value): old_value = self.array[index - 1] diff = value - old_value self.array[index - 1] = value for i in range(index, len(self.prefix_sums)): self.prefix_sums[i] += diff def query(self, left, right): return self.prefix_sums[right] - self.prefix_sums[left - 1] def process_operations(n, m, initial_array, operations): array_handler = ArrayHandler(initial_array) results = [] for operation in operations: t, x, y = operation if t == 1: array_handler.update(x, y) else: results.append(array_handler.query(x, y)) return results"},{"question":"def findSmallestSubstring(S: str, K: int) -> int: Determine the length of the smallest substring that contains at least K distinct characters. >>> findSmallestSubstring('abcabcabc', 4) -1 >>> findSmallestSubstring('abcabcabc', 3) 3 >>> findSmallestSubstring('abcdabc', 3) 3 >>> findSmallestSubstring('abcdabcde', 4) 4 >>> findSmallestSubstring('aaabbccddd', 3) 4 >>> findSmallestSubstring('abac', 2) 2 >>> findSmallestSubstring('abcdefghijklmnopqrstuvwxyz', 26) 26 >>> findSmallestSubstring('aaaaaaa', 1) 1 >>> findSmallestSubstring('aaaaaaa', 2) -1 >>> findSmallestSubstring('abcabcabcabc', 3) 3 >>> findSmallestSubstring('abcabcabcabc', 2) 2 >>> findSmallestSubstring('abcabcabcabc', 1) 1","solution":"def findSmallestSubstring(S: str, K: int) -> int: if len(set(S)) < K: return -1 freq = {} min_len = float('inf') distinct_count = 0 left = 0 for right in range(len(S)): if S[right] not in freq: freq[S[right]] = 0 freq[S[right]] += 1 if freq[S[right]] == 1: distinct_count += 1 while distinct_count >= K: min_len = min(min_len, right - left + 1) freq[S[left]] -= 1 if freq[S[left]] == 0: distinct_count -= 1 left += 1 return min_len if min_len != float('inf') else -1"},{"question":"def analyze_winners(M, R, winners): Analyze the game results to find: 1. The participant ID of the participant who won the highest number of rounds. 2. The total number of rounds each participant won. 3. The participant ID(s) who won the least number of rounds among those who won at least one round. >>> analyze_winners(5, 10, [1, 2, 3, 1, 2, 3, 1, 2, 1, 3]) (1, [4, 3, 3, 0, 0], [2, 3]) >>> analyze_winners(3, 5, [2, 2, 2, 2, 2]) (2, [0, 5, 0], [2]) >>> analyze_winners(4, 4, [1, 2, 3, 4]) (1, [1, 1, 1, 1], [1, 2, 3, 4]) >>> analyze_winners(3, 0, []) (1, [0, 0, 0], []) >>> analyze_winners(4, 10, [1, 1, 1, 3, 3, 2, 4, 3, 3, 3]) (3, [3, 1, 5, 1], [2, 4])","solution":"def analyze_winners(M, R, winners): Analyze the game results to find: 1. The participant ID of the participant who won the highest number of rounds. 2. The total number of rounds each participant won. 3. The participant ID(s) who won the least number of rounds among those who won at least one round. # Initialize the win count for each participant win_counts = [0] * M # Count wins for each participant for winner in winners: win_counts[winner - 1] += 1 # Determine the participant with the highest number of wins max_wins = max(win_counts) highest_winner_id = win_counts.index(max_wins) + 1 # Find the least number of wins among those who won at least once, by filtering out non-zero win counts non_zero_wins = [count for count in win_counts if count > 0] if non_zero_wins: least_wins = min(non_zero_wins) least_winner_ids = [i + 1 for i, count in enumerate(win_counts) if count == least_wins] else: least_winner_ids = [] return highest_winner_id, win_counts, least_winner_ids"},{"question":"def evaluate_expression_tree(tree: dict) -> int: Evaluate the expression represented by the tree and return the result as an integer. The tree is represented by a nested dictionary structure where: - Each node is a dictionary with keys: 'value', 'left', and 'right'. - Leaf nodes contain integers, non-leaf nodes contain operators ('+', '-', '*', '/'). Args: tree (dict): The root of the expression tree. Returns: int: The result of evaluating the tree. Examples: >>> evaluate_expression_tree({\\"value\\": \\"+\\", \\"left\\": {\\"value\\": 3, \\"left\\": None, \\"right\\": None}, \\"right\\": {\\"value\\": \\"*\\", \\"left\\": {\\"value\\": 2, \\"left\\": None, \\"right\\": None}, \\"right\\": {\\"value\\": 5, \\"left\\": None, \\"right\\": None}}}) 13 # Test Cases def test_single_value(): tree = {\\"value\\": 5, \\"left\\": None, \\"right\\": None} assert evaluate_expression_tree(tree) == 5 def test_addition(): tree = { \\"value\\": \\"+\\", \\"left\\": {\\"value\\": 3, \\"left\\": None, \\"right\\": None}, \\"right\\": {\\"value\\": 2, \\"left\\": None, \\"right\\": None} } assert evaluate_expression_tree(tree) == 5 def test_subtraction(): tree = { \\"value\\": \\"-\\", \\"left\\": {\\"value\\": 5, \\"left\\": None, \\"right\\": None}, \\"right\\": {\\"value\\": 3, \\"left\\": None, \\"right\\": None} } assert evaluate_expression_tree(tree) == 2 def test_multiplication(): tree = { \\"value\\": \\"*\\", \\"left\\": {\\"value\\": 4, \\"left\\": None, \\"right\\": None}, \\"right\\": {\\"value\\": 3, \\"left\\": None, \\"right\\": None} } assert evaluate_expression_tree(tree) == 12 def test_division(): tree = { \\"value\\": \\"/\\", \\"left\\": {\\"value\\": 10, \\"left\\": None, \\"right\\": None}, \\"right\\": {\\"value\\": 2, \\"left\\": None, \\"right\\": None} } assert evaluate_expression_tree(tree) == 5 def test_complex_expression(): tree = { \\"value\\": \\"+\\", \\"left\\": {\\"value\\": 3, \\"left\\": None, \\"right\\": None}, \\"right\\": { \\"value\\": \\"*\\", \\"left\\": {\\"value\\": 2, \\"left\\": None, \\"right\\": None}, \\"right\\": {\\"value\\": 5, \\"left\\": None, \\"right\\": None} } } assert evaluate_expression_tree(tree) == 13","solution":"def evaluate_expression_tree(tree): if tree[\\"left\\"] is None and tree[\\"right\\"] is None: return tree[\\"value\\"] left_value = evaluate_expression_tree(tree[\\"left\\"]) right_value = evaluate_expression_tree(tree[\\"right\\"]) if tree[\\"value\\"] == \\"+\\": return left_value + right_value elif tree[\\"value\\"] == \\"-\\": return left_value - right_value elif tree[\\"value\\"] == \\"*\\": return left_value * right_value elif tree[\\"value\\"] == \\"/\\": return left_value // right_value"},{"question":"from typing import List, Tuple, Union def assign_grades(n: int, m: int, friends: List[Tuple[int, int]]) -> Union[str, Tuple[str, List[int]]]: Determine if it's possible to assign grades to students such that no two friends have the same grade. Returns \\"possible\\" and a list of grades if it is possible, otherwise \\"impossible\\". Args: n: Number of students. m: Number of friend pairs. friends: List of tuples representing friend pairs. Returns: A tuple containing a string \\"possible\\" and a list of grades if the assignment is possible. Otherwise, returns \\"impossible\\". Examples: >>> assign_grades(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) (\\"possible\\", [1, 2, 3, 4]) >>> assign_grades(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"impossible\\" >>> assign_grades(3, 2, [(1, 2), (2, 3)]) (\\"possible\\", [1, 2, 1])","solution":"def assign_grades(n, m, friends): from collections import deque # Build adjacency list for the graph adj_list = [[] for _ in range(n + 1)] for a, b in friends: adj_list[a].append(b) adj_list[b].append(a) # We will use BFS to check if we can color the graph using 2 colors. color = [-1] * (n + 1) # -1 means unvisited, 0 and 1 will be our two colors def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring the first node with color 0 while queue: node = queue.popleft() for neighbor in adj_list[node]: if color[neighbor] == -1: # If unvisited color[neighbor] = 1 - color[node] # Color with opposite color queue.append(neighbor) elif color[neighbor] == color[node]: # If the neighbor has the same color return False return True for student in range(1, n + 1): if color[student] == -1: # If not visited if not bfs(student): return \\"impossible\\" # We need to ensure grading (1-indexed) rather than (0,1). Therefore adding 1 to each. grades = [c + 1 for c in color[1:]] return \\"possible\\", grades # Example usage: # n, m = 4, 4 # friends = [(1, 2), (2, 3), (3, 4), (4, 1)] # print(assign_grades(n, m, friends))"},{"question":"def can_be_balanced_sequence(n: int, sequence: List[int]) -> str: Determine if the sequence can be rearranged to form a balanced sequence. Args: n (int): Length of the sequence. sequence (list of int): List of positive integers of length n. Returns: str: \\"YES\\" if the sequence can be rearranged to be balanced, otherwise \\"NO\\". >>> can_be_balanced_sequence(6, [4, 1, 7, 2, 5, 1]) \\"YES\\" >>> can_be_balanced_sequence(5, [1, 2, 3, 4, 5]) \\"NO\\"","solution":"def can_be_balanced_sequence(n, sequence): Determine if the sequence can be rearranged to form a balanced sequence. Args: n (int): Length of the sequence. sequence (list of int): List of positive integers of length n. Returns: str: \\"YES\\" if the sequence can be rearranged to be balanced, otherwise \\"NO\\". total_sum = sum(sequence) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 current_sums = {0} for num in sequence: new_sums = set() for s in current_sums: new_sum = s + num if new_sum == target: return \\"YES\\" new_sums.add(new_sum) current_sums.update(new_sums) return \\"NO\\""},{"question":"def player_with_max_wins(n, m, game_results): Returns the player ID with the maximum number of wins. If there are multiple players with the same maximum number of wins, returns the smallest ID among them. :param n: int - number of players :param m: int - number of games played :param game_results: list of int - list of winning player IDs for each game :return: int - player ID with the maximum number of wins >>> player_with_max_wins(3, 4, [1, 2, 1, 3]) 1 >>> player_with_max_wins(2, 6, [2, 2, 1, 2, 2, 1]) 2 >>> player_with_max_wins(3, 3, [1, 2, 3]) 1 >>> player_with_max_wins(3, 5, [1, 1, 1, 1, 1]) 1 >>> player_with_max_wins(3, 6, [1, 2, 1, 2, 3, 1]) 1 >>> player_with_max_wins(1, 5, [1, 1, 1, 1, 1]) 1 >>> player_with_max_wins(5, 1, [3]) 3","solution":"def player_with_max_wins(n, m, game_results): Returns the player ID with the maximum number of wins. If there are multiple players with the same maximum number of wins, returns the smallest ID among them. :param n: int - number of players :param m: int - number of games played :param game_results: list of int - list of winning player IDs for each game :return: int - player ID with the maximum number of wins from collections import defaultdict # Dictionary to count the number of wins for each player win_count = defaultdict(int) for player_id in game_results: win_count[player_id] += 1 # Find the player with the maximum wins and the smallest ID if there are ties max_wins = -1 min_id_with_max_wins = float('inf') for player_id, wins in win_count.items(): if wins > max_wins or (wins == max_wins and player_id < min_id_with_max_wins): max_wins = wins min_id_with_max_wins = player_id return min_id_with_max_wins"},{"question":"def perform_operations(n: int, q: int, array: List[int], operations: List[List[int]]) -> List[int]: Perform operations as specified on the given array. :param n: Number of elements in the array (int) :param q: Number of operations (int) :param array: List of integers representing the initial array :param operations: List of operations, each operation being a list [t, l, r, k] :return: List of results for each query of the third type (sum operations) >>> perform_operations(6, 5, [1, 2, 3, 4, 5, 6], [[1, 2, 4, 2], [2, 1, 3, 1], [3, 3, 5, 0], [1, 1, 6, 5], [3, 1, 6, 0]]) [15, 54] >>> perform_operations(5, 2, [1, 2, 3, 4, 5], [[1, 1, 3, 3], [3, 1, 5, 0]]) [24] >>> perform_operations(4, 2, [3, 6, 9, 12], [[2, 2, 4, 3], [3, 1, 4, 0]]) [21] >>> perform_operations(3, 1, [10, 20, 30], [[3, 1, 3, 0]]) [60]","solution":"def perform_operations(n, q, array, operations): Perform operations as specified on the given array. :param n: Number of elements in the array (int) :param q: Number of operations (int) :param array: List of integers representing the initial array :param operations: List of operations, each operation being a list [t, l, r, k] :return: List of results for each query of the third type (sum operations) results = [] for operation in operations: t, l, r, k = operation if t == 1: for i in range(l-1, r): array[i] += k elif t == 2: for i in range(l-1, r): array[i] -= k elif t == 3: subarray_sum = sum(array[l-1:r]) results.append(subarray_sum) return results"},{"question":"from typing import List def can_first_player_win(t: int, n: int, test_cases: List[str]) -> List[str]: Determine if the first player has a guaranteed winning strategy given the initial positions of all pieces on the board. >>> can_first_player_win(2, 4, [\\"2 1 1 4 4\\", \\"3 1 1 2 2 3 3\\"]) [\\"NO\\", \\"YES\\"] >>> can_first_player_win(1, 5, [\\"4 1 1 2 2 3 3 4 4\\"]) [\\"NO\\"] def solve(t: int, n: int, test_cases: List[str]) -> List[str]: Parse the input and call the can_first_player_win function. >>> solve(2, 4, [\\"2 1 1 4 4\\", \\"3 1 1 2 2 3 3\\"]) [\\"NO\\", \\"YES\\"] >>> solve(1, 5, [\\"4 1 1 2 2 3 3 4 4\\"]) [\\"NO\\"] # Test cases def test_can_first_player_win(): assert solve(2, 4, [\\"2 1 1 4 4\\", \\"3 1 1 2 2 3 3\\"]) == [\\"NO\\", \\"YES\\"] assert solve(1, 5, [\\"4 1 1 2 2 3 3 4 4\\"]) == [\\"NO\\"] assert solve(3, 3, [\\"1 2 2\\", \\"2 1 1 3 3\\", \\"4 1 1 2 2 3 3 2 3\\"]) == [\\"YES\\", \\"NO\\", \\"NO\\"] assert solve(1, 1, [\\"1 1 1\\"]) == [\\"YES\\"] assert solve(2, 6, [\\"4 1 1 2 2 3 3 4 4\\", \\"3 2 2 3 3 4 4\\"]) == [\\"NO\\", \\"YES\\"] # Running the tests test_can_first_player_win()","solution":"def can_first_player_win(t, n, test_cases): results = [] for case in test_cases: p = case[0] positions = case[1:] if p % 2 == 0: results.append(\\"NO\\") else: results.append(\\"YES\\") return results # Function to parse input and call the function def solve(t, n, cases): test_cases = [] for case in cases: test_cases.append(list(map(int, case.split()))) return can_first_player_win(t, n, test_cases)"},{"question":"def min_moves_to_equal_ages(ages: List[int]) -> int: Returns the minimum number of moves required to make all ages equal. A move is defined as incrementing or decrementing an individual's age by 1. >>> min_moves_to_equal_ages([10, 12, 12, 15, 13]) 6 >>> min_moves_to_equal_ages([21, 21, 21]) 0 >>> min_moves_to_equal_ages([35]) 0 >>> min_moves_to_equal_ages([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 25 >>> min_moves_to_equal_ages([120, 0, 0, 120]) 240 >>> min_moves_to_equal_ages([1, 2, 2, 2, 2, 3]) 2 >>> min_moves_to_equal_ages([5, 4, 3, 2, 1]) 6","solution":"def min_moves_to_equal_ages(ages): Returns the minimum number of moves required to make all ages equal. A move is defined as incrementing or decrementing an individual's age by 1. ages.sort() median = ages[len(ages) // 2] moves = sum(abs(age - median) for age in ages) return moves"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Find the maximum sum of any non-empty subarray of the list using Kadane's Algorithm. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4, -999]) 6 >>> max_subarray_sum([-2, -3, -4, -5, -6, -999]) -2 >>> max_subarray_sum([5, -999]) 5 >>> max_subarray_sum([-1, -999]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5, -999]) 15 >>> max_subarray_sum([3, -2, 5, -1, 4, -999]) 9 >>> max_subarray_sum([1, 2, 3, -5, -999]) 6","solution":"def max_subarray_sum(nums): nums = nums[:-1] # Remove the ending -999 current_max = max_sum = nums[0] for num in nums[1:]: current_max = max(num, current_max + num) max_sum = max(max_sum, current_max) return max_sum"},{"question":"def is_valid_sudoku(grid) -> bool: Checks if the given Sudoku grid is valid according to Sudoku rules. >>> grid = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> is_valid_sudoku(grid) True >>> grid = [ ... [\\"8\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> is_valid_sudoku(grid) False","solution":"def is_valid_sudoku(grid): Checks if the given Sudoku grid is valid according to Sudoku rules. def is_valid_block(block): Checks if a block (row, column, or subgrid) contains no duplicates, excluding the empty cells represented by '.'. block = [i for i in block if i != '.'] return len(block) == len(set(block)) # Check rows for row in grid: if not is_valid_block(row): return False # Check columns for col in range(9): if not is_valid_block([grid[row][col] for row in range(9)]): return False # Check sub-grids for box_row in range(0, 9, 3): for box_col in range(0, 9, 3): block = [grid[r][c] for r in range(box_row, box_row + 3) for c in range(box_col, box_col + 3)] if not is_valid_block(block): return False return True"},{"question":"def smallest_power_of_2_greater_than_sum(n, arr): Finds the smallest power of 2 that is greater than or equal to the sum of the integers in the array. Parameters: n (int): Number of elements in the array arr (list of int): The array of integers Returns: int: The smallest power of 2 greater than or equal to the sum of the array >>> smallest_power_of_2_greater_than_sum(3, [1, 2, 3]) 8 >>> smallest_power_of_2_greater_than_sum(5, [-1, -2, -3, -4, -5]) 1","solution":"def smallest_power_of_2_greater_than_sum(n, arr): Finds the smallest power of 2 that is greater than or equal to the sum of the integers in the array. Parameters: n (int): Number of elements in the array arr (list of int): The array of integers Returns: int: The smallest power of 2 greater than or equal to the sum of the array total_sum = sum(arr) power = 1 while power < total_sum: power *= 2 return power"},{"question":"def assign_rooms(n: int, m: int, preferences: List[List[int]]) -> List[Tuple[int, int]]: Assign rooms to students based on their preferences. Parameters: n (int): The number of students m (int): The number of rooms preferences (List[List[int]]): A list of lists containing the students' room preferences Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains the student's index and the assigned room number. If no room can be assigned, the room number is -1. Example: >>> assign_rooms(3, 3, [[1, 2], [2, 3], [1]]) [(1, 1), (2, 2), (3, -1)] >>> assign_rooms(4, 5, [[4, 2, 1], [5, 3], [2], [3, 1]]) [(1, 4), (2, 5), (3, 2), (4, 3)] from solution import assign_rooms def test_example_1(): n = 3 m = 3 preferences = [ [1, 2], [2, 3], [1] ] expected_output = [(1, 1), (2, 2), (3, -1)] assert assign_rooms(n, m, preferences) == expected_output def test_example_2(): n = 4 m = 5 preferences = [ [4, 2, 1], [5, 3], [2], [3, 1] ] expected_output = [(1, 4), (2, 5), (3, 2), (4, 3)] assert assign_rooms(n, m, preferences) == expected_output def test_no_overlap(): n = 2 m = 2 preferences = [ [1], [2] ] expected_output = [(1, 1), (2, 2)] assert assign_rooms(n, m, preferences) == expected_output def test_all_overlap(): n = 3 m = 3 preferences = [ [1, 2, 3], [1, 2, 3], [1, 2, 3] ] expected_output = [(1, 1), (2, 2), (3, 3)] assert assign_rooms(n, m, preferences) == expected_output def test_not_everyone_gets_room(): n = 4 m = 2 preferences = [ [1, 2], [1, 2], [1, 2], [1, 2] ] expected_output = [(1, 1), (2, 2), (3, -1), (4, -1)] assert assign_rooms(n, m, preferences) == expected_output","solution":"def assign_rooms(n, m, preferences): room_assignments = [-1] * n room_taken = [False] * m for student_index in range(n): preferred_rooms = preferences[student_index] for room in preferred_rooms: if not room_taken[room - 1]: room_assignments[student_index] = room room_taken[room - 1] = True break return [(i + 1, room_assignments[i]) for i in range(n)]"},{"question":"def is_possible_to_rearrange(n: int, k: int, steps: List[Tuple[int, str]]) -> str: Determine if it is possible to rearrange the dance steps such that Hannah never stands still for more than k consecutive seconds. >>> is_possible_to_rearrange(3, 5, [(3, 'hold'), (6, 'move'), (1, 'hold')]) \\"POSSIBLE\\" >>> is_possible_to_rearrange(4, 10, [(3, 'hold'), (4, 'hold'), (5, 'hold'), (6, 'move')]) \\"IMPOSSIBLE\\"","solution":"def is_possible_to_rearrange(n, k, steps): # Separate the steps into hold and move hold_steps = [t for t, s in steps if s == \\"hold\\"] move_steps = [t for t, s in steps if s == \\"move\\"] # Sum of all hold times total_hold_time = sum(hold_steps) # If there's no move step and total hold time exceeds k, it's impossible if not move_steps and total_hold_time > k: return \\"IMPOSSIBLE\\" # If the longest hold step is greater than k, it's immediately impossible if hold_steps and max(hold_steps) > k: return \\"IMPOSSIBLE\\" # If all hold steps together exceed k and there are enough move steps to separate them, it's possible if len(move_steps) >= len(hold_steps) - 1: return \\"POSSIBLE\\" return \\"IMPOSSIBLE\\""},{"question":"def is_anagram_substring(s: str, t: str) -> str: Determine if some anagram of t is a substring of s. Parameters: s (str): The string to search within. t (str): The string to form anagrams from. Returns: str: \\"YES\\" if some anagram of t is a substring of s, otherwise \\"NO\\". >>> is_anagram_substring(\\"cbabcacab\\", \\"abc\\") \\"YES\\" >>> is_anagram_substring(\\"afghilmn\\", \\"abc\\") \\"NO\\"","solution":"def is_anagram_substring(s, t): Determine if some anagram of t is a substring of s. Parameters: s (str): The string to search within. t (str): The string to form anagrams from. Returns: str: \\"YES\\" if some anagram of t is a substring of s, otherwise \\"NO\\". from collections import Counter len_s, len_t = len(s), len(t) if len_t > len_s: return \\"NO\\" t_count = Counter(t) window_count = Counter(s[:len_t]) if window_count == t_count: return \\"YES\\" for i in range(len_t, len_s): window_count[s[i]] += 1 window_count[s[i - len_t]] -= 1 if window_count[s[i - len_t]] == 0: del window_count[s[i - len_t]] if window_count == t_count: return \\"YES\\" return \\"NO\\""},{"question":"def calculate_centroid_of_polygon(vertices): Calculate the centroid of a polygon given its vertices. vertices: list of tuples, where each tuple is an (x, y) coordinate of a vertex. Returns the centroid of the polygon as a tuple (Cx, Cy). def find_centroids_of_forests(input_data): Determine the centroids of multiple rain forest polygons based on input data. input_data: A string representing the input format described in the task. Returns a list of tuples, where each tuple provides the (Cx, Cy) of a polygon. # Tests def test_calculate_centroid_of_polygon_triangle(): vertices = [(0, 0), (4, 0), (2, 3)] assert calculate_centroid_of_polygon(vertices) == (2.0000, 1.0000) def test_calculate_centroid_of_polygon_square(): vertices = [(1, 1), (4, 1), (4, 5), (1, 5)] assert calculate_centroid_of_polygon(vertices) == (2.5000, 3.0000) def test_find_centroids_of_forests(): input_data = \\"2n3 0 0 4 0 2 3n4 1 1 4 1 4 5 1 5\\" centroids = find_centroids_of_forests(input_data) assert centroids == [(2.0000, 1.0000), (2.5000, 3.0000)] def test_find_centroids_of_forests_single_polygon(): input_data = \\"1n4 0 0 0 4 4 4 4 0\\" centroids = find_centroids_of_forests(input_data) assert centroids == [(2.0000, 2.0000)]","solution":"def calculate_centroid_of_polygon(vertices): Calculate the centroid of a polygon given its vertices. vertices: list of tuples, where each tuple is an (x, y) coordinate of a vertex. Returns the centroid of the polygon as a tuple (Cx, Cy). n = len(vertices) area = 0 Cx = 0 Cy = 0 for i in range(n): x0, y0 = vertices[i] x1, y1 = vertices[(i + 1) % n] factor = (x0 * y1 - x1 * y0) area += factor Cx += (x0 + x1) * factor Cy += (y0 + y1) * factor area = area / 2 Cx = Cx / (6 * area) Cy = Cy / (6 * area) return round(Cx, 4), round(Cy, 4) def find_centroids_of_forests(input_data): lines = input_data.strip().split('n') M = int(lines[0]) centroids = [] for i in range(1, M + 1): parts = list(map(int, lines[i].split())) c_i = parts[0] vertices = [(parts[2*j + 1], parts[2*j + 2]) for j in range(c_i)] centroid = calculate_centroid_of_polygon(vertices) centroids.append(centroid) return centroids"},{"question":"def isInterleave(word1: str, word2: str, target: str) -> str: Determine if the target word is an interleaving of word1 and word2. >>> isInterleave(\\"abc\\", \\"def\\", \\"adbcef\\") \\"Yes\\" >>> isInterleave(\\"abc\\", \\"def\\", \\"abdfec\\") \\"No\\" >>> isInterleave(\\"aab\\", \\"cc\\", \\"ababac\\") \\"No\\" from solution import isInterleave def test_interleaving_words(): assert isInterleave(\\"abc\\", \\"def\\", \\"adbcef\\") == \\"Yes\\" assert isInterleave(\\"abc\\", \\"def\\", \\"abdfec\\") == \\"No\\" assert isInterleave(\\"aab\\", \\"cc\\", \\"ababac\\") == \\"No\\" assert isInterleave(\\"abc\\", \\"\\", \\"abc\\") == \\"Yes\\" assert isInterleave(\\"\\", \\"abc\\", \\"abc\\") == \\"Yes\\" assert isInterleave(\\"a\\", \\"b\\", \\"ab\\") == \\"Yes\\" assert isInterleave(\\"a\\", \\"b\\", \\"ba\\") == \\"Yes\\" assert isInterleave(\\"abc\\", \\"def\\", \\"abcdef\\") == \\"Yes\\" assert isInterleave(\\"abc\\", \\"def\\", \\"abdecf\\") == \\"Yes\\" assert isInterleave(\\"abc\\", \\"def\\", \\"abcdefg\\") == \\"No\\"","solution":"def isInterleave(word1, word2, target): # Check if the lengths match the requirement if len(target) != len(word1) + len(word2): return \\"No\\" # dp table to store results of subproblems dp = [[False] * (len(word2)+1) for _ in range(len(word1)+1)] # Initial state, both word1 and word2 are empty dp[0][0] = True # Fill the dp table for i in range(len(word1)+1): for j in range(len(word2)+1): if i > 0 and dp[i-1][j] and word1[i-1] == target[i+j-1]: dp[i][j] = True if j > 0 and dp[i][j-1] and word2[j-1] == target[i+j-1]: dp[i][j] = True # The answer will be in the bottom-right cell of the dp table return \\"Yes\\" if dp[len(word1)][len(word2)] else \\"No\\""},{"question":"def process_bookings(input_data: str) -> List[str]: Process ticket booking requests, allocate seats, and ensure that no two patrons are allocated the same seat for the same show at the same time. Args: input_data (str): Input string containing details of shows, time slots, and booking requests. Returns: List[str]: A list of strings \\"SUCCESS\\" or \\"FAIL\\" for each booking request. Examples: >>> process_bookings('''2 ... 3 ... 10:00 100 ... 12:00 100 ... 14:00 150 ... 2 ... 09:00 50 ... 11:00 60 ... 5 ... 10:00 1 10 ... 12:00 1 100 ... 14:00 1 150 ... 09:00 2 25 ... 10:00 1 10''') ['SUCCESS', 'SUCCESS', 'SUCCESS', 'SUCCESS', 'FAIL'] >>> process_bookings('''1 ... 1 ... 10:00 100 ... 0''') []","solution":"def process_bookings(input_data): lines = input_data.strip().split(\\"n\\") n = int(lines[0].strip()) idx = 1 # Show and Time slot seat allocation dictionary shows = {} for _ in range(n): show_id = _ + 1 t = int(lines[idx].strip()) idx += 1 shows[show_id] = {} for _ in range(t): timeslot, s = lines[idx].strip().split() s = int(s) idx += 1 shows[show_id][timeslot] = [False] * (s + 1) # Boolean array to track booked seats for each timeslot m = int(lines[idx].strip()) idx += 1 results = [] for _ in range(m): timeslot, show_id, seat = lines[idx].strip().split() show_id = int(show_id) seat = int(seat) idx += 1 if shows[show_id][timeslot][seat] == False: shows[show_id][timeslot][seat] = True results.append(\\"SUCCESS\\") else: results.append(\\"FAIL\\") return results"},{"question":"def min_base_modules(n: int) -> int: Determine the minimum number of base modules required to achieve the target LBU capacity. >>> min_base_modules(1) == 1 >>> min_base_modules(2) == 2 >>> min_base_modules(3) == 2 >>> min_base_modules(4) == 3 >>> min_base_modules(6) == 3 >>> min_base_modules(10) == 4","solution":"def min_base_modules(n): Determine the minimum number of base modules required to achieve the target LBU capacity. if n == 1: return 1 # We perform a binary search for efficient calculation left, right = 1, n while left <= right: mid = (left + right) // 2 if (mid * (mid + 1)) // 2 >= n: right = mid - 1 else: left = mid + 1 return left"},{"question":"def find_pairs_with_target(arr, target): Returns an array of unique pairs of integers from arr whose sum is equal to target. Each pair is in the form of [x, y] where x <= y. The pairs in the output array are sorted in ascending order. >>> find_pairs_with_target([-2, 1, 3, 0, 2, 7, 5], 5) [[-2, 7], [0, 5], [2, 3]] >>> find_pairs_with_target([1, 2, 3, 4, 5, 6], 10) [[4, 6]] >>> find_pairs_with_target([1, 2, 3], 7) \\"No valid pairs\\" >>> find_pairs_with_target([1, 1, 2, 2, 3, 3], 4) [[1, 3], [2, 2]] >>> find_pairs_with_target([-1, -2, -3, 3, 2, 1], 0) [[-3, 3], [-2, 2], [-1, 1]] >>> find_pairs_with_target([-10**6, 10**6, 0], 0) [[-1000000, 1000000]] >>> find_pairs_with_target([1, 9, 2, 8, 3, 7, 4, 6, 5, 5], 10) [[1, 9], [2, 8], [3, 7], [4, 6], [5, 5]] >>> find_pairs_with_target([], 5) \\"No valid pairs\\" >>> find_pairs_with_target([5], 5) \\"No valid pairs\\" >>> find_pairs_with_target([-1, 1, -2, 2], 0) [[-2, 2], [-1, 1]]","solution":"def find_pairs_with_target(arr, target): Returns an array of unique pairs of integers from arr whose sum is equal to target. Each pair is in the form of [x, y] where x <= y. The pairs in the output array are sorted in ascending order. arr.sort() seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pair = tuple(sorted((number, complement))) pairs.add(pair) seen.add(number) result = sorted(map(list, pairs)) return result if result else \\"No valid pairs\\""},{"question":"def highest_sales_per_day(test_cases: list) -> list: Processes the given sales data and finds the highest sales day within each week for a given period. Returns the day of the week and the sales amount for that day in the specified format. Example: >>> highest_sales_per_day(parse_input(\\"2n10 20 30 40 50 60 70n50 60 70 80 30 20 10n1n5 15 25 35 45 55 65n-1\\")) [\\"Week 1: 6 70\\", \\"Week 2: 3 80\\", \\"Week 3: 6 65\\"] pass def parse_input(input_data: str) -> list: Parses the input data string and converts it into a list of test cases. Example: >>> parse_input(\\"2n10 20 30 40 50 60 70n50 60 70 80 30 20 10n1n5 15 25 35 45 55 65n-1\\") [[[10, 20, 30, 40, 50, 60, 70], [50, 60, 70, 80, 30, 20, 10]], [[5, 15, 25, 35, 45, 55, 65]]] pass","solution":"def highest_sales_per_day(test_cases): results = [] week_number = 1 for sales_data in test_cases: for week in sales_data: max_sales = max(week) max_day = week.index(max_sales) results.append(f\\"Week {week_number}: {max_day} {max_sales}\\") week_number += 1 return results def parse_input(input_data): data = input_data.strip().split(\\"n\\") i = 0 test_cases = [] while i < len(data) and data[i] != \\"-1\\": weeks_count = int(data[i]) i += 1 weeks_sales = [] for _ in range(weeks_count): week_sales = list(map(int, data[i].split())) weeks_sales.append(week_sales) i += 1 test_cases.append(weeks_sales) return test_cases"},{"question":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id, initial_quantity): Adds a new product with initial quantity. if product_id not in self.products: self.products[product_id] = initial_quantity def update_product_quantity(self, product_id, change_in_quantity): Updates the quantity of an existing product. if product_id in self.products: self.products[product_id] += change_in_quantity def get_product_quantity(self, product_id): Retrieves the current quantity of a product. if product_id in self.products: return self.products[product_id] else: return \\"Product not found\\" # Unit Tests def test_add_and_get_product(): inventory = Inventory() inventory.add_product('apple', 50) assert inventory.get_product_quantity('apple') == 50 def test_update_and_get_product(): inventory = Inventory() inventory.add_product('apple', 50) inventory.update_product_quantity('apple', -30) assert inventory.get_product_quantity('apple') == 20 def test_get_product_not_found(): inventory = Inventory() assert inventory.get_product_quantity('orange') == \\"Product not found\\" def test_update_product_multiple_times(): inventory = Inventory() inventory.add_product('banana', 100) inventory.update_product_quantity('banana', 200) inventory.update_product_quantity('banana', -50) assert inventory.get_product_quantity('banana') == 250 def test_add_multiple_products_and_get(): inventory = Inventory() inventory.add_product('apple', 50) inventory.add_product('banana', 100) assert inventory.get_product_quantity('apple') == 50 assert inventory.get_product_quantity('banana') == 100","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_id, initial_quantity): Adds a new product with initial quantity. if product_id not in self.products: self.products[product_id] = initial_quantity def update_product_quantity(self, product_id, change_in_quantity): Updates the quantity of an existing product. if product_id in self.products: self.products[product_id] += change_in_quantity def get_product_quantity(self, product_id): Retrieves the current quantity of a product. if product_id in self.products: return self.products[product_id] else: return \\"Product not found\\""},{"question":"def scale_polyline(points, factor): Scales a polyline by a given factor. Parameters: points (list of tuple): A list of (x, y) tuples representing the polyline points. factor (float): The scaling factor. Returns: list of tuple: A list of (x, y) tuples representing the scaled polyline points. def process_input(input_data): Process input data and return points and scaling factor. Parameters: input_data (str): Multiline string of input data. Returns: tuple: A tuple containing a list of points and a scaling factor. def format_output(scaled_points): Formats the scaled points for output. Parameters: scaled_points (list of tuple): A list of scaled polyline points. Returns: str: A formatted string with the scaled points. def main(input_data): Main function to process the input data, scale the polyline, and format the output. Parameters: input_data (str): Multiline string of input data. Returns: str: A formatted string with the scaled polyline points. def test_scale_polyline(): points = [(1, 1), (2, 3), (4, 5), (8, 8), (10, 10)] factor = 0.5 expected = [(0.50, 0.50), (1.00, 1.50), (2.00, 2.50), (4.00, 4.00), (5.00, 5.00)] assert scale_polyline(points, factor) == expected def test_process_input(): input_data = \\"5n1 1n2 3n4 5n8 8n10 10n0.5\\" expected_points = [(1, 1), (2, 3), (4, 5), (8, 8), (10, 10)] expected_factor = 0.5 points, factor = process_input(input_data) assert points == expected_points assert factor == expected_factor def test_format_output(): scaled_points = [(0.50, 0.50), (1.00, 1.50), (2.00, 2.50), (4.00, 4.00), (5.00, 5.00)] expected_output = \\"0.50 0.50n1.00 1.50n2.00 2.50n4.00 4.00n5.00 5.00\\" assert format_output(scaled_points) == expected_output def test_main(): input_data = \\"5n1 1n2 3n4 5n8 8n10 10n0.5\\" expected_output = \\"0.50 0.50n1.00 1.50n2.00 2.50n4.00 4.00n5.00 5.00\\" assert main(input_data) == expected_output","solution":"def scale_polyline(points, factor): Scales a polyline by a given factor. Parameters: points (list of tuple): A list of (x, y) tuples representing the polyline points. factor (float): The scaling factor. Returns: list of tuple: A list of (x, y) tuples representing the scaled polyline points. scaled_points = [(round(x * factor, 2), round(y * factor, 2)) for x, y in points] return scaled_points def process_input(input_data): Process input data and return points and scaling factor. Parameters: input_data (str): Multiline string of input data. Returns: tuple: A tuple containing a list of points and a scaling factor. lines = input_data.strip().split('n') N = int(lines[0].strip()) points = [tuple(map(int, lines[i + 1].strip().split())) for i in range(N)] factor = float(lines[N + 1].strip()) return points, factor def format_output(scaled_points): Formats the scaled points for output. Parameters: scaled_points (list of tuple): A list of scaled polyline points. Returns: str: A formatted string with the scaled points. return 'n'.join(f\\"{x:.2f} {y:.2f}\\" for x, y in scaled_points) def main(input_data): points, factor = process_input(input_data) scaled_points = scale_polyline(points, factor) return format_output(scaled_points)"},{"question":"def longest_arithmetic_subsequence(n: int, arr: List[int]) -> int: Determine the length of the longest arithmetic sequence that can be formed using elements from this list. >>> longest_arithmetic_subsequence(5, [3, 6, 9, 12, 15]) 5 >>> longest_arithmetic_subsequence(7, [1, 7, 3, 5, 9, 11, 13]) 4 >>> longest_arithmetic_subsequence(4, [1, 2, 2, 2]) 3 >>> longest_arithmetic_subsequence(1, [3]) 1 >>> longest_arithmetic_subsequence(2, [1, 5]) 2 >>> longest_arithmetic_subsequence(4, [1, 4, 7, 10]) 4 >>> longest_arithmetic_subsequence(4, [1000000000, 999999997, 999999994, 999999991]) 4 >>> longest_arithmetic_subsequence(5, [5, 5, 5, 5, 5]) 5 >>> longest_arithmetic_subsequence(4, [10, 1, 3, 4]) 2 >>> longest_arithmetic_subsequence(8, [1, 5, 7, 8, 5, 3, 4, 5]) 3","solution":"def longest_arithmetic_subsequence(n, arr): if n <= 2: return n dp = {} max_length = 0 for i in range(n): for j in range(i + 1, n): diff = arr[j] - arr[i] if (i, diff) in dp: dp[(j, diff)] = dp[(i, diff)] + 1 else: dp[(j, diff)] = 2 max_length = max(max_length, dp[(j, diff)]) return max_length"},{"question":"def min_operations_to_convert(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s to string t. >>> min_operations_to_convert(\\"sitting\\", \\"kitten\\") 3 >>> min_operations_to_convert(\\"sunday\\", \\"saturday\\") 3","solution":"def min_operations_to_convert(s, t): Returns the minimum number of operations required to convert string s to string t. m, n = len(s), len(t) # Create a DP array to hold the minimum number of operations for each substring. dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the first row and first column of the DP array. for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill in the rest of the DP array. for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"from typing import List, Tuple def minimum_time_to_collect_treasure(N: int, temples: List[Tuple[int, int, int]], sequence: List[int]) -> int: Determine the shortest possible time to visit all specified temples and collect all pieces of the treasure. :param N: Size of the grid (N x N) :param temples: A list of tuples, each containing the x, y coordinates of a temple, and an indicator of whether it contains a treasure :param sequence: A list of temple indices specifying the order to visit them :return: The shortest travel time to visit all specified temples and collect all treasure pieces Example: >>> N = 5 >>> temples = [(0, 0, 1), (0, 1, 0), (1, 1, 1), (2, 2, 0), (4, 4, 1)] >>> sequence = [1, 3, 5] >>> minimum_time_to_collect_treasure(N, temples, sequence) 8 # Unit tests def test_example_1(): N = 5 temples = [(0, 0, 1), (0, 1, 0), (1, 1, 1), (2, 2, 0), (4, 4, 1)] sequence = [1, 3, 5] assert minimum_time_to_collect_treasure(N, temples, sequence) == 8 def test_minimum_travel(): N = 3 temples = [(0, 0, 1), (1, 0, 0), (1, 1, 1)] sequence = [1, 2, 3] assert minimum_time_to_collect_treasure(N, temples, sequence) == 2 def test_large_grid(): N = 10 temples = [(0, 0, 1), (9, 9, 1)] sequence = [1, 2] assert minimum_time_to_collect_treasure(N, temples, sequence) == 18 def test_all_treasures(): N = 3 temples = [(0, 0, 1), (0, 2, 1), (2, 2, 1)] sequence = [1, 2, 3] assert minimum_time_to_collect_treasure(N, temples, sequence) == 4","solution":"from collections import deque def shortest_path_bfs(grid, start, end): N = len(grid) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist+1)) return -1 def minimum_time_to_collect_treasure(N, temples, sequence): grid = [[0] * N for _ in range(N)] treasures = [] for x, y, treasure in temples: grid[x][y] = treasure treasures.append((x, y, treasure)) total_time = 0 current_position = treasures[sequence[0]-1] for index in sequence[1:]: next_position = treasures[index-1] travel_time = shortest_path_bfs(grid, current_position[:2], next_position[:2]) total_time += travel_time current_position = next_position return total_time def parse_input(input_str): lines = input_str.strip().split('n') N = int(lines[0].strip()) M = int(lines[1].strip()) temples = [] for i in range(2, 2 + M): x, y, treasure = map(int, lines[i].strip().split()) temples.append((x, y, treasure)) R = int(lines[2 + M].strip()) sequence = list(map(int, lines[2 + M + 1].strip().split())) return (N, temples, sequence) def main(): import sys input_str = sys.stdin.read() N, temples, sequence = parse_input(input_str) result = minimum_time_to_collect_treasure(N, temples, sequence) print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def max_subsequences(n: int, s: str, words: List[str]) -> int: Returns the maximum number of words from the array that can appear as subsequences in the given string s. >>> max_subsequences(3, 'abpcplea', ['apple', 'monkey', 'plea']) 2 >>> max_subsequences(4, 'abcde', ['a', 'bb', 'acd', 'ace']) 3","solution":"def max_subsequences(n, s, words): Returns the maximum number of words that can appear as subsequences in the string s. def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) count = 0 for word in words: if is_subsequence(word, s): count += 1 return count"},{"question":"def min_unique_ingredients(courses: List[str]) -> int: Find the minimum number of unique ingredients required to cover all the courses. >>> min_unique_ingredients([\\"pepper salt\\", \\"butter garlic\\", \\"salt garlic pepper\\"]) 4 >>> min_unique_ingredients([\\"tomato basil\\"]) 2 >>> min_unique_ingredients([\\"sugar spice\\", \\"everything nice\\", \\"chemical x\\"]) 6 >>> min_unique_ingredients([\\"apple banana\\", \\"banana cherry\\", \\"cherry date\\"]) 4 >>> min_unique_ingredients([\\"milk milk\\", \\"milk milk\\", \\"milk milk\\"]) 1","solution":"def min_unique_ingredients(courses): unique_ingredients = set() for course in courses: ingredients = course.split() unique_ingredients.update(ingredients) return len(unique_ingredients)"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Processes the queries on the list. Args: n (int): The number of elements in the list. q (int): The number of queries. array (list of int): The initial list of elements. queries (list of tuples): The list of queries. Returns: list of int: The result of the queries where sum is calculated. result = [] for query in queries: if query[0] == 1: # Find the sum of the elements in the subarray from index query[1] to query[2] elif query[0] == 2: # Update the element at index query[1] to the value query[2] return result # Unit Test def test_process_queries_example_case(): n = 6 q = 5 array = [1, 2, 3, 4, 5, 6] queries = [ (1, 1, 3), (1, 2, 4), (2, 3, 10), (1, 1, 3), (1, 3, 6) ] expected_output = [6, 9, 13, 25] assert process_queries(n, q, array, queries) == expected_output def test_process_queries_single_element_update(): n = 3 q = 4 array = [1, 3, 5] queries = [ (1, 1, 1), (2, 2, 10), (1, 1, 3), (1, 2, 2) ] expected_output = [1, 16, 10] assert process_queries(n, q, array, queries) == expected_output def test_process_queries_multiple_updates(): n = 4 q = 5 array = [2, 4, 6, 8] queries = [ (1, 1, 4), (2, 3, 5), (1, 1, 4), (2, 4, 10), (1, 2, 4) ] expected_output = [20, 19, 19] assert process_queries(n, q, array, queries) == expected_output def test_process_queries_no_sum_queries(): n = 2 q = 2 array = [1, 2] queries = [ (2, 1, 5), (2, 2, 8) ] expected_output = [] assert process_queries(n, q, array, queries) == expected_output def test_process_queries_large_numbers(): n = 3 q = 2 array = [10**9, -10**9, 10**9] queries = [ (1, 1, 3), (2, 2, 10**9) ] expected_output = [10**9] assert process_queries(n, q, array, queries) == expected_output","solution":"def process_queries(n, q, array, queries): Processes the queries on the list. Args: n (int): The number of elements in the list. q (int): The number of queries. array (list of int): The initial list of elements. queries (list of tuples): The list of queries. Returns: list of int: The result of the queries where sum is calculated. result = [] for query in queries: if query[0] == 1: # Query of type 1: sum of subarray from index query[1] to query[2] l, r = query[1] - 1, query[2] - 1 # Convert to 0-based index result.append(sum(array[l:r+1])) elif query[0] == 2: # Query of type 2: update element at index query[1] to query[2] x, y = query[1] - 1, query[2] # Convert to 0-based index array[x] = y return result"},{"question":"def max_teams(n: int, k: int, t: int, power_levels: List[int]) -> int: Determines the maximum number of teams that can be formed such that each team has exactly k creatures and the difference between the maximum and minimum power levels in each team does not exceed the threshold t. :param n: int - the total number of creatures :param k: int - the number of creatures per team :param t: int - the threshold of maximum power difference in a team :param power_levels: List[int] - the power levels of the creatures :return: int - the maximum number of teams that can be formed >>> max_teams(6, 3, 10, [18, 12, 15, 9, 7, 10]) 2 >>> max_teams(5, 2, 5, [3, 8, 5, 1, 11]) 2 >>> max_teams(4, 2, 1, [1, 3, 5, 7]) 0 >>> max_teams(6, 3, 0, [5, 5, 5, 5, 5, 5]) 2 >>> max_teams(7, 3, 2, [1, 2, 3, 4, 5, 6, 7]) 2 >>> max_teams(3, 1, 0, [10, 20, 30]) 3 >>> max_teams(6, 3, 100, [10, 20, 30, 40, 50, 60]) 2 >>> max_teams(1, 1, 0, [10]) 1 >>> max_teams(4, 2, 0, [10, 10, 10, 10]) 2","solution":"def max_teams(n, k, t, power_levels): Determines the maximum number of teams that can be formed such that each team has exactly k creatures and the difference between the maximum and minimum power levels in each team does not exceed the threshold t. :param n: int - the total number of creatures :param k: int - the number of creatures per team :param t: int - the threshold of maximum power difference in a team :param power_levels: List[int] - the power levels of the creatures :return: int - the maximum number of teams that can be formed power_levels.sort() teams = 0 i = 0 while i + k <= n: if power_levels[i + k - 1] - power_levels[i] <= t: teams += 1 i += k else: i += 1 return teams"},{"question":"def are_anagrams(s1: str, s2: str) -> str: Determines if two strings are anagrams of each other. Args: s1 (str): First string. s2 (str): Second string. Returns: str: \\"Yes\\" if the strings are anagrams, otherwise \\"No\\". pass def process_test_cases(t: int, test_cases: list) -> list: Processes multiple test cases to determine if pairs of strings are anagrams. Args: t (int): Number of test cases. test_cases (list of tuples): List of tuples where each tuple contains two strings to be checked. Returns: list of str: List of results for each test case, 'Yes' or 'No'. pass","solution":"def are_anagrams(s1, s2): Returns 'Yes' if s1 and s2 are anagrams, 'No' otherwise. return 'Yes' if sorted(s1) == sorted(s2) else 'No' def process_test_cases(t, test_cases): Processes multiple test cases to determine if pairs of strings are anagrams. Args: t (int): Number of test cases. test_cases (list of tuples): List of tuples where each tuple contains two strings to be checked. Returns: list of str: List of results for each test case, 'Yes' or 'No'. return [are_anagrams(s1, s2) for s1, s2 in test_cases]"},{"question":"def max_non_overlapping_events(n: int, events: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping events one can attend in a day. Parameters: n (int): Number of events events (list of tuples): Each tuple contains the start time and end time of an event Returns: int: Maximum number of non-overlapping events Examples: >>> max_non_overlapping_events(5, [(1, 4), (2, 5), (3, 6), (4, 7), (5, 8)]) 2 >>> max_non_overlapping_events(3, [(1, 2), (2, 3), (3, 4)]) 3","solution":"def max_non_overlapping_events(n, events): Determines the maximum number of non-overlapping events one can attend in a day. Parameters: n (int): Number of events events (list of tuples): Each tuple contains the start time and end time of an event Returns: int: Maximum number of non-overlapping events # Sort the events based on their end times events.sort(key=lambda x: x[1]) count = 0 last_end_time = -1 for start, end in events: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def merge_sequences(n: int, seq1: List[int], seq2: List[int]) -> List[int]: Merges two sequences by alternating the values from each sequence. Parameters: n (int): Number of integers in each sequence. seq1 (list): The first sequence of integers. seq2 (list): The second sequence of integers. Returns: list: The merged sequence of integers. Examples: >>> merge_sequences(3, [1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sequences(4, [9, 7, 5, 3], [8, 6, 4, 2]) [9, 8, 7, 6, 5, 4, 3, 2]","solution":"def merge_sequences(n, seq1, seq2): Merges two sequences by alternating the values from each sequence. Parameters: n (int): Number of integers in each sequence. seq1 (list): The first sequence of integers. seq2 (list): The second sequence of integers. Returns: list: The merged sequence of integers. merged_sequence = [] for i in range(n): merged_sequence.append(seq1[i]) merged_sequence.append(seq2[i]) return merged_sequence"},{"question":"def valid_arrangements(T: int, cases: List[int]) -> List[int]: Given the number of plants N, return the number of valid arrangements modulo 1000000007. >>> valid_arrangements(1, [1]) == [1] >>> valid_arrangements(1, [2]) == [2] >>> valid_arrangements(1, [3]) == [0]","solution":"def valid_arrangements(T, cases): MOD = 1000000007 results = [] for N in cases: if N == 1: results.append(1) elif N == 2: results.append(2) else: results.append(0) return results"},{"question":"def repeated_substring_pattern(lines): Returns a list of booleans indicating whether each string in the input list has a repeated substring pattern. >>> repeated_substring_pattern([\\"abab\\", \\"aba\\", \\"abcabcabc\\", \\"a\\"]) [True, False, True, False] >>> repeated_substring_pattern([\\"a\\", \\"b\\", \\"c\\"]) [False, False, False] >>> repeated_substring_pattern([\\"aaa\\", \\"abcabc\\", \\"zzzz\\"]) [True, True, True] >>> repeated_substring_pattern([\\"ab\\", \\"abcdef\\", \\"abcdefghij\\"]) [False, False, False] >>> repeated_substring_pattern([\\"\\"]) [False] >>> repeated_substring_pattern([\\"aaaaaaaaaa\\"]) [True] >>> repeated_substring_pattern([\\"a\\" * 100000]) [True] >>> repeated_substring_pattern([\\"abababab\\", \\"abcdabcd\\", \\"abcabcabcabc\\", \\"a\\"]) [True, True, True, False]","solution":"def repeated_substring_pattern(lines): Returns a list of booleans indicating whether each string in the input list has a repeated substring pattern. def is_repeated_pattern(s): Helper function to determine if a string s has a repeated substring pattern. l = len(s) for i in range(1, l // 2 + 1): if l % i == 0: if s[:i] * (l // i) == s: return True return False return [is_repeated_pattern(line) for line in lines]"},{"question":"def subarrays_with_k_distinct(arr: List[int], K: int) -> int: Count the number of subarrays that have exactly K distinct integers. >>> subarrays_with_k_distinct([1, 2, 1, 2, 3], 2) 7 >>> subarrays_with_k_distinct([1, 1, 1, 1], 1) 10 >>> subarrays_with_k_distinct([1, 1, 1, 1], 2) 0 >>> subarrays_with_k_distinct([1, 2, 3, 4], 5) 0 >>> subarrays_with_k_distinct([1, 2, 1, 3, 4], 3) 3 >>> large_array = [i // 100 for i in range(100000)] >>> subarrays_with_k_distinct(large_array, 2) > 0 True","solution":"def subarrays_with_k_distinct(arr, K): from collections import defaultdict def at_most_k_distinct(k): count = defaultdict(int) left = 0 result = 0 for right in range(len(arr)): if count[arr[right]] == 0: k -= 1 count[arr[right]] += 1 while k < 0: count[arr[left]] -= 1 if count[arr[left]] == 0: k += 1 left += 1 result += right - left + 1 return result return at_most_k_distinct(K) - at_most_k_distinct(K - 1)"},{"question":"def process_transactions(book_transactions): Processes a list of book transactions and determines the final state of each book. Parameters: book_transactions (list of tuples): A list of tuples where each tuple contains an integer (book_id) and a string (action, either 'borrow' or 'return'). Returns: dict: A dictionary with book IDs as keys and their final status ('borrowed' or 'returned') as values. from solution import process_transactions def test_process_transactions_basic(): transactions = [(1, 'borrow'), (2, 'borrow'), (1, 'return'), (3, 'borrow'), (2, 'return'), (3, 'return')] assert process_transactions(transactions) == {1: 'returned', 2: 'returned', 3: 'returned'} def test_process_transactions_ignoring_redundant_actions(): transactions = [(1, 'borrow'), (1, 'borrow'), (2, 'return'), (2, 'borrow'), (2, 'borrow'), (1, 'return'), (3, 'borrow')] assert process_transactions(transactions) == {1: 'returned', 2: 'borrowed', 3: 'borrowed'} def test_process_transactions_with_same_action(): transactions = [(5, 'borrow'), (5, 'borrow'), (5, 'return'), (5, 'return')] assert process_transactions(transactions) == {5: 'returned'} def test_process_transactions_single_borrow(): transactions = [(10, 'borrow')] assert process_transactions(transactions) == {10: 'borrowed'} def test_process_transactions_single_return(): transactions = [(10, 'return')] assert process_transactions(transactions) == {10: 'returned'} def test_process_transactions_mixed_actions(): transactions = [(20, 'borrow'), (20, 'return'), (20, 'borrow')] assert process_transactions(transactions) == {20: 'borrowed'}","solution":"def process_transactions(book_transactions): Processes a list of book transactions and determines the final state of each book. Parameters: book_transactions (list of tuples): A list of tuples where each tuple contains an integer (book_id) and a string (action, either 'borrow' or 'return'). Returns: dict: A dictionary with book IDs as keys and their final status ('borrowed' or 'returned') as values. final_status = {} for book_id, action in book_transactions: if book_id not in final_status: if action == 'borrow': final_status[book_id] = 'borrowed' elif action == 'return': final_status[book_id] = 'returned' else: if action == 'borrow' and final_status[book_id] == 'returned': final_status[book_id] = 'borrowed' elif action == 'return' and final_status[book_id] == 'borrowed': final_status[book_id] = 'returned' return final_status"},{"question":"def find_min_subset_difference(N: int, arr: List[int]) -> int: Partition the list into two non-empty subsets such that the absolute difference between the sum of the elements in the two subsets is minimized. >>> find_min_subset_difference(4, [1, 6, 5, 11]) == 1 >>> find_min_subset_difference(5, [3, 1, 4, 2, 2]) == 0 >>> find_min_subset_difference(1, [1000]) == 1000 >>> find_min_subset_difference(2, [10, 10]) == 0 >>> find_min_subset_difference(4, [2, 4, 1, 7]) == 0 >>> find_min_subset_difference(5, [1, 1, 1, 1, 1000]) == 996","solution":"def min_subset_difference(arr): Function to calculate the minimum subset difference Args: arr: List of integers Returns: int: The minimum difference between the sums of two subsets total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j def find_min_subset_difference(N, arr): return min_subset_difference(arr)"},{"question":"def check_goal(target_miles: int, daily_miles: List[int]) -> Union[str, int]: Given a target mileage for the week and a list of daily mileage, determines if the target is met or how many more miles are needed. >>> check_goal(150, [20, 30, 25, 10, 15, 40, 60]) \\"Goal met\\" >>> check_goal(100, [10, 10, 10, 10, 10, 10, 10]) 30","solution":"def check_goal(target_miles, daily_miles): Given a target mileage for the week and a list of daily mileage, determines if the target is met or how many more miles are needed. :param target_miles: The minimum target mileage for the week (int). :param daily_miles: List of integers representing daily mileage for each day of the week. :return: \\"Goal met\\" if the weekly mileage meets or exceeds the target, otherwise the number of additional miles needed. total_miles = sum(daily_miles) if total_miles >= target_miles: return \\"Goal met\\" else: return target_miles - total_miles"},{"question":"def is_leap_year(year: int) -> bool: Determine whether a given year is a leap year. >>> is_leap_year(2020) True >>> is_leap_year(2019) False >>> is_leap_year(1900) False >>> is_leap_year(2000) True >>> is_leap_year(0) True >>> is_leap_year(-400) True >>> is_leap_year(-100) False","solution":"def is_leap_year(year): Determine whether a given year is a leap year. Args: year (int): The year to check. Returns: bool: True if the year is a leap year, False otherwise. if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return True return False"},{"question":"class SegmentTree: def __init__(self, data): Initialize the Segment Tree with the given data pass def update(self, pos, value): Update the element at index pos to the new value pass def maximum(self, left, right): Return the maximum value in the sublist from index left to index right (inclusive) pass def process_queries(N, Q, A, queries): Process a list of queries on an array A Args: N: int : size of the array Q: int : number of queries A: List[int] : the array of integers queries: List[str]: list of queries Returns: List[int]: The results for all 'q' queries pass import pytest def test_segment_tree_initialization(): data = [1, 2, 3, 4, 5] st = SegmentTree(data) assert st.maximum(0, 4) == 5 def test_segment_tree_update(): data = [1, 2, 3, 4, 5] st = SegmentTree(data) st.update(1, 6) assert st.maximum(0, 4) == 6 assert st.maximum(0, 1) == 6 assert st.maximum(2, 4) == 5 def test_segment_tree_max_query(): data = [10, 20, 30, 40, 50, 60] st = SegmentTree(data) assert st.maximum(1, 3) == 40 st.update(3, 25) assert st.maximum(1, 3) == 30 assert st.maximum(0, 5) == 60 def test_process_queries_1(): N = 5 Q = 4 A = [1, 2, 3, 4, 5] queries = [ 'q 1 3', 'u 2 6', 'q 1 5', 'q 3 3' ] result = process_queries(N, Q, A, queries) assert result == [3, 6, 3] def test_process_queries_2(): N = 6 Q = 3 A = [10, 20, 30, 40, 50, 60] queries = [ 'q 2 4', 'u 4 25', 'q 1 6' ] result = process_queries(N, Q, A, queries) assert result == [40, 60]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.data = data self.tree = [0] * (2 * self.n) self.__build() def __build(self): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.data[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, pos, value): # Update value at the leaf pos += self.n self.tree[pos] = value # Update internal nodes while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def maximum(self, left, right): res = -float('inf') left += self.n right += self.n + 1 while left < right: if left % 2 == 1: res = max(res, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 res = max(res, self.tree[right]) left //= 2 right //= 2 return res def process_queries(N, Q, A, queries): st = SegmentTree(A) result = [] for query in queries: parts = query.split() type_ = parts[0] if type_ == 'q': l = int(parts[1]) - 1 r = int(parts[2]) - 1 result.append(st.maximum(l, r)) elif type_ == 'u': index = int(parts[1]) - 1 value = int(parts[2]) st.update(index, value) return result"},{"question":"def longest_contiguous_upvotes(test_cases: List[str]) -> List[int]: Given a list of binary strings, this function returns the length of the longest contiguous subsequence of '1's (upvotes) for each string. >>> longest_contiguous_upvotes([\\"110011\\", \\"111111\\", \\"10000\\"]) [2, 6, 1] >>> longest_contiguous_upvotes([\\"00000\\"]) [0]","solution":"def longest_contiguous_upvotes(test_cases): Given a list of binary strings, this function returns the length of the longest contiguous subsequence of '1's (upvotes) for each string. :param test_cases: List of strings containing '1's and '0's :return: List of integers representing the longest contiguous upvote sequences result = [] for s in test_cases: max_count = 0 current_count = 0 for char in s: if char == '1': current_count += 1 if current_count > max_count: max_count = current_count else: current_count = 0 result.append(max_count) return result"},{"question":"def longest_substring_with_two_distinct_characters(s: str) -> int: Determine the maximum length of the substring containing at most two distinct characters. >>> longest_substring_with_two_distinct_characters(\\"abcbbbbcccbdddadacb\\") 10 >>> longest_substring_with_two_distinct_characters(\\"aaaaa\\") 5 >>> longest_substring_with_two_distinct_characters(\\"abbacccacccabba\\") 9 >>> longest_substring_with_two_distinct_characters(\\"abcdef\\") 2 >>> longest_substring_with_two_distinct_characters(\\"bbbbbbb\\") 7 >>> longest_substring_with_two_distinct_characters(\\"\\") 0 >>> longest_substring_with_two_distinct_characters(\\"c\\") 1 >>> longest_substring_with_two_distinct_characters(\\"ab\\") 2 >>> longest_substring_with_two_distinct_characters(\\"abc\\") 2 >>> longest_substring_with_two_distinct_characters(\\"abbaaacc\\") 6","solution":"def longest_substring_with_two_distinct_characters(s): from collections import defaultdict start = 0 max_length = 0 char_count = defaultdict(int) for end, char in enumerate(s): char_count[char] += 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 current_length = end - start + 1 max_length = max(max_length, current_length) return max_length"},{"question":"def is_magic_square(grid: List[List[int]]) -> str: Determines if the given grid is a magic square. >>> is_magic_square([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ]) == \\"YES\\" >>> is_magic_square([ ... [3, 7, 6], ... [8, 1, 6], ... [4, 3, 8] ... ]) == \\"NO\\" >>> is_magic_square([ ... [16, 2, 3, 13], ... [5, 11, 10, 8], ... [9, 7, 6, 12], ... [4, 14, 15, 1] ... ]) == \\"YES\\" >>> is_magic_square([[5]]) == \\"YES\\" >>> is_magic_square([ ... [1, 2], ... [3, 4] ... ]) == \\"NO\\"","solution":"def is_magic_square(grid): Determines if the given grid is a magic square. Parameters: grid (list of list of int): 2D list representing the grid. Returns: str: \\"YES\\" if the grid is a magic square, \\"NO\\" otherwise. n = len(grid) if n == 1: # A 1x1 grid is a magic square by definition return \\"YES\\" # Reference value is the sum of the first row reference_sum = sum(grid[0]) # Check sums of rows for row in grid: if sum(row) != reference_sum: return \\"NO\\" # Check sums of columns for col in range(n): if sum(grid[row][col] for row in range(n)) != reference_sum: return \\"NO\\" # Check sums of main diagonals if sum(grid[i][i] for i in range(n)) != reference_sum: return \\"NO\\" if sum(grid[i][n-i-1] for i in range(n)) != reference_sum: return \\"NO\\" return \\"YES\\""},{"question":"def find_duplicates(n: int, arr: List[int]) -> List[int]: Finds elements that appear twice in the array. Parameters: n (int): Size of the array arr (list): List of integers Returns: list: Elements that appear twice >>> find_duplicates(8, [4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates(3, [1, 1, 2]) [1] >>> find_duplicates(7, [1, 2, 3, 4, 5, 6, 7]) []","solution":"def find_duplicates(n, arr): Finds elements that appear twice in the array. Parameters: n (int): Size of the array arr (list): List of integers Returns: list: Elements that appear twice from collections import Counter # Count the frequency of each element in the array freq = Counter(arr) # Extract elements that appear twice result = [key for key, count in freq.items() if count == 2] return result"},{"question":"def visualize_truck_loading(n: int) -> str: Visualizes the loading of boxes into the truck's storage grid. Parameters: n (int): Number of boxes to load into the truck (0 ≤ n ≤ 12). Returns: str: A representation of the truck's storage grid. pass # Example usage: # >>> visualize_truck_loading(5) # XXXX # X... # .... from solution import visualize_truck_loading def test_visualize_truck_loading_zero_boxes(): expected_output = \\"....n....n....\\" assert visualize_truck_loading(0) == expected_output def test_visualize_truck_loading_five_boxes(): expected_output = \\"XXXXnX...n....\\" assert visualize_truck_loading(5) == expected_output def test_visualize_truck_loading_ten_boxes(): expected_output = \\"XXXXnXXXXnXX..\\" assert visualize_truck_loading(10) == expected_output def test_visualize_truck_loading_twelve_boxes(): expected_output = \\"XXXXnXXXXnXXXX\\" assert visualize_truck_loading(12) == expected_output def test_visualize_truck_loading_one_box(): expected_output = \\"X...n....n....\\" assert visualize_truck_loading(1) == expected_output","solution":"def visualize_truck_loading(n): Visualizes the loading of boxes into the truck's storage grid. Parameters: n (int): Number of boxes to load into the truck (0 ≤ n ≤ 12). Returns: str: A representation of the truck's storage grid. grid = [['.' for _ in range(4)] for _ in range(3)] for i in range(n): grid[i // 4][i % 4] = 'X' result = 'n'.join(''.join(row) for row in grid) return result"},{"question":"def max_treasures(n: int, m: int, grid: List[str]) -> int: Determines the maximum number of treasures in any straight line within a grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): The grid represented as a list of strings, where each character is either a '.' or 'T'. Returns: int: The maximum number of treasures in a single straight line. Examples: >>> grid = [ ... '.....', ... 'T....', ... '.TTTT', ... '..TT.' ... ] >>> max_treasures(4, 5, grid) 4 >>> grid = [ ... '.T.', ... 'TTT', ... '.T.' ... ] >>> max_treasures(3, 3, grid) 3 >>> grid = [ ... 'T.TTT', ... '..T..', ... '.T.T.', ... '..T..', ... 'T.TTT' ... ] >>> max_treasures(5, 5, grid) 3 from solution import max_treasures def test_max_treasures_case1(): grid = [ '.....', 'T....', '.TTTT', '..TT.' ] assert max_treasures(4, 5, grid) == 4 def test_max_treasures_case2(): grid = [ '.T.', 'TTT', '.T.' ] assert max_treasures(3, 3, grid) == 3 def test_max_treasures_case3(): grid = [ 'T.TTT', '..T..', '.T.T.', '..T..', 'T.TTT' ] assert max_treasures(5, 5, grid) == 3 def test_max_treasures_all_empty(): grid = [ '...', '...', '...' ] assert max_treasures(3, 3, grid) == 0 def test_max_treasures_all_treasures(): grid = [ 'TTT', 'TTT', 'TTT' ] assert max_treasures(3, 3, grid) == 3 def test_max_treasures_single_treasure(): grid = [ '.T.', '...', '...' ] assert max_treasures(3, 3, grid) == 1","solution":"def max_treasures(n, m, grid): def horizontal_max(): max_t = 0 for row in grid: current_t = 0 for cell in row: if cell == 'T': current_t += 1 max_t = max(max_t, current_t) else: current_t = 0 return max_t def vertical_max(): max_t = 0 for col in range(m): current_t = 0 for row in range(n): if grid[row][col] == 'T': current_t += 1 max_t = max(max_t, current_t) else: current_t = 0 return max_t def diag_max(): max_t = 0 # Check bottom-left to top-right diagonals for d in range(n + m - 1): current_t = 0 for i in range(max(0, d - m + 1), min(n, d + 1)): if grid[i][d - i] == 'T': current_t += 1 max_t = max(max_t, current_t) else: current_t = 0 # Check top-left to bottom-right diagonals for d in range(n + m - 1): current_t = 0 for i in range(max(0, d - m + 1), min(n, d + 1)): if grid[i][m - 1 - (d - i)] == 'T': current_t += 1 max_t = max(max_t, current_t) else: current_t = 0 return max_t return max(horizontal_max(), vertical_max(), diag_max())"},{"question":"from typing import List def tsp(distance_matrix: List[List[int]]) -> int: Calculate the minimum distance required to visit all cities exactly once and return to the starting city. >>> tsp([ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) == 80 >>> tsp([ ... [0, 5, 6], ... [5, 0, 4], ... [6, 4, 0] ... ]) == 15 >>> tsp([ ... [0, 10], ... [10, 0] ... ]) == 20 >>> tsp([ ... [0, 2, 9, 10], ... [1, 0, 6, 4], ... [15, 7, 0, 8], ... [6, 3, 12, 0] ... ]) == 21","solution":"import itertools def tsp(distance_matrix): n = len(distance_matrix) # Generating all possible permutations of cities (excluding the starting city 0) permutations = itertools.permutations(range(1, n)) min_distance = float('inf') for perm in permutations: current_distance = 0 start = 0 for city in perm: current_distance += distance_matrix[start][city] start = city # Returning to starting city current_distance += distance_matrix[start][0] min_distance = min(min_distance, current_distance) return min_distance # Example use case if __name__ == \\"__main__\\": n = int(input()) distance_matrix = [list(map(int, input().split())) for _ in range(n)] result = tsp(distance_matrix) print(result)"},{"question":"def last_non_zero_digit(m: int, k: int) -> int: Determine the last non-zero digit of m^k. Input - m: an integer (1 ≤ m ≤ 10^6) - k: an integer (0 ≤ k ≤ 10^6) Output - An integer representing the last non-zero digit of m raised to the power of k. Examples: >>> last_non_zero_digit(7, 3) 3 >>> last_non_zero_digit(531, 2) 1","solution":"def last_non_zero_digit(m, k): def last_digit_non_zero(n): while n % 10 == 0: n //= 10 return n % 10 if k == 0: return 1 result = 1 for _ in range(k): result *= m result = last_digit_non_zero(result) return result"},{"question":"from typing import List def min_steps_with_one_wall_break(n: int, m: int, grid: List[str]) -> int: You are given a grid with \`n\` rows and \`m\` columns. Each cell in the grid can either be an open space (\`.\`) or a wall (\`#\`). You start at the top-left corner of the grid (1, 1) and want to find the shortest path to the bottom-right corner of the grid (n, m) while being able to break at most one wall. Print the minimum number of steps required to reach the bottom-right corner of the grid (n, m) from the top-left corner (1, 1), breaking at most one wall if necessary. If there is no such path, return \`-1\`. :param n: int, number of rows in the grid :param m: int, number of columns in the grid :param grid: List[str], the grid with \`.\` representing open space and \`#\` representing a wall :return: int, minimum number of steps required >>> min_steps_with_one_wall_break(5, 5, [ ... \\".#.\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\"...#.\\" ... ]) 9 >>> min_steps_with_one_wall_break(2, 2, [ ... \\"\\", ... \\"\\" ... ]) -1","solution":"from collections import deque def min_steps_with_one_wall_break(n, m, grid): # Initialize the directions for moving in the grid (right, down, left, up) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # BFS queue initialized with the starting position (0, 0) queue = deque([(0, 0, 0, False)]) # (current_row, current_col, steps, wall_broken) # Visited set, storing (row, col, wall_broken) visited = set((0, 0, False)) while queue: row, col, steps, wall_broken = queue.popleft() # If we reach the bottom-right corner of the grid if row == n-1 and col == m-1: return steps + 1 # Check all 4 possible directions for dr, dc in directions: new_row, new_col = row + dr, col + dc # Ensure new position is within bounds if 0 <= new_row < n and 0 <= new_col < m: # If the new position is an open space if grid[new_row][new_col] == '.' and (new_row, new_col, wall_broken) not in visited: queue.append((new_row, new_col, steps + 1, wall_broken)) visited.add((new_row, new_col, wall_broken)) # If the new position is a wall and we have not broken a wall yet elif grid[new_row][new_col] == '#' and not wall_broken and (new_row, new_col, True) not in visited: queue.append((new_row, new_col, steps + 1, True)) visited.add((new_row, new_col, True)) # If we exhausted all possibilities and did not reach the goal, return -1 return -1"},{"question":"def generate_nth_term(n): Generate the nth term of the sequence defined as: a(1) = 1 a(2) = 2 a(n) = a(n-1) * a(n-2) for n > 2 >>> generate_nth_term(1) 1 >>> generate_nth_term(2) 2 >>> generate_nth_term(3) 2 >>> generate_nth_term(4) 4 >>> generate_nth_term(5) 8 >>> generate_nth_term(6) 32 def process_test_cases(T, test_cases): Process the test cases and print the nth term for each case. >>> process_test_cases(3, [1, 2, 3]) [1, 2, 2] >>> process_test_cases(3, [5, 6, 7]) [8, 32, 256] >>> process_test_cases(3, [2, 4, 5]) [2, 4, 8]","solution":"def generate_nth_term(n): Generate the nth term of the sequence defined as: a(1) = 1 a(2) = 2 a(n) = a(n-1) * a(n-2) for n > 2 if n == 1: return 1 elif n == 2: return 2 else: a = [0] * (n+1) a[1] = 1 a[2] = 2 for i in range(3, n+1): a[i] = a[i-1] * a[i-2] return a[n] def process_test_cases(T, test_cases): Process the test cases and print the nth term for each case. results = [] for n in test_cases: results.append(generate_nth_term(n)) return results"},{"question":"def filter_restaurants_by_rating(n, t, restaurant_data): Filters restaurants based on average rating threshold. Parameters: n (int): Number of restaurants t (int): Rating threshold restaurant_data (list): List of restaurant data with each item containing restaurant name followed by ratings Returns: list: List of restaurant names having average rating >= t, or [\\"None\\"] if no restaurant meets the threshold pass # Example unit tests def test_filter_restaurants_by_rating_example1(): n = 3 t = 4 restaurant_data = [ \\"Pizzeria 5 4 4 3 5\\", \\"BurgerKing 3 3 4\\", \\"SushiPlace 5 5 5 4 4 5\\" ] expected_output = [\\"Pizzeria\\", \\"SushiPlace\\"] assert filter_restaurants_by_rating(n, t, restaurant_data) == expected_output def test_filter_restaurants_by_rating_example2(): n = 2 t = 4 restaurant_data = [ \\"TacoBell 2 3 4\\", \\"Subway 1 2 3 4 5\\" ] expected_output = [\\"None\\"] assert filter_restaurants_by_rating(n, t, restaurant_data) == expected_output def test_no_restaurants_meet_threshold(): n = 1 t = 5 restaurant_data = [ \\"AveragePlace 1 2 3 4 2\\" ] expected_output = [\\"None\\"] assert filter_restaurants_by_rating(n, t, restaurant_data) == expected_output def test_all_restaurants_meet_threshold(): n = 2 t = 3 restaurant_data = [ \\"GoodFood 4 4 3 4\\", \\"GreatEats 5 5 4 5 3\\" ] expected_output = [\\"GoodFood\\", \\"GreatEats\\"] assert filter_restaurants_by_rating(n, t, restaurant_data) == expected_output def test_mixed_ratings(): n = 2 t = 3 restaurant_data = [ \\"MediocrePlace 3 3 3\\", \\"BadPlace 2 2 2\\" ] expected_output = [\\"MediocrePlace\\"] assert filter_restaurants_by_rating(n, t, restaurant_data) == expected_output def test_single_restaurant_multiple_ratings(): n = 1 t = 4 restaurant_data = [ \\"SoloRestaurant 4 4 4 4 4\\" ] expected_output = [\\"SoloRestaurant\\"] assert filter_restaurants_by_rating(n, t, restaurant_data) == expected_output","solution":"def filter_restaurants_by_rating(n, t, restaurant_data): Filters restaurants based on average rating threshold. Parameters: n (int): Number of restaurants t (int): Rating threshold restaurant_data (list): List of restaurant data with each item containing restaurant name followed by ratings Returns: list: List of restaurant names having average rating >= t, or [\\"None\\"] if no restaurant meets the threshold result = [] for data in restaurant_data: parts = data.split() name = parts[0] ratings = list(map(int, parts[1:])) average_rating = sum(ratings) / len(ratings) if average_rating >= t: result.append(name) return result if result else [\\"None\\"]"},{"question":"def missing_number_in_array(arr: List[int], n: int) -> int: Write a function \`missing_number_in_array(arr, n)\` that takes an array of integers \`arr\` and a single integer \`n\` as arguments. The array contains n-1 unique integers chosen from the range 1 to n. The function should return the missing integer from this range. >>> missing_number_in_array([1, 2, 3, 5], 5) 4 >>> missing_number_in_array([3, 7, 1, 2, 6, 4], 7) 5 def find_missing_numbers(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Write a function \`find_missing_numbers(test_cases)\` that takes a list of test cases, where each test case is a tuple containing an integer n and a list of n-1 integers. The function should return a list of missing integers for each test case. >>> find_missing_numbers([(5, [1, 2, 3, 5]), (7, [3, 7, 1, 2, 6, 4])]) [4, 5]","solution":"def missing_number_in_array(arr, n): Returns the missing number from the range 1 to n in the array \`arr\`. # Calculate the expected sum of numbers from 1 to n expected_sum = n * (n + 1) // 2 # Calculate the actual sum of the numbers in arr actual_sum = sum(arr) # The missing number is the difference between expected and actual sum return expected_sum - actual_sum def find_missing_numbers(test_cases): results = [] for test in test_cases: n, arr = test missing_number = missing_number_in_array(arr, n) results.append(missing_number) return results"},{"question":"from typing import List def are_anagrams(N: int, strings: List[str]) -> bool: Returns True if there are two strings in the list that are anagrams of each other, otherwise returns False. >>> are_anagrams(5, ['abc', 'bca', 'xyz', 'yxz', '123']) True >>> are_anagrams(3, ['hello', 'world', 'python']) False >>> are_anagrams(4, ['test', 'sett', 'sett', 'stet']) True >>> are_anagrams(2, ['abc', 'def']) False >>> are_anagrams(4, ['123', '321', '213', '132']) True >>> are_anagrams(3, ['a1b2c3', '3c2b1a', 'abc123']) True >>> are_anagrams(2, ['', '']) True >>> are_anagrams(3, ['short', 'longest', 'size']) False","solution":"from typing import List def are_anagrams(N: int, strings: List[str]) -> bool: Returns True if there are two strings in the list that are anagrams of each other, otherwise returns False. seen = {} for s in strings: sorted_s = ''.join(sorted(s)) if sorted_s in seen: return True seen[sorted_s] = s return False"},{"question":"def count_unique_positions(m: int, moves: str) -> int: Calculate the number of unique positions Alice visits on an infinite 2D grid. Alice starts at position (0, 0). The possible moves are 'U' (up), 'D' (down), 'L' (left), and 'R' (right). Args: m (int): The number of moves Alice will make. moves (str): A string of length \`m\` consisting of the characters 'U', 'D', 'L', 'R'. Returns: int: The number of unique positions Alice visits. Examples: >>> count_unique_positions(5, \\"UUDLR\\") 4 >>> count_unique_positions(10, \\"UUDDLLRRUD\\") 5","solution":"def count_unique_positions(m, moves): position = (0, 0) visited_positions = set() visited_positions.add(position) for move in moves: x, y = position if move == 'U': position = (x, y + 1) elif move == 'D': position = (x, y - 1) elif move == 'L': position = (x - 1, y) elif move == 'R': position = (x + 1, y) visited_positions.add(position) return len(visited_positions)"},{"question":"def generate_sequence(n: int, p: int) -> int: Generates the p-th element in sequence starting from n. Parameters: - n: starting digit (0 ≤ n ≤ 9) - p: position in the sequence (1 ≤ p ≤ 1000) Returns: - p-th element in the sequence Examples: >>> generate_sequence(2, 5) 2 >>> generate_sequence(19, 3) 1 >>> generate_sequence(5, 10) 5","solution":"def generate_sequence(n, p): Generates the p-th element in sequence starting from n. Parameters: - n: starting digit (0 ≤ n ≤ 9) - p: position in the sequence (1 ≤ p ≤ 1000) Returns: - p-th element in the sequence sequence = [n] current = n while len(sequence) < p: next_value = sum(int(digit) for digit in str(current)) sequence.append(next_value) current = next_value return sequence[p-1]"},{"question":"def is_prime(N): Determines whether a given integer N is a prime number. Returns \\"Yes\\" if N is prime, otherwise returns \\"No\\". >>> is_prime(17) \\"Yes\\" >>> is_prime(2) \\"Yes\\" >>> is_prime(1) \\"No\\"","solution":"def is_prime(N): Determines whether a given integer N is a prime number. Returns \\"Yes\\" if N is prime, otherwise returns \\"No\\". if N <= 1: return \\"No\\" if N <= 3: return \\"Yes\\" if N % 2 == 0 or N % 3 == 0: return \\"No\\" i = 5 while i * i <= N: if N % i == 0 or N % (i + 2) == 0: return \\"No\\" i += 6 return \\"Yes\\""},{"question":"def count_contiguous_segments(work_log: str) -> int: Given a work log as a string, counts the number of contiguous segments of tasks. pass def process_work_logs(test_cases: list) -> list: Processes multiple work logs and returns a list of the number of contiguous segments for each work log. pass def main(): T = int(input(\\"Enter the number of test cases: \\")) work_logs = [input().strip() for _ in range(T)] results = process_work_logs(work_logs) for result in results: print(result) if __name__ == \\"__main__\\": main() # Unit tests def test_count_contiguous_segments(): assert count_contiguous_segments(\\"AAAABBBCCDAA\\") == 5 assert count_contiguous_segments(\\"ABABABAB\\") == 8 assert count_contiguous_segments(\\"CCCCCCCCCC\\") == 1 def test_process_work_logs(): assert process_work_logs([\\"AAAABBBCCDAA\\", \\"ABABABAB\\", \\"CCCCCCCCCC\\"]) == [5, 8, 1] assert process_work_logs([\\"A\\", \\"B\\", \\"CC\\", \\"DDDD\\", \\"EEEFFFGG\\"]) == [1, 1, 1, 1, 3] assert process_work_logs([\\"\\"]) == [0] # Running the tests test_count_contiguous_segments() test_process_work_logs()","solution":"def count_contiguous_segments(work_log): Given a work log as a string, counts the number of contiguous segments of tasks. if not work_log: return 0 segments_count = 1 # There's at least one segment if the string is not empty prev_task = work_log[0] for task in work_log[1:]: if task != prev_task: segments_count += 1 prev_task = task return segments_count def process_work_logs(test_cases): Processes multiple work logs and returns a list of the number of contiguous segments for each work log. results = [] for log in test_cases: results.append(count_contiguous_segments(log)) return results def main(): T = int(input(\\"Enter the number of test cases: \\")) work_logs = [input().strip() for _ in range(T)] results = process_work_logs(work_logs) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def apply_operations(m: int, n: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Apply operations on an m x n grid where operations are described as top-left and bottom-right coordinates marking rectangles within the grid. :param m: Number of rows in the grid :param n: Number of columns in the grid :param operations: List of tuples containing the coordinates of rectangles (r1, c1, r2, c2) :return: The grid after all operations have been applied >>> apply_operations(3, 3, [(0, 0, 2, 2)]) [[1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> apply_operations(3, 3, [(0, 0, 1, 1), (1, 1, 2, 2)]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> apply_operations(3, 3, []) [[0, 0, 0], [0, 0, 0], [0, 0, 0]] >>> apply_operations(3, 3, [(0, 0, 1, 1), (1, 1, 2, 2), (0, 1, 2, 1)]) [[1, 2, 0], [1, 3, 1], [0, 2, 1]]","solution":"def apply_operations(m, n, operations): Apply operations on an m x n grid where operations are described as top-left and bottom-right coordinates marking rectangles within the grid. # Initialize the grid with zeros grid = [[0] * n for _ in range(m)] # Apply each operation for (r1, c1, r2, c2) in operations: for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): grid[r][c] += 1 return grid"},{"question":"def sum_of_unique_elements(n: int, elements: List[int]) -> int: Given a list of n integers, return the sum of all unique integers in the list. :param n: int, the number of integers in the list. :param elements: list of int, the integers in the list. :return: int, the sum of all unique integers in the list. >>> sum_of_unique_elements(5, [1, 2, 2, 3, 4]) == 10 >>> sum_of_unique_elements(3, [1, 1, 1]) == 1 >>> sum_of_unique_elements(4, [-1, -2, -3, -4]) == -10 >>> sum_of_unique_elements(6, [0, 0, 1, 2, 2, 3]) == 6 >>> sum_of_unique_elements(1, [1000]) == 1000 >>> sum_of_unique_elements(2, [999, -1000]) == -1 >>> sum_of_unique_elements(0, []) == 0","solution":"def sum_of_unique_elements(n, elements): Given a list of n integers, return the sum of all unique integers in the list. :param n: int, the number of integers in the list. :param elements: list of int, the integers in the list. :return: int, the sum of all unique integers in the list. unique_elements = set(elements) return sum(unique_elements) # Example usage: # n = 5 # elements = [1, 2, 2, 3, 4] # print(sum_of_unique_elements(n, elements)) # Output should be 10"},{"question":"from typing import List def words_from_chars(words: List[str], chars: str) -> List[str]: Returns a list of words that can be formed using the given set of characters. >>> words_from_chars([\\"apple\\"], \\"aelpp\\") [\\"apple\\"] >>> words_from_chars([\\"apple\\", \\"orange\\", \\"grape\\", \\"melon\\"], \\"aelpp\\") [\\"apple\\"] >>> words_from_chars([\\"apple\\", \\"orange\\", \\"grape\\", \\"mel\\"], \\"grpaeomel\\") [\\"grape\\", \\"mel\\"] >>> words_from_chars([\\"banana\\", \\"orange\\", \\"grape\\"], \\"xyz\\") [] >>> words_from_chars([\\"apple\\", \\"pple\\"], \\"aelpp\\") [\\"apple\\", \\"pple\\"]","solution":"from collections import Counter def can_form_word(word, chars): Check if a word can be formed using the given set of characters. word_count = Counter(word) chars_count = Counter(chars) for char in word_count: if word_count[char] > chars_count.get(char, 0): return False return True def words_from_chars(words, chars): Returns a list of words that can be formed using the given set of characters. result = [] for word in words: if can_form_word(word, chars): result.append(word) return result"},{"question":"def smallest_lexicographical_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained after exactly k operations. >>> smallest_lexicographical_string(\\"bcdea\\", 3) \\"abcde\\" >>> smallest_lexicographical_string(\\"abcde\\", 0) \\"abcde\\" >>> smallest_lexicographical_string(\\"edcba\\", 10) \\"abcde\\" >>> smallest_lexicographical_string(\\"qwerty\\", 2) \\"eqrtwy\\" >>> smallest_lexicographical_string(\\"banana\\", 1) \\"aaabnn\\" >>> smallest_lexicographical_string(\\"banana\\", 0) \\"banana\\" def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[str]: Processes multiple test cases and returns their results. >>> test_cases = [(\\"bcdea\\", 3), (\\"abcde\\", 0)] >>> process_test_cases(test_cases) ['abcde', 'abcde'] >>> test_cases = [(\\"edcba\\", 10), (\\"qwerty\\", 2)] >>> process_test_cases(test_cases) ['abcde', 'eqrtwy'] >>> test_cases = [(\\"banana\\", 1), (\\"banana\\", 0)] >>> process_test_cases(test_cases) ['aaabnn', 'banana']","solution":"def smallest_lexicographical_string(s, k): Returns the lexicographically smallest string that can be obtained after exactly k operations. if k == 0: return s return ''.join(sorted(s)) def process_test_cases(test_cases): results = [] for s, k in test_cases: results.append(smallest_lexicographical_string(s, k)) return results"},{"question":"import heapq def process_queries(n: int, queries: List[str]) -> List[Union[int, str]]: Process the given queries on a list of integers using a min-heap. Args: n (int): The number of queries. queries (List[str]): The list of queries to process. Returns: List[Union[int, str]]: The results of the 'remove_min' queries in the order they are processed. >>> process_queries(6, [\\"add 5\\", \\"add 3\\", \\"remove_min\\", \\"add 7\\", \\"remove_min\\", \\"remove_min\\"]) [3, 5, 7] >>> process_queries(4, [\\"remove_min\\", \\"add 10\\", \\"remove_min\\", \\"remove_min\\"]) [\\"None\\", 10, \\"None\\"]","solution":"import heapq def process_queries(n, queries): min_heap = [] results = [] for query in queries: if query.startswith(\\"add\\"): _, x = query.split() heapq.heappush(min_heap, int(x)) elif query == \\"remove_min\\": if min_heap: results.append(heapq.heappop(min_heap)) else: results.append(\\"None\\") return results"},{"question":"def rearrange_even_odd(n: int, arr: List[int]) -> List[int]: Rearrange the elements of the array such that all even numbers come before all odd numbers, while maintaining the relative order of the even and odd numbers in the original array. >>> rearrange_even_odd(6, [1, 2, 3, 4, 5, 6]) [2, 4, 6, 1, 3, 5] >>> rearrange_even_odd(5, [9, 8, 7, 6, 5]) [8, 6, 9, 7, 5] >>> rearrange_even_odd(3, [1, 1, 1]) [1, 1, 1]","solution":"def rearrange_even_odd(n, arr): Returns the rearranged array with all even numbers coming before odd numbers while maintaining their relative order. evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in the given string s. >>> longest_palindromic_substring(\\"babad\\") == \\"bab\\" or longest_palindromic_substring(\\"babad\\") == \\"aba\\" True >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" True >>> longest_palindromic_substring(\\"a\\") == \\"a\\" True >>> longest_palindromic_substring(\\"ac\\") == \\"a\\" or longest_palindromic_substring(\\"ac\\") == \\"c\\" True >>> longest_palindromic_substring(\\"aaaa\\") == \\"aaaa\\" True >>> longest_palindromic_substring(\\"abcdefg\\") == \\"a\\" True pass def solve(test_cases: List[str]) -> List[str]: Finds the longest palindromic substring for each test case in the given list. >>> solve([\\"babad\\", \\"cbbd\\"]) == [\\"bab\\", \\"bb\\"] or solve([\\"babad\\", \\"cbbd\\"]) == [\\"aba\\", \\"bb\\"] True >>> solve([\\"abcdefg\\"]) == [\\"a\\"] True >>> solve([\\"a\\", \\"ac\\"]) == [\\"a\\", \\"a\\"] or solve([\\"a\\", \\"ac\\"]) == [\\"a\\", \\"c\\"] True pass","solution":"def longest_palindromic_substring(s): Finds the longest palindromic substring in the given string s. def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes temp = expand_around_center(s, i, i) if len(temp) > len(longest): longest = temp # Even length palindromes temp = expand_around_center(s, i, i + 1) if len(temp) > len(longest): longest = temp return longest def solve(test_cases): results = [] for s in test_cases: results.append(longest_palindromic_substring(s)) return results"},{"question":"def sum_of_primes(n: int) -> int: Returns the sum of the first n prime numbers. >>> sum_of_primes(4) 17 >>> sum_of_primes(10) 129 >>> sum_of_primes(15) 328 >>> sum_of_primes(1) 2 >>> sum_of_primes(5) 28","solution":"def sum_of_primes(n): Returns the sum of the first n prime numbers. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True primes = [] num = 2 while len(primes) < n: if is_prime(num): primes.append(num) num += 1 return sum(primes)"},{"question":"def min_steps_to_palindrome(n: int, s: str) -> int: Calculate the minimum number of steps to convert string s into a palindrome. >>> min_steps_to_palindrome(3, 'AAB') 1 >>> min_steps_to_palindrome(4, 'ABCD') 2 >>> min_steps_to_palindrome(5, 'ABCDE') 2 # Because it only requires changing 2 characters, not 3","solution":"def min_steps_to_palindrome(n, s): Calculate the minimum number of steps to convert string s into a palindrome. steps = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: steps += 1 return steps"},{"question":"import math from typing import List def count_vowel_strings(n: int) -> int: Calculate the number of possible strings of length n that can be formed using only vowels (a, e, i, o, u) without repeating any vowels. :param n: length of the string (1 ≤ n ≤ 5) :return: number of possible strings >>> count_vowel_strings(1) 5 >>> count_vowel_strings(2) 20 >>> count_vowel_strings(3) 60 >>> count_vowel_strings(4) 120 >>> count_vowel_strings(5) 120 def test_count_vowel_strings_length_1(): assert count_vowel_strings(1) == 5 def test_count_vowel_strings_length_2(): assert count_vowel_strings(2) == 20 def test_count_vowel_strings_length_3(): assert count_vowel_strings(3) == 60 def test_count_vowel_strings_length_4(): assert count_vowel_strings(4) == 120 def test_count_vowel_strings_length_5(): assert count_vowel_strings(5) == 120 def test_invalid_n_too_small(): try: count_vowel_strings(0) except ValueError: assert True else: assert False def test_invalid_n_too_large(): try: count_vowel_strings(6) except ValueError: assert True else: assert False","solution":"import math def count_vowel_strings(n): Returns the number of strings of length n that can be formed using only vowels (a, e, i, o, u) without repeating any vowels. :param n: length of the string (1 ≤ n ≤ 5) :return: number of possible strings if not (1 <= n <= 5): raise ValueError(\\"n must be between 1 and 5\\") vowels = 5 return math.perm(vowels, n)"},{"question":"def valid_sequences(n: int) -> int: Returns the number of valid sequences of length n modulo 10^9 + 7. >>> valid_sequences(1) == 1 >>> valid_sequences(2) == 2 >>> valid_sequences(3) == 4 >>> valid_sequences(4) == 8 >>> valid_sequences(5) == 16 >>> valid_sequences(6) == 32 >>> valid_sequences(1000) == (2**999) % (10**9 + 7) MOD = 10**9 + 7","solution":"MOD = 10**9 + 7 def valid_sequences(n): Returns the number of valid sequences of length n modulo 10^9 + 7. return pow(2, n-1, MOD)"},{"question":"def smallest_square_sidelen(treasure_positions): Returns the side length of the smallest square sub-grid that can enclose all treasure locations. >>> smallest_square_sidelen([(-1, -1), (2, 2), (0, 1)]) 4 >>> smallest_square_sidelen([(-3, -3), (1, 4), (4, 1), (-1, -2)]) 8 pass def read_input(): import sys input = sys.stdin.read data = input().split() i = 0 results = [] while i < len(data): n = int(data[i]) if n == 0: break treasure_positions = [] for j in range(n): x = int(data[i + 1 + 2 * j]) y = int(data[i + 2 + 2 * j]) treasure_positions.append((x, y)) results.append(smallest_square_sidelen(treasure_positions)) i += 1 + 2 * n for result in results: print(result) def test_smallest_square_sidelen(): assert smallest_square_sidelen([(-1, -1), (2, 2), (0, 1)]) == 4 assert smallest_square_sidelen([(-3, -3), (1, 4), (4, 1), (-1, -2)]) == 8 assert smallest_square_sidelen([(0, 0)]) == 1 assert smallest_square_sidelen([(-1000, -1000), (1000, 1000)]) == 2001 assert smallest_square_sidelen([(0, 0), (0, 0), (0, 0), (0, 0)]) == 1 assert smallest_square_sidelen([(1, 2), (2, 3), (3, 4)]) == 3 from io import StringIO import sys def test_read_input(): input_data = \\"3n-1 -1n2 2n0 1n4n-3 -3n1 4n4 1n-1 -2n0n\\" sys.stdin = StringIO(input_data) read_input() sys.stdout.seek(0) assert sys.stdout.read().split() == [\\"4\\", \\"8\\"]","solution":"def smallest_square_sidelen(treasure_positions): Returns the side length of the smallest square sub-grid that can enclose all treasure locations. if not treasure_positions: return 0 # No treasures min_x = min(x for x, y in treasure_positions) max_x = max(x for x, y in treasure_positions) min_y = min(y for x, y in treasure_positions) max_y = max(y for x, y in treasure_positions) max_span = max(max_x - min_x, max_y - min_y) return (max_span + 1) def read_input(): import sys input = sys.stdin.read data = input().split() i = 0 results = [] while i < len(data): n = int(data[i]) if n == 0: break treasure_positions = [] for j in range(n): x = int(data[i + 1 + 2 * j]) y = int(data[i + 2 + 2 * j]) treasure_positions.append((x, y)) results.append(smallest_square_sidelen(treasure_positions)) i += 1 + 2 * n for result in results: print(result)"},{"question":"from collections import deque, defaultdict def find_furthest_node(n, start_node, graph): Performs BFS to find the furthest node from the start_node. max_dist = 0 furthest_node = start_node queue = deque([(start_node, 0)]) visited = set([start_node]) while queue: node, dist = queue.popleft() if dist > max_dist: max_dist = dist furthest_node = node for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return furthest_node, max_dist def bfs_to_get_distances(n, start_node, graph): BFS starting from start_node to get distances of all nodes from start_node. distances = [float('inf')] * (n + 1) queue = deque([(start_node, 0)]) distances[start_node] = 0 while queue: node, dist = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == float('inf'): distances[neighbor] = dist + 1 queue.append((neighbor, dist + 1)) return distances def find_special_junction(n, edges): if n == 2: return min(edges[0]) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) node_a, _ = find_furthest_node(n, 1, graph) node_b, _ = find_furthest_node(n, node_a, graph) distances_from_a = bfs_to_get_distances(n, node_a, graph) distances_from_b = bfs_to_get_distances(n, node_b, graph) min_max_depth = float('inf') special_node = -1 for node in range(1, n + 1): max_depth = max(distances_from_a[node], distances_from_b[node]) if max_depth < min_max_depth or (max_depth == min_max_depth and node < special_node): min_max_depth = max_depth special_node = node return special_node def hiking_adventure(input_string): Determine the special junction for the hiking adventure from the graph representation. Input: n u_1 v_1 u_2 v_2 ... u_(n-1) v_(n-1) Output: The junction whose removal minimizes the maximum depth of resulting forest. >>> hiking_adventure('7n1 2n2 3n2 4n4 5n5 6n5 7n') == 4 >>> hiking_adventure('3n1 2n2 3n') == 2 inputs = input_string.strip().split('n') n = int(inputs[0]) edges = [tuple(map(int, line.split())) for line in inputs[1:]] return find_special_junction(n, edges)","solution":"from collections import deque, defaultdict def find_furthest_node(n, start_node, graph): Performs BFS to find the furthest node from the start_node. max_dist = 0 furthest_node = start_node queue = deque([(start_node, 0)]) visited = set([start_node]) while queue: node, dist = queue.popleft() if dist > max_dist: max_dist = dist furthest_node = node for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return furthest_node, max_dist def bfs_to_get_distances(n, start_node, graph): BFS starting from start_node to get distances of all nodes from start_node. distances = [float('inf')] * (n + 1) queue = deque([(start_node, 0)]) distances[start_node] = 0 while queue: node, dist = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == float('inf'): distances[neighbor] = dist + 1 queue.append((neighbor, dist + 1)) return distances def find_special_junction(n, edges): if n == 2: return min(edges[0]) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) node_a, _ = find_furthest_node(n, 1, graph) node_b, _ = find_furthest_node(n, node_a, graph) distances_from_a = bfs_to_get_distances(n, node_a, graph) distances_from_b = bfs_to_get_distances(n, node_b, graph) min_max_depth = float('inf') special_node = -1 for node in range(1, n + 1): max_depth = max(distances_from_a[node], distances_from_b[node]) if max_depth < min_max_depth or (max_depth == min_max_depth and node < special_node): min_max_depth = max_depth special_node = node return special_node def hiking_adventure(input_string): inputs = input_string.strip().split('n') n = int(inputs[0]) edges = [tuple(map(int, line.split())) for line in inputs[1:]] return find_special_junction(n, edges)"},{"question":"def nth_highest_unique_salary(salaries: List[int], n: int) -> Union[int, str]: Returns the nth highest unique salary from a list of salaries. If there are fewer than n unique salaries, returns \\"Not possible\\". >>> nth_highest_unique_salary([120000, 85000, 120000, 90000, 100000], 2) 100000 >>> nth_highest_unique_salary([70000, 70000, 50000], 3) \\"Not possible\\"","solution":"def nth_highest_unique_salary(salaries, n): Returns the nth highest unique salary from a list of salaries. If there are fewer than n unique salaries, returns \\"Not possible\\". unique_salaries = sorted(set(salaries), reverse=True) if len(unique_salaries) >= n: return unique_salaries[n-1] else: return \\"Not possible\\""},{"question":"def longest_distinct_substring_length(s: str) -> int: Create a function that takes a string consisting of lowercase English letters and returns the length of the longest substring with all distinct characters. >>> longest_distinct_substring_length('abcabcbb') 3 >>> longest_distinct_substring_length('bbbbb') 1 >>> longest_distinct_substring_length('pwwkew') 3","solution":"def longest_distinct_substring_length(s): Returns the length of the longest substring with all distinct characters. n = len(s) max_len = 0 start = 0 char_map = {} for end in range(n): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List, Tuple class InventoryManagementSystem: def __init__(self): self.inventory = {} def add_product(self, product_name: str, quantity: int) -> None: Add a new product to the inventory with a specified quantity. If the product already exists, update its quantity by adding the new quantity to the existing quantity. if product_name in self.inventory: self.inventory[product_name] += quantity else: self.inventory[product_name] = quantity def reduce_product(self, product_name: str, quantity: int) -> None: Reduce the quantity of a specific product by a given amount. If the quantity to be reduced is greater than the available quantity, reduce the quantity to zero. if product_name in self.inventory: self.inventory[product_name] -= quantity if self.inventory[product_name] < 0: self.inventory[product_name] = 0 def query_product(self, product_name: str) -> int: Provide the quantity of a specific product in the inventory. return self.inventory.get(product_name, 0) def list_products(self) -> List[Tuple[str, int]]: List all products in the inventory sorted in lexicographical order (case-sensitive) along with their quantities. return sorted(self.inventory.items()) def process_operations(q: int, operations: List[str]) -> List[str]: Process a list of inventory management operations and return the corresponding results. >>> process_operations(7, [\\"ADD apples 100\\", \\"ADD bananas 150\\", \\"QUERY apples\\", \\"REDUCE apples 30\\", \\"QUERY apples\\", \\"ADD apples 20\\", \\"LIST\\"]) ['100', '70', 'apples 90', 'bananas 150'] >>> process_operations(3, [\\"ADD apples 100\\", \\"ADD apples 50\\", \\"QUERY apples\\"]) ['150'] >>> process_operations(3, [\\"ADD apples 100\\", \\"REDUCE apples 150\\", \\"QUERY apples\\"]) ['0'] >>> process_operations(4, [\\"ADD apples 100\\", \\"ADD bananas 150\\", \\"ADD cherries 50\\", \\"LIST\\"]) ['apples 100', 'bananas 150', 'cherries 50'] >>> process_operations(1, [\\"QUERY oranges\\"]) ['0'] >>> process_operations(9, [\\"ADD apples 100\\", \\"REDUCE apples 20\\", \\"ADD oranges 200\\", \\"ADD bananas 150\\", \\"REDUCE oranges 50\\", \\"QUERY apples\\", \\"QUERY oranges\\", \\"QUERY bananas\\", \\"LIST\\"]) ['80', '150', '150', 'apples 80', 'bananas 150', 'oranges 150']","solution":"class InventoryManagementSystem: def __init__(self): self.inventory = {} def add_product(self, product_name, quantity): if product_name in self.inventory: self.inventory[product_name] += quantity else: self.inventory[product_name] = quantity def reduce_product(self, product_name, quantity): if product_name in self.inventory: self.inventory[product_name] -= quantity if self.inventory[product_name] < 0: self.inventory[product_name] = 0 def query_product(self, product_name): return self.inventory.get(product_name, 0) def list_products(self): return sorted(self.inventory.items()) # Helper function to process operations def process_operations(q, operations): ims = InventoryManagementSystem() results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": product_name = parts[1] quantity = int(parts[2]) ims.add_product(product_name, quantity) elif command == \\"REDUCE\\": product_name = parts[1] quantity = int(parts[2]) ims.reduce_product(product_name, quantity) elif command == \\"QUERY\\": product_name = parts[1] results.append(str(ims.query_product(product_name))) elif command == \\"LIST\\": product_list = ims.list_products() for product, qty in product_list: results.append(f\\"{product} {qty}\\") return results"},{"question":"def can_form_palindrome(n: int, sequence: List[int]) -> str: Determine if it is possible to unlock the vault by performing a series of operations to make the sequence a palindrome. >>> can_form_palindrome(5, [1, 2, 3, 2, 1]) 'YES' >>> can_form_palindrome(3, [1, 2, 1]) 'YES' >>> can_form_palindrome(4, [1, 2, 3, 4]) 'NO'","solution":"def can_form_palindrome(n, sequence): Determine if it's possible to perform a series of operations to make the sequence a palindrome. # If the sequence is already a palindrome, return YES. if sequence == sequence[::-1]: return \\"YES\\" # Perform the operations until the length of the sequence gets reduced to 1. while len(sequence) > 1: # Check if sequence is already palindrome after any operations if sequence == sequence[::-1]: return \\"YES\\" i = 0 operation_possible = False # Try to merge elements and check if sequence can become palindrome while i < len(sequence) - 1: if sequence[i] == sequence[i + 1]: # Merge them and remove the elements sequence = sequence[:i] + [sequence[i] + sequence[i + 1]] + sequence[i+2:] operation_possible = True break i += 1 if not operation_possible: break return \\"NO\\""},{"question":"def longest_contiguous_segment(binary_string: str) -> int: Determines the length of the longest contiguous segment of '1's that can be created by flipping exactly one '0' to '1'. >>> longest_contiguous_segment(\\"11011001111\\") 5 >>> longest_contiguous_segment(\\"1111\\") 4 >>> longest_contiguous_segment(\\"000\\") 1 >>> longest_contiguous_segment(\\"0\\") 1 >>> longest_contiguous_segment(\\"1\\") 1 >>> longest_contiguous_segment(\\"1010101\\") 3 >>> longest_contiguous_segment(\\"0000000\\") 1 >>> longest_contiguous_segment(\\"1111111\\") 7 >>> longest_contiguous_segment(\\"1110111\\") 7 >>> longest_contiguous_segment(\\"1111111101111111\\") 16 pass","solution":"def longest_contiguous_segment(binary_string: str) -> int: n = len(binary_string) if '0' not in binary_string: return n max_length = 0 left = [0] * n right = [0] * n count = 0 for i in range(n): if binary_string[i] == '1': count += 1 else: count = 0 left[i] = count count = 0 for i in range(n-1, -1, -1): if binary_string[i] == '1': count += 1 else: count = 0 right[i] = count for i in range(n): if binary_string[i] == '0': left_segment = left[i-1] if i > 0 else 0 right_segment = right[i+1] if i < n - 1 else 0 max_length = max(max_length, left_segment + 1 + right_segment) return max_length"},{"question":"def final_radii_after_expansion(N: int, T: int, radii: List[int]) -> List[int]: Returns the final radii of circles after T time units. >>> final_radii_after_expansion(5, 3, [2, 1, 4, 3, 5]) [5, 4, 7, 6, 8] >>> final_radii_after_expansion(3, 2, [1, 1, 1]) [3, 3, 3] >>> final_radii_after_expansion(1, 10, [5]) [15] >>> final_radii_after_expansion(4, 1000000000, [1, 2, 3, 4]) [1000000001, 1000000002, 1000000003, 1000000004] >>> final_radii_after_expansion(3, 10, [1000000000, 999999999, 999999998]) [1000000010, 1000000009, 1000000008] pass","solution":"def final_radii_after_expansion(N, T, radii): Returns the final radii of circles after T time units. # Increase each circle's radius by T expanded_radii = [r + T for r in radii] return expanded_radii"},{"question":"def can_form_even_adjacent_sums(n: int, a: List[int]) -> str: Determines if there exists a permutation of the list such that the sum of every pair of adjacent integers is an even number. Parameters: n (int): The number of integers in the list a (list of int): The integers in the list Returns: str: \\"YES\\" if there exists such a permutation, otherwise \\"NO\\" Example: >>> can_form_even_adjacent_sums(4, [1, 3, 5, 7]) \\"YES\\" >>> can_form_even_adjacent_sums(3, [1, 2, 3]) \\"NO\\"","solution":"def can_form_even_adjacent_sums(n, a): Determines if there exists a permutation of the list such that the sum of every pair of adjacent integers is an even number. Parameters: n (int): The number of integers in the list a (list of int): The integers in the list Returns: str: \\"YES\\" if there exists such a permutation, otherwise \\"NO\\" odd_count = sum(1 for x in a if x % 2 != 0) even_count = n - odd_count # All numbers need to be even or all numbers need to be odd. if odd_count == n or even_count == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def distribute_tasks(n: int, m: int, a: List[int]) -> Union[List[int], str]: Distributes m tasks among n participants based on their maximum capacity to handle tasks. Returns the distribution as a list of task assignments or \\"Impossible\\" if it cannot be done. :param n: Number of participants. :param m: Number of tasks. :param a: List of maximum tasks each participant can handle. :return: Task distribution or \\"Impossible\\". def test_example_1(): assert distribute_tasks(3, 5, [2, 2, 3]) == [1, 2, 3, 1, 2] def test_example_2(): assert distribute_tasks(2, 3, [1, 1]) == \\"Impossible\\" def test_no_tasks(): assert distribute_tasks(3, 0, [1, 1, 1]) == [] def test_max_capacity_tasks(): assert distribute_tasks(3, 3, [1, 1, 1]) == [1, 2, 3] def test_exceed_total_capacity(): assert distribute_tasks(2, 4, [2, 1]) == \\"Impossible\\" def test_single_participant_fits_all_tasks(): assert distribute_tasks(1, 5, [5]) == [1, 1, 1, 1, 1]","solution":"def distribute_tasks(n, m, a): Distributes m tasks among n participants based on their maximum capacity to handle tasks. Returns the distribution as a list of task assignments or \\"Impossible\\" if it cannot be done. :param n: Number of participants. :param m: Number of tasks. :param a: List of maximum tasks each participant can handle. :return: Task distribution or \\"Impossible\\". if sum(a) < m: return \\"Impossible\\" tasks_distributed = [] participants = list(range(1, n + 1)) idx = 0 for task in range(m): while a[idx] == 0: idx = (idx + 1) % n tasks_distributed.append(participants[idx]) a[idx] -= 1 idx = (idx + 1) % n return tasks_distributed"},{"question":"def is_unique_path(test_cases): Determine if the given set of positions forms a unique path where each position is visited exactly once. Args: - test_cases (List[Dict[str, Any]]): List of test cases, each containing the number of positions and the positions themselves. Returns: - List[str]: List of results for each test case, \\"YES\\" if the positions form a unique path, \\"NO\\" otherwise. >>> test_cases = [{'N': 5, 'positions': [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]}] >>> is_unique_path(test_cases) [\\"YES\\"] >>> test_cases = [{'N': 4, 'positions': [(1, 1), (2, 2), (1, 1), (3, 3)]}] >>> is_unique_path(test_cases) [\\"NO\\"] pass def process_input(input_data): Process input data into a list of test cases. Args: - input_data (str): Raw input data as a string. Returns: - List[Dict[str, Any]]: List of processed test cases. >>> input_data = \\"1n5n1 2n2 3n3 4n4 5n5 6n\\" >>> process_input(input_data) [{'N': 5, 'positions': [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]}] pass def main(input_data): Main function to process the input data and return the results. Args: - input_data (str): Raw input data as a string. Returns: - str: Newline-separated results for each test case. >>> input_data = \\"3n5n1 2n2 3n3 4n4 5n5 6n4n1 1n2 2n1 1n3 3n6n1 0n0 1n-1 0n0 -1n1 1n-1 -1n\\" >>> main(input_data) \\"YESnNOnYES\\" pass # Unit tests def test_is_unique_path(): input_data = \\"3n5n1 2n2 3n3 4n4 5n5 6n4n1 1n2 2n1 1n3 3n6n1 0n0 1n-1 0n0 -1n1 1n-1 -1n\\" expected_output = \\"YESnNOnYES\\" assert main(input_data) == expected_output def test_no_revisit(): input_data = \\"1n5n1 1n2 2n3 3n4 4n5 5n\\" expected_output = \\"YES\\" assert main(input_data) == expected_output def test_with_revisit(): input_data = \\"1n3n0 0n1 1n0 0n\\" expected_output = \\"NO\\" assert main(input_data) == expected_output def test_large_input(): input_data = f\\"1n1000n\\" + \\"n\\".join(f\\"{i} {i}\\" for i in range(1000)) + \\"n\\" expected_output = \\"YES\\" assert main(input_data) == expected_output def test_negative_positions(): input_data = \\"1n4n-1 -1n-2 -2n-3 -3n-4 -4n\\" expected_output = \\"YES\\" assert main(input_data) == expected_output","solution":"def is_unique_path(test_cases): results = [] for case in test_cases: positions = set() unique = True for pos in case['positions']: if pos in positions: unique = False break positions.add(pos) results.append(\\"YES\\" if unique else \\"NO\\") return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) positions = [tuple(map(int, lines[i].split())) for i in range(index+1, index+1+N)] test_cases.append({'N': N, 'positions': positions}) index += N + 1 return test_cases def main(input_data): test_cases = process_input(input_data) results = is_unique_path(test_cases) return 'n'.join(results)"},{"question":"def move_elements_to_end(test_cases): Moves all occurrences of a target element in the array to the end while maintaining the relative order of the other elements. :param test_cases: List of tuples, where each tuple contains: - n: number of elements in the array - x: the integer to move to the end - arr: the list of integers :returns: List of lists, each containing the modified array for the respective test case. >>> test_cases = [(5, 3, [3, 1, 2, 3, 4]), (6, 4, [4, 4, 4, 2, 1, 3]), (4, 2, [2, 2, 2, 1])] >>> move_elements_to_end(test_cases) [[1, 2, 4, 3, 3], [2, 1, 3, 4, 4, 4], [1, 2, 2, 2]]","solution":"def move_elements_to_end(test_cases): Moves all occurrences of a target element in the array to the end while maintaining the relative order of the other elements. :param test_cases: List of tuples, where each tuple contains: - n: number of elements in the array - x: the integer to move to the end - arr: the list of integers :returns: List of lists, each containing the modified array for the respective test case. results = [] for n, x, arr in test_cases: without_x = [num for num in arr if num != x] # Keep all elements except x x_count = arr.count(x) # Count occurrences of x # Append x x_count times to the end result = without_x + [x] * x_count results.append(result) return results"},{"question":"def digit_diversity(n: int, numbers: List[int]) -> List[int]: Given a list of numbers, returns the digit diversity for each number. n: int : number of test cases numbers: list of int : list of numbers to calculate the digit diversity >>> digit_diversity(3, [524, 111222, 1000000000]) [3, 2, 2] >>> digit_diversity(2, [0, 123456789]) [1, 9]","solution":"def digit_diversity(n, numbers): Given a list of numbers, returns the digit diversity for each number. n: int : number of test cases numbers: list of int : list of numbers to calculate the digit diversity results = [] for number in numbers: unique_digits = set(str(number)) results.append(len(unique_digits)) return results"},{"question":"def currently_parked_cars(cars_entry: list, cars_exit: list) -> (int, list): Determine which cars are currently parked in the parking lot. Args: cars_entry (list): List of license plate numbers captured during entry. cars_exit (list): List of license plate numbers captured during exit. Returns: (int, list): Number of unique cars currently parked and the list of these cars in alphabetical order. >>> currently_parked_cars(['ABC123', 'DEF456', 'GHI789', 'ABC123', 'JKL101'], ['DEF456', 'ABC123', 'GHI789']) (2, ['ABC123', 'JKL101']) >>> currently_parked_cars(['XYZ789', 'ABC123', 'QRS456', 'TUV567'], ['TUV567', 'ABC123', 'XYZ789', 'QRS456']) (0, []) >>> currently_parked_cars(['LMN123', 'OPQ456', 'RST789', 'LMN123', 'UVW101', 'XYZ456'], ['XYZ456', 'UVW101', 'OPQ456', 'LMN123']) (2, ['LMN123', 'RST789']) >>> currently_parked_cars([], []) (0, []) >>> currently_parked_cars(['CAR1', 'CAR2'], []) (2, ['CAR1', 'CAR2']) >>> currently_parked_cars([], ['CAR1', 'CAR2']) (0, []) >>> currently_parked_cars(['ABC123', 'DEF456', 'ABC123', 'DEF456', 'ABC123'], ['DEF456', 'ABC123', 'DEF456']) (1, ['ABC123'])","solution":"def currently_parked_cars(cars_entry, cars_exit): Function to determine which cars are currently parked in the parking lot. Args: cars_entry (list): List of license plate numbers captured during entry. cars_exit (list): List of license plate numbers captured during exit. Returns: (int, list): Number of unique cars currently parked and the list of these cars in alphabetical order. entry_set = set(cars_entry) exit_set = set(cars_exit) # Count the occurrences entry_counts = {} exit_counts = {} for car in cars_entry: if car in entry_counts: entry_counts[car] += 1 else: entry_counts[car] = 1 for car in cars_exit: if car in exit_counts: exit_counts[car] += 1 else: exit_counts[car] = 1 currently_parked = [] for car in entry_counts: if car not in exit_counts or entry_counts[car] > exit_counts[car]: currently_parked.append(car) currently_parked.sort() return len(currently_parked), currently_parked"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: Calculates the maximum possible profit from buying and then selling one stock. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"from typing import List def max_profit(prices: List[int]) -> int: if not prices: return 0 max_profit = 0 min_price = prices[0] for price in prices[1:]: if price < min_price: min_price = price else: profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"def count_heights_less_than(heights: List[int], x: int) -> int: Returns the number of people whose height is less than x. Args: heights (list of int): A list of heights in non-decreasing order x (int): The target height Returns: int: The number of heights less than x >>> count_heights_less_than([150, 160, 165, 170, 180], 165) 2 >>> count_heights_less_than([100, 120, 150, 170, 200, 220], 180) 4 >>> count_heights_less_than([140, 150, 160, 170], 130) 0 >>> count_heights_less_than([100, 101, 102, 103, 104], 105) 5 >>> count_heights_less_than([100, 101, 102, 103, 104], 100) 0 >>> count_heights_less_than([100], 101) 1 >>> count_heights_less_than([100], 99) 0","solution":"def count_heights_less_than(heights, x): Returns the number of people whose height is less than x. Args: heights (list of int): A list of heights in non-decreasing order x (int): The target height Returns: int: The number of heights less than x left, right = 0, len(heights) while left < right: mid = (left + right) // 2 if heights[mid] < x: left = mid + 1 else: right = mid return left"},{"question":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence. Parameters: nums (List[int]): An unsorted array of integers Returns: int: Length of the longest consecutive elements sequence Examples: >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([100]) 1 >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_sequence([10, 9, 1, 2, 4, 6, 8, 3, 5, 7]) 10 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) 4 >>> longest_consecutive_sequence([-1, -2, -3, 0, 1]) 5 >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2, 5, 6, 7, 8]) 8","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence. Parameters: nums (List[int]): An unsorted array of integers Returns: int: Length of the longest consecutive elements sequence if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only check for the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def rearrange_string(s: str) -> str: Determine whether it is possible to rearrange the characters in the string such that no two adjacent characters are the same. If possible, return the rearranged string. Otherwise, return 'IMPOSSIBLE'. Parameters: s (str): The input string consisting of 'a' and 'b' characters. Returns: str: A rearranged string or 'IMPOSSIBLE'. Examples: >>> rearrange_string('aabb') in [\\"abab\\", \\"baba\\"] True >>> rearrange_string('aaaaaaaaabbbbb') 'IMPOSSIBLE' pass def solve(t: int, test_cases: List[str]) -> List[str]: Solve the problem for multiple test cases. Parameters: t (int): The number of test cases. test_cases (List[str]): List of input strings. Returns: List[str]: List of results for each test case, either a rearranged string or 'IMPOSSIBLE'. Examples: >>> solve(3, ['aabb', 'aaaaaaaaabbbbb', 'abab']) ['abab', 'IMPOSSIBLE', 'abab'] pass def test_rearrange_string_possible_cases(): assert rearrange_string('aabb') in [\\"abab\\", \\"baba\\"] assert rearrange_string('abab') in [\\"abab\\", \\"baba\\"] def test_rearrange_string_impossible_cases(): assert rearrange_string('aaaaaaaaabbbbb') == \\"IMPOSSIBLE\\" def test_single_character_cases(): assert rearrange_string('a') == 'a' assert rearrange_string('b') == 'b' def test_mixed_cases(): test_cases = ['aabb', 'aaaaaaaaabbbbb', 'abab', 'a', 'b'] results = solve(len(test_cases), test_cases) assert results[0] in [\\"abab\\", \\"baba\\"] assert results[1] == \\"IMPOSSIBLE\\" assert results[2] in [\\"abab\\", \\"baba\\"] assert results[3] == 'a' assert results[4] == 'b'","solution":"def rearrange_string(s): count_a = s.count('a') count_b = s.count('b') if abs(count_a - count_b) > 1: return \\"IMPOSSIBLE\\" # Create the result with a balance of 'a' and 'b' res = [] if count_a > count_b: res = ['a'] * count_a + ['b'] * count_b elif count_b > count_a: res = ['b'] * count_b + ['a'] * count_a else: res = ['a'] * count_a + ['b'] * count_b # Prepare the final result by interleaving result = [] for i in range(len(res) // 2): result.append(res[i]) result.append(res[i + (len(res) // 2)]) if len(res) % 2 == 1: result.append(res[len(res) // 2]) return ''.join(result) def solve(t, test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"def largest_subset_size(T, test_cases): Determine the size of the largest subset where the sum of any two integers is not divisible by K from the given list of integers. Arguments: T - Integer representing the number of test cases test_cases - List of tuples where each tuple consists of: - (N, K): A tuple with two integers where N is the number of integers and K is the divisor - A: List of N integers Returns: List of integers where each integer represents the size of the largest subset for the corresponding test case. >>> T = 2 >>> test_cases = [((4, 3), [1, 7, 2, 4]), ((5, 5), [1, 2, 3, 4, 5])] >>> largest_subset_size(T, test_cases) [3, 3]","solution":"def largest_subset_size(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] A = test_cases[i][1] # Array to store counts of remainders remainder_counts = [0] * K # Fill the frequency array with counts of respective remainders for num in A: remainder_counts[num % K] += 1 # Initialize the result count count = 0 # If there are any elements which are exactly divisible by k, we can take at most one if remainder_counts[0] > 0: count += 1 # Traverse remainder_elements from 1 to (k//2) and choose maximum count for r in range(1, (K//2) + 1): if r != K - r: count += max(remainder_counts[r], remainder_counts[K - r]) else: # If remainder half k (like 3 out of 6), we can only take one if remainder_counts[r] > 0: count += 1 results.append(count) return results # Test the function with sample input T = 2 test_cases = [ ((4, 3), [1, 7, 2, 4]), ((5, 5), [1, 2, 3, 4, 5]) ] print(largest_subset_size(T, test_cases)) # Output should be [3, 3]"},{"question":"import heapq from typing import List, Tuple def final_element_after_operations(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Perform operations on a list of non-negative integers until the length becomes 1. Each operation involves removing the two smallest numbers, and adding their sum back to the list. Args: t (int): The number of test cases. cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer n and a list of n non-negative integers. Returns: List[int]: A list containing the final element remaining in the list for each test case. Example: >>> final_element_after_operations(1, [(4, [2, 1, 3, 5])]) [11] >>> final_element_after_operations(3, [(4, [2, 1, 3, 5]), (5, [1, 1, 1, 1, 1]), (3, [0, 9, 8])]) [11, 5, 17]","solution":"import heapq def final_element_after_operations(t, cases): results = [] for i in range(t): n, nums = cases[i] heapq.heapify(nums) while len(nums) > 1: smallest1 = heapq.heappop(nums) smallest2 = heapq.heappop(nums) heapq.heappush(nums, smallest1 + smallest2) results.append(nums[0]) return results"},{"question":"def total_distance_covered(N: int, D: List[int], P: str) -> int: Calculates the total distance covered by Takahashi based on the checkpoints he has passed. :param N: Number of checkpoints :param D: List of distances of each checkpoint from city A :param P: Binary string indicating whether Takahashi passed each checkpoint :return: Total distance covered >>> total_distance_covered(5, [10, 20, 30, 40, 50], \\"11010\\") 70 >>> total_distance_covered(4, [5, 15, 25, 35], \\"1001\\") 40","solution":"def total_distance_covered(N, D, P): Calculates the total distance covered by Takahashi based on the checkpoints he has passed. :param N: Number of checkpoints :param D: List of distances of each checkpoint from city A :param P: Binary string indicating whether Takahashi passed each checkpoint :return: Total distance covered total_distance = 0 for i in range(N): if P[i] == '1': total_distance += D[i] return total_distance"},{"question":"from typing import List def harvest_rainwater(heights: List[int]) -> int: Calculate the total amount of rainwater that can be harvested after a heavy rain. Args: heights (List[int]): A list of integers representing the heights of the compartments. Returns: int: The total amount of rainwater that can be harvested. Examples: >>> harvest_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> harvest_rainwater([4, 4, 4, 4]) 0 >>> harvest_rainwater([5]) 0 >>> harvest_rainwater([5, 3]) 0 >>> harvest_rainwater([1, 2, 3, 4, 5]) 0 >>> harvest_rainwater([5, 4, 3, 2, 1]) 0 >>> harvest_rainwater([5, 1, 5]) 4 >>> harvest_rainwater([3, 0, 2, 0, 4]) 7 >>> harvest_rainwater([0] * 100000 + [1] * 100000) 0 >>> harvest_rainwater([4, 2, 0, 3, 2, 5]) 9","solution":"from typing import List def harvest_rainwater(heights: List[int]) -> int: Calculate the total amount of rainwater that can be harvested. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the water on top of each compartment for i in range(n): water += min(left_max[i], right_max[i]) - heights[i] return water"},{"question":"def is_good_sequence(n: int, sequence: List[int]) -> str: Determines if a given sequence of integers is \\"good\\". A sequence is \\"good\\" if for any non-empty sub-sequence, the sum of the sub-sequence is not divisible by 5. :param n: int - The number of elements in the sequence. :param sequence: list of int - The elements of the sequence. :return: str - \\"YES\\" if the sequence is good, otherwise \\"NO\\". >>> is_good_sequence(5, [1, 2, 3, 4, 5]) \\"NO\\" >>> is_good_sequence(4, [1, 2, 3, 7]) \\"YES\\" >>> is_good_sequence(3, [5, 10, 15]) \\"NO\\"","solution":"def is_good_sequence(n, sequence): Determines if a given sequence of integers is \\"good\\". A sequence is \\"good\\" if for any non-empty sub-sequence, the sum of the sub-sequence is not divisible by 5. :param n: int - The number of elements in the sequence. :param sequence: list of int - The elements of the sequence. :return: str - \\"YES\\" if the sequence is good, otherwise \\"NO\\". for num in sequence: if num % 5 == 0: return \\"NO\\" return \\"YES\\""},{"question":"def smallest_subarray_with_conditions(arr, x, y): Find the length of the smallest contiguous subarray such that the sum of its elements is at least x and the sum of any larger subarray starting with the same left boundary is strictly less than y. If no such subarray exists, return -1. Args: arr (List[int]): List of integers x (int): Minimum sum required y (int): Maximum sum that any larger subarray can have Returns: int: Length of the smallest subarray that meets the criteria or -1 Example Usage: >>> smallest_subarray_with_conditions([1, 2, 3, 4, 5, 6, 7, 8], 15, 20) 2 >>> smallest_subarray_with_conditions([1, 1, 1, 1, 1, 1, 1, 1], 15, 20) -1 >>> smallest_subarray_with_conditions([5], 5, 10) 1 pass # Test Cases def test_example_case(): arr = [1, 2, 3, 4, 5, 6, 7, 8] x = 15 y = 20 assert smallest_subarray_with_conditions(arr, x, y) == 2 def test_case_no_valid_subarray(): arr = [1, 1, 1, 1, 1, 1, 1, 1] x = 15 y = 20 assert smallest_subarray_with_conditions(arr, x, y) == -1 def test_case_single_element(): arr = [5] x = 5 y = 10 assert smallest_subarray_with_conditions(arr, x, y) == 1 def test_case_boundary_sums(): arr = [5, 5, 5, 5, 5] x = 10 y = 20 assert smallest_subarray_with_conditions(arr, x, y) == 2 def test_case_larger_array(): arr = [2, 1, 2, 1, 2, 1, 2, 1, 2] x = 5 y = 10 assert smallest_subarray_with_conditions(arr, x, y) == 3 def test_case_with_negative_numbers(): arr = [-1, 3, 4, -2, 1, 2, -1, 3] x = 5 y = 10 assert smallest_subarray_with_conditions(arr, x, y) == 2 def test_case_multiple_valid_subarrays(): arr = [1, 2, 3, 4, 5] x = 6 y = 12 assert smallest_subarray_with_conditions(arr, x, y) == 2","solution":"def smallest_subarray_with_conditions(arr, x, y): Find the length of the smallest contiguous subarray such that the sum of its elements is at least x and the sum of any larger subarray starting with the same left boundary is strictly less than y. If no such subarray exists, return -1. N = len(arr) min_length = float('inf') for i in range(N): current_sum = 0 for j in range(i, N): current_sum += arr[j] if current_sum >= x: if j + 1 < N and current_sum + arr[j+1] >= y: break min_length = min(min_length, j - i + 1) break return min_length if min_length != float('inf') else -1"},{"question":"def min_transformations(n: int, s1: str, s2: str) -> int: Determines the minimum number of operations required to transform s1 into s2 by changing characters in s1 to match s2. >>> min_transformations(5, 'apple', 'apply') 1 >>> min_transformations(4, 'abcd', 'efgh') 4","solution":"def min_transformations(n, s1, s2): Determines the minimum number of operations required to transform s1 into s2 by changing characters in s1 to match s2. operations = 0 for c1, c2 in zip(s1, s2): if c1 != c2: operations += 1 return operations"},{"question":"from typing import List, Tuple def optimize_shipping_rules(n: int, rules: List[Tuple[str, int, int, float]], q: int, packages: List[Tuple[str, int]]) -> List[str]: Optimize the shipping cost rules and calculate the correct shipping cost for a given package. Parameters: n (int): The number of shipping cost rules. rules (List[Tuple[str, int, int, float]]): The shipping cost rules in the format (destination, weight_low, weight_high, cost). q (int): The number of packages. packages (List[Tuple[str, int]]): The packages details in the format (destination, weight). Returns: List[str]: The calculated shipping cost for each package. Examples: >>> optimize_shipping_rules(5, [(\\"us\\", 0, 1000, 10.5), (\\"us\\", 1001, 2000, 15.5), (\\"us\\", 2001, 3000, 20.5), (\\"ca\\", 0, 500, 8.5), (\\"ca\\", 501, 1000, 12.5)], 3, [(\\"us\\", 500), (\\"us\\", 1500), (\\"ca\\", 600)]) [\\"10.50\\", \\"15.50\\", \\"12.50\\"] >>> optimize_shipping_rules(5, [(\\"us\\", 0, 1000, 10.5), (\\"us\\", 1001, 2000, 15.5), (\\"us\\", 2001, 3000, 20.5), (\\"ca\\", 0, 500, 8.5), (\\"ca\\", 501, 1000, 12.5)], 1, [(\\"us\\", 5000)]) [\\"No Shipping Rule\\"] >>> optimize_shipping_rules(6, [(\\"us\\", 0, 1000, 10.5), (\\"us\\", 1001, 2000, 15.5), (\\"us\\", 2001, 3000, 20.5), (\\"ca\\", 0, 500, 8.5), (\\"ca\\", 501, 1000, 12.5), (\\"mx\\", 0, 1500, 18.0)], 3, [(\\"us\\", 500), (\\"mx\\", 1400), (\\"ca\\", 450)]) [\\"10.50\\", \\"18.00\\", \\"8.50\\"]","solution":"def optimize_shipping_rules(n, rules, q, packages): from collections import defaultdict # Organize the rules by destination destination_rules = defaultdict(list) for rule in rules: destination, weight_low, weight_high, cost = rule destination_rules[destination].append((weight_low, weight_high, cost)) # Sort the rules by weight_low to make the search easier later for destination, rule_list in destination_rules.items(): destination_rules[destination] = sorted(rule_list, key=lambda r: r[0]) # Function to get the shipping cost for a given package def get_shipping_cost(destination, weight): if destination not in destination_rules: return \\"No Shipping Rule\\" # Look for the closest applicable rule applicable_rule = None for weight_low, weight_high, cost in destination_rules[destination]: if weight_low <= weight <= weight_high: applicable_rule = cost break elif weight < weight_low: break return f\\"{applicable_rule:.2f}\\" if applicable_rule is not None else \\"No Shipping Rule\\" # Determine shipping costs for the packages results = [] for package in packages: destination, weight = package cost = get_shipping_cost(destination, weight) results.append(cost) return results"},{"question":"def optimize_commands(commands: list[str]) -> list[str]: Optimizes the list of movement commands by merging consecutive movements in the same direction. >>> optimize_commands([\\"N10\\", \\"N20\\", \\"S5\\", \\"E15\\", \\"E5\\", \\"W10\\", \\"N10\\", \\"S10\\"]) [\\"N30\\", \\"S5\\", \\"E20\\", \\"W10\\", \\"N10\\", \\"S10\\"] >>> optimize_commands([]) [] >>> optimize_commands([\\"N10\\"]) [\\"N10\\"] >>> optimize_commands([\\"N10\\", \\"S10\\", \\"E10\\", \\"W10\\"]) [\\"N10\\", \\"S10\\", \\"E10\\", \\"W10\\"] >>> optimize_commands([\\"N1\\", \\"N2\\", \\"N3\\", \\"E4\\", \\"E5\\", \\"S6\\", \\"S7\\", \\"W8\\", \\"W9\\"]) [\\"N6\\", \\"E9\\", \\"S13\\", \\"W17\\"] # Your code here","solution":"def optimize_commands(commands): Optimizes the list of movement commands by merging consecutive movements in the same direction. Parameters: commands (list of str): List of movement commands in the format \\"DNN\\", where D is the direction (N, S, E, W) and NN is the distance. Returns: list of str: Optimized list of movement commands. if not commands: return [] optimized_commands = [] current_direction = commands[0][0] current_distance = int(commands[0][1:]) for command in commands[1:]: direction = command[0] distance = int(command[1:]) if direction == current_direction: current_distance += distance else: optimized_commands.append(f\\"{current_direction}{current_distance}\\") current_direction = direction current_distance = distance optimized_commands.append(f\\"{current_direction}{current_distance}\\") return optimized_commands"},{"question":"def calculate_yield(M, N, grid, x1, y1, x2, y2): Calculate the total yield from the specified subgrid. :param M: Number of rows in the grid :param N: Number of columns in the grid :param grid: The crop grid represented as a list of lists :param x1: Row number of the top-left corner of the subgrid (1-indexed) :param y1: Column number of the top-left corner of the subgrid (1-indexed) :param x2: Row number of the bottom-right corner of the subgrid (1-indexed) :param y2: Column number of the bottom-right corner of the subgrid (1-indexed) :return: Total yield from the specified subgrid >>> M, N = 3, 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> calculate_yield(M, N, grid, 1, 1, 2, 2) 12 >>> calculate_yield(M, N, grid, 1, 2, 3, 3) 33 >>> M, N = 2, 2 >>> grid = [ ... [0, 0], ... [0, 0] ... ] >>> calculate_yield(M, N, grid, 1, 1, 2, 2) 0 >>> M, N = 2, 2 >>> grid = [ ... [1, 2], ... [3, 4] ... ] >>> calculate_yield(M, N, grid, 1, 1, 1, 1) 1 >>> calculate_yield(M, N, grid, 1, 1, 2, 2) 10","solution":"def calculate_yield(M, N, grid, x1, y1, x2, y2): Calculate the total yield from the specified subgrid. :param M: Number of rows in the grid :param N: Number of columns in the grid :param grid: The crop grid represented as a list of lists :param x1: Row number of the top-left corner of the subgrid (1-indexed) :param y1: Column number of the top-left corner of the subgrid (1-indexed) :param x2: Row number of the bottom-right corner of the subgrid (1-indexed) :param y2: Column number of the bottom-right corner of the subgrid (1-indexed) :return: Total yield from the specified subgrid total_yield = 0 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): total_yield += grid[i][j] return total_yield"},{"question":"from collections import deque, defaultdict def max_width_binary_tree(n, edges, values): You are given a binary tree where each node contains an integer value. We define the width of a level in the tree as the number of nodes present at that level. The task is to find the maximum width among all the levels in the tree. Args: n (int): the number of nodes in the tree. edges (list): a list of tuples where each tuple contains two integers u and v, representing an edge between node u and node v. values (list): a list of integers representing the value of each node. Returns: int: the maximum width of the tree. Example: >>> max_width_binary_tree(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], [7, 2, 9, 10, 15, 11]) 3 >>> max_width_binary_tree(4, [(1, 2), (1, 3), (3, 4)], [5, 3, 8, 12]) 2 Unit Tests: >>> def test_max_width_binary_tree_example1(): ... n = 6 ... edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] ... values = [7, 2, 9, 10, 15, 11] ... assert max_width_binary_tree(n, edges, values) == 3 ... >>> def test_max_width_binary_tree_example2(): ... n = 4 ... edges = [(1, 2), (1, 3), (3, 4)] ... values = [5, 3, 8, 12] ... assert max_width_binary_tree(n, edges, values) == 2 ... >>> def test_max_width_binary_tree_single_node(): ... n = 1 ... edges = [] ... values = [1] ... assert max_width_binary_tree(n, edges, values) == 1 ... >>> def test_max_width_binary_tree_two_levels(): ... n = 3 ... edges = [(1, 2), (1, 3)] ... values = [1, 2, 3] ... assert max_width_binary_tree(n, edges, values) == 2 ... >>> def test_max_width_binary_tree_unbalanced(): ... n = 4 ... edges = [(1, 2), (2, 3), (3, 4)] ... values = [1, 2, 3, 4] ... assert max_width_binary_tree(n, edges, values) == 1 ... >>> def test_max_width_binary_tree_large(): ... n = 7 ... edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] ... values = [1, 2, 3, 4, 5, 6, 7] ... assert max_width_binary_tree(n, edges, values) == 4 ...","solution":"from collections import deque, defaultdict def max_width_binary_tree(n, edges, values): if n == 1: return 1 # Construct the adjacency list from the edges adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # Perform BFS to determine the width of each level max_width = 0 queue = deque([1]) # Start BFS traversal from the root node (node 1) visited = set() visited.add(1) while queue: level_size = len(queue) max_width = max(max_width, level_size) for _ in range(level_size): node = queue.popleft() for neighbor in adj[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return max_width # Example usage n = 6 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] values = [7, 2, 9, 10, 15, 11] print(max_width_binary_tree(n, edges, values)) # Should output 3"},{"question":"def sum_of_integers_divisible_by_3(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the sum of all the integers between (and including) a and b that are divisible by 3. >>> sum_of_integers_divisible_by_3(2, [(1, 10), (-5, 4)]) [18, 0] >>> sum_of_integers_divisible_by_3(1, [(1, 2)]) [0]","solution":"def sum_of_integers_divisible_by_3(t, test_cases): results = [] for case in test_cases: a, b = case sum_divisible_by_3 = sum([x for x in range(a, b + 1) if x % 3 == 0]) results.append(sum_divisible_by_3) return results"},{"question":"def binary_tree_traversals(n, arr): Perform pre-order, in-order, and post-order traversals on a binary tree given as an array. >>> binary_tree_traversals(7, [1, 2, 3, 4, 5, 6, 7]) ([1, 2, 4, 5, 3, 6, 7], [4, 2, 5, 1, 6, 3, 7], [4, 5, 2, 6, 7, 3, 1]) >>> binary_tree_traversals(1, [1]) ([1], [1], [1]) >>> binary_tree_traversals(2, [1, 2]) ([1, 2], [2, 1], [2, 1]) >>> binary_tree_traversals(3, [1, 2, 3]) ([1, 2, 3], [2, 1, 3], [2, 3, 1]) >>> binary_tree_traversals(6, [1, 2, 3, 4, 5, 6]) ([1, 2, 4, 5, 3, 6], [4, 2, 5, 1, 6, 3], [4, 5, 2, 6, 3, 1])","solution":"def pre_order_traversal(arr, index=0): if index >= len(arr): return [] result = [arr[index]] result += pre_order_traversal(arr, 2 * index + 1) result += pre_order_traversal(arr, 2 * index + 2) return result def in_order_traversal(arr, index=0): if index >= len(arr): return [] result = [] result += in_order_traversal(arr, 2 * index + 1) result += [arr[index]] result += in_order_traversal(arr, 2 * index + 2) return result def post_order_traversal(arr, index=0): if index >= len(arr): return [] result = [] result += post_order_traversal(arr, 2 * index + 1) result += post_order_traversal(arr, 2 * index + 2) result += [arr[index]] return result def binary_tree_traversals(n, arr): pre_order = pre_order_traversal(arr) in_order = in_order_traversal(arr) post_order = post_order_traversal(arr) return pre_order, in_order, post_order"},{"question":"def max_difference(test_cases): Given a list of integers, returns the maximum difference between any two integers in the list for each test case. Parameters: test_cases (list of lists of int): A list where each element is a list containing integers. Returns: list of int: A list containing the maximum difference for each test case. Examples: >>> max_difference([[1, 5, 3, 19, 18, 25], [30, 5, 20, 9]]) [24, 25] >>> max_difference([[-10, -5, 0, 5, 10], [1, 2, 3, 4, 5, 6]]) [20, 5] >>> max_difference([[100, 100], [-100, 100], [-5, -5, -5, -5]]) [0, 200, 0] def parse_input(input_string): Parses the input string and returns the number of test cases and the lists of integers. Parameters: input_string (str): The input string containing the number of test cases and subsequent integer lists. Returns: tuple: A tuple containing the number of test cases (int) and a list of lists of integers. Examples: >>> parse_input(\\"2n1 5 3 19 18 25n30 5 20 9\\") (2, [[1, 5, 3, 19, 18, 25], [30, 5, 20, 9]]) def format_output(results): Formats the results into the required output format. Parameters: results (list of int): A list containing the maximum differences for each test case. Returns: str: A formatted string of results. Examples: >>> format_output([24, 25]) '24n25' >>> format_output([20, 5]) '20n5' >>> format_output([0, 200, 0]) '0n200n0'","solution":"def max_difference(test_cases): Given a list of integers, returns the maximum difference between any two integers in the list for each test case. Parameters: test_cases (list of lists of int): A list where each element is a list containing integers. Returns: list of int: A list containing the maximum difference for each test case. results = [] for case in test_cases: min_val = min(case) max_val = max(case) results.append(max_val - min_val) return results def parse_input(input_string): Parses the input string and returns the number of test cases and the lists of integers. Parameters: input_string (str): The input string containing the number of test cases and subsequent integer lists. Returns: tuple: A tuple containing the number of test cases (int) and a list of lists of integers. lines = input_string.strip().split('n') t = int(lines[0]) test_cases = [list(map(int, line.split())) for line in lines[1:t+1]] return t, test_cases def format_output(results): Formats the results into the required output format. Parameters: results (list of int): A list containing the maximum differences for each test case. Returns: str: A formatted string of results. return \\"n\\".join(map(str, results))"},{"question":"from typing import List def min_transactions(transactions: List[int]) -> int: Calculate the minimum number of transactions left after repeatedly applying the cancellation rule. A list of integer transactions is provided. Each positive transaction is a credit and each negative transaction is a debit. If the sum of any consecutive transactions is zero, those transactions cancel each other out and should be removed. The function returns the minimum number of transactions left after all possible cancellations. >>> min_transactions([1, 2, -3, 3, -1]) 2 >>> min_transactions([3, -3, 4, -4]) 0 >>> min_transactions([1, -1, 2, -2, 3, -3]) 0 >>> min_transactions([1, 2, 3, -1, -2, -3]) 0 >>> min_transactions([1, 2, 3, -3, -2, -1, 4, -4]) 0 # Your code goes here","solution":"def min_transactions(transactions): from collections import defaultdict # Stack to hold running sums stack = [] sum_map = defaultdict(int) current_sum = 0 for transaction in transactions: current_sum += transaction if current_sum == 0: # Found a zero sum from the beginning stack.clear() sum_map.clear() elif current_sum in sum_map: # Found a zero sum subarray pos = sum_map[current_sum] del stack[pos:] else: sum_map[current_sum] = len(stack) stack.append(transaction) return len(stack)"},{"question":"def max_unique_books(n: int, sales_data: List[List[int]]) -> int: Given sales data for n days, determine the maximum number of unique book sales on a single day. Parameters: n : int : the number of days sales_data : list of lists of int : the sales data, where the first number of each sublist is the number of sales for that day and the following numbers are book identifiers. Returns: int: Maximum number of unique books sold on any single day. Example: >>> max_unique_books(3, [[5, 1, 2, 3, 3, 4], [6, 1, 1, 2, 2, 3, 3], [4, 4, 4, 4, 5]]) 4 >>> max_unique_books(2, [[3, 10, 20, 10], [7, 7, 7, 8, 9, 7, 10, 8]]) 4","solution":"def max_unique_books(n, sales_data): Given sales data for n days, determine the maximum number of unique book sales on a single day. Parameters: n : int : the number of days sales_data : list of lists of int : the sales data, where the first number of each sublist is the number of sales for that day and the following numbers are book identifiers. Returns: int: Maximum number of unique books sold on any single day. max_unique = 0 for day_sales in sales_data: # Converting sales data of the day (skipping the first element) to a set for uniqueness unique_books = set(day_sales[1:]) max_unique = max(max_unique, len(unique_books)) return max_unique # Example usage: # n = 3 # sales_data = [[5, 1, 2, 3, 3, 4], [6, 1, 1, 2, 2, 3, 3], [4, 4, 4, 4, 5]] # print(max_unique_books(n, sales_data)) # Output should be 4"},{"question":"def count_distinct_patterns(n: int) -> int: Returns the number of distinct binary strings of length n where no two consecutive '1's appear. >>> count_distinct_patterns(1) 2 >>> count_distinct_patterns(2) 3 >>> count_distinct_patterns(3) 5 >>> count_distinct_patterns(4) 8","solution":"def count_distinct_patterns(n): Returns the number of distinct binary strings of length n where no two consecutive '1's appear. if n == 1: return 2 # '0', '1' elif n == 2: return 3 # '00', '01', '10' # Create a memoization table to avoid recomputation dp = [0] * (n + 1) dp[1] = 2 dp[2] = 3 for i in range(3, n + 1): dp[i] = dp[i-1] + dp[i-2] return dp[n]"},{"question":"def min_edit_distance(s: str, t: str) -> int: Computes the minimum number of operations required to convert source string s into target string t. The operations are insert, delete, and replace a character. >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> min_edit_distance(\\"abc\\", \\"abc\\") 0 >>> min_edit_distance(\\"\\", \\"abc\\") 3 >>> min_edit_distance(\\"abc\\", \\"\\") 3 >>> min_edit_distance(\\"abc\\", \\"xyz\\") 3 >>> min_edit_distance(\\"a\\", \\"aaaa\\") 3 >>> min_edit_distance(\\"aaaa\\", \\"a\\") 3 >>> min_edit_distance(\\"abcdef\\", \\"azced\\") 3 pass","solution":"def min_edit_distance(s: str, t: str) -> int: Computes the minimum number of operations required to convert source string s into target string t. The operations are insert, delete, and replace a character. m, n = len(s), len(t) # Create a DP table where dp[i][j] represents the edit distance between # s[0...i-1] and t[0...j-1] dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for the base cases for i in range(m + 1): dp[i][0] = i # Cost of deleting all characters from s to match an empty t for j in range(n + 1): dp[0][j] = j # Cost of inserting all characters of t to match an empty s # Fill dp table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: # If characters match, no new operation is needed dp[i][j] = dp[i - 1][j - 1] else: # Compute costs of insert, delete, and replace insert_cost = dp[i][j - 1] + 1 delete_cost = dp[i - 1][j] + 1 replace_cost = dp[i - 1][j - 1] + 1 dp[i][j] = min(insert_cost, delete_cost, replace_cost) return dp[m][n]"},{"question":"def longest_consecutive_sequence(n: int, plants: List[int]) -> Tuple[int, int]: Determine the length and starting index of the longest consecutive sequence of the same type of plant. >>> longest_consecutive_sequence(7, [3, 3, 3, 5, 5, 5, 5]) (4, 4) >>> longest_consecutive_sequence(5, [2, 2, 1, 1, 1]) (3, 3)","solution":"def longest_consecutive_sequence(n, plants): max_length = 1 max_index = 0 current_length = 1 for i in range(1, n): if plants[i] == plants[i - 1]: current_length += 1 else: current_length = 1 if current_length > max_length: max_length = current_length max_index = i - current_length + 1 return max_length, max_index + 1"},{"question":"def reorder_stones(n: int, k: int, power_values: List[int]) -> Tuple[str, List[int]]: Determines if the stones can be reordered such that the difference between any two consecutive stones' power values does not exceed k. :param n: Number of stones. :param k: Maximum allowed difference in power values. :param power_values: List of integers representing the power values of the stones. :return: Tuple containing a string 'YES' or 'NO' and a list of reordered power values or an empty list. >>> reorder_stones(5, 3, [8, 1, 5, 4, 10]) ('YES', [1, 4, 5, 8, 10]) >>> reorder_stones(4, 7, [15, 30, 8, 24]) ('NO', [])","solution":"def reorder_stones(n, k, power_values): Determines if the stones can be reordered such that the difference between any two consecutive stones' power values does not exceed k. :param n: Number of stones. :param k: Maximum allowed difference in power values. :param power_values: List of integers representing the power values of the stones. :return: Tuple containing a string 'YES' or 'NO' and a list of reordered power values or an empty list. power_values.sort() for i in range(n - 1): if abs(power_values[i+1] - power_values[i]) > k: return \\"NO\\", [] return \\"YES\\", power_values"},{"question":"def find_single_number(nums: List[int]) -> int: Returns the integer that appears only once in the list of integers where each integer appears exactly twice, except for one integer that appears exactly once. >>> find_single_number([2, 2, 3, 4, 4, 5, 5]) 3 >>> find_single_number([10, 10, -1, -1, 12, 13, 13]) 12 pass def parse_input(s: str) -> List[int]: Parses the input string into a list of integers. >>> parse_input(\\"2 2 3 4 4 5 5\\") [2, 2, 3, 4, 4, 5, 5] >>> parse_input(\\"10 10 -1 -1 12 13 13\\") [10, 10, -1, -1, 12, 13, 13] pass","solution":"def find_single_number(nums): Returns the integer that appears only once in the list of integers where each integer appears exactly twice, except for one integer that appears exactly once. result = 0 for num in nums: result ^= num return result def parse_input(s): Parses the input string into a list of integers. return list(map(int, s.split()))"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: Determine the area of the largest rectangle composed entirely of 1s in a given matrix of tables. >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 6 >>> maximalRectangle([ ... [0, 1, 1, 0], ... [0, 1, 1, 1], ... [1, 1, 1, 1] ... ]) 6 >>> maximalRectangle([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> maximalRectangle([]) 0 >>> maximalRectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> maximalRectangle([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9 >>> maximalRectangle([ ... [1], ... [0], ... [1] ... ]) 1 >>> maximalRectangle([[1, 0, 1, 1]]) 2","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) max_area = 0 heights = [0] * (m + 1) for row in matrix: for i in range(m): if row[i] == 1: heights[i] += 1 else: heights[i] = 0 stack = [-1] for i in range(m + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def max_treasure(N: int, T: List[int]) -> int: Determine the maximum amount of treasure the thief can steal without triggering the security alarms. >>> max_treasure(4, [5, 3, 4, 11]) 16 >>> max_treasure(3, [2, 7, 9]) 11 >>> max_treasure(2, [1, 2]) 2 >>> max_treasure(1, [10]) 10","solution":"def max_treasure(N, T): if N == 0: return 0 if N == 1: return T[0] dp = [0] * N dp[0] = T[0] dp[1] = max(T[0], T[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + T[i]) return dp[-1]"},{"question":"def kth_largest_element(lst: List[int], k: int) -> int: Returns the k-th largest element in the list. >>> kth_largest_element([3, 2, 1, 5, 4], 2) 4 >>> kth_largest_element([2, 3, 1, 4, 4, 5], 3) 4 >>> kth_largest_element([-1, -3, -2, -5, -4], 1) -1 >>> kth_largest_element([7, 6, 5, 4, 3], 5) 3 >>> kth_largest_element([10, 8, 11, 5, 3], 1) 11 >>> kth_largest_element([2, 2, 2, 2, 2], 3) 2 >>> kth_largest_element([100], 1) 100 >>> kth_largest_element([-10, 13, 15, -9, 12, 0], 4) 0","solution":"def kth_largest_element(lst, k): Returns the k-th largest element in the list. Parameters: lst (list): A list of integers. k (int): The position of the largest element to find. Returns: int: The k-th largest element in the list. # Sort the list in descending order lst_sorted = sorted(lst, reverse=True) # Return the k-th largest element return lst_sorted[k-1]"},{"question":"def determine_winner(num_cases: int, cases: list[tuple[int, int]]) -> list[str]: Determine the winner based on their scores. If Arjun scores higher than Veer, Arjun is considered the winner. If Veer scores higher than Arjun, Veer is the winner. If their scores are equal, the result is a tie. >>> determine_winner(3, [(450, 480), (320, 320), (375, 400)]) ['Veer', 'Tie', 'Veer'] >>> determine_winner(2, [(400, 400), (350, 300)]) ['Tie', 'Arjun']","solution":"def determine_winner(num_cases, cases): results = [] for case in cases: A, B = case if A > B: results.append(\\"Arjun\\") elif B > A: results.append(\\"Veer\\") else: results.append(\\"Tie\\") return results # Example usage: T = 3 cases = [(450, 480), (320, 320), (375, 400)] print(determine_winner(T, cases)) # Output: ['Veer', 'Tie', 'Veer']"},{"question":"from typing import List def minimum_cost_path(n: int, m: int, grid: List[List[int]]) -> int: Returns the minimum cost to travel from the top-left corner to the bottom-right corner of the grid. >>> minimum_cost_path(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> minimum_cost_path(2, 2, [ ... [1, 2], ... [1, 1] ... ]) == 3 def test_example_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert minimum_cost_path(3, 3, grid) == 7 def test_example_2(): grid = [ [1, 2], [1, 1] ] assert minimum_cost_path(2, 2, grid) == 3 def test_single_cell(): grid = [[5]] assert minimum_cost_path(1, 1, grid) == 5 def test_large_costs(): grid = [ [1000, 1000], [1000, 1000] ] assert minimum_cost_path(2, 2, grid) == 3000 def test_another_example(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert minimum_cost_path(3, 3, grid) == 21","solution":"import heapq def minimum_cost_path(n, m, grid): Returns the minimum cost to travel from the top-left corner to the bottom-right corner of the grid. directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] costs = [[float('inf')] * m for _ in range(n)] costs[0][0] = grid[0][0] pq = [(grid[0][0], 0, 0)] while pq: current_cost, x, y = heapq.heappop(pq) if x == n - 1 and y == m - 1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: next_cost = current_cost + grid[nx][ny] if next_cost < costs[nx][ny]: costs[nx][ny] = next_cost heapq.heappush(pq, (next_cost, nx, ny)) return costs[n-1][m-1]"},{"question":"from typing import List, Union def min_days_to_gather_fruits(n: int, k: int, orchards: List[int]) -> Union[int, str]: This function returns the minimum number of days required to gather exactly k fruits each day from any single orchard or \\"Impossible\\" if it is not possible. Parameters: n (int): The number of orchards. k (int): The number of required fruits to collect from any orchard each day. orchards (list): A list of integers where the i-th integer represents the number of fruits in the i-th orchard. Returns: int or str: The minimum number of days required or \\"Impossible\\" if not possible. >>> min_days_to_gather_fruits(3, 5, [4, 10, 7]) \\"Impossible\\" >>> min_days_to_gather_fruits(2, 8, [5, 3]) \\"Impossible\\" >>> min_days_to_gather_fruits(4, 10, [10, 10, 10, 10]) 4 >>> min_days_to_gather_fruits(5, 9, [18, 27, 36, 45, 54]) 20 >>> min_days_to_gather_fruits(5, 7, [7, 14, 21, 28, 35]) 15","solution":"def min_days_to_gather_fruits(n, k, orchards): This function returns the minimum number of days required to gather exactly k fruits each day from any single orchard or \\"Impossible\\" if it is not possible. Parameters: n (int): The number of orchards. k (int): The number of required fruits to collect from any orchard each day. orchards (list): A list of integers where the i-th integer represents the number of fruits in the i-th orchard. Returns: int or str: The minimum number of days required or \\"Impossible\\" if not possible. # Calculate the total number of days for each orchard total_days = 0 for fruits in orchards: if fruits < k: return \\"Impossible\\" total_days += fruits // k return total_days # Example usage print(min_days_to_gather_fruits(3, 5, [4, 10, 7])) # Output should be \\"Impossible\\" print(min_days_to_gather_fruits(2, 8, [5, 3])) # Output should be \\"Impossible\\" print(min_days_to_gather_fruits(4, 10, [10, 10, 10, 10])) # Output should be 4"},{"question":"def search_books(books: List[Tuple[str, str, int]], term: str) -> List[Tuple[str, str, int]]: Searches for books based on a search term. The search term can match any part of the title or author's name, case-insensitively. The result is a list of books sorted by year of publication in ascending order. Args: books: A list of tuples - (title: str, author: str, year: int) term: Search term (str) Returns: A list of books that match the search term, sorted by year of publication in ascending order. >>> books = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960), (\\"1984\\", \\"George Orwell\\", 1949), (\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951), (\\"Great Expectations\\", \\"Charles Dickens\\", 1861) ] >>> search_books(books, \\"great\\") [(\\"Great Expectations\\", \\"Charles Dickens\\", 1861), (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925)]","solution":"def search_books(books, term): Searches for books based on a search term. The search term can match any part of the title or author's name, case-insensitively. The result is a list of books sorted by year of publication in ascending order. Args: books: A list of tuples - (title: str, author: str, year: int) term: Search term (str) Returns: A list of books that match the search term, sorted by year of publication in ascending order. term = term.lower() matching_books = [ book for book in books if term in book[0].lower() or term in book[1].lower() ] return sorted(matching_books, key=lambda book: book[2]) # Example usage: books = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925), (\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960), (\\"1984\\", \\"George Orwell\\", 1949), (\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", 1951), (\\"Great Expectations\\", \\"Charles Dickens\\", 1861) ] term = \\"great\\" print(search_books(books, term)) # Expected output: # [ # (\\"Great Expectations\\", \\"Charles Dickens\\", 1861), # (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925) # ]"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Find the largest rectangular area possible in a histogram represented by heights. >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([2, 1]) 2 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 4]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([2, 1, 2]) 3 def process_input(input_str: str) -> int: Process input to find the largest rectangle area. >>> process_input(\\"7n2 1 5 6 2 3 4\\") 10 >>> process_input(\\"2n2 4\\") 4 >>> process_input(\\"4n1 2 3 4\\") 6 >>> process_input(\\"6n2 1 2 3 4 1\\") 6 >>> process_input(\\"1n5\\") 5 >>> process_input(\\"3n1 1 1\\") 3 >>> process_input(\\"5n0 2 0 2 1\\") 2","solution":"def largest_rectangle_area(heights): Find the largest rectangular area possible in a histogram represented by heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def process_input(input_str): input_lines = input_str.strip().split('n') N = int(input_lines[0].strip()) heights = list(map(int, input_lines[1].strip().split())) return largest_rectangle_area(heights)"},{"question":"def rotate_array_right(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Parameters: arr (list): List of integers to be rotated. k (int): Number of steps to rotate the list. Returns: list: Rotated list of integers. >>> rotate_array_right([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array_right([1, 2, 3, 4], 0) [1, 2, 3, 4] >>> rotate_array_right([1, 2, 3, 4], 1) [4, 1, 2, 3] >>> rotate_array_right([1, 2, 3, 4], 4) [1, 2, 3, 4] >>> rotate_array_right([1, 2, 3, 4], 6) [3, 4, 1, 2] >>> arr = list(range(1000)) >>> rotate_array_right(arr, 500) == arr[500:] + arr[:500] True # Your code here","solution":"def rotate_array_right(arr, k): Rotates the array to the right by k steps. Parameters: arr (list): List of integers to be rotated. k (int): Number of steps to rotate the list. Returns: list: Rotated list of integers. n = len(arr) k = k % n # In case k is greater than the size of the array return arr[-k:] + arr[:-k]"},{"question":"def count_networks(grid): Count the number of unique networks of connected computers in the grid. >>> count_networks([\\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\"]) 3 >>> count_networks([\\"111\\", \\"010\\", \\"111\\"]) 1","solution":"def dfs(grid, i, j, visited): Depth-first search to mark all connected '1's as visited. n, m = len(grid), len(grid[0]) stack = [(i, j)] while stack: x, y = stack.pop() if 0 <= x < n and 0 <= y < m and grid[x][y] == '1' and not visited[x][y]: visited[x][y] = True # Add all adjacent cells (up, down, left, right) stack.append((x-1, y)) stack.append((x+1, y)) stack.append((x, y-1)) stack.append((x, y+1)) def count_networks(grid): Count the number of unique networks of connected computers. if not grid: return 0 n, m = len(grid), len(grid[0]) visited = [[False for _ in range(m)] for _ in range(n)] network_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '1' and not visited[i][j]: dfs(grid, i, j, visited) network_count += 1 return network_count"},{"question":"from datetime import datetime, timedelta from typing import List, Tuple def compute_time_difference(start: str, end: str) -> timedelta: start_time = datetime.strptime(start, \\"%H:%M\\") end_time = datetime.strptime(end, \\"%H:%M\\") if end_time < start_time: end_time += timedelta(days=1) return end_time - start_time def format_time_difference(diff: timedelta) -> str: hours, remainder = divmod(diff.seconds, 3600) minutes = remainder // 60 return f\\"{hours:02}:{minutes:02}\\" def calc_travel_and_waiting_times(schedule: List[Tuple[str, str]]) -> Tuple[str, str]: total_travel_time = timedelta(0) total_waiting_time = timedelta(0) n = len(schedule) for i in range(n): start_time, end_time = schedule[i] total_travel_time += compute_time_difference(start_time, end_time) if i > 0: _, prev_end_time = schedule[i-1] total_waiting_time += compute_time_difference(prev_end_time, start_time) return format_time_difference(total_travel_time), format_time_difference(total_waiting_time) def train_schedule(T: int, test_cases: List[Tuple[int, List[Tuple[str, str]]]]) -> List[str]: Computes the total travel time and waiting time for Bob's train journeys. >>> train_schedule(2, [(3, [(\\"09:00\\", \\"11:00\\"), (\\"12:00\\", \\"14:00\\"), (\\"15:00\\", \\"17:00\\")]), (2, [(\\"08:30\\", \\"09:45\\"), (\\"10:15\\", \\"12:30\\")])]) [\\"06:00\\", \\"02:00\\", \\"03:30\\", \\"01:00\\"] >>> train_schedule(1, [(2, [(\\"23:00\\", \\"01:00\\"), (\\"02:00\\", \\"03:00\\")])]) [\\"03:00\\", \\"01:00\\"] >>> train_schedule(1, [(3, [(\\"09:00\\", \\"11:00\\"), (\\"11:00\\", \\"13:00\\"), (\\"13:00\\", \\"15:00\\")])]) [\\"06:00\\", \\"00:00\\"]","solution":"from datetime import datetime, timedelta def compute_time_difference(start, end): start_time = datetime.strptime(start, \\"%H:%M\\") end_time = datetime.strptime(end, \\"%H:%M\\") if end_time < start_time: end_time += timedelta(days=1) return end_time - start_time def format_time_difference(diff): hours, remainder = divmod(diff.seconds, 3600) minutes = remainder // 60 return f\\"{hours:02}:{minutes:02}\\" def calc_travel_and_waiting_times(schedule): total_travel_time = timedelta(0) total_waiting_time = timedelta(0) n = len(schedule) for i in range(n): start_time, end_time = schedule[i] total_travel_time += compute_time_difference(start_time, end_time) if i > 0: _, prev_end_time = schedule[i-1] total_waiting_time += compute_time_difference(prev_end_time, start_time) return format_time_difference(total_travel_time), format_time_difference(total_waiting_time) def train_schedule(T, test_cases): results = [] for i in range(T): N, schedule = test_cases[i] travel_time, waiting_time = calc_travel_and_waiting_times(schedule) results.append(travel_time) results.append(waiting_time) return results"},{"question":"def min_sum_path(matrix: List[List[int]]) -> int: Returns the sum of the numbers along the path that costs the least to traverse from the top-left corner (0, 0) to the bottom-right corner (M-1, N-1). Args: matrix: List[List[int]] - A 2D list containing non-negative integers. Returns: int - The minimum sum along the path. >>> min_sum_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_sum_path([[1, 2, 3], [4, 5, 6]]) 12 >>> min_sum_path([[0, 0, 0], [0, 0, 0]]) 0 >>> min_sum_path([[5]]) 5 >>> min_sum_path([[1, 2], [1, 1]]) 3 >>> min_sum_path([[10]]) 10 >>> min_sum_path([[2, 2], [2, 2]]) 6","solution":"def min_sum_path(matrix): Returns the sum of the numbers along the path that costs the least to traverse from the top-left corner (0, 0) to the bottom-right corner (M-1, N-1). Args: matrix: List[List[int]] - A 2D list containing non-negative integers. Returns: int - The minimum sum along the path. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Calculate the minimum sum for each cell for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1] # Helper function to parse the input and call min_sum_path def solve(): import sys input = sys.stdin.read data = input().split() M, N = int(data[0]), int(data[1]) matrix = [] idx = 2 for i in range(M): row = list(map(int, data[idx:idx+N])) idx += N matrix.append(row) print(min_sum_path(matrix))"},{"question":"from typing import List, Tuple from collections import deque def tree_diameter(n: int, connections: List[Tuple[int, int]]) -> int: Calculate the diameter of a tree given the number of nodes and a list of connections. >>> tree_diameter(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 3 >>> tree_diameter(3, [(1, 2), (2, 3)]) 2 pass","solution":"from collections import deque def tree_diameter(n, connections): if n == 1: return 0 # Convert connections to adjacency list adj = [[] for _ in range(n + 1)] for u, v in connections: adj[u].append(v) adj[v].append(u) def bfs(start): # Perform BFS to find the farthest node from the start node q = deque([(start, 0)]) visited = set() visited.add(start) farthest_node = start farthest_dist = 0 while q: node, dist = q.popleft() for neighbor in adj[node]: if neighbor not in visited: visited.add(neighbor) q.append((neighbor, dist + 1)) if dist + 1 > farthest_dist: farthest_dist = dist + 1 farthest_node = neighbor return farthest_node, farthest_dist # Step 1: Pick any node and find the farthest node from it farthest_node, _ = bfs(1) # Step 2: Perform BFS again from the farthest node found in step 1 # to find the actual diameter _, diameter = bfs(farthest_node) return diameter # Example usage: connections = [ (1, 2), (1, 3), (3, 4), (3, 5) ] result = tree_diameter(5, connections) print(result) # Output: 3"},{"question":"def is_possible_to_cover(n: int, m: int) -> str: Determines if it is possible to cover an entire n x m greenhouse using only 1x2 or 2x1 glass panels. Parameters: n (int): The number of rows of the greenhouse. m (int): The number of columns of the greenhouse. Returns: str: \\"POSSIBLE\\" if the greenhouse can be fully covered with the panels, otherwise \\"IMPOSSIBLE\\". pass from solution import is_possible_to_cover def test_even_dimensions(): assert is_possible_to_cover(2, 4) == \\"POSSIBLE\\" assert is_possible_to_cover(4, 6) == \\"POSSIBLE\\" def test_odd_even_dimensions(): assert is_possible_to_cover(3, 4) == \\"POSSIBLE\\" assert is_possible_to_cover(5, 6) == \\"POSSIBLE\\" def test_odd_dimensions(): assert is_possible_to_cover(1, 1) == \\"IMPOSSIBLE\\" assert is_possible_to_cover(3, 5) == \\"IMPOSSIBLE\\" def test_square_even_dimensions(): assert is_possible_to_cover(2, 2) == \\"POSSIBLE\\" assert is_possible_to_cover(4, 4) == \\"POSSIBLE\\" def test_square_odd_dimensions(): assert is_possible_to_cover(3, 3) == \\"IMPOSSIBLE\\" assert is_possible_to_cover(5, 5) == \\"IMPOSSIBLE\\"","solution":"def is_possible_to_cover(n, m): Determines if it is possible to cover an entire n x m greenhouse using only 1x2 or 2x1 glass panels. Parameters: n (int): The number of rows of the greenhouse. m (int): The number of columns of the greenhouse. Returns: str: \\"POSSIBLE\\" if the greenhouse can be fully covered with the panels, otherwise \\"IMPOSSIBLE\\". # Check if the product of n and m is even if (n * m) % 2 == 0: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def unique_paths(n, m, grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[List[str]]): the grid representation where 'O' is an open cell and 'X' is a blocked cell Returns: int: number of unique paths from (1, 1) to (n, m) Examples: >>> unique_paths(3, 3, [[\\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\"]]) 2 >>> unique_paths(2, 2, [[\\"O\\", \\"O\\"], [\\"O\\", \\"O\\"]]) 2 >>> unique_paths(4, 4, [[\\"O\\", \\"O\\", \\"O\\", \\"O\\"], [\\"O\\", \\"X\\", \\"X\\", \\"O\\"], [\\"O\\", \\"O\\", \\"X\\", \\"O\\"], [\\"O\\", \\"O\\", \\"O\\", \\"O\\"]]) 3","solution":"def unique_paths(n, m, grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of the grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[List[str]]): the grid representation where 'O' is an open cell and 'X' is a blocked cell Returns: int: number of unique paths from (1, 1) to (n, m) if grid[0][0] == 'X' or grid[n-1][m-1] == 'X': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 'X': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"import math from typing import List, Tuple def largest_square_tile_side_lengths(t: int, dimensions: List[Tuple[int, int]]) -> List[int]: Given the number of test cases and a list of plaque dimensions, find the size of the largest possible square tiles for each plaque by calculating the greatest common divisor (GCD) of the dimensions. Args: t (int): Number of test cases. dimensions (List[Tuple[int, int]]): List of tuples containing the dimensions of the plaques. Returns: List[int]: A list of integers representing the side length of the largest possible square tile for each plaque. Examples: >>> largest_square_tile_side_lengths(3, [(4, 6), (10, 15), (12, 8)]) [2, 5, 4] >>> largest_square_tile_side_lengths(1, [(5, 5)]) [5]","solution":"import math def largest_square_tile_side_lengths(t, dimensions): results = [] for i in range(t): n, m = dimensions[i] gcd = math.gcd(n, m) results.append(gcd) return results"},{"question":"def word_break(s: str, wordDict: List[str]) -> bool: Determines if the string s can be segmented into one or more dictionary words from wordDict. Args: s (str): The input string. wordDict (List[str]): The list of words as the dictionary. Returns: bool: True if the string s can be segmented, False otherwise. Examples: >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False","solution":"def word_break(s, wordDict): Determines if the string s can be segmented into one or more dictionary words from wordDict. Args: s (str): The input string. wordDict (List[str]): The list of words as the dictionary. Returns: bool: True if the string s can be segmented, False otherwise. n = len(s) dp = [False] * (n + 1) dp[0] = True for i in range(1, n + 1): for word in wordDict: if dp[i - len(word)] and s[i - len(word):i] == word: dp[i] = True break return dp[n]"},{"question":"def find_cycle_length(n: int, permutation: List[int]) -> int: Finds the length of the cycle starting from the first position in the permutation. Parameters: n (int): The number of elements in the permutation. permutation (list of int): The permutation list of integers from 1 to n. Returns: int: The length of the cycle. Example: >>> find_cycle_length(3, [2, 3, 1]) == 3 >>> find_cycle_length(5, [2, 3, 4, 5, 1]) == 5 >>> find_cycle_length(1, [1]) == 1 >>> find_cycle_length(2, [2, 1]) == 2 >>> find_cycle_length(3, [1, 2, 3]) == 1 pass","solution":"def find_cycle_length(n, permutation): Finds the length of the cycle starting from the first position in the permutation. Parameters: n (int): The number of elements in the permutation. permutation (list of int): The permutation list of integers from 1 to n. Returns: int: The length of the cycle. visited = {} current_position = 0 steps = 0 while current_position not in visited: visited[current_position] = True current_position = permutation[current_position] - 1 steps += 1 return steps"},{"question":"from typing import List, Tuple def most_frequent_pair(t: int, transactions: List[List[int]]) -> Tuple[int, int]: Identify the most frequently bought pair of products from the transaction data. If there are multiple pairs with the same frequency, return the lexicographically smallest pair. >>> most_frequent_pair(5, [[1, 2, 3], [2, 3, 4], [1, 2, 4], [2, 3], [1, 2]]) == (1, 2) >>> most_frequent_pair(1, [[10, 20]]) == (10, 20) >>> most_frequent_pair(3, [[1, 2], [3, 4], [5, 6]]) == (1, 2) >>> most_frequent_pair(4, [[1, 2, 3], [1, 3], [2, 3], [1, 2]]) == (1, 2) >>> most_frequent_pair(3, [[1, 2], [1, 2], [1, 2]]) == (1, 2) pass","solution":"from collections import defaultdict from itertools import combinations def most_frequent_pair(t, transactions): pair_count = defaultdict(int) for transaction in transactions: for pair in combinations(sorted(transaction), 2): pair_count[pair] += 1 most_frequent = max(pair_count.items(), key=lambda x: (x[1], -x[0][0], -x[0][1])) return most_frequent[0] # Function to read input and use the most_frequent_pair function def main(): import sys input = sys.stdin.read data = input().split(\\"n\\") t = int(data[0]) transactions = [] for i in range(1, t + 1): if data[i].strip(): transactions.append(list(map(int, data[i].split()))) result = most_frequent_pair(t, transactions) print(result[0], result[1])"},{"question":"from typing import List def max_tasks_completed(t: int, test_cases: List[List[List[int]]]) -> List[int]: Determines the maximum number of tasks that can be completed given the employees and their skills. Args: t (int): The number of test cases. test_cases (List[List[List[int]]]): A list containing test cases where each test case includes employee skills and task requirements. Returns: List[int]: A list with the maximum number of tasks completed for each test case. Example: >>> t = 2 >>> test_cases = [ ... [ ... [3, 3], ... [2, 1, 2], ... [3, 2, 3, 4], ... [1, 5], ... [1, 1], ... [2, 1, 4], ... [2, 2, 5] ... ], ... [ ... [2, 3], ... [1, 2], ... [1, 3], ... [1, 2], ... [1, 3] ... ] ... ] >>> max_tasks_completed(t, test_cases) [1, 2]","solution":"from typing import List, Set def can_handle(task: Set[int], employee_skills: Set[int]) -> bool: return task.issubset(employee_skills) def max_tasks_completed(t: int, test_cases: List[List[List[int]]]) -> List[int]: results = [] for case in test_cases: n, m = case[0] employee_skills = [set(employee[1:]) for employee in case[1:n+1]] tasks = [set(task[1:]) for task in case[n+1:]] assigned_tasks = 0 for task in tasks: for employee in employee_skills: if can_handle(task, employee): assigned_tasks += 1 employee_skills.remove(employee) break results.append(assigned_tasks) return results # Example usage # t = 2 # test_cases = [ # [ # [3, 3], # [2, 1, 2], # [3, 2, 3, 4], # [1, 5], # [1, 1], # [2, 1, 4], # [2, 2, 5] # ], # [ # [2, 3], # [1, 2], # [1, 3], # [1, 2], # # [1, 3] # Removed last task for clarity # ] # ] # print(max_tasks_completed(t, test_cases)) # Output [1, 2]"},{"question":"def longest_palindromic_subsequence_length(t: int, digits: str) -> int: Sheldon loves creating palindromic strings using his pieces of ice with digits on them. A palindromic string reads the same backward as forward. Given a sequence of digits on the pieces of ice, Sheldon wants to know the length of the longest palindromic subsequence he can construct. >>> longest_palindromic_subsequence_length(5, \\"12321\\") 5 >>> longest_palindromic_subsequence_length(8, \\"12345678\\") 1","solution":"def longest_palindromic_subsequence_length(t, digits): dp = [[0] * t for _ in range(t)] for i in range(t): dp[i][i] = 1 for cl in range(2, t+1): for i in range(t - cl + 1): j = i + cl - 1 if digits[i] == digits[j] and cl == 2: dp[i][j] = 2 elif digits[i] == digits[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][t-1]"},{"question":"def is_valid_brackets(s: str) -> str: Check if the string of brackets is valid. Args: s (string): A string containing only '(', ')', '{', '}', '[' and ']'. Returns: string: \\"YES\\" if the string is valid, otherwise \\"NO\\". pass # Unit tests def test_is_valid_brackets(): assert is_valid_brackets(\\"()[]{}\\") == \\"YES\\" assert is_valid_brackets(\\"([{}])\\") == \\"YES\\" assert is_valid_brackets(\\"(]\\") == \\"NO\\" assert is_valid_brackets(\\"([{])\\") == \\"NO\\" def test_is_valid_brackets_single_type(): assert is_valid_brackets(\\"((()))\\") == \\"YES\\" assert is_valid_brackets(\\"()\\") == \\"YES\\" assert is_valid_brackets(\\"(\\") == \\"NO\\" assert is_valid_brackets(\\"(((\\") == \\"NO\\" def test_is_valid_brackets_mixed_types(): assert is_valid_brackets(\\"{[()]}\\") == \\"YES\\" assert is_valid_brackets(\\"{[(])}\\") == \\"NO\\" assert is_valid_brackets(\\"\\") == \\"YES\\" assert is_valid_brackets(\\"{}[]()\\") == \\"YES\\" def test_is_valid_brackets_edge_cases(): assert is_valid_brackets(\\"(\\" * 5000 + \\")\\" * 5000) == \\"YES\\" assert is_valid_brackets(\\"(\\" * 5000 + \\")\\" * 4999) == \\"NO\\" assert is_valid_brackets(\\"(\\" * 5000 + \\")\\" * 5001) == \\"NO\\"","solution":"def is_valid_brackets(s): Check if the string of brackets is valid. Args: s (string): A string containing only '(', ')', '{', '}', '[' and ']'. Returns: string: \\"YES\\" if the string is valid, otherwise \\"NO\\". stack = [] bracket_map = {')': '(', '}': '{', ']': '['} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\""},{"question":"def can_divide_garden(M, N, garden, K): Determine whether it is possible to divide the garden into at least two non-overlapping sections where each section has the sum of fertility levels equal to K. Args: M (int): number of rows in the garden matrix. N (int): number of columns in the garden matrix. garden (List[List[int]]): the garden matrix with fertility levels. K (int): the sum of fertility levels each section should equal to. Returns: str: \\"YES\\" if possible to divide the garden as required, otherwise \\"NO\\". >>> can_divide_garden(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 15) \\"YES\\" >>> can_divide_garden(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) \\"NO\\" >>> can_divide_garden(2, 2, [[5, 5], [5, 5]], 10) \\"YES\\" >>> can_divide_garden(2, 2, [[5, 5], [5, 5]], 9) \\"NO\\"","solution":"def can_divide_garden(M, N, garden, K): def calculate_prefix_sum(matrix): prefix = [[0] * (N + 1) for _ in range(M + 1)] for i in range(1, M + 1): for j in range(1, N + 1): prefix[i][j] = matrix[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1] return prefix prefix = calculate_prefix_sum(garden) seen_sums = {} for row1 in range(M): for row2 in range(row1, M): for col1 in range(N): for col2 in range(col1, N): current_sum = (prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1] - prefix[row2 + 1][col1] + prefix[row1][col1]) if current_sum == K: if current_sum in seen_sums: return \\"YES\\" seen_sums[current_sum] = True return \\"NO\\""},{"question":"from typing import List def subarray_sum_equals_k(nums: List[int], k: int) -> int: Given an array of integers nums and an integer k, return the number of distinct subarrays of nums whose sum is equal to k. Example: >>> subarray_sum_equals_k([1, 1, 1], 2) 2 >>> subarray_sum_equals_k([1, 2, 3], 3) 2","solution":"def subarray_sum_equals_k(nums, k): Returns the number of distinct subarrays whose sum equals to k. prefix_sum_counts = {0: 1} current_sum = 0 count = 0 for num in nums: current_sum += num if current_sum - k in prefix_sum_counts: count += prefix_sum_counts[current_sum - k] if current_sum not in prefix_sum_counts: prefix_sum_counts[current_sum] = 0 prefix_sum_counts[current_sum] += 1 return count"},{"question":"def can_travel(n, roads, city_widths, queries): Determines for each query if a vehicle can travel from the start city to the destination city under the constraints. Args: n: int : number of cities roads: List[Tuple[int, int, int]] : roads between cities with their widths city_widths: List[int] : list of widths capacities for each city queries: List[Tuple[int, int, int]] : queries with start, end cities and vehicle width Returns: List[str] : results for each query (\\"YES\\"/\\"NO\\") pass def test_can_travel_case1(): n = 5 roads = [(1, 2, 3), (2, 3, 5), (3, 4, 4), (3, 5, 2)] city_widths = [5, 4, 3, 4, 2] queries = [(1, 4, 3), (3, 5, 2), (4, 2, 5)] result = can_travel(n, roads, city_widths, queries) assert result == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_can_travel_case2(): n = 4 roads = [(1, 2, 5), (2, 3, 7), (3, 4, 4)] city_widths = [4, 6, 6, 3] queries = [(1, 3, 5), (2, 4, 6)] result = can_travel(n, roads, city_widths, queries) assert result == [\\"YES\\", \\"NO\\"] def test_can_travel_edge_case(): n = 2 roads = [(1, 2, 1)] city_widths = [1, 1] queries = [(1, 2, 1), (1, 2, 2)] result = can_travel(n, roads, city_widths, queries) assert result == [\\"YES\\", \\"NO\\"] def test_can_travel_larger_case(): n = 6 roads = [(1, 2, 3), (1, 3, 3), (2, 4, 3), (3, 5, 3), (5, 6, 3)] city_widths = [3, 3, 3, 3, 3, 3] queries = [(1, 6, 2), (2, 5, 3), (1, 4, 4)] result = can_travel(n, roads, city_widths, queries) assert result == [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"from collections import defaultdict, deque def can_travel(n, roads, city_widths, queries): Determines for each query if a vehicle can travel from the start city to the destination city under the constraints. Args: n: int : number of cities roads: List[Tuple[int, int, int]] : roads between cities with their widths city_widths: List[int] : list of widths capacities for each city queries: List[Tuple[int, int, int]] : queries with start, end cities and vehicle width Returns: List[str] : results for each query (\\"YES\\"/\\"NO\\") graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) results = [] for a, b, w in queries: if bfs(graph, city_widths, a, b, w): results.append(\\"YES\\") else: results.append(\\"NO\\") return results def bfs(graph, city_widths, start, end, vehicle_width): Performs a BFS to check if there is a valid path for the vehicle. Args: graph: Dict : adjacency list of the graph city_widths: List[int] : list of widths capacities for each city start: int : starting city end: int : destination city vehicle_width: int : vehicle width Returns: bool : True if path exists, else False visited = [False] * (len(city_widths) + 1) queue = deque([(start, city_widths[start - 1])]) while queue: current_city, current_city_width = queue.popleft() if current_city == end: return True if visited[current_city]: continue visited[current_city] = True for neighbor, road_width in graph[current_city]: if not visited[neighbor] and road_width >= vehicle_width and city_widths[neighbor - 1] >= vehicle_width: queue.append((neighbor, city_widths[neighbor - 1])) return False"},{"question":"def maximize_expected_profit(N: int, B: int, stocks: List[Tuple[int, int]]) -> int: Given the number of stocks N, initial budget B, and a list of stocks with their prices and expected profits, this function returns the maximum expected profit. Args: N : int : Number of different stocks B : int : Initial budget in dollars stocks : List[Tuple[int, int]] : List of tuples where each tuple contains (P(i), C(i)) Returns: int : Maximum expected profit >>> maximize_expected_profit(3, 50, [(10, 5), (20, 10), (30, 15)]) 25 >>> maximize_expected_profit(3, 20, [(4, 4), (5, 5), (10, 10)]) 20 >>> maximize_expected_profit(3, 150, [(100, 20), (200, 40), (300, 60)]) 20 >>> maximize_expected_profit(3, 0, [(10, 5), (15, 7), (20, 9)]) 0 >>> maximize_expected_profit(3, 100, [(500, 50), (600, 60), (700, 70)]) 0 >>> maximize_expected_profit(1, 100, [(10, 10)]) 100 >>> maximize_expected_profit(1, 50, [(1, 100)]) 5000 pass","solution":"def maximize_expected_profit(N, B, stocks): Given the number of stocks N, initial budget B, and a list of stocks with their prices and expected profits, this function returns the maximum expected profit. Args: N : int : Number of different stocks B : int : Initial budget in dollars stocks : List[Tuple[int, int]] : List of tuples where each tuple contains (P(i), C(i)) Returns: int : Maximum expected profit # Sort stocks by profit to price ratio in descending order stocks.sort(key=lambda x: x[1]/x[0], reverse=True) max_profit = 0 for price, profit in stocks: if B >= price: shares = B // price max_profit += shares * profit B -= shares * price return max_profit"},{"question":"def longest_same_parity_subarray(n: int, a: List[int]) -> int: Returns the length of the longest contiguous subarray where all elements have the same parity. Parameters: n (int): The number of elements in the array. a (list): The list of integers representing the magical numbers on the stones. Returns: int: The length of the longest contiguous subarray with the same parity. >>> longest_same_parity_subarray(7, [1, 2, 2, 2, 3, 4, 4]) 3 >>> longest_same_parity_subarray(8, [4, 4, 5, 5, 5, 5, 2, 2]) 4 >>> longest_same_parity_subarray(1, [7]) 1 >>> longest_same_parity_subarray(5, [2, 4, 6, 8, 10]) 5 >>> longest_same_parity_subarray(5, [1, 3, 5, 7, 9]) 5 >>> longest_same_parity_subarray(6, [1, 2, 3, 4, 5, 6]) 1 >>> longest_same_parity_subarray(10, [1, 1, 1, 2, 2, 2, 1, 1, 1, 2]) 3","solution":"def longest_same_parity_subarray(n, a): Returns the length of the longest contiguous subarray where all elements have the same parity. Parameters: n (int): The number of elements in the array. a (list): The list of integers representing the magical numbers on the stones. Returns: int: The length of the longest contiguous subarray with the same parity. if n == 0: return 0 max_length = 1 current_length = 1 current_parity = a[0] % 2 for i in range(1, n): if a[i] % 2 == current_parity: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 current_parity = a[i] % 2 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List, Tuple def find_frequent_path_sum(n: int, nodes: List[Tuple[int, int, int]]) -> int: Given a binary tree, find the most frequent sum of root-to-leaf paths. Args: n (int): the number of nodes in the tree. nodes (List[Tuple[int, int, int]]): a list of nodes, where each node is represented by a tuple (v, l, r) with v being the value of the node, l being the value of the left child (or -1 if there is no left child), and r being the value of the right child (or -1 if there is no right child). Returns: int: the most frequent sum of root-to-leaf paths. If there is a tie, returns the smallest sum. Example: >>> find_frequent_path_sum(5, [(1, 2, 3), (2, 4, -1), (3, -1, 5), (4, -1, -1), (5, -1, -1)]) 7 >>> find_frequent_path_sum(1, [(10, -1, -1)]) 10 >>> find_frequent_path_sum(3, [(5, 4, 4), (4, -1, -1), (4, -1, -1)]) 9 >>> find_frequent_path_sum(3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)]) 3 >>> find_frequent_path_sum(0, []) 0","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_list): if not node_list: return None nodes = {} for v, l, r in node_list: if v not in nodes: nodes[v] = TreeNode(v) if l != -1 and l not in nodes: nodes[l] = TreeNode(l) if r != -1 and r not in nodes: nodes[r] = TreeNode(r) nodes[v].left = nodes.get(l) nodes[v].right = nodes.get(r) return nodes[node_list[0][0]] # return the root node def find_frequent_path_sum(n, node_list): if n == 0: return 0 # No nodes root = build_tree(node_list) sum_frequency = defaultdict(int) def dfs(node, current_sum): if not node: return current_sum += node.value if not node.left and not node.right: # Leaf node sum_frequency[current_sum] += 1 dfs(node.left, current_sum) dfs(node.right, current_sum) dfs(root, 0) most_frequent_sum = min(sum_frequency, key=lambda x: (-sum_frequency[x], x)) return most_frequent_sum"},{"question":"class BookstoreInventory: def __init__(self): Initialize the bookstore inventory. self.inventory = {} def add_book(self, title, quantity, price): Add a new book to the inventory. If the book title already exists, ignore this operation. >>> inventory = BookstoreInventory() >>> inventory.add_book(\\"The Great Gatsby\\", 5, 120) >>> inventory.inventory {\\"The Great Gatsby\\": (5, 120)} pass def update_quantity(self, title, quantity): Update the quantity of an existing book. If the book title does not exist, ignore this operation. >>> inventory = BookstoreInventory() >>> inventory.add_book(\\"The Great Gatsby\\", 5, 120) >>> inventory.update_quantity(\\"The Great Gatsby\\", 7) >>> inventory.inventory {\\"The Great Gatsby\\": (7, 120)} pass def delete_book(self, title): Delete a book from the inventory. If the book title does not exist, ignore this operation. >>> inventory = BookstoreInventory() >>> inventory.add_book(\\"The Great Gatsby\\", 5, 120) >>> inventory.delete_book(\\"The Great Gatsby\\") >>> inventory.inventory {} pass def query_total_value(self): Query the total value of all books in the inventory. >>> inventory = BookstoreInventory() >>> inventory.add_book(\\"The Great Gatsby\\", 5, 120) >>> inventory.add_book(\\"1984\\", 10, 150) >>> inventory.query_total_value() 2700 pass","solution":"class BookstoreInventory: def __init__(self): self.inventory = {} def add_book(self, title, quantity, price): if title not in self.inventory: self.inventory[title] = (quantity, price) def update_quantity(self, title, quantity): if title in self.inventory: _, price = self.inventory[title] self.inventory[title] = (quantity, price) def delete_book(self, title): if title in self.inventory: del self.inventory[title] def query_total_value(self): total_value = 0 for quantity, price in self.inventory.values(): total_value += quantity * price return total_value"},{"question":"from typing import List def rearrange_string(s: str) -> str: Rearranges string \`s\` such that no two adjacent characters are the same. If not possible, returns 'IMPOSSIBLE'. >>> rearrange_string(\\"aab\\") \\"aba\\" >>> rearrange_string(\\"aaab\\") \\"IMPOSSIBLE\\" pass import unittest class TestRearrangeString(unittest.TestCase): def test_single_character(self): self.assertEqual(rearrange_string(\\"a\\"), \\"a\\") def test_two_same_characters(self): self.assertEqual(rearrange_string(\\"aa\\"), \\"IMPOSSIBLE\\") def test_two_different_characters(self): result = rearrange_string(\\"ab\\") self.assertIn(result, [\\"ab\\", \\"ba\\"]) def test_three_characters_possible(self): self.assertIn(rearrange_string(\\"aab\\"), [\\"aba\\", \\"bab\\"]) def test_three_characters_impossible(self): self.assertEqual(rearrange_string(\\"aaab\\"), \\"IMPOSSIBLE\\") def test_four_characters_possible(self): result = rearrange_string(\\"aabb\\") self.assertIn(result, [\\"abab\\", \\"baba\\"]) def test_four_characters_impossible(self): self.assertEqual(rearrange_string(\\"aaaab\\"), \\"IMPOSSIBLE\\") def test_longer_string(self): s = \\"aaabc\\" result = rearrange_string(s) self.assertIn(result, [\\"abaca\\", \\"acaba\\", \\"bacaa\\", \\"baaca\\", \\"caaba\\", \\"caaab\\"]) if __name__ == '__main__': unittest.main()","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges string s such that no two adjacent characters are the same. If not possible, returns \\"IMPOSSIBLE\\". if not s: return \\"IMPOSSIBLE\\" freq_counter = Counter(s) max_freq = max(freq_counter.values()) if max_freq > (len(s) + 1) // 2: return \\"IMPOSSIBLE\\" max_heap = [(-freq, char) for char, freq in freq_counter.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_char and -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 return ''.join(result)"},{"question":"def min_packets(n: int, a: int, b: int) -> int: Determine the minimum number of packets required to make exactly \`n\` grams of the mixture. If it's not possible to create exactly \`n\` grams using the given packets, return \`-1\`. >>> min_packets(10, 3, 5) == 2 >>> min_packets(9, 4, 6) == -1 >>> min_packets(12, 3, 4) == 3 >>> min_packets(10, 5, 7) == 2 >>> min_packets(12, 5, 6) == 2 >>> min_packets(0, 3, 5) == 0 >>> min_packets(5, 5, 10) == 1 >>> min_packets(10, 3, 10) == 1 >>> min_packets(20, 5, 5) == 4","solution":"def min_packets(n, a, b): Returns the minimum number of packets required to make exactly \`n\` grams of the mixture using packets of weight \`a\` and \`b\`. If it's not possible, returns \`-1\`. min_packets = float('inf') for i in range(n // a + 1): remainder = n - i * a if remainder % b == 0: j = remainder // b min_packets = min(min_packets, i + j) return min_packets if min_packets != float('inf') else -1"},{"question":"from datetime import datetime def date_difference(date1: str, date2: str) -> int: Returns the number of days between two dates. Parameters: date1 (str) : First date in the format YYYY-MM-DD. date2 (str) : Second date in the format YYYY-MM-DD. Returns: int: The number of days between the two dates. Examples: >>> date_difference(\\"2023-03-15\\", \\"2023-03-15\\") 0 >>> date_difference(\\"2021-12-25\\", \\"2022-01-01\\") 7 >>> date_difference(\\"2022-01-01\\", \\"2022-01-31\\") 30 >>> date_difference(\\"2022-01-31\\", \\"2021-12-25\\") 37 >>> date_difference(\\"2020-02-28\\", \\"2020-03-01\\") 2 >>> date_difference(\\"2019-02-28\\", \\"2019-03-01\\") 1","solution":"from datetime import datetime def date_difference(date1, date2): Returns the number of days between two dates. Parameters: date1 (str) : First date in the format YYYY-MM-DD. date2 (str) : Second date in the format YYYY-MM-DD. Returns: int: The number of days between the two dates. # Convert date strings to datetime objects date1 = datetime.strptime(date1, '%Y-%m-%d') date2 = datetime.strptime(date2, '%Y-%m-%d') # Calculate the difference in days difference = abs((date2 - date1).days) return difference"},{"question":"def count_new_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the number of ways to build the minimum number of space roads to ensure that all planets are connected. >>> count_new_roads(5, 3, [(1, 2), (1, 3), (4, 5)]) 6 >>> count_new_roads(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 1","solution":"def count_new_roads(n, m, roads): from collections import defaultdict, deque def bfs(start, visited, adj_list): queue = deque([start]) visited[start] = True component_size = 0 while queue: node = queue.popleft() component_size += 1 for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_size if n == 1: return 1 if m == 0 else 0 adj_list = defaultdict(list) for u, v in roads: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (n + 1) components = [] for planet in range(1, n + 1): if not visited[planet]: component_size = bfs(planet, visited, adj_list) components.append(component_size) if len(components) == 1: return 1 components.sort(reverse=True) total_ways = 1 for component in components[:-1]: total_ways *= component * components[-1] return total_ways"},{"question":"def solve(input_lines: str) -> str: Given an undirected graph G with N vertices and M edges, determine if there's a path between given pairs of vertices. Input: 5 4 1 2 2 3 3 4 4 5 3 1 5 2 4 5 1 Output: YES YES YES Input: 4 2 1 2 3 4 2 1 3 4 2 Output: NO NO def test_example_case_1(): input_data = \\"5 4n1 2n2 3n3 4n4 5n3n1 5n2 4n5 1n\\" assert solve(input_data) == \\"YESnYESnYES\\" def test_example_case_2(): input_data = \\"4 2n1 2n3 4n2n1 3n4 2n\\" assert solve(input_data) == \\"NOnNO\\" def test_example_case_3(): input_data = \\"6 5n1 2n2 3n1 4n4 5n5 6n4n1 6n2 3n4 1n6 5n\\" assert solve(input_data) == \\"YESnYESnYESnYES\\" def test_no_edges(): input_data = \\"3 0n1n1 2n\\" assert solve(input_data) == \\"NO\\" def test_all_connected(): input_data = \\"4 6n1 2n2 3n3 4n4 1n1 3n2 4n2n1 4n3 2n\\" assert solve(input_data) == \\"YESnYES\\" def test_single_component(): input_data = \\"3 2n1 2n2 3n2n1 3n3 1n\\" assert solve(input_data) == \\"YESnYES\\"","solution":"def find_parent(parent, i): if parent[i] == i: return i return find_parent(parent, parent[i]) def union(parent, rank, x, y): xroot = find_parent(parent, x) yroot = find_parent(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def is_connected(n, edges, queries): # Initialize parent and rank arrays parent = [i for i in range(n + 1)] rank = [0] * (n + 1) # Apply union-find algorithm for u, v in edges: x = find_parent(parent, u) y = find_parent(parent, v) if x != y: union(parent, rank, x, y) # Process each query result = [] for u, v in queries: if find_parent(parent, u) == find_parent(parent, v): result.append(\\"YES\\") else: result.append(\\"NO\\") return result def solve(input_lines): data = input_lines.split() index = 0 N, M = int(data[index]), int(data[index+1]) index += 2 edges = [] for _ in range(M): A, B = int(data[index]), int(data[index+1]) edges.append((A, B)) index += 2 Q = int(data[index]) index += 1 queries = [] for _ in range(Q): U, V = int(data[index]), int(data[index+1]) queries.append((U, V)) index += 2 result = is_connected(N, edges, queries) return \\"n\\".join(result)"},{"question":"def min_operations_to_transform(initial: str, desired: str) -> int: Returns the minimum number of operations required to transform the initial sequence of lights into the desired sequence by flipping subsequences of lights. >>> min_operations_to_transform(\\"10101\\", \\"01010\\") 5 >>> min_operations_to_transform(\\"11111\\", \\"11111\\") 0 >>> min_operations_to_transform(\\"00000\\", \\"11111\\") 5 >>> min_operations_to_transform(\\"101010\\", \\"010101\\") 6 >>> min_operations_to_transform(\\"0\\", \\"1\\") 1 >>> min_operations_to_transform(\\"1\\", \\"0\\") 1","solution":"def min_operations_to_transform(initial, desired): Returns the minimum number of operations required to transform the initial sequence of lights into the desired sequence by flipping subsequences of lights. count = 0 n = len(initial) for i in range(n): if initial[i] != desired[i]: count += 1 return count"},{"question":"def find_max_in_subarray(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given a list of integers and multiple range-based queries, find the maximum number in each query's subarray. Parameters: arr (List[int]): The list of integers. queries (List[Tuple[int, int]]): List of queries, where each query is a tuple of (l, r) representing the subarray's start and end indices (1-based). Returns: List[int]: A list of integers where each integer is the maximum value found in the corresponding subarray from the queries. Examples: >>> find_max_in_subarray([1, 2, 3, -1, 5, 6], [(1, 3), (4, 6), (2, 5)]) [3, 6, 5] >>> find_max_in_subarray([-4, -2, -5, -1, -3], [(1, 5), (2, 4)]) [-1, -1]","solution":"def find_max_in_subarray(arr, queries): results = [] for l, r in queries: results.append(max(arr[l-1:r])) return results"},{"question":"from collections import Counter import heapq from typing import List def smallest_non_adjacent_permutation(S: str) -> str: Find the lexicographically smallest permutation of the string such that no two adjacent characters are the same. If no such permutation exists, return \\"Impossible\\". >>> smallest_non_adjacent_permutation(\\"aabbcc\\") 'abcabc' >>> smallest_non_adjacent_permutation(\\"aaab\\") 'Impossible' def test_smallest_non_adjacent_permutation(): assert smallest_non_adjacent_permutation(\\"aabbcc\\") == \\"abcabc\\" assert smallest_non_adjacent_permutation(\\"aaab\\") == \\"Impossible\\" assert smallest_non_adjacent_permutation(\\"a\\") == \\"a\\" assert smallest_non_adjacent_permutation(\\"ab\\") == \\"ab\\" assert smallest_non_adjacent_permutation(\\"aaabb\\") == \\"ababa\\" assert smallest_non_adjacent_permutation(\\"aaaabb\\") == \\"Impossible\\" assert smallest_non_adjacent_permutation(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"abcdefghijklmnopqrstuvwxyz\\" assert smallest_non_adjacent_permutation(\\"aabbccddeeffgghhiijj\\") == \\"abcdefghijabcdefghij\\" # Running tests test_smallest_non_adjacent_permutation()","solution":"from collections import Counter import heapq def smallest_non_adjacent_permutation(S): Function to find the lexicographically smallest permutation of the string such that no two adjacent characters are the same. If no such permutation exists, return \\"Impossible\\". # First, count the frequency of each character count = Counter(S) # Create a max heap based on the counts max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap or prev_freq: if prev_freq and not max_heap: return \\"Impossible\\" freq, char = heapq.heappop(max_heap) # Add the character to the result result.append(char) # Since we are using a max heap with negative frequencies, add the previous character back if needed if prev_freq: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the previous character and frequency prev_char = char prev_freq = freq + 1 return ''.join(result)"},{"question":"def can_form_circle(num_people: int, handshakes: List[Tuple[int, int]]) -> str: Determine if it is possible to form a closed circle of handshakes. >>> can_form_circle(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YESn1 2 3 4\\" or can_form_circle(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YESn2 3 4 1\\" or can_form_circle(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YESn3 4 1 2\\" or can_form_circle(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YESn4 1 2 3\\" >>> can_form_circle(4, [(1, 2), (2, 3), (3, 1), (4, 1)]) == \\"NO\\" >>> can_form_circle(3, [(1, 2), (2, 3)]) == \\"NO\\" >>> can_form_circle(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == \\"YESn1 2 3 4 5 6\\" or can_form_circle(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == \\"YESn2 3 4 5 6 1\\" or can_form_circle(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == \\"YESn3 4 5 6 1 2\\" or can_form_circle(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == \\"YESn4 5 6 1 2 3\\" or can_form_circle(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == \\"YESn5 6 1 2 3 4\\" or can_form_circle(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) == \\"YESn6 1 2 3 4 5\\" >>> can_form_circle(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"NO\\"","solution":"def can_form_circle(num_people, handshakes): from collections import defaultdict, deque # Create an adjacency list for recording the handshake pairs graph = defaultdict(list) for a, b in handshakes: graph[a].append(b) graph[b].append(a) # Check if every person can shake hands with exactly 2 people for key, value in graph.items(): if len(value) != 2: return \\"NO\\" # Start forming the circle start = list(graph.keys())[0] circle = [] visited = set() current = start while True: if current in visited: break visited.add(current) circle.append(current) for neighbor in graph[current]: if neighbor not in visited: current = neighbor break if len(visited) == num_people: return \\"YESn\\" + \\" \\".join(map(str, circle)) else: return \\"NO\\""},{"question":"def count_intersections(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Returns the number of different intersections in the city. Parameters: n (int): Number of roads m (int): Number of loops roads (List[Tuple[int, int]]): List of tuples representing roads (u, v) Returns: int: Number of intersections >>> count_intersections(3, 1, [(1, 2), (2, 3), (3, 1)]) 3 >>> count_intersections(5, 2, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) 5 pass from solution import count_intersections def test_count_intersections_example1(): n = 3 m = 1 roads = [(1, 2), (2, 3), (3, 1)] assert count_intersections(n, m, roads) == 3 def test_count_intersections_example2(): n = 5 m = 2 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert count_intersections(n, m, roads) == 5 def test_count_intersections_single_road(): n = 1 m = 0 roads = [(1, 2)] assert count_intersections(n, m, roads) == 2 def test_count_intersections_disconnected_vertices(): n = 4 m = 0 roads = [(1, 2), (3, 4)] assert count_intersections(n, m, roads) == 4 def test_count_intersections_all_intersections_covered(): n = 6 m = 1 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)] assert count_intersections(n, m, roads) == 6","solution":"def count_intersections(n, m, roads): Returns the number of different intersections in the city. Parameters: n (int): Number of roads m (int): Number of loops roads (list): List of tuples representing roads (u, v) Returns: int: Number of intersections intersections = set() for u, v in roads: intersections.add(u) intersections.add(v) return len(intersections)"},{"question":"def can_make_palindrome(s: str) -> str: Determines if changing exactly one character in the string can create a palindrome. Args: s (str): Input string consisting of lowercase letters. Returns: str: 'YES' if it is possible to create a palindrome by changing one character, otherwise 'NO'. Examples: >>> can_make_palindrome(\\"abccaa\\") 'YES' >>> can_make_palindrome(\\"abcdef\\") 'NO'","solution":"def can_make_palindrome(s): Determines if changing exactly one character in the string can create a palindrome. Args: s (str): Input string consisting of lowercase letters. Returns: str: 'YES' if it is possible to create a palindrome by changing one character, otherwise 'NO'. def is_palindrome(s): return s == s[::-1] # Check if the string is already a palindrome if is_palindrome(s): return \\"YES\\" if len(s) % 2 != 0 else \\"NO\\" # Count mismatches left, right = 0, len(s) - 1 mismatches = 0 while left < right: if s[left] != s[right]: mismatches += 1 left += 1 right -= 1 # If there is exactly one mismatch, we can change one char to make it a palindrome return \\"YES\\" if mismatches == 1 else \\"NO\\""},{"question":"def find_best_peak_index(T, test_cases): Determine the peak Sam should visit based on maximizing the product of height and difficulty. >>> T = 2 >>> test_cases = [ ... {'n': 3, 'heights': [10, 20, 30], 'difficulties': [4, 5, 6]}, ... {'n': 4, 'heights': [12, 10, 14, 8], 'difficulties': [3, 7, 2, 6]} ... ] >>> find_best_peak_index(T, test_cases) [3, 2] # Implementation goes here","solution":"def find_best_peak_index(T, test_cases): results = [] for t in range(T): n = test_cases[t]['n'] heights = test_cases[t]['heights'] difficulties = test_cases[t]['difficulties'] best_index = 0 best_value = 0 # Value of Hi * Di best_height = 0 for i in range(n): current_value = heights[i] * difficulties[i] if current_value > best_value or (current_value == best_value and heights[i] > best_height): best_value = current_value best_height = heights[i] best_index = i results.append(best_index + 1) # Convert to 1-based indexing return results # Example Usage: # T = 2 # test_cases = [ # {'n': 3, 'heights': [10, 20, 30], 'difficulties': [4, 5, 6]}, # {'n': 4, 'heights': [12, 10, 14, 8], 'difficulties': [3, 7, 2, 6]} # ] # Output: [3, 2]"},{"question":"def generate_peak_sequence(n: int) -> str: Generate a peak sequence of length n or determine if it is impossible. >>> generate_peak_sequence(1) 'NO' >>> generate_peak_sequence(3) 'YESn1 3 2' >>> generate_peak_sequence(5) 'YESn1 2 3 4 5'","solution":"def generate_peak_sequence(n): if n < 3: return \\"NO\\" peak_sequence = [i for i in range(1, n+1)] if n == 3: return \\"YESn1 3 2\\" if n % 2 == 0: peak_sequence[1], peak_sequence[-1] = peak_sequence[-1], peak_sequence[1] return \\"YESn\\" + \\" \\".join(map(str, peak_sequence))"},{"question":"def count_cameras(n, r, c): Returns the total number of cameras observed in the given row r and column c. :param n: Size of the grid (n x n) :param r: Row index to evaluate :param c: Column index to evaluate :return: Total number of cameras observed pass def test_count_cameras_4x4_grid(): assert count_cameras(4, 2, 1) == 7 def test_count_cameras_5x5_grid(): assert count_cameras(5, 3, 3) == 9 def test_count_cameras_single_camera(): assert count_cameras(1, 0, 0) == 1 def test_count_cameras_10x10_grid(): assert count_cameras(10, 5, 5) == 19 def test_count_cameras_largest_grid(): assert count_cameras(100, 50, 50) == 199","solution":"def count_cameras(n, r, c): Returns the total number of cameras observed in the given row r and column c. :param n: Size of the grid (n x n) :param r: Row index to evaluate :param c: Column index to evaluate :return: Total number of cameras observed # Number of cameras in the row r cameras_in_row = n # Number of cameras in the column c (excluding the intersection already counted in the row) cameras_in_column = n - 1 # Total cameras observed total_cameras = cameras_in_row + cameras_in_column return total_cameras"},{"question":"def decrypt_message(n: int, encrypted_message: str) -> str: Decrypts an encrypted message that has been encoded using a simple substitution cipher with a given shift number n. >>> decrypt_message(3, \\"Khoor, Zruog!\\") == \\"Hello, World!\\" >>> decrypt_message(0, \\"Hello, World!\\") == \\"Hello, World!\\" >>> decrypt_message(1, \\"B\\") == \\"A\\" >>> decrypt_message(1, \\"a\\") == \\"z\\" >>> decrypt_message(26, \\"Hello, World!\\") == \\"Hello, World!\\" >>> decrypt_message(4, \\"Lipps, Asvph! 123\\") == \\"Hello, World! 123\\" >>> decrypt_message(1, \\"A\\") == \\"Z\\" >>> decrypt_message(1, \\"a\\") == \\"z\\" >>> decrypt_message(5, \\"Mjqqt, Btwqi!\\") == \\"Hello, World!\\"","solution":"def decrypt_message(n, encrypted_message): Decrypts an encrypted message that has been encoded using a simple substitution cipher with a given shift number n. decrypted_message = [] for char in encrypted_message: if char.isalpha(): shift = n base = ord('A') if char.isupper() else ord('a') new_char = chr((ord(char) - base - shift) % 26 + base) decrypted_message.append(new_char) else: decrypted_message.append(char) return ''.join(decrypted_message)"},{"question":"def maximalRectangle(matrix: List[List[str]]) -> int: Find the area of the largest rectangle containing only '1's in the given 2D grid. Args: matrix (List[List[str]]): 2D grid representing the garden with '1's as flower patches and '0's as empty spaces. Returns: int: Area of the largest rectangle containing only '1's. >>> maximalRectangle([[\\"1\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"1\\", \\"0\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\"]]) 6 >>> maximalRectangle([[\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"1\\"]]) 2 >>> maximalRectangle([[\\"1\\"], [\\"1\\"], [\\"0\\"], [\\"1\\"], [\\"1\\"], [\\"1\\"]]) 3 >>> maximalRectangle([[\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\"]]) 0 >>> maximalRectangle([[\\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\"]]) 9 >>> maximalRectangle([]) 0 pass","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 m, n = len(matrix), len(matrix[0]) height = [0] * (n + 1) for i in range(m): stack = [] for j in range(n + 1): if j < n: if matrix[i][j] == '1': height[j] += 1 else: height[j] = 0 while stack and height[stack[-1]] > height[j]: h = height[stack.pop()] w = j if not stack else j - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(j) return max_area"},{"question":"def is_constant_speed(n: int, checkpoints: List[Tuple[int, int]]) -> str: Determines if the speeds at different checkpoints form a consistent pattern. Args: n (int): Number of checkpoints. checkpoints (list of tuples): List of (time, distance) pairs. Returns: str: \\"Yes\\" if the running speed has been constant, \\"No\\" otherwise.","solution":"def is_constant_speed(n, checkpoints): Determines if the speeds at different checkpoints form a consistent pattern. Args: n (int): Number of checkpoints. checkpoints (list of tuples): List of (time, distance) pairs. Returns: str: \\"Yes\\" if the running speed has been constant, \\"No\\" otherwise. if n < 2: return \\"No\\" # Less than 2 data points can't form a pattern previous_time, previous_distance = checkpoints[0] for i in range(1, n): current_time, current_distance = checkpoints[i] # Calculate the speed between the previous checkpoint and the current checkpoint if (current_distance - previous_distance) * (checkpoints[i-1][0]) != (current_time - previous_time) * (checkpoints[i-1][1]): return \\"No\\" return \\"Yes\\""},{"question":"def count_pairs_with_difference_k(n: int, arr: List[int], k: int) -> int: Returns the number of pairs (i, j) such that i < j and j - i = k. >>> count_pairs_with_difference_k(5, [1, 5, 3, 4, 2], 2) 3 >>> count_pairs_with_difference_k(4, [1, 2, 3, 4], 1) 3","solution":"def count_pairs_with_difference_k(n, arr, k): Returns the number of pairs (i, j) such that i < j and j - i = k. Parameters: - n: int, the number of integers in the list. - arr: list of int, the integers list. - k: int, the required difference between pairs. Returns: - int, the count of pairs (i, j) with difference k. arr_set = set(arr) count = 0 for num in arr: if num + k in arr_set: count += 1 return count"},{"question":"def max_combined_spell_power(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: In a magical land, there are n wizards, each with a certain magical power level. The wizards, being curious creatures, want to form pairs and cast a combined spell. The power level of a combined spell is defined as the product of the power levels of the two wizards forming that pair. However, when two wizards form a pair, they consume each other's power, meaning their individual power levels turn to zero after forming a pair and casting the spell. This function determines the maximum combined spell power that can be achieved by forming exactly one pair of wizards from the entire group. >>> max_combined_spell_power(2, [(3, [10, 20, 30]), (4, [5, 5, 5, 5])]) [600, 25] >>> max_combined_spell_power(1, [(4, [100000, 99999, 1, 2])]) [100000 * 99999] >>> max_combined_spell_power(1, [(1, [10])]) [0] >>> max_combined_spell_power(1, [(5, [1, 1, 1, 1, 1])]) [1]","solution":"def max_combined_spell_power(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] power_levels = test_cases[i][1] if n < 2: results.append(0) continue max1 = max2 = -1 for power in power_levels: if power > max1: max2 = max1 max1 = power elif power > max2: max2 = power results.append(max1 * max2) return results"},{"question":"MOD = 10**9 + 7 def distinct_teams_count(n, k, m): Returns the number of distinct ways to form k teams each consisting of m employees from a total of n employees modulo 10^9 + 7. >>> distinct_teams_count(4, 2, 2) 6 >>> distinct_teams_count(5, 1, 3) 10 >>> distinct_teams_count(6, 3, 2) 90 >>> distinct_teams_count(4, 3, 2) 0 >>> distinct_teams_count(12, 1, 3) 220 pass def process_input(input_lines): Processes the input lines to extract test cases and compute results. >>> input_lines = [\\"3\\", \\"4 2 2\\", \\"5 1 3\\", \\"6 3 2\\"] >>> process_input(input_lines) [6, 10, 90] pass","solution":"from math import comb MOD = 10**9 + 7 def distinct_teams_count(n, k, m): Returns the number of distinct ways to form k teams each consisting of m employees from a total of n employees modulo 10^9 + 7. if k * m > n: return 0 remaining = n result = 1 for _ in range(k): result = (result * comb(remaining, m)) % MOD remaining -= m return result def process_input(input_lines): Processes the input lines to extract test cases and compute results. t = int(input_lines[0]) results = [] for i in range(1, t + 1): n, k, m = map(int, input_lines[i].split()) results.append(distinct_teams_count(n, k, m)) return results"},{"question":"def pair_with_difference(n: int, k: int, arr: List[int]) -> str: Determines if there exists a pair of distinct elements in the array whose difference is equal to k. Parameters: n (int): the number of elements in the array. k (int): the given integer to check the difference. arr (list): the list of n integers. Returns: str: \\"YES\\" if there exists a pair with the difference k, otherwise \\"NO\\". Examples: >>> pair_with_difference(5, 3, [1, 5, 3, 4, 2]) \\"YES\\" >>> pair_with_difference(5, 10, [1, 2, 3, 4, 5]) \\"NO\\"","solution":"def pair_with_difference(n, k, arr): Determines if there exists a pair of distinct elements in the array whose difference is equal to k. Parameters: n (int): the number of elements in the array. k (int): the given integer to check the difference. arr (list): the list of n integers. Returns: str: \\"YES\\" if there exists a pair with the difference k, otherwise \\"NO\\". encountered = set() for num in arr: if (num + k) in encountered or (num - k) in encountered: return \\"YES\\" encountered.add(num) return \\"NO\\""},{"question":"def maximal_rectangle(matrix: List[List[int]]) -> int: Calculate the area of the largest submatrix that contains only zeros. >>> maximal_rectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0], ... [0, 0, 0, 0, 1] ... ]) 6 >>> maximal_rectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 9 >>> maximal_rectangle([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 0 >>> maximal_rectangle([ ... [0, 1], ... [1, 0] ... ]) 1 >>> maximal_rectangle([ ... [1, 0, 1], ... [0, 0, 1], ... [0, 0, 1] ... ]) 4 >>> maximal_rectangle([ ... [1] ... ]) 0 >>> maximal_rectangle([ ... [0] ... ]) 1 >>> maximal_rectangle([]) 0","solution":"def maximal_rectangle(matrix): if not matrix: return 0 def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area max_area = 0 row_count = len(matrix) col_count = len(matrix[0]) dp = [0] * col_count for i in range(row_count): for j in range(col_count): dp[j] = dp[j] + 1 if matrix[i][j] == 0 else 0 max_area = max(max_area, max_histogram_area(dp)) return max_area"},{"question":"def min_balloons_to_burst(n: int, colors: List[int]) -> int: Returns the minimum number of balloons that need to be burst to achieve a sequence such that no two adjacent balloons have the same color. >>> min_balloons_to_burst(5, [1, 1, 2, 3, 3]) 2 >>> min_balloons_to_burst(4, [1, 2, 3, 4]) 0 pass from solution import min_balloons_to_burst def test_case1(): assert min_balloons_to_burst(5, [1, 1, 2, 3, 3]) == 2 def test_case2(): assert min_balloons_to_burst(4, [1, 2, 3, 4]) == 0 def test_case3(): assert min_balloons_to_burst(3, [1, 2, 2]) == 1 def test_case4(): assert min_balloons_to_burst(1, [1]) == 0 def test_case5(): assert min_balloons_to_burst(0, []) == 0 def test_case6(): assert min_balloons_to_burst(6, [5, 5, 5, 5, 5, 5]) == 5","solution":"def min_balloons_to_burst(n, colors): Returns the minimum number of balloons that need to be burst to achieve a sequence such that no two adjacent balloons have the same color. if n == 0: return 0 burst_count = 0 for i in range(1, n): if colors[i] == colors[i - 1]: burst_count += 1 return burst_count"},{"question":"def max_profit_from_cities(datasets): Determine the maximum profit the salesman can gain by visiting up to a set number of cities. >>> max_profit_from_cities([(5, [10, 20, 30, 40, 50], 3), (4, [100, 20, 30, 40], 2)]) [120, 140] pass def parse_input(input_data): Parse the input data into the required format. >>> parse_input('''5 10 20 30 40 50 3 4 100 20 30 40 2 -1''') [(5, [10, 20, 30, 40, 50], 3), (4, [100, 20, 30, 40], 2)] pass if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().strip() datasets = parse_input(input_data) results = max_profit_from_cities(datasets) for result in results: print(result)","solution":"def max_profit_from_cities(datasets): result = [] for data in datasets: n = data[0] profits = data[1] c = data[2] # Sort the profits in descending order and pick the top c profits sorted_profits = sorted(profits, reverse=True) max_profit = sum(sorted_profits[:c]) result.append(max_profit) return result def parse_input(input_data): datasets = [] current_data = [] for line in input_data.split('n'): if line.strip() == '-1': break elif line.strip(): current_data.append(line.strip()) if len(current_data) == 3: n = int(current_data[0]) profits = list(map(int, current_data[1].split())) c = int(current_data[2]) datasets.append((n, profits, c)) current_data = [] return datasets"},{"question":"def max_product_pair(n: int, arr: List[int]) -> Tuple[int, int, int]: Returns the maximum product of two numbers in the array and the pair of numbers. Parameters: n (int): number of elements in the array arr (list): list of non-negative integers Returns: tuple: tuple containing the maximum product, and the pair of numbers >>> max_product_pair(5, [1, 20, 30, 40, 50]) (2000, 50, 40) >>> max_product_pair(4, [3, 6, 8, 2]) (48, 8, 6) >>> max_product_pair(2, [5, 10]) (50, 10, 5) >>> max_product_pair(3, [10000, 9999, 9998]) (99990000, 10000, 9999) >>> max_product_pair(3, [0, 0, 0]) (0, 0, 0) >>> max_product_pair(4, [1, 2, 3, 10000]) (30000, 10000, 3)","solution":"def max_product_pair(n, arr): Returns the maximum product of two numbers in the array and the pair of numbers. Parameters: n (int): number of elements in the array arr (list): list of non-negative integers Returns: tuple: tuple containing the maximum product, and the pair of numbers if n < 2: raise ValueError(\\"Array should contain at least two elements.\\") max1 = max2 = 0 # Find the two largest numbers in the array for num in arr: if num > max1: max2 = max1 max1 = num elif num > max2: max2 = num max_product = max1 * max2 return (max_product, max1, max2)"},{"question":"def largest_concatenated_number(nums: List[int]) -> str: Reorders the numbers to form the largest concatenated number. >>> largest_concatenated_number([10, 2, 9]) '9210' >>> largest_concatenated_number([54, 546, 548, 60]) '6054854654' >>> largest_concatenated_number([1, 10]) '110' >>> largest_concatenated_number([3, 30, 34, 5, 9]) '9534330' >>> largest_concatenated_number([10, 100, 1000]) '101001000' >>> largest_concatenated_number([0, 0, 0]) '0' >>> largest_concatenated_number([0, 0, 1]) '100' pass","solution":"from functools import cmp_to_key def largest_concatenated_number(nums): Reorders the numbers to form the largest concatenated number. def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert integers to strings for comparison nums = list(map(str, nums)) nums.sort(key=cmp_to_key(compare)) # Join the sorted list to form the largest number largest_number = ''.join(nums) # Edge case: if the largest number is a series of zeros, return '0' if largest_number[0] == '0': return '0' return largest_number"},{"question":"def calculate_depths(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Process a list of direct reporting lines to find the depth of each employee in the hierarchy. >>> calculate_depths(2, [(5, [-1, 0, 1, 1, 3]), (3, [-1, 0, 0])]) [[0, 1, 2, 2, 3], [0, 1, 1]]","solution":"def calculate_depths(t, test_cases): results = [] for i in range(t): n, managers = test_cases[i] depths = [0] * n for employee in range(n): depth = 0 current = employee while managers[current] != -1: depth += 1 current = managers[current] depths[employee] = depth results.append(depths) return results"},{"question":"def longest_contiguous_substring(S: str) -> int: Given a string S consisting of lowercase alphabets, find the length of the longest contiguous substring that consists of the same character. >>> longest_contiguous_substring(\\"aaabbbaaacccc\\") 4 >>> longest_contiguous_substring(\\"abcdef\\") 1 >>> longest_contiguous_substring(\\"aaaabbbbbccccddddeeeeefffff\\") 5","solution":"def longest_contiguous_substring(S): Returns the length of the longest contiguous substring that consists of the same character. if not S: return 0 max_length = 1 current_length = 1 # Iterate over the string, starting from the second character for i in range(1, len(S)): if S[i] == S[i - 1]: # Check if the current character is same as the previous one current_length += 1 else: max_length = max(max_length, current_length) # Update max_length if needed current_length = 1 # Reset current_length # Final check to update max_length for the last contiguous characters max_length = max(max_length, current_length) return max_length"},{"question":"def determine_drone_position(moves: str) -> (int, int): Given a string of moves (N, S, E, W), determine the final position of the drone. >>> determine_drone_position(\\"NESW\\") (0, 0) >>> determine_drone_position(\\"NNWWSS\\") (-2, 0) >>> determine_drone_position(\\"SE\\") (1, -1) pass def process_input(lines: List[str]) -> List[str]: Given a list of strings representing drone movements, process each line to get the drone's final position. Each test case should be numbered starting from 1. If the drone returns to the starting point, output \\"Return to start\\". Otherwise, output \\"End at (x, y)\\" where (x, y) is the final position of the drone. >>> process_input([\\"NESW\\", \\"NNWWSS\\", \\"SE\\", \\"STOP\\"]) [\\"Case #1nReturn to start\\", \\"Case #2nEnd at (-2, 0)\\", \\"Case #3nEnd at (1, -1)\\"] >>> process_input([\\"\\", \\"NWSE\\", \\"STOP\\"]) [\\"Case #1nReturn to start\\", \\"Case #2nReturn to start\\"] pass","solution":"def determine_drone_position(moves): Given a string of moves (N, S, E, W), determine the final position of the drone. x, y = 0, 0 for move in moves: if move == 'N': y += 1 elif move == 'S': y -= 1 elif move == 'E': x += 1 elif move == 'W': x -= 1 return x, y def process_input(lines): case_number = 1 results = [] for moves in lines: if moves == \\"STOP\\": break x, y = determine_drone_position(moves) if x == 0 and y == 0: results.append(f\\"Case #{case_number}nReturn to start\\") else: results.append(f\\"Case #{case_number}nEnd at ({x}, {y})\\") case_number += 1 return results"},{"question":"from itertools import permutations def generate_permutations(S: str): Generate all unique permutations of the sequence that are lexicographically greater than the original sequence. Args: S (str): the original sequence of characters >>> generate_permutations(\\"ABC\\") ACB BAC BCA CAB CBA >>> generate_permutations(\\"CAB\\") CBA # Your implementation here # Unit tests def test_generate_permutations_ABC(capsys): generate_permutations(\\"ABC\\") captured = capsys.readouterr() assert captured.out == \\"ACBnBACnBCAnCABnCBAn\\" def test_generate_permutations_CAB(capsys): generate_permutations(\\"CAB\\") captured = capsys.readouterr() assert captured.out == \\"CBAn\\" def test_generate_permutations_AA(capsys): generate_permutations(\\"AA\\") captured = capsys.readouterr() assert captured.out == \\"\\" def test_generate_permutations_AAAA(capsys): generate_permutations(\\"AAAA\\") captured = capsys.readouterr() assert captured.out == \\"\\" def test_generate_permutations_with_duplicates(capsys): generate_permutations(\\"AAB\\") captured = capsys.readouterr() assert captured.out == \\"ABAnBAAn\\" def test_generate_permutations_single_letter(capsys): generate_permutations(\\"A\\") captured = capsys.readouterr() assert captured.out == \\"\\" def test_generate_permutations_longer_example(capsys): generate_permutations(\\"ABCD\\") captured = capsys.readouterr() assert captured.out == \\"ABDCnACBDnACDBnADBCnADCBnBACDnBADCnBCADnBCDAnBDACnBDCAnCABDnCADBnCBADnCBDAnCDABnCDBAnDABCnDACBnDBACnDBCAnDCABnDCBAn\\"","solution":"from itertools import permutations def generate_permutations(S): Generate all unique permutations of the sequence that are lexicographically greater than the original sequence. original_permutations = sorted(set(''.join(p) for p in permutations(S))) result = [perm for perm in original_permutations if perm > S] for perm in result: print(perm)"},{"question":"def transform_string(S: str) -> str: Transforms the input string S by replacing each distinct character with a unique integer starting from 1, based on the order of their first occurrence. >>> transform_string(\\"abac\\") '1 2 1 3' >>> transform_string(\\"hello\\") '1 2 3 3 4' >>> transform_string(\\"xyz\\") '1 2 3'","solution":"def transform_string(S): Transforms the input string S by replacing each distinct character with a unique integer starting from 1, based on the order of their first occurrence. char_to_number = {} next_number = 1 result = [] for ch in S: if ch not in char_to_number: char_to_number[ch] = next_number next_number += 1 result.append(char_to_number[ch]) return ' '.join(map(str, result))"},{"question":"def calculate_average_time_diffs(logs: List[str]) -> List[Tuple[str, float]]: Calculate the average time difference between consecutive log entries for each unique user. Args: logs: List of string log entries in the format \\"timestamp user_id action_type\\". Returns: List of tuples containing user_id and the average time difference, sorted by user_id. >>> calculate_average_time_diffs([ ... \\"1609459200 user1 login\\", ... \\"1609459260 user1 logout\\", ... \\"1609459320 user1 upload\\"]) [(\\"user1\\", 60.0)] >>> calculate_average_time_diffs([ ... \\"1609459200 user1 login\\", ... \\"1609459260 user2 logout\\", ... \\"1609459320 user1 upload\\", ... \\"1609459380 user2 login\\", ... \\"1609459440 user1 download\\"]) [(\\"user1\\", 120.0), (\\"user2\\", 120.0)] >>> calculate_average_time_diffs([\\"1609459200 user1 login\\"]) [(\\"user1\\", 0.0)] >>> calculate_average_time_diffs([ ... \\"1609459200 user1 login\\", ... \\"1609459300 user2 logout\\"]) [(\\"user1\\", 0.0), (\\"user2\\", 0.0)] >>> calculate_average_time_diffs([ ... \\"1609459200 user1 login\\", ... \\"1609459400 user1 upload\\", ... \\"1609460000 user1 download\\"]) [(\\"user1\\", 400.0)]","solution":"def calculate_average_time_diffs(logs): from collections import defaultdict import statistics user_logs = defaultdict(list) # Parse the store logs for log in logs: timestamp, user_id, action_type = log.split() timestamp = int(timestamp) user_logs[user_id].append(timestamp) average_diffs = {} # Calculate the average time differences for each user for user_id, timestamps in user_logs.items(): timestamps.sort() if len(timestamps) == 1: average_diffs[user_id] = 0.0 else: time_diffs = [timestamps[i] - timestamps[i-1] for i in range(1, len(timestamps))] average_diffs[user_id] = statistics.mean(time_diffs) # Sort the results by user_id in ascending order sorted_diffs = sorted(average_diffs.items()) return sorted_diffs"},{"question":"def is_valid_berland_number(number: str) -> str: Checks if the provided string is a valid Berland phone number. A valid Berland phone number has exactly 11 digits and starts with '7', '8', or '9'. Args: number (str): input string of digits. Returns: str: \\"VALID\\" if the string is a valid Berland phone number, otherwise \\"INVALID\\".","solution":"def is_valid_berland_number(number): Checks if the provided string is a valid Berland phone number. A valid Berland phone number has exactly 11 digits and starts with '7', '8', or '9'. Args: number (str): input string of digits. Returns: str: \\"VALID\\" if the string is a valid Berland phone number, otherwise \\"INVALID\\". if len(number) == 11 and number[0] in '789': return \\"VALID\\" return \\"INVALID\\""},{"question":"import math def distinct_gcd_lcm_sum(c: int) -> int: Returns the number of distinct values of gcd(a, c) + lcm(a, c) for a in the range 1 to c. Input: - c: int, (1 <= c <= 10^6), a single integer. Output: - int, the number of distinct values. Examples: >>> distinct_gcd_lcm_sum(1) 1 >>> distinct_gcd_lcm_sum(2) 2","solution":"import math def distinct_gcd_lcm_sum(c): Returns the number of distinct values of gcd(a, c) + lcm(a, c) for a in the range 1 to c. distinct_values = set() for a in range(1, c + 1): gcd_val = math.gcd(a, c) lcm_val = (a * c) // gcd_val distinct_values.add(gcd_val + lcm_val) return len(distinct_values)"},{"question":"def generate_pattern(n: int) -> str: Generates a specific string pattern based on the given integer input \`n\`. The pattern consists of the digits from 1 to 9 repeated as necessary. Parameters: n (int): The length of the string to be generated. Returns: str: The generated string pattern. >>> generate_pattern(5) '12345' >>> generate_pattern(9) '123456789' >>> generate_pattern(12) '123456789123' >>> generate_pattern(1) '1' >>> generate_pattern(18) '123456789123456789' >>> try: ... generate_pattern(0) ... except ValueError as e: ... assert str(e) == \\"Input must be between 1 and 100\\" >>> try: ... generate_pattern(101) ... except ValueError as e: ... assert str(e) == \\"Input must be between 1 and 100\\"","solution":"def generate_pattern(n): Generates a string pattern based on the given integer input \`n\`. The pattern consists of digits from 1 to 9 repeated as necessary. Parameters: n (int): The length of the string to be generated. Returns: str: The generated string pattern. if n < 1 or n > 100: raise ValueError(\\"Input must be between 1 and 100\\") pattern = \\"123456789\\" generated_string = (pattern * ((n // 9) + 1))[:n] return generated_string"},{"question":"def sort_songs_by_duration(songs): Sort a list of songs by their duration in ascending order. Parameters: songs (list of tuples): A list where each tuple contains a song's file name and its duration in \\"hh:mm:ss\\" format. Returns: list of tuples: The input list sorted by the duration of the songs. pass def test_sort_songs_by_duration_single(): songs = [(\\"songA.mp3\\", \\"00:03:20\\")] expected = [(\\"songA.mp3\\", \\"00:03:20\\")] assert sort_songs_by_duration(songs) == expected def test_sort_songs_by_duration_sorted(): songs = [ (\\"songA.mp3\\", \\"00:02:15\\"), (\\"songB.wav\\", \\"00:03:20\\"), (\\"songC.flac\\", \\"00:04:00\\") ] expected = [ (\\"songA.mp3\\", \\"00:02:15\\"), (\\"songB.wav\\", \\"00:03:20\\"), (\\"songC.flac\\", \\"00:04:00\\") ] assert sort_songs_by_duration(songs) == expected def test_sort_songs_by_duration_unsorted(): songs = [ (\\"songA.mp3\\", \\"00:03:20\\"), (\\"songB.wav\\", \\"00:02:15\\"), (\\"songC.flac\\", \\"00:03:20\\") ] expected = [ (\\"songB.wav\\", \\"00:02:15\\"), (\\"songA.mp3\\", \\"00:03:20\\"), (\\"songC.flac\\", \\"00:03:20\\") ] assert sort_songs_by_duration(songs) == expected def test_sort_songs_by_duration_same_duration(): songs = [ (\\"songA.mp3\\", \\"00:03:20\\"), (\\"songB.wav\\", \\"00:03:20\\"), (\\"songC.flac\\", \\"00:03:20\\") ] expected = [ (\\"songA.mp3\\", \\"00:03:20\\"), (\\"songB.wav\\", \\"00:03:20\\"), (\\"songC.flac\\", \\"00:03:20\\") ] assert sort_songs_by_duration(songs) == expected def test_sort_songs_by_duration_varied(): songs = [ (\\"songA.mp3\\", \\"01:02:30\\"), (\\"songB.wav\\", \\"00:15:45\\"), (\\"songC.flac\\", \\"02:30:00\\"), (\\"songD.mp3\\", \\"00:00:30\\") ] expected = [ (\\"songD.mp3\\", \\"00:00:30\\"), (\\"songB.wav\\", \\"00:15:45\\"), (\\"songA.mp3\\", \\"01:02:30\\"), (\\"songC.flac\\", \\"02:30:00\\") ] assert sort_songs_by_duration(songs) == expected","solution":"def sort_songs_by_duration(songs): Sort a list of songs by their duration in ascending order. Parameters: songs (list of tuples): A list where each tuple contains a song's file name and its duration in \\"hh:mm:ss\\" format. Returns: list of tuples: The input list sorted by the duration of the songs. def duration_to_seconds(duration): # Convert duration \\"hh:mm:ss\\" to seconds h, m, s = map(int, duration.split(':')) return h * 3600 + m * 60 + s # Sort the list using the duration converted to seconds as the key return sorted(songs, key=lambda x: duration_to_seconds(x[1]))"},{"question":"def minimum_rounds(n: int, m: int, a: List[int]) -> int: Determine the minimum number of rounds needed if all workers work optimally. >>> minimum_rounds(5, 2, [5, 2, 3, 7, 1]) 7 >>> minimum_rounds(6, 3, [1, 2, 3, 4, 5, 6]) 6 >>> minimum_rounds(4, 2, [0, 0, 0, 10]) 10 >>> minimum_rounds(5, 2, [0, 0, 0, 0, 0]) 0 >>> minimum_rounds(1, 1, [5]) 5 >>> minimum_rounds(6, 6, [1, 0, 1, 0, 1, 0]) 1","solution":"def minimum_rounds(n, m, a): max_items_per_round = max(a) return max_items_per_round"},{"question":"from collections import Counter def check_permutation_in_string(s: str, t: str) -> str: Check if there is a permutation of s that is a substring of t. >>> check_permutation_in_string(\\"ab\\", \\"eidbaooo\\") \\"YES\\" >>> check_permutation_in_string(\\"ab\\", \\"eidboaoo\\") \\"NO\\" >>> check_permutation_in_string(\\"abc\\", \\"cbasketball\\") \\"YES\\" >>> check_permutation_in_string(\\"abcde\\", \\"edcbabcdef\\") \\"YES\\" >>> check_permutation_in_string(\\"a\\", \\"a\\") \\"YES\\" >>> check_permutation_in_string(\\"a\\", \\"b\\") \\"NO\\" >>> check_permutation_in_string(\\"\\", \\"anything\\") \\"YES\\" >>> check_permutation_in_string(\\"a\\", \\"aaaaaaaaa\\") \\"YES\\" >>> check_permutation_in_string(\\"abc\\", \\"defghijklmnopqrstuvwxyz\\" * 4000 + \\"cab\\") \\"YES\\" >>> check_permutation_in_string(\\"abcdefghij\\", \\"abcd\\") \\"NO\\"","solution":"from collections import Counter def check_permutation_in_string(s, t): Check if there is a permutation of s that is a substring of t. len_s, len_t = len(s), len(t) if len_s > len_t: return \\"NO\\" s_counter = Counter(s) window_counter = Counter(t[:len_s]) if s_counter == window_counter: return \\"YES\\" for i in range(len_s, len_t): window_counter[t[i]] += 1 window_counter[t[i - len_s]] -= 1 if window_counter[t[i - len_s]] == 0: del window_counter[t[i - len_s]] if s_counter == window_counter: return \\"YES\\" return \\"NO\\""},{"question":"def calculate_document_relevance(w: int, word_scores: List[Tuple[str, int]], d: int, documents: List[str]) -> List[int]: Calculate the total relevance score for each document. Args: w (int): the number of words for which the relevance score is provided. word_scores (List[Tuple[str, int]]): the list of tuples containing each word and its relevance score. d (int): the number of documents. documents (List[str]): the list of documents, each as a space-separated string of words. Returns: List[int]: the list of total relevance scores for each document. Example: >>> calculate_document_relevance(5, [('hello', 50), ('world', 40), ('search', 100), ('engine', 60), ('ranking', 30)], 3, ['hello world', 'search engine ranking', 'hello hello search']) [90, 190, 150] >>> calculate_document_relevance(2, [('important', 100), ('relevant', 50)], 2, ['this document has no', 'relevant words at all']) [0, 50] >>> calculate_document_relevance(3, [('doc', 50), ('test', 30), ('empty', 10)], 1, ['']) [0] >>> calculate_document_relevance(3, [('apple', 50), ('banana', 30), ('cherry', 20)], 2, ['apple banana cherry', 'cherry apple apple']) [100, 70] >>> calculate_document_relevance(4, [('alpha', 10), ('beta', 20), ('gamma', 30), ('delta', 40)], 1, ['alpha beta gamma delta beta alpha']) [100]","solution":"def calculate_document_relevance(w, word_scores, d, documents): word_score_dict = {word: score for word, score in word_scores} document_scores = [] for document in documents: words = set(document.split()) total_score = sum(word_score_dict.get(word, 0) for word in words) document_scores.append(total_score) return document_scores"},{"question":"def shortest_path(n: int, m: int, q: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the shortest communication path between different pairs of computers. n: int : Number of computers. m: int : Number of bi-directional communication channels. q: int : Number of queries. edges : List[Tuple[int, int, int]] : Each tuple represents a communication channel between computers with latency. queries : List[Tuple[int, int]] : Each tuple represents a query to determine the minimum latency. Returns a list of minimum latencies for each query, or -1 if no path exists. Example: >>> shortest_path(4, 4, 2, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 7)], [(1, 4), (2, 3)]) [9, 1] >>> shortest_path(5, 3, 3, [(1, 2, 3), (1, 3, 10), (4, 5, 1)], [(1, 4), (1, 5), (3, 5)]) [-1, -1, -1] pass","solution":"import heapq def floyd_warshall(n, edges): dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 for u, v, l in edges: dist[u-1][v-1] = min(dist[u-1][v-1], l) dist[v-1][u-1] = min(dist[v-1][u-1], l) for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def shortest_path(n, m, q, edges, queries): dist = floyd_warshall(n, edges) results = [] for a, b in queries: result = dist[a-1][b-1] if dist[a-1][b-1] != float('inf') else -1 results.append(result) return results"},{"question":"class ArrayManipulator: def __init__(self, array): self.array = array def range_sum(self, L, R): Returns the sum of the subarray from index L to index R (1-based). pass def update_value(self, X, V): Updates the element at index X (1-based) to the new value V. pass # Example usage: # obj = ArrayManipulator([1, 2, 3, 4, 5]) # print(obj.range_sum(1, 3)) # Should return the sum of elements from index 1 to 3 # obj.update_value(2, 10) # print(obj.range_sum(1, 3)) # Should return the updated sum of elements from index 1 to 3 # Unit Tests: def test_range_sum_initial(): obj = ArrayManipulator([1, 2, 3, 4, 5]) assert obj.range_sum(1, 3) == 6 def test_update_value_and_range_sum(): obj = ArrayManipulator([1, 2, 3, 4, 5]) obj.update_value(2, 10) assert obj.range_sum(1, 3) == 14 def test_range_sum_full(): obj = ArrayManipulator([1, 2, 3, 4, 5]) assert obj.range_sum(1, 5) == 15 def test_multiple_updates(): obj = ArrayManipulator([1, 2, 3, 4, 5]) obj.update_value(2, 10) obj.update_value(3, 15) assert obj.range_sum(1, 5) == 35 def test_range_sum_after_updates(): obj = ArrayManipulator([1, 2, 3, 4, 5]) obj.update_value(2, 10) obj.update_value(3, 15) assert obj.range_sum(3, 4) == 19","solution":"class ArrayManipulator: def __init__(self, array): self.array = array def range_sum(self, L, R): Returns the sum of the subarray from index L to index R (1-based). return sum(self.array[L-1:R]) def update_value(self, X, V): Updates the element at index X (1-based) to the new value V. self.array[X-1] = V # Example usage: # obj = ArrayManipulator([1, 2, 3, 4, 5]) # print(obj.range_sum(1, 3)) # Should return 6 # obj.update_value(2, 10) # print(obj.range_sum(1, 3)) # Should return 14"},{"question":"def min_shelves(n: int, m: int) -> int: Determine the minimum number of shelves needed to organize all the books under the given constraints. Args: n (int): The total number of books. m (int): The maximum number of books that can be placed on a single shelf. Returns: int: The minimum number of shelves required, or -1 if it is not possible to organize the books. Examples: >>> min_shelves(10, 3) 4 >>> min_shelves(5, 5) 1 >>> min_shelves(23, 4) 6 Unit test: from solution import min_shelves def test_example_cases(): assert min_shelves(10, 3) == 4 assert min_shelves(5, 5) == 1 assert min_shelves(23, 4) == 6 def test_edge_cases(): assert min_shelves(1, 1) == 1 assert min_shelves(100000, 100) == 1000 def test_invalid_cases(): assert min_shelves(10, 0) == -1 assert min_shelves(10, -1) == -1 def test_general_cases(): assert min_shelves(50, 5) == 10 assert min_shelves(12345, 100) == 124 def test_large_number_of_books(): assert min_shelves(999999, 100) == 10000","solution":"def min_shelves(n, m): if m <= 0: return -1 # Calculate minimum number of shelves needed shelves_needed = (n + m - 1) // m return shelves_needed"},{"question":"from typing import List, Tuple def simplify_fraction(numerator: int, denominator: int) -> Tuple[int, int]: Simplifies the fraction by dividing the numerator and denominator by their greatest common divisor (GCD). >>> simplify_fraction(4, 6) (2, 3) >>> simplify_fraction(2, 4) (1, 2) pass def are_equivalent(rational1: str, rational2: str) -> bool: Determines if two rational numbers given as strings are equivalent. >>> are_equivalent(\\"4/6\\", \\"2/3\\") True >>> are_equivalent(\\"1/2\\", \\"2/3\\") False pass def check_equivalence(test_cases: List[Tuple[str, str]]) -> List[str]: For each pair in test_cases, determine if the two rational numbers are equivalent. >>> check_equivalence([(\\"4/6\\", \\"2/3\\"), (\\"1/2\\", \\"2/3\\"), (\\"6/8\\", \\"3/4\\")]) ['Yes', 'No', 'Yes'] >>> check_equivalence([(\\"10/25\\", \\"2/5\\"), (\\"5/25\\", \\"1/5\\")]) ['Yes', 'Yes'] pass","solution":"from math import gcd def simplify_fraction(numerator, denominator): Simplifies the fraction by dividing the numerator and denominator by their greatest common divisor (GCD). common_divisor = gcd(numerator, denominator) return numerator // common_divisor, denominator // common_divisor def are_equivalent(rational1, rational2): Determines if two rational numbers given as strings are equivalent. num1, denom1 = map(int, rational1.split('/')) num2, denom2 = map(int, rational2.split('/')) # Simplify both fractions simplified_r1 = simplify_fraction(num1, denom1) simplified_r2 = simplify_fraction(num2, denom2) # Check if simplified fractions are the same return simplified_r1 == simplified_r2 def check_equivalence(test_cases): For each pair in test_cases, determine if the two rational numbers are equivalent. results = [] for rational1, rational2 in test_cases: if are_equivalent(rational1, rational2): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def minimum_irrigated_meters(m: int, n: int) -> int: Determine the minimum number of meters that need to be directly irrigated from the water source located at the top-left corner of a rectangular farm of dimensions m x n. Input: - m: int - the number of meters in the rows of the farm (1 ≤ m ≤ 1000) - n: int - the number of meters in the columns of the farm (1 ≤ n ≤ 1000) Output: - int - the minimum number of meters that need to be directly irrigated from the source Examples: >>> minimum_irrigated_meters(3, 3) 1 >>> minimum_irrigated_meters(1, 5) 1 >>> minimum_irrigated_meters(4, 7) 1","solution":"def minimum_irrigated_meters(m, n): Returns the minimum number of meters that need to be directly irrigated from the water source so that the entire farm is covered. The farm is a rectangular grid of size m x n. return 1"},{"question":"def optimal_game_winner(n: int) -> str: Determines if Alice has a winning strategy given the starting number n. :param n: int - starting number of the game :return: str - \\"Alice\\" if Alice can ensure a win, \\"Bob\\" otherwise >>> optimal_game_winner(10) \\"Alice\\" >>> optimal_game_winner(12) \\"Bob\\" >>> optimal_game_winner(15) \\"Alice\\"","solution":"def optimal_game_winner(n): Determines if Alice has a winning strategy given the starting number n. :param n: int - starting number of the game :return: str - \\"Alice\\" if Alice can ensure a win, \\"Bob\\" otherwise # If n is odd, Alice plays first and can only make it even for Bob's turn # In this case, Alice will always win because she will continue to ensure # Bob gets an odd number eventually leading to 1 and Bob losing # If n is even, Bob can mimic Alice's play each turn until n becomes odd if n % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def categorize_users(users): Categorizes users based on their age into three groups: \\"Child\\", \\"Adult\\", \\"Senior\\". Args: users (list): A list of dictionaries, where each dictionary represents a user record with keys \\"id\\", \\"name\\", and \\"age\\". Returns: dict: A dictionary with three keys: \\"Child\\", \\"Adult\\", \\"Senior\\". Each key maps to a list of user records sorted by their 'id' in ascending order. pass # Unit tests def test_categorize_users_all_categories(): input_users = [ {\\"id\\": 2, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"age\\": 12}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 65} ] expected_output = { \\"Child\\": [{\\"id\\": 1, \\"name\\": \\"Bob\\", \\"age\\": 12}], \\"Adult\\": [{\\"id\\": 2, \\"name\\": \\"Alice\\", \\"age\\": 30}], \\"Senior\\": [{\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 65}] } assert categorize_users(input_users) == expected_output def test_categorize_users_single_category_child(): input_users = [ {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"age\\": 12}, {\\"id\\": 4, \\"name\\": \\"Danny\\", \\"age\\": 7} ] expected_output = { \\"Child\\": [ {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"age\\": 12}, {\\"id\\": 4, \\"name\\": \\"Danny\\", \\"age\\": 7} ], \\"Adult\\": [], \\"Senior\\": [] } assert categorize_users(input_users) == expected_output def test_categorize_users_single_category_adult(): input_users = [ {\\"id\\": 2, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"age\\": 25} ] expected_output = { \\"Child\\": [], \\"Adult\\": [ {\\"id\\": 2, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"age\\": 25} ], \\"Senior\\": [] } assert categorize_users(input_users) == expected_output def test_categorize_users_single_category_senior(): input_users = [ {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 65}, {\\"id\\": 6, \\"name\\": \\"Frank\\", \\"age\\": 70} ] expected_output = { \\"Child\\": [], \\"Adult\\": [], \\"Senior\\": [ {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 65}, {\\"id\\": 6, \\"name\\": \\"Frank\\", \\"age\\": 70} ] } assert categorize_users(input_users) == expected_output def test_categorize_users_mixed_ages(): input_users = [ {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"age\\": 12}, {\\"id\\": 2, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 70}, {\\"id\\": 4, \\"name\\": \\"Danny\\", \\"age\\": 7}, {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"age\\": 65}, {\\"id\\": 6, \\"name\\": \\"Frank\\", \\"age\\": 25} ] expected_output = { \\"Child\\": [ {\\"id\\": 1, \\"name\\": \\"Bob\\", \\"age\\": 12}, {\\"id\\": 4, \\"name\\": \\"Danny\\", \\"age\\": 7} ], \\"Adult\\": [ {\\"id\\": 2, \\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"id\\": 6, \\"name\\": \\"Frank\\", \\"age\\": 25} ], \\"Senior\\": [ {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 70}, {\\"id\\": 5, \\"name\\": \\"Eve\\", \\"age\\": 65} ] } assert categorize_users(input_users) == expected_output def test_categorize_users_empty_input(): input_users = [] expected_output = { \\"Child\\": [], \\"Adult\\": [], \\"Senior\\": [] } assert categorize_users(input_users) == expected_output","solution":"def categorize_users(users): Categorizes users based on their age into three groups: \\"Child\\", \\"Adult\\", \\"Senior\\". Args: users (list): A list of dictionaries, where each dictionary represents a user record with keys \\"id\\", \\"name\\", and \\"age\\". Returns: dict: A dictionary with three keys: \\"Child\\", \\"Adult\\", \\"Senior\\". Each key maps to a list of user records sorted by their 'id' in ascending order. categories = {\\"Child\\": [], \\"Adult\\": [], \\"Senior\\": []} for user in users: if user[\\"age\\"] >= 0 and user[\\"age\\"] <= 17: categories[\\"Child\\"].append(user) elif user[\\"age\\"] >= 18 and user[\\"age\\"] <= 64: categories[\\"Adult\\"].append(user) elif user[\\"age\\"] >= 65: categories[\\"Senior\\"].append(user) for category in categories: categories[category] = sorted(categories[category], key=lambda x: x['id']) return categories"},{"question":"def generate_parentheses(n: int) -> List[str]: Given an integer n, find all the combinations of well-formed parentheses (round brackets) of length 2n. A well-formed parentheses means that for every opening bracket '(', there is a corresponding closing bracket ')', and the sequence is balanced such that at no point do the closing brackets exceed the opening brackets. >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] The output list should have combinations of well-formed parentheses in lexicographical order.","solution":"def generate_parentheses(n): Generate all combinations of well-formed parentheses of length 2n. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: combinations.append(s) return if left < n: backtrack(s+'(', left+1, right) if right < left: backtrack(s+')', left, right+1) combinations = [] backtrack() return combinations"},{"question":"from typing import List, Tuple def min_operations_to_transform(s1: str, s2: str) -> int: Returns the minimum number of operations required to transform s1 into s2. >>> min_operations_to_transform(\\"horse\\", \\"ros\\") 3 >>> min_operations_to_transform(\\"intention\\", \\"execution\\") 5 >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"\\", \\"a\\") 1 >>> min_operations_to_transform(\\"abc\\", \\"\\") 3 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"abcdef\\", \\"azced\\") 3 def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[int]: Processes multiple test cases and returns the results. >>> process_test_cases([(\\"horse\\", \\"ros\\"), (\\"intention\\", \\"execution\\"), (\\"kitten\\", \\"sitting\\")]) [3, 5, 3]","solution":"def min_operations_to_transform(s1, s2): Returns the minimum number of operations required to transform s1 into s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[m][n] def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for s1, s2 in test_cases: result = min_operations_to_transform(s1, s2) results.append(result) return results"},{"question":"def compress_list(n: int, lst: List[int]) -> str: Compresses a list by counting occurrences of each integer and outputting them in the order of their first appearance. Parameters: n (int): The number of integers in the list. lst (list): The list of integers. Returns: str: The compressed representation of the list. Examples: >>> compress_list(7, [2, 2, 1, 3, 3, 3, 4]) '2 appears 2 times, 1 appears 1 time, 3 appears 3 times, 4 appears 1 time' >>> compress_list(5, [-1, -1, 2, 2, 2]) '-1 appears 2 times, 2 appears 3 times' from solution import compress_list def test_compress_list_single_element(): assert compress_list(1, [5]) == \\"5 appears 1 time\\" def test_compress_list_multiple_elements(): assert compress_list(7, [2, 2, 1, 3, 3, 3, 4]) == \\"2 appears 2 times, 1 appears 1 time, 3 appears 3 times, 4 appears 1 time\\" def test_compress_list_with_negative_numbers(): assert compress_list(5, [-1, -1, 2, 2, 2]) == \\"-1 appears 2 times, 2 appears 3 times\\" def test_compress_list_no_repetition(): assert compress_list(4, [7, 8, 9, 10]) == \\"7 appears 1 time, 8 appears 1 time, 9 appears 1 time, 10 appears 1 time\\" def test_compress_list_all_same_elements(): assert compress_list(4, [3, 3, 3, 3]) == \\"3 appears 4 times\\" def test_compress_list_mixed_elements(): assert compress_list(6, [0, 2, 0, -2, 2, -2]) == \\"0 appears 2 times, 2 appears 2 times, -2 appears 2 times\\" def test_compress_list_zero_elements(): assert compress_list(0, []) == \\"\\"","solution":"def compress_list(n, lst): Compresses a list by counting occurrences of each integer and outputting them in the order of their first appearance. Parameters: n (int): The number of integers in the list. lst (list): The list of integers. Returns: str: The compressed representation of the list. from collections import OrderedDict count_dict = OrderedDict() for num in lst: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 result = [] for key, value in count_dict.items(): result.append(f\\"{key} appears {value} {'times' if value > 1 else 'time'}\\") return \\", \\".join(result)"},{"question":"def longest_message_sequence(N: int, M: int, messages: List[Tuple[int, int, int, int]]) -> int: Find the longest sequence of messages such that for any two consecutive messages in the sequence, they are sent between the same pair of users in either direction with strictly increasing timestamps. Parameters: N (int): The number of users. M (int): The number of messages. messages (List[Tuple[int, int, int, int]]): A list of messages where each message is represented as a tuple of four integers - message_id, timestamp, sender_id, receiver_id. Returns: int: The length of the longest sequence of messages. Examples: >>> longest_message_sequence(5, 8, [(1, 1, 1, 2), (2, 2, 2, 1), (3, 3, 1, 2), (4, 4, 3, 2), (5, 5, 2, 3), (6, 6, 1, 3), (7, 7, 3, 1), (8, 8, 2, 3)]) 3 >>> longest_message_sequence(5, 0, []) 0 >>> longest_message_sequence(2, 1, [(1, 1, 1, 2)]) 1 >>> longest_message_sequence(4, 4, [(1, 1, 1, 2), (2, 2, 2, 1), (3, 3, 3, 4), (4, 4, 4, 3)]) 2 >>> longest_message_sequence(3, 5, [(1, 1, 1, 2), (2, 2, 2, 1), (3, 3, 1, 2), (4, 4, 2, 1), (5, 10, 3, 1)]) 4","solution":"def longest_message_sequence(N, M, messages): from collections import defaultdict # Create a dictionary holding lists of messages for each user pair user_pairs = defaultdict(list) for message_id, timestamp, sender_id, receiver_id in messages: pair = tuple(sorted([sender_id, receiver_id])) user_pairs[pair].append((timestamp, sender_id, receiver_id, message_id)) def find_longest_sequence_for_pair(messages_list): messages_list.sort() dp = [1] * len(messages_list) for i in range(1, len(messages_list)): for j in range(i): if messages_list[i][0] > messages_list[j][0]: dp[i] = max(dp[i], dp[j] + 1) return max(dp, default=0) max_sequence_length = 0 for pair, msgs in user_pairs.items(): max_sequence_length = max(max_sequence_length, find_longest_sequence_for_pair(msgs)) return max_sequence_length # Example usage # N = 5 # M = 8 # messages = [ # (1, 1, 1, 2), # (2, 2, 2, 1), # (3, 3, 1, 2), # (4, 4, 3, 2), # (5, 5, 2, 3), # (6, 6, 1, 3), # (7, 7, 3, 1), # (8, 8, 2, 3) # ] # print(longest_message_sequence(N, M, messages)) # Output should be 3"},{"question":"from typing import List def min_coins(amount: int) -> int: Returns the minimum number of coins needed to make up the given amount. Denominations are 1, 5, 10, and 25 cents. >>> min_coins(23) == 5 >>> min_coins(50) == 2 >>> min_coins(75) == 3 >>> min_coins(0) == 0 >>> min_coins(1) == 1 >>> min_coins(99) == 9 pass def process_input(input_list: List[int]) -> List[str]: Takes a list of amounts in cents and returns the minimum number of coins needed for each amount in the form \\"MIN amount\\". The input ends when the amount is zero. >>> process_input([23, 50, 75, 0]) == [\\"5 23\\", \\"2 50\\", \\"3 75\\"] >>> process_input([1, 10, 100, 0]) == [\\"1 1\\", \\"1 10\\", \\"4 100\\"] >>> process_input([0]) == [] >>> process_input([5, 0]) == [\\"1 5\\"] >>> process_input([10000, 0]) == [\\"400 10000\\"] pass","solution":"def min_coins(amount): Returns the minimum number of coins needed to make up the given amount. Denominations are 1, 5, 10, and 25 cents. coins = [25, 10, 5, 1] count = 0 remaining_amount = amount for coin in coins: count += remaining_amount // coin remaining_amount %= coin return count def process_input(input_list): results = [] for amount in input_list: if amount == 0: break min_coins_needed = min_coins(amount) results.append(f\\"{min_coins_needed} {amount}\\") return results"},{"question":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: Calculate the minimum path sum in a given NxN matrix from top left to bottom right. You can only move right or down from any cell. >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21 >>> min_path_sum([ ... [1, 2], ... [1, 1] ... ]) == 3 >>> min_path_sum([ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]) == -29 >>> min_path_sum([ ... [0] ... ]) == 0 >>> min_path_sum([ ... [5, 5, 5], ... [5, 5, 5], ... [5, 5, 5] ... ]) == 25","solution":"from typing import List def min_path_sum(matrix: List[List[int]]) -> int: Calculate the minimum path sum in a given NxN matrix from top left to bottom right. You can only move right or down from any cell. N = len(matrix) # Initialize a 2D dp array to store the minimum path sum up to each point dp = [[0]*N for _ in range(N)] # Base case: starting point dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, N): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, N): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of dp table for i in range(1, N): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[N-1][N-1]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: Determine the maximum depth of a binary tree. The maximum depth is the number of nodes along the longest path from the root node to the farthest leaf node. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> max_depth(root) 3 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> max_depth(root) 2","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(1) False >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False def sum_primes_in_range(a: int, b: int) -> int: Calculate the sum of prime numbers in a given range [a, b] inclusive. >>> sum_primes_in_range(1, 10) 17 >>> sum_primes_in_range(10, 20) 60 >>> sum_primes_in_range(20, 30) 52 >>> sum_primes_in_range(1, 2) 2 >>> sum_primes_in_range(1, 1) 0 def solve_primes_sum(test_cases: List[Tuple[int, int]]) -> List[int]: Given multiple test cases, calculate the sum of prime numbers in the specified range for each test case. >>> solve_primes_sum([(1, 10), (10, 20), (20, 30), (1, 2), (1, 1)]) [17, 60, 52, 2, 0] from typing import List, Tuple import unittest class TestPrimeSum(unittest.TestCase): def test_is_prime(self): self.assertFalse(is_prime(1)) self.assertTrue(is_prime(2)) self.assertTrue(is_prime(3)) self.assertFalse(is_prime(4)) self.assertTrue(is_prime(17)) self.assertFalse(is_prime(18)) def test_sum_primes_in_range(self): self.assertEqual(sum_primes_in_range(1, 10), 17) self.assertEqual(sum_primes_in_range(10, 20), 60) self.assertEqual(sum_primes_in_range(20, 30), 52) self.assertEqual(sum_primes_in_range(1, 2), 2) self.assertEqual(sum_primes_in_range(1, 1), 0) def test_solve_primes_sum(self): test_cases = [(1, 10), (10, 20), (20, 30), (1, 2), (1, 1)] expected = [17, 60, 52, 2, 0] self.assertEqual(solve_primes_sum(test_cases), expected) if __name__ == \\"__main__\\": unittest.main()","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_primes_in_range(a, b): prime_sum = 0 for num in range(a, b + 1): if is_prime(num): prime_sum += num return prime_sum def solve_primes_sum(test_cases): results = [] for a, b in test_cases: results.append(sum_primes_in_range(a, b)) return results"},{"question":"def longest_common_subsequence(seq1, seq2): Given two sequences, find the length of the longest common subsequence (LCS). A subsequence is derived by deleting some or no elements from a sequence without changing the order of the remaining elements. Args: seq1 (list of int): The first sequence. seq2 (list of int): The second sequence. Returns: int: The length of the longest common subsequence. Examples: >>> longest_common_subsequence([1, 2, 3, 4, 5], [2, 4, 6, 1, 3, 5]) 3 >>> longest_common_subsequence([7, 8, 9], [10, 11, 12]) 0","solution":"def longest_common_subsequence(seq1, seq2): n = len(seq1) m = len(seq2) # Create a dp array with (n+1) x (m+1) dimensions initialized to 0 dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if seq1[i - 1] == seq2[j - 1]: # If elements match, take diagonal value + 1 dp[i][j] = dp[i - 1][j - 1] + 1 else: # If not, take the maximum of the left and top values dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The value at the bottom-right corner will be the length of the LCS return dp[n][m]"},{"question":"def can_form_strictly_increasing_sequence(t: int, test_cases: List[List[int]]) -> List[str]: Determines if it is possible to rearrange a sequence such that it forms a strictly increasing sequence. Args: t (int): The number of test cases. test_cases (List[List[int]]): A list of test cases, each containing a sequence of integers. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_form_strictly_increasing_sequence(1, [[5, 1, 3, 2, 4]]) [\\"YES\\"] >>> can_form_strictly_increasing_sequence(1, [[4, 4, 4, 4]]) [\\"NO\\"] >>> can_form_strictly_increasing_sequence(4, [ ... [5, 1, 3, 2, 4], ... [4, 4, 4, 4], ... [1, 2, 2], ... [6, 5, 4, 3, 2, 1] ... ]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_strictly_increasing_sequence(t, test_cases): results = [] for seq in test_cases: if len(seq) == len(set(seq)): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_subset_diff(arr: List[int]) -> int: Given an array of integers, partition the array into two subsets such that the difference of their sums is minimized. Args: arr (List[int]): List of integers to partition. Returns: int: The minimum difference possible between the sums of the two subsets. Examples: >>> min_subset_diff([3, 1, 4, 2, 2, 1]) 1 >>> min_subset_diff([1, 2, 3, 9]) 3 def test_min_subset_diff_example1(): assert min_subset_diff([3, 1, 4, 2, 2, 1]) == 1 def test_min_subset_diff_example2(): assert min_subset_diff([1, 2, 3, 9]) == 3 def test_min_subset_diff_single_element(): assert min_subset_diff([20]) == 20 def test_min_subset_diff_two_elements(): assert min_subset_diff([10, 10]) == 0 assert min_subset_diff([14, 7]) == 7 def test_min_subset_diff_large_elements(): assert min_subset_diff([100000, 1, 2, 3, 4]) == 99990 def test_min_subset_diff_equal_splits(): assert min_subset_diff([1, 2, 3, 4, 5, 6]) == 1 assert min_subset_diff([5, 5, 5, 5]) == 0","solution":"def min_subset_diff(arr): Returns the minimum difference possible between the sums of two subsets of arr. total_sum = sum(arr) n = len(arr) half_sum = total_sum // 2 dp = [[False] * (half_sum + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(0, half_sum + 1): if j >= arr[i-1]: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] for j in range(half_sum, -1, -1): if dp[n][j]: return (total_sum - 2*j) return total_sum # In worst case, the total sum difference is the total sum itself"},{"question":"from typing import List, Tuple def min_removal_to_acyclic(n: int, m: int, edges: List[Tuple[int, int]]) -> int: This function returns the minimum number of edges to remove to ensure no cycles exist in the graph defined by \`n\` nodes and \`edges\` connections. Parameters: n (int): number of locations m (int): number of clues edges (List[Tuple[int, int]]): list of edges representing the clues Returns: int: minimum number of edges to remove to remove cycles pass # Unit Tests def test_example_1(): n = 4 m = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 2)] assert min_removal_to_acyclic(n, m, edges) == 1 def test_example_2(): n = 5 m = 3 edges = [(1, 2), (2, 3), (3, 4)] assert min_removal_to_acyclic(n, m, edges) == 0 def test_small_graph_no_cycle(): n = 3 m = 2 edges = [(1, 2), (2, 3)] assert min_removal_to_acyclic(n, m, edges) == 0 def test_self_loop(): n = 2 m = 1 edges = [(1, 1)] assert min_removal_to_acyclic(n, m, edges) == 1 def test_large_graph_with_multiple_cycles(): n = 6 m = 7 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4), (3, 4)] assert min_removal_to_acyclic(n, m, edges) == 2","solution":"from collections import defaultdict def min_removal_to_acyclic(n, m, edges): This function returns the minimum number of edges to remove to ensure no cycles exist in the graph defined by \`n\` nodes and \`edges\` connections. Parameters: n (int): number of locations m (int): number of clues edges (List[Tuple[int, int]]): list of edges representing the clues Returns: int: minimum number of edges to remove to remove cycles # Step 1: Represent the graph using adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Step 2: Detect cycles using DFS and a stack for the current path def dfs(v, visited, rec_stack): visited[v] = True rec_stack[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False visited = [False] * (n + 1) rec_stack = [False] * (n + 1) cycles = 0 for node in range(1, n + 1): if not visited[node]: if dfs(node, visited, rec_stack): cycles += 1 return cycles"},{"question":"from typing import List def find_smallest_greater_than(arr: List[int], x: int) -> int: Find the smallest number in \`arr\` that is greater than \`x\`. If no such number exists, return -1. >>> find_smallest_greater_than([1, 3, 5, 7, 9], 4) == 5 >>> find_smallest_greater_than([1, 3, 5, 7, 9], 10) == -1 >>> find_smallest_greater_than([1, 3, 5, 7, 9], 0) == 1 def process_queries(arr: List[int], queries: List[int]) -> List[int]: Process a list of queries to find the smallest number in \`arr\` that is greater than each element in \`queries\`. >>> process_queries([1, 3, 5, 7, 9], [4, 10, 0]) == [5, -1, 1] >>> process_queries([1, 3, 5, 7, 9], [2, 6, 8, 0]) == [3, 7, 9, 1] >>> process_queries([1, 3, 5, 7, 9], [1, 7, 3, 9]) == [3, 9, 5, -1]","solution":"def find_smallest_greater_than(arr, x): Find the smallest number in \`arr\` that is greater than \`x\`. If no such number exists, return -1. from bisect import bisect_right idx = bisect_right(arr, x) if idx < len(arr): return arr[idx] else: return -1 def process_queries(arr, queries): Process a list of queries to find the smallest number in \`arr\` that is greater than each element in \`queries\`. results = [] for q in queries: results.append(find_smallest_greater_than(arr, q)) return results"},{"question":"def min_meeting_rooms(n, m, requests): Determines the minimum number of meeting rooms required to accommodate all the meeting requests or returns -1 if the available rooms are not enough. :param n: The number of available meeting rooms. :param m: The number of meeting requests. :param requests: List of tuples - Each tuple represents a meeting request with start and end times. :return: int - The minimum number of meeting rooms required or -1 if not all requests can be accommodated. >>> min_meeting_rooms(2, 3, [(1, 5), (6, 10), (2, 8)]) == 2 >>> min_meeting_rooms(3, 2, [(1, 3), (2, 6)]) == 2 def solve(T, test_cases): Processes multiple test cases to determine the required number of meeting rooms for each case. :param T: The number of test cases. :param test_cases: List of test cases, each containing the number of rooms, number of requests, and the requests themselves. :return: List of results for each test case, indicating the minimum number of meeting rooms required or -1 if not possible. >>> solve(3, [(2, 3, [(1, 5), (6, 10), (2, 8)]), (3, 2, [(1, 3), (2, 6)]), (4, 4, [(2, 5), (9, 12), (5, 9), (3, 8)])]) == [2, 2, 3]","solution":"def min_meeting_rooms(n, m, requests): Determines the minimum number of meeting rooms required to accommodate all the meeting requests or returns -1 if the available rooms are not enough. :param n: int - The number of available meeting rooms. :param m: int - The number of meeting requests. :param requests: List of tuples - Each tuple represents a meeting request with start and end times. :return: int - The minimum number of meeting rooms required or -1 if not all requests can be accommodated. # Flatten the list of requests and distinguish between start and end times times = [] for start, end in requests: times.append((start, 'start')) times.append((end, 'end')) # Sort the timings times.sort(key=lambda x: (x[0], x[1] == 'end')) required_rooms = 0 max_rooms = 0 for time, type in times: if type == 'start': required_rooms += 1 max_rooms = max(max_rooms, required_rooms) else: required_rooms -= 1 if max_rooms > n: return -1 return max_rooms def solve(T, test_cases): results = [] for i in range(T): n, m, requests = test_cases[i] results.append(min_meeting_rooms(n, m, requests)) return results"},{"question":"def competition_tracker(n: int, Q: int, queries: List[Tuple[int, int]]) -> List[int]: Tracks the matches and responds to the queries in a competition involving n participants and Q queries. The queries can be of two types: 1. \`1 p\`: Record participation of the p-th participant in a new match. 2. \`2 p\`: Output the current score of the p-th participant. Args: n (int): Number of participants. Q (int): Number of queries. queries (List[Tuple[int, int]]): List of queries. Returns: List[int]: Results of type 2 queries. from solution import competition_tracker def test_competition_tracker_case1(): n, Q = 5, 7 queries = [(1, 3), (1, 1), (1, 2), (2, 2), (1, 2), (2, 2), (2, 3)] assert competition_tracker(n, Q, queries) == [1, 2, 1] def test_competition_tracker_case2(): n, Q = 3, 5 queries = [(1, 1), (1, 1), (2, 1), (2, 2), (1, 2)] assert competition_tracker(n, Q, queries) == [2, 0] def test_competition_tracker_case3(): n, Q = 4, 6 queries = [(1, 4), (2, 4), (1, 4), (2, 4), (1, 3), (2, 3)] assert competition_tracker(n, Q, queries) == [1, 2, 1] def test_competition_tracker_case4(): n, Q = 2, 4 queries = [(1, 2), (1, 2), (2, 2), (2, 1)] assert competition_tracker(n, Q, queries) == [2, 0] def test_competition_tracker_case5(): n, Q = 1, 3 queries = [(1, 1), (2, 1), (1, 1)] assert competition_tracker(n, Q, queries) == [1]","solution":"def competition_tracker(n, Q, queries): # Initialize scores for all participants to zero scores = [0] * (n + 1) results = [] for query in queries: typei, pi = query if typei == 1: # Record participation scores[pi] += 1 elif typei == 2: # Output the current score results.append(scores[pi]) return results"},{"question":"def is_valid_parentheses_sequence(n: int, operations: str) -> str: Determine if the given sequence of operations results in a valid parentheses string. >>> is_valid_parentheses_sequence(6, '((()))') 'valid' >>> is_valid_parentheses_sequence(6, '())(()') 'invalid' >>> is_valid_parentheses_sequence(10, '()()()()()') 'valid' >>> is_valid_parentheses_sequence(6, ')()()(') 'invalid' >>> is_valid_parentheses_sequence(3, '(((') 'invalid' >>> is_valid_parentheses_sequence(0, '') 'valid'","solution":"def is_valid_parentheses_sequence(n, operations): Determine if the given sequence of operations results in a valid parentheses string. :param n: int, the number of operations. :param operations: str, the sequence of operations containing '(' and ')'. :return: str, \\"valid\\" or \\"invalid\\" based on whether the sequence is valid. balance = 0 for op in operations: if op == '(': balance += 1 elif op == ')': balance -= 1 if balance < 0: return \\"invalid\\" return \\"valid\\" if balance == 0 else \\"invalid\\""},{"question":"def can_partition(nums: List[int]) -> str: Determines if the array can be partitioned into two subarrays with equal sum. Parameters: nums: List[int] - An array of integers. Returns: str - \\"YES\\" if the partition is possible, \\"NO\\" otherwise. Examples: >>> can_partition([1, 5, 11, 5]) 'YES' >>> can_partition([1, 2, 3, 5, 4]) 'NO' from typing import List def test_can_partition_example1(): nums = [1, 5, 11, 5] assert can_partition(nums) == \\"YES\\" def test_can_partition_example2(): nums = [1, 2, 3, 5, 4] assert can_partition(nums) == \\"NO\\" def test_can_partition_single_element(): nums = [1] assert can_partition(nums) == \\"NO\\" def test_can_partition_two_elements(): nums = [1, 1] assert can_partition(nums) == \\"YES\\" def test_can_partition_equal_elements(): nums = [2, 2, 2, 2] assert can_partition(nums) == \\"YES\\" def test_can_partition_no_partition(): nums = [1, 2, 3, 8] assert can_partition(nums) == \\"NO\\" def test_can_partition_large_equal(): nums = [50, 50] assert can_partition(nums) == \\"YES\\" def test_can_partition_large_non_partition(): nums = [50, 50, 1] assert can_partition(nums) == \\"NO\\"","solution":"def can_partition(nums): Determines if the array can be partitioned into two subarrays with equal sum. :param nums: List[int] - an array of integers :return: str - \\"YES\\" if the partition is possible, \\"NO\\" otherwise. total_sum = sum(nums) # If the sum is odd, it's impossible to partition into two equal subarrays if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 n = len(nums) # Using dynamic programming to check if we can form the target sum dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return \\"YES\\" if dp[target] else \\"NO\\""}]`),A={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},C={class:"card-container"},D={key:0,class:"empty-state"},z=["disabled"],O={key:0},P={key:1};function I(i,e,u,c,r,a){const p=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(s(!0),n(y,null,x(a.displayedPoems,(o,f)=>(s(),v(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",D,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",P,"Loading...")):(s(),n("span",O,"See more"))],8,z)):l("",!0)])}const Y=m(A,[["render",I],["__scopeId","data-v-cb22e815"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/20.md","filePath":"guide/20.md"}'),F={name:"guide/20.md"},G=Object.assign(F,{setup(i){return(e,u)=>(s(),n("div",null,[w(Y)]))}});export{M as __pageData,G as default};
