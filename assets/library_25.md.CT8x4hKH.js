import{_,o as r,c as n,a as t,m,t as d,C as g,M as p,U as b,f as l,F as x,p as y,e as w,q as v}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function R(s,e,u,h,i,a){return r(),n("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(u.poem.solution),1)])])])}const j=_(k,[["render",R],["__scopeId","data-v-36ba0357"]]),A=JSON.parse(`[{"question":"def min_traversal_cost(grid: List[List[int]]) -> int: Given a square grid of size n x n where each cell contains a positive integer representing the cost to traverse through that cell, return the minimum cost to traverse from the top-left corner to the bottom-right corner, moving only right or down. >>> min_traversal_cost([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 21 >>> min_traversal_cost([ ... [5] ... ]) 5 >>> min_traversal_cost([ ... [1, 2], ... [3, 4] ... ]) 7 >>> min_traversal_cost([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 >>> min_traversal_cost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7","solution":"def min_traversal_cost(grid): Given a square grid of size n x n where each cell contains a positive integer representing the cost to traverse through that cell, return the minimum cost to traverse from the top-left corner to the bottom-right corner, moving only right or down. n = len(grid) if n == 0: return 0 # Create a 2D list to store the cost of reaching each cell cost = [[0] * n for _ in range(n)] # Initialize the cost of the top-left cell cost[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): cost[0][j] = cost[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, n): cost[i][0] = cost[i - 1][0] + grid[i][0] # Fill in the rest of the cost grid for i in range(1, n): for j in range(1, n): cost[i][j] = min(cost[i - 1][j], cost[i][j - 1]) + grid[i][j] # Return the cost of the bottom-right cell return cost[n - 1][n - 1]"},{"question":"def longestPalindrome(s: str) -> str: Return the longest palindromic substring in s. A palindrome is a string that reads the same backward as forward. Args: s (str): A string consisting of lower-case and/or upper-case English letters. Returns: str: The longest palindromic substring of the input string. Examples: >>> longestPalindrome(\\"a\\") \\"a\\" >>> longestPalindrome(\\"aa\\") \\"aa\\" >>> longestPalindrome(\\"abc\\") \\"a\\" # or 'b' or 'c' >>> longestPalindrome(\\"babad\\") \\"bab\\" # or \\"aba\\" >>> longestPalindrome(\\"cbbd\\") \\"bb\\" >>> longestPalindrome(\\"racecar\\") \\"racecar\\" >>> longestPalindrome(\\"abbd\\") \\"bb\\" >>> longestPalindrome(\\"AbaB\\") \\"A\\" # or 'B' or 'a' or 'b' or \\"aba\\" >>> longestPalindrome(\\"\\") \\"\\"","solution":"def longestPalindrome(s): Returns the longest palindromic substring in s. if not s: return \\"\\" start, end = 0, 0 def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 for i in range(len(s)): l1, r1 = expand_around_center(i, i) # odd length palindrome l2, r2 = expand_around_center(i, i + 1) # even length palindrome if r1 - l1 > end - start: start, end = l1, r1 if r2 - l2 > end - start: start, end = l2, r2 return s[start:end + 1]"},{"question":"import re def is_strong_password(password: str) -> bool: Returns True if the given password is strong, otherwise False. A password is considered strong if: 1. It has at least 8 characters. 2. It contains at least one lowercase letter. 3. It contains at least one uppercase letter. 4. It contains at least one digit. 5. It contains at least one special character (!@#%^&*()-+). >>> is_strong_password(\\"Abcdef1@\\") == True >>> is_strong_password(\\"StrongPass123!\\") == True >>> is_strong_password(\\"Ab1@\\") == False >>> is_strong_password(\\"ABCDEFG1@\\") == False >>> is_strong_password(\\"abcdefg1@\\") == False >>> is_strong_password(\\"Abcdefg@\\") == False >>> is_strong_password(\\"Abcdefg1\\") == False >>> is_strong_password(\\"\\") == False >>> is_strong_password(\\"!@#%^&*()-+\\") == False","solution":"import re def is_strong_password(password): Returns True if the given password is strong, otherwise False. A password is considered strong if: 1. It has at least 8 characters. 2. It contains at least one lowercase letter. 3. It contains at least one uppercase letter. 4. It contains at least one digit. 5. It contains at least one special character (!@#%^&*()-+). if len(password) < 8: return False if not re.search(r'[a-z]', password): return False if not re.search(r'[A-Z]', password): return False if not re.search(r'd', password): return False if not re.search(r'[!@#%^&*()-+]', password): return False return True"},{"question":"def count_missing_numbers(nums): Given a list of integers nums containing n unique elements, where each element is in the range [1, n], return the number of positive integers that are missing from the list. >>> count_missing_numbers([]) 0 >>> count_missing_numbers([1, 2, 3, 4, 5]) 0 >>> count_missing_numbers([6, 7, 8, 9, 10]) 5 >>> count_missing_numbers([2, 3, 7, 8, 9]) 3 >>> count_missing_numbers([1, 2, 4, 5]) 1 >>> count_missing_numbers([4, 2, 5, 1, 3]) 0 >>> count_missing_numbers(list(range(1, 100001))) 0","solution":"def count_missing_numbers(nums): Returns the number of positive integers that are missing from the list. n = len(nums) present = [False] * n for num in nums: if 1 <= num <= n: present[num - 1] = True missing_count = 0 for present_flag in present: if not present_flag: missing_count += 1 return missing_count"},{"question":"def first_missing_positive(nums): Given an unsorted integer array nums, find the smallest positive integer that is not present in the array. The algorithm runs in O(n) time and uses constant extra space. >>> first_missing_positive([1, 2, 3]) 4 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([1]) 2 >>> first_missing_positive([2]) 1 >>> first_missing_positive([-1, -2, -6]) 1 >>> first_missing_positive([1, 1, 2, 2]) 3 >>> first_missing_positive([1, 3, 5, 4, 2]) 6","solution":"def first_missing_positive(nums): Given an unsorted integer array nums, find the smallest positive integer that is not present in the array. The algorithm runs in O(n) time and uses constant extra space. n = len(nums) # Place each number in its right place, i.e., nums[i] should be equal to i+1 for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: # Swap nums[i] with nums[nums[i] - 1] nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first position where the index doesn't match the value for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def number_of_focal_subarrays(nums: List[int], k: int) -> int: Returns the number of focal subarrays that contain exactly k odd numbers. >>> number_of_focal_subarrays([1, 1, 2, 1, 1], 3) 2 >>> number_of_focal_subarrays([2, 4, 6], 1) 0 >>> number_of_focal_subarrays([1, 2, 1, 2, 1], 2) 4 >>> number_of_focal_subarrays([1], 1) 1 >>> number_of_focal_subarrays([2], 1) 0 >>> number_of_focal_subarrays([1, 3, 5, 7, 9], 3) 3 >>> number_of_focal_subarrays([], 1) 0 >>> number_of_focal_subarrays([1, 2, 3, 4, 5], 0) 2","solution":"def number_of_focal_subarrays(nums, k): Returns the number of focal subarrays that contain exactly k odd numbers. count = 0 odd_count = 0 prefix_counts = {0: 1} for num in nums: if num % 2 == 1: odd_count += 1 if odd_count - k in prefix_counts: count += prefix_counts[odd_count - k] if odd_count in prefix_counts: prefix_counts[odd_count] += 1 else: prefix_counts[odd_count] = 1 return count"},{"question":"def count_palindromic_substrings(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, determine the number of palindromic substrings. A palindromic substring is a substring which reads the same backward as forward. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"aabaa\\") 9 >>> count_palindromic_substrings(\\"abccba\\") 9","solution":"def count_palindromic_substrings(s): n = len(s) count = 0 # dp[i][j] will be True if the string from index i to j is a palindrome. dp = [[False] * n for _ in range(n)] # Every single letter is a palindrome for i in range(n): dp[i][i] = True count += 1 # Check for string of length 2. for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for lengths greater than 2. for length in range(3, n + 1): # length of the substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count"},{"question":"def max_cakes(ingredients: List[int], available: List[int]) -> int: Calculates the maximum number of cakes that can be baked with the given ingredients and available quantities. :param ingredients: List[int] - quantities of ingredients required for a single cake :param available: List[int] - quantities of ingredients available :return: int - maximum number of cakes that can be baked >>> max_cakes([2, 3, 5], [10, 15, 25]) 5 >>> max_cakes([4, 4, 2], [8, 8, 4]) 2 >>> max_cakes([2, 3, 5], [0, 15, 25]) 0 >>> max_cakes([4, 4, 2], [7, 8, 4]) 1 >>> max_cakes([1, 1, 1], [100, 200, 300]) 100 >>> max_cakes([5, 10, 20], [50, 100, 200]) 10 try: max_cakes([1, 2, 3], [4, 5]) except ValueError: True else: False","solution":"def max_cakes(ingredients, available): Calculates the maximum number of cakes that can be baked with the given ingredients and available quantities. :param ingredients: List[int] - quantities of ingredients required for a single cake :param available: List[int] - quantities of ingredients available :return: int - maximum number of cakes that can be baked if len(ingredients) != len(available): raise ValueError(\\"The length of ingredients and available must be the same\\") return min(available[i] // ingredients[i] for i in range(len(ingredients)))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestConsecutivePath(root): Returns the length of the longest path with consecutive increasing values in the binary tree. >>> root = TreeNode(1) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(2) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(5) >>> longestConsecutivePath(root) 3 >>> root = TreeNode(2) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(2) >>> root.right.left.left = TreeNode(4) >>> longestConsecutivePath(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> longestConsecutivePath(root) 2 >>> root = TreeNode(1) >>> longestConsecutivePath(root) 1 >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(10) >>> longestConsecutivePath(root) 1 >>> longestConsecutivePath(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestConsecutivePath(root): Returns the length of the longest path with consecutive increasing values in the binary tree. def longestPath(node, parent_val, length): if not node: return length if node.val == parent_val + 1: left_length = longestPath(node.left, node.val, length + 1) right_length = longestPath(node.right, node.val, length + 1) return max(left_length, right_length) else: left_length = longestPath(node.left, node.val, 1) right_length = longestPath(node.right, node.val, 1) return max(length, left_length, right_length) if not root: return 0 return max(longestPath(root, root.val - 1, 0), longestPath(root.left, root.val, 1), longestPath(root.right, root.val, 1))"},{"question":"def shortest_subarray_with_k_types(nums: List[int], k: int) -> int: You are given an array of integers \`nums\` and an integer \`k\`. Each element in the array represents a type of candy, and \`k\` represents the number of different types of candy you need to collect. The goal is to find the shortest subarray of \`nums\` that contains at least \`k\` different types of candies. Write a function to return the length of that shortest subarray. If it is not possible to collect \`k\` different types of candies from \`nums\`, return -1. >>> shortest_subarray_with_k_types([1, 2, 1, 2, 3], 2) == 2 >>> shortest_subarray_with_k_types([1, 2, 1, 3, 4], 3) == 3 >>> shortest_subarray_with_k_types([1, 2, 3, 1, 2, 3, 4], 3) == 3 >>> shortest_subarray_with_k_types([1, 2, 3, 4, 5], 4) == 4 >>> shortest_subarray_with_k_types([1, 2, 3, 4, 5], 5) == 5 >>> shortest_subarray_with_k_types([1, 2, 3, 4], 5) == -1 >>> shortest_subarray_with_k_types([1, 1, 1, 1], 2) == -1 >>> shortest_subarray_with_k_types([1], 1) == 1 >>> shortest_subarray_with_k_types([2, 2, 2, 2, 2], 1) == 1 >>> shortest_subarray_with_k_types([], 1) == -1","solution":"def shortest_subarray_with_k_types(nums, k): from collections import defaultdict # Edge case: if k is greater than the number of unique candies in nums if len(set(nums)) < k: return -1 left = 0 min_length = float('inf') candy_count = defaultdict(int) unique_candies = 0 for right in range(len(nums)): candy_count[nums[right]] += 1 if candy_count[nums[right]] == 1: # New candy type unique_candies += 1 while unique_candies >= k: min_length = min(min_length, right - left + 1) candy_count[nums[left]] -= 1 if candy_count[nums[left]] == 0: # No more of this type in the window unique_candies -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def judgeCircle(s: str) -> bool: Determines if the robot returns to the origin after completing all the moves. :param s: A string representing a sequence of moves ('U', 'D', 'L', 'R') :return: True if the robot returns to the origin, False otherwise >>> judgeCircle(\\"UD\\") True >>> judgeCircle(\\"LL\\") False","solution":"def judgeCircle(s): Determines if the robot returns to the origin after completing all the moves. :param s: A string representing a sequence of moves ('U', 'D', 'L', 'R') :return: True if the robot returns to the origin, False otherwise # Initial position x, y = 0, 0 # Traverse through each move in the sequence for move in s: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 # Check if robot is back at the origin return x == 0 and y == 0"},{"question":"def min_transmitters(grid: List[List[int]]) -> int: You are given a 2D grid of size m x n representing a map of a city, where each cell in the grid is either 0 (an empty plot) or 1 (a building). A building can see its neighbors in four directions: up, down, left, and right. You must place a set of transmitters in empty plots such that each building can connect to at least one transmitter. A building can connect to a transmitter if it is in the line of sight (direct path of 0s) to the transmitter with no other buildings obstructing the view. Return the minimum number of transmitters needed to ensure every building is connected to at least one transmitter. >>> min_transmitters([ ... [0, 1, 0], ... [0, 0, 0], ... [1, 0, 0] ... ]) == 2 >>> min_transmitters([ ... [0, 0, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ]) == 3 >>> min_transmitters([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> min_transmitters([ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 1 >>> min_transmitters([ ... [1] ... ]) == 1","solution":"def min_transmitters(grid): from collections import deque m, n = len(grid), len(grid[0]) def bfs(queue): visited = [[False] * n for _ in range(m)] while queue: (x, y), dist = queue.popleft() if visited[x][y]: continue visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy while 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: if not visited[nx][ny]: queue.append(((nx, ny), dist + 1)) nx += dx ny += dy return visited required_buildings = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1] left, right = 0, len(required_buildings) result = 0 while left <= right: mid = (left + right) // 2 queue = deque([((i, j), 0) for i, j in required_buildings[:mid]]) visited = bfs(queue) covered = all(visited[i][j] for i, j in required_buildings) if covered: result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"from typing import List def calculateDaysToWarmerTemperature(temperatures: List[int]) -> List[int]: Compute the number of days you have to wait until a warmer temperature for each day. If there is no future day with a warmer temperature, return 0 for that day. >>> calculateDaysToWarmerTemperature([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> calculateDaysToWarmerTemperature([30, 40, 50, 60]) == [1, 1, 1, 0] >>> calculateDaysToWarmerTemperature([30, 60, 90]) == [1, 1, 0] >>> calculateDaysToWarmerTemperature([90, 80, 70, 60]) == [0, 0, 0, 0] >>> calculateDaysToWarmerTemperature([30, 50, 40, 60, 50, 70, 60]) == [1, 2, 1, 2, 1, 0, 0]","solution":"from typing import List def calculateDaysToWarmerTemperature(temperatures: List[int]) -> List[int]: Compute the number of days you have to wait until a warmer temperature for each day. n = len(temperatures) result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"def sort_subarray(arr: List[int], k: int) -> List[int]: Sorts exactly one subarray of the given array in non-decreasing order and then replaces it back into the original array. If sorting any subarray won't change the overall order, returns the array as it is. >>> sort_subarray([4, 3, 2, 1], 4) [1, 2, 3, 4] >>> sort_subarray([4, 3, 2, 1], 2) [3, 4, 2, 1] >>> sort_subarray([1, 5, 3, 4, 2], 3) [1, 3, 5, 4, 2] >>> sort_subarray([1, 2, 3, 4], 2) [1, 2, 3, 4] >>> sort_subarray([1, 5, 3, 6, 2], 3) [1, 3, 5, 6, 2] >>> sort_subarray([10, 20, 30, 40], 1) [10, 20, 30, 40] >>> sort_subarray([20, 10, 30, 40], 1) [20, 10, 30, 40]","solution":"def sort_subarray(arr, k): Sorts exactly one subarray of the given array in non-decreasing order and then replaces it back into the original array. If sorting any subarray won't change the overall order, returns the array as it is. Parameters: arr (list): The list of integers. k (int): The size of the subarray to sort. Returns: list: Modified array after sorting one subarray. n = len(arr) if k >= n: return sorted(arr) original = arr[:] for i in range(n - k + 1): subarray_sorted = sorted(arr[i:i + k]) arr_modified = arr[:i] + subarray_sorted + arr[i + k:] if arr_modified != original: return arr_modified return arr"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def find_topological_order(n: int, edges: List[Tuple[int, int]]) -> List[int]: Given a directed acyclic graph (DAG) with n nodes and m edges, where each node represents a task and each edge represents a dependency, determine the order in which the tasks can be completed. If there is more than one valid topological order, return the lexicographically smallest order. If no such order exists, return an empty list. :param n: Number of nodes (tasks) :param edges: List of edges representing dependencies between tasks :return: A list representing the topological order of tasks >>> find_topological_order(3, []) [0, 1, 2] >>> find_topological_order(3, [(0, 1), (1, 2)]) [0, 1, 2] >>> find_topological_order(3, [(0, 1), (0, 2)]) [0, 1, 2] >>> find_topological_order(4, [(0, 1), (1, 2), (2, 3), (0, 2)]) [0, 1, 2, 3] >>> find_topological_order(6, [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]) [4, 5, 0, 2, 3, 1] >>> find_topological_order(5, [(0, 1), (1, 2)]) [0, 1, 2, 3, 4] >>> find_topological_order(0, []) []","solution":"import heapq from collections import defaultdict, deque def find_topological_order(n, edges): Returns the lexicographically smallest topological order of tasks represented as a DAG. :param n: Number of nodes (tasks) :param edges: List of edges representing dependencies between tasks :return: A list representing the topological order of tasks in_degree = [0] * n graph = defaultdict(list) # Build the graph and calculate the in-degrees for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Use a min-heap to prioritize the lexicographically smallest order min_heap = [] for i in range(n): if in_degree[i] == 0: heapq.heappush(min_heap, i) topological_order = [] while min_heap: u = heapq.heappop(min_heap) topological_order.append(u) for v in graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: heapq.heappush(min_heap, v) return topological_order if len(topological_order) == n else []"},{"question":"def can_make_identical(s1: str, s2: str) -> bool: Determines if it's possible to make strings s1 and s2 identical by performing allowed swaps any number of times. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if it's possible to make s1 and s2 identical, False otherwise. >>> can_make_identical(\\"abc\\", \\"abc\\") True >>> can_make_identical(\\"ab\\", \\"ba\\") True >>> can_make_identical(\\"abcdef\\", \\"fbdcea\\") True >>> can_make_identical(\\"abc\\", \\"abd\\") False >>> can_make_identical(\\"abc\\", \\"def\\") False >>> can_make_identical(\\"aabbcc\\", \\"abcabc\\") True >>> can_make_identical(\\"abc\\", \\"abcd\\") False >>> can_make_identical(\\"aabbcc\\", \\"ccbbaa\\") True >>> can_make_identical(\\"aabbcc\\", \\"aabbbc\\") False","solution":"def can_make_identical(s1, s2): Determines if it's possible to make strings s1 and s2 identical by performing allowed swaps any number of times. Args: s1 (str): First string. s2 (str): Second string. Returns: bool: True if it's possible to make s1 and s2 identical, False otherwise. from collections import Counter # Check if both strings have the same character counts return Counter(s1) == Counter(s2)"},{"question":"def num_decodings(s: str) -> int: Given a string \`s\` containing only digits, return the number of ways to decode it. Each digit or group of digits can be mapped to letters (1 -> A, 2 -> B, ..., 26 -> Z). A valid encoding will not contain leading zeros, and \\"0\\" cannot be mapped to any letter individually. >>> num_decodings('1') == 1 >>> num_decodings('9') == 1 >>> num_decodings('12') == 2 >>> num_decodings('26') == 2 >>> num_decodings('0') == 0 >>> num_decodings('06') == 0 >>> num_decodings('226') == 3 >>> num_decodings('11106') == 2 >>> num_decodings('123456789') == 3 >>> num_decodings('1111111111') == 89 >>> num_decodings('') == 0","solution":"def num_decodings(s): Returns the number of ways to decode a string containing only digits. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): single_digit = int(s[i-1:i]) double_digit = int(s[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def min_days_to_complete_tasks(tasks: List[int], maxTime: int) -> int: Returns the minimum number of days required to complete all tasks given the constraints. >>> min_days_to_complete_tasks([2, 3, 1, 5, 4], 5) == 3 >>> min_days_to_complete_tasks([1], 2) == 1 >>> min_days_to_complete_tasks([3], 2) == 1 >>> min_days_to_complete_tasks([3, 3, 3, 3], 6) == 2 >>> min_days_to_complete_tasks([1, 2, 3, 4, 5], 10) == 3 >>> min_days_to_complete_tasks([3, 5, 3, 8, 6], 8) == 4 >>> min_days_to_complete_tasks([7, 8, 5, 6], 10) == 4","solution":"def min_days_to_complete_tasks(tasks, maxTime): Returns the minimum number of days required to complete all tasks given the constraints. tasks.sort() left, right = 0, len(tasks) - 1 days = 0 while left <= right: if tasks[left] + tasks[right] <= maxTime: left += 1 right -= 1 days += 1 return days"},{"question":"def has_path(matrix, start, destination): Determines if there is a path from start to destination in a 2D grid. >>> matrix = [ ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ] >>> has_path(matrix, (0, 4), (4, 4)) True >>> matrix = [ ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 1], ... [0, 0, 1, 0, 0] ... ] >>> has_path(matrix, (0, 4), (4, 4)) False","solution":"def has_path(matrix, start, destination): Determines if there is a path from start to destination in a 2D grid. def is_valid(x, y): return 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and matrix[x][y] == 0 def dfs(x, y): if not is_valid(x, y): return False if (x, y) == destination: return True matrix[x][y] = 2 # Mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: if dfs(x + dx, y + dy): return True return False return dfs(start[0], start[1])"},{"question":"def decode_string(s: str) -> str: Decodes the encoded string according to the rule: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. >>> decode_string(\\"3[a]\\") == \\"aaa\\" >>> decode_string(\\"2[bc]\\") == \\"bcbc\\" >>> decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" >>> decode_string(\\"abc\\") == \\"abc\\" >>> decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\"","solution":"def decode_string(s): Decodes the encoded string according to the rule: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string, current_num = \\"\\", 0 elif char == ']': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"class FileSystem: A file system that supports creating paths, setting values, and retrieving values. FileSystem() -> Initializes the file system. boolean createPath(String path, int value) -> Creates a new path and associates a value with it. Returns \`true\` if the path is successfully created, and \`false\` if the parent path does not exist or the path already exists. int getValue(String path) -> Returns the value associated with the given path. Returns \`-1\` if the path does not exist. >>> fs = FileSystem() >>> fs.createPath(\\"/a\\", 1) True >>> fs.getValue(\\"/a\\") 1 >>> fs.createPath(\\"/a/b\\", 2) True >>> fs.getValue(\\"/a/b\\") 2 >>> fs.createPath(\\"/c/d\\", 3) False >>> fs.getValue(\\"/c\\") -1 from solution import FileSystem def test_create_and_get_value(): fs = FileSystem() # Test creating and retrieving single level path assert fs.createPath(\\"/a\\", 1) == True assert fs.getValue(\\"/a\\") == 1 # Test creating sub-path assert fs.createPath(\\"/a/b\\", 2) == True assert fs.getValue(\\"/a/b\\") == 2 # Test invalid path creation as parent does not exist assert fs.createPath(\\"/c/d\\", 3) == False assert fs.getValue(\\"/c/d\\") == -1 # Test retrieving non-existent path assert fs.getValue(\\"/c\\") == -1 def test_createPath_with_invalid_data(): fs = FileSystem() # Path doesn't start with / assert fs.createPath(\\"a/b\\", 1) == False # Trying to recreate an existing path assert fs.createPath(\\"/a\\", 1) == True assert fs.createPath(\\"/a\\", 2) == False # Missing intermediate path assert fs.createPath(\\"/a/c/d\\", 4) == False def test_getValue_with_nonexistent_path(): fs = FileSystem() # Path does not exist assert fs.getValue(\\"/nonexistent\\") == -1","solution":"class FileSystem: def __init__(self): self.paths = {} def createPath(self, path: str, value: int) -> bool: if len(path) == 0 or path[0] != '/' or len(path.split('/')) < 2: return False parent_path = '/'.join(path.rstrip('/').split('/')[:-1]) if parent_path and parent_path != '/' and parent_path not in self.paths: return False if path in self.paths: return False self.paths[path] = value return True def getValue(self, path: str) -> int: return self.paths.get(path, -1)"},{"question":"def trap(height): Calculate the total amount of rain water trapped. :param height: List[int] -- A list of integers representing the heights of bars. :return: int -- The total amount of rain water trapped. pass # Test cases def test_water_trapped_single_bar(): assert trap([1]) == 0 def test_water_trapped_no_bars(): assert trap([]) == 0 def test_water_trapped_all_same_height(): assert trap([3, 3, 3, 3, 3]) == 0 def test_water_trapped_decreasing_height(): assert trap([5, 4, 3, 2, 1]) == 0 def test_water_trapped_increasing_height(): assert trap([1, 2, 3, 4, 5]) == 0 def test_water_trapped_trapped_scenario_1(): assert trap([0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2]) == 8 def test_water_trapped_trapped_scenario_2(): assert trap([4, 2, 0, 3, 2, 5]) == 9 def test_water_trapped_alternating_heights(): assert trap([1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]) == 5 def test_water_trapped_random_heights(): assert trap([4, 2, 3]) == 1","solution":"def trap(height): Calculate the total amount of rain water trapped. :param height: List[int] -- A list of integers representing the heights of bars. :return: int -- The total amount of rain water trapped. if not height: return 0 n = len(height) left = [0] * n right = [0] * n left[0] = height[0] for i in range(1, n): left[i] = max(left[i-1], height[i]) right[n-1] = height[n-1] for i in range(n-2, -1, -1): right[i] = max(right[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left[i], right[i]) - height[i] return water_trapped"},{"question":"def min_steps_to_convert(matrix: List[List[int]], target: List[List[int]]) -> int: Returns the minimum number of steps required to convert the matrix into the target matrix. - Increment any element of the matrix. - Decrement any element of the matrix. If it is not possible to convert the matrix to target, return -1. >>> min_steps_to_convert([[1, 2, 3], [4, 5, 6]], [[2, 3, 4], [5, 6, 7]]) == 6 >>> min_steps_to_convert([[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]) == 0 >>> min_steps_to_convert([[1, 2, 3]], [[1, 2, 3], [4, 5, 6]]) == -1 >>> min_steps_to_convert([[-1, -2, -3], [-4, -5, -6]], [[1, 2, 3], [4, 5, 6]]) == 42 >>> min_steps_to_convert([[0, 0, 0], [0, 0, 0]], [[1, 1, 1], [1, 1, 1]]) == 6","solution":"def min_steps_to_convert(matrix, target): Returns the minimum number of steps required to convert the matrix into the target matrix. - Increment any element of the matrix. - Decrement any element of the matrix. If it is not possible to convert the matrix to target, return -1. if len(matrix) != len(target) or len(matrix[0]) != len(target[0]): return -1 min_steps = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): min_steps += abs(matrix[i][j] - target[i][j]) return min_steps"},{"question":"def longest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Returns the length of the longest contiguous subarray with at most k distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_k_distinct([1], 1) 1 >>> longest_subarray_with_k_distinct([1], 0) 0 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 3) 3 >>> longest_subarray_with_k_distinct([1, 1, 1, 1, 1], 1) 5 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 0) 0 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 10) 5 >>> longest_subarray_with_k_distinct([1, 2, 2, 1, 2, 3], 3) 6","solution":"def longest_subarray_with_k_distinct(arr, k): Returns the length of the longest contiguous subarray with at most k distinct integers. if k == 0: return 0 from collections import defaultdict n = len(arr) freq = defaultdict(int) left = 0 max_length = 0 unique_count = 0 for right in range(n): if freq[arr[right]] == 0: unique_count += 1 freq[arr[right]] += 1 while unique_count > k: freq[arr[left]] -= 1 if freq[arr[left]] == 0: unique_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def min_moves_to_non_decreasing(heights: List[int]) -> int: Given an integer array \`heights\` representing the heights of students in a line, find the minimum number of students who must be moved in order to make the heights list non-decreasing. >>> min_moves_to_non_decreasing([1, 2, 3, 4, 5]) 0 >>> min_moves_to_non_decreasing([5, 5, 5, 5, 5]) 0 >>> min_moves_to_non_decreasing([5, 3, 4, 2, 1]) 3 >>> min_moves_to_non_decreasing([5, 4, 3, 2, 1]) 4 >>> min_moves_to_non_decreasing([1, 5, 3, 4, 2]) 2 >>> min_moves_to_non_decreasing([]) 0 >>> min_moves_to_non_decreasing([10]) 0 >>> min_moves_to_non_decreasing([2, 2, 1, 2, 2]) 1","solution":"def min_moves_to_non_decreasing(heights): Returns the minimum number of moves required to arrange the array of heights in non-decreasing order. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) longest_increasing_subsequence = max(dp) return n - longest_increasing_subsequence"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Returns the number of distinct islands in the grid. >>> numDistinctIslands([ ... [1, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 1, 1] ... ]) == 2 >>> numDistinctIslands([ ... [1, 1, 0, 0], ... [1, 0, 0, 1], ... [0, 0, 1, 1], ... [0, 0, 0, 1] ... ]) == 2 >>> numDistinctIslands([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> numDistinctIslands([ ... [1, 0, 0, 1], ... [0, 0, 0, 0], ... [1, 0, 0, 1] ... ]) == 1 >>> numDistinctIslands([ ... [1, 1, 0, 0, 1], ... [1, 0, 0, 1, 0], ... [1, 1, 1, 1, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 1, 1, 1] ... ]) == 3","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. def dfs(x, y, baseX, baseY, shape): if (0 <= x < len(grid)) and (0 <= y < len(grid[0])) and grid[x][y] == 1: grid[x][y] = 0 shape.append((x - baseX, y - baseY)) dfs(x + 1, y, baseX, baseY, shape) dfs(x - 1, y, baseX, baseY, shape) dfs(x, y + 1, baseX, baseY, shape) dfs(x, y - 1, baseX, baseY, shape) shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, i, j, shape) shapes.add(tuple(shape)) return len(shapes)"},{"question":"from typing import List def shortest_to_char(s: str, c: str) -> List[int]: Given a string \`s\` and a character \`c\`, determine the shortest distance from each character in \`s\` to the character \`c\`. Return an integer array \`distances\`, where \`distances[i]\` represents the shortest distance from the \`i\`th character in \`s\` to \`c\`. The distance between two characters is defined as the absolute difference of their indices. >>> shortest_to_char(\\"loveleetcode\\", 'e') == [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_to_char(\\"a\\", 'a') == [0] >>> shortest_to_char(\\"aaaaa\\", 'a') == [0, 0, 0, 0, 0] Args: s (str): The input string. c (str): The character to measure distances to. Returns: List[int]: An integer array representing the shortest distances. pass from solution import shortest_to_char def test_shortest_to_char_basic_case(): assert shortest_to_char(\\"loveleetcode\\", 'e') == [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] def test_shortest_to_char_single_char(): assert shortest_to_char(\\"a\\", 'a') == [0] def test_shortest_to_char_no_occurrence(): # Edge Case: Assumption if the character 'c' never occurs in 's', \`float('inf')\` value should be adjusted based on the problem constraints. # This function assumes the scenario where \`c\` always appears at least once in \`s\`. pass def test_shortest_to_char_all_characters_same(): assert shortest_to_char(\\"aaaaa\\", 'a') == [0, 0, 0, 0, 0] def test_shortest_to_char_chars_at_edges(): assert shortest_to_char(\\"ab\\", 'a') == [0, 1] assert shortest_to_char(\\"ab\\", 'b') == [1, 0] assert shortest_to_char(\\"abcde\\", 'a') == [0, 1, 2, 3, 4] assert shortest_to_char(\\"abcde\\", 'e') == [4, 3, 2, 1, 0] def test_shortest_to_char_multiple_occurrences(): assert shortest_to_char(\\"aabaa\\", 'b') == [2, 1, 0, 1, 2]","solution":"def shortest_to_char(s, c): Given a string s and a character c, returns an array of the shortest distances from each character in s to the character c. n = len(s) distances = [float('inf')] * n # First pass: From left to right prev_position = float('-inf') for i in range(n): if s[i] == c: prev_position = i distances[i] = i - prev_position # Second pass: From right to left prev_position = float('inf') for i in range(n-1, -1, -1): if s[i] == c: prev_position = i distances[i] = min(distances[i], prev_position - i) return distances"},{"question":"def max_stones_collected(nums, k): Returns the maximum number of stones collected in a traversal of exactly k cells. >>> max_stones_collected([1, 2, 3, 4], 2) == 7 >>> max_stones_collected([10, 20, 30, 40, 50], 5) == 150 >>> max_stones_collected([1, 2, 3, 4, 5], 3) == 12 >>> max_stones_collected([100, 1, 1, 1], 3) == 102 >>> max_stones_collected([1, 1, 1, 100], 3) == 102 >>> max_stones_collected([5, 10, 15, 20], 1) == 20","solution":"def max_stones_collected(nums, k): Returns the maximum number of stones collected in a traversal of exactly k cells. n = len(nums) # Since it's a circular track, we consider the array twice # to handle the circular nature in a simple manner. nums_circular = nums * 2 max_stones = 0 # Traverse considering all possible starting positions and directions for start in range(n): # Clockwise collection clockwise_stones = sum(nums_circular[start:start + k]) max_stones = max(max_stones, clockwise_stones) # Counter-Clockwise collection counter_start = start + n counterclockwise_stones = sum(nums_circular[counter_start:counter_start - k: -1]) max_stones = max(max_stones, counterclockwise_stones) return max_stones"},{"question":"def generate_permutations(s: str) -> List[str]: Generate all possible strings by replacing each '*' in the string s with any uppercase English letter from 'A' to 'Z'. Return the list of all possible strings in lexicographical order. >>> generate_permutations(\\"ABCD\\") [\\"ABCD\\"] >>> generate_permutations(\\"A*\\") ['AA', 'AB', 'AC', 'AD', 'AE', 'AF', 'AG', 'AH', 'AI', 'AJ', 'AK', 'AL', 'AM', 'AN', 'AO', 'AP', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AV', 'AW', 'AX', 'AY', 'AZ'] >>> generate_permutations(\\"A*C\\") ['AAC', 'ABC', 'ACC', 'ADC', 'AEC', 'AFC', 'AGC', 'AHC', 'AIC', 'AJC', 'AKC', 'ALC', 'AMC', 'ANC', 'AOC', 'APC', 'AQC', 'ARC', 'ASC', 'ATC', 'AUC', 'AVC', 'AWC', 'AXC', 'AYC', 'AZC'] >>> generate_permutations(\\"***\\") ['AAA', 'AAB', 'AAC', 'AAD', 'AAE', 'AAF', 'AAG', 'AAH', 'AAI', 'AAJ', 'AAK', 'AAL', 'AAM', 'AAN', 'AAO', 'AAP', 'AAQ', 'AAR', 'AAS', 'AAT', 'AAU', 'AAV', 'AAW', 'AAX', 'AAY', 'AAZ', 'ABA', 'ABB', 'ABC', 'ABD', 'ABE', 'ABF', 'ABG', 'ABH', 'ABI', 'ABJ', 'ABK', 'ABL', 'ABM', 'ABN', 'ABO', 'ABP', 'ABQ', 'ABR', 'ABS', 'ABT', 'ABU', 'ABV', 'ABW', 'ABX', 'ABY', 'ABZ', 'ACA', 'ACB', 'ACC', ... (and so on for all combinations)] >>> generate_permutations(\\"A*B*C\\") ['AABAC', 'AABBC', 'AABCC', 'AABDC', 'AABEC', 'AABFC', 'AABGC', 'AABHC', 'AABIC', 'AABJC', 'AABKC', 'AABLC', 'AABMC', 'AABNC', 'AABOC', 'AABPC', 'AABQC', 'AABRC', 'AABSC', 'AABTC', 'AABUC', 'AABVC', 'AABWC', 'AABXC', 'AABYC', 'AABZC', 'AACAC', 'AACBC', etc.]","solution":"def generate_permutations(s): Generate all possible strings by replacing each '*' in the string s with any uppercase English letter from 'A' to 'Z'. from itertools import product # Find the positions of '*' star_positions = [i for i, char in enumerate(s) if char == '*'] # Generate all combinations of letters for each '*' replacements = product('ABCDEFGHIJKLMNOPQRSTUVWXYZ', repeat=len(star_positions)) result = [] for replacement in replacements: s_list = list(s) for idx, char in zip(star_positions, replacement): s_list[idx] = char result.append(''.join(s_list)) return sorted(result)"},{"question":"def max_beautiful_pairs(arr, d): Returns the maximum number of pairs such that the absolute difference between the elements in each pair is greater than or equal to d. :param arr: List of integers :param d: Integer specifying the required minimum absolute difference :return: Maximum number of pairs >>> max_beautiful_pairs([1, 3, 5, 9], 2) 2 >>> max_beautiful_pairs([1, 1, 1, 1], 2) 0 >>> max_beautiful_pairs([1, 4], 3) 1 >>> max_beautiful_pairs([10, 20, 30, 40], 60) 0 >>> max_beautiful_pairs([5, 5, 5, 5], 0) 2 >>> max_beautiful_pairs([1, 100, 200], 50) 1 >>> max_beautiful_pairs([9, 1, 5, 3], 2) 2 >>> max_beautiful_pairs([], 1) 0 >>> max_beautiful_pairs([5], 1) 0","solution":"def max_beautiful_pairs(arr, d): Returns the maximum number of pairs such that the absolute difference between the elements in each pair is greater than or equal to d. :param arr: List of integers :param d: Integer specifying the required minimum absolute difference :return: Maximum number of pairs arr.sort() n = len(arr) count = 0 i = 0 while i < n - 1: if abs(arr[i + 1] - arr[i]) >= d: count += 1 i += 2 else: i += 1 return count"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in a given string s. Each word is separated by a single space. Parameters: s (str): The input string. Returns: str: The string with the words reversed in order. # your code here # Unit tests def test_single_word(): assert reverse_words(\\"hello\\") == \\"hello\\" def test_two_words(): assert reverse_words(\\"hello world\\") == \\"world hello\\" def test_multiple_words(): assert reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" def test_repeated_words(): assert reverse_words(\\"one one one\\") == \\"one one one\\" def test_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_leading_trailing_spaces(): assert reverse_words(\\" space before and after \\") == \\"after and before space\\" def test_mixed_case(): assert reverse_words(\\"Hello World\\") == \\"World Hello\\"","solution":"def reverse_words(s): Reverses the order of words in a given string s. Each word is separated by a single space. Parameters: s (str): The input string. Returns: str: The string with the words reversed in order. # Split the string into words words = s.split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space return ' '.join(reversed_words)"},{"question":"from typing import List from collections import Counter def is_valid_string(s: str) -> bool: Returns True if the string s can be transformed into a balanced string by removing at most one character. def test_single_character(): assert is_valid_string(\\"a\\") == True def test_balanced_string(): assert is_valid_string(\\"aabbcc\\") == True assert is_valid_string(\\"aabbc\\") == True # by removing one 'c' def test_not_balanced_string(): assert is_valid_string(\\"aaabbc\\") == False def test_complex_balanced_string(): assert is_valid_string(\\"aabbccdde\\") == True # by removing 'd' or 'e' assert is_valid_string(\\"aabbccddee\\") == True # already balanced def test_one_difference(): assert is_valid_string(\\"aabbccc\\") == True # by removing one 'c' assert is_valid_string(\\"aaabbcc\\") == True # by removing one 'a'","solution":"from collections import Counter def is_valid_string(s): Returns True if the string s can be transformed into a balanced string by removing at most one character. freq = Counter(s) freq_values = list(freq.values()) # Count occurrences of each frequency freq_count = Counter(freq_values) if len(freq_count) == 1: return True if len(freq_count) == 2: min_freq = min(freq_count.keys()) # Minimum frequency count max_freq = max(freq_count.keys()) # Maximum frequency count # Check for the conditions where the string can become balanced by removing one character if min_freq == 1 and freq_count[min_freq] == 1: return True if max_freq - min_freq == 1 and freq_count[max_freq] == 1: return True return False"},{"question":"def partition_labels(s: str, k: int) -> List[int]: Partitions the string s into as many parts as possible such that each letter appears in at most one part, and the length of the longest part is minimized. Return the lengths of the parts. >>> partition_labels(\\"ababcbacadefegdehijhklij\\", 3) [9, 7, 8] >>> partition_labels(\\"a\\", 1) [1] >>> partition_labels(\\"abcdefghi\\", 9) [1, 1, 1, 1, 1, 1, 1, 1, 1] >>> partition_labels(\\"abac\\", 2) [3, 1] >>> partition_labels(\\"aaaa\\", 1) [4] >>> partition_labels(\\"eccbbbbdec\\", 2) [10]","solution":"def partition_labels(s: str, k: int): Partitions the string s into as many parts as possible such that each letter appears in at most one part, and the length of the longest part is minimized. Returns the lengths of the parts. last_occurrence = {ch: ix for ix, ch in enumerate(s)} partitions = [] start, end = 0, 0 for ix, ch in enumerate(s): end = max(end, last_occurrence[ch]) if ix == end: partitions.append(end - start + 1) start = ix + 1 return partitions"},{"question":"def can_form_by_deleting_one(s: str, t: str) -> bool: Determines if string t can be obtained by deleting exactly one character from string s and rearranging the remaining characters. >>> can_form_by_deleting_one(\\"abc\\", \\"ab\\") == True >>> can_form_by_deleting_one(\\"abcd\\", \\"abc\\") == True >>> can_form_by_deleting_one(\\"aabbcc\\", \\"abbcc\\") == True >>> can_form_by_deleting_one(\\"hello\\", \\"helo\\") == True >>> can_form_by_deleting_one(\\"abc\\", \\"abcd\\") == False >>> can_form_by_deleting_one(\\"abcd\\", \\"abce\\") == False >>> can_form_by_deleting_one(\\"aabbcc\\", \\"abc\\") == False >>> can_form_by_deleting_one(\\"hello\\", \\"helloo\\") == False >>> can_form_by_deleting_one(\\"hello\\", \\"hloo\\") == False >>> can_form_by_deleting_one(\\"a\\", \\"\\") == True >>> can_form_by_deleting_one(\\"aa\\", \\"a\\") == True >>> can_form_by_deleting_one(\\"a\\", \\"a\\") == False >>> can_form_by_deleting_one(\\"a\\", \\"b\\") == False >>> can_form_by_deleting_one(\\"\\", \\"\\") == False # Your implementation here","solution":"def can_form_by_deleting_one(s, t): Determines if string t can be obtained by deleting exactly one character from string s and rearranging the remaining characters. if len(s) != len(t) + 1: return False s_counter = {} t_counter = {} # Count the frequency of each character in s for char in s: if char in s_counter: s_counter[char] += 1 else: s_counter[char] = 1 # Count the frequency of each character in t for char in t: if char in t_counter: t_counter[char] += 1 else: t_counter[char] = 1 # Check if t_counter matches s_counter with exactly one less character diff_count = 0 for char in s_counter: s_count = s_counter.get(char, 0) t_count = t_counter.get(char, 0) if s_count != t_count: diff_count += 1 if diff_count > 1 or t_count != s_count - 1: return False return True"},{"question":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): Insert a key into the BST, maintaining its properties. if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.key: if node.left is None: node.left = Node(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert_recursive(node.right, key) def rangeSum(self, low, high): Return the sum of all keys in the BST that fall within the given range [low, high] inclusive. return self._range_sum_recursive(self.root, low, high) def _range_sum_recursive(self, node, low, high): # Implementation here # Test case examples def test_insert_and_range_sum(): bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) assert bst.rangeSum(7, 15) == 32 assert bst.rangeSum(3, 7) == 15 assert bst.rangeSum(5, 10) == 22 assert bst.rangeSum(10, 10) == 10 assert bst.rangeSum(1, 2) == 0 assert bst.rangeSum(8, 9) == 0 def test_range_sum_with_negative_values(): bst = BST() bst.insert(-10) bst.insert(-5) bst.insert(0) bst.insert(5) bst.insert(10) assert bst.rangeSum(-10, 10) == 0 assert bst.rangeSum(-5, 5) == 0 assert bst.rangeSum(-7, 7) == 0 def test_range_sum_with_single_value(): bst = BST() bst.insert(10) assert bst.rangeSum(10, 10) == 10 assert bst.rangeSum(5, 15) == 10 assert bst.rangeSum(11, 20) == 0 assert bst.rangeSum(1, 9) == 0 assert bst.rangeSum(-10, 0) == 0 def test_empty_tree(): bst = BST() assert bst.rangeSum(0, 10) == 0","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, node, key): if key < node.key: if node.left is None: node.left = Node(key) else: self._insert_recursive(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert_recursive(node.right, key) def rangeSum(self, low, high): return self._range_sum_recursive(self.root, low, high) def _range_sum_recursive(self, node, low, high): if node is None: return 0 if node.key < low: return self._range_sum_recursive(node.right, low, high) elif node.key > high: return self._range_sum_recursive(node.left, low, high) else: return (node.key + self._range_sum_recursive(node.left, low, high) + self._range_sum_recursive(node.right, low, high))"},{"question":"def search_insert(nums: List[int], target: int) -> int: You are given a sorted array of distinct integers \`nums\` and a target integer \`target\`. Your task is to find the insert position of \`target\` in \`nums\` such that the array remains sorted. If the target is already present in the array, return its position. Return the index at which \`target\` should be inserted in \`nums\` to maintain the sorted order. >>> search_insert([1, 3, 5, 6], 5) 2 >>> search_insert([1, 3, 5, 6], 0) 0 >>> search_insert([1, 3, 5, 6], 7) 4 >>> search_insert([1, 3, 5, 6], 2) 1 >>> search_insert([1, 3, 5, 6], 4) 2 >>> search_insert([1, 3, 5, 6], 3) 1","solution":"def search_insert(nums, target): Returns the index at which target should be inserted in nums to maintain the sorted order. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def find_indices(nums: List[int], x: int) -> bool: You are given an array of integers \`nums\` and an integer \`x\`. You need to find out whether there are two distinct indices \`i\` and \`j\` in the array such that \`nums[i] + nums[j] == x\`. If such indices exist, return \`true\`; otherwise, return \`false\`. >>> find_indices([1, 2, 3, 4], 5) True >>> find_indices([1, 2, 3, 4], 8) False >>> find_indices([-1, -2, -3, -4], -6) True >>> find_indices([-1, 2, 3, -4], -5) True >>> find_indices([1, 3, 5, 7], 14) False >>> find_indices([1], 2) False","solution":"def find_indices(nums, x): Returns true if there are two distinct indices i and j in the array such that nums[i] + nums[j] == x, otherwise false. seen = {} for i, num in enumerate(nums): complement = x - num if complement in seen: return True seen[num] = i return False"},{"question":"def can_form_target(words: List[str], target: str) -> bool: Given an array of strings \`words\` and a \`target\` string, return True if the target string can be formed by concatenating a subsequence of strings from \`words\` in the same order, otherwise return False. >>> can_form_target([\\"ab\\", \\"cde\\", \\"fg\\"], \\"abfg\\") True >>> can_form_target([\\"ab\\", \\"cde\\", \\"fg\\"], \\"abcfg\\") False","solution":"def can_form_target(words, target): Returns True if the target string can be formed by concatenating a subsequence of words from the words list, otherwise returns False. word_indices = 0 target_index = 0 while word_indices < len(words) and target_index < len(target): word = words[word_indices] word_len = len(word) if target.startswith(word, target_index): target_index += word_len word_indices += 1 return target_index == len(target)"},{"question":"def rearrange_max_even_min_odd(arr): Rearranges the elements of the array so that the maximum elements are at the even indices and the minimum elements are at the odd indices. Parameters: arr (list): An array of integers. Returns: list: The rearranged array. >>> rearrange_max_even_min_odd([1]) [1] >>> rearrange_max_even_min_odd([5, 2, 9, 1, 7]) [9, 1, 7, 2, 5] >>> rearrange_max_even_min_odd([6, 3, 8, 1, 7, 4]) [8, 1, 7, 3, 6, 4] >>> rearrange_max_even_min_odd([2, 2, 2, 2]) [2, 2, 2, 2] >>> rearrange_max_even_min_odd([1, 2, 3, 4, 5, 6]) [6, 1, 5, 2, 4, 3] >>> rearrange_max_even_min_odd([6, 5, 4, 3, 2, 1]) [6, 1, 5, 2, 4, 3] >>> rearrange_max_even_min_odd([13, 7, 6, 12, 10]) [13, 6, 12, 7, 10]","solution":"def rearrange_max_even_min_odd(arr): Rearranges the elements of the array so that the maximum elements are at the even indices and the minimum elements are at the odd indices. Parameters: arr (list): An array of integers. Returns: list: The rearranged array. arr_sorted = sorted(arr) result = [0] * len(arr) n = len(arr) even_index = 0 odd_index = 1 for i in range(n-1, -1, -1): result[even_index] = arr_sorted[i] even_index += 2 if even_index >= n: break for i in range((n+1)//2): if odd_index >= n: break result[odd_index] = arr_sorted[i] odd_index += 2 return result"},{"question":"from typing import List def min_cost_with_layover(flights: List[List[int]], src: int, dst: int) -> int: Returns the minimum cost to travel from src to dst with up to one layover. If no such route exists, -1 is returned. >>> min_cost_with_layover([[0, 1, 100], [1, 2, 100], [0, 2, 500]], 0, 2) 200 >>> min_cost_with_layover([[0, 1, 100], [1, 2, 100]], 0, 3) -1 >>> min_cost_with_layover([[0, 1, 100], [1, 2, 200], [0, 2, 150]], 0, 2) 150 >>> min_cost_with_layover([[0, 1, 100], [1, 2, 50], [0, 2, 200]], 0, 2) 150 >>> min_cost_with_layover([[0, 1, 100], [2, 3, 200]], 0, 3) -1","solution":"def min_cost_with_layover(flights, src, dst): Returns the minimum cost to travel from src to dst with up to one layover. If no such route exists, -1 is returned. # Initialize dictionaries to store direct flights and layover flights direct_flights = {} # Direct flights from src layover_flights = {} # Layover flights from intermediate city for flight in flights: from_city, to_city, price = flight # Process direct flight if from_city == src: if to_city not in direct_flights or price < direct_flights[to_city]: direct_flights[to_city] = price # Process layover flight if from_city != src: if from_city not in layover_flights: layover_flights[from_city] = {} layover_flights[from_city][to_city] = price # Calculate minimum costs using direct flight and layover combination min_cost = float('inf') if dst in direct_flights: min_cost = direct_flights[dst] for intermediate_city in direct_flights: if intermediate_city in layover_flights and dst in layover_flights[intermediate_city]: layover_cost = direct_flights[intermediate_city] + layover_flights[intermediate_city][dst] if layover_cost < min_cost: min_cost = layover_cost return min_cost if min_cost != float('inf') else -1"},{"question":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) where 0 <= i < j < len(nums) and nums[i] + nums[j] == target. >>> count_pairs([1, 2, 3, 4], 5) 2 >>> count_pairs([1, 2, 3, 4], 8) 0 >>> count_pairs([1, 3, 2, 2, 3, 1], 4) 2 >>> count_pairs([1], 2) 0 >>> count_pairs([], 5) 0 >>> count_pairs([5, 5, 5, 5], 10) 1 >>> count_pairs([1000000, 2000000, 3000000], 5000000) 1","solution":"def count_pairs(nums, target): Returns the number of unique pairs (i, j) where 0 <= i < j < len(nums) and nums[i] + nums[j] == target. count = 0 seen = set() pairs = set() for i, num in enumerate(nums): complement = target - num if complement in seen: pairs.add((min(complement, num), max(complement, num))) seen.add(num) return len(pairs)"},{"question":"def longest_subsequence_sum_k(nums: List[int], k: int) -> int: Returns the length of the longest subsequence with a sum equal to k. If no such subsequence exists, returns 0. >>> longest_subsequence_sum_k([1, 2, 3, 4, 5], 5) == 2 >>> longest_subsequence_sum_k([5, 1, 1, 2, 2], 5) == 3 >>> longest_subsequence_sum_k([1, 1, 1, 1, 1], 3) == 3 >>> longest_subsequence_sum_k([1, 2, 3], 10) == 0 >>> longest_subsequence_sum_k([], 1) == 0 >>> longest_subsequence_sum_k([1, 2, 3], 7) == 0 >>> longest_subsequence_sum_k([1, 2, 3, 1, 2], 3) == 2 >>> longest_subsequence_sum_k([1, 1, 1, 1, 1], 2) == 2 >>> longest_subsequence_sum_k([2, 2, 2, 2], 8) == 4 >>> longest_subsequence_sum_k([5], 5) == 1","solution":"def longest_subsequence_sum_k(nums, k): Returns the length of the longest subsequence with a sum equal to k. If no such subsequence exists, returns 0. n = len(nums) dp = [-float('inf')] * (k + 1) # Initialize dp array dp[0] = 0 # Base case: sum of 0 with 0 elements for num in nums: for s in range(k, num - 1, -1): if dp[s - num] != -float('inf'): dp[s] = max(dp[s], dp[s - num] + 1) return dp[k] if dp[k] != -float('inf') else 0"},{"question":"def min_adjacent_swaps_to_sort(numbers: List[int]) -> int: Given an integer array 'numbers', determine the minimum number of adjacent swaps required to convert the array into a non-decreasing order. An array is in a non-decreasing order if for every i where 0 <= i < len(numbers) - 1, numbers[i] <= numbers[i + 1]. Return the minimum number of adjacent swaps needed. >>> min_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps_to_sort([5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps_to_sort([3, 1, 2, 4, 5]) 2 >>> min_adjacent_swaps_to_sort([2, 2, 2, 2, 2]) 0 >>> min_adjacent_swaps_to_sort([2, 1, 4, 3, 6, 5]) 3 >>> min_adjacent_swaps_to_sort([1]) 0 >>> min_adjacent_swaps_to_sort([2, 1]) 1 >>> min_adjacent_swaps_to_sort([]) 0","solution":"def count_inversions(numbers): Helper function to count inversions using merge sort. An inversion indicates an out-of-order pair which needs to be swapped to sort the array. # Merge sort and count inversions def merge_sort(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort(arr, temp_arr, left, mid) inv_count += merge_sort(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count # Merge two subarrays of arr[] and count inversions def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count temp_arr = [0]*len(numbers) return merge_sort(numbers, temp_arr, 0, len(numbers)-1) def min_adjacent_swaps_to_sort(numbers): Returns the minimum number of adjacent swaps required to convert the array into a non-decreasing order. return count_inversions(numbers)"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob without triggering the security system. >>> rob([]) == 0 >>> rob([10]) == 10 >>> rob([10, 5]) == 10 >>> rob([5, 10]) == 10 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([2, 1, 1, 2]) == 4 >>> rob([100, 200, 300, 400, 500]) == 900","solution":"def rob(nums): Returns the maximum amount of money you can rob without triggering the security system. :param nums: List of non-negative integers representing the amount of money in each house. :return: Maximum amount of money that can be robbed. if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def coin_change(coins, amount): Returns the fewest number of coins that you need to make up the given amount. If that amount cannot be made up by any combination of the coins, return -1. >>> coin_change([1, 2, 5], 11) 3 >>> coin_change([2], 3) -1 >>> coin_change([1], 0) 0 >>> coin_change([1, 2, 5, 10], 27) 4 >>> coin_change([1, 3, 4, 5], 7) 2 >>> coin_change([2], 4) 2 >>> coin_change([5, 10], 3) -1","solution":"def coin_change(coins, amount): Returns the fewest number of coins that you need to make up the given amount. If that amount cannot be made up by any combination of the coins, return -1. # Create a list to store the minimum number of coins for each amount up to the given amount dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: No coins needed to make amount 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def generate_parentheses(n: int) -> List[str]: Generate all possible strings of length 2*n that consist of balanced parentheses. >>> generate_parentheses(0) [\\"\\"] >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(4) [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"]","solution":"def generate_parentheses(n): Generate all possible strings of length 2*n that consist of balanced parentheses. Parameters: n (int): The number of pairs of parentheses. Returns: List[str]: A list of all balanced parentheses combinations of length 2*n sorted in lexicographical order. result = [] def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) backtrack() return sorted(result)"},{"question":"def bulbSwitch(n, presses): Determines the number of different possible states of the bulbs after m presses. Args: n (int): The number of bulbs. presses (int): The number of presses. Returns: int: The number of possible states the bulbs can be in. >>> bulbSwitch(1, 0) 1 >>> bulbSwitch(2, 0) 1 >>> bulbSwitch(3, 0) 1 >>> bulbSwitch(1, 1) 2 >>> bulbSwitch(1, 2) 2 >>> bulbSwitch(1, 3) 2 >>> bulbSwitch(2, 1) 3 >>> bulbSwitch(2, 2) 4 >>> bulbSwitch(2, 3) 4 >>> bulbSwitch(3, 1) 4 >>> bulbSwitch(3, 2) 7 >>> bulbSwitch(3, 3) 8 >>> bulbSwitch(4, 1) 4 >>> bulbSwitch(4, 2) 8 >>> bulbSwitch(4, 3) 8 >>> bulbSwitch(5, 1) 4 >>> bulbSwitch(5, 2) 8 >>> bulbSwitch(5, 3) 8 >>> bulbSwitch(100, 1) 4 >>> bulbSwitch(100, 2) 8 >>> bulbSwitch(100, 3) 8","solution":"def bulbSwitch(n, presses): Determines the number of different possible states of the bulbs after m presses. if presses == 0: return 1 if n == 1: return 2 if n == 2: return 3 if presses == 1 else 4 if presses == 1: return 4 if presses == 2: return 7 if n == 3 else 8 return 8"},{"question":"import heapq from collections import defaultdict def highest_quality_path(n, edges, quality): Return the highest quality of any path between nodes 1 and n. If there is no path between nodes 1 and n, return -1. >>> highest_quality_path(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1)], [5, 4, 3, 2]) == 2 >>> highest_quality_path(4, [(1, 2, 1), (3, 4, 1)], [5, 4, 3, 2]) == -1 >>> highest_quality_path(1, [], [5]) == 5 >>> highest_quality_path(4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], [5, 4, 3, 6]) == 5 >>> highest_quality_path(2, [(1, 2, 1)], [10, 8]) == 8","solution":"import heapq from collections import defaultdict def highest_quality_path(n, edges, quality): # Create an adjacency list to represent the graph graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Use Dijkstra's algorithm to find the maximum quality path from node 1 to node n pq = [(-quality[0], 1)] # Use a max-heap by inserting negative quality values max_quality = {1: quality[0]} while pq: curr_quality, node = heapq.heappop(pq) curr_quality = -curr_quality if node == n: return curr_quality for neighbor, weight in graph[node]: path_quality = min(curr_quality, quality[neighbor - 1]) if neighbor not in max_quality or path_quality > max_quality[neighbor]: max_quality[neighbor] = path_quality heapq.heappush(pq, (-path_quality, neighbor)) return -1"},{"question":"def sum_of_maximums(arr, k): Returns the sum of the maximum values of all subarrays of size k. :param arr: List of integers :param k: Size of the subarrays :return: Sum of the maximum values of all subarrays of size k >>> sum_of_maximums([1, 3, -1, -3, 5, 3, 6, 7], 3) == 29 >>> sum_of_maximums([4, 2, 8, 6, 7], 1) == 4 + 2 + 8 + 6 + 7 >>> sum_of_maximums([4, 2, 8, 6, 7], 5) == 8 >>> sum_of_maximums([], 3) == 0 >>> sum_of_maximums([1, 2, 3], 5) == 0 >>> sum_of_maximums([1, 2, 3], 0) == 0 >>> sum_of_maximums([-1, -3, -5, -7], 2) == -1 + -3 + -5","solution":"def sum_of_maximums(arr, k): Returns the sum of the maximum values of all subarrays of size k. :param arr: List of integers :param k: Size of the subarrays :return: Sum of the maximum values of all subarrays of size k if not arr or k <= 0 or k > len(arr): return 0 from collections import deque n = len(arr) max_sum = 0 deq = deque() for i in range(k): while deq and arr[i] >= arr[deq[-1]]: deq.pop() deq.append(i) for i in range(k, n): max_sum += arr[deq[0]] while deq and deq[0] <= i - k: deq.popleft() while deq and arr[i] >= arr[deq[-1]]: deq.pop() deq.append(i) max_sum += arr[deq[0]] return max_sum"},{"question":"from typing import List def minimum_threshold(heights: List[List[int]]) -> int: Determine the minimum value of threshold required to go from the top-left corner of the grid to the bottom-right corner. If it is impossible to traverse from the top-left to the bottom-right, return \`-1\`. >>> heights = [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ] >>> minimum_threshold(heights) 2 >>> heights = [ ... [1, 10, 6], ... [9, 3, 15], ... [10, 2, 5] ... ] >>> minimum_threshold(heights) 8","solution":"from typing import List, Tuple import heapq def minimum_threshold(heights: List[List[int]]) -> int: def can_traverse(threshold: int) -> bool: m, n = len(heights), len(heights[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] heap = [(0, 0, 0)] # (cost, x, y) heapq.heapify(heap) visited[0][0] = True while heap: cost, x, y = heapq.heappop(heap) if x == m-1 and y == n-1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: diff = abs(heights[nx][ny] - heights[x][y]) if diff <= threshold: visited[nx][ny] = True heapq.heappush(heap, (cost + diff, nx, ny)) return False if not heights or not heights[0]: return -1 left, right = 0, max(max(row) for row in heights) result = -1 while left <= right: mid = (left + right) // 2 if can_traverse(mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"def diagonal_sum(grid: List[List[int]]) -> int: Calculate the sum of the elements along the two diagonals in a square matrix. The primary diagonal runs from the upper-left to the bottom-right corner, and the secondary diagonal runs from the upper-right to the bottom-left corner. The center element, which belongs to both diagonals, is only counted once. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> diagonal_sum(grid) 25 >>> grid = [[5]] >>> diagonal_sum(grid) 5 >>> grid = [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ] >>> diagonal_sum(grid) 117 >>> grid = [ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ] >>> diagonal_sum(grid) 10 >>> grid = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ] >>> diagonal_sum(grid) -25 pass","solution":"def diagonal_sum(grid): n = len(grid) primary_diagonal_sum = sum(grid[i][i] for i in range(n)) secondary_diagonal_sum = sum(grid[i][n-1-i] for i in range(n)) # Subtract the middle element as it will be counted twice middle_element = grid[n//2][n//2] return primary_diagonal_sum + secondary_diagonal_sum - middle_element"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseKGroup(head, k): Reverse the nodes of the list k nodes at a time, and return the modified list. >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1, 2, 3, 4, 5]), 2)) == [2, 1, 4, 3, 5] >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1, 2, 3, 4, 5]), 3)) == [3, 2, 1, 4, 5] >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1, 2]), 2)) == [2, 1] >>> linked_list_to_list(reverseKGroup(list_to_linked_list([1]), 1)) == [1]","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseKGroup(head, k): if head is None or k == 1: return head dummy = ListNode(0) dummy.next = head curr, prev, next = head, dummy, None count = 0 while curr: curr = curr.next count += 1 while count >= k: curr = prev.next next = curr.next for i in range(1, k): curr.next = next.next next.next = prev.next prev.next = next next = curr.next prev = curr count -= k return dummy.next"},{"question":"def max_area_of_island(matrix): Returns the maximum area of an island in the given 2D matrix. An island is a group of \`1\`s connected horizontally or vertically. If there are no islands, return \`0\`. :param matrix: 2D list of integers representing the grid of \`0\`s and \`1\`s :return: Integer representing the maximum area of an island >>> max_area_of_island([[0, 1, 0, 0], [1, 1, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0]]) 4 >>> max_area_of_island([[1, 0, 0, 1], [1, 0, 1, 1], [0, 0, 0, 0], [1, 1, 0, 0]]) 3 >>> max_area_of_island([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 0 >>> max_area_of_island([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) 16 >>> max_area_of_island([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]) 0","solution":"def max_area_of_island(matrix): Returns the maximum area of an island in the given 2D matrix. if not matrix or not matrix[0]: return 0 max_area = 0 rows, cols = len(matrix), len(matrix[0]) def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or matrix[r][c] == 0: return 0 matrix[r][c] = 0 # mark as visited area = 1 area += dfs(r+1, c) area += dfs(r-1, c) area += dfs(r, c+1) area += dfs(r, c-1) return area for r in range(rows): for c in range(cols): if matrix[r][c] == 1: max_area = max(max_area, dfs(r, c)) return max_area"},{"question":"from collections import Counter def is_anagram_substring(s: str, t: str) -> bool: Returns True if t is an anagram of a substring of s, otherwise False. >>> is_anagram_substring(\\"abcdefghijkl\\", \\"hgf\\") True >>> is_anagram_substring(\\"abcdef\\", \\"abc\\") True >>> is_anagram_substring(\\"abcdef\\", \\"xyz\\") False >>> is_anagram_substring(\\"ababab\\", \\"aabb\\") True","solution":"from collections import Counter def is_anagram_substring(s, t): Returns True if t is an anagram of a substring of s, otherwise False. len_s = len(s) len_t = len(t) if len_t > len_s: return False t_counter = Counter(t) window_counter = Counter(s[:len_t]) if t_counter == window_counter: return True for i in range(len_t, len_s): window_counter[s[i]] += 1 window_counter[s[i - len_t]] -= 1 if window_counter[s[i - len_t]] == 0: del window_counter[s[i - len_t]] if t_counter == window_counter: return True return False"},{"question":"class TreeNode: def __init__(self, value=0, children=None): self.value = value self.children = children if children is not None else [] def minimize_directory_size(root: TreeNode) -> int: Given the root of a binary tree where each node represents a directory with an integer value representing the size of files within that directory, return the minimum total size that can be achieved by deleting the appropriate directories. >>> minimize_directory_size(TreeNode(5)) == 5 >>> minimize_directory_size(TreeNode(5, [TreeNode(10, [TreeNode(20)])])) == 5 >>> minimize_directory_size(TreeNode(5, [TreeNode(1), TreeNode(2), TreeNode(3)])) == 5 >>> minimize_directory_size( ... TreeNode(5, [TreeNode(6, [TreeNode(2), TreeNode(3)]), TreeNode(4, [TreeNode(8), TreeNode(1)])])) == 5 >>> minimize_directory_size(TreeNode(20, [TreeNode(5), TreeNode(5)])) == 10 >>> minimize_directory_size(TreeNode(3, [TreeNode(4), TreeNode(5)])) == 3 >>> minimize_directory_size(TreeNode(2, [TreeNode(2), TreeNode(2)])) == 2","solution":"class TreeNode: def __init__(self, value=0, children=None): self.value = value self.children = children if children is not None else [] def minimize_directory_size(root: TreeNode) -> int: def recursive_min_size(node: TreeNode) -> int: if not node.children: return node.value child_sizes = [recursive_min_size(child) for child in node.children] return min(node.value, sum(child_sizes)) return recursive_min_size(root)"},{"question":"def exist(grid: List[List[str]], word: str) -> bool: Determines if the word exists in the grid by moving through adjacent cells. :param grid: List[List[str]], grid of letters. :param word: str, the word to be searched for. :return: bool, True if the word can be constructed, otherwise False. Example: >>> exist([[\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"]], \\"ABCCED\\") True >>> exist([[\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"]], \\"ABCB\\") False >>> exist([[\\"A\\"]], \\"A\\") True >>> exist([[\\"A\\", \\"B\\"], [\\"C\\", \\"D\\"]], \\"E\\") False >>> exist([[\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"E\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"]], \\"ABCESEEEFS\\") True","solution":"def exist(grid, word): Determines if the word exists in the grid by moving through adjacent cells. :param grid: List[List[str]], grid of letters :param word: str, the word to be searched for :return: bool, True if the word can be constructed, otherwise False def dfs(x, y, index): if index == len(word): return True if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or word[index] != grid[x][y]: return False temp = grid[x][y] grid[x][y] = '#' # mark as visited # Explore all possible directions: up, down, left, right result = (dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1)) grid[x][y] = temp # restore the original value return result for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == word[0]: # start DFS if the first letter matches if dfs(i, j, 0): return True return False"},{"question":"def rotate_image(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n 2D matrix representing an image by 90 degrees (clockwise). :param matrix: List[List[int]], the input n x n 2D matrix :return: List[List[int]], the rotated matrix >>> rotate_image([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_image([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] >>> rotate_image([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ] >>> rotate_image([[1]]) [[1]] >>> rotate_image([ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ]) [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ]","solution":"def rotate_image(matrix): Rotates the given n x n 2D matrix representing an image by 90 degrees (clockwise). :param matrix: List[List[int]], the input n x n 2D matrix :return: List[List[int]], the rotated matrix n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: You are given a matrix of size \`m x n\` representing a grid of rooms, where: - \`-1\` represents a wall or an obstacle, - \`0\` represents a gate, and - \`INF\` represents an empty room. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should remain \`INF\`. >>> INF = float('inf') >>> rooms = [ ... [INF, -1, 0, INF], ... [INF, INF, INF, -1], ... [INF, -1, INF, -1], ... [0, -1, INF, INF] ... ] >>> walls_and_gates(rooms) >>> rooms [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] def test_walls_and_gates(): INF = float('inf') def test_walls_and_gates_general_case(): rooms = [ [INF, -1, 0, INF], [INF, INF, INF, -1], [INF, -1, INF, -1], [0, -1, INF, INF] ] expected = [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] walls_and_gates(rooms) assert rooms == expected def test_walls_and_gates_empty_grid(): rooms = [] expected = [] walls_and_gates(rooms) assert rooms == expected def test_walls_and_gates_no_gates(): rooms = [ [INF, -1, INF], [-1, INF, -1], [INF, -1, INF] ] expected = [ [INF, -1, INF], [-1, INF, -1], [INF, -1, INF] ] walls_and_gates(rooms) assert rooms == expected def test_walls_and_gates_all_gates(): rooms = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] expected = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] walls_and_gates(rooms) assert rooms == expected def test_walls_and_gates_all_walls(): rooms = [ [-1, -1, -1], [-1, -1, -1], [-1, -1, -1] ] expected = [ [-1, -1, -1], [-1, -1, -1], [-1, -1, -1] ] walls_and_gates(rooms) assert rooms == expected def test_walls_and_gates_mix_case(): rooms = [ [0, INF, INF], [INF, -1, INF], [INF, INF, INF] ] expected = [ [0, 1, 2], [1, -1, 3], [2, 3, 4] ] walls_and_gates(rooms) assert rooms == expected test_walls_and_gates_general_case() test_walls_and_gates_empty_grid() test_walls_and_gates_no_gates() test_walls_and_gates_all_gates() test_walls_and_gates_all_walls() test_walls_and_gates_mix_case()","solution":"from collections import deque def walls_and_gates(rooms): if not rooms: return m, n = len(rooms), len(rooms[0]) INF = float('inf') queue = deque() # Initially, add all gates to the queue for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from all gates simultaneously while queue: x, y = queue.popleft() for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)): nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"def smallest_missing_positive(matrix: List[List[int]]) -> int: Returns the smallest positive integer that does not appear in the matrix. >>> smallest_missing_positive([ [1, 2, 3], [4, 5, 6], [-1, 7, 8] ]) == 9 >>> smallest_missing_positive([ [-1, -2, -3], [-4, -5, -6] ]) == 1 >>> smallest_missing_positive([ [0, 2, 3], [1, 4, 5] ]) == 6 >>> smallest_missing_positive([ [1, 2, 4], [5, 6, 7] ]) == 3 >>> smallest_missing_positive([]) == 1 >>> smallest_missing_positive([ [1, 1, 1], [2, 2, 2] ]) == 3 >>> smallest_missing_positive([ [100, 200], [300, 400] ]) == 1","solution":"def smallest_missing_positive(matrix): Returns the smallest positive integer that does not appear in the matrix. # Flatten the matrix into a list nums = [num for row in matrix for num in row if num > 0] # Remove duplicates by converting to a set nums_set = set(nums) # Start checking from number 1 smallest_missing = 1 # Increment smallest_missing until we find a number that's not in nums_set while smallest_missing in nums_set: smallest_missing += 1 return smallest_missing"},{"question":"from typing import List def longest_unique_substring_length(s: str) -> int: Given a string \`s\` consisting of only lowercase letters, return the length of the longest substring with all distinct characters. The function should ensure that the algorithm has a time complexity of O(n), where \`n\` is the length of the string. >>> longest_unique_substring_length(\\"\\") == 0 >>> longest_unique_substring_length(\\"a\\") == 1 >>> longest_unique_substring_length(\\"abcdef\\") == 6 >>> longest_unique_substring_length(\\"abcabcbb\\") == 3 >>> longest_unique_substring_length(\\"bbbbb\\") == 1 >>> longest_unique_substring_length(\\"pwwkew\\") == 3 >>> longest_unique_substring_length(\\"abrkaabcdefghijjxxx\\") == 10","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with all distinct characters. n = len(s) if n == 0: return 0 max_length = 0 char_index_map = {} start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"import heapq from collections import Counter def rearrange_string(s: str) -> str: Rearranges the characters of the string s such that no two adjacent characters are the same. Returns an empty string if such an arrangement is not possible. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"aaaa\\") \\"\\" >>> rearrange_string(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] True","solution":"import heapq from collections import Counter def rearrange_string(s): Rearranges the characters of the string s such that no two adjacent characters are the same. Returns an empty string if such arrangement is not possible. if not s: return \\"\\" # Count the frequency of each character count = Counter(s) max_heap = [(-freq, char) for char, freq in count.items()] # Create a max heap based on count heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # If prev_freq is still negative, we put it back to heap if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Decrease the count of the current char and set it as previous prev_freq = freq + 1 prev_char = char result_str = ''.join(result) # Check if the rearranged string's length is same as original string's length if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Given the root of a binary tree, returns the maximum depth. >>> max_depth(None) 0 >>> root = TreeNode(1) >>> max_depth(root) 1 >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> max_depth(root) 3 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> max_depth(root) 3 >>> root.left.left.left = TreeNode(6) >>> max_depth(root) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Given the root of a binary tree, returns the maximum depth. if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restores the string to its original order based on the provided indices. >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) == \\"leetcode\\" >>> restore_string(\\"a\\", [0]) == \\"a\\" >>> restore_string(\\"abcd\\", [3,2,1,0]) == \\"dcba\\" >>> restore_string(\\"aiohn\\", [3,1,4,2,0]) == \\"nihao\\" >>> restore_string(\\"abcdef\\", [0, 1, 2, 3, 4, 5]) == \\"abcdef\\"","solution":"def restore_string(s, indices): Restores the string to its original order based on the provided indices. Parameters: s (str): the shuffled string. indices (list): the list of indices indicating the original position. Returns: str: the restored string in its original order. restored = [''] * len(s) for i, index in enumerate(indices): restored[index] = s[i] return ''.join(restored)"},{"question":"def subset_sum(prices: List[int], M: int) -> bool: Determines if there exists a subset of prices that adds up to the target amount M. >>> subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> subset_sum([3, 34, 4, 12, 5, 2], 30) False >>> subset_sum([3, 34, 4, 12, 5, 2], 0) True >>> subset_sum([10], 10) True >>> subset_sum([10], 5) False >>> subset_sum([], 0) True >>> subset_sum([], 10) False >>> subset_sum([1, 2, 3, 4, 5], 10) True","solution":"def subset_sum(prices, M): Determines if there exists a subset of prices that adds up to M. :param prices: List of integers representing the prices of items. :param M: Integer representing the target amount. :return: True if there exists a subset of prices that add up to M, otherwise False. n = len(prices) subset = [[False] * (M + 1) for _ in range(n + 1)] # Initialize the first column as True, since a sum of 0 can always be achieved with an empty set. for i in range(n + 1): subset[i][0] = True # Fill the subset table in bottom up manner for i in range(1, n + 1): for j in range(1, M + 1): if prices[i - 1] > j: subset[i][j] = subset[i - 1][j] else: subset[i][j] = subset[i - 1][j] or subset[i - 1][j - prices[i - 1]] return subset[n][M]"},{"question":"from typing import List def split_into_non_decreasing_subsequences(s: str) -> List[str]: Splits the input string s into the lexicographically smallest sequence of non-decreasing subsequences. :param s: str - An input string containing only digits :return: List[str] - List of non-decreasing subsequences which is lexicographically smallest >>> split_into_non_decreasing_subsequences(\\"5\\") [\\"5\\"] >>> split_into_non_decreasing_subsequences(\\"1111\\") [\\"1111\\"] >>> split_into_non_decreasing_subsequences(\\"123\\") [\\"123\\"] >>> split_into_non_decreasing_subsequences(\\"321\\") [\\"3\\", \\"2\\", \\"1\\"] >>> split_into_non_decreasing_subsequences(\\"132\\") [\\"13\\", \\"2\\"] >>> split_into_non_decreasing_subsequences(\\"54321\\") [\\"5\\", \\"4\\", \\"3\\", \\"2\\", \\"1\\"] >>> split_into_non_decreasing_subsequences(\\"112233\\") [\\"112233\\"] >>> split_into_non_decreasing_subsequences(\\"\\") [\\"\\"]","solution":"def split_into_non_decreasing_subsequences(s): Splits the input string s into the lexicographically smallest sequence of non-decreasing subsequences. :param s: str - An input string containing only digits :return: List[List[str]] - List of non-decreasing subsequences which is lexicographically smallest subsequences = [[]] for char in s: placed = False for subseq in subsequences: if not subseq or subseq[-1] <= char: subseq.append(char) placed = True break if not placed: subsequences.append([char]) return [\\"\\".join(subseq) for subseq in subsequences]"},{"question":"import heapq from typing import List def min_time_to_complete_tasks(task_durations: List[int], workers: int) -> int: Returns the minimum time required to complete all tasks using the specified number of workers. Parameters: task_durations: list of integers representing task durations workers: integer representing the number of available workers Returns: Integer representing the minimum time required to complete all tasks. pass def test_no_tasks(): assert min_time_to_complete_tasks([], 3) == 0 def test_single_task(): assert min_time_to_complete_tasks([5], 3) == 5 def test_multiple_tasks_single_worker(): assert min_time_to_complete_tasks([2, 2, 3, 7], 1) == 14 def test_multiple_tasks_multiple_workers(): assert min_time_to_complete_tasks([2, 2, 3, 7], 2) == 9 def test_equal_task_duration_and_workers(): assert min_time_to_complete_tasks([3, 3, 3], 3) == 3 def test_more_workers_than_tasks(): assert min_time_to_complete_tasks([3, 2], 5) == 3 def test_tasks_with_varying_durations(): assert min_time_to_complete_tasks([1, 2, 3, 4, 5], 2) == 9","solution":"import heapq def min_time_to_complete_tasks(task_durations, workers): Returns the minimum time required to complete all tasks using the specified number of workers. Parameters: task_durations: list of integers representing task durations workers: integer representing the number of available workers Returns: Integer representing the minimum time required to complete all tasks. if not task_durations: return 0 # Use a min-heap to keep track of the end time of tasks assigned to each worker min_heap = [0] * workers # Assign tasks to workers greedily for duration in task_durations: # Extract the worker with the earliest end time earliest_end_time = heapq.heappop(min_heap) # Assign the next task to this worker new_end_time = earliest_end_time + duration # Push the new end time back into the heap heapq.heappush(min_heap, new_end_time) # The overall completion time is the maximum of the end times in the heap return max(min_heap)"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Restore the given string to all possible valid IP address combinations. A valid IP address may be in the form of \\"0.0.0.0\\" to \\"255.255.255.255\\". Each segment of the IP address must have a value between 0 and 255, and cannot contain leading zeros, except for \\"0\\" itself which is a valid segment. Given a string s, find all such possible IP addresses. Examples: >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> restore_ip_addresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] >>> restore_ip_addresses(\\"123\\") [] >>> restore_ip_addresses(\\"1234567890123\\") [] >>> restore_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"] >>> restore_ip_addresses(\\"999999999999\\") []","solution":"def restore_ip_addresses(s): def is_valid(segment): # Check if the segment is between 0 and 255 if segment.startswith('0') and len(segment) > 1: return False return 0 <= int(segment) <= 255 def backtrack(start=0, path=[]): # If we have 4 segments and we've used up all the digits, it's a valid IP. if len(path) == 4: if start == len(s): result.append('.'.join(path)) return # Try segments of length 1, 2, and 3 for length in range(1, 4): if start + length > len(s): break segment = s[start:start+length] if is_valid(segment): backtrack(start+length, path+[segment]) result = [] backtrack() return result"},{"question":"def count_valid_subarrays(arr: List[int], k: int) -> int: Returns the total number of valid subarrays of length k whose sum is divisible by k. >>> count_valid_subarrays([1, 2, 3, 4, 5], 2) == 0 >>> count_valid_subarrays([1, 2, 3, 4, 6], 2) == 1 >>> count_valid_subarrays([2, 4, 6, 8, 10], 2) == 4 >>> count_valid_subarrays([1, 2, 3], 3) == 1 >>> count_valid_subarrays([1, 2, 3], 4) == 0 >>> count_valid_subarrays([], 1) == 0 >>> count_valid_subarrays([2, 2, 2, 2], 2) == 3 pass","solution":"def count_valid_subarrays(arr, k): Returns the number of valid subarrays of length k whose sum is divisible by k. n = len(arr) if k > n: return 0 count = 0 for i in range(n - k + 1): subarray_sum = sum(arr[i:i+k]) if subarray_sum % k == 0: count += 1 return count"},{"question":"def find_original_array(nums: List[int], k: int) -> List[int]: Given the array nums where nums[i] is the absolute difference between an original value and a target value k (which is the median), return the original array. Example: >>> find_original_array([2, 3, 1], 5) [7, 8, 6] >>> find_original_array([0, 0, 0], 5) [5, 5, 5] >>> find_original_array([5, 5, 5], 5) [10, 10, 10] >>> find_original_array([1, 1, 1, 1], 4) [5, 5, 5, 5] >>> find_original_array([3, 2, 1, 0], 3) [6, 5, 4, 3]","solution":"def find_original_array(nums, k): Given the array nums where nums[i] is the absolute difference between an original value and a target value k (which is the median), return the original array. original = [] for num in nums: original.append(k + num) return original # Example: # If the target value (k) is 5 and nums = [2, 3, 1], # the original values should be [7, 8, 6] because 5 + 2 = 7, 5 + 3 = 8, 5 + 1 = 6 # There's a second possible result where the original values could be [3, 2, 4] # because 5 - 2 = 3, 5 - 3 = 2 and 5 - 1 = 4 # To simplify we just consider the addition method for this implementation."},{"question":"def max_items_within_budget(arr: List[int], budget: int) -> int: Returns the maximum number of items that can be purchased without exceeding the given budget. :param arr: List of integers representing the cost of items. :param budget: Integer representing the budget. :return: Integer representing the maximum number of items that can be purchased. >>> max_items_within_budget([1, 2, 3, 4], 10) 4 >>> max_items_within_budget([1, 5, 3, 2, 4], 8) 3 >>> max_items_within_budget([5, 7, 8, 10], 4) 0 >>> max_items_within_budget([1, 2, 2, 3], 6) 3 >>> max_items_within_budget([], 10) 0 >>> max_items_within_budget([1, 2, 3], 0) 0 >>> max_items_within_budget([5, 4, 3, 2, 1], 50) 5 pass","solution":"def max_items_within_budget(arr, budget): Returns the maximum number of items that can be purchased without exceeding the given budget. :param arr: List of integers representing the cost of items. :param budget: Integer representing the budget. :return: Integer representing the maximum number of items that can be purchased. arr.sort() # Sort the array to consider cheaper items first total_cost = 0 items_count = 0 for cost in arr: if total_cost + cost <= budget: total_cost += cost items_count += 1 else: break return items_count"},{"question":"def minimum_height_to_reach_destination(m: int, n: int, grid: List[List[int]]) -> int: Determines the minimum height that the raft needs to lower to in order to reach the bottom-right cell (m-1, n-1) from the top-left cell (0, 0). >>> minimum_height_to_reach_destination(3, 3, [[1, 2, 2], [3, 8, 2], [5, 3, 5]]) == 5 >>> minimum_height_to_reach_destination(3, 3, [[5, 4, 5], [1, 2, 6], [7, 4, 6]]) == 6 >>> minimum_height_to_reach_destination(2, 2, [[0, 1], [1, 0]]) == 1 >>> minimum_height_to_reach_destination(2, 2, [[3, 3], [1, 0]]) == 3 >>> minimum_height_to_reach_destination(4, 4, [[1, 10, 6, 7], [8, 6, 7, 8], [1, 1, 1, 1], [9, 1, 1, 1]]) == 8","solution":"import heapq def minimum_height_to_reach_destination(m, n, grid): Determines the minimum height that the raft needs to lower to in order to reach the bottom-right cell (m-1, n-1) from the top-left cell (0, 0). def is_valid(x, y): return 0 <= x < m and 0 <= y < n directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] min_heap = [(grid[0][0], 0, 0)] visited = [[False] * n for _ in range(m)] visited[0][0] = True while min_heap: curr_height, x, y = heapq.heappop(min_heap) if (x, y) == (m-1, n-1): return curr_height for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True heapq.heappush(min_heap, (max(curr_height, grid[nx][ny]), nx, ny))"},{"question":"def find_minimum_pages(A: List[int], N: int, K: int) -> int: Allocate books to students such that the maximum number of pages assigned to a student is minimized. Each student must be assigned at least one book and books must be assigned contiguously. Args: A (List[int]): List of integers representing the number of pages in each book. N (int): Total number of books. K (int): Number of students. Returns: int: The minimum possible value of the maximum number of pages assigned to a student, or -1 if allocation is not possible. Example: >>> find_minimum_pages([12, 34, 67, 90], 4, 2) 113 >>> find_minimum_pages([12, 34, 67, 90], 4, 5) -1","solution":"def is_valid_distribution(A, N, K, max_pages): required_students = 1 current_pages = 0 for pages in A: if current_pages + pages > max_pages: required_students += 1 current_pages = pages if required_students > K: return False else: current_pages += pages return True def find_minimum_pages(A, N, K): if K > N: return -1 # More students than books, impossible to allocate low = max(A) high = sum(A) result = high while low <= high: mid = (low + high) // 2 if is_valid_distribution(A, N, K, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"from typing import List def maxNumberOfEventDays(events: List[List[int]], k: int) -> int: You are given an array called \`events\`, where \`events[i]\` represents the start and end day of the \`i-th\` event. Also, you are given a positive integer \`k\`, which denotes the maximum number of events you can attend. Your goal is to find the maximum number of days you can be engaged in events by attending at most \`k\` events. Each event \`events[i]\` is given as a pair [starti, endi] and they are sorted by their start day. Write an algorithm to return the maximum number of days you can attend the events. >>> maxNumberOfEventDays([[1, 2], [2, 3], [3, 4]], 2) 2 >>> maxNumberOfEventDays([[1, 2], [2, 3], [3, 4], [4, 5]], 2) 2 >>> maxNumberOfEventDays([[1, 2], [2, 3], [3, 4]], 1) 1 >>> maxNumberOfEventDays([[1, 10], [2, 3], [3, 4], [4, 5]], 2) 2 >>> maxNumberOfEventDays([[1, 10], [10, 20], [20, 30]], 3) 3","solution":"def maxNumberOfEventDays(events, k): events.sort(key=lambda x: x[1]) # sort events by their end days attended_days = [0] * 100000 # assume largest day can be 100000 number_of_events_attended = 0 for event in events: start, end = event for day in range(start, end + 1): if attended_days[day] == 0 and number_of_events_attended < k: attended_days[day] = 1 number_of_events_attended += 1 break return sum(attended_days) # Example usage: # events = [[1, 2], [2, 3], [3, 4]] # k = 2 # print(maxNumberOfEventDays(events, k)) # Output: 2 (can choose event [1, 2] and event [3, 4])"},{"question":"from typing import List from collections import Counter def longest_palindrome(s: str) -> str: Returns the longest palindrome that can be formed by rearranging the characters in s. If there are multiple palindromes with the maximum length, returns any one of them. >>> longest_palindrome('a') == 'a' >>> longest_palindrome('aa') == 'aa' >>> longest_palindrome('ab') in {'a', 'b'} >>> longest_palindrome('aabb') in {'abba', 'baab'} >>> longest_palindrome('aaabb') in {'ababa'} >>> longest_palindrome('aabbcc') in {'abccba', 'bacab', 'baccab'} >>> len(longest_palindrome('aabbcddca')) == 9 >>> longest_palindrome('abc') in {'a', 'b', 'c'}","solution":"from collections import Counter def longest_palindrome(s): Returns the longest palindrome that can be formed by rearranging the characters in s. If there are multiple palindromes with the maximum length, returns any one of them. char_count = Counter(s) mid_char = '' left_half = [] for char, count in char_count.items(): if count % 2 != 0: mid_char = char left_half.extend([char] * (count // 2)) left_half = ''.join(sorted(left_half)) right_half = left_half[::-1] return left_half + (mid_char if mid_char else '') + right_half"},{"question":"from typing import List def longestSubarray(arr: List[int], limit: int) -> int: Returns the length of the longest continuous subarray where the absolute difference between any two elements is less than or equal to limit. Examples: >>> longestSubarray([8, 2, 4, 7], 4) 2 >>> longestSubarray([10, 1, 2, 4, 7, 2], 5) 4 >>> longestSubarray([4, 2, 2, 2, 4, 4, 2, 2], 0) 3 >>> longestSubarray([4], 5) 1 >>> longestSubarray([1, 1, 1, 1, 1], 0) 5","solution":"from collections import deque def longestSubarray(arr, limit): Returns the length of the longest continuous subarray where the absolute difference between any two elements is less than or equal to limit. max_deque = deque() min_deque = deque() left = 0 result = 0 for right, value in enumerate(arr): while max_deque and value > max_deque[-1]: max_deque.pop() max_deque.append(value) while min_deque and value < min_deque[-1]: min_deque.pop() min_deque.append(value) if max_deque[0] - min_deque[0] > limit: if max_deque[0] == arr[left]: max_deque.popleft() if min_deque[0] == arr[left]: min_deque.popleft() left += 1 result = max(result, right - left + 1) return result"},{"question":"from typing import List def longest_str_chain(words: List[str]) -> int: Determine the length of the longest chain of words where each word in the chain is formed by adding exactly one letter to the previous word while rearranging the letters. >>> longest_str_chain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) 4 >>> longest_str_chain([\\"xbc\\", \\"pcxbcf\\", \\"xb\\", \\"cxbc\\", \\"pcxbc\\"]) 5 >>> longest_str_chain([\\"abcd\\", \\"dbqca\\"]) 1 >>> longest_str_chain([\\"a\\"]) 1 >>> longest_str_chain([\\"a\\", \\"z\\", \\"x\\", \\"y\\", \\"w\\", \\"b\\"]) 1","solution":"from collections import defaultdict def longest_str_chain(words): words.sort(key=len) dp = defaultdict(int) max_chain_length = 0 for word in words: current_length = 1 for i in range(len(word)): predecessor = word[:i] + word[i+1:] if predecessor in dp: current_length = max(current_length, dp[predecessor] + 1) dp[word] = current_length max_chain_length = max(max_chain_length, current_length) return max_chain_length"},{"question":"def count_unique_substrings(s: str, k: int) -> int: Returns the number of unique substrings of length k in the given string s. >>> count_unique_substrings(\\"abcabc\\", 3) 3 >>> count_unique_substrings(\\"abc\\", 4) 0 >>> count_unique_substrings(\\"\\", 1) 0 >>> count_unique_substrings(\\"aaaa\\", 2) 1 >>> count_unique_substrings(\\"ababab\\", 2) 2 >>> count_unique_substrings(\\"abcd\\", 1) 4 >>> count_unique_substrings(\\"aaa\\", 1) 1 >>> count_unique_substrings(\\"abcdef\\", 6) 1 >>> count_unique_substrings(\\"aaaaaa\\", 6) 1 >>> count_unique_substrings(\\"abcabcabc\\", 3) 3 >>> count_unique_substrings(\\"abcdefg\\", 2) 6","solution":"def count_unique_substrings(s, k): Returns the number of unique substrings of length k in the given string s. if k > len(s): return 0 unique_substrings = set() for i in range(len(s) - k + 1): substring = s[i:i+k] unique_substrings.add(substring) return len(unique_substrings)"},{"question":"def longest_substring_with_k_distinct(t: str, k: int) -> str: Finds and returns the longest substring of t that contains at most k distinct characters. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) \\"ece\\" >>> longest_substring_with_k_distinct(\\"aa\\", 1) \\"aa\\" >>> longest_substring_with_k_distinct(\\"aa\\", 0) \\"\\" >>> longest_substring_with_k_distinct(\\"\\", 2) \\"\\" >>> longest_substring_with_k_distinct(\\"aabbccdd\\", 2) \\"aabb\\" >>> longest_substring_with_k_distinct(\\"aabbccdd\\", 10) \\"aabbccdd\\"","solution":"def longest_substring_with_k_distinct(t, k): Finds and returns the longest substring of t that contains at most k distinct characters. if k == 0 or not t: return \\"\\" window_start = 0 max_length = 0 max_substr = \\"\\" char_frequency = {} for window_end in range(len(t)): end_char = t[window_end] if end_char not in char_frequency: char_frequency[end_char] = 0 char_frequency[end_char] += 1 while len(char_frequency) > k: start_char = t[window_start] char_frequency[start_char] -= 1 if char_frequency[start_char] == 0: del char_frequency[start_char] window_start += 1 if (window_end - window_start + 1) > max_length: max_length = window_end - window_start + 1 max_substr = t[window_start:window_end+1] return max_substr"},{"question":"def canFormPalindrome(s: str, start: int, end: int) -> bool: Determine if the substring of \`s\` from \`start\` to \`end-1\` can be rearranged to form a palindrome. :param s: Original string :param start: Start index of the substring :param end: End index of the substring (exclusive) :return: True if the substring can be rearranged to form a palindrome, False otherwise >>> canFormPalindrome(\\"civic\\", 0, 5) == True >>> canFormPalindrome(\\"hello\\", 0, 5) == False >>> canFormPalindrome(\\"aabbcc\\", 0, 6) == True >>> canFormPalindrome(\\"a\\", 0, 1) == True >>> canFormPalindrome(\\"abcd\\", 0, 4) == False >>> canFormPalindrome(\\"abcba\\", 0, 5) == True >>> canFormPalindrome(\\"racecar\\", 0, 7) == True >>> canFormPalindrome(\\"racecar\\", 1, 6) == True >>> canFormPalindrome(\\"racecar\\", 1, 5) == False","solution":"def canFormPalindrome(s, start, end): Determine if the substring of \`s\` from \`start\` to \`end-1\` can be rearranged to form a palindrome. :param s: Original string :param start: Start index of the substring :param end: End index of the substring (exclusive) :return: True if the substring can be rearranged to form a palindrome, False otherwise substring = s[start:end] char_count = {} for char in substring: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd count. return odd_count <= 1"},{"question":"def min_knight_removals(board: List[List[int]]) -> int: Determine the fewest number of knights that need to be removed to ensure that no two knights threaten each other. Args: board (List[List[int]]): A rectangular n x m chessboard grid with cells that are either empty (0) or occupied by a knight (1). Returns: int: The minimum number of knights that need to be removed. Example: >>> min_knight_removals([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 4 >>> min_knight_removals([ ... [1, 1, 1], ... [0, 0, 0], ... [0, 0, 0] ... ]) 2","solution":"def min_knight_removals(board): def can_threaten(x1, y1, x2, y2): return ( x1 == x2 or y1 == y2 or (abs(x1 - x2), abs(y1 - y2)) in [(1, 2), (2, 1)], ) def dfs(i, j, visited): stack = [(i, j)] component = [] while stack: x, y = stack.pop() if (x, y) not in visited: visited.add((x, y)) component.append((x, y)) for nx in range(n): for ny in range(m): if board[nx][ny] == 1 and can_threaten(x, y, nx, ny) and (nx, ny) not in visited: stack.append((nx, ny)) return component n = len(board) m = len(board[0]) if n > 0 else 0 visited = set() components = [] for i in range(n): for j in range(m): if board[i][j] == 1 and (i, j) not in visited: components.append(dfs(i, j, visited)) total_remove = 0 for component in components: total_remove += len(component) - 1 return total_remove"},{"question":"def island_perimeter(grid: List[List[int]]) -> int: Returns the perimeter of the island in the given grid. >>> island_perimeter([[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]) 8 >>> island_perimeter([[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) 10 >>> island_perimeter([[0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0]]) 6","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Start with 4 sides for each land cell perimeter += 4 # Subtract sides for each adjacent land if r > 0 and grid[r-1][c] == 1: # Check the cell above perimeter -= 2 if c > 0 and grid[r][c-1] == 1: # Check the cell to the left perimeter -= 2 return perimeter"},{"question":"def num_decodings(s: str) -> int: Given a string s consisting of only digits from 0 to 9, return the number of ways to decode it. A single digit '1' maps to 'A', ..., '9' maps to 'I', and two digits '10' maps to 'J', ..., '26' maps to 'Z'. Note that the string can contain leading zeros which are invalid for decoding. >>> num_decodings(\\"12\\") == 2 # \\"12\\" -> \\"AB\\" or \\"L\\" >>> num_decodings(\\"226\\") == 3 # \\"226\\" -> \\"BBF\\", \\"BZ\\", \\"VF\\" >>> num_decodings(\\"1234\\") == 3 # \\"1234\\" -> \\"ABCD\\", \\"LCD\\", \\"AWD\\"","solution":"def num_decodings(s: str) -> int: if not s: return 0 if s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if one_digit >= 1: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"from typing import List def min_delivery_time(deliveryTimes: List[List[int]], totalDeliveries: int) -> int: Determines the minimum overall time required for the fleet to complete a specified number of deliveries. Parameters: deliveryTimes (list of list of int): Represents the time taken by robots to complete deliveries. totalDeliveries (int): The number of deliveries to complete. Returns: int: The minimum overall time required to complete the deliveries, or -1 if it is not possible. >>> min_delivery_time([[1, 3, 5], [2, 4, 6]], 3) 6 >>> min_delivery_time([[1, 2], [2, 3]], 5) -1 >>> min_delivery_time([[2, 3, 4]], 1) 2 >>> min_delivery_time([[2, 3, 4]], 3) 9 >>> min_delivery_time([[2, 3, 4]], 4) -1 >>> min_delivery_time([[2, 3, 4], [1, 5, 6]], 0) 0 >>> min_delivery_time([[1, 3, 5], [2, 4, 6]], 4) 10","solution":"def min_delivery_time(deliveryTimes, totalDeliveries): Determines the minimum overall time required for the fleet to complete a specified number of deliveries. Parameters: deliveryTimes (list of list of int): Represents the time taken by robots to complete deliveries. totalDeliveries (int): The number of deliveries to complete. Returns: int: The minimum overall time required to complete the deliveries, or -1 if it is not possible. import heapq if totalDeliveries == 0: return 0 n = len(deliveryTimes) delivery_heap = [] for i in range(n): for d in range(len(deliveryTimes[i])): heapq.heappush(delivery_heap, deliveryTimes[i][d]) if len(delivery_heap) < totalDeliveries: return -1 minimum_time = 0 for _ in range(totalDeliveries): minimum_time += heapq.heappop(delivery_heap) return minimum_time"},{"question":"def min_decrement_operations(arr1, arr2): Returns the minimum number of decrement operations required to make arr1 identical to arr2. If it is not possible, returns -1. >>> min_decrement_operations([1, 2, 3], [1, 2, 3]) 0 >>> min_decrement_operations([4, 2, 3], [1, 2, 1]) 5 >>> min_decrement_operations([1, 2, 3], [4, 2, 3]) -1 >>> min_decrement_operations([1, 2, 3], [1, 2]) -1 >>> min_decrement_operations([5, 5, 5], [2, 2, 2]) 9","solution":"def min_decrement_operations(arr1, arr2): Returns the minimum number of decrement operations required to make arr1 identical to arr2. If it is not possible, returns -1. if len(arr1) != len(arr2): return -1 total_ops = 0 for i in range(len(arr1)): if arr1[i] < arr2[i]: return -1 total_ops += arr1[i] - arr2[i] return total_ops"},{"question":"def longest_subarray_with_limited_difference(arr, value): Returns the length of the longest possible subarray where no two adjacent elements have a difference greater than the given value. >>> longest_subarray_with_limited_difference([5], 3) == 1 >>> longest_subarray_with_limited_difference([1, 2, 3, 4], 2) == 4 >>> longest_subarray_with_limited_difference([1, 3, 6, 7, 8], 2) == 3 >>> longest_subarray_with_limited_difference([1, 3, 8, 6], 3) == 2 >>> longest_subarray_with_limited_difference([1, 10, 20, 30], 5) == 1","solution":"def longest_subarray_with_limited_difference(arr, value): Returns the length of the longest possible subarray where no two adjacent elements have a difference greater than the given value. if not arr: return 0 n = len(arr) if n == 1: return 1 # Initialize the length of the longest subarray max_length = 1 # Initialize the current subarray length current_length = 1 # Iterate through the array for i in range(1, n): if abs(arr[i] - arr[i - 1]) <= value: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> List[int]: Find the maximum possible sum of a subarray of length 'k'. If there are multiple such subarrays with the same maximum sum, return any one of them. Parameters: arr (List[int]): An array of integers. k (int): The length of the subarray. Returns: List[int]: The subarray with maximum sum of length 'k'. If the array has fewer than 'k' elements, return an empty list. Examples: >>> max_sum_subarray([1, 2, 3, 4, 5], 2) [4, 5] >>> max_sum_subarray([1, 2, 3, 4, 5], 3) [3, 4, 5] >>> max_sum_subarray([1, 2, -1, -2, 3, 4, -5], 2) [3, 4] >>> max_sum_subarray([4, 0, -2, 3, 5, 7], 6) [4, 0, -2, 3, 5, 7] >>> max_sum_subarray([1, 1, 1, 1, 1], 2) [1, 1] >>> max_sum_subarray([1, 2, 3], k = 5) []","solution":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> List[int]: if len(arr) < k: return [] max_sum = float('-inf') current_sum = sum(arr[:k]) max_sum = current_sum max_start_index = 0 for i in range(1, len(arr) - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum max_start_index = i return arr[max_start_index:max_start_index + k]"},{"question":"def min_operations_to_sort(arr): You are given an integer array \`arr\` of length \`n\` which contains distinct integers from \`1\` to \`n\` inclusive. You can perform the following operation on the array any number of times: choose an element and move it to the front of the array. Return the minimum number of operations needed to sort the array in ascending order. >>> min_operations_to_sort([4, 3, 1, 2]) == 2 >>> min_operations_to_sort([1, 2, 3, 4]) == 0 >>> min_operations_to_sort([4, 3, 2, 1]) == 3 >>> min_operations_to_sort([2, 1, 4, 3]) == 2 >>> min_operations_to_sort([3, 1, 4, 2]) == 2 >>> min_operations_to_sort([3, 2, 1]) == 2","solution":"def min_operations_to_sort(arr): Returns the minimum number of operations needed to sort the array in ascending order. n = len(arr) longest_sorted_subsequence_length = 0 current_length = 1 for i in range(1, n): if arr[i] > arr[i - 1]: current_length += 1 else: longest_sorted_subsequence_length = max(longest_sorted_subsequence_length, current_length) current_length = 1 longest_sorted_subsequence_length = max(longest_sorted_subsequence_length, current_length) return n - longest_sorted_subsequence_length"},{"question":"def reorderList(head): Reorders a singly linked list as per the specified pattern. class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def linked_list_to_list(head): Helper function to convert linked list to Python list result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(items): Helper function to convert Python list to linked list if not items: return None head = ListNode(items[0]) current = head for item in items[1:]: current.next = ListNode(item) current = current.next return head def test_reorderList(): # Test case 1 head = list_to_linked_list([1, 2, 3, 4]) reorderList(head) assert linked_list_to_list(head) == [1, 4, 2, 3] # Test case 2 head = list_to_linked_list([1, 2, 3, 4, 5]) reorderList(head) assert linked_list_to_list(head) == [1, 5, 2, 4, 3] # Test case 3 head = list_to_linked_list([1]) reorderList(head) assert linked_list_to_list(head) == [1] # Test case 4 head = list_to_linked_list([1, 2]) reorderList(head) assert linked_list_to_list(head) == [1, 2] # Test case 5 head = list_to_linked_list([]) reorderList(head) assert linked_list_to_list(head) == []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorders a singly linked list as per the specified pattern. if not head or not head.next: return # Find the middle of the list slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev = None curr = slow.next slow.next = None # Split the list into two halves while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp first, second = head, prev # Merge the two halves while second: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first, second = temp1, temp2"},{"question":"from typing import List def min_subarray_length(nums: List[int], threshold: int) -> int: Find the smallest length of a subarray where the sum of the elements is greater than or equal to the threshold. Args: nums (List[int]): Array of integers. threshold (int): The threshold value. Returns: int: The minimum length of the subarray, or -1 if no such subarray exists. Examples: >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 1, 1, 1, 1], 11) -1 >>> min_subarray_length([1, 2, 3, 4, 5], 0) 1 >>> min_subarray_length([5], 5) 1 >>> min_subarray_length([4], 5) -1 >>> min_subarray_length([1, 4, 4], 10) -1 >>> min_subarray_length([1, 2, 3, 4, 5], 15) 5","solution":"def min_subarray_length(nums, threshold): Finds the smallest length of a subarray where the sum of the elements is greater than or equal to the threshold. n = len(nums) minimum_length = float('inf') for start in range(n): sum_subarray = 0 for end in range(start, n): sum_subarray += nums[end] if sum_subarray >= threshold: minimum_length = min(minimum_length, end - start + 1) break return minimum_length if minimum_length != float('inf') else -1"},{"question":"def roman_to_integer(s: str) -> int: Converts a Roman numeral string to an integer. Args: s (str): A string representing a Roman numeral. Returns: int: The integer representation of the Roman numeral. >>> roman_to_integer('I') == 1 >>> roman_to_integer('IV') == 4 >>> roman_to_integer('MCMXCIV') == 1994 >>> roman_to_integer('MMXX') == 2020","solution":"def roman_to_integer(s): Converts a Roman numeral to its integer value. :param s: str, Roman numeral string :return: int, the integer value of the Roman numeral roman_to_int = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 } total = 0 prev_value = 0 for ch in reversed(s): value = roman_to_int[ch] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"def minTransformations(s1: str, s2: str) -> int: Returns the minimum number of operations needed to transform s1 into s2. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of transformations required. >>> minTransformations(\\"abc\\", \\"abc\\") == 0 >>> minTransformations(\\"abc\\", \\"def\\") == 3 >>> minTransformations(\\"abcd\\", \\"abcf\\") == 1 >>> minTransformations(\\"abcd\\", \\"abfd\\") == 1 >>> minTransformations(\\"abcd\\", \\"afcd\\") == 1 >>> minTransformations(\\"abcd\\", \\"fbcd\\") == 1 >>> minTransformations(\\"abc\\", \\"adc\\") == 1 >>> minTransformations(\\"abcdef\\", \\"abcfed\\") == 2 >>> minTransformations(\\"a\\", \\"b\\") == 1 >>> minTransformations(\\"\\", \\"\\") == 0","solution":"def minTransformations(s1, s2): Returns the minimum number of operations needed to transform s1 into s2. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: int: The minimum number of transformations required. if len(s1) != len(s2): raise ValueError(\\"Strings must be of equal length\\") min_operations = 0 for char1, char2 in zip(s1, s2): if char1 != char2: min_operations += 1 return min_operations"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Given the head of a singly linked list, reverse the list, and return the reversed list. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> reversed_head = reverse_list(head) >>> list_to_array(reversed_head) [5, 4, 3, 2, 1] >>> head = array_to_list([1]) >>> reversed_head = reverse_list(head) >>> list_to_array(reversed_head) [1] >>> head = array_to_list([]) >>> reversed_head = reverse_list(head) >>> list_to_array(reversed_head) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. :param head: ListNode :return: ListNode prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"class ListNode: def __init__(self, value=0, next=None): self.val = value self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: Removes the nth node from the end of the list and returns the head of the modified list. If n is greater than the length of the list, returns the original list. def list_to_array(head: ListNode): array = [] while head: array.append(head.val) head = head.next return array def array_to_list(arr): if not arr: return None dummy = ListNode(0) current = dummy for val in arr: current.next = ListNode(val) current = current.next return dummy.next def test_remove_middle(): head = array_to_list([1, 2, 3, 4, 5]) result = remove_nth_from_end(head, 2) assert list_to_array(result) == [1, 2, 3, 5] def test_remove_head(): head = array_to_list([1, 2, 3, 4, 5]) result = remove_nth_from_end(head, 5) assert list_to_array(result) == [2, 3, 4, 5] def test_remove_tail(): head = array_to_list([1, 2, 3, 4, 5]) result = remove_nth_from_end(head, 1) assert list_to_array(result) == [1, 2, 3, 4] def test_single_element(): head = array_to_list([1]) result = remove_nth_from_end(head, 1) assert list_to_array(result) == [] def test_n_greater_than_length(): head = array_to_list([1, 2]) result = remove_nth_from_end(head, 3) assert list_to_array(result) == [1, 2]","solution":"class ListNode: def __init__(self, value=0, next=None): self.val = value self.next = next def remove_nth_from_end(head: ListNode, n: int) -> ListNode: Removes the nth node from the end of the list and returns the head of the modified list. If n is greater than the length of the list, returns the original list. def get_length(node): length = 0 while node: length += 1 node = node.next return length length = get_length(head) if n > length: return head dummy = ListNode(0) dummy.next = head current = dummy to_advance = length - n for _ in range(to_advance): current = current.next current.next = current.next.next return dummy.next"},{"question":"def longest_subarray_with_n_unique(arr: List[int], n: int) -> int: Finds the length of the longest contiguous subarray with n unique integers. >>> longest_subarray_with_n_unique([1, 2, 1, 2, 3], 2) 4 >>> longest_subarray_with_n_unique([1, 2, 1, 3, 4], 3) 4 >>> longest_subarray_with_n_unique([1, 2, 1, 2, 3], 3) 5 >>> longest_subarray_with_n_unique([1, 2, 3, 4, 5], 5) 5 >>> longest_subarray_with_n_unique([1, 2, 1, 3, 4], 1) 1 >>> longest_subarray_with_n_unique([], 1) 0 >>> longest_subarray_with_n_unique([1, 2, 3, 4, 5], 6) 0 >>> longest_subarray_with_n_unique([1, 1, 1, 1, 1], 1) 5 >>> longest_subarray_with_n_unique([1, 2, 3, 2, 2], 2) 4 >>> longest_subarray_with_n_unique([1, 2, 3, 2, 1], 3) 5","solution":"def longest_subarray_with_n_unique(arr, n): Finds the length of the longest contiguous subarray with n unique integers. Args: arr (list of int): The input array. n (int): The number of unique integers to find in the subarray. Returns: int: The length of the longest contiguous subarray with n unique integers. Returns 0 if no such subarray exists. if n == 0 or not arr: return 0 from collections import defaultdict left = 0 right = 0 max_length = 0 unique_count = 0 freq_map = defaultdict(int) while right < len(arr): if freq_map[arr[right]] == 0: unique_count += 1 freq_map[arr[right]] += 1 right += 1 while unique_count > n: freq_map[arr[left]] -= 1 if freq_map[arr[left]] == 0: unique_count -= 1 left += 1 if unique_count == n: max_length = max(max_length, right - left) return max_length"},{"question":"def update_plant_heights(arr, k): Updates the heights of plants over k days. Each day: - Plants at odd indices (1, 3, 5, ...) increase by 1 - Plants at even indices (0, 2, 4, ...) decrease by 1 :param arr: List[int] representing the heights of the plants :param k: int representing the number of days to update the heights :return: List[int] representing the final heights of the plants >>> update_plant_heights([1, 2, 3, 4], 0) [1, 2, 3, 4] >>> update_plant_heights([1, 2, 3, 4], 1) [0, 3, 2, 5] >>> update_plant_heights([1, 2, 3, 4], 2) [-1, 4, 1, 6] >>> update_plant_heights([1, 1, 1, 1, 1], 3) [-2, 4, -2, 4, -2] >>> update_plant_heights([-1, -2, -3, -4], 1) [-2, -1, -4, -3] >>> update_plant_heights([], 5) [] >>> update_plant_heights([5], 10) [-5]","solution":"def update_plant_heights(arr, k): Updates the heights of plants over k days. Each day: - Plants at odd indices (1, 3, 5, ...) increase by 1 - Plants at even indices (0, 2, 4, ...) decrease by 1 :param arr: List[int] representing the heights of the plants :param k: int representing the number of days to update the heights :return: List[int] representing the final heights of the plants for _ in range(k): for i in range(len(arr)): if i % 2 == 0: arr[i] -= 1 else: arr[i] += 1 return arr"},{"question":"def change(amount: int, coins: List[int]) -> int: Returns the number of combinations that make up the amount using the given coins. >>> change(0, [1, 2, 5]) 1 >>> change(3, [2, 4, 6]) 0 >>> change(5, [5]) 1 >>> change(5, [1, 2, 5]) 4 >>> change(10, [1, 2, 5]) 10","solution":"def change(amount, coins): Returns the number of combinations that make up the amount using the given coins. dp = [0] * (amount + 1) dp[0] = 1 # There's one way to make amount 0, which is using no coins for coin in coins: for x in range(coin, amount + 1): dp[x] += dp[x - coin] return dp[amount]"},{"question":"def min_operations_to_lexicographic_smallest(s: str) -> int: Given a string s containing only characters 'a' and 'b', returns the minimum number of operations needed to make the string lexicographically smallest. An operation consists of replacing 'ab' with 'ba'. >>> min_operations_to_lexicographic_smallest(\\"aaa\\") == 0 >>> min_operations_to_lexicographic_smallest(\\"bbb\\") == 0 >>> min_operations_to_lexicographic_smallest(\\"ab\\") == 1 >>> min_operations_to_lexicographic_smallest(\\"aab\\") == 1 >>> min_operations_to_lexicographic_smallest(\\"abb\\") == 1 >>> min_operations_to_lexicographic_smallest(\\"aabb\\") == 1 >>> min_operations_to_lexicographic_smallest(\\"abab\\") == 2 >>> min_operations_to_lexicographic_smallest(\\"babab\\") == 2 >>> min_operations_to_lexicographic_smallest(\\"aabba\\") == 1 >>> min_operations_to_lexicographic_smallest(\\"ba\\") == 0 >>> min_operations_to_lexicographic_smallest(\\"\\") == 0","solution":"def min_operations_to_lexicographic_smallest(s): Given a string s containing only characters 'a' and 'b', returns the minimum number of operations needed to make the string lexicographically smallest. An operation consists of replacing 'ab' with 'ba'. operations = 0 i = 0 # Traverse the string to count 'ab' occurrences. while i < len(s) - 1: if s[i] == 'a' and s[i + 1] == 'b': operations += 1 i += 1 # Skip checking next character since 'ab' was changed to 'ba' i += 1 return operations"},{"question":"from typing import List def pacificAtlantic(heights: List[List[int]]) -> List[List[int]]: Returns a list of cell coordinates [i, j] from which water can flow to both the Pacific and Atlantic oceans. >>> pacificAtlantic([ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ]) [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] >>> pacificAtlantic([ ... [1, 1], ... [1, 1] ... ]) [[0, 0], [0, 1], [1, 0], [1, 1]] >>> pacificAtlantic([ ... [10, 10, 10], ... [10, 1, 10], ... [10, 10, 10] ... ]) [[0, 0], [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2]]","solution":"def pacificAtlantic(heights): if not heights: return [] m, n = len(heights), len(heights[0]) pacific = [[False] * n for _ in range(m)] atlantic = [[False] * n for _ in range(m)] def dfs(x, y, ocean): ocean[x][y] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not ocean[nx][ny] and heights[nx][ny] >= heights[x][y]: dfs(nx, ny, ocean) for i in range(m): dfs(i, 0, pacific) dfs(i, n-1, atlantic) for j in range(n): dfs(0, j, pacific) dfs(m-1, j, atlantic) result = [] for i in range(m): for j in range(n): if pacific[i][j] and atlantic[i][j]: result.append([i, j]) return result"},{"question":"def shortest_string_length(s: str) -> int: Given a string s, determine the length of the shortest string that can be obtained after removing all occurrences of one character. Return an integer representing the length of the shortest possible string. >>> shortest_string_length(\\"\\") == 0 >>> shortest_string_length(\\"a\\") == 0 >>> shortest_string_length(\\"ab\\") == 1 >>> shortest_string_length(\\"aaab\\") == 1 >>> shortest_string_length(\\"aabbb\\") == 2 >>> shortest_string_length(\\"aaaa\\") == 0 >>> shortest_string_length(\\"abcabc\\") == 4 >>> shortest_string_length(\\"abababa\\") == 3 >>> shortest_string_length(\\"abcdefghijklmnopqrstuvwxyz\\"*10) == 250","solution":"def shortest_string_length(s): Returns the length of the shortest string that can be obtained by removing all occurrences of one character from the input string. if not s: return 0 min_length = len(s) for char in set(s): new_length = len(s) - s.count(char) if new_length < min_length: min_length = new_length return min_length"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Length of the longest substring with all distinct characters. def test_empty_string(): assert length_of_longest_substring('') == 0 def test_single_character(): assert length_of_longest_substring('a') == 1 def test_all_distinct_characters(): assert length_of_longest_substring('abcdefg') == 7 def test_some_repeated_characters(): assert length_of_longest_substring('abcabcbb') == 3 # \\"abc\\" assert length_of_longest_substring('bbbbb') == 1 # \\"b\\" assert length_of_longest_substring('pwwkew') == 3 # \\"wke\\" def test_mix_of_distinct_and_repeated(): assert length_of_longest_substring('dvdf') == 3 # \\"vdf\\" assert length_of_longest_substring('anviaj') == 5 # \\"nviaj\\" def test_long_string(): input_str = \\"abc\\" * 1000 + \\"def\\" assert length_of_longest_substring(input_str) == 6 # \\"abcdef\\"","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all distinct characters. Parameters: s (str): Input string consisting of lowercase English letters. Returns: int: Length of the longest substring with all distinct characters. char_index_map = {} longest = 0 start = 0 for end, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end longest = max(longest, end - start + 1) return longest"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_sum(root: TreeNode) -> int: Computes the sum of all nodes' values in the tree using Inorder Traversal. >>> root = TreeNode(10) >>> inorder_sum(root) 10 >>> root = None >>> inorder_sum(root) 0 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> inorder_sum(root) 6 >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) >>> inorder_sum(root) 10 >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> inorder_sum(root) 6 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> inorder_sum(root) 28","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_sum(root): Computes the sum of all nodes' values in the tree using Inorder Traversal. :param root: The root of the binary tree. :return: The sum of all nodes' values. def inorder(node): if node is None: return 0 return inorder(node.left) + node.value + inorder(node.right) return inorder(root)"},{"question":"def rearrange_string_by_digit_sum(s: str) -> str: Groups the digits of the string \`s\` based on their sum and rearranges them such that groups with a larger sum come before groups with a smaller sum. Within a group, maintains the original order of digits. >>> rearrange_string_by_digit_sum(\\"4\\") '4' >>> rearrange_string_by_digit_sum(\\"1234\\") '4321' >>> rearrange_string_by_digit_sum(\\"4312\\") '4321' >>> rearrange_string_by_digit_sum(\\"44445555\\") '55554444' >>> rearrange_string_by_digit_sum(\\"2222222\\") '2222222' >>> rearrange_string_by_digit_sum(\\"9876543210\\") '9876543210' >>> rearrange_string_by_digit_sum(\\"000021\\") '210000'","solution":"from collections import defaultdict def rearrange_string_by_digit_sum(s): Groups and arranges digits in the string \`s\` by the sum of their digits. Groups with larger sums come before groups with smaller sums. sum_to_digits = defaultdict(list) for digit in s: digit_sum = int(digit) sum_to_digits[digit_sum].append(digit) # Sorting sums in descending order sorted_sums = sorted(sum_to_digits.keys(), reverse=True) result = [] for digit_sum in sorted_sums: result.extend(sum_to_digits[digit_sum]) return ''.join(result)"},{"question":"def build_array(nums: List[int]) -> List[int]: Given an array nums containing n distinct integers, where nums is a permutation of the numbers in the range [0, n-1]. For each number i in the range [0, n-1], find nums[nums[i]] and return the new array. >>> build_array([0, 2, 1]) == [0, 1, 2] >>> build_array([4, 3, 2, 1, 0]) == [0, 1, 2, 3, 4] >>> build_array([0]) == [0] >>> build_array([1, 0]) == [0, 1] >>> build_array([1, 4, 3, 2, 0]) == [4, 0, 2, 3, 1] >>> build_array([2, 0, 1, 3]) == [1, 2, 0, 3]","solution":"def build_array(nums): Given an array nums containing n distinct integers, where nums is a permutation of the numbers in the range [0, n-1]. For each number i in the range [0, n-1], find nums[nums[i]] and return the new array. return [nums[nums[i]] for i in range(len(nums))]"},{"question":"def can_partition_into_subsequences(nums: List[int]) -> bool: Given a list of integers \`nums\`, partition it into subsequences, where each subsequence is of length at least \`3\` and consists of consecutive integers. Return \`true\` if you can do this partition, and \`false\` otherwise. Each integer in \`nums\` must be used exactly once in a subsequence. >>> can_partition_into_subsequences([1, 2, 3, 3, 4, 5]) == True >>> can_partition_into_subsequences([1, 2, 3, 4, 4, 5]) == False >>> can_partition_into_subsequences([1, 2, 3, 4, 5, 6, 7, 8, 9]) == True >>> can_partition_into_subsequences([1, 2, 4, 5, 6]) == False >>> can_partition_into_subsequences([1]) == False >>> can_partition_into_subsequences([]) == False >>> can_partition_into_subsequences([1, 2, 3, 6, 7, 8, 10, 11, 12]) == True >>> can_partition_into_subsequences([1, 2, 3, 4, 5, 6, 7, 7, 8]) == False >>> can_partition_into_subsequences([1, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9]) == True","solution":"from collections import Counter, defaultdict def can_partition_into_subsequences(nums): Determines if it is possible to partition the array into subsequences of length at least 3 where each subsequence consists of consecutive integers. Args: nums (List[int]): List of integers. Returns: bool: True if the partition is possible, False otherwise. if len(nums) < 3: return False freq = Counter(nums) sequences = defaultdict(int) for num in nums: if freq[num] == 0: continue if sequences[num - 1] > 0: sequences[num - 1] -= 1 sequences[num] += 1 elif freq[num + 1] > 0 and freq[num + 2] > 0: freq[num + 1] -= 1 freq[num + 2] -= 1 sequences[num + 2] += 1 else: return False freq[num] -= 1 return True"},{"question":"def max_overlapping_intervals(matrix: List[List[int]]) -> int: Returns the maximum number of overlapping intervals at any point in the 2D matrix. >>> max_overlapping_intervals([]) 0 >>> max_overlapping_intervals([[1, 2]]) 1 >>> max_overlapping_intervals([[1, 2], [3, 4]]) 1 >>> max_overlapping_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) 2 >>> max_overlapping_intervals([[1, 5], [2, 6], [3, 7]]) 3 >>> max_overlapping_intervals([[1, 5], [2, 6], [8, 10], [9, 18], [11, 13]]) 2","solution":"def max_overlapping_intervals(matrix): Returns the maximum number of overlapping intervals at any point in the 2D matrix. Parameters: matrix (list of list of int): A 2D list where each sublist represents an interval [start, end]. Returns: int: The maximum number of overlapping intervals. if not matrix: return 0 # Create a list of events events = [] for interval in matrix: start, end = interval events.append((start, 1)) # starting an interval adds to overlaps events.append((end, -1)) # ending an interval removes from overlaps # Sort events first by time, then by type (-1 before +1 when times are equal) events.sort(key=lambda x: (x[0], x[1])) max_overlaps = 0 current_overlaps = 0 # Iterate through events and calculate overlaps for event in events: current_overlaps += event[1] max_overlaps = max(max_overlaps, current_overlaps) return max_overlaps"},{"question":"from typing import List def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum sum of the values of the cells that the robot can collect while moving to the bottom-right corner of the grid. :param grid: List[List[int]], 2D grid of non-negative integers :return: int, maximum sum collected >>> max_path_sum([[1, 2], [1, 3]]) == 6 >>> max_path_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5 >>> max_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12 >>> max_path_sum([]) == 0 >>> max_path_sum([[1, 2, 3, 4]]) == 10 >>> max_path_sum([[1], [2], [3], [4]]) == 10","solution":"def max_path_sum(grid): Returns the maximum sum of the values of the cells that the robot can collect while moving to the bottom-right corner of the grid. :param grid: List[List[int]], 2D grid of non-negative integers :return: int, maximum sum collected if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def min_meeting_rooms(meetings: List[List[int]]) -> int: Compute the minimum number of meeting rooms required to accommodate all meetings. Args: meetings: List of lists, where each sub-list [start_i, end_i] represents a meeting that starts at start_i and ends at end_i. Returns: int: Minimum number of meeting rooms required. Examples: >>> min_meeting_rooms([]) 0 >>> min_meeting_rooms([[0, 30]]) 1 >>> min_meeting_rooms([[0, 10], [15, 20], [25, 30]]) 1 >>> min_meeting_rooms([[0, 30], [5, 10], [15, 20]]) 2 >>> min_meeting_rooms([[0, 5], [5, 10]]) 1 >>> min_meeting_rooms([[0, 10], [10, 20]]) 1 >>> min_meeting_rooms([[1, 4], [2, 5], [3, 6]]) 3 >>> min_meeting_rooms([[1, 10], [2, 7], [3, 4], [5, 6]]) 3 pass","solution":"def min_meeting_rooms(meetings): Compute the minimum number of meeting rooms required to accommodate all meetings. Args: meetings: List of lists, where each sub-list [start_i, end_i] represents a meeting that starts at start_i and ends at end_i. Returns: int: Minimum number of meeting rooms required. if not meetings: return 0 # Separate and sort start times and end times start_times = sorted(meetings[i][0] for i in range(len(meetings))) end_times = sorted(meetings[i][1] for i in range(len(meetings))) start_pointer = end_pointer = 0 used_rooms = 0 while start_pointer < len(meetings): # If there's a meeting that has ended by the time the meeting at start_pointer starts if start_times[start_pointer] >= end_times[end_pointer]: used_rooms -= 1 end_pointer += 1 # We do this irrespective of whether a room frees up or not, as the meeting room is always required used_rooms += 1 start_pointer += 1 return used_rooms"},{"question":"def min_diff_to_target(nums: List[int], target: int, k: int) -> int: Find the minimum possible value of the absolute difference between the sum of the modified list and the target after at most k operations. >>> min_diff_to_target([1, 2, 3], 8, 5) 0 >>> min_diff_to_target([1, 2, 3, 2], 8, 0) 0 >>> min_diff_to_target([1, 2, 3], 15, 5) 4 >>> min_diff_to_target([1, 2], 10, 20) 0 >>> min_diff_to_target([1, 2, 2], 5, 2) 0 >>> min_diff_to_target([1, 2, 3], 100, 150) 0 >>> min_diff_to_target([1, 2, 3], 10, 0) 4","solution":"def min_diff_to_target(nums, target, k): Function to find the minimum possible value of the absolute difference between the sum of the modified list and the target after at most k operations. Parameters: nums (list): List of positive integers. target (int): Target integer. k (int): Maximum number of operations to perform on the list. Returns: int: Minimum absolute difference. current_sum = sum(nums) diff = abs(current_sum - target) # If the difference can be eliminated using k operations, adjust it accordingly if k >= diff: return 0 # Otherwise, the minimum possible difference is the difference reduced by k operations return diff - k"},{"question":"from typing import List def largest_possible_integer(inputArray: List[int]) -> str: Rearrange the array elements to form the largest possible integer. Each integer in the array must keep its original form and cannot be split. >>> largest_possible_integer([10, 2]) '210' >>> largest_possible_integer([3, 30, 34, 5, 9]) '9534330' >>> largest_possible_integer([1, 20, 23, 4, 8]) '8423201' >>> largest_possible_integer([54, 546, 548, 60]) '6054854654' >>> largest_possible_integer([0, 0, 0]) '0' >>> largest_possible_integer([999, 99, 9999, 9]) '9999999999' >>> largest_possible_integer([128, 12, 320, 32]) '3232012812'","solution":"from functools import cmp_to_key def largest_possible_integer(inputArray): def compare(x, y): # Compare two elements as per the custom comparison logic if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert integer array to string array for easier manipulation inputArray = list(map(str, inputArray)) # Sort using the custom comparator inputArray.sort(key=cmp_to_key(compare)) # Join the sorted array into a single string result = ''.join(inputArray) # Special case: if the result is all zeros, return '0' instead of '000...' if result[0] == '0': return '0' else: return result"},{"question":"import heapq from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into one sorted linked list. >>> linked_list_to_list(merge_k_lists([build_linked_list([1,4,5]), build_linked_list([1,3,4]), build_linked_list([2,6])])) [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_k_lists([]) == None True # Helper functions to facilitate testing def build_linked_list(vals: List[int]) -> Optional[ListNode]: if not vals: return None head = ListNode(vals[0]) current = head for val in vals[1:]: current.next = ListNode(val) current = current.next return head def linked_list_to_list(node: Optional[ListNode]) -> List[int]: result = [] while node: result.append(node.val) node = node.next return result","solution":"import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists): Merges k sorted linked lists into one sorted linked list. if not lists or len(lists) == 0: return None min_heap = [] for idx, lst in enumerate(lists): if lst: heapq.heappush(min_heap, (lst.val, idx, lst)) dummy = ListNode(0) current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next # Helper functions to facilitate testing def build_linked_list(vals): if not vals: return None head = ListNode(vals[0]) current = head for val in vals[1:]: current.next = ListNode(val) current = current.next return head def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result"},{"question":"def find_pair_with_sum(arr: List[int], x: int) -> Union[Tuple[int, int], int]: Returns the indices of two distinct elements in the array such that their sum equals x, or -1 if no such pair exists. Args: arr (List[int]): List of integers. x (int): The target sum. Returns: Union[Tuple[int, int], int]: Tuple of indices (i, j) in ascending order if such a pair exists, otherwise -1. >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([3, 2, 4], 6) (1, 2) >>> find_pair_with_sum([3, 3], 6) (0, 1) >>> find_pair_with_sum([1, 2, 3, 4], 8) -1 >>> find_pair_with_sum([10], 10) -1 >>> find_pair_with_sum([1, 2, 2, 3], 4) (1, 2) >>> find_pair_with_sum([-1, 2, 3, -4], -5) (0, 3)","solution":"def find_pair_with_sum(arr, x): Returns the indices of two distinct elements in the array such that their sum equals x, or -1 if no such pair exists. # Dictionary to store the value to index mapping value_to_index = {} for i, num in enumerate(arr): # Calculate the complement that would add up to x complement = x - num if complement in value_to_index: # Return the indices in ascending order return (value_to_index[complement], i) if value_to_index[complement] < i else (i, value_to_index[complement]) value_to_index[num] = i return -1"},{"question":"from typing import List def rotate_right(arr: List[int], k: int) -> List[int]: Rotates the list 'arr' to the right by 'k' steps. >>> rotate_right([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_right([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_right([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_right([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_right([], 3) [] >>> rotate_right([1], 3) [1] >>> rotate_right([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2]","solution":"def rotate_right(arr, k): Rotates the list 'arr' to the right by 'k' steps. if not arr: # Check if the list is empty return arr k = k % len(arr) # Ensure k is within bounds of the list length return arr[-k:] + arr[:-k]"},{"question":"def product_except_self(nums, k): Returns an array 'result' where each element at index 'i' is the product of all elements in 'nums' except nums[i], and ensures the sum of all elements in 'result' is less than or equal to 'k'. If there is no such possible 'result' array, returns an empty array. >>> product_except_self([1, 2, 3, 4], 50) [24, 12, 8, 6] >>> product_except_self([1, 2, 3, 4], 10) [] >>> product_except_self([5], 10) [1] >>> product_except_self([1, 0], 10) [0, 1] >>> product_except_self([1, 0, 3], 10) [0, 3, 0] >>> product_except_self([1, 0, 3, 0], 10) [0, 0, 0, 0] >>> product_except_self([1, 2, 3, 4], 100) [24, 12, 8, 6] >>> product_except_self([], 10) []","solution":"def product_except_self(nums, k): Returns an array 'result' where each element at index 'i' is the product of all elements in 'nums' except nums[i], and ensures the sum of all elements in 'result' is less than or equal to 'k'. If there is no such possible 'result' array, returns an empty array. length = len(nums) if length == 0: return [] left_products = [1] * length right_products = [1] * length result = [0] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(length): result[i] = left_products[i] * right_products[i] if sum(result) > k: return [] else: return result"},{"question":"from typing import List def find_min_non_negative_and_max(nums: List[int]) -> List[int]: Returns an array of length 2 where the first element is the minimum non-negative number and the second element is the maximum number from the list. If there is no non-negative number in the list, the first element is -1. If there is no maximum number in the list, the second element is -1. >>> find_min_non_negative_and_max([3, 1, 4, 1, 5, 9]) == [1, 9] >>> find_min_non_negative_and_max([-1, 7, -3, 2, 5, -8]) == [2, 7] >>> find_min_non_negative_and_max([-7, -6, -5]) == [-1, -5] >>> find_min_non_negative_and_max([0, -1, 3, 5, -10]) == [0, 5] >>> find_min_non_negative_and_max([]) == [-1, -1] >>> find_min_non_negative_and_max([0, 0, 0]) == [0, 0] >>> find_min_non_negative_and_max([5]) == [5, 5] >>> find_min_non_negative_and_max([-5]) == [-1, -5]","solution":"def find_min_non_negative_and_max(nums): Returns an array of length 2 where the first element is the minimum non-negative number and the second element is the maximum number from the list. If there is no non-negative number in the list, the first element is -1. If there is no maximum number in the list, the second element is -1. min_non_negative = float('inf') max_num = float('-inf') for num in nums: if num >= 0 and num < min_non_negative: min_non_negative = num if num > max_num: max_num = num if min_non_negative == float('inf'): min_non_negative = -1 if max_num == float('-inf'): max_num = -1 return [min_non_negative, max_num]"},{"question":"def remove_k_digits(nums: List[int], k: int) -> str: Removes exactly k digits from the list nums to form the largest possible number. Returns the resulting number as a string with leading zeros stripped. If the result is an empty string, returns \\"0\\". >>> remove_k_digits([1, 2, 3, 4, 5], 2) == \\"345\\" >>> remove_k_digits([0, 0, 1], 1) == \\"1\\" >>> remove_k_digits([1, 2, 3], 3) == \\"0\\" >>> remove_k_digits([9, 2, 3, 5, 6, 1], 3) == \\"961\\" >>> remove_k_digits([4, 5, 6], 0) == \\"456\\" >>> remove_k_digits([4], 0) == \\"4\\" >>> remove_k_digits([4], 1) == \\"0\\" >>> remove_k_digits([0, 0, 0, 0], 2) == \\"0\\" >>> remove_k_digits([0, 0, 0], 1) == \\"0\\"","solution":"def remove_k_digits(nums, k): Removes exactly k digits from the list nums to form the largest possible number. Returns the resulting number as a string with leading zeros stripped. If the result is an empty string, returns \\"0\\". stack = [] for num in nums: while k > 0 and stack and stack[-1] < num: stack.pop() k -= 1 stack.append(num) # If k is still greater than 0, remove the remaining digits from the end while k > 0: stack.pop() k -= 1 # Convert list to string and remove leading zeros result = ''.join(map(str, stack)).lstrip('0') return result if result else \\"0\\""},{"question":"from typing import List def maxDistance(arr: List[int]) -> int: You are given an array of positive integers \`arr\` representing the heights of a series of buildings. The buildings form a row, and the height of each building is given by \`arr[i]\`. The goal is to find the maximum distance \`d\` such that there is a pair of buildings \`arr[i]\` and \`arr[j]\` with \`arr[i] <= arr[j]\` and the distance \`|i - j|\` (the absolute difference between their indices) is maximum. If no such pair exists, return \`-1\`. >>> maxDistance([1, 2, 3, 4]) == 3 >>> maxDistance([4, 3, 2, 1, 5]) == 4 >>> maxDistance([4, 3, 2, 1]) == -1 >>> maxDistance([2, 2, 2]) == 2 >>> maxDistance([1, 2]) == 1 >>> maxDistance([2, 1]) == -1 >>> maxDistance([1, 5, 4, 3, 2, 6]) == 5 >>> maxDistance([]) == -1 >>> maxDistance([1]) == -1","solution":"from typing import List def maxDistance(arr: List[int]) -> int: max_dist = -1 for i in range(len(arr)): for j in range(i + 1, len(arr)): if arr[i] <= arr[j]: max_dist = max(max_dist, j - i) return max_dist"},{"question":"def min_delivery_batches(orders: List[int], k: int) -> int: Calculate the minimum number of delivery batches required to fulfill all orders. :param orders: List[int] - List of integers representing the number of items ordered by customers :param k: int - Capacity of a single delivery batch :return: int - Minimum number of delivery batches required >>> min_delivery_batches([5, 5, 5], 5) == 3 >>> min_delivery_batches([2, 3, 4], 5) == 3 >>> min_delivery_batches([6, 7, 8], 5) == 6 >>> min_delivery_batches([1, 10, 15], 5) == 6 >>> min_delivery_batches([500, 1000, 1500], 100) == 30 >>> min_delivery_batches([1], 5) == 1 >>> min_delivery_batches([15], 5) == 3","solution":"def min_delivery_batches(orders, k): Calculate the minimum number of delivery batches required to fulfill all orders. :param orders: List[int] - List of integers representing number of items ordered by customers :param k: int - Capacity of a single delivery batch :return: int - Minimum number of delivery batches required total_batches = 0 for order in orders: # Calculate required batches for current order and add to total total_batches += -(-order // k) # Equivalent to math.ceil(order / k) return total_batches"},{"question":"from typing import List def can_transform(s1: str, s2: str) -> bool: Determine if s1 can be transformed into s2 by replacing characters with characters that appear earlier in the alphabet. >>> can_transform(\\"abc\\", \\"aaa\\") == True >>> can_transform(\\"dbc\\", \\"abc\\") == True >>> can_transform(\\"xyz\\", \\"xyx\\") == True >>> can_transform(\\"abc\\", \\"bca\\") == False >>> can_transform(\\"xyz\\", \\"zyx\\") == False >>> can_transform(\\"abc\\", \\"abd\\") == False >>> can_transform(\\"\\", \\"\\") == True >>> can_transform(\\"a\\", \\"a\\") == True >>> can_transform(\\"a\\", \\"b\\") == False","solution":"def can_transform(s1, s2): Determine if s1 can be transformed into s2 by replacing characters with characters that appear earlier in the alphabet. for c1, c2 in zip(s1, s2): if c1 < c2: return False return True"},{"question":"from typing import List def min_operations_to_avoid_consecutive_duplicates(s: str) -> int: Returns the minimum number of operations required to convert the string s into a string that contains no consecutive duplicate characters. Args: s: A string consisting of lowercase English letters Returns: An integer representing the minimum number of operations required. Examples: >>> min_operations_to_avoid_consecutive_duplicates(\\"abcdef\\") 0 >>> min_operations_to_avoid_consecutive_duplicates(\\"aaaaa\\") 4 >>> min_operations_to_avoid_consecutive_duplicates(\\"ababab\\") 0 >>> min_operations_to_avoid_consecutive_duplicates(\\"aabbaa\\") 3 >>> min_operations_to_avoid_consecutive_duplicates(\\"\\") 0 >>> min_operations_to_avoid_consecutive_duplicates(\\"a\\") 0 >>> min_operations_to_avoid_consecutive_duplicates(\\"aa\\") 1 >>> min_operations_to_avoid_consecutive_duplicates(\\"aaabcdef\\") 2 >>> min_operations_to_avoid_consecutive_duplicates(\\"abcdefaaa\\") 2","solution":"def min_operations_to_avoid_consecutive_duplicates(s): Returns the minimum number of operations required to convert the string s into a string that contains no consecutive duplicate characters. if not s: return 0 operations = 0 prev_char = s[0] for i in range(1, len(s)): if s[i] == prev_char: operations += 1 else: prev_char = s[i] return operations"},{"question":"def can_be_sorted_by_reversals(nums: List[int]) -> bool: Returns whether the array nums can be sorted in non-decreasing order by any number of subarray reversals. >>> can_be_sorted_by_reversals([3, 1, 2, 4]) == True >>> can_be_sorted_by_reversals([4, 2, 2, 3, 1]) == False >>> can_be_sorted_by_reversals([1, 2, 3, 4, 5]) == True >>> can_be_sorted_by_reversals([1]) == True >>> can_be_sorted_by_reversals([2, 2, 2, 2]) == False >>> can_be_sorted_by_reversals([-1, -5, -3, -2, -4]) == True >>> can_be_sorted_by_reversals([]) == True","solution":"def can_be_sorted_by_reversals(nums): Returns whether the array nums can be sorted in non-decreasing order by any number of subarray reversals. # An array can be sorted by subarray reversals if it has no duplicate elements. return len(nums) == len(set(nums))"},{"question":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head): Create a deep copy of a list with each node having a random pointer. Each node in the new list should have the same value and random pointer assignment as the nodes in the original list. :param head: Node, the head of the linked list. :return: Node, the head of the deep copied linked list. >>> head = Node(1) >>> head.random = head >>> copy = copyRandomList(head) >>> assert copy.val == 1 >>> assert copy.random == copy","solution":"class Node: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def copyRandomList(head): if not head: return None # Step 1: Create new nodes and insert them beside the original nodes cur = head while cur: new_node = Node(cur.val, cur.next) cur.next = new_node cur = new_node.next # Step 2: Copy the random pointers cur = head while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next # Step 3: Separate the corrupted list into the original list and the copied list original = head copy = head.next copy_head = head.next while original: original.next = original.next.next if copy.next: copy.next = copy.next.next original = original.next copy = copy.next return copy_head"},{"question":"def split_string(s: str, k: int) -> List[str]: Splits the string s into as many parts as necessary so that each part is a substring of length k, while ensuring that each character appears in at most one of the created substrings. If such a split is impossible due to character repetition constraints, return an empty array. If there are multiple valid ways to split the string, return the split with the smallest lexicographic order. >>> split_string(\\"abcdef\\", 3) [\\"abc\\", \\"def\\"] >>> split_string(\\"a\\", 1) [\\"a\\"] >>> split_string(\\"aa\\", 1) [] >>> split_string(\\"cbadef\\", 2) [\\"ab\\", \\"cd\\", \\"ef\\"] >>> split_string(\\"abcdefgh\\", 3) [\\"abc\\", \\"def\\", \\"gh\\"] >>> split_string(\\"abcdefgh\\", 4) [\\"abcd\\", \\"efgh\\"] >>> split_string(\\"\\", 3) [] >>> split_string(\\"abcdefgh\\", 0) [] >>> split_string(\\"abcdefgh\\", -1) [] >>> split_string(\\"abcdefgh\\", 10) [\\"abcdefgh\\"]","solution":"def split_string(s, k): Splits the string s into as many parts as necessary so that each part is a substring of length k, while ensuring that each character appears in at most one of the created substrings. If such a split is impossible, return an empty array. if k <= 0: return [] # Count the frequency of each character char_counts = {} for char in s: if char in char_counts: char_counts[char] += 1 else: char_counts[char] = 1 # Check if any character appears more times than allowed for count in char_counts.values(): if count > 1: return [] # Arrange the characters in lexicographic order chars_sorted = sorted(s) # Split the characters into parts of length k result = [] i = 0 while i < len(chars_sorted): result.append(''.join(chars_sorted[i:i + k])) i += k return result"},{"question":"def min_path_cost(grid): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of a grid. You can only move either down or right at any point in time. >>> grid1 = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> min_path_cost(grid1) 7 >>> grid2 = [ ... [1, 2, 5], ... [3, 2, 1] ... ] >>> min_path_cost(grid2) 6 >>> grid3 = [ ... [1, 2], ... [1, 1] ... ] >>> min_path_cost(grid3) 3 >>> grid4 = [ ... [5] ... ] >>> min_path_cost(grid4) 5 >>> grid5 = [] >>> min_path_cost(grid5) 0 >>> grid6 = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> min_path_cost(grid6) 21","solution":"def min_path_cost(grid): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of a grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) cost = [[0] * n for _ in range(m)] cost[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): cost[i][0] = cost[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): cost[0][j] = cost[0][j-1] + grid[0][j] # Fill in the rest of the cost matrix for i in range(1, m): for j in range(1, n): cost[i][j] = grid[i][j] + min(cost[i-1][j], cost[i][j-1]) return cost[m-1][n-1]"},{"question":"def count_interesting_subarrays(nums: List[int]) -> int: Returns the total number of interesting (strictly increasing or strictly decreasing) subarrays in nums. :param nums: List[int] :return: int >>> count_interesting_subarrays([1, 2, 3, 4]) 6 >>> count_interesting_subarrays([4, 3, 2, 1]) 6 >>> count_interesting_subarrays([1, 2, 1]) 2 >>> count_interesting_subarrays([2, 2, 2]) 0 >>> count_interesting_subarrays([1]) 0 >>> count_interesting_subarrays([1, 2, 1, 2, 1]) 4","solution":"def count_interesting_subarrays(nums): Returns the total number of interesting (strictly increasing or strictly decreasing) subarrays in nums. :param nums: List[int] :return: int n = len(nums) total_count = 0 # Counts strictly increasing subarrays inc_length = 1 # Initial length of the increasing subarray, minimum is 1 for i in range(1, n): if nums[i] > nums[i - 1]: inc_length += 1 else: total_count += (inc_length * (inc_length - 1)) // 2 inc_length = 1 total_count += (inc_length * (inc_length - 1)) // 2 # Counts strictly decreasing subarrays dec_length = 1 # Initial length of the decreasing subarray, minimum is 1 for i in range(1, n): if nums[i] < nums[i - 1]: dec_length += 1 else: total_count += (dec_length * (dec_length - 1)) // 2 dec_length = 1 total_count += (dec_length * (dec_length - 1)) // 2 return total_count"},{"question":"def follows_pattern(pattern: str, string: str) -> bool: Determine if \`string\` follows the same pattern as \`pattern\`. There should exist a bijective mapping between each distinct character in \`pattern\` and each distinct non-empty substring in \`string\`. >>> follows_pattern(\\"abab\\", \\"redblueredblue\\") == True >>> follows_pattern(\\"aaaa\\", \\"asdasdasdasd\\") == True >>> follows_pattern(\\"aabb\\", \\"xyzabcxzyabc\\") == False >>> follows_pattern(\\"abc\\", \\"crystyyztal\\") == True >>> follows_pattern(\\"xyzxy\\", \\"applebananapplebanan\\") == False >>> follows_pattern(\\"abba\\", \\"dogcatcatdog\\") == True >>> follows_pattern(\\"abba\\", \\"dogcatcatfish\\") == False >>> follows_pattern(\\"aaaa\\", \\"dogdogdogdog\\") == True >>> follows_pattern(\\"a\\", \\"dog\\") == True >>> follows_pattern(\\"ab\\", \\"dogcat\\") == True pass","solution":"def follows_pattern(pattern, string): def match(string, i, pattern, j, map_char_index, set_substrings): if i == len(string) and j == len(pattern): return True if i == len(string) or j == len(pattern): return False p_char = pattern[j] if p_char in map_char_index: mapped_str = map_char_index[p_char] if string.startswith(mapped_str, i): return match(string, i + len(mapped_str), pattern, j + 1, map_char_index, set_substrings) return False else: for k in range(i, len(string)): candidate_str = string[i:k + 1] if candidate_str in set_substrings: continue map_char_index[p_char] = candidate_str set_substrings.add(candidate_str) if match(string, k + 1, pattern, j + 1, map_char_index, set_substrings): return True del map_char_index[p_char] set_substrings.remove(candidate_str) return False return match(string, 0, pattern, 0, {}, set()) # Example usage: # print(follows_pattern(\\"abab\\", \\"redblueredblue\\")) # should return True # print(follows_pattern(\\"aaaa\\", \\"asdasdasdasd\\")) # should return True # print(follows_pattern(\\"aabb\\", \\"xyzabcxzyabc\\")) # should return False"},{"question":"def rearrangeHeights(heights: List[int]) -> List[int]: You are given a **0-indexed** integer array \`heights\` representing the heights of a group of people standing in a line. The goal is to order the people such that each person is standing in front of others who are **equal to or taller** than themselves. Specifically, return a new array \`result\` such that for every person at index \`i\` in \`result\`, every person ahead of them (i.e., from index \`0\` to \`i-1\`) is equal in height or taller. >>> rearrangeHeights([5, 3, 6, 7, 2]) [7, 6, 5, 3, 2] >>> rearrangeHeights([5, 5, 5, 5]) [5, 5, 5, 5] >>> rearrangeHeights([1, 2, 3, 4, 5]) [5, 4, 3, 2, 1] >>> rearrangeHeights([]) [] >>> rearrangeHeights([10, 1, 2, 8, 7, 6]) [10, 8, 7, 6, 2, 1]","solution":"def rearrangeHeights(heights): Returns a new list where elements are arranged from tallest to shortest. return sorted(heights, reverse=True)"},{"question":"def maximalSquare(matrix: List[List[str]]) -> int: Given a m x n binary matrix \`grid\`, return the size of the largest square containing only \`1's\` and return its area. >>> maximalSquare([]) 0 >>> maximalSquare([['0', '0'], ['0','0']]) 0 >>> maximalSquare([['1', '1', '0', '1']]) 1 >>> maximalSquare([['1'], ['0'], ['1'], ['1']]) 1 >>> maximalSquare([ ... ['1', '0', '1', '0', '0'], ... ['1', '0', '1', '1', '1'], ... ['1', '1', '1', '1', '1'], ... ['1', '0', '0', '1', '0'] ... ]) 4 >>> maximalSquare([ ... ['1', '1'], ... ['1', '1'] ... ]) 4 >>> maximalSquare([ ... ['1', '1', '0', '1'], ... ['1', '1', '1', '1'], ... ['1', '1', '1', '1'], ... ['0', '1', '1', '1'] ... ]) 9","solution":"def maximalSquare(matrix): This function takes a 2D binary matrix filled with 0's and 1's and returns the area of the largest square containing only 1's. :param matrix: List[List[int]] :return: int if not matrix: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def can_partition_to_target(arr, target): Determines if the array can be partitioned into two subsets where each subset has a sum equal to \`target\`. :param arr: List of integers. :param target: Integer, target sum for each subset. :return: Boolean, True if partitioning is possible, otherwise False. >>> can_partition_to_target([1, 5, 11, 5], 11) True >>> can_partition_to_target([1, 2, 3, 5], 5) False >>> can_partition_to_target([], 0) True >>> can_partition_to_target([1], 1) False >>> can_partition_to_target([-1, -1, 2], 0) True >>> can_partition_to_target([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 27) False","solution":"def can_partition_to_target(arr, target): Determines if the array can be partitioned into two subsets where each subset has a sum equal to \`target\`. :param arr: List of integers. :param target: Integer, target sum for each subset. :return: Boolean, True if partitioning is possible, otherwise False. total_sum = sum(arr) # If total_sum is not equal to 2 * target, then we cannot partition the array into two parts where each part sums to target. if total_sum != 2 * target: return False n = len(arr) # Initialize DP array dp = [[False] * (target + 1) for _ in range(n + 1)] # A sum of zero can always be made with zero elements. dp[0][0] = True for i in range(1, n + 1): for j in range(target + 1): dp[i][j] = dp[i-1][j] if j >= arr[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]] return dp[n][target]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Determine if the binary tree is symmetric. >>> test_empty_tree() True >>> test_single_node_tree() True >>> test_symmetric_tree() True >>> test_asymmetric_tree_with_different_structure() False >>> test_asymmetric_tree_with_different_values() False >>> test_symmetric_tree_with_none_nodes() True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Determine if the binary tree is symmetric. def isMirror(left, right): # If both subtrees are empty if not left and not right: return True # If only one of the subtrees is empty if not left or not right: return False # Check if the values match and the subtrees are mirrors of each other return (left.val == right.val and isMirror(left.right, right.left) and isMirror(left.left, right.right)) # An empty tree is symmetric if not root: return True return isMirror(root.left, root.right)"},{"question":"def knightProbability(N: int, k: int, r: int, c: int) -> float: Return the probability that a knight remains on an N x N chessboard after making k moves, starting from position (r, c). >>> round(knightProbability(3, 2, 0, 0), 5) 0.06250 >>> knightProbability(8, 0, 4, 4) 1.0 >>> round(knightProbability(100, 2, 50, 50), 5) 1.0 >>> round(knightProbability(3, 3, 0, 0), 5) 0.01562","solution":"def knightProbability(N, k, r, c): Return the probability that the knight remains on the board after making k moves. directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)] dp = [[[0] * N for _ in range(N)] for _ in range(k+1)] dp[0][r][c] = 1 for step in range(1, k+1): for i in range(N): for j in range(N): for dr, dc in directions: ni, nj = i + dr, j + dc if 0 <= ni < N and 0 <= nj < N: dp[step][i][j] += dp[step-1][ni][nj] / 8.0 probability = 0 for i in range(N): for j in range(N): probability += dp[k][i][j] return probability"},{"question":"from typing import List def can_partition_k_subsets(arr: List[int], k: int) -> bool: Determines whether the array can be partitioned into k subsets with equal sum. Parameters: arr (List[int]): The array of non-negative integers. k (int): The number of subsets. Returns: bool: True if the array can be partitioned into k subsets with equal sum, False otherwise. Examples: >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition_k_subsets([1, 2, 3, 4], 3) False from solution import can_partition_k_subsets def test_can_partition_k_subsets_example1(): assert can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) == True def test_can_partition_k_subsets_example2(): assert can_partition_k_subsets([1, 2, 3, 4], 3) == False def test_can_partition_k_subsets_single_element_equal_k(): assert can_partition_k_subsets([5, 5, 5, 5], 4) == True def test_can_partition_k_subsets_equal_k_elements(): assert can_partition_k_subsets([2, 2, 2, 2, 2, 2], 3) == True def test_can_partition_k_subsets_larger_numbers(): assert can_partition_k_subsets([10, 10, 10, 7, 7, 7, 5, 5, 5, 3, 3, 3], 3) == True def test_can_partition_k_subsets_impossible_partition(): assert can_partition_k_subsets([1, 1, 1, 1, 1], 3) == False def test_can_partition_k_subsets_large_k(): assert can_partition_k_subsets([1] * 20, 20) == True","solution":"def can_partition_k_subsets(arr, k): Determines whether the array can be partitioned into k subsets with equal sum. Parameters: arr (List[int]): The array of non-negative integers. k (int): The number of subsets. Returns: bool: True if the array can be partitioned into k subsets with equal sum, False otherwise. total_sum = sum(arr) target_sum = total_sum // k if total_sum % k != 0: return False arr.sort(reverse=True) used = [False] * len(arr) def can_partition(start_index, needed_subsets, current_sum): if needed_subsets == 1: return True if current_sum == target_sum: return can_partition(0, needed_subsets - 1, 0) for i in range(start_index, len(arr)): if not used[i] and current_sum + arr[i] <= target_sum: used[i] = True if can_partition(i + 1, needed_subsets, current_sum + arr[i]): return True used[i] = False return False return can_partition(0, k, 0)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_paths_with_sum(root: TreeNode, target_sum: int) -> int: You are given a binary tree where each node contains a positive integer value. Each path in the tree starts from the root node and goes down to any of the leaves. A path sum is defined as the sum of the values of the nodes visited along the path. Given an integer \`sum\`, return the number of paths in the tree where the path sum equals \`sum\`. The path does not need to start or end at the root or a leaf, but it must go downwards (from parent to child). >>> root = TreeNode(7) >>> count_paths_with_sum(root, 7) 1 >>> root = TreeNode(7) >>> count_paths_with_sum(root, 10) 0 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(-3) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(2) >>> root.right.right = TreeNode(11) >>> root.left.left.left = TreeNode(3) >>> root.left.left.right = TreeNode(-2) >>> root.left.right.right = TreeNode(1) >>> count_paths_with_sum(root, 8) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> count_paths_with_sum(root, 15) 0 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(-3) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(2) >>> root.right.right = TreeNode(11) >>> root.left.left.left = TreeNode(3) >>> root.left.left.right = TreeNode(-2) >>> root.left.right.right = TreeNode(1) >>> root.left.left.left.left = TreeNode(-1) >>> count_paths_with_sum(root, 8) 3 >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> count_paths_with_sum(root, 22) 3","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_paths_with_sum(root, target_sum): def dfs(node, current_path_sums): if not node: return 0 # Update the current path sums current_path_sums = [num + node.value for num in current_path_sums] + [node.value] # Count the paths that sum to target_sum path_count = current_path_sums.count(target_sum) # Explore the left and right subtrees path_count += dfs(node.left, current_path_sums) path_count += dfs(node.right, current_path_sums) return path_count return dfs(root, [])"},{"question":"def min_subarray_length(nums, target): Returns the length of the shortest subarray with a sum at least \`target\`. >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 1, 1, 1, 1], 6) 0 >>> min_subarray_length([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_length([10], 5) 1 >>> min_subarray_length([1], 2) 0 >>> min_subarray_length([1, 4, 4], 8) 2 >>> min_subarray_length([1, 1, 1, 1], 4) 4","solution":"def min_subarray_length(nums, target): Returns the length of the shortest subarray with a sum at least \`target\`. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_unreliable_leaves(root: TreeNode) -> int: Return the number of unreliable leaves in the binary tree. >>> count_unreliable_leaves(None) 0 >>> count_unreliable_leaves(TreeNode(1)) 0 >>> count_unreliable_leaves(TreeNode(2, None, TreeNode(1))) 1 >>> count_unreliable_leaves(TreeNode(1, TreeNode(1))) 0 >>> count_unreliable_leaves(TreeNode(2, TreeNode(3))) 0 >>> count_unreliable_leaves(TreeNode(2, TreeNode(3), TreeNode(1))) 1 >>> count_unreliable_leaves(TreeNode(5, TreeNode(4, TreeNode(7), TreeNode(2)), TreeNode(6))) 1 >>> count_unreliable_leaves(TreeNode(4, TreeNode(3, TreeNode(1), TreeNode(2)), TreeNode(5, TreeNode(6), TreeNode(7)))) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_unreliable_leaves(root): Returns the number of unreliable leaves in the binary tree. if not root: return 0 def is_unreliable_leaf(node, parent_val, sibling_val=None): if node is None: return False # Check if node is a leaf if node.left or node.right: return False # Check if it's less than parent if node.val < parent_val: return True # Check if it's less than sibling if sibling_val is not None and node.val < sibling_val: return True return False def dfs(node, parent_val, sibling_val=None): if node is None: return 0 left_count = dfs(node.left, node.val, node.right.val if node.right else None) right_count = dfs(node.right, node.val, node.left.val if node.left else None) unreliable_leaf_count = 0 if is_unreliable_leaf(node.left, node.val, node.right.val if node.right else None): unreliable_leaf_count += 1 if is_unreliable_leaf(node.right, node.val, node.left.val if node.left else None): unreliable_leaf_count += 1 return left_count + right_count + unreliable_leaf_count return dfs(root, float('inf'))"},{"question":"def judgeCircle(moves: str) -> bool: Determines if the sequence of moves returns the robot to its original starting position. Args: moves (str): A string of moves where 'L' means left, 'R' means right, 'U' means up, and 'D' means down. Returns: bool: True if the sequence of moves returns the robot to the original starting position, otherwise False. >>> judgeCircle(\\"UD\\") True >>> judgeCircle(\\"LL\\") False >>> judgeCircle(\\"RRDD\\") False >>> judgeCircle(\\"LDRU\\") True >>> judgeCircle(\\"\\") True >>> judgeCircle(\\"UDUDUDUDRLRLRLRLU\\") False >>> judgeCircle(\\"ULDR\\") True >>> judgeCircle(\\"ULDRR\\") False >>> judgeCircle(\\"U\\") False >>> judgeCircle(\\"D\\") False >>> judgeCircle(\\"L\\") False >>> judgeCircle(\\"R\\") False","solution":"def judgeCircle(moves): Determines if the sequence of moves returns the robot to its original starting position. Args: moves (str): A string of moves where 'L' means left, 'R' means right, 'U' means up, and 'D' means down. Returns: bool: True if the sequence of moves returns the robot to the original starting position, otherwise False. horizontal, vertical = 0, 0 for move in moves: if move == 'L': horizontal -= 1 elif move == 'R': horizontal += 1 elif move == 'U': vertical += 1 elif move == 'D': vertical -= 1 return horizontal == 0 and vertical == 0"},{"question":"def find_peaks(arr: List[int]) -> List[int]: Finds and returns a list of all peak elements in the array. An element is a peak if it is greater than its neighbors. >>> find_peaks([10]) [10] >>> find_peaks([5, 5, 5, 5]) [] >>> find_peaks([1, 2, 3, 4, 5]) [5] >>> find_peaks([5, 4, 3, 2, 1]) [5] >>> find_peaks([1, 3, 2, 4, 1, 5, 2]) [3, 4, 5] >>> find_peaks([2, 1, 3]) [2, 3] >>> find_peaks([3, 2, 1]) [3] >>> find_peaks([1, 3, 1]) [3] >>> find_peaks([1, 2, 3]) [3]","solution":"def find_peaks(arr): Finds and returns a list of all peak elements in the array. An element is a peak if it is greater than its neighbors. n = len(arr) peaks = [] for i in range(n): if (i == 0 and n > 1 and arr[i] > arr[i+1]) or (i == n-1 and n > 1 and arr[i] > arr[i-1]) or (0 < i < n-1 and arr[i] > arr[i-1] and arr[i] > arr[i+1]) or (n == 1): peaks.append(arr[i]) return peaks"},{"question":"def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left to the bottom-right of the grid, taking into account the obstacles present in the grid. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> unique_paths_with_obstacles([[1, 0], [0, 0]]) == 0 >>> unique_paths_with_obstacles([[0, 0], [0, 0]]) == 2 >>> unique_paths_with_obstacles([[0, 0], [0, 1]]) == 0 >>> unique_paths_with_obstacles([[0]]) == 1 >>> unique_paths_with_obstacles([[1]]) == 0 >>> unique_paths_with_obstacles([[0, 0, 0, 0], [0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0]]) == 3 pass","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right of the grid, taking into account the obstacles present in the grid. m = len(grid) n = len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0]*n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"def num_cells_water_accumulate(grid: List[List[int]]) -> int: Return the total number of cells in the region where water can accumulate when it stops raining. >>> num_cells_water_accumulate([[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]) 7 >>> num_cells_water_accumulate([[2, 4, 3], [6, 5, 2], [3, 1, 1]]) 5 >>> num_cells_water_accumulate([]) 0 >>> num_cells_water_accumulate([[5]]) 1 >>> num_cells_water_accumulate([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 9","solution":"def num_cells_water_accumulate(grid): from collections import deque def bfs(start_cells): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] q = deque(start_cells) seen = set(start_cells) while q: x, y = q.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and (nx, ny) not in seen and grid[nx][ny] >= grid[x][y]: q.append((nx, ny)) seen.add((nx, ny)) return seen if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) pacific_start = [(i, 0) for i in range(m)] + [(0, j) for j in range(n)] atlantic_start = [(i, n - 1) for i in range(m)] + [(m - 1, j) for j in range(n)] pacific_reachable = bfs(pacific_start) atlantic_reachable = bfs(atlantic_start) water_accumulate_cells = pacific_reachable & atlantic_reachable return len(water_accumulate_cells)"},{"question":"def splitArray(nums, k): Distribute the array into exactly \`k\` non-empty contiguous subarrays such that the maximum sum of any subarray is minimized. Example: >>> splitArray([7,2,5,10,8], 2) 18 >>> splitArray([1,2,3,4,5], 2) 9 >>> splitArray([1,4,4], 3) 4","solution":"def splitArray(nums, k): def is_valid(mid): subarray_count = 1 current_sum = 0 for num in nums: if current_sum + num > mid: subarray_count += 1 current_sum = num if subarray_count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if is_valid(mid): right = mid else: left = mid + 1 return left"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Given a string \`s\` of lowercase English letters and an integer array \`indices\`, both of length \`n\`, return a new string where the character at the \`i\`-th position in the new string is the character at the \`indices[i]\`-th position of the input string \`s\`. Parameters: s (str): The input string. indices (List[int]): The list of indices. Returns: str: The reconstructed string. >>> restore_string(\\"abc\\", [2, 1, 0]) 'cba' >>> restore_string(\\"abc\\", [0, 1, 2]) 'abc' >>> restore_string(\\"abcd\\", [3, 2, 1, 0]) 'dcba' >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) 'nihao' >>> restore_string(\\"a\\", [0]) 'a' >>> restore_string(\\"\\", []) ''","solution":"def restore_string(s, indices): Reconstructs the string \`s\` based on the \`indices\` array. Parameters: s (str): The input string of lowercase English letters. indices (list): The list of indices. Returns: str: The reconstructed string. n = len(s) result = [''] * n for i in range(n): result[indices[i]] = s[i] return ''.join(result)"},{"question":"def top_k_candidates(candidates: List[int], k: int) -> List[int]: Returns the indices of the top k candidates based on scores. If scores are tied, the candidates earlier in the list are considered higher ranked. :param candidates: List of integers representing scores of candidates. :param k: Integer representing the number of top candidates to select. :return: List of indices of the top k candidates in the order they should be awarded. >>> top_k_candidates([10, 20, 30, 40, 50], 3) [4, 3, 2] >>> top_k_candidates([50, 20, 30, 40, 10], 2) [0, 3] >>> top_k_candidates([1, 2, 3, 4, 5], 1) [4] >>> top_k_candidates([5, 4, 3, 2, 1], 5) [0, 1, 2, 3, 4] >>> top_k_candidates([10, 10, 10, 10], 2) [0, 1] >>> top_k_candidates([100, 90, 90, 80, 70], 3) [0, 1, 2] >>> top_k_candidates([5, 10], 1) [1] >>> top_k_candidates([3, 3, 3, 3, 3], 4) [0, 1, 2, 3] >>> top_k_candidates([], 0) [] >>> top_k_candidates([7], 1) [0] # Implementation here","solution":"def top_k_candidates(candidates, k): Returns the indices of the top k candidates based on scores. If scores are tied, the candidates earlier in the list are considered higher ranked. :param candidates: List of integers representing scores of candidates. :param k: Integer representing the number of top candidates to select. :return: List of indices of the top k candidates in the order they should be awarded. # Pair each candidate's score with its original index indexed_scores = list(enumerate(candidates)) # Sort the candidates based on their scores in descending order, using the original index to break ties indexed_scores.sort(key=lambda x: (-x[1], x[0])) # Extract the indices of the top k candidates top_k_indices = [idx for idx, score in indexed_scores[:k]] return top_k_indices"},{"question":"def max_subarray_sum(nums: List[int], k: int) -> int: Returns the maximum sum of any subarray of length k from the array nums. If nums contains fewer than k elements, return -1. >>> max_subarray_sum([2, 1, 5, 1, 3, 2], 3) == 9 >>> max_subarray_sum([1, 2, 3], 3) == 6 >>> max_subarray_sum([1, 2], 3) == -1 >>> max_subarray_sum([10], 1) == 10 >>> max_subarray_sum([-2, -1, -3, -4, -6], 2) == -3 >>> max_subarray_sum([4, -1, 2, 1, -7, 8], 3) == 5 >>> max_subarray_sum([4, -1, 2, 1, -7, 8], 4) == 6 >>> max_subarray_sum([1000000, -1000000, 2000000, -2000000, 3000000], 2) == 1000000","solution":"def max_subarray_sum(nums, k): Returns the maximum sum of any subarray of length k from the array nums. If nums contains fewer than k elements, return -1. n = len(nums) if n < k: return -1 max_sum = sum(nums[:k]) current_sum = max_sum for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def minimize_max_books(nums, m): Distribute books into boxes such that each box contains a contiguous sequence of books and the maximum number of books in any box is minimized. Args: nums (List[int]): List of integers representing the number of books on each shelf. m (int): Number of boxes to distribute the books into. Returns: int: The minimized maximum number of books in any box. >>> minimize_max_books([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_books([7, 2, 5, 10, 8], 1) 32 >>> minimize_max_books([1, 2, 3, 4, 5], 5) 5 >>> minimize_max_books([5, 5, 5, 5], 2) 10 >>> minimize_max_books([12, 34, 67, 90], 2) 113","solution":"def minimize_max_books(nums, m): def can_partition(max_books): current_sum = 0 boxes = 1 for num in nums: if current_sum + num > max_books: boxes += 1 current_sum = num if boxes > m: return False else: current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_partition(mid): high = mid else: low = mid + 1 return low"},{"question":"from collections import Counter def min_operations_to_k_distinct_characters(s: str, k: int) -> int: Returns the minimum number of operations required to make the string have at most \`k\` distinct characters. >>> min_operations_to_k_distinct_characters(\\"aabbcc\\", 2) == 2 >>> min_operations_to_k_distinct_characters(\\"abc\\", 3) == 0 >>> min_operations_to_k_distinct_characters(\\"aaabbbccc\\", 2) == 3 >>> min_operations_to_k_distinct_characters(\\"aaaaa\\", 1) == 0 >>> min_operations_to_k_distinct_characters(\\"abcdef\\", 1) == 5 >>> min_operations_to_k_distinct_characters(\\"abcdef\\", 2) == 4 >>> min_operations_to_k_distinct_characters(\\"abcde\\", 10) == 0","solution":"def min_operations_to_k_distinct_characters(s, k): from collections import Counter if k >= len(set(s)): return 0 char_freq = Counter(s) char_freq_values = sorted(char_freq.values(), reverse=True) num_operations = 0 while len(char_freq_values) > k: num_operations += char_freq_values.pop() return num_operations"},{"question":"from typing import List def min_days_to_equal_heights(heights: List[int]) -> int: Returns the minimum number of days required to make all building heights equal. >>> min_days_to_equal_heights([3, 3, 3]) == 0 >>> min_days_to_equal_heights([1, 2, 3]) == 3 >>> min_days_to_equal_heights([1, 3, 5]) == 6 >>> min_days_to_equal_heights([10]) == 0 >>> min_days_to_equal_heights([4, 4, 4, 4]) == 0 >>> min_days_to_equal_heights([0, 2, 10]) == 18","solution":"def min_days_to_equal_heights(heights): Returns the minimum number of days required to make all building heights equal. max_height = max(heights) days_needed = 0 for height in heights: days_needed += (max_height - height) return days_needed"},{"question":"def min_seconds_to_burn_candles(candles): Returns the minimum number of seconds needed to burn out all candles. :param candles: List of non-negative integers representing candle stacks :return: Integer, the minimum number of seconds to burn out all candles from solution import min_seconds_to_burn_candles def test_min_seconds_empty_list(): assert min_seconds_to_burn_candles([]) == 0 def test_min_seconds_single_stack(): assert min_seconds_to_burn_candles([5]) == 5 assert min_seconds_to_burn_candles([0]) == 0 def test_min_seconds_identical_stacks(): assert min_seconds_to_burn_candles([3, 3, 3]) == 3 def test_min_seconds_different_stacks(): assert min_seconds_to_burn_candles([1, 2, 5]) == 5 assert min_seconds_to_burn_candles([4, 2, 1]) == 4 def test_min_seconds_large_numbers(): assert min_seconds_to_burn_candles([100, 200, 300]) == 300 assert min_seconds_to_burn_candles([1000, 750, 500]) == 1000","solution":"def min_seconds_to_burn_candles(candles): Returns the minimum number of seconds needed to burn out all candles. :param candles: List of non-negative integers representing candle stacks :return: Integer, the minimum number of seconds to burn out all candles if not candles: return 0 # The number of seconds needed is determined by the stack with the maximum candles return max(candles)"},{"question":"def minSubArrayLen(s: int, arr: List[int]) -> int: Returns the length of the shortest, non-empty, contiguous subarray of arr with a sum equal to s. If no such subarray exists, return -1. >>> minSubArrayLen(7, [2, 3, 1, 2, 4, 3]) 2 >>> minSubArrayLen(100, [1, 2, 3, 4, 5]) -1 >>> minSubArrayLen(15, [1, 2, 3, 4, 5]) 5 >>> minSubArrayLen(4, [4]) 1 >>> minSubArrayLen(8, [1, 7, 1, 2, 8, 3, 2, 1, 1, 5]) 1","solution":"def minSubArrayLen(s, arr): Returns the length of the shortest, non-empty, contiguous subarray of arr with a sum equal to s. If no such subarray exists, return -1. n = len(arr) min_len = float('inf') start = 0 current_sum = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else -1"},{"question":"def longestCommonSubsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence of s1 and s2. Parameters: s1 (str): First string. s2 (str): Second string. Returns: int: The length of the longest common subsequence. Examples: >>> longestCommonSubsequence(\\"abcde\\", \\"ace\\") 3 >>> longestCommonSubsequence(\\"abc\\", \\"def\\") 0 >>> longestCommonSubsequence(\\"abc\\", \\"abc\\") 3 >>> longestCommonSubsequence(\\"abcd\\", \\"abef\\") 2 >>> longestCommonSubsequence(\\"aab\\", \\"azb\\") 2 >>> longestCommonSubsequence(\\"\\", \\"abc\\") 0 >>> longestCommonSubsequence(\\"abc\\", \\"\\") 0 >>> longestCommonSubsequence(\\"\\", \\"\\") 0 pass","solution":"def longestCommonSubsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence of s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def max_consistent_study_days(nums: List[int], k: int, n: int) -> int: Returns the maximum number of consecutive days a student can study at least k hours. Args: nums (list of int): A list of positive integers representing the hours studied each day. k (int): The minimum required hours of study each day to be considered consistent. n (int): The number of consecutive days required to be considered consistent. Returns: int: The maximum number of consecutive days a student can be consistent. >>> max_consistent_study_days([1, 2, 3], 4, 2) 0 >>> max_consistent_study_days([4, 5, 6], 4, 2) 3 >>> max_consistent_study_days([4, 5, 2, 4, 5, 6], 3, 2) 3 >>> max_consistent_study_days([4], 4, 1) 1 >>> max_consistent_study_days([1, 3, 3, 3, 1], 3, 3) 3 >>> max_consistent_study_days([1, 2, 3] * 1000 + [5, 6] * 1000, 5, 2) 2000","solution":"def max_consistent_study_days(nums, k, n): Returns the maximum number of consecutive days a student can study at least k hours. Args: nums (list of int): A list of positive integers representing the hours studied each day. k (int): The minimum required hours of study each day to be considered consistent. n (int): The number of consecutive days required to be considered consistent. Returns: int: The maximum number of consecutive days a student can be consistent. max_days = 0 current_days = 0 for hours in nums: if hours >= k: current_days += 1 else: current_days = 0 if current_days >= n: max_days = max(max_days, current_days) return max_days"},{"question":"import heapq from typing import List def dijkstra(n: int, edges: List[List[int], src: int) -> List[int]: Returns the shortest path distances from the starting node \`src\` to all other nodes in the graph. Parameters: n (int): The number of nodes labeled from 1 to n. edges (list of lists of int): The list of edges represented as [from, to, weight]. src (int): The starting node. Returns: list of int: The list of shortest distances, where the distance to each node i is \`dist[i - 1]\`. If there is no path from \`src\` to node i, \`dist[i - 1]\` is -1. >>> dijkstra(5, [[1, 2, 2], [1, 3, 5], [2, 3, 1], [2, 4, 2], [3, 4, 2], [4, 5, 1]], 1) [0, 2, 3, 4, 5] >>> dijkstra(4, [[1, 2, 4], [1, 3, 2]], 1) [0, 4, 2, -1] >>> dijkstra(1, [], 1) [0] >>> dijkstra(6, [[1, 2, 7], [1, 3, 9], [2, 4, 10], [3, 6, 1]], 1) [0, 7, 9, 17, -1, 10] >>> dijkstra(3, [[1, 2, 1000000], [1, 3, 500000]], 1) [0, 1000000, 500000]","solution":"import heapq def dijkstra(n, edges, src): Returns the shortest path distances from the starting node \`src\` to all other nodes in the graph. Parameters: n (int): The number of nodes labeled from 1 to n. edges (list of lists of int): The list of edges represented as [from, to, weight]. src (int): The starting node. Returns: list of int: The list of shortest distances, where the distance to each node i is \`dist[i - 1]\`. If there is no path from \`src\` to node i, \`dist[i - 1]\` is -1. graph = {i: [] for i in range(1, n + 1)} for frm, to, weight in edges: graph[frm].append((to, weight)) dist = {i: float('inf') for i in range(1, n + 1)} dist[src] = 0 priority_queue = [(0, src)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(1, n + 1): result.append(dist[i] if dist[i] != float('inf') else -1) return result"},{"question":"def canJump(nums): Determines if you can reach the last index starting from the first index. Args: nums (list of int): List where each element represents the maximum jump length at that position. Returns: bool: True if you can reach the last index, otherwise False. >>> canJump([2,3,1,1,4]) == True >>> canJump([3,2,1,0,4]) == False >>> canJump([0]) == True >>> canJump([2,0,0,0,0]) == False >>> canJump([2,5,0,0]) == True >>> canJump([]) == True","solution":"def canJump(nums): Determines if you can reach the last index starting from the first index. Args: nums (list of int): List where each element represents the maximum jump length at that position. Returns: bool: True if you can reach the last index, otherwise False. furthest_reach = 0 for i in range(len(nums)): if i > furthest_reach: return False furthest_reach = max(furthest_reach, i + nums[i]) return True"},{"question":"class SmallestNumber: def __init__(self): pass def removeKdigits(self, num: str, k: int) -> str: Removes k digits from the non-negative integer num to form the smallest possible number. Parameters: num (str): The non-negative integer represented as a string. k (int): The number of digits to remove. Returns: str: The smallest possible number after removing k digits. Examples: >>> obj = SmallestNumber() >>> obj.removeKdigits(\\"1432219\\", 3) \\"1219\\" >>> obj.removeKdigits(\\"10200\\", 1) \\"200\\" >>> obj.removeKdigits(\\"10\\", 2) \\"0\\" >>> obj.removeKdigits(\\"10\\", 1) \\"0\\"","solution":"class SmallestNumber: def __init__(self): pass def removeKdigits(self, num, k): Removes k digits from the non-negative integer num to form the smallest possible number. Parameters: num (str): The non-negative integer represented as a string. k (int): The number of digits to remove. Returns: str: The smallest possible number after removing k digits. stack = [] # Iterate through each character in the number for digit in num: # Remove the last digit from stack if the current digit is smaller # and we still have digits to remove while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still digits to remove, remove from the end stack = stack[:-k] if k else stack # Join stack to form the resulting number and remove leading zeros result = ''.join(stack).lstrip('0') return result if result else \\"0\\""},{"question":"def max_sum_submatrix(matrix): Returns the maximum sum of any rectangular submatrix. The submatrix must contain at least one element. >>> max_sum_submatrix([ ... [1, -2], ... [-1, 2] ... ]) == 2 >>> max_sum_submatrix([ ... [1, 2], ... [3, 4] ... ]) == 10 >>> max_sum_submatrix([ ... [-1, -2], ... [-3, -4] ... ]) == -1 >>> max_sum_submatrix([ ... [6, -5, -7, 4, -4], ... [-9, 3, -6, 5, 2], ... [-10, 4, 7, -6, 3], ... [-8, 9, -3, 3, -7] ... ]) == 17 >>> max_sum_submatrix([ ... [2], ... [1], ... [-3], ... [4], ... [-1] ... ]) == 4 >>> max_sum_submatrix([ ... [7] ... ]) == 7 pass","solution":"def max_sum_submatrix(matrix): Returns the maximum sum of any rectangular submatrix. m, n = len(matrix), len(matrix[0]) if matrix else 0 max_sum = float('-inf') for left in range(n): temp = [0] * m for right in range(left, n): for i in range(m): temp[i] += matrix[i][right] current_max = max_subarray_sum(temp) max_sum = max(max_sum, current_max) return max_sum def max_subarray_sum(arr): Helper function to find the maximum sum of a subarray. current_max = global_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"def min_height_to_cut(heights: List[int], target: int) -> int: Given an array of integers \`heights\` representing the height of trees in a forest, and an integer \`target\`, find the minimum height \`H\` you need to cut the trees such that the sum of the heights of the trees cut equals or exceeds \`target\`. You may assume that if a tree is cut at height \`H\`, then the height of the tree after cutting is \`max(0, height - H)\`. Return \`-1\` if it's not possible to achieve the \`target\` by cutting the trees at any height. >>> min_height_to_cut([4, 42, 40, 26, 46], 20) == 36 >>> min_height_to_cut([20, 15, 10, 17], 7) == 15 >>> min_height_to_cut([4, 42, 40, 26, 46], 1000) == -1 >>> min_height_to_cut([], 10) == -1 >>> min_height_to_cut([4, 42, 40, 26, 46], 0) == 46 >>> min_height_to_cut([0, 0, 0, 0], 1) == -1","solution":"def min_height_to_cut(heights, target): def wood_collected(cut_height): return sum(max(0, height - cut_height) for height in heights) if not heights: return -1 left, right = 0, max(heights) result = -1 while left <= right: mid = (left + right) // 2 if wood_collected(mid) >= target: result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generate a n x n spiral matrix. :param n: Size of the matrix (n x n) :type n: int :return: n x n matrix in spiral order :rtype: List[List[int]] >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(0) [] >>> generate_spiral_matrix(-1) [] >>> generate_spiral_matrix(-5) []","solution":"def generate_spiral_matrix(n): Generate a n x n spiral matrix. :param n: Size of the matrix (n x n) :type n: int :return: n x n matrix in spiral order :rtype: List[List[int]] if n <= 0: return [] matrix = [[0] * n for _ in range(n)] current_value = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): # Traverse from left to right matrix[top][i] = current_value current_value += 1 top += 1 for i in range(top, bottom + 1): # Traverse from top to bottom matrix[i][right] = current_value current_value += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): # Traverse from right to left matrix[bottom][i] = current_value current_value += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): # Traverse from bottom to top matrix[i][left] = current_value current_value += 1 left += 1 return matrix"},{"question":"from typing import List def subarray_sum_exists(nums: List[int], target: int) -> bool: Determine if there exists a subarray (contiguous subsequence) whose sum is exactly equal to target. >>> subarray_sum_exists([1, 2, 3, 4, 5], 9) True >>> subarray_sum_exists([1, 2, 3, 4, 5], 20) False >>> subarray_sum_exists([10, -10, 10], 10) True >>> subarray_sum_exists([-5, -4, -3], 1) False >>> subarray_sum_exists([-1, -2, -3, -4, -5], -10) True >>> subarray_sum_exists([10, 2, -2, -20, 10], -10) True >>> subarray_sum_exists([], 0) False # No subarray possible in empty array >>> subarray_sum_exists([1, 2, -3, 4, 5], 0) True","solution":"def subarray_sum_exists(nums, target): Returns True if there exists a subarray with sum exactly equal to target, otherwise returns False. current_sum = 0 sum_dict = {0: -1} # Dictionary to store sum:index pairs for i, num in enumerate(nums): current_sum += num if (current_sum - target) in sum_dict: return True sum_dict[current_sum] = i return False"},{"question":"from typing import List def least_interval(tasks: List[str], k: int) -> int: Given a list of \`n\` tasks, each represented by a lowercase alphabet character, and an integer \`k\` representing a cooling period, this function returns the minimum number of units of time required to finish all the tasks. >>> least_interval(['a', 'a', 'a', 'b', 'b', 'b'], 0) 6 >>> least_interval(['a', 'a', 'a', 'b', 'b', 'b'], 2) 8 >>> least_interval(['a', 'a', 'a'], 2) 7 >>> least_interval(['a', 'a', 'a', 'a'], 2) 10 >>> least_interval(['a', 'b', 'c', 'd'], 2) 4 >>> least_interval(['a', 'b', 'c', 'a', 'b', 'c'], 2) 6 >>> least_interval(['a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'], 2) 8 >>> least_interval(['a'], 2) 1 >>> least_interval(['a'], 0) 1","solution":"from collections import Counter import heapq def least_interval(tasks, k): Returns the minimum number of units of time to finish all tasks with a cooldown period of k. if k == 0: return len(tasks) # Count the frequency of each task task_counts = Counter(tasks) # Use a max heap to store tasks based on their frequency max_heap = [-cnt for cnt in task_counts.values()] heapq.heapify(max_heap) time = 0 while max_heap: temp = [] for _ in range(k + 1): if max_heap: cnt = heapq.heappop(max_heap) if cnt < -1: temp.append(cnt + 1) time += 1 if not max_heap and not temp: break for item in temp: heapq.heappush(max_heap, item) return time"},{"question":"def min_swaps_to_make_identical(s: str, t: str) -> int: Returns the minimum number of swap operations needed to make the strings identical. >>> min_swaps_to_make_identical(\\"abc\\", \\"abc\\") == 0 >>> min_swaps_to_make_identical(\\"ab\\", \\"ba\\") == 1 >>> min_swaps_to_make_identical(\\"abcd\\", \\"cdab\\") == 2 >>> min_swaps_to_make_identical(\\"abc\\", \\"def\\") == -1 >>> min_swaps_to_make_identical(\\"abcdefghijklmnopqrstuvwxyz\\", \\"zyxwvutsrqponmlkjihgfedcba\\") == 13","solution":"def min_swaps_to_make_identical(s, t): Returns the minimum number of swap operations needed to make the strings identical. if sorted(s) != sorted(t): return -1 # Not possible to make identical mismatches = sum(1 for i in range(len(s)) if s[i] != t[i]) return mismatches // 2"},{"question":"def shortest_gift_group(gift_weights: List[int], threshold: int) -> int: Returns the length of the shortest group of gifts where the sum is greater than or equal to the threshold. If no such group exists, returns -1. >>> shortest_gift_group([1, 2, 3], 10) -1 >>> shortest_gift_group([10, 2, 3], 10) 1 >>> shortest_gift_group([2, 1, 5, 2], 6) 2 >>> shortest_gift_group([1, 2, 3, 4, 5], 9) 2 >>> shortest_gift_group([1, 1, 1, 1], 3) 3 >>> shortest_gift_group([2, 3, 1, 2, 4, 3], 7) 2 >>> shortest_gift_group([1, 2, 3, 40, 5, 2], 41) 2","solution":"def shortest_gift_group(gift_weights, threshold): Returns the length of the shortest group of gifts where the sum is greater than or equal to the threshold. If no such group exists, returns -1. n = len(gift_weights) min_length = float('inf') for start in range(n): current_sum = 0 for end in range(start, n): current_sum += gift_weights[end] if current_sum >= threshold: min_length = min(min_length, end - start + 1) break return min_length if min_length != float('inf') else -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.nextRight = None def connect_next_right(root): Initialize the nextRight pointer for each node in the binary tree to point to the node immediately to its right at the same level. If there is no node to the immediate right, the nextRight pointer should be set to None. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> connect_next_right(root) >>> root.nextRight is None True >>> root.left.nextRight == root.right True >>> root.right.nextRight is None True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> connect_next_right(root) >>> root.left.left.nextRight == root.left.right True >>> root.left.right.nextRight == root.right.right True >>> root.right.right.nextRight is None True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right self.nextRight = None def connect_next_right(root): if not root: return None queue = [root] while queue: next_level = [] prev_node = None for node in queue: if prev_node: prev_node.nextRight = node if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) prev_node = node # The last node in the current level should point to None if prev_node: prev_node.nextRight = None queue = next_level return root"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLeaves(root: TreeNode) -> List[List[int]]: Given a binary tree, collect the leaves of all nodes and remove them, then repeat the process. The output should be a list of lists, where each list contains the leaves collected at each stage of the process. >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> findLeaves(root) [[4, 5, 3], [2], [1]] >>> root = TreeNode(1) >>> findLeaves(root) [[1]] >>> root = None >>> findLeaves(root) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findLeaves(root): def remove_leaves(node): if not node: return None, [] if not node.left and not node.right: return None, [node.val] node.left, left_leaves = remove_leaves(node.left) node.right, right_leaves = remove_leaves(node.right) return node, left_leaves + right_leaves result = [] while root: root, leaves = remove_leaves(root) result.append(leaves) return result"},{"question":"from typing import List def countCharacters(words: List[str], chars: str) -> int: Returns the sum of lengths of all good strings in \`words\`. A string is considered good if it can be formed by characters from \`chars\` (each character can be used only once). >>> countCharacters([\\"cat\\"], \\"atach\\") 3 >>> countCharacters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> countCharacters([\\"hello\\", \\"world\\"], \\"abc\\") 0 >>> countCharacters([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") 3 >>> countCharacters([], \\"abc\\") 0 >>> countCharacters([\\"hello\\", \\"world\\"], \\"\\") 0 >>> countCharacters([\\"aa\\", \\"bb\\", \\"cc\\"], \\"aabbcc\\") 6 >>> countCharacters([\\"hello\\", \\"world\\", \\"abc\\", \\"d\\"], \\"abcdabcd\\") 4 >>> countCharacters([\\"ab\\", \\"cd\\", \\"ef\\"], \\"abcdef\\") 6","solution":"from collections import Counter def countCharacters(words, chars): Returns the sum of lengths of all good strings in \`words\`. A string is considered good if it can be formed by characters from \`chars\` (each character can be used only once). chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[c] <= chars_count.get(c, 0) for c in word_count): total_length += len(word) return total_length"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Given a binary tree, returns the right side view of its nodes' values. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.left.left = TreeNode(7) >>> right_side_view(root) [1, 3, 6, 7] >>> root = TreeNode(1) >>> root.right = TreeNode(3) >>> root.right.right = TreeNode(6) >>> right_side_view(root) [1, 3, 6] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(4) >>> right_side_view(root) [1, 2, 4] >>> right_side_view(None) [] >>> root = TreeNode(1) >>> right_side_view(root) [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.right = TreeNode(5) >>> root.right = TreeNode(3) >>> root.right.right = TreeNode(4) >>> right_side_view(root) [1, 3, 4] >>> root = TreeNode(1) >>> root.left = TreeNode(2, None, TreeNode(5)) >>> root.right = TreeNode(3, None, TreeNode(6)) >>> root.left.right.left = TreeNode(7) >>> root.right.right.right = TreeNode(8) >>> right_side_view(root) [1, 3, 6, 8] pass","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: TreeNode): if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # Add the last node of this level to the right_view if i == level_length - 1: right_view.append(node.val) # Add left and right children to the queue if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"def max_buildings_stacked(heights: list[int], weights: list[int], capacity: int) -> int: Determines the maximum number of buildings that can be stacked vertically. Each building's height must be less than or equal to the previous one in the stack and the total weight of the stack must not exceed the given capacity. Parameters: heights (list[int]): The heights of the buildings. weights (list[int]): The weights of the buildings. capacity (int): The maximum allowed total weight of the stack. Returns: int: The maximum number of buildings that can be stacked according to the rules. >>> max_buildings_stacked([4, 3, 2, 1], [10, 20, 30, 40], 50) 2 >>> max_buildings_stacked([4, 3, 2, 1], [10, 10, 10, 10], 50) 4 >>> max_buildings_stacked([4, 3, 2, 1], [10, 20, 30, 40], 100) 4 >>> max_buildings_stacked([4, 3, 2, 1], [60, 70, 80, 90], 50) 0 >>> max_buildings_stacked([4, 3, 2, 1], [30, 20, 10, 10], 60) 3 >>> max_buildings_stacked([3, 3, 2, 1], [20, 30, 40, 50], 40) 1 >>> max_buildings_stacked([1, 2, 3], [60, 70, 80], 50) 0 >>> max_buildings_stacked([5], [5], 5) 1 >>> max_buildings_stacked([5], [5], 4) 0","solution":"def max_buildings_stacked(heights, weights, capacity): Determines the maximum number of buildings that can be stacked vertically. Each building's height must be less than or equal to the previous one in the stack and the total weight of the stack must not exceed the given capacity. Parameters: heights (list of int): The heights of the buildings. weights (list of int): The weights of the buildings. capacity (int): The maximum allowed total weight of the stack. Returns: int: The maximum number of buildings that can be stacked according to the rules. buildings = list(zip(heights, weights)) buildings.sort(reverse=True, key=lambda x: x[0]) # Sort by height in descending order total_weight = 0 count = 0 for height, weight in buildings: if total_weight + weight > capacity: break total_weight += weight count += 1 return count"},{"question":"from typing import List def maxValue(grid: List[List[int]]) -> int: Returns the maximum sum of numbers that the robot can collect by the time it reaches the bottom-right cell. :param grid: List[List[int]] - 2D grid of non-negative integers :return: int - maximum sum of numbers >>> maxValue([[5]]) 5 >>> maxValue([[1, 2], [1, 1]]) 4 >>> maxValue([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> maxValue([[1, 2, 5], [3, 2, 1]]) 9 >>> maxValue([[1, 2, 3, 4]]) 10 >>> maxValue([[1], [2], [3], [4]]) 10 >>> maxValue([]) 0 >>> maxValue([[]]) 0","solution":"def maxValue(grid): Returns the maximum sum of numbers that the robot can collect by the time it reaches the bottom-right cell. :param grid: List[List[int]] - 2D grid of non-negative integers :return: int - maximum sum of numbers if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] for i in range(1, m): for j in range(1, n): grid[i][j] += max(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"def has_divisible_pair(n: int, a: List[int]) -> bool: Determine if there exists a pair of indices (i, j) such that i < j and a[i] is evenly divisible by a[j]. Parameters: n (int): The length of the array a. a (list of int): The array of positive integers. Returns: bool: True if such a pair exists, otherwise False. >>> has_divisible_pair(4, [6, 8, 12, 2]) True >>> has_divisible_pair(5, [10, 15, 25, 50, 3]) True >>> has_divisible_pair(3, [7, 5, 10]) False >>> has_divisible_pair(6, [24, 36, 48, 1, 6, 12]) True >>> has_divisible_pair(4, [2, 3, 5, 7]) False","solution":"def has_divisible_pair(n, a): Determines if there exists a pair of indices (i, j) such that i < j and a[i] is evenly divisible by a[j]. Parameters: n (int): The length of the array a. a (list of int): The array of positive integers. Returns: bool: True if such a pair exists, otherwise False. for i in range(n): for j in range(i + 1, n): if a[i] % a[j] == 0: return True return False"},{"question":"def is_match(s: str, p: str) -> bool: Given a string \`s\` which consists of lowercase letters and a pattern \`p\` which consists of lowercase letters and the special character \`*\` where \`*\` can match zero or more of the preceding element, return \`true\` if \`s\` matches the pattern \`p\` or \`false\` otherwise. Note that \`*\` only applies to the character immediately to its left and not to the entire pattern. >>> is_match(\\"aab\\", \\"c*a*b\\") True >>> is_match(\\"mississippi\\", \\"mis*is*p*.\\") False >>> is_match(\\"ab\\", \\".*\\") True","solution":"def is_match(s, p): Returns true if the string s matches the pattern p, otherwise false. The pattern can include the special character '*' which means zero or more of the preceding element. # Base conditions if not p: return not s # Check if the first character of the string matches the first character of the pattern or if the first character # of the pattern is '.' first_match = bool(s) and p[0] in {s[0], '.'} # Handle the '*' in the pattern if len(p) >= 2 and p[1] == '*': # Two cases: # 1. We ignore the current pattern character and the '*' (this is the expression is_match(s, p[2:])) # 2. The current pattern character matches the first character of the string and we check the rest of the string return is_match(s, p[2:]) or (first_match and is_match(s[1:], p)) else: # Simple case: first characters match and the rest of the string must match the rest of the pattern return first_match and is_match(s[1:], p[1:])"},{"question":"def can_rearrange_to_substring(s: str, t: str) -> bool: Determine if \`t\` can be rearranged to form a substring of \`s\`. >>> can_rearrange_to_substring(\\"hello\\", \\"oellh\\") True >>> can_rearrange_to_substring(\\"udacity\\", \\"city\\") True >>> can_rearrange_to_substring(\\"hellothere\\", \\"xyz\\") False >>> can_rearrange_to_substring(\\"anystring\\", \\"\\") True >>> can_rearrange_to_substring(\\"short\\", \\"longerstring\\") False >>> can_rearrange_to_substring(\\"hellotheremate\\", \\"hello\\") True","solution":"def can_rearrange_to_substring(s, t): Determine if \`t\` can be rearranged to form a substring of \`s\`. Args: s (str): The string in which to find the substring. t (str): The string that needs to be rearranged and checked. Returns: bool: True if \`t\` can be rearranged to form a substring of \`s\`, False otherwise. from collections import Counter len_s, len_t = len(s), len(t) if len_t > len_s: return False t_count = Counter(t) window_count = Counter(s[:len_t]) if window_count == t_count: return True for i in range(len_t, len_s): window_count[s[i]] += 1 window_count[s[i - len_t]] -= 1 if window_count[s[i - len_t]] == 0: del window_count[s[i - len_t]] if window_count == t_count: return True return False"},{"question":"def min_difference(arr: List[int]) -> int: Returns the minimum absolute difference between the sums of two equal length sub-arrays of arr. Parameters: arr (list of int): A permutation of the first n natural numbers where n is even. Returns: int: Minimum absolute difference between the sums of the two equal length sub-arrays. pass # Test cases def test_min_difference_simple(): assert min_difference([1, 2, 3, 4]) == 0 def test_min_difference_large(): assert min_difference([1, 3, 5, 7, 2, 4, 6, 8]) == 0 def test_min_difference_edge_case(): assert min_difference([1, 2]) == 1 def test_min_difference_mixed(): assert min_difference([4, 1, 2, 3]) == 0 def test_min_difference_more_complex(): assert min_difference([1, 8, 3, 6, 5, 4, 7, 2]) == 0 def test_min_difference_unsorted(): assert min_difference([8, 1, 6, 3, 5, 4, 7, 2]) == 0","solution":"def min_difference(arr): Returns the minimum absolute difference between the sums of two equal length sub-arrays of arr. Parameters: arr (list of int): A permutation of the first n natural numbers where n is even. Returns: int: Minimum absolute difference between the sums of the two equal length sub-arrays. total_sum = sum(arr) n = len(arr) // 2 # Finding the closest sum to half of total sum for one of the sub-arrays half_sum = total_sum // 2 dp = [0] * (half_sum + 1) for num in arr: for j in range(half_sum, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) sub1_sum = dp[half_sum] sub2_sum = total_sum - sub1_sum return abs(sub1_sum - sub2_sum)"},{"question":"def has_two_indices_with_sum_leq_target(nums, target): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] is less than or equal to target. :param nums: List of integers. :param target: Integer target value. :return: Boolean value, True if such indices exist, otherwise False. >>> has_two_indices_with_sum_leq_target([1, 2, 3, 4, 5], 5) True >>> has_two_indices_with_sum_leq_target([3, 1, 4, 1, 5], 6) True >>> has_two_indices_with_sum_leq_target([5, 6, 7, 8, 9], 10) False >>> has_two_indices_with_sum_leq_target([], 5) False >>> has_two_indices_with_sum_leq_target([5], 5) False >>> has_two_indices_with_sum_leq_target([0, -1, 2, -3, 4], 1) True >>> has_two_indices_with_sum_leq_target([-4, -3, -2, -1], -5) True >>> has_two_indices_with_sum_leq_target([10**6, 2 * 10**6, -10**6], 10**6) True >>> has_two_indices_with_sum_leq_target([], 0) False >>> has_two_indices_with_sum_leq_target([1], 2) False","solution":"def has_two_indices_with_sum_leq_target(nums, target): Determines if there are two distinct indices i and j in the array such that nums[i] + nums[j] is less than or equal to target. :param nums: List of integers. :param target: Integer target value. :return: Boolean value, True if such indices exist, otherwise False. # Checking pairs (i, j) such that i < j for i in range(len(nums)): for j in range(i + 1, len(nums)): if nums[i] + nums[j] <= target: return True return False"},{"question":"from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Return the level order traversal of a binary tree as a list of lists. >>> root = TreeNode(1) >>> levelOrder(root) [[1]] >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> levelOrder(root) [[1], [2, 3]] >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> levelOrder(root) [[1], [2, 3], [4, 5, 6]]","solution":"from collections import deque # Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root): Return the level order traversal of a binary tree as a list of lists. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string s containing only lowercase letters, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right, char in enumerate(s): if char in char_map: left = max(left, char_map[char] + 1) char_map[char] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def find_buildings_outline(heights): Returns an array of height intervals where each interval is represented as a tuple (start, end, height). Each building must have a flat top and extend down to the ground. >>> find_buildings_outline([]) == [] >>> find_buildings_outline([5]) == [(0, 0, 5)] >>> find_buildings_outline([3, 3, 3]) == [(0, 2, 3)] >>> find_buildings_outline([1, 2, 3]) == [(0, 0, 1), (1, 1, 2), (2, 2, 3)] >>> find_buildings_outline([1, 2, 2, 3, 1, 1]) == [(0, 0, 1), (1, 2, 2), (3, 3, 3), (4, 5, 1)] >>> find_buildings_outline([1, 3, 1, 3, 2, 2]) == [(0, 0, 1), (1, 1, 3), (2, 2, 1), (3, 3, 3), (4, 5, 2)] # Your code here","solution":"def find_buildings_outline(heights): Returns an array of height intervals representing the buildings outline. Each interval is a tuple (start, end, height). if not heights: return [] result = [] start = 0 current_height = heights[0] for i in range(1, len(heights)): if heights[i] != current_height: result.append((start, i - 1, current_height)) start = i current_height = heights[i] result.append((start, len(heights) - 1, current_height)) return result"},{"question":"def is_beautiful_array(nums: List[int]) -> bool: Determines if the array is beautiful. An array is called beautiful if for any two elements nums[i] and nums[j] (where i < j), the difference between them is not equal to 1. Parameters: nums (list of ints): The array of integers to check. Returns: bool: True if the array is beautiful, False otherwise. >>> is_beautiful_array([4, 5, 6]) == False >>> is_beautiful_array([1, 3, 5]) == True >>> is_beautiful_array([7, 10, 13]) == True >>> is_beautiful_array([2, 3, 4, 6]) == False >>> is_beautiful_array([]) == True >>> is_beautiful_array([1]) == True >>> is_beautiful_array([1, 2, 4, 5]) == False >>> is_beautiful_array([10, 12, 14, 16]) == True","solution":"def is_beautiful_array(nums): Determines if the array is beautiful. Parameters: nums (list of ints): The array of integers to check. Returns: bool: True if the array is beautiful, False otherwise. nums_set = set(nums) # Convert list to set for O(1) lookups for num in nums: if (num + 1) in nums_set or (num - 1) in nums_set: return False return True"},{"question":"from typing import List, Tuple def reconstruct_queue(people: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Reconstruct and return the queue that meets the specifications based on the list of people represented as tuples (height, k), where 'height' is the person's height, and 'k' is the number of people in front of them who have a height greater than or equal to their height. >>> reconstruct_queue([(7, 0), (4, 4), (7, 1), (5, 0), (6, 1), (5, 2)]) [(5, 0), (7, 0), (5, 2), (6, 1), (4, 4), (7, 1)] >>> reconstruct_queue([]) [] >>> reconstruct_queue([(1, 0)]) [(1, 0)] >>> reconstruct_queue([(6, 0), (5, 1), (4, 2)]) [(6, 0), (5, 1), (4, 2)] >>> reconstruct_queue([(5, 0), (5, 1), (5, 2)]) [(5, 0), (5, 1), (5, 2)]","solution":"def reconstruct_queue(people): Reconstructs the queue based on the given people list of tuples. Each tuple is (height, k) where 'height' is the person's height and 'k' is the number of people in front who have a height greater than or equal to that person's height. :param people: List of tuples [(height, k), ...] :return: Reconstructed queue as a list of tuples # Sort people by height in descending order, and by k in ascending order people.sort(key=lambda x: (-x[0], x[1])) queue = [] # Insert each person into the queue based on their k value for person in people: queue.insert(person[1], person) return queue"},{"question":"def count_visible_buildings(heights: List[int]) -> int: Returns the number of buildings that can be seen from the left side. >>> count_visible_buildings([]) 0 >>> count_visible_buildings([5]) 1 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([5, 4, 3, 2, 1]) 1 >>> count_visible_buildings([3, 1, 4, 2, 5, 1]) 3 >>> count_visible_buildings([3, 3, 4, 4, 5, 5, 1]) 3 >>> count_visible_buildings([4, 4, 4, 4, 4, 4]) 1 pass","solution":"def count_visible_buildings(heights): Returns the number of buildings that can be seen from the left side. if not heights: return 0 visible_count = 1 # The first building is always visible max_height = heights[0] for height in heights[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def diagonal_difference(mat: List[List[int]]) -> int: Return the difference between the sum of the primary and secondary diagonals of a square matrix. :param mat: A square matrix represented as a list of lists of integers. :return: The absolute difference between the sums of the matrix's primary and secondary diagonals. >>> diagonal_difference([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 0 >>> diagonal_difference([ ... [1, 2, 1], ... [6, 5, 4], ... [1, 8, 9] ... ]) 8","solution":"def diagonal_difference(mat): Returns the difference between the sum of the primary and secondary diagonals of a square matrix. :param mat: List[List[int]] - square matrix :return: int - difference between the sums of the diagonals n = len(mat) primary_diagonal_sum = sum(mat[i][i] for i in range(n)) secondary_diagonal_sum = sum(mat[i][n - i - 1] for i in range(n)) return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"def max_profit(nums: List[int]) -> int: Calculate the maximum profit from at most one transaction (buy one and sell one share of the stock) given the array of stock prices \`nums\`. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([1, 2]) == 1 >>> max_profit([2, 4, 1]) == 2 >>> max_profit([]) == 0 >>> max_profit([3]) == 0 >>> max_profit([1, 7, 5, 3, 6, 4]) == 6 pass","solution":"def max_profit(nums): Calculate the maximum profit from at most one transaction (buy one and sell one share of the stock) given the array of stock prices \`nums\`. Args: nums (List[int]): List of stock prices Returns: int: The maximum profit, or 0 if no profit can be made. if not nums or len(nums) < 2: return 0 min_price = nums[0] max_profit = 0 for price in nums[1:]: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def find_words(words: List[str]) -> List[str]: Given an array of strings \`words\`, find all the strings that can be typed using letters of alphabet on only one row of an American QWERTY keyboard. The rows of the keyboard are: 1. \\"QWERTYUIOP\\" 2. \\"ASDFGHJKL\\" 3. \\"ZXCVBNM\\" Note that the function should be case insensitive, and the output should be in the same order as the input. >>> find_words([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) == [\\"Alaska\\", \\"Dad\\"] >>> find_words([\\"Test\\", \\"Android\\"]) == [] >>> find_words([]) == []","solution":"def find_words(words): Returns a list of words that can be typed using letters of alphabet on only one row of an American QWERTY keyboard. row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") result = [] for word in words: lowercase_word = word.lower() if set(lowercase_word).issubset(row1) or set(lowercase_word).issubset(row2) or set(lowercase_word).issubset(row3): result.append(word) return result"},{"question":"def minDistance(word1: str, word2: str) -> int: Given two strings word1 and word2, returns the minimum number of operations (insert, delete, replace) required to convert word1 to word2, known as the Levenshtein distance. >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"\\", \\"\\") 0 >>> minDistance(\\"a\\", \\"\\") 1 >>> minDistance(\\"abc\\", \\"abc\\") 0 >>> minDistance(\\"abcdef\\", \\"azced\\") 3 >>> minDistance(\\"a\\", \\"ab\\") 1 >>> minDistance(\\"abc\\", \\"abcd\\") 1 >>> minDistance(\\"abcd\\", \\"abc\\") 1 >>> minDistance(\\"ab\\", \\"a\\") 1 >>> minDistance(\\"abc\\", \\"abd\\") 1 >>> minDistance(\\"kitten\\", \\"sitting\\") 3","solution":"def minDistance(word1, word2): Returns the minimum number of operations (insert, delete, replace) required to convert word1 to word2. m, n = len(word1), len(word2) # Create a DP table to store the number of operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0: # If word1 is empty, insert all characters of word2 dp[i][j] = j elif j == 0: # If word2 is empty, delete all characters of word1 dp[i][j] = i elif word1[i - 1] == word2[j - 1]: # If last characters are the same, ignore them dp[i][j] = dp[i - 1][j - 1] else: # If last characters are different, consider all three operations dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Delete dp[i - 1][j - 1] # Replace ) return dp[m][n]"},{"question":"def splitArray(arr, k): Given a list of unique integers \`arr\` and an integer \`k\`, return the number of ways to split the array into \`k\` non-empty contiguous subarrays such that the sum of the maximum element in each subarray is minimized. If it's not possible to split the array in such a way, return \`-1\`. >>> splitArray([7, 2, 5, 10, 8], 2) 18 >>> splitArray([7, 2, 5, 10, 8], 3) 14 >>> splitArray([7], 1) 7 >>> splitArray([7], 2) -1 >>> splitArray([5, 5, 5, 5, 5], 2) 15 >>> splitArray([5, 5, 5, 5, 5], 5) 5 >>> splitArray([1, 2, 3], 6) -1 >>> splitArray([1, 2, 3, 4, 5], 2) 9 >>> splitArray([1, 2, 3, 4, 5], 3) 6 >>> splitArray([1, 2, 3, 4, 5], 5) 5 >>> splitArray([10, 20, 30, 40, 50], 2) 90 >>> splitArray([10, 20, 30, 40, 50], 3) 60","solution":"def splitArray(arr, k): def canSplit(max_sum): current_sum = 0 subarrays = 1 for num in arr: if current_sum + num > max_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True if k > len(arr): return -1 left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"def has_three_indices_with_product(arr: List[int], target: int) -> bool: Determines if there are three distinct indices i, j, k in the array such that the product of the integers at these indices equals the target integer. :param arr: List of integers :param target: Target integer :return: True if such indices exist, otherwise False >>> has_three_indices_with_product([1, 2, 3, 4], 6) True >>> has_three_indices_with_product([1, 2, 3, 4], 100) False","solution":"def has_three_indices_with_product(arr, target): Determines if there are three distinct indices i, j, k in the array such that the product of the integers at these indices equals the target integer. :param arr: List of integers :param target: Target integer :return: True if such indices exist, otherwise False n = len(arr) if n < 3: return False for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if arr[i] * arr[j] * arr[k] == target: return True return False"},{"question":"def find_order(projects, dependencies): Determine the minimum total time required to complete all projects. If it is impossible to complete all projects due to cyclic dependencies, return -1. >>> find_order([3, 2, 5, 4], [[0, 1], [1, 2], [2, 3]]) 14 >>> find_order([3, 2, 5], [[0, 1], [1, 2], [2, 0]]) -1 >>> find_order([1, 2, 3, 4], []) 10 >>> find_order([1, 2, 5, 3, 4], [[1, 3], [2, 4]]) 15 >>> find_order([2, 3, 4], [[0, 1], [1, 2]]) 9 # Your code here","solution":"from collections import defaultdict, deque def find_order(projects, dependencies): Returns the minimum total time to complete all projects or -1 if cyclic dependencies exist. # Initialize graph and indegree graph = defaultdict(list) indegree = [0] * len(projects) # Build the graph for dep in dependencies: ai, bi = dep graph[ai].append(bi) indegree[bi] += 1 # Initialize the queue with projects having no prerequisites queue = deque([i for i in range(len(projects)) if indegree[i] == 0]) completed_projects = 0 total_time = 0 while queue: for _ in range(len(queue)): # Process all nodes at the current depth current = queue.popleft() total_time += projects[current] completed_projects += 1 for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all projects are completed, return the total time, otherwise return -1 return total_time if completed_projects == len(projects) else -1"},{"question":"def count_subsets(nums: List[int], target: int) -> int: Returns the number of subsets of nums that add up to the target. >>> count_subsets([2, 3, 5, 6, 8, 10], 10) 3 >>> count_subsets([], 0) 1 >>> count_subsets([1, 2, 3], 7) 0 >>> count_subsets([5], 5) 1 >>> count_subsets([1, 1, 1, 1], 2) 6","solution":"def count_subsets(nums, target): Returns the number of subsets of nums that add up to the target. # Initialize a list to store the number of subsets for each target from 0 to the given target dp = [0] * (target + 1) # There is always one subset (the empty subset) that sums up to 0 dp[0] = 1 # Iterate through each number in the array for num in nums: # Traverse the dp array from right to left to avoid using the same number more than once for t in range(target, num - 1, -1): dp[t] += dp[t - num] return dp[target]"},{"question":"def max_sum_subarray_k(nums: List[int], k: int) -> int: Find the sum of the subarray with length k that has the maximum sum. Parameters: nums (list): List of integers k (int): Length of subarray Returns: int: Maximum sum of subarray with length k >>> max_sum_subarray_k([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray_k([1, 2, 3, 4, 5], 1) 5 >>> max_sum_subarray_k([], 3) 0 >>> max_sum_subarray_k([1, 2], 3) 0 >>> max_sum_subarray_k([-1,[index]) pass from solution import max_sum_subarray_k def test_max_sum_subarray_k_regular_case(): assert max_sum_subarray_k([2, 1, 5, 1, 3, 2], 3) == 9 # Subarray [5, 1, 3] def test_max_sum_subarray_k_single_element_arrays(): assert max_sum_subarray_k([1, 2, 3, 4, 5], 1) == 5 # Subarray [5] def test_max_sum_subarray_k_empty_array(): assert max_sum_subarray_k([], 3) == 0 def test_max_sum_subarray_k_exceed_length(): assert max_sum_subarray_k([1, 2], 3) == 0 def test_max_sum_subarray_k_negative_numbers(): assert max_sum_subarray_k([-1, -2, -3, -4], 2) == -3 # Subarray [-1, -2] def test_max_sum_subarray_k_entire_array(): assert max_sum_subarray_k([1, 2, 3, 4], 4) == 10 # Subarray [1, 2, 3, 4]","solution":"def max_sum_subarray_k(nums, k): Find the sum of the subarray with length k that has the maximum sum. Parameters: nums (list): List of integers k (int): Length of subarray Returns: int: Maximum sum of subarray with length k if not nums or k <= 0 or k > len(nums): return 0 current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def lineup_army(arr: List[int]) -> List[int]: Arrange the army such that each soldier who is stronger than their next soldier in line is strictly greater in strength. >>> lineup_army([2, 4, 5, 1, 3]) == [5, 4, 3, 2, 1] >>> lineup_army([5, 4, 3, 2, 1]) == [5, 4, 3, 2, 1] >>> lineup_army([1]) == [1] >>> lineup_army([1, 2]) == [2, 1] >>> lineup_army([2, 1]) == [2, 1] >>> lineup_army([2, 2, 2, 2]) == [2, 2, 2, 2] >>> lineup_army([1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1]","solution":"def lineup_army(arr): Arrange the army such that each soldier who is stronger than their next soldier in line is strictly greater in strength. sorted_arr = sorted(arr, reverse=True) return sorted_arr"},{"question":"def max_distinct_elements(nums: List[int], k: int) -> int: Given an array of integers \`nums\` and an integer \`k\`, return the maximum number of distinct elements you can select from the array such that the sum of the selected elements is less than or equal to \`k\`. >>> max_distinct_elements([1, 2, 3, 4, 5], 10) 4 >>> max_distinct_elements([1, 2, 3, 3, 3, 4, 5], 10) 4 >>> max_distinct_elements([5, 6, 7, 8], 5) 1 >>> max_distinct_elements([1, 3, 5, 7, 9], 8) 2 >>> max_distinct_elements([1, 1, 1, 1], 2) 1 >>> max_distinct_elements([1, 2, 3, 4, 5], 100) 5 >>> max_distinct_elements([], 10) 0","solution":"def max_distinct_elements(nums, k): Returns the maximum number of distinct elements that can be selected from nums such that their sum is less than or equal to k. nums = list(set(nums)) # get unique elements nums.sort() # sort elements to pick the smallest ones first sum_of_selected = 0 selected_elements = [] for num in nums: if sum_of_selected + num <= k: sum_of_selected += num selected_elements.append(num) else: break return len(selected_elements)"},{"question":"def longest_odd_subarray(arr: list) -> int: Returns the length of the longest subarray containing only odd numbers. >>> longest_odd_subarray([2, 4, 6, 8]) 0 >>> longest_odd_subarray([1, 3, 5, 7]) 4 >>> longest_odd_subarray([1, 2, 3, 5, 2, 7, 9]) 2 >>> longest_odd_subarray([1, 2, 4, 6]) 1 >>> longest_odd_subarray([]) 0 >>> longest_odd_subarray([2, 1, 2, 3, 4, 5, 6]) 1 >>> longest_odd_subarray([2, 2, 3, 5, 7, 6, 8]) 3","solution":"def longest_odd_subarray(arr): Returns the length of the longest subarray containing only odd numbers. Parameters: arr (list): The input list of integers. Returns: int: The length of the longest subarray containing only odd numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 != 0: # Check if the number is odd current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root: TreeNode) -> TreeNode: Prunes the binary tree so that subtrees containing all zeros are removed. Args: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the pruned binary tree. >>> root = TreeNode(1, TreeNode(1), TreeNode(1)) >>> result = pruneTree(root) >>> result is not None and result.left is not None and result.right is not None True >>> root = TreeNode(0, TreeNode(0), TreeNode(0)) >>> pruneTree(root) is None True >>> root = TreeNode(1, TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(1)) >>> result = pruneTree(root) >>> result is not None and result.left is None and result.right is not None True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Prunes the binary tree so that subtrees containing all zeros are removed. Args: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the pruned binary tree. if not root: return None root.left = pruneTree(root.left) root.right = pruneTree(root.right) # If current node is a zero and has no child (left and right both are None) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"def minimizeMaxSum(arr: List[int], m: int) -> int: Divide the array into m non-empty continuous subarrays such that the maximum sum of any subarray is minimized. >>> minimizeMaxSum([7, 2, 5, 10, 8], 2) == 18 >>> minimizeMaxSum([1, 2, 3, 4, 5], 1) == 15 >>> minimizeMaxSum([1, 4, 4], 3) == 4 >>> minimizeMaxSum([7, 2, 5, 10, 8], 3) == 14 >>> minimizeMaxSum([1, 1, 1, 1, 1], 2) == 3","solution":"def minimizeMaxSum(arr, m): def valid(mid): current_sum = 0 count = 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if valid(mid): right = mid else: left = mid + 1 return left"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root, p, q): Finds the lowest common ancestor (LCA) of two nodes in a binary tree. :param root: TreeNode - The root of the binary tree. :param p: TreeNode - The first node. :param q: TreeNode - The second node. :return: TreeNode - The LCA of p and q. import pytest def test_example_tree(): root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.left = TreeNode(0) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) p = root.left # Node with value 5 q = root.right # Node with value 1 assert findLCA(root, p, q).val == 3 p = root.left # Node with value 5 q = root.left.right.right # Node with value 4 assert findLCA(root, p, q).val == 5 def test_lca_when_one_node_is_ancestor(): root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) p = root.left.right.left # Node with value 7 q = root.left.right.right # Node with value 4 assert findLCA(root, p, q).val == 2 def test_lca_with_root_as_ancestor(): root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.left = TreeNode(0) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) p = root.left.left # Node with value 6 q = root.right.right # Node with value 8 assert findLCA(root, p, q).val == 3 @pytest.mark.parametrize(\\"nodes,lca_value\\", [ ((5, 1), 3), ((5, 4), 5), ((6, 8), 3), ((7, 4), 2), ]) def test_lca_various_cases(nodes, lca_value): root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.right.left = TreeNode(0) root.right.right = TreeNode(8) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) p = find_node(root, nodes[0]) q = find_node(root, nodes[1]) assert findLCA(root, p, q).val == lca_value def find_node(root, value): if not root: return None if root.val == value: return root left_result = find_node(root.left, value) if left_result: return left_result return find_node(root.right, value)","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLCA(root, p, q): Finds the lowest common ancestor (LCA) of two nodes in a binary tree. :param root: TreeNode - The root of the binary tree. :param p: TreeNode - The first node. :param q: TreeNode - The second node. :return: TreeNode - The LCA of p and q. if not root or root == p or root == q: return root left = findLCA(root.left, p, q) right = findLCA(root.right, p, q) if left and right: return root return left if left else right"},{"question":"def fillLakes(grid: List[List[int]]) -> int: Fills all lakes in the given 2D grid with '1's, and returns the count of lakes filled. >>> grid = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [1, 1, 1, 1]] >>> fillLakes(grid) 1 >>> grid [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] >>> grid = [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] >>> fillLakes(grid) 0 >>> grid [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]] >>> grid = [[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]] >>> fillLakes(grid) 1 >>> grid [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]] >>> grid = [[1, 0, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [0, 1, 1, 1]] >>> fillLakes(grid) 0 >>> grid [[1, 0, 1, 1], [1, 0, 0, 1], [1, 1, 0, 1], [0, 1, 1, 1]] >>> grid = [[1, 1, 1, 1, 1, 1], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1]] >>> fillLakes(grid) 3 >>> grid [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]","solution":"def fillLakes(grid): Fills all lakes in the given 2D grid with '1's, and returns the count of lakes filled. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return grid[x][y] = -1 # Temporarily mark as visited dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) # Mark boundary-connected '0's so they're not considered lakes for i in range(m): if grid[i][0] == 0: dfs(i, 0) if grid[i][n-1] == 0: dfs(i, n-1) for j in range(n): if grid[0][j] == 0: dfs(0, j) if grid[m-1][j] == 0: dfs(m-1, j) # Now process actual lakes def fill(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return grid[x][y] = 1 fill(x+1, y) fill(x-1, y) fill(x, y+1) fill(x, y-1) lake_count = 0 for i in range(1, m-1): for j in range(1, n-1): if grid[i][j] == 0: fill(i, j) lake_count += 1 # Clean up visited marks (-1 to 0) for i in range(m): for j in range(n): if grid[i][j] == -1: grid[i][j] = 0 return lake_count"},{"question":"def longest_equal_freq_substring(s: str) -> int: Returns the length of the longest substring with 'a', 'b', and 'c' occurring with the same frequency. >>> longest_equal_freq_substring(\\"aabbcc\\") 6 >>> longest_equal_freq_substring(\\"abcabc\\") 6 >>> longest_equal_freq_substring(\\"aabbc\\") 0 >>> longest_equal_freq_substring(\\"aaabbbccc\\") 9 >>> longest_equal_freq_substring(\\"\\") 0 >>> longest_equal_freq_substring(\\"a\\") 0 >>> longest_equal_freq_substring(\\"abc\\") 3 >>> longest_equal_freq_substring(\\"abccba\\") 6 >>> longest_equal_freq_substring(\\"abababa\\") 0 pass","solution":"def longest_equal_freq_substring(s): Returns the length of the longest substring with 'a', 'b', and 'c' occurring with the same frequency. from collections import defaultdict n = len(s) max_len = 0 # Frequency maps freq_a = [0] * (n + 1) freq_b = [0] * (n + 1) freq_c = [0] * (n + 1) # Fill frequency maps for i in range(1, n + 1): freq_a[i] = freq_a[i - 1] + (1 if s[i - 1] == 'a' else 0) freq_b[i] = freq_b[i - 1] + (1 if s[i - 1] == 'b' else 0) freq_c[i] = freq_c[i - 1] + (1 if s[i - 1] == 'c' else 0) # Use a map to store frequency differences diff_map = defaultdict(lambda: defaultdict(int)) # Traverse the frequency maps to find the longest valid substring for i in range(n + 1): # Calculate differences d1 = freq_a[i] - freq_b[i] d2 = freq_b[i] - freq_c[i] if d1 == 0 and d2 == 0: max_len = max(max_len, i) elif d2 in diff_map and d1 in diff_map[d2]: max_len = max(max_len, i - diff_map[d2][d1]) else: diff_map[d2][d1] = i return max_len"},{"question":"def min_deletions_to_make_balanced(s: str) -> int: Determine the minimum number of characters that need to be removed to make the string balanced. A string is considered balanced if no two adjacent characters are the same. >>> min_deletions_to_make_balanced(\\"aaaa\\") == 3 >>> min_deletions_to_make_balanced(\\"ababab\\") == 0 >>> min_deletions_to_make_balanced(\\"a\\") == 0 >>> min_deletions_to_make_balanced(\\"aa\\") == 1 >>> min_deletions_to_make_balanced(\\"ab\\") == 0 >>> min_deletions_to_make_balanced(\\"aaabbcc\\") == 4 >>> min_deletions_to_make_balanced(\\"aabaa\\") == 2 >>> min_deletions_to_make_balanced(\\"abcdefgh\\") == 0","solution":"def min_deletions_to_make_balanced(s): Determine the minimum number of characters that need to be removed to make the string balanced. A string is considered balanced if no two adjacent characters are the same. Parameters: s (str): input string consisting of lowercase English letters Returns: int: minimum number of characters to remove deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions"},{"question":"def min_total_cost(s: str, cost: List[int], k: int) -> int: Returns the minimum total cost of the string after removing up to k characters. Parameters: s (str): The input string. cost (list): The list of costs associated with each character in the string. k (int): The maximum number of characters that can be removed. Returns: int: The minimum total cost after removing up to k characters. >>> min_total_cost(\\"abcde\\", [1, 2, 3, 4, 5], 2) 6 >>> min_total_cost(\\"aabbcc\\", [1, 2, 1, 2, 1, 2], 3) 3 >>> min_total_cost(\\"xyz\\", [4, 1, 2], 1) 3 >>> min_total_cost(\\"hello\\", [1, 2, 1, 2, 1], 0) 7 >>> min_total_cost(\\"test\\", [2, 2, 2, 2], 4) 0 >>> min_total_cost(\\"example\\", [3, 3, 3, 3, 3, 3, 3], 3) 12 pass","solution":"def min_total_cost(s, cost, k): Returns the minimum total cost of the string after removing up to k characters. Parameters: s (str): The input string. cost (list): The list of costs associated with each character in the string. k (int): The maximum number of characters that can be removed. Returns: int: The minimum total cost after removing up to k characters. # Pair each character with its cost cost_pairs = list(zip(s, cost)) # Sort cost pairs by their costs in descending order cost_pairs.sort(key=lambda x: x[1], reverse=True) # Remove the k highest cost characters for i in range(k): cost_pairs.pop(0) # Sum the remaining costs remaining_costs = [pair[1] for pair in cost_pairs] return sum(remaining_costs)"},{"question":"from typing import List def non_conflicting_tasks(intervals: List[List[int]]) -> int: Returns the maximum number of non-conflicting tasks that can be performed. Each task is represented by a start and end time. >>> non_conflicting_tasks([]) == 0 >>> non_conflicting_tasks([[1, 2]]) == 1 >>> non_conflicting_tasks([[1, 2], [3, 4], [0, 6], [5, 7], [8, 9], [5, 9]]) == 4 >>> non_conflicting_tasks([[1, 4], [2, 5], [3, 6]]) == 1 >>> non_conflicting_tasks([[1, 3], [2, 4], [3, 5], [7, 8]]) == 3","solution":"def non_conflicting_tasks(intervals): Returns the maximum number of non-conflicting tasks that can be performed. Each task is represented by a start and end time. if not intervals: return 0 # Sort intervals by end time intervals.sort(key=lambda x: x[1]) count = 1 # We can always take at least one task end_time = intervals[0][1] for i in range(1, len(intervals)): if intervals[i][0] >= end_time: count += 1 end_time = intervals[i][1] return count"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum path sum from top-left corner to bottom-right corner in a 2D grid. You can only move either down or right at any point in time. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([[5]]) 5 >>> min_path_sum([[1, 2, 3]]) 6","solution":"def min_path_sum(grid): Returns the minimum path sum from top-left corner to bottom-right corner in a 2D grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the grid's first row and first column paths for i in range(1, m): grid[i][0] += grid[i-1][0] for j in range(1, n): grid[0][j] += grid[0][j-1] # Populate the rest of the grid paths for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"def trap_rain_water(heights): Calculates the total units of rain water trapped between buildings represented by heights. :param heights: List of integers representing the heights of buildings. :return: Integer representing the total units of trapped rain water. pass # Test cases to validate the solution def test_trap_rain_water_empty(): assert trap_rain_water([]) == 0 def test_trap_rain_water_no_trap(): assert trap_rain_water([1, 1, 1, 1]) == 0 assert trap_rain_water([1, 2, 3, 4]) == 0 assert trap_rain_water([4, 3, 2, 1]) == 0 def test_trap_rain_water_simple_case(): assert trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_rain_water_complex_case(): assert trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 def test_trap_rain_water_single_building(): assert trap_rain_water([4]) == 0 def test_trap_rain_water_two_buildings(): assert trap_rain_water([4, 1]) == 0 def test_trap_rain_water_peaks_and_valleys(): assert trap_rain_water([1, 0, 2, 1, 0, 1, 3]) == 5","solution":"def trap_rain_water(heights): Calculates the total units of rain water trapped between buildings represented by heights. :param heights: List of integers representing the heights of buildings. :return: Integer representing the total units of trapped rain water. if not heights: return 0 left_max = [0] * len(heights) right_max = [0] * len(heights) # Initialize left_max array left_max[0] = heights[0] for i in range(1, len(heights)): left_max[i] = max(left_max[i-1], heights[i]) # Initialize right_max array right_max[-1] = heights[-1] for i in range(len(heights)-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate total trapped water total_water = 0 for i in range(len(heights)): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"from typing import List def count_distinct_elements_with_k_occurrences(arr: List[int], k: int) -> int: Returns the number of distinct elements in the array that appear exactly k times. :param arr: List[int], the input array of integers. :param k: int, the required number of occurrences. :return: int, count of distinct elements with exactly k occurrences. >>> count_distinct_elements_with_k_occurrences([1, 2, 2, 3, 3, 3], 1) == 1 >>> count_distinct_elements_with_k_occurrences([1, 1, 2, 2, 2, 3, 4, 4, 4, 4], 2) == 1 >>> count_distinct_elements_with_k_occurrences([1, 2, 3, 4, 5], 1) == 5 >>> count_distinct_elements_with_k_occurrences([1, 2, 2, 2, 3, 3], 3) == 1 >>> count_distinct_elements_with_k_occurrences([1, 1, 1, 2, 2, 3, 3, 3], 1) == 0 >>> count_distinct_elements_with_k_occurrences([], 1) == 0","solution":"from collections import Counter def count_distinct_elements_with_k_occurrences(arr, k): Returns the number of distinct elements in the array that appear exactly k times. :param arr: List[int], the input array of integers. :param k: int, the required number of occurrences. :return: int, count of distinct elements with exactly k occurrences. # Count the occurrences of each element in the array element_counts = Counter(arr) # Count how many elements appear exactly k times count = 0 for value in element_counts.values(): if value == k: count += 1 return count"},{"question":"def longest_increasing_subsequence_length(s: str) -> int: Finds the length of the longest increasing subsequence in a given string consisting of lowercase English letters. >>> longest_increasing_subsequence_length(\\"abc\\") 3 >>> longest_increasing_subsequence_length(\\"zxy\\") 2 >>> longest_increasing_subsequence_length(\\"aabbcc\\") 3 >>> longest_increasing_subsequence_length(\\"edcba\\") 1 >>> longest_increasing_subsequence_length(\\"\\") 0 >>> longest_increasing_subsequence_length(\\"abcdefg\\") 7 >>> longest_increasing_subsequence_length(\\"zyxwvuts\\") 1","solution":"def longest_increasing_subsequence_length(s): Finds the length of the longest increasing subsequence in a given string s. if not s: return 0 # Initialize an array to store the length of the longest increasing subsequence ending at each character dp = [1] * len(s) # Compute lengths of all increasing subsequences for i in range(1, len(s)): for j in range(i): if s[i] > s[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence is the maximum value in dp array return max(dp)"},{"question":"def min_adjacent_swaps_to_sort(nums: List[int]) -> int: Return the minimum number of adjacent swaps required to sort the list. >>> min_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_adjacent_swaps_to_sort([5, 4, 3, 2, 1]) 10 >>> min_adjacent_swaps_to_sort([3, 1, 2, 4, 5]) 2 >>> min_adjacent_swaps_to_sort([1]) 0 >>> min_adjacent_swaps_to_sort([2, 1]) 1 >>> min_adjacent_swaps_to_sort([2, 3, 1, 4, 6, 5]) 3","solution":"def count_inversions(nums): Helper function to count inversions using merge sort. def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if there are any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if there are any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*len(nums) return merge_sort_and_count(nums, temp_arr, 0, len(nums) - 1) def min_adjacent_swaps_to_sort(nums): Returns the minimum number of adjacent swaps required to sort the list. return count_inversions(nums)"},{"question":"from typing import List def maxSubArray(nums: List[int]) -> int: This function takes a list of integers and returns the maximum possible sum of a contiguous subarray. >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> maxSubArray([1, 2, 3, 4, 5]) 15 >>> maxSubArray([-1, -2, -3, -4, -5]) -1 >>> maxSubArray([10]) 10 >>> maxSubArray([-10]) -10 >>> maxSubArray([10, -5, 3, 4, -2, 7]) 17 >>> maxSubArray([]) 0 >>> maxSubArray([-1, -2, 5, 6, 7]) 18 >>> maxSubArray([5, 6, 7, -8, -9]) 18","solution":"def maxSubArray(nums): This function takes a list of integers and returns the maximum possible sum of a contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def kth_smallest_absolute_difference(nums: List[int], k: int) -> int: Return the k-th smallest absolute difference between any two distinct elements in the array. >>> kth_smallest_absolute_difference([1, 3, 1], 1) 0 >>> kth_smallest_absolute_difference([1, 3, 1], 2) 2 >>> kth_smallest_absolute_difference([1, 3, 1], 3) 2 >>> kth_smallest_absolute_difference([1, 6, 1], 1) 0 >>> kth_smallest_absolute_difference([1, 6, 1], 2) 5 >>> kth_smallest_absolute_difference([1, 6, 1], 3) 5 >>> kth_smallest_absolute_difference([1, 3, 4, 7], 4) 3 def test_kth_smallest_absolute_difference(): assert kth_smallest_absolute_difference([1, 3, 1], 1) == 0 assert kth_smallest_absolute_difference([1, 3, 1], 2) == 2 assert kth_smallest_absolute_difference([1, 3, 1], 3) == 2 assert kth_smallest_absolute_difference([1, 6, 1], 1) == 0 assert kth_smallest_absolute_difference([1, 6, 1], 2) == 5 assert kth_smallest_absolute_difference([1, 6, 1], 3) == 5 assert kth_smallest_absolute_difference([1, 3, 4, 7], 4) == 3 def test_edge_cases(): assert kth_smallest_absolute_difference([1, 2], 1) == 1 assert kth_smallest_absolute_difference([1], 1) == 0 assert kth_smallest_absolute_difference([10, 20, 30, 100], 2) == 10 assert kth_smallest_absolute_difference([5, 8, 12], 4) == 7 assert kth_smallest_absolute_difference([2, 9, 1, 3], 3) == 2","solution":"def kth_smallest_absolute_difference(nums, k): Returns the k-th smallest absolute difference between any two elements in nums. nums.sort() n = len(nums) def count_pairs(mid): count, j = 0, 1 for i in range(n): while j < n and nums[j] - nums[i] <= mid: j += 1 count += (j - i - 1) return count left, right = 0, nums[-1] - nums[0] while left < right: mid = (left + right) // 2 if count_pairs(mid) < k: left = mid + 1 else: right = mid return left"},{"question":"from typing import List, Tuple def closestPair(arr: List[int], target: int) -> Tuple[int, int]: Find a pair of integers from the array such that their sum is closest to target. Args: arr (List[int]): The list of distinct integers. target (int): The target sum. Returns: Tuple[int, int]: A tuple containing the pair of integers whose sum is closest to target. If the array has fewer than 2 elements, return an empty tuple. Examples: >>> closestPair([1, 3, 4, 7, 10], 8) (3, 4) or (1, 7) >>> closestPair([-10, -5, 5, 2], 3) (-5, 5) >>> closestPair([], 0) () def test_closestPair(): # Test case 1: Normal case arr = [1, 3, 4, 7, 10] target = 8 result = closestPair(arr, target) assert result == (3, 4) or result == (1, 7) # Test case 2: Multiple pairs with the same closest sum arr = [1, 2, 3, 4, 5] target = 6 result = closestPair(arr, target) assert result in [(1, 5), (2, 4)] # Test case 3: Negative numbers arr = [-10, -5, 5, 2] target = 3 result = closestPair(arr, target) assert result == (-5, 5) # Test case 4: Array has fewer than 2 elements arr = [5] target = 3 result = closestPair(arr, target) assert result == () # Test case 5: Empty array arr = [] target = 0 result = closestPair(arr, target) assert result == () # Test case 6: Closest pair equals target arr = [10, 22, 28, 29, 30, 40] target = 54 result = closestPair(arr, target) assert result in [(22, 30), (28, 29)] # Test case 7: Large range arr = [-1000, -999, 1, 1000, 2000] target = 0 result = closestPair(arr, target) assert result == (-1000, 1000) test_closestPair()","solution":"from typing import List, Tuple def closestPair(arr: List[int], target: int) -> Tuple[int, int]: # If array has fewer than 2 elements, return an empty tuple if len(arr) < 2: return () # Sort the array to use two-pointer technique arr.sort() # Initialize pointers and variables to track the closest sum left, right = 0, len(arr) - 1 closest_sum = float('inf') closest_pair = () # Two-pointer approach to find the closest pair while left < right: current_sum = arr[left] + arr[right] # Update closest pair and closest sum if current sum is closer to target if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum closest_pair = (arr[left], arr[right]) # Move pointers based on comparison of current sum and target if current_sum < target: left += 1 else: right -= 1 return closest_pair"},{"question":"def can_sum_subset(nums: List[int], target: int) -> bool: Determines if there is a non-empty subset of nums whose sum equals target. :param nums: List[int] - A list of distinct positive integers. :param target: int - The target sum we are trying to find. :return: bool - True if such a subset exists, otherwise False. >>> can_sum_subset([1, 2, 3, 4, 5], 9) True >>> can_sum_subset([1, 2, 3], 7) False >>> can_sum_subset([7], 7) True >>> can_sum_subset([1, 5], 6) True >>> can_sum_subset([8, 3, 2, 4], 1) False >>> can_sum_subset([2, 4, 8, 10], 14) True >>> can_sum_subset([2, 4, 6, 8], 20) True","solution":"def can_sum_subset(nums, target): Determines if there is a non-empty subset of nums whose sum equals target. :param nums: List[int] - A list of distinct positive integers. :param target: int - The target sum we are trying to find. :return: bool - True if such a subset exists, otherwise False. n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"from typing import List def next_permutation(nums: List[int]) -> List[int]: Modifies nums in place to the next lexicographical permutation. If the array is sorted in descending order, it changes it to the smallest permutation possible (ascending order). >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] pass","solution":"def next_permutation(nums): Modifies nums in place to the next lexicographical permutation. If the array is sorted in descending order, it changes it to the smallest permutation possible (ascending order). n = len(nums) # Find the rightmost element which is smaller than its next element. k = n - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k < 0: # The array is in descending order. Reverse to get smallest permutation. nums.reverse() return nums # Find the rightmost element which is greater than nums[k] l = n - 1 while nums[l] <= nums[k]: l -= 1 # Swap elements at k and l nums[k], nums[l] = nums[l], nums[k] # Reverse the elements from k+1 to the end of the array nums[k + 1:] = reversed(nums[k + 1:]) return nums"},{"question":"def count_sunny_buildings(heights: List[int]) -> int: Returns the count of buildings that can receive sunlight when the sun rises from the left. A building can receive sunlight if no building to its left has a greater height. >>> count_sunny_buildings([]) == 0 >>> count_sunny_buildings([5]) == 1 >>> count_sunny_buildings([3, 3, 3, 3, 3]) == 1 >>> count_sunny_buildings([1, 2, 3, 4, 5]) == 5 >>> count_sunny_buildings([5, 4, 3, 2, 1]) == 1 >>> count_sunny_buildings([1, 3, 2, 4, 2, 5]) == 4 >>> count_sunny_buildings([2, 1, 4, 3, 6, 5, 7]) == 4 >>> count_sunny_buildings([3, 1, 4, 2, 6, 1, 5, 1, 7, 1]) == 4","solution":"def count_sunny_buildings(heights): Returns the count of buildings that can receive sunlight. A building can receive sunlight if no building to its left has a greater height. if not heights: return 0 max_height = heights[0] count = 1 for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"def max_songs(durations: List[int], totalTime: int) -> int: Returns the maximum number of songs that can be included without exceeding totalTime. >>> max_songs([3, 5, 4, 11, 6], 17) == 3 >>> max_songs([2, 3, 5], 10) == 3 >>> max_songs([5, 8, 12], 4) == 0 >>> max_songs([5, 8, 4], 5) == 1 >>> max_songs([4, 6, 3, 7, 2], 10) == 3 >>> max_songs([5, 5, 5], 10) == 2 >>> max_songs([3, 3, 3, 3], 9) == 3 >>> max_songs([1, 2, 3], 0) == 0 >>> max_songs([], 10) == 0","solution":"def max_songs(durations, totalTime): Returns the maximum number of songs that can be included without exceeding totalTime. durations.sort() total_duration = 0 song_count = 0 for duration in durations: if total_duration + duration <= totalTime: total_duration += duration song_count += 1 else: break return song_count"},{"question":"def is_unique_characters_within_limit(s: str, queries: List[List[int]]) -> List[bool]: Given a string \`s\` and a list of queries, determines if the number of unique characters within the substring specified by each query is less than or equal to \`k\`. Parameters: s (str): The input string. queries (list): A list of queries where each query is represented as a list [l, r, k]. Returns: list: A list of boolean values where each value is \`True\` if the number of unique characters in the corresponding query's substring is less than or equal to \`k\`, otherwise \`False\`. # Your code here from solution import is_unique_characters_within_limit def test_single_query_all_unique(): s = \\"abcdef\\" queries = [[0, 5, 5]] assert is_unique_characters_within_limit(s, queries) == [False] def test_single_query_exactly_k_unique(): s = \\"abcabc\\" queries = [[0, 5, 3]] assert is_unique_characters_within_limit(s, queries) == [True] def test_single_query_less_than_k_unique(): s = \\"aaabbb\\" queries = [[0, 5, 3]] assert is_unique_characters_within_limit(s, queries) == [True] def test_multiple_queries(): s = \\"abcdef\\" queries = [[0, 2, 3], [0, 5, 4], [2, 5, 2]] expected = [True, False, False] assert is_unique_characters_within_limit(s, queries) == expected def test_query_entire_string(): s = \\"abcdefghi\\" queries = [[0, 8, 7]] assert is_unique_characters_within_limit(s, queries) == [False] def test_empty_string(): s = \\"\\" queries = [[0, 0, 0]] assert is_unique_characters_within_limit(s, queries) == [True]","solution":"def is_unique_characters_within_limit(s, queries): Given a string \`s\` and a list of queries, determines if the number of unique characters within the substring specified by each query is less than or equal to \`k\`. Parameters: s (str): The input string. queries (list): A list of queries where each query is represented as a list [l, r, k]. Returns: list: A list of boolean values where each value is \`True\` if the number of unique characters in the corresponding query's substring is less than or equal to \`k\`, otherwise \`False\`. results = [] for l, r, k in queries: substring = s[l:r+1] unique_chars = set(substring) if len(unique_chars) <= k: results.append(True) else: results.append(False) return results"},{"question":"def check_subarray_sum_exists(arr: List[int], k: int) -> bool: Checks if there exists a subarray whose elements sum up to exactly k. :param arr: List of integers (-1, 0, or 1) :param k: Target sum for the subarray :return: True if such a subarray exists, False otherwise >>> check_subarray_sum_exists([1, -1, 1, 0, 1], 1) True >>> check_subarray_sum_exists([0, 0, 0, 0], 1) False >>> check_subarray_sum_exists([], 0) False >>> check_subarray_sum_exists([1], 1) True >>> check_subarray_sum_exists([-1], -1) True >>> check_subarray_sum_exists([1, 0, -1], 2) False","solution":"def check_subarray_sum_exists(arr, k): Checks if there exists a subarray whose elements sum up to exactly k. :param arr: List of integers (-1, 0, or 1) :param k: Target sum for the subarray :return: True if such a subarray exists, False otherwise current_sum = 0 sum_indices = {0: -1} # Dictionary to store (sum, index) pairs for i, num in enumerate(arr): current_sum += num if (current_sum - k) in sum_indices: return True if current_sum not in sum_indices: sum_indices[current_sum] = i return False"},{"question":"def single_numbers(arr): Finds the two elements that appear only once in the array where each other element appears exactly twice. Parameters: arr (list of int): The input array of integers. Returns: tuple: A tuple containing the two unique elements. pass from solution import single_numbers def test_single_numbers_example_1(): assert set(single_numbers([1, 2, 1, 3, 2, 5])) == {3, 5} def test_single_numbers_example_2(): assert set(single_numbers([4, 1, 2, 1, 2, 3])) == {3, 4} def test_single_numbers_all_negative(): assert set(single_numbers([-1, -2, -1, -3, -2, -4])) == {-3, -4} def test_single_numbers_mixed_signs(): assert set(single_numbers([-1, 2, -1, 3, 2, -3])) == {3, -3} def test_single_numbers_large_numbers(): assert set(single_numbers([1000000, 999999, 1000000, 500, 999999, 4000000])) == {500, 4000000}","solution":"def single_numbers(arr): Finds the two elements that appear only once in the array where each other element appears exactly twice. Parameters: arr (list of int): The input array of integers. Returns: tuple: A tuple containing the two unique elements. # XOR all the elements in the array. The result will be the XOR of the two unique numbers. xor_result = 0 for num in arr: xor_result ^= num # Get the rightmost set bit in the xor_result rightmost_set_bit = xor_result & (-xor_result) num1, num2 = 0, 0 for num in arr: # Divide the numbers into two groups based on the rightmost set bit if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return num1, num2"},{"question":"from collections import defaultdict, deque def findTreeHeight(n, edges, root): Find the height of the tree when it is rooted at a specific node. :param n: Number of nodes in the tree. :param edges: List of [u, v] pairs indicating an edge between nodes u and v. :param root: The root node of the tree. :return: The height of the tree. # Implement your solution here def test_single_node_tree(): assert findTreeHeight(1, [], 1) == 0 def test_three_node_tree(): edges = [[1, 2], [1, 3]] assert findTreeHeight(3, edges, 1) == 1 assert findTreeHeight(3, edges, 2) == 2 assert findTreeHeight(3, edges, 3) == 2 def test_four_node_tree(): edges = [[1, 2], [1, 3], [3, 4]] assert findTreeHeight(4, edges, 1) == 2 assert findTreeHeight(4, edges, 2) == 3 assert findTreeHeight(4, edges, 3) == 2 assert findTreeHeight(4, edges, 4) == 3 def test_linear_tree(): edges = [[1, 2], [2, 3], [3, 4], [4, 5]] assert findTreeHeight(5, edges, 1) == 4 assert findTreeHeight(5, edges, 3) == 2 assert findTreeHeight(5, edges, 5) == 4","solution":"from collections import defaultdict, deque def findTreeHeight(n, edges, root): Find the height of the tree when it is rooted at a specific node. :param n: Number of nodes in the tree. :param edges: List of [u, v] pairs indicating an edge between nodes u and v. :param root: The root node of the tree. :return: The height of the tree. if n == 1: return 0 # Build the adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # BFS to find the height of the tree rooted at 'root' def bfs(node): visited = set() queue = deque([(node, 0)]) # (current_node, current_depth) max_depth = 0 while queue: current_node, current_depth = queue.popleft() visited.add(current_node) max_depth = max(max_depth, current_depth) for neighbor in tree[current_node]: if neighbor not in visited: queue.append((neighbor, current_depth + 1)) return max_depth return bfs(root)"},{"question":"from typing import List def unique_path_length(grid: List[List[str]], k: int) -> int: Finds the length of the longest path in the grid such that no cell character is repeated within any segment of the path and the path length is at least k. If no such path exists, return -1. >>> grid = [ ... ['a', 'b', 'c'], ... ['d', 'e', 'f'], ... ['g', 'h', 'i'] ... ] >>> unique_path_length(grid, 4) 9 >>> grid = [ ... ['a', 'b', 'a'], ... ['a', 'a', 'a'], ... ['a', 'a', 'a'] ... ] >>> unique_path_length(grid, 2) 2 >>> grid = [ ... ['a', 'b', 'c'], ... ['c', 'b', 'a'] ... ] >>> unique_path_length(grid, 5) -1 >>> grid = [['a']] >>> unique_path_length(grid, 1) 1 >>> unique_path_length([], 1) -1","solution":"def unique_path_length(grid, k): Finds the length of the longest path in the grid such that no cell character is repeated within any segment of the path and the path length is at least k. If no such path exists, return -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) longest_path = -1 def dfs(x, y, visited, path): nonlocal longest_path if (x, y) in visited: return if grid[x][y] in path: return path.add(grid[x][y]) visited.add((x, y)) # Current path length being checked current_length = len(path) if current_length >= k: longest_path = max(longest_path, current_length) # Explore neighbours for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: dfs(nx, ny, visited, path) # Backtrack path.remove(grid[x][y]) visited.remove((x, y)) for i in range(m): for j in range(n): dfs(i, j, set(), set()) return longest_path"},{"question":"def find_distance_to_ceo(employeeIDs, managers): Returns a dictionary where the keys are the employee IDs and the values are their respective distances to the CEO. >>> find_distance_to_ceo([1, 2, 3, 4], [-1, 1, 1, 2]) {1: 0, 2: 1, 3: 1, 4: 2} >>> find_distance_to_ceo([1, 2, 3, 4], [-1, 1, 1, 1]) {1: 0, 2: 1, 3: 1, 4: 1} >>> find_distance_to_ceo([1], [-1]) {1: 0} >>> find_distance_to_ceo([1, 2, 3, 4, 5, 6], [-1, 1, 2, 2, 3, 4]) {1: 0, 2: 1, 3: 2, 4: 2, 5: 3, 6: 3} >>> find_distance_to_ceo([1, 2, 3, 4, 5, 6, 7], [-1, 1, 1, 2, 2, 3, 4]) {1: 0, 2: 1, 3: 1, 4: 2, 5: 2, 6: 2, 7: 3}","solution":"def find_distance_to_ceo(employeeIDs, managers): Returns a dictionary where the keys are the employee IDs and the values are their respective distances to the CEO. distance_to_ceo = {} # Helper function to find the distance of a given employee to the CEO. def get_distance(employee): if employee not in distance_to_ceo: manager = managers[employeeIDs.index(employee)] if manager == -1: distance_to_ceo[employee] = 0 else: distance_to_ceo[employee] = 1 + get_distance(manager) return distance_to_ceo[employee] for emp in employeeIDs: get_distance(emp) return distance_to_ceo"},{"question":"def calculate_work_times(logs): Calculate the total time spent on each work identified by workId. Args: logs (list): List of log strings in the format \\"{workId}:startOrEnd:timestamp\\". Returns: dict: A dictionary with workId as keys and total time spent on that work in milliseconds as values. from solution import calculate_work_times def test_calculate_work_times_unique_ids(): logs = [ \\"1:start:10\\", \\"1:end:50\\", \\"2:start:20\\", \\"2:end:40\\", \\"3:start:30\\", \\"3:end:70\\" ] result = calculate_work_times(logs) expected = {\\"1\\": 40, \\"2\\": 20, \\"3\\": 40} assert result == expected def test_calculate_work_times_overlapping_start(): logs = [ \\"1:start:10\\", \\"1:start:20\\", # overlapping start, should be ignored \\"2:start:20\\", \\"2:end:40\\", \\"1:end:50\\" ] result = calculate_work_times(logs) expected = {\\"2\\": 20} assert result == expected def test_calculate_work_times_no_start(): logs = [ \\"1:end:50\\", # no start for workId 1 \\"2:start:20\\", \\"2:end:40\\" ] result = calculate_work_times(logs) expected = {\\"2\\": 20} assert result == expected def test_calculate_work_times_no_end(): logs = [ \\"1:start:10\\", \\"2:start:20\\" ] result = calculate_work_times(logs) expected = {} assert result == expected def test_calculate_work_times_multiple_entries(): logs = [ \\"1:start:10\\", \\"1:end:30\\", \\"1:start:40\\", \\"1:end:70\\", \\"2:start:20\\", \\"2:end:60\\" ] result = calculate_work_times(logs) expected = {\\"1\\": 50, \\"2\\": 40} assert result == expected","solution":"def calculate_work_times(logs): Calculate the total time spent on each work identified by workId. Args: logs (list): List of log strings in the format \\"{workId}:startOrEnd:timestamp\\". Returns: dict: A dictionary with workId as keys and total time spent on that work in milliseconds as values. work_times = {} active_work = {} for log in logs: workId, event, timestamp = log.split(':') timestamp = int(timestamp) if event == \\"start\\": if workId in active_work: # Overlapping start for this workId, ignore it del active_work[workId] else: active_work[workId] = timestamp elif event == \\"end\\": if workId in active_work: start_time = active_work[workId] elapsed_time = timestamp - start_time if workId in work_times: work_times[workId] += elapsed_time else: work_times[workId] = elapsed_time del active_work[workId] # If there are any active work that hasn't ended, they are ignored. return work_times"},{"question":"from typing import List def find_words(board: List[List[str]], words: List[str]) -> List[str]: Find all words from a given list that can be constructed from letters of sequentially adjacent cells in a 2D grid of characters. The cells are adjacent horizontally or vertically and cannot be reused. Args: board (List[List[str]]): 2D grid of characters. words (List[str]): List of words to search in the grid. Returns: List[str]: List of found words sorted lexicographically. Examples: >>> find_words([ ... [\\"o\\",\\"a\\",\\"a\\",\\"n\\"], ... [\\"e\\",\\"t\\",\\"a\\",\\"e\\"], ... [\\"i\\",\\"h\\",\\"k\\",\\"r\\"], ... [\\"i\\",\\"f\\",\\"l\\",\\"v\\"] ... ], [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"]) ['eat', 'oath'] >>> find_words([ ... [\\"a\\",\\"b\\"], ... [\\"c\\",\\"d\\"] ... ], [\\"efg\\", \\"hij\\"]) []","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.end_of_word def find_words(board, words): def dfs(board, node, word, x, y, found_words, visited): if node.end_of_word: found_words.add(word) node.end_of_word = False # Avoid duplicate entry if not (0 <= x < len(board)) or not (0 <= y < len(board[0])): return temp = board[x][y] if temp not in node.children or visited[x][y]: return visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy dfs(board, node.children[temp], word + temp, nx, ny, found_words, visited) visited[x][y] = False trie = Trie() for word in words: trie.insert(word) found_words = set() visited = [[False] * len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): dfs(board, trie.root, '', i, j, found_words, visited) return sorted(found_words)"},{"question":"from typing import List def maxSubarraySum(arr: List[int], k: int) -> int: Find the maximum possible sum of a subarray of length k. If k is greater than the length of the array, return -1. >>> maxSubarraySum([1, 2, 3, 4, 5], 2) == 9 >>> maxSubarraySum([1, -2, 3, -1, 2], 3) == 4 >>> maxSubarraySum([5, 4, 3, 2, 1], 5) == 15 >>> maxSubarraySum([5, 4, 3, 2, 1], 0) == -1 >>> maxSubarraySum([1, 2, 3], 4) == -1 >>> maxSubarraySum([1, 2, 3], 1) == 3 >>> maxSubarraySum([2, 3, 4], 3) == 9","solution":"from typing import List def maxSubarraySum(arr: List[int], k: int) -> int: Find the maximum sum of a subarray of length k. if k > len(arr) or k == 0: return -1 max_sum = -float('inf') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List def minTimeToCompleteTasks(time: List[int], workers: List[int]) -> int: Distribute tasks among the workers to minimize the total time to complete all tasks. >>> minTimeToCompleteTasks([10], [1, 2]) 10 >>> minTimeToCompleteTasks([1, 2, 3], [1, 2, 3]) 3 >>> minTimeToCompleteTasks([10, 10, 10], [1, 2, 3, 4]) 10 >>> minTimeToCompleteTasks([10, 20, 30, 40], [1, 2]) 50 >>> minTimeToCompleteTasks([], [1, 2, 3]) 0 >>> minTimeToCompleteTasks([1, 2, 3], []) 0","solution":"import heapq def minTimeToCompleteTasks(time, workers): if not time or not workers: return 0 n = len(time) m = len(workers) task_queue = [] for t in time: heapq.heappush(task_queue, -t) worker_queue = [0] * m while task_queue: longest_task = -heapq.heappop(task_queue) min_loaded_worker = heapq.heappop(worker_queue) min_loaded_worker += longest_task heapq.heappush(worker_queue, min_loaded_worker) return max(worker_queue)"},{"question":"def min_operations_to_substring(s: str, t: str) -> int: Given two strings \`s\` and \`t\`, find the minimum number of operations required to make \`t\` a substring of \`s\`, where the only allowed operation is to replace any character in \`t\` with any other character. Return the minimum number of operations needed. >>> min_operations_to_substring(\\"abcdef\\", \\"abf\\") 1 >>> min_operations_to_substring(\\"abcdef\\", \\"bdf\\") 2 >>> min_operations_to_substring(\\"abcdef\\", \\"abcdef\\") 0 >>> min_operations_to_substring(\\"abcd\\", \\"abcf\\") 1 >>> min_operations_to_substring(\\"abcd\\", \\"abcd\\") 0 >>> min_operations_to_substring(\\"a\\", \\"b\\") 1 >>> min_operations_to_substring(\\"a\\", \\"a\\") 0 >>> min_operations_to_substring(\\"abc\\", \\"xyz\\") 3 >>> min_operations_to_substring(\\"abcdexyz\\", \\"bcd\\") 0 >>> min_operations_to_substring(\\"abcdexyz\\", \\"cdx\\") 1 >>> min_operations_to_substring(\\"abxfab\\", \\"abf\\") 1 >>> min_operations_to_substring(\\"abxabf\\", \\"abf\\") 0","solution":"def min_operations_to_substring(s, t): Return the minimum number of operations needed to make t a substring of s. The only allowed operation is replacing a character in t with another character. len_s = len(s) len_t = len(t) min_operations = float('inf') for i in range(len_s - len_t + 1): current_operations = 0 for j in range(len_t): if s[i + j] != t[j]: current_operations += 1 min_operations = min(min_operations, current_operations) return min_operations"},{"question":"def transform(nums, threshold): Transforms the array such that each index i contains the sum of numbers from index 0 to i in the original array. Truncates the sum at any index to the threshold if it exceeds the threshold. :param nums: List[int] - array of integers :param threshold: int - threshold value :return: List[int] - transformed array >>> transform([1, 2, 3], 10) [1, 3, 6] >>> transform([2, 4, 6], 5) [2, 5, 5] >>> transform([1, 2, 3], 0) [0, 0, 0] >>> transform([2, 3, 5], 5) [2, 5, 5] >>> transform([1, 2, 3], 6) [1, 3, 6] >>> transform([10, 20, 30], 15) [10, 15, 15] >>> transform(list(range(1, 101)), 2500) [sum(range(1, i+1)) if sum(range(1, i+1))<=2500 else 2500 for i in range(1, 101)]","solution":"def transform(nums, threshold): Transforms the array such that each index i contains the sum of numbers from index 0 to i in the original array. Truncates the sum at any index to the threshold if it exceeds the threshold. :param nums: List[int] - array of integers :param threshold: int - threshold value :return: List[int] - transformed array result = [] current_sum = 0 truncated = False for num in nums: if not truncated: current_sum += num if current_sum > threshold: current_sum = threshold truncated = True result.append(current_sum) return result"},{"question":"from typing import List def find_elements(arr: List[int]) -> List[int]: Find all elements that appear more than ⌊n / 3⌋ times in the array. >>> find_elements([3, 2, 3]) [3] >>> find_elements([1,1,1,3,3,2,2,2]) [1, 2] >>> find_elements([1, 2, 3]) [] >>> find_elements([]) [] >>> find_elements([1, 2, 1, 2, 3, 3]) [] >>> find_elements([4,4,4,4]) [4] >>> find_elements([-1, -1, -1, 0, 0, 0, 1, 1]) [-1, 0]","solution":"from collections import Counter def find_elements(arr): Find all elements that appear more than ⌊n / 3⌋ times in the array. n = len(arr) if n == 0: return [] threshold = n // 3 counts = Counter(arr) result = [key for key, count in counts.items() if count > threshold] return result"},{"question":"def max_distance(cars: List[List[int]]) -> int: Returns the maximum distance that the car with the highest efficiency can travel without refueling. Parameters: cars (list): A list of lists, where each inner list contains two numbers, the fuel efficiency (in miles per gallon) and the current amount of fuel (in gallons) of a car. Returns: int: The maximum distance that the car with the highest efficiency can travel without refueling. >>> max_distance([[25, 10]]) == 250 >>> max_distance([[20, 5], [30, 5], [10, 10]]) == 150 >>> max_distance([[0, 10], [0, 5], [0, 1]]) == 0 >>> max_distance([[25, 0], [30, 0], [50, 0]]) == 0 >>> max_distance([[15, 3], [25, 4], [30, 2]]) == 100 >>> max_distance([]) == 0 >>> max_distance([[10, 10], [12, 8], [15, 7], [20, 5]]) == 105","solution":"def max_distance(cars): Returns the maximum distance that the car with the highest efficiency can travel without refueling. Parameters: cars (list): A list of lists, where each inner list contains two numbers, the fuel efficiency (in miles per gallon) and the current amount of fuel (in gallons) of a car. Returns: int: The maximum distance that the car with the highest efficiency can travel without refueling. max_dist = 0 for efficiency, fuel in cars: distance = efficiency * fuel if distance > max_dist: max_dist = distance return max_dist"},{"question":"def remove_duplicates_and_sort(head): Given an unsorted linked list \`head\`, remove all duplicates such that each element appears only once. Return the linked list sorted in non-decreasing order. >>> head = list_to_linkedlist([3, 1, 2, 1, 3]) >>> result = remove_duplicates_and_sort(head) >>> linkedlist_to_list(result) == [1, 2, 3] True >>> head = list_to_linkedlist([4, 2, 5, 1, 3]) >>> result = remove_duplicates_and_sort(head) >>> linkedlist_to_list(result) == [1, 2, 3, 4, 5] True >>> head = None >>> result = remove_duplicates_and_sort(head) >>> linkedlist_to_list(result) == [] True >>> head = list_to_linkedlist([1]) >>> result = remove_duplicates_and_sort(head) >>> linkedlist_to_list(result) == [1] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_and_sort(head): if not head: return None # Use a set to track seen values seen = set() current = head prev = None # Traverse the linked list and filter out duplicates while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next # Convert linked list to list to sort and then rebuild it as a linked list node_list = [] current = head while current: node_list.append(current.val) current = current.next node_list.sort() # Rebuild the sorted linked list dummy = ListNode(0) current = dummy for val in node_list: current.next = ListNode(val) current = current.next return dummy.next"},{"question":"def tic_tac_toe_winner(matrix: List[List[str]]) -> str: Determines the winner of a Tic-Tac-Toe game from a n x n board. >>> tic_tac_toe_winner([ ... ['X', 'X', 'X'], ... ['O', '-', 'O'], ... ['-', '-', '-']]) == 'X' >>> tic_tac_toe_winner([ ... ['O', 'X', 'X'], ... ['O', '-', 'X'], ... ['O', '-', '-']]) == 'O' >>> tic_tac_toe_winner([ ... ['X', 'O', '-'], ... ['O', 'X', 'O'], ... ['-', 'O', 'X']]) == 'X' >>> tic_tac_toe_winner([ ... ['O', 'O', 'X'], ... ['O', 'X', 'O'], ... ['X', '-', 'O']]) == 'X' >>> tic_tac_toe_winner([ ... ['O', 'X', 'O'], ... ['X', 'O', 'X'], ... ['X', 'O', 'X']]) == None","solution":"def tic_tac_toe_winner(matrix): Determines the winner of a Tic-Tac-Toe game from a n x n board. Returns 'X' if player X wins, 'O' if player O wins, and None if there is no winner. n = len(matrix) # Check rows for row in matrix: if row[0] != '-' and all(cell == row[0] for cell in row): return row[0] # Check columns for col in range(n): if matrix[0][col] != '-' and all(matrix[row][col] == matrix[0][col] for row in range(n)): return matrix[0][col] # Check main diagonal if matrix[0][0] != '-' and all(matrix[i][i] == matrix[0][0] for i in range(n)): return matrix[0][0] # Check secondary diagonal if matrix[0][n-1] != '-' and all(matrix[i][n-1-i] == matrix[0][n-1] for i in range(n)): return matrix[0][n-1] return None"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_until_negative(root): Returns the sum of values from the root to the level containing the first negative value, inclusive. If no negative value is encountered, it sums all the values in the tree. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> sum_until_negative(root) 6 >>> root = TreeNode(1, TreeNode(-2), TreeNode(3)) >>> sum_until_negative(root) 1 >>> root = TreeNode(-1, TreeNode(2), TreeNode(3)) >>> sum_until_negative(root) 0 >>> root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(-4), TreeNode(5))) >>> sum_until_negative(root) 6 >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, TreeNode(5), TreeNode(6))) >>> sum_until_negative(root) 21 >>> sum_until_negative(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_until_negative(root): Returns the sum of values from the root to the level containing the first negative value, inclusive. If no negative value is encountered, it sums all the values in the tree. if not root: return 0 from collections import deque queue = deque([root]) total_sum = 0 while queue: level_size = len(queue) for i in range(level_size): node = queue.popleft() if node.val < 0: return total_sum total_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return total_sum"},{"question":"def trapRainWater(heightMap: List[List[int]]) -> int: Calculate the maximum height of water that can be trapped within an elevation map. Parameters: heightMap (List[List[int]]): A 2D list representing the elevation map. Returns: int: Maximum height of the water body that can be formed. >>> trapRainWater([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) == 4 >>> trapRainWater([ ... [3, 3, 3, 3, 3], ... [3, 2, 2, 2, 3], ... [3, 2, 1, 2, 3], ... [3, 2, 2, 2, 3], ... [3, 3, 3, 3, 3] ... ]) == 10 >>> trapRainWater([ ... [0] ... ]) == 0 >>> trapRainWater([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 0 >>> trapRainWater([ ... [3, 3, 3, 3], ... [3, 1, 1, 3], ... [3, 1, 1, 3], ... [3, 3, 3, 3] ... ]) == 8","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] # Push all the border cells into the priority queue for i in range(m): for j in range(n): if i == 0 or i == m-1 or j == 0 or j == n-1: heapq.heappush(heap, (heightMap[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_trapped, min_boundary_height = 0, 0 while heap: height, x, y = heapq.heappop(heap) min_boundary_height = max(min_boundary_height, height) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True if heightMap[nx][ny] < min_boundary_height: max_trapped += min_boundary_height - heightMap[nx][ny] heapq.heappush(heap, (heightMap[nx][ny], nx, ny)) return max_trapped"},{"question":"def highest_peak(grid: List[List[int]]) -> int: Finds and returns the height of the highest peak in the given grid. A peak is defined as a cell that is taller than all of its adjacent cells (north, south, east, west). Returns the height of the highest peak or -1 if there are no valid peaks. >>> highest_peak([[1, 2], [3, 4]]) -1 >>> highest_peak([ ... [1, 1, 1], ... [1, 2, 1], ... [1, 1, 1] ... ]) 2 >>> highest_peak([ ... [1, 2, 1], ... [3, 4, 3], ... [1, 2, 1] ... ]) 4 >>> highest_peak([ ... [5, 5], ... [5, 5] ... ]) -1 >>> highest_peak([ ... [1, 3, 1, 4], ... [2, 10, 2, 6], ... [1, 4, 1, 5] ... ]) 10 >>> highest_peak([[10] * 100] * 100) -1","solution":"def highest_peak(grid): Finds and returns the height of the highest peak in the given grid. A peak is defined as a cell that is taller than all of its adjacent cells (north, south, east, west). if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) highest = -1 def is_peak(i, j): current = grid[i][j] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and current <= grid[ni][nj]: return False return True for i in range(1, m - 1): for j in range(1, n - 1): if is_peak(i, j): highest = max(highest, grid[i][j]) return highest"},{"question":"from typing import List from collections import Counter def min_steps_to_anagram(s: str, t: str) -> int: You are given two strings \`s\` and \`t\`. Write a function that returns the minimum number of steps required to make \`t\` an anagram of \`s\`. In one step, you can choose any character in \`t\` and replace it with another character. >>> min_steps_to_anagram(\\"anagram\\", \\"anagram\\") == 0 >>> min_steps_to_anagram(\\"anagram\\", \\"mangaar\\") == 0 >>> min_steps_to_anagram(\\"abc\\", \\"def\\") == 3 >>> min_steps_to_anagram(\\"aabbcc\\", \\"abcabc\\") == 0 >>> min_steps_to_anagram(\\"abcd\\", \\"abcdeeee\\") == 0 >>> min_steps_to_anagram(\\"anagram\\", \\"mangaa\\") == 1","solution":"from collections import Counter def min_steps_to_anagram(s, t): Returns the minimum number of steps required to make t an anagram of s. In one step, you can choose any character in t and replace it with another character. s_count = Counter(s) t_count = Counter(t) steps = 0 for char in s_count: if s_count[char] > t_count[char]: steps += s_count[char] - t_count[char] return steps"},{"question":"def maxDistToClosest(seats): Finds the maximum distance to the closest person in a row of seats. Args: seats : List[int] : A list of integers where 0 represents an empty seat and 1 represents an occupied seat. Returns: int : The maximum distance to the closest person. >>> maxDistToClosest([1, 0, 0, 0, 1, 0, 1]) == 2 >>> maxDistToClosest([1, 0, 0, 0]) == 3 >>> maxDistToClosest([0, 0, 0, 1]) == 3 >>> maxDistToClosest([1, 1, 1, 1, 1]) == 0 >>> maxDistToClosest([1, 0, 0, 0, 1]) == 2 >>> maxDistToClosest([1, 0, 1, 0, 1]) == 1 >>> maxDistToClosest([0, 0, 0, 0, 0]) == 5 # Implement the function to return the maximum distance to the closest person.","solution":"def maxDistToClosest(seats): Finds the maximum distance to the closest person in a row of seats. Args: seats : List[int] : A list of integers where 0 represents an empty seat and 1 represents an occupied seat. Returns: int : The maximum distance to the closest person. prev = -1 max_distance = 0 for i, seat in enumerate(seats): if seat == 1: if prev == -1: max_distance = i else: max_distance = max(max_distance, (i - prev) // 2) prev = i max_distance = max(max_distance, len(seats) - 1 - prev) return max_distance"},{"question":"def min_flips_to_alternate(s: str) -> int: Returns the minimum number of flip operations required to make the string \`s\` alternate between '0' and '1'. >>> min_flips_to_alternate(\\"010101\\") 0 >>> min_flips_to_alternate(\\"1111\\") 2 >>> min_flips_to_alternate(\\"0000\\") 2 >>> min_flips_to_alternate(\\"10101\\") 0 >>> min_flips_to_alternate(\\"001\\") 1 >>> min_flips_to_alternate(\\"10\\") 0 >>> min_flips_to_alternate(\\"0110\\") 2 >>> min_flips_to_alternate(\\"0\\") 0 >>> min_flips_to_alternate(\\"1\\") 0 >>> min_flips_to_alternate(\\"110\\") 1","solution":"def min_flips_to_alternate(s): Returns the minimum number of flip operations required to make the string \`s\` alternate between '0' and '1'. Args: s (str): A binary string. Returns: int: The minimum number of flip operations required. # Generate the two possible alternating patterns alternate_pattern_1 = ''.join('01'[i % 2] for i in range(len(s))) alternate_pattern_2 = ''.join('10'[i % 2] for i in range(len(s))) # Count the number of flips needed for both patterns flips_1 = sum(1 for a, b in zip(s, alternate_pattern_1) if a != b) flips_2 = sum(1 for a, b in zip(s, alternate_pattern_2) if a != b) # Return the minimum of the two return min(flips_1, flips_2)"},{"question":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy-sell transaction given the list of prices of a commodity on different days. :param prices: List of prices of the commodity on different days :return: Maximum profit that can be achieved, or 0 if no profit can be made pass from solution import max_profit def test_max_profit_no_prices(): assert max_profit([]) == 0 def test_max_profit_one_price(): assert max_profit([5]) == 0 def test_max_profit_increasing_prices(): assert max_profit([1, 2, 3, 4, 5]) == 4 def test_max_profit_decreasing_prices(): assert max_profit([5, 4, 3, 2, 1]) == 0 def test_max_profit_mixed_prices(): assert max_profit([7, 1, 5, 3, 6, 4]) == 5 def test_max_profit_no_profit(): assert max_profit([7, 6, 4, 3, 1]) == 0 def test_max_profit_same_prices(): assert max_profit([3, 3, 3, 3, 3]) == 0 def test_max_profit_fluctuating_prices(): assert max_profit([3, 2, 6, 1, 4, 8, 3]) == 7","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from a single buy-sell transaction given the list of prices of a commodity on different days. :param prices: List of prices of the commodity on different days :return: Maximum profit that can be achieved, or 0 if no profit can be made if not prices: return 0 # Initialize minimum price to a large value and max profit to 0 min_price = float('inf') max_profit = 0 for price in prices: # Update the minimum price so far if price < min_price: min_price = price # Calculate current profit current_profit = price - min_price # Update the maximum profit so far if current_profit > max_profit: max_profit = current_profit return max_profit"},{"question":"def max_connected_land_components(grid): Returns the maximum number of connected land components after shuffling the matrix. >>> max_connected_land_components([ [1, 0, 1], [0, 1, 0], [1, 0, 1] ]) == 1 >>> max_connected_land_components([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) == 0 >>> max_connected_land_components([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 1 >>> max_connected_land_components([ [0, 1, 0], [0, 0, 0], [0, 0, 0] ]) == 1 >>> max_connected_land_components([ [1, 0, 1], [0, 0, 0], [1, 0, 1] ]) == 1","solution":"def max_connected_land_components(grid): Returns the maximum number of connected land components after shuffling the matrix. m, n = len(grid), len(grid[0]) land_cells = sum(cell for row in grid for cell in row) def dfs(x, y, visited): stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and (nx * n + ny) < land_cells: visited[nx][ny] = True stack.append((nx, ny)) visited = [[False] * n for _ in range(m)] components = 0 for i in range(m): for j in range(n): if not visited[i][j] and (i * n + j) < land_cells: visited[i][j] = True dfs(i, j, visited) components += 1 return components"},{"question":"from typing import Dict def parse_chemical_formula(formula: str) -> Dict[str, int]: Parses the chemical formula and returns a dictionary with atom counts. Parameters: formula (str): The chemical formula as a string containing only uppercase English letters and numbers. Returns: Dict[str, int]: A dictionary with atom types as keys and their counts as values. Examples: >>> parse_chemical_formula(\\"H2O\\") {'H': 2, 'O': 1} >>> parse_chemical_formula(\\"CO2\\") {'C': 1, 'O': 2} >>> parse_chemical_formula(\\"HO\\") {'H': 1, 'O': 1} >>> parse_chemical_formula(\\"C6H12O6\\") {'C': 6, 'H': 12, 'O': 6} >>> parse_chemical_formula(\\"CH4\\") {'C': 1, 'H': 4} >>> parse_chemical_formula(\\"NaCl\\") {'Na': 1, 'Cl': 1}","solution":"import re from collections import defaultdict def parse_chemical_formula(formula): Parses the chemical formula and returns a dictionary with atom counts. pattern = re.compile(r'([A-Z][a-z]*)(d*)') element_counts = defaultdict(int) for element, count in pattern.findall(formula): count = int(count) if count else 1 element_counts[element] += count return dict(element_counts)"},{"question":"def maximum_product(nums: List[int]) -> int: Return the maximum product of exactly three integers from the list nums. If there are fewer than three integers, return 0. >>> maximum_product([1, 2]) == 0 >>> maximum_product([0, 0, 0]) == 0 >>> maximum_product([1, 2, 3, 4]) == 24 >>> maximum_product([-10, -10, 1, 3, 2]) == 300 >>> maximum_product([-1, -2, -3, 4]) == 24 >>> maximum_product([-1, 0, 3, 100, -70, -50]) == 350000 pass","solution":"def maximum_product(nums): Return the maximum product of exactly three integers from the list nums. If there are fewer than three integers, return 0. if len(nums) < 3: return 0 nums.sort() # Case 1: Product of the three largest elements max1 = nums[-1] * nums[-2] * nums[-3] # Case 2: Product of the two smallest elements (due to possible high negatives) and the largest element max2 = nums[0] * nums[1] * nums[-1] return max(max1, max2)"},{"question":"def max_water_trapped(heights): Calculates the maximum amount of water that can be trapped between the columns after raining. Args: heights (list of int): 0-indexed integer array representing the heights of columns. Returns: int: Maximum amount of water that can be trapped. from solution import max_water_trapped def test_max_water_trapped(): assert max_water_trapped([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 assert max_water_trapped([1, 1]) == 1 assert max_water_trapped([4,3,2,1,4]) == 16 assert max_water_trapped([1,2,1]) == 2 assert max_water_trapped([3,3,3,3,3,3,3]) == 18 def test_empty_list(): assert max_water_trapped([]) == 0 def test_single_element(): assert max_water_trapped([1]) == 0 def test_all_equal_elements(): assert max_water_trapped([2, 2, 2, 2]) == 6 def test_increasing_order(): assert max_water_trapped([1, 2, 3, 4, 5]) == 6 def test_decreasing_order(): assert max_water_trapped([5, 4, 3, 2, 1]) == 6","solution":"def max_water_trapped(heights): Calculates the maximum amount of water that can be trapped between the columns after raining. Args: heights (list of int): 0-indexed integer array representing the heights of columns. Returns: int: Maximum amount of water that can be trapped. # Initialize variables max_water = 0 left, right = 0, len(heights) - 1 # Use two pointers approach to find the maximum water trapped while left < right: # Calculate the water trapped between the two columns width = right - left height = min(heights[left], heights[right]) max_water = max(max_water, width * height) # Move the pointer pointing to the shorter column if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"from typing import List def countSubarrays(nums: List[int], k: int) -> int: Find the number of continuous subarrays whose sum equals to k. >>> countSubarrays([1, 1, 1], 2) 2 >>> countSubarrays([1, 2, 3], 3) 2 >>> countSubarrays([3], 3) 1 >>> countSubarrays([0, 0, 0, 0], 0) 10 >>> countSubarrays([1, 2, 3], 7) 0 >>> countSubarrays([1, -1, 1, -1, 1], 0) 6 >>> countSubarrays([1000, 1000, -1000, 1000], 2000) 2","solution":"from typing import List def countSubarrays(nums: List[int], k: int) -> int: count = 0 current_sum = 0 sum_count_dict = {0: 1} for num in nums: current_sum += num if (current_sum - k) in sum_count_dict: count += sum_count_dict[current_sum - k] if current_sum in sum_count_dict: sum_count_dict[current_sum] += 1 else: sum_count_dict[current_sum] = 1 return count"},{"question":"def min_abs_sum(arr1: List[int], arr2: List[int]) -> int: Find the minimum sum of absolute differences between each pair of corresponding elements in the two arrays after reordering the elements in \`arr1\`. >>> min_abs_sum([1, 3, 2], [4, 5, 6]) 7 >>> min_abs_sum([1, 2, 3], [1, 2, 3]) 0 >>> min_abs_sum([3, 2, 1], [1, 2, 3]) 0 >>> min_abs_sum([-1, -3, -2], [4, -5, 6]) 16 >>> min_abs_sum([1000000, 1000000, 1000000], [2000000, 2000000, 2000000]) 3000000","solution":"def min_abs_sum(arr1, arr2): # Sorting arr1 and arr2 arr1.sort() arr2.sort() # Calculating the minimum sum of absolute differences min_sum = sum(abs(a - b) for a, b in zip(arr1, arr2)) return min_sum"},{"question":"def searchMatrix(matrix: List[List[int]], target: int) -> bool: Searches for a target in a given sorted matrix. Args: matrix (List[List[int]]): 2D list of integers where each row and column is sorted. target (int): The target integer to search for in the matrix. Returns: bool: True if the target is found, False otherwise. Examples: >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> searchMatrix(matrix, 5) True >>> searchMatrix(matrix, 20) False","solution":"def searchMatrix(matrix, target): Searches for a target in a given sorted matrix. Args: matrix (List[List[int]]): 2D list of integers where each row and column is sorted. target (int): The target integer to search for in the matrix. Returns: bool: True if the target is found, False otherwise. if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findInorderPredecessor(root, p): Finds the in-order predecessor of the given node p in the BST. Args: root (TreeNode): The root of the BST. p (TreeNode): The node for which we need to find the in-order predecessor. Returns: TreeNode: The in-order predecessor of the given node p, or None if no predecessor exists.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def findInorderPredecessor(root, p): Finds the in-order predecessor of the given node p in the BST. Args: root (TreeNode): The root of the BST. p (TreeNode): The node for which we need to find the in-order predecessor. Returns: TreeNode: The in-order predecessor of the given node p, or None if no predecessor exists. if not root or not p: return None predecessor = None current = root while current: if p.val <= current.val: current = current.left else: predecessor = current current = current.right return predecessor"},{"question":"def minEditDistance(s1: str, s2: str) -> int: Returns the minimum number of operations required to convert s1 into s2. An operation is defined as inserting, deleting, or replacing a single character. >>> minEditDistance(\\"intention\\", \\"execution\\") 5 >>> minEditDistance(\\"kitten\\", \\"sitting\\") 3","solution":"def minEditDistance(s1, s2): Returns the minimum number of operations required to convert s1 into s2. An operation is defined as inserting, deleting, or replacing a single character. m = len(s1) n = len(s2) # Create a DP table to store minimum edit distance dp = [[0 for x in range(n + 1)] for x in range(m + 1)] # Fill dp[][] in bottom-up manner for i in range(m + 1): for j in range(n + 1): if i == 0: # If first string is empty, insert all characters of second string dp[i][j] = j elif j == 0: # If second string is empty, remove all characters of first string dp[i][j] = i elif s1[i-1] == s2[j-1]: # If last characters are the same, ignore last char and recur for remaining strings dp[i][j] = dp[i-1][j-1] else: # Consider all three operations and take minimum dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def min_deletions_to_make_balanced(s: str) -> int: Returns the minimum number of deletions required to make the string balanced. A string is balanced if it does not contain any substrings \\"aa\\", \\"bb\\" or \\"cc\\". >>> min_deletions_to_make_balanced(\\"abc\\") == 0 >>> min_deletions_to_make_balanced(\\"a\\") == 0 >>> min_deletions_to_make_balanced(\\"acbacb\\") == 0 >>> min_deletions_to_make_balanced(\\"aa\\") == 1 >>> min_deletions_to_make_balanced(\\"aab\\") == 1 >>> min_deletions_to_make_balanced(\\"bbcc\\") == 2 >>> min_deletions_to_make_balanced(\\"bbaaacc\\") == 3 >>> min_deletions_to_make_balanced(\\"aabbcc\\") == 3 >>> min_deletions_to_make_balanced(\\"ababcc\\") == 1 >>> min_deletions_to_make_balanced(\\"aabbac\\") == 2 >>> min_deletions_to_make_balanced(\\"abcabcabc\\") == 0 >>> min_deletions_to_make_balanced(\\"ababababc\\") == 0 >>> min_deletions_to_make_balanced(\\"abcabcabca\\") == 0","solution":"def min_deletions_to_make_balanced(s): Returns the minimum number of deletions required to make the string balanced. A string is balanced if it does not contain any substrings \\"aa\\", \\"bb\\" or \\"cc\\". deletions = 0 i = 1 while i < len(s): if s[i] == s[i - 1]: # Found a consecutive pair \\"aa\\", \\"bb\\" or \\"cc\\" deletions += 1 i += 1 i += 1 return deletions"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the values of tree nodes in a specific zigzag level order traversal. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> zigzagLevelOrder(root) [1, 3, 2] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [1, 3, 2, 4, 5, 6, 7] >>> zigzagLevelOrder(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.left.right.right = TreeNode(4) >>> zigzagLevelOrder(root) [1, 2, 3, 4] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> zigzagLevelOrder(root) [1, 2, 3, 4] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> zigzagLevelOrder(root) [1, 2, 3, 4]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root): Returns the values of tree nodes in a specific zigzag level order traversal. if not root: return [] result = [] queue = deque([root]) level = 0 while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if level % 2 != 0: current_level.reverse() result.extend(current_level) level += 1 return result"},{"question":"def remove_covered_intervals(intervals: List[List[int]]) -> int: Returns the number of intervals that are not covered by any other interval in the list. >>> remove_covered_intervals([[1, 2], [3, 4], [5, 6]]) == 3 >>> remove_covered_intervals([[1, 4], [2, 3], [3, 4]]) == 1 >>> remove_covered_intervals([[1, 10], [2, 9], [3, 8]]) == 1 >>> remove_covered_intervals([]) == 0 >>> remove_covered_intervals([[1, 4], [2, 4], [3, 4], [1, 3]]) == 1 >>> remove_covered_intervals([[1, 4], [3, 6], [2, 8]]) == 2","solution":"def remove_covered_intervals(intervals): Returns the number of intervals that are not covered by any other interval. # Sort intervals by start time, and then by end time decreasing intervals.sort(key=lambda x: (x[0], -x[1])) count = 0 end_max = 0 for start, end in intervals: if end > end_max: count += 1 end_max = end return count"},{"question":"def trap(height: List[int]) -> int: Calculate the amount of water that can be trapped after raining. Given a list of non-negative integers representing the height of columns, this function returns the total amount of rainwater that can be trapped after raining. Parameters: - height (list of int): A list representing the height of columns. Returns: - int: The total amount of water trapped. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([]) 0 >>> trap([1, 1, 1, 1, 1]) 0 >>> trap([0, 1, 0]) 0 >>> trap([2, 1, 2]) 1","solution":"def trap(height): Calculate the amount of water that can be trapped after raining. Parameters: - height (list of int): A list representing the height of columns. Returns: - int: The total amount of water trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def min_swaps_to_pseudo_palindrome(s: str) -> int: Determine the minimum number of adjacent swaps required to transform \`s\` into a pseudo-palindrome. If it is impossible to transform \`s\` into a pseudo-palindrome, return \`-1\`. >>> min_swaps_to_pseudo_palindrome(\\"mamad\\") == 3 >>> min_swaps_to_pseudo_palindrome(\\"aabb\\") == 2 >>> min_swaps_to_pseudo_palindrome(\\"abbaa\\") == 1 >>> min_swaps_to_pseudo_palindrome(\\"racecar\\") == 0 >>> min_swaps_to_pseudo_palindrome(\\"aabc\\") == -1 >>> min_swaps_to_pseudo_palindrome(\\"abc\\") == -1 >>> min_swaps_to_pseudo_palindrome(\\"a\\") == 0 >>> min_swaps_to_pseudo_palindrome(\\"aa\\") == 0 >>> min_swaps_to_pseudo_palindrome(\\"\\") == 0","solution":"def min_swaps_to_pseudo_palindrome(s): def can_form_pseudo_palindrome(s): from collections import Counter counter = Counter(s) odd_count = sum(1 for count in counter.values() if count % 2 != 0) # A palindrome can have at most one character of odd frequency return odd_count <= 1 # Check if it's possible to form a pseudo-palindrome if not can_form_pseudo_palindrome(s): return -1 n = len(s) s = list(s) swaps = 0 # Using two pointers technique l, r = 0, n - 1 while l < r: if s[l] == s[r]: l += 1 r -= 1 continue # Move \`r\` left to find a matching pair for s[l] k = r while k > l and s[k] != s[l]: k -= 1 if k == l: # If no matching character found then it is the middle one s[l], s[l + 1] = s[l + 1], s[l] swaps += 1 else: # Move the match s[k] to the position of s[r] while k < r: s[k], s[k + 1] = s[k + 1], s[k] k += 1 swaps += 1 l += 1 r -= 1 return swaps"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generate an n x n matrix in spiral order. >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]]","solution":"def generate_spiral_matrix(n): Generate an n x n spiral matrix. Args: n (int): The size of the matrix. Returns: List[List[int]]: A 2D list representing the spiral matrix. matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n - 1, 0, n - 1 while left <= right and top <= bottom: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def can_form_with_one_additional_char(s: str, t: str) -> bool: Determine if \`t\` can be obtained by rearranging the characters of \`s\` and inserting exactly one additional character. >>> can_form_with_one_additional_char(\\"abc\\", \\"dabc\\") == True >>> can_form_with_one_additional_char(\\"abc\\", \\"abcf\\") == True >>> can_form_with_one_additional_char(\\"abc\\", \\"abdc\\") == True >>> can_form_with_one_additional_char(\\"abc\\", \\"abc\\") == False >>> can_form_with_one_additional_char(\\"abc\\", \\"abcde\\") == False >>> can_form_with_one_additional_char(\\"abc\\", \\"cabd\\") == True >>> can_form_with_one_additional_char(\\"abc\\", \\"abcdef\\") == False >>> can_form_with_one_additional_char(\\"aaaa\\", \\"aaaaa\\") == True >>> can_form_with_one_additional_char(\\"aabb\\", \\"aabbb\\") == True","solution":"def can_form_with_one_additional_char(s, t): from collections import Counter count_s = Counter(s) count_t = Counter(t) # If length difference is not 1, immediately return false if len(t) - len(s) != 1: return False # The difference between the two counts should be exactly one character diff_count = sum((count_t[char] - count_s[char] for char in count_t)) return diff_count == 1"},{"question":"def walls_and_gates(rooms): Fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it remains filled with inf. >>> grid = [ >>> [2147483647, -1, 0, 2147483647], >>> [2147483647, 2147483647, 2147483647, -1], >>> [2147483647, -1, 2147483647, -1], >>> [0, -1, 2147483647, 2147483647], >>> ] >>> expected = [ >>> [3, -1, 0, 1], >>> [2, 2, 1, -1], >>> [1, -1, 2, -1], >>> [0, -1, 3, 4] >>> ] >>> walls_and_gates(grid) >>> assert grid == expected pass from solution import walls_and_gates def test_walls_and_gates_with_standard_grid(): grid = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647], ] expected = [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] walls_and_gates(grid) assert grid == expected def test_walls_and_gates_with_no_rooms(): grid = [] expected = [] walls_and_gates(grid) assert grid == expected def test_walls_and_gates_with_all_walls(): grid = [ [-1, -1], [-1, -1] ] expected = [ [-1, -1], [-1, -1] ] walls_and_gates(grid) assert grid == expected def test_walls_and_gates_with_all_infinite(): grid = [ [2147483647, 2147483647], [2147483647, 2147483647] ] expected = [ [2147483647, 2147483647], [2147483647, 2147483647] ] walls_and_gates(grid) assert grid == expected def test_walls_and_gates_with_one_gate(): grid = [ [0, 2147483647], [2147483647, 2147483647] ] expected = [ [0, 1], [1, 2] ] walls_and_gates(grid) assert grid == expected def test_walls_and_gates_with_small_grid(): grid = [ [2147483647, 0] ] expected = [ [1, 0] ] walls_and_gates(grid) assert grid == expected","solution":"from collections import deque def walls_and_gates(rooms): Fills each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it remains filled with inf. if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) queue = deque() # Initialize the queue with all the gates' positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from the gates while queue: x, y = queue.popleft() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and rooms[new_x][new_y] == 2147483647: rooms[new_x][new_y] = rooms[x][y] + 1 queue.append((new_x, new_y))"},{"question":"def can_partition(nums): Determines whether it is possible to partition the array nums into two subsets such that the sum of the elements in both subsets is equal. If possible, returns the two subsets. Otherwise, returns an empty list. >>> can_partition([1, 5, 11, 5]) != [] >>> can_partition([1, 2, 3, 5]) == [] >>> can_partition([1]) == [] >>> can_partition([10, 10]) != [] >>> can_partition([1, 9]) == [] >>> can_partition([1, 1, 1, 1, 1, 1, 1, 1]) != []","solution":"def can_partition(nums): Determines whether it is possible to partition the array nums into two subsets such that the sum of the elements in both subsets is equal. If possible, returns the two subsets. Otherwise, returns an empty list. total_sum = sum(nums) # If total sum is odd, it cannot be partitioned into two equal subsets if total_sum % 2 != 0: return [] subset_sum = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be formed from the array elements dp = [False] * (subset_sum + 1) dp[0] = True for num in nums: for i in range(subset_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] if not dp[subset_sum]: return [] # Find the sets subset1, subset2 = [], [] curr_sum = subset_sum for i in range(n - 1, -1, -1): if curr_sum >= nums[i] and dp[curr_sum - nums[i]]: subset1.append(nums[i]) curr_sum -= nums[i] else: subset2.append(nums[i]) return [subset1, subset2]"},{"question":"def next_palindrome(num: str) -> str: Given a non-negative integer \`num\` represented as a string, return the smallest palindrome number that is greater than \`num\`, also represented as a string. A palindrome number reads the same backward as forward. The solution should not convert the input number to an integer or use any built-in library for handling large integers. If the given \`num\` is already a palindrome, find the next largest palindrome. >>> next_palindrome(\\"123\\") == \\"131\\" >>> next_palindrome(\\"1\\") == \\"2\\" >>> next_palindrome(\\"9\\") == \\"11\\" >>> next_palindrome(\\"999\\") == \\"1001\\" >>> next_palindrome(\\"888\\") == \\"898\\" >>> next_palindrome(\\"12\\") == \\"22\\" >>> next_palindrome(\\"12345\\") == \\"12421\\" >>> next_palindrome(\\"12321\\") == \\"12421\\" >>> next_palindrome(\\"123456789\\") == \\"123464321\\" >>> next_palindrome(\\"111\\") == \\"121\\" >>> next_palindrome(\\"2222\\") == \\"2332\\" >>> next_palindrome(\\"9999\\") == \\"10001\\"","solution":"def next_palindrome(num: str) -> str: length = len(num) if all(x == '9' for x in num): return '1' + '0' * (length - 1) + '1' def is_palindrome(s): return s == s[::-1] num_list = list(num) half_len = (length + 1) // 2 first_half = num[:half_len] palindrome_candidate = first_half + first_half[:length//2][::-1] if palindrome_candidate > num: return palindrome_candidate first_half_incremented = str(int(first_half) + 1) next_palindrome_candidate = first_half_incremented + first_half_incremented[:length//2][::-1] return next_palindrome_candidate"},{"question":"def min_shelves(weights: List[int], maxWeight: int) -> int: Calculate the minimum number of shelves required to place all parcels such that no shelf exceeds the maxWeight. >>> min_shelves([1, 2, 3], 10) == 1 >>> min_shelves([5, 5, 5], 5) == 3 >>> min_shelves([6, 7, 8, 3], 10) == 4 >>> min_shelves([5, 5, 5], 10) == 2 >>> min_shelves([4, 8, 2, 6], 10) == 3 >>> min_shelves([1, 8, 3, 5, 2, 4], 10) == 3 >>> min_shelves([10, 10, 10], 10) == 3 pass","solution":"def min_shelves(weights, maxWeight): Calculate the minimum number of shelves required to place all parcels such that no shelf exceeds the maxWeight. :param weights: List[int], weights of parcels. :param maxWeight: int, the maximum weight each shelf can hold. :return: int, the minimum number of shelves required. # Initialize variables num_shelves = 0 current_shelf_weight = 0 for weight in weights: # Check if adding this weight exceeds the maxWeight of the current shelf if current_shelf_weight + weight <= maxWeight: current_shelf_weight += weight else: # Use a new shelf num_shelves += 1 current_shelf_weight = weight # Account for the last shelf in use if current_shelf_weight > 0: num_shelves += 1 return num_shelves"},{"question":"def can_rearrange_with_k_distinct(s: str, k: int) -> bool: Determines if the string 's' can be rearranged such that it contains at most 'k' distinct characters. >>> can_rearrange_with_k_distinct(\\"aaabb\\", 2) True >>> can_rearrange_with_k_distinct(\\"aabb\\", 2) True >>> can_rearrange_with_k_distinct(\\"aabbc\\", 2) False","solution":"def can_rearrange_with_k_distinct(s, k): Determines if the string 's' can be rearranged such that it contains at most 'k' distinct characters. # Use a set to find the number of distinct characters in the string 's' distinct_chars = set(s) # Check if the number of distinct characters is less than or equal to 'k' return len(distinct_chars) <= k"},{"question":"def find_critical_roads(n, roads): Returns a list of critical roads in the city. Parameters: n (int): Number of intersections. roads (List[List[int]]): List of roads where each road connects two intersections u and v. Returns: List[Tuple[int, int]]: List of critical roads. Examples: >>> find_critical_roads(2, [[1, 2]]) [(1, 2)] >>> find_critical_roads(3, []) [] >>> find_critical_roads(4, [[1, 2], [2, 3], [3, 4], [4, 1]]) [] >>> sorted(find_critical_roads(5, [[1, 2], [2, 3], [3, 4], [4, 5]])) [(1, 2), (2, 3), (3, 4), (4, 5)] >>> sorted(find_critical_roads(5, [[1, 2], [1, 3], [3, 4], [4, 5], [3, 5]])) [(1, 2), (1, 3)]","solution":"from collections import defaultdict def find_critical_roads(n, roads): Returns a list of critical roads in the city. Parameters: n (int): Number of intersections. roads (List[List[int]]): List of roads where each road connects two intersections u and v. Returns: List[Tuple[int, int]]: List of critical roads. def dfs(node, parent, discovery_time, low_time, visited, disc, low, bridges, time): visited[node] = True disc[node] = low[node] = time[0] time[0] += 1 for neighbor in graph[node]: if not visited[neighbor]: # If the neighbor is not visited dfs(neighbor, node, discovery_time, low_time, visited, disc, low, bridges, time) low[node] = min(low[node], low[neighbor]) if low[neighbor] > disc[node]: bridges.append((node, neighbor)) elif neighbor != parent: low[node] = min(low[node], disc[neighbor]) graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) discovery_time = [-1] * (n + 1) low_time = [-1] * (n + 1) visited = [False] * (n + 1) bridges = [] time = [0] for i in range(1, n + 1): if not visited[i]: dfs(i, -1, discovery_time, low_time, visited, discovery_time, low_time, bridges, time) return bridges"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restores the string \`s\` by rearranging its characters based on the \`indices\` array. >>> restore_string(\\"abc\\", [2, 1, 0]) == \\"cba\\" >>> restore_string(\\"a\\", [0]) == \\"a\\" >>> restore_string(\\"hello\\", [0, 1, 2, 3, 4]) == \\"hello\\" >>> restore_string(\\"abcd\\", [3, 2, 1, 0]) == \\"dcba\\" >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) == \\"nihao\\" >>> restore_string(\\"aabbcc\\", [5, 4, 3, 2, 1, 0]) == \\"ccbbaa\\"","solution":"def restore_string(s, indices): Restores the string \`s\` by rearranging its characters based on the \`indices\` array. restored = [''] * len(s) for i, idx in enumerate(indices): restored[idx] = s[i] return ''.join(restored)"},{"question":"def least_interval(tasks: List[str], cooldown: int) -> int: Returns the minimum number of intervals needed to complete all tasks. Parameters: tasks (list of str): List of tasks. cooldown (int): Minimum number of intervals that must pass between two same tasks. Returns: int: Minimum number of intervals required to complete all tasks. >>> least_interval([\\"A\\",\\"A\\",\\"A\\",\\"B\\",\\"B\\",\\"B\\"], 2) 8 >>> least_interval([\\"A\\",\\"A\\",\\"A\\",\\"B\\",\\"B\\",\\"B\\",\\"C\\",\\"C\\",\\"D\\",\\"D\\"], 2) 10 >>> least_interval([\\"A\\",\\"A\\",\\"A\\",\\"B\\",\\"B\\",\\"B\\"], 0) 6 >>> least_interval([], 2) 0 >>> least_interval([\\"A\\",\\"B\\",\\"C\\",\\"D\\"], 2) 4 >>> least_interval([\\"A\\"], 2) 1","solution":"from collections import Counter def least_interval(tasks, cooldown): Returns the minimum number of intervals needed to complete all tasks. Parameters: tasks (list of str): List of tasks. cooldown (int): Minimum number of intervals that must pass between two same tasks. Returns: int: Minimum number of intervals required to complete all tasks. if not tasks: return 0 task_counts = Counter(tasks) max_freq = max(task_counts.values()) max_freq_tasks = list(task_counts.values()).count(max_freq) intervals = (max_freq - 1) * (cooldown + 1) + max_freq_tasks return max(len(tasks), intervals)"},{"question":"def count_buildings_with_scenic_view(nums: List[int]) -> int: Returns the total number of buildings that have a scenic view of at least one shorter building to their right. >>> count_buildings_with_scenic_view([1, 2, 3, 4]) 0 >>> count_buildings_with_scenic_view([4, 3, 2, 1]) 3 >>> count_buildings_with_scenic_view([2, 3, 1, 4, 1, 2]) 3 >>> count_buildings_with_scenic_view([1]) 0 >>> count_buildings_with_scenic_view([2, 1]) 1 >>> count_buildings_with_scenic_view([1, 2]) 0","solution":"def count_buildings_with_scenic_view(nums): count = 0 for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[j] < nums[i]: count += 1 break return count"},{"question":"def can_rearrange(nums: List[int], k: int) -> bool: Rearranges the integers in the list such that every adjacent pair of integers has a difference of less than or equal to k. Args: nums (List[int]): List of non-negative integers. k (int): Integer representing the maximum allowed difference between any two adjacent integers. Returns: bool: True if such arrangement is possible, False otherwise. >>> can_rearrange([3, 5, 8, 12], 4) True >>> can_rearrange([1, 10, 14, 20], 5) False >>> can_rearrange([5], 3) True >>> can_rearrange([4, 6, 5, 7], 2) True >>> can_rearrange([0, 0, 0, 0], 0) True >>> can_rearrange([1000, 2000, 3000], 1000) True","solution":"def can_rearrange(nums, k): Rearranges the integers in the list such that every adjacent pair of integers has a difference of less than or equal to k. Args: nums: List of non-negative integers. k: Integer representing the maximum allowed difference between any two adjacent integers. Returns: bool: True if such arrangement is possible, False otherwise. nums.sort() # Sort the numbers to easily check differences between adjacent elements for i in range(len(nums) - 1): if abs(nums[i] - nums[i + 1]) > k: return False return True"},{"question":"def max_study_hours(studyHours: List[int]) -> int: Returns the maximum total uninterrupted study hours for any contiguous block of students. >>> max_study_hours([4, 3, 2, 6, 1]) 16 >>> max_study_hours([1, 2, -1, 2, 3]) 7 >>> max_study_hours([-1, -2, -3, -4]) -1 >>> max_study_hours([1, 2, 3, -2, 5, -1, 2, 6, -1, 4]) 19 >>> max_study_hours([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6","solution":"def max_study_hours(studyHours): Returns the maximum total uninterrupted study hours for any contiguous block of students. max_ending_here = max_so_far = studyHours[0] for hour in studyHours[1:]: max_ending_here = max(hour, max_ending_here + hour) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restores a shuffled string to its original order based on the provided indices. >>> restore_string(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" >>> restore_string(\\"a\\", [0]) \\"a\\" >>> restore_string(\\"aaaaa\\", [4, 3, 2, 1, 0]) \\"aaaaa\\" >>> restore_string(\\"abcd\\", [3, 2, 1, 0]) \\"dcba\\" >>> restore_string(\\"lkjhg\\", [4, 3, 2, 1, 0]) \\"ghjkl\\" >>> restore_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) \\"leetcode\\"","solution":"def restore_string(s, indices): Restores a shuffled string to its original order based on the provided indices. :param s: Shuffled string. :param indices: List of indices indicating the original position of each character. :return: The original string restored to its proper order. restored = [''] * len(s) for i, char in enumerate(s): restored[indices[i]] = char return ''.join(restored)"},{"question":"from typing import List def maxRiders(arr: List[int], k: int, minHeight: int, maxHeight: int) -> int: Calculate the maximum number of people that can ride the roller coaster simultaneously. Parameters: arr (List[int]): The heights of the people. k (int): The maximum capacity of the roller coaster. minHeight (int): The minimum height requirement. maxHeight (int): The maximum height allowed. Returns: int: The maximum number of people that can ride the roller coaster simultaneously. >>> maxRiders([120, 130, 140, 150], 5, 120, 150) 4 >>> maxRiders([110, 120, 130, 140, 150, 160], 5, 120, 150) 4 >>> maxRiders([110, 160, 170], 3, 120, 150) 0 >>> maxRiders([120, 130, 140, 150, 160], 3, 120, 150) 3 >>> maxRiders([120, 130, 140, 150], 4, 120, 150) 4 >>> maxRiders([119, 151, 160], 3, 120, 150) 0 >>> maxRiders([], 5, 120, 150) 0 >>> maxRiders([120, 130, 140], 0, 120, 150) 0","solution":"def maxRiders(arr, k, minHeight, maxHeight): Calculate the maximum number of people that can ride the roller coaster simultaneously. Parameters: arr (list of int): The heights of the people. k (int): The maximum capacity of the roller coaster. minHeight (int): The minimum height requirement. maxHeight (int): The maximum height allowed. Returns: int: The maximum number of people that can ride the roller coaster simultaneously. # Filter the heights that fall within the acceptable range valid_heights = [height for height in arr if minHeight <= height <= maxHeight] # The maximum number of people is the minimum of the valid persons and the capacity return min(len(valid_heights), k)"},{"question":"def longest_non_decreasing_subsequence(nums: List[int]) -> int: Calculate the length of the longest non-decreasing subsequence in a list of integers. :param nums: List[int] - A list of integers. :return: int - Length of the longest non-decreasing subsequence. >>> longest_non_decreasing_subsequence([]) == 0 >>> longest_non_decreasing_subsequence([10]) == 1 >>> longest_non_decreasing_subsequence([1, 2, 3, 4, 5]) == 5 >>> longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) == 1 >>> longest_non_decreasing_subsequence([2, 1, 3, 2, 4, 3, 5]) == 4 >>> longest_non_decreasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6","solution":"def longest_non_decreasing_subsequence(nums): Calculate the length of the longest non-decreasing subsequence in a list of integers. :param nums: List[int] - A list of integers. :return: int - Length of the longest non-decreasing subsequence. if not nums: return 0 # Initialize the dp array where dp[i] will be the length of longest non-decreasing subsequence ending at nums[i] dp = [1] * len(nums) # Fill dp array using dynamic programming for i in range(1, len(nums)): for j in range(i): if nums[i] >= nums[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest non-decreasing subsequence will be the maximum value in dp array return max(dp)"},{"question":"def find_words(words, s): This function finds and returns the list of words from the given list \`words\` that can be used to form the string \`s\` in the correct order. Each word in \`words\` can be used only once. :param words: List of unique words. :param s: String that is a concatenation of the words from \`words\`. :return: The list of words in the order they appear in \`s\`, if a solution exists; otherwise, return an empty list. from solution import find_words def test_find_words_found1(): words = [\\"cat\\", \\"dog\\", \\"sd\\"] s = \\"dogcat\\" output = find_words(words, s) assert sorted(output) == sorted([\\"dog\\", \\"cat\\"]) def test_find_words_found2(): words = [\\"apple\\", \\"pen\\"] s = \\"applepenapple\\" output = find_words(words, s) assert sorted(output) == sorted([\\"apple\\", \\"pen\\", \\"apple\\"]) def test_find_words_not_found(): words = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] s = \\"catsandog\\" output = find_words(words, s) assert output == [] def test_find_words_single_word(): words = [\\"cat\\"] s = \\"cat\\" output = find_words(words, s) assert output == [\\"cat\\"] def test_find_words_empty_s(): words = [\\"cat\\", \\"dog\\"] s = \\"\\" output = find_words(words, s) assert output == []","solution":"def find_words(words, s): This function finds and returns the list of words from the given list \`words\` that can be used to form the string \`s\` in the correct order. Each word in \`words\` can be used only once. :param words: List of unique words. :param s: String that is a concatenation of the words from \`words\`. :return: The list of words in the order they appear in \`s\`, if a solution exists; otherwise, return an empty list. def backtrack(start, path): if start == len(s): return path for word in words: if s.startswith(word, start): result = backtrack(start + len(word), path + [word]) if result: return result return None result = backtrack(0, []) return result if result else []"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of water that can be trapped after raining. >>> trap([]) == 0 >>> trap([1, 2, 3, 4]) == 0 >>> trap([4, 3, 2, 1]) == 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([3, 3, 3, 3, 3]) == 0 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([6, 5, 4, 3, 2, 1]) == 0 >>> trap([1, 2, 3, 4, 5, 6]) == 0","solution":"def trap(height): Calculate the total amount of water that can be trapped after raining. Args: height : List[int] - a list of non-negative integers representing the heights of blocks. Returns: int - the total amount of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def sunlit_buildings(heights: List[int]) -> int: Returns the number of buildings that are sunlit. >>> sunlit_buildings([]) 0 >>> sunlit_buildings([5]) 1 >>> sunlit_buildings([3, 3, 3, 3, 3]) 1 >>> sunlit_buildings([1, 2, 3, 4, 5]) 5 >>> sunlit_buildings([5, 4, 3, 2, 1]) 1 >>> sunlit_buildings([2, 3, 2, 4, 1]) 3 >>> sunlit_buildings([1, 3, 2, 5, 4]) 3 pass","solution":"def sunlit_buildings(heights): Returns the number of buildings that are sunlit. if not heights: return 0 sunlit_count = 1 max_height = heights[0] for height in heights[1:]: if height > max_height: sunlit_count += 1 max_height = height return sunlit_count"},{"question":"from typing import List, Tuple def find_project_order(numProjects: int, dependencies: List[Tuple[int, int]]) -> List[int]: Returns a valid order of project IDs to complete all projects given the dependencies. If no valid order exists, returns an empty list. >>> find_project_order(4, []) [0, 1, 2, 3] >>> find_project_order(4, [(0, 1), (1, 2), (2, 3)]) [0, 1, 2, 3] >>> find_project_order(4, [(0, 1), (0, 2), (1, 3), (2, 3)]) [0, 1, 2, 3] >>> find_project_order(3, [(0, 1), (1, 2), (2, 0)]) [] >>> result = find_project_order(4, [(1, 2), (2, 3)]) >>> result == [0, 1, 2, 3] or result == [1, 0, 2, 3] or result == [0, 2, 1, 3] True","solution":"from collections import defaultdict, deque def find_project_order(numProjects, dependencies): Returns a valid order of project IDs to complete all projects given the dependencies. If no valid order exists, returns an empty list. # Build the graph and indegree array graph = defaultdict(list) indegree = [0] * numProjects for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Use a queue to perform topological sorting queue = deque([i for i in range(numProjects) if indegree[i] == 0]) order = [] while queue: project = queue.popleft() order.append(project) for neighbor in graph[project]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If we processed all projects, return the order, else return an empty list if len(order) == numProjects: return order else: return []"},{"question":"def numIslands(grid): Count the number of distinct islands in a 2D grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. >>> numIslands([ ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\",\\"1\\",\\"1\\"] ... ]) 3 >>> numIslands([[\\"0\\"]]) 0 >>> numIslands([[\\"1\\"]]) 1 >>> numIslands([ ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ]) 0 >>> numIslands([ ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"], ... [\\"1\\", \\"1\\", \\"1\\"] ... ]) 1 >>> numIslands([ ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... [\\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\"], ... ]) 8","solution":"def numIslands(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False]*n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0' or visited[i][j]: return visited[i][j] = True dfs(i+1, j) dfs(i-1, j) dfs(i, j+1) dfs(i, j-1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count"},{"question":"def findLexSmallestString(s: str, a: int, b: int) -> str: You are given a string \`s\` and two integers \`a\` and \`b\`. Your task is to apply the following operation any number of times and return the lexicographically smallest string that you can obtain: 1. **Add operation**: Add \`a\` to all the odd indices of the string \`s\` (index 1, 3, 5, etc.). Digits in the string wrap around, i.e., if you add a value to '9', it becomes '0' + (value - 1). 2. **Rotate operation**: Rotate string \`s\` to the right by \`b\` positions. For example, if \`b = 3\`, then rotating \\"abcdef\\" by 3 positions would result in \\"defabc\\". >>> findLexSmallestString(\\"5525\\", 9, 2) '2050' >>> findLexSmallestString(\\"74\\", 5, 1) '24' >>> findLexSmallestString(\\"0011\\", 4, 2) '0011' >>> findLexSmallestString(\\"1234\\", 0, 2) '1234' >>> findLexSmallestString(\\"0000\\", 1, 3) '0000'","solution":"from collections import deque def add_operation(s, a): s = list(s) for i in range(1, len(s), 2): s[i] = str((int(s[i]) + a) % 10) return ''.join(s) def findLexSmallestString(s, a, b): visited = set() queue = deque([s]) smallest = s while queue: current = queue.popleft() if current < smallest: smallest = current # Apply add operation added = add_operation(current, a) if added not in visited: visited.add(added) queue.append(added) # Apply rotate operation rotated = current[-b:] + current[:-b] if rotated not in visited: visited.add(rotated) queue.append(rotated) return smallest"},{"question":"def largestNumber(nums: List[int]) -> str: Given a list of non-negative integers, arrange them such that they form the largest number and return it as a string. >>> largestNumber([10, 2]) == \\"210\\" >>> largestNumber([3, 30, 34, 5, 9]) == \\"9534330\\" >>> largestNumber([1, 20, 23, 4, 8]) == \\"8423201\\" >>> largestNumber([0, 0]) == \\"0\\" >>> largestNumber([121, 12]) == \\"12121\\"","solution":"from functools import cmp_to_key def largestNumber(nums): Given a list of non-negative integers, arrange them such that they form the largest number and return it as a string. def compare(x, y): # Comparator for sorting if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert all numbers to strings nums_str = [str(num) for num in nums] # Sort numbers using a custom comparator nums_str_sorted = sorted(nums_str, key=cmp_to_key(compare)) # Join the sorted list into a single string largest_num_str = ''.join(nums_str_sorted) # Handle the edge case for multiple 0s if largest_num_str[0] == '0': return '0' return largest_num_str"},{"question":"def product_except_self(arr: List[int]) -> List[int]: Given an array of integers 'arr', return a new array where each element at index 'i' is the product of all the numbers in the original array except the one at 'i'. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([5, 3, 4]) == [12, 20, 15] >>> product_except_self([1, 2, 3]) == [6, 3, 2] >>> product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] >>> product_except_self([2, 0, 9, 3]) == [0, 54, 0, 0] >>> product_except_self([]) == [] >>> product_except_self([10]) == [1]","solution":"def product_except_self(arr): Given an array of integers 'arr', return a new array where each element at index 'i' is the product of all the numbers in the original array except the one at 'i'. length = len(arr) if length == 0: return [] # Initialize arrays left_products, right_products, result = [1] * length, [1] * length, [1] * length # Calculate left products for i in range(1, length): left_products[i] = left_products[i - 1] * arr[i - 1] # Calculate right products for i in reversed(range(length - 1)): right_products[i] = right_products[i + 1] * arr[i + 1] # Calculate result as product of left and right products for i in range(length): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List def canReachLastStep(steps: List[int]) -> bool: Determines if a person can reach the last step from the first step given the movement constraints. Args: steps (List[int]): A list of n integers representing the heights of the steps. Returns: bool: True if the person can reach the last step, False otherwise. Examples: >>> canReachLastStep([1, 2, 3]) True >>> canReachLastStep([1, 2, 1, 3]) True >>> canReachLastStep([3, 2, 1, 2, 3]) False >>> canReachLastStep([1]) True >>> canReachLastStep([5, 4, 3, 2, 1]) False >>> canReachLastStep([1, 3, 2, 4, 3, 5]) True >>> canReachLastStep([]) False","solution":"from typing import List def canReachLastStep(steps: List[int]) -> bool: Determines if a person can reach the last step from the first step given the movement constraints. Args: steps (List[int]): A list of n integers representing the heights of the steps. Returns: bool: True if the person can reach the last step, False otherwise. n = len(steps) if n == 0: return False # No steps to move def can_reach(index): if index >= n - 1: return True if index < 0 or steps[index] >= steps[index + 1]: if index + 2 < n and steps[index] < steps[index + 2]: return can_reach(index + 2) return False return can_reach(index + 1) or (index + 2 < n and can_reach(index + 2) if steps[index] < steps[index + 2] else False) return can_reach(0)"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Returns the shuffled string based on the given indices. >>> restore_string(\\"codeleet\\", [4,5,6,7,0,2,1,3]) == \\"leetcode\\" >>> restore_string(\\"a\\", [0]) == \\"a\\" >>> restore_string(\\"abcdef\\", [0,1,2,3,4,5]) == \\"abcdef\\" >>> restore_string(\\"abcdef\\", [5,4,3,2,1,0]) == \\"fedcba\\" >>> restore_string(\\"aiohn\\", [3,1,4,2,0]) == \\"nihao\\"","solution":"def restore_string(s, indices): Returns the shuffled string based on the given indices. Parameters: s (str): The input string to be shuffled. indices (list): The list of indices representing the new positions of each character. Returns: str: The shuffled string. # Create a list with the same length as s initialized with empty strings shuffled = [''] * len(s) # Place each character of s at the corresponding index position in shuffled for i, idx in enumerate(indices): shuffled[idx] = s[i] # Join the list into a single string and return it return ''.join(shuffled)"},{"question":"def min_deletions_to_unify(s: str) -> int: Given a string \`s\` containing only characters \`a\` and \`b\`, return the minimum number of deletions needed to make it either a string with only characters 'a' or a string with only characters 'b'. >>> min_deletions_to_unify(\\"\\") == 0 >>> min_deletions_to_unify(\\"aaaa\\") == 0 >>> min_deletions_to_unify(\\"bbbb\\") == 0 >>> min_deletions_to_unify(\\"aab\\") == 1 >>> min_deletions_to_unify(\\"bbaa\\") == 2 >>> min_deletions_to_unify(\\"abababa\\") == 3","solution":"def min_deletions_to_unify(s): Returns the minimum number of deletions needed to make the string consist of only one type of character (either all 'a' or all 'b'). Parameters: s (str): Input string containing only 'a' and 'b' Returns: int: The minimum number of deletions needed if not s: return 0 count_a = s.count('a') count_b = s.count('b') # To make the string consist of only 'a' or only 'b', delete the less frequent character return min(count_a, count_b)"},{"question":"def max_points_on_line(points: List[Tuple[int, int]]) -> int: Given a list of points on a 2D plane, where each point is represented as a pair of integers (x, y), return the maximum number of points that lie on the same straight line. >>> max_points_on_line([[1,1],[2,2],[3,3]]) 3 >>> max_points_on_line([[0, 0], [0, 1], [0, 2], [0, 3]]) 4 >>> max_points_on_line([[0, 0]]) 1 >>> max_points_on_line([[1, 1], [2, 2], [3, 3], [3, 2], [1, 2]]) 3 >>> max_points_on_line([]) 0","solution":"def max_points_on_line(points): import math def gcd(a, b): while b: a, b = b, a % b return a def slope(c1, c2): dx = c2[0] - c1[0] dy = c2[1] - c1[1] if dx == 0: return 'inf' g = gcd(dx, dy) return (dy // g, dx // g) if not points: return 0 max_points = 1 for i in range(len(points)): slopes = {} same_point = 0 for j in range(i + 1, len(points)): if points[i] == points[j]: same_point += 1 continue s = slope(points[i], points[j]) if s in slopes: slopes[s] += 1 else: slopes[s] = 1 current_max = same_point for count in slopes.values(): if count + same_point > current_max: current_max = count + same_point max_points = max(max_points, current_max + 1) return max_points"},{"question":"import heapq from typing import List def min_total_cost(heights: List[int]) -> int: Returns the minimum possible total cost required to visit all points along the terrain trail starting at the first point. >>> min_total_cost([1]) 0 >>> min_total_cost([1, 2]) 1 >>> min_total_cost([1, 4, 6]) 5 >>> min_total_cost([1, 3, 7, 8, 10]) 9 >>> min_total_cost([3, 3, 3, 3]) 0 >>> min_total_cost([1, 2, 3, 6, 8, 10]) 9","solution":"import heapq def min_total_cost(heights): Returns the minimum possible total cost required to visit all points along the terrain trail starting at the first point. n = len(heights) adj = [[] for _ in range(n)] # Build the graph with all pairs of edges and their costs for i in range(n): for j in range(i + 1, n): cost = abs(heights[i] - heights[j]) adj[i].append((cost, j)) adj[j].append((cost, i)) # Prim's algorithm to find the Minimum Spanning Tree (MST) min_cost = 0 visited = [False] * n min_heap = [(0, 0)] # (cost, index) while min_heap: cost, u = heapq.heappop(min_heap) if visited[u]: continue visited[u] = True min_cost += cost for next_cost, v in adj[u]: if not visited[v]: heapq.heappush(min_heap, (next_cost, v)) return min_cost"},{"question":"from typing import List def check_subarray_sum(nums: List[int], k: int) -> bool: Given an array of integers 'nums' and an integer 'k', check if there is a continuous subarray of length at least 2 that sums up to a multiple of k. >>> check_subarray_sum([23, 2, 4, 6, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 6) True >>> check_subarray_sum([23, 2, 6, 4, 7], 13) False >>> check_subarray_sum([0, 0], 0) True >>> check_subarray_sum([0, 1, 0], 0) False >>> check_subarray_sum([1, 0, 0], 0) True >>> check_subarray_sum([1, 2, 3], 0) False >>> check_subarray_sum([5, 0, 0], 5) True >>> check_subarray_sum([1, 2, 12, 15], 5) True >>> check_subarray_sum([1, 2, 12, 15], 17) False","solution":"def check_subarray_sum(nums, k): Given an array of integers 'nums' and an integer 'k', check if there is a continuous subarray of length at least 2 that sums up to a multiple of k. if k == 0: # Special case when k is 0 for i in range(len(nums) - 1): if nums[i] == 0 and nums[i + 1] == 0: return True return False mod_dict = {0: -1} # Dictionary to store modulus and index running_sum = 0 for i in range(len(nums)): running_sum += nums[i] if k != 0: running_sum %= k if running_sum in mod_dict: if i - mod_dict[running_sum] > 1: return True else: mod_dict[running_sum] = i return False"},{"question":"def is_valid_number_string(s: str) -> bool: Determines whether the string s is a valid string by the given rules. A string is valid if it can be obtained by concatenating one or more positive integers, each without leading zeros. Parameters: s (str): Input string containing only digits. Returns: bool: True if the string is valid, False otherwise. >>> is_valid_number_string(\\"1234\\") True >>> is_valid_number_string(\\"0123\\") False >>> is_valid_number_string(\\"1\\") True >>> is_valid_number_string(\\"0\\") False >>> is_valid_number_string(\\"\\") False >>> is_valid_number_string(\\"1000000007\\") True >>> is_valid_number_string(\\"0012\\") False","solution":"def is_valid_number_string(s): Determines whether the string s is a valid string by the given rules. A string is valid if it can be obtained by concatenating one or more positive integers, each without leading zeros. Parameters: s (str): Input string containing only digits. Returns: bool: True if the string is valid, False otherwise. # First, check for the length of the string. If the string is empty, it is not a valid number. if not s: return False # Check if the string has any leading zeros. if s[0] == '0': return False return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Given a binary tree, return the inorder traversal of its nodes' values as an array. The tree is represented using nodes with the class TreeNode, where each node has a value and pointers to its left and right children. The inorder traversal of a binary tree visits the left subtree first, then the current node, and finally the right subtree. >>> root = TreeNode(2, TreeNode(1), TreeNode(3)) >>> inorder_traversal(root) [1, 2, 3] >>> root = TreeNode(1) >>> inorder_traversal(root) [1] >>> inorder_traversal(None) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of a binary tree starting from the root. result = [] def _inorder(node): if node is not None: _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(root) return result"},{"question":"def count_odd_sum_subsets(nums: List[int]) -> int: Return the number of subsets where the sum of the elements is an odd number. The result is returned modulo 10^9 + 7. >>> count_odd_sum_subsets([1, 2, 3]) 4 >>> count_odd_sum_subsets([1, 1, 1]) 4 >>> count_odd_sum_subsets([0, 1, 2]) 4 >>> count_odd_sum_subsets([2, 2, 2]) 0 >>> count_odd_sum_subsets([1]) 1","solution":"def count_odd_sum_subsets(nums): MOD = 10**9 + 7 def count_subsets_with_sum(arr, target): dp = [0] * (target + 1) dp[0] = 1 for num in arr: for s in range(target, num - 1, -1): dp[s] += dp[s - num] dp[s] %= MOD return dp total_sum = sum(nums) odd_sum_count = count_subsets_with_sum(nums, total_sum)[1::2] result = sum(odd_sum_count) % MOD return result"},{"question":"def can_empty_array(nums, x): Determines if you can make the array empty by repeatedly removing a contiguous subarray whose sum is equal to x. >>> can_empty_array([1, 2, 3, 4, 5], 5) == False >>> can_empty_array([1, 1, 1, 1, 1], 1) == True >>> can_empty_array([10, -10, 10, -10], 0) == True >>> can_empty_array([2, 3, -2, -3, 2], 0) == False >>> can_empty_array([1, 2, 3, 4, 2, 3, 1], 6) == False >>> can_empty_array([1, 2, 3, 6], 6) == True","solution":"def can_empty_array(nums, x): Determines if the array can be made empty by repeatedly removing a contiguous subarray whose sum is equal to x. def can_remove_subarray(nums, x, start): if not nums: return True running_sum = 0 for i in range(start, len(nums)): running_sum += nums[i] if running_sum == x: # Recursively check the remaining part of the array if can_remove_subarray(nums[i + 1:], x, 0): return True return False return can_remove_subarray(nums, x, 0)"},{"question":"class NumArray: A data structure to manage an array of integers and support the following operations: 1. Add an integer value to a specific index in the array. 2. Find the maximum sum of any contiguous subarray within the array. Example: >>> num_array = NumArray([1, -2, 3, 4, -5]) >>> num_array.maxSumSubarray() 7 >>> num_array.add(1, 2) >>> num_array.maxSumSubarray() 8 def __init__(self, nums): Initializes the NumArray with the given list of integers nums. self.nums = nums def add(self, index, value): Adds value to nums[index] in the array. pass def maxSumSubarray(self): Returns the maximum sum of any contiguous subarray using Kadane's algorithm. pass","solution":"class NumArray: def __init__(self, nums): Initializes the NumArray with the given list of integers nums. self.nums = nums def add(self, index, value): Adds value to nums[index] in the array. if 0 <= index < len(self.nums): self.nums[index] += value else: raise IndexError(\\"Index out of bounds\\") def maxSumSubarray(self): Returns the maximum sum of any contiguous subarray using Kadane's algorithm. if not self.nums: return 0 max_so_far = self.nums[0] max_ending_here = self.nums[0] for num in self.nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def exist(board: List[List[str]], word: str) -> bool: Determine if a word exists in a 2D grid of characters. The word can be constructed from letters of sequentially adjacent cells. Adjacent cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in the word. >>> board = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> exist(board, \\"ABCCED\\") True >>> exist(board, \\"ABCD\\") False >>> exist([], \\"ABCCED\\") False >>> exist([['A']], \\"A\\") True >>> exist([['A']], \\"B\\") False >>> board = [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'E', 'S'], ... ['A', 'D', 'E', 'E'] ... ] >>> exist(board, \\"ABCESEEEFS\\") True","solution":"def exist(board, word): def helper(x, y, word): if len(word) == 0: return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] != word[0]: return False tmp, board[x][y] = board[x][y], '#' res = helper(x + 1, y, word[1:]) or helper(x - 1, y, word[1:]) or helper(x, y + 1, word[1:]) or helper(x, y - 1, word[1:]) board[x][y] = tmp return res for i in range(len(board)): for j in range(len(board[0])): if helper(i, j, word): return True return False"},{"question":"def is_palindrome(s): Helper function to determine if a given string s is a palindrome. pass def can_divide_substring(s, start, end): Determines if the substring s[start...end] can be divided into two non-empty parts such that one is a palindrome and the other is not. pass def test_valid_division(): assert can_divide_substring(\\"abca\\", 1, 3) == True # \\"bca\\" => \\"b\\" (not palindrome), \\"ca\\" (palindrome) def test_no_palindrome(): assert can_divide_substring(\\"abcd\\", 1, 3) == True # \\"bcd\\" => \\"bc\\" (not palindrome), \\"d\\" (palindrome) def test_no_non_palindrome(): assert can_divide_substring(\\"abba\\", 1, 3) == True # \\"abb\\" => \\"a\\" (palindrome), \\"bb\\" (not palindrome) def test_entire_string_palindrome(): assert can_divide_substring(\\"aaaa\\", 0, 3) == False # \\"aaaa\\" cannot be split into non-palindrome part def test_string_too_short(): assert can_divide_substring(\\"a\\", 0, 0) == False # Single character cannot be split into two parts def test_invalid_indices(): assert can_divide_substring(\\"hello\\", -1, 5) == False # Out of range indices assert can_divide_substring(\\"hello\\", 4, 2) == False # start > end","solution":"def is_palindrome(s): Helper function to determine if a given string s is a palindrome. return s == s[::-1] def can_divide_substring(s, start, end): Determines if the substring s[start...end] can be divided into two non-empty parts such that one is a palindrome and the other is not. if start < 0 or end >= len(s) or start > end: return False substring = s[start:end+1] n = len(substring) for i in range(1, n): # i is the split point left = substring[:i] right = substring[i:] if is_palindrome(left) and not is_palindrome(right): return True if not is_palindrome(left) and is_palindrome(right): return True return False"},{"question":"def evalRPN(tokens: List[str]) -> int: Evaluates the value of an arithmetic expression in Reverse Polish Notation (RPN). :param tokens: List[str] - List of strings representing the RPN expression. :return: int - Result of the evaluated expression. pass # Test cases def test_evalRPN_simple(): assert evalRPN([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) == 9 # ((2 + 1) * 3) = 9 assert evalRPN([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) == 6 # (4 + (13 / 5)) = 6 assert evalRPN([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) == 22 def test_evalRPN_division(): assert evalRPN([\\"10\\", \\"6\\", \\"/\\"]) == 1 # 10 / 6 = 1 (truncate towards zero) assert evalRPN([\\"-10\\", \\"6\\", \\"/\\"]) == -1 # -10 / 6 = -1 (truncate towards zero) assert evalRPN([\\"10\\", \\"-6\\", \\"/\\"]) == -1 # 10 / -6 = -1 (truncate towards zero) assert evalRPN([\\"-10\\", \\"-6\\", \\"/\\"]) == 1 # -10 / -6 = 1 (truncate towards zero) def test_evalRPN_multiple_operators(): assert evalRPN([\\"5\\", \\"1\\", \\"2\\", \\"+\\", \\"4\\", \\"*\\", \\"+\\", \\"3\\", \\"-\\"]) == 14 # 5 + ((1 + 2) * 4) - 3 = 14 assert evalRPN([\\"2\\", \\"3\\", \\"+\\", \\"11\\", \\"*\\"]) == 55 # (2 + 3) * 11 = 55 def test_evalRPN_single_value(): assert evalRPN([\\"3\\"]) == 3 assert evalRPN([\\"-3\\"]) == -3","solution":"def evalRPN(tokens): Evaluates the value of an arithmetic expression in Reverse Polish Notation (RPN). :param tokens: List[str] - List of strings representing the RPN expression. :return: int - Result of the evaluated expression. stack = [] for token in tokens: if token in {'+', '-', '*', '/'}: b = stack.pop() a = stack.pop() if token == '+': result = a + b elif token == '-': result = a - b elif token == '*': result = a * b elif token == '/': result = int(a / b) # Truncate towards zero stack.append(result) else: stack.append(int(token)) return stack[0]"},{"question":"import heapq from typing import List def merge_stones(nums: List[int]) -> int: Returns the minimum cost to merge all the given piles into one pile. Parameters: nums (list of int): The number of stones in each pile. Returns: int: The minimum cost to merge all the piles into one. >>> merge_stones([10]) 0 >>> merge_stones([4, 3]) 7 >>> merge_stones([4, 3, 3, 4]) 28 >>> merge_stones([10, 20, 30, 40]) 190 >>> merge_stones([]) 0","solution":"import heapq def merge_stones(nums): Returns the minimum cost to merge all the given piles into one pile. Parameters: nums (list of int): The number of stones in each pile. Returns: int: The minimum cost to merge all the piles into one. if not nums: return 0 heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first_smallest = heapq.heappop(nums) second_smallest = heapq.heappop(nums) cost = first_smallest + second_smallest total_cost += cost heapq.heappush(nums, cost) return total_cost"},{"question":"from typing import List def lexicographically_smallest_substring(s: str, k: int) -> str: Returns the lexicographically smallest substring of length k from the given string s. If k is greater than the length of the string s, return an empty string. >>> lexicographically_smallest_substring(\\"abcde\\", 2) 'ab' >>> lexicographically_smallest_substring(\\"azbzcz\\", 2) 'az' >>> lexicographically_smallest_substring(\\"aaaaa\\", 3) 'aaa' >>> lexicographically_smallest_substring(\\"abc\\", 3) 'abc' >>> lexicographically_smallest_substring(\\"abc\\", 4) '' >>> lexicographically_smallest_substring(\\"abcde\\", 1) 'a' >>> lexicographically_smallest_substring(\\"zayxb\\", 2) 'ay'","solution":"def lexicographically_smallest_substring(s, k): Returns the lexicographically smallest substring of length k from the given string s. n = len(s) if k > n: return \\"\\" smallest_substring = s[:k] for i in range(1, n - k + 1): current_substring = s[i:i + k] if current_substring < smallest_substring: smallest_substring = current_substring return smallest_substring"},{"question":"def findMaxConsecutiveOnes(nums: List[int]) -> int: Given an array of integers \`nums\`, where each element is \`1\`, return the maximum number of consecutive \`1\`s in the array. >>> findMaxConsecutiveOnes([1, 1, 1, 1, 1]) 5 >>> findMaxConsecutiveOnes([0, 0, 0, 0, 0]) 0 >>> findMaxConsecutiveOnes([1, 0, 1, 1, 0, 1, 1, 1]) 3 >>> findMaxConsecutiveOnes([1, 1, 0, 1, 1, 1, 0, 1]) 3 >>> findMaxConsecutiveOnes([0, 1, 1, 1, 0, 0, 1, 1, 1, 1]) 4 >>> findMaxConsecutiveOnes([1]) 1 >>> findMaxConsecutiveOnes([0]) 0 >>> findMaxConsecutiveOnes([]) 0","solution":"def findMaxConsecutiveOnes(nums): Returns the maximum number of consecutive 1s in the given array nums. max_consecutive = 0 current_consecutive = 0 for num in nums: if num == 1: current_consecutive += 1 max_consecutive = max(max_consecutive, current_consecutive) else: current_consecutive = 0 return max_consecutive"},{"question":"def max_value_events(events: List[Tuple[int, int, int]]) -> int: Given an array events where each event is represented as a tuple (start, end, value) indicating the start time, end time, and value of the event, find the maximum value you can achieve by attending non-overlapping events. >>> max_value_events([(1, 2, 50)]) == 50 >>> max_value_events([(1, 2, 50), (3, 4, 60)]) == 110 >>> max_value_events([(1, 3, 50), (2, 5, 60)]) == 60 >>> max_value_events([(1, 2, 50), (2, 3, 60), (3, 4, 70)]) == 180 >>> max_value_events([(1, 3, 50), (3, 5, 20), (2, 4, 70), (6, 8, 30)]) == 100 >>> max_value_events([]) == 0","solution":"def binary_search(events, end_time): left, right = 0, len(events) - 1 while left <= right: mid = (left + right) // 2 if events[mid][1] <= end_time: left = mid + 1 else: right = mid - 1 return right def max_value_events(events): events.sort(key=lambda x: x[1]) dp = [0] * len(events) def find_max_value(index): if index == -1: return 0 if dp[index] > 0: return dp[index] current_value = events[index][2] previous_index = binary_search(events, events[index][0]) if previous_index != -1: current_value += find_max_value(previous_index) dp[index] = max(find_max_value(index - 1), current_value) return dp[index] return find_max_value(len(events) - 1)"},{"question":"def lexicographically_smallest_permutation(nums: List[int]) -> List[int]: Transform the permutation into the smallest possible permutation in lexicographical order by reversing at most one segment. Args: nums (List[int]): The permutation of the first \`n\` natural numbers. Returns: List[int]: The lexicographically smallest permutation that can be obtained. Examples: >>> lexicographically_smallest_permutation([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_permutation([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_permutation([3, 2, 4, 5, 1]) [1, 5, 4, 2, 3] >>> lexicographically_smallest_permutation([1, 3, 2, 4, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_permutation([2, 1, 3, 4, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_permutation([1, 2, 3, 5, 4]) [1, 2, 3, 4, 5]","solution":"def lexicographically_smallest_permutation(nums): n = len(nums) # Find the first non increasing element from the left first = 0 while first < n - 1 and nums[first] < nums[first + 1]: first += 1 # If the list is already in lexicographically smallest order if first == n - 1: return nums # Find the largest element from the end which is smaller than nums[first] second = first for i in range(n - 1, first, -1): if nums[i] < nums[first]: second = i break # Reverse the segment between first and second nums = nums[:first] + nums[first:second + 1][::-1] + nums[second + 1:] return nums"},{"question":"def minimum_trips() -> int: Returns the minimum number of trips required for Alice, Bob, and Charlie to cross the river, given the constraints: - The boat can carry at most two friends at a time. - Alice and Bob can't be left alone on either side of the river without Charlie, as they will argue. >>> minimum_trips() 5","solution":"def minimum_trips(): Returns the minimum number of trips required for Alice, Bob, and Charlie to cross the river, given the constraints. # Given the constraints, a possible solution is as follows: # 1. Charlie takes Alice to the right bank # 2. Charlie returns to the left bank # 3. Charlie takes Bob to the right bank # 4. Charlie returns to the left bank # 5. Charlie takes himself to the right bank # This results in 5 trips in total return 5"},{"question":"from typing import List def rob(houses: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police. Given a list of non-negative integers representing the amount of money of each house, where any two immediately adjacent houses cannot be robbed on the same night. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([5, 10]) == 10 >>> rob([1,2,3,1]) == 4 >>> rob([2,7,9,3,1]) == 12 >>> rob([100, 200, 300, 400, 500, 600]) == 1200","solution":"def rob(houses): if not houses: return 0 if len(houses) == 1: return houses[0] # Using DP array to store the maximum profit up to each house dp = [0] * len(houses) dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, len(houses)): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1]"},{"question":"def min_operations_to_equal_k_sum(arr: List[int], k: int) -> int: Return the minimum number of operations required to make the sum of any \`k\` consecutive elements in the array the same. >>> min_operations_to_equal_k_sum([1, 2, 3, 4, 5], 2) 3 >>> min_operations_to_equal_k_sum([1], 1) 0 >>> min_operations_to_equal_k_sum([5, 5, 5, 5], 2) 0 >>> min_operations_to_equal_k_sum([1, 2], 3) -1 >>> min_operations_to_equal_k_sum([1, 2, 3, 1, 2, 3], 2) 3 >>> min_operations_to_equal_k_sum([4, 3, 2, 6, 1], 3) 1","solution":"def min_operations_to_equal_k_sum(arr, k): n = len(arr) if n < k: return -1 # not possible since we need at least k elements # Calculate the initial sum of the first k elements current_sum = sum(arr[:k]) # Store all possible sums of k consecutive elements k_consecutive_sums = [current_sum] for i in range(k, n): current_sum += arr[i] current_sum -= arr[i - k] k_consecutive_sums.append(current_sum) # The target sum is the most common k-consecutive sum target_sum = max(set(k_consecutive_sums), key=k_consecutive_sums.count) # Calculate the minimum number of operations required operations_needed = 0 for s in k_consecutive_sums: if s != target_sum: operations_needed += 1 return operations_needed"},{"question":"def max_unique_integers(arr: List[int], k: int) -> int: Given an array of integers arr, return the maximum number of unique integers in any contiguous subarray of length k. >>> max_unique_integers([1, 2, 3, 1, 2, 3], 3) 3 >>> max_unique_integers([1, 1, 1, 1, 1, 1], 2) 1 >>> max_unique_integers([1, 2, 1, 3, 4], 3) 3 >>> max_unique_integers([4, 2, 1, 3, 4, 1, 2, 3], 8) 4 >>> max_unique_integers([1], 1) 1 >>> max_unique_integers([1, 2, 3], 5) 3 >>> max_unique_integers([1, 2, 3, 4, 5, 6], 4) 4","solution":"def max_unique_integers(arr, k): Returns the maximum number of unique integers in any contiguous subarray of length k. if len(arr) < k: return len(set(arr)) max_unique = 0 current_window = set() current_count = {} for i in range(len(arr)): if i >= k: if current_count[arr[i - k]] == 1: current_window.remove(arr[i - k]) current_count[arr[i - k]] -= 1 current_window.add(arr[i]) current_count[arr[i]] = current_count.get(arr[i], 0) + 1 max_unique = max(max_unique, len(current_window)) return max_unique"},{"question":"def max_distinct_sections(s: str) -> int: Returns the maximum number of distinct contiguous sections in the given string. Each section is made up of one or more repeated characters. >>> max_distinct_sections(\\"aabbcc\\") 3 >>> max_distinct_sections(\\"aaabbbccc\\") 3 >>> max_distinct_sections(\\"abc\\") 3 >>> max_distinct_sections(\\"aaaa\\") 1 >>> max_distinct_sections(\\"ababab\\") 6 >>> max_distinct_sections(\\"\\") 0 >>> max_distinct_sections(\\"a\\") 1 >>> max_distinct_sections(\\"aaaaaaaaaaaaaaaaaaaaaaaa\\") 1 >>> max_distinct_sections(\\"aabbaabb\\") 4 >>> max_distinct_sections(\\"abccba\\") 5 >>> max_distinct_sections(\\"abbcccdddde\\") 5 >>> max_distinct_sections(\\"aabbccddeeffgghhiijj\\") 10","solution":"def max_distinct_sections(s): Returns the maximum number of distinct contiguous sections in the given string. Each section is made up of one or more repeated characters. if not s: return 0 sections = 1 for i in range(1, len(s)): if s[i] != s[i-1]: sections += 1 return sections"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Determine whether a binary tree is symmetric. :param root: TreeNode, the root of the binary tree. :return: bool, True if the tree is symmetric, False otherwise. if not root: return True return is_mirror(root.left, root.right) def is_mirror(left, right): Helper function to determine whether two trees are mirror images. :param left: TreeNode, the root of the first tree. :param right: TreeNode, the root of the second tree. :return: bool, True if the trees are mirrors, False otherwise. if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left) def test_symmetric_tree(): # Construct a symmetric tree # 1 # / # 2 2 # / / # 3 4 4 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.left.right = TreeNode(4) root.right.left = TreeNode(4) root.right.right = TreeNode(3) assert is_symmetric(root) == True def test_asymmetric_tree(): # Construct an asymmetric tree # 1 # / # 2 2 # # 3 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.right = TreeNode(3) root.right.right = TreeNode(3) assert is_symmetric(root) == False def test_single_node(): # Single node tree root = TreeNode(1) assert is_symmetric(root) == True def test_empty_tree(): # Empty tree assert is_symmetric(None) == True def test_two_level_tree(): # Symmetric two-level tree with different structure # 1 # / # 2 2 # / # 3 3 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.right = TreeNode(3) root.right.left = TreeNode(3) assert is_symmetric(root) == True def test_asymmetric_values_tree(): # Asymmetric tree in values # 1 # / # 2 2 # / # 3 4 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(2) root.left.left = TreeNode(3) root.right.right = TreeNode(4) assert is_symmetric(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root): Determine whether a binary tree is symmetric. :param root: TreeNode, the root of the binary tree. :return: bool, True if the tree is symmetric, False otherwise. if not root: return True return is_mirror(root.left, root.right) def is_mirror(left, right): Helper function to determine whether two trees are mirror images. :param left: TreeNode, the root of the first tree. :param right: TreeNode, the root of the second tree. :return: bool, True if the trees are mirrors, False otherwise. if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left)"},{"question":"def min_operations_to_make_unique(arr): Returns the minimum number of operations required to make all elements of the array distinct. >>> min_operations_to_make_unique([1, 2, 3]) 0 >>> min_operations_to_make_unique([1, 1, 1]) 3 >>> min_operations_to_make_unique([3, 2, 1, 2, 1, 7]) 6 >>> min_operations_to_make_unique([5]) 0 >>> min_operations_to_make_unique([10, 10, 10, 20, 20, 20]) 6 >>> min_operations_to_make_unique([]) 0","solution":"def min_operations_to_make_unique(arr): Returns the minimum number of operations required to make all elements of the array distinct. if not arr: return 0 arr.sort() operations = 0 for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: needed_increment = arr[i - 1] - arr[i] + 1 arr[i] += needed_increment operations += needed_increment return operations"},{"question":"def three_sum_exists(nums: List[int], target: int) -> bool: Checks if there are three distinct indices i, j, k in the array such that nums[i] + nums[j] + nums[k] == target. :param nums: List of integers :param target: Target integer sum :return: Boolean value indicating if such indices exist >>> three_sum_exists([2, 7, 11, 15], 24) True >>> three_sum_exists([1, 2, 3, 4], 10) False","solution":"def three_sum_exists(nums, target): Checks if there are three distinct indices i, j, k in the array such that nums[i] + nums[j] + nums[k] == target. :param nums: List of integers :param target: Target integer sum :return: Boolean value indicating if such indices exist n = len(nums) for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if nums[i] + nums[j] + nums[k] == target: return True return False"},{"question":"def splitArray(nums: List[int], k: int) -> int: Split the array into k contiguous subarrays such that the sum of the maximum subarray sums is minimized. Returns the minimized sum of the maximum subarray sums. >>> splitArray([7, 2, 5, 10, 8], 2) 18 >>> splitArray([1], 1) 1 >>> splitArray([5, 5, 5, 5], 2) 10 >>> splitArray([1, 2, 3, 4], 4) 4 >>> splitArray([1, 4, 4], 3) 4 >>> splitArray([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17","solution":"def splitArray(nums, k): Split the array into k contiguous subarrays such that the sum of the maximum subarray sums is minimized. Returns the minimized sum of the maximum subarray sums. def can_split(nums, k, max_sum): current_sum = 0 count = 1 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_split(nums, k, mid): high = mid else: low = mid + 1 return low"},{"question":"def kth_smallest(arr: List[int], k: int) -> int: Returns the k-th smallest element in the array. :param arr: List of integers :param k: The k-th smallest position to find (1-based index) :return: The k-th smallest element >>> kth_smallest([3, 1, 2, 4], 1) == 1 >>> kth_smallest([3, 1, 2, 4], 2) == 2 >>> kth_smallest([3, 1, 2, 4], 3) == 3 >>> kth_smallest([3, 1, 2, 4], 4) == 4 >>> kth_smallest([5, 3, 5, 3, 6], 3) == 5 >>> kth_smallest([-1, -5, -10, 0], 1) == -10 >>> kth_smallest([-1, -5, -10, 0], 2) == -5 >>> kth_smallest([-1, -5, -10, 0], 3) == -1 >>> kth_smallest([-1, -5, -10, 0], 4) == 0 >>> kth_smallest([1, 2, 3], 0) Traceback (most recent call last): ... ValueError: Invalid input: Check the array is not empty and k is within range. >>> kth_smallest([1, 2, 3], 4) Traceback (most recent call last): ... ValueError: Invalid input: Check the array is not empty and k is within range. >>> kth_smallest([], 1) Traceback (most recent call last): ... ValueError: Invalid input: Check the array is not empty and k is within range. >>> kth_smallest([1, 2, 3, 4, 5], 3) == 3 >>> kth_smallest([10], 1) == 10 >>> kth_smallest([7, 10, 4, 3, 20, 15], 4) == 10 pass","solution":"def kth_smallest(arr, k): Returns the k-th smallest element in the array. :param arr: List of integers :param k: The k-th smallest position to find (1-based index) :return: The k-th smallest element if not arr or k < 1 or k > len(arr): raise ValueError(\\"Invalid input: Check the array is not empty and k is within range.\\") # Sort the array in ascending order sorted_arr = sorted(arr) # Return the k-th smallest element (1-based index, so k-1 for 0-based index) return sorted_arr[k-1]"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Given an array of integers representing heights of buildings, where each building's width is 1, find the largest rectangular area that can be formed within the confines of the skyline. The width of each rectangle is the distance between two buildings, and the height of each rectangle is the height of the shortest building in that range. Return this maximum area. >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([2, 3]) 4 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 2, 2, 2]) 8 >>> largest_rectangle_area([]) 0","solution":"def largest_rectangle_area(heights): Returns the largest rectangular area that can be formed in the skyline. Parameters: heights (list of int): Heights of the buildings. Returns: int: Maximum area of the rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): # Push building into stack if it is higher than the building before if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) # Remaining buildings in stack while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: Perform a flood fill operation on an image. Args: image (List[List[int]]): A 2D list of integers representing the image. sr (int): The starting row index for the flood fill. sc (int): The starting column index for the flood fill. newColor (int): The new color to apply. Returns: List[List[int]]: The modified image after performing the flood fill operation. >>> floodFill( ... [ ... [1, 1, 1], ... [1, 1, 0], ... [1, 0, 1] ... ], 1, 1, 2 ... ) [[2, 2, 2], [2, 2, 0], [2, 0, 1]] >>> floodFill( ... [ ... [0, 0, 0], ... [0, 1, 1] ... ], 1, 1, 1 ... ) [[0, 0, 0], [0, 1, 1]] >>> floodFill( ... [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ], 0, 0, 3 ... ) [[3, 3, 3], [3, 3, 3], [3, 3, 3]] >>> floodFill( ... [ ... [0, 0, 0], ... [0, 0, 0] ... ], 0, 0, 2 ... ) [[2, 2, 2], [2, 2, 2]] >>> floodFill( ... [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ], 1, 1, 3 ... ) [[0, 1, 0], [1, 3, 1], [0, 1, 0]]","solution":"from typing import List def floodFill(image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: rows, cols = len(image), len(image[0]) originalColor = image[sr][sc] if originalColor == newColor: return image def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or image[r][c] != originalColor: return image[r][c] = newColor dfs(r-1, c) # up dfs(r+1, c) # down dfs(r, c-1) # left dfs(r, c+1) # right dfs(sr, sc) return image"},{"question":"def mean_of_neighbors(nums: list[int]) -> list[float]: Calculate the mean average of each element and its nearest neighbors in the input nums array. :param nums: List of integers :return: List of floats with mean averages of each element and its nearest neighbors. >>> mean_of_neighbors([5]) [5] >>> mean_of_neighbors([1, 3]) [2, 2] >>> mean_of_neighbors([1, 2, 3, 4]) [1.5, 2.0, 3.0, 3.5] >>> mean_of_neighbors([5, 5, 5]) [5.0, 5.0, 5.0] >>> mean_of_neighbors([-1, -5, -3]) [-3.0, -3.0, -4.0] >>> mean_of_neighbors([-1, 0, 1]) [-0.5, 0.0, 0.5] >>> mean_of_neighbors([]) []","solution":"def mean_of_neighbors(nums): Calculates the mean average of each element and its nearest neighbor in the input nums array. Parameters: nums (list of int): The input integer array. Returns: list of float: The resulting array with mean averages of each element and its nearest neighbors. n = len(nums) if n == 0: return [] if n == 1: return [nums[0]] result = [0] * n # Handling the first element result[0] = (nums[0] + nums[1]) / 2 # Handling the elements in the middle for i in range(1, n - 1): result[i] = (nums[i - 1] + nums[i] + nums[i + 1]) / 3 # Handling the last element result[n - 1] = (nums[n - 1] + nums[n - 2]) / 2 return result"},{"question":"def islandPerimeter(grid: List[List[int]]) -> int: Returns the perimeter of the island in the given 2D grid. >>> islandPerimeter([[1]]) == 4 >>> islandPerimeter([[0, 0, 0], [1, 1, 1], [0, 0, 0]]) == 8 >>> islandPerimeter([[0, 1, 0], [0, 1, 0], [0, 1, 0]]) == 8 >>> islandPerimeter([[1, 1], [1, 1]]) == 8 >>> islandPerimeter([ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ]) == 16","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the given 2D grid. rows, cols = len(grid), len(grid[0]) perimeter = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: perimeter += 4 if i > 0 and grid[i - 1][j] == 1: perimeter -= 2 if j > 0 and grid[i][j - 1] == 1: perimeter -= 2 return perimeter"},{"question":"def longest_substring_length(s: str) -> int: Returns the length of the longest substring which contains only one distinct character. >>> longest_substring_length(\\"a\\") 1 >>> longest_substring_length(\\"aa\\") 2 >>> longest_substring_length(\\"abc\\") 1 >>> longest_substring_length(\\"abcaabc\\") 3 >>> longest_substring_length(\\"aaaa\\") 4 >>> longest_substring_length(\\"\\") 0 >>> longest_substring_length(\\"aabbbcccccdd\\") 5","solution":"def longest_substring_length(s): Returns the length of the longest substring which contains only one distinct character. from collections import Counter if not s: return 0 frequency = Counter(s) return max(frequency.values())"},{"question":"class Node: def __init__(self, val = 0, next = None, random = None): self.val = val self.next = next self.random = random def copyRandomList(head): Return a deep copy of the linked list, preserving the structure including the random pointers. >>> linked_list_values(copyRandomList(None)) == None True >>> node = Node(1) >>> node.random = node >>> copied_list = copyRandomList(node) >>> linked_list_values(copied_list) [(1, 1)] >>> node1 = Node(1) >>> node2 = Node(2) >>> node3 = Node(3) >>> node1.next = node2 >>> node2.next = node3 >>> node1.random = node3 >>> node2.random = node1 >>> node3.random = node2 >>> copied_list = copyRandomList(node1) >>> linked_list_values(copied_list) [(1, 3), (2, 1), (3, 2)] >>> node1 = Node(7) >>> node2 = Node(13) >>> node3 = Node(11) >>> node4 = Node(10) >>> node5 = Node(1) >>> node1.next = node2 >>> node2.next = node3 >>> node3.next = node4 >>> node4.next = node5 >>> node2.random = node1 >>> node3.random = node5 >>> node4.random = node3 >>> node5.random = node1 >>> copied_list = copyRandomList(node1) >>> linked_list_values(copied_list) [(7, None), (13, 7), (11, 1), (10, 11), (1, 7)]","solution":"class Node: def __init__(self, val = 0, next = None, random = None): self.val = val self.next = next self.random = random def copyRandomList(head): if not head: return None # Step 1. Create a new node for each original node and insert it next to the original node. iter_node = head while iter_node: next_node = iter_node.next copy = Node(iter_node.val, next_node) iter_node.next = copy iter_node = next_node # Step 2. Assign random pointers for the copy nodes. iter_node = head while iter_node: if iter_node.random: iter_node.next.random = iter_node.random.next iter_node = iter_node.next.next # Step 3. Restore the original list, and extract the copy list. iter_node = head copy_head = head.next while iter_node: copy_node = iter_node.next iter_node.next = copy_node.next if copy_node.next: copy_node.next = copy_node.next.next iter_node = iter_node.next return copy_head"},{"question":"from typing import List def rob(nums: List[int]) -> int: Returns the maximum amount of money the thief can rob without alerting the security system. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([1, 2]) == 2 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([2, 1, 1, 2]) == 4 >>> rob([8, 2, 8, 9, 2, 6]) == 23","solution":"def rob(nums): Returns the maximum amount of money the thief can rob without alerting the security system. if not nums: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"import heapq from typing import List def min_cost_to_combine_stones(nums: List[int]) -> int: Returns the minimum cost to combine all stones into one pile. Args: nums: List[int] - list of integers representing the number of stones in each pile. Returns: int - minimum cost to combine all stones into one pile. >>> min_cost_to_combine_stones([5]) 0 >>> min_cost_to_combine_stones([4, 3]) 7 >>> min_cost_to_combine_stones([1, 2, 3, 4]) 19 >>> min_cost_to_combine_stones([4, 4, 4, 4]) 32 >>> min_cost_to_combine_stones([1000, 2000, 3000, 4000]) 19000","solution":"import heapq def min_cost_to_combine_stones(nums): Returns the minimum cost to combine all stones into one pile. Args: nums: List[int] - list of integers representing the number of stones in each pile. Returns: int - minimum cost to combine all stones into one pile. if len(nums) <= 1: return 0 heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first = heapq.heappop(nums) second = heapq.heappop(nums) cost = first + second total_cost += cost heapq.heappush(nums, cost) return total_cost"},{"question":"class MaxStack: A class that simulates a stack with push, pop, top, and getMax functions. Methods: - push(x: int) -> None - pop() -> int - top() -> int - getMax() -> int Examples: >>> stack = MaxStack() >>> stack.push(3) >>> stack.push(5) >>> stack.top() 5 >>> stack.getMax() 5 >>> stack.pop() 5 >>> stack.getMax() 3 import pytest from solution import MaxStack def test_push(): stack = MaxStack() stack.push(3) stack.push(5) assert stack.top() == 5 assert stack.getMax() == 5 def test_pop(): stack = MaxStack() stack.push(1) stack.push(2) stack.push(3) assert stack.pop() == 3 assert stack.top() == 2 assert stack.getMax() == 2 def test_top(): stack = MaxStack() stack.push(10) stack.push(20) assert stack.top() == 20 assert stack.getMax() == 20 def test_getMax(): stack = MaxStack() stack.push(4) stack.push(3) stack.push(2) stack.push(5) assert stack.getMax() == 5 stack.pop() assert stack.getMax() == 4 def test_empty_stack_operations(): stack = MaxStack() assert stack.top() == -1 assert stack.pop() == -1 assert stack.getMax() == -1","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if not self.stack: return -1 # Stack is empty top_element = self.stack.pop() if top_element == self.max_stack[-1]: self.max_stack.pop() return top_element def top(self) -> int: if not self.stack: return -1 # Stack is empty return self.stack[-1] def getMax(self) -> int: if not self.max_stack: return -1 # Stack is empty return self.max_stack[-1]"},{"question":"def longest_subarray_with_k_distinct(arr: List[int], k: int) -> int: Returns the length of the longest subarray that contains at most k distinct integers. If there are multiple such subarrays, returns the length of the first one found. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) == 4 >>> longest_subarray_with_k_distinct([1, 1, 1, 1], 1) == 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 5) == 5 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 10) == 5 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 5], 0) == 0 >>> longest_subarray_with_k_distinct([1, 2, 3, 2, 1, 4, 5, 6, 2], 3) == 5 >>> longest_subarray_with_k_distinct([1], 1) == 1 >>> longest_subarray_with_k_distinct([], 1) == 0 >>> longest_subarray_with_k_distinct([1, 2, 2, 3, 3, 5], 10) == 6","solution":"def longest_subarray_with_k_distinct(arr, k): Returns the length of the longest subarray that contains at most k distinct integers. If there are multiple such subarrays, returns the length of the first one found. from collections import defaultdict window_start = 0 max_length = 0 char_frequency = defaultdict(int) for window_end in range(len(arr)): right_char = arr[window_end] char_frequency[right_char] += 1 while len(char_frequency) > k: left_char = arr[window_start] char_frequency[left_char] -= 1 if char_frequency[left_char] == 0: del char_frequency[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"def find_missing_number(nums): Returns the missing number from the array nums where numbers are in the range [1, n+1]. >>> find_missing_number([1, 2, 4, 5]) 3 >>> find_missing_number([2, 3, 4, 5]) 1 >>> find_missing_number([1, 2, 3, 4]) 5 >>> find_missing_number([1, 2, 3, 4, 5, 7, 8, 9, 10]) 6 >>> find_missing_number([2]) 1","solution":"def find_missing_number(nums): Returns the missing number from the array nums where numbers are in the range [1, n+1]. n = len(nums) expected_sum = (n + 1) * (n + 2) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"from typing import List def maxNonOverlappingProjects(projects: List[List[int]]) -> int: Returns the maximum number of non-overlapping projects that can be assigned to a single worker. >>> maxNonOverlappingProjects([]) 0 >>> maxNonOverlappingProjects([[1, 3]]) 1 >>> maxNonOverlappingProjects([[1, 2], [3, 4]]) 2 >>> maxNonOverlappingProjects([[1, 2], [3, 4], [5, 6], [7, 8]]) 4 >>> maxNonOverlappingProjects([[1, 3], [2, 4], [3, 5], [4, 6]]) 2 >>> maxNonOverlappingProjects([[1, 4], [2, 3], [3, 5], [7, 8]]) 2","solution":"from typing import List def maxNonOverlappingProjects(projects: List[List[int]]) -> int: Returns the maximum number of non-overlapping projects that can be assigned to a single worker. if not projects: return 0 # Sort projects by their end day projects.sort(key=lambda x: x[1]) count = 0 end_time = float('-inf') for project in projects: if project[0] > end_time: count += 1 end_time = project[1] return count"},{"question":"from typing import List def reorganize_string(s: str) -> str: Given a string s consisting of lowercase letters, reorganize the string such that no two adjacent characters are the same. If such a reorganization is possible, return the reorganized string. Otherwise, return an empty string. >>> reorganize_string(\\"aab\\") \\"aba\\" >>> reorganize_string(\\"aaab\\") \\"\\" >>> reorganize_string(\\"a\\") \\"a\\" >>> reorganize_string(\\"aa\\") \\"\\" >>> reorganize_string(\\"aaabbc\\") \\"ababac\\" pass from collections import Counter import heapq # Unit Tests def test_reorganize_string_example1(): assert reorganize_string(\\"aab\\") == \\"aba\\" or reorganize_string(\\"aab\\") == \\"baa\\" def test_reorganize_string_example2(): assert reorganize_string(\\"aaab\\") == \\"\\" def test_reorganize_string_single_char(): assert reorganize_string(\\"a\\") == \\"a\\" def test_reorganize_string_two_chars(): result = reorganize_string(\\"aa\\") assert result == \\"\\" def test_reorganize_string_valid_reorganization(): result = reorganize_string(\\"aaabbc\\") assert result == \\"ababac\\" or result == \\"abacab\\" or result == \\"acabab\\" or result == \\"abacba\\" def test_reorganize_string_complex(): result = reorganize_string(\\"vvvlo\\") assert result == \\"vlvov\\" or result == \\"vovlv\\" or result == \\"lvovv\\"","solution":"from collections import Counter import heapq def reorganize_string(s: str) -> str: Reorganizes the string so that no two adjacent characters are the same. If not possible, returns an empty string. # Count the frequency of each character count = Counter(s) # Max heap to store characters by their frequency max_heap = [(-freq, char) for char, freq in count.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, \\"\\" result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Append current character to result list result.append(char) # Next character becomes the previous if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Update the frequency and character for next round prev_freq, prev_char = freq + 1, char reorganized_str = ''.join(result) # Check if we have successfully reorganized the string or not if len(reorganized_str) != len(s): return \\"\\" return reorganized_str"},{"question":"def count_good_subsequences(s: str) -> int: Returns the number of good subsequences of the string s. A good subsequence contains no two identical characters. :param s: string consisting of digits and lowercase letters :return: number of good subsequences >>> count_good_subsequences(\\"abc\\") == 7 >>> count_good_subsequences(\\"a\\") == 1 >>> count_good_subsequences(\\"abcd\\") == 15 >>> count_good_subsequences(\\"aabc\\") == 7 >>> count_good_subsequences(\\"\\") == 0 >>> count_good_subsequences(\\"a1b2\\") == 15 >>> count_good_subsequences(\\"aaaa\\") == 1","solution":"from itertools import combinations def count_good_subsequences(s): Returns the number of good subsequences of the string s. A good subsequence contains no two identical characters. :param s: string consisting of digits and lowercase letters :return: number of good subsequences unique_characters = set(s) count = 0 n = len(unique_characters) for k in range(1, n + 1): count += len(list(combinations(unique_characters, k))) return count"},{"question":"from typing import List def largest_connected_component(grid: List[List[int]]) -> int: Returns the size of the largest connected component of 1s in a grid. >>> largest_connected_component([]) == 0 >>> largest_connected_component([[0]]) == 0 >>> largest_connected_component([[1]]) == 1 >>> largest_connected_component([ [1, 1], [1, 1] ]) == 4 >>> largest_connected_component([ [0, 0], [0, 0] ]) == 0 >>> largest_connected_component([ [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 0, 0], [1, 0, 0, 0] ]) == 3 >>> largest_connected_component([ [1, 1, 0, 0, 1], [1, 0, 0, 1, 1], [0, 1, 1, 0, 0], [1, 0, 1, 1, 1] ]) == 5","solution":"def largest_connected_component(grid): Returns the size of the largest connected component of 1s in a grid. if not grid: return 0 m, n = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or r >= m or c < 0 or c >= n or grid[r][c] == 0: return 0 grid[r][c] = 0 # Mark the cell as visited by setting it to 0 size = 1 # Explore all 4 possible directions size += dfs(r + 1, c) size += dfs(r - 1, c) size += dfs(r, c + 1) size += dfs(r, c - 1) return size largest_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: largest_size = max(largest_size, dfs(i, j)) return largest_size"},{"question":"from typing import List def min_operations_to_target(nums: List[int], target: int) -> int: Returns the minimum number of operations required to make all elements in nums equal to target. :param nums: List of integers :param target: Target integer :return: Minimum number of operations >>> min_operations_to_target([5, 5, 5], 5) 0 >>> min_operations_to_target([1, 2, 3], 3) 3 >>> min_operations_to_target([-1, -2, -3], -3) 3 >>> min_operations_to_target([-1, 0, 1], 1) 3 >>> min_operations_to_target([1, 2, 3], 100) 294 >>> min_operations_to_target([100, 200, 300], 150) 250","solution":"def min_operations_to_target(nums, target): Returns the minimum number of operations required to make all elements in nums equal to target. :param nums: List of integers :param target: Target integer :return: Minimum number of operations return sum(abs(num - target) for num in nums)"},{"question":"def min_time_to_complete_tasks(tasks: List[int], k: int) -> int: Determines the minimum amount of time required to complete all tasks using the available workers. Parameters: tasks (list of int): A list of integers representing the amount of time needed to complete each task. k (int): The number of workers available to complete these tasks. Returns: int: The minimum amount of time required to complete all tasks. >>> min_time_to_complete_tasks([], 3) == 0 >>> min_time_to_complete_tasks([5], 2) == 5 >>> min_time_to_complete_tasks([3, 2, 8, 4, 3], 2) == 10 >>> min_time_to_complete_tasks([4, 5, 8], 5) == 8 >>> min_time_to_complete_tasks([6, 7, 8, 9], 4) == 9 >>> min_time_to_complete_tasks([10, 20, 30], 1) == 60 >>> min_time_to_complete_tasks([1, 2, 3, 4, 5], 1) == 15 >>> min_time_to_complete_tasks([1, 2, 3], 0) raises ValueError","solution":"import heapq def min_time_to_complete_tasks(tasks, k): Determines the minimum amount of time required to complete all tasks using the available workers. Parameters: tasks (list of int): A list of integers representing the amount of time needed to complete each task. k (int): The number of workers available to complete these tasks. Returns: int: The minimum amount of time required to complete all tasks. if not tasks: return 0 if k <= 0: raise ValueError(\\"Number of workers must be greater than zero\\") # Initialize a heap for tracking worker's availability workers_heap = [0] * k for task in sorted(tasks, reverse=True): min_available_time = heapq.heappop(workers_heap) heapq.heappush(workers_heap, min_available_time + task) return max(workers_heap)"},{"question":"from typing import List def minTotalTravelDistance(grid: List[List[int]]) -> int: Given a grid of size m x n where each cell can have one of three values: - 0 representing an empty cell, - 1 representing a building, - 2 representing an obstacle, Find a location to build a well that will minimize the total travel distance for all the buildings. You can only build the well on an empty cell (0). The total travel distance is defined as the sum of the shortest distances from the well to each building. You may use 4-directional movement (up, down, left, right) to move from one cell to another. Return the minimum total travel distance. If it is not possible to find such a location, return -1. >>> minTotalTravelDistance([[1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]]) 7 >>> minTotalTravelDistance([[1, 1, 2], [2, 1, 2], [2, 2, 2]]) -1 >>> minTotalTravelDistance([[0, 0, 2], [2, 0, 2], [2, 0, 2]]) -1 >>> minTotalTravelDistance([]) -1 >>> minTotalTravelDistance([[2, 2, 0, 2], [2, 1, 0, 2], [2, 2, 0, 2]]) 1 >>> minTotalTravelDistance([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) -1 pass","solution":"from collections import deque def minTotalTravelDistance(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) buildings = [] obstacles = set() # Gather all buildings and obstacles for i in range(m): for j in range(n): if grid[i][j] == 1: buildings.append((i, j)) elif grid[i][j] == 2: obstacles.add((i, j)) if not buildings: return -1 distance_sum = [[0] * n for _ in range(m)] reach = [[0] * n for _ in range(m)] directions = [(0,1), (1,0), (0,-1), (-1,0)] def bfs(start_i, start_j): visited = [[False] * n for _ in range(m)] queue = deque([(start_i, start_j, 0)]) visited[start_i][start_j] = True while queue: i, j, dist = queue.popleft() distance_sum[i][j] += dist reach[i][j] += 1 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj] and grid[ni][nj] == 0: visited[ni][nj] = True queue.append((ni, nj, dist + 1)) # Run BFS from each building for bi, bj in buildings: bfs(bi, bj) min_distance = float('inf') for i in range(m): for j in range(n): if grid[i][j] == 0 and reach[i][j] == len(buildings): min_distance = min(min_distance, distance_sum[i][j]) return min_distance if min_distance != float('inf') else -1"},{"question":"def longest_palindromic_subsequence_lengths(s: str) -> List[int]: You are given a string \`s\` consisting of lowercase English letters. A palindromic subsequence is a subsequence (i.e., sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements) of \`s\` that reads the same forward and backward. The length of the string \`s\` is denoted by \`n\`. Now, for every \`i\` from \`1\` to \`n\`, you have to find the length of the longest palindromic subsequence that can be obtained by considering only the first \`i\` characters of the string \`s\`. Return an array of integers \`result\` where \`result[i]\` is the length of the longest palindromic subsequence that can be formed from the first \`i\` characters of the string \`s\`. Args: s (str): A string consisting of lowercase English letters Returns: List[int]: An array of integers representing the length of the longest palindromic subsequence for each prefix of the string \`s\`. Examples: >>> longest_palindromic_subsequence_lengths(\\"a\\") [1] >>> longest_palindromic_subsequence_lengths(\\"aaaaa\\") [1, 2, 3, 4, 5] >>> longest_palindromic_subsequence_lengths(\\"abcba\\") [1, 1, 1, 3, 5] >>> longest_palindromic_subsequence_lengths(\\"abca\\") [1, 1, 1, 3] >>> longest_palindromic_subsequence_lengths(\\"abcdefgh\\") [1, 1, 1, 1, 1, 1, 1, 1]","solution":"def longest_palindromic_subsequence_lengths(s): n = len(s) result = [0] * n for i in range(n): subsequence = s[:i+1] result[i] = longest_palindromic_subsequence(subsequence) return result def longest_palindromic_subsequence(subsequence): m = len(subsequence) dp = [[0] * m for _ in range(m)] for i in range(m): dp[i][i] = 1 for length in range(2, m+1): for start in range(m-length+1): end = start + length - 1 if subsequence[start] == subsequence[end]: dp[start][end] = dp[start+1][end-1] + 2 else: dp[start][end] = max(dp[start][end-1], dp[start+1][end]) return dp[0][m-1]"},{"question":"def smallest_configuration(configs: List[str]) -> str: Returns the lexicographically smallest configuration string that can be formed by concatenating exactly one character from each string in configs. >>> smallest_configuration([\\"A\\", \\"B\\", \\"C\\"]) \\"ABC\\" >>> smallest_configuration([\\"AA\\", \\"BB\\", \\"CC\\"]) \\"ABC\\" >>> smallest_configuration([\\"BAC\\", \\"CBA\\", \\"ACB\\"]) \\"AAA\\" >>> smallest_configuration([\\"B\\"]) \\"B\\" >>> smallest_configuration([]) \\"\\" >>> smallest_configuration([\\"ABCD\\", \\"EFGH\\", \\"IJKL\\", \\"MNOP\\"]) \\"AEIM\\" >>> smallest_configuration([\\"AAA\\", \\"BBB\\", \\"CCC\\"]) \\"ABC\\" >>> smallest_configuration([\\"CBA\\", \\"B\\", \\"A\\"]) \\"ABA\\"","solution":"def smallest_configuration(configs): Returns the lexicographically smallest configuration string that can be formed by concatenating exactly one character from each string in configs. smallest_config = [] for characters in configs: smallest_char = min(characters) smallest_config.append(smallest_char) return ''.join(smallest_config)"},{"question":"import heapq from typing import List def min_cost_to_connect_ropes(nums: List[int]) -> int: Returns the minimum cost to connect all the ropes into one rope. Args: nums (List[int]): A list of integers representing the lengths of ropes. Returns: int: The minimum cost to connect all the ropes into one rope. >>> min_cost_to_connect_ropes([4, 3, 2, 6]) 29 >>> min_cost_to_connect_ropes([10]) 0 >>> min_cost_to_connect_ropes([]) 0 >>> min_cost_to_connect_ropes([1, 1, 1, 1]) 8 >>> min_cost_to_connect_ropes([1000, 2000, 3000, 4000]) 19000 >>> min_cost_to_connect_ropes([5, 9]) 14","solution":"import heapq def min_cost_to_connect_ropes(nums): Returns the minimum cost to connect all the ropes into one rope. Args: nums (List[int]): A list of integers representing the lengths of ropes. Returns: int: The minimum cost to connect all the ropes into one rope. if not nums: return 0 heapq.heapify(nums) total_cost = 0 while len(nums) > 1: first_min = heapq.heappop(nums) second_min = heapq.heappop(nums) cost = first_min + second_min total_cost += cost heapq.heappush(nums, cost) return total_cost"},{"question":"def firstNonRepeatingCharacter(s: str) -> int: Determine the first non-repeating character in the string and return its index. If all characters repeat or the string is empty, return -1. >>> firstNonRepeatingCharacter(\\"leetcode\\") == 0 >>> firstNonRepeatingCharacter(\\"loveleetcode\\") == 2 >>> firstNonRepeatingCharacter(\\"aabb\\") == -1 >>> firstNonRepeatingCharacter(\\"\\") == -1 >>> firstNonRepeatingCharacter(\\"abcabc\\") == -1 >>> firstNonRepeatingCharacter(\\"aabccbd\\") == 6 >>> firstNonRepeatingCharacter(\\"a\\") == 0 >>> firstNonRepeatingCharacter(\\"z\\") == 0 >>> firstNonRepeatingCharacter(\\"aa\\") == -1 >>> firstNonRepeatingCharacter(\\"bb\\") == -1 >>> firstNonRepeatingCharacter(\\"cccc\\") == -1 >>> firstNonRepeatingCharacter(\\"aA\\") == 0 >>> firstNonRepeatingCharacter(\\"abAa\\") == 1 >>> firstNonRepeatingCharacter(\\"abAAb\\") == 0","solution":"def firstNonRepeatingCharacter(s): Returns the index of the first non-repeating character in the given string, or -1 if there is no such character. # Record the frequency of each character in the string char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Iterate through the string and return the index of the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"from typing import List def lexicographically_smallest_string(s: str, k: int) -> str: Return the lexicographically smallest string after performing the operation k times. Choose any one character from the string and move it to the end of the string exactly k times. >>> lexicographically_smallest_string(\\"cba\\", 1) \\"acb\\" >>> lexicographically_smallest_string(\\"ba\\", 1) \\"ab\\" >>> lexicographically_smallest_string(\\"abc\\", 1) \\"abc\\" >>> lexicographically_smallest_string(\\"bcdaef\\", 1) \\"aefbcd\\"","solution":"def lexicographically_smallest_string(s, k): if k == 1: # Generate all rotations of the string and return the lexicographically smallest one candidates = [s[i:] + s[:i] for i in range(len(s))] return min(candidates) else: # If k > 1, we can fully sort the string to get the smallest lexicographic order return ''.join(sorted(s))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: Removes the n-th node from the end of the linked list and returns its head. If n is greater than the length of the list, removes the head node. def list_to_array(head): Helper function to convert linked list to array for easy comparison. array = [] while head: array.append(head.val) head = head.next return array def array_to_list(array): Helper function to convert array to linked list. dummy = ListNode() current = dummy for val in array: current.next = ListNode(val) current = current.next return dummy.next def test_remove_nth_from_end(): ll = array_to_list([1, 2, 3, 4, 5]) new_head = removeNthFromEnd(ll, 2) assert list_to_array(new_head) == [1, 2, 3, 5] def test_remove_nth_from_end_n_greater_than_length(): ll = array_to_list([1, 2, 3]) new_head = removeNthFromEnd(ll, 5) assert list_to_array(new_head) == [2, 3] def test_remove_nth_from_end_last_element(): ll = array_to_list([1, 2, 3]) new_head = removeNthFromEnd(ll, 1) assert list_to_array(new_head) == [1, 2] def test_remove_nth_from_end_single_element(): ll = array_to_list([1]) new_head = removeNthFromEnd(ll, 1) assert list_to_array(new_head) == [] def test_remove_nth_from_end_two_elements(): ll = array_to_list([1, 2]) new_head = removeNthFromEnd(ll, 1) assert list_to_array(new_head) == [1] new_head = removeNthFromEnd(array_to_list([1, 2]), 2) assert list_to_array(new_head) == [2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head, n): Removes the n-th node from the end of the linked list and returns its head. If n is greater than the length of the list, removes the head node. dummy = ListNode(0, head) first = dummy second = dummy # Move first n+1 steps for _ in range(n + 1): if first.next is None: # If n is greater than the length of the list, remove the head dummy.next = head.next return dummy.next first = first.next # Move first to the end, maintaining the gap while first: first = first.next second = second.next # Skip the desired node second.next = second.next.next return dummy.next"},{"question":"def max_profit(k: int, arr: List[int]) -> int: You are given an array of integers \`arr\` representing the prices of various stocks on different days. You are also given an integer \`k\` representing the maximum number of transactions you can make. A transaction consists of buying and then selling one share of a stock. Write a function that finds the maximum profit you can achieve given that you can complete at most \`k\` transactions. Return an integer representing the maximum profit obtainable. Note: - You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again). - The order of transactions matters (i.e., selling a stock before buying another is necessary). Example: >>> max_profit(2, [3, 2, 6, 5, 0, 3]) 7 >>> max_profit(0, [1, 2, 3, 4, 5]) 0","solution":"def max_profit(k, arr): n = len(arr) if n == 0: return 0 # If k is greater than n//2, it is equivalent to unlimited transactions. if k >= n // 2: return sum( max(arr[i + 1] - arr[i], 0) for i in range(n - 1) ) profits = [[0] * n for _ in range(k + 1)] for t in range(1, k + 1): max_diff = -arr[0] for d in range(1, n): profits[t][d] = max(profits[t][d - 1], arr[d] + max_diff) max_diff = max(max_diff, profits[t - 1][d] - arr[d]) return profits[k][-1]"},{"question":"def repeat_characters(s: str, n: int) -> str: Constructs a new string by repeating each character in \`s\` exactly \`n\` times consecutively. If \`n\` is zero, an empty string is returned. Args: s (str): The input string consisting of lowercase English letters. n (int): The number of times to repeat each character. Returns: str: The newly constructed string with each character repeated \`n\` times. >>> repeat_characters(\\"a\\", 3) \\"aaa\\" >>> repeat_characters(\\"b\\", 0) \\"\\" >>> repeat_characters(\\"abc\\", 2) \\"aabbcc\\"","solution":"def repeat_characters(s, n): Constructs a new string by repeating each character in \`s\` exactly \`n\` times consecutively. If \`n\` is zero, an empty string is returned. Args: s (str): The input string consisting of lowercase English letters. n (int): The number of times to repeat each character. Returns: str: The newly constructed string with each character repeated \`n\` times. if n == 0: return \\"\\" return ''.join(char * n for char in s)"},{"question":"def max_non_overlapping_tasks(tasks: List[List[int]]) -> int: Returns the maximum number of non-overlapping tasks that can be scheduled. Args: tasks (List[List[int]]): A list of tasks where each task is represented as a list with start and end times. Returns: int: The maximum number of non-overlapping tasks. Examples: >>> max_non_overlapping_tasks([[1, 3], [2, 4], [3, 5]]) 2 >>> max_non_overlapping_tasks([[1, 2]]) 1 >>> max_non_overlapping_tasks([]) 0 >>> max_non_overlapping_tasks([[1, 4], [2, 5], [3, 6]]) 1 >>> max_non_overlapping_tasks([[1, 2], [2, 3], [3, 4], [4, 5]]) 4 >>> max_non_overlapping_tasks([[1, 2], [3, 4], [0, 6], [5, 7], [8, 9], [5, 9]]) 4 # Your implementation here","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. # Sort the tasks by their end time tasks.sort(key=lambda x: x[1]) count = 0 last_end_time = float('-inf') for start, end in tasks: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def reverse_words(sentence: str) -> str: Reverse the order of the words in the sentence while maintaining the relative order of the spaces. >>> reverse_words(\\"hello\\") 'hello' >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\" hello world \\") ' world hello ' >>> reverse_words(\\" \\") ' ' >>> reverse_words(\\"hello\\") 'hello' >>> reverse_words(\\" a b c d e \\") ' e d c b a '","solution":"def reverse_words(sentence): Reverses the order of words in the sentence while maintaining the relative order of the spaces. # Split the sentence into words words = sentence.split() # Reverse the list of words reversed_words = words[::-1] # Split the sentence into spaces spaces = sentence.split(\\" \\") # Create an index for the words word_index = 0 # Result list to aggregate the result along with spaces result = [] for space in spaces: if space == '': # If there's an empty space, add it back as multiple spaces result.append(space) else: # Add the next reversed word result.append(reversed_words[word_index]) word_index += 1 return \\" \\".join(result)"},{"question":"def min_diff_in_subarray(arr, k): Returns the minimum possible difference between the maximum and minimum values in any subarray of size k. >>> min_diff_in_subarray([1, 3, 6, 4, 1, 2], 2) 0 >>> min_diff_in_subarray([1, 3, 6, 4, 1, 2], 3) 1 >>> min_diff_in_subarray([1, 3, 6, 4, 1, 2], 6) 5 >>> min_diff_in_subarray([], 3) 0 >>> min_diff_in_subarray([7], 1) 0 >>> min_diff_in_subarray([1, 2, 3], 4) 0 >>> min_diff_in_subarray([10, 1, 2, 5, 7], 2) 1 >>> min_diff_in_subarray([4, 10, 8, 6], 4) 6 # Implementation goes here","solution":"def min_diff_in_subarray(arr, k): Returns the minimum possible difference between the maximum and minimum values in any subarray of size k. if not arr or k <= 0 or k > len(arr): return 0 min_diff = float('inf') # Sort the array first to consider all potential subarrays of size k sorted_arr = sorted(arr) # Slide window across sorted array to find minimum diff for i in range(len(sorted_arr) - k + 1): current_diff = sorted_arr[i + k - 1] - sorted_arr[i] min_diff = min(min_diff, current_diff) return min_diff"},{"question":"def partition_labels(s: str) -> List[str]: Partition the string s into the maximum number of substrings such that no letter appears in more than one substring. :param s: A string consisting of lowercase English letters. :return: A list of substrings meeting the condition. >>> partition_labels(\\"abac\\") == [\\"aba\\", \\"c\\"] >>> partition_labels(\\"abaccbdeffed\\") == [\\"abaccb\\", \\"deffed\\"]","solution":"def partition_labels(s): Partition the string s into the maximum number of substrings such that no letter appears in more than one substring. :param s: A string consisting of lowercase English letters. :return: A list of substrings meeting the condition. last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start = end = 0 for i, char in enumerate(s): end = max(end, last_occurrence[char]) if i == end: partitions.append(s[start:end + 1]) start = i + 1 return partitions"},{"question":"def min_operations(start: int, end: int) -> int: Returns the minimum number of operations needed to transform \`start\` into \`end\`. The operations allowed are multiplying the current number by 2 or subtracting 1. >>> min_operations(1, 10) == 6 >>> min_operations(1, 16) == 4 >>> min_operations(2, 16) == 3 >>> min_operations(10, 5) == 5 >>> min_operations(7, 4) == 3 >>> min_operations(3, 10) == 3 >>> min_operations(5, 8) == 2 >>> min_operations(4, 7) == 2 >>> min_operations(5, 5) == 0 >>> min_operations(1, 1) == 0","solution":"from collections import deque def min_operations(start, end): Returns the minimum number of operations needed to transform \`start\` into \`end\`. The operations allowed are multiplying the current number by 2 or subtracting 1. # Edge case: if start is already equal to end if start == end: return 0 # This set keeps track of visited numbers to avoid cycles visited = set() queue = deque([(start, 0)]) # queue of tuples (current number, steps taken) while queue: current, steps = queue.popleft() if current in visited: continue visited.add(current) # If we reached the target if current == end: return steps # Add the results of possible operations to the queue if current * 2 <= 2 * end: # to avoid redundant calculations queue.append((current * 2, steps + 1)) if current - 1 > 0: queue.append((current - 1, steps + 1)) # If somehow it's impossible to reach \`end\`, but this should never happen with rational constraints return -1"},{"question":"from typing import List def maxEnvelopes(envelopes: List[List[int]]) -> int: Finds the maximum number of envelopes you can Russian doll (put one inside the other). Args: envelopes: List of lists, where each list contains width and height of an envelope. Returns: An integer representing the maximum number of envelopes you can nest. pass from solution import maxEnvelopes def test_maxEnvelopes_no_envelopes(): assert maxEnvelopes([]) == 0 def test_maxEnvelopes_single_envelope(): assert maxEnvelopes([[1, 1]]) == 1 def test_maxEnvelopes_non_nestable(): assert maxEnvelopes([[5, 4], [6, 4], [6, 7], [2, 3]]) == 3 def test_maxEnvelopes_mixed_envelopes(): assert maxEnvelopes([[2, 3], [5, 4], [6, 7], [6, 4], [7, 8], [3, 8]]) == 4 def test_maxEnvelopes_all_nestable(): assert maxEnvelopes([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) == 5 def test_maxEnvelopes_no_possible_nesting(): assert maxEnvelopes([[1, 1], [1, 1], [1, 1], [1, 1]]) == 1","solution":"from bisect import bisect_left def maxEnvelopes(envelopes): Finds the maximum number of envelopes you can Russian doll (put one inside the other). Args: envelopes: List of lists, where each list contains width and height of an envelope. Returns: An integer representing the maximum number of envelopes you can nest. if not envelopes: return 0 envelopes.sort(key=lambda x: (x[0], -x[1])) heights = [envelope[1] for envelope in envelopes] dp = [] for height in heights: index = bisect_left(dp, height) if index == len(dp): dp.append(height) else: dp[index] = height return len(dp)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes duplicates from a singly linked list. :param head: ListNode representing the head of the linked list :return: ListNode representing the head of the modified linked list with duplicates removed >>> linked_list_to_list(remove_duplicates(None)) == [] >>> linked_list_to_list(remove_duplicates(ListNode(1))) == [1] >>> linked_list_to_list(remove_duplicates(ListNode(1, ListNode(2, ListNode(3))))) == [1, 2, 3] >>> linked_list_to_list(remove_duplicates(ListNode(1, ListNode(2, ListNode(2, ListNode(3, ListNode(3, ListNode(3, ListNode(4))))))))) == [1, 2, 3, 4] >>> linked_list_to_list(remove_duplicates(ListNode(1, ListNode(1, ListNode(1, ListNode(1)))))) == [1] >>> linked_list_to_list(remove_duplicates(ListNode(1, ListNode(2, ListNode(1, ListNode(2, ListNode(3, ListNode(3, ListNode(2))))))))) == [1, 2, 3] pass def linked_list_to_list(head): Helper function to convert linked list to Python list for easy comparison in tests result = [] while head: result.append(head.val) head = head.next return result","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): Removes duplicates from a singly linked list. :param head: ListNode representing the head of the linked list :return: ListNode representing the head of the modified linked list with duplicates removed if head is None: return None current = head values_seen = set([current.val]) while current.next: if current.next.val in values_seen: current.next = current.next.next else: values_seen.add(current.next.val) current = current.next return head"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Calculate the maximum profit with at most two transactions. :param prices: List of stock prices :return: Maximum profit possible with two transactions >>> maxProfit([]) == 0 >>> maxProfit([100]) == 0 >>> maxProfit([5, 4, 3, 2, 1]) == 0 >>> maxProfit([1, 2, 3, 4, 5]) == 4 >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) == 6 >>> maxProfit([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) == 13 >>> maxProfit([7, 7, 7, 7, 7, 7, 7]) == 0 >>> maxProfit([3, 2, 6, 5, 0, 3]) == 7","solution":"def maxProfit(prices): Calculate the maximum profit with at most two transactions. :param prices: List of stock prices :return: Maximum profit possible with two transactions n = len(prices) if n == 0: return 0 # Initializing arrays to store the maximum profit profit1 = [0] * n profit2 = [0] * n # Forward pass: Maximum profit if only one transaction is allowed min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit1[i] = max(profit1[i - 1], prices[i] - min_price) # Backward pass: Maximum profit if the second transaction is considered max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) profit2[i] = max(profit2[i + 1], max_price - prices[i]) # Combine the results of two transactions max_profit = 0 for i in range(n): max_profit = max(max_profit, profit1[i] + profit2[i]) return max_profit"},{"question":"def minimize_max_difference(students, k): Returns the minimized difference between the maximum and minimum skill levels among k groups. >>> minimize_max_difference([1, 3, 6, 9], 2) == 3 >>> minimize_max_difference([1, 2, 3, 4], 1) == 3 >>> minimize_max_difference([10, 20, 30, 40], 4) == 0 >>> minimize_max_difference([5, 5, 5, 5], 3) == 0 >>> minimize_max_difference([1, 100, 1000, 10000], 2) == 999 >>> minimize_max_difference([5, 8, 12, 14], 5) == 0","solution":"def minimize_max_difference(students, k): Returns the minimized difference between the maximum and minimum skill levels among k groups. students.sort() def is_valid_max_diff(mid): count = 1 min_val = students[0] for skill in students: if skill - min_val > mid: count += 1 min_val = skill return count <= k low, high = 0, students[-1] - students[0] while low < high: mid = (low + high) // 2 if is_valid_max_diff(mid): high = mid else: low = mid + 1 return low"},{"question":"def longest_string_with_limit(s: str, k: int) -> int: Returns the length of the longest possible resultant string such that the frequency of each character in the new string is at most k. :param s: The input string consisting of lowercase letters. :param k: The maximum allowed frequency for any character. :return: Length of the longest possible resultant string. >>> longest_string_with_limit(\\"aabbcc\\", 1) 3 >>> longest_string_with_limit(\\"aabbcc\\", 2) 6 >>> longest_string_with_limit(\\"aaaa\\", 1) 1 >>> longest_string_with_limit(\\"aaaa\\", 2) 2 >>> longest_string_with_limit(\\"abbabbabba\\", 3) 6 >>> longest_string_with_limit(\\"abcd\\", 1) 4","solution":"from collections import Counter def longest_string_with_limit(s, k): Returns the length of the longest possible resultant string such that the frequency of each character in the new string is at most k. :param s: The input string consisting of lowercase letters. :param k: The maximum allowed frequency for any character. :return: Length of the longest possible resultant string. counter = Counter(s) # Get the frequency of each character length = 0 for char, freq in counter.items(): length += min(freq, k) # Add min(freq, k) to the total length return length"},{"question":"def multiply_matrices(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: Multiply two sparse matrices mat1 and mat2 represented by two 2D lists. A sparse matrix is a matrix in which most of the elements are zero. Each of the two matrices is of dimension m x n. If they cannot be multiplied due to dimension mismatch, return an empty list. >>> multiply_matrices([[1, 0, 0], [-1, 0, 3]], [[7, 0, 0], [0, 0, 0], [0, 0, 1]]) [[7, 0, 0], [-7, 0, 3]] >>> multiply_matrices([[1, 2], [3, 4]], [[5, 6, 7]]) [] >>> multiply_matrices([[1, 0, 0], [0, 0, 0]], [[0, 0], [0, 0], [0, 0]]) [[0, 0], [0, 0]] >>> multiply_matrices([[2]], [[3]]) [[6]] >>> multiply_matrices([[1, 0, 2], [0, 3, 0]], [[0, 2], [1, 0], [4, 5]]) [[8, 12], [3, 0]]","solution":"def multiply_matrices(mat1, mat2): m, n = len(mat1), len(mat1[0]) k, p = len(mat2), len(mat2[0]) if n != k: return [] # Initialize the result matrix with zeros result = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(n): if mat1[i][j] != 0: for l in range(p): result[i][l] += mat1[i][j] * mat2[j][l] return result"},{"question":"from typing import List def combinationSum(candidates: List[int], target: int) -> List[List[int]]: Return all unique combinations of candidates where the chosen numbers sum to target. Each number in candidates can be used multiple times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. >>> combinationSum([2], 4) [[2, 2]] >>> combinationSum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combinationSum([2, 4, 6], 5) [] >>> combinationSum([2, 3], 6) [[2, 2, 2], [3, 3]] >>> combinationSum([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]]","solution":"from typing import List def combinationSum(candidates: List[int], target: int) -> List[List[int]]: def backtrack(start, current_combination, current_sum): if current_sum == target: result.append(list(current_combination)) return if current_sum > target: return for i in range(start, len(candidates)): current_combination.append(candidates[i]) backtrack(i, current_combination, current_sum + candidates[i]) current_combination.pop() result = [] candidates.sort() backtrack(0, [], 0) return result"},{"question":"from typing import List def canThreePartsEqualSum(arr: List[int]) -> bool: Given an array of integers, determine whether the array can be partitioned into three non-empty contiguous subarrays such that each subarray has an equal sum. Return true if such a partitioning exists, otherwise return false. >>> canThreePartsEqualSum([0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]) True >>> canThreePartsEqualSum([0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]) False >>> canThreePartsEqualSum([1]) False >>> canThreePartsEqualSum([1, 2, 3, 4, 5, 6]) False >>> canThreePartsEqualSum([3, 3, 6, 5, -2, 2, 5, 1, -9, 4]) True","solution":"def canThreePartsEqualSum(arr): Determines if the array can be partitioned into three non-empty contiguous subarrays that have an equal sum. :param arr: List[int] - list of integers :return: bool - True if such partitioning exists, otherwise False total_sum = sum(arr) if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum = 0 count = 0 for num in arr: current_sum += num if current_sum == target_sum: count += 1 current_sum = 0 if count == 3: return True return False"},{"question":"def pass_or_fail(grades, threshold): Determines whether each student passed based on their grade and the threshold. Parameters: grades (list of int): List of student grades. threshold (int): The passing grade threshold. Returns: list of str: List of \\"pass\\" or \\"fail\\" corresponding to each student's result. >>> pass_or_fail([70, 80, 90], 50) ['pass', 'pass', 'pass'] >>> pass_or_fail([30, 40, 49], 50) ['fail', 'fail', 'fail'] >>> pass_or_fail([30, 50, 70], 50) ['fail', 'pass', 'pass'] >>> pass_or_fail([], 50) [] >>> pass_or_fail([50], 50) ['pass']","solution":"def pass_or_fail(grades, threshold): Determines whether each student passed based on their grade and the threshold. Parameters: grades (list of int): List of student grades. threshold (int): The passing grade threshold. Returns: list of str: List of \\"pass\\" or \\"fail\\" corresponding to each student's result. return [\\"pass\\" if grade >= threshold else \\"fail\\" for grade in grades]"},{"question":"from typing import List def max_sum_subarray(arr: List[int], k: int) -> int: Returns the maximum sum of any continuous subarray of length \`k\`. If the length of the array is less than \`k\`, return \`0\`. >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) == 9 >>> max_sum_subarray([5], 1) == 5 >>> max_sum_subarray([-2, -1, -3, -4], 2) == -3 >>> max_sum_subarray([1, 2], 3) == 0 >>> max_sum_subarray([1, 2, 3, 4], 4) == 10 >>> max_sum_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 35 >>> max_sum_subarray([1, 2, 2, 1, 2, 2, 1], 2) == 4 >>> max_sum_subarray([], 1) == 0 >>> max_sum_subarray([1, 2, 3], 0) == 0 >>> max_sum_subarray([3, -2, 7, 2], 1) == 7 pass","solution":"def max_sum_subarray(arr, k): Returns the maximum sum of any continuous subarray of length \`k\`. If the length of the array is less than \`k\`, return \`0\`. :param arr: List[int] - Array of integers. :param k: int - Length of the subarray. :return: int - Maximum sum of the continuous subarray of length \`k\`. n = len(arr) if n < k: return 0 # Compute the sum of the first 'k' elements max_sum = sum(arr[:k]) current_sum = max_sum # Slide through the array adjusting the window of size 'k' for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the array can be partitioned into two non-empty subarrays with equal sums. >>> can_partition([1, 2, 3, 4, 5, 5]) True >>> can_partition([1, 2, 1, 2, 1, 1]) True >>> can_partition([3, 3, 3, 3]) True >>> can_partition([1, 2, 3, 4, 5]) False >>> can_partition([1, 1, 1, 1, 1, 1, 9]) False >>> can_partition([2]) False >>> can_partition([2, 2]) True >>> can_partition([2, 1]) False >>> can_partition([1]*1000 + [500]*2) True","solution":"def can_partition(nums): Determine if the array can be partitioned into two non-empty subarrays with equal sums. :param nums: List[int] - The array of collected apples :return: bool - True if partitioning is possible, False otherwise total_sum = sum(nums) # If the total sum is odd, it's impossible to partition it into two equal parts if total_sum % 2 != 0: return False subarray_sum = total_sum // 2 current_sum = 0 # Iterate through the array to find possible partitions for num in nums: current_sum += num if current_sum == subarray_sum: return True return False"},{"question":"def trap_rain_water(height: List[int]) -> int: Calculate the total amount of trapped rainwater given the heights of the bars. Args: height: List[int] - a list of non-negative integers representing the height of the bars. Returns: int - the total units of trapped rainwater.","solution":"def trap_rain_water(height): Calculate the total amount of trapped rainwater given the heights of the bars. Args: height: List[int] - a list of non-negative integers representing the height of the bars. Returns: int - the total units of trapped rainwater. if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) total_water += left_max - height[left] else: right -= 1 right_max = max(right_max, height[right]) total_water += right_max - height[right] return total_water"},{"question":"from typing import List def findAndReplacePattern(words: List[str], pattern: str) -> List[str]: Find all the words in the list that match the given pattern. >>> findAndReplacePattern([\\"mee\\"], \\"abb\\") == [\\"mee\\"] >>> findAndReplacePattern([\\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") == [\\"mee\\", \\"aqq\\"] >>> findAndReplacePattern([\\"abc\\", \\"xyz\\", \\"def\\"], \\"abb\\") == [] >>> findAndReplacePattern([\\"aaa\\", \\"bbb\\", \\"ccc\\"], \\"aaa\\") == [\\"aaa\\", \\"bbb\\", \\"ccc\\"] >>> findAndReplacePattern([], \\"abc\\") == [] >>> findAndReplacePattern([\\"abcd\\", \\"abc\\"], \\"ab\\") == []","solution":"from typing import List def findAndReplacePattern(words: List[str], pattern: str) -> List[str]: def normalize(word): mapping = {} normalized = [] next_char = 'a' for char in word: if char not in mapping: mapping[char] = next_char next_char = chr(ord(next_char) + 1) normalized.append(mapping[char]) return ''.join(normalized) normalized_pattern = normalize(pattern) return [word for word in words if normalize(word) == normalized_pattern]"},{"question":"def min_moves_to_identical(arr1, arr2): Returns the minimum number of moves required to make arr1 and arr2 identical. If not possible, returns -1. pass def test_example_cases(): assert min_moves_to_identical([1, 2, 3], [2, 3, 1]) == 2 assert min_moves_to_identical([1, 2, 3], [1, 2, 3]) == 0 assert min_moves_to_identical([1, 3, 5], [1, 2, 3]) == -1 def test_identical_arrays(): assert min_moves_to_identical([1, 2, 3, 4], [1, 2, 3, 4]) == 0 def test_non_matching_elements(): assert min_moves_to_identical([1, 2, 3, 4], [5, 6, 7, 8]) == -1 assert min_moves_to_identical([1, 2, 3], [4, 5, 6]) == -1 def test_partial_overlap(): assert min_moves_to_identical([1, 2, 3, 4], [2, 3, 1, 4]) == 2 assert min_moves_to_identical([1, 3, 5, 7], [3, 5, 1, 7]) == 2 def test_edge_cases(): assert min_moves_to_identical([], []) == 0 assert min_moves_to_identical([1], [1]) == 0 assert min_moves_to_identical([1], [2]) == -1 assert min_moves_to_identical([1, 3], [2, 3]) == -1","solution":"def min_moves_to_identical(arr1, arr2): Returns the minimum number of moves required to make arr1 and arr2 identical. If not possible, returns -1. # Check if the arrays have same elements with same frequency if sorted(arr1) != sorted(arr2): return -1 # Find Longest Common Subsequence (LCS) length len1, len2 = len(arr1), len(arr2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) lcs_length = dp[len1][len2] # Moves required to matching up both arrays: moves_required = (len1 - lcs_length) + (len2 - lcs_length) return moves_required"},{"question":"from typing import List def count_good_sentences(sentences: List[str]) -> int: Returns the number of good sentences in the array \`sentences\`. A sentence is classified as \\"good\\" if it contains an even number of words. >>> count_good_sentences([\\"hello world\\", \\"this is a test\\", \\"good day\\"]) == 3 >>> count_good_sentences([\\"hello\\", \\"this is a\\", \\"good\\"]) == 0 >>> count_good_sentences([\\"hello\\", \\"this is a test\\", \\"good day\\", \\"bad\\"]) == 2 >>> count_good_sentences([]) == 0 >>> count_good_sentences([\\"\\"]) == 1 >>> count_good_sentences([\\"a\\", \\"b\\", \\"c\\"]) == 0","solution":"def count_good_sentences(sentences): Returns the number of good sentences in the array \`sentences\`. A sentence is classified as \\"good\\" if it contains an even number of words. def is_good(sentence): words = sentence.split() return len(words) % 2 == 0 return sum(is_good(sentence) for sentence in sentences)"},{"question":"def max_visible_buildings(heights: List[int]) -> int: Determine the maximum number of buildings that can be seen in a single view from the leftmost side of the street based on the given rule. A building is visible if: - each building must be shorter than the building immediately before it, OR - each building must be taller than the building immediately after it AND is not blocked by any taller buildings before it in the line. >>> max_visible_buildings([1, 2, 3, 4, 5]) 5 >>> max_visible_buildings([5, 4, 3, 2, 1]) 5 >>> max_visible_buildings([1, 3, 2, 4, 3]) 5 >>> max_visible_buildings([2, 2, 2, 2, 2]) 1 >>> max_visible_buildings([3, 1, 4, 2, 5]) 5 >>> max_visible_buildings([3]) 1 >>> max_visible_buildings([1, 2]) 2 >>> max_visible_buildings([2, 1]) 2 >>> max_visible_buildings([]) 0","solution":"def max_visible_buildings(heights): Determine the maximum number of buildings that can be seen in a single view from the leftmost side of the street based on the given rule. A building is visible if: - each building must be shorter than the building immediately before it, OR - each building must be taller than the building immediately after it AND is not blocked by any taller buildings before it in the line. if not heights: return 0 n = len(heights) visible_count = 1 # The first building is always visible for i in range(1, n): if heights[i] > heights[i-1]: visible_count += 1 elif heights[i] < heights[i-1]: visible_count += 1 else: continue return visible_count"},{"question":"def longest_common_substring(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. Args: s1 (str): The first string. s2 (str): The second string. Returns: int: The length of the longest common substring. Examples: >>> longest_common_substring(\\"abc\\", \\"def\\") 0 >>> longest_common_substring(\\"abc\\", \\"a\\") 1 >>> longest_common_substring(\\"abcde\\", \\"abfghcde\\") 3 >>> longest_common_substring(\\"abc\\", \\"abc\\") 3 >>> longest_common_substring(\\"\\", \\"abc\\") 0 >>> longest_common_substring(\\"abc\\", \\"\\") 0 >>> longest_common_substring(\\"\\", \\"\\") 0 >>> longest_common_substring(\\"xyzabc\\", \\"defabc\\") 3","solution":"def longest_common_substring(s1, s2): Returns the length of the longest common substring between s1 and s2. if not s1 or not s2: return 0 m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] longest_len = 0 for i in range(1, m + 1): for j in range(1, n + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 longest_len = max(longest_len, dp[i][j]) else: dp[i][j] = 0 return longest_len"},{"question":"def unique_paths_dag(n: int, edges: List[Tuple[int, int]], start: int, end: int) -> int: Given a directed acyclic graph (DAG) represented by a list of edges where each edge is a pair [u, v] indicating there is an edge from node u to node v, compute the number of unique paths from a given start node to a given end node. Nodes are labeled from 0 to n-1 where n is the number of nodes. >>> unique_paths_dag(5, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4)], 0, 4) 2 >>> unique_paths_dag(4, [(0, 1), (1, 2), (2, 3)], 0, 3) 1 >>> unique_paths_dag(4, [(0, 1), (2, 3)], 0, 3) 0 >>> unique_paths_dag(5, [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (1, 4)], 0, 4) 3 >>> unique_paths_dag(4, [(0, 1), (1, 2), (2, 3)], 3, 3) 1 >>> unique_paths_dag(4, [], 1, 3) 0 pass # your implementation here","solution":"def unique_paths_dag(n, edges, start, end): from collections import defaultdict, deque # Build the adjacency list for the DAG graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Function to perform topological sorting using Kahn's Algorithm def topological_sort(): in_degree = [0] * n for u in graph: for v in graph[u]: in_degree[v] += 1 queue = deque([i for i in range(n) if in_degree[i] == 0]) topo_order = [] while queue: node = queue.popleft() topo_order.append(node) for neighbour in graph[node]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: queue.append(neighbour) return topo_order topo_order = topological_sort() dp = [0] * n dp[start] = 1 for node in topo_order: for neighbour in graph[node]: dp[neighbour] += dp[node] return dp[end]"},{"question":"from collections import Counter from typing import List def min_operations_to_anagram(s: str, t: str) -> int: Returns the minimum number of operations required to make t an anagram of s. :param s: The string to which we want to make an anagram. :param t: The string to be transformed into an anagram of s. :return: Minimum number of operations required. >>> min_operations_to_anagram(\\"listen\\", \\"silent\\") 0 >>> min_operations_to_anagram(\\"abc\\", \\"abd\\") 1 >>> min_operations_to_anagram(\\"aab\\", \\"xyz\\") 3 >>> min_operations_to_anagram(\\"aab\\", \\"yza\\") 2 >>> min_operations_to_anagram(\\"anagram\\", \\"mangaar\\") 0 pass","solution":"from collections import Counter def min_operations_to_anagram(s, t): Returns the minimum number of operations required to make t an anagram of s. if len(s) != len(t): raise ValueError(\\"The strings s and t must be of the same length to be anagrams of each other\\") count_s = Counter(s) count_t = Counter(t) operations = 0 for char in count_s: if char in count_t: if count_s[char] > count_t[char]: operations += count_s[char] - count_t[char] else: operations += count_s[char] return operations"},{"question":"def make_lexicographically_smallest(a: str) -> str: Returns the lexicographically smallest binary string by flipping bits in the given binary string \`a\`. >>> make_lexicographically_smallest('111') '000' >>> make_lexicographically_smallest('101') '000' >>> make_lexicographically_smallest('010') '000' >>> make_lexicographically_smallest('000') '000' >>> make_lexicographically_smallest('1') '0' >>> make_lexicographically_smallest('0') '0' pass","solution":"def make_lexicographically_smallest(a): Returns the lexicographically smallest binary string by flipping bits in given binary string \`a\`. return '0' * len(a)"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring in s. A balanced substring contains an equal number of 'a' and 'b'. >>> longest_balanced_substring(\\"ababab\\") == 6 >>> longest_balanced_substring(\\"ab\\") == 2 >>> longest_balanced_substring(\\"aabb\\") == 4 >>> longest_balanced_substring(\\"abba\\") == 4 >>> longest_balanced_substring(\\"a\\") == 0 >>> longest_balanced_substring(\\"b\\") == 0 >>> longest_balanced_substring(\\"\\") == 0 >>> longest_balanced_substring(\\"abbbaaabbaa\\") == 10 >>> longest_balanced_substring(\\"ababaabb\\") == 8 >>> longest_balanced_substring(\\"aaabbbabab\\") == 10","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring in s. A balanced substring contains an equal number of 'a' and 'b'. max_len = 0 n = len(s) # To keep track of count differences count_diff = {0: -1} # Initialize with difference 0 at index -1 count = 0 for i in range(n): if s[i] == 'a': count += 1 else: count -= 1 if count in count_diff: max_len = max(max_len, i - count_diff[count]) else: count_diff[count] = i return max_len"},{"question":"def coinChange(coins: List[int], target: int) -> int: This function returns the minimum number of coins required to make the target amount. If the amount cannot be made, it returns -1. Args: coins: List[int] - an array of integers representing coin denominations target: int - the target amount of money Returns: int - minimum number of coins required to make the target amount, or -1 if it cannot be made >>> coinChange([1, 2, 5], 11) 3 >>> coinChange([2], 3) -1 >>> coinChange([1], 0) 0 >>> coinChange([1], 7) 7 >>> coinChange([1, 2, 5], 100) 20 >>> coinChange([1, 3, 4], 6) 2 >>> coinChange([], 10) -1","solution":"def coinChange(coins, target): This function returns the minimum number of coins required to make the target amount. If the amount cannot be made, it returns -1. Args: coins: List[int] - an array of integers representing coin denominations target: int - the target amount of money Returns: int - minimum number of coins required to make the target amount, or -1 if it cannot be made # Create a list to store the minimum coins needed for each amount up to target dp = [float('inf')] * (target + 1) dp[0] = 0 # Base case: 0 coins are needed to make the amount 0 # Iterate over the amounts from 1 to target for amount in range(1, target + 1): # Iterate over each coin for coin in coins: if amount - coin >= 0: dp[amount] = min(dp[amount], dp[amount - coin] + 1) # If dp[target] is still infinity, we cannot make the target amount return dp[target] if dp[target] != float('inf') else -1"},{"question":"def min_partitions(s: str) -> int: Given a string \`s\` containing only digits, return the minimum number of partitions you need to make in such a way that each substring is a power of 2 in binary representation. If it is not possible to partition the string in such a way, return -1. >>> min_partitions(\\"1\\") 1 >>> min_partitions(\\"16\\") 1 >>> min_partitions(\\"256128\\") 2 >>> min_partitions(\\"6\\") -1 >>> min_partitions(\\"00128\\") -1","solution":"def is_power_of_2(s): Helper function to check if a given string s of digits is a power of 2. # Convert string s to integer num = int(s) # Check if num is a power of 2 return num != 0 and (num & (num - 1)) == 0 def min_partitions(s): Returns the minimum number of partitions needed for the string such that each substring is a power of 2. If it is not possible, return -1. n = len(s) dp = [float('inf')] * (n + 1) dp[0] = 0 # No partitions needed for an empty string for i in range(1, n + 1): for j in range(i): substring = s[j:i] if substring[0] != '0' and is_power_of_2(substring): dp[i] = min(dp[i], dp[j] + 1) return dp[n] if dp[n] != float('inf') else -1"},{"question":"def combination_sum(n): Given an integer n, return all possible unique combinations of positive integers that sum up to n. Each combination should be sorted in non-decreasing order and must be unique in terms of number sequence. >>> combination_sum(4) [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [4]] >>> combination_sum(5) [[1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 3], [1, 2, 2], [1, 4], [2, 3], [5]] >>> combination_sum(3) [[1, 1, 1], [1, 2], [3]] >>> combination_sum(6) [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 2], [1, 1, 1, 3], [1, 1, 2, 2], [1, 1, 4], [1, 2, 3], [1, 5], [2, 2, 2], [2, 4], [3, 3], [6]] >>> combination_sum(1) [[1]] # Your code here","solution":"def combination_sum(n): Returns all possible unique combinations of positive integers that sum up to n result = [] def backtrack(remaining, start, path): if remaining == 0: result.append(path) return for i in range(start, remaining + 1): backtrack(remaining - i, i, path + [i]) backtrack(n, 1, []) return result"},{"question":"def can_transform(source: str, target: str) -> bool: Determines if it is possible to transform \`source\` into \`target\` using exactly one of the following operations any number of times on \`source\`: 1. Insert any character at any position. 2. Delete any character. 3. Replace any character with another character. >>> can_transform(\\"abc\\", \\"abc\\") == True >>> can_transform(\\"abc\\", \\"abcd\\") == True >>> can_transform(\\"abcde\\", \\"bcd\\") == True >>> can_transform(\\"abc\\", \\"def\\") == True >>> can_transform(\\"abcdef\\", \\"ghij\\") == True","solution":"def can_transform(source, target): Determines if it is possible to transform 'source' into 'target' using the allowed operations any number of times. Args: source (str): The starting string. target (str): The string to transform to. Returns: bool: True if it is possible to transform 'source' into 'target', False otherwise. return True"},{"question":"def max_assigned_tasks(tasks: List[int], workers: List[int]) -> int: Determines the maximum number of tasks that can be assigned to workers under the given constraints. :param tasks: List[int], list of tasks' efforts :param workers: List[int], list of workers' energy units :return: int, maximum number of tasks that can be assigned >>> max_assigned_tasks([1, 3, 5], [5, 3, 1]) 3 >>> max_assigned_tasks([1, 2, 3], [4, 5, 6]) 3 >>> max_assigned_tasks([6, 3, 2], [2, 3, 4]) 2 >>> max_assigned_tasks([4, 2, 3], [3, 2, 1]) 2 >>> max_assigned_tasks([5, 6, 7], [1, 2, 3]) 0 >>> max_assigned_tasks([4, 3], [1, 2]) 0 >>> max_assigned_tasks([], []) 0 >>> max_assigned_tasks([1], [2]) 1 >>> max_assigned_tasks([2], [1]) 0","solution":"def max_assigned_tasks(tasks, workers): Determines the maximum number of tasks that can be assigned to workers under the given constraints. :param tasks: List[int], list of tasks' efforts :param workers: List[int], list of workers' energy units :return: int, maximum number of tasks that can be assigned tasks.sort() workers.sort() i, j = 0, 0 num_tasks_assigned = 0 while i < len(tasks) and j < len(workers): if workers[j] >= tasks[i]: num_tasks_assigned += 1 i += 1 j += 1 return num_tasks_assigned"},{"question":"def max_distinct_pairs(nums: list[int], k: int) -> int: Given an array nums of integers and an integer k, return the maximum number of distinct pairs (a, b) such that a and b both exist in the array and a + b = k. You may assume each pair is unique and each element from the array can only be used once. >>> max_distinct_pairs([1, 2, 3, 4], 5) 2 >>> max_distinct_pairs([1, 2, 3, 4], 8) 0 >>> max_distinct_pairs([1, 2, 3, 4, 3, 5, 6, 0], 5) 3 >>> max_distinct_pairs([1, 1, 1, 1, 1, 1], 2) 3 >>> max_distinct_pairs([1, -1, 0, 2, -2], 1) 2 >>> max_distinct_pairs([-1, -2, -3, -4], -5) 2 >>> max_distinct_pairs([], 1) 0","solution":"def max_distinct_pairs(nums, k): nums_count = {} for num in nums: if num in nums_count: nums_count[num] += 1 else: nums_count[num] = 1 pairs = 0 for num in list(nums_count.keys()): target = k - num if target in nums_count: if target == num: pairs += nums_count[num] // 2 else: pairs += min(nums_count[num], nums_count[target]) del nums_count[num] if target in nums_count: del nums_count[target] return pairs"},{"question":"def num_partitions(s: str, k: int) -> int: Given a string \`s\` consisting of lowercase letters and an integer \`k\`, partition the string into as few parts as possible such that each part is a substring with no more than \`k\` distinct characters. Return the total number of parts needed to achieve this. You can assume that \`k\` is in the range \`[1, 26]\` and the length of \`s\` is at least \`1\`. >>> num_partitions(\\"a\\", 1) 1 >>> num_partitions(\\"ab\\", 1) 2 >>> num_partitions(\\"abcdee\\", 5) 1 >>> num_partitions(\\"abacabad\\", 2) 4 >>> num_partitions(\\"abcdefghijklmnopqrstuvwxyz\\", 1) 26 >>> num_partitions(\\"abc\\", 0) 0","solution":"def num_partitions(s, k): Given a string s and an integer k, partition the string into as few parts as possible such that each part contains no more than k distinct characters. Return the total number of parts needed. if k == 0 or not s: return 0 count = 0 distinct_chars = set() for char in s: distinct_chars.add(char) if len(distinct_chars) > k: count += 1 distinct_chars = {char} return count + 1"},{"question":"def sort_problems(problem_ids, difficulties): Sorts the problems by their difficulty levels in non-decreasing order. If two problems have the same difficulty, they are sorted by their IDs in ascending order. Args: problem_ids (list of int): List of problem IDs. difficulties (list of int): List of difficulties corresponding to the problem IDs. Returns: list of int: List of problem IDs sorted by difficulty, then by ID. # Unit Tests def test_sort_problems_distinct_difficulties(): problem_ids = [3, 2, 1] difficulties = [30, 20, 10] assert sort_problems(problem_ids, difficulties) == [1, 2, 3] def test_sort_problems_same_difficulties(): problem_ids = [3, 2, 1] difficulties = [10, 10, 10] assert sort_problems(problem_ids, difficulties) == [1, 2, 3] def test_sort_problems_mixed(): problem_ids = [3, 5, 2, 4, 1] difficulties = [30, 20, 20, 10, 10] assert sort_problems(problem_ids, difficulties) == [1, 4, 2, 5, 3] def test_sort_problems_empty(): problem_ids = [] difficulties = [] assert sort_problems(problem_ids, difficulties) == [] def test_sort_problems_single_element(): problem_ids = [7] difficulties = [50] assert sort_problems(problem_ids, difficulties) == [7]","solution":"def sort_problems(problem_ids, difficulties): Sorts the problems by their difficulty levels in non-decreasing order. If two problems have the same difficulty, they are sorted by their IDs in ascending order. Args: problem_ids (list of int): List of problem IDs. difficulties (list of int): List of difficulties corresponding to the problem IDs. Returns: list of int: List of problem IDs sorted by difficulty, then by ID. problems = sorted(zip(difficulties, problem_ids)) return [problem_id for difficulty, problem_id in problems]"},{"question":"def longest_increasing_path(matrix): Given a matrix 'mat' of size \`n x m\`, return the length of the longest increasing path in the matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Two cells are considered in an increasing path if the subsequent cell has a strictly larger value than the current cell. >>> longest_increasing_path([]) == 0 >>> longest_increasing_path([[]]) == 0 >>> longest_increasing_path([[1]]) == 1 >>> mat = [ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ] >>> longest_increasing_path(mat) == 4 >>> mat = [ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ] >>> longest_increasing_path(mat) == 4 >>> mat = [ ... [7, 7, 7], ... [7, 7, 7], ... [7, 7, 7] ... ] >>> longest_increasing_path(mat) == 1","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) dp = [[-1] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] max_len = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] > matrix[x][y]: max_len = max(max_len, 1 + dfs(nx, ny)) dp[x][y] = max_len return max_len max_path = 0 for i in range(n): for j in range(m): max_path = max(max_path, dfs(i, j)) return max_path"},{"question":"def remove_k_digits(s: str, k: int) -> str: Given a string \`s\` representing a positive integer, remove \`k\` digits from the number so that the new number is the smallest possible. Return the new number as a string. >>> remove_k_digits(\\"1432219\\", 3) \\"1219\\" >>> remove_k_digits(\\"10200\\", 1) \\"200\\" >>> remove_k_digits(\\"10\\", 2) \\"0\\"","solution":"def remove_k_digits(s, k): Remove k digits from the number s to make the smallest possible number. stack = [] for digit in s: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still digits to remove, remove them from the end stack = stack[:-k] if k else stack # Convert the list back to string and strip leading zeros return ''.join(stack).lstrip('0') or '0'"},{"question":"from typing import List def max_distinct_items(costs: List[int], budget: int) -> int: Returns the maximum number of distinct items that can be purchased without exceeding the given budget. >>> max_distinct_items([1, 3, 2, 5, 4], 10) 4 >>> max_distinct_items([2, 4, 6, 8], 5) 1 >>> max_distinct_items([1], 2) 1 >>> max_distinct_items([7, 10, 2], 5) 1 >>> max_distinct_items([5, 5, 5, 5], 5) 1 >>> max_distinct_items([10, 20, 30], 25) 1 >>> max_distinct_items([5, 10, 3, 2, 1], 15) 4 >>> max_distinct_items([], 100) 0 >>> max_distinct_items([2, 2, 2, 2, 2], 6) 3","solution":"def max_distinct_items(costs, budget): Returns the maximum number of distinct items that can be purchased without exceeding the given budget. :param costs: List of integers representing the cost of each item. :param budget: Integer representing the available budget. :return: Integer representing the number of distinct items that can be bought. # Sort the costs in ascending order costs.sort() total_cost = 0 distinct_items_count = 0 # Loop through the sorted costs for cost in costs: if total_cost + cost <= budget: total_cost += cost distinct_items_count += 1 else: break return distinct_items_count"},{"question":"def can_see_next(heights): Returns the number of students who can see the immediate next student in front of them. Args: heights (list): List of integers representing the heights of students. Returns: int: Number of students who can see the immediate next student. >>> can_see_next([5, 5, 5, 5]) == 3 >>> can_see_next([6, 5, 4, 3]) == 3 >>> can_see_next([6, 7, 5, 8, 6]) == 2 >>> can_see_next([5]) == 0 >>> can_see_next([3, 6, 7, 8, 9]) == 0 >>> can_see_next([3, 5, 7, 6]) == 1 >>> can_see_next([]) == 0 >>> can_see_next([5, 5, 5, 4, 4, 4, 3]) == 6","solution":"def can_see_next(heights): Returns the number of students who can see the immediate next student in front of them. Args: heights (list): List of integers representing the heights of students. Returns: int: Number of students who can see the immediate next student. count = 0 for i in range(len(heights) - 1): if heights[i] >= heights[i + 1]: count += 1 return count"},{"question":"def minCostClimbingStairs(nums: List[int]) -> int: Returns the minimum cost to reach the top of the staircase. :param nums: List of costs associated with each step. :type nums: List[int] :return: Minimum cost to reach the top. :rtype: int >>> minCostClimbingStairs([10]) == 10 >>> minCostClimbingStairs([10, 15]) == 10 >>> minCostClimbingStairs([10, 15, 20]) == 15 >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6 >>> minCostClimbingStairs([]) == 0 >>> minCostClimbingStairs([3, 2, 5]) == 2 >>> minCostClimbingStairs([1, 2, 3]) == 2 >>> minCostClimbingStairs([100, 99, 98, 1]) == 100","solution":"def minCostClimbingStairs(nums): Returns the minimum cost to reach the top of the staircase. :param nums: List of costs associated with each step. :type nums: List[int] :return: Minimum cost to reach the top. :rtype: int n = len(nums) if n == 0: return 0 elif n == 1: return nums[0] # Initialize dp array dp = [0] * (n+1) dp[0] = 0 dp[1] = 0 for i in range(2, n+1): dp[i] = min(dp[i-1] + nums[i-1], dp[i-2] + nums[i-2]) return dp[n]"},{"question":"def max_groups(skills: List[int], k: int, m: int) -> int: Returns the maximum number of groups that can be formed such that each group has at least m members and the skill level of each member is within k units of the average skill level of the group. :param skills: List of integers representing the skill levels of employees :param k: Integer representing the allowed skill level deviation from the average skill level of the group :param m: Integer representing the minimum number of members in each group :return: Integer representing the number of groups that can be formed >>> max_groups([1, 2, 3, 4, 5], 1, 2) 2 >>> max_groups([1, 10, 20, 30], 2, 2) 0 >>> max_groups([1, 2, 3, 4, 5, 6], 1, 3) 2 >>> max_groups([1, 2, 3, 4, 5, 6], 10, 6) 1 >>> max_groups([7, 7, 7, 7, 7, 7, 7], 0, 1) 7 >>> max_groups([1, 5, 9, 12], 10, 2) 2 >>> max_groups([3, 8, 9, 10, 15, 16], 2, 2) 2","solution":"def max_groups(skills, k, m): Returns the maximum number of groups that can be formed such that each group has at least m members and the skill level of each member is within k units of the average skill level of the group. :param skills: List of integers representing the skill levels of employees :param k: Integer representing the allowed skill level deviation from the average skill level of the group :param m: Integer representing the minimum number of members in each group :return: Integer representing the number of groups that can be formed skills.sort() n = len(skills) groups = 0 i = 0 while i <= n - m: avg = sum(skills[i:i+m]) / m # average of the first m members if skills[i+m-1] <= avg + k and skills[i] >= avg - k: groups += 1 i += m # move to the next potential group else: i += 1 # try the next employee return groups"},{"question":"def min_operations_to_transform(source: str, target: str) -> int: Returns the minimum number of operations required to transform the source string into the target string. Operations allowed: insert, delete, replace. >>> min_operations_to_transform(\\"horse\\", \\"ros\\") 3 >>> min_operations_to_transform(\\"intention\\", \\"execution\\") 5 >>> min_operations_to_transform(\\"abc\\", \\"yabd\\") 2 >>> min_operations_to_transform(\\"\\", \\"\\") 0 >>> min_operations_to_transform(\\"a\\", \\"\\") 1 >>> min_operations_to_transform(\\"\\", \\"a\\") 1 >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"flaw\\", \\"lawn\\") 2 >>> min_operations_to_transform(\\"gumbo\\", \\"gambol\\") 2","solution":"def min_operations_to_transform(source, target): Returns the minimum number of operations required to transform the source string into the target string. Operations allowed: insert, delete, replace. m, n = len(source), len(target) # Initialize a DP array dp = [[0] * (n + 1) for _ in range(m + 1)] # Base cases for transformation from empty string to target, or source to empty string for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill the DP array for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Replacement return dp[m][n]"},{"question":"def rearrange_sentence(s: str) -> str: Rearranges the words in the sentence such that all the words that start with a vowel come before all the words that start with a consonant. Parameters: s (str): The input sentence consisting of words separated by spaces. Returns: str: The rearranged sentence as a single string. >>> rearrange_sentence(\\"apple banana orange grape\\") \\"apple orange banana grape\\" >>> rearrange_sentence(\\"banana apple grape orange\\") \\"apple orange banana grape\\" >>> rearrange_sentence(\\"apple orange\\") \\"apple orange\\" >>> rearrange_sentence(\\"banana grape\\") \\"banana grape\\" >>> rearrange_sentence(\\"apple banana orange\\") \\"apple orange banana\\" >>> rearrange_sentence(\\"apple\\") \\"apple\\" >>> rearrange_sentence(\\"banana\\") \\"banana\\"","solution":"def rearrange_sentence(s): Rearranges the words in the sentence such that all the words that start with a vowel come before all the words that start with a consonant. Parameters: s (str): The input sentence consisting of words separated by spaces. Returns: str: The rearranged sentence as a single string. vowels = {'a', 'e', 'i', 'o', 'u'} words = s.split() vowel_words = [word for word in words if word[0] in vowels] consonant_words = [word for word in words if word[0] not in vowels] return ' '.join(vowel_words + consonant_words)"},{"question":"def has_pair_with_difference(arr, m): Determines if there are two distinct indices i and j in the array such that the absolute difference between arr[i] and arr[j] is exactly m. :param arr: List of integers. :param m: An integer representing the difference. :return: True if such a pair exists, False otherwise. # Unit Tests def test_pair_exists(): assert has_pair_with_difference([1, 5, 3, 4, 2], 2) == True def test_pair_does_not_exist(): assert has_pair_with_difference([1, 2, 3, 4], 7) == False def test_empty_array(): assert has_pair_with_difference([], 1) == False def test_single_element_array(): assert has_pair_with_difference([1], 1) == False def test_pair_exists_with_negatives(): assert has_pair_with_difference([-1, -2, -3], 1) == True def test_pair_exists_with_large_difference(): assert has_pair_with_difference([1, 1000000], 999999) == True def test_repeated_elements(): assert has_pair_with_difference([1, 1, 1, 1], 0) == True def test_no_repeated_elements(): assert has_pair_with_difference([1, 5, 9, 14], 4) == True","solution":"def has_pair_with_difference(arr, m): Determines if there are two distinct indices i and j in the array such that the absolute difference between arr[i] and arr[j] is exactly m. :param arr: List of integers. :param m: An integer representing the difference. :return: True if such a pair exists, False otherwise. seen = set() for num in arr: if (num + m) in seen or (num - m) in seen: return True seen.add(num) return False"},{"question":"def max_elements(nums1: List[int], nums2: List[int]) -> List[int]: Returns an array where each element is the maximum of the corresponding elements in nums1 and nums2. >>> max_elements([1, 5, 3], [4, 2, 7]) [4, 5, 7] >>> max_elements([-1, 5, -3], [4, -2, 7]) [4, 5, 7] >>> max_elements([-1, -5, -3], [-4, -2, -7]) [-1, -2, -3] >>> max_elements([0, 5, 0], [4, 0, 7]) [4, 5, 7] >>> max_elements([0, 0, 0], [0, 0, 0]) [0, 0, 0] >>> max_elements([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> max_elements([1], [2]) [2] >>> max_elements([3], [3]) [3] >>> max_elements([-1], [0]) [0]","solution":"def max_elements(nums1, nums2): Returns an array where each element is the maximum of the corresponding elements in nums1 and nums2. :param nums1: List[int], first list of integers :param nums2: List[int], second list of integers :return: List[int] result, where result[i] is max(nums1[i], nums2[i]) return [max(a, b) for a, b in zip(nums1, nums2)]"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Finds two distinct numbers in nums whose sum equals target. Args: nums (List[int]): The list of integers to check. target (int): The target sum. Returns: List[int]: A list containing the two numbers whose sum is equal to target. If no such pair exists, returns an empty list. Examples: >>> two_sum([2, 7, 11, 15], 9) [2, 7] >>> two_sum([1, 2, 3], 6) [] >>> two_sum([-1, -2, -3], -5) [-2, -3] >>> two_sum([0, 4, 3, 0], 0) [0, 0] >>> two_sum([-1, 2, 4, -3], 1) [-1, 2] >>> two_sum([1000000000, 2, 4, -3, -1000000000], 0) [1000000000, -1000000000]","solution":"def two_sum(nums, target): Finds two distinct numbers in nums whose sum equals target. Args: nums : list of int : The list of integers to check. target : int : The target sum. Returns: list of int : A list containing the two numbers whose sum is equal to target. If no such pair exists, returns an empty list. seen = {} for num in nums: complement = target - num if complement in seen: return [complement, num] seen[num] = True return []"},{"question":"def count_primes(n: int) -> int: Returns the number of prime numbers strictly less than n. >>> count_primes(10) 4 >>> count_primes(20) 8 >>> count_primes(2) 0 pass def test_count_primes_less_than_10(): assert count_primes(10) == 4 # Primes are 2, 3, 5, 7 def test_count_primes_small_numbers(): assert count_primes(0) == 0 assert count_primes(1) == 0 assert count_primes(2) == 0 # Prime numbers start from 2 but strictly less than 2 means none assert count_primes(3) == 1 # Primes are 2 def test_count_primes_prime_number(): assert count_primes(11) == 4 # Primes less than 11 are 2, 3, 5, 7 def test_count_primes_larger_numbers(): assert count_primes(20) == 8 # Primes are 2, 3, 5, 7, 11, 13, 17, 19 assert count_primes(30) == 10 # Primes are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 def test_count_primes_no_primes(): assert count_primes(2) == 0 # No primes strictly less than 2","solution":"def count_primes(n): Returns the number of prime numbers strictly less than n. if n <= 2: return 0 sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False return sum(sieve)"},{"question":"from typing import List def distinct_numbers_in_subarrays(arr: List[int], k: int) -> List[int]: Returns an array where the i-th element is the number of distinct integers in the subarray arr[i:i+k]. Parameters: arr (List[int]): List of integers. k (int): Length of the subarrays. Returns: List[int]: List of integers where the i-th element is the number of distinct integers in the subarray arr[i:i+k]. Examples: >>> distinct_numbers_in_subarrays([1, 2, 3, 4, 5], 1) [1, 1, 1, 1, 1] >>> distinct_numbers_in_subarrays([1, 2, 3], 4) [] >>> distinct_numbers_in_subarrays([1, 1, 1, 1], 2) [1, 1, 1] >>> distinct_numbers_in_subarrays([1, 2, 3, 4, 5], 3) [3, 3, 3] >>> distinct_numbers_in_subarrays([1, 2, 1, 3, 4, 2, 3], 4) [3, 4, 4, 3] >>> distinct_numbers_in_subarrays([1, 2, 3], 3) [3] >>> distinct_numbers_in_subarrays([1, 2, 1, 2, 1, 2], 3) [2, 2, 2, 2] pass","solution":"from collections import Counter def distinct_numbers_in_subarrays(arr, k): Returns an array where the i-th element is the number of distinct integers in the subarray arr[i:i+k]. if k > len(arr): return [] result = [] window = Counter(arr[:k]) result.append(len(window)) for i in range(1, len(arr) - k + 1): # Remove the element going out of the window outgoing_elem = arr[i - 1] window[outgoing_elem] -= 1 if window[outgoing_elem] == 0: del window[outgoing_elem] # Add the new element coming into the window new_elem = arr[i + k - 1] window[new_elem] += 1 # Append the count of distinct elements in the current window result.append(len(window)) return result"},{"question":"def trap_max_water(height): Returns the maximum amount of water a single building can trap. >>> trap_max_water([]) == 0 >>> trap_max_water([5]) == 0 >>> trap_max_water([5, 3]) == 0 >>> trap_max_water([3, 3, 3, 3]) == 0 >>> trap_max_water([5, 0, 5]) == 5 >>> trap_max_water([0, 3, 0, 5, 0]) == 3 >>> trap_max_water([5, 0, 3, 0, 4]) == 4 >>> trap_max_water([0, 4, 0, 4, 4, 0, 3, 0]) == 4","solution":"def trap_max_water(height): Returns the maximum amount of water a single building can trap. n = len(height) if n < 3: return 0 max_water = 0 # Arrays to store the maximum height to the left and right of each building left_max = [0] * n right_max = [0] * n # Fill left_max from left to right left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) # Fill right_max from right to left right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) # Calculate maximum water for each building for i in range(1, n-1): # Water trapped on current building is determined by the minimum of maximum heights to its left and right minus its own height water = min(left_max[i], right_max[i]) - height[i] if water > 0: max_water = max(max_water, water) return max_water"},{"question":"def findPoisonedDuration(timeSeries: List[int], duration: int) -> int: Returns the total duration for which the effect was active. Parameters: - timeSeries (List[int]): List of times at which the effect starts. - duration (int): Duration for which each effect lasts. Returns: - int: Total time for which the effect was active. >>> findPoisonedDuration([1, 4], 2) 4 >>> findPoisonedDuration([1, 2], 2) 3","solution":"def findPoisonedDuration(timeSeries, duration): Returns the total duration for which the effect was active. Parameters: - timeSeries (List[int]): List of times at which the effect starts. - duration (int): Duration for which each effect lasts. Returns: - int: Total time for which the effect was active. if not timeSeries: return 0 total_duration = 0 for i in range(len(timeSeries) - 1): total_duration += min(timeSeries[i+1] - timeSeries[i], duration) total_duration += duration return total_duration"},{"question":"def partition_labels(s: str) -> List[int]: Partitions the string such that each letter appears in at most one part and returns the sizes of these parts. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"abcdef\\") [1, 1, 1, 1, 1, 1] >>> partition_labels(\\"aaaaa\\") [5] >>> partition_labels(\\"abcabc\\") [6]","solution":"def partition_labels(s): Partitions the string such that each letter appears in at most one part and returns the sizes of these parts. last_occurrence = {char: idx for idx, char in enumerate(s)} result = [] start = end = 0 for index, char in enumerate(s): end = max(end, last_occurrence[char]) if index == end: result.append(end - start + 1) start = index + 1 return result"},{"question":"def num_shapes(grid: List[List[int]], numShapes: int) -> bool: Check if the grid contains exactly numShapes shapes. >>> num_shapes([[0, 0], [0, 0]], 0) True >>> num_shapes([[1, 0], [0, 0]], 1) True >>> num_shapes([[1, 0], [0, 1]], 2) True >>> num_shapes([[1, 1], [1, 0]], 1) True >>> num_shapes([[1, 0, 1], [0, 1, 0], [1, 0, 1]], 2) False >>> num_shapes([[1, 0], [1, 0], [1, 1]], 2) False","solution":"def num_shapes(grid, numShapes): def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 # Marking the cell as visited # Exploring all four possible directions (up, down, left, right) dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) shape_count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) shape_count += 1 return shape_count == numShapes"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Perform a level-order traversal (BFS) on a binary tree and return a list of node values. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [1, 2, 3, 4, 5, 6, 7] >>> empty_root = None >>> level_order_traversal(empty_root) []","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Perform a level-order traversal (BFS) on a binary tree and return a list of node values. if not root: return [] queue = deque([root]) result = [] while queue: node = queue.popleft() result.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result"},{"question":"from typing import List def max_sum_after_k_changes(arr: List[int], k: int) -> float: Given an array of integers \`arr\` and an integer \`k\`, return the maximum possible sum you can obtain by changing at most \`k\` distinct elements of the array to any value. The array may contain both positive and negative numbers. :param arr: List of integers. :param k: Integer, number of changes allowed. :return: Float, the maximal sum possible. >>> max_sum_after_k_changes([1, -2, 3, 4, -5], 2) float('inf') >>> max_sum_after_k_changes([1, 2, 3], 10) float('inf') >>> max_sum_after_k_changes([-1, -2, -3, -4, -5], 3) float('inf') >>> max_sum_after_k_changes([5], 1) float('inf') >>> max_sum_after_k_changes([1, 2, 3, 4, 5], 0) 15","solution":"def max_sum_after_k_changes(arr, k): Returns the maximum possible sum obtained by changing at most k distinct elements of the array to any value. :param arr: List of integers. :param k: Integer, number of changes allowed. :return: Integer, the maximal sum possible. # If k is greater than length of array, we can change all elements to positive infinity if k >= len(arr): return float('inf') # Sort the array in increasing order arr.sort() # Change the smallest k elements to positive infinity for i in range(min(k, len(arr))): arr[i] = float('inf') # Return the sum of the array return sum(arr)"},{"question":"def max_bitwise_and_pair(bin_nums: List[str]) -> int: Given a list of binary number strings, return the maximum possible value of the bitwise AND operation among all pairs of these binary numbers. >>> max_bitwise_and_pair([\\"0110\\", \\"1100\\", \\"1001\\"]) 8 >>> max_bitwise_and_pair([\\"1111\\", \\"1111\\"]) 15 >>> max_bitwise_and_pair([\\"0000\\", \\"0000\\", \\"0000\\"]) 0 >>> max_bitwise_and_pair([\\"1010\\", \\"0101\\", \\"1111\\", \\"0011\\"]) 10 >>> max_bitwise_and_pair([\\"1010\\"]) 0 >>> max_bitwise_and_pair([\\"1001\\", \\"0101\\"]) 1","solution":"def max_bitwise_and_pair(bin_nums): Given a list of binary number strings, returns the maximum possible value of the bitwise AND operation among all pairs of these binary numbers. :param bin_nums: List[str] :return: int max_and = 0 n = len(bin_nums) for i in range(n): for j in range(i + 1, n): num1 = int(bin_nums[i], 2) num2 = int(bin_nums[j], 2) curr_and = num1 & num2 max_and = max(max_and, curr_and) return max_and"},{"question":"def find_indices_with_difference(arr: List[int], x: int) -> List[int]: Returns a list of two indices [i, j] such that the absolute difference between arr[i] and arr[j] is exactly x. If no such pair exists, return an empty list. >>> find_indices_with_difference([1, 5, 3, 4, 2], 2) [0, 2] >>> find_indices_with_difference([10, 8, 6, 4, 2], 5) []","solution":"def find_indices_with_difference(arr, x): Returns a list of two indices [i, j] such that the absolute difference between arr[i] and arr[j] is exactly x. If no such pair exists, return an empty list. if not arr or x < 0: return [] value_to_indices = {} for index, value in enumerate(arr): if value in value_to_indices: value_to_indices[value].append(index) else: value_to_indices[value] = [index] for index, value in enumerate(arr): if value + x in value_to_indices: for candidate_index in value_to_indices[value + x]: if candidate_index != index: return [index, candidate_index] if value - x in value_to_indices: for candidate_index in value_to_indices[value - x]: if candidate_index != index: return [index, candidate_index] return []"},{"question":"from typing import List def min_subarray_sum(arr1: List[int], arr2: List[int]) -> List[int]: Returns an array where result[i] is the minimum of the sum of any non-empty subarray from arr1 that starts at i and the sum of the subarray from arr2 that starts at i. >>> min_subarray_sum([1, 3, -2, 5], [2, -1, 4, -3]) [1, -1, -2, -3] >>> min_subarray_sum([2, 3, 4], [1, 1, 1]) [1, 1, 1] >>> min_subarray_sum([-1, 2, 3], [4, -2, 5]) [-1, -2, 3] >>> min_subarray_sum([0, 0, 0], [0, 0, 0]) [0, 0, 0] >>> min_subarray_sum([5, 5, 5], [1, 1, 1]) [1, 1, 1]","solution":"def min_subarray_sum(arr1, arr2): Returns an array where result[i] is the minimum of the sum of any non-empty subarray from arr1 that starts at i and the sum of the subarray from arr2 that starts at i. n = len(arr1) result = [0] * n for i in range(n): min_sum1 = float('inf') current_sum1 = 0 for j in range(i, n): current_sum1 += arr1[j] min_sum1 = min(min_sum1, current_sum1) min_sum2 = float('inf') current_sum2 = 0 for j in range(i, n): current_sum2 += arr2[j] min_sum2 = min(min_sum2, current_sum2) result[i] = min(min_sum1, min_sum2) return result"},{"question":"def max_students_grouped(heights: List[int], k: int) -> int: Returns the maximum number of students that can be grouped such that in each group, the difference between the tallest and the shortest student is no greater than k. heights (list[int]): List representing heights of students. k (int): Maximum allowed difference in heights within a group. Returns: int: Maximum number of students that can be grouped according to the given condition. >>> max_students_grouped([1, 2, 3, 4, 5], 2) 3 >>> max_students_grouped([7, 4, 1, 3, 2, 9, 6, 8, 5], 3) 4","solution":"def max_students_grouped(heights, k): Returns the maximum number of students that can be grouped such that in each group, the difference between the tallest and the shortest student is no greater than k. heights (list[int]): List representing heights of students. k (int): Maximum allowed difference in heights within a group. Returns: int: Maximum number of students that can be grouped according to the given condition. if not heights or k < 0: return 0 heights.sort() max_group = 0 left = 0 for right in range(len(heights)): while heights[right] - heights[left] > k: left += 1 max_group = max(max_group, right - left + 1) return max_group"},{"question":"from typing import List def numIslands(grid: List[List[str]]) -> int: Return the number of distinct islands in the grid where '1' represent land and '0' represent water. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. >>> grid = [ ... [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ] >>> numIslands(grid) 1 >>> grid = [ ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ... ] >>> numIslands(grid) 3 >>> grid = [ ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ] >>> numIslands(grid) 0 >>> grid = [ ... [\\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"] ... ] >>> numIslands(grid) 7 >>> grid = [] >>> numIslands(grid) 0 >>> grid = [[\\"1\\"]] >>> numIslands(grid) 1 >>> grid = [[\\"0\\"]] >>> numIslands(grid) 0 >>> grid = [ ... [\\"1\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"0\\", \\"1\\"] ... ] >>> numIslands(grid) 5","solution":"from typing import List def numIslands(grid: List[List[str]]) -> int: if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = set() def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == '1': visited.add((nr, nc)) stack.append((nr, nc)) islands = 0 for r in range(rows): for c in range(cols): if grid[r][c] == '1' and (r, c) not in visited: visited.add((r, c)) dfs(r, c) islands += 1 return islands"},{"question":"def smallest_missing_greater_or_equal(arr: List[int], k: int) -> int: Returns the smallest non-negative integer that is not present in the array and is greater than or equal to k. >>> smallest_missing_greater_or_equal([0, 1, 2, 4], 3) # 3 >>> smallest_missing_greater_or_equal([0, 1, 2, 4], 2) # 3 >>> smallest_missing_greater_or_equal([5, 6, 7], 5) # 8 >>> smallest_missing_greater_or_equal([0, 1, 2, 3], 0) # 4 >>> smallest_missing_greater_or_equal([3, 4, 5], 1) # 1 >>> smallest_missing_greater_or_equal([], 0) # 0 >>> smallest_missing_greater_or_equal([0], 0) # 1","solution":"def smallest_missing_greater_or_equal(arr, k): Returns the smallest non-negative integer that is not present in the array and is greater than or equal to k. :param arr: List of non-negative integers :param k: Integer value to compare against :return: Smallest non-negative integer not in arr and >= k # Convert the list to a set for O(1) lookup times num_set = set(arr) # Start from k and find the first integer not in set while k in num_set: k += 1 return k"},{"question":"def min_zigzag_sum(grid): Returns the minimum sum of the values along any valid zigzag path in the grid. pass # Unit Tests def test_min_zigzag_sum_small_grid(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_zigzag_sum(grid) == 7 # Path: 1 -> 3 -> 1 -> 1 -> 1 def test_min_zigzag_sum_single_element(): grid = [[5]] assert min_zigzag_sum(grid) == 5 # Path: only 5 def test_min_zigzag_sum_all_zeros(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert min_zigzag_sum(grid) == 0 # Path: always zero def test_min_zigzag_sum_increasing_values(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_zigzag_sum(grid) == 21 # Path: 1 -> 2 -> 3 -> 6 -> 9 def test_min_zigzag_sum_larger_grid(): grid = [ [1, 3, 1, 2], [1, 5, 1, 3], [4, 2, 1, 4], [7, 8, 9, 1] ] assert min_zigzag_sum(grid) == 12 # Path: 1 -> 1 -> 1 -> 1 -> 2 -> 1","solution":"def min_zigzag_sum(grid): Returns the minimum sum of the values along any valid zigzag path in the grid. n = len(grid) dp = [[float('inf')] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"def minimumWindowSubstring(s: str, t: str) -> str: Given two strings \`s\` and \`t\`, find the minimum window substring in \`s\` that contains all the characters in \`t\` (including duplicates). If there is no such window in \`s\` that covers all characters in \`t\`, return the empty string \`\\"\\"\`. If there are multiple such windows, return the one with the smallest length. >>> minimumWindowSubstring(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" >>> minimumWindowSubstring(\\"a\\", \\"a\\") == \\"a\\" >>> minimumWindowSubstring(\\"a\\", \\"aa\\") == \\"\\" >>> minimumWindowSubstring(\\"bba\\", \\"ab\\") == \\"ba\\" >>> minimumWindowSubstring(\\"this is a test string\\", \\"tist\\") == \\"t stri\\" >>> minimumWindowSubstring(\\"cabwefgewcwaefgcf\\", \\"cae\\") == \\"cwae\\"","solution":"from collections import Counter def minimumWindowSubstring(s: str, t: str) -> str: if not s or not t or len(s) < len(t): return \\"\\" t_counter = Counter(t) window_counter = Counter() required = len(t_counter) formed = 0 l, r = 0, 0 min_length = float(\\"inf\\") min_window = (0, 0) while r < len(s): char = s[r] window_counter[char] += 1 if char in t_counter and window_counter[char] == t_counter[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < min_length: min_length = r - l + 1 min_window = (l, r) window_counter[char] -= 1 if char in t_counter and window_counter[char] < t_counter[char]: formed -= 1 l += 1 r += 1 l, r = min_window return s[l:r+1] if min_length != float(\\"inf\\") else \\"\\""},{"question":"def min_cost_to_sort(arr: List[int]) -> int: Returns the minimum cost to sort the array in non-decreasing order given the specified operation and cost. >>> min_cost_to_sort([1, 2, 3, 4, 5]) == 0 >>> min_cost_to_sort([5, 4, 3, 2, 1]) == 6 >>> min_cost_to_sort([3, 1, 2, 4, 5]) == 2 >>> min_cost_to_sort([1]) == 0 >>> min_cost_to_sort([1, 2]) == 0 >>> min_cost_to_sort([2, 1]) == 1 >>> min_cost_to_sort([1000, 500, 100]) == 900","solution":"def min_cost_to_sort(arr): Returns the minimum cost to sort the array in non-decreasing order given the specified operation and cost. n = len(arr) if n <= 1: return 0 # Calculate the minimum cost using dynamic programming sorted_arr = sorted(arr) # Cost of converting arr[:i] to sorted_arr[:j] dp = [[float('inf')] * n for _ in range(n)] # Base condition dp[0][0] = abs(arr[0] - sorted_arr[0]) for j in range(1, n): dp[0][j] = min(dp[0][j-1], abs(arr[0] - sorted_arr[j])) for i in range(1, n): min_so_far = dp[i-1][0] dp[i][0] = min_so_far + abs(arr[i] - sorted_arr[0]) for j in range(1, n): min_so_far = min(min_so_far, dp[i-1][j]) dp[i][j] = min_so_far + abs(arr[i] - sorted_arr[j]) return min(dp[-1])"},{"question":"def smallest_absolute_difference(nums: List[int]) -> int: Given an array of integers \`nums\`, return the smallest absolute difference between any two elements in the array. >>> smallest_absolute_difference([3, 8, 15, 17]) 2 >>> smallest_absolute_difference([5, 16, 5, 10]) 0 >>> smallest_absolute_difference([1, 2, 3, 4, 5]) 1 >>> smallest_absolute_difference([10, 3, 6, 9, 1]) 2 >>> smallest_absolute_difference([1, 100]) 99 >>> smallest_absolute_difference([-5, -1, -10, -7]) 2 >>> smallest_absolute_difference([-3, 4, -2, 7, -1]) 2 >>> smallest_absolute_difference([42]) 0","solution":"def smallest_absolute_difference(nums): Returns the smallest absolute difference between any two elements in the array. if len(nums) < 2: return 0 # Not enough elements to compare nums.sort() min_diff = float('inf') for i in range(len(nums) - 1): diff = abs(nums[i+1] - nums[i]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def minimize_maximum_distance(nums: List[int], k: int) -> int: Minimizes the maximum walking distance any car has to walk to reach a parking lot. Args: nums: List[int] - positions of cars on a number line. k: int - number of parking lots. Returns: int - the minimum possible value of the maximum walking distance any car has to walk. >>> minimize_maximum_distance([1, 2, 3, 4, 5], 1) 4 >>> minimize_maximum_distance([1, 2, 3, 4, 5], 2) 2 >>> minimize_maximum_distance([1, 3, 6, 8], 3) 2 >>> minimize_maximum_distance([5, 5, 5, 5], 2) 0 >>> minimize_maximum_distance([10, 20, 30, 40, 50], 3) 10","solution":"def minimize_maximum_distance(nums, k): Minimizes the maximum walking distance any car has to walk to reach a parking lot. Args: nums: List[int] - positions of cars on a number line. k: int - number of parking lots. Returns: int - the minimum possible value of the maximum walking distance any car has to walk. nums.sort() def canAllocate(max_distance): parking_lots = 1 start_position = nums[0] for position in nums: if position - start_position > max_distance: parking_lots += 1 start_position = position if parking_lots > k: return False return True low, high = 0, nums[-1] - nums[0] while low < high: mid = (low + high) // 2 if canAllocate(mid): high = mid else: low = mid + 1 return low"},{"question":"def is_self_dividing(number: int) -> bool: Helper function that checks if a number is self-dividing. >>> is_self_dividing(128) True >>> is_self_dividing(1) True >>> is_self_dividing(12) True >>> is_self_dividing(102) False >>> is_self_dividing(20) False >>> is_self_dividing(30) False pass def self_dividing_numbers(n: int) -> List[int]: Returns a list of all self-dividing numbers between 1 and n (inclusive). >>> self_dividing_numbers(1) [1] >>> self_dividing_numbers(15) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15] >>> self_dividing_numbers(128) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88, 99, 111, 112, 115, 122, 124, 126, 128] pass","solution":"def is_self_dividing(number): Helper function that checks if a number is self-dividing. original_number = number while number > 0: digit = number % 10 if digit == 0 or original_number % digit != 0: return False number //= 10 return True def self_dividing_numbers(n): Returns a list of all self-dividing numbers between 1 and n (inclusive). return [i for i in range(1, n + 1) if is_self_dividing(i)]"},{"question":"import random class RandomizedSet: Data structure that supports insert, delete, and get_random operations. def __init__(self): Initialize the RandomizedSet object. pass def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. pass def delete(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. pass def get_random(self) -> int: Get a random element from the set. pass # Unit tests def test_insert(): rs = RandomizedSet() assert rs.insert(1) == True # 1 is not in the set, should insert successfully. assert rs.insert(2) == True # 2 is not in the set, should insert successfully. assert rs.insert(1) == False # 1 is already in the set, cannot insert again. def test_delete(): rs = RandomizedSet() rs.insert(1) rs.insert(2) assert rs.delete(1) == True # 1 is in the set, should delete successfully. assert rs.delete(1) == False # 1 is already deleted, cannot delete again. assert rs.delete(3) == False # 3 is not in the set, cannot delete. def test_get_random(): rs = RandomizedSet() rs.insert(1) rs.insert(2) rs.insert(3) random_val = rs.get_random() assert random_val in [1, 2, 3] # get_random should return one of the inserted values. def test_full_operations(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.insert(2) == True assert rs.delete(1) == True assert rs.insert(2) == False assert rs.insert(3) == True assert rs.delete(2) == True assert rs.get_random() == 3 def test_empty_operations(): rs = RandomizedSet() assert rs.delete(1) == False # Delete on empty set should return False rs.insert(1) rs.delete(1) try: rs.get_random() # get_random on empty set should raise an error assert False, \\"get_random should raise an IndexError when the set is empty\\" except IndexError: pass def test_insert_after_delete(): rs = RandomizedSet() assert rs.insert(1) == True assert rs.delete(1) == True assert rs.insert(1) == True # Should allow re-inserting after deletion","solution":"import random class RandomizedSet: def __init__(self): Initialize the RandomizedSet object. self.data = {} self.list = [] def insert(self, val: int) -> bool: Inserts a value to the set. Returns true if the set did not already contain the specified element. if val in self.data: return False self.data[val] = len(self.list) self.list.append(val) return True def delete(self, val: int) -> bool: Removes a value from the set. Returns true if the set contained the specified element. if val not in self.data: return False index = self.data[val] last_element = self.list[-1] self.list[index] = last_element self.data[last_element] = index self.list.pop() del self.data[val] return True def get_random(self) -> int: Get a random element from the set. return random.choice(self.list)"},{"question":"def add_binary(s1: str, s2: str) -> str: Returns the sum of two binary numbers represented as strings. >>> add_binary(\\"0\\", \\"0\\") \\"0\\" >>> add_binary(\\"1\\", \\"0\\") \\"1\\" >>> add_binary(\\"0\\", \\"1\\") \\"1\\" >>> add_binary(\\"1\\", \\"1\\") \\"10\\" >>> add_binary(\\"11\\", \\"1\\") \\"100\\" >>> add_binary(\\"101\\", \\"110\\") \\"1011\\" >>> add_binary(\\"110010\\", \\"101010\\") \\"1011100\\" >>> add_binary(\\"1111\\", \\"1111\\") \\"11110\\" >>> add_binary(\\"1\\", \\"0001\\") \\"10\\" >>> add_binary(\\"1010\\", \\"10\\") \\"1100\\" >>> add_binary(\\"1\\"*1000, \\"1\\") \\"1\\" + \\"0\\"*1000 >>> add_binary(\\"1111\\"*250, \\"1\\") \\"1000\\" + \\"0\\"*997","solution":"def add_binary(s1, s2): Returns the sum of two binary numbers represented as strings. # Convert binary strings to integers num1 = int(s1, 2) num2 = int(s2, 2) # Add binary numbers binary_sum = num1 + num2 # Convert the sum back to a binary string and remove the '0b' prefix return bin(binary_sum)[2:]"},{"question":"from typing import List def min_subarrays(arr: List[int]) -> int: Splits the array into the minimum number of non-empty consecutive subarrays such that each subarray has its elements in strictly increasing order. Args: arr (List[int]): The input array of integers. Returns: int: The minimum number of subarrays required. >>> min_subarrays([1, 2, 3, 4, 5]) == 1 >>> min_subarrays([5, 4, 3, 2, 1]) == 5 >>> min_subarrays([1, 2, 2, 3, 4]) == 2 >>> min_subarrays([1, 3, 2, 4, 5]) == 2 >>> min_subarrays([1, 2, 3, 1, 2, 3]) == 2 >>> min_subarrays([1, 1, 1, 1, 1]) == 5 >>> min_subarrays([1]) == 1 >>> min_subarrays([]) == 0 >>> min_subarrays([1, 2, 1, 2, 1, 2]) == 3 >>> min_subarrays([10, 20, 30, 10, 40, 50]) == 2","solution":"def min_subarrays(arr): Splits the array into the minimum number of non-empty consecutive subarrays such that each subarray has its elements in strictly increasing order. Args: arr (List[int]): The input array of integers. Returns: int: The minimum number of subarrays required. if not arr: return 0 subarray_count = 1 for i in range(1, len(arr)): if arr[i] <= arr[i - 1]: subarray_count += 1 return subarray_count"},{"question":"def lexicographically_smallest(s: str) -> str: Transforms the string s into the lexicographically smallest string t possible by performing the allowed operations any number of times. Args: - s: a string consisting of only lowercase English letters. Returns: - a string t which is the lexicographically smallest possible string. >>> lexicographically_smallest(\\"bcab\\") == \\"abbc\\" >>> lexicographically_smallest(\\"zxy\\") == \\"xyz\\" >>> lexicographically_smallest(\\"abc\\") == \\"abc\\" >>> lexicographically_smallest(\\"aabc\\") == \\"aabc\\" >>> lexicographically_smallest(\\"bbaac\\") == \\"aabbc\\" >>> lexicographically_smallest(\\"a\\") == \\"a\\" >>> lexicographically_smallest(\\"z\\") == \\"z\\" >>> lexicographically_smallest(\\"aaaa\\") == \\"aaaa\\" >>> lexicographically_smallest(\\"bbbb\\") == \\"bbbb\\"","solution":"def lexicographically_smallest(s): Transforms the string s into the lexicographically smallest string t possible by performing the allowed operations any number of times. Args: - s: a string consisting of only lowercase English letters. Returns: - a string t which is the lexicographically smallest possible string. t = [] while s: min_char = min(s) min_index = s.index(min_char) t.append(min_char) s = s[:min_index] + s[min_index+1:] return ''.join(t)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotate the linked list to the right by k places. >>> lst = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> result = rotateRight(lst, 2) >>> list_to_array(result) [4, 5, 1, 2, 3] >>> lst = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> result = rotateRight(lst, 5) >>> list_to_array(result) [1, 2, 3, 4, 5] >>> lst = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> result = rotateRight(lst, 7) >>> list_to_array(result) [4, 5, 1, 2, 3] def list_to_array(head: ListNode) -> List[int]: Helper function to convert linked list to array array = [] while head: array.append(head.val) head = head.next return array def array_to_list(arr: List[int]) -> ListNode: Helper function to convert array to linked list if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Determine the length of the list old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 # Create a circular list old_tail.next = head # Find the new tail and new head new_tail = head for _ in range(length - k % length - 1): new_tail = new_tail.next new_head = new_tail.next # Break the circle new_tail.next = None return new_head"},{"question":"def min_toggles_to_equal_matrix(matrix: List[List[int]]) -> int: Determine the minimum number of toggles required to make all elements in the matrix equal. >>> min_toggles_to_equal_matrix([ [0, 0, 0], [1, 0, 0], [0, 0, 0] ]) != -1 >>> min_toggles_to_equal_matrix([ [0, 1, 0, 1] ]) > 0 >>> min_toggles_to_equal_matrix([ [1] ]) == 0 >>> min_toggles_to_equal_matrix([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 0 pass","solution":"def min_toggles_to_equal_matrix(matrix): Determine the minimum number of toggles required to make all elements in the matrix equal. def toggle(matrix, i, j): Toggle the element at (i, j) and its neighbors. rows, cols = len(matrix), len(matrix[0]) neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)] matrix[i][j] ^= 1 for di, dj in neighbors: ni, nj = i + di, j + dj if 0 <= ni < rows and 0 <= nj < cols: matrix[ni][nj] ^= 1 rows, cols = len(matrix), len(matrix[0]) original_matrix = [row[:] for row in matrix] operations_0 = operations_1 = 0 # Try to make all 0s for i in range(rows): for j in range(cols): if matrix[i][j] == 1: toggle(matrix, i, j) operations_0 += 1 # Reset matrix and try to make all 1s matrix = [row[:] for row in original_matrix] for i in range(rows): for j in range(cols): if matrix[i][j] == 0: toggle(matrix, i, j) operations_1 += 1 return min(operations_0, operations_1) # Example usage matrix = [ [0, 0, 0], [1, 0, 0], [0, 0, 0] ] print(min_toggles_to_equal_matrix(matrix)) # Output should be the minimum number of toggles required"},{"question":"def sortArrayByParity(nums: List[int]) -> List[int]: Sort the array in such a way that all the even numbers are followed by all the odd numbers while maintaining the relative order of even and odd numbers as in the original array. Args: nums: List[int] - The input list of integers. Returns: List[int] - The sorted list containing all even numbers followed by all odd numbers. >>> sortArrayByParity([2, 4, 6, 8]) [2, 4, 6, 8] >>> sortArrayByParity([1, 3, 5, 7]) [1, 3, 5, 7] >>> sortArrayByParity([3, 1, 2, 4]) [2, 4, 3, 1] >>> sortArrayByParity([1, 2, 3, 4]) [2, 4, 1, 3] >>> sortArrayByParity([]) [] >>> sortArrayByParity([1]) [1] >>> sortArrayByParity([2]) [2]","solution":"def sortArrayByParity(nums): Sort the array in such a way that all the even numbers are followed by all the odd numbers while maintaining the relative order of even and odd numbers as in the original array. Args: nums: List[int] - The input list of integers. Returns: List[int] - The sorted list containing all even numbers followed by all odd numbers. evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 != 0] return evens + odds"},{"question":"def minimum_moves_to_sort(heights: List[int]) -> int: Returns the minimum number of students that must be moved such that the heights are in non-decreasing order. >>> minimum_moves_to_sort([4, 1, 3, 2]) == 3 >>> minimum_moves_to_sort([1, 2, 3, 4]) == 0 >>> minimum_moves_to_sort([4, 3, 2, 1]) == 4 >>> minimum_moves_to_sort([2, 2, 2, 2]) == 0 >>> minimum_moves_to_sort([2, 3]) == 0 >>> minimum_moves_to_sort([3, 2]) == 2","solution":"def minimum_moves_to_sort(heights): Returns the minimum number of students that must be moved such that the heights are in non-decreasing order. # Sort the list to get the target positions sorted_heights = sorted(heights) # Count the number of positions where the heights differ from the sorted sequence moves = sum(1 for i in range(len(heights)) if heights[i] != sorted_heights[i]) return moves"},{"question":"def max_length_subsequence(nums: List[int], k: int) -> int: Find the maximum length of a contiguous subsequence such that every element in the subsequence appears at least k times in the entire sequence. Args: nums (list of int): The sequence of integers. k (int): The minimum frequency for each element within the contiguous subsequence. Returns: int: The maximum length of such a contiguous subsequence. If no such subsequence exists, return 0. >>> max_length_subsequence([1, 2, 3], 2) == 0 >>> max_length_subsequence([1, 1, 2, 2, 2, 3, 3, 1], 1) == 8 >>> max_length_subsequence([1, 2, 2, 2, 3, 1], 2) == 3 >>> max_length_subsequence([4, 4, 4, 4], 4) == 4 >>> max_length_subsequence([1, 1, 2, 2, 3, 3, 1, 1], 2) == 8 >>> max_length_subsequence([], 1) == 0 >>> max_length_subsequence([1, 1, 1], 4) == 0","solution":"def max_length_subsequence(nums, k): Find the maximum length of a contiguous subsequence such that every element in the subsequence appears at least k times in the entire sequence. Args: nums (list of int): The sequence of integers. k (int): The minimum frequency for each element within the contiguous subsequence. Returns: int: The maximum length of such a contiguous subsequence. If no such subsequence exists, return 0. from collections import Counter n = len(nums) max_len = 0 for start in range(n): count = Counter() for end in range(start, n): count[nums[end]] += 1 if all(v >= k for v in count.values()): max_len = max(max_len, end - start + 1) return max_len"},{"question":"def find_fixed_point(arr: List[int]) -> int: You are given an integer array \`arr\`, where the elements are sorted in strictly increasing order. Find the fixed point in the array, if it exists. A fixed point in an array is an element whose value is equal to its index. Return the index if there is a fixed point in the array; otherwise, return -1. If there are multiple fixed points, return the smallest index. >>> find_fixed_point([1, 2, 3, 4]) == -1 >>> find_fixed_point([-1, 0, 2, 5]) == 2 >>> find_fixed_point([0, 1, 2, 3]) == 0 >>> find_fixed_point([-10, -5, 2, 3, 4]) == 2 >>> find_fixed_point([0]) == 0 >>> find_fixed_point([]) == -1 >>> find_fixed_point([-10, -5, 1, 3]) == 3","solution":"def find_fixed_point(arr): Finds the fixed point in the array, where element value is equal to its index. Returns the index if a fixed point exists, otherwise returns -1. for i in range(len(arr)): if arr[i] == i: return i return -1"},{"question":"def numIslands(grid: List[List[str]]) -> int: Return the number of islands in the given grid. An island is a region of contiguous '1's (horizontally or vertically). >>> numIslands([ ... [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) == 1 >>> numIslands([ ... [\\"1\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\"] ... ]) == 4 >>> numIslands([ ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ... ]) == 0 >>> numIslands([]) == 0 >>> numIslands([[\\"0\\"]]) == 0 >>> numIslands([[\\"1\\"]]) == 1 >>> numIslands([ ... [\\"1\\", \\"0\\"], ... [\\"0\\", \\"1\\"] ... ]) == 2","solution":"def numIslands(grid): def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': dfs(grid, i, j) count += 1 return count"},{"question":"def bfs_shortest_path(grid): Perform BFS to find the shortest path from top-left to bottom-right in a binary maze. Returns the length of the shortest path or -1 if there is no path. import pytest def test_no_walls(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert bfs_shortest_path(grid) == 5 def test_one_wall_with_path(): grid = [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ] assert bfs_shortest_path(grid) == 5 def test_no_path(): grid = [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ] assert bfs_shortest_path(grid) == -1 def test_starting_point_is_wall(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert bfs_shortest_path(grid) == -1 def test_ending_point_is_wall(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert bfs_shortest_path(grid) == -1 def test_complex_path(): grid = [ [0, 0, 1, 0, 0], [1, 0, 1, 0, 1], [1, 0, 1, 0, 0], [1, 0, 0, 0, 1], [1, 1, 1, 0, 0] ] assert bfs_shortest_path(grid) == 9","solution":"from collections import deque def bfs_shortest_path(grid): Perform BFS to find the shortest path from top-left to bottom-right in a binary maze. Returns the length of the shortest path or -1 if there is no path. if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 n = len(grid) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List from collections import Counter def rearrange_to_palindrome(data: List[int], k: int) -> List[int]: Determines if it is possible to rearrange the elements of the array such that the array becomes a palindrome. If it is possible, returns the rearranged array; otherwise, returns an empty array. >>> rearrange_to_palindrome([], 0) == [] >>> rearrange_to_palindrome([1], 1) == [1] >>> rearrange_to_palindrome([1, 2, 2, 1], 4) == [1, 2, 2, 1] >>> rearrange_to_palindrome([1, 2, 1, 2], 4) == [1, 2, 2, 1] >>> rearrange_to_palindrome([1, 2, 3, 2, 1], 5) == [1, 2, 3) assert insert_apples([5, 6, 7], [6, 5, 7], [3, 5, 6], 2, 2) == []","solution":"from collections import Counter def rearrange_to_palindrome(data, k): Determines if it's possible to rearrange the array such that it becomes a palindrome. If possible, returns the rearranged array, otherwise returns an empty array. if k <= 0 or len(data) != k: return [] count = Counter(data) odd_count = sum(1 for v in count.values() if v % 2 != 0) if odd_count > 1: return [] half = [] middle = [] for key, value in count.items(): if value % 2 != 0: middle = [key] * value else: half.extend([key] * (value // 2)) return half + middle + half[::-1]"},{"question":"def isValidSudoku(board: List[List[str]]) -> bool: Check if a 9x9 Sudoku board is valid. >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> isValidSudoku(board) True >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\"8\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], # duplicate '8' in the row ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> isValidSudoku(board) False >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> isValidSudoku(board) True >>> board[8][4] = \\"6\\" # duplicate '6' in the column >>> isValidSudoku(board) False >>> board = [ ... [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], ... [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], ... [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], ... [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], ... [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], ... [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], ... [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], ... [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], ... [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ... ] >>> isValidSudoku(board) True >>> board[4][4] = \\"9\\" # duplicate '9' in the overlapping box >>> isValidSudoku(board) False","solution":"def isValidSudoku(board): Check if a 9x9 Sudoku board is valid. # Initialize data structures to keep track of seen numbers rows = [set() for _ in range(9)] cols = [set() for _ in range(9)] boxes = [set() for _ in range(9)] for i in range(9): for j in range(9): num = board[i][j] if num == '.': continue # Calculate the index of the box box_index = (i // 3) * 3 + j // 3 if num in rows[i] or num in cols[j] or num in boxes[box_index]: return False rows[i].add(num) cols[j].add(num) boxes[box_index].add(num) return True"},{"question":"def trap(heights: List[int]) -> int: Calculate the total volume of trapped water given the heights of the boxes. :param heights: List[int] - list of non-negative integers representing heights of boxes. :return: int - total volume of trapped water. >>> trap([]) == 0 >>> trap([5]) == 0 >>> trap([0, 1, 2, 3, 4, 5]) == 0 >>> trap([5, 4, 3, 2, 1, 0]) == 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([3, 3, 3, 3]) == 0 >>> trap([0, 3, 0, 3, 0, 3]) == 6","solution":"def trap(heights): Calculate the total volume of trapped water given the heights of the boxes. :param heights: List[int] - list of non-negative integers representing heights of boxes. :return: int - total volume of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate trapped water trapped_water = 0 for i in range(n): trapped_water += max(0, min(left_max[i], right_max[i]) - heights[i]) return trapped_water"},{"question":"def longest_alphabetical_substring(s: str) -> str: Finds the longest substring where the letters occur in alphabetical order. >>> longest_alphabetical_substring(\\"abacdfgdc\\") == \\"acdfg\\" >>> longest_alphabetical_substring(\\"xyzabc\\") == \\"xyz\\" >>> longest_alphabetical_substring(\\"\\") == \\"\\" >>> longest_alphabetical_substring(\\"a\\") == \\"a\\" >>> longest_alphabetical_substring(\\"aaaaaaa\\") == \\"aaaaaaa\\" >>> longest_alphabetical_substring(\\"zyxwvutsrqponmlkjihgfedcba\\") == \\"z\\" >>> longest_alphabetical_substring(\\"abcdeaaaaa\\") == \\"abcde\\"","solution":"def longest_alphabetical_substring(s): Finds the longest substring where the letters occur in alphabetical order. if not s: return \\"\\" longest = current = s[0] for i in range(1, len(s)): if s[i] >= s[i - 1]: current += s[i] else: if len(current) > len(longest): longest = current current = s[i] if len(current) > len(longest): # Check the last accumulated substring longest = current return longest"},{"question":"from typing import List def count_unique_pairs(nums: List[int], target: int) -> int: Returns the count of unique pairs (i, j) where i < j and nums[i] + nums[j] == target. >>> count_unique_pairs([1, 2, 3, 4, 5], 5) 2 >>> count_unique_pairs([1, 2, 3], 10) 0 >>> count_unique_pairs([1, 1, 2, 2, 3, 3], 4) 2 >>> count_unique_pairs([2, 2, 2, 2], 4) 1 >>> count_unique_pairs([1, 5, 8, 10], 15) 1","solution":"def count_unique_pairs(nums, target): Returns the count of unique pairs (i, j) where i < j and nums[i] + nums[j] == target. count = 0 seen = set() pairs = set() for i in range(len(nums)): complement = target - nums[i] if complement in seen: pairs.add((min(nums[i], complement), max(nums[i], complement))) seen.add(nums[i]) count = len(pairs) return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n: int): Generates all structurally unique BSTs (binary search trees) that store values 1 to n. >>> len(generateTrees(1)) == 1 >>> len(generateTrees(2)) == 2 >>> len(generateTrees(3)) == 5 >>> len(generateTrees(0)) == 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def generateTrees(n): Generates all structurally unique BSTs (binary search trees) that store values 1 to n. if n == 0: return [] def generate_trees(start, end): if start > end: return [None] all_trees = [] for i in range(start, end + 1): # Generate all left and right subtrees left_trees = generate_trees(start, i - 1) right_trees = generate_trees(i + 1, end) for l in left_trees: for r in right_trees: current_tree = TreeNode(i) current_tree.left = l current_tree.right = r all_trees.append(current_tree) return all_trees return generate_trees(1, n)"},{"question":"from typing import List def can_reach_destination(grid: List[List[int]], k: int) -> bool: Determine if you can reach the bottom-right corner of the grid within the allowed elevation change k for all moves. Args: grid (List[List[int]]): 2D list representing elevation map. k (int): Maximum allowed elevation change per move. Returns: bool: True if you can reach the bottom-right corner, False otherwise. >>> can_reach_destination([[1, 2, 2], [3, 8, 2], [5, 3, 5]], 3) True >>> can_reach_destination([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) False >>> can_reach_destination([[1, 2, 3], [3, 8, 3], [2, 2, 2]], 1) True >>> can_reach_destination([[1, 2, 2], [3, 3, 3], [4, 4, 4]], 2) True >>> can_reach_destination([[1]], 5) True >>> can_reach_destination([[1, 10], [10, 1]], 8) False","solution":"def can_reach_destination(grid, k): from collections import deque rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid_move(x, y, nx, ny): return 0 <= nx < rows and 0 <= ny < cols and abs(grid[nx][ny] - grid[x][y]) <= k queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows - 1, cols - 1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(x, y, nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"def find_missing_element(nums1: List[int], nums2: List[int]) -> int: Returns the missing element that is present in nums1 but not in nums2. >>> find_missing_element([1, 2, 2, 3], [2, 3, 2]) == 1 >>> find_missing_element([4, 5, 6, 7, 8], [8, 6, 4, 7]) == 5 >>> find_missing_element([10, 20, 20, 30, 30], [30, 10, 20, 30]) == 20 >>> find_missing_element([1, 1], [1]) == 1 >>> find_missing_element([12], []) == 12 >>> find_missing_element([1, 2, 3], [2, 3]) == 1 >>> find_missing_element([5, 7, 9], [5, 9]) == 7 >>> find_missing_element([-1, -2, -3, -4], [-4, -1, -3]) == -2 >>> find_missing_element([0, -1, -2], [-2, 0]) == -1","solution":"def find_missing_element(nums1, nums2): Returns the missing element that is present in nums1 but not in nums2. element_counts = {} # Count elements in nums2 for num in nums2: if num in element_counts: element_counts[num] += 1 else: element_counts[num] = 1 # Find the missing element in nums1 for num in nums1: if num not in element_counts or element_counts[num] == 0: return num else: element_counts[num] -= 1"},{"question":"from typing import List def largest_rectangle_area(arr: List[int]) -> int: Returns the largest rectangular area that can be formed by choosing a contiguous subarray of buildings. :param arr: List[int] representing the heights of the buildings :return: int, the largest rectangular area >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10","solution":"def largest_rectangle_area(arr): Returns the largest rectangular area that can be formed by choosing a contiguous subarray of buildings. :param arr: List[int] representing the heights of the buildings :return: int, the largest rectangular area max_area = 0 stack = [] index = 0 while index < len(arr): if not stack or arr[stack[-1]] <= arr[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (arr[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class DocumentManager: Manages a collection of documents and allows for efficient keyword searching within the documents. Methods: - void addDocument(int id, string content): Adds a new document with the given \`id\` and \`content\` to the collection. If a document with the same \`id\` already exists, it replaces the existing content. - list<int> search(string keyword): Searches for documents containing the specified \`keyword\` and returns a list of their ids in ascending order. The keyword search should be case-insensitive. - void removeDocument(int id): Removes the document with the given \`id\` from the collection, if it exists. def __init__(self): pass def addDocument(self, id, content): Adds a new document with the given \`id\` and \`content\` to the collection. pass def search(self, keyword): Searches for documents containing the specified \`keyword\` and returns a list of their ids in ascending order. pass def removeDocument(self, id): Removes the document with the given \`id\` from the collection. pass # Unit tests def test_add_and_search_document(): manager = DocumentManager() manager.addDocument(1, \\"This is a test document.\\") assert manager.search(\\"test\\") == [1] def test_case_insensitive_search(): manager = DocumentManager() manager.addDocument(1, \\"This is a Test document.\\") assert manager.search(\\"test\\") == [1] assert manager.search(\\"TEST\\") == [1] def test_search_multiple_documents(): manager = DocumentManager() manager.addDocument(1, \\"First document content.\\") manager.addDocument(2, \\"Second document content containing a keyword.\\") manager.addDocument(3, \\"Keyword keyword multiple times.\\") assert manager.search(\\"keyword\\") == [2, 3] def test_replace_document_content(): manager = DocumentManager() manager.addDocument(1, \\"Initial content.\\") manager.addDocument(1, \\"Replaced content.\\") assert manager.search(\\"Initial\\") == [] assert manager.search(\\"Replaced\\") == [1] def test_remove_document(): manager = DocumentManager() manager.addDocument(1, \\"Some content.\\") manager.removeDocument(1) assert manager.search(\\"Some\\") == [] def test_no_search_results(): manager = DocumentManager() manager.addDocument(1, \\"Document with no matching keyword.\\") assert manager.search(\\"nonexistent\\") == [] def test_empty_document_manager(): manager = DocumentManager() assert manager.search(\\"anything\\") == []","solution":"class DocumentManager: def __init__(self): self.documents = {} def addDocument(self, id, content): Adds a new document with the given \`id\` and \`content\` to the collection. If a document with the same \`id\` already exists, it replaces the existing content. self.documents[id] = content def search(self, keyword): Searches for documents containing the specified \`keyword\` and returns a list of their ids in ascending order. The keyword search should be case-insensitive. keyword = keyword.lower() result = [doc_id for doc_id, content in self.documents.items() if keyword in content.lower()] return sorted(result) def removeDocument(self, id): Removes the document with the given \`id\` from the collection, if it exists. if id in self.documents: del self.documents[id]"},{"question":"def process_commands(commands): Processes a list of commands to modify a string, initially empty, and returns the final string after executing all the commands. Args: commands (list): List of strings representing commands. Returns: str: The resulting string after processing all commands. >>> process_commands(['add_a']) == 'a' >>> process_commands(['add_b', 'add_c']) == 'bc' >>> process_commands(['add_a', 'remove']) == '' >>> process_commands(['add_x', 'add_y', 'remove']) == 'x' >>> process_commands(['remove']) == '' >>> process_commands(['add_a', 'remove', 'undo']) == 'a' >>> process_commands(['add_a', 'add_b', 'undo']) == 'a' >>> process_commands(['add_x', 'add_y', 'undo', 'undo']) == '' >>> process_commands(['add_a', 'add_b', 'remove', 'undo']) == 'ab' >>> process_commands(['add_x', 'add_y', 'remove', 'remove', 'undo', 'undo']) == 'xy' >>> process_commands(['add_a', 'add_b', 'add_c', 'undo', 'remove', 'undo']) == 'ab' >>> process_commands([]) == '' >>> process_commands(['undo']) == '' >>> process_commands(['add_a', 'undo', 'undo', 'remove']) == '' >>> process_commands(['add_a', 'remove', 'remove', 'undo', 'remove']) == ''","solution":"def process_commands(commands): Processes a list of commands to modify a string, initially empty, and returns the final string after executing all the commands. Args: commands (list): List of strings representing commands. Returns: str: The resulting string after processing all commands. result = [] history = [] for command in commands: if command.startswith('add_'): char = command[4:] if len(char) == 1: result.append(char) history.append(('add', char)) elif command == 'remove': if result: last_char = result.pop() history.append(('remove', last_char)) elif command == 'undo': if history: last_command = history.pop() action, char = last_command if action == 'add': result.pop() elif action == 'remove': result.append(char) return ''.join(result)"},{"question":"def shifting_letters(s: str, shifts: List[int]) -> str: Shifts each character in the string s according to the corresponding value in the shifts array. >>> shifting_letters(\\"abc\\", [1, 1, 1]) \\"bcd\\" >>> shifting_letters(\\"xyz\\", [1, 1, 1]) \\"yza\\" >>> shifting_letters(\\"abc\\", [27, 28, 29]) \\"bdf\\" >>> shifting_letters(\\"abc\\", [0, 0, 0]) \\"abc\\" >>> shifting_letters(\\"abcdef\\", [1, 2, 3, 4, 5, 6]) \\"bdfhjl\\" >>> shifting_letters(\\"a\\", [25]) \\"z\\" >>> input_str = \\"abcdefghijklmnopqrstuvwxyz\\" >>> shifts = [0] * 26 >>> shifting_letters(input_str, shifts) input_str","solution":"def shifting_letters(s, shifts): Shifts each character in the string s according to the corresponding value in the shifts array. result = [] for i, char in enumerate(s): new_char = chr((ord(char) - ord('a') + shifts[i]) % 26 + ord('a')) result.append(new_char) return ''.join(result)"},{"question":"from typing import List class LogSystem: A log system to store and retrieve log entries based on multiple criteria. - LogSystem() : Initializes the log system. - put_log(log: str) : Adds a new log entry to the system. - get_logs(start_time: int, end_time: int, server_ids: List[str], log_level: str) -> List[str] : Returns the list of log entries that match the specified criteria. The logs should be within the time range provided [start_time, end_time] (inclusive both ends), originate from one of the specified server_ids, and have the given log_level. The log entries in the returned list should be sorted by timestamp in ascending order. >>> log_system = LogSystem() >>> log_system.put_log(\\"1000 server1 INFO Log entry 1\\") >>> log_system.put_log(\\"1001 server2 ERROR Log entry 2\\") >>> log_system.put_log(\\"1002 server1 INFO Log entry 3\\") >>> log_system.get_logs(1001, 1003, [\\"server1\\", \\"server2\\"], \\"INFO\\") ['1002 server1 INFO Log entry 3'] def __init__(self): pass def put_log(self, log: str): pass def get_logs(self, start_time: int, end_time: int, server_ids: List[str], log_level: str) -> List[str]: pass","solution":"from typing import List class LogSystem: def __init__(self): self.logs = [] def put_log(self, log: str): self.logs.append(log) def get_logs(self, start_time: int, end_time: int, server_ids: List[str], log_level: str) -> List[str]: result = [] for log in self.logs: parts = log.split() timestamp = int(parts[0]) server_id = parts[1] log_lvl = parts[2] if start_time <= timestamp <= end_time and server_id in server_ids and log_lvl == log_level: result.append(log) result.sort(key=lambda log: int(log.split()[0])) return result"},{"question":"def max_profit(projects: list, H: int) -> int: Returns the maximum profit given a list of projects and the total available hours. Parameters: projects (list): A list of pairs, each representing the profit and the hours required for a project. H (int): The total available hours. Returns: int: The maximum profit that can be achieved within the available hours. >>> max_profit([[10, 5]], 5) == 10 >>> max_profit([[10, 6]], 5) == 0 >>> max_profit([[10, 4], [20, 3], [30, 5]], 7) == 30 >>> max_profit([[10, 1], [15, 2], [25, 2]], 5) == 50 >>> max_profit([[10, 6], [15, 7], [25, 8]], 5) == 0 >>> max_profit([[10, 5], [20, 7], [30, 8]], 0) == 0 >>> max_profit([], 5) == 0","solution":"def max_profit(projects, H): Returns the maximum profit given a list of projects and the total available hours. Parameters: projects (list): A list of pairs, each representing the profit and the hours required for a project. H (int): The total available hours. Returns: int: The maximum profit that can be achieved within the available hours. # dp[i] will store the maximum profit possible with i hours available dp = [0] * (H + 1) # Iterate through each project for profit, hours in projects: # Traverse dp array backwards to avoid recomputation with the same project for h in range(H, hours - 1, -1): dp[h] = max(dp[h], dp[h - hours] + profit) return dp[H]"},{"question":"def min_water_tanks(heights: List[int], d: int) -> int: Determines the minimum number of water tanks required to ensure every building has access to water supply within a given distance \`d\`. Parameters: heights (list of int): The heights of the buildings. d (int): Maximum distance a water tank can supply water. Returns: int: Minimum number of water tanks required. >>> min_water_tanks([], 1) 0 >>> min_water_tanks([3], 1) 1 >>> min_water_tanks([1, 3, 2, 4, 5], 1) 3 >>> min_water_tanks([1, 3, 2, 4, 5], 2) 2 >>> min_water_tanks([1, 3, 2, 4, 5], 10) 1 >>> min_water_tanks([1, 3, 2, 4, 5], 4) 1 >>> min_water_tanks([1, 3, 2, 4, 5, 2, 3], 7) 1 pass","solution":"def min_water_tanks(heights, d): Determines the minimum number of water tanks required to ensure every building has access to water supply within a given distance \`d\`. Parameters: heights (list of int): The heights of the buildings. d (int): Maximum distance a water tank can supply water. Returns: int: Minimum number of water tanks required. n = len(heights) if n == 0: return 0 tanks = 0 i = 0 while i < n: tanks += 1 # Place a tank farthest_dist = i + d # Calculate the farthest distance for current tank # Find the best spot to place the tank (within the range which maximizes coverage) while i < n and i <= farthest_dist: i += 1 + d # Move to the next building outside the current tank's range if i >= n: # All buildings are covered break return tanks"},{"question":"def longest_concatenated_word(words: List[str]) -> str: Return the longest string in \`words\` that can be constructed by concatenating other strings from \`words\`. If there is no such string, return an empty string. >>> longest_concatenated_word([\\"cat\\",\\"dog\\",\\"catdog\\"]) 'catdog' >>> longest_concatenated_word([\\"cat\\",\\"dog\\",\\"catdog\\",\\"dogcatdog\\"]) 'dogcatdog' >>> longest_concatenated_word([\\"rat\\",\\"ratcat\\",\\"cat\\",\\"dog\\",\\"catdog\\",\\"dogcat\\",\\"ratcatdogcat\\"]) 'ratcatdogcat' >>> longest_concatenated_word([\\"a\\", \\"b\\", \\"ab\\", \\"abc\\"]) 'ab' >>> longest_concatenated_word([\\"not\\", \\"possible\\", \\"there\\"]) '' >>> longest_concatenated_word([]) '' >>> longest_concatenated_word([\\"a\\"]) '' >>> longest_concatenated_word([\\"a\\", \\"b\\", \\"ab\\", \\"c\\", \\"abc\\"]) 'abc'","solution":"def can_form_word(word, words_set, memo): Helper function to determine if a word can be formed by concatenating other words in the set. if word in memo: return memo[word] for i in range(1, len(word)): prefix = word[:i] suffix = word[i:] if prefix in words_set and (suffix in words_set or can_form_word(suffix, words_set, memo)): memo[word] = True return True memo[word] = False return False def longest_concatenated_word(words): Returns the longest string in words that can be constructed by concatenating other strings from words. If there is no such string, returns an empty string. words_set = set(words) memo = {} longest_word = \\"\\" for word in words: if can_form_word(word, words_set, memo): if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"from typing import List def shortest_distance_to_building(grid: List[List[int]]) -> List[List[int]]: Identify the shortest distance from each land cell to any building on a city map grid. The distance is measured in the number of steps in the four possible directions (up, down, left, right). If a land cell cannot reach any building, return -1 for that cell. >>> test_single_building() >>> test_multiple_buildings() >>> test_unreachable_land() >>> test_no_land() >>> test_no_buildings() >>> test_empty_grid() pass def test_single_building(): grid = [ [0, 1], [0, 0] ] assert shortest_distance_to_building(grid) == [ [1, -1], [2, 1] ] def test_multiple_buildings(): grid = [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] assert shortest_distance_to_building(grid) == [ [-1, 1, -1], [1, 2, 1], [-1, 1, -1] ] def test_unreachable_land(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 1] ] assert shortest_distance_to_building(grid) == [ [-1, 1, 2], [1, 2, 1], [2, 1, -1] ] def test_no_land(): grid = [ [1, 1], [1, 1] ] assert shortest_distance_to_building(grid) == [ [-1, -1], [-1, -1] ] def test_no_buildings(): grid = [ [0, 0], [0, 0] ] assert shortest_distance_to_building(grid) == [ [-1, -1], [-1, -1] ] def test_empty_grid(): grid = [] assert shortest_distance_to_building(grid) == []","solution":"from collections import deque def shortest_distance_to_building(grid): n = len(grid) if n == 0: return [] def bfs(start_row, start_col): queue = deque([(start_row, start_col, 0)]) visited = set([(start_row, start_col)]) distances = [[-1] * n for _ in range(n)] while queue: row, col, dist = queue.popleft() distances[row][col] = dist for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: r, c = row + dr, col + dc if 0 <= r < n and 0 <= c < n and (r, c) not in visited and grid[r][c] == 0: visited.add((r, c)) queue.append((r, c, dist + 1)) return distances result = [[-1] * n for _ in range(n)] for row in range(n): for col in range(n): if grid[row][col] == 0: result[row][col] = float('inf') for r in range(n): for c in range(n): if grid[r][c] == 1: building_distances = bfs(r, c) if building_distances[row][col] != -1: result[row][col] = min(result[row][col], building_distances[row][col]) if result[row][col] == float('inf'): result[row][col] = -1 return result"},{"question":"def minimized_maximum_sum(nums: List[int], k: int) -> int: You are given a **0-indexed** integer array \`nums\` with length \`n\` and an integer \`k\`. Your task is to partition the array into exactly \`k\` non-empty subsets such that the maximum sum of any subset is minimized. Return the minimized maximum sum. >>> minimized_maximum_sum([1, 2, 3, 4, 5], 3) 6 >>> minimized_maximum_sum([10], 1) 10 >>> minimized_maximum_sum([5, 5, 5, 5], 2) 10 >>> minimized_maximum_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> minimized_maximum_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 8) 9 >>> minimized_maximum_sum([10, 20, 30, 40, 50], 2) 90 >>> minimized_maximum_sum([3, 1, 4, 1, 5, 9], 10) 9","solution":"def can_partition(nums, k, max_sum): Helper function to check if we can partition the array into k subsets with each subset having a sum less than or equal to max_sum. current_sum = 0 subsets = 1 for num in nums: if current_sum + num > max_sum: subsets += 1 current_sum = num if subsets > k: return False else: current_sum += num return True def minimized_maximum_sum(nums, k): Returns the minimized maximum sum of any subset when partitioning the array into exactly k non-empty subsets. left, right = max(nums), sum(nums) result = right while left <= right: mid = (left + right) // 2 if can_partition(nums, k, mid): result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseList(head: ListNode) -> ListNode: Reverses a singly linked list. :param head: ListNode, the head of the linked list :return: ListNode, the new head of the reversed linked list","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def reverseList(head): Reverses a singly linked list. :param head: ListNode, the head of the linked list :return: ListNode, the new head of the reversed linked list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def min_changes_to_make_k_regular(arr: List[int], k: int) -> int: Returns the minimum number of changes needed to make the array k-regular. An array is defined as k-regular if each element in the array has the same parity (i.e., even or odd), and the difference between the maximum and minimum element is at most k. :param arr: List[int] - The input array of integers :param k: int - The regularity parameter :return: int - The minimum number of changes needed >>> min_changes_to_make_k_regular([2, 4, 6, 8], 3) 0 >>> min_changes_to_make_k_regular([1, 3, 5, 7], 2) 0 >>> min_changes_to_make_k_regular([2, 4, 1, 3], 5) 2 >>> min_changes_to_make_k_regular([1, 2, 3, 4], 4) 2 >>> min_changes_to_make_k_regular([1, 2, 3, 4, 5, 6, 7, 8], 5) 4 >>> min_changes_to_make_k_regular([7], 3) 0 >>> min_changes_to_make_k_regular([], 10) 0","solution":"def min_changes_to_make_k_regular(arr, k): Returns the minimum number of changes needed to make the array k-regular. :param arr: List[int] - The input array of integers :param k: int - The regularity parameter :return: int - The minimum number of changes needed n = len(arr) evens = sum(1 for x in arr if x % 2 == 0) odds = n - evens changes_to_all_even = odds changes_to_all_odd = evens return min(changes_to_all_even, changes_to_all_odd)"},{"question":"from typing import List def countReachableCells(grid: List[List[int]], waterLevel: int) -> int: Return the total number of distinct cells that can be reached starting from any non-flooded cell in the given grid. >>> countReachableCells([], 1) 0 >>> countReachableCells([[0, 1], [1, 1]], 1) 0 >>> countReachableCells([[2, 3], [3, 4]], 1) 4 >>> countReachableCells([[2, 1, 3], [0, 3, 1], [4, 2, 2]], 1) 6 >>> countReachableCells([[2], [1], [3], [0], [4]], 1) 3 >>> countReachableCells([[2, 1, 3, 0, 4]], 1) 3","solution":"def countReachableCells(grid, waterLevel): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False for _ in range(n)] for _ in range(m)] def is_valid(x, y): return 0 <= x < m and 0 <= y < n and not visited[x][y] and grid[x][y] > waterLevel def dfs(x, y): stack = [(x, y)] count = 0 while stack: cx, cy = stack.pop() if not is_valid(cx, cy): continue visited[cx][cy] = True count += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if is_valid(nx, ny): stack.append((nx, ny)) return count reachable_cells = 0 for i in range(m): for j in range(n): if grid[i][j] > waterLevel and not visited[i][j]: reachable_cells += dfs(i, j) return reachable_cells"},{"question":"def count_unique_pairs(arr: List[int], target: int) -> int: Returns the number of unique pairs of integers in \`arr\` whose sum is equal to \`target\`. >>> count_unique_pairs([1, 2, 3, 4, 3], 6) 2 >>> count_unique_pairs([1, 5, 1, 5], 6) 1 >>> count_unique_pairs([1, 2, 3, 4], 8) 0 >>> count_unique_pairs([2, 2, 2, 2], 4) 1 >>> count_unique_pairs([1, 9, 2, 8, 3, 7, 4, 6, 5], 10) 4 >>> count_unique_pairs([], 5) 0 >>> count_unique_pairs([5], 5) 0 >>> count_unique_pairs([1, 2, 3, 4, 5], 6) 2 >>> count_unique_pairs([1, 2, 3, 4, 5], 7) 2 pass","solution":"def count_unique_pairs(arr, target): Returns the number of unique pairs of integers in \`arr\` whose sum is equal to \`target\`. seen = set() unique_pairs = set() for num in arr: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) unique_pairs.add(pair) seen.add(num) return len(unique_pairs)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Given a binary tree, return the maximum depth of the tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. :param root: TreeNode, the root node of the binary tree :return: int, maximum depth of the binary tree >>> max_depth(None) 0 >>> max_depth(TreeNode(1)) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> max_depth(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> max_depth(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> max_depth(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> root.right = TreeNode(5) >>> max_depth(root) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root): Returns the maximum depth of the binary tree with root node as root. :param root: TreeNode, the root node of the binary tree :return: int, maximum depth of the binary tree if root is None: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"def longest_k_distinct_subsequence(s: str, k: int) -> int: Returns the length of the longest k-distinct subsequence of s. A subsequence of s is created by deleting some (or none) of the characters in s without changing the order of the remaining characters. A subsequence is considered k-distinct if it contains at most k distinct characters. Parameters: s (str): The string in which we are finding the subsequence. k (int): The maximum number of distinct characters allowed in the subsequence. Returns: int: The length of the longest k-distinct subsequence. >>> longest_k_distinct_subsequence(\\"abcba\\", 2) 3 >>> longest_k_distinct_subsequence(\\"abc\\", 0) 0 >>> longest_k_distinct_subsequence(\\"aaaaa\\", 1) 5 >>> longest_k_distinct_subsequence(\\"abcde\\", 5) 5 >>> longest_k_distinct_subsequence(\\"aabbcc\\", 2) 4 >>> longest_k_distinct_subsequence(\\"abcdefghi\\", 10) 9 pass","solution":"def longest_k_distinct_subsequence(s, k): Returns the length of the longest k-distinct subsequence of s. Parameters: s (str): The string in which we are finding the subsequence. k (int): The maximum number of distinct characters allowed in the subsequence. Returns: int: The length of the longest k-distinct subsequence. if k == 0: return 0 from collections import defaultdict n = len(s) char_counts = defaultdict(int) distinct_count = 0 left = 0 max_length = 0 for right in range(n): if char_counts[s[right]] == 0: distinct_count += 1 char_counts[s[right]] += 1 while distinct_count > k: char_counts[s[left]] -= 1 if char_counts[s[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_healthy_plants(plants, unhealthy_days, k): Determines the maximum number of healthy plants after k days. Parameters: plants (list): A list of integers representing plant types. unhealthy_days (int): The number of days within which a plant must be watered to remain healthy. k (int): The number of days available to water the plants. Returns: int: The maximum number of healthy plants. Example: >>> max_healthy_plants([1, 2, 3, 4, 5], 2, 10) 5 >>> max_healthy_plants([1, 2, 3], 5, 3) 0 >>> max_healthy_plants([1, 2], 2, 4) 2 >>> max_healthy_plants([1, 2, 3], 2, 0) 0 >>> max_healthy_plants([1, 2, 3, 4], 1, 4) 4","solution":"def max_healthy_plants(plants, unhealthy_days, k): Determines the maximum number of healthy plants after k days. Parameters: plants (list): A list of integers representing plant types. unhealthy_days (int): The number of days within which a plant must be watered to remain healthy. k (int): The number of days available to water the plants. Returns: int: The maximum number of healthy plants. total_plants = len(plants) if unhealthy_days > k: return 0 # Not enough days to keep any plant healthy plant_water_count = [0] * total_plants for day in range(k): plant_water_count[day % total_plants] += 1 # Water the plant as per its watering schedule healthy_plants = sum(1 for water_count in plant_water_count if water_count >= unhealthy_days) return healthy_plants"},{"question":"def maxJumps(arr: List[int], d: int) -> int: Determine the maximum number of indices you can visit starting from any index in the array. You are given an array of integers \`arr\` and an integer \`d\`. In one step, you can move from index \`i\` to index \`i + j\` or \`i - j\` where \`1 <= j <= d\` and \`arr[i] > arr[i + j]\` or \`arr[i] > arr[i - j]\` respectively. You cannot move outside of the array boundaries. Determine the maximum number of indices you can visit starting from any index in the array. Note that you must move strictly to a smaller integer at each step. Examples: >>> maxJumps([6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2) 4 >>> maxJumps([3, 3, 3, 3, 3], 3) 1 >>> maxJumps([7, 6, 5, 4, 3, 2, 1], 1) 7 >>> maxJumps([7, 1, 7, 1, 7, 1], 2) 2 >>> maxJumps([66], 1) 1","solution":"def maxJumps(arr, d): Returns the maximum number of indices that can be visited starting from any index in the array. n = len(arr) # Memoization table. memo = [-1] * n def dfs(i): if memo[i] != -1: return memo[i] max_jump_count = 1 # Move to the right for j in range(i + 1, min(n, i + d + 1)): if arr[i] > arr[j]: max_jump_count = max(max_jump_count, 1 + dfs(j)) else: break # Move to the left for j in range(i - 1, max(-1, i - d - 1), -1): if arr[i] > arr[j]: max_jump_count = max(max_jump_count, 1 + dfs(j)) else: break memo[i] = max_jump_count return max_jump_count max_count = 0 for i in range(n): max_count = max(max_count, dfs(i)) return max_count"},{"question":"def max_length_subarray(arr: List[int], d: int) -> int: Returns the maximum length of a subarray where the absolute difference between the maximum value and the minimum value in the subarray does not exceed d. >>> max_length_subarray([4, 7, 2, 9, 3], 3) == 2 >>> max_length_subarray([1], 0) == 1 >>> max_length_subarray([3, 3, 3, 3], 0) == 4 >>> max_length_subarray([1, 10, 20, 30, 40], 5) == 1 >>> max_length_subarray([1, 3, 2, 1, 5, 1, 2], 4) == 7 >>> max_length_subarray([], 1) == 0 >>> max_length_subarray([10, 20], 15) == 2 >>> max_length_subarray([10, 20], 5) == 1","solution":"def max_length_subarray(arr, d): Returns the maximum length of a subarray where the absolute difference between the maximum value and the minimum value in the subarray does not exceed d. from collections import deque if not arr: return 0 max_len = 0 min_dq, max_dq = deque(), deque() left = 0 for right in range(len(arr)): while min_dq and arr[min_dq[-1]] >= arr[right]: min_dq.pop() while max_dq and arr[max_dq[-1]] <= arr[right]: max_dq.pop() min_dq.append(right) max_dq.append(right) while arr[max_dq[0]] - arr[min_dq[0]] > d: if min_dq[0] == left: min_dq.popleft() if max_dq[0] == left: max_dq.popleft() left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def min_cuts_to_form_beam(nums: List[int], k: int) -> int: Determines the minimum number of cuts needed to form beams of length \`k\` using the provided logs (nums). If it is not possible, returns -1. >>> min_cuts_to_form_beam([5, 4, 3, 7], 10) 2 >>> min_cuts_to_form_beam([10], 10) 1 >>> min_cuts_to_form_beam([5, 4, 3, 2], 6) 2 >>> min_cuts_to_form_beam([1, 2, 3], 7) -1 >>> min_cuts_to_form_beam([5, 4, 3, 2], 0) 0 >>> min_cuts_to_form_beam([15, 20, 25], 15) 1 >>> min_cuts_to_form_beam([], 10) -1","solution":"from typing import List def min_cuts_to_form_beam(nums: List[int], k: int) -> int: Determines the minimum number of cuts needed to form beams of length \`k\` using the provided logs (nums). If it is not possible, returns -1. # Edge case: if k is zero, no cuts needed. if k == 0: return 0 # Sort the list of logs in descending order nums.sort(reverse=True) # Helper function to check if we can make the beam of length \`k\` with available logs def can_make_beam(nums, k): n = len(nums) dp = [float('inf')] * (k + 1) dp[0] = 0 for num in nums: for i in range(k, num - 1, -1): dp[i] = min(dp[i], dp[i - num] + 1) return dp[k] if dp[k] != float('inf') else -1 result = can_make_beam(nums, k) return result"},{"question":"def max_sum_subarray_k(nums, k): Returns the maximum sum of any non-empty subarray of length 'k' in the array 'nums'. If 'nums' length is less than 'k', return 0. >>> max_sum_subarray_k([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray_k([1, -2, 3, -4, 5, 6], 3) 7 >>> max_sum_subarray_k([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray_k([5, -1, -2, 6, 3, 4, -5, 2], 3) 13 >>> max_sum_subarray_k([1, 2], 3) 0 >>> max_sum_subarray_k([3], 1) 3 >>> max_sum_subarray_k([1, 4, 2, 10, 23, 3, 1, 0, 20], 4) 39 >>> max_sum_subarray_k([-3, -2, -1], 2) -3 >>> max_sum_subarray_k([-2, -1, 0, 1, 2], 3) 3 >>> max_sum_subarray_k([], 1) 0 >>> max_sum_subarray_k([5, 5, 5, 5, 5], 3) 15 >>> max_sum_subarray_k([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) 55","solution":"def max_sum_subarray_k(nums, k): Returns the maximum sum of any non-empty subarray of length 'k' in the array 'nums'. If 'nums' length is less than 'k', return 0. n = len(nums) if n < k: return 0 # Compute the sum of the first subarray of length k max_sum = sum(nums[:k]) current_sum = max_sum # Use a sliding window to compute the sum of the remaining subarrays of length k for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def has_special_diagonal(matrix: list[list[int]]) -> bool: Checks if the given square matrix has a special diagonal. A matrix has a special diagonal if either the main diagonal (top-left to bottom-right) or the anti-diagonal (top-right to bottom-left) contains all the same values. Args: matrix (list of list of int): The square matrix to check. Returns: bool: True if the matrix has a special diagonal, False otherwise. pass # Test cases def test_has_special_diagonal_main_diag_special(): matrix = [ [1, 2, 3], [4, 1, 6], [7, 8, 1] ] assert has_special_diagonal(matrix) == True def test_has_special_diagonal_anti_diag_special(): matrix = [ [2, 2, 1], [4, 1, 6], [1, 8, 7] ] assert has_special_diagonal(matrix) == True def test_has_special_diagonal_no_special_diag(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert has_special_diagonal(matrix) == False def test_has_special_diagonal_single_element(): matrix = [ [1] ] assert has_special_diagonal(matrix) == True def test_has_special_diagonal_all_elements_same(): matrix = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert has_special_diagonal(matrix) == True","solution":"def has_special_diagonal(matrix): Checks if the given square matrix has a special diagonal. A matrix has a special diagonal if either the main diagonal (top-left to bottom-right) or the anti-diagonal (top-right to bottom-left) contains all the same values. Args: matrix (list of list of int): The square matrix to check. Returns: bool: True if the matrix has a special diagonal, False otherwise. size = len(matrix) # Check main diagonal main_diag_value = matrix[0][0] main_diag_special = all(matrix[i][i] == main_diag_value for i in range(size)) # Check anti-diagonal anti_diag_value = matrix[0][size-1] anti_diag_special = all(matrix[i][size-1-i] == anti_diag_value for i in range(size)) return main_diag_special or anti_diag_special"},{"question":"def longest_substring_same_char(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, return the length of the longest substring with all characters the same. >>> longest_substring_same_char(\\"aaabbccaa\\") 3 >>> longest_substring_same_char(\\"\\") 0 >>> longest_substring_same_char(\\"a\\") 1 >>> longest_substring_same_char(\\"abcdefg\\") 1 >>> longest_substring_same_char(\\"aaaaa\\") 5 >>> longest_substring_same_char(\\"aabbbccddeee\\") 3 >>> longest_substring_same_char(\\"bbbaannnaa\\") 3 >>> longest_substring_same_char(\\"aabbbaaccc\\") 3 >>> longest_substring_same_char(\\"aaabbccc\\") 3","solution":"def longest_substring_same_char(s): Given a string s consisting of lowercase English letters, return the length of the longest substring with all characters the same. if not s: return 0 max_length = current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"class TreeNode: Definition for a binary tree node. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root: TreeNode, targetSum: int) -> List[List[int]]: Given a binary tree, return the list of all root-to-leaf paths such that the sum of the values of the nodes in each path is equal to targetSum. Each path should be represented as a list of node values, and the result should be returned as a list of these lists. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(1) >>> root.right.right = TreeNode(1) >>> pathSum(root, 4) [[1, 2, 1], [1, 2, 1]] >>> root = TreeNode(5) >>> pathSum(root, 5) [[5]] >>> pathSum(root, 7) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pathSum(root, targetSum): Returns all root-to-leaf paths in a binary tree where the sum of the node values in each path equals targetSum. def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == targetSum: result.append(list(current_path)) dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"def valid_word_square(words: List[str]) -> bool: Check if the given list of words forms a valid word square. >>> valid_word_square([\\"abcd\\", \\"bnrt\\", \\"crmy\\", \\"dtye\\"]) == True >>> valid_word_square([\\"ball\\", \\"area\\", \\"read\\", \\"lady\\"]) == False >>> valid_word_square([\\"abcd\\", \\"bnet\\", \\"crmy\\", \\"dtye\\"]) == False >>> valid_word_square([\\"a\\"]) == True >>> valid_word_square([\\"\\"]) == True >>> valid_word_square([\\"\\", \\"\\", \\"\\"]) == True >>> valid_word_square([\\"abc\\", \\"b\\"]) == False >>> valid_word_square([\\"Aba\\", \\"bBy\\", \\"aYX\\"]) == False","solution":"def valid_word_square(words): Check if the given list of words forms a valid word square. :param words: List of strings, where each string represents a row. :return: True if the words form a valid word square, False otherwise. n = len(words) for i in range(n): for j in range(len(words[i])): if j >= n or i >= len(words[j]) or words[i][j] != words[j][i]: return False return True"},{"question":"def max_area_of_island(grid): Given a grid of size \`m x n\` consisting of \`1's\` (land) and \`0's\` (water), an **island** is a group of \`1's\` (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water. The **area** of an island is the number of cells with value \`1\` in the island. Write an algorithm to return the size of the largest island. If there is no island, return \`0\`. >>> max_area_of_island([]) == 0 >>> max_area_of_island([[]]) == 0 >>> max_area_of_island([[0]]) == 0 >>> max_area_of_island([[1]]) == 1 >>> max_area_of_island([[0, 1, 0], [0, 1, 1], [0, 0, 1]]) == 4 >>> max_area_of_island([[1, 0, 0, 1], [1, 0, 1, 1], [0, 1, 1, 0], [0, 0, 0, 1]]) == 5 >>> max_area_of_island([[0, 0, 1, 0, 0], [0, 1, 1, 1, 0], [0, 0, 1, 0, 0], [1, 1, 0, 0, 1], [1, 0, 0, 1, 1]]) == 5","solution":"def max_area_of_island(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0: return 0 grid[x][y] = 0 # mark as visited return 1 + dfs(x + 1, y) + dfs(x - 1, y) + dfs(x, y + 1) + dfs(x, y - 1) max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"def is_valid_parentheses(s: str) -> bool: Check if the string can be valid by replacing all '*' with '(', ')' or ''. >>> is_valid_parentheses('') True >>> is_valid_parentheses('()') True >>> is_valid_parentheses('((*)') True >>> is_valid_parentheses('((()') False","solution":"def is_valid_parentheses(s): Returns true if the string can be valid by replacing all '*' with '(', ')' or '' left_balance = right_balance = 0 for char in s: if char in '(*': left_balance += 1 else: left_balance -= 1 if char != '(': right_balance -= 1 else: right_balance += 1 if left_balance < 0: return False right_balance = max(right_balance, 0) return right_balance == 0"},{"question":"def longestLine(matrix): Given a 2D matrix where each cell contains either a 0 or a 1, find the length of the longest line of consecutive 1s in the matrix. The line could be horizontal, vertical, diagonal, or anti-diagonal. >>> longestLine([]) 0 >>> longestLine([[0, 0], [0, 0]]) 0 >>> longestLine([[1, 1], [1, 1]]) 2 >>> longestLine([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ]) 3 >>> longestLine([ ... [1, 1, 0], ... [0, 1, 1], ... [1, 0, 1] ... ]) 3 >>> longestLine([ ... [0, 0, 1], ... [0, 1, 0], ... [1, 0, 0] ... ]) 3","solution":"def longestLine(matrix): if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_len = 0 # Create 3D dp array dp = [[[0]*4 for _ in range(cols)] for _ in range(rows)] for i in range(rows): for j in range(cols): if matrix[i][j] == 1: # Horizontal dp[i][j][0] = dp[i][j-1][0] + 1 if j > 0 else 1 # Vertical dp[i][j][1] = dp[i-1][j][1] + 1 if i > 0 else 1 # Diagonal dp[i][j][2] = dp[i-1][j-1][2] + 1 if i > 0 and j > 0 else 1 # Anti-diagonal dp[i][j][3] = dp[i-1][j+1][3] + 1 if i > 0 and j < cols-1 else 1 # Updating max_len max_len = max(max_len, dp[i][j][0], dp[i][j][1], dp[i][j][2], dp[i][j][3]) return max_len"},{"question":"from collections import deque class MovingAverage: def __init__(self, k: int): Initializes the data structure with the integer k, the size of the moving window. pass def next(self, val: int) -> float: Inserts the value val into the stream and returns the moving average of the last k integers. >>> ma = MovingAverage(3) >>> ma.next(1) 1.0 >>> ma.next(10) 5.5 >>> ma.next(3) 4.666666666666667 >>> ma.next(5) 6.0 pass","solution":"from collections import deque class MovingAverage: def __init__(self, k): Initializes the data structure with the integer k, the size of the moving window. self.k = k self.window = deque() self.sum = 0 def next(self, val): Inserts the value val into the stream and returns the moving average of the last k integers. If there are fewer than k elements in the stream, calculate the average of all elements present. # Add new value to the window self.window.append(val) self.sum += val # If the window contains more than k elements, remove the oldest one if len(self.window) > self.k: removed_val = self.window.popleft() self.sum -= removed_val # Return the current moving average return self.sum / len(self.window)"},{"question":"def min_minutes_to_goal(sprint: List[int], goal: int) -> int: Returns the minimum number of minutes needed to cover the goal distance. If it is not possible to cover the goal distance, returns -1. >>> min_minutes_to_goal([1, 2, 3, 4, 5], 15) == 5 >>> min_minutes_to_goal([1, 2, 3, 4, 5, 1, 1, 1, 1, 1], 6) == 2 >>> min_minutes_to_goal([1, 2, 3, 4, 5], 11) == 3 >>> min_minutes_to_goal([1, 1, 1, 1, 1], 3) == 3 >>> min_minutes_to_goal([1, 1, 1, 1, 1], 6) == -1 >>> min_minutes_to_goal([5, 5, 5, 5], 5) == 1 >>> min_minutes_to_goal([], 5) == -1 >>> min_minutes_to_goal([1], 1) == 1 >>> min_minutes_to_goal([10], 5) == 1 >>> min_minutes_to_goal([0, 0, 3, 0], 3) == 1","solution":"def min_minutes_to_goal(sprint, goal): Returns the minimum number of minutes needed to cover the goal distance. If it is not possible to cover the goal distance, returns -1. running_sum = 0 # Initialize running sum to 0 min_minutes = float('inf') # Initialize minimum minutes to infinity start_index = 0 # Starting index for end_index in range(len(sprint)): running_sum += sprint[end_index] while running_sum >= goal: min_minutes = min(min_minutes, end_index - start_index + 1) running_sum -= sprint[start_index] start_index += 1 return min_minutes if min_minutes != float('inf') else -1"},{"question":"def min_cost_climbing_stairs(cost): Given an array of integers \`cost\` where each integer represents the cost of a step on a staircase, this function returns the minimum cost to reach the top of the staircase. You can either start from the step with index 0 or the step with index 1. Once you pay the cost to get to a step, you can either climb one or two steps. The function should return the minimum cost to reach the top of the staircase. >>> min_cost_climbing_stairs([10, 15, 20]) == 15 >>> min_cost_climbing_stairs([10]) == 10 >>> min_cost_climbing_stairs([]) == 0 >>> min_cost_climbing_stairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]) == 6 >>> min_cost_climbing_stairs([5, 5, 5, 5, 5, 5, 5, 5]) == 20 >>> min_cost_climbing_stairs([0, 0, 1, 1]) == 1","solution":"def min_cost_climbing_stairs(cost): Given an array of integers \`cost\` where cost[i] is the cost of the i-th step on a staircase, this function returns the minimum cost to reach the top of the staircase. You can either start from the step with index 0 or 1. n = len(cost) if n == 0: return 0 elif n == 1: return cost[0] # Minimum cost to reach the top starts from the first two steps first = cost[0] second = cost[1] for i in range(2, n): current = cost[i] + min(first, second) first, second = second, current return min(first, second)"},{"question":"def trap(height: List[int]) -> int: Returns the total amount of trapped rainwater given the heights of the histogram bars. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([2, 1, 2]) 1 >>> trap([3, 3, 3, 3]) 0 >>> trap([]) 0 >>> trap([4]) 0 >>> trap([4, 2]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): Returns the total amount of trapped rainwater given the heights of the histogram bars. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def can_hire(candidates, k, maxDifference): Determines if it's possible to hire k candidates such that the highest difference in their skill levels does not exceed maxDifference. :param candidates: List of integers representing skill levels of candidates. :param k: Integer representing the number of candidates to hire. :param maxDifference: Integer representing the maximum allowed difference in skill levels. :return: Boolean value indicating if it's possible to hire k candidates within the maxDifference. from solution import can_hire def test_can_hire_example1(): assert can_hire([1, 3, 5, 9, 10], 3, 4) == True def test_can_hire_example2(): assert can_hire([1, 3, 5, 9, 10], 3, 2) == False def test_can_hire_example3(): assert can_hire([1, 2, 3], 2, 1) == True def test_can_hire_not_enough_candidates(): assert can_hire([4, 10, 5], 4, 10) == False def test_can_hire_exact_difference(): assert can_hire([4, 10, 5, 6], 2, 6) == True def test_can_hire_single_candidate(): assert can_hire([7], 1, 0) == True def test_can_hire_equal_candidates(): assert can_hire([5, 5, 5, 5], 2, 0) == True","solution":"def can_hire(candidates, k, maxDifference): Determines if it's possible to hire k candidates such that the highest difference in their skill levels does not exceed maxDifference. :param candidates: List of integers representing skill levels of candidates. :param k: Integer representing the number of candidates to hire. :param maxDifference: Integer representing the maximum allowed difference in skill levels. :return: Boolean value indicating if it's possible to hire k candidates within the maxDifference. # Sort candidates by their skill levels in descending order candidates.sort(reverse=True) for i in range(len(candidates) - k + 1): # Check the difference between the highest and lowest in this window if candidates[i] - candidates[i + k - 1] <= maxDifference: return True return False"},{"question":"def rob(nums: List[int]) -> int: Calculate the maximum amount of money the thief can steal without triggering the alarm. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([2, 7]) == 7 >>> rob([2, 7, 9]) == 11 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([2, 1, 1, 2]) == 4 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41","solution":"def rob(nums): Calculates the maximum amount of money the thief can steal without triggering the alarm. if not nums: return 0 elif len(nums) == 1: return nums[0] n = len(nums) dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"def min_insertions_to_transform(s: str, t: str) -> int: Returns the minimum number of insertions required to transform \`s\` into \`t\`. If it's not possible, returns -1. >>> min_insertions_to_transform(\\"abc\\", \\"aebdc\\") == 2 >>> min_insertions_to_transform(\\"abc\\", \\"abc\\") == 0 >>> min_insertions_to_transform(\\"abc\\", \\"abd\\") == -1 >>> min_insertions_to_transform(\\"\\", \\"abc\\") == 3 >>> min_insertions_to_transform(\\"abc\\", \\"\\") == -1 >>> min_insertions_to_transform(\\"aaa\\", \\"aaaaaa\\") == 3","solution":"def min_insertions_to_transform(s, t): Returns the minimum number of insertions required to transform \`s\` into \`t\`. If it's not possible, returns -1. si, ti = 0, 0 while si < len(s) and ti < len(t): if s[si] == t[ti]: si += 1 ti += 1 # If some characters in \`s\` have not been matched, it's impossible to transform \`s\` into \`t\` if si != len(s): return -1 # Number of insertions needed is the remaining unmatched characters in \`t\` return len(t) - len(s)"},{"question":"class StringIterator: Develop a StringIterator class that supports the following operations: 1. StringIterator(String compressedString) Initializes the StringIterator object with a compressed string. 2. char next() Returns the next character if the original string still has characters to be extracted, otherwise returns ' ' (a single space). 3. boolean hasNext() Returns true if the original string still has characters to be extracted, otherwise returns false. >>> iterator = StringIterator(\\"a2b3\\") >>> iterator.next() 'a' >>> iterator.next() 'a' >>> iterator.next() 'b' >>> iterator.next() 'b' >>> iterator.next() 'b' >>> iterator.next() ' ' >>> iterator.hasNext() False >>> iterator = StringIterator(\\"\\") >>> iterator.next() ' ' >>> iterator.hasNext() False >>> iterator = StringIterator(\\"c1\\") >>> iterator.next() 'c' >>> iterator.next() ' ' >>> iterator.hasNext() False >>> iterator = StringIterator(\\"x3y2z1\\") >>> iterator.next() 'x' >>> iterator.next() 'x' >>> iterator.next() 'x' >>> iterator.next() 'y' >>> iterator.next() 'y' >>> iterator.next() 'z' >>> iterator.next() ' ' >>> iterator.hasNext() False","solution":"class StringIterator: def __init__(self, compressedString): self.chars = [] self.counts = [] i = 0 while i < len(compressedString): char = compressedString[i] i += 1 count = 0 while i < len(compressedString) and compressedString[i].isdigit(): count = count * 10 + int(compressedString[i]) i += 1 self.chars.append(char) self.counts.append(count) self.index = 0 self.char_count = 0 def next(self): if not self.hasNext(): return ' ' if self.char_count == 0: self.current_char = self.chars[self.index] self.char_count = self.counts[self.index] self.index += 1 self.char_count -= 1 return self.current_char def hasNext(self): return self.index < len(self.chars) or self.char_count > 0"},{"question":"def max_good_words(s: str, words: List[str]) -> int: Returns the maximum number of good words that can appear in s without overlapping. :param s: The main string :param words: List of words to be checked in the string :return: Maximum number of good words >>> max_good_words(\\"abcdabcdabcd\\", [\\"abc\\", \\"bcd\\"]) 3 >>> max_good_words(\\"abcdabcd\\", [\\"abc\\", \\"d\\"]) 4 >>> max_good_words(\\"abcdefg\\", [\\"xyz\\", \\"pqr\\"]) 0 >>> max_good_words(\\"ababab\\", [\\"ab\\", \\"ba\\"]) 3 >>> max_good_words(\\"aabbaabbaa\\", [\\"aab\\", \\"baa\\"]) 3","solution":"def max_good_words(s, words): Returns the maximum number of good words that can appear in s without overlapping. :param s: The main string :param words: List of words to be checked in the string :return: Maximum number of good words start = 0 count = 0 while start < len(s): found = False for word in words: if s.startswith(word, start): count += 1 start += len(word) found = True break if not found: start += 1 return count"},{"question":"def kthSmallestElement(arr, k): You are given an integer array \`arr\` and an integer \`k\`. Implement a function that returns the \`kth\` smallest element in the merged sorted array when \`arr\` is partitioned into exactly \`k\` non-overlapping, non-empty subarrays such that each subarray is individually sorted and then merged. Ensure that your algorithm is optimized for large values of \`k\` and the length of \`arr\`. >>> kthSmallestElement([3, 1, 2, 1, 4], 1) == 1 >>> kthSmallestElement([3, 1, 2, 1, 4], 2) == 1 >>> kthSmallestElement([3, 1, 2, 1, 4], 3) == 2 >>> kthSmallestElement([3, 1, 2, 1, 4], 4) == 3 >>> kthSmallestElement([3, 1, 2, 1, 4], 5) == 4 >>> kthSmallestElement([], 3) == None >>> kthSmallestElement([1, 2, 3], 5) == None >>> kthSmallestElement([1], 1) == 1 >>> kthSmallestElement([2, 2, 2, 2], 3) == 2","solution":"def kthSmallestElement(arr, k): if not arr or k == 0: return None n = len(arr) if k > n: return None # Step 1: Sort the array arr.sort() # Step 2: Determine the size of each partition partition_size = n // k extra_elements = n % k partitions = [] index = 0 # Step 3: Create partitions for i in range(k): if i < extra_elements: partitions.append(arr[index:index + partition_size + 1]) index += partition_size + 1 else: partitions.append(arr[index:index + partition_size]) index += partition_size # Step 4: Merge the partitions. We use a min-heap to efficiently find the kth element import heapq min_heap = [] for partition in partitions: for num in partition: heapq.heappush(min_heap, num) # Step 5: Extract the kth smallest element for _ in range(k - 1): heapq.heappop(min_heap) return heapq.heappop(min_heap)"},{"question":"def three_consecutive_odds(arr): Returns True if there are three consecutive odd numbers in the list \`arr\`. Otherwise, returns False. >>> three_consecutive_odds([2, 6, 4, 1, 3, 5, 7]) True >>> three_consecutive_odds([1, 3, 5, 7, 9]) True >>> three_consecutive_odds([2, 6, 4, 8, 10]) False >>> three_consecutive_odds([1, 2, 4, 6, 8]) False >>> three_consecutive_odds([1, 3]) False >>> three_consecutive_odds([]) False >>> three_consecutive_odds([1, 3, 5]) True >>> three_consecutive_odds([2, 1, 3, 5, 7, 9]) True","solution":"def three_consecutive_odds(arr): Returns True if there are three consecutive odd numbers in the list \`arr\`. Otherwise, returns False. count = 0 for num in arr: if num % 2 != 0: # num is odd count += 1 if count == 3: return True else: count = 0 return False"},{"question":"def count_unique_subarrays(nums: List[int], k: int) -> int: Returns the count of unique subarrays of length k with all distinct elements. >>> count_unique_subarrays([1, 2, 3, 1, 2, 3], 3) 3 >>> count_unique_subarrays([1, 1, 1, 1], 2) 0 >>> count_unique_subarrays([1, 2, 3, 4, 5], 3) 3 >>> count_unique_subarrays([1, 2], 3) 0 >>> count_unique_subarrays([1, 2, 1, 2, 1, 2], 2) 2","solution":"def count_unique_subarrays(nums, k): Returns the count of unique subarrays of length k with all distinct elements. if len(nums) < k: return 0 unique_subarrays = set() for i in range(len(nums) - k + 1): subarray = nums[i:i + k] if len(set(subarray)) == k: unique_subarrays.add(tuple(subarray)) return len(unique_subarrays)"},{"question":"class Bank: Design a class that emulates a bank's transaction process where each account has a unique identifier. - Bank(long[] balance) initializes the Bank object with balance, an array representing the initial balances of each account. - boolean transfer(int account1, int account2, long amount) transfers amount from the account with ID account1 to the account with ID account2. Returns true if the transaction was successful, otherwise false. - boolean deposit(int account, long amount) deposits amount into the account with ID account. Returns true if the deposit was successful. - boolean withdraw(int account, long amount) withdraws amount from the account with ID account. Returns true if the withdrawal was successful. >>> bank = Bank([100, 200, 300]) >>> bank.deposit(1, 50) # returns True >>> bank.balance # returns [150, 200, 300] >>> bank.withdraw(1, 50) # returns True >>> bank.balance # returns [100, 200, 300] >>> bank.transfer(1, 2, 50) # returns True >>> bank.balance # returns [50, 250, 300] def __init__(self, balance): pass def transfer(self, account1, account2, amount): pass def deposit(self, account, amount): pass def withdraw(self, account, amount): pass","solution":"class Bank: def __init__(self, balance): self.balance = balance def transfer(self, account1, account2, amount): if (1 <= account1 <= len(self.balance)) and (1 <= account2 <= len(self.balance)) and (self.balance[account1 - 1] >= amount): self.balance[account1 - 1] -= amount self.balance[account2 - 1] += amount return True return False def deposit(self, account, amount): if 1 <= account <= len(self.balance): self.balance[account - 1] += amount return True return False def withdraw(self, account, amount): if (1 <= account <= len(self.balance)) and (self.balance[account - 1] >= amount): self.balance[account - 1] -= amount return True return False"},{"question":"def search_insert(nums: List[int], target: int) -> int: Search for the target in the sorted array. If found, return its index, otherwise return the index where it should be inserted to maintain order. Parameters: nums (List[int]): A list of integers sorted in ascending order. target (int): The target integer to search for or insert. Returns: int: The index of the target if found, otherwise the index where the target should be inserted. >>> search_insert([1, 3, 5, 6], 5) 2 >>> search_insert([1, 3, 5, 6], 0) 0","solution":"def search_insert(nums, target): Search for the target in the sorted array. If found, return its index, otherwise return the index where it should be inserted to maintain order. Parameters: nums (List[int]): A list of integers sorted in ascending order. target (int): The target integer to search for or insert. Returns: int: The index of the target if found, otherwise the index where the target should be inserted. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def numIslands(grid: List[List[int]]) -> int: Returns the number of islands in the given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water. :param grid: List[List[int]], the grid representing islands and water :return: int, the number of islands >>> numIslands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1]]) 3 >>> numIslands([[1, 0, 0, 1, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 1], [0, 1, 1, 0, 1]]) 4 >>> numIslands([[1, 1, 1], [0, 1, 0], [1, 1, 1]]) 1 >>> numIslands([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> numIslands([]) 0 >>> numIslands([[1]]) 1 >>> numIslands([[0]]) 0","solution":"def numIslands(grid): Returns the number of islands in the given grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. :param grid: List[List[int]], the grid representing islands and water :return: int, the number of islands if not grid: return 0 def dfs(grid, i, j): if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return grid[i][j] = 0 # Mark the cell as visited dfs(grid, i + 1, j) # Down dfs(grid, i - 1, j) # Up dfs(grid, i, j + 1) # Right dfs(grid, i, j - 1) # Left count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(grid, i, j) count += 1 return count"},{"question":"def longest_palindromic_substring(st: str) -> str: Find the longest palindromic substring in a given string. If multiple substrings have the same length, return the lexicographically first one. >>> longest_palindromic_substring(\\"babad\\") \\"aba\\" >>> longest_palindromic_substring(\\"cbbd\\") \\"bb\\" >>> longest_palindromic_substring(\\"aabb\\") \\"aa\\" >>> longest_palindromic_substring(\\"racecar\\") \\"racecar\\" >>> longest_palindromic_substring(\\"abc\\") \\"a\\" >>> longest_palindromic_substring(\\"abacc\\") \\"aba\\" >>> longest_palindromic_substring(\\"cbbdcb\\") \\"bb\\"","solution":"def longest_palindromic_substring(st): Returns the longest palindromic substring. If there are multiple such substrings with the same length, returns the one which appears first in lexicographical order. def is_palindrome(s): return s == s[::-1] n = len(st) longest = \\"\\" for i in range(n): for j in range(i, n): current_substring = st[i:j+1] if is_palindrome(current_substring): if len(current_substring) > len(longest) or (len(current_substring) == len(longest) and current_substring < longest): longest = current_substring return longest"},{"question":"def longest_path_value_sum(n: int, edges: List[List[int]], values: List[int]) -> int: You are given a directed graph with \`n\` vertices and \`m\` edges represented as an array \`edges\` of size \`m\`, where \`edges[i] = [ui, vi]\` indicates there is a directed edge from vertex \`ui\` to vertex \`vi\`. Each vertex \`i\` has an associated value given by the array \`value[i]\`. You need to determine the longest path in terms of the sum of the values of the vertices along the path in this directed graph. The path should start at any vertex and end at any other vertex, and each vertex can be visited at most once. Return the maximum value sum for the longest path possible in the graph. If there is no path, return \`0\`. >>> longest_path_value_sum(5, [[0, 1], [1, 2], [2, 3], [3, 4], [1, 3]], [1, 2, 3, 4, 5]) 15 >>> longest_path_value_sum(1, [], [10]) 10 >>> longest_path_value_sum(3, [], [3, 2, 5]) 5 >>> longest_path_value_sum(4, [[0, 1], [1, 2], [2, 3], [3, 1]], [1, 2, 3, 4]) 0 >>> longest_path_value_sum(6, [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4], [4, 5]], [3, 2, 4, 1, 2, 4]) 14","solution":"def longest_path_value_sum(n, edges, values): from collections import defaultdict, deque # Construct the graph graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Topological Sort using Kahn's algorithm topo_order = [] zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) while zero_in_degree_queue: node = zero_in_degree_queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # Early exit if there's a cycle and not all nodes are in topological order if len(topo_order) != n: return 0 # Initialize distance with negative infinity dist = [-float('inf')] * n # Maximum path values starting from each vertex max_path_value = 0 # Process vertices in topological order for node in topo_order: if dist[node] == -float('inf'): dist[node] = values[node] for neighbor in graph[node]: dist[neighbor] = max(dist[neighbor], dist[node] + values[neighbor]) return max(dist)"},{"question":"def generate_parenthesis(n: int) -> List[str]: Returns a list of unique combinations of n pairs of well-formed parentheses. >>> generate_parenthesis(3) ['((()))', '(()())', '(())()', '()(())', '()()()'] >>> generate_parenthesis(0) [''] >>> generate_parenthesis(1) ['()'] >>> generate_parenthesis(2) ['(())', '()()'] >>> generate_parenthesis(4) ['(((())))', '((()()))', '((())())', '((()))()', '(()(()))', '(()()())', '(()())()', '(())(())', '(())()()', '()((()))', '()(()())', '()(())()', '()()(())', '()()()()']","solution":"def generate_parenthesis(n): Returns a list of unique combinations of n pairs of well-formed parentheses. result = [] def backtrack(current, open_count, close_count): if len(current) == 2 * n: result.append(current) return if open_count < n: backtrack(current + \\"(\\", open_count + 1, close_count) if close_count < open_count: backtrack(current + \\")\\", open_count, close_count + 1) backtrack(\\"\\", 0, 0) return result"},{"question":"def rob(nums, ownership): Given a list of integers nums representing amount of money for each house in a row and a list of booleans ownership representing whether you own the house (True) or the thief owns the house (False), this function returns the maximum amount of money you can rob given you can't rob two consecutive houses. >>> rob_with_no_houses() 0 >>> rob_with_only_thief_houses() 0 >>> rob_with_alternate_owned_houses() 4 >>> rob_with_consecutive_owned_houses() 4 >>> rob_with_mixed_ownership() 9 >>> rob_with_single_house_owned() 5 >>> rob_with_single_house_by_thief() 0 >>> rob_with_two_houses_one_owned() 2 >>> rob_with_two_houses_both_owned() 4","solution":"def rob(nums, ownership): Given a list of integers nums representing amount of money for each house in a row and a list of booleans ownership representing whether you own the house (True) or the thief owns the house (False), this function returns the maximum amount of money you can rob given you can't rob two consecutive houses. if not nums: return 0 n = len(nums) # Initialize an array to store the maximum amounts dp = [0] * (n + 1) # Iterate through the houses for i in range(1, n + 1): if ownership[i - 1]: if i == 1: dp[i] = nums[i - 1] else: dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]) else: dp[i] = dp[i - 1] return dp[n]"},{"question":"def min_replacements_to_palindrome(s: str, k: int) -> int: Returns the minimum number of characters that need to be replaced in order for the string \`s\` to become a palindrome. >>> min_replacements_to_palindrome(\\"racecar\\", 1) 0 >>> min_replacements_to_palindrome(\\"abca\\", 2) 1 >>> min_replacements_to_palindrome(\\"abcdef\\", 3) 3 >>> min_replacements_to_palindrome(\\"abc\\", 5) 1 >>> min_replacements_to_palindrome(\\"abcbda\\", 3) 2 >>> min_replacements_to_palindrome(\\"abcdef\\", 2) 2","solution":"def min_replacements_to_palindrome(s, k): Returns the minimum number of characters that need to be replaced in order for the string \`s\` to become a palindrome. n = len(s) replacements = 0 # Only need to check the first half, compare it with the second half left = 0 right = n - 1 while left < right: if s[left] != s[right]: replacements += 1 left += 1 right -= 1 return min(replacements, k)"},{"question":"def minimum_difference(weights: List[int]) -> int: You are given a 0-indexed integer array \`weights\` where \`weights[i]\` represents the weight of the i-th item. You need to distribute these items into two groups such that the difference between the total weights of the two groups is minimized. Return the minimum possible difference. Args: weights (List[int]): List of weights. Returns: int: The minimum possible difference between the total weights of the two groups. >>> minimum_difference([1, 2, 3, 4, 5]) 1 >>> minimum_difference([10]) 10 >>> minimum_difference([10, 20]) 10 >>> minimum_difference([3, 3, 3, 3]) 0 >>> minimum_difference([1, 5, 11, 5]) 0 >>> minimum_difference([1, 2, 5, 6, 7]) 1 >>> minimum_difference([10, 20, 15, 5, 25]) 5 pass","solution":"def minimum_difference(weights): Returns the minimum possible difference between two groups formed from weights. total_sum = sum(weights) n = len(weights) dp = [0] * (total_sum // 2 + 1) for weight in weights: for j in range(total_sum // 2, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return abs(total_sum - 2 * dp[total_sum // 2])"},{"question":"def largest_concatenated_string(words): Arrange strings in such a way that they form the largest possible concatenated string in lexicographical order. >>> largest_concatenated_string([\\"apple\\"]) == \\"apple\\" >>> largest_concatenated_string([\\"apple\\", \\"banana\\"]) == \\"bananaapple\\" >>> largest_concatenated_string([\\"cat\\", \\"bat\\", \\"apple\\"]) == \\"catbatapple\\" >>> largest_concatenated_string([\\"abc\\", \\"abc\\", \\"abc\\"]) == \\"abcabcabc\\" >>> largest_concatenated_string([]) == \\"\\" >>> largest_concatenated_string([\\"abc\\", \\"abcd\\", \\"ab\\"]) == \\"abcdabcab\\"","solution":"def largest_concatenated_string(words): Returns the largest concatenated string in lexicographical order. Args: words (list of str): List of strings to concatenate. Returns: str: The largest concatenated string. # Sort the words in reverse lexicographical order and concatenate them words_sorted = sorted(words, reverse=True) return ''.join(words_sorted)"},{"question":"def count_zero_substrings(s: str) -> int: Given a binary string \`s\`, return the number of substrings with all characters \`0\`. A substring is defined as a contiguous sequence of characters within the string. >>> count_zero_substrings(\\"0000\\") 10 >>> count_zero_substrings(\\"1111\\") 0 >>> count_zero_substrings(\\"0011000\\") 9 >>> count_zero_substrings(\\"0\\") 1 >>> count_zero_substrings(\\"0101010\\") 4 >>> count_zero_substrings(\\"\\") 0","solution":"def count_zero_substrings(s): Counts the number of substrings consisting solely of the character '0' in the given binary string s. :param s: A string consisting of '0's and '1's. :return: The number of substrings with all characters '0'. count = 0 zero_count = 0 for char in s: if char == '0': zero_count += 1 count += zero_count else: zero_count = 0 return count"},{"question":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: 'Node') -> 'Node': Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Args: root: The root of the binary tree. Returns: The root of the modified tree. pass def level_order_traversal(root: 'Node') -> list: Helper function to return level order traversal of the tree including next pointers. Each level ends with a '#'. Args: root: The root of the binary tree. Returns: A list representing the level order traversal with next pointers. pass # Unit Tests def test_single_node(): root = Node(1) connect(root) assert level_order_traversal(root) == [1, '#'] def test_two_levels(): root = Node(1, Node(2), Node(3)) connect(root) assert level_order_traversal(root) == [1, '#', 2, 3, '#'] def test_three_levels(): root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))) connect(root) assert level_order_traversal(root) == [1, '#', 2, 3, '#', 4, 5, 6, 7, '#'] def test_incomplete_tree(): root = Node(1, Node(2, None, Node(5)), Node(3, Node(6), None)) connect(root) assert level_order_traversal(root) == [1, '#', 2, 3, '#', 5, 6, '#'] def test_empty_tree(): root = None connect(root) assert connect(root) == None","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root): Given a binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. if not root: return None leftmost = root while leftmost: current = leftmost leftmost = None prev = None while current: if current.left: if not leftmost: leftmost = current.left if prev: prev.next = current.left prev = current.left if current.right: if not leftmost: leftmost = current.right if prev: prev.next = current.right prev = current.right current = current.next return root def level_order_traversal(root): Helper function to return level order traversal of the tree including next pointers. Each level ends with a '#'. result = [] while root: current = root while current: result.append(current.val) current = current.next result.append('#') root = root.left if root.left else root.right return result"},{"question":"def min_steps_to_one(n: int) -> int: Return the minimum number of steps required to reduce n to 1. >>> min_steps_to_one(1) == 0 >>> min_steps_to_one(2) == 1 >>> min_steps_to_one(3) == 1 >>> min_steps_to_one(4) == 2 >>> min_steps_to_one(5) == 3 >>> min_steps_to_one(10) == 3 >>> min_steps_to_one(20) == 4 >>> min_steps_to_one(27) == 3 >>> min_steps_to_one(100) == 7","solution":"def min_steps_to_one(n): Return the minimum number of steps required to reduce n to 1. # Dictionary to store the minimum steps for each number dp = {1: 0} # Function to compute minimum steps using memoization def compute_steps(k): if k in dp: return dp[k] steps = compute_steps(k - 1) + 1 if k % 2 == 0: steps = min(steps, compute_steps(k // 2) + 1) if k % 3 == 0: steps = min(steps, compute_steps(k // 3) + 1) dp[k] = steps return steps return compute_steps(n)"},{"question":"def longest_palindromic_substring(s: str) -> str: Given a string \`s\` that consists of only lowercase letters, find the largest substring that is a palindrome. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"] True >>> longest_palindromic_substring(\\"\\") '' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"anana\\") 'anana' >>> longest_palindromic_substring(\\"noonabcdcba\\") 'abcdcba' >>> longest_palindromic_substring(\\"bananas\\") 'anana'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in the given string s. :param s: A string consisting of only lowercase letters. :return: The longest palindromic substring in s. n = len(s) if n == 0: return \\"\\" start, max_length = 0, 1 for i in range(1, n): # Check for even length palindromes low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd length palindromes low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def find_top_manager(n: int, reportPairs: List[List[int]]) -> int: Given the number of employees and a list of reporting pairs, return the ID of the top-most manager (the one who does not report to anyone). If multiple top-most managers exist, return the smallest ID among them. If there is no such employee, return -1. >>> find_top_manager(6, [[1, 2], [1, 3], [2, 4], [3, 5], [3, 6]]) == 1 >>> find_top_manager(0, []) == -1 >>> find_top_manager(1, []) == 1 >>> find_top_manager(4, [[2, 3], [3, 4]]) == 1 >>> find_top_manager(2, [[1, 2], [2, 1]]) == -1 >>> find_top_manager(2, [[1, 2]]) == 1","solution":"def find_top_manager(n, reportPairs): if n == 0: return -1 # a set of all employee IDs all_employees = set(range(1, n+1)) # a set of employees who report to someone has_manager = set(e for _, e in reportPairs) # find the set of employees who do not report to anyone top_managers = all_employees - has_manager if not top_managers: return -1 # return the smallest ID among the top managers return min(top_managers)"},{"question":"def has_repeated_non_overlapping_substring(s: str) -> bool: Determines if there exists a non-empty substring that occurs at least twice in \`s\`, without overlapping. :param s: A string representing a sequence of characters. :return: True if there is a repeated non-overlapping substring, False otherwise. >>> has_repeated_non_overlapping_substring(\\"abcdef\\") == False >>> has_repeated_non_overlapping_substring(\\"abcabc\\") == True >>> has_repeated_non_overlapping_substring(\\"a\\") == False >>> has_repeated_non_overlapping_substring(\\"aa\\") == True >>> has_repeated_non_overlapping_substring(\\"xyzabcxyzabc\\") == True >>> has_repeated_non_overlapping_substring(\\"xyxy\\") == True >>> has_repeated_non_overlapping_substring(\\"abcdab\\") == False >>> has_repeated_non_overlapping_substring(\\"abababababab\\") == True >>> has_repeated_non_overlapping_substring(\\"aabbaabb\\") == True >>> has_repeated_non_overlapping_substring(\\"abcabxyz\\") == False","solution":"def has_repeated_non_overlapping_substring(s): Determines if there exists a non-empty substring that occurs at least twice in \`s\`, without overlapping. :param s: A string representing a sequence of characters. :return: True if there is a repeated non-overlapping substring, False otherwise. length = len(s) for sub_len in range(1, length // 2 + 1): for i in range(length - sub_len * 2 + 1): if s[i:i + sub_len] == s[i + sub_len:i + sub_len * 2]: return True return False"},{"question":"def min_partitions(nums): Return the minimum number of partitions required such that each partition is a continuous subsequence and sorted in strictly increasing order. :param nums: List[int], a permutation of integers from 1 to n :return: int, minimum number of partitions required >>> min_partitions([1]) 1 >>> min_partitions([1, 2, 3, 4, 5]) 1 >>> min_partitions([5, 4, 3, 2, 1]) 5 >>> min_partitions([1, 3, 2, 5, 4]) 3 >>> min_partitions([2, 1, 4, 3, 6, 5]) 3","solution":"def min_partitions(nums): Return the minimum number of partitions required such that each partition is a continuous subsequence and sorted in strictly increasing order. :param nums: List[int], a permutation of integers from 1 to n :return: int, minimum number of partitions required # Initialize the number of partitions partition_count = 0 # Initialize the end of the current partition current_end = 0 for i in range(len(nums)): # Update the end of the current partition current_end = max(current_end, nums[i]) # If current index reaches the end of the current partition, # increment the partition count if i + 1 == current_end: partition_count += 1 return partition_count"},{"question":"from typing import List def minimum_distance(positions: List[int]) -> int: Returns the minimum distance the player must cover to visit all positions in \`positions\` starting and ending at position 0. >>> minimum_distance([]) == 0 >>> minimum_distance([5]) == 10 >>> minimum_distance([-5]) == 10 >>> minimum_distance([1, 2, 3, 4, 5]) == 10 >>> minimum_distance([-1, -2, -3, -4, -5]) == 10 >>> minimum_distance([-10, 5, -3, 9, 6]) == 20 >>> minimum_distance([1, -1, 2, -2, 3, -3]) == 6 >>> minimum_distance([-1, 0, 1]) == 2","solution":"def minimum_distance(positions): Returns the minimum distance the player must cover to visit all positions in \`positions\` starting and ending at position 0 if not positions: return 0 # Sort the positions positions.sort() # Total distance is twice the distance from the farthest point because the player must return to 0 max_distance = max(abs(position) for position in positions) return 2 * max_distance"},{"question":"import heapq class MedianFinder: A class that continuously maintains the median of a sequence of integers being added. Methods: - addNum(int num): Adds the integer \`num\` to the data structure. - findMedian(): Returns the median of all elements so far. The median is the middle element in an ordered list if the list length is odd, or the average of the two middle elements if the list length is even. Example: >>> mf = MedianFinder() >>> mf.addNum(1) >>> mf.findMedian() 1.0 >>> mf.addNum(2) >>> mf.findMedian() 1.5 >>> mf.addNum(3) >>> mf.findMedian() 2.0 def __init__(self): pass def addNum(self, num: int) -> None: pass def findMedian(self) -> float: pass","solution":"import heapq class MedianFinder: def __init__(self): self.small = [] # max heap (inverted min heap) self.large = [] # min heap def addNum(self, num: int) -> None: heapq.heappush(self.small, -num) if (self.small and self.large and (-self.small[0] > self.large[0])): heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.small) > len(self.large) + 1: heapq.heappush(self.large, -heapq.heappop(self.small)) if len(self.large) > len(self.small): heapq.heappush(self.small, -heapq.heappop(self.large)) def findMedian(self) -> float: if len(self.small) > len(self.large): return float(-self.small[0]) return (-self.small[0] + self.large[0]) / 2.0"},{"question":"def longest_sequence_length(n): Returns the length of the longest sequence of consecutive positive integers that sums up to n. Returns -1 if no such sequence exists. >>> longest_sequence_length(9) == 3 >>> longest_sequence_length(15) == 5 >>> longest_sequence_length(8) == -1 >>> longest_sequence_length(3) == 2 >>> longest_sequence_length(1) == -1 >>> longest_sequence_length(21) == 6 >>> longest_sequence_length(10) == 4","solution":"def longest_sequence_length(n): Returns the length of the longest sequence of consecutive positive integers that sums up to n. Returns -1 if no such sequence exists. max_length = -1 for start in range(1, n): current_sum = start length = 1 for next_num in range(start + 1, n+1): current_sum += next_num length += 1 if current_sum == n: max_length = max(max_length, length) if current_sum >= n: break return max_length if max_length >= 2 else -1"},{"question":"class Bank: A bank maintains customer accounts, each with a unique account number and a balance. The bank needs a system to manage transfers between accounts. Initializes the \`Bank\` object with an array of account balances. >>> bank = Bank([100, 200, 300]) >>> bank.balance # Expected [100, 200, 300] Transfers \`amount\` of money from \`account1\` to \`account2\`. Returns \`true\` if the transfer is successful, or \`false\` if \`account1\` does not have enough balance. >>> bank.transfer(1, 2, 50) # Expected True >>> bank.balance # Expected [50, 250, 300] Deposits \`amount\` of money into \`account\`. Returns \`true\` if the deposit is successful. >>> bank.deposit(1, 50) # Expected True >>> bank.balance # Expected [100, 250, 300] Withdraws \`amount\` of money from \`account\`. Returns \`true\` if the withdrawal is successful, or \`false\` if \`account\` does not have enough balance. >>> bank.withdraw(1, 50) # Expected True >>> bank.balance # Expected [50, 250, 300] def __init__(self, balance): pass def transfer(self, account1, account2, amount): pass def deposit(self, account, amount): pass def withdraw(self, account, amount): pass","solution":"class Bank: def __init__(self, balance): self.balance = balance def transfer(self, account1, account2, amount): if account1 <= 0 or account1 > len(self.balance) or account2 <= 0 or account2 > len(self.balance): return False if self.balance[account1 - 1] < amount: return False self.balance[account1 - 1] -= amount self.balance[account2 - 1] += amount return True def deposit(self, account, amount): if account <= 0 or account > len(self.balance): return False self.balance[account - 1] += amount return True def withdraw(self, account, amount): if account <= 0 or account > len(self.balance): return False if self.balance[account - 1] < amount: return False self.balance[account - 1] -= amount return True"},{"question":"def min_operations_to_match(words: List[str], target: str) -> int: Determine the minimum number of operations required to change one string in \`words\` to exactly match the \`target\` string. :param words: list of strings :param target: string to match :return: minimum number of operations required >>> min_operations_to_match([\\"test\\", \\"best\\", \\"nest\\"], \\"test\\") == 0 >>> min_operations_to_match([\\"test\\", \\"best\\", \\"nest\\"], \\"rest\\") == 1 >>> min_operations_to_match([\\"abc\\", \\"def\\", \\"ghi\\"], \\"xyz\\") == 3 >>> min_operations_to_match([\\"abcd\\", \\"defg\\", \\"hijk\\"], \\"wxyz\\") == 4 >>> min_operations_to_match([\\"short\\", \\"longer\\", \\"tiny\\"], \\"short\\") == 0 >>> min_operations_to_match([\\"aaaa\\", \\"bbbb\\", \\"cccc\\"], \\"bbbb\\") == 0 >>> min_operations_to_match([\\"aaaa\\", \\"bbbb\\", \\"cccc\\"], \\"aaaa\\") == 0 >>> min_operations_to_match([\\"aaaa\\", \\"bbbb\\", \\"cccc\\"], \\"cccc\\") == 0 pass","solution":"def min_operations_to_match(words, target): Determine the minimum number of operations required to change one string in \`words\` to exactly match the \`target\` string. :param words: list of strings :param target: string to match :return: minimum number of operations required def operations_to_match(word, target): return sum(1 for w_char, t_char in zip(word, target) if w_char != t_char) return min(operations_to_match(word, target) for word in words if len(word) == len(target))"},{"question":"def trap_water(arr: List[int]) -> int: Calculate the total amount of water that can be trapped after raining, given an integer array representing the height of buildings. Args: arr (List[int]): A 0-indexed integer array where the length is n. Returns: int: Total water trapped after raining. >>> trap_water([]) == 0 >>> trap_water([4]) == 0 >>> trap_water([2, 1]) == 0 >>> trap_water([1, 2, 3, 4, 5]) == 0 >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_water([3, 3, 3, 3, 3]) == 0 >>> trap_water([4, 1, 2, 1, 3]) == 5 >>> trap_water([4, 0, 4, 0, 4]) == 8","solution":"def trap_water(arr): Given an integer array arr representing the height of buildings, return the total amount of water that can be trapped. Args: arr (List[int]): A 0-indexed integer array where the length is n. Returns: int: Total water trapped after raining. if not arr or len(arr) < 3: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"def longest_path(board) -> int: You are given a grid \`board\` of size \`m x n\`, where each cell contains a character from \`'a'\` to \`'z'\`. You want to find the longest path on the board such that no letter is repeated. The path can move in any of the four cardinal directions (up, down, left, right) from the current cell. Return the length of the longest path with no repeated characters. >>> longest_path([['a']]) 1 >>> longest_path([['a', 'b'], ['c', 'd']]) 4 >>> longest_path([['a', 'a', 'a'], ['b', 'c', 'b'], ['a', 'a', 'a']]) 3 >>> longest_path([['a', 'c', 'd'], ['b', 'a', 'e'], ['f', 'g', 'h']]) 8 >>> longest_path([['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p']]) 16","solution":"def longest_path(board): def dfs(x, y, visited): longest = 0 visited.add(board[x][y]) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(board) and 0 <= ny < len(board[0]) and board[nx][ny] not in visited: longest = max(longest, dfs(nx, ny, visited)) visited.remove(board[x][y]) return longest + 1 max_path = 0 for i in range(len(board)): for j in range(len(board[0])): max_path = max(max_path, dfs(i, j, set())) return max_path"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Search for a target value in a m x n matrix. Each row and column is sorted in ascending order. :param matrix: List of List of integers representing the matrix. :param target: Integer representing the target value to find. :return: Boolean indicating if the target exists in the matrix. >>> matrix = [ >>> [1, 4, 7, 11, 15], >>> [2, 5, 8, 12, 19], >>> [3, 6, 9, 16, 22], >>> [10, 13, 14, 17, 24], >>> [18, 21, 23, 26, 30] >>> ] >>> target = 5 >>> search_matrix(matrix, target) True >>> target = 20 >>> search_matrix(matrix, target) False >>> search_matrix([], 1) False >>> search_matrix([[]], 1) False >>> search_matrix([[1]], 1) True >>> search_matrix([[1]], 2) False","solution":"def search_matrix(matrix, target): Search for a target value in a m x n matrix. Each row and column is sorted in ascending order. :param matrix: List of List of integers representing the matrix. :param target: Integer representing the target value to find. :return: Boolean indicating if the target exists in the matrix. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_alternate_reverse(head): Merges alternate nodes from the second half into the first half in reverse order. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified linked list. >>> head = array_to_linked_list([1, 2, 3, 4, 5, 6]) >>> new_head = merge_alternate_reverse(head) >>> linked_list_to_array(new_head) [1, 6, 2, 5, 3, 4] >>> head = array_to_linked_list([1, 2, 3, 4]) >>> new_head = merge_alternate_reverse(head) >>> linked_list_to_array(new_head) [1, 4, 2, 3] >>> head = array_to_linked_list([10, 20, 30, 40, 50, 60, 70, 80]) >>> new_head = merge_alternate_reverse(head) >>> linked_list_to_array(new_head) [10, 80, 20, 70, 30, 60, 40, 50] >>> head = array_to_linked_list([1, 1]) >>> new_head = merge_alternate_reverse(head) >>> linked_list_to_array(new_head) [1, 1] >>> head = array_to_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) >>> new_head = merge_alternate_reverse(head) >>> linked_list_to_array(new_head) [1, 8, 2, 7, 3, 6, 4, 5] pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_alternate_reverse(head): Merges alternate nodes from the second half into the first half in reverse order. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified linked list. if not head or not head.next or not head.next.next: return head # Find the middle of the list slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Split the list into two halves second_half = slow.next slow.next = None # Reverse the second half prev = None current = second_half while current: next_node = current.next current.next = prev prev = current current = next_node second_half = prev # Merge the lists alternately first = head second = second_half while second: first_next = first.next second_next = second.next first.next = second second.next = first_next first = first_next second = second_next return head"},{"question":"def longestSubstring(s: str, k: int) -> int: Given a string s and an integer k, returns the length of the longest substring where every character appears at least k times. >>> longestSubstring(\\"aaabb\\", 3) 3 >>> longestSubstring(\\"ababbc\\", 2) 5 >>> longestSubstring(\\"aaaaa\\", 2) 5 >>> longestSubstring(\\"abcde\\", 2) 0 >>> longestSubstring(\\"aaabbbccc\\", 3) 9 >>> longestSubstring(\\"a\\", 2) 0 >>> longestSubstring(\\"ababbba\\", 3) 7","solution":"def longestSubstring(s, k): Returns the length of the longest substring where every character appears at least \`k\` times. def longest_substring_helper(s, k, start, end): if end - start < k: return 0 count = [0] * 26 for i in range(start, end): count[ord(s[i]) - ord('a')] += 1 for mid in range(start, end): if count[ord(s[mid]) - ord('a')] >= k: continue next_mid = mid + 1 while next_mid < end and count[ord(s[next_mid]) - ord('a')] < k: next_mid += 1 return max(longest_substring_helper(s, k, start, mid), longest_substring_helper(s, k, next_mid, end)) return end - start return longest_substring_helper(s, k, 0, len(s))"},{"question":"def contains_duplicate(arr: List[int]) -> bool: Given an array of integers 'arr', return 'true' if any value appears at least twice in the array, and return 'false' if every element is distinct. >>> contains_duplicate([1, 2, 3, 1]) True >>> contains_duplicate([4, 5, 6, 7, 8, 9]) False >>> contains_duplicate([]) False >>> contains_duplicate([1]) False >>> contains_duplicate([1, 1, 1, 1]) True","solution":"def contains_duplicate(arr): Returns true if any value appears at least twice in the array, else false. return len(arr) != len(set(arr))"},{"question":"def convert(s: str, numRows: int) -> str: Convert the string \`s\` into a zigzag pattern on a given number of rows and return the resulting string read line by line. >>> convert(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" >>> convert(\\"ABCD\\", 1) == \\"ABCD\\" >>> convert(\\"ABCD\\", 5) == \\"ABCD\\" >>> convert(\\"ABCD\\", 4) == \\"ABCD\\" >>> convert(\\"PAYPALISHIRING\\", 2) == \\"PYAIHRNAPLSIIG\\" >>> convert(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\"","solution":"def convert(s, numRows): if numRows == 1 or numRows >= len(s): return s rows = [''] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 return ''.join(rows)"},{"question":"def rearrange_even_odd(arr): Rearrange the list \`arr\` such that all even numbers precede all odd numbers while maintaining the relative order of even and odd numbers. >>> rearrange_even_odd([3, 1, 2, 4, 7, 6]) [2, 4, 6, 3, 1, 7] >>> rearrange_even_odd([2, 4, 8, 6]) [2, 4, 8, 6] >>> rearrange_even_odd([3, 1, 7, 5]) [3, 1, 7, 5] >>> rearrange_even_odd([2, 4, 3, 1, 5]) [2, 4, 3, 1, 5] >>> rearrange_even_odd([1]) [1] >>> rearrange_even_odd([2]) [2] >>> rearrange_even_odd([]) []","solution":"def rearrange_even_odd(arr): Rearrange the list \`arr\` such that all even numbers precede all odd numbers while maintaining the relative order of even and odd numbers. if not arr: # When the input list is empty return arr even_count = 0 for i in range(len(arr)): if arr[i] % 2 == 0: # Check if the current element is even arr.insert(even_count, arr.pop(i)) # Insert to the position of even_count and pop from i even_count += 1 # Increment the even count return arr"},{"question":"def find_lexicographically_smallest_substring(s: str, k: int) -> str: Finds the lexicographically smallest substring of length k with the highest frequency in the string. :param s: Input string consisting of only lowercase English letters. :param k: Length of the substring. :return: Lexicographically smallest substring of length k with the highest frequency. >>> find_lexicographically_smallest_substring(\\"aabc\\", 2) == \\"aa\\" >>> find_lexicographically_smallest_substring(\\"banana\\", 3) == \\"ana\\" >>> find_lexicographically_smallest_substring(\\"abcabcabc\\", 3) == \\"abc\\" >>> find_lexicographically_smallest_substring(\\"aaaaa\\", 1) == \\"a\\" >>> find_lexicographically_smallest_substring(\\"ababab\\", 2) == \\"ab\\" >>> find_lexicographically_smallest_substring(\\"abcdef\\", 2) == \\"ab\\"","solution":"def find_lexicographically_smallest_substring(s, k): Finds the lexicographically smallest substring of length k with the highest frequency in the string. :param s: Input string consisting of only lowercase English letters. :param k: Length of the substring. :return: Lexicographically smallest substring of length k with the highest frequency. from collections import defaultdict # Create a dictionary to store the frequency of substrings of length k freq_dict = defaultdict(int) # Iterate through the string to count the frequency of each substring of length k for i in range(len(s) - k + 1): substring = s[i:i+k] freq_dict[substring] += 1 # Find the maximum frequency max_frequency = max(freq_dict.values()) # Filter out the substrings with the maximum frequency max_frequency_substrings = [substr for substr, freq in freq_dict.items() if freq == max_frequency] # Find and return the lexicographically smallest substring among those with the maximum frequency return min(max_frequency_substrings)"},{"question":"def min_days(tasks, d): Returns the minimum number of days needed to complete all tasks if tasks completed on consecutive days are a valid schedule. :param tasks: List of task durations :param d: Number of available days :return: Minimum number of days required","solution":"def min_days(tasks, d): Returns the minimum number of days needed to complete all tasks if tasks completed on consecutive days are a valid schedule. :param tasks: List of task durations :param d: Number of available days :return: Minimum number of days required def is_valid_schedule(daily_limit): days_needed = 1 current_sum = 0 for task in tasks: if current_sum + task > daily_limit: days_needed += 1 current_sum = task if days_needed > d: return False else: current_sum += task return True if not tasks: return 0 left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if is_valid_schedule(mid): right = mid else: left = mid + 1 return left"},{"question":"def valid_palindrome(s: str) -> bool: Check if a string can be transformed into a palindrome by removing at most one character. Parameters: s (str): The input string. Returns: bool: True if the string can be transformed into a palindrome, False otherwise. >>> valid_palindrome(\\"abca\\") == True >>> valid_palindrome(\\"racecar\\") == True >>> valid_palindrome(\\"deified\\") == True >>> valid_palindrome(\\"palindrome\\") == False >>> valid_palindrome(\\"acbca\\") == True >>> valid_palindrome(\\"abc\\") == False >>> valid_palindrome(\\"abccba\\") == True >>> valid_palindrome(\\"abcdedcba\\") == True >>> valid_palindrome(\\"aa\\") == True >>> valid_palindrome(\\"a\\") == True >>> valid_palindrome(\\"\\") == True","solution":"def valid_palindrome(s): Check if a string can be transformed into a palindrome by removing at most one character. Parameters: s (str): The input string. Returns: bool: True if the string can be transformed into a palindrome, False otherwise. def is_palindrome_range(i, j): Helper function to check if the substring s[i:j+1] is a palindrome. return all(s[k] == s[j-k+i] for k in range(i, j)) l, r = 0, len(s) - 1 while l < r: if s[l] != s[r]: # Check by removing one character either from left or right. return is_palindrome_range(l+1, r) or is_palindrome_range(l, r-1) l += 1 r -= 1 return True"},{"question":"def max_product_subarray(arr: List[int]) -> int: Returns the maximum product obtained from the elements of any contiguous subarray of arr. If the array contains only one element, returns that element. :param arr: List[int] - array of integers :return: int - maximum product of any contiguous subarray >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0 >>> max_product_subarray([2, 3, -2, 4, -1]) 48 >>> max_product_subarray([-2, -3, 0, -2, -40]) 80 >>> max_product_subarray([3]) 3 >>> max_product_subarray([-1, -2, -3, -4]) 24","solution":"def max_product_subarray(arr): Returns the maximum product obtained from the elements of any contiguous subarray of arr. If the array contains only one element, returns that element. :param arr: List[int] - array of integers :return: int - maximum product of any contiguous subarray if len(arr) == 1: return arr[0] current_max = arr[0] current_min = arr[0] max_product = arr[0] for num in arr[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) max_product = max(max_product, current_max) return max_product"},{"question":"def has_pair_with_sum(arr, x): Determine if there exists a pair of elements in the array such that their sum is equal to x. :param arr: List[int] - A list of unique integers. :param x: int - The target sum. :return: bool - True if such a pair exists, otherwise False. >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([10, 15, 3, 7], 17) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([5, 7, 1, 2], 20) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> has_pair_with_sum([1, 2, 3, 4, -2], 2) True","solution":"def has_pair_with_sum(arr, x): Determine if there exists a pair of elements in the array such that their sum is equal to x. :param arr: List[int] - A list of unique integers. :param x: int - The target sum. :return: bool - True if such a pair exists, otherwise False. seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Reconstructs the string s based on the indices array which tells the position of each character in the final string. Args: s (str): a string of lowercase English letters. indices (list of int): an array of integers representing the positions. Returns: str: the newly reconstructed string. >>> restore_string(\\"abcde\\", [4, 3, 2, 1, 0]) \\"edcba\\" >>> restore_string(\\"hello\\", [4, 3, 2, 1, 0]) \\"olleh\\" pass","solution":"def restore_string(s, indices): Reconstructs the string s based on the indices array which tells the position of each character in the final string. Args: s (str): a string of lowercase English letters. indices (list of int): an array of integers representing the positions. Returns: str: the newly reconstructed string. # Create an empty list to hold the characters at the correct positions result = [''] * len(s) # Place each character at the corresponding position for i, char in enumerate(s): result[indices[i]] = char # Join the list into a string and return return ''.join(result)"},{"question":"def min_jumps(nums): Returns the minimum number of jumps needed to reach the end of the array. If it is not possible to reach the end, returns -1. >>> min_jumps([0]) 0 >>> min_jumps([1, 0]) 1 >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([3, 2, 1, 0, 4]) -1 >>> min_jumps([1]) 0 >>> min_jumps([1, 1, 1, 1, 1, 1, 1, 1]) 7 >>> min_jumps([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 1","solution":"def min_jumps(nums): Returns the minimum number of jumps needed to reach the end of the array. If it is not possible to reach the end, returns -1. if len(nums) <= 1: return 0 jumps = 0 farthest = 0 current_end = 0 for i in range(len(nums) - 1): farthest = max(farthest, i + nums[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= len(nums) - 1: return jumps return -1 if current_end < len(nums) - 1 else jumps"},{"question":"def can_transform_by_reversing_substring(s: str, t: str) -> bool: Determines if you can convert string s to string t by reversing exactly one substring. Parameters: s (str): The source string. t (str): The target string. Returns: bool: True if it is possible to transform s into t by reversing one substring, False otherwise. Examples: >>> can_transform_by_reversing_substring(\\"abc\\", \\"abc\\") True >>> can_transform_by_reversing_substring(\\"abc\\", \\"acb\\") True >>> can_transform_by_reversing_substring(\\"abc\\", \\"xyz\\") False >>> can_transform_by_reversing_substring(\\"abcd\\", \\"abc\\") False >>> can_transform_by_reversing_substring(\\"abc\\", \\"abcd\\") False >>> can_transform_by_reversing_substring(\\"abcdef\\", \\"abcfed\\") True >>> can_transform_by_reversing_substring(\\"abcdef\\", \\"abdcfe\\") False >>> can_transform_by_reversing_substring(\\"abcedf\\", \\"abcdef\\") True >>> can_transform_by_reversing_substring(\\"ab\\", \\"ba\\") True >>> can_transform_by_reversing_substring(\\"abcd\\", \\"dbca\\") False >>> can_transform_by_reversing_substring(\\"a\\", \\"a\\") True >>> can_transform_by_reversing_substring(\\"a\\", \\"b\\") False","solution":"def can_transform_by_reversing_substring(s, t): Determines if you can convert string s to string t by reversing exactly one substring. Parameters: s (str): The source string. t (str): The target string. Returns: bool: True if it is possible to transform s into t by reversing one substring, False otherwise. if len(s) != len(t): return False # Find the first and last positions where s and t differ start, end = None, None for i in range(len(s)): if s[i] != t[i]: if start is None: start = i end = i # If start is None, it means both strings are exactly same, no need for any operation. if start is None: return True # Reverse the substring s[start:end+1] and check if it equals to t[start:end+1] return s[:start] + s[start:end+1][::-1] + s[end+1:] == t"},{"question":"def min_operations_to_make_rows_identical(grid): Determine the minimum number of operations to make all rows identical in the matrix grid. Return -1 if it is impossible. >>> min_operations_to_make_rows_identical([[2, 4, 6], [2, 4, 6], [2, 4, 6]]) 0 >>> min_operations_to_make_rows_identical([[2, 4, 6], [6, 4, 2], [2, 4, 6]]) 1 >>> min_operations_to_make_rows_identical([[2, 4, 6], [1, 3, 5], [2, 4, 6]]) -1 >>> min_operations_to_make_rows_identical([[2, 4, 6]]) 0 >>> min_operations_to_make_rows_identical([[1, 2], [2, 1], [1, 2], [1, 2]]) 1","solution":"def min_operations_to_make_rows_identical(grid): Determine the minimum number of operations to make all rows identical in the matrix grid. Return -1 if it is impossible. # Get the number of rows and columns in the grid rows = len(grid) cols = len(grid[0]) # Function to reverse a list def reverse(lst): return lst[::-1] # Try to make all rows equal to the first row considering both original and reversed versions first_row = grid[0] reversed_first_row = reverse(first_row) # Function to determine the minimum operations needed to make a target row equal def min_operations_to_match(row, target_row, reversed_target_row): if row == target_row: return 0 elif row == reversed_target_row: return 1 else: return float('inf') # Calculate total minimum operations total_operations = 0 for row in grid[1:]: operations = min_operations_to_match(row, first_row, reversed_first_row) if operations == float('inf'): return -1 total_operations += operations return total_operations"},{"question":"from collections import deque from typing import Tuple def min_knight_moves(n: int, start: Tuple[int, int], end: Tuple[int, int]) -> int: Calculate the minimum number of moves required for a knight to move from start to end on an n x n chessboard. If the target position is not reachable, return -1. >>> min_knight_moves(8, (0, 0), (0, 0)) == 0 >>> min_knight_moves(8, (0, 0), (2, 1)) == 1 >>> min_knight_moves(8, (0, 0), (1, 2)) == 1 >>> min_knight_moves(8, (0, 0), (7, 7)) >= 0 # Check that it returns a valid move count >>> min_knight_moves(8, (0, 0), (6, 6)) >= 0 # Ensure a solution exists within this board size >>> min_knight_moves(3, (0, 0), (2, 2)) == 4 # Ensure a solution exists within this board size","solution":"from collections import deque def min_knight_moves(n, start, end): Returns the minimum number of moves required for a knight to move from start to end in an n x n chessboard. If the target position is not reachable, return -1. if start == end: return 0 directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] def is_valid(x, y): return 0 <= x < n and 0 <= y < n queue = deque([(start[0], start[1], 0)]) visited = set((start[0], start[1])) while queue: x, y, moves = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) == end: return moves + 1 if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"def has_pair_with_sum(arr: List[int], x: int) -> bool: Determine if there exist two distinct indices i and j in arr such that arr[i] + arr[j] == x. Args: arr: List[int] - A list of integers. x: int - The target sum. Returns: bool - True if there is a pair with sum x, otherwise False. >>> has_pair_with_sum([1, 2, 3], 7) False >>> has_pair_with_sum([1, 2, 3, 4], 5) True >>> has_pair_with_sum([1, 2, 3, 4], 7) True >>> has_pair_with_sum([-1, -2, 3, 4], 2) True >>> has_pair_with_sum([-1, -2, -3, -4], 2) False >>> has_pair_with_sum([1, 2, 3, 2], 4) True >>> has_pair_with_sum([3], 6) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([1000000000, 2000000000], 3000000000) True >>> has_pair_with_sum([1000000000, 2000000000], 1000000000) False","solution":"def has_pair_with_sum(arr, x): Determine if there exist two distinct indices i and j in arr such that arr[i] + arr[j] == x. Args: arr: List[int] - A list of integers. x: int - The target sum. Returns: bool - True if there is a pair with sum x, otherwise False. seen = set() for num in arr: if x - num in seen: return True seen.add(num) return False"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDiffInBST(root): Returns the minimum difference between the values of any two different nodes in the BST. >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> minDiffInBST(root) 1 >>> root = TreeNode(1) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(2) >>> minDiffInBST(root) 1 >>> root = TreeNode(4) >>> root.left = TreeNode(4) >>> minDiffInBST(root) 0 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(8) >>> root.right.right = TreeNode(20) >>> minDiffInBST(root) 2 >>> root = TreeNode(10) >>> minDiffInBST(root) inf","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDiffInBST(root): Returns the minimum difference between the values of any two different nodes in the BST. def in_order_traversal(node): if not node: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) values = in_order_traversal(root) min_diff = float('inf') for i in range(1, len(values)): min_diff = min(min_diff, values[i] - values[i-1]) return min_diff"},{"question":"def water_pool(grid: List[List[int]]) -> int: Determines the amount of water that can be trapped after raining across the entire grid. >>> water_pool([]) == 0 >>> water_pool([[1, 2, 1, 2, 1]]) == 0 >>> water_pool([[1], [2], [1], [2], [1]]) == 0 >>> water_pool([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0 >>> water_pool([ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 3], [2, 3, 3, 2, 3, 1] ]) == 4 >>> water_pool([ [3, 3, 3, 3, 3], [3, 2, 2, 2, 3], [3, 2, 1, 2, 3], [3, 2, 2, 2, 3], [3, 3, 3, 3, 3] ]) == 10","solution":"import heapq def water_pool(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] heap = [] for i in range(m): for j in [0, n - 1]: heapq.heappush(heap, (grid[i][j], i, j)) visited[i][j] = True for j in range(n): for i in [0, m - 1]: heapq.heappush(heap, (grid[i][j], i, j)) visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] water_trapped = 0 while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - grid[nx][ny]) heapq.heappush(heap, (max(height, grid[nx][ny]), nx, ny)) return water_trapped"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_up_to_n(head, n): Reverse the linked list up to position \`n\`. >>> head = array_to_linked_list([1, 2, 3, 4, 5]) >>> linked_list_to_array(reverse_up_to_n(head, 3)) [3, 2, 1, 4, 5] >>> head = array_to_linked_list([1, 2, 3, 4, 5]) >>> linked_list_to_array(reverse_up_to_n(head, 1)) [1, 2, 3, 4, 5] >>> head = array_to_linked_list([1, 2, 3, 4, 5]) >>> linked_list_to_array(reverse_up_to_n(head, 5)) [5, 4, 3, 2, 1] >>> head = array_to_linked_list([1, 2, 3]) >>> linked_list_to_array(reverse_up_to_n(head, 4)) [3, 2, 1] >>> head = array_to_linked_list([]) >>> linked_list_to_array(reverse_up_to_n(head, 2)) [] >>> head = array_to_linked_list([1]) >>> linked_list_to_array(reverse_up_to_n(head, 1)) [1] >>> head = array_to_linked_list([1, 2]) >>> linked_list_to_array(reverse_up_to_n(head, 3)) [2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_up_to_n(head, n): if not head or n == 1: return head # Initialize current, prev and next pointers current = head prev = None # Reverse the first \`n\` nodes of the linked list count = 0 while current and count < n: next_node = current.next current.next = prev prev = current current = next_node count += 1 # If there are more nodes left, link the (n+1)th node to the original head if head: head.next = current return prev"},{"question":"import math from typing import List def smallest_divisor(nums: List[int], threshold: int) -> int: Returns the smallest possible integer k such that when each element in the array nums is divided by k and rounded up to the nearest integer, the sum of this new array is less than or equal to the given threshold. >>> smallest_divisor([1, 2, 5, 9], 6) 5 >>> smallest_divisor([2, 3, 5, 7, 11], 11) 3 >>> smallest_divisor([10], 5) 2 >>> smallest_divisor([1, 2, 3, 4], 4) 4 >>> smallest_divisor([6, 6, 6, 6], 8) 3 >>> smallest_divisor([1000000, 2000000, 3000000], 3000000) 2 >>> smallest_divisor([1, 1, 1, 1], 4) 1","solution":"import math def smallest_divisor(nums, threshold): Returns the smallest possible integer k such that when each element in the array nums is divided by k and rounded up to the nearest integer, the sum of this new array is less than or equal to the given threshold. def compute_sum(divisor): return sum(math.ceil(num / divisor) for num in nums) left, right = 1, max(nums) result = right while left <= right: mid = (left + right) // 2 if compute_sum(mid) <= threshold: result = mid right = mid - 1 else: left = mid + 1 return result"},{"question":"from typing import List def max_subarray_sum(nums: List[int], k: int) -> int: Returns the maximum possible sum of a subarray of length k. Args: nums (List[int]): A list of integers. k (int): The length of the subarray. Returns: int: The maximum sum of a subarray of length k. >>> max_subarray_sum([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_sum([5, 5, 5, 5, 5], 3) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5], 2) -3 >>> max_subarray_sum([4, -1, 2, 1, -5, 4], 3) 5 >>> max_subarray_sum([1, 2, 3, 4, 5], 1) 5 >>> max_subarray_sum([1, 2, 3, 4, 5], 5) 15","solution":"def max_subarray_sum(nums, k): Returns the maximum possible sum of a subarray of length k. n = len(nums) # Initial sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) # Slide the window across the array for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"from typing import List def minCost(cost: List[List[int]]) -> int: Returns the minimum cost to paint the houses such that no two adjacent houses have the same color. >>> minCost([[17, 2, 17], [16, 16, 5], [14, 3, 19]]) 10 >>> minCost([[5, 8, 6]]) 5 >>> minCost([[1, 5, 3], [2, 9, 4]]) 5 >>> minCost([[1, 5, 3], [2, 9, 4], [10, 1, 1]]) 6 >>> minCost([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 3 >>> minCost([[1, 2, 3], [1, 2, 3], [3, 1, 2], [2, 3, 1]]) 5","solution":"def minCost(cost): Returns the minimum cost to paint the houses such that no two adjacent houses have the same color. if not cost: return 0 n = len(cost) for i in range(1, n): # Cost of painting current house red cost[i][0] += min(cost[i-1][1], cost[i-1][2]) # Cost of painting current house green cost[i][1] += min(cost[i-1][0], cost[i-1][2]) # Cost of painting current house blue cost[i][2] += min(cost[i-1][0], cost[i-1][1]) return min(cost[-1])"},{"question":"def max_subset_sum_no_adjacent(nums): Returns the maximum sum of a subset of the given list of integers \`nums\` such that no two elements in the subset are adjacent in the original array. :param nums: List of integers. :return: Maximum sum obtained from selecting non-adjacent elements. >>> max_subset_sum_no_adjacent([3, 2, 7, 10]) == 13 >>> max_subset_sum_no_adjacent([5]) == 5 >>> max_subset_sum_no_adjacent([3, 7]) == 7 >>> max_subset_sum_no_adjacent([-2, -7, -10]) == 0 >>> max_subset_sum_no_adjacent([-1, 2, 9, 3, 10]) == 19 >>> max_subset_sum_no_adjacent([3, 2, 5, 10, 7]) == 15 >>> max_subset_sum_no_adjacent([i for i in range(1, 101)]) == 2550 >>> max_subset_sum_no_adjacent([]) == 0","solution":"def max_subset_sum_no_adjacent(nums): Returns the maximum sum of a subset of the given list of integers \`nums\` such that no two elements in the subset are adjacent in the original array. :param nums: List of integers. :return: Maximum sum obtained from selecting non-adjacent elements. if not nums: return 0 elif len(nums) == 1: return nums[0] include = nums[0] exclude = 0 for i in range(1, len(nums)): new_exclude = max(include, exclude) include = exclude + nums[i] exclude = new_exclude return max(include, exclude)"},{"question":"def is_path_available(grid): Returns True if there is a connected path from top-left to bottom-right avoiding obstacles (1's), otherwise False. Uses Depth-First Search to determine the path connectivity. # Example test cases def test_is_path_available(): grid1 = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert is_path_available(grid1) == True grid2 = [ [0, 0, 0], [0, 1, 1], [0, 1, 0] ] assert is_path_available(grid2) == False grid3 = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert is_path_available(grid3) == True grid4 = [ [1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert is_path_available(grid4) == False grid5 = [ [0, 0, 0], [0, 0, 0], [0, 0, 1] ] assert is_path_available(grid5) == False grid6 = [ [0, 0, 0], [1, 1, 1], [0, 0, 0] ] assert is_path_available(grid6) == False grid7 = [[0]] assert is_path_available(grid7) == True grid8 = [ [0, 1, 1, 1], [0, 0, 1, 1], [1, 0, 0, 1], [1, 1, 0, 0] ] assert is_path_available(grid8) == True","solution":"def is_path_available(grid): Returns True if there is a connected path from top-left to bottom-right avoiding obstacles (1's), otherwise False. Uses Depth-First Search to determine the path connectivity. n = len(grid) if grid[0][0] == 1 or grid[n-1][n-1] == 1: return False directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == 0 def dfs(x, y): if not is_valid(x, y): return False if (x, y) == (n-1, n-1): return True grid[x][y] = -1 # Mark as visited for dx, dy in directions: new_x, new_y = x + dx, y + dy if dfs(new_x, new_y): return True return False return dfs(0, 0)"},{"question":"from typing import List def shortest_substring_containing_all_anagrams(s: str, words: List[str]) -> int: Returns the length of the shortest substring of \`s\` that contains all the words in \`words\` as anagrams. If there is no such substring, returns -1. >>> shortest_substring_containing_all_anagrams(\\"aaabcbcba\\", [\\"a\\", \\"b\\", \\"c\\"]) == 3 >>> shortest_substring_containing_all_anagrams(\\"aaabcbcba\\", [\\"x\\", \\"y\\", \\"z\\"]) == -1 >>> shortest_substring_containing_all_anagrams(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == -1 >>> shortest_substring_containing_all_anagrams(\\"aaabcbcba\\", []) == -1 >>> shortest_substring_containing_all_anagrams(\\"aaabcbcba\\", [\\"a\\"]) == 1 >>> shortest_substring_containing_all_anagrams(\\"abcabcababc\\", [\\"a\\", \\"b\\", \\"c\\"]) == 3 >>> shortest_substring_containing_all_anagrams(\\"a\\" * 1000 + \\"bca\\" + \\"a\\" * 1000, [\\"a\\", \\"b\\", \\"c\\"]) == 3 pass","solution":"from collections import Counter import sys def shortest_substring_containing_all_anagrams(s, words): Returns the length of the shortest substring of \`s\` that contains all the words in \`words\` as anagrams. If there is no such substring, returns -1. if not s or not words: return -1 word_counter = Counter(''.join(words)) required_chars = len(word_counter) left = 0 min_length = sys.maxsize current_counter = Counter() formed = 0 for right in range(len(s)): char = s[right] current_counter[char] += 1 if char in word_counter and current_counter[char] == word_counter[char]: formed += 1 while left <= right and formed == required_chars: char = s[left] if right - left + 1 < min_length: min_length = right - left + 1 current_counter[char] -= 1 if char in word_counter and current_counter[char] < word_counter[char]: formed -= 1 left += 1 return min_length if min_length != sys.maxsize else -1"},{"question":"def minCostToPaintFences(cost): Return the minimum cost to paint all the fences such that no two adjacent fences have the same color. >>> minCostToPaintFences([[1, 2, 3]]) 1 >>> minCostToPaintFences([[1, 2, 3], [1, 2, 3]]) 3 >>> minCostToPaintFences([[17, 2, 17], [16, 16, 5], [14, 3, 19]]) 10 >>> minCostToPaintFences([[10, 10, 10], [10, 10, 10], [10, 10, 10]]) 30 >>> minCostToPaintFences([[1, 100, 100], [100, 1, 100], [100, 100, 1]]) 3","solution":"def minCostToPaintFences(cost): if not cost: return 0 n = len(cost) dp = [[0] * 3 for _ in range(n)] dp[0][0] = cost[0][0] dp[0][1] = cost[0][1] dp[0][2] = cost[0][2] for i in range(1, n): dp[i][0] = cost[i][0] + min(dp[i-1][1], dp[i-1][2]) dp[i][1] = cost[i][1] + min(dp[i-1][0], dp[i-1][2]) dp[i][2] = cost[i][2] + min(dp[i-1][0], dp[i-1][1]) return min(dp[-1])"},{"question":"class VaultSecurity: A class to represent the security system for a vault which checks if the access sequence contains any forbidden subsequences. Attributes: forbidden_sequences (List[str]): List of forbidden subsequences. Methods: canAccess(sequence: str) -> bool: Checks if the sequence can access the vault. def __init__(self, forbidden_sequences): Initializes the data structure with the forbidden sequences. :param forbidden_sequences: List of forbidden subsequences. pass def canAccess(self, sequence): Returns True if the given sequence does not contain any of the forbidden subsequences, otherwise returns False. :param sequence: The sequence to check. :return: Boolean value indicating whether access is granted. pass # Example Unit Tests def test_vault_security_no_forbidden_subsequences(): vs = VaultSecurity(['123', '456', '789']) assert vs.canAccess('014') == True def test_vault_security_with_forbidden_subsequence(): vs = VaultSecurity(['123', '456', '789']) assert vs.canAccess('1234') == False def test_vault_security_with_multiple_forbidden_subsequences(): vs = VaultSecurity(['123', '456', '789']) assert vs.canAccess('1234567') == False assert vs.canAccess('11123456789') == False def test_vault_security_empty_forbidden_sequences(): vs = VaultSecurity([]) assert vs.canAccess('0123456789') == True def test_vault_security_empty_sequence(): vs = VaultSecurity(['123', '456', '789']) assert vs.canAccess('') == True def test_vault_security_partial_match(): vs = VaultSecurity(['123', '456', '789']) assert vs.canAccess('01234') == False assert vs.canAccess('03456') == False def test_vault_security_no_match(): vs = VaultSecurity(['123', '456', '789']) assert vs.canAccess('987') == True","solution":"class VaultSecurity: def __init__(self, forbidden_sequences): Initializes the data structure with the forbidden sequences. :param forbidden_sequences: List of forbidden subsequences. self.forbidden_sequences = forbidden_sequences def canAccess(self, sequence): Returns True if the given sequence does not contain any of the forbidden subsequences, otherwise returns False. :param sequence: The sequence to check. :return: Boolean value indicating whether access is granted. for forbidden in self.forbidden_sequences: if forbidden in sequence: return False return True"},{"question":"def min_removals_to_non_decreasing(heights: List[int]) -> int: Returns the minimum number of removals required to make the heights list non-decreasing. >>> min_removals_to_non_decreasing([1, 2, 3, 4, 5]) == 0 >>> min_removals_to_non_decreasing([5, 4, 3, 2, 1]) == 4 >>> min_removals_to_non_decreasing([3, 4, 2, 1, 5]) == 2 >>> min_removals_to_non_decreasing([5]) == 0 >>> min_removals_to_non_decreasing([2, 2, 2, 2]) == 0","solution":"def min_removals_to_non_decreasing(heights): Returns the minimum number of removals required to make the heights list non-decreasing. n = len(heights) # Initialize the list to store the length of the longest increasing subsequence ending at each index LIS = [1] * n # Compute the length of the longest increasing subsequence using dynamic programming for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: LIS[i] = max(LIS[i], LIS[j] + 1) # The number of removals required is the size of the array minus the length of the longest increasing subsequence return n - max(LIS)"},{"question":"def find_rooms(rooms: List[List[int]], queries: List[List[int]]) -> List[List[int]]: Finds rooms that meet the requirements of each query. Parameters: - rooms: List of list of integers, where each element is [length, width, height]. - queries: List of list of integers, where each element is [desired_length, desired_width, desired_height]. Returns: - List of lists of indices. Each sublist represents the indices of rooms that meet the requirements of the corresponding query. >>> find_rooms([[5, 5, 5], [6, 6, 6]], [[7, 7, 7]]) [[]] >>> find_rooms([[5, 5, 5], [6, 6, 6]], [[5, 5, 5]]) [[0, 1]] >>> find_rooms([[5, 5, 5], [6, 6, 6]], [[4, 4, 4]]) [[0, 1]] >>> find_rooms([[5, 5, 5], [6, 6, 6], [7, 7, 7]], [[5, 5, 5], [6, 6, 6], [7, 7, 8]]) [[0, 1, 2], [1, 2], []] >>> find_rooms([[2, 2, 2]], [[1, 1, 1], [2, 2, 2], [3, 3, 3]]) [[0], [0], []] >>> find_rooms([], [[1, 1, 1]]) [[]] >>> find_rooms([[5, 5, 5]], []) []","solution":"def find_rooms(rooms, queries): Finds rooms that meet the requirements of each query. Parameters: - rooms: List of list of integers, where each element is [length, width, height]. - queries: List of list of integers, where each element is [desired_length, desired_width, desired_height]. Returns: - List of lists of indices. Each sublist represents the indices of rooms that meet the requirements of the corresponding query. result = [] for q in queries: desired_length, desired_width, desired_height = q indices = [] for i, room in enumerate(rooms): if room[0] >= desired_length and room[1] >= desired_width and room[2] >= desired_height: indices.append(i) result.append(indices) return result"},{"question":"from typing import List def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Find all strings in words that match the given pattern. A word matches the pattern if there exists a permutation of letters such that the word can be transformed into the pattern. Args: words (List[str]): List of words to be checked. pattern (str): Pattern to match words against. Returns: List[str]: List of words that match the pattern. Example: >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] pass # Test cases from solution import find_and_replace_pattern def test_find_and_replace_pattern_basic(): words = [\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"] pattern = \\"abb\\" expected = [\\"mee\\", \\"aqq\\"] assert find_and_replace_pattern(words, pattern) == expected def test_find_and_replace_pattern_no_match(): words = [\\"abc\\", \\"deq\\", \\"xyz\\"] pattern = \\"abb\\" expected = [] assert find_and_replace_pattern(words, pattern) == expected def test_find_and_replace_pattern_all_match(): words = [\\"xyz\\", \\"zyx\\", \\"zzy\\"] pattern = \\"xyz\\" expected = [\\"xyz\\", \\"zyx\\"] assert find_and_replace_pattern(words, pattern) == expected def test_find_and_replace_pattern_partial_match(): words = [\\"xyz\\", \\"zyx\\", \\"yxx\\"] pattern = \\"abb\\" expected = [\\"yxx\\"] assert find_and_replace_pattern(words, pattern) == expected def test_find_and_replace_pattern_different_lengths(): words = [\\"xyz\\", \\"zyx\\", \\"zzz\\", \\"zz\\"] pattern = \\"abc\\" expected = [\\"xyz\\", \\"zyx\\"] assert find_and_replace_pattern(words, pattern) == expected","solution":"def find_and_replace_pattern(words, pattern): def match(word): if len(word) != len(pattern): return False m1, m2 = {}, {} for w, p in zip(word, pattern): if w not in m1: m1[w] = p if p not in m2: m2[p] = w if (m1[w], m2[p]) != (p, w): return False return True return [word for word in words if match(word)]"},{"question":"def longestPalindromeSubstr(s: str) -> str: Finds the longest palindromic substring within the given string s. >>> longestPalindromeSubstr(\\"babad\\") \\"bab\\" or longestPalindromeSubstr(\\"babad\\") \\"aba\\" >>> longestPalindromeSubstr(\\"cbbd\\") \\"bb\\" >>> longestPalindromeSubstr(\\"a\\") \\"a\\" >>> longestPalindromeSubstr(\\"ac\\") \\"a\\" or longestPalindromeSubstr(\\"ac\\") \\"c\\"","solution":"def longestPalindromeSubstr(s: str) -> str: def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if not s or len(s) == 1: return s longest = '' for i in range(len(s)): # Odd length palindromes substr1 = expand_around_center(s, i, i) if len(substr1) > len(longest): longest = substr1 # Even length palindromes substr2 = expand_around_center(s, i, i + 1) if len(substr2) > len(longest): longest = substr2 return longest"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: You are given an \`m x n\` matrix of integers where each row is sorted in ascending order from left to right and each column is sorted in ascending order from top to bottom. Finds an element \`target\` in the matrix. Returns the coordinates of \`target\` as a pair (row_index, column_index) if it is found, or \`(-1, -1)\` if it is not. >>> matrix = [ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ] >>> search_matrix(matrix, 5) (1, 1) >>> search_matrix(matrix, 20) (-1, -1)","solution":"def search_matrix(matrix, target): Returns the coordinates (row_index, column_index) of target in the matrix. If target is not found, returns (-1, -1). if not matrix or not matrix[0]: return (-1, -1) m, n = len(matrix), len(matrix[0]) row, col = 0, n - 1 while row < m and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"def max_visible_buildings(heights: List[int]) -> int: Determine the maximum number of buildings visible from the observation tower. :param heights: List[int] : A list of integers representing the heights of buildings :return: int : The number of buildings visible from the first building >>> max_visible_buildings([]) 0 >>> max_visible_buildings([5]) 1 >>> max_visible_buildings([5, 5, 5, 5]) 1 >>> max_visible_buildings([1, 2, 3, 4, 5]) 5 >>> max_visible_buildings([5, 4, 3, 2, 1]) 1 >>> max_visible_buildings([3, 1, 4, 2, 5]) 3 >>> max_visible_buildings([1, 3, 2, 4, 2, 5]) 4 >>> max_visible_buildings([10, 4, 3, 12, 20, 5]) 3 # Write your implementation here","solution":"def max_visible_buildings(heights): Returns the maximum number of buildings visible from the observation tower. :param heights: List[int] : A list of integers representing the heights of buildings :return: int : The number of buildings visible from the first building if not heights: return 0 max_height = heights[0] visible_count = 1 for i in range(1, len(heights)): if heights[i] > max_height: visible_count += 1 max_height = heights[i] return visible_count"},{"question":"def min_max_weight_partition(nums, k): Returns the minimum possible value of max weight W for a valid partition into k components. >>> min_max_weight_partition([1, 2, 3, 4, 5], 2) 9 >>> min_max_weight_partition([7, 2, 5, 10, 8], 1) 32 >>> min_max_weight_partition([7, 2, 5, 10, 8], 5) 10 >>> min_max_weight_partition([1, 2, 3, 4, 5], 3) 6 >>> min_max_weight_partition([10, 10, 10, 10], 2) 20 >>> min_max_weight_partition([100, 200, 300, 400, 500], 3) 600","solution":"def is_valid_partition(nums, k, max_weight): Helper function to determine if we can partition nums into k components with max weight max_weight. current_sum = 0 count = 1 # We start with 1 component for weight in nums: if current_sum + weight <= max_weight: current_sum += weight else: count += 1 current_sum = weight if count > k: return False return True def min_max_weight_partition(nums, k): Returns the minimum possible value of max weight W for a valid partition into k components. left = max(nums) # Minimum of max_weight should be at least the maximum element in nums right = sum(nums) # Maximum of max_weight can be the sum of all elements while left < right: mid = (left + right) // 2 if is_valid_partition(nums, k, mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List def shortest_bridge(grid: List[List[int]]) -> int: Find the minimum length of the shortest bridge that can be built to connect any two islands. Args: grid List[List[int]]: A m x n grid representing the map. Returns: int: The minimum length of the shortest possible bridge. >>> shortest_bridge([[0, 1], [1, 0]]) == 1 >>> shortest_bridge([[0, 1, 0], [0, 0, 0], [0, 0, 1]]) == 2 pass def test_example_case(): grid = [ [0, 1], [1, 0] ] assert shortest_bridge(grid) == 1 def test_medium_case(): grid = [ [0, 1, 0], [0, 0, 0], [0, 0, 1] ] assert shortest_bridge(grid) == 2 def test_no_water_between_islands(): grid = [ [1, 0, 1], [1, 0, 1] ] assert shortest_bridge(grid) == 1 def test_large_case(): grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 0, 0] ] assert shortest_bridge(grid) == 2 def test_large_case_2(): grid = [ [0, 1, 0, 1], [1, 0, 0, 0] ] assert shortest_bridge(grid) == 1 def test_snaking_islands(): grid = [ [1, 0, 1, 0, 0], [0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [1, 0, 0, 0, 1] ] assert shortest_bridge(grid) == 1 def test_case_with_one_vacant_cell(): grid = [ [1, 1, 0], [1, 0, 1], [0, 1, 1] ] assert shortest_bridge(grid) == 1 def test_case_with_large_water_body(): grid = [ [1, 0, 0, 0, 0, 1] ] assert shortest_bridge(grid) == 4","solution":"from collections import deque def shortest_bridge(grid): def bfs_find_island(x, y): queue = deque([(x, y)]) island = set([(x, y)]) grid[x][y] = -1 while queue: cx, cy = queue.popleft() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 1: queue.append((nx, ny)) grid[nx][ny] = -1 island.add((nx, ny)) return island def bfs_expand_island(): steps = 0 while queue: for _ in range(len(queue)): cx, cy = queue.popleft() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): if grid[nx][ny] == 1: return steps if grid[nx][ny] == 0: grid[nx][ny] = -1 queue.append((nx, ny)) steps += 1 return -1 # Find the first island found_island = False for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island1 = bfs_find_island(i, j) found_island = True break if found_island: break # Expand the first island to find the shortest bridge to the second island queue = deque(island1) return bfs_expand_island()"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring containing properly nested parentheses. >>> longest_balanced_substring('') == 0 >>> longest_balanced_substring('()') == 2 >>> longest_balanced_substring('(())') == 4 >>> longest_balanced_substring('()()') == 4 >>> longest_balanced_substring('(()') == 2 >>> longest_balanced_substring('())') == 2 >>> longest_balanced_substring(')()())') == 4 >>> longest_balanced_substring('((((') == 0 >>> longest_balanced_substring('((()))(()') == 6 >>> longest_balanced_substring('()((()))') == 8","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring containing properly nested parentheses. max_length = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) elif char == ')': stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"def longest_subarray_with_two_distinct(arr: List[int]) -> int: Returns the length of the longest contiguous subarray that contains at most two distinct numbers. >>> longest_subarray_with_two_distinct([1, 2, 1]) 3 >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) 4 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_two_distinct([3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]) 5 >>> longest_subarray_with_two_distinct([1, 1, 1, 1]) 4 >>> longest_subarray_with_two_distinct([]) 0","solution":"def longest_subarray_with_two_distinct(arr): Returns the length of the longest contiguous subarray that contains at most two distinct numbers. if not arr: return 0 n = len(arr) max_len = 0 left = 0 num_count = {} for right in range(n): if arr[right] in num_count: num_count[arr[right]] += 1 else: num_count[arr[right]] = 1 while len(num_count) > 2: num_count[arr[left]] -= 1 if num_count[arr[left]] == 0: del num_count[arr[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression with non-negative integers and operators '+' '-' '*'. >>> evaluate_expression(\\"3+2\\") == 5 >>> evaluate_expression(\\"5-3\\") == 2 >>> evaluate_expression(\\"4*2\\") == 8 >>> evaluate_expression(\\"2+3*4\\") == 14 >>> evaluate_expression(\\"2*3+4\\") == 10 >>> evaluate_expression(\\"3+5-2*6\\") == -4 >>> evaluate_expression(\\"0+1+2+3+4\\") == 10 >>> evaluate_expression(\\"1-1+1-1\\") == 0 >>> evaluate_expression(\\"3+2-5*6\\") == -25 >>> evaluate_expression(\\"12*3-4*2+1\\") == 29","solution":"def evaluate_expression(s): Evaluates a mathematical expression with non-negative integers and operators '+' '-' '*'. tokens = [] num = 0 op = '+' for char in s + '+': if char.isdigit(): num = num * 10 + int(char) else: if op == '+': tokens.append(num) elif op == '-': tokens.append(-num) elif op == '*': tokens[-1] = tokens[-1] * num op = char num = 0 return sum(tokens)"},{"question":"def next_closest_time(time: str) -> str: Given a time in \\"HH:MM\\" format, find the next closest time using the same digits. >>> next_closest_time(\\"19:34\\") '19:39' >>> next_closest_time(\\"23:59\\") '22:22' >>> next_closest_time(\\"00:00\\") '00:00' >>> next_closest_time(\\"01:32\\") '01:33' >>> next_closest_time(\\"11:11\\") '11:11'","solution":"def next_closest_time(time): Given a time in \\"HH:MM\\" format, find the next closest time using the same digits. # Extract digits from the input time digits = sorted(set(time.replace(':', ''))) # Convert the input time to minutes current_minutes = int(time[:2]) * 60 + int(time[3:]) while True: # Increment the time by one minute current_minutes = (current_minutes + 1) % (24 * 60) # Extract the new hour and minute in string format new_hour = current_minutes // 60 new_minute = current_minutes % 60 # Format the new time as \\"HH:MM\\" new_time = \\"{:02d}:{:02d}\\".format(new_hour, new_minute) # Check if all of the digits of the new time are present in the original digits if all(digit in digits for digit in new_time.replace(':', '')): return new_time"},{"question":"def longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> longest_substring_two_distinct(\\"eceba\\") 3 >>> longest_substring_two_distinct(\\"abcbbbbcccbdddadacb\\") 10 >>> longest_substring_two_distinct(\\"\\") 0 >>> longest_substring_two_distinct(\\"aaaaa\\") 5 >>> longest_substring_two_distinct(\\"abcdef\\") 2 >>> longest_substring_two_distinct(\\"aabbcc\\") 4 >>> longest_substring_two_distinct(\\"aabbccabc\\") 4","solution":"def longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. if not s: return 0 left = 0 right = 0 max_len = 0 char_count = {} while right < len(s): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def num_islands(grid: List[List[str]]) -> int: Calculate the size of the largest island in a given grid where '1' represents land and '0' represents water. >>> num_islands([ ['0', '0', '0', '0'], ['0', '0', '0', '0'], ['0', '0', '0', '0'], ['0', '0', '0', '0'] ]) == 0 >>> num_islands([ ['1', '1', '0', '0'], ['0', '1', '0', '0'], ['0', '0', '0', '0'], ['0', '0', '1', '1'] ]) == 3 >>> num_islands([ ['1', '0', '0', '1'], ['0', '0', '1', '1'], ['1', '0', '0', '0'], ['1', '1', '0', '0'] ]) == 3 >>> num_islands([ ['1', '1', '1', '0'], ['1', '1', '0', '0'], ['1', '0', '1', '1'], ['0', '0', '1', '1'] ]) == 6 >>> num_islands([ ['1', '1', '1', '1'], ['1', '1', '1', '1'], ['1', '1', '1', '1'], ['1', '1', '1', '1'] ]) == 16","solution":"def num_islands(grid): if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) largest_island = 0 def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == '0': return 0 grid[x][y] = '0' size = 1 size += dfs(x + 1, y) size += dfs(x - 1, y) size += dfs(x, y + 1) size += dfs(x, y - 1) return size for i in range(n): for j in range(m): if grid[i][j] == '1': island_size = dfs(i, j) largest_island = max(largest_island, island_size) return largest_island"},{"question":"from typing import List def min_subarray_len(arr: List[int], target: int) -> int: Given an integer array \`arr\`, return the length of the shortest, non-empty, contiguous subarray of \`arr\` with a sum greater than or equal to \`target\`. If there is no such subarray, return \`-1\`. >>> min_subarray_len([2,3,1,2,4,3], 7) == 2 >>> min_subarray_len([1,1,1,1,1], 10) == -1 >>> min_subarray_len([5], 5) == 1 >>> min_subarray_len([1], 2) == -1 >>> min_subarray_len([1,4,4], 4) == 1 >>> min_subarray_len([1,2,3,4,5], 11) == 3 >>> min_subarray_len([1,2,3,4,5], 15) == 5 >>> min_subarray_len([2,1,1,1,2,1,1,2], 7) == 5","solution":"def min_subarray_len(arr, target): Returns the length of the shortest, non-empty, contiguous subarray of arr with a sum greater than or equal to target. If there is no such subarray, returns -1. n = len(arr) min_len = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else -1"},{"question":"def longest_special_subarray(arr: List[int]) -> int: Returns the length of the longest special subarray (containing at least one even and one odd number). If there are no such subarrays, returns -1. pass from typing import List def test_all_even(): assert longest_special_subarray([2, 4, 6, 8]) == -1 def test_all_odd(): assert longest_special_subarray([1, 3, 5, 7]) == -1 def test_mixed_numbers(): assert longest_special_subarray([1, 2, 4, 5]) == 4 def test_single_even_and_odd(): assert longest_special_subarray([2, 1]) == 2 def test_no_special_subarray(): assert longest_special_subarray([]) == -1 def test_long_special_subarray(): assert longest_special_subarray([1, 3, 5, 2, 4, 6, 8]) == 7 def test_longest_subarray_in_middle(): assert longest_special_subarray([1, 1, 2, 5, 2, 1]) == 6","solution":"def longest_special_subarray(arr): Returns the length of the longest special subarray (containing at least one even and one odd number). If there are no such subarrays, returns -1. n = len(arr) max_length = -1 for i in range(n): has_even = has_odd = False for j in range(i, n): if arr[j] % 2 == 0: has_even = True else: has_odd = True if has_even and has_odd: max_length = max(max_length, j - i + 1) return max_length"},{"question":"def move_val_to_end(nums: List[int], val: int) -> int: Moves all occurrences of val to the end of nums array in-place. Returns the number of elements that are not equal to val. >>> nums = [0, 1, 2, 2, 3, 0, 4, 2] >>> val = 2 >>> move_val_to_end(nums, val) 5 >>> nums[:5] [0, 1, 3, 0, 4] >>> nums = [0, 1, 3, 4] >>> val = 2 >>> move_val_to_end(nums, val) 4 >>> nums [0, 1, 3, 4] >>> nums = [2, 2, 2, 2] >>> val = 2 >>> move_val_to_end(nums, val) 0 >>> nums [2, 2, 2, 2] >>> nums = [3, 2, 2, 3] >>> val = 2 >>> move_val_to_end(nums, val) 2 >>> nums[:2] [3, 3] >>> nums = [2, 3, 4, 5] >>> val = 2 >>> move_val_to_end(nums, val) 3 >>> nums[:3] [3, 4, 5] >>> nums = [3, 4, 5, 2] >>> val = 2 >>> move_val_to_end(nums, val) 3 >>> nums[:3] [3, 4, 5]","solution":"def move_val_to_end(nums, val): Moves all occurrences of val to the end of nums array in-place. Returns the number of elements that are not equal to val. n = len(nums) insert_pos = 0 for i in range(n): if nums[i] != val: nums[insert_pos] = nums[i] insert_pos += 1 for i in range(insert_pos, n): nums[i] = val return insert_pos"},{"question":"def merge_and_remove_duplicates(arr1: List[int], arr2: List[int]) -> List[int]: Merge two arrays into one sorted array in non-decreasing order, and remove any duplicates. Args: arr1 (list of int): First array. arr2 (list of int): Second array. Returns: list of int: Merged, sorted list with unique elements. Examples: >>> merge_and_remove_duplicates([1, 3, 4, 7], [2, 3, 5, 6, 7]) [1, 2, 3, 4, 5, 6, 7] >>> merge_and_remove_duplicates([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6]","solution":"def merge_and_remove_duplicates(arr1, arr2): Merges two arrays, removes duplicates, and returns a sorted list. Args: arr1 (list of int): First array. arr2 (list of int): Second array. Returns: list of int: Merged, sorted list with unique elements. merged_set = set(arr1) | set(arr2) return sorted(list(merged_set))"},{"question":"def count_valid_subsets(weights: List[int], capacity: int) -> int: Returns the number of ways to select a non-empty subset of items such that the total weight of the subset does not exceed the capacity. >>> count_valid_subsets([1, 2, 3], 3) 4 >>> count_valid_subsets([1, 1, 1, 1], 4) 15 >>> count_valid_subsets([5, 6, 7], 4) 0 >>> count_valid_subsets([2], 3) 1 >>> count_valid_subsets([2, 3, 5], 10) 7","solution":"def count_valid_subsets(weights, capacity): Returns the number of ways to select a non-empty subset of items such that the total weight of the subset does not exceed the capacity. from itertools import combinations n = len(weights) count = 0 # Check all subsets of weights for i in range(1, n+1): for subset in combinations(weights, i): if sum(subset) <= capacity: count += 1 return count"},{"question":"def maxProfit(prices: List[int], x: int) -> int: Returns the maximum profit that can be achieved with the given prices and initial capital. param prices: List of integers where each represents the stock price on a given day. x: Initial capital for trading. return: Maximum profit possible, or 0 if no transaction can be made. >>> maxProfit([10, 15, 20, 25], 5) 0 >>> maxProfit([10], 10) 0 >>> maxProfit([5, 3, 6, 2, 8], 10) 6 >>> maxProfit([7, 1, 5, 3, 6, 4], 7) 5 >>> maxProfit([7, 6, 4, 3, 1], 6) 0 >>> maxProfit([1, 2, 3, 0, 2], 2) 2 >>> maxProfit([7, 1, 5, 3, 6, 4], 0) 0 >>> maxProfit([10, 8, 6, 4, 2], 5) 0","solution":"def maxProfit(prices, x): Returns the maximum profit that can be achieved with the given prices and initial capital. :param prices: List of integers where each represents the stock price on a given day. :param x: Initial capital for trading. :return: Maximum profit possible, or 0 if no transaction can be made. n = len(prices) if n == 0: return 0 min_price = float('inf') max_profit = 0 for i in range(n): if prices[i] <= x: # Buy only if price is within the capital. min_price = min(min_price, prices[i]) max_profit = max(max_profit, prices[i] - min_price) # Check if a valid transaction was possible with the given capital. if max_profit == 0: for price in prices: if price <= x: return 0 # No valid transaction found return max_profit"},{"question":"def find_redundant_connections(n, edges): Finds the minimum number of roads that need to be removed to ensure no cycles in the remaining graph. Parameters: n (int): Number of cities (nodes) edges (list of tuples): Each tuple (u, v, w) represents a road between cities u and v with length w Returns: int: The minimum number of roads to be removed to make the graph acyclic Examples: >>> find_redundant_connections(4, [(0, 1, 1), (1, 2, 2), (2, 3, 3)]) 0 >>> find_redundant_connections(4, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 0, 4)]) 1 >>> find_redundant_connections(4, [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 0, 4), (1, 3, 5)]) 2 >>> find_redundant_connections(5, [(0, 1, 1), (0, 2, 2), (1, 2, 3), (3, 4, 4), (2, 4, 5), (1, 3, 6)]) 2 >>> find_redundant_connections(6, [(0, 1, 1), (2, 3, 2), (4, 5, 3)]) 0","solution":"def find_redundant_connections(n, edges): Finds the minimum number of roads that need to be removed to ensure no cycles in the remaining graph. Parameters: n (int): Number of cities (nodes) edges (list of tuples): Each tuple (u, v, w) represents a road between cities u and v with length w Returns: int: The minimum number of roads to be removed to make the graph acyclic parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootX] = rootY return True return False union_count = 0 for u, v, _ in edges: if not union(u, v): union_count += 1 return union_count"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in a given string. pass def find_longest_palindromic_substring_length(strings: List[str]) -> int: Given a list of strings, returns the length of the longest palindrome found as a substring in any of the strings in the list. >>> find_longest_palindromic_substring_length([\\"babad\\"]) 3 >>> find_longest_palindromic_substring_length([\\"cbbd\\"]) 2 >>> find_longest_palindromic_substring_length([\\"babad\\", \\"cbbd\\", \\"a\\"]) 3 >>> find_longest_palindromic_substring_length([\\"ac\\", \\"bb\\", \\"ccd\\"]) 2 >>> find_longest_palindromic_substring_length([\\"\\"]) 0 >>> find_longest_palindromic_substring_length([\\"abcde\\"]) 1 >>> find_longest_palindromic_substring_length([\\"racecar\\"]) 7 >>> find_longest_palindromic_substring_length([\\"aaaa\\"]) 4 pass","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in a given string. if not s: return 0 n = len(s) longest = 1 # Create a 2D array to keep track of palindromes dp = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for palindrome of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True longest = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True longest = length return longest def find_longest_palindromic_substring_length(strings): Given a list of strings, returns the length of the longest palindrome found as a substring in any of the strings in the list. max_length = 0 for s in strings: max_length = max(max_length, longest_palindromic_substring_length(s)) return max_length"},{"question":"def sum_every_third(nums: List[int]) -> List[int]: Given an array of integers \`nums\`, create a different array \`res\`, where each element \`res[i]\` is the sum of every third element in the \`nums\` array starting from index \`i\`. >>> sum_every_third([1, 2, 3, 4, 5, 6, 7, 8, 9]) [12, 15, 18] >>> sum_every_third([1, 2, 3]) [1, 2, 3] >>> sum_every_third([1, 2]) [1, 2, 0] >>> sum_every_third([]) [0, 0, 0] >>> sum_every_third([4]) [4, 0, 0] >>> sum_every_third([1, 2, 3, 4, 5, 6, 7]) [12, 7, 9] >>> sum_every_third([-1, -2, -3, -4, -5, -6, -7, -8, -9]) [-12, -15, -18]","solution":"def sum_every_third(nums): result = [0, 0, 0] # Initialize result array with zeros for i in range(len(nums)): result[i % 3] += nums[i] return result"},{"question":"def three_consecutive_common(arr: List[int]) -> bool: Return True if there are three consecutive common elements, otherwise return False. >>> three_consecutive_common([1, 2, 2, 2, 3, 4]) == True >>> three_consecutive_common([1, 2, 3, 4, 5, 6]) == False >>> three_consecutive_common([5, 5, 5, 1, 2, 2]) == True >>> three_consecutive_common([]) == False >>> three_consecutive_common([3]) == False >>> three_consecutive_common([9, 9, 9]) == True >>> three_consecutive_common([2, 2, 2, 2]) == True >>> three_consecutive_common([1, 1, 2, 2, 2, 2, 3, 3]) == True","solution":"def three_consecutive_common(arr): Returns True if there are three consecutive common elements in the array, otherwise returns False. for i in range(len(arr) - 2): if arr[i] == arr[i+1] == arr[i+2]: return True return False"},{"question":"from typing import List def nth_smallest_pair_distance(arr: List[int], n: int) -> int: Given an array of integers \`arr\`, and a positive integer \`n\`, find the n-th smallest pair distance. The pair distance of a pair (arr[i], arr[j]) is defined as the absolute difference between arr[i] and arr[j]. The n-th smallest pair distance is the n-th smallest value out of all the possible pair distances. Args: arr (List[int]): List of integers n (int): Positive integer representing the n-th position Returns: int: The n-th smallest pair distance in the array Examples: >>> nth_smallest_pair_distance([1, 3, 1], 1) 0 >>> nth_smallest_pair_distance([1, 3, 1], 2) 2 >>> nth_smallest_pair_distance([1, 6, 1], 3) 5 >>> nth_smallest_pair_distance([1, 2, 3, 4, 5], 7) 2 >>> nth_smallest_pair_distance([1, 2, 3, 5, 7], 5) 2 >>> nth_smallest_pair_distance([1, 1, 1, 1], 3) 0","solution":"def nth_smallest_pair_distance(arr, n): Returns the n-th smallest pair distance in the array. def count_pairs_with_max_distance(max_dist): Counts the number of pairs with a distance less than or equal to max_dist. count = 0 left = 0 for right in range(len(arr)): while arr[right] - arr[left] > max_dist: left += 1 count += right - left return count arr.sort() lo, hi = 0, arr[-1] - arr[0] while lo < hi: mid = (lo + hi) // 2 if count_pairs_with_max_distance(mid) < n: lo = mid + 1 else: hi = mid return lo"},{"question":"def has_k_distinct_indices_sum_zero(arr: List[int], k: int) -> bool: Determine if there are k distinct indices in the array such that the sum of the elements at those indices is 0. Args: arr (List[int]): A list of integers. k (int): The number of distinct indices. Returns: bool: True if such indices exist, False otherwise. >>> has_k_distinct_indices_sum_zero([1, 2, 3, 4], 2) False >>> has_k_distinct_indices_sum_zero([0], 1) True >>> has_k_distinct_indices_sum_zero([1, -1, 2, -2, 3, -3], 3) True >>> has_k_distinct_indices_sum_zero([1, -1], 3) False >>> has_k_distinct_indices_sum_zero([1, 2, -2, -1, 4, 0, -4], 4) True","solution":"def has_k_distinct_indices_sum_zero(arr, k): Determine if there are k distinct indices in the array such that the sum of the elements at those indices is 0. Args: arr (list): A list of integers. k (int): The number of distinct indices. Returns: bool: True if such indices exist, False otherwise. from itertools import combinations for indices in combinations(range(len(arr)), k): if sum(arr[i] for i in indices) == 0: return True return False"},{"question":"def min_swaps_to_balance(s: str) -> int: Returns the minimum number of swaps required to make the string balanced. If it is not possible to make the string balanced, return -1. >>> min_swaps_to_balance(\\"abcabc\\") == 0 >>> min_swaps_to_balance(\\"aaabbbccc\\") == 0 >>> min_swaps_to_balance(\\"aaaabbcc\\") == -1 >>> min_swaps_to_balance(\\"aabbcc\\") == 0 >>> min_swaps_to_balance(\\"abcab\\") == -1 >>> min_swaps_to_balance(\\"a\\") == -1 >>> min_swaps_to_balance(\\"\\") == 0 >>> min_swaps_to_balance(\\"aaabb\\") == -1 >>> min_swaps_to_balance(\\"ccbbaa\\") == 0 >>> min_swaps_to_balance(\\"cbacba\\") == 0 >>> min_swaps_to_balance(\\"aaaabbbbcc\\") == -1 >>> min_swaps_to_balance(\\"aabbccc\\") == -1","solution":"def min_swaps_to_balance(s: str) -> int: Returns the minimum number of swaps required to make the string balanced. If it is not possible to make the string balanced, return -1. # Count the number of 'a', 'b', and 'c' in the string count_a = s.count('a') count_b = s.count('b') count_c = s.count('c') # Calculate the expected count for 'a', 'b', and 'c' to be balanced n = len(s) if n % 3 != 0: return -1 # If length is not a multiple of 3, balancing is impossible target_count = n // 3 # Check if balancing is possible if count_a != target_count or count_b != target_count or count_c != target_count: return -1 # The string is already balanced if we reach here return 0 # No swaps needed if counts are already equal"},{"question":"def count_interesting_subarrays(nums: List[int], k: int) -> int: Counts the number of interesting subarrays of length k in the given array. An interesting subarray contains exactly k elements and all elements are distinct. Parameters: nums (list): The input array of integers. k (int): The length of the subarray. Returns: int: The number of interesting subarrays of length k. pass from solution import count_interesting_subarrays def test_example_case(): nums = [1, 2, 3, 4] k = 2 assert count_interesting_subarrays(nums, k) == 3 def test_no_interesting_subarrays(): nums = [1, 1, 1, 1] k = 2 assert count_interesting_subarrays(nums, k) == 0 def test_one_interesting_subarray(): nums = [1, 2, 2, 3] k = 2 assert count_interesting_subarrays(nums, k) == 2 def test_k_greater_than_length(): nums = [1, 2, 3] k = 4 assert count_interesting_subarrays(nums, k) == 0 def test_all_elements_distinct(): nums = [1, 2, 3, 4, 5] k = 5 assert count_interesting_subarrays(nums, k) == 1 def test_large_input(): nums = list(range(1, 101)) k = 50 assert count_interesting_subarrays(nums, k) == 51","solution":"def count_interesting_subarrays(nums, k): Counts the number of interesting subarrays of length k in the given array. An interesting subarray contains exactly k elements and all elements are distinct. Parameters: nums (list): The input array of integers. k (int): The length of the subarray. Returns: int: The number of interesting subarrays of length k. if k > len(nums): return 0 count = 0 for i in range(len(nums) - k + 1): if len(set(nums[i:i+k])) == k: count += 1 return count"},{"question":"def max_balanced_substring(s: str) -> int: Returns the maximum length of a balanced substring in the given string \`s\`. A balanced substring has an equal number of '0's and '1's. >>> max_balanced_substring(\\"0000\\") == 0 >>> max_balanced_substring(\\"1111\\") == 0 >>> max_balanced_substring(\\"0101\\") == 4 >>> max_balanced_substring(\\"011\\") == 2 >>> max_balanced_substring(\\"0001110\\") == 6 >>> max_balanced_substring(\\"0101010101\\") == 10 >>> max_balanced_substring(\\"00110011\\") == 8 >>> max_balanced_substring(\\"\\") == 0","solution":"def max_balanced_substring(s): Returns the maximum length of a balanced substring in the given string \`s\`. A balanced substring has an equal number of '0's and '1's. Parameters: s (str): The input string containing only '0' and '1' characters. Returns: int: The length of the maximum balanced substring. max_length = 0 balance = 0 balance_map = {0: -1} for i, char in enumerate(s): if char == '0': balance -= 1 else: balance += 1 if balance in balance_map: max_length = max(max_length, i - balance_map[balance]) else: balance_map[balance] = i return max_length"},{"question":"def charAtK(s: str, k: int) -> str: Returns the k-th character in the decoded string of the run-length encoded string s. Args: s (str): The run-length encoded string. k (int): The position (1-indexed) of the character to retrieve from the decoded string. Returns: str: The k-th character in the decoded string. Examples: >>> charAtK(\\"a2b4c3\\", 5) 'b' >>> charAtK(\\"a5\\", 3) 'a' >>> charAtK(\\"a1b2c3\\", 4) 'c' >>> charAtK(\\"a1b3\\", 3) 'b' >>> charAtK(\\"a1b2c1d2\\", 6) 'd'","solution":"def charAtK(s: str, k: int) -> str: Returns the k-th character in the decoded string of the run-length encoded string s. decoded_str = \\"\\" i = 0 while i < len(s): char = s[i] num = \\"\\" i += 1 while i < len(s) and s[i].isdigit(): num += s[i] i += 1 decoded_str += char * int(num) return decoded_str[k-1]"},{"question":"def numWords(words, queries): Returns the number of distinct words that can be formed using exactly queries[i] characters from any of the words in the list \`words\`. >>> numWords([\\"hello\\", \\"world\\", \\"hi\\", \\"words\\", \\"example\\"], [2, 5]) [1, 3] >>> numWords([\\"hello\\", \\"world\\", \\"hi\\", \\"words\\", \\"example\\"], [1, 9]) [0, 0] >>> numWords([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"], [1, 2, 3, 4]) [1, 1, 1, 1]","solution":"def numWords(words, queries): Returns the number of distinct words that can be formed using exactly queries[i] characters from any of the words in the list \`words\`. word_lengths = sorted(set(len(word) for word in words)) def count_words_with_length(length): return len(set(word for word in words if len(word) == length)) return [count_words_with_length(query) for query in queries]"},{"question":"from typing import List def findClosestElements(arr: List[int], k: int, x: int) -> List[int]: Find the k closest integers to x in the array. The result should be sorted in ascending order. >>> findClosestElements([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> findClosestElements([1, 2, 3, 4, 5], 4, -1) [1, 2, 3, 4] >>> findClosestElements([1, 2, 3, 4, 5], 4, 6) [2, 3, 4, 5] >>> findClosestElements([1, 5, 10, 15], 2, 12) [10, 15] >>> findClosestElements([1, 2, 3, 4, 5], 1, 3) [3] >>> findClosestElements([1, 2, 3, 4, 5], 5, 3) [1, 2, 3, 4, 5] >>> findClosestElements([], 0, 3) [] >>> findClosestElements([1], 1, 1) [1] >>> findClosestElements([1, 2, 2, 2, 3], 2, 2) [2, 2] >>> findClosestElements([1, 3, 3, 4, 5], 3, 3) [3, 3, 4]","solution":"def findClosestElements(arr, k, x): Find the k closest integers to x in the array. The result should be sorted in ascending order. # Binary search to find the right place to start left, right = 0, len(arr) - k while left < right: mid = (left + right) // 2 if x - arr[mid] > arr[mid + k] - x: left = mid + 1 else: right = mid return arr[left:left + k]"},{"question":"def transform_string(s: str) -> str: Transforms the string \`s\` such that no two adjacent characters are the same. Returns the lexicographically smallest possible string after transformation. If such a transformation is not possible, returns an empty string. >>> transform_string(\\"aab\\") == \\"aba\\" >>> transform_string(\\"aaab\\") == \\"\\" >>> transform_string(\\"a\\") == \\"a\\" >>> transform_string(\\"abcdef\\") == \\"abcdef\\" >>> transform_string(\\"aaaa\\") == \\"\\" >>> transform_string(\\"aabbcc\\") in [\\"abcabc\\", \\"acbacb\\", \\"abacbc\\", \\"acbabc\\"] >>> transform_string(\\"aaabbb\\") in [\\"ababab\\", \\"bababa\\"] >>> transform_string(\\"aaaabbbbccccddddeeeeffff\\") in [ \\"abcdefabcdefabcdefabcdef\\", \\"abcdefabcdefabcdefabcdef\\", ] # Your code implementation here","solution":"def transform_string(s): Transforms the string \`s\` such that no two adjacent characters are the same. Returns the lexicographically smallest possible string after transformation. If such a transformation is not possible, returns an empty string. from collections import Counter import heapq # Count the frequency of each character char_count = Counter(s) max_freq = max(char_count.values()) # If the most frequent character is more than half of the string length plus one, it's impossible if max_freq > (len(s) + 1) // 2: return \\"\\" # Max-heap (Python's heapq is a min-heap, so we negate the counts to simulate a max-heap) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # decrement the count return ''.join(result)"},{"question":"def minPathSum(grid): Returns the minimum sum of weights to reach the bottom-right corner of the grid from the top-left corner. >>> minPathSum([[5]]) 5 >>> minPathSum([[1, 2], [1, 1]]) 3 >>> minPathSum([[1, 2, 5], [3, 2, 1]]) 6 >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([]) 0 >>> minPathSum([[]]) 0","solution":"def minPathSum(grid): Returns the minimum sum of weights to reach the bottom-right corner of the grid from the top-left corner. if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill up the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def count_min_length_words(s: str) -> int: Given a string \`s\` representing a sentence, return the number of words that have a length equal to the minimum word length in the sentence. A word is defined as a contiguous sequence of characters separated by spaces. Parameters: s (str): Input string representing the sentence. Returns: int: The number of words with the minimum length. >>> count_min_length_words(\\"The quick brown fox jumps over the lazy dog\\") == 4 >>> count_min_length_words(\\"hello\\") == 1 >>> count_min_length_words(\\"\\") == 0 >>> count_min_length_words(\\"a aa aaa aaaa\\") == 1 >>> count_min_length_words(\\"a bb ccc dddd eeeee\\") == 1 >>> count_min_length_words(\\"a! bb# ccc dddd%\\") == 1 >>> count_min_length_words(\\"a a a\\") == 3","solution":"def count_min_length_words(s): Returns the number of words that have a length equal to the minimum word length in the sentence s. Parameters: s (str): Input string representing the sentence. Returns: int: The number of words with the minimum length. words = s.split() if not words: return 0 min_length = min(len(word) for word in words) return sum(1 for word in words if len(word) == min_length)"},{"question":"def partition_labels(s: str) -> List[int]: Divides the string into as many parts as possible so that each letter appears in at most one part. Returns the lengths of the parts in an array. :param s: str :return: List[int] >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"abcdefghi\\") [1, 1, 1, 1, 1, 1, 1, 1, 1] >>> partition_labels(\\"aaaaa\\") [5] >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"abac\\") [3, 1]","solution":"def partition_labels(s): Divides the string into as many parts as possible so that each letter appears in at most one part. Returns the lengths of the parts in an array. :param s: str :return: List[int] last_occurrence = {char: idx for idx, char in enumerate(s)} partitions = [] start, end = 0, 0 for idx, char in enumerate(s): end = max(end, last_occurrence[char]) if idx == end: partitions.append(end - start + 1) start = idx + 1 return partitions"},{"question":"def find_task_order(n: int, dependencies: List[List[int]]) -> List[int]: Determine if it is possible to complete all tasks. If yes, return the order of task completion. If not, return an empty list. :param n: Number of tasks :param dependencies: A list of dependencies where dependencies[i] = [a, b] means task a must be completed before task b :return: A list of task completion order, or an empty list if not possible >>> find_task_order(4, []) == [1, 2, 3, 4] >>> find_task_order(4, [[1, 2], [2, 3], [3, 4]]) == [1, 2, 3, 4] >>> find_task_order(2, [[1, 2]]) == [1, 2] >>> find_task_order(4, [[1, 2], [1, 3], [3, 4], [2, 4]]) in [[1, 3, 2, 4], [1, 2, 3, 4]] >>> find_task_order(3, [[1, 2], [2, 3], [3, 1]]) == [] >>> find_task_order(6, [[1, 4], [2, 4], [3, 4], [4, 5], [5, 6]]) in [[1, 2, 3, 4, 5, 6], [2, 1, 3, 4, 5, 6], [3, 1, 2, 4, 5, 6]]","solution":"from collections import deque, defaultdict def find_task_order(n, dependencies): Determine if it is possible to complete all tasks. If yes, return the order of task completion. If not, return an empty list. :param n: Number of tasks :param dependencies: A list of dependencies where dependencies[i] = [a, b] means task a must be completed before task b :return: A list of task completion order, or an empty list if not possible indegree = [0] * (n + 1) adj_list = defaultdict(list) # Build the graph and compute in-degrees of each node (task) for dep in dependencies: adj_list[dep[0]].append(dep[1]) indegree[dep[1]] += 1 # Initialize the queue with nodes having no incoming edges queue = deque([i for i in range(1, n + 1) if indegree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in adj_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If the order contains all tasks, return it; otherwise, return an empty list return order if len(order) == n else []"},{"question":"def num_trees(n: int) -> int: Return the number of unique BSTs that can be constructed with n nodes where each node contains a unique value from 1 to n. >>> num_trees(0) 1 >>> num_trees(1) 1 >>> num_trees(2) 2 >>> num_trees(3) 5 >>> num_trees(4) 14 >>> num_trees(5) 42","solution":"def num_trees(n): Returns the number of unique BSTs that can be constructed with n nodes, where each node contains a unique value from 1 to n. if n == 0 or n == 1: return 1 count = [0] * (n + 1) count[0], count[1] = 1, 1 for i in range(2, n + 1): for j in range(1, i + 1): count[i] += count[j - 1] * count[i - j] return count[n]"},{"question":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. The houses are arranged in a circle, so you cannot rob the first and last house both. >>> rob([2]) == 2 >>> rob([3, 4]) == 4 >>> rob([2, 3, 2]) == 3 >>> rob([2, 7, 9, 3, 1]) == 11 >>> rob([2, 1, 1, 2]) == 3 >>> rob([1, 2, 3, 1]) == 4 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41 >>> rob([]) == 0","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. def rob_linear(houses): prev_max = 0 curr_max = 0 for amount in houses: temp = curr_max curr_max = max(prev_max + amount, curr_max) prev_max = temp return curr_max if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] elif len(nums) == 2: return max(nums[0], nums[1]) # Solve the problem in two linear cases: # 1. Rob houses from the first to the second-to-last house. # 2. Rob houses from the second to the last house. return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def largest_square_area(grid: List[List[int]]) -> int: You are given a 2D integer array \`grid\` representing a crossword puzzle, where \`grid[i][j]\` can be either \`0\` (an open cell) or \`1\` (a filled cell). Each \`1\` in the grid represents an obstacle that blocks the path. You need to find out the largest square area of connected open cells (\`0\`s) that can be formed in the grid. The square must be filled entirely with \`0\`s and should not be adjacent to any \`1\`s (except outside the grid). Return the side length of the largest square that can be formed. >>> largest_square_area([]) == 0 >>> largest_square_area([[1, 1], [1, 1]]) == 0 >>> largest_square_area([[0]]) == 1 >>> largest_square_area([[0, 0], [0, 0]]) == 2 >>> largest_square_area([[0, 1], [0, 0]]) == 1 >>> largest_square_area([ [0, 0, 1], [0, 0, 1], [1, 1, 1] ]) == 2 >>> largest_square_area([ [1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 0, 1, 0, 0], [0, 0, 0, 0, 0] ]) == 2","solution":"def largest_square_area(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 0: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def longest_subsequence_after_one_swap(s: str) -> int: Determines the length of the longest subsequence consisting of the same character that can be obtained after one swap. The sequence consists only of 'a' and 'b'. Args: s (str): The input string containing only 'a' and 'b'. Returns: int: The length of the longest subsequence after one swap. >>> longest_subsequence_after_one_swap(\\"abba\\") 3 >>> longest_subsequence_after_one_swap(\\"aaaa\\") 4 >>> longest_subsequence_after_one_swap(\\"abab\\") 3 >>> longest_subsequence_after_one_swap(\\"baba\\") 3 >>> longest_subsequence_after_one_swap(\\"aabb\\") 3 >>> longest_subsequence_after_one_swap(\\"aaaaab\\") 6 >>> longest_subsequence_after_one_swap(\\"bbbbb\\") 5 >>> longest_subsequence_after_one_swap(\\"a\\") 1 >>> longest_subsequence_after_one_swap(\\"b\\") 1 # Your implementation here","solution":"def longest_subsequence_after_one_swap(s): Determines the length of the longest subsequence consisting of the same character that can be obtained after one swap. The sequence consists only of 'a' and 'b'. Args: s (str): The input string containing only 'a' and 'b'. Returns: int: The length of the longest subsequence after one swap. # Count the number of 'a's and 'b's count_a = s.count('a') count_b = s.count('b') # The maximum subsequence length is the length of the whole string minus one character max_subseq_length = max(count_a, count_b) # One swap can only increase the count by 1 only if \`count_a\` and \`count_b\` are not initially equal if max_subseq_length < len(s): return max_subseq_length + 1 else: # If max_subseq_length is already the length of the string return max_subseq_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom. :param root: TreeNode, the root of the binary tree. :return: List[int], the values of the nodes seen from the right side. >>> rightSideView(TreeNode(1)) [1] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> rightSideView(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(3)), None) >>> rightSideView(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6))) >>> rightSideView(root) [1, 3, 6] >>> root = TreeNode(1, TreeNode(2, None, TreeNode(5)), TreeNode(3, None, TreeNode(4))) >>> rightSideView(root) [1, 3, 4] >>> rightSideView(None) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom. :param root: TreeNode, the root of the binary tree. :return: List[int], the values of the nodes seen from the right side. if not root: return [] right_view = [] level_nodes = [root] while level_nodes: right_view.append(level_nodes[-1].val) next_level = [] for node in level_nodes: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) level_nodes = next_level return right_view"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. def test_reverse_list(): def list_to_array(head): array = [] while head: array.append(head.val) head = head.next return array def array_to_list(array): if not array: return None head = ListNode(array[0]) current = head for val in array[1:]: current.next = ListNode(val) current = current.next return head # Test case 1: Empty list assert reverse_list(None) is None # Test case 2: Single element list head = ListNode(1) new_head = reverse_list(head) assert list_to_array(new_head) == [1] # Test case 3: Multiple element list head = array_to_list([1, 2, 3, 4, 5]) new_head = reverse_list(head) assert list_to_array(new_head) == [5, 4, 3, 2, 1] # Test case 4: Two element list head = array_to_list([1, 2]) new_head = reverse_list(head) assert list_to_array(new_head) == [2, 1] # Test case 5: List with duplicate values head = array_to_list([1, 2, 2, 3]) new_head = reverse_list(head) assert list_to_array(new_head) == [3, 2, 2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head): Reverses a singly linked list. Args: head (ListNode): The head of the singly linked list. Returns: ListNode: The new head of the reversed singly linked list. prev = None current = head while current: next_node = current.next # Temporarily save the next node current.next = prev # Reverse the current node's pointer prev = current # Move the prev pointer to the current node current = next_node # Move the current pointer to the next node return prev # Prev will be the new head of the reversed list"},{"question":"def smallest_lexicographical_substring(s: str, k: int) -> str: Returns the lexicographically smallest substring of length k from the given string s. Parameters: s (str): The input string. k (int): The length of the substring to be extracted. Returns: str: The lexicographically smallest substring of length k. >>> smallest_lexicographical_substring(\\"abcde\\", 3) \\"abc\\" >>> smallest_lexicographical_substring(\\"aaaaa\\", 2) \\"aa\\" >>> smallest_lexicographical_substring(\\"ababab\\", 2) \\"ab\\" >>> smallest_lexicographical_substring(\\"dbca23f\\", 3) \\"23f\\" >>> smallest_lexicographical_substring(\\"abecid\\", 2) \\"ab\\" >>> smallest_lexicographical_substring(\\"\\", 0) \\"\\" >>> smallest_lexicographical_substring(\\"ab\\", 2) \\"ab\\"","solution":"def smallest_lexicographical_substring(s, k): Returns the lexicographically smallest substring of length k from the given string s. Parameters: s (str): The input string. k (int): The length of the substring to be extracted. Returns: str: The lexicographically smallest substring of length k. smallest = s[:k] for i in range(1, len(s) - k + 1): current = s[i:i + k] if current < smallest: smallest = current return smallest"},{"question":"from typing import List def minPathSum(grid: List[List[int]]) -> int: Given a 2D grid of size m x n filled with non-negative integers, a rat needs to find a path from the top-left corner to the bottom-right corner of the grid. The rat can move either down or right at any point in time. Implement a function minPathSum(grid) that returns the minimum sum of all numbers along its path. :param grid: List[List[int]], the 2D grid :return: int, the minimum path sum >>> minPathSum([[1, 2, 3]]) == 6 >>> minPathSum([[1], [2], [3]]) == 6 >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> minPathSum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21 >>> minPathSum([]) == 0","solution":"def minPathSum(grid): Finds the minimum path sum in a 2D grid from top-left to bottom-right corner. The function can navigate only by moving right or down. :param grid: List[List[int]], the 2D grid :return: int, the minimum path sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first cell for i in range(1, m): grid[i][0] += grid[i - 1][0] for j in range(1, n): grid[0][j] += grid[0][j - 1] # Update the path sums for the rest of the cells for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) return grid[m - 1][n - 1]"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Calculates the minimum path sum from the top-left to the bottom-right corner of a grid. :param grid: List[List[int]] - 2D list of integers where each element represents the cost associated with moving through that cell. :return: int - Minimum path sum to reach the bottom-right corner. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_path_sum([[1, 2, 3], [4, 5, 6]]) == 12 >>> min_path_sum([[1, 2], [1, 1]]) == 3 >>> min_path_sum([[5]]) == 5 >>> min_path_sum([]) == 0 >>> min_path_sum([[1, 2, 3]]) == 6 >>> min_path_sum([[1], [2], [3]]) == 6 pass","solution":"def min_path_sum(grid): Calculates the minimum path sum from the top-left to the bottom-right corner of a grid. :param grid: List[List[int]] - 2D list of integers where each element represents the cost associated with moving through that cell. :return: int - Minimum path sum to reach the bottom-right corner. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Initialize the top-left corner for i in range(1, rows): grid[i][0] += grid[i-1][0] # Initialize the left column for j in range(1, cols): grid[0][j] += grid[0][j-1] # Fill in the remainder of the grid for i in range(1, rows): for j in range(1, cols): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[rows-1][cols-1]"},{"question":"def find_x_smallest_elements(arr, x): Returns the x smallest elements from the array in sorted order. Parameters: arr (list of int): The input unsorted integer array. x (int): The number of smallest elements to find. Returns: list of int: The x smallest elements in sorted order. Examples: >>> find_x_smallest_elements([7, 10, 4, 3, 20, 15], 3) [3, 4, 7] >>> find_x_smallest_elements([5, 15, 10, 20, 8], 2) [5, 8]","solution":"def find_x_smallest_elements(arr, x): Returns the x smallest elements from the array in sorted order. Parameters: arr (list of int): The input unsorted integer array. x (int): The number of smallest elements to find. Returns: list of int: The x smallest elements in sorted order. if not arr or x <= 0 or x > len(arr): raise ValueError(\\"Invalid input parameters\\") return sorted(arr)[:x]"},{"question":"from typing import List from itertools import permutations def generate_permutations(nums: List[int]) -> List[List[int]]: Generate all possible permutations of a given array of distinct integers. :param nums: A list of distinct integers :return: A list of all unique permutations of the array nums >>> generate_permutations([1]) [(1,)] >>> generate_permutations([1, 2]) [(1, 2), (2, 1)] >>> generate_permutations([1, 2, 3]) [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)] >>> generate_permutations([]) [()] >>> generate_permutations([-1, -2, -3]) [(-1, -2, -3), (-1, -3, -2), (-2, -1, -3), (-2, -3, -1), (-3, -1, -2), (-3, -2, -1)] return list(permutations(nums))","solution":"from itertools import permutations def generate_permutations(nums): Returns a list of all unique permutations of the array nums. :param nums: A list of distinct integers. :return: A list of lists, where each list is a unique permutation of nums. return list(permutations(nums))"},{"question":"def findClosestElements(arr, k, x): Write a function findClosestElements(arr, k, x) that takes a sorted integer array arr, two integers k and x, and returns the k closest integers to x from the array. The result should also be sorted in ascending order. An integer a is considered closer to x than an integer b if |a - x| < |b - x|, or |a - x| == |b - x| but a is smaller than b. >>> findClosestElements([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> findClosestElements([1, 2, 3, 4, 5], 4, -1) [1, 2, 3, 4] >>> findClosestElements([5, 6, 7, 8, 9], 3, 7) [6, 7, 8] >>> findClosestElements([2, 3, 5, 8], 3, 5) [2, 3, 5] >>> findClosestElements([1, 2, 3, 4, 5], 4, 4) [2, 3, 4, 5] >>> findClosestElements([1, 1, 1, 10, 10, 10], 2, 9) [10, 10] >>> findClosestElements([1], 1, 1) [1] >>> findClosestElements([1], 1, 5) [1] >>> findClosestElements([2], 1, 1) [2] >>> findClosestElements([], 1, 1) [] >>> findClosestElements([1, 2, 3], 5, 2) [1, 2, 3] >>> findClosestElements([1, 2, 3, 4, 1000, 2000], 3, 1500) [4, 1000, 2000]","solution":"def findClosestElements(arr, k, x): Returns the k closest integers to x from the sorted array arr. # Sort the array with the custom comparator: first by absolute difference with x, then by natural order sorted_arr = sorted(arr, key=lambda num: (abs(num - x), num)) # Pick the first k elements and sort them before returning result = sorted(sorted_arr[:k]) return result"},{"question":"def shift_string(word: str, shifts: List[int]) -> str: Shifts each character in the word by the corresponding value in shifts array. :param word: A string consisting of lowercase English letters. :param shifts: A list of integers where each integer indicates how many positions to shift the corresponding character in word. :return: The shifted string. >>> shift_string(\\"abc\\", [1, 2, 3]) 'bdf' >>> shift_string(\\"a\\", [1]) 'b' >>> shift_string(\\"z\\", [1]) 'a' >>> shift_string(\\"m\\", [13]) 'z' >>> shift_string(\\"zzz\\", [1, 2, 3]) 'abc' >>> shift_string(\\"abc\\", [25, 25, 25]) 'zab' >>> shift_string(\\"abc\\", [1, 1, 1]) 'bcd' >>> shift_string(\\"xyz\\", [2, 2, 2]) 'zab' >>> shift_string(\\"abc\\", [26, 52, 78]) 'abc' >>> shift_string(\\"abc\\", [27, 53, 79]) 'bcd' >>> shift_string(\\"abc\\", [0, 0, 0]) 'abc'","solution":"def shift_string(word, shifts): Shifts each character in the word by the corresponding value in shifts array. :param word: A string consisting of lowercase English letters. :param shifts: A list of integers where each integer indicates how many positions to shift the corresponding character in word. :return: The shifted string. shifted_word = [] for i, char in enumerate(word): new_char = chr(((ord(char) - ord('a') + shifts[i]) % 26) + ord('a')) shifted_word.append(new_char) return ''.join(shifted_word)"},{"question":"def min_jumps(arr: list[int], k: int) -> int: Determines the minimum number of jumps needed for the rabbit to clear the field. Returns -1 if it's not possible within the given maximum jump height. Parameters: arr (List[int]): List of obstacle heights in the field. k (int): Maximum jump height of the rabbit. Returns: int: Minimum number of jumps or -1 if not possible. >>> min_jumps([3, 4, 3, 2, 5], 5) 5 >>> min_jumps([1, 1, 1, 1], 1) 4 >>> min_jumps([3, 4, 6, 2, 5], 3) -1 >>> min_jumps([], 3) 0 >>> min_jumps([10], 10) 1 >>> min_jumps([1], 1) 1 >>> min_jumps([3, 3, 3], 3) 3 >>> min_jumps([3, 7, 2, 3], 5) -1 >>> min_jumps([2, 3, 1, 4], 4) 4 >>> min_jumps([6, 1, 4], 7) 3","solution":"def min_jumps(arr, k): Determines the minimum number of jumps needed for the rabbit to clear the field. Returns -1 if it's not possible within the given maximum jump height. Parameters: arr (List[int]): List of obstacle heights in the field. k (int): Maximum jump height of the rabbit. Returns: int: Minimum number of jumps or -1 if not possible. jumps = 0 for height in arr: if height > k: return -1 jumps += 1 return jumps"},{"question":"def min_difference(nums): Returns the minimum possible difference in total time spent by the two workers. >>> min_difference([10]) == 10 >>> min_difference([10, 10]) == 0 >>> min_difference([1, 2, 3, 4, 5]) == 1 >>> min_difference([100, 200, 300, 400, 500]) == 100 >>> min_difference([]) == 0","solution":"def min_difference(nums): Returns the minimum possible difference in total time spent by the two workers. total_sum = sum(nums) n = len(nums) target = total_sum // 2 dp = [0] * (target + 1) for num in nums: for j in range(target, num - 1, -1): dp[j] = max(dp[j], dp[j - num] + num) return abs(total_sum - 2 * dp[target])"},{"question":"def count_connected_components(graph): This function returns the number of connected components in the graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are nodes and values are lists of adjacent nodes. Returns: int: The number of connected components in the graph. pass def test_single_component(): graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3] } assert count_connected_components(graph) == 2 def test_multiple_disconnected_components(): graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [], 4: [5], 5: [4] } assert count_connected_components(graph) == 3 def test_no_edges(): graph = { 0: [], 1: [], 2: [], 3: [], 4: [] } assert count_connected_components(graph) == 5 def test_fully_connected_graph(): graph = { 0: [1, 2, 3, 4], 1: [0, 2, 3, 4], 2: [0, 1, 3, 4], 3: [0, 1, 2, 4], 4: [0, 1, 2, 3] } assert count_connected_components(graph) == 1 def test_mixed_edges(): graph = { 0: [1], 1: [0], 2: [3], 3: [2], 4: [5], 5: [4] } assert count_connected_components(graph) == 3","solution":"def count_connected_components(graph): This function returns the number of connected components in the graph. Parameters: graph (dict): An adjacency list representation of the graph where keys are nodes and values are lists of adjacent nodes. Returns: int: The number of connected components in the graph. visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(graph.get(current, [])) components = 0 for node in graph: if node not in visited: dfs(node) components += 1 return components"},{"question":"def highest_peak(heights): Calculate the highest peak in the grid such that every cell is reachable from at least one border cell. >>> highest_peak([[5]]) 5 >>> highest_peak([[3, 3], [3, 3]]) 3 >>> highest_peak([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) 9 >>> highest_peak([ ... [9, 8, 7], ... [6, 5, 4], ... [3, 2, 1]]) 9 >>> highest_peak([ ... [1, 3, 2], ... [4, 6, 5], ... [7, 9, 8]]) 9 >>> highest_peak([ ... [1, 1, 1], ... [1, 10, 1], ... [1, 1, 1]]) 10 pass","solution":"def highest_peak(heights): from collections import deque m, n = len(heights), len(heights[0]) queue = deque() visited = [[False] * n for _ in range(m)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue with all border cells for i in range(m): for j in range(n): if i == 0 or i == m - 1 or j == 0 or j == n - 1: queue.append((i, j)) visited[i][j] = True # Process the queue and perform BFS to find the highest peak while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: heights[nx][ny] = max(heights[nx][ny], heights[x][y]) visited[nx][ny] = True queue.append((nx, ny)) return max(max(row) for row in heights)"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Returns the values of nodes in a binary tree using level-order traversal (breadth-first traversal). :param root: TreeNode, the root of the binary tree :return: List[List[int]], list of lists where each list contains the values of nodes at the same level >>> level_order_traversal(TreeNode(1)) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> level_order_traversal(root) [[1], [2, 3]] >>> level_order_traversal(None) []","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Returns the values of nodes in a binary tree using level-order traversal. :param root: TreeNode, the root of the binary tree :return: List[List[int]], list of lists where each list contains the values of nodes at the same level if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.popleft() level_nodes.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Check whether the binary tree is symmetric around its center. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is symmetric, False otherwise def isMirror(t1, t2): Check whether two trees are mirror images. :param t1: TreeNode, the root of the first subtree :param t2: TreeNode, the root of the second subtree :return: bool, True if the subtrees are mirror images, False otherwise pass def test_symmetric_tree(): root = TreeNode(1) root.left = TreeNode(2, TreeNode(3), TreeNode(4)) root.right = TreeNode(2, TreeNode(4), TreeNode(3)) assert isSymmetric(root) == True def test_asymmetric_tree(): root = TreeNode(1) root.left = TreeNode(2, None, TreeNode(3)) root.right = TreeNode(2, None, TreeNode(3)) assert isSymmetric(root) == False def test_single_node_tree(): root = TreeNode(1) assert isSymmetric(root) == True def test_empty_tree(): root = None assert isSymmetric(root) == True def test_symmetric_tree_with_null_subtrees(): root = TreeNode(1) root.left = TreeNode(2, TreeNode(3), None) root.right = TreeNode(2, None, TreeNode(3)) assert isSymmetric(root) == True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Check whether the binary tree is symmetric around its center. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is symmetric, False otherwise def isMirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.left, t2.right) and isMirror(t1.right, t2.left) return isMirror(root, root)"},{"question":"def max_good_subsequence_length(nums: List[int], k: int) -> int: You have a sequence of integers given in the form of an array nums of length n. A subsequence of this array is considered to be a good subsequence if the sum of the numbers in the subsequence is divisible by a given integer k. Return the maximum length of a good subsequence that can be constructed from nums. If no such subsequence exists, return 0. >>> max_good_subsequence_length([2, 4, 6, 8], 2) 4 >>> max_good_subsequence_length([1, 3, 5], 7) 0 >>> max_good_subsequence_length([1, 2, 3, 4, 5], 5) 5 >>> max_good_subsequence_length([5], 5) 1 >>> max_good_subsequence_length([3], 5) 0 >>> max_good_subsequence_length([], 1) 0","solution":"def max_good_subsequence_length(nums, k): from itertools import combinations def is_good_subsequence(subsequence): return sum(subsequence) % k == 0 max_length = 0 n = len(nums) for length in range(1, n + 1): for subseq in combinations(nums, length): if is_good_subsequence(subseq): max_length = max(max_length, length) return max_length"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the zigzag level order traversal of its nodes' values. >>> values = [3, 9, 20, None, None, 15, 7] >>> root = build_tree(values) >>> zigzag_level_order(root) [[3], [20, 9], [15, 7]] >>> values = [] >>> root = build_tree(values) >>> zigzag_level_order(root) [] >>> values = [1] >>> root = build_tree(values) >>> zigzag_level_order(root) [[1]] >>> values = [1, 2, 3, 4, 5, 6, 7] >>> root = build_tree(values) >>> zigzag_level_order(root) [[1], [3, 2], [4, 5, 6, 7]] >>> values = [1, 2, 3, None, None, 4, 5] >>> root = build_tree(values) >>> zigzag_level_order(root) [[1], [3, 2], [4, 5]] def build_tree(values: List[Optional[int]]) -> Optional[TreeNode]: Helper function to build a tree from a list of values.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzag_level_order(root): if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_len = len(current_level) level_vals = deque() for _ in range(level_len): node = current_level.popleft() if left_to_right: level_vals.append(node.val) else: level_vals.appendleft(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) result.append(list(level_vals)) left_to_right = not left_to_right return result # Helper function to build a tree from a list of values def build_tree(values): if not values: return None root = TreeNode(values[0]) queue = deque([root]) index = 1 while index < len(values): current = queue.popleft() if values[index] is not None: current.left = TreeNode(values[index]) queue.append(current.left) index += 1 if index < len(values) and values[index] is not None: current.right = TreeNode(values[index]) queue.append(current.right) index += 1 return root"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Find the length of the shortest path from the top-left cell to the bottom-right cell, avoiding obstacles. Return -1 if no valid path exists. >>> shortest_path([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 5 >>> shortest_path([ [0, 1, 0], [0, 1, 0], [0, 0, 0] ]) 5 >>> shortest_path([ [0, 1, 0], [0, 1, 0], [0, 1, 0] ]) -1 >>> shortest_path([ [1, 0, 0], [0, 0, 0], [0, 0, 0] ]) -1 >>> shortest_path([ [0, 0, 0], [0, 0, 0], [0, 0, 1] ]) -1 >>> shortest_path([ [0] ]) 1 >>> shortest_path([]) -1","solution":"from collections import deque def shortest_path(grid): Find the shortest path from the top-left to the bottom-right of the grid, avoiding obstacles. If no path exists, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # down, up, right, left queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dir in directions: nx, ny = x + dir[0], y + dir[1] if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_length_subarray_with_sum_k(nums, k): Returns the maximum length of a subarray with sum equal to k. Args: nums: A list of integers. k: An integer sum. Returns: An integer representing the maximum length of a subarray with sum equal to k. Example: >>> max_length_subarray_with_sum_k([1, -1, 5, -2, 3], 3) 4 >>> max_length_subarray_with_sum_k([-2, -1, 2, 1], 1) 2 from solution import max_length_subarray_with_sum_k def test_example_1(): nums = [1, -1, 5, -2, 3] k = 3 assert max_length_subarray_with_sum_k(nums, k) == 4 def test_example_2(): nums = [-2, -1, 2, 1] k = 1 assert max_length_subarray_with_sum_k(nums, k) == 2 def test_no_subarray(): nums = [1, 2, 3, 4, 5] k = 100 assert max_length_subarray_with_sum_k(nums, k) == 0 def test_single_element_equals_k(): nums = [10] k = 10 assert max_length_subarray_with_sum_k(nums, k) == 1 def test_all_elements_sum_to_k(): nums = [1, 1, 1, 1, 1, 1] k = 6 assert max_length_subarray_with_sum_k(nums, k) == 6 def test_long_array(): nums = [1]*100000 k = 99999 assert max_length_subarray_with_sum_k(nums, k) == 99999 def test_contains_negative_numbers(): nums = [1, 2, -1, 2, 1] k = 4 assert max_length_subarray_with_sum_k(nums, k) == 4 def test_single_element_not_equals_k(): nums = [5] k = 1 assert max_length_subarray_with_sum_k(nums, k) == 0","solution":"def max_length_subarray_with_sum_k(nums, k): Returns the maximum length of a subarray with sum equal to k. sum_dict = {} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == k: max_length = i + 1 if current_sum - k in sum_dict: max_length = max(max_length, i - sum_dict[current_sum - k]) if current_sum not in sum_dict: sum_dict[current_sum] = i return max_length"},{"question":"def can_obtain_goal_by_rotation(s: str, goal: str) -> bool: Determines if the string goal can be obtained by rotating string s any number of times. >>> can_obtain_goal_by_rotation(\\"abcde\\", \\"abcde\\") True >>> can_obtain_goal_by_rotation(\\"abcde\\", \\"cdeab\\") True >>> can_obtain_goal_by_rotation(\\"abcde\\", \\"eabcd\\") True >>> can_obtain_goal_by_rotation(\\"abcd\\", \\"abcde\\") False >>> can_obtain_goal_by_rotation(\\"abcde\\", \\"abced\\") False >>> can_obtain_goal_by_rotation(\\"abcde\\", \\"ababc\\") False >>> can_obtain_goal_by_rotation(\\"\\", \\"\\") True >>> can_obtain_goal_by_rotation(\\"a\\", \\"a\\") True >>> can_obtain_goal_by_rotation(\\"a\\", \\"b\\") False","solution":"def can_obtain_goal_by_rotation(s, goal): Determines if the string goal can be obtained by rotating string s any number of times. Parameters: s (str): The original string. goal (str): The target string to check against. Returns: bool: True if goal can be obtained by rotating s any number of times, false otherwise. if len(s) != len(goal): return False return goal in (s + s)"},{"question":"from typing import List, Tuple, Dict def max_revenue_order(projects: List[int], dependencies: List[Tuple[int, int]], revenues: Dict[int, int]) -> List[int]: Determine the order of project completion to maximize revenue while respecting dependencies. Args: projects (List[int]): List of project identifiers. dependencies (List[Tuple[int, int]]): List of dependencies as tuples (a, b), where project \`b\` must be completed after project \`a\`. revenues (Dict[int, int]): Dictionary mapping project identifiers to their revenue values. Returns: List[int]: A valid order of project completion that maximizes revenue, or an empty list if impossible due to cyclical dependencies. Example: >>> projects = [1, 2, 3, 4] >>> dependencies = [] >>> revenues = {1: 10, 2: 20, 3: 30, 4: 40} >>> max_revenue_order(projects, dependencies, revenues) [1, 2, 3, 4] >>> projects = [1, 2, 3] >>> dependencies = [[1, 2], [2, 3]] >>> revenues = {1: 10, 2: 20, 3: 30} >>> max_revenue_order(projects, dependencies, revenues) [1, 2, 3]","solution":"def max_revenue_order(projects, dependencies, revenues): from collections import defaultdict, deque # Create graph and calculate in-degrees graph = {project: [] for project in projects} in_degree = {project: 0 for project in projects} for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Topological sort using Kahn's Algorithm queue = deque([project for project in projects if in_degree[project] == 0]) sorted_projects = [] while queue: project = queue.popleft() sorted_projects.append(project) for neighbor in graph[project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If all projects are not included in the topological sort, there's a cycle if len(sorted_projects) != len(projects): return [] # Calculating the total revenue in the order of sorted_projects total_revenue = sum(revenues[project] for project in sorted_projects) return sorted_projects"},{"question":"def longest_increasing_subsequence(heights: List[int]) -> int: Returns the length of the longest increasing subsequence of tree heights. :param heights: List[int] - List of tree heights. :return: int - Length of the longest increasing subsequence. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10, 20, 10, 30, 20, 50]) 4","solution":"def longest_increasing_subsequence(heights): Returns the length of the longest increasing subsequence of tree heights. :param heights: List[int] - List of tree heights. :return: int - Length of the longest increasing subsequence. if not heights: return 0 # Initialize an array to store the length of the LIS ending at each index lis = [1] * len(heights) # Compute the LIS values in a bottom up manner for i in range(1, len(heights)): for j in range(i): if heights[i] > heights[j]: lis[i] = max(lis[i], lis[j] + 1) # The longest increasing subsequence will be the maximum value in lis[] return max(lis)"},{"question":"def path_exists(matrix): Determines if there exists a path from the top-left corner to the bottom-right one that only moves either down or right and moves to cells with greater or equal height. >>> path_exists([ [1, 2, 3], [2, 3, 4], [3, 4, 5] ]) True >>> path_exists([ [5, 4, 3], [4, 3, 2], [3, 2, 1] ]) False >>> path_exists([ [1] ]) True >>> path_exists([ [1, 2] ]) True >>> path_exists([ [2, 1] ]) False >>> path_exists([ [1], [2] ]) True >>> path_exists([ [2], [1] ]) False >>> path_exists([ [1, 2, 1, 1], [1, 5, 1, 1], [1, 1, 6, 1], [1, 1, 1, 7] ]) True pass","solution":"def path_exists(matrix): Determines if there exists a path from the top-left corner to the bottom-right one that only moves either down or right and moves to cells with greater or equal height. if not matrix or not matrix[0]: return False def dfs(x, y): if x == len(matrix) - 1 and y == len(matrix[0]) - 1: return True if (x + 1 < len(matrix) and matrix[x + 1][y] >= matrix[x][y] and dfs(x + 1, y)): return True if (y + 1 < len(matrix[0]) and matrix[x][y + 1] >= matrix[x][y] and dfs(x, y + 1)): return True return False return dfs(0, 0)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Finds the lowest common ancestor (LCA) of two given nodes in a BST. >>> root = TreeNode(6) >>> root.left = TreeNode(2) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(7) >>> root.right.right = TreeNode(9) >>> root.left.right.left = TreeNode(3) >>> root.left.right.right = TreeNode(5) >>> p = TreeNode(2) >>> q = TreeNode(4) >>> result = lowestCommonAncestor(root, p, q) >>> result.val 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Finds the lowest common ancestor (LCA) of two given nodes in a BST. current = root while current: if p.val < current.val and q.val < current.val: current = current.left elif p.val > current.val and q.val > current.val: current = current.right else: return current"},{"question":"def can_rearrange_to_specify_diff(arr: List[int], k: int) -> bool: Determines if the array can be rearranged such that the difference between the maximum and minimum element in every contiguous subarray of size \`k\` is the same. Args: arr (list of int): The input array of integers. k (int): The size of the subarray. Returns: bool: True if such a rearrangement is possible, False otherwise. >>> can_rearrange_to_specify_diff([4, 3, 2, 1], 2) True >>> can_rearrange_to_specify_diff([1, 5, 9, 14], 2) False >>> can_rearrange_to_specify_diff([7, 7, 7, 7], 3) True","solution":"def can_rearrange_to_specify_diff(arr, k): Determines if the array can be rearranged such that the difference between the maximum and minimum element in every contiguous subarray of size \`k\` is the same. Args: arr (list of int): The input array of integers. k (int): The size of the subarray. Returns: bool: True if such a rearrangement is possible, False otherwise. if k > len(arr): return False sorted_arr = sorted(arr) diff_set = set() for i in range(len(sorted_arr) - k + 1): diff = sorted_arr[i + k - 1] - sorted_arr[i] diff_set.add(diff) if len(diff_set) > 1: return False return True"},{"question":"def checkPossibility(nums: List[int]) -> bool: Returns True if it is possible to make the array non-decreasing with at most one modification, otherwise returns False. >>> checkPossibility([4, 2, 3]) True >>> checkPossibility([3, 4, 2, 3]) False","solution":"def checkPossibility(nums): Returns True if it is possible to make the array non-decreasing with at most one modification, otherwise returns False. n = len(nums) count = 0 for i in range(1, n): if nums[i] < nums[i - 1]: if count == 1: return False count += 1 if i == 1 or nums[i - 2] <= nums[i]: nums[i - 1] = nums[i] else: nums[i] = nums[i - 1] return True"},{"question":"def matrixBlockSum(mat: List[List[int]], k: int) -> List[List[int]]: Calculate the block sum matrix for the given matrix 'mat' with an integer 'k'. Args: mat (List[List[int]]): A 2D list of integers representing the input matrix. k (int): An integer defining the radius of the block sum. Returns: List[List[int]]: The resulting block sum matrix. Example: >>> matrixBlockSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1) [[12, 21, 16], [27, 45, 33], [24, 39, 28]] >>> matrixBlockSum([[5]], 0) [[5]]","solution":"def matrixBlockSum(mat, k): m, n = len(mat), len(mat[0]) # Step 1: Create prefix sum matrix prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for r in range(m): for c in range(n): prefix_sum[r + 1][c + 1] = mat[r][c] + prefix_sum[r + 1][c] + prefix_sum[r][c + 1] - prefix_sum[r][c] result = [[0] * n for _ in range(m)] # Step 2: Calculate the block sum using the prefix sum matrix for r in range(m): for c in range(n): r1 = max(0, r - k) r2 = min(m - 1, r + k) c1 = max(0, c - k) c2 = min(n - 1, c + k) result[r][c] = prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r2 + 1][c1] - prefix_sum[r1][c2 + 1] + prefix_sum[r1][c1] return result"},{"question":"def remove_duplicate_letters(s: str) -> str: Given a string that contains only lowercase letters, remove duplicate letters so that every letter appears only once. You must make sure your result is the smallest in lexicographical order among all possible results. Return the resulting string. >>> remove_duplicate_letters(\\"bcabc\\") 'abc' >>> remove_duplicate_letters(\\"cbacdcbc\\") 'acdb'","solution":"def remove_duplicate_letters(s): Remove duplicate letters and return the smallest in lexicographical order among all possible results. stack = [] seen = set() last_occurrence = {char: idx for idx, char in enumerate(s)} for idx, char in enumerate(s): if char not in seen: while stack and char < stack[-1] and idx < last_occurrence[stack[-1]]: seen.discard(stack.pop()) seen.add(char) stack.append(char) return ''.join(stack)"},{"question":"def single_number(nums: List[int]) -> int: Given a non-empty list of integers \`nums\` where every element appears twice except for one, finds that single one. Args: nums (list of int): List of integers containing exactly one element that appears once and all others appear exactly twice. Returns: int: The single integer that appears only once in the list. >>> single_number([2, 2, 3, 4, 4]) == 3 >>> single_number([1, 1, 2]) == 2 >>> single_number([-1, -1, 2]) == 2 >>> single_number([4, 1, 2, 1, 2]) == 4 >>> single_number([42]) == 42 >>> single_number([1000000, 9999999, 9999999, 1000000, 1234567, 1234567, 10001000]) == 10001000","solution":"def single_number(nums): Given a non-empty list of integers \`nums\` where every element appears twice except for one, finds that single one. Args: nums (list of int): List of integers containing exactly one element that appears once and all others appear exactly twice. Returns: int: The single integer that appears only once in the list. unique = 0 for num in nums: unique ^= num return unique"},{"question":"from collections import deque from typing import List def min_steps_to_treasure(grid: List[List[int]]) -> int: Returns the minimum number of steps required to reach the treasure (2) from the top-left corner (0,0). If it is not possible to reach the treasure, return -1. >>> min_steps_to_treasure([ >>> [1, 0, 0], >>> [1, 1, 0], >>> [1, 1, 2] >>> ]) == 4 >>> min_steps_to_treasure([ >>> [1, 0, 0], >>> [0, 1, 0], >>> [0, 0, 2] >>> ]) == -1 >>> min_steps_to_treasure([ >>> [1, 1, 1], >>> [1, 1, 1], >>> [1, 1, 2] >>> ]) == 4 >>> min_steps_to_treasure([ >>> [0, 0, 0], >>> [0, 0, 0], >>> [0, 0, 0] >>> ]) == -1 >>> min_steps_to_treasure([ >>> [2, 1, 0], >>> [1, 1, 0], >>> [1, 1, 0] >>> ]) == 0 >>> min_steps_to_treasure([ >>> [1, 0, 0], >>> [1, 0, 0], >>> [1, 0, 2] >>> ]) == -1","solution":"from collections import deque def min_steps_to_treasure(grid): Returns the minimum number of steps required to reach the treasure (2) from the top-left corner (0,0). If it is not possible to reach the treasure, return -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) if grid[0][0] == 0: return -1 while queue: x, y, steps = queue.popleft() if grid[x][y] == 2: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != 0: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"class WordDictionary: Implement a class, \`WordDictionary\`, that supports adding words and searching for words with wildcard characters. Methods: - addWord(word): Adds a word into the data structure. - search(word): Returns true if there is any string in the data structure that matches \`word\` or false otherwise. A word could contain the wildcard character \`'.'\` to represent any one letter. def __init__(self): Initialize the data structure. pass def addWord(self, word: str) -> None: Adds a word into the data structure. Args: word (str): The word to add. pass def search(self, word: str) -> bool: Returns True if there is any string in the data structure that matches \`word\` or False otherwise. A word could contain the wildcard character \`'.'\` to represent any one letter. Args: word (str): The word to search. Returns: bool: True if the word is found, False otherwise. pass def test_add_and_search_exact(): wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") wd.addWord(\\"mad\\") assert wd.search(\\"pad\\") == False assert wd.search(\\"bad\\") == True assert wd.search(\\"dad\\") == True assert wd.search(\\"mad\\") == True def test_search_with_wildcard(): wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") wd.addWord(\\"mad\\") assert wd.search(\\".ad\\") == True assert wd.search(\\"b..\\") == True assert wd.search(\\"..d\\") == True assert wd.search(\\"m..\\") == True assert wd.search(\\"..z\\") == False def test_search_only_wildcards(): wd = WordDictionary() wd.addWord(\\"a\\") wd.addWord(\\"ab\\") wd.addWord(\\"abc\\") assert wd.search(\\".\\") == True assert wd.search(\\"..\\") == True assert wd.search(\\"...\\") == True assert wd.search(\\"....\\") == False def test_empty_search(): wd = WordDictionary() assert wd.search(\\"\\") == False wd.addWord(\\"\\") assert wd.search(\\"\\") == True","solution":"class WordDictionary: def __init__(self): self.words = [] def addWord(self, word): Adds a word into the data structure. self.words.append(word) def search(self, word): Returns True if there is any string in the data structure that matches \`word\` or False otherwise. A word could contain the wildcard character \`'.'\` to represent any one letter. from re import match pattern = \\"^\\" + word + \\"\\" for w in self.words: if match(pattern, w): return True return False"},{"question":"def maximum_gap(nums: List[int]) -> int: Given an unsorted integer array nums, find the maximum difference between the successive elements in its sorted form. If the array contains less than two elements, return 0. You must write an algorithm that runs in linear time and uses linear space. >>> maximum_gap([3, 6, 9, 1]) == 3 >>> maximum_gap([10, 5, 1, 7]) == 4 >>> maximum_gap([1, 2, 3, 4, 5]) == 1 >>> maximum_gap([5, 6, 7, 8, 9]) == 1 >>> maximum_gap([1, 1, 1, 1]) == 0 >>> maximum_gap([5, 5, 5]) == 0 >>> maximum_gap([1]) == 0 >>> maximum_gap([]) == 0 >>> maximum_gap([1, 1000000]) == 999999 >>> maximum_gap([0, 100, 10, 1000, 10000, 100000]) == 90000","solution":"def maximum_gap(nums): Finds the maximum difference between the successive elements in the sorted form of the array nums. :param nums: List of integers :return: Maximum difference between successive elements in sorted form if len(nums) < 2: return 0 min_val, max_val = min(nums), max(nums) if min_val == max_val: return 0 bucket_size = (max_val - min_val) // (len(nums) - 1) or 1 bucket_count = (max_val - min_val) // bucket_size + 1 buckets = [[None, None] for _ in range(bucket_count)] for num in nums: idx = (num - min_val) // bucket_size if buckets[idx][0] is None: buckets[idx][0] = buckets[idx][1] = num else: buckets[idx][0] = min(buckets[idx][0], num) buckets[idx][1] = max(buckets[idx][1], num) max_gap = 0 prev_max = min_val for bucket_min, bucket_max in buckets: if bucket_min is not None: max_gap = max(max_gap, bucket_min - prev_max) prev_max = bucket_max return max_gap"},{"question":"def max_profit(prices: List[int], k: int) -> int: Returns the maximum profit that can be achieved with at most k transactions. Parameters: prices (list): list of integers representing the prices of the stock on different days. k (int): the maximum number of transactions allowed. Returns: int: the maximum profit that can be achieved. >>> max_profit([], 2) 0 >>> max_profit([5], 2) 0 >>> max_profit([3, 2, 6, 5, 0, 3], 1) 4 >>> max_profit([3, 2, 6, 5, 0, 3], 2) 7 >>> max_profit([7, 1, 5, 3, 6, 4], 3) 7 >>> max_profit([7, 1, 5, 3, 6, 4], 10) 7 >>> max_profit([7, 6, 4, 3, 1], 2) 0 >>> max_profit([1, 2, 3, 4, 5, 6], 2) 5","solution":"def max_profit(prices, k): Returns the maximum profit that can be achieved with at most k transactions. Parameters: prices (list): list of integers representing the prices of the stock on different days. k (int): the maximum number of transactions allowed. Returns: int: the maximum profit that can be achieved. n = len(prices) if n == 0 or k == 0: return 0 if k >= n // 2: return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1)) profits = [[0] * n for _ in range(k+1)] for t in range(1, k+1): max_diff = -prices[0] for d in range(1, n): profits[t][d] = max(profits[t][d-1], prices[d] + max_diff) max_diff = max(max_diff, profits[t-1][d] - prices[d]) return profits[k][n-1]"},{"question":"from typing import List def maxProfitAssignment(difficulty: List[int], profit: List[int], worker: List[int]) -> int: You are given an integer array difficulty and an integer array profit, where difficulty[i] and profit[i] are the difficulty and profit of the i-th job, respectively. Return the maximum profit you can achieve by assigning the optimal job to each worker. >>> maxProfitAssignment([2, 4, 6, 8, 10], [10, 20, 30, 40, 50], [4, 5, 6, 7]) 100 >>> maxProfitAssignment([2, 4, 6, 8, 10], [10, 20, 30, 40, 50], [1, 1, 1]) 0 >>> maxProfitAssignment([2], [10], [2]) 10 >>> maxProfitAssignment([2, 2, 2, 2, 2], [10, 20, 30, 40, 50], [2, 2, 2]) 150 >>> maxProfitAssignment([1, 2, 3, 4], [10, 20, 30, 40], [5, 5, 5]) 120","solution":"def maxProfitAssignment(difficulty, profit, worker): jobs = sorted(zip(difficulty, profit)) worker.sort() max_profit = i = best = 0 for ability in worker: while i < len(jobs) and ability >= jobs[i][0]: best = max(best, jobs[i][1]) i += 1 max_profit += best return max_profit"},{"question":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray with the largest sum. :param nums: List of integers :return: Integer, the largest sum of contiguous subarray >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1,2,3,4,5]) 15 >>> max_subarray_sum([5,4,-1,7,8]) 23 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5]) 18 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray with the largest sum. :param nums: List of integers :return: Integer, the largest sum of contiguous subarray # Handling edge case if the input list is empty if not nums: return 0 # Initialize current sum and max sum to the first element of the array current_sum = max_sum = nums[0] # Iterate through the list starting from the second element for num in nums[1:]: # Update current sum by including the current number or starting a new subarray current_sum = max(num, current_sum + num) # Update max sum if current sum is greater max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def has_cycle(graph) -> bool: Detect if the graph contains a cycle. >>> has_cycle({0: [1], 1: [0, 2], 2: [1, 3], 3: [2]}) False >>> has_cycle({0: [1, 2], 1: [0, 2], 2: [0, 1]}) True >>> has_cycle({0: [1], 1: [0, 2], 2: [1, 3], 3: [2], 4: [5], 5: [4, 6], 6: [5, 7], 7: [6, 4]}) True >>> has_cycle({0: [1], 1: [0, 2], 2: [1, 3], 3: [2], 4: [5], 5: [4, 6], 6: [5, 7], 7: [6]}) False >>> has_cycle({0: [0]}) True","solution":"def has_cycle(graph): Detect if the graph contains a cycle. :param graph: dict, representing the adjacency list of the graph :return: bool, True if there is a cycle, False otherwise def dfs(node, parent, visited): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node, visited): return True elif neighbor != parent: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, None, visited): return True return False"},{"question":"from typing import List def len_longest_fib_subseq(nums: List[int]) -> int: Given a list of integers, returns the length of the longest subsequence that is a valid Fibonacci sequence. A sequence is valid if n >= 3 and xi + xi+1 = xi+2 for all i + 2 <= n. If no such subsequence exists, return 0. >>> len_longest_fib_subseq([1]) 0 >>> len_longest_fib_subseq([1, 3, 5, 7]) 0 >>> len_longest_fib_subseq([1, 2, 3]) 3 >>> len_longest_fib_subseq([1, 2, 3, 4, 5, 6, 7, 8]) 5 >>> len_longest_fib_subseq([1, 3, 7, 11, 12, 14, 18]) 3 >>> len_longest_fib_subseq([1, 2, 3, 5, 8, 13, 21, 34]) 8 >>> len_longest_fib_subseq([]) 0 >>> len_longest_fib_subseq([1, 2]) 0 pass","solution":"def len_longest_fib_subseq(nums): Returns the length of the longest subsequence that is a valid Fibonacci sequence. If no such subsequence exists, return 0. num_index = {num: i for i, num in enumerate(nums)} longest = {} max_len = 0 for k, z in enumerate(nums): for j in range(k): i = num_index.get(z - nums[j]) if i is not None and i < j: if (i, j) in longest: longest[(j, k)] = longest[(i, j)] + 1 else: longest[(j, k)] = 3 max_len = max(max_len, longest[(j, k)]) return max_len if max_len >= 3 else 0"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node where the cycle begins in a linked list. :param ListNode head: Head node of the linked list :return: The node where the cycle begins. If no cycle, return None def test_no_cycle(): head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) assert detectCycle(head) is None def test_cycle_at_head(): head = ListNode(1) second = ListNode(2) third = ListNode(3) head.next = second second.next = third third.next = head assert detectCycle(head) == head def test_cycle_in_middle(): head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) fifth = ListNode(5) head.next = second second.next = third third.next = fourth fourth.next = fifth fifth.next = third assert detectCycle(head) == third def test_single_node_no_cycle(): head = ListNode(1) assert detectCycle(head) is None def test_single_node_with_cycle(): head = ListNode(1) head.next = head assert detectCycle(head) == head","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def detectCycle(head): Detects the node where the cycle begins in a linked list. :param ListNode head: Head node of the linked list :return: The node where the cycle begins. If no cycle, return None if not head or not head.next: return None # Using Floyd's Tortoise and Hare algorithm to detect cycle slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None # Find the starting node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def all_unique_in_sliding_window(nums: List[int], k: int) -> bool: Return True if all the numbers in the array within each sliding window of length \`k\` are unique. >>> all_unique_in_sliding_window([1], 1) == True >>> all_unique_in_sliding_window([1, 2, 3], 3) == True >>> all_unique_in_sliding_window([1, 2, 3, 1], 2) == True >>> all_unique_in_sliding_window([1, 2, 3, 1], 3) == True >>> all_unique_in_sliding_window([1, 2, 3, 1], 4) == False >>> all_unique_in_sliding_window([-1, -2, -3, 1], 2) == True >>> all_unique_in_sliding_window([-1, -1, -2, -3], 2) == False >>> all_unique_in_sliding_window([1, 2, 1, 3, 4], 3) == False >>> all_unique_in_sliding_window([1, 2, 3, 4, 5], 3) == True >>> all_unique_in_sliding_window([1, 2, 3], 4) == False","solution":"def all_unique_in_sliding_window(nums, k): Returns True if all numbers in each sliding window of length k are unique. if k > len(nums): return False # If k is larger than the length of the array, return false because we can't form a window. num_set = set() for i in range(len(nums)): if i >= k: num_set.remove(nums[i - k]) # Remove the element that is sliding out of the window. if nums[i] in num_set: return False # If we encounter a duplicate, return False. num_set.add(nums[i]) # Add the current number to the set. return True"},{"question":"def longest_uniform_substring(s: str, k: int) -> int: Return the length of the longest uniform substring after performing at most k operations. Each operation allows changing any character of the string to another lowercase alphabet. Args: s (str): The input string comprised of lowercase alphabets. k (int): The maximum number of operations allowed to perform. Returns: int: The length of the longest uniform substring. Example: >>> longest_uniform_substring(\\"aaabbccc\\", 0) 3 >>> longest_uniform_substring(\\"aaabbccc\\", 1) 4 >>> longest_uniform_substring(\\"aaabbccc\\", 2) 5 from solution import longest_uniform_substring def test_example_cases(): assert longest_uniform_substring(\\"aaabbccc\\", 0) == 3 # from \\"aaa\\" or \\"ccc\\" assert longest_uniform_substring(\\"aaabbccc\\", 1) == 4 # change \\"b\\" to \\"a\\" or \\"c\\" -> \\"aaaa\\" or \\"cccc\\" assert longest_uniform_substring(\\"aaabbccc\\", 2) == 5 # change \\"bb\\" to \\"a\\" or \\"c\\" -> \\"aaaaa\\" or \\"ccccc\\" def test_empty_string(): assert longest_uniform_substring(\\"\\", 1) == 0 def test_no_operations(): assert longest_uniform_substring(\\"abc\\", 0) == 1 assert longest_uniform_substring(\\"aaa\\", 0) == 3 def test_complete_change(): assert longest_uniform_substring(\\"abc\\", 2) == 3 # change \\"bc\\" to \\"a\\" -> \\"aaa\\" def test_variable_k(): assert longest_uniform_substring(\\"abcde\\", 1) == 2 # \\"aa\\" or similar assert longest_uniform_substring(\\"abcde\\", 4) == 5 # change all but one to be the same character def test_large_string(): assert longest_uniform_substring(\\"a\\" * 100000, 0) == 100000 assert longest_uniform_substring(\\"a\\" * 50000 + \\"b\\" * 50000, 50000) == 100000 # change all \\"b\\" to \\"a\\" def test_multiple_operations(): assert longest_uniform_substring(\\"abcab\\", 2) == 4 # change last \\"b\\" to \\"a\\" and \\"c\\" to \\"a\\" -> \\"aaaab\\" assert longest_uniform_substring(\\"aabbcc\\", 3) == 5 # change \\"bbcc\\" to \\"a\\" -> \\"aaaaaa\\"","solution":"def longest_uniform_substring(s, k): def helper(ch): left, max_length, max_count = 0, 0, 0 for right in range(len(s)): if s[right] == ch: max_count += 1 while (right - left + 1) - max_count > k: if s[left] == ch: max_count -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length # considering each character as the one to be maximized in the uniform substring max_len = 0 for char in set(s): max_len = max(max_len, helper(char)) return max_len"},{"question":"def min_cost_path(matrix: List[List[int]]) -> int: Given a matrix n x m where each element represents the cost to pass through that cell, and you can only move right or down from the top-left corner to the bottom-right corner, find the minimum cost path. Return the minimum cost to reach the bottom-right corner of the matrix from the top-left corner. >>> min_cost_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_cost_path([ ... [1, 2], ... [1, 1] ... ]) == 3 >>> min_cost_path([ ... [5] ... ]) == 5 >>> min_cost_path([ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 12 >>> min_cost_path([]) == 0 >>> min_cost_path([ ... [1, 2, 3, 4] ... ]) == 10 >>> min_cost_path([ ... [1], ... [2], ... [3], ... [4] ... ]) == 10","solution":"def min_cost_path(matrix): Returns the minimum cost to reach the bottom-right corner of the matrix from the top-left corner. Parameters: matrix (list of list of int): The cost matrix. Returns: int: The minimum cost. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) # Create a 2D list to store the cost of the minimum cost path to each cell dp = [[0 for _ in range(m)] for _ in range(n)] dp[0][0] = matrix[0][0] # Initialize the first column of the dp array for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Initialize the first row of the dp array for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1]"},{"question":"def minAddToMakeValid(s: str) -> int: Returns the minimum number of parentheses to add to make the string valid. >>> minAddToMakeValid(\\"())\\") 1 >>> minAddToMakeValid(\\"(((\\") 3 >>> minAddToMakeValid(\\"\\") 0 >>> minAddToMakeValid(\\"()\\") 0 >>> minAddToMakeValid(\\"(())\\") 0 >>> minAddToMakeValid(\\"(((((\\") 5 >>> minAddToMakeValid(\\"(()\\") 1 >>> minAddToMakeValid(\\")))))\\") 5 >>> minAddToMakeValid(\\"())\\") 1 >>> minAddToMakeValid(\\"()()())(\\") 2 >>> minAddToMakeValid(\\")()((())(\\") 3","solution":"def minAddToMakeValid(s: str) -> int: Returns the minimum number of parentheses to add to make the string valid. left_balance = 0 right_balance = 0 for char in s: if char == '(': left_balance += 1 elif char == ')': if left_balance > 0: left_balance -= 1 else: right_balance += 1 return left_balance + right_balance"},{"question":"def find_single_number(arr: List[int]) -> int: Given an array of integers where every integer appears twice except for one, find the integer that appears only once. >>> find_single_number([2, 2, 3, 4, 4]) == 3 >>> find_single_number([1, 1, 2]) == 2 >>> find_single_number([-1, -1, -2, -3, -3]) == -2 >>> find_single_number([-5, -4, -4, -5, -6]) == -6 >>> find_single_number([1, -1, 2, 1, -1]) == 2 >>> find_single_number([-3, 3, 3, 4, 4]) == -3 >>> find_single_number([10]) == 10 >>> find_single_number([0, 1, 1, 2, 2]) == 0","solution":"def find_single_number(arr): Given an array of integers where every integer appears twice except for one, find the integer that appears only once. single_number = 0 for num in arr: single_number ^= num return single_number"},{"question":"def is_mountain(arr: List[int]) -> bool: Returns True if the array is mountain-shaped, otherwise returns False. >>> is_mountain([0, 3, 2, 1]) True >>> is_mountain([2, 1, 2]) False >>> is_mountain([0, 2, 2, 1]) False >>> is_mountain([0, 1, 2, 3, 4]) False >>> is_mountain([5, 4, 3, 2, 1]) False >>> is_mountain([1, 2]) False >>> is_mountain([3, 2, 1]) False >>> is_mountain([1, 2, 3]) False >>> is_mountain([1, 3, 2, 4, 1]) False >>> is_mountain([1, 2, 3, 4, 3, 2, 1]) True","solution":"def is_mountain(arr): Returns True if the array is mountain-shaped, otherwise returns False. n = len(arr) if n < 3: return False i = 0 # climb up while i + 1 < n and arr[i] < arr[i + 1]: i += 1 # peak can't be first or last if i == 0 or i == n - 1: return False # climb down while i + 1 < n and arr[i] > arr[i + 1]: i += 1 return i == n - 1"},{"question":"def max_subarray_score(arr, k): Calculate the maximum possible score by dividing the array into k contiguous subarrays. The score is the sum of the maximum values of each subarray. :param arr: List[int] - The array of integers :param k: int - The number of contiguous subarrays :return: int - The maximum possible score >>> max_subarray_score([1, 2, 3, 4, 5], 2) 9 >>> max_subarray_score([1, 2, 3], 4) -1 >>> max_subarray_score([5, 5, 5, 5], 4) 20 >>> max_subarray_score([3, 3, 3, 3], 2) 6 >>> max_subarray_score([10, 1, 2, 10, 3, 4, 10], 3) 30 >>> max_subarray_score([-5, -1, -3, -4, -2], 2) -3","solution":"def max_subarray_score(arr, k): Calculate the maximum possible score by dividing the array into k contiguous subarrays. The score is the sum of the maximum values of each subarray. :param arr: List[int] - The array of integers :param k: int - The number of contiguous subarrays :return: int - The maximum possible score n = len(arr) if k > n: return -1 # Impossible to divide into more subarrays than elements # dp[i][j] will be the maximum score using the first i elements and j subarrays dp = [[float('-inf')] * (k + 1) for _ in range(n + 1)] # Initialize dp for 0 subarrays for i in range(n + 1): dp[i][0] = 0 # Fill dp array for j in range(1, k + 1): for i in range(j, n + 1): local_max = float('-inf') for l in range(i, j - 1, -1): local_max = max(local_max, arr[l - 1]) dp[i][j] = max(dp[i][j], dp[l - 1][j - 1] + local_max) return dp[n][k]"},{"question":"def longest_substring_with_k_distinct_chars(s: str, k: int) -> int: Returns the length of the longest substring in \`s\` that contains at most \`k\` distinct characters. :param s: The input string consisting of lowercase English letters :param k: The maximum number of distinct characters allowed in the substring :return: The length of the longest substring with at most \`k\` distinct characters >>> longest_substring_with_k_distinct_chars(\\"eceba\\", 2) 3 >>> longest_substring_with_k_distinct_chars(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct_chars(\\"a\\", 1) 1 >>> longest_substring_with_k_distinct_chars(\\"a\\", 0) 0 >>> longest_substring_with_k_distinct_chars(\\"abc\\", 0) 0 >>> longest_substring_with_k_distinct_chars(\\"\\", 2) 0 >>> longest_substring_with_k_distinct_chars(\\"aabbcc\\", 1) 2 >>> longest_substring_with_k_distinct_chars(\\"aabbcc\\", 2) 4 >>> longest_substring_with_k_distinct_chars(\\"aabbcc\\", 3) 6 >>> longest_substring_with_k_distinct_chars(\\"abaccc\\", 2) 4 >>> longest_substring_with_k_distinct_chars(\\"aaabbbccc\\", 1) 3 >>> longest_substring_with_k_distinct_chars(\\"aaabbbccc\\", 2) 6 >>> longest_substring_with_k_distinct_chars(\\"aaabbbccc\\", 3) 9","solution":"def longest_substring_with_k_distinct_chars(s, k): Returns the length of the longest substring in \`s\` that contains at most \`k\` distinct characters. :param s: The input string consisting of lowercase English letters :param k: The maximum number of distinct characters allowed in the substring :return: The length of the longest substring with at most \`k\` distinct characters if k == 0 or not s: return 0 left = 0 max_length = 0 char_frequency = {} for right in range(len(s)): char_frequency[s[right]] = char_frequency.get(s[right], 0) + 1 while len(char_frequency) > k: char_frequency[s[left]] -= 1 if char_frequency[s[left]] == 0: del char_frequency[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def countSubTrees(n, edges, labels): Count the number of nodes in the subtree rooted at the i-th node which have the same label as node i. >>> countSubTrees(7, [[0, 1], [0, 2], [1, 4], [1, 5], [2, 3], [2, 6]], \\"abaedcd\\") [2, 1, 1, 1, 1, 1, 1] >>> countSubTrees(1, [], \\"a\\") [1] >>> countSubTrees(2, [[0, 1]], \\"aa\\") [2, 1] >>> countSubTrees(2, [[0, 1]], \\"ab\\") [1, 1] >>> countSubTrees(6, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5]], \\"aaaaaa\\") [6, 3, 2, 1, 1, 1]","solution":"from collections import defaultdict, Counter def countSubTrees(n, edges, labels): def dfs(node, parent): count = Counter() for child in graph[node]: if child == parent: continue count.update(dfs(child, node)) count[labels[node]] += 1 result[node] = count[labels[node]] return count graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) result = [0] * n dfs(0, -1) return result"},{"question":"def four_sum(arr, k): Given an array of integers \`arr\` and an integer \`k\`, return all the unique quadruples \`[a, b, c, d]\` such that \`a + b + c + d = k\`. Each quadruple should be sorted in non-decreasing order and the result should be returned in sorted order based on the first element of each quadruple. >>> four_sum([1, 2, 3], 10) [] >>> four_sum([1, 2, 3, 4], 10) [(1, 2, 3, 4)] >>> four_sum([1, 0, -1, 0, -2, 2], 0) [(-2, -1, 1, 2), (-2, 0, 0, 2), (-1, 0, 0, 1)] >>> four_sum([1, 0, -1, 0, -2, 2, 2], 0) [(-2, -1, 1, 2), (-2, 0, 0, 2), (-1, 0, 0, 1)] >>> four_sum([1, 1, 1, 1], 10) []","solution":"def four_sum(arr, k): arr.sort() n = len(arr) quadruples = set() for i in range(n - 3): for j in range(i + 1, n - 2): left, right = j + 1, n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == k: quadruples.add((arr[i], arr[j], arr[left], arr[right])) left += 1 right -= 1 elif total < k: left += 1 else: right -= 1 return sorted(quadruples)"},{"question":"def shift_string(word: str, k: int) -> str: Shifts the characters in the word k times. >>> shift_string(\\"abc\\", 1) == \\"bcd\\" >>> shift_string(\\"xyz\\", 1) == \\"yza\\" >>> shift_string(\\"abc\\", 3) == \\"def\\" >>> shift_string(\\"xyz\\", 3) == \\"abc\\" pass def shift_strings(words: List[str], k: int) -> List[str]: Returns an array of strings where each string is shifted from 1 to k times. >>> shift_strings([\\"abc\\", \\"xyz\\"], 2) == [\\"bcd\\", \\"cde\\", \\"yza\\", \\"zab\\"] >>> shift_strings([\\"aaa\\", \\"zzz\\"], 1) == [\\"bbb\\", \\"aaa\\"] >>> shift_strings([\\"abc\\"], 3) == [\\"bcd\\", \\"cde\\", \\"def\\"] >>> shift_strings([], 2) == [] >>> shift_strings([\\"abc\\", \\"xyz\\"], 1) == [\\"bcd\\", \\"yza\\"] >>> shift_strings([\\"abc\\", \\"xyz\\"], 3) == [\\"bcd\\", \\"cde\\", \\"def\\", \\"yza\\", \\"zab\\", \\"abc\\"] pass","solution":"def shift_string(word, k): Shifts the characters in the word k times. shifted = [] for char in word: shifted.append(chr((ord(char) - ord('a') + k) % 26 + ord('a'))) return ''.join(shifted) def shift_strings(words, k): Returns an array of strings where each string is shifted from 1 to k times. result = [] for word in words: for shift in range(1, k + 1): result.append(shift_string(word, shift)) return result"},{"question":"def max_balanced_teams(skills, t, d): Determines the maximum number of balanced teams that can be formed. A team is balanced if the difference between the highest and lowest skill levels in the team does not exceed \`d\`. Parameters: skills (list of int): Array of employee skill levels. t (int): Required team size. d (int): Skill threshold for team to be balanced. Returns: int: Maximum number of balanced teams. pass # Unit tests def test_max_balanced_teams_basic(): assert max_balanced_teams([1, 2, 3, 4, 5], 2, 1) == 2 assert max_balanced_teams([1, 2, 3, 4, 5], 3, 2) == 1 assert max_balanced_teams([1, 4, 7, 10], 2, 3) == 2 def test_max_balanced_teams_no_teams(): assert max_balanced_teams([1, 2, 3, 4, 5], 3, 0) == 0 assert max_balanced_teams([1, 10, 20, 30], 2, 5) == 0 def test_max_balanced_teams_single_element(): assert max_balanced_teams([1], 1, 0) == 1 assert max_balanced_teams([1], 2, 0) == 0 def test_max_balanced_teams_multiple_balanced_teams(): assert max_balanced_teams([1, 2, 2, 3, 3], 2, 1) == 2 assert max_balanced_teams([1, 1, 1, 1, 1], 2, 0) == 2 def test_max_balanced_teams_large_range(): assert max_balanced_teams(list(range(100)), 10, 9) == 10 assert max_balanced_teams(list(range(100)), 20, 19) == 5 assert max_balanced_teams(list(range(100)), 25, 24) == 4 def test_max_balanced_teams_edge_cases(): assert max_balanced_teams([], 2, 1) == 0 assert max_balanced_teams([1, 2, 3, 4, 5], 0, 1) == 0 assert max_balanced_teams([1, 2, 3, 4, 5], 2, -1) == 0","solution":"def max_balanced_teams(skills, t, d): Determines the maximum number of balanced teams that can be formed. A team is balanced if the difference between the highest and lowest skill levels in the team does not exceed \`d\`. Parameters: skills (list of int): Array of employee skill levels. t (int): Required team size. d (int): Skill threshold for team to be balanced. Returns: int: Maximum number of balanced teams. if not skills or t == 0: return 0 skills.sort() n = len(skills) teams = 0 i = 0 while i <= n - t: j = i + t - 1 if skills[j] - skills[i] <= d: teams += 1 i += t else: i += 1 return teams"},{"question":"def buildings_with_view(heights): Returns an array containing the indices of the buildings that are not blocked. >>> buildings_with_view([1, 2, 3, 4, 5]) [4] >>> buildings_with_view([5, 4, 3, 2, 1]) [0, 1, 2, 3, 4] >>> buildings_with_view([3, 1, 4, 2, 6, 5]) [4, 5] >>> buildings_with_view([7]) [0] >>> buildings_with_view([2, 2, 2, 2]) [3] >>> buildings_with_view([]) [] >>> buildings_with_view([2, 3, 4, 1, 3, 2, 5, 7]) [7] >>> buildings_with_view([7, 5, 3, 1, 2, 4, 6]) [0, 6]","solution":"def buildings_with_view(heights): Returns the indices of the buildings that are not blocked. n = len(heights) if n == 0: return [] result = [] max_height_from_right = -1 for i in range(n-1, -1, -1): if heights[i] > max_height_from_right: result.append(i) max_height_from_right = heights[i] return result[::-1]"},{"question":"from typing import List def max_river_area(grid: List[List[int]]) -> int: Determine the maximum area of a river in the given grid. A river starts from any \\"1\\" cell and flows to its adjacent cells (horizontally or vertically) until it reaches an edge of the grid, another \\"1\\" cell, or a \\"2\\" cell. A river's area is defined as the number of \\"1\\" cells it flows through. :param grid: List[List[int]] - 2D list where each element can be 0 (empty), 1 (land), or 2 (obstacle). :return: int - Maximum area of the river. >>> max_river_area([[1, 0, 0, 0, 1], [1, 1, 0, 2, 0], [0, 1, 0, 1, 1], [1, 0, 0, 0, 1]]) 4 >>> max_river_area([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_river_area([[0, 1, 0], [0, 0, 0], [0, 0, 0]]) 1 >>> max_river_area([[2, 1, 2], [2, 1, 2], [2, 2, 2]]) 2 >>> max_river_area([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 1","solution":"def max_river_area(grid): Determine the maximum area of such a river in the given grid. :param grid: List[List[int]] - 2D list where each element can be 0, 1, or 2. :return: int - Maximum area of the river. def dfs(x, y): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 1: return 0 grid[x][y] = -1 # Mark as visited area = 1 # Current cell # Check all four possible directions area += dfs(x + 1, y) area += dfs(x - 1, y) area += dfs(x, y + 1) area += dfs(x, y - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_predecessor(root: TreeNode, target: TreeNode) -> TreeNode: Find the in-order predecessor of a given target node in a BST. Returns the in-order predecessor, or None if it doesn't exist. >>> # Construct the BST >>> root = TreeNode(20) >>> root.left = TreeNode(10) >>> root.right = TreeNode(30) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(15) >>> root.right.left = TreeNode(25) >>> root.right.right = TreeNode(35) >>> target = root.left.right # this is the node with value 15 >>> inorder_predecessor(root, target).val 10 >>> target = root.right.left # this is the node with value 25 >>> inorder_predecessor(root, target).val 20 >>> target = root.right # this is the node with value 30 >>> inorder_predecessor(root, target).val 25 >>> target = root # this is the node with value 20 >>> inorder_predecessor(root, target).val 15 >>> target = root.left.left # this is the node with value 5 >>> inorder_predecessor(root, target) is None True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_predecessor(root: TreeNode, target: TreeNode) -> TreeNode: predecessor = None current = root while current: if target.val > current.val: predecessor = current current = current.right else: current = current.left return predecessor"},{"question":"def splitArray(arr: List[int], m: int) -> int: Given an array \`arr\` of integers and an integer \`m\`, split the array into \`m\` contiguous subarrays, such that the largest sum among these subarrays is minimized. Return this minimized largest sum. >>> splitArray([5], 1) == 5 >>> splitArray([1, 2, 3, 4, 5], 1) == 15 >>> splitArray([1, 2, 3, 4, 5], 5) == 5 >>> splitArray([7, 2, 5, 10, 8], 2) == 18 >>> splitArray([1, 4, 4], 3) == 4","solution":"def splitArray(arr, m): def canSplit(mid): current_sum = 0 number_of_subarrays = 1 for number in arr: if current_sum + number > mid: number_of_subarrays += 1 current_sum = number if number_of_subarrays > m: return False else: current_sum += number return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left"},{"question":"def max_tasks(arr: List[int], k: int, totalTime: int) -> int: Determines the maximum number of tasks that can be completed within given total time. Args: arr : List[int] - list of integers where each element represents the time of a task. k : int - maximum number of tasks that can be performed consecutively before needing a break. totalTime : int - the limit of total time in which tasks can be performed. Returns: int : maximum number of tasks that can be completed. Example: >>> max_tasks([2, 1, 3, 2], 2, 5) 2 >>> max_tasks([2, 2, 2, 2], 2, 6) 2","solution":"def max_tasks(arr, k, totalTime): Determines the maximum number of tasks that can be completed within given total time. Args: arr : List[int] - list of integers where each element represents the time of a task. k : int - maximum number of tasks that can be performed consecutively before needing a break. totalTime : int - the limit of total time in which tasks can be performed. Returns: int : maximum number of tasks that can be completed. arr.sort() # Sort the tasks based on time required tasks_completed = 0 current_time_used = 0 for i in range(len(arr)): if tasks_completed < k and current_time_used + arr[i] <= totalTime: current_time_used += arr[i] tasks_completed += 1 else: break return tasks_completed"},{"question":"from typing import List, Tuple def find_clusters(events: List[Tuple[int, int]]) -> List[List[int]]: Return a list of isolated clusters in the network after processing all events. Each cluster is defined as a set of nodes that are directly or indirectly connected to each other but not connected to any other nodes in the network. Each cluster should be returned as a sorted list of node identifiers. The list of clusters should be sorted in increasing order of the smallest node identifier in each cluster. >>> find_clusters([(1, 2), (2, 3), (3, 4)]) [[1, 2, 3, 4]] >>> find_clusters([(1, 2), (3, 4), (5, 6), (2, 3)]) [[1, 2, 3, 4], [5, 6]] >>> find_clusters([(1, 2), (3, 4)]) [[1, 2], [3, 4]] >>> find_clusters([(1, 2), (2, 3), (1, 2)]) [[1, 2, 3]] >>> find_clusters([]) [] pass","solution":"def find_clusters(events): from collections import defaultdict, deque # Build adjacency list adj = defaultdict(list) for a, b in events: adj[a].append(b) adj[b].append(a) # because connections are bidirectional def bfs(node): # Perform BFS to find all nodes in the same cluster visited = set([node]) queue = deque([node]) cluster = [] while queue: current = queue.popleft() cluster.append(current) for neighbor in adj[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return visited, sorted(cluster) visited_nodes = set() clusters = [] # Find all clusters for node in adj.keys(): if node not in visited_nodes: visited, cluster = bfs(node) visited_nodes.update(visited) clusters.append(cluster) # Sort clusters by the smallest node in each cluster clusters.sort(key=lambda x: x[0]) return clusters"},{"question":"def min_moves_to_equalize_piles(nums: List[int]) -> int: Given a list of \`n\` integers \`nums\` representing the number of coins in \`n\` piles, return the minimum number of moves required to make all piles equal by either taking one coin from a pile or adding one coin to a pile at each move. >>> min_moves_to_equalize_piles([1, 2, 3]) == 2 >>> min_moves_to_equalize_piles([4, 4, 4]) == 0 >>> min_moves_to_equalize_piles([1, 10, 2]) == 9 >>> min_moves_to_equalize_piles([5, 8]) == 3 >>> min_moves_to_equalize_piles([7]) == 0 >>> min_moves_to_equalize_piles([1, 2, 3, 4]) == 4 >>> min_moves_to_equalize_piles([6, 2, 2, 8]) == 10","solution":"def min_moves_to_equalize_piles(nums): Returns the minimum number of moves required to make all piles equal by either taking one coin from a pile or adding one coin to a pile at each move. # Find the median value; this minimizes the total moves required nums.sort() median = nums[len(nums) // 2] # Sum the absolute differences between each pile and the median min_moves = sum(abs(num - median) for num in nums) return min_moves"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorderTraversal(root: TreeNode) -> List[int]: Given the root of a binary tree, return the inorder traversal of its nodes' values. Uses an iterative approach that simulates the process using a stack. >>> inorderTraversal(None) [] >>> root = TreeNode(1) >>> inorderTraversal(root) [1] >>> root = TreeNode(1, TreeNode(2)) >>> inorderTraversal(root) [2, 1] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> inorderTraversal(root) [2, 1, 3] >>> root = TreeNode(1, None, TreeNode(3, TreeNode(2))) >>> inorderTraversal(root) [1, 2, 3] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> inorderTraversal(root) [4, 2, 5, 1, 6, 3, 7]","solution":"def inorderTraversal(root): Returns the inorder traversal of a binary tree's nodes' values. Uses an iterative approach with a stack. :param root: TreeNode :return: List[int] res, stack = [], [] current = root while current or stack: while current: stack.append(current) current = current.left current = stack.pop() res.append(current.val) current = current.right return res"},{"question":"def max_candles_to_light(candles: List[int]) -> int: Determine the maximum number of candles you can light until at least one candle height in the array becomes zero. Args: candles (list): A list of integers representing candle heights. Returns: int: The maximum number of candles you can light. >>> max_candles_to_light([3]) 3 >>> max_candles_to_light([2, 2, 2]) 2 >>> max_candles_to_light([4, 1, 3]) 1 >>> max_candles_to_light([3, 5, 2, 4, 4]) 2 >>> max_candles_to_light([100, 200, 300, 400]) 100 >>> max_candles_to_light([]) 0","solution":"def max_candles_to_light(candles): Determine the maximum number of candles you can light until at least one candle height in the array becomes zero. Args: candles (list): A list of integers representing candle heights. Returns: int: The maximum number of candles you can light. if not candles: return 0 min_height = min(candles) # The maximum number of candles that can be lit is the initial minimum height of any candle. return min_height"},{"question":"def max_coast_hugging_subarray(nums: List[int]) -> int: Given an integer array nums, return the maximum sum of a non-empty coast-hugging subarray of nums. A coast-hugging subarray is defined as a contiguous subarray that touches either the first or the last element of the array. >>> max_coast_hugging_subarray([5, -2, 3, -4, 1]) == 6 >>> max_coast_hugging_subarray([-5, 2, -1, -4, 6]) == 6 pass from solution import max_coast_hugging_subarray def test_single_element(): assert max_coast_hugging_subarray([1]) == 1 assert max_coast_hugging_subarray([-1]) == -1 def test_all_positive_numbers(): assert max_coast_hugging_subarray([1, 2, 3, 4, 5]) == 15 def test_all_negative_numbers(): assert max_coast_hugging_subarray([-1, -2, -3, -4, -5]) == -1 def test_mixed_numbers(): assert max_coast_hugging_subarray([3, -2, 5, -1, 2]) == 7 assert max_coast_hugging_subarray([-3, 2, -1, 4, -2, 3]) == 6 def test_touching_start_elements(): assert max_coast_hugging_subarray([5, -2, 3, -4, 1]) == 6 def test_touching_end_elements(): assert max_coast_hugging_subarray([-5, 2, -1, -4, 6]) == 6 def test_full_array(): assert max_coast_hugging_subarray([-1, 2, 3, -1, 2, -1, 2, 1, -5, 4, 6]) == 13","solution":"def max_coast_hugging_subarray(nums): n = len(nums) if n == 1: return nums[0] # Calculate maximum subarray sum touching the first element max_sum_from_start = float('-inf') current_sum = 0 for i in range(n): current_sum += nums[i] max_sum_from_start = max(max_sum_from_start, current_sum) # Calculate maximum subarray sum touching the last element max_sum_from_end = float('-inf') current_sum = 0 for i in range(n-1, -1, -1): current_sum += nums[i] max_sum_from_end = max(max_sum_from_end, current_sum) return max(max_sum_from_start, max_sum_from_end)"},{"question":"def smallest_island(grid: List[List[int]]) -> int: Given a binary matrix 'grid' where '0' represents water and '1' represents land, find and return the size of the smallest island in the grid. If there is no land, return 0. >>> smallest_island([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> smallest_island([ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 1 >>> smallest_island([ ... [1, 0, 1, 1], ... [0, 0, 0, 0], ... [1, 1, 0, 0] ... ]) 1 >>> smallest_island([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) 12 >>> smallest_island([ ... [1, 0, 0, 1, 1], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 1, 0] ... ]) 1 >>> smallest_island([ ... [1, 1, 0, 0], ... [1, 0, 0, 0], ... [1, 0, 0, 0], ... [0, 0, 0, 1] ... ]) 1","solution":"def smallest_island(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1) min_island_size = float('inf') found_island = False for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: found_island = True island_size = dfs(i, j) if island_size < min_island_size: min_island_size = island_size return min_island_size if found_island else 0"},{"question":"def length_of_shortest_word(s: str) -> int: Returns the length of the shortest word in the given sentence. :param s: A string representing a sentence containing words separated by spaces. :return: An integer representing the length of the shortest word in the sentence. >>> length_of_shortest_word(\\"Hello\\") == 5 >>> length_of_shortest_word(\\"The quick brown fox\\") == 3 >>> length_of_shortest_word(\\"Jumped over the Lazy DOG\\") == 3 >>> length_of_shortest_word(\\"\\") == 0 >>> length_of_shortest_word(\\" The quick brown fox \\") == 3 >>> length_of_shortest_word(\\"why are you all same\\") == 3","solution":"def length_of_shortest_word(s): Returns the length of the shortest word in the given sentence. :param s: A string representing a sentence containing words separated by spaces. :return: An integer representing the length of the shortest word in the sentence. words = s.split() if not words: return 0 return min(len(word) for word in words)"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Returns an array such that answer[i] is equal to the product of all the elements of nums except nums[i]. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([0, 4, 0]) [0, 0, 0] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([10]) [1] >>> product_except_self([1, 2]) [2, 1] >>> product_except_self([1, 2, 3, 0]) [0, 0, 0, 6] >>> product_except_self([0, 0, 0]) [0, 0, 0]","solution":"def product_except_self(nums): Returns an array such that answer[i] is equal to the product of all the elements of nums except nums[i]. length = len(nums) answer = [1] * length # Calculate left product for each element left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Calculate right product for each element and multiply with the corresponding left product right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"from itertools import permutations from typing import List def num_topological_sorts(n: int, edges: List[List[int]]) -> int: Returns the number of possible topological sorts for a given DAG. Parameters: n (int): Number of nodes in the DAG. edges (list): List of directed edges represented as pairs [u, v]. Returns: int: Number of possible topological sorts. >>> num_topological_sorts(3, []) 6 >>> num_topological_sorts(2, [[0, 1]]) 1 >>> num_topological_sorts(3, [[0, 1], [1, 2]]) 1 >>> num_topological_sorts(4, [[0, 1], [0, 2], [1, 3], [2, 3]]) 2 >>> num_topological_sorts(2, [[0, 1], [1, 0]]) 0","solution":"from itertools import permutations def num_topological_sorts(n, edges): Returns the number of possible topological sorts for a given DAG. Parameters: n (int): Number of nodes in the DAG. edges (list): List of directed edges represented as pairs [u, v]. Returns: int: Number of possible topological sorts. def is_topological(permutation, edges): index = {node: i for i, node in enumerate(permutation)} for u, v in edges: if index[u] > index[v]: return False return True nodes = [i for i in range(n)] count = 0 for perm in permutations(nodes): if is_topological(perm, edges): count += 1 return count"},{"question":"def two_sum(arr, t): Returns the indices of the two numbers in the array \`arr\` such that they add up to \`t\`. Parameters: arr (list): A list of integers. t (int): The target sum. Returns: list: A list containing the indices of the two numbers. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, 1, -2], -1) [1, 2] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([0, 4, 3, -3], 0) [2, 3] >>> two_sum([1, 2, 3, 2147483647, -2147483648], -1) [3, 4] >>> try: ... two_sum([1, 2, 3], 6) ... except ValueError as e: ... assert str(e) == \\"No two sum solution\\" pass","solution":"def two_sum(arr, t): Returns the indices of the two numbers in the array \`arr\` such that they add up to \`t\`. Parameters: arr (list): A list of integers. t (int): The target sum. Returns: list: A list containing the indices of the two numbers. num_map = {} # To store number and its index for index, num in enumerate(arr): complement = t - num if complement in num_map: return [num_map[complement], index] num_map[num] = index # Raise an exception if there is no solution raise ValueError(\\"No two sum solution\\")"},{"question":"from typing import List class CaveSystem: A class to represent a cave system composed of n nodes with tunnels connecting the nodes. Attributes ---------- n : int Number of nodes in the cave system connections : List[List[int]] List of tuples representing tunnels between nodes Methods ------- def __init__(self, n: int, connections: List[List[int]]) -> None: Initializes the cave system with \`n\` nodes and the specified list of connections. def hasPath(self, start: int, end: int) -> bool: Checks if there is a path from node \`start\` to node \`end\`. Returns \`True\` if a path exists, otherwise returns \`False\`. def shortestPath(self, start: int, end: int) -> List[int]: Returns the shortest path from node \`start\` to node \`end\` as a list of node indices. If there is no path, returns an empty list. def addConnection(self, a: int, b: int) -> None: Adds a new tunnel connecting nodes \`a\` and \`b\`. def __init__(self, n: int, connections: List[List[int]]) -> None: # Initialize the cave system with n nodes and the list of connections def hasPath(self, start: int, end: int) -> bool: Check if there is a path from node \`start\` to node \`end\`. Parameters: start (int): Starting node end (int): Ending node Returns: bool: True if a path exists, False otherwise pass def shortestPath(self, start: int, end: int) -> List[int]: Get the shortest path from node \`start\` to node \`end\`. Parameters: start (int): Starting node end (int): Ending node Returns: List[int]: Shortest path as a list of node indices, empty list if no path pass def addConnection(self, a: int, b: int) -> None: Add a new connection between nodes \`a\` and \`b\`. Parameters: a (int): First node b (int): Second node pass import pytest def test_hasPath_direct_connection(): cs = CaveSystem(3, [[0, 1], [1, 2]]) assert cs.hasPath(0, 2) == True def test_hasPath_no_connection(): cs = CaveSystem(3, [[0, 1]]) assert cs.hasPath(0, 2) == False def test_hasPath_self(): cs = CaveSystem(3, [[0, 1], [1, 2]]) assert cs.hasPath(1, 1) == True def test_shortestPath_direct_connection(): cs = CaveSystem(3, [[0, 1], [1, 2]]) assert cs.shortestPath(0, 2) == [0, 1, 2] def test_shortestPath_no_path(): cs = CaveSystem(3, [[0, 1]]) assert cs.shortestPath(0, 2) == [] def test_shortestPath_multiple_paths(): cs = CaveSystem(5, [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3], [3, 4]]) assert cs.shortestPath(0, 4) == [0, 1, 3, 4] or cs.shortestPath(0, 4) == [0, 2, 3, 4] def test_addConnection(): cs = CaveSystem(3, [[0, 1]]) cs.addConnection(1, 2) assert cs.hasPath(0, 2) == True assert cs.shortestPath(0, 2) == [0, 1, 2] if __name__ == \\"__main__\\": pytest.main()","solution":"from collections import deque, defaultdict class CaveSystem: def __init__(self, n, connections): self.n = n self.graph = defaultdict(list) for a, b in connections: self.graph[a].append(b) self.graph[b].append(a) def hasPath(self, start, end): if start == end: return True visited = set() queue = deque([start]) while queue: node = queue.popleft() if node == end: return True for neighbor in self.graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return False def shortestPath(self, start, end): if start == end: return [start] visited = set() queue = deque([(start, [start])]) while queue: node, path = queue.popleft() for neighbor in self.graph[node]: if neighbor == end: return path + [end] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] def addConnection(self, a, b): self.graph[a].append(b) self.graph[b].append(a)"},{"question":"def longest_non_decreasing_subarray(temps): Returns the length of the longest contiguous subarray where the temperature readings are non-decreasing. >>> longest_non_decreasing_subarray([5]) 1 >>> longest_non_decreasing_subarray([1, 2, 3, 4, 5]) 5 >>> longest_non_decreasing_subarray([5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_subarray([1, 3, 2, 3, 4, 1, 2, 2, 3]) 4 >>> longest_non_decreasing_subarray([0, 0, 0, 0, 0]) 5 >>> longest_non_decreasing_subarray([-1, -1, 0, 1, 2, -1, 0]) 5 >>> longest_non_decreasing_subarray([]) 0 pass","solution":"def longest_non_decreasing_subarray(temps): Returns the length of the longest contiguous subarray where the temperature readings are non-decreasing. if not temps: return 0 max_length = 1 current_length = 1 for i in range(1, len(temps)): if temps[i] >= temps[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root: TreeNode) -> int: Return the number of 'good' nodes in the binary tree. A node X in the binary tree is named 'good' if in the path from the root to X there are no nodes with a value greater than X's value. >>> root = TreeNode(3, TreeNode(1), TreeNode(4)) >>> good_nodes(root) 2 >>> root = TreeNode(3) >>> root.left = TreeNode(3) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(5) >>> good_nodes(root) 5 >>> root = TreeNode(3, TreeNode(1), TreeNode(1)) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(2) >>> root.right.right = TreeNode(0) >>> good_nodes(root) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def good_nodes(root: TreeNode) -> int: def dfs(node, max_val): if not node: return 0 good = 1 if node.val >= max_val else 0 max_val = max(max_val, node.val) good += dfs(node.left, max_val) good += dfs(node.right, max_val) return good return dfs(root, float('-inf'))"},{"question":"def min_operations(inbox: List[int]) -> int: Return the minimum number of operations required to process all emails in the \`inbox\`. >>> min_operations([1, 0, 4, 0, 3]) 3 >>> min_operations([0, 0, 0, 0]) 0 >>> min_operations([1, 2, 3, 4, 5]) 5 >>> min_operations([0, 5, 0, 6, 8, 3]) 4 >>> min_operations([0]) 0 >>> min_operations([7]) 1","solution":"def min_operations(inbox): operations = 0 n = len(inbox) # Count non-zero days for i in range(n): if inbox[i] > 0: operations += 1 return operations"},{"question":"def rotate(nums, k): Rotates the array \`nums\` to the right by \`k\` steps in-place. Parameters: nums (List[int]): The input array of integers. k (int): The number of steps to rotate the array. Returns: None pass def reverse(nums, start, end): Reverses the elements of nums from index \`start\` to \`end\` in-place. Parameters: nums (List[int]): The input array of integers. start (int): The starting index for the reverse operation. end (int): The ending index for the reverse operation. Returns: None pass # Test cases def test_rotate_example_case(): nums = [1, 2, 3, 4, 5, 6, 7] rotate(nums, 3) assert nums == [5, 6, 7, 1, 2, 3, 4] def test_rotate_zero_steps(): nums = [1, 2, 3, 4, 5, 6, 7] rotate(nums, 0) assert nums == [1, 2, 3, 4, 5, 6, 7] def test_rotate_full_cycle(): nums = [1, 2, 3, 4, 5, 6, 7] rotate(nums, 7) assert nums == [1, 2, 3, 4, 5, 6, 7] def test_rotate_more_than_length(): nums = [1, 2, 3, 4, 5, 6, 7] rotate(nums, 10) assert nums == [5, 6, 7, 1, 2, 3, 4] def test_rotate_single_element(): nums = [1] rotate(nums, 5) assert nums == [1] def test_reverse_function(): nums = [1, 2, 3, 4, 5] reverse(nums, 0, 4) assert nums == [5, 4, 3, 2, 1]","solution":"def rotate(nums, k): Rotates the array \`nums\` to the right by \`k\` steps in-place. Parameters: nums (List[int]): The input array of integers. k (int): The number of steps to rotate the array. Returns: None n = len(nums) k %= n reverse(nums, 0, n - 1) reverse(nums, 0, k - 1) reverse(nums, k, n - 1) def reverse(nums, start, end): Reverses the elements of nums from index \`start\` to \`end\` in-place. Parameters: nums (List[int]): The input array of integers. start (int): The starting index for the reverse operation. end (int): The ending index for the reverse operation. Returns: None while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1"},{"question":"from typing import List def minimum_moves(grid: List[List[int]]) -> int: Returns the minimum number of moves to reach the bottom-right cell from the top-left cell, or -1 if not possible. >>> minimum_moves([[0, 1, 2],[1, 2, 3],[2, 3, 4]]) 4 >>> minimum_moves([[0, 1, 10],[1, 2, 10],[10, 10, 10]]) -1 >>> minimum_moves([[0]]) 0 >>> minimum_moves([[0, 5, 10],[0, 5, 10],[0, 5, 0]]) -1 >>> minimum_moves([[0, 0],[1, 1]]) 2","solution":"from collections import deque def minimum_moves(grid): Returns the minimum number of moves to reach the bottom-right cell from the top-left cell, or -1 if not possible. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (x, y, moves) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() if x == m - 1 and y == n - 1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: if grid[nx][ny] <= grid[x][y] + 1: queue.append((nx, ny, moves + 1)) visited.add((nx, ny)) return -1"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths for a robot to reach the bottom-right corner of a grid avoiding obstacles. The robot can only move either down or right. :param grid: List[List[int]] 2D array where 1 represents obstacles and 0 represents free space. :return: int Number of unique paths from top-left to bottom-right avoiding obstacles. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) == 1 >>> unique_paths_with_obstacles([[1]]) == 0 >>> unique_paths_with_obstacles([[0, 0], [0, 1]]) == 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 1], [0, 1, 0]]) == 0 >>> unique_paths_with_obstacles([[0, 0], [0, 0]]) == 2 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6 >>> unique_paths_with_obstacles([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> unique_paths_with_obstacles([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) == 0 >>> unique_paths_with_obstacles([[0] * 100 for _ in range(100)]) == 22750883079422934966181954039568885395604168260154104734000 >>> unique_paths_with_obstacles([[0, 0, 0, 0]]) == 1 >>> unique_paths_with_obstacles([[0], [0], [0], [0]]) == 1 >>> unique_paths_with_obstacles([[0, 1, 0, 0]]) == 0 >>> unique_paths_with_obstacles([[0], [1], [0], [0]]) == 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths for a robot to reach the bottom-right corner of a grid avoiding obstacles. The robot can only move either down or right. :param grid: List[List[int]] 2D array where 1 represents obstacles and 0 represents free space. :return: int Number of unique paths from top-left to bottom-right avoiding obstacles. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = 1 # Fill the first row for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j - 1] else: dp[0][j] = 0 # Fill the first column for i in range(1, m): if grid[i][0] == 0: dp[i][0] = dp[i - 1][0] else: dp[i][0] = 0 # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i - 1][j] + dp[i][j - 1] else: dp[i][j] = 0 return dp[-1][-1]"},{"question":"def minimized_max_length(s: str, k: int) -> int: Returns the minimized maximum length of the \`k\` parts that the string \`s\` can be partitioned into. If it's not possible to split the string into \`k\` parts, return \`-1\`. >>> minimized_max_length(\\"abcde\\", 1) == 5 >>> minimized_max_length(\\"abcde\\", 2) == 3 >>> minimized_max_length(\\"abcdefgh\\", 4) == 2 >>> minimized_max_length(\\"aabbcc\\", 3) == 2 >>> minimized_max_length(\\"a\\", 2) == -1 >>> minimized_max_length(\\"abc\\", 4) == -1 >>> minimized_max_length(\\"a\\" * 10000, 5) == 2000 >>> minimized_max_length(\\"a\\" * 10000, 10000) == 1 >>> minimized_max_length(\\"\\", 1) == -1 >>> minimized_max_length(\\"a\\", 1) == 1 >>> minimized_max_length(\\"a\\" * 100, 1) == 100 >>> minimized_max_length(\\"abcdefgh\\", 8) == 1","solution":"def minimized_max_length(s, k): Returns the minimized maximum length of the \`k\` parts that the string \`s\` can be partitioned into. If it's not possible to split the string into \`k\` parts, return \`-1\`. n = len(s) if k > n: return -1 def can_partition(max_len): partitions = 0 current_len = 0 for char in s: if current_len + 1 > max_len: partitions += 1 current_len = 1 if partitions >= k: return False else: current_len += 1 # If we haven't added the last partition return partitions + 1 <= k left, right = 1, n while left < right: mid = (left + right) // 2 if can_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"from typing import List from collections import defaultdict def max_subtree_sum(n: int, edges: List[List[int]], values: List[int]) -> int: Find the maximum sum of values in the subtree of any node in the tree. >>> max_subtree_sum(1, [], [5]) 5 >>> max_subtree_sum(2, [[0, 1]], [2, 3]) 5 >>> max_subtree_sum(3, [[0, 1], [0, 2]], [1, 2, 3]) 6 >>> max_subtree_sum(5, [[0, 1], [0, 2], [1, 3], [1, 4]], [3, -2, 5, 1, -1]) 6 >>> max_subtree_sum(7, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]], [1, 2, 3, 4, 5, 6, 7]) 28 >>> max_subtree_sum(4, [[0, 1], [1, 2], [1, 3]], [0, 0, 0, 0]) 0","solution":"def max_subtree_sum(n, edges, values): from collections import defaultdict # Create adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): curr_sum = values[node] for neighbor in tree[node]: if neighbor != parent: curr_sum += dfs(neighbor, node) max_subtree_sum[0] = max(max_subtree_sum[0], curr_sum) return curr_sum max_subtree_sum = [float('-inf')] dfs(0, -1) # Starting DFS from node 0, with no parent (-1) return max_subtree_sum[0]"},{"question":"class BTree: def __init__(self, nums): Initializes the tree with elements from the array nums. The tree should remain balanced after the initialization. >>> btree = BTree([3, 1, 2]) >>> btree.inorderTraversal() [1, 2, 3] pass def insert(self, val): Inserts a new element val into the BST and keeps the tree balanced. >>> btree = BTree([1, 3]) >>> btree.insert(2) >>> btree.inorderTraversal() [1, 2, 3] pass def search(self, val): Searches for the element val in the BST. Returns True if the element is found, otherwise returns False. >>> btree = BTree([1, 2, 3]) >>> btree.search(2) True >>> btree.search(5) False pass def delete(self, val): Deletes the element val from the BST. If the element does not exist, do nothing. The tree should remain balanced after the deletion. >>> btree = BTree([1, 2, 3]) >>> btree.delete(2) >>> btree.inorderTraversal() [1, 3] pass def inorderTraversal(self): Returns the elements of the BST in sorted order through an inorder traversal. >>> btree = BTree([10, 20, 30, 40, 50]) >>> btree.inorderTraversal() [10, 20, 30, 40, 50] >>> btree.insert(35) >>> btree.inorderTraversal() [10, 20, 30, 35, 40, 50] >>> btree.delete(40) >>> btree.inorderTraversal() [10, 20, 30, 35, 50] >>> btree.search(35) True >>> btree.search(40) False pass","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BTree: def __init__(self, nums): self.root = None self.sorted_nums = sorted(nums) self.root = self._sorted_array_to_bst(self.sorted_nums, 0, len(self.sorted_nums) - 1) def _sorted_array_to_bst(self, nums, start, end): if start > end: return None mid = (start + end) // 2 node = TreeNode(nums[mid]) node.left = self._sorted_array_to_bst(nums, start, mid-1) node.right = self._sorted_array_to_bst(nums, mid+1, end) return node def insert(self, val): self.sorted_nums.append(val) self.sorted_nums.sort() self.root = self._sorted_array_to_bst(self.sorted_nums, 0, len(self.sorted_nums) - 1) def search(self, val): def _search_recursive(node, val): if node is None: return False if val == node.val: return True elif val < node.val: return _search_recursive(node.left, val) else: return _search_recursive(node.right, val) return _search_recursive(self.root, val) def delete(self, val): if val not in self.sorted_nums: return self.sorted_nums.remove(val) self.root = self._sorted_array_to_bst(self.sorted_nums, 0, len(self.sorted_nums) - 1) def inorderTraversal(self): result = [] def _inorder_traversal(node): if node: _inorder_traversal(node.left) result.append(node.val) _inorder_traversal(node.right) _inorder_traversal(self.root) return result"},{"question":"from typing import List def maxSlidingWindow(nums: List[int], k: int) -> List[int]: Returns a list of the maximum values in each sliding window of size k. :param nums: List of integers representing the array :param k: Integer representing the size of the sliding window :return: List of integers representing the maximum values in each window >>> maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3) [3, 3, 5, 5, 6, 7] >>> maxSlidingWindow([1, 2, 3, 4], 1) [1, 2, 3, 4] >>> maxSlidingWindow([4, 1, 2, 3], 4) [4] >>> maxSlidingWindow([6, 5, 4, 3, 2, 1], 3) [6, 5, 4, 3] >>> maxSlidingWindow([1, 2, 3, 4, 5, 6], 4) [4, 5, 6] >>> maxSlidingWindow([2, 2, 2, 2, 2], 2) [2, 2, 2, 2] >>> maxSlidingWindow([], 3) [] >>> maxSlidingWindow([1, 2], 3) [] >>> maxSlidingWindow([1, 2, 3], 0) [] >>> maxSlidingWindow(list(range(100000)), 1000) list(range(999, 100000))","solution":"from collections import deque from typing import List def maxSlidingWindow(nums: List[int], k: int) -> List[int]: Returns a list of the maximum values in each sliding window of size k. :param nums: List of integers representing the array :param k: Integer representing the size of the sliding window :return: List of integers representing the maximum values in each window if not nums or k == 0: return [] if k == 1: return nums deq = deque() result = [] for i in range(len(nums)): # Remove elements not within the current window if deq and deq[0] < i - k + 1: deq.popleft() # Remove elements not useful within the window (smaller than current element) while deq and nums[deq[-1]] <= nums[i]: deq.pop() deq.append(i) # When we reach the window size, record the max element (front of deque) if i >= k - 1: result.append(nums[deq[0]]) return result"},{"question":"from itertools import permutations def can_reorder(nums, k): Given a list of integers \`nums\`, determine whether it is possible to reorder the list such that the sum of any two adjacent numbers is not divisible by a given integer \`k\`. If it is possible, return the reordered list. If it is not possible, return an empty list. >>> can_reorder([1, 2, 3, 4], 5) != [] >>> can_reorder([1, 4, 2, 3], 5) != [] >>> can_reorder([1, 3, 5, 7], 2) == [] >>> can_reorder([1, 2, 3, 6], 3) != [] >>> can_reorder([1, 2, 3], 5) != []","solution":"from itertools import permutations def can_reorder(nums, k): Check if it is possible to reorder the list such that the sum of any two adjacent numbers is not divisible by k. If possible, return the reordered list. If not possible, return an empty list. def is_valid(nums, k): for i in range(len(nums) - 1): if (nums[i] + nums[i + 1]) % k == 0: return False return True for perm in permutations(nums): if is_valid(perm, k): return list(perm) return [] # Example usage: # nums = [1, 2, 3, 4] # k = 5 # Output: [1, 2, 3, 4] or any valid permutation"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest element in the BST. :param root: TreeNode, the root of the BST :param k: int, the k-th smallest position :return: int, the value of the k-th smallest element def test_kth_smallest_single_node(): root = TreeNode(1) assert kth_smallest(root, 1) == 1 def test_kth_smallest_left_heavy(): root = TreeNode(3, TreeNode(1, None, TreeNode(2)), TreeNode(4)) assert kth_smallest(root, 1) == 1 assert kth_smallest(root, 2) == 2 assert kth_smallest(root, 3) == 3 assert kth_smallest(root, 4) == 4 def test_kth_smallest_right_heavy(): root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) assert kth_smallest(root, 1) == 1 assert kth_smallest(root, 2) == 2 assert kth_smallest(root, 3) == 3 assert kth_smallest(root, 4) == 4 def test_kth_smallest_balanced(): root = TreeNode(5, TreeNode(3, TreeNode(2, TreeNode(1), None), TreeNode(4)), TreeNode(7, TreeNode(6), TreeNode(8))) assert kth_smallest(root, 1) == 1 assert kth_smallest(root, 2) == 2 assert kth_smallest(root, 3) == 3 assert kth_smallest(root, 4) == 4 assert kth_smallest(root, 5) == 5 assert kth_smallest(root, 6) == 6 assert kth_smallest(root, 7) == 7 assert kth_smallest(root, 8) == 8 def test_kth_smallest_complex(): root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6, TreeNode(5), TreeNode(7))) assert kth_smallest(root, 1) == 1 assert kth_smallest(root, 2) == 2 assert kth_smallest(root, 3) == 3 assert kth_smallest(root, 4) == 4 assert kth_smallest(root, 5) == 5 assert kth_smallest(root, 6) == 6 assert kth_smallest(root, 7) == 7","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest element in the BST. :param root: TreeNode, the root of the BST :param k: int, the k-th smallest position :return: int, the value of the k-th smallest element def inorder_traversal(node): if node is None: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) elements = inorder_traversal(root) return elements[k - 1]"},{"question":"def palindromic_substring_indices(s: str) -> List[int]: Returns the starting indices of all palindromic substrings of s in lexicographical order. >>> palindromic_substring_indices(\\"abc\\") == [0, 1, 2] >>> palindromic_substring_indices(\\"aaa\\") == [0, 1, 2] >>> palindromic_substring_indices(\\"ababa\\") == [0, 1, 2, 3, 4] >>> palindromic_substring_indices(\\"aabbbaa\\") == [0, 1, 2, 3, 4, 5, 6] >>> palindromic_substring_indices(\\"racecar\\") == [0, 1, 2, 3, 4, 5, 6] >>> palindromic_substring_indices(\\"abcde\\") == [0, 1, 2, 3, 4] >>> palindromic_substring_indices(\\"\\") == []","solution":"def palindromic_substring_indices(s): Returns the starting indices of all palindromic substrings of s. n = len(s) result = [] def is_palindrome(substr): return substr == substr[::-1] for i in range(n): for j in range(i+1, n+1): if is_palindrome(s[i:j]): result.append(i) return sorted(set(result))"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring of the given string s. >>> longest_palindromic_substring(\\"a\\") == \\"a\\" >>> longest_palindromic_substring(\\"aa\\") == \\"aa\\" >>> longest_palindromic_substring(\\"abc\\") == \\"a\\" >>> longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"racecarxyz\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"xyzracecar\\") == \\"racecar\\" >>> longest_palindromic_substring(\\"abba\\") == \\"abba\\" >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> longest_palindromic_substring(\\"Aba\\") == \\"A\\" >>> longest_palindromic_substring(\\"\\") == \\"\\"","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring of the given string s. if s == \\"\\": return \\"\\" n = len(s) longest_palindrome_start = 0 longest_palindrome_length = 1 for i in range(1, n): # Check for even length palindromes l, r = i - 1, i while l >= 0 and r < n and s[l] == s[r]: if (r - l + 1) > longest_palindrome_length: longest_palindrome_start = l longest_palindrome_length = r - l + 1 l -= 1 r += 1 # Check for odd length palindromes l, r = i - 1, i + 1 while l >= 0 and r < n and s[l] == s[r]: if (r - l + 1) > longest_palindrome_length: longest_palindrome_start = l longest_palindrome_length = r - l + 1 l -= 1 r += 1 return s[longest_palindrome_start:longest_palindrome_start + longest_palindrome_length]"},{"question":"def shortest_bridge(grid: List[List[int]]) -> int: You are given a 2D grid of dimension \`n x n\` representing a map of an island where: - \`1\` represents land, and - \`0\` represents water. You must build a bridge to connect two separate islands by flipping exactly one \`0\` to \`1\`. The bridge can only be built in a place where two separate islands are closest to each other. Return the length of the shortest bridge that can be built to connect the two islands. If no such bridge exists, return \`-1\`. A bridge's length is defined as the number of \`0\`s between the two \`1\`s that connect the islands, including the one flipped. You may assume that the given grid always has exactly two separate islands. >>> shortest_bridge([ ... [0, 1], ... [1, 0] ... ]) == 1 >>> shortest_bridge([ ... [0,1,0], ... [0,0,0], ... [0,0,1] ... ]) == 2 >>> shortest_bridge([ ... [1,1,1,1,1], ... [1,0,0,0,1], ... [1,0,1,0,1], ... [1,0,0,0,1], ... [1,1,1,1,1] ... ]) == 1 >>> shortest_bridge([ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [1, 1, 1, 1, 1] ... ]) == 1 >>> shortest_bridge([ ... [1, 1, 1, 0], ... [1, 0, 0, 0], ... [1, 1, 0, 1], ... [1, 1, 1, 1] ... ]) == -1","solution":"def shortest_bridge(grid): from collections import deque def get_neighbors(x, y, n): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n: yield nx, ny def bfs(queue, visited, mark_lookup): while queue: x, y = queue.popleft() for nx, ny in get_neighbors(x, y, n): if (nx, ny) not in visited and grid[nx][ny] == 1: queue.append((nx, ny)) visited.add((nx, ny)) mark_lookup.append((nx, ny)) # Find and mark all cells of the first island. n = len(grid) first_island = [] visited = set() for i in range(n): for j in range(n): if grid[i][j] == 1: first_island.append((i, j)) visited.add((i, j)) break if first_island: break queue = deque(first_island) bfs(queue, visited, first_island) # Use BFS to find the shortest path from the first island to the second island. queue = deque([(x, y, 0) for x, y in first_island]) visited = set(first_island) while queue: x, y, dist = queue.popleft() for nx, ny in get_neighbors(x, y, n): if (nx, ny) not in visited: if grid[nx][ny] == 1: return dist queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List def can_rearrange_string(s: str, charLimit: List[int]) -> bool: Checks if characters of the string \`s\` can be rearranged such that the frequency of each character does not exceed its respective limit in \`charLimit\`. Parameters: s : str : a string consisting of lowercase English letters charLimit : list : an integer list of length 26 representing the maximum allowable frequency for each letter Returns: bool : True if such rearrangement is possible, False otherwise >>> can_rearrange_string(\\"aabbcc\\", [2, 2, 2] + [0]*23) True >>> can_rearrange_string(\\"aabbbcc\\", [2, 1, 2] + [0]*23) False >>> can_rearrange_string(\\"\\", [1] * 26) True >>> can_rearrange_string(\\"a\\" * 10 + \\"b\\" * 10, [2, 2] + [0] * 24) False >>> can_rearrange_string(\\"abc\\" * 2, [2, 2, 2] + [0] * 23) True","solution":"def can_rearrange_string(s, charLimit): Checks if characters of the string \`s\` can be rearranged such that the frequency of each character does not exceed its respective limit in \`charLimit\`. Parameters: s : str : a string consisting of lowercase English letters charLimit : list : an integer list of length 26 representing the maximum allowable frequency for each letter Returns: bool : True if such rearrangement is possible, False otherwise from collections import Counter # Count the frequency of each character in the string \`s\` char_count = Counter(s) for i in range(26): char = chr(i + ord('a')) # get character corresponding to index i if char_count[char] > charLimit[i]: return False return True"},{"question":"def longest_substring_with_n_unique_characters(s: str, n: int) -> str: Returns the longest substring of s that contains exactly n unique characters. Parameters: - s: a string of lowercase alphabets - n: an integer representing the number of unique characters Returns: - The longest substring with exactly n unique characters or an empty string if no such substring exists. pass def test_longest_substring_with_n_unique_characters(): assert longest_substring_with_n_unique_characters(\\"aabbcc\\", 1) == \\"aa\\" assert longest_substring_with_n_unique_characters(\\"aabbcc\\", 2) == \\"aabb\\" assert longest_substring_with_n_unique_characters(\\"aabbcc\\", 3) == \\"aabbcc\\" assert longest_substring_with_n_unique_characters(\\"abcabcabc\\", 2) == \\"ab\\" assert longest_substring_with_n_unique_characters(\\"abcabcabc\\", 3) == \\"abcabcabc\\" assert longest_substring_with_n_unique_characters(\\"aaaaaaaa\\", 1) == \\"aaaaaaaa\\" assert longest_substring_with_n_unique_characters(\\"aaabbb\\", 2) == \\"aaabbb\\" assert longest_substring_with_n_unique_characters(\\"\\", 1) == \\"\\" assert longest_substring_with_n_unique_characters(\\"aabbcc\\", 0) == \\"\\" def test_edge_cases(): assert longest_substring_with_n_unique_characters(\\"abc\\", 4) == \\"\\" assert longest_substring_with_n_unique_characters(\\"a\\", 1) == \\"a\\" assert longest_substring_with_n_unique_characters(\\"a\\", 0) == \\"\\" assert longest_substring_with_n_unique_characters(\\"abcdef\\", 6) == \\"abcdef\\" assert longest_substring_with_n_unique_characters(\\"abcdef\\", 5) == \\"abcde\\"","solution":"def longest_substring_with_n_unique_characters(s, n): Returns the longest substring of s that contains exactly n unique characters. Parameters: - s: a string of lowercase alphabets - n: an integer representing the number of unique characters Returns: - The longest substring with exactly n unique characters or an empty string if no such substring exists. if n == 0 or not s: return \\"\\" start = 0 max_len = 0 max_substr = \\"\\" char_count = {} for end in range(len(s)): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > n: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 if len(char_count) == n and end - start + 1 > max_len: max_len = end - start + 1 max_substr = s[start:end+1] return max_substr"},{"question":"def max_profit(nums: List[int]) -> int: Returns the maximum profit that can be achieved from a single buy and sell transaction. If no profit can be made, returns 0. :param nums: List of integers representing stock prices per day. :return: Integer maximum profit, or 0 if no profit is possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(nums): Returns the maximum profit that can be achieved from a single buy and sell transaction. If no profit can be made, returns 0. :param nums: List of integers representing stock prices per day. :return: Integer maximum profit, or 0 if no profit is possible. if not nums: return 0 min_price = float('inf') max_profit = 0 for price in nums: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def count_distinct_subarrays_with_sum_k(arr: List[int], k: int) -> int: Returns the number of distinct subarrays where the sum of the elements in the subarray is equal to k. >>> count_distinct_subarrays_with_sum_k([1, 2, 3], 3) == 2 >>> count_distinct_subarrays_with_sum_k([1, 1, 1], 2) == 2 >>> count_distinct_subarrays_with_sum_k([1, -1, 1, -1], 0) == 4 >>> count_distinct_subarrays_with_sum_k([1, 2, 3, 4, 5], 9) == 2 >>> count_distinct_subarrays_with_sum_k([], 0) == 0 >>> count_distinct_subarrays_with_sum_k([2, 2, 2], 2) == 3 >>> count_distinct_subarrays_with_sum_k([0, 0, 0, 0], 0) == 10","solution":"def count_distinct_subarrays_with_sum_k(arr, k): Returns the number of distinct subarrays where the sum of the elements in the subarray is equal to k. Parameters: arr (list of int): The input array of integers. k (int): The target sum. Returns: int: The number of distinct subarrays with sum equal to k. n = len(arr) count = 0 for start in range(n): current_sum = 0 for end in range(start, n): current_sum += arr[end] if current_sum == k: count += 1 return count"},{"question":"def daily_temperatures(temperatures): For each day in the input list 'temperatures', return a list 'answer' where answer[i] is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, answer[i] should be 0. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([60, 50, 40, 30]) [0, 0, 0, 0] >>> daily_temperatures([30, 60, 90, 60, 30]) [1, 1, 0, 0, 0] >>> daily_temperatures([73]) [0]","solution":"def daily_temperatures(temperatures): For each day in the input list 'temperatures', return a list 'answer' where answer[i] is the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, answer[i] should be 0. n = len(temperatures) answer = [0] * n stack = [] # This will store the indices of the temperatures list for i in range(n): # If current temperature is higher than the temp at index stored in stack # pop from stack and calculate the difference while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() answer[prev_day] = i - prev_day stack.append(i) return answer"},{"question":"def minTime(n: int, edges: List[List[int]], hasApple: List[bool]) -> int: Return the minimum cost to collect all apples in the tree. The tree is represented by n nodes and the edges list. >>> minTime(7, [[0, 1], [0, 2], [1, 4], [1, 5], [2, 3], [2, 6]], [False, False, True, False, True, True, False]) == 8 >>> minTime(5, [[0, 1], [0, 2], [1, 3], [1, 4]], [False, False, False, False, False]) == 0 >>> minTime(4, [[0, 1], [1, 2], [1, 3]], [True, True, True, True]) == 6 >>> minTime(3, [[0, 1], [1, 2]], [False, False, True]) == 4 >>> minTime(5, [[0, 1], [0, 2], [1, 3], [2, 4]], [False, True, False, True, False]) == 4","solution":"def minTime(n, edges, hasApple): from collections import defaultdict # Build an adjacency list from edges tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): time = 0 # Traverse all children for child in tree[node]: if child != parent: child_time = dfs(child, node) # If child or its subtree has an apple, we add the time to traverse to this child and back if child_time > 0 or hasApple[child]: time += child_time + 2 return time # Start DFS from the root node (0) return dfs(0, -1) # Example usage # n = 7 # edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]] # hasApple = [False,False,True,False,True,True,False] # Output: 8 # 1 <-- 0 --> 2 # | | # [4,5] [3,6]"},{"question":"from typing import List, Tuple def max_profit(initial_workers: int, projects: List[Tuple[int, int]]) -> int: Calculate the maximum profit you can achieve given the initial number of workers and the list of projects where each project has a required number of workers and a profit. >>> max_profit(3, [(2, 3), (1, 2), (3, 4)]) 9 >>> max_profit(3, [(5, 10), (4, 8), (2, 1)]) 1 >>> max_profit(5, [(2, 6), (4, 7), (1, 5)]) 18 >>> max_profit(10, [(1, 2), (2, 4), (3, 6)]) 12 >>> max_profit(5, []) 0 >>> max_profit(2, [(0, 0), (0, 0)]) 0","solution":"from typing import List, Tuple def max_profit(initial_workers: int, projects: List[Tuple[int, int]]) -> int: # Sort projects based on required workers in ascending order projects.sort() total_workers = initial_workers total_profit = 0 for required_workers, profit in projects: # If we have enough workers to start the project if total_workers >= required_workers: # Star the project total_workers -= required_workers # Deduct the required workers total_profit += profit # Gain the profit total_workers += profit # Reinvest profit into hiring new workers return total_profit"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, find and return the length of the longest substring without repeating characters using a sliding window approach. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcde\\") 5 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring without repeating characters. char_index_map = {} start = 0 max_length = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def count_pairs_with_diff(arr: List[int], target: int) -> int: Returns the number of distinct pairs (i, j) where 0 <= i < j < len(arr) such that the absolute difference between arr[i] and arr[j] is equal to target. >>> count_pairs_with_diff([1, 5, 3, 4, 2], 2) 3 >>> count_pairs_with_diff([1, 1, 1, 1], 0) 6 >>> count_pairs_with_diff([1, 3, 5, 7, 9], 2) 4 >>> count_pairs_with_diff([], 1) 0 >>> count_pairs_with_diff([1], 1) 0 >>> count_pairs_with_diff([1, 2, 3, 4, 5], 1) 4 >>> count_pairs_with_diff([10, 10, 10, 10], 0) 6 from solution import count_pairs_with_diff def test_count_pairs_with_diff(): assert count_pairs_with_diff([1, 5, 3, 4, 2], 2) == 3 assert count_pairs_with_diff([1, 1, 1, 1], 0) == 6 assert count_pairs_with_diff([1, 3, 5, 7, 9], 2) == 4 assert count_pairs_with_diff([], 1) == 0 assert count_pairs_with_diff([1], 1) == 0 assert count_pairs_with_diff([1, 2, 3, 4, 5], 1) == 4 assert count_pairs_with_diff([10, 10, 10, 10], 0) == 6 def test_count_pairs_with_no_pairs(): assert count_pairs_with_diff([1, 2, 3, 4], 10) == 0 assert count_pairs_with_diff([4, 8, 12], 5) == 0","solution":"def count_pairs_with_diff(arr, target): Returns the number of distinct pairs (i, j) where 0 <= i < j < len(arr) such that the absolute difference between arr[i] and arr[j] is equal to target. count = 0 seen = set() n = len(arr) for i in range(n): if arr[i] + target in seen: count += 1 if arr[i] - target in seen: count += 1 seen.add(arr[i]) return count"},{"question":"def isMatch(s: str, p: str) -> bool: Returns True if the input string \`s\` matches the pattern \`p\`. The pattern \`p\` can include '.' which matches any single character and '*' which matches zero or more of the preceding element. >>> isMatch(\\"abc\\", \\"abc\\") True >>> isMatch(\\"abc\\", \\"a.c\\") True >>> isMatch(\\"abcd\\", \\"a.d.\\") False >>> isMatch(\\"abc\\", \\"ab*c\\") True >>> isMatch(\\"abbbbbc\\", \\"ab*c\\") True >>> isMatch(\\"ab\\", \\".*\\") True >>> isMatch(\\"aab\\", \\"c*a*b\\") True >>> isMatch(\\"mississippi\\", \\"mis*is*p*.\\") False >>> isMatch(\\"mississippi\\", \\"mis*is*ip*.\\") True","solution":"def isMatch(s: str, p: str) -> bool: Returns True if the input string \`s\` matches the pattern \`p\`. The pattern \`p\` can include '.' which matches any single character and '*' which matches zero or more of the preceding element. # Use dynamic programming to solve the problem m, n = len(s), len(p) # dp[i][j] means whether s[0:i] matches p[0:j] dp = [[False] * (n + 1) for _ in range(m + 1)] # Both s and p are empty dp[0][0] = True # Handle patterns with * for j in range(1, n + 1): if p[j - 1] == '*': dp[0][j] = dp[0][j - 2] # Matches zero preceding element (e.g. x*) for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == '.' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == '*': dp[i][j] = dp[i][j - 2] if p[j - 2] == '.' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] return dp[m][n]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root: TreeNode) -> List[int]: Given a binary tree, return the preorder traversal of its nodes' values. >>> preorder_traversal(TreeNode(1)) [1] >>> preorder_traversal(TreeNode(1, TreeNode(2, TreeNode(3)))) [1, 2, 3] >>> preorder_traversal(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) [1, 2, 3] >>> preorder_traversal(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) [1, 2, 4, 5, 3] >>> preorder_traversal(None) [] >>> preorder_traversal(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))) [1, 2, 4, 5, 3, 6, 7]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def preorder_traversal(root): Returns the preorder traversal of a binary tree's nodes' values. def helper(node): if not node: return [] return [node.val] + helper(node.left) + helper(node.right) return helper(root)"},{"question":"def longest_consecutive(nums: List[int]) -> int: Given an unsorted array of integers \`nums\`, find the length of the longest consecutively increasing sequence presented in the array. The sequence must be strictly increasing, and no elements should be skipped in the sequence. Your algorithm should run in \`O(n)\` time complexity. Return the length of this longest sequence. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) == 4 # Sequence: 1, 2, 3, 4 >>> longest_consecutive([]) == 0 >>> longest_consecutive([10]) == 1 >>> longest_consecutive([10, 30, 20, 40]) == 1 >>> longest_consecutive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 >>> longest_consecutive([-1, -2, -3, -4, -5, -8, 6, -6, -7]) == 8 # Sequence: -8 to -1 >>> longest_consecutive([1, 2, 2, 3, 3, 4, 4, 5]) == 5 # Sequence: 1, 2, 3, 4, 5","solution":"def longest_consecutive(nums): Finds the length of the longest consecutively increasing sequence in the array \`nums\`. Parameters: nums (list of int): The input array of integers. Returns: int: The length of the longest consecutively increasing sequence. if not nums: return 0 nums_set = set(nums) longest_sequence = 0 for num in nums_set: if num - 1 not in nums_set: # Start of a new sequence current_num = num current_sequence = 1 while (current_num + 1) in nums_set: current_num += 1 current_sequence += 1 longest_sequence = max(longest_sequence, current_sequence) return longest_sequence"},{"question":"import heapq from typing import List def minimumEffortPath(grid: List[List[int]]) -> int: Determines the minimum effort required to travel from the top-left cell to the bottom-right cell in the grid. Parameters: grid (List[List[int]]): The grid representing the field of cells. Returns: int: The minimum effort required. pass # Unit Tests def test_minimumEffortPath_example1(): grid = [ [1, 2, 2], [3, 8, 2], [5, 3, 5] ] assert minimumEffortPath(grid) == 2 def test_minimumEffortPath_example2(): grid = [ [1, 2, 3], [3, 8, 4], [5, 3, 5] ] assert minimumEffortPath(grid) == 1 def test_minimumEffortPath_single_cell(): grid = [[0]] assert minimumEffortPath(grid) == 0 def test_minimumEffortPath_increasing_heights(): grid = [ [1, 3, 5, 7], [2, 4, 6, 8], [3, 5, 7, 9] ] assert minimumEffortPath(grid) == 2 def test_minimumEffortPath_flat_grid(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert minimumEffortPath(grid) == 0","solution":"import heapq def minimumEffortPath(grid): Determines the minimum effort required to travel from the top-left cell to the bottom-right cell in the grid. Parameters: grid (List[List[int]]): The grid representing the field of cells. Returns: int: The minimum effort required. n, m = len(grid), len(grid[0]) directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] effort = [[float('inf')] * m for _ in range(n)] effort[0][0] = 0 min_heap = [(0, 0, 0)] # (effort, row, col) while min_heap: current_effort, x, y = heapq.heappop(min_heap) if x == n-1 and y == m-1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: new_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < effort[nx][ny]: effort[nx][ny] = new_effort heapq.heappush(min_heap, (new_effort, nx, ny)) return effort[n-1][m-1]"},{"question":"def minimum_routes(routes: List[List[str]], keys: List[str]) -> int: Determine the minimum number of routes required to cover all key locations. >>> minimum_routes([[\\"A\\", \\"B\\", \\"C\\"], [\\"C\\", \\"D\\"], [\\"D\\", \\"E\\", \\"A\\"], [\\"B\\", \\"E\\"]], [\\"A\\", \\"D\\"]) == 1 >>> minimum_routes([[\\"A\\", \\"B\\"], [\\"C\\", \\"D\\"], [\\"E\\", \\"F\\"], [\\"G\\", \\"H\\"]], [\\"A\\", \\"D\\", \\"F\\", \\"H\\"]) == 4 >>> minimum_routes([[\\"A\\", \\"B\\", \\"C\\"], [\\"C\\", \\"D\\", \\"E\\"], [\\"E\\", \\"F\\", \\"G\\"]], [\\"A\\", \\"E\\"]) == 2 >>> minimum_routes([[\\"A\\", \\"B\\", \\"C\\"], [\\"C\\", \\"D\\", \\"E\\"]], [\\"A\\", \\"F\\"]) == -1 >>> minimum_routes([[\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\"]], [\\"A\\", \\"C\\", \\"E\\"]) == 1","solution":"from itertools import combinations def minimum_routes(routes, keys): n = len(routes) key_set = set(keys) def covers_all_keys(route_indices): covered = set() for i in route_indices: covered.update(routes[i]) return key_set.issubset(covered) for i in range(1, n + 1): for combo in combinations(range(n), i): if covers_all_keys(combo): return i return -1"},{"question":"def can_form_palindrome_by_inserting_one_char(s: str) -> bool: Determine if you can form a palindrome by inserting exactly one character into the string s. >>> can_form_palindrome_by_inserting_one_char(\\"abcba\\") True >>> can_form_palindrome_by_inserting_one_char(\\"abca\\") True >>> can_form_palindrome_by_inserting_one_char(\\"abcdefg\\") False >>> can_form_palindrome_by_inserting_one_char(\\"\\") True >>> can_form_palindrome_by_inserting_one_char(\\"a\\") True >>> can_form_palindrome_by_inserting_one_char(\\"aabaa\\") True","solution":"def can_form_palindrome_by_inserting_one_char(s): Determine if we can form a palindrome by inserting exactly one character into the string s. def is_palindrome(subs): Helper function to check if a given string is a palindrome. return subs == subs[::-1] n = len(s) for i in range(n + 1): # Try inserting a character at every possible position if i == 0: new_str = '_' + s elif i == n: new_str = s + '_' else: new_str = s[:i] + '_' + s[i:] # Check if placing any character at this position can make it a palindrome for char in 'abcdefghijklmnopqrstuvwxyz': candidate = new_str.replace('_', char) if is_palindrome(candidate): return True return False"},{"question":"def removeKchars(s: str, k: int) -> str: Returns the lexicographically smallest string by removing exactly k characters from the input string 's'. >>> removeKchars(\\"abcde\\", 2) \\"abc\\" >>> removeKchars(\\"acbd\\", 1) \\"abd\\" >>> removeKchars(\\"abcdabcd\\", 4) \\"aabc\\" >>> removeKchars(\\"a\\", 1) \\"\\" >>> removeKchars(\\"abc\\", 3) \\"\\" >>> removeKchars(\\"bcabc\\", 1) \\"babc\\" >>> removeKchars(\\"bcabc\\", 2) \\"abc\\"","solution":"def removeKchars(s, k): Returns the lexicographically smallest string by removing exactly k characters from the input string 's'. stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If k characters are not removed while k > 0: stack.pop() k -= 1 return \\"\\".join(stack)"},{"question":"def min_transfers_to_even_stacks(stacks: List[List[int]]) -> int: Determine the minimum number of transfers needed to make the total weight of all stacks as even as possible. Args: stacks (list[list[int]]): 2D list where each sublist represents a stack of packages with their weights. Returns: int: Minimum number of transfers needed or -1 if not possible. >>> min_transfers_to_even_stacks([[1, 2, 3], [4, 5], [6]]) 2 >>> min_transfers_to_even_stacks([[1, 2, 3], [4, 5], [7]]) -1 >>> min_transfers_to_even_stacks([[3], [3], [3]]) 0 >>> min_transfers_to_even_stacks([[1, 2, 3]]) 0 >>> min_transfers_to_even_stacks([[], [], []]) 0","solution":"def min_transfers_to_even_stacks(stacks): Determine the minimum number of transfers needed to make the total weight of all stacks as even as possible. Args: stacks (list[list[int]]): 2D list where each sublist represents a stack of packages with their weights. Returns: int: Minimum number of transfers needed or -1 if not possible. total_weight = sum(sum(stack) for stack in stacks) num_stacks = len(stacks) if total_weight % num_stacks != 0: return -1 target_weight = total_weight // num_stacks def get_stack_weights(stacks): return [sum(stack) for stack in stacks] stack_weights = get_stack_weights(stacks) transfers = 0 for i in range(len(stacks)): while stack_weights[i] > target_weight: excess_weight = stack_weights[i] - target_weight for j in range(len(stacks)): if i != j and stack_weights[j] < target_weight: transfer_weight = min(excess_weight, target_weight - stack_weights[j]) stack_weights[i] -= transfer_weight stack_weights[j] += transfer_weight transfers += 1 if stack_weights[i] == target_weight: break return transfers"},{"question":"def count_unique_pairs(nums: List[int], target: int) -> int: Returns the number of unique pairs (i, j) such that nums[i] + nums[j] == target and i != j. Each pair is counted only once, regardless of order. >>> count_unique_pairs([1, 2, 3, 4, 5], 5) == 2 # (1, 4) and (2, 3) >>> count_unique_pairs([1, 1, 1, 1], 2) == 1 # (1, 1) >>> count_unique_pairs([1, -1, -1, 1], 0) == 1 # (1, -1) >>> count_unique_pairs([3, 1, 4, 1], 5) == 1 # (1, 4) and (3, 2) >>> count_unique_pairs([0, 0, 0, 0], 0) == 1 # (0, 0) >>> count_unique_pairs([1, 3, 2, 2, 4], 4) == 2 # (1, 3) and (2, 2) >>> count_unique_pairs([], 5) == 0 # no pairs >>> count_unique_pairs([1, 2, 3, 4, 6, 8], 7) == 2 # (1, 6) and (3, 4) pass","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs (i, j) such that nums[i] + nums[j] == target and i != j. Each pair is counted only once, regardless of order. nums_sort = sorted(nums) left, right = 0, len(nums_sort) - 1 pairs = set() while left < right: current_sum = nums_sort[left] + nums_sort[right] if current_sum == target: pairs.add((nums_sort[left], nums_sort[right])) left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return len(pairs)"},{"question":"class TextDB: A simple text-based database management system, where you can store key-value pairs and perform various operations. Methods: - __init__() - Initializes an empty database. - put(key: str, value: str) -> None - Inserts a key-value pair into the database. If the key already exists, its value will be updated. - get(key: str) -> str - Returns the value associated with the key. If the key does not exist, return \\"Not found\\". - delete(key: str) -> None - Deletes the key-value pair from the database. If the key does not exist, do nothing. - list() -> List[str] - Returns an array of all keys in the database in lexicographical order. >>> db = TextDB() >>> db.put(\\"name\\", \\"Alice\\") >>> db.put(\\"age\\", \\"23\\") >>> db.get(\\"name\\") 'Alice' >>> db.get(\\"gender\\") 'Not found' >>> db.delete(\\"age\\") >>> db.list() ['name'] import pytest def test_put_and_get(): db = TextDB() db.put(\\"name\\", \\"Alice\\") assert db.get(\\"name\\") == \\"Alice\\" db.put(\\"age\\", \\"23\\") assert db.get(\\"age\\") == \\"23\\" def test_get_not_found(): db = TextDB() assert db.get(\\"gender\\") == \\"Not found\\" def test_update_value(): db = TextDB() db.put(\\"name\\", \\"Alice\\") assert db.get(\\"name\\") == \\"Alice\\" db.put(\\"name\\", \\"Bob\\") assert db.get(\\"name\\") == \\"Bob\\" def test_delete_key(): db = TextDB() db.put(\\"name\\", \\"Alice\\") assert db.get(\\"name\\") == \\"Alice\\" db.delete(\\"name\\") assert db.get(\\"name\\") == \\"Not found\\" def test_delete_non_existent_key(): db = TextDB() db.delete(\\"nonexistent\\") assert db.get(\\"nonexistent\\") == \\"Not found\\" def test_list_keys(): db = TextDB() db.put(\\"name\\", \\"Alice\\") db.put(\\"age\\", \\"23\\") db.put(\\"country\\", \\"Wonderland\\") assert db.list() == [\\"age\\", \\"country\\", \\"name\\"] def test_list_empty_db(): db = TextDB() assert db.list() == []","solution":"class TextDB: def __init__(self): self.database = {} def put(self, key, value): self.database[key] = value def get(self, key): return self.database.get(key, \\"Not found\\") def delete(self, key): if key in self.database: del self.database[key] def list(self): return sorted(self.database.keys())"},{"question":"def count_distinct_substrings(s: str, k: int) -> int: Return the number of distinct substrings of length k in the string s. If k is larger than the length of s, return 0. >>> count_distinct_substrings(\\"abcabc\\", 3) 3 >>> count_distinct_substrings(\\"aaaaa\\", 1) 1 >>> count_distinct_substrings(\\"abcd\\", 2) 3 >>> count_distinct_substrings(\\"abc\\", 4) 0 >>> count_distinct_substrings(\\"\\", 1) 0 >>> count_distinct_substrings(\\"abc\\", 1) 3 >>> count_distinct_substrings(\\"abc\\", 3) 1 >>> count_distinct_substrings(\\"aa\\", 2) 1 >>> count_distinct_substrings(\\"aaba bb\\", 3) 5 >>> count_distinct_substrings(\\" \\", 2) 1 >>> count_distinct_substrings(\\"abcd\\", 4) 1 >>> count_distinct_substrings(\\"abcdefg\\", 2) 6 # Implement the function here","solution":"def count_distinct_substrings(s, k): Return the number of distinct substrings of length k in the string s. If k is larger than the length of s, return 0. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substrings.add(s[i:i+k]) return len(substrings)"},{"question":"def threeSumClosest(arr, target): Returns the sum of three integers in \`arr\` such that the sum is closest to \`target\`. >>> threeSumClosest([1, 2, 3, 4, 5], 9) == 9 >>> threeSumClosest([1, 1, 1, 1], 3) == 3 >>> threeSumClosest([10, 20, 30, 40, 50], 60) == 60 >>> threeSumClosest([10, 20, 30, 40, 50], 100) == 100 >>> threeSumClosest([1, 1, 1, 1], 4) == 3 >>> threeSumClosest([5, 5, 5, 5], 15) == 15 >>> threeSumClosest([5, 5, 5, 5], 14) == 15 >>> threeSumClosest([0, 0, 0], 1) == 0 >>> threeSumClosest([-1, 2, 1, -4], 1) == 2","solution":"def threeSumClosest(arr, target): Returns the sum of three integers in \`arr\` such that the sum is closest to \`target\`. arr.sort() n = len(arr) closest_sum = float('inf') for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return current_sum if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 else: right -= 1 return closest_sum"},{"question":"from typing import List def longest_unique_substring_length(input: str) -> int: Given a string input consisting of lowercase English letters, determine the length of the longest substring with all unique characters. Return the length of this longest substring. >>> longest_unique_substring_length(\\"abcdef\\") 6 >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"aaaaa\\") 1 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"pwwkew\\") 3 >>> longest_unique_substring_length(\\"dvdf\\") 3","solution":"def longest_unique_substring_length(input): Returns the length of the longest substring with all unique characters. char_index_map = {} max_length = 0 start = 0 for i, char in enumerate(input): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def count_students_in_same_position(heights: List[int]) -> int: Returns the number of students standing in the same position before and after sorting the array. Parameters: heights (list of int): List of heights of students. Returns: int: The number of students in the same position. >>> count_students_in_same_position([3, 1, 2]) == 0 >>> count_students_in_same_position([1, 2, 3]) == 3 >>> count_students_in_same_position([1, 3, 2]) == 1 >>> count_students_in_same_position([5]) == 1 >>> count_students_in_same_position([]) == 0 >>> count_students_in_same_position([2, 3, 3, 1]) == 1 >>> count_students_in_same_position([2, 2, 2]) == 3","solution":"def count_students_in_same_position(heights): Returns the number of students standing in the same position before and after sorting the array. Parameters: heights (list of int): List of heights of students. Returns: int: The number of students in the same position. sorted_heights = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] == sorted_heights[i]: count += 1 return count"},{"question":"def count_k_edge_paths(tree, k): Given a tree represented as an adjacency list and a target integer \`k\`, find the number of paths in the tree that have exactly \`k\` edges. Parameters: tree (dict): Adjacency list representing the tree. k (int): The number of edges that each path should have. Returns: int: The total number of such distinct paths. Example: >>> tree = { ... 1: [2, 3], ... 2: [1, 4, 5], ... 3: [1], ... 4: [2], ... 5: [2] ... } >>> count_k_edge_paths(tree, 1) 4 >>> count_k_edge_paths(tree, 2) 4 >>> count_k_edge_paths(tree, 3) 2 >>> count_k_edge_paths(tree, 4) 0 Example: >>> count_k_edge_paths({}, 1) 0","solution":"from collections import defaultdict def count_k_edge_paths(tree, k): Returns the number of paths in the tree that have exactly k edges. if k == 0: return 0 # No such paths with 0 edges def dfs(node, parent, depth): # Base case: if path has exactly k edges, count it if depth == k: return 1 count = 0 # Traverse all adjacent nodes for neighbor in tree[node]: if neighbor != parent: # Don't revisit the parent node count += dfs(neighbor, node, depth+1) return count total_paths = 0 # Start DFS from each node (as each node might be a starting point) for start_node in tree: total_paths += dfs(start_node, None, 0) # Each path is counted twice (once in each direction), so divide by 2 return total_paths // 2 # Example Tree for testing tree = { 1: [2, 3], 2: [1, 4, 5], 3: [1], 4: [2], 5: [2] }"},{"question":"def minDistance(word1: str, word2: str) -> int: Returns the minimum number of steps required to convert word1 to word2. Operations allowed: Insert a character, Delete a character, Replace a character. >>> minDistance(\\"abc\\", \\"abc\\") 0 >>> minDistance(\\"abc\\", \\"ab\\") 1 >>> minDistance(\\"abc\\", \\"\\") 3 >>> minDistance(\\"ab\\", \\"abc\\") 1 >>> minDistance(\\"\\", \\"abc\\") 3 >>> minDistance(\\"abc\\", \\"adc\\") 1 >>> minDistance(\\"abcd\\", \\"abcf\\") 1 >>> minDistance(\\"horse\\", \\"ros\\") 3 >>> minDistance(\\"intention\\", \\"execution\\") 5 >>> minDistance(\\"kitten\\", \\"sitting\\") 3","solution":"def minDistance(word1, word2): Returns the minimum number of steps required to convert word1 to word2. Operations allowed: Insert a character, Delete a character, Replace a character. m, n = len(word1), len(word2) # create a DP table to memoize the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # initialize the table with base cases for i in range(m + 1): dp[i][0] = i # if word2 is empty, we need i deletions for j in range(n + 1): dp[0][j] = j # if word1 is empty, we need j insertions # fill the table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: # if characters match, no new operation needed dp[i][j] = dp[i - 1][j - 1] else: # otherwise, consider the minimum cost of the three operations dp[i][j] = min(dp[i - 1][j] + 1, # delete dp[i][j - 1] + 1, # insert dp[i - 1][j - 1] + 1) # replace return dp[m][n]"},{"question":"def longest_substring_transformed_palindrome(s: str, k: int) -> int: Returns the length of the longest substring of s that can be transformed into a palindrome by inserting at most k characters. >>> longest_substring_transformed_palindrome(\\"abcdeca\\", 2) 7 >>> longest_substring_transformed_palindrome(\\"aabbc\\", 1) -1 >>> longest_substring_transformed_palindrome(\\"abcd\\", 3) 4 >>> longest_substring_transformed_palindrome(\\"\\", 3) 0 >>> longest_substring_transformed_palindrome(\\"racecar\\", 0) 7","solution":"def longest_palindrome_subseq(s: str) -> int: Helper function to find the length of the longest palindromic subsequence in s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n - 1, -1, -1): dp[i][i] = 1 for j in range(i + 1, n): if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] def longest_substring_transformed_palindrome(s: str, k: int) -> int: Returns the length of the longest substring of s that can be transformed into a palindrome by inserting at most k characters. n = len(s) if n == 0: return 0 # Find the length of the longest palindromic subsequence longest_palindromic_subseq_length = longest_palindrome_subseq(s) # Minimum insertions needed to transform the longest palindromic subsequence to a full palindrome min_insertions = n - longest_palindromic_subseq_length if min_insertions <= k: return n return -1 # It means it's not possible within k characters to make the entire string palindrome"},{"question":"def findOrder(numCourses, prerequisites): Determines the order of courses to finish جميع courses given the prerequisites. :param numCourses: int, number of courses :param prerequisites: List[List[int]], list of prerequisite pairs :return: List[int], the order of courses to take or an empty list if impossible >>> findOrder(4, []) == [0, 1, 2, 3] >>> findOrder(2, [[1, 0]]) == [0, 1] >>> findOrder(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) == [0, 1, 2, 3] >>> findOrder(2, [[1, 0], [0, 1]]) == [] >>> findOrder(6, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]]) == [5, 4, 3, 2, 1, 0] >>> findOrder(0, []) == [] >>> findOrder(4, [[0, 1], [1, 2], [2, 3], [3, 0], [1, 0]]) == []","solution":"from collections import deque, defaultdict def findOrder(numCourses, prerequisites): Determines the order of courses to finish جميع courses given the prerequisites. :param numCourses: int, number of courses :param prerequisites: List[List[int]], list of prerequisite pairs :return: List[int], the order of courses to take or an empty list if impossible indegree = [0] * numCourses graph = defaultdict(list) for dest, src in prerequisites: graph[src].append(dest) indegree[dest] += 1 queue = deque([i for i in range(numCourses) if indegree[i] == 0]) order = [] while queue: course = queue.popleft() order.append(course) for neighbor in graph[course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == numCourses: return order else: return []"},{"question":"from typing import List def count_visible_buildings(heights: List[int]) -> int: Determine the number of buildings that can see each other directly without any taller buildings in between. >>> count_visible_buildings([4, 2, 3, 1]) 3 >>> count_visible_buildings([2, 2, 2, 2]) 4 >>> count_visible_buildings([1, 2, 3, 4]) 3 >>> count_visible_buildings([4, 3, 2, 1]) 3 >>> count_visible_buildings([5]) 0 >>> count_visible_buildings([10, 5, 6, 3, 4]) 4 >>> count_visible_buildings([3, 4, 5, 6, 10]) 4 >>> count_visible_buildings([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) 10","solution":"def count_visible_buildings(heights): def visible_left(index, heights): curr_max = 0 for i in range(index-1, -1, -1): if heights[i] >= heights[index]: return True if heights[i] > curr_max: curr_max = heights[i] return curr_max >= heights[index] def visible_right(index, heights): curr_max = 0 for i in range(index+1, len(heights)): if heights[i] >= heights[index]: return True if heights[i] > curr_max: curr_max = heights[i] return curr_max >= heights[index] count = 0 for i in range(len(heights)): if visible_left(i, heights) or visible_right(i, heights): count += 1 return count"},{"question":"def find_substring_indices(s: str, words: List[str]) -> List[int]: Given a string \`s\` and an array of string \`words\`, return a list of all starting indices of \`words\`' concatenations in \`s\`. Each concatenation is formed by joining all the strings in \`words\` exactly once and without any intervening characters. The order of concatenation must match the order given in the array \`words\`. >>> find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substring_indices(\\"foobar\\", [\\"f\\", \\"o\\", \\"o\\"]) [0] >>> find_substring_indices(\\"abcdef\\", [\\"gh\\", \\"ij\\"]) [] >>> find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) [] >>> find_substring_indices(\\"barfoofoobarthefoobarman\\", [\\"bar\\", \\"foo\\", \\"the\\"]) [6, 9, 12] >>> find_substring_indices(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) [] >>> find_substring_indices(\\"abcdef\\", []) []","solution":"def find_substring_indices(s, words): if not s or not words: return [] word_length = len(words[0]) total_words_length = word_length * len(words) word_count = len(words) result = [] word_dict = {} for word in words: word_dict[word] = word_dict.get(word, 0) + 1 for i in range(len(s) - total_words_length + 1): seen_words = {} for j in range(word_count): word_index = i + j * word_length word = s[word_index:word_index + word_length] if word in word_dict: seen_words[word] = seen_words.get(word, 0) + 1 if seen_words[word] > word_dict[word]: break else: break else: result.append(i) return result"},{"question":"import random class RandomizedSet: Design a data structure that supports insert, remove, and pick operations efficiently on a list of unique numbers. - RandomizedSet() Initializes the data structure. - bool insert(int val) Inserts a value to the set if not already present and returns True. Otherwise returns False. - bool remove(int val) Removes the integer val from the list if it exists and returns True. Otherwise returns False. - int pick() Randomly returns an integer from the current list of numbers. Returns None if the list is empty. Example Usage: >>> rs = RandomizedSet() >>> rs.insert(1) True >>> rs.insert(2) True >>> rs.pick() 1 # or 2 (randomly selected) >>> rs.remove(1) True >>> rs.pick() 2 def __init__(self): pass def pick(self): pass def remove(self, val): pass def insert(self, val): pass import pytest from solution import RandomizedSet def test_randomized_set(): rs = RandomizedSet() # Insert elements and check their presence assert rs.insert(1) == True assert rs.insert(2) == True assert rs.insert(3) == True assert rs.insert(1) == False # Already present # Pick should give an element from the set picked = rs.pick() assert picked in [1, 2, 3] # Remove elements and verify removal assert rs.remove(2) == True assert rs.remove(2) == False # Already removed picked_after_removal = rs.pick() assert picked_after_removal in [1, 3] # Removing remaining elements assert rs.remove(1) == True assert rs.remove(3) == True # After all elements are removed, pick should handle empty case. assert rs.pick() == None pytest.main()","solution":"import random class RandomizedSet: def __init__(self): Initialize the data structure which supports average O(1) operations. self.num_map = {} # Mapping from number to its index in the list self.nums_list = [] # List of numbers def pick(self): Randomly select an integer from the list and return it. if not self.nums_list: return None return random.choice(self.nums_list) def remove(self, val): Remove the integer val from the list if it exists. Returns True if the element was successfully removed, otherwise False. if val not in self.num_map: return False # Swap the element to remove with the last element index_to_remove = self.num_map[val] last_element = self.nums_list[-1] # Move the last element to the place of the element to remove self.nums_list[index_to_remove] = last_element self.num_map[last_element] = index_to_remove # Remove the last element from the list and map self.nums_list.pop() del self.num_map[val] return True def insert(self, val): Inserts a value to the set. Returns True if the set did not already contain the specified element. if val in self.num_map: return False self.num_map[val] = len(self.nums_list) self.nums_list.append(val) return True"},{"question":"from typing import List def min_moves(board: List[List[str]]) -> int: Find the minimum number of moves required to reach the bottom-right cell from the top-left cell in a grid with obstacles. Parameters: - board (List[List[str]]): 2D grid where '.' represents an empty cell and '#' represents an obstacle Returns: - int: Minimum number of moves to reach the bottom-right cell, or -1 if unreachable >>> min_moves([ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) 4 >>> min_moves([ ... ['.', '#', '.'], ... ['#', '#', '.'], ... ['.', '.', '.'] ... ]) -1 >>> min_moves([ ... ['.'] ... ]) 0","solution":"from collections import deque def min_moves(board): Find the minimum number of moves required to reach the bottom-right cell from the top-left cell in a grid with obstacles. Parameters: - board (List[List[str]]): 2D grid where '.' represents an empty cell and '#' represents an obstacle Returns: - int: Minimum number of moves to reach the bottom-right cell, or -1 if unreachable if not board or board[0][0] == '#' or board[-1][-1] == '#': return -1 n = len(board) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([((0, 0), 0)]) # ((current_position), current_steps) visited = set((0, 0)) while queue: (x, y), steps = queue.popleft() if (x, y) == (n-1, n-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and board[nx][ny] == '.': queue.append(((nx, ny), steps + 1)) visited.add((nx, ny)) return -1"},{"question":"def longest_triangular_subsequence(nums): Returns the length of the longest consecutive subsequence that forms a triangular sequence. If no such subsequence exists, returns 0. >>> longest_triangular_subsequence([1, 3, 6, 2, 5, 10, 15]) == 3 >>> longest_triangular_subsequence([1]) == 1 >>> longest_triangular_subsequence([4, 8, 12, 14]) == 0 >>> longest_triangular_subsequence([1, 3, 6, 10, 15, 21]) == 6 >>> longest_triangular_subsequence([5, 10, 15, 1, 2, 3, 3, 6]) == 3 pass","solution":"def longest_triangular_subsequence(nums): Returns the length of the longest consecutive subsequence that forms a triangular sequence. If no such subsequence exists, returns 0. def is_triangular(num): # Check if \`num\` is a triangular number # Using arithmetic series formula: n(n+1)//2 = num n = ((8 * num + 1) ** 0.5 - 1) / 2 return n == int(n) longest, current_length = 0, 0 for num in nums: if is_triangular(num): current_length += 1 else: longest = max(longest, current_length) current_length = 0 return max(longest, current_length)"},{"question":"def longest_mountain(height: List[int]) -> int: Given an array of integers \`height\` where \`height[i]\` represents the height of a mountain, find the length of the longest mountain. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5]) 5 >>> longest_mountain([2, 1, 2]) 0 >>> longest_mountain([1, 3, 2, 5, 4]) 3","solution":"def longest_mountain(height): if not height or len(height) < 3: return 0 n = len(height) longest = 0 for i in range(1, n - 1): if height[i - 1] < height[i] > height[i + 1]: # peak of mountain left = i - 1 while left > 0 and height[left - 1] < height[left]: left -= 1 right = i + 1 while right < n - 1 and height[right] > height[right + 1]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"from typing import List, Tuple def find_min_time(tasks: List[Tuple[int, int, List[int]]]) -> int: Returns the minimum time required to complete all tasks considering dependencies. If there's a cyclic dependency, returns -1. >>> find_min_time([(1, 2, []), (2, 3, []), (3, 1, [])]) 3 >>> find_min_time([(1, 2, []), (2, 3, [1]), (3, 1, [2])]) 6 >>> find_min_time([(1, 3, []), (2, 2, [1]), (3, 1, [1]), (4, 4, [2, 3])]) 9 >>> find_min_time([(1, 2, [2]), (2, 3, [1])]) -1 >>> find_min_time([(1, 2, []), (2, 3, [1]), (3, 1, [2]), (4, 5, [])]) 6 pass","solution":"from collections import defaultdict, deque def find_min_time(tasks): Returns the minimum time required to complete all tasks considering dependencies. If there's a cyclic dependency, returns -1. # Create adjacency list and indegree count adj_list = defaultdict(list) indegree = {task[0]: 0 for task in tasks} duration = {task[0]: task[1] for task in tasks} for task in tasks: for dep in task[2]: adj_list[dep].append(task[0]) indegree[task[0]] += 1 # Initialize queue with tasks having no dependencies queue = deque() for task in tasks: if indegree[task[0]] == 0: queue.append((task[0], task[1])) total_time = 0 completed = 0 task_count = len(tasks) time_taken = {task[0]: 0 for task in tasks} while queue: t, current_time = queue.popleft() total_time = max(total_time, current_time) completed += 1 for neighbor in adj_list[t]: indegree[neighbor] -= 1 time_taken[neighbor] = max(time_taken[neighbor], current_time + duration[neighbor]) if indegree[neighbor] == 0: queue.append((neighbor, time_taken[neighbor])) # Check if all tasks were completed if completed == task_count: return total_time else: return -1"},{"question":"def rearrange_list(nums: List[int], pivot: int) -> List[int]: Rearrange the list such that all elements less than pivot come before elements equal to pivot, which come before elements greater than pivot. Maintains the relative order of elements within each group. Parameters: nums (list of int): The list of integers to be rearranged. pivot (int): The pivot element. Returns: list of int: The rearranged list. >>> rearrange_list([1, 2, 3, 4, 5], 3) [1, 2, 3, 4, 5] >>> rearrange_list([5, 1, 5, 3, 2, 3, 4], 3) [1, 2, 3, 3, 5, 5, 4] >>> rearrange_list([], 3) [] >>> rearrange_list([1, 1, 1, 1], 3) [1, 1, 1, 1] >>> rearrange_list([4, 4, 4], 3) [4, 4, 4] >>> rearrange_list([3, 3, 3], 3) [3, 3, 3] >>> rearrange_list([10, 5, 3, 8, 2, 1, 7], 5) [3, 2, 1, 5, 10, 8, 7] >>> rearrange_list([5], 5) [5] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def rearrange_list(nums, pivot): Rearrange the list such that all elements less than pivot come before elements equal to pivot, which come before elements greater than pivot. Maintains the relative order of elements within each group. Parameters: nums (list of int): The list of integers to be rearranged. pivot (int): The pivot element. Returns: list of int: The rearranged list. less_than = [num for num in nums if num < pivot] equal_to = [num for num in nums if num == pivot] greater_than = [num for num in nums if num > pivot] return less_than + equal_to + greater_than"},{"question":"import re def is_palindrome(s: str) -> bool: Determines if a string is a valid palindrome. A valid palindrome is a string that reads the same forward and backward, ignoring cases and removing all non-alphanumeric characters. Args: s (str): The input string. Returns: bool: True if the string is a valid palindrome, False otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\" \\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"Madam In Eden, I’m Adam\\") True >>> is_palindrome(\\"!@#%^&*()_+\\") True >>> is_palindrome(\\"Able,, ;; was I ere I saw eLba\\") True >>> is_palindrome(\\"\\") True","solution":"import re def is_palindrome(s): Determines if a string is a valid palindrome. A valid palindrome is a string that reads the same forward and backward, ignoring cases and removing all non-alphanumeric characters. Args: s (str): The input string. Returns: bool: True if the string is a valid palindrome, False otherwise. # Remove all non-alphanumeric characters and convert to lower case cleaned_str = re.sub(r'[^A-Za-z0-9]', '', s).lower() # Check if the cleaned string is equal to its reversed version return cleaned_str == cleaned_str[::-1]"},{"question":"from typing import List def min_operations_to_sort(A: List[int]) -> int: Returns the minimum number of operations needed to sort the array A in non-decreasing order. An operation consists of selecting a subarray and reversing it. >>> min_operations_to_sort([]) == 0 >>> min_operations_to_sort([1]) == 0 >>> min_operations_to_sort([1, 2, 3, 4, 5]) == 0 >>> min_operations_to_sort([5, 4, 3, 2, 1]) == 4 >>> min_operations_to_sort([3, 1, 2, 4, 5]) == 1 >>> min_operations_to_sort([3, 7, 8, 4, 2, 6, 5, 1]) == 5","solution":"def min_operations_to_sort(A): Returns the minimum number of operations needed to sort the array A in non-decreasing order. An operation consists of selecting a subarray and reversing it. if not A: return 0 n = len(A) lis = [1] * n # Compute the length of the Longest Increasing Subsequence (LIS) for i in range(1, n): for j in range(i): if A[i] >= A[j]: lis[i] = max(lis[i], lis[j] + 1) lis_length = max(lis) # The minimum operations required is the length of the array minus the length # of the LIS because it shows how many elements are already in order. return n - lis_length"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def split_list_to_parts(head: ListNode, k: int) -> list: Given a linked list, split it into k consecutive linked list parts. Each part should have a length as equal as possible. Args: head: ListNode - The head of the linked list to be split. k: int - The number of parts to split the linked list into. Returns: list: A list of ListNode objects, each representing the head of a split linked list part. Examples: >>> head = create_linked_list([1, 2, 3]) >>> k = 5 >>> parts = split_list_to_parts(head, k) >>> [[linked_list_to_list(part) if part else [] for part in parts]] [[1], [2], [3], [], []] >>> head = create_linked_list([1, 2, 3, 4]) >>> k = 2 >>> parts = split_list_to_parts(head, k) >>> [[linked_list_to_list(part) if part else [] for part in parts]] [[1, 2], [3, 4]] >>> head = create_linked_list([1, 2]) >>> k = 3 >>> parts = split_list_to_parts(head, k) >>> [[linked_list_to_list(part) if part else [] for part in parts]] [[1], [2], []] >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> k = 3 >>> parts = split_list_to_parts(head, k) >>> [[linked_list_to_list(part) if part else [] for part in parts]] [[1, 2], [3, 4], [5]] >>> head = None >>> k = 3 >>> parts = split_list_to_parts(head, k) >>> [[linked_list_to_list(part) if part else [] for part in parts]] [[], [], []]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def split_list_to_parts(head, k): def get_length(head): length = 0 while head: length += 1 head = head.next return length length = get_length(head) part_length = length // k extra = length % k parts = [] current = head for i in range(k): part_size = part_length + (1 if i < extra else 0) part_head, part_tail = None, None for j in range(part_size): if part_head is None: part_head = part_tail = ListNode(current.val) else: part_tail.next = ListNode(current.val) part_tail = part_tail.next if current: current = current.next parts.append(part_head) return parts"},{"question":"import re class HTMLParser: A class to parse HTML-like strings and extract attributes and content. >>> html = '<div class=\\"container\\" id=\\"main\\"><h1 class=\\"title\\">Hello</h1></div>' >>> parser = HTMLParser(html) >>> parser.getAttribute(\\"div\\", \\"class\\") 'container' >>> parser.getAttribute(\\"h1\\", \\"class\\") 'title' >>> parser.getAttribute(\\"div\\", \\"id\\") 'main' >>> parser.getAttribute(\\"h1\\", \\"id\\") None >>> parser.getContent(\\"h1\\") 'Hello' >>> parser.getContent(\\"div\\") '<h1 class=\\"title\\">Hello</h1>' >>> html = '<div><span class=\\"highlight\\">Nested <b>text</b></span></div>' >>> parser = HTMLParser(html) >>> parser.getContent(\\"span\\") 'Nested <b>text</b>' >>> parser.getAttribute(\\"span\\", \\"class\\") 'highlight' def __init__(self, html: str): Initializes the HTMLParser with the given HTML string. pass def getAttribute(self, tag: str, attribute: str) -> str: Returns the value of the specified attribute from the specified tag. pass def getContent(self, tag: str) -> str: Returns the content inside the specified tag in the HTML string. pass","solution":"import re class HTMLParser: def __init__(self, html): self.html = html def getAttribute(self, tag, attribute): pattern = f\\"<{tag}[^>]*b{attribute}=\\"([^\\"]*)\\"[^>]*>\\" match = re.search(pattern, self.html) if match: return match.group(1) return None def getContent(self, tag): pattern = f\\"<{tag}[^>]*>(.*?)</{tag}>\\" match = re.search(pattern, self.html, re.DOTALL) if match: return match.group(1) return None"},{"question":"def trap(height: List[int]) -> int: Returns the amount of water that can be collected between buildings. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([]) == 0 >>> trap([1, 1, 1, 1]) == 0 >>> trap([4, 1, 2]) == 1 >>> trap([1, 2, 3, 4]) == 0 >>> trap([3, 3, 3, 3, 3]) == 0 >>> trap([5]) == 0 >>> trap([5, 5]) == 0 >>> trap([5, 0, 5]) == 5 >>> trap([3, 0, 1, 3, 0, 5]) == 8 >>> trap([2, 1, 0, 2]) == 3","solution":"def trap(height): Returns the amount of water that can be collected between buildings. if not height: return 0 n = len(height) left = 0 right = n - 1 left_max = height[left] right_max = height[right] water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water += max(0, right_max - height[right]) return water"},{"question":"def max_sum_submatrix(mat): Returns the maximum sum of any rectangle in a 2D matrix. :param mat: List of List of integers representing the matrix :return: Integer representing the maximum rectangle sum >>> mat1 = [[1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6]] >>> max_sum_submatrix(mat1) 29 >>> mat2 = [[1, 2, 3], [-1, -2, -3], [1, 2, 3]] >>> max_sum_submatrix(mat2) 6 >>> mat3 = [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]] >>> max_sum_submatrix(mat3) -1 >>> mat4 = [[6]] >>> max_sum_submatrix(mat4) 6 >>> mat5 = [] >>> max_sum_submatrix(mat5) 0 >>> mat6 = [[1, -2, 3, 4]] >>> max_sum_submatrix(mat6) 7 >>> mat7 = [[1], [2], [-1], [4]] >>> max_sum_submatrix(mat7) 6","solution":"def max_sum_submatrix(mat): Returns the maximum sum of any rectangle in a 2D matrix. :param mat: List of List of integers representing the matrix :return: Integer representing the maximum rectangle sum if not mat or not mat[0]: return 0 m, n = len(mat), len(mat[0]) max_sum = float('-inf') for left in range(n): temp = [0] * m for right in range(left, n): for i in range(m): temp[i] += mat[i][right] max_sum = max(max_sum, max_sum_subarray(temp)) return max_sum def max_sum_subarray(arr): Helper function to find the maximum sum of a subarray in a 1D array using Kadane's algorithm. current_max = global_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"from typing import List def letter_combinations(s: str) -> List[str]: Given a string s containing digits from '2' to '9' inclusive, return all possible letter combinations that the number could represent in lexicographical order. The mapping of digit to letters is as follows: 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" Note that 1 does not map to any letters. The input string will have a length between 0 and 4. Examples: >>> letter_combinations('') [] >>> letter_combinations('2') ['a', 'b', 'c'] >>> letter_combinations('23') ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] pass","solution":"from itertools import product def letter_combinations(s): Returns all possible letter combinations that the number could represent in lexicographical order. if not s: return [] phone_map = { '2': \\"abc\\", '3': \\"def\\", '4': \\"ghi\\", '5': \\"jkl\\", '6': \\"mno\\", '7': \\"pqrs\\", '8': \\"tuv\\", '9': \\"wxyz\\" } chars = [phone_map[digit] for digit in s] combinations = [''.join(combo) for combo in product(*chars)] return sorted(combinations)"},{"question":"from typing import List, Tuple def find_peak(grid: List[List[int]]) -> Tuple[int, int]: Finds any one peak in a 2D grid where a peak is defined as a position which has a value greater than or equal to its four neighbors (left, right, above, below). Args: grid (list of list of int): The 2D grid of non-negative integers. Returns: tuple: Coordinates (i, j) of any one peak in the grid. >>> find_peak([[5]]) (0, 0) >>> find_peak([[1, 3], [2, 1]]) (0, 1) >>> find_peak([[10, 8, 10], [14, 13, 12], [15, 9, 11]]) (0, 2) >>> find_peak([[1, 2, 3], [4, 5, 6]]) (1, 2) >>> find_peak([[10, 20, 15], [21, 30, 14], [7, 16, 32]]) (2, 2)","solution":"def find_peak(grid): This function finds any one peak in a 2D grid where a peak is defined as a position which has a value greater than or equal to its four neighbors (left, right, above, below). Args: grid (list of list of int): The 2D grid of non-negative integers. Returns: tuple: Coordinates (i, j) of any one peak in the grid. m, n = len(grid), len(grid[0]) def is_peak(i, j): Helper function to check if a position (i, j) is a peak Args: i (int): Row coordinate. j (int): Column coordinate. Returns: bool: True if the position is a peak, False otherwise. neighbors = [] if i > 0: neighbors.append(grid[i - 1][j]) # above if i < m - 1: neighbors.append(grid[i + 1][j]) # below if j > 0: neighbors.append(grid[i][j - 1]) # left if j < n - 1: neighbors.append(grid[i][j + 1]) # right for neighbor in neighbors: if grid[i][j] < neighbor: return False return True for i in range(m): for j in range(n): if is_peak(i, j): return (i, j) return (-1, -1) # Return (-1, -1) if no peak found, which should not happen in this problem as per definition."},{"question":"import heapq from typing import List def shortest_path(n: int, edges: List[List[int]], start: int, end: int) -> int: Computes the shortest transmission time from start to end in a weighted, directed graph. :param n: Number of nodes (servers) :param edges: List of edges where each edge is represented as [ui, vi, weighti] :param start: Starting node :param end: Destination node :return: Shortest transmission time from start to end, or -1 if no such path exists >>> n = 5 >>> edges = [ ... [0, 1, 10], ... [1, 2, 5], ... [0, 3, 1], ... [3, 4, 2], ... [4, 2, 1] ... ] >>> start = 0 >>> end = 2 >>> shortest_path(n, edges, start, end) 4 >>> n = 3 >>> edges = [ ... [0, 1, 1], ... [1, 2, 1] ... ] >>> start = 2 >>> end = 0 >>> shortest_path(n, edges, start, end) -1 >>> n = 4 >>> edges = [ ... [0, 1, 1], ... [1, 2, 2], ... [2, 3, 1] ... ] >>> start = 1 >>> end = 1 >>> shortest_path(n, edges, start, end) 0 >>> n = 4 >>> edges = [ ... [0, 1, 1], ... [0, 2, 4], ... [1, 2, 2], ... [2, 3, 1], ... [1, 3, 6] ... ] >>> start = 0 >>> end = 3 >>> shortest_path(n, edges, start, end) 4 >>> n = 4 >>> edges = [ ... [0, 1, 1], ... [2, 3, 5] ... ] >>> start = 0 >>> end = 3 >>> shortest_path(n, edges, start, end) -1","solution":"import heapq def shortest_path(n, edges, start, end): Computes the shortest transmission time from start to end in a weighted, directed graph. :param n: Number of nodes (servers) :param edges: List of edges where each edge is represented as [ui, vi, weighti] :param start: Starting node :param end: Destination node :return: Shortest transmission time from start to end, or -1 if no such path exists graph = {i: [] for i in range(n)} for ui, vi, weight in edges: graph[ui].append((vi, weight)) pq = [(0, start)] # Priority queue to hold (current_time, current_node) dist = {i: float('inf') for i in range(n)} dist[start] = 0 while pq: current_time, current_node = heapq.heappop(pq) if current_node == end: return current_time if current_time > dist[current_node]: continue for neighbor, weight in graph[current_node]: time = current_time + weight if time < dist[neighbor]: dist[neighbor] = time heapq.heappush(pq, (time, neighbor)) return -1"},{"question":"def min_possible_max_height(heights: List[int], k: int) -> int: Returns the minimum possible maximum height after painting any k consecutive buildings. :param heights: List of integers representing the heights of buildings. :param k: Integer representing the number of consecutive buildings to consider. :return: Integer representing the minimum possible maximum height. >>> min_possible_max_height([4, 1, 3, 2, 5], 3) 3 >>> min_possible_max_height([5, 5, 5, 5, 5], 2) 5 >>> min_possible_max_height([4, 1, 7, 2], 1) 1 >>> min_possible_max_height([7, 4, 3, 1], 4) 7 >>> min_possible_max_height([100, 200, 300, 400, 500], 2) 200 >>> min_possible_max_height([5, 4, 3, 2, 1], 3) 3 >>> min_possible_max_height([1, 2, 3, 4, 5], 3) 3 pass","solution":"def min_possible_max_height(heights, k): Returns the minimum possible maximum height after painting any k consecutive buildings. :param heights: List of integers representing the heights of buildings. :param k: Integer representing the number of consecutive buildings to consider. :return: Integer representing the minimum possible maximum height. n = len(heights) min_max_height = float('inf') for i in range(n - k + 1): current_max_height = max(heights[i:i + k]) min_max_height = min(min_max_height, current_max_height) return min_max_height"},{"question":"def min_increasing_subseq_sum(arr): Returns the minimum sum of a non-empty increasing subsequence of arr. >>> min_increasing_subseq_sum([10]) 10 >>> min_increasing_subseq_sum([1, 2, 3, 4]) 1 >>> min_increasing_subseq_sum([4, 1, 6, 2, 3, 5]) 1 >>> min_increasing_subseq_sum([100, 10, 1000, 20, 30, 200]) 10 >>> min_increasing_subseq_sum([5, 4, 3, 2, 1]) 1 >>> min_increasing_subseq_sum([3, 3, 3, 3]) 3 >>> min_increasing_subseq_sum([]) 0 # Edge case, though problem states non-empty >>> min_increasing_subseq_sum([10, 22, 9, 33, 21, 50, 41, 60, 80]) 9","solution":"def min_increasing_subseq_sum(arr): Returns the minimum sum of a non-empty increasing subsequence of arr. if not arr: return 0 n = len(arr) min_sum = [float('inf')] * n # Initialize min_sum array with values of arr for i in range(n): min_sum[i] = arr[i] # Find the minimum sum of an increasing subsequence for i in range(1, n): for j in range(i): if arr[i] > arr[j] and min_sum[i] > arr[i] + min_sum[j]: min_sum[i] = arr[i] + min_sum[j] # The result is the minimum value in the min_sum array return min(min_sum)"},{"question":"class WordDictionary: A class which supports adding words and searching for words with '.' which can represent any letter. Example: wd = WordDictionary() wd.addWord(\\"bad\\") wd.addWord(\\"dad\\") wd.addWord(\\"mad\\") wd.search(\\"pad\\") # returns False wd.search(\\"bad\\") # returns True wd.search(\\".ad\\") # returns True wd.search(\\"b..\\") # returns True def __init__(self): pass def addWord(self, word): pass def search(self, word): pass","solution":"class WordDictionary: def __init__(self): self.dictionary = {} def addWord(self, word): node = self.dictionary for char in word: if char not in node: node[char] = {} node = node[char] node[''] = True # End of word marker def search(self, word): def search_in_node(word, node): for i, char in enumerate(word): if char == '.': for x in node: if x != '' and search_in_node(word[i+1:], node[x]): return True return False else: if char not in node: return False node = node[char] return '' in node return search_in_node(word, self.dictionary)"},{"question":"def decodeString(s: str) -> str: Decodes the given encoded string s as per the encoding rules. k[encoded_string]: The \`encoded_string\` inside the square brackets is repeated exactly \`k\` times. >>> decodeString(\\"3[a]2[bc]\\") 'aaabcbc' >>> decodeString(\\"3[a2[c]]\\") 'accaccacc' >>> decodeString(\\"2[abc]3[cd]ef\\") 'abcabccdcdcdef' >>> decodeString(\\"1[a]\\") 'a' >>> decodeString(\\"abc\\") 'abc' >>> decodeString(\\"2[3[a]b]\\") 'aaabaaab' >>> decodeString(\\"10[a]\\") 'aaaaaaaaaa'","solution":"def decodeString(s: str) -> str: Decodes the given encoded string s as per the encoding rules. stack = [] current_string = \\"\\" current_num = 0 for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == ']': previous_string, repeat_count = stack.pop() current_string = previous_string + current_string * repeat_count else: current_string += char return current_string"},{"question":"def max_subarray_sum(nums): Returns the sum of the subarray with the maximum possible sum. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-2, -3, -1, -5]) == -1 >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9 >>> max_subarray_sum([]) raises ValueError","solution":"def max_subarray_sum(nums): Returns the sum of the subarray with the maximum sum. if not nums: raise ValueError(\\"The input array is empty\\") max_sum = nums[0] current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_sum_subarray(arr: List[int], k: int) -> int: Returns the minimum sum of any contiguous subarray of length k. Parameters: arr (list): List of positive integers. k (int): Length of the subarray. Returns: int: Minimum sum of any contiguous subarray of length k. >>> min_sum_subarray([1, 2, 3, 4, 5], 1) 1 >>> min_sum_subarray([7, 3, 5, 2, 8, 1], 1) 1 >>> min_sum_subarray([1, 2, 3, 4, 5], 2) 3 >>> min_sum_subarray([7, 3, 5, 2, 8, 6], 3) 10 >>> min_sum_subarray([7, 3, 5, 2], 4) 17 >>> min_sum_subarray([4, 4, 4, 4, 4], 3) 12 >>> min_sum_subarray([10, 20, 3, 5, 2], 2) 7","solution":"def min_sum_subarray(arr, k): Returns the minimum sum of any contiguous subarray of length k. Parameters: arr (list): List of positive integers. k (int): Length of the subarray. Returns: int: Minimum sum of any contiguous subarray of length k. # Initial sum of the first subarray of length k min_sum = sum(arr[:k]) current_sum = min_sum # Slide the window over the array for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] if current_sum < min_sum: min_sum = current_sum return min_sum"},{"question":"def canCross(nums: List[int]) -> bool: Determine if you can cross the river by jumping from stone to stone on the given array of positions. >>> canCross([0]) True >>> canCross([0, 1]) True >>> canCross([0, 2]) False >>> canCross([0, 3, 5, 10]) False >>> canCross([0, 1, 3, 5, 6, 8, 12, 17]) True >>> canCross([0, 1, 2, 3, 5, 6, 8, 12, 17]) True >>> canCross([0, 1, 2, 3, 4, 8, 9, 11]) False >>> canCross([]) False >>> canCross([0, 1, 4, 5]) False","solution":"def canCross(nums): Determine if you can cross the river by jumping from stone to stone on the given array of positions. Parameters: nums (list): List of integers representing the positions of stones on a river. Returns: bool: True if you can cross the river, False otherwise. if not nums or nums[0] != 0: return False from collections import defaultdict positions = set(nums) jumps = {pos: set() for pos in nums} jumps[0].add(0) # starting position, previous jump was 0 for position in nums: for jump in jumps[position]: for new_jump in {jump - 1, jump, jump + 1}: if new_jump > 0 and (position + new_jump) in positions: jumps[position + new_jump].add(new_jump) return bool(jumps[nums[-1]])"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing +, -, *, and / (integer division). Parameters: expression (str): The expression string to be evaluated. Returns: int: The result of the evaluated expression. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"10-3*2\\") 4 >>> evaluate_expression(\\"10-3+2\\") 9 >>> evaluate_expression(\\"14/3*2\\") 8 >>> evaluate_expression(\\"14-3*2/1+3\\") 11 >>> evaluate_expression(\\"3+2*2-4/2\\") 5 >>> evaluate_expression(\\"3*4/2+2-5\\") 3 >>> evaluate_expression(\\"1+1+1+1+1*1/1\\") 5 >>> evaluate_expression(\\"100*2/2-100\\") 0","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing +, -, *, and / (integer division). Parameters: expression (str): The expression string to be evaluated. Returns: int: The result of the evaluated expression. # Initialize the variables stack = [] current_number = 0 operation = '+' # Iterate through each character in the string for i, char in enumerate(expression): if char.isdigit(): current_number = current_number * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if operation == '+': stack.append(current_number) elif operation == '-': stack.append(-current_number) elif operation == '*': stack.append(stack.pop() * current_number) elif operation == '/': stack.append(int(stack.pop() / current_number)) operation = char current_number = 0 # Sum up values in the stack return sum(stack)"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Given an \`m x n\` grid that represents fields, each cell contains an integer that represents the height of the field at that position. Find the longest increasing path in the field grid. The length of the path is defined by the number of cells it traverses. You can only move up, down, left, or right from a cell to an adjacent cell. The path cannot visit the same cell more than once. Return the length of the longest increasing path. >>> longest_increasing_path([]) == 0 >>> longest_increasing_path([[1]]) == 1 >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) == 4 >>> longest_increasing_path([ ... [3, 3, 3], ... [3, 3, 3], ... [3, 3, 3] ... ]) == 1 >>> longest_increasing_path([ ... [7, 7, 5], ... [8, 6, 4], ... [9, 2, 1] ... ]) == 5 >>> longest_increasing_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) == 4","solution":"def longest_increasing_path(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) cache = [[-1]*n for _ in range(m)] def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_length = 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) cache[x][y] = max_length return max_length max_path_len = 0 for i in range(m): for j in range(n): max_path_len = max(max_path_len, dfs(i, j)) return max_path_len"},{"question":"from collections import deque from typing import List, Tuple def shortest_path_maze(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Returns the length of the shortest path from start to end in the grid. Returns -1 if no such path exists. Parameters: grid (List[List[int]]): A 2D binary grid where 0 represents an empty cell and 1 represents a blocked cell. start (Tuple[int, int]): The starting coordinates in the grid. end (Tuple[int, int]): The ending coordinates in the grid. Returns: int: The length of the shortest path, or -1 if no valid path exists. Examples: >>> grid = [ ... [0, 0, 1], ... [0, 0, 1], ... [1, 0, 0]] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path_maze(grid, start, end) 4 >>> grid = [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0]] >>> start = (0, 0) >>> end = (2, 2) >>> shortest_path_maze(grid, start, end) -1","solution":"from collections import deque def shortest_path_maze(grid, start, end): Returns the length of the shortest path from start to end in the grid. Returns -1 if no such path exists. # Check if the start or end points are blocked if grid[start[0]][start[1]] == 1 or grid[end[0]][end[1]] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def smallest_subarray_with_target_sum(arr: List[int], target: int) -> int: Returns the length of the smallest subarray with a sum greater than or equal to target. If no such subarray exists, return 0. >>> smallest_subarray_with_target_sum([2, 1, 5, 2, 8], 7) 1 >>> smallest_subarray_with_target_sum([2, 1, 5, 2, 3, 2], 7) 2 >>> smallest_subarray_with_target_sum([3, 4, 1, 1, 6], 8) 3 >>> smallest_subarray_with_target_sum([1, 1, 1, 1, 1], 10) 0 >>> smallest_subarray_with_target_sum([1, 2, 3, 4, 5], 15) 5 >>> smallest_subarray_with_target_sum([10, 2, 3], 7) 1 >>> smallest_subarray_with_target_sum([5, 1, 2, 3], 5) 1 >>> smallest_subarray_with_target_sum([1, 2, 3, 4, 5], 11) 3 >>> smallest_subarray_with_target_sum([1, 2, 3, 4, 5], 9) 2","solution":"def smallest_subarray_with_target_sum(arr, target): Returns the length of the smallest subarray with a sum greater than or equal to target. If no such subarray exists, return 0. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0"},{"question":"from typing import List def can_rearrange_string(s: str, k: int) -> bool: You are given a string \`s\` consisting of lowercase English letters and an integer \`k\`. The string can be rearranged such that every \`k\` consecutive characters are unique. Return \`True\` if it is possible to rearrange the string in such a way, otherwise return \`False\`. >>> can_rearrange_string(\\"aabbcc\\", 3) True >>> can_rearrange_string(\\"aaabc\\", 3) False >>> can_rearrange_string(\\"aaadbbcc\\", 2) True >>> can_rearrange_string(\\"aabbcc\\", 0) True >>> can_rearrange_string(\\"a\\", 2) True >>> can_rearrange_string(\\"aa\\", 2) False","solution":"from collections import Counter from heapq import heapify, heappop, heappush def can_rearrange_string(s: str, k: int) -> bool: if k == 0: return True counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapify(max_heap) queue = [] result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) queue.append((freq + 1, char)) # decrement the frequency if len(queue) >= k: popped = queue.pop(0) if popped[0] < 0: heappush(max_heap, popped) return len(result) == len(s)"},{"question":"def min_operations_to_equalize(arr, k): Given a 0-indexed integer array arr and an integer k, this function returns the minimum number of operations required to make all elements in arr equal by either adding or subtracting k to any element. If it is impossible, it returns -1. from solution import min_operations_to_equalize def test_all_elements_equal(): assert min_operations_to_equalize([4, 4, 4], 3) == 0 def test_possible_operations(): assert min_operations_to_equalize([1, 3, 5], 2) == 0 assert min_operations_to_equalize([6, 10, 14], 4) == 0 def test_impossible_operations(): assert min_operations_to_equalize([1, 2, 3], 2) == -1 assert min_operations_to_equalize([1, 4, 6], 5) == -1 def test_single_element(): assert min_operations_to_equalize([7], 3) == 0 def test_large_difference_possible(): assert min_operations_to_equalize([0, 10, 20], 10) == 0 def test_large_difference_impossible(): assert min_operations_to_equalize([0, 10, 21], 10) == -1","solution":"def min_operations_to_equalize(arr, k): Given a 0-indexed integer array arr and an integer k, this function returns the minimum number of operations required to make all elements in arr equal by either adding or subtracting k to any element. If it is impossible, it returns -1. mod_set = set(element % k for element in arr) # All elements must have the same remainder when divided by k if len(mod_set) > 1: return -1 # All elements can be made equal, return 0 operations since they already contain the same residue mod k return 0"},{"question":"def min_swaps_to_identical(arr1, arr2): Returns the minimum number of swap operations needed to make arr1 and arr2 identical. If it is not possible to make the arrays identical, returns -1. >>> min_swaps_to_identical([1, 2, 3], [1, 2, 3]) == 0 >>> min_swaps_to_identical([1, 2, 3], [1, 3, 2]) == 1 >>> min_swaps_to_identical([1, 2, 3, 4], [4, 3, 2, 1]) == 2 >>> min_swaps_to_identical([1, 2, 3], [4, 5, 6]) == -1 >>> min_swaps_to_identical([1, 1, 2, 2], [2, 2, 1, 1]) == 2 >>> min_swaps_to_identical([1, 2, 3, 4], [1, 2, 3, 4]) == 0","solution":"def min_swaps_to_identical(arr1, arr2): Returns the minimum number of swap operations needed to make arr1 and arr2 identical. If it is not possible to make the arrays identical, returns -1. if sorted(arr1) != sorted(arr2): return -1 n = len(arr1) count = 0 for i in range(n): if arr1[i] != arr2[i]: target_index = arr2.index(arr1[i], i) arr2[i], arr2[target_index] = arr2[target_index], arr2[i] count += 1 return count"},{"question":"def word_break(s: str, wordDict: List[str]) -> List[str]: Add spaces in \`s\` to construct a sentence where each word is a valid dictionary word. >>> word_break(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cats and dog\\", \\"cat sand dog\\"] >>> word_break(\\"hello\\", [\\"hello\\"]) [\\"hello\\"] >>> word_break(\\"abcd\\", [\\"a\\", \\"b\\", \\"c\\"]) [] >>> word_break(\\"applepie\\", [\\"apple\\", \\"pie\\"]) [\\"apple pie\\"] >>> word_break(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] pass","solution":"def word_break(s, wordDict): def backtrack(index, path): if index == len(s): result.append(\\" \\".join(path)) return for end in range(index + 1, len(s) + 1): word = s[index:end] if word in wordDict: backtrack(end, path + [word]) wordSet = set(wordDict) result = [] backtrack(0, []) return result"},{"question":"class TextEditor: A text editor that allows users to perform different operations on a string \`s\` which is initially empty. The operations supported by the editor are: - Append a new character - Delete the last character - Replace a character at a specified position - Undo the last operation >>> editor = TextEditor() >>> editor.append('a') >>> editor.getContent() == 'a' >>> editor.append('b') >>> editor.getContent() == 'ab' >>> editor.delete() >>> editor.getContent() == 'a' >>> editor.append('c') >>> editor.replace(2, 'x') >>> editor.getContent() == 'ax' >>> editor.undo() >>> editor.getContent() == 'ac' def __init__(self): # Implementation here def append(self, c): # Implementation here def delete(self): # Implementation here def replace(self, position, c): # Implementation here def undo(self): # Implementation here def getContent(self): # Implementation here","solution":"class TextEditor: def __init__(self): self.content = [] self.history = [] def append(self, c): self.history.append(('delete', len(self.content))) self.content.append(c) def delete(self): if self.content: last_char = self.content.pop() self.history.append(('append', last_char)) def replace(self, position, c): if 1 <= position <= len(self.content): old_char = self.content[position-1] self.content[position-1] = c self.history.append(('replace', position, old_char)) def undo(self): if self.history: last_operation = self.history.pop() if last_operation[0] == 'append': self.content.append(last_operation[1]) elif last_operation[0] == 'delete': del self.content[last_operation[1]:] elif last_operation[0] == 'replace': self.content[last_operation[1]-1] = last_operation[2] def getContent(self): return ''.join(self.content)"},{"question":"def max_board_surface_area(pillars): Returns the maximum surface area covered by boards placed on top of the pillars. A board can be placed on top of consecutive pillars that are of the same height. >>> max_board_surface_area([]) == 0 >>> max_board_surface_area([5]) == 5 >>> max_board_surface_area([3, 3, 3, 3]) == 12 >>> max_board_surface_area([1, 2, 2, 3, 3, 3, 2, 2, 1]) == 9 >>> max_board_surface_area([1, 2, 3, 4, 5]) == 5 >>> max_board_surface_area([1, 1, 1, 2, 2, 3, 3, 3, 3, 2, 2]) == 12 >>> max_board_surface_area([5, 5, 1, 5, 5, 6, 6, 6, 6, 1, 1, 2, 3, 4]) == 24","solution":"def max_board_surface_area(pillars): Returns the maximum surface area covered by boards placed on top of the pillars. A board can be placed on top of consecutive pillars that are of the same height. if not pillars: return 0 max_area = 0 current_height = pillars[0] current_length = 1 for i in range(1, len(pillars)): if pillars[i] == current_height: current_length += 1 else: max_area = max(max_area, current_height * current_length) current_height = pillars[i] current_length = 1 max_area = max(max_area, current_height * current_length) return max_area"},{"question":"def count_ongoing_events(events: List[List[int]], q: int) -> int: Returns the number of events ongoing at time q. An event is considered ongoing if startTimei <= q <= endTimei. Parameters: events (list of lists): A list of events where each event is represented as [startTime, endTime] q (int): The query time to check the number of ongoing events. Returns: int: The number of ongoing events at time q. >>> count_ongoing_events([[1, 2], [3, 4]], 5) == 0 >>> count_ongoing_events([[1, 2], [3, 4]], 0) == 0 >>> count_ongoing_events([[1, 2], [3, 4]], 1) == 1 >>> count_ongoing_events([[1, 2], [3, 4]], 4) == 1 >>> count_ongoing_events([[1, 3], [2, 4], [5, 7]], 3) == 2 >>> count_ongoing_events([[1, 5], [2, 6], [4, 8]], 5) == 3 >>> count_ongoing_events([[1, 5], [2, 6]], 5) == 2 >>> count_ongoing_events([[1, 3], [3, 5]], 3) == 2 >>> count_ongoing_events([[1, 1], [2, 2]], 1) == 1","solution":"def count_ongoing_events(events, q): Returns the number of events ongoing at time q. An event is considered ongoing if startTimei <= q <= endTimei. Parameters: events (list of lists): A list of events where each event is represented as [startTime, endTime] q (int): The query time to check the number of ongoing events. Returns: int: The number of ongoing events at time q. return sum(start <= q <= end for start, end in events)"},{"question":"def max_area_trapped_water(heights: List[int]) -> int: Given an array of integers representing the heights of buildings on a street, where the width of each building is 1 unit, compute the maximum area of water that can be trapped between two buildings after raining. The water cannot spill over the edges of the array, and each building must be able to support as much water as possible without collapsing. >>> max_area_trapped_water([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area_trapped_water([1, 1]) 1 >>> max_area_trapped_water([4, 4, 4, 4, 4]) 16 >>> max_area_trapped_water([5, 4, 3, 2, 1]) 6 >>> max_area_trapped_water([1, 2, 3, 4, 5]) 6 >>> max_area_trapped_water([5]) 0 >>> max_area_trapped_water([]) 0","solution":"def max_area_trapped_water(heights): Returns the maximum area of water that can be trapped between the buildings. :param heights: List[int] - A list of integers representing the heights of buildings. :return: int - The maximum area of water trapped. left, right = 0, len(heights) - 1 max_area = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_area = max(max_area, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area"},{"question":"def longest_increasing_streak(visitors): Returns the length of the longest increasing subsequence of consecutive days. :param visitors: List[int] - a list where each element represents the number of visitors on a different day. :return: int - the length of the longest increasing subsequence of consecutive days. >>> longest_increasing_streak([]) == 0 >>> longest_increasing_streak([5]) == 1 >>> longest_increasing_streak([3, 3, 3, 3]) == 1 >>> longest_increasing_streak([1, 2, 3, 4, 5]) == 5 >>> longest_increasing_streak([5, 4, 3, 2, 1]) == 1 >>> longest_increasing_streak([1, 3, 2, 4, 6, 3, 5]) == 3 >>> longest_increasing_streak([1, 2, 1, 2, 3, 1, 2, 3, 4]) == 4 >>> longest_increasing_streak([5, 1, 2, 3, 4, 1, 2, 1, 4, 5]) == 4 >>> longest_increasing_streak([1, 2, 3, 4, 2, 3, 4, 5]) == 4 # Placeholder to complete the implementation pass","solution":"def longest_increasing_streak(visitors): Returns the length of the longest increasing subsequence of consecutive days. :param visitors: List[int] - a list where each element represents the number of visitors on a different day. :return: int - the length of the longest increasing subsequence of consecutive days. if not visitors: return 0 longest_streak = 1 current_streak = 1 for i in range(1, len(visitors)): if visitors[i] > visitors[i - 1]: current_streak += 1 longest_streak = max(longest_streak, current_streak) else: current_streak = 1 return longest_streak"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given the root of a binary tree, returns all root-to-leaf paths. >>> root = TreeNode(1) >>> binary_tree_paths(root) [[1]] >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> binary_tree_paths(root) [[1, 2], [1, 3]] >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, None, TreeNode(5))) >>> binary_tree_paths(root) [[1, 2, 4], [1, 3, 5]] >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> binary_tree_paths(root) [[1, 2, 3, 4]] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4)))) >>> binary_tree_paths(root) [[1, 2, 3, 4]] >>> root = None >>> binary_tree_paths(root) [] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6, TreeNode(7)))) >>> binary_tree_paths(root) [[1, 2, 4], [1, 2, 5], [1, 3, 6, 7]]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Given the root of a binary tree, returns all root-to-leaf paths. def dfs(node, path, paths): if not node: return path.append(node.val) if not node.left and not node.right: # Current node is a leaf paths.append(list(path)) else: dfs(node.left, path, paths) dfs(node.right, path, paths) path.pop() # Backtrack paths = [] dfs(root, [], paths) return paths"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers that add up to the target. Args: nums : List[int] : List of integers target : int : Target sum Returns: List[int] : List of two indices of the numbers that add up to the target Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2]","solution":"def two_sum(nums, target): Returns indices of the two numbers that add up to the target. Args: nums : List[int] : List of integers target : int : Target sum Returns: List[int] : List of two indices of the numbers that add up to the target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], index] num_to_index[num] = index return []"},{"question":"def reverse_bits(bits: str) -> str: Reverses all the bits in a binary string. Parameters: bits (str): The input binary string. Returns: str: The reversed binary string. pass # Unit Tests def test_reverse_bits_all_ones(): assert reverse_bits('11111') == '00000' def test_reverse_bits_all_zeros(): assert reverse_bits('00000') == '11111' def test_reverse_bits_mixed(): assert reverse_bits('10101') == '01010' assert reverse_bits('110011') == '001100' def test_reverse_bits_single_bit(): assert reverse_bits('1') == '0' assert reverse_bits('0') == '1' def test_reverse_bits_empty_string(): assert reverse_bits('') == ''","solution":"def reverse_bits(bits): Reverses all the bits in a binary string. Parameters: bits (str): The input binary string. Returns: str: The reversed binary string. return ''.join('1' if bit == '0' else '0' for bit in bits)"},{"question":"def count_connected_components(n: int, edges: List[List[int]]) -> int: In a social network, users are represented as nodes, and friendships are represented as undirected edges between nodes. Returns the number of connected components in the network. >>> count_connected_components(5, []) == 5 >>> count_connected_components(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) == 1 >>> count_connected_components(5, [[0, 1], [2, 3]]) == 3 >>> count_connected_components(4, [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]) == 1 >>> count_connected_components(6, [[0, 1], [2, 3], [4, 5]]) == 3 >>> count_connected_components(1, []) == 1 >>> count_connected_components(3, [[0, 1], [1, 2], [2, 0]]) == 1","solution":"def count_connected_components(n, edges): def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) adj_list = {i: [] for i in range(n)} for a, b in edges: adj_list[a].append(b) adj_list[b].append(a) visited = set() components = 0 for node in range(n): if node not in visited: visited.add(node) dfs(node, visited, adj_list) components += 1 return components"},{"question":"from typing import List, Optional def most_frequent_element(nums: List[int]) -> Optional[int]: Given an array of integers nums, find the most frequent element in the array. If there are multiple elements with the same highest frequency, return the smallest element among them. Returns the most frequent element. If the array is empty, return None. >>> most_frequent_element([1]) 1 >>> most_frequent_element([1, 2, 2, 3, 1]) 1 >>> most_frequent_element([4, 1, 2, 2, 4, 4, 1, 1]) 1 >>> most_frequent_element([]) None >>> most_frequent_element([100, 200, 300, 100, 200, 100, 300]) 100 >>> most_frequent_element([-1, -1, -2, 2, -2, 2, -1]) -1 >>> most_frequent_element([5, 5, 5, 5, 5]) 5 pass","solution":"from collections import Counter def most_frequent_element(nums): Returns the most frequent element in the array. In case of a tie, returns the smallest element among the most frequent ones. if not nums: return None count = Counter(nums) max_frequency = max(count.values()) most_frequent_elements = [num for num, freq in count.items() if freq == max_frequency] return min(most_frequent_elements)"},{"question":"from collections import Counter from heapq import heappop, heappush from typing import List def reorganize_string(s: str) -> str: Rearrange the string such that no two adjacent characters are the same. If it is not possible, return an empty string. :param s: A string with lowercase alphabets :return: Reorganized string or empty string if it's not possible >>> reorganize_string(\\"aab\\") in [\\"aba\\"] True >>> reorganize_string(\\"aaabbb\\") in [\\"ababab\\", \\"bababa\\"] True >>> reorganize_string(\\"aabbcc\\") in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\"] True >>> reorganize_string(\\"aaab\\") == \\"\\" True >>> reorganize_string(\\"aaaa\\") == \\"\\" True >>> reorganize_string(\\"a\\") == \\"a\\" True >>> reorganize_string(\\"abab\\") in [\\"abab\\", \\"baba\\"] True >>> reorganize_string(\\"\\") == \\"\\" True","solution":"from collections import Counter from heapq import heappop, heappush def reorganize_string(s): Rearrange the string such that no two adjacent characters are the same. If it is not possible, return an empty string. :param s: A string with lowercase alphabets :return: Reorganized string or empty string if it's not possible counter = Counter(s) max_heap = [] # Build a max heap based on character frequencies for char, freq in counter.items(): heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, \\"\\" result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) # If the previous character needs to be pushed back into the heap, do that if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char # decrement the frequency result_str = ''.join(result) # Check if the resulting string length matches the input string length if len(result_str) == len(s): return result_str else: return ''"},{"question":"from typing import List def maxLeafPathSum(n: int, edges: List[List[int]], values: List[int]) -> int: Find the maximum sum of values starting from node 0 and traversing to any leaf node. >>> maxLeafPathSum(3, [[0, 1], [0, 2]], [1, 2, 3]) 4 >>> maxLeafPathSum(4, [[0, 1], [1, 2], [2, 3]], [1, 2, 3, 4]) 10 >>> maxLeafPathSum(7, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]], [1, 2, 3, 4, 5, 6, 7]) 11 >>> maxLeafPathSum(5, [[0, 1], [0, 2], [1, 3], [3, 4]], [1, 2, 3, 4, 5]) 12 >>> maxLeafPathSum(1, [], [42]) 42","solution":"def maxLeafPathSum(n, edges, values): from collections import defaultdict def dfs(node, parent): max_sum = values[node] leaf = True for neighbor in tree[node]: if neighbor != parent: leaf = False max_sum = max(max_sum, values[node] + dfs(neighbor, node)) return max_sum # Create the adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Start DFS from the root node 0 return dfs(0, -1)"},{"question":"from typing import List def can_visit_m_nodes(n: int, m: int, edges: List[List[int]]) -> bool: Determine if there exists a path that visits exactly m different nodes in an undirected graph. >>> can_visit_m_nodes(4, 3, [[0, 1], [0, 2], [1, 2], [1, 3]]) True >>> can_visit_m_nodes(4, 4, [[0, 1], [0, 2], [1, 2], [1, 3]]) True >>> can_visit_m_nodes(4, 2, [[0, 1], [0, 2], [1, 2], [1, 3]]) True >>> can_visit_m_nodes(4, 5, [[0, 1], [0, 2], [1, 2], [1, 3]]) False >>> can_visit_m_nodes(6, 3, [[0, 1], [2, 3], [4, 5]]) False >>> can_visit_m_nodes(6, 2, [[0, 1], [2, 3], [4, 5]]) True >>> can_visit_m_nodes(1, 1, []) True >>> can_visit_m_nodes(1, 2, []) False >>> can_visit_m_nodes(3, 1, []) True >>> can_visit_m_nodes(3, 2, []) False","solution":"def can_visit_m_nodes(n, m, edges): from collections import defaultdict, deque if m > n: return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def bfs(start_node): visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) if len(visited) == m: return True return len(visited) == m for i in range(n): if bfs(i): return True return False"},{"question":"def max_subarray_sum(nums: List[int], window_size: int) -> int: Returns the maximum sum of any subarray of size window_size in nums. If window_size is larger than the array size, return -1. >>> max_subarray_sum([1, 2, 3, 4, 5], 3) 12 >>> max_subarray_sum([1, 2, -1, 4, 5], 2) 9 >>> max_subarray_sum([4, 3, -2, 6, 7], 3) 11 >>> max_subarray_sum([1, 2], 3) -1 >>> max_subarray_sum([1, 2, 3], 3) 6 >>> max_subarray_sum([1, 2, -3, 4, 5], 3) 6 >>> max_subarray_sum([-1, -2, -3, -4, -5], 2) -3 >>> max_subarray_sum([3], 1) 3 >>> max_subarray_sum([], 1) -1","solution":"def max_subarray_sum(nums, window_size): Returns the maximum sum of any subarray of size window_size in nums. If window_size is larger than the array size, return -1. n = len(nums) if window_size > n: return -1 # Calculate the sum of the first window max_sum = sum(nums[:window_size]) current_sum = max_sum # Slide the window over the array for i in range(window_size, n): current_sum += nums[i] - nums[i - window_size] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_items(nums: List[int], coin_count: int) -> int: Returns the maximum number of items that can be bought with the given coin_count. Args: nums (List[int]): List of integers representing the cost of items. coin_count (int): Number of coins available. Returns: int: Maximum number of items that can be bought. >>> max_items([], 10) 0 >>> max_items([10, 20, 30], 5) 0 >>> max_items([2, 3, 5], 10) 3 >>> max_items([1, 3, 2, 5, 4], 9) 3 >>> max_items([4, 2, 3, 1], 5) 2 >>> max_items(list(range(1, 10001)), 5000) 99","solution":"def max_items(nums, coin_count): Returns the maximum number of items that can be bought with the given coin_count. Args: nums (List[int]): List of integers representing the cost of items. coin_count (int): Number of coins available. Returns: int: Maximum number of items that can be bought. nums.sort() total_cost = 0 count = 0 for cost in nums: if total_cost + cost <= coin_count: total_cost += cost count += 1 else: break return count"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Find the area of the largest rectangle that can be formed in a histogram. The function takes a list of non-negative integers where each element represents the height of a building. The width of each building is 1. It returns the area of the largest rectangle that can be formed using these buildings without any gaps. Parameters: heights (List[int]): List of non-negative integers representing building heights. Returns: int: The area of the largest rectangle. Examples: >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([4, 4, 4, 4]) 16 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([2, 1, 2, 1, 2]) 5","solution":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Find the area of the largest rectangle that can be formed in a histogram. Parameters: heights (List[int]): List of non-negative integers representing building heights. Returns: int: The area of the largest rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): # If the stack is empty or the current bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def isPalindrome(head: ListNode) -> bool: Checks if the linked list is a palindrome. >>> linked_list_from_list([1, 2, 2, 1]) True >>> linked_list_from_list([1, 2, 3, 2, 1]) True >>> linked_list_from_list([1, 2, 3, 4, 5]) False >>> linked_list_from_list([1]) True >>> linked_list_from_list([1, 1]) True >>> linked_list_from_list([1, 2]) False pass def linked_list_from_list(values): if not values: return None head = ListNode(values[0]) curr = head for value in values[1:]: curr.next = ListNode(value) curr = curr.next return head","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def isPalindrome(head: ListNode) -> bool: Checks if the linked list is a palindrome. vals = [] curr = head while curr is not None: vals.append(curr.val) curr = curr.next return vals == vals[::-1]"},{"question":"def min_concatenations(words: List[str], target: str) -> int: Returns the minimum number of concatenations needed to form the target string using the words from the list. Returns -1 if it is not possible. >>> min_concatenations([\\"ab\\", \\"bc\\", \\"a\\"], \\"abc\\") 2 >>> min_concatenations([\\"apple\\", \\"pie\\"], \\"applepiee\\") -1 >>> min_concatenations([\\"single\\"], \\"single\\") 1 >>> min_concatenations([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaa\\") 2 >>> min_concatenations([], \\"\\") 0 >>> min_concatenations([\\"any\\", \\"words\\"], \\"\\") 0 >>> min_concatenations([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"], \\"aaaaaaaaaaaa\\") 3","solution":"from collections import defaultdict, deque def min_concatenations(words, target): Returns the minimum number of concatenations needed to form the target string using the words from the list. Returns -1 if it is not possible. word_set = set(words) memo = {} def solve(t): if t == '': return 0 if t in memo: return memo[t] min_concats = float('inf') for word in word_set: if t.startswith(word): remaining = t[len(word):] result = solve(remaining) if result != -1: min_concats = min(min_concats, 1 + result) min_concats = min_concats if min_concats != float('inf') else -1 memo[t] = min_concats return min_concats return solve(target)"},{"question":"def distinct_strings(s: str) -> int: Returns the number of distinct strings that can be obtained by performing the given operation any number of times on the input string s. >>> distinct_strings(\\"aaa\\") == 1 >>> distinct_strings(\\"aabb\\") == 2 >>> distinct_strings(\\"abc\\") == 3","solution":"def distinct_strings(s): Returns the number of distinct strings that can be obtained by performing the given operation any number of times on the input string s. distinct_chars = set(s) return len(distinct_chars)"},{"question":"def minimizeMaxWorkload(tasks: List[int], k: int) -> int: Given a list of non-negative integers representing the amount of time taken by each task, and an integer 'k' representing the number of workers available to complete these tasks, return the minimum possible maximum workload whenever the tasks are distributed optimally among the workers. Each worker must be assigned at least one task, and the goal is to minimize the maximum time any single worker has to spend. >>> minimizeMaxWorkload([10, 20, 30, 40], 2) 60 >>> minimizeMaxWorkload([15], 1) 15 >>> minimizeMaxWorkload([10, 10, 10, 10], 2) 20 >>> minimizeMaxWorkload([7, 2, 5, 10, 8], 2) 18 >>> minimizeMaxWorkload([5, 5, 5, 5], 4) 5 >>> minimizeMaxWorkload([100, 300, 200, 400], 3) 400","solution":"def canDistribute(tasks, k, max_workload): current_workers = 1 current_load = 0 for task in tasks: if current_load + task <= max_workload: current_load += task else: current_workers += 1 current_load = task if current_workers > k: return False return True def minimizeMaxWorkload(tasks, k): low = max(tasks) high = sum(tasks) result = high while low <= high: mid = (low + high) // 2 if canDistribute(tasks, k, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def count_votes(arr: list) -> list: Given an array of integers \`arr\` where each element in the array represents a vote cast for a particular candidate, return a list containing the counts of votes for each candidate from 1 to n. Parameters: arr (list): A list of integers representing votes for candidates. Returns: list: A list where the ith element is the number of votes for the (i+1)th candidate. >>> count_votes([1, 2, 3, 1, 2, 3, 3, 3]) [2, 2, 4] >>> count_votes([1, 2, 1, 2, 2]) [2, 3] >>> count_votes([1, 1, 1]) [3]","solution":"def count_votes(arr): Given an array of integers \`arr\` where each element in the array represents a vote cast for a particular candidate, return a list containing the counts of votes for each candidate from 1 to n. Parameters: arr (list): A list of integers representing votes for candidates. Returns: list: A list where the ith element is the number of votes for the (i+1)th candidate. # Find the number of candidates n = max(arr) # Initialize result array with zero votes for each candidate result = [0] * n # Count votes for each candidate for vote in arr: result[vote - 1] += 1 return result"},{"question":"def minimum_deletions(s: str, t: str) -> int: Returns the minimum number of deletions required from \`s\` to obtain \`t\` as a subsequence. If it is not possible to form \`t\` from \`s\`, returns -1. :param s: String from which characters can be deleted. :param t: Target subsequence to achieve. :return: Minimum number of deletions required, or -1 if not possible. >>> minimum_deletions(\\"abcde\\", \\"ace\\") == 2 >>> minimum_deletions(\\"abc\\", \\"abc\\") == 0 >>> minimum_deletions(\\"abc\\", \\"ab\\") == 1 >>> minimum_deletions(\\"abcd\\", \\"acd\\") == 1 >>> minimum_deletions(\\"abcde\\", \\"fgh\\") == -1 >>> minimum_deletions(\\"abcde\\", \\"\\") == 5 >>> minimum_deletions(\\"\\", \\"\\") == 0 >>> minimum_deletions(\\"ab\\", \\"abc\\") == -1","solution":"def minimum_deletions(s, t): Returns the minimum number of deletions required from \`s\` to obtain \`t\` as a subsequence. If it is not possible to form \`t\` from \`s\`, returns -1. :param s: String from which characters can be deleted. :param t: Target subsequence to achieve. :return: Minimum number of deletions required, or -1 if not possible. m, n = len(s), len(t) j = 0 for i in range(m): if j < n and s[i] == t[j]: j += 1 if j == n: return m - n return -1"},{"question":"def max_rect_area(heights): Returns the maximum area of a rectangular section that can be formed using adjacent buildings. :param heights: List of integers representing the heights of buildings. :return: Integer representing the maximum rectangular area. >>> max_rect_area([5]) 5 >>> max_rect_area([3, 3, 3]) 9 >>> max_rect_area([1, 2, 3, 4, 5]) 9 >>> max_rect_area([5, 4, 3, 2, 1]) 9 >>> max_rect_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rect_area([2, 4, 2, 1]) 6 >>> max_rect_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> max_rect_area([]) 0 >>> max_rect_area([1, 2, 3, 4, 5, 6]) 12","solution":"def max_rect_area(heights): Returns the maximum area of a rectangular section that can be formed using adjacent buildings. :param heights: List of integers representing the heights of buildings. :return: Integer representing the maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top = stack.pop() area = (heights[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top = stack.pop() area = (heights[top] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def split_array_min_largest_sum(arr: List[int], k: int) -> int: Split the array \`arr\` into \`k\` non-empty subarrays such that the largest sum of any subarray is minimized. >>> split_array_min_largest_sum([1], 1) 1 >>> split_array_min_largest_sum([1, 2, 3, 4, 5], 1) 15 >>> split_array_min_largest_sum([1, 2, 3, 4, 5], 5) 5 >>> split_array_min_largest_sum([7, 2, 5, 10, 8], 2) 18 >>> split_array_min_largest_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> split_array_min_largest_sum([1, 4, 4], 3) 4","solution":"def split_array_min_largest_sum(arr, k): Split the array \`arr\` into \`k\` non-empty subarrays such that the largest sum of any subarray is minimized. def can_split(nums, m, max_sum): count, current_sum = 1, 0 for num in nums: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(arr, k, mid): right = mid else: left = mid + 1 return left"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Write a function that takes a string \`s\` containing only digits and returns all possible valid IP addresses that can be obtained by inserting three dots in \`s\`. Each segment of the IP address must be between 0 and 255 (inclusive) and should not contain leading zeros unless the segment is exactly '0'. Return the valid IP addresses as a list of strings in their original order found in the input string. >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> restore_ip_addresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] >>> restore_ip_addresses(\\"999999999999\\") []","solution":"def restore_ip_addresses(s): def is_valid(segment): Check if a segment is a valid IP address segment. return int(segment) <= 255 and (segment == \\"0\\" or not segment.startswith(\\"0\\")) def backtrack(start, path): if len(path) == 4: if start == len(s): result.append(\\".\\".join(path)) return for length in range(1, 4): if start + length <= len(s): segment = s[start:start + length] if is_valid(segment): backtrack(start + length, path + [segment]) result = [] backtrack(0, []) return result"},{"question":"def reverse_letters(s: str) -> str: Returns a string where every letter in the input string \`s\` is reversed, but the position of the digits is preserved. >>> reverse_letters(\\"a1b2cde3\\") \\"e1d2cba3\\" >>> reverse_letters(\\"abcdef\\") \\"fedcba\\" >>> reverse_letters(\\"123456\\") \\"123456\\" >>> reverse_letters(\\"a1B2c3D4\\") \\"D1c2B3a4\\" >>> reverse_letters(\\"\\") \\"\\" >>> reverse_letters(\\"abcXYZ\\") \\"ZYXcba\\" >>> reverse_letters(\\"123456\\") \\"123456\\" >>> reverse_letters(\\"a\\") \\"a\\" >>> reverse_letters(\\"1\\") \\"1\\"","solution":"def reverse_letters(s): Returns a string where every letter in the input string \`s\` is reversed, but the position of the digits is preserved. # Extract only the letters from the string, reverse them letters = [char for char in s if char.isalpha()][::-1] # Use a list to store the result result = [] # Iterate through the original string letter_index = 0 for char in s: if char.isalpha(): # Append the letters from the reversed list result.append(letters[letter_index]) letter_index += 1 else: # Append the digits directly result.append(char) return ''.join(result)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longestConsecutivePath(root: TreeNode) -> int: Given a binary tree, determine the length of the longest sequence of nodes such that the values of successive nodes in the sequence increase by one. >>> root = TreeNode(3) >>> root.left = TreeNode(2) >>> root.right = TreeNode(4) >>> root.right.right = TreeNode(5) >>> longestConsecutivePath(root) 3 >>> root = TreeNode(3) >>> root.left = TreeNode(2) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(5) >>> root.right.right.right = TreeNode(6) >>> longestConsecutivePath(root) 4","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longestConsecutivePath(root): if not root: return 0 def dfs(node, parent, length): if not node: return length if parent and node.value == parent.value + 1: length += 1 else: length = 1 left_length = dfs(node.left, node, length) right_length = dfs(node.right, node, length) return max(length, left_length, right_length) return dfs(root, None, 0)"},{"question":"from typing import List def shortest_path(matrix: List[List[int]]) -> int: Find the length of the shortest path from the top-left corner (0,0) to the bottom-right corner (n-1,m-1) in a matrix avoiding obstacles. If there is no possible path, return -1. :param matrix: List[List[int]] :return: int >>> shortest_path([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 4 >>> shortest_path([ ... [0, 1], ... [1, 0] ... ]) -1 >>> shortest_path([]) -1 >>> shortest_path([ ... [0, 0], ... [0, 0] ... ]) 2 >>> shortest_path([ ... [0, 0, 0, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 0, 0] ... ]) 6","solution":"from collections import deque def shortest_path(matrix): Find the shortest path from top-left to bottom-right corner in a matrix avoiding obstacles. :param matrix: List[List[int]] :return: int if not matrix or not matrix[0] or matrix[0][0] == 1 or matrix[-1][-1] == 1: return -1 n = len(matrix) m = len(matrix[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Determine the length of the longest substring that contains at most k distinct characters. >>> length_of_longest_substring_k_distinct(\\"\\", 1) == 0 >>> length_of_longest_substring_k_distinct(\\"abc\\", 0) == 0 >>> length_of_longest_substring_k_distinct(\\"a\\", 1) == 1 >>> length_of_longest_substring_k_distinct(\\"a\\", 2) == 1 >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) == 3 >>> length_of_longest_substring_k_distinct(\\"aa\\", 1) == 2 >>> length_of_longest_substring_k_distinct(\\"abc\\", 2) == 2 >>> length_of_longest_substring_k_distinct(\\"a\\" * 10**6, 1) == 10**6 >>> length_of_longest_substring_k_distinct(\\"abc\\" * 10**5, 5) == len(\\"abc\\" * 10**5)","solution":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: if k == 0 or not s: return 0 from collections import defaultdict left = 0 right = 0 char_count = defaultdict(int) max_length = 0 while right < len(s): char_count[s[right]] += 1 right += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def sunset_buildings(heights): Determines the indices of the buildings that can see the sunset. Args: heights (list of int): Heights of the buildings. Returns: list of int: Indices of the buildings that can see the sunset. >>> sunset_buildings([3, 7, 8, 3, 6, 1]) == [2, 4, 5] >>> sunset_buildings([1, 2, 3, 4, 5]) == [4] >>> sunset_buildings([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4] >>> sunset_buildings([3, 3, 3, 3, 3]) == [4] >>> sunset_buildings([]) == [] >>> sunset_buildings([10, 8, 6, 4, 2]) == [0, 1, 2, 3, 4] >>> sunset_buildings([10]) == [0] >>> sunset_buildings([1]) == [0]","solution":"def sunset_buildings(heights): Determines the indices of the buildings that can see the sunset. Args: heights (list of int): Heights of the buildings. Returns: list of int: Indices of the buildings that can see the sunset. n = len(heights) if n == 0: return [] highest_so_far = heights[-1] sunset_indices = [n - 1] for i in range(n - 2, -1, -1): if heights[i] > highest_so_far: sunset_indices.append(i) highest_so_far = heights[i] return sorted(sunset_indices)"},{"question":"from typing import List def numSubarrayProductLessThanK(nums: List[int], k: int) -> int: Returns the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. >>> numSubarrayProductLessThanK([1], 2) == 1 >>> numSubarrayProductLessThanK([1], 1) == 0 >>> numSubarrayProductLessThanK([2], 2) == 0 >>> numSubarrayProductLessThanK([1, 2], 3) == 3 >>> numSubarrayProductLessThanK([1, 2], 2) == 1 >>> numSubarrayProductLessThanK([10, 5, 2, 6], 100) == 8 >>> numSubarrayProductLessThanK([1, 2, 3], 0) == 0 >>> numSubarrayProductLessThanK([1, 2, 3], 100000) == 6 >>> numSubarrayProductLessThanK([1, 2, 3], 0) == 0 >>> numSubarrayProductLessThanK([1, 2, 3], 1) == 0","solution":"def numSubarrayProductLessThanK(nums, k): Returns the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. if k <= 1: return 0 product = 1 left = 0 count = 0 for right in range(len(nums)): product *= nums[right] while product >= k and left <= right: product /= nums[left] left += 1 count += right - left + 1 return count"},{"question":"def max_consecutive_sum(nums, k): Returns the maximum number of consecutive elements that sum to a number less than or equal to k. Parameters: nums (list of int): The list of integers. k (int): The maximum sum allowed. Returns: int: The maximum number of consecutive elements that sum to a number less than or equal to k. from solution import max_consecutive_sum def test_example_case(): assert max_consecutive_sum([1, 2, 1, 0, 1, 1, 0], 4) == 5 def test_no_subarray(): assert max_consecutive_sum([5, 6, 7, 8], 3) == 0 def test_entire_array(): assert max_consecutive_sum([1, 2, 3], 6) == 3 def test_single_element_subarray(): assert max_consecutive_sum([1, 2, 3, 4, 5], 3) == 2 def test_edge_case_empty_array(): assert max_consecutive_sum([], 5) == 0 def test_edge_case_large_k(): assert max_consecutive_sum([1, 2, 3], 100) == 3 def test_k_is_zero(): assert max_consecutive_sum([1, 2, 3], 0) == 0","solution":"def max_consecutive_sum(nums, k): Returns the maximum number of consecutive elements that sum to a number less than or equal to k. Parameters: nums (list of int): The list of integers. k (int): The maximum sum allowed. Returns: int: The maximum number of consecutive elements that sum to a number less than or equal to k. max_length = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > k and start <= end: current_sum -= nums[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def replace_words(dictionary, sentence): Replaces words in a sentence with their shortest root form from a given dictionary. Parameters: dictionary (list of str): The list of root words. sentence (str): The input sentence where words need to be replaced. Returns: str: The modified sentence with words replaced by their shortest root form. def test_replace_words_single_root(): dictionary = [\\"cat\\"] sentence = \\"the cattle was rattled by the battery\\" result = replace_words(dictionary, sentence) assert result == \\"the cat was rattled by the battery\\" def test_replace_words_multiple_roots(): dictionary = [\\"cat\\", \\"bat\\", \\"rat\\"] sentence = \\"the cattle was rattled by the battery\\" result = replace_words(dictionary, sentence) assert result == \\"the cat was rat by the bat\\" def test_replace_words_no_replacements(): dictionary = [\\"flower\\", \\"sun\\"] sentence = \\"the cattle was rattled by the battery\\" result = replace_words(dictionary, sentence) assert result == \\"the cattle was rattled by the battery\\" def test_replace_words_with_multiple_same_roots(): dictionary = [\\"ca\\", \\"cat\\"] sentence = \\"the cattle was rattled by the battery\\" result = replace_words(dictionary, sentence) assert result == \\"the ca was rattled by the battery\\" def test_replace_words_emtpy_dictionary(): dictionary = [] sentence = \\"the cattle was rattled by the battery\\" result = replace_words(dictionary, sentence) assert result == \\"the cattle was rattled by the battery\\" def test_replace_words_empty_sentence(): dictionary = [\\"cat\\", \\"bat\\", \\"rat\\"] sentence = \\"\\" result = replace_words(dictionary, sentence) assert result == \\"\\"","solution":"def replace_words(dictionary, sentence): Replaces words in a sentence with their shortest root form from a given dictionary. Parameters: dictionary (list of str): The list of root words. sentence (str): The input sentence where words need to be replaced. Returns: str: The modified sentence with words replaced by their shortest root form. root_set = set(dictionary) words = sentence.split() for i, word in enumerate(words): min_length = float('inf') shortest_root = word for root in root_set: if word.startswith(root) and len(root) < min_length: min_length = len(root) shortest_root = root words[i] = shortest_root return ' '.join(words)"},{"question":"def max_items(x, prices): Returns the maximum number of different items that can be bought with the given amount of money x. :param x: non-negative integer representing the amount of money available. :param prices: list of integers where prices[i] is the price of the i-th item in the store. :return: the maximum number of different items that can be bought. >>> max_items(10, [3, 2, 5, 7]) == 3 >>> max_items(0, [1, 2, 3]) == 0 >>> max_items(20, [1, 2, 3, 4, 5]) == 5 >>> max_items(1, [2, 3, 4, 5]) == 0 >>> max_items(3, [2, 3, 4, 5]) == 1 >>> max_items(10, [2, 2, 2, 2, 2]) == 5 >>> max_items(100, [i for i in range(1, 101)]) == 13","solution":"def max_items(x, prices): Returns the maximum number of different items that can be bought with the given amount of money x. :param x: non-negative integer representing the amount of money available. :param prices: list of integers where prices[i] is the price of the i-th item in the store. :return: the maximum number of different items that can be bought. prices.sort() items_bought = 0 for price in prices: if x >= price: x -= price items_bought += 1 else: break return items_bought"},{"question":"def can_partition_k_subsets(nums, k): Determine if the list can be partitioned into k non-empty subsets with equal sums. Each number in the list can be used in exactly one subset. Args: nums (List[int]): List of integers to partition. k (int): Number of subsets to partition into. Returns: bool: True if the list can be partitioned into k subsets with equal sums, False otherwise. Examples: >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition_k_subsets([1, 2, 3, 4, 5, 6], 4) False >>> can_partition_k_subsets([10, 1, 1, 1, 1, 1], 3) False >>> can_partition_k_subsets([2, 2, 2, 2], 2) True >>> can_partition_k_subsets([10], 1) True >>> can_partition_k_subsets([1, 2, 3, 4], 3) False >>> can_partition_k_subsets([2, 2, 2, 2, 3, 3, 3, 3], 4) True","solution":"def can_partition_k_subsets(nums, k): def backtrack(index, k, subset_sum, used, target): if k == 1: return True if subset_sum == target: return backtrack(0, k - 1, 0, used, target) for i in range(index, len(nums)): if not used[i] and subset_sum + nums[i] <= target: used[i] = True if backtrack(i + 1, k, subset_sum + nums[i], used, target): return True used[i] = False return False total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) return backtrack(0, k, 0, used, target)"},{"question":"def rearrange_string(s: str) -> str: Rearranges the letters in the string s such that all uppercase letters come before all lowercase letters, while maintaining their respective order among themselves. :param s: input string consisting of lowercase and uppercase letters :return: rearranged string with all uppercase letters before all lowercase letters >>> rearrange_string(\\"ABC\\") == \\"ABC\\" >>> rearrange_string(\\"abc\\") == \\"abc\\" >>> rearrange_string(\\"aAbB\\") == \\"ABab\\" >>> rearrange_string(\\"BaAbcD\\") == \\"BADabc\\" >>> rearrange_string(\\"\\") == \\"\\" >>> rearrange_string(\\"abcdef\\") == \\"abcdef\\" >>> rearrange_string(\\"ABCDEF\\") == \\"ABCDEF\\" >>> rearrange_string(\\"aAaAa\\") == \\"AAaaa\\" >>> rearrange_string(\\"BbBbBBBbbb\\") == \\"BBBBBbbbbb\\"","solution":"def rearrange_string(s): Rearranges the letters in the string s such that all uppercase letters come before all lowercase letters, while maintaining their respective order among themselves. :param s: input string consisting of lowercase and uppercase letters :return: rearranged string with all uppercase letters before all lowercase letters upper = [] lower = [] for char in s: if char.isupper(): upper.append(char) else: lower.append(char) return ''.join(upper) + ''.join(lower)"},{"question":"def largest_swap(num_str: str) -> str: Returns the largest number by swapping at most two digits only once. >>> largest_swap('98765') '98765' >>> largest_swap('12345') '52341' >>> largest_swap('5') '5' >>> largest_swap('12') '21' >>> largest_swap('21') '21' >>> largest_swap('2736') '7236' >>> largest_swap('9973') '9973' >>> largest_swap('1993') '9913' >>> largest_swap('123456') '623451' >>> largest_swap('321') '321' >>> largest_swap('102') '201' >>> largest_swap('120') '210'","solution":"def largest_swap(num_str): Returns the largest number by swapping at most two digits only once. num_list = list(num_str) n = len(num_list) # Track the rightmost position of each digit last = {int(x): i for i, x in enumerate(num_list)} for i, x in enumerate(num_list): for d in range(9, int(x), -1): if last.get(d, -1) > i: num_list[i], num_list[last[d]] = num_list[last[d]], num_list[i] return ''.join(num_list) return num_str"},{"question":"def minGroups(products: List[int], budget: int) -> int: Determines the minimum number of groups needed to bundle all the products within the given budget. :param products: List of product prices. :param budget: Maximum budget for each group. :return: Minimum number of groups needed. >>> minGroups([3, 2, 2, 1], 10) == 1 >>> minGroups([3, 2, 2, 1], 5) == 2 >>> minGroups([3, 2, 2, 1], 3) == 3 >>> minGroups([1, 2, 3, 4, 5], 15) == 1 >>> minGroups([5, 5, 5, 5, 5], 5) == 5 >>> minGroups([7, 2, 3, 6, 1], 10) == 2","solution":"def minGroups(products, budget): Determines the minimum number of groups needed to bundle all the products within the given budget. :param products: List of product prices. :param budget: Maximum budget for each group. :return: Minimum number of groups needed. # Sort products in descending order products.sort(reverse=True) # Initialize an empty list to hold the groups groups = [] for product in products: placed_in_group = False for group in groups: if sum(group) + product <= budget: group.append(product) placed_in_group = True break if not placed_in_group: groups.append([product]) return len(groups)"},{"question":"def minCostToConnectRopes(ropes: List[int]) -> int: Returns the minimum cost to connect all the ropes into one rope. Parameters: ropes (List[int]): A list of integers representing the lengths of the ropes Returns: int: The minimum cost to connect all the ropes >>> minCostToConnectRopes([5]) == 0 >>> minCostToConnectRopes([2, 4]) == 6 >>> minCostToConnectRopes([1, 2, 3, 4, 5]) == 33 >>> minCostToConnectRopes([4, 4, 4, 4]) == 32 >>> minCostToConnectRopes([]) == 0","solution":"import heapq def minCostToConnectRopes(ropes): Returns the minimum cost to connect all the ropes into one rope. Parameters: ropes (List[int]): A list of integers representing the lengths of the ropes. Returns: int: The minimum cost to connect all the ropes. if not ropes: return 0 heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"def length_of_LNDS(nums: List[int]) -> int: Given a 0-indexed array nums, return the length of the longest non-decreasing subsequence that can be obtained by removing some elements from nums. >>> length_of_LNDS([]) == 0 >>> length_of_LNDS([1]) == 1 >>> length_of_LNDS([1, 2, 3, 4, 5]) == 5 >>> length_of_LNDS([5, 4, 3, 2, 1]) == 1 >>> length_of_LNDS([3, 1, 2, 1, 4]) == 3 >>> length_of_LNDS([2, 2, 2, 2]) == 4 >>> length_of_LNDS([10, 5, 6, 3, 8, 7, 9]) == 4","solution":"def length_of_LNDS(nums): Given a 0-indexed array nums, return the length of the longest non-decreasing subsequence that can be obtained by removing some elements from nums. if not nums: return 0 # Initialize list to hold longest subsequence lengths n = len(nums) dp = [1] * n # Iterate through the list, applying dynamic programming technique for i in range(1, n): for j in range(i): if nums[i] >= nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def is_subsequence(s: str, t: str) -> bool: Determines whether t is a subsequence of s. Args: s (str): The main string. t (str): The sequence to check as a subsequence. Returns: bool: True if t is a subsequence of s, False otherwise. >>> is_subsequence(\\"abcde\\", \\"ace\\") == True >>> is_subsequence(\\"abcde\\", \\"aec\\") == False >>> is_subsequence(\\"abcde\\", \\"\\") == True >>> is_subsequence(\\"abcde\\", \\"abcde\\") == True >>> is_subsequence(\\"abcde\\", \\"abcdef\\") == False >>> is_subsequence(\\"abc\\", \\"abcd\\") == False >>> is_subsequence(\\"abcde\\", \\"xyz\\") == False >>> is_subsequence(\\"abcabcabc\\", \\"aaa\\") == True >>> is_subsequence(\\"abpcplea\\", \\"apple\\") == True >>> is_subsequence(\\"aab\\", \\"ab\\") == True >>> is_subsequence(\\"abaa\\", \\"aa\\") == True >>> is_subsequence(\\"abc\\", \\"aabc\\") == False","solution":"def is_subsequence(s, t): Determines whether t is a subsequence of s. Args: s (str): The main string. t (str): The sequence to check as a subsequence. Returns: bool: True if t is a subsequence of s, False otherwise. m, n = len(s), len(t) if n == 0: return True t_index = 0 for char in s: if char == t[t_index]: t_index += 1 if t_index == n: return True return False"},{"question":"def remove_k_digits(n: int, k: int) -> str: Removes exactly k digits from the integer n to form the smallest possible new integer. Returns the smallest possible new integer as a string after k digits have been removed. >>> remove_k_digits(1432219, 3) == '1219' >>> remove_k_digits(10200, 1) == '200' >>> remove_k_digits(10, 2) == '0' >>> remove_k_digits(1234567890, 9) == '0' >>> remove_k_digits(100200300, 4) == '0' >>> remove_k_digits(12345, 5) == '0'","solution":"def remove_k_digits(n, k): Removes exactly k digits from the integer n to form the smallest possible new integer. Returns the smallest possible new integer as a string after k digits have been removed. number_str = str(n) stack = [] for digit in number_str: while k and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still elements to remove, remove them from the end. final_stack = stack[:-k] if k else stack # Join the stack to form the resultant number and strip leading zeros. result = ''.join(final_stack).lstrip('0') return result if result else '0'"},{"question":"def min_cuts(arr): Returns the minimum number of cuts needed to bring down all the trees. Parameters: arr (list): A list of integers representing the heights of trees. Returns: int: Minimum number of cuts needed. >>> min_cuts([5]) 1 >>> min_cuts([3, 3, 3, 3]) 1 >>> min_cuts([2, 3, 1, 4, 3]) 4 >>> min_cuts([1, 2, 3, 4, 5]) 5 >>> min_cuts([1, 3, 2, 3, 1]) 3 >>> min_cuts([6, 7, 8]) 3 >>> min_cuts([1, 2, 1, 3]) 3","solution":"def min_cuts(arr): Returns the minimum number of cuts needed to bring down all the trees. Parameters: arr (list): A list of integers representing the heights of trees. Returns: int: Minimum number of cuts needed. # Consider the unique values in the heights unique_heights = set(arr) # The number of unique heights determines the minimum cuts needed return len(unique_heights)"},{"question":"def convert(s: str, numRows: int) -> str: Transform a given string \`s\` to its zigzag conversion with a given number of rows \`numRows\`. The function should return the string that reads line by line. >>> convert(\\"PAYPALISHIRING\\", 3) == \\"PAHNAPLSIIGYIR\\" >>> convert(\\"PAYPALISHIRING\\", 4) == \\"PINALSIGYAHRPI\\" >>> convert(\\"A\\", 1) == \\"A\\" >>> convert(\\"AB\\", 1) == \\"AB\\" >>> convert(\\"AB\\", 2) == \\"AB\\" >>> convert(\\"ABCDEFGHI\\", 3) == \\"AEIBDFHCG\\" >>> convert(\\"\\", 3) == \\"\\" >>> convert(\\"ABCDEF\\", 6) == \\"ABCDEF\\" >>> convert(\\"ABCDEFGH\\", 100) == \\"ABCDEFGH\\" # Your code here","solution":"def convert(s: str, numRows: int) -> str: if numRows == 1 or numRows >= len(s): return s # Initialize a list of strings for each row rows = [''] * numRows current_row = 0 going_down = False for char in s: rows[current_row] += char if current_row == 0 or current_row == numRows - 1: going_down = not going_down current_row += 1 if going_down else -1 # Concatenate all rows and return return ''.join(rows)"},{"question":"def maxSumSubmatrix(matrix: List[List[int]], k: int) -> int: Given a 2D integer array \`mat\` representing a matrix of dimensions \`m x n\` and an integer \`k\`, return the maximum sum of any non-empty submatrix of \`mat\` such that the sum of the elements of the submatrix is less than or equal to \`k\`. >>> matrix = [ ... [1, 0, 1], ... [0, -2, 3] ... ] >>> k = 2 >>> maxSumSubmatrix(matrix, k) 2 >>> matrix = [ ... [2] ... ] >>> k = 1 >>> maxSumSubmatrix(matrix, k) -float('inf') >>> matrix = [ ... [2] ... ] >>> k = 2 >>> maxSumSubmatrix(matrix, k) 2 >>> matrix = [ ... [2, 2, -1] ... ] >>> k = 3 >>> maxSumSubmatrix(matrix, k) 3 >>> matrix = [ ... [2], ... [2], ... [-1] ... ] >>> k = 3 >>> maxSumSubmatrix(matrix, k) 3 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> k = 100 >>> maxSumSubmatrix(matrix, k) 45 >>> matrix = [ ... [1, 2, -1], ... [2, 3, -2] ... ] >>> k = 3 >>> maxSumSubmatrix(matrix, k) 3","solution":"def maxSumSubmatrix(matrix, k): import bisect def maxSumSubarray(arr, k): max_sum = -float('inf') curr_sum = 0 cum_set = [0] for num in arr: curr_sum += num # We need cum_sum[j] such that cum_sum[j] >= cum_sum[i] - k where j < i idx = bisect.bisect_left(cum_set, curr_sum - k) if idx < len(cum_set): max_sum = max(max_sum, curr_sum - cum_set[idx]) bisect.insort(cum_set, curr_sum) return max_sum m, n = len(matrix), len(matrix[0]) max_sum = -float('inf') # left and right define the bounds of the columns of the submatrix for left in range(n): row_sums = [0] * m for right in range(left, n): for i in range(m): row_sums[i] += matrix[i][right] max_sum = max(max_sum, maxSumSubarray(row_sums, k)) return max_sum"},{"question":"def can_form_palindrome_with_swaps(s: str, k: int) -> bool: Determine if the string s can be rearranged to form a palindrome such that the maximum number of adjacent character swaps needed to achieve this rearrangement is less than or equal to k. >>> can_form_palindrome_with_swaps(\\"aabb\\", 2) True >>> can_form_palindrome_with_swaps(\\"racecar\\", 2) True >>> can_form_palindrome_with_swaps(\\"abcba\\", 1) True >>> can_form_palindrome_with_swaps(\\"aabbcc\\", 3) True >>> can_form_palindrome_with_swaps(\\"abc\\", 2) False >>> can_form_palindrome_with_swaps(\\"abcdefgh\\", 20) False >>> can_form_palindrome_with_swaps(\\"aabbaa\\", 0) True >>> can_form_palindrome_with_swaps(\\"level\\", 0) True >>> can_form_palindrome_with_swaps(\\"aabbccddeeff\\", 6) True >>> can_form_palindrome_with_swaps(\\"abcdedcba\\", 4) True >>> can_form_palindrome_with_swaps(\\"abcdabcd\\", 3) False >>> can_form_palindrome_with_swaps(\\"abcdefghijklmnop\\", 10) False","solution":"def can_form_palindrome_with_swaps(s, k): from collections import Counter # Count frequency of each character char_count = Counter(s) # Check how many characters have odd counts odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) # For a string to be rearranged into a palindrome: # - If the length of the string is even, there should be no characters with odd counts. # - If the length is odd, there should be at most one character with an odd count. if odd_counts > 1: return False # The minimum number of swaps needed to make a string into a palindrome is # n//2 - number of positions where characters don't match from start to end # For the optimal number of swaps computation, it's a complex graph problem, # but for simplicity let's consider the condition checks. # Placeholder for actual swaps logic since exact optimal swap distance is complex # We use simple check only for constraint satisfaction: n = len(s) swap_needed = 0 for i in range(n // 2): if s[i] != s[n-i-1]: swap_needed += 1 # Since k is supposed to be the maximum allowed swaps, we directly check return swap_needed <= k"},{"question":"def valid_palindrome(s: str) -> bool: Given a string s, determine if it can be converted into a palindrome by removing at most one character. Return True if it can be converted into a palindrome, otherwise return False. >>> valid_palindrome(\\"abca\\") == True >>> valid_palindrome(\\"racecar\\") == True >>> valid_palindrome(\\"racecarr\\") == True >>> valid_palindrome(\\"abc\\") == False >>> valid_palindrome(\\"deeed\\") == True >>> valid_palindrome(\\"a\\") == True >>> valid_palindrome(\\"ab\\") == True >>> valid_palindrome(\\"\\") == True >>> valid_palindrome(\\"aa\\") == True","solution":"def valid_palindrome(s: str) -> bool: Determines if the string can be converted into a palindrome by removing at most one character. def is_palindrome_range(i, j): return all(s[k] == s[j - k + i] for k in range(i, j)) i, j = 0, len(s) - 1 while i < j: if s[i] != s[j]: return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1) i, j = i + 1, j - 1 return True"},{"question":"def evaluate_expression(expr: str) -> int: Evaluates a given arithmetic expression with + and * following the standard operator precedence. Args: expr (str): The arithmetic expression as a string. Returns: int: The result of the expression. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"2*3\\") == 6 >>> evaluate_expression(\\"2*3+4\\") == 10 >>> evaluate_expression(\\"4+2*3\\") == 10 >>> evaluate_expression(\\"2+3*4+5*6\\") == 44 >>> evaluate_expression(\\"2*3*4+5\\") == 29 >>> evaluate_expression(\\"2+3+4+5\\") == 14 >>> evaluate_expression(\\"0+3*4+5*0\\") == 12","solution":"def evaluate_expression(expr): Evaluates a given arithmetic expression with + and * following the standard operator precedence. Args: expr (str): The arithmetic expression as a string. Returns: int: The result of the expression. # Split expression by '+' terms = expr.split('+') # Process each term (which can contain only multiplication) evaluated_terms = [] for term in terms: factors = map(int, term.split('*')) product = 1 for factor in factors: product *= factor evaluated_terms.append(product) # Sum of all evaluated terms result = sum(evaluated_terms) return result"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Calculates the maximum profit from at most two transactions. :param prices: List[int] - List of stock prices :return: int - Maximum profit that can be achieved with at most two transactions >>> maxProfit([3,3,5,0,0,3,1,4]) 6 >>> maxProfit([1,2,3,4,5]) 4 >>> maxProfit([7,6,4,3,1]) 0","solution":"def maxProfit(prices): Calculates the maximum profit from at most two transactions. :param prices: List[int] - List of stock prices :return: int - Maximum profit that can be achieved with at most two transactions if not prices: return 0 n = len(prices) first_buy = second_buy = float('-inf') first_sell = second_sell = 0 for price in prices: first_buy = max(first_buy, -price) first_sell = max(first_sell, first_buy + price) second_buy = max(second_buy, first_sell - price) second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"def max_non_conflicting_projects(projects: List[List[int]]) -> int: Returns the maximum number of non-conflicting projects. Projects are represented by pairs of integers [start, end] denoting the start and end times. >>> max_non_conflicting_projects([]) == 0 >>> max_non_conflicting_projects([[1, 2]]) == 1 >>> max_non_conflicting_projects([[1, 3], [3, 5], [5, 7]]) == 3 >>> max_non_conflicting_projects([[1, 4], [2, 5], [3, 6]]) == 1 >>> max_non_conflicting_projects([[1, 2], [2, 3], [3, 4], [1, 5]]) == 3 >>> max_non_conflicting_projects([[1, 3], [2, 5], [4, 6], [6, 7], [5, 8]]) == 3 >>> max_non_conflicting_projects([[1, 2], [2, 6], [1, 3], [5, 8], [4, 7], [8, 9]]) == 3","solution":"def max_non_conflicting_projects(projects): Returns the maximum number of non-conflicting projects. Projects are represented by pairs of integers [start, end] denoting the start and end times. if not projects: return 0 # Sort projects based on their end times projects.sort(key=lambda x: x[1]) # Use a greedy approach to select the maximum number of non-conflicting projects count = 1 last_end_time = projects[0][1] for i in range(1, len(projects)): if projects[i][0] >= last_end_time: count += 1 last_end_time = projects[i][1] return count"},{"question":"import heapq class Solution: def __init__(self, nums, k): Initializes the object with the integer array nums and the integer k. self.nums = nums self.k = k def findKthLargest(self): Returns the k-th largest element in the array. >>> Solution([3, 2, 1, 5, 6, 4], 2).findKthLargest() 5 >>> Solution([3, 2, 3, 1, 2, 4, 5, 5, 6], 4).findKthLargest() 4 >>> Solution([1], 1).findKthLargest() 1 >>> Solution([1, 2], 2).findKthLargest() 1 >>> Solution([2, 2, 2, 2, 2], 3).findKthLargest() 2 >>> Solution([3, 2, 3, -1, 2, 4, 5, 5, 6], 3).findKthLargest() 5","solution":"import heapq class Solution: def __init__(self, nums, k): self.nums = nums self.k = k def findKthLargest(self): # use a min-heap with size k to store the k largest elements min_heap = self.nums[:self.k] heapq.heapify(min_heap) for num in self.nums[self.k:]: if num > min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap[0]"},{"question":"def minReorder(n: int, connections: List[List[int]]) -> int: Determines the minimum number of edges you need to reverse to make all the nodes in an undirected graph reachable from node 0. >>> minReorder(6, [[0,1],[1,3],[2,3],[4,0],[4,5]]) 3 >>> minReorder(3, [[1,0],[2,0]]) 0 >>> minReorder(3, [[0,1],[1,2],[2,0]]) 1 >>> minReorder(5, [[1,0],[2,1],[3,1],[4,0]]) 0 >>> minReorder(4, [[1,0], [2,1], [3,2]]) 0","solution":"def minReorder(n, connections): from collections import defaultdict, deque graph = defaultdict(list) reverse_graph = defaultdict(list) # Build the graph and reverse graph for a, b in connections: graph[a].append(b) reverse_graph[b].append(a) visited = [False] * n queue = deque([0]) visited[0] = True reversals = 0 while queue: current = queue.popleft() # Explore all nodes connected to current in the original graph for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) reversals += 1 # Explore all nodes connected to current in the reversed graph for neighbor in reverse_graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return reversals"},{"question":"def is_single_network(connections: List[Tuple[int, int]]) -> bool: Determine if all computers are part of a single network. >>> is_single_network([(1, 2)]) == True >>> is_single_network([(1, 2), (2, 3), (3, 4)]) == True >>> is_single_network([(1, 2), (3, 4)]) == False >>> is_single_network([(1, 2), (1, 3), (1, 4), (2, 3), (3, 4)]) == True >>> is_single_network([]) == True >>> is_single_network([(1, 2), (2, 3), (4, 5)]) == False","solution":"def is_single_network(connections): from collections import defaultdict, deque if not connections: return True adjacency_list = defaultdict(list) nodes = set() for a, b in connections: nodes.add(a) nodes.add(b) adjacency_list[a].append(b) adjacency_list[b].append(a) visited = set() def bfs(start_node): queue = deque([start_node]) visited.add(start_node) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Start BFS from the first node first_node = next(iter(nodes)) bfs(first_node) # After BFS, if visited contains all nodes, it means all nodes are connected return len(visited) == len(nodes)"},{"question":"def maximize_consecutive_sum(arr: List[int], m: int) -> List[int]: Rearrange the elements of \`arr\` such that the sum of every \`m\` consecutive elements is maximized. :param arr: List[int] -- input array :param m: int -- number of consecutive elements to maximize the sum for :return: List[int] -- rearranged array >>> maximize_consecutive_sum([1, 2, 3, 4, 5], 3) == [5, 4, 3, 2, 1] >>> maximize_consecutive_sum([1, 2, 3, 4, 5, 6], 4) == [6, 5, 4, 3, 2, 1] >>> maximize_consecutive_sum([1, 3, 5, 2, 4], 5) == [5, 4, 3, 2, 1] >>> maximize_consecutive_sum([1, 3, 5, 2, 4, 6, 7, 8], 2) == [8, 7, 6, 5, 4, 3, 2, 1] >>> maximize_consecutive_sum([5, 5, 5, 5, 5], 3) == [5, 5, 5, 5, 5] >>> maximize_consecutive_sum([1], 1) == [1] >>> maximize_consecutive_sum([10, 20, 30], 5) == [30, 20, 10]","solution":"def maximize_consecutive_sum(arr, m): Rearrange the elements of \`arr\` such that the sum of every \`m\` consecutive elements is maximized. :param arr: List[int] -- input array :param m: int -- number of consecutive elements to maximize the sum for :return: List[int] -- rearranged array # Sort the array in decreasing order arr.sort(reverse=True) # Create the rearranged array to store result rearranged = [] n = len(arr) # Logic: We take the first m elements from the sorted array directly # because they are the largest numbers and will definitely maximize the first segment. # We then repeat this until we have covered the entire array. for i in range(n // m): rearranged.extend(arr[i*m:i*m + m]) # If there are any remaining elements that don't make up a full segment of size m, # append them at the end. remaining_elements = n % m if remaining_elements > 0: rearranged.extend(arr[-remaining_elements:]) return rearranged"},{"question":"def two_sum(arr, target): Returns the indices of the two numbers that add up to the target. Parameters: arr (list of int): The input array target (int): The target sum Returns: list of int: A list of two indices, or an empty list if no such pair exists >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([1, 2, 3], 7) [] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 3, 4, 2], 6) [2, 3]","solution":"def two_sum(arr, target): Returns the indices of the two numbers that add up to the target. Parameters: arr (list of int): The input array target (int): The target sum Returns: list of int: A list of two indices, or an empty list if no such pair exists num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"from typing import List def min_steps_to_convert_land_to_water(grid: List[List[int]]) -> int: Return the minimum number of steps to convert all lands (1s) in the grid to waters (0s). >>> grid = [ ... [1, 1], ... [1, 1] ... ] >>> min_steps_to_convert_land_to_water(grid) 1 >>> grid = [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0] ... ] >>> min_steps_to_convert_land_to_water(grid) 1 >>> grid = [ ... [0, 0], ... [0, 0] ... ] >>> min_steps_to_convert_land_to_water(grid) 0 >>> grid = [ ... [0, 0], ... [0, 1] ... ] >>> min_steps_to_convert_land_to_water(grid) 0 >>> grid = [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> min_steps_to_convert_land_to_water(grid) 1","solution":"from collections import deque def min_steps_to_convert_land_to_water(grid): Returns the minimum number of steps to convert all lands (1s) in the grid to waters (0s). if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) queue = deque() steps = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: queue.append((r, c)) if not queue: return 0 # No land to convert # Directions for moving in 4 directions (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: steps += 1 for _ in range(len(queue)): row, col = queue.popleft() for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 0 queue.append((nr, nc)) return steps - 1 # Subtract 1 because the last increment happens when no more lands are left # Example usage # grid = [ # [0, 1, 0], # [1, 1, 1], # [0, 1, 0] # ] # print(min_steps_to_convert_land_to_water(grid)) # Output: 2"},{"question":"def min_swaps_to_order(s: str) -> int: Returns the minimum number of swaps required to rearrange the string such that all 'a's come before all 'b's. >>> min_swaps_to_order(\\"aaaa\\") == 0 >>> min_swaps_to_order(\\"bbbb\\") == 0 >>> min_swaps_to_order(\\"abab\\") == 1 >>> min_swaps_to_order(\\"baba\\") == 2 >>> min_swaps_to_order(\\"aaabbb\\") == 0 >>> min_swaps_to_order(\\"ababbab\\") == 3 >>> min_swaps_to_order(\\"babaabbab\\") == 4 >>> min_swaps_to_order(\\"\\") == 0 >>> min_swaps_to_order(\\"a\\") == 0 >>> min_swaps_to_order(\\"b\\") == 0","solution":"def min_swaps_to_order(s): Returns the minimum number of swaps required to rearrange the string such that all 'a's come before all 'b's. # Count the total number of 'a's and 'b's in the string total_a = s.count('a') total_b = len(s) - total_a # Any 'b' found before having counted all 'a's is a misposition needed_swaps = 0 a_seen = 0 for char in s: if char == 'a': a_seen += 1 elif char == 'b' and a_seen < total_a: needed_swaps += 1 return needed_swaps"},{"question":"def rearrange(nums: List[int]) -> List[int]: Rearrange the numbers such that every nums[i] is equal to the product of the largest elements in all even indexed positions and all odd indexed positions up to i-1. >>> rearrange([]) == [] >>> rearrange([10]) == [10] >>> rearrange([10, 5]) == [10, 5] >>> rearrange([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] >>> rearrange([6, 5, 4, 3, 2, 1]) == [6, 5, 6, 5, 6, 5] >>> rearrange([1, 5, 3, 7, 2, 9, 8]) == [1, 5, 3, 7, 3, 9, 8] >>> rearrange([4, 4, 4, 4, 4, 4]) == [4, 4, 4, 4, 4, 4] from typing import List","solution":"def rearrange(nums): if len(nums) == 0: return nums max_even = float('-inf') max_odd = float('-inf') new_nums = [] for i, num in enumerate(nums): if i % 2 == 0: # even index max_even = max(max_even, num) new_nums.append(max_even) else: # odd index max_odd = max(max_odd, num) new_nums.append(max_odd) return new_nums"},{"question":"from typing import List def min_path_cost(cost: List[List[int]]) -> int: Given a m x n integer grid cost where cost[i][j] represents the cost of stepping on the cell (i, j) from either the left or from above, return the minimum cost to reach the bottom-right cell (m-1, n-1) from the top-left cell (0, 0). You can only move either down or right at any point in time. >>> min_path_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_cost([[1, 2, 3], [4, 5, 6]]) 12 >>> min_path_cost([[1]]) 1 >>> min_path_cost([[1, 2], [1, 1]]) 3 >>> min_path_cost([]) 0 >>> min_path_cost([[]]) 0","solution":"def min_path_cost(cost): Returns the minimum cost to reach the bottom-right cell from the top-left cell. :param cost: A list of lists of integers where cost[i][j] represents the cost of stepping on the cell (i, j) :return: Minimum cost to reach the bottom-right cell (m-1, n-1) from the top-left cell (0, 0) if not cost or not cost[0]: return 0 m, n = len(cost), len(cost[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = cost[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + cost[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + cost[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost[i][j] return dp[m-1][n-1]"},{"question":"def two_sum(arr, target): Given an integer array \`arr\` and an integer \`target\`, return the indices of two distinct numbers in the array that add up to \`target\`. Assumes that there is exactly one solution, and array contains distinct elements. Parameters: arr (list): List of integers target (int): Target sum for two numbers in the array Returns: list: List containing indices of the two numbers","solution":"def two_sum(arr, target): Given an array of integers, return indices of the two numbers such that they add up to a specific target. Assumes that there is exactly one solution, and array contains distinct elements. Parameters: arr (list): List of integers target (int): Target sum for two numbers in the array Returns: list: List containing indices of the two numbers num_map = {} # dictionary to store numbers and their indices for i, num in enumerate(arr): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i return [] # return an empty list if no solution is found (though the problem guarantees one solution)"},{"question":"def min_operations_to_increase(arr: List[int], k: int) -> int: Determine the minimum number of operations needed to make the array strictly increasing by reversing subarrays of length k. If it is not possible to make the array strictly increasing, return -1. >>> min_operations_to_increase([1, 2, 3, 4, 5], 3) 0 >>> min_operations_to_increase([5, 4, 3, 2, 1], 5) 1 >>> min_operations_to_increase([5, 1, 3, 2, 4], 2) -1 >>> min_operations_to_increase([3, 2, 1, 4], 3) 1 >>> min_operations_to_increase([1], 1) 0","solution":"def min_operations_to_increase(arr, k): Determine the minimum number of operations needed to make the array strictly increasing by reversing subarrays of length k. If it is not possible to make the array strictly increasing, return -1. def is_strictly_increasing(lst): return all(x < y for x, y in zip(lst, lst[1:])) n = len(arr) if is_strictly_increasing(arr): return 0 for i in range(1, k + 1): new_arr = arr[:] for j in range(0, n, i): new_arr[j:j+i] = reversed(new_arr[j:j+i]) if is_strictly_increasing(new_arr): return 1 return -1"},{"question":"def decodeString(s: str) -> str: Given a string s, decode it according to the following rule: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. >>> decodeString(\\"3[a]2[bc]\\") == \\"aaabcbc\\" >>> decodeString(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decodeString(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" >>> decodeString(\\"2[a]\\") == \\"aa\\" >>> decodeString(\\"abc\\") == \\"abc\\" >>> decodeString(\\"10[a]\\") == \\"aaaaaaaaaa\\" >>> decodeString(\\"2[3[a]b]\\") == \\"aaabaaab\\" >>> decodeString(\\"2[abc3[cd]ef]\\") == \\"abccdcdcdefabccdcdcdef\\"","solution":"def decodeString(s: str) -> str: stack = [] current_num = 0 current_string = \\"\\" for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \\"[\\": stack.append((current_string, current_num)) current_string = \\"\\" current_num = 0 elif char == \\"]\\": last_string, num = stack.pop() current_string = last_string + current_string * num else: current_string += char return current_string"},{"question":"def largest_clique_size(s: str) -> int: Find the size of the largest clique where each word shares at least one common letter with every other word in the group. >>> largest_clique_size(\\"a b c d e\\") == 1 >>> largest_clique_size(\\"ab cd ef gh\\") == 1 >>> largest_clique_size(\\"abc bde efg fgh hij\\") == 5 >>> largest_clique_size(\\"abc def ghi jkl\\") == 1 >>> largest_clique_size(\\"abc ade afg\\") == 3","solution":"def share_common_letter(word1, word2): Check if two words share at least one common letter. return bool(set(word1) & set(word2)) def largest_clique_size(s): Find the size of the largest clique where each word shares at least one common letter with every other word in the group. words = s.split() n = len(words) def dfs(node, visited, graph): visited.add(node) size = 1 for neighbor in graph[node]: if neighbor not in visited: size += dfs(neighbor, visited, graph) return size # Build the graph graph = {i: [] for i in range(n)} for i in range(n): for j in range(i + 1, n): if share_common_letter(words[i], words[j]): graph[i].append(j) graph[j].append(i) # Perform DFS to find the largest connected component visited = set() largest_clique = 0 for node in range(n): if node not in visited: largest_clique = max(largest_clique, dfs(node, visited, graph)) return largest_clique"},{"question":"def largest_island(grid): Returns the size of the largest island in the given grid. An island is a maximal 4-directionally (horizontal or vertical) connected group of \`0\`s. >>> largest_island([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]) == 8 >>> largest_island([[1, 1, 0, 0, 1], [1, 0, 0, 1, 1], [1, 1, 1, 1, 1], [0, 0, 0, 1, 1], [1, 1, 1, 1, 1]]) == 4 >>> largest_island([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 0 >>> largest_island([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 9 >>> largest_island([[0]]) == 1 >>> largest_island([[1]]) == 0","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. An island is a maximal 4-directionally (horizontal or vertical) connected group of \`0\`s. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] != 0: return 0 # Mark as visited grid[x][y] = -1 return 1 + dfs(x+1, y) + dfs(x-1, y) + dfs(x, y+1) + dfs(x, y-1) max_island_size = 0 for i in range(m): for j in range(n): if grid[i][j] == 0: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"def isValid(s: str) -> bool: Determine if the input string of brackets is valid. >>> isValid(\\"()\\") == True >>> isValid(\\"()[]{}\\") == True >>> isValid(\\"(]\\") == False >>> isValid(\\"([)]\\") == False >>> isValid(\\"{[]}\\") == True def test_isValid_empty_string(): assert isValid(\\"\\") == True def test_isValid_simple_valid(): assert isValid(\\"()\\") == True def test_isValid_different_brackets_valid(): assert isValid(\\"()[]{}\\") == True def test_isValid_mixed_invalid(): assert isValid(\\"(]\\") == False def test_isValid_nested_invalid(): assert isValid(\\"([)]\\") == False def test_isValid_nested_valid(): assert isValid(\\"{[]}\\") == True def test_isValid_open_brackets_left(): assert isValid(\\"(((([[[\\") == False def test_isValid_wrong_order(): assert isValid(\\"{\\") == False assert isValid(\\"}\\") == False assert isValid(\\"{[}]\\") == False","solution":"def isValid(s: str) -> bool: Determine if the input string of brackets is valid. stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map: top_element = stack.pop() if stack else '#' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"from typing import List def find132pattern(nums: List[int]) -> bool: Determine whether there exists a 132 pattern in the array. A 132 pattern is a subsequence of three integers nums[i], nums[j], nums[k] such that i < j < k and nums[i] < nums[k] < nums[j]. >>> find132pattern([1, 2, 3, 4]) False >>> find132pattern([3, 1, 4, 2]) True >>> find132pattern([1, 2]) False >>> find132pattern([1, 1, 1, 1]) False >>> find132pattern([3, 5, 0, 3, 4]) True >>> find132pattern([-1, 3, 2, 0]) True >>> find132pattern([]) False >>> find132pattern([1]) False >>> find132pattern([1, 2]) False","solution":"def find132pattern(nums): if len(nums) < 3: return False # Using a stack to maintain the candidate's third element(k) stack = [] third = float('-inf') # Traversing elements from right to left for num in reversed(nums): if num < third: return True while stack and num > stack[-1]: third = stack.pop() stack.append(num) return False"},{"question":"def min_candies(arr): Returns the minimum number of candies required to distribute among students with the given ratings, ensuring each student receives at least one candy and students with higher ratings get more candies than their neighbors. >>> min_candies([1]) 1 >>> min_candies([1, 2]) 3 >>> min_candies([2, 1]) 3 >>> min_candies([1, 2, 1]) 4 >>> min_candies([2, 1, 2]) 5 >>> min_candies([1, 1, 1, 1]) 4 >>> min_candies([1, 3, 2, 2, 1]) 7 >>> min_candies([1, 2, 3, 4, 5]) 15 >>> min_candies([5, 4, 3, 2, 1]) 15","solution":"def min_candies(arr): Returns the minimum number of candies required to distribute among students with the given ratings, ensuring each student receives at least one candy and students with higher ratings get more candies than their neighbors. n = len(arr) if n == 0: return 0 candies = [1] * n # First pass: from left to right, ensure each student has more candies than # the left neighbor if the rating is higher for i in range(1, n): if arr[i] > arr[i-1]: candies[i] = candies[i-1] + 1 # Second pass: from right to left, ensure each student has more candies than # the right neighbor if the rating is higher for i in range(n-2, -1, -1): if arr[i] > arr[i + 1]: candies[i] = max(candies[i], candies[i + 1] + 1) # Return the sum of all candies return sum(candies)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_valid_path(root): Determines if there is at least one valid path from the root to a leaf node, following the traversal rule. :param TreeNode root: The root node of the tree. :return: True if there is a valid path, else False. :rtype: bool import pytest def test_valid_path(): # Constructing the following tree: # 0 # / # 1 0 root = TreeNode(0) root.left = TreeNode(1) root.right = TreeNode(0) assert is_valid_path(root) == True def test_no_valid_path(): # Constructing the following tree: # 1 # / # 0 1 root = TreeNode(1) root.left = TreeNode(0) root.right = TreeNode(1) assert is_valid_path(root) == False def test_single_node(): # Single node tree root = TreeNode(1) assert is_valid_path(root) == True def test_multiple_levels_mixed(): # Constructing the following tree: # 0 # / # 1 0 # / # 0 1 root = TreeNode(0) root.left = TreeNode(1) root.right = TreeNode(0) root.left.left = TreeNode(0) root.left.right = TreeNode(1) assert is_valid_path(root) == True def test_no_leaves_on_even_level(): # Constructing the following tree: # 1 # / # 1 1 root = TreeNode(1) root.left = TreeNode(1) root.right = TreeNode(1) assert is_valid_path(root) == False def test_valid_path_complex(): # Constructing the following tree: # 0 # / # 1 0 # / # 0 1 1 # / # 1 root = TreeNode(0) root.left = TreeNode(1) root.right = TreeNode(0) root.left.left = TreeNode(0) root.left.right = TreeNode(1) root.left.left.left = TreeNode(1) root.right.right = TreeNode(1) assert is_valid_path(root) == True","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_valid_path(root): Determines if there is at least one valid path from the root to a leaf node, following the traversal rule. :param TreeNode root: The root node of the tree. :return: True if there is a valid path, else False. :rtype: bool def dfs(node, level): if not node: return False if not node.left and not node.right: return True if node.value == 1: # Can move to nodes at even levels next_level = level + 1 if next_level % 2 == 0: return (node.left and dfs(node.left, next_level)) or (node.right and dfs(node.right, next_level)) else: # Can move to nodes at odd levels next_level = level + 1 if next_level % 2 != 0: return (node.left and dfs(node.left, next_level)) or (node.right and dfs(node.right, next_level)) return False return dfs(root, 0)"},{"question":"def leftMaxView(heights: List[int]) -> List[int]: You are given a list of \`n\` integers representing the height of buildings on a street. The city plans to enhance the view by allowing travelers to see the maximum height of buildings to their left as they walk along the street. This is represented by a new list, \`leftMaxView\`, where \`leftMaxView[i]\` is the maximum height of buildings from the beginning of the list up to the \`i-th\` building (inclusive). :param heights: A list of integers representing building heights. :return: A list of integers where each element is the maximum height of buildings from the start up to that index in the input list. >>> leftMaxView([3, 7, 8, 3, 6, 1, 4]) [3, 7, 8, 8, 8, 8, 8] >>> leftMaxView([5]) [5] >>> leftMaxView([4, 4, 4, 4, 4]) [4, 4, 4, 4, 4] >>> leftMaxView([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> leftMaxView([5, 4, 3, 2, 1]) [5, 5, 5, 5, 5] >>> leftMaxView([-3, -7, -1, -8, -2]) [-3, -3, -1, -1, -1] >>> leftMaxView([0, 2, 0, 4, 2]) [0, 2, 2, 4, 4]","solution":"def leftMaxView(heights): Returns the list of maximum height from the beginning of the list up to each building. :param heights: A list of integers representing building heights. :return: A list of integers where each element is the maximum height of buildings from the start up to that index in the input list. if not heights: return [] max_view = [heights[0]] for i in range(1, len(heights)): max_view.append(max(max_view[-1], heights[i])) return max_view"},{"question":"def can_partition(arr: List[int]) -> bool: Determine whether it's possible to partition the array into two subsets such that the sum of elements in both subsets is equal. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(arr): total_sum = sum(arr) # If total sum is odd, it's not possible to partition into two equal subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(arr) # Creating a dp array of (target_sum+1) elements, initialized with False dp = [False] * (target_sum + 1) dp[0] = True for num in arr: for j in range(target_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target_sum]"},{"question":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrderSum(root: Optional[TreeNode]) -> List[int]: Calculate the sum of the values of nodes at each level of the tree. Given the root node, this function returns an array where each element represents the sum of the nodes' values at that level, starting from the root level. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> levelOrderSum(root) [1, 5, 22] >>> root = TreeNode(1) >>> levelOrderSum(root) [1] >>> levelOrderSum(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> levelOrderSum(root) [1, 2, 3, 4] # Your code here","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrderSum(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_sum = 0 for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"def add_digits(num: int) -> int: Repeatedly add all digits of a non-negative integer num until the result has only one digit. :param num: Non-negative integer :return: Single digit integer >>> add_digits(5) 5 >>> add_digits(38) 2 >>> add_digits(9999) 9 >>> add_digits(0) 0 >>> add_digits(12345) 6","solution":"def add_digits(num): Repeatedly add all digits of a non-negative integer num until the result has only one digit. :param num: Non-negative integer :return: Single digit integer while num >= 10: num = sum(int(digit) for digit in str(num)) return num"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum possible subarray sum of any length. >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4, -100]) == 6","solution":"def max_subarray_sum(nums): Returns the maximum possible subarray sum of any length. Uses Kadane's Algorithm which runs in O(n) time. :param nums: List[int] - A list of integers representing the array. :return: int - The maximum subarray sum. max_ending_here = max_so_far = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def rotateArray(nums, k): Rotates the array such that the element at index i in the original array is moved to index (i + k) % n in the rearranged array. Args: nums: List[int] - The original array of integers. k: int - The number of positions to rotate the array. Returns: List[int] - The rearranged array. >>> rotateArray([1], 3) [1] >>> rotateArray([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotateArray([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotateArray([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotateArray([1, 2, 3, 4, 5], -3) [4, 5, 1, 2, 3] >>> rotateArray(list(range(1, 101)), 3) [98, 99, 100, 1, 2, 3, ..., 96, 97]","solution":"def rotateArray(nums, k): Rotates the array such that the element at index i in the original array is moved to index (i + k) % n in the rearranged array. Args: nums: List[int] - The original array of integers. k: int - The number of positions to rotate the array. Returns: List[int] - The rearranged array. n = len(nums) k = k % n # Normalize k to be within the bounds of the array length return nums[-k:] + nums[:-k]"},{"question":"def floyd_warshall(graph: List[List[int]]) -> List[List[int]]: Performs Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes. :param graph: List[List[int]], 2D matrix representing the weights of the edges. If graph[i][j] is -1, it means there is no direct connection. :return: List[List[int]], updated graph with shortest paths between all pairs of nodes. >>> floyd_warshall([ [0, 3, -1], [-1, 0, 1], [2, -1, 0] ]) [[0, 3, 4], [3, 0, 1], [2, 5, 0]] >>> floyd_warshall([ [0, -1, -1], [-1, 0, -1], [-1, -1, 0] ]) [[0, -1, -1], [-1, 0, -1], [-1, -1, 0]] >>> floyd_warshall([ [0, 1, 4], [1, 0, 2], [4, 2, 0] ]) [[0, 1, 3], [1, 0, 2], [3, 2, 0]] >>> floyd_warshall([ [0, 5, -1, 10], [-1, 0, 3, -1], [-1, -1, 0, 1], [-1, -1, -1, 0] ]) [[0, 5, 8, 9], [-1, 0, 3, 4], [-1, -1, 0, 1], [-1, -1, -1, 0]]","solution":"def floyd_warshall(graph): Performs Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes. :param graph: List[List[int]], 2D matrix representing the weights of the edges. If graph[i][j] is -1, it means there is no direct connection. :return: List[List[int]], updated graph with shortest paths between all pairs of nodes. n = len(graph) # Initialize the matrix: replace -1 with inf, except on the diagonal (identity paths with zero cost) for i in range(n): for j in range(n): if graph[i][j] == -1 and i != j: graph[i][j] = float('inf') # Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if graph[i][j] > graph[i][k] + graph[k][j]: graph[i][j] = graph[i][k] + graph[k][j] # Convert inf back to -1 for no connections for i in range(n): for j in range(n): if graph[i][j] == float('inf'): graph[i][j] = -1 return graph"},{"question":"def find_diagonal_order(matrix): Given an m x n matrix of integers, return all the elements of the matrix in diagonal order. The diagonal order starts from the top-left corner and moves in a zigzag pattern. >>> find_diagonal_order([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 4, 7, 5, 3, 6, 8, 9] >>> find_diagonal_order([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [1, 2, 5, 9, 6, 3, 4, 7, 10, 13, 14, 11, 8, 12, 15, 16] # Your code here","solution":"def find_diagonal_order(matrix): if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] diagonals = {} for i in range(m): for j in range(n): if i + j not in diagonals: diagonals[i + j] = [] diagonals[i + j].append(matrix[i][j]) for k in range(m + n - 1): if k % 2 == 0: result.extend(reversed(diagonals[k])) else: result.extend(diagonals[k]) return result"},{"question":"def longest_allowed_substring(s: str, letters: List[str]) -> int: Returns the length of the longest substring of 's' that contains only characters from 'letters'. :param s: str, the input string consisting of lowercase English letters :param letters: list of str, the allowed characters :return: int, the length of the longest allowed substring >>> longest_allowed_substring(\\"abcde\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"]) 5 >>> longest_allowed_substring(\\"abcde\\", []) 0 >>> longest_allowed_substring(\\"abcde\\", [\\"a\\", \\"b\\", \\"d\\"]) 2 >>> longest_allowed_substring(\\"abcdefg\\", [\\"a\\", \\"b\\", \\"d\\", \\"e\\", \\"f\\"]) 3 >>> longest_allowed_substring(\\"abcde\\", [\\"b\\", \\"d\\"]) 1 >>> longest_allowed_substring(\\"abacabad\\", [\\"a\\", \\"b\\", \\"c\\"]) 7 >>> longest_allowed_substring(\\"abacabad\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 8 >>> longest_allowed_substring(\\"abxyzacde\\", [\\"a\\", \\"b\\", \\"d\\", \\"e\\"]) 2 >>> longest_allowed_substring(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) 0","solution":"def longest_allowed_substring(s, letters): Returns the length of the longest substring of 's' that contains only characters from 'letters'. :param s: str, the input string consisting of lowercase English letters :param letters: list of str, the allowed characters :return: int, the length of the longest allowed substring allowed_set = set(letters) max_length = 0 current_length = 0 for char in s: if char in allowed_set: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], x: int, y: int) -> bool: Determines if there exists a pair of indices (i, j) such that: - arr[i] + arr[j] equals x - abs(i - j) <= y Parameters: arr (list): List of integers. x (int): Target sum. y (int): Maximum index difference. Returns: bool: True if such a pair exists, False otherwise. pass def test_has_pair_with_sum_found(): assert has_pair_with_sum([1, 2, 3, 4, 5], 5, 2) == True # (1, 4) assert has_pair_with_sum([1, 1, 2, 2, 3, 3], 4, 4) == True # (1, 3) assert has_pair_with_sum([1, 2, 3], 5, 1) == True # (2, 3) def test_has_pair_with_sum_not_found(): assert has_pair_with_sum([1, 2, 3, 4, 5], 10, 1) == False assert has_pair_with_sum([1, 1, 1, 1, 1], 3, 2) == False assert has_pair_with_sum([1, 2, 3], 7, 2) == False def test_has_pair_with_sum_edge_cases(): assert has_pair_with_sum([], 1, 1) == False # Empty array assert has_pair_with_sum([1], 2, 1) == False # Single element assert has_pair_with_sum([1, 1], 2, 0) == False # y is 0 assert has_pair_with_sum([1, 1], 2, 1) == True # Pair (1, 1) assert has_pair_with_sum([1, 1], 2, 2) == True # Pair (1, 1)","solution":"def has_pair_with_sum(arr, x, y): Determines if there exists a pair of indices (i, j) such that: - arr[i] + arr[j] equals x - abs(i - j) <= y Parameters: arr (list): List of integers. x (int): Target sum. y (int): Maximum index difference. Returns: bool: True if such a pair exists, False otherwise. for i in range(len(arr)): for j in range(max(0, i - y), min(len(arr), i + y + 1)): if i != j and arr[i] + arr[j] == x: return True return False"},{"question":"def move_zeroes(arr): Moves all zeroes in the array to the end while maintaining the order of non-zero elements. Parameters: arr (list): List of integers. Returns: list: The modified list with all zeroes at the end. >>> move_zeroes([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> move_zeroes([0, 0, 0, 0, 0]) [0, 0, 0, 0, 0] >>> move_zeroes([0, 1, 0, 3, 12]) [1, 3, 12, 0, 0] >>> move_zeroes([1, 2, 0, 4, 0, 5, 0]) [1, 2, 4, 5, 0, 0, 0] >>> move_zeroes([0]) [0] >>> move_zeroes([1]) [1] >>> move_zeroes([1, 0, 2, 0, 3, 0, 0, 4, 5]) [1, 2, 3, 4, 5, 0, 0, 0, 0]","solution":"def move_zeroes(arr): Moves all zeroes in the array to the end while maintaining the order of non-zero elements. Parameters: arr (list): List of integers. Returns: list: The modified list with all zeroes at the end. non_zero_index = 0 # Pointer to place non-zero elements for i in range(len(arr)): if arr[i] != 0: arr[non_zero_index] = arr[i] non_zero_index += 1 for j in range(non_zero_index, len(arr)): arr[j] = 0 return arr"},{"question":"def positions_before_last_move(position): Returns the positions of the balls just before the last move is made. If the game cannot be started, return an empty list. >>> positions_before_last_move([]) == [] >>> positions_before_last_move([1]) == [] >>> positions_before_last_move([1, 2, 3, 4]) == [] >>> positions_before_last_move([2, 3, 4, 5]) == [] >>> positions_before_last_move([1, 3, 5]) == [1, 3, 5] >>> positions_before_last_move([1, 2, 4]) == [1, 2, 4] >>> positions_before_last_move([3, 6, 9]) == [3, 6, 9]","solution":"def positions_before_last_move(position): Returns the positions of the balls just before the last move is made. If the game cannot be started, return an empty list. position.sort() n = len(position) if n == 0 or n == 1: return [] for i in range(1, n): if position[i] - position[i-1] > 1: return position return []"},{"question":"def checkValidString(s: str) -> bool: Check if the input string s is valid according to the given rules. A string s is valid if: - Any left parenthesis '(' must have a corresponding right parenthesis ')'. - Any right parenthesis ')' must have a corresponding left parenthesis '('. - Left parenthesis '(' must go before the corresponding right parenthesis ')'. - '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string. >>> checkValidString(\\"()\\") True >>> checkValidString(\\"(()\\") False >>> checkValidString(\\"(*)\\") True >>> checkValidString(\\"(*))\\") True >>> checkValidString(\\"****\\") True >>> checkValidString(\\"(()**)\\") True >>> checkValidString(\\"((*)\\") True >>> checkValidString(\\")(\\") False","solution":"def checkValidString(s: str) -> bool: Check if the input string s is valid according to the given rules. left_balance = 0 for char in s: if char == '(' or char == '*': left_balance += 1 else: left_balance -= 1 if left_balance < 0: return False right_balance = 0 for char in reversed(s): if char == ')' or char == '*': right_balance += 1 else: right_balance -= 1 if right_balance < 0: return False return True"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Returns the lexicographically smallest string that can be obtained by choosing from the first k characters and appending them to the end. >>> lexicographically_smallest_string(\\"cba\\", 1) == \\"acb\\" >>> lexicographically_smallest_string(\\"abc\\", 2) == \\"abc\\" >>> lexicographically_smallest_string(\\"cab\\", 1) == \\"abc\\" >>> lexicographically_smallest_string(\\"dcba\\", 4) == \\"abcd\\" >>> lexicographically_smallest_string(\\"z\\", 1) == \\"z\\" >>> lexicographically_smallest_string(\\"aaaaa\\", 2) == \\"aaaaa\\" >>> lexicographically_smallest_string(\\"ba\\", 1) == \\"ab\\" >>> lexicographically_smallest_string(\\"ba\\", 2) == \\"ab\\"","solution":"def lexicographically_smallest_string(s, k): Returns the lexicographically smallest string that can be obtained by choosing from the first k characters and appending them to the end. if k == 1: smallest_string = s for i in range(1, len(s)): rotated = s[i:] + s[:i] if rotated < smallest_string: smallest_string = rotated return smallest_string else: return ''.join(sorted(s))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root: TreeNode, low: int, high: int) -> int: Returns the sum of all nodes with values within a given range [low, high] in a binary search tree. >>> root = TreeNode(10, TreeNode(5), TreeNode(15)) >>> rangeSumBST(root, 5, 15) 30 >>> root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) >>> rangeSumBST(root, 7, 15) 32 >>> root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) >>> rangeSumBST(root, 20, 25) 0 >>> root = TreeNode(10) >>> rangeSumBST(root, 5, 15) 10 >>> root = None >>> rangeSumBST(root, 5, 15) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root: TreeNode, low: int, high: int) -> int: def dfs(node: TreeNode) -> int: if not node: return 0 if node.val < low: return dfs(node.right) if node.val > high: return dfs(node.left) return node.val + dfs(node.left) + dfs(node.right) return dfs(root)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head: ListNode) -> ListNode: Reverses a singly linked list. :param head: ListNode, the head of the singly linked list :return: ListNode, the head of the new reversed list >>> list_to_array(reverseList(array_to_list([1, 2, 3, 4, 5]))) == [5, 4, 3, 2, 1] >>> list_to_array(reverseList(array_to_list([1, 2, 2, 3, 3, 4]))) == [4, 3, 3, 2, 2, 1] >>> list_to_array(reverseList(array_to_list([1]))) == [1] >>> list_to_array(reverseList(None)) == None def list_to_array(head: ListNode): Helper function to convert linked list to a Python list for easier comparison in tests array = [] current = head while current: array.append(current.val) current = current.next return array def array_to_list(array): Helper function to convert a Python list to a linked list if not array: return None head = ListNode(array[0]) current = head for value in array[1:]: current.next = ListNode(value) current = current.next return head def test_reverse_empty_list(): assert reverseList(None) == None def test_reverse_single_element_list(): head = ListNode(1) assert list_to_array(reverseList(head)) == [1] def test_reverse_multiple_element_list(): head = array_to_list([1, 2, 3, 4, 5]) reversed_head = reverseList(head) assert list_to_array(reversed_head) == [5, 4, 3, 2, 1] def test_reverse_multiple_element_list_with_duplicates(): head = array_to_list([1, 2, 2, 3, 3, 4]) reversed_head = reverseList(head) assert list_to_array(reversed_head) == [4, 3, 3, 2, 2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseList(head: ListNode) -> ListNode: Reverses a singly linked list. :param head: ListNode, the head of the singly linked list :return: ListNode, the head of the new reversed list prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def max_guests(arrivalTimes: List[int], k: int) -> int: Determines the maximum number of guests present at any given time. Parameters: arrivalTimes (list of int): List of guests' arrival times. k (int): Duration of stay for each guest in minutes. Returns: int: Maximum number of guests present at the event simultaneously. >>> max_guests([1], 5) 1 >>> max_guests([1, 7, 13, 19, 25], 5) 1 >>> max_guests([1, 1, 1, 1, 1], 5) 5 >>> max_guests([1, 2, 3, 4, 5], 5) 5 >>> max_guests([1, 2, 10, 15, 20], 5) 2 >>> max_guests([1, 5, 9, 13, 17], 3) 1","solution":"def max_guests(arrivalTimes, k): Determines the maximum number of guests present at any given time. Parameters: arrivalTimes (list of int): List of guests' arrival times. k (int): Duration of stay for each guest in minutes. Returns: int: Maximum number of guests present at the event simultaneously. events = [] for arrival in arrivalTimes: events.append((arrival, 'arrive')) events.append((arrival + k, 'depart')) # Sort events by time with 'arrive' events taking priority if they have the same time events.sort(key=lambda x: (x[0], x[1] == 'depart')) max_guests = 0 current_guests = 0 for event in events: if event[1] == 'arrive': current_guests += 1 max_guests = max(max_guests, current_guests) else: current_guests -= 1 return max_guests"},{"question":"def maximize_sum(nums, k): Modify the list so that each element is incremented by \`k\` non-negative integer multiples. Return the maximum possible sum of the modified list while keeping the elements in non-decreasing order. Args: nums: list of non-negative integers k: non-negative integer Returns: int: maximum possible sum of the modified list >>> maximize_sum([1], 5) 1 >>> maximize_sum([1, 1, 1], 2) 9 >>> maximize_sum([1, 2, 3], 1) 9 >>> maximize_sum([1, 2, 3], 10) 36 >>> maximize_sum([0, 0, 0], 1) 3","solution":"def maximize_sum(nums, k): Modify the list so that each element is incremented by \`k\` non-negative integer multiples. Return the maximum possible sum of the modified list + while keeping the elements in non-decreasing order. Args: nums: list of non-negative integers k: non-negative integer Returns: int: maximum possible sum of the modified list nums.sort() max_sum = 0 for i in range(len(nums)): nums[i] += k * i max_sum += nums[i] return max_sum"},{"question":"from typing import List def find_the_city(n: int, roads: List[List[int]], distance: int) -> int: Find the city with the smallest number of neighbors at a distance less than or equal to a given threshold. Args: n (int): The number of cities. roads (List[List[int]]): A list of roads where each road is represented as [city1, city2, distance_i]. distance (int): The threshold distance. Returns: int: The city with the desired properties. Examples: >>> find_the_city(4, [[0, 1, 3], [1, 2, 1], [1, 3, 4], [2, 3, 1]], 4) 3 >>> find_the_city(3, [[0, 1, 3], [1, 2, 1]], 3) 2 >>> find_the_city(5, [[0, 1, 2], [0, 4, 8], [1, 2, 3], [1, 4, 2], [2, 3, 1], [3, 4, 1]], 2) 0 >>> find_the_city(5, [], 1) 4 >>> find_the_city(5, [[0, 1, 2], [0, 4, 8], [1, 2, 3], [1, 4, 2], [2, 3, 1], [3, 4, 1]], 10) 4","solution":"from collections import defaultdict, deque def find_the_city(n, roads, distance): def dijkstra(src): import heapq distances = {i: float('inf') for i in range(n)} distances[src] = 0 min_heap = [(0, src)] while min_heap: curr_dist, u = heapq.heappop(min_heap) if curr_dist > distances[u]: continue for v, w in neighbors[u]: if curr_dist + w < distances[v]: distances[v] = curr_dist + w heapq.heappush(min_heap, (distances[v], v)) return distances neighbors = defaultdict(list) for u, v, w in roads: neighbors[u].append((v, w)) neighbors[v].append((u, w)) min_neighbor_count = float('inf') best_city = -1 for city in range(n): distances = dijkstra(city) neighbor_count = sum(1 for d in distances.values() if d <= distance) if neighbor_count < min_neighbor_count or (neighbor_count == min_neighbor_count and city > best_city): min_neighbor_count = neighbor_count best_city = city return best_city"},{"question":"def contains_all_integers_subarray(A: List[int], K: int) -> bool: Determine if there exists a continuous subarray of length K that contains every integer from 1 to K (inclusive). Arguments: A -- List of integers. K -- Length of the subarray and the range of integers to check (from 1 to K). Returns: boolean -- True if such a subarray exists, otherwise False. >>> contains_all_integers_subarray([2, 1, 3, 4, 6, 5], 3) == True >>> contains_all_integers_subarray([1, 2, 3, 4, 5], 5) == True >>> contains_all_integers_subarray([1, 2, 2, 4, 5], 3) == False >>> contains_all_integers_subarray([4, 5, 6, 7, 8], 3) == False >>> contains_all_integers_subarray([1, 2], 3) == False >>> contains_all_integers_subarray([], 1) == False >>> contains_all_integers_subarray([1], 1) == True >>> contains_all_integers_subarray([3, 3, 2, 1, 4, 4], 4) == True >>> contains_all_integers_subarray([3, 3, 2, 1, 3, 4, 4, 2, 1, 3], 4) == True pass","solution":"def contains_all_integers_subarray(A, K): Determine if there exists a continuous subarray of length K that contains every integer from 1 to K (inclusive). Arguments: A -- List of integers. K -- Length of the subarray and the range of integers to check (from 1 to K). Returns: boolean -- True if such a subarray exists, otherwise False. # Check for early exit if K > len(A) if K > len(A): return False # Required set of integers from 1 to K required_set = set(range(1, K + 1)) # Slide over the array with a window of size K for i in range(len(A) - K + 1): if set(A[i:i+K]) == required_set: return True return False"},{"question":"def min_cost_to_palindrome(s: str, matrix: List[List[int]]) -> int: Return the minimum cost to transform the given string \`s\` into a palindrome using the provided cost matrix. Args: s (str): A string consisting of lowercase Latin letters. matrix (List[List[int]]): A matrix where matrix[i][j] represents the cost of replacing character \`i\` with character \`j\`. Returns: int: The minimum cost to transform \`s\` into a palindrome. >>> min_cost_to_palindrome(\\"racecar\\", [[0]*26 for _ in range(26)]) 0 >>> min_cost_to_palindrome(\\"a\\", [[0]*26 for _ in range(26)]) 0 >>> min_cost_to_palindrome(\\"ab\\", [[0]*26 for _ in range(26)]) 1 >>> min_cost_to_palindrome(\\"abcd\\", [[0]*26 for _ in range(26)]) 3 >>> min_cost_to_palindrome(\\"gfedcba\\", [[0]*26 for _ in range(26)]) 12","solution":"def min_cost_to_palindrome(s, matrix): n = len(s) cost = 0 for i in range(n // 2): left_char = s[i] right_char = s[n - i - 1] if left_char != right_char: left_idx = ord(left_char) - ord('a') right_idx = ord(right_char) - ord('a') cost += min(matrix[left_idx][right_idx], matrix[right_idx][left_idx]) return cost"},{"question":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def sortLinkedList(head): Rearrange the linked list in non-decreasing order based on node values. def linked_list_to_list(head): Helper function to convert linked list to a list result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(items): Helper function to convert a list to a linked list if not items: return None head = Node(items[0]) current = head for item in items[1:]: current.next = Node(item) current = current.next return head def test_sort_linked_list_given_example(): values = [4, 2, 1, 3] head = list_to_linked_list(values) sorted_head = sortLinkedList(head) assert linked_list_to_list(sorted_head) == [1, 2, 3, 4] def test_sort_single_element_list(): values = [1] head = list_to_linked_list(values) sorted_head = sortLinkedList(head) assert linked_list_to_list(sorted_head) == [1] def test_sort_empty_list(): head = None sorted_head = sortLinkedList(head) assert sorted_head == None def test_sort_already_sorted_list(): values = [1, 2, 3, 4] head = list_to_linked_list(values) sorted_head = sortLinkedList(head) assert linked_list_to_list(sorted_head) == [1, 2, 3, 4] def test_sort_reverse_list(): values = [4, 3, 2, 1] head = list_to_linked_list(values) sorted_head = sortLinkedList(head) assert linked_list_to_list(sorted_head) == [1, 2, 3, 4] def test_sort_duplicate_values(): values = [4, 2, 4, 3, 1, 2] head = list_to_linked_list(values) sorted_head = sortLinkedList(head) assert linked_list_to_list(sorted_head) == [1, 2, 2, 3, 4, 4]","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def sortLinkedList(head): Rearrange the linked list in non-decreasing order based on node values. if not head or not head.next: return head # Convert linked list to array current = head values = [] while current: values.append(current.val) current = current.next # Sort the array values.sort() # Convert array back to linked list current = head for value in values: current.val = value current = current.next return head"},{"question":"def findLength(arr1: List[int], arr2: List[int]) -> int: Finds the length of the longest common subarray between arr1 and arr2. >>> findLength([1,2,3,2,1], [3,2,1,4,7]) == 3 >>> findLength([0,0,0,0,0], [0,0,0,0,0]) == 5 >>> findLength([1,2,3], [4,5,6]) == 0 >>> findLength([], [1,2,3]) == 0 >>> findLength([1,2,3], []) == 0 >>> findLength([], []) == 0 >>> findLength([1,2,3,4,5], [2,3,4,5,6]) == 4 >>> findLength([1,2,3], [3, 4, 5]) == 1","solution":"def findLength(arr1, arr2): Finds the length of the longest common subarray between arr1 and arr2. m, n = len(arr1), len(arr2) dp = [[0] * (n + 1) for _ in range(m + 1)] max_length = 0 for i in range(1, m + 1): for j in range(1, n + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"def shortest_palindrome(s: str) -> str: Find the shortest palindrome by adding characters in front of the given string. >>> shortest_palindrome(\\"aacecaaa\\") \\"aaacecaaa\\" >>> shortest_palindrome(\\"abcd\\") \\"dcbabcd\\" >>> shortest_palindrome(\\"\\") \\"\\" >>> shortest_palindrome(\\"a\\") \\"a\\" >>> shortest_palindrome(\\"racecar\\") \\"racecar\\" >>> shortest_palindrome(\\"aabba\\") \\"abbaabba\\"","solution":"def shortest_palindrome(s): Returns the shortest palindrome that can be formed by adding characters in front of the string s. if not s: return s rev_s = s[::-1] l = s + '#' + rev_s p = [0] * len(l) for i in range(1, len(l)): j = p[i - 1] while j > 0 and l[i] != l[j]: j = p[j - 1] if l[i] == l[j]: j += 1 p[i] = j return rev_s[:len(s) - p[-1]] + s"},{"question":"def find_cut_index(arr: List[int]) -> int: You are given an array of positive integers \`arr\`, where each integer represents the height of a tree in a forest. You want to cut exactly one tree such that the resulting sequence of tree heights is strictly increasing from left to right. If it is possible to make such a cut, return the index of the tree to be cut. If there are multiple answers, return any one of them. If it is not possible to make the sequence strictly increasing with one cut, return -1. Ensure your solution has a linear time complexity. >>> find_cut_index([1, 2, 3, 4]) -1 >>> find_cut_index([3, 1, 2, 3]) in (0, ) True >>> find_cut_index([1, 2, 3, 2]) in (3, ) True >>> find_cut_index([1, 3, 2, 4]) in (1, 2) True >>> find_cut_index([4, 3, 2, 1]) -1 >>> find_cut_index([1, 2, 2, 3]) in (1, 2) True","solution":"def find_cut_index(arr): def is_valid(arr): for i in range(1, len(arr)): if arr[i] <= arr[i-1]: return False return True n = len(arr) if is_valid(arr): return -1 for i in range(n): if is_valid(arr[:i] + arr[i+1:]): return i return -1"},{"question":"def find_unstable_elements(nums: List[int], k: int) -> List[int]: Returns the list of indexes of unstable elements in the array nums. An element nums[i] is considered unstable if there is at least one neighboring element that differs from it by more than k. >>> find_unstable_elements([1, 2, 3, 4], 3) [] >>> find_unstable_elements([5, 5, 5, 5], 0) [] >>> find_unstable_elements([1, 3, 5, 7], 1) [0, 1, 2, 3] >>> find_unstable_elements([1, 2, 3, 10], 3) [2, 3] >>> find_unstable_elements([1, 5, 2, 8], 3) [0, 1, 2, 3] >>> find_unstable_elements([1], 0) [] >>> find_unstable_elements([1, 10], 5) [0, 1] >>> find_unstable_elements([10, 1], 5) [0, 1]","solution":"def find_unstable_elements(nums, k): Returns the list of indexes of unstable elements in the array nums. An element nums[i] is considered unstable if there is at least one neighboring element that differs from it by more than k. n = len(nums) unstable_indexes = [] for i in range(n): if (i > 0 and abs(nums[i] - nums[i - 1]) > k) or (i < n - 1 and abs(nums[i] - nums[i + 1]) > k): unstable_indexes.append(i) return unstable_indexes"},{"question":"def rob(arr): Determines the maximum amount of money that can be stolen without triggering the alarms. Parameters: arr (list of int): List of integers representing money in houses. Returns: int: Maximum amount of money that can be stolen. Examples: >>> rob([]) 0 >>> rob([10]) 10 >>> rob([10, 20]) 20 >>> rob([10, 20, 30]) 40 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([100, 1, 100, 1, 100]) 300 >>> rob([50, 3, 50, 3, 50, 3, 50]) 200","solution":"def rob(arr): Determines the maximum amount of money that can be stolen without triggering the alarms. Parameters: arr (list of int): List of integers representing money in houses. Returns: int: Maximum amount of money that can be stolen. if not arr: return 0 if len(arr) == 1: return arr[0] prev2, prev1 = 0, arr[0] for i in range(1, len(arr)): current = max(prev1, prev2 + arr[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"def is_subsequence(s: str, pattern: str) -> bool: Helper function to determine if a pattern is a subsequence of the string s. it = iter(s) return all(char in it for char in pattern) def check_patterns(s: str, patterns: List[str]) -> List[bool]: Determines for each pattern in patterns whether it is a subsequence of the string s. Args: s (str): The source string. patterns (list of str): The list of patterns to check. Returns: list of bool: List of boolean values indicating whether each pattern is a subsequence of s. >>> check_patterns(\\"abcdef\\", [\\"abc\\", \\"def\\", \\"acf\\", \\"af\\"]) [True, True, True, True] >>> check_patterns(\\"abcdef\\", [\\"z\\", \\"gh\\", \\"xyz\\", \\"az\\"]) [False, False, False, False] >>> check_patterns(\\"abcdef\\", [\\"\\", \\"\\"]) [True, True]","solution":"def is_subsequence(s, pattern): Helper function to determine if a pattern is a subsequence of s. it = iter(s) return all(char in it for char in pattern) def check_patterns(s, patterns): Determines for each pattern in patterns whether it is a subsequence of the string s. Parameters: s (str): The source string. patterns (list of str): The list of patterns to check. Returns: list of bool: List of boolean values indicating whether each pattern is a subsequence of s. return [is_subsequence(s, pattern) for pattern in patterns]"},{"question":"def min_operations_to_equal_array(arr): Returns the minimum number of operations required to make all elements in the array equal. Each operation replaces the larger of two selected elements with the value of the smaller one. >>> min_operations_to_equal_array([5, 5, 5, 5]) == 0 >>> min_operations_to_equal_array([1, 2, 3, 4, 5]) == 4 >>> min_operations_to_equal_array([10, 20, 30]) == 2 >>> min_operations_to_equal_array([10, 10, 20, 30, 10]) == 2 >>> min_operations_to_equal_array([100]) == 0 >>> min_operations_to_equal_array([10**9, 10**9 - 1, 10**9 - 2]) == 2 >>> min_operations_to_equal_array([i for i in range(1, 10001)]) == 9999","solution":"def min_operations_to_equal_array(arr): Returns the minimum number of operations required to make all elements in the array equal. Each operation replaces the larger of two selected elements with the value of the smaller one. # The optimal strategy is to make all elements equal to the smallest element in the array, # since that reduces the number of necessary operations to the minimum. min_element = min(arr) operations = 0 for num in arr: if num != min_element: operations += 1 return operations"},{"question":"class Tree: A class representing a binary tree with efficient update and query operations. You are given a binary tree with \`n\` nodes, where each node is uniquely labeled from \`1\` to \`n\`. The tree is represented as an array \`parent\`, where \`parent[i]\` is the parent of the \`(i + 1)\`-th node (for each \`i\` in the range \`0\` to \`n-1\`). The root node has \`parent[root-1] = -1\`. Each node in the tree also has a value associated with it given by an integer array \`value\` of length \`n\`. Attributes: n (int): Number of nodes in the tree. parent (List[int]): The parent array where parent[i] represents the parent of (i+1)-th node. value (List[int]): The values associated with each node. children (List[List[int]]): The list of child nodes for each node. Methods: __init__(int, List[int], List[int]): Initializes the Tree class. updateValue(int, int): Updates the value of a specified node. querySum(int): Returns the sum of the values of the subtree rooted at a specified node. Example: >>> n = 5 >>> parent = [-1, 0, 0, 1, 1] >>> value = [1, 2, 3, 4, 5] >>> tree = Tree(n, parent, value) >>> tree.querySum(0) 15 >>> tree.updateValue(2, 10) >>> tree.querySum(0) 22 def __init__(self, n, parent, value): pass def updateValue(self, node, newValue): pass def querySum(self, node): pass # Test cases def test_tree_initialization(): n = 5 parent = [-1, 0, 0, 1, 1] value = [1, 2, 3, 4, 5] tree = Tree(n, parent, value) assert tree.n == n assert tree.parent == parent assert tree.value == value assert tree.children == [[1, 2], [3, 4], [], [], []] def test_update_value(): n = 5 parent = [-1, 0, 0, 1, 1] value = [1, 2, 3, 4, 5] tree = Tree(n, parent, value) tree.updateValue(2, 10) assert tree.value[2] == 10 def test_query_sum(): n = 5 parent = [-1, 0, 0, 1, 1] value = [1, 2, 3, 4, 5] tree = Tree(n, parent, value) assert tree.querySum(0) == 15 # Sum of all nodes assert tree.querySum(1) == 11 # Sum of subtree rooted at node 1: 2 + 4 + 5 assert tree.querySum(2) == 3 # Node 2 itself # After updating values tree.updateValue(2, 10) assert tree.querySum(0) == 22 # Sum after update assert tree.querySum(2) == 10 # Updated node","solution":"class Tree: def __init__(self, n, parent, value): self.n = n self.parent = parent self.value = value self.children = [[] for _ in range(n)] for i in range(n): if parent[i] != -1: self.children[parent[i]].append(i) def updateValue(self, node, newValue): self.value[node] = newValue def querySum(self, node): def dfs(node): total = self.value[node] for child in self.children[node]: total += dfs(child) return total return dfs(node)"},{"question":"def countBinarySubstrings(s: str) -> int: Returns the number of contiguous substrings that have an equal number of \`0\` and \`1\`, and all the \`0\`s and all the \`1\`s in these substrings are grouped consecutively. >>> countBinarySubstrings(\\"00110011\\") 6 >>> countBinarySubstrings(\\"10101\\") 4 >>> countBinarySubstrings(\\"000111\\") 3 >>> countBinarySubstrings(\\"00011\\") 2 >>> countBinarySubstrings(\\"10001\\") 2 >>> countBinarySubstrings(\\"0000\\") 0 >>> countBinarySubstrings(\\"1111\\") 0 >>> countBinarySubstrings(\\"00100\\") 2 >>> countBinarySubstrings(\\"\\") 0 >>> countBinarySubstrings(\\"01\\") 1 >>> countBinarySubstrings(\\"10\\") 1","solution":"def countBinarySubstrings(s): Returns the number of contiguous substrings that have an equal number of \`0\` and \`1\`, and all the \`0\`s and all the \`1\`s in these substrings are grouped consecutively. # Lengths of consecutive groups of '0's or '1's groups = [] continuous_length = 1 # Create the groups array for i in range(1, len(s)): if s[i] == s[i - 1]: continuous_length += 1 else: groups.append(continuous_length) continuous_length = 1 groups.append(continuous_length) # Count the valid substrings count = 0 for i in range(1, len(groups)): count += min(groups[i], groups[i - 1]) return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_bst_subtree_sum(root: TreeNode) -> int: Computes the maximum population sum of any BST subtree in the given binary tree. >>> root = TreeNode(5) >>> max_bst_subtree_sum(root) 5 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> max_bst_subtree_sum(root) 30 >>> root = TreeNode(10) >>> root.left = TreeNode(15) >>> root.right = TreeNode(5) >>> max_bst_subtree_sum(root) 15 # Best subtree is either left or right child >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(8) >>> root.right.left = TreeNode(12) >>> root.right.right = TreeNode(20) >>> max_bst_subtree_sum(root) 71 # Whole tree is a BST >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.left.right = TreeNode(20) >>> root.right = TreeNode(15) >>> root.right.left = TreeNode(12) >>> root.right.right = TreeNode(20) >>> max_bst_subtree_sum(root) 47 # Best BST is the right subtree [15, 12, 20] pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_bst_subtree_sum(root): def postorder_traversal(node): if not node: return (True, 0, float('inf'), float('-inf')) l_is_bst, l_sum, l_min, l_max = postorder_traversal(node.left) r_is_bst, r_sum, r_min, r_max = postorder_traversal(node.right) if l_is_bst and r_is_bst and l_max < node.val < r_min: current_sum = node.val + l_sum + r_sum max_sum[0] = max(max_sum[0], current_sum) return (True, current_sum, min(l_min, node.val), max(r_max, node.val)) else: return (False, 0, 0, 0) max_sum = [0] postorder_traversal(root) return max_sum[0]"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence in the array. :param nums: List[int], the array of integers :return: int, the length of the longest consecutive elements sequence >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) # Sequence: [1, 2, 3, 4] 4 >>> longest_consecutive_sequence([1]) # Single element 1 >>> longest_consecutive_sequence([]) # Empty list 0 >>> longest_consecutive_sequence([1, 2, 2, 3]) # Duplicates 3 >>> longest_consecutive_sequence([-1, -2, -3, 0, 1, 2]) # With negatives 6 >>> longest_consecutive_sequence([10, 5, 12, 6, 7, 20, 8, 21, 22]) # Disjoint sequences 4 >>> longest_consecutive_sequence([1, 3, 5, 2, 4]) # Unordered list 5","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence in the array. :param nums: List[int], the array of integers :return: int, the length of the longest consecutive elements sequence if not nums: return 0 num_set = set(nums) max_length = 0 for num in num_set: if num - 1 not in num_set: # Only start counting if \`num\` is the start of a sequence current_num = num current_length = 1 while current_num + 1 in num_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def find_error_nums(nums): This function finds the duplicated and missing number in the given permutation of numbers. Args: nums (list of int): A list of integers representing a permutation with one duplicate and one missing. Returns: list of int: A list containing the duplicated number and the missing number. Examples: >>> find_error_nums([3, 1, 2, 2]) [2, 4] >>> find_error_nums([1, 2, 2, 4]) [2, 3]","solution":"def find_error_nums(nums): This function finds the duplicated and missing number in the given permutation of numbers. Args: nums (list of int): A list of integers representing a permutation with one duplicate and one missing. Returns: list of int: A list containing the duplicated number and the missing number. n = len(nums) actual_sum = sum(nums) expected_sum = n * (n + 1) // 2 expected_square_sum = sum([i ** 2 for i in range(1, n + 1)]) actual_square_sum = sum([x ** 2 for x in nums]) diff = expected_sum - actual_sum square_diff = expected_square_sum - actual_square_sum missing_plus_dup = square_diff // diff missing = (diff + missing_plus_dup) // 2 dup = missing_plus_dup - missing return [dup, missing]"},{"question":"def maxCircularSubarraySum(nums: List[int]) -> int: Calculate the maximum sum of a contiguous subarray in a circular array. >>> maxCircularSubarraySum([1, -2, 3, -2]) == 3 >>> maxCircularSubarraySum([5, -3, 5]) == 10 >>> maxCircularSubarraySum([3, -1, 2, -1]) == 4 >>> maxCircularSubarraySum([-2, -3, -1]) == -1 >>> maxCircularSubarraySum([2, -1, 2, -1, 2, -1, 2]) == 6 >>> maxCircularSubarraySum([8, -1, -1, -1, 8]) == 16","solution":"def maxCircularSubarraySum(nums): Returns the maximum sum of a contiguous subarray in a circular array. def kadane(arr): max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far n = len(nums) max_kadane = kadane(nums) max_wrap = sum(nums) # Invert sign of all elements to find the minimum subarray sum using kadane's algorithm for i in range(n): nums[i] = -nums[i] max_wrap = max_wrap + kadane(nums) # max_wrap would be zero if all numbers are negative, so return max_kadane in that case if max_wrap == 0: return max_kadane return max(max_kadane, max_wrap)"},{"question":"def max_area(heights): Given an array of non-negative integers representing the heights of a series of buildings, return the maximum area of water that can be trapped between two buildings after a rainstorm. This must be done using a linear time complexity algorithm. :param heights: List[int] :return: int >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) == 49 >>> max_area([1, 1]) == 1 >>> max_area([4, 3, 2, 1, 4]) == 16 >>> max_area([1, 2, 1]) == 2","solution":"def max_area(heights): Returns the maximum area of water that can be trapped between two buildings. :param heights: List[int] :return: int left, right = 0, len(heights) - 1 max_water = 0 while left < right: # Calculate the width and the constrained height width = right - left height = min(heights[left], heights[right]) # Calculate the current area current_area = width * height max_water = max(max_water, current_area) # Move the pointer of the shorter building inward if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def min_operations_to_empty_string(s: str) -> int: Returns the minimum number of operations required to make the string empty. >>> min_operations_to_empty_string(\\"a\\") == 1 >>> min_operations_to_empty_string(\\"aaaaaa\\") == 1 >>> min_operations_to_empty_string(\\"ab\\") == 2 >>> min_operations_to_empty_string(\\"aabb\\") == 2 >>> min_operations_to_empty_string(\\"aabbaa\\") == 3 >>> min_operations_to_empty_string(\\"abababab\\") == 8 >>> min_operations_to_empty_string(\\"abcde\\") == 5","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations required to make the string empty. operations = 0 i = 0 while i < len(s): operations += 1 char = s[i] while i < len(s) and s[i] == char: i += 1 return operations"},{"question":"from typing import List def generate_string_array(n: int) -> List[str]: Generate a string array of length \`n\` with given constraints. Each string has a length of i (1 ≤ i ≤ n) and contains alphabetically increasing characters starting from 'a'. Parameters: n (int): The length of the string array to generate. Returns: list[str]: A list of strings meeting the criteria. >>> generate_string_array(1) [\\"a\\"] >>> generate_string_array(2) [\\"a\\", \\"ab\\"] >>> generate_string_array(3) [\\"a\\", \\"ab\\", \\"abc\\"] >>> generate_string_array(4) [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"] >>> generate_string_array(0) [] >>> generate_string_array(5) [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"]","solution":"def generate_string_array(n): Generate a string array of length \`n\` with given constraints. Each string has a length of i (1 ≤ i ≤ n) and contains alphabetically increasing characters starting from 'a'. Parameters: n (int): The length of the string array to generate. Returns: list[str]: A list of strings meeting the criteria. ans = [] for i in range(1, n + 1): # Generate string of length i ans.append(\\"\\".join(chr(97 + j) for j in range(i))) return ans"},{"question":"from typing import List def longest_non_decreasing_sequence(heights: List[int]) -> int: Returns the length of the longest non-decreasing sequence of heights. :param heights: List[int] - A list of integers representing the heights of blocks. :return: int - The length of the longest non-decreasing sequence. >>> longest_non_decreasing_sequence([1, 3, 2, 3, 4, 5, 1, 2, 2, 3]) 4 >>> longest_non_decreasing_sequence([5, 5, 5, 5, 5]) 5 >>> longest_non_decreasing_sequence([1, 2, 3, 4, 5]) 5 >>> longest_non_decreasing_sequence([10]) 1 >>> longest_non_decreasing_sequence([5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_sequence([]) 0","solution":"def longest_non_decreasing_sequence(heights): Returns the length of the longest non-decreasing sequence of heights. :param heights: List[int] - A list of integers representing the heights of blocks. :return: int - The length of the longest non-decreasing sequence. if not heights: return 0 longest_seq = 1 current_seq = 1 for i in range(1, len(heights)): if heights[i] >= heights[i - 1]: current_seq += 1 longest_seq = max(longest_seq, current_seq) else: current_seq = 1 return longest_seq"},{"question":"from typing import List def min_window(s: str, t: str) -> str: Determine the minimum window in \`s\` which will contain all the characters in \`t\` in their order of appearance. >>> min_window(\\"abcdebdde\\", \\"bde\\") == \\"bcde\\" >>> min_window(\\"abc\\", \\"def\\") == \\"\\" >>> min_window(\\"abcdefg\\", \\"abcdefg\\") == \\"abcdefg\\" >>> min_window(\\"abcdebdde\\", \\"bd\\") == \\"bd\\" >>> min_window(\\"abcdebdde\\", \\"e\\") == \\"e\\" >>> min_window(\\"abcdebdde\\", \\"\\") == \\"\\"","solution":"def min_window(s, t): def find_sub_sequence(s, t): i, j = 0, 0 while i < len(s) and j < len(t): if s[i] == t[j]: j += 1 i += 1 return j == len(t) if not t: return \\"\\" min_len = float(\\"inf\\") result = \\"\\" for i in range(len(s)): if s[i] == t[0]: for j in range(i, len(s)): if find_sub_sequence(s[i:j+1], t): if j - i + 1 < min_len: min_len = j - i + 1 result = s[i:j+1] break return result"},{"question":"class MazeSolver: def __init__(self, grid): Initializes the MazeSolver with the maze grid. Args: grid (List[List[str]]): A 2D grid representing the maze where 'P' is the starting point, 'W' is a wall, and 'O' is an open space. self.grid = grid def findShortestPath(self) -> int: Returns the length of the shortest path from the starting position 'P' to the bottom-right corner of the maze. If no such path exists, returns -1. Returns: int: The length of the shortest path or -1 if no path exists. >>> solver = MazeSolver([['P', 'O', 'O'], ['O', 'W', 'O'], ['O', 'O', 'O']]) >>> solver.findShortestPath() 4 >>> solver = MazeSolver([['P', 'W', 'O'], ['O', 'W', 'O'], ['O', 'W', 'O']]) >>> solver.findShortestPath() -1 pass","solution":"from collections import deque class MazeSolver: def __init__(self, grid): self.grid = grid self.n = len(grid) def findShortestPath(self): if not self.grid or self.grid[0][0] != 'P': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if (r, c) == (self.n-1, self.n-1): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < self.n and 0 <= nc < self.n and self.grid[nr][nc] != 'W' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def exist(grid: List[List[str]], word: str) -> bool: Determines if the given word exists in the grid using sequentially adjacent cells. >>> grid = [[\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"]] >>> exist(grid, \\"ABCCED\\") True >>> exist(grid, \\"SEEPA\\") False >>> exist(grid, \\"\\") True >>> exist([[]], \\"A\\") False","solution":"def exist(grid, word): def dfs(i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != word[word_index] or (i, j) in visited: return False visited.add((i, j)) result = (dfs(i+1, j, word_index+1) or dfs(i-1, j, word_index+1) or dfs(i, j+1, word_index+1) or dfs(i, j-1, word_index+1)) visited.remove((i, j)) return result for i in range(len(grid)): for j in range(len(grid[0])): visited = set() if dfs(i, j, 0): return True return False"},{"question":"def can_split_into_k_palindromes(s: str, k: int) -> bool: Determine if the string \`s\` can be split into exactly \`k\` substrings, where each substring is a palindrome. >>> can_split_into_k_palindromes(\\"aab\\", 2) True >>> can_split_into_k_palindromes(\\"aabb\\", 4) True >>> can_split_into_k_palindromes(\\"racecar\\", 1) True >>> can_split_into_k_palindromes(\\"racecar\\", 2) False","solution":"def can_split_into_k_palindromes(s, k): def is_palindrome(sub): return sub == sub[::-1] n = len(s) # If k is greater than the length of s, we cannot split it into k non-empty substrings if k > n: return False dp = [[False] * n for _ in range(n)] # Fill dp array: dp[i][j] will be True if s[i:j+1] is a palindrome for length in range(1, n + 1): for i in range(n - length + 1): j = i + length - 1 if length == 1: dp[i][j] = True elif length == 2: dp[i][j] = (s[i] == s[j]) else: dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] def can_partition(start, k): if k == 0: return start == n if k < 0: return False for end in range(start, n): if dp[start][end]: if can_partition(end + 1, k - 1): return True return False return can_partition(0, k)"},{"question":"def unobstructed_views(arr: List[int]) -> int: Returns the number of buildings with an unobstructed view from the leftmost side of the array. Parameters: arr (List[int]): A list of integers representing the heights of buildings. Returns: int: The number of buildings with an unobstructed view. >>> unobstructed_views([]) == 0 >>> unobstructed_views([10]) == 1 >>> unobstructed_views([1, 2, 3, 4, 5]) == 5 >>> unobstructed_views([5, 4, 3, 2, 1]) == 1 >>> unobstructed_views([3, 1, 4, 2, 5]) == 3 >>> unobstructed_views([5, 5, 5, 5, 5]) == 1 >>> unobstructed_views([4, 3, 6, 7, 8, 2, 3, 4]) == 4","solution":"def unobstructed_views(arr): Returns the number of buildings with an unobstructed view from the leftmost side of the array. Parameters: arr (List[int]): A list of integers representing the heights of buildings. Returns: int: The number of buildings with an unobstructed view. n = len(arr) if n == 0: return 0 count = 1 # The first building always has an unobstructed view. max_height = arr[0] for i in range(1, n): if arr[i] > max_height: count += 1 max_height = arr[i] return count"},{"question":"def max_effectiveness_difference(numbers): Returns the maximum possible difference between any two elements in the array such that the higher element appears after the lower element. >>> max_effectiveness_difference([]) == 0 >>> max_effectiveness_difference([5]) == 0 >>> max_effectiveness_difference([1, 2, 3, 4, 5]) == 4 >>> max_effectiveness_difference([5, 4, 3, 2, 1]) == 0 >>> max_effectiveness_difference([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == 8 >>> max_effectiveness_difference([2, 2, 2, 2]) == 0 >>> max_effectiveness_difference([10, 1, 10]) == 9 >>> max_effectiveness_difference([2, 3, 10, 2, 4, 8, 1]) == 8","solution":"def max_effectiveness_difference(numbers): Returns the maximum possible difference between any two elements in the array such that the higher element appears after the lower element. if not numbers or len(numbers) < 2: return 0 min_value = numbers[0] max_diff = 0 for number in numbers[1:]: if number > min_value: max_diff = max(max_diff, number - min_value) min_value = min(min_value, number) return max_diff"},{"question":"def find_sum_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns an array of all the sum pairs of nums where nums[i] + nums[j] == target. >>> find_sum_pairs([1, 2, 3, 4, 5], 5) [(0, 3), (1, 2)] >>> find_sum_pairs([1, 2, 3, 4], 10) [] >>> find_sum_pairs([1, 2, 3, 4], 6) [(1, 3)] >>> find_sum_pairs([1, 2, 3, 4, 5, 6], 7) [(0, 5), (1, 4), (2, 3)] >>> find_sum_pairs([1000000, 500000, -500000, -1000000], 0) [(0, 3), (1, 2)]","solution":"def find_sum_pairs(nums, target): Returns all pairs of indices whose elements sum up to the target. :param nums: List[int], list of distinct integers :param target: int, target sum :return: List[Tuple[int, int]], list of pairs of indices pairs = [] num_indices = {num: idx for idx, num in enumerate(nums)} for i, num in enumerate(nums): complement = target - num if complement in num_indices and num_indices[complement] != i: j = num_indices[complement] if i < j: pairs.append((i, j)) return pairs"},{"question":"def max_sum_path(grid: List[List[int]]) -> int: Returns the maximum sum path from the top-left corner to the bottom-right corner. The path can only move right or down. >>> grid = [ ... [5, 3, 2, 1], ... [1, 2, 1, 1], ... [4, 2, 1, 5], ... [1, 5, 2, 1] ... ] >>> max_sum_path(grid) 20 >>> grid = [ ... [1, 2, 3, 4] ... ] >>> max_sum_path(grid) 10 >>> grid = [ ... [1], ... [2], ... [3], ... [4] ... ] >>> max_sum_path(grid) 10 >>> grid = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ] >>> max_sum_path(grid) -21 >>> grid = [ ... [1, -2, 3], ... [4, 5, -6], ... [7, 8, 9] ... ] >>> max_sum_path(grid) 29 >>> max_sum_path([]) 0 >>> grid = [[5]] >>> max_sum_path(grid) 5","solution":"def max_sum_path(grid): Returns the maximum sum path from the top-left corner to the bottom-right corner. The path can only move right or down. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def two_sum(arr, target): Determines if there are two integers in the array whose sum is equal to the target. Args: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if there are two integers in the array whose sum is equal to the target, False otherwise. Examples: >>> two_sum([4, -1, 9, 7, 5, 2], 6) True >>> two_sum([3, 1, 4, 2, 5], 10) False >>> two_sum([1, 2, 3, 4, 5], 9) True >>> two_sum([-1, -2, -3, -4, -5, -6], -11) True >>> two_sum([1, 2, 3, 4, 5], 10) False >>> two_sum([], 5) False >>> two_sum([5], 10) False >>> two_sum([0, -1, 1, -2, 2], 0) True","solution":"def two_sum(arr, target): Determines if there are two integers in the array whose sum is equal to the target. Args: arr (list of int): The array of integers. target (int): The target sum. Returns: bool: True if there are two integers in the array whose sum is equal to the target, False otherwise. seen = set() for number in arr: if target - number in seen: return True seen.add(number) return False"},{"question":"def longestStrChain(words: List[str]) -> int: Return the length of the longest possible word chain with words chosen from the given list of words. >>> longestStrChain([\\"a\\",\\"b\\",\\"ba\\",\\"bca\\",\\"bda\\",\\"bdca\\"]) 4 >>> longestStrChain([\\"a\\"]) 1 >>> longestStrChain([\\"abc\\", \\"def\\", \\"ghi\\"]) 1 >>> longestStrChain([\\"a\\", \\"ab\\", \\"abc\\", \\"abd\\", \\"bc\\", \\"bce\\"]) 3 >>> longestStrChain([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\", \\"bc\\", \\"bcd\\", \\"bcde\\", \\"c\\"]) 5","solution":"def longestStrChain(words): Returns the length of the longest possible word chain with words chosen from the given list of words. # Sort words by their lengths words.sort(key=len) # Dictionary to keep the longest chain ending with the word longest_chain = {} max_length = 1 for word in words: longest_chain[word] = 1 # Every word at least has a chain length of 1 (itself) # Try to generate predecessors by removing one character at a time for i in range(len(word)): predecessor = word[:i] + word[i + 1:] if predecessor in longest_chain: longest_chain[word] = max(longest_chain[word], longest_chain[predecessor] + 1) # Update max_length for the longest chain found so far max_length = max(max_length, longest_chain[word]) return max_length"},{"question":"from typing import List def min_max_division_strength(nums: List[int], k: int) -> int: Given an array of integers \`nums\` and an integer \`k\`, this function computes the minimum possible value of the maximum sum of any subarray after splitting \`nums\` into \`k\` contiguous subarrays. :param nums: List[int], array of integers :param k: int, number of divisions :return: int, minimized maximum strength of any division >>> min_max_division_strength([1, 2, 3, 4, 5], 1) 15 >>> min_max_division_strength([1, 2, 3, 4, 5], 5) 5 >>> min_max_division_strength([1, 2, 3, 4, 5], 2) 9 >>> min_max_division_strength([1, 4, 4], 3) 4 >>> min_max_division_strength([7, 2, 5, 10, 8], 2) 18 >>> min_max_division_strength([1, 2, 3, 4, 5], 3) 6 >>> min_max_division_strength([100, 200, 300, 400, 500], 3) 600 >>> min_max_division_strength([1, 1, 1, 1, 1], 5) 1 >>> min_max_division_strength([10], 1) 10","solution":"def min_max_division_strength(nums, k): Given an array of integers \`nums\` and an integer \`k\`, this function computes the minimum possible value of the maximum sum of any subarray after splitting \`nums\` into \`k\` contiguous subarrays. :param nums: List[int], array of integers :param k: int, number of divisions :return: int, minimized maximum strength of any division def can_divide(max_sum): current_sum = 0 required_divisions = 1 for num in nums: if current_sum + num > max_sum: required_divisions += 1 current_sum = num if required_divisions > k: return False else: current_sum += num return True low, high = max(nums), sum(nums) while low < high: mid = (low + high) // 2 if can_divide(mid): high = mid else: low = mid + 1 return low"},{"question":"def largest_island(grid: List[List[int]]) -> int: Given a matrix of integers \`grid\` representing a city's layout where \`1\` represents land and \`0\` represents water, return the size of the largest island. An island is formed by connecting adjacent lands horizontally or vertically (not diagonally). If there are no islands, return \`0\`. :param grid: List[List[int]] - 2D list representing the city's layout. :return: int - the size of the largest island. >>> largest_island([ ... [1, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1] ... ]) 4 >>> largest_island([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> largest_island([ ... [1, 0, 0, 1], ... [0, 1, 1, 0], ... [0, 1, 0, 0], ... [1, 0, 0, 1] ... ]) 3 >>> largest_island([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> largest_island([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9","solution":"def largest_island(grid): Returns the size of the largest island in the grid. :param grid: List[List[int]] - 2D list representing the city's layout. :return: int - the size of the largest island. def dfs(i, j): if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1: grid[i][j] = 0 # Mark as visited size = 1 size += dfs(i + 1, j) size += dfs(i - 1, j) size += dfs(i, j + 1) size += dfs(i, j - 1) return size return 0 max_island_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_island_size = max(max_island_size, dfs(i, j)) return max_island_size"},{"question":"def can_sum_to_target(nums: List[int], target: int) -> bool: Determines if it is possible to reduce the array to a single element equal to the target by summing adjacent elements. >>> can_sum_to_target([1, 3, 5], 9) == True >>> can_sum_to_target([5], 5) == True >>> can_sum_to_target([10], 9) == False >>> can_sum_to_target([2, 3, 4], 8) == False >>> can_sum_to_target([2, 3, 4], 9) == True >>> can_sum_to_target([-1, -2, -3], -6) == True >>> can_sum_to_target([0, 0, 0], 0) == True >>> can_sum_to_target([1, 2, -3, 4], 4) == True >>> can_sum_to_target([], 0) == True >>> can_sum_to_target([], 1) == False","solution":"def can_sum_to_target(nums, target): Determines if it is possible to reduce the array to a single element equal to the target by summing adjacent elements. Args: nums: List[int] : List of integers. target: int : The target sum to achieve. Returns: bool : True if the target sum can be achieved, otherwise False. return sum(nums) == target"},{"question":"from typing import List def tree_diameter(edges: List[List[int]], n: int) -> int: Given a binary tree represented as a set of n-1 edges, find the diameter of the tree. The diameter of a binary tree is defined as the longest path between any two nodes in the tree. Args: edges (List[List[int]]): A list of n-1 edges where each edge is a pair [u, v] denoting a connection between nodes u and v. n (int): The number of nodes in the tree. Returns: int: The diameter of the tree. Examples: >>> tree_diameter([], 1) 0 >>> tree_diameter([[1, 2]], 2) 1 >>> tree_diameter([[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]], 7) 4 >>> tree_diameter([[1, 2], [2, 3], [3, 4], [4, 5]], 5) 4 >>> tree_diameter([[1, 2], [2, 3], [3, 4], [2, 5], [5, 6], [6, 7]], 7) 5 pass","solution":"from collections import defaultdict, deque from typing import List def tree_diameter(edges: List[List[int]], n: int) -> int: def bfs(start_node): # Helper function for BFS that returns the farthest node and its distance from start_node queue = deque([start_node]) visited = [-1] * (n + 1) visited[start_node] = 0 farthest_node = start_node max_distance = 0 while queue: node = queue.popleft() current_distance = visited[node] for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = current_distance + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance # Build the graph from the edges graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Start BFS from an arbitrary node (node 1) farthest_node_1, _ = bfs(1) # Use the farthest node from first BFS to start a second BFS _, diameter = bfs(farthest_node_1) return diameter"},{"question":"def can_split_array_into_three_parts(nums: List[int]) -> bool: Determine if there exists a way to split the array into three parts such that the sum of the elements in each part is equal. >>> can_split_array_into_three_parts([0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1]) True >>> can_split_array_into_three_parts([0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1]) False >>> can_split_array_into_three_parts([3,3,6,5,-2,2,5,1,-9,4]) True","solution":"def can_split_array_into_three_parts(nums): total_sum = sum(nums) # If the total_sum is not divisible by 3, it is impossible to split the array into three parts with equal sum if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum = 0 parts_found = 0 for num in nums: current_sum += num if current_sum == target_sum: parts_found += 1 current_sum = 0 if parts_found == 2 and current_sum == 0: return True return False"},{"question":"from collections import deque from typing import List, Dict def level_order(n_ary_tree: Dict[int, List[int]], root: int) -> List[List[int]]: Returns the level order traversal of an n-ary tree. n_ary_tree: dict, The representation of the n-ary tree where keys are node values and values are lists of children. root: The root node of the n-ary tree. return: List[List[Node values at each level]] pass # Test cases def test_single_node_tree(): tree = {1: []} result = level_order(tree, 1) assert result == [[1]] def test_two_level_tree(): tree = {1: [2, 3, 4], 2: [], 3: [], 4: []} result = level_order(tree, 1) assert result == [[1], [2, 3, 4]] def test_three_level_tree(): tree = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: []} result = level_order(tree, 1) assert result == [[1], [2, 3], [4, 5, 6]] def test_unbalanced_tree(): tree = {1: [2], 2: [3], 3: [4], 4: []} result = level_order(tree, 1) assert result == [[1], [2], [3], [4]] def test_empty_tree(): tree = {} result = level_order(tree, 1) assert result == [] def test_tree_with_missing_root(): tree = {2: [3], 3: [4], 4: []} result = level_order(tree, 1) assert result == []","solution":"from collections import deque def level_order(n_ary_tree, root): Returns the level order traversal of an n-ary tree. n_ary_tree: dict, The representation of the n-ary tree where keys are node values and values are lists of children. root: The root node of the n-ary tree. return: List[List[Node values at each level]] if not n_ary_tree or root not in n_ary_tree: return [] queue = deque([root]) result = [] while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node) for child in n_ary_tree.get(node, []): queue.append(child) result.append(level) return result"},{"question":"def sum_of_diagonals(grid: List[List[int]]) -> int: Return the sum of the values in all cells that are part of any diagonal in the matrix. >>> sum_of_diagonals([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> sum_of_diagonals([ ... [1, 2], ... [3, 4] ... ]) 10 >>> sum_of_diagonals([ ... [5] ... ]) 5 >>> sum_of_diagonals([ ... [1, 2, 3], ... [4, 5, 6] ... ]) 21 >>> sum_of_diagonals([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12] ... ]) 78","solution":"def sum_of_diagonals(grid): m, n = len(grid), len(grid[0]) diag_sums = 0 seen = set() # Sum top-left to bottom-right diagonals for d in range(-(m - 1), n): for i in range(max(0, -d), min(m, n - d)): if (i, i + d) not in seen: diag_sums += grid[i][i + d] seen.add((i, i + d)) # Sum top-right to bottom-left diagonals for d in range(m + n - 1): for i in range(max(0, d - n + 1), min(m, d + 1)): if (i, d - i) not in seen: diag_sums += grid[i][d - i] seen.add((i, d - i)) return diag_sums"},{"question":"def can_be_sorted_by_reversing_subarray(arr: List[int]) -> bool: Determines if the array can be sorted in non-decreasing order by reversing one subarray. >>> can_be_sorted_by_reversing_subarray([1, 2, 3, 4, 5]) True >>> can_be_sorted_by_reversing_subarray([1]) True >>> can_be_sorted_by_reversing_subarray([5, 4, 3, 2, 1]) True >>> can_be_sorted_by_reversing_subarray([1, 3, 2, 4, 5]) True >>> can_be_sorted_by_reversing_subarray([1, 5, 4, 3, 2, 6]) True >>> can_be_sorted_by_reversing_subarray([1, 5, 3, 4, 2]) False >>> can_be_sorted_by_reversing_subarray([1, 3, 5, 4, 2]) False","solution":"def can_be_sorted_by_reversing_subarray(arr): Determines if the array can be sorted in non-decreasing order by reversing one subarray. n = len(arr) if n <= 1: return True # Find the first decreasing element i = 0 while i < n - 1 and arr[i] <= arr[i + 1]: i += 1 if i == n - 1: # Already sorted return True # Find the last element that is out of order from the end j = n - 1 while j > 0 and arr[j - 1] <= arr[j]: j -= 1 # Reverse the subarray from i to j arr[i:j+1] = arr[i:j+1][::-1] # Check if the array is now sorted for k in range(n - 1): if arr[k] > arr[k + 1]: return False return True"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Finds the shortest path from the top-left corner to the bottom-right corner in a 2D grid. The grid contains 0s (empty spaces) and 1s (obstacles). Allowed movements are up, down, left, or right. Parameters: grid (List[List[int]]): A 2D grid representing the map with obstacles and empty spaces. Returns: int: Length of the shortest path or -1 if it's not possible to reach the bottom-right corner.","solution":"from collections import deque def shortest_path(grid): Finds the shortest path from the top-left corner to the bottom-right corner in a 2D grid. The grid contains 0s (empty spaces) and 1s (obstacles). Allowed movements are up, down, left, or right. Parameters: grid (List[List[int]]): A 2D grid representing the map with obstacles and empty spaces. Returns: int: Length of the shortest path or -1 if it's not possible to reach the bottom-right corner. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if row == m - 1 and col == n - 1: return dist for d_row, d_col in directions: n_row, n_col = row + d_row, col + d_col if 0 <= n_row < m and 0 <= n_col < n and grid[n_row][n_col] == 0 and (n_row, n_col) not in visited: visited.add((n_row, n_col)) queue.append((n_row, n_col, dist + 1)) return -1"},{"question":"def distinct_subsequences(n: int, m: int) -> List[int]: Given two integers \`n\` and \`m\`, where \`1 <= m <= n\`, return an integer array where the \`k\`-th element is the number of distinct subsequences of length \`k\` that can be formed from the set \`{1, 2, . . . , n}\`. Since the result can be very large, return each element in the array modulo \`10^9 + 7\`. >>> distinct_subsequences(5, 3) == [5, 10, 10] >>> distinct_subsequences(4, 4) == [4, 6, 4, 1] >>> distinct_subsequences(1, 1) == [1]","solution":"def distinct_subsequences(n, m): MOD = 10**9 + 7 # Calculate the binomial coefficient C(n,k) which is n!/(k!(n-k)!) def binomial_coeff(n, k): if k > n: return 0 if k == 0 or k == n: return 1 # Calculate n! / (n-k)! first num = 1 for i in range(k): num = num * (n - i) % MOD # Calculate k! denom = 1 for i in range(1, k + 1): denom = denom * i % MOD # Use Fermat's Little Theorem to find modular inverse denom_inverse = pow(denom, MOD - 2, MOD) return num * denom_inverse % MOD result = [] for k in range(1, m + 1): result.append(binomial_coeff(n, k)) return result"},{"question":"def can_visit_all_rooms(rooms: List[List[int]]) -> bool: Determines if you can visit all the rooms starting from room 0. Args: rooms (List[List[int]]): A list of lists, where each list represents keys in a room. Returns: bool: True if you can visit all the rooms, False otherwise. >>> can_visit_all_rooms([[1], [2], [3], []]) == True >>> can_visit_all_rooms([[1,3], [3,0,1], [2], [0]]) == False >>> can_visit_all_rooms([[]]) == True >>> can_visit_all_rooms([[1,2,3], [0,2,3], [0,1,3], [0,1,2]]) == True >>> can_visit_all_rooms([[1,3], [3,0,1], [2], [0, 4, 5], [2], []]) == True >>> can_visit_all_rooms([[], [1,2], [2]]) == False","solution":"def can_visit_all_rooms(rooms): Determines if you can visit all the rooms starting from room 0. Args: rooms (List[List[int]]): A list of lists, where each list represents keys in a room. Returns: bool: True if you can visit all the rooms, False otherwise. n = len(rooms) visited = [False] * n stack = [0] while stack: current_room = stack.pop() if not visited[current_room]: visited[current_room] = True stack.extend(rooms[current_room]) return all(visited)"},{"question":"def count_connected_components(n: int, connections: List[List[int]]) -> int: Returns the number of connected components in an undirected graph represented by n nodes and a list of edges. Parameters: n (int): Number of users in the network. connections (List[List[int]]): List of connections where each connection is represented as a pair of users. Returns: int: The number of connected components. Examples: >>> count_connected_components(0, []) 0 >>> count_connected_components(3, []) 3 >>> count_connected_components(2, [[0, 1]]) 1 >>> count_connected_components(4, [[0, 1], [2, 3]]) 2 >>> count_connected_components(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) 1 >>> count_connected_components(6, [[0, 1], [2, 3], [3, 4]]) 3 >>> count_connected_components(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) 1","solution":"def count_connected_components(n, connections): Returns the number of connected components in an undirected graph represented by n nodes and a list of edges. from collections import defaultdict, deque if n == 0: return 0 # Build the adjacency list representation of the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = set() count = 0 def bfs(node): queue = deque([node]) while queue: curr = queue.popleft() for neighbor in graph[curr]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Iterate through all nodes and perform BFS for each unvisited node for i in range(n): if i not in visited: visited.add(i) bfs(i) count += 1 return count"},{"question":"def count_ways(arr, k): You are given an array of integers \`arr\` representing the heights of trees. You need to chop down trees such that exactly \`k\` trees remain standing. A tree is \\"visible\\" if it is not blocked by a taller tree to its left. A tree of height \`arr[i]\` will block another tree at \`arr[j]\` if \`i < j\` and \`arr[i] >= arr[j]\`. Return the number of ways to chop down the trees so that exactly \`k\` trees remain visible. Since the answer may be large, return it **modulo** \`10^9 + 7\`. >>> count_ways([1, 2, 3, 4], 2) 6 >>> count_ways([4, 3, 2, 1], 1) 4 >>> count_ways([5], 1) 1 >>> count_ways([2, 3, 1], 4) 0 >>> count_ways([3, 3, 3, 3], 1) 4 >>> count_ways([3, 3, 3, 3], 2) 0 # Your code here","solution":"MOD = 10**9 + 7 def count_ways(arr, k): def count_subsequences(i, count, prev_height): if count == k: return 1 if i == len(arr): return 0 # Include the current tree if it is taller than the last included tree include = exclude = 0 if arr[i] > prev_height: include = count_subsequences(i + 1, count + 1, arr[i]) # Exclude the current tree exclude = count_subsequences(i + 1, count, prev_height) return (include + exclude) % MOD return count_subsequences(0, 0, -1)"},{"question":"def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of replacements needed to make the string s a palindrome. s is a string consisting only of the characters 'a', 'b', and 'c'. >>> min_replacements_to_palindrome(\\"aaa\\") 0 >>> min_replacements_to_palindrome(\\"aba\\") 0 >>> min_replacements_to_palindrome(\\"abb\\") 1 >>> min_replacements_to_palindrome(\\"abcd\\") 2 >>> min_replacements_to_palindrome(\\"\\") 0","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of replacements needed to make the string s a palindrome. s is a string consisting only of the characters 'a', 'b', and 'c'. n = len(s) replacements = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: replacements += 1 return replacements"},{"question":"def min_edit_distance(str1: str, str2: str) -> int: Returns the minimum number of operations required to convert str1 into str2. Allowed operations are insert, delete, and replace. >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 >>> min_edit_distance(\\"abc\\", \\"abc\\") 0 >>> min_edit_distance(\\"\\", \\"\\") 0 >>> min_edit_distance(\\"\\", \\"abc\\") 3 >>> min_edit_distance(\\"abc\\", \\"\\") 3 >>> min_edit_distance(\\"abcdef\\", \\"azced\\") 3 >>> min_edit_distance(\\"ab\\", \\"abcdef\\") 4","solution":"def min_edit_distance(str1, str2): Returns the minimum number of operations required to convert str1 into str2. Allowed operations are insert, delete, and replace. m = len(str1) k = len(str2) # Create a DP array to memoize result of previous computations. dp = [[0 for _ in range(k + 1)] for _ in range(m + 1)] # Initialize DP array for i in range(m + 1): for j in range(k + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore last character and recur for remaining string elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # If last character are different, consider all possibilities and find minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][k]"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def shortest_path_length(root: TreeNode, node1: TreeNode, node2: TreeNode) -> int: Find the length of the shortest path between two nodes in a binary tree. The length is defined as the number of edges between the two nodes. Assume both nodes exist in the tree. >>> # Example tree >>> # 1 >>> # / >>> # 2 3 >>> # / >>> # 4 5 >>> node5 = TreeNode(5) >>> node4 = TreeNode(4) >>> node3 = TreeNode(3) >>> node2 = TreeNode(2, left=node4, right=node5) >>> node1 = TreeNode(1, left=node2, right=node3) >>> shortest_path_length(node1, node4, node5) 2 # Path: 4 -> 2 -> 5 >>> shortest_path_length(node1, node4, node3) 3 # Path: 4 -> 2 -> 1 -> 3 >>> shortest_path_length(node1, node2, node3) 2 # Path: 2 -> 1 -> 3 >>> shortest_path_length(node1, node4, node2) 1 # Path: 4 -> 2 >>> shortest_path_length(node1, node1, node3) 1 # Path: 1 -> 3 >>> shortest_path_length(node1, node1, node1) 0 # Path: 1 (itself) >>> shortest_path_length(node1, node2, node5) 1 # Path: 2 -> 5 >>> shortest_path_length(node1, node2, node1) 1 # Path: 2 -> 1","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_lca(root, node1, node2): if root is None: return None if root == node1 or root == node2: return root left_lca = find_lca(root.left, node1, node2) right_lca = find_lca(root.right, node1, node2) if left_lca and right_lca: return root return left_lca if left_lca is not None else right_lca def find_distance_from_ancestor(root, node, distance): if root is None: return -1 if root == node: return distance left_distance = find_distance_from_ancestor(root.left, node, distance + 1) if left_distance != -1: return left_distance right_distance = find_distance_from_ancestor(root.right, node, distance + 1) return right_distance def shortest_path_length(root, node1, node2): lca = find_lca(root, node1, node2) distance1 = find_distance_from_ancestor(lca, node1, 0) distance2 = find_distance_from_ancestor(lca, node2, 0) return distance1 + distance2"},{"question":"def has_cycle(graph: List[List[int]]) -> bool: Determines if there is a cycle in a directed graph. Parameters: graph (list): A list of lists where graph[i] contains the list of nodes to which node i is connected. Returns: bool: True if there is a cycle, False otherwise. >>> has_cycle([ ... [1], # Node 0 -> Node 1 ... [2], # Node 1 -> Node 2 ... [0] # Node 2 -> Node 0 (cycle) ... ]) == True >>> has_cycle([ ... [1], # Node 0 -> Node 1 ... [2], # Node 1 -> Node 2 ... [] # Node 2 -> No connection (no cycle) ... ]) == False >>> has_cycle([ ... [0] # Node 0 -> Node 0 (self loop) ... ]) == True >>> has_cycle([ ... [1], # Node 0 -> Node 1 ... [], # Node 1 -> No connection ... [3], # Node 2 -> Node 3 ... [] # Node 3 -> No connection (two disconnected components, no cycle) ... ]) == False >>> has_cycle([ ... [1], # Node 0 -> Node 1 ... [], # Node 1 -> No connection ... [3], # Node 2 -> Node 3 ... [2] # Node 3 -> Node 2 (cycle in second component) ... ]) == True","solution":"def has_cycle(graph): Determines if there is a cycle in a directed graph. Parameters: graph (list): A list of lists where graph[i] contains the list of nodes to which node i is connected. Returns: bool: True if there is a cycle, False otherwise. def dfs(node, visited, recursion_stack): visited[node] = True recursion_stack[node] = True for neighbour in graph[node]: if not visited[neighbour]: if dfs(neighbour, visited, recursion_stack): return True elif recursion_stack[neighbour]: return True recursion_stack[node] = False return False visited = [False] * len(graph) recursion_stack = [False] * len(graph) for node in range(len(graph)): if not visited[node]: if dfs(node, visited, recursion_stack): return True return False"},{"question":"def ball_arrangement(n: int) -> List[int]: Returns the arrangement of ball numbers after one move in a counter-clockwise direction. Parameters: n (int): Number of people in the circle Returns: List[int]: The new arrangement of ball numbers >>> ball_arrangement(1) [1] >>> ball_arrangement(2) [2, 1] >>> ball_arrangement(3) [2, 3, 1] >>> ball_arrangement(4) [2, 3, 4, 1] >>> ball_arrangement(5) [2, 3, 4, 5, 1] >>> ball_arrangement(0) []","solution":"def ball_arrangement(n): Returns the arrangement of ball numbers after one move in a counter-clockwise direction. Parameters: n (int): Number of people in the circle Returns: List[int]: The new arrangement of ball numbers if n == 0: return [] # The person labeled \`i\` will receive the ball from person labeled \`i+1\`, # and the person labeled \`1\` receives the ball from person labeled \`n\`. # Therefore, the result will be a list from 2 to n, followed by 1. return [i for i in range(2, n+1)] + [1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root: TreeNode) -> bool: Determines whether the binary tree is balanced. A binary tree is balanced if for every node, the height difference between its left and right subtree is no more than 1. >>> isBalanced(None) True >>> root = TreeNode(1) >>> isBalanced(root) True >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> isBalanced(root) True >>> root.left.left.left = TreeNode(5) >>> isBalanced(root) False def test_functions(): assert isBalanced(None) == True root = TreeNode(1) assert isBalanced(root) == True root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) assert isBalanced(root) == True root.left.left.left = TreeNode(5) assert isBalanced(root) == False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root: TreeNode) -> bool: Determines whether the binary tree is balanced. A binary tree is balanced if for every node, the height difference between its left and right subtree is no more than 1. def check_height(node): if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob without alerting the police in a circular arrangement of houses. >>> rob([]) == 0 >>> rob([3]) == 3 >>> rob([2, 3]) == 3 >>> rob([2, 3, 2]) == 3 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 11 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41","solution":"def rob(nums): Returns the maximum amount of money you can rob without alerting the police. def rob_linear(houses): prev_max, curr_max = 0, 0 for amount in houses: prev_max, curr_max = curr_max, max(curr_max, prev_max + amount) return curr_max if len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"from typing import List def minimumDifference(nums: List[int]) -> int: You are given a 0-indexed integer array \`nums\` consisting of \`n\` elements, where \`n\` is even. You need to partition the array into two subsets such that the sum of the elements in both subsets is as equal as possible. Return the minimum absolute difference between the sum of the elements in the two subsets. >>> minimumDifference([1, 2, 3, 4]) 0 >>> minimumDifference([1, 6, 11, 5]) 1 >>> minimumDifference([8, 5]) 3 >>> minimumDifference([10, 20, 5, 1]) 4 >>> minimumDifference([10, 10, 10, 10]) 0 >>> minimumDifference([-1, 2, -3, 4]) 0","solution":"from itertools import combinations from typing import List def minimumDifference(nums: List[int]) -> int: n = len(nums) total_sum = sum(nums) half_n = n // 2 def get_subset_sums(nums: List[int]) -> List[List[int]]: n = len(nums) subsets = [] for i in range(n+1): subsets.append([sum(combination) for combination in combinations(nums, i)]) return subsets left_sums = get_subset_sums(nums[:half_n]) right_sums = get_subset_sums(nums[half_n:]) right_all_sums = set() for sums in right_sums: right_all_sums.update(sums) min_diff = float('inf') for i, left_subset_sums in enumerate(left_sums): for left_sum in left_subset_sums: target = (total_sum // 2) - left_sum possible_sums = sorted(right_all_sums) for sum_candidate in possible_sums: current_diff = abs(total_sum - 2 * (left_sum + sum_candidate)) min_diff = min(min_diff, current_diff) # Since the candidate sums are sorted, break early to optimize if sum_candidate >= target: break return min_diff"},{"question":"import collections from typing import List, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def rightSideView(root: Optional[TreeNode]) -> List[int]: Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. >>> rightSideView(TreeNode(1)) [1] >>> t = TreeNode(1); t.left = TreeNode(2); t.right = TreeNode(3); t.left.left = TreeNode(4); t.left.right = TreeNode(5); t.right.right = TreeNode(6); rightSideView(t) [1, 3, 6] >>> t = TreeNode(1); t.left = TreeNode(2); t.left.left = TreeNode(3); t.left.left.left = TreeNode(4); rightSideView(t) [1, 2, 3, 4] >>> t = TreeNode(1); t.right = TreeNode(2); t.right.right = TreeNode(3); t.right.right.right = TreeNode(4); rightSideView(t) [1, 2, 3, 4] >>> t = TreeNode(1); t.left = TreeNode(2); t.right = TreeNode(3); t.left.right = TreeNode(5); t.right.right = TreeNode(4); rightSideView(t) [1, 3, 4] >>> rightSideView(None) []","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def rightSideView(root): Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # if it's the last node in the current level, add it to the right view if i == level_length - 1: right_view.append(node.val) # add child nodes to the queue if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring which contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"abcba\\") 3 >>> length_of_longest_substring_two_distinct(\\"aabbcc\\") 4 >>> length_of_longest_substring_two_distinct(\\"\\") 0","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring which contains at most two distinct characters. if len(s) < 3: return len(s) left, right = 0, 0 max_len = 2 hashmap = {} while right < len(s): if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"from typing import List def minDeletionsToMakeAnagrams(s1: str, s2: str) -> int: Determine the minimum number of deletions needed to make two strings anagrams of each other. >>> minDeletionsToMakeAnagrams(\\"abc\\", \\"abc\\") 0 >>> minDeletionsToMakeAnagrams(\\"abc\\", \\"def\\") 6 >>> minDeletionsToMakeAnagrams(\\"abc\\", \\"bcd\\") 2 >>> minDeletionsToMakeAnagrams(\\"aabbcc\\", \\"abc\\") 3 >>> minDeletionsToMakeAnagrams(\\"aabcc\\", \\"abccc\\") 2 >>> minDeletionsToMakeAnagrams(\\"\\", \\"abc\\") 3 >>> minDeletionsToMakeAnagrams(\\"abc\\", \\"\\") 3 >>> minDeletionsToMakeAnagrams(\\"\\", \\"\\") 0","solution":"def minDeletionsToMakeAnagrams(s1: str, s2: str) -> int: from collections import Counter # Count the frequency of each character in both strings counter1 = Counter(s1) counter2 = Counter(s2) # Calculate the number of deletions required deletions = 0 # For characters in s1 for char in counter1: if char in counter2: # The difference in counts of the same character in both strings deletions += abs(counter1[char] - counter2[char]) else: # All characters should be deleted if not present in s2 deletions += counter1[char] # For characters in s2 that are not in s1 for char in counter2: if char not in counter1: deletions += counter2[char] return deletions"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Determines if there are three distinct elements in nums that add up to target. >>> three_sum([1, 2, 3, 4, 5], 9) == True >>> three_sum([1, 1, 1, 1, 1], 10) == False >>> three_sum([-1, 0, 1, 2, -1, -4], 0) == True >>> three_sum([1, 2, 2, 3, 4], 8) == True >>> three_sum([1000000, 2000000, 3000000, -1000000], 4000000) == True >>> three_sum([2, 2, 2, 2, 2], 6) == True >>> three_sum([], 10) == False >>> three_sum([1, 1, 1, 2, 2, 2], 5) == True","solution":"def three_sum(nums, target): Determines if there are three distinct elements in nums that add up to target. Args: nums : List[int] - List of integers target : int - Target sum Returns: bool - True if there exist three elements in nums that sum up to target, otherwise False nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def longest_consecutive_subsequence(arr: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers in the array. >>> longest_consecutive_subsequence([]) == 0 >>> longest_consecutive_subsequence([1]) == 1 >>> longest_consecutive_subsequence([1, 2]) == 2 >>> longest_consecutive_subsequence([2, 2]) == 1 >>> longest_consecutive_subsequence([4, 2, 1, 6, 5]) == 3 >>> longest_consecutive_subsequence([10, 5, 12, 3, 55, 30, 4, 11, 2]) == 4 >>> longest_consecutive_subsequence([7, 7, 7, 7]) == 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 >>> longest_consecutive_subsequence([-3, -2, -1, 0, 1, 2, 3]) == 7 pass","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence of consecutive integers in the array. if not arr: return 0 arr = set(arr) longest_streak = 0 for number in arr: if number - 1 not in arr: current_number = number current_streak = 1 while current_number + 1 in arr: current_number += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def trap_rain_water(arr: List[int], threshold: int) -> int: Calculate the total amount of trapped rainwater within the threshold limit. Parameters: arr (list of int): List of heights of buildings threshold (int): Maximum allowable collected rainwater Returns: int: Total collected rainwater if it's <= threshold, else -1 Examples: >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], 5) -1 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1], 10) 6 >>> trap_rain_water([1, 2, 3, 4, 5], 10) 0 >>> trap_rain_water([5], 10) 0 >>> trap_rain_water([], 10) 0 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1], 2) 2 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1], -1) -1","solution":"def trap_rain_water(arr, threshold): Calculate the total amount of trapped rainwater within the threshold limit. Parameters: arr (list of int): List of heights of buildings threshold (int): Maximum allowable collected rainwater Returns: int: Total collected rainwater if it's <= threshold, else -1 if not arr: return 0 if threshold >= 0 else -1 n = len(arr) left, right = 0, n - 1 left_max, right_max = arr[left], arr[right] total_water = 0 while left < right: if arr[left] < arr[right]: left += 1 left_max = max(left_max, arr[left]) total_water += left_max - arr[left] else: right -= 1 right_max = max(right_max, arr[right]) total_water += right_max - arr[right] if total_water > threshold: return -1 return total_water if total_water <= threshold else -1"},{"question":"def can_transform_to_palindrome(s: str) -> bool: Given a string \`s\`, determine if it is possible to transform \`s\` into a palindrome by performing the following operation any number of times: Choose a non-empty prefix of the string and add its reverse to the end of \`s\`. :param s: input string :return: True if it's possible to transform \`s\` into a palindrome, otherwise False >>> can_transform_to_palindrome(\\"a\\") True >>> can_transform_to_palindrome(\\"aba\\") True >>> can_transform_to_palindrome(\\"abca\\") False >>> can_transform_to_palindrome(\\"abcba\\") True >>> can_transform_to_palindrome(\\"\\") True","solution":"def can_transform_to_palindrome(s): Determine if it is possible to transform the string \`s\` into a palindrome by appending the reverse of its prefixes any number of times. :param s: input string :return: True if it's possible to transform to palindrome, otherwise False # A helper function to check if a string is palindrome def is_palindrome(subs): return subs == subs[::-1] # Checking whether it is possible with the given conditions if is_palindrome(s): return True return False"},{"question":"def transform_array(nums: List[int], k: int) -> List[int]: Perform exactly k transformations to get lexicographically smallest array. Args: nums: List[int] - The input array of integers. k: int - Number of transformations. Returns: List[int] - The lexicographically smallest array after k transformations. pass from solution import transform_array def test_transform_array_basic(): assert transform_array([3, 1, 2], 1) == [3, 2, 3] assert transform_array([3, 1, 2], 2) == [3, 3, 4] assert transform_array([3, 1, 2], 3) == [4, 4, 5] def test_transform_array_all_equal(): assert transform_array([1, 1, 1], 1) == [2, 2, 2] assert transform_array([1, 1, 1], 2) == [3, 3, 3] def test_transform_array_single_element(): assert transform_array([5], 1) == [6] assert transform_array([5], 3) == [8] def test_transform_array_already_sorted(): assert transform_array([1, 2, 3], 1) == [2, 3, 4] assert transform_array([1, 2, 3], 2) == [3, 4, 5] def test_transform_array_descending_order(): assert transform_array([3, 2, 1], 1) == [3, 2, 2] assert transform_array([3, 2, 1], 2) == [3, 3, 3] assert transform_array([3, 2, 1], 3) == [4, 4, 4]","solution":"def transform_array(nums, k): Perform exactly k transformations to get lexicographically smallest array. Args: nums: List[int] - The input array of integers. k: int - Number of transformations. Returns: List[int] - The lexicographically smallest array after k transformations. n = len(nums) for _ in range(k): min_index = 0 # Find the first occurrence of the minimum element for i in range(1, n): if nums[i] < nums[min_index]: min_index = i # Add 1 to all elements in the subarray starting at min_index for i in range(min_index, n): nums[i] += 1 return nums"},{"question":"from typing import List def count_distinct_permutations(s: str, words: List[str]) -> int: Returns the count of all distinct permutations of \`s\` that appear as a substring in any of the strings in \`words\`. >>> count_distinct_permutations(\\"abc\\", [\\"abacb\\", \\"bcabc\\"]) == 5 >>> count_distinct_permutations(\\"abc\\", [\\"defgh\\", \\"ijklmn\\"]) == 0 >>> count_distinct_permutations(\\"ab\\", [\\"ab\\", \\"ba\\"]) == 2 >>> count_distinct_permutations(\\"aa\\", [\\"aaaa\\"]) == 3 >>> count_distinct_permutations(\\"abc\\", [\\"cba\\"]) == 1","solution":"from collections import Counter def count_distinct_permutations(s, words): Returns the count of all distinct permutations of \`s\` that appear as a substring in any of the strings in \`words\`. s_len = len(s) s_counter = Counter(s) permutations = set() for word in words: word_len = len(word) for i in range(word_len - s_len + 1): substring = word[i:i+s_len] if Counter(substring) == s_counter: permutations.add((word, i)) return len(permutations)"},{"question":"from typing import List, Dict class InventoryManager: InventoryManager class to manage stock in a warehouse. InventoryManager(List[List[String]] initialInventory) - Initializes the inventory with the provided initial state. boolean addStock(String storageId, String itemId, int quantity) - Adds \`quantity\` units of \`itemId\` to the specified \`storageId\`. Return \`true\` if the operation is successful, or \`false\` if the \`storageId\` does not exist. boolean removeStock(String storageId, String itemId, int quantity) - Removes \`quantity\` units of \`itemId\` from the specified \`storageId\`. Return \`true\` if the operation is successful and there is enough stock, or \`false\` otherwise. Map<String, Integer> getStock(String storageId) - Returns a dictionary representing the inventory of the specified \`storageId\`, where the keys are \`itemId\`s and the values are their quantities. If the \`storageId\` does not exist, return an empty dictionary. def __init__(self, initialInventory: List[List[str]]): # Constructor to initialize the inventory with the given initial state pass def addStock(self, storageId: str, itemId: str, quantity: int) -> bool: # Method to add stock to the specified storage area pass def removeStock(self, storageId: str, itemId: str, quantity: int) -> bool: # Method to remove stock from the specified storage area pass def getStock(self, storageId: str) -> Dict[str, int]: # Method to get the stock of the specified storage area pass # Here are the test cases for the above class: def test_initial_inventory(): initial_inventory = [['S1', 'I1', 10], ['S1', 'I2', 5], ['S2', 'I1', 15]] manager = InventoryManager(initial_inventory) assert manager.getStock('S1') == {'I1': 10, 'I2': 5} assert manager.getStock('S2') == {'I1': 15} assert manager.getStock('S3') == {} def test_add_stock(): initial_inventory = [['S1', 'I1', 10]] manager = InventoryManager(initial_inventory) assert manager.addStock('S1', 'I1', 5) == True assert manager.getStock('S1') == {'I1': 15} def test_add_stock_new_item(): initial_inventory = [['S1', 'I1', 10]] manager = InventoryManager(initial_inventory) assert manager.addStock('S1', 'I2', 5) == True assert manager.getStock('S1') == {'I1': 10, 'I2': 5} def test_add_stock_invalid_storageId(): initial_inventory = [['S1', 'I1', 10]] manager = InventoryManager(initial_inventory) assert manager.addStock('S2', 'I1', 5) == False def test_remove_stock(): initial_inventory = [['S1', 'I1', 10]] manager = InventoryManager(initial_inventory) assert manager.removeStock('S1', 'I1', 5) == True assert manager.getStock('S1') == {'I1': 5} def test_remove_stock_invalid_storageId(): initial_inventory = [['S1', 'I1', 10]] manager = InventoryManager(initial_inventory) assert manager.removeStock('S2', 'I1', 5) == False def test_remove_stock_not_enough(): initial_inventory = [['S1', 'I1', 10]] manager = InventoryManager(initial_inventory) assert manager.removeStock('S1', 'I1', 15) == False assert manager.getStock('S1') == {'I1': 10} def test_remove_stock_complete(): initial_inventory = [['S1', 'I1', 10]] manager = InventoryManager(initial_inventory) assert manager.removeStock('S1', 'I1', 10) == True assert manager.getStock('S1') == {} def test_get_empty_stock(): initial_inventory = [['S1', 'I1', 10]] manager = InventoryManager(initial_inventory) assert manager.getStock('S2') == {}","solution":"from collections import defaultdict class InventoryManager: def __init__(self, initialInventory): self.inventory = defaultdict(lambda: defaultdict(int)) for storageId, itemId, quantity in initialInventory: self.inventory[storageId][itemId] += quantity def addStock(self, storageId, itemId, quantity): if storageId not in self.inventory: return False self.inventory[storageId][itemId] += quantity return True def removeStock(self, storageId, itemId, quantity): if storageId not in self.inventory: return False if self.inventory[storageId][itemId] < quantity: return False self.inventory[storageId][itemId] -= quantity if self.inventory[storageId][itemId] == 0: del self.inventory[storageId][itemId] return True def getStock(self, storageId): if storageId not in self.inventory: return {} return dict(self.inventory[storageId])"},{"question":"def smallerNumbersThanCurrent(nums): Given an integer array nums, return an array of the same length where each element at index i is the count of numbers in nums that are smaller than nums[i]. :param nums: List[int] - The input list of integers :return: List[int] - The resulting list where each index indicates the count of numbers smaller than the number at that index in the input list >>> smallerNumbersThanCurrent([8, 1, 2, 2, 3]) [4, 0, 1, 1, 3] >>> smallerNumbersThanCurrent([7, 7, 7, 7]) [0, 0, 0, 0] >>> smallerNumbersThanCurrent([5]) [0] >>> smallerNumbersThanCurrent([10, 10, 10, 10]) [0, 0, 0, 0] >>> smallerNumbersThanCurrent([5, 10, 0, 4]) [2, 3, 0, 1] >>> smallerNumbersThanCurrent([10, -10, 0, 5]) [3, 0, 1, 2] >>> smallerNumbersThanCurrent([10, 9, 8, 7]) [3, 2, 1, 0]","solution":"def smallerNumbersThanCurrent(nums): Given an integer array nums, return an array of the same length where each element at index i is the count of numbers in nums that are smaller than nums[i]. :param nums: List[int] - The input list of integers :return: List[int] - The resulting list where each index indicates the count of numbers smaller than the number at that index in the input list result = [] for i in nums: count = 0 for j in nums: if j < i: count += 1 result.append(count) return result"},{"question":"from typing import List from collections import Counter def longest_unique_word(words: List[str]) -> str: Returns the longest unique word in the list of words. A word is considered unique if it appears exactly once in the list. If there are multiple longest unique words, the one that appears first is returned. If there are no unique words, an empty string is returned. >>> longest_unique_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"date\\"]) == \\"banana\\" >>> longest_unique_word([\\"ant\\", \\"bat\\", \\"cat\\", \\"dog\\", \\"elephant\\"]) == \\"elephant\\" >>> longest_unique_word([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\"]) == \\"\\" >>> longest_unique_word([\\"apple\\", \\"bananas\\", \\"apple\\", \\"cherry\\"]) == \\"bananas\\" >>> longest_unique_word([\\"ant\\", \\"bat\\", \\"cat\\", \\"dog\\", \\"elephant\\"]) == \\"elephant\\" >>> longest_unique_word([]) == \\"\\" >>> longest_unique_word([\\"apple\\", \\"Banana\\", \\"apple\\", \\"cherry\\", \\"Banana\\"]) == \\"cherry\\" >>> longest_unique_word([\\"apple\\"]) == \\"apple\\"","solution":"def longest_unique_word(words): Returns the longest unique word in the list of words. A word is considered unique if it appears exactly once in the list. If there are multiple longest unique words, the one that appears first is returned. If there are no unique words, an empty string is returned. from collections import Counter word_counts = Counter(words) unique_words = [word for word in words if word_counts[word] == 1] if not unique_words: return \\"\\" longest_word = max(unique_words, key=len) return longest_word"},{"question":"def can_form_string(s: str, words: List[str]) -> bool: Determine if \`s\` can be formed exactly by concatenating strings from \`words\`. >>> can_form_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True >>> can_form_string(\\"leetcode\\", [\\"leet\\", \\"co\\"]) == False >>> can_form_string(\\"leetcodeleetcode\\", [\\"leet\\", \\"code\\", \\"leetcode\\"]) == True >>> can_form_string(\\"\\", [\\"leet\\", \\"code\\"]) == True >>> can_form_string(\\"leetcode\\", []) == False >>> can_form_string(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\"]) == True >>> can_form_string(\\"abcdef\\", [\\"a\\", \\"b\\", \\"c\\"]) == False","solution":"def can_form_string(s, words): from collections import Counter def can_form(s, word_counter): if not s: return True for word in word_counter: if s.startswith(word) and word_counter[word] > 0: word_counter[word] -= 1 if can_form(s[len(word):], word_counter): return True word_counter[word] += 1 return False word_counter = Counter(words) return can_form(s, word_counter)"},{"question":"from typing import List def findQuadruplets(nums: List[int], target: int) -> List[List[int]]: Returns a list of all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that a, b, c, and d are distinct indices and nums[a] + nums[b] + nums[c] + nums[d] == target. >>> findQuadruplets([1, 2, 3, 4], 100) [] >>> findQuadruplets([1, 0, -1, 0, -2, 2], 0) [ [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1] ] >>> findQuadruplets([1, 2, 3, 4, 5], 10) [ [1, 2, 3, 4] ] >>> findQuadruplets([1, 0, -1, 0, -2, 2, 2], 0) [ [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1] ] >>> findQuadruplets([-1, 2, 2, -5, 0, -1, 4], 3) [ [-5, 2, 2, 4], [-1, 0, 2, 2] ]","solution":"def findQuadruplets(nums, target): Returns a list of all unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that a, b, c, and d are distinct indices and nums[a] + nums[b] + nums[c] + nums[d] == target. nums.sort() quadruplets = [] length = len(nums) for i in range(length - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, length - 2): if j > i + 1 and nums[j] == nums[j-1]: continue left, right = j + 1, length - 1 while left < right: current_sum = nums[i] + nums[j] + nums[left] + nums[right] if current_sum == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif current_sum < target: left += 1 else: right -= 1 return quadruplets"},{"question":"from typing import List def largestRectangleArea(heights: List[int]) -> int: Returns the largest possible rectangular area of the billboard that can be installed on top of the buildings. >>> largestRectangleArea([5]) == 5 >>> largestRectangleArea([1, 1]) == 2 >>> largestRectangleArea([2, 1]) == 2 >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> largestRectangleArea([2, 4]) == 4 >>> largestRectangleArea([6, 7, 5, 2, 4, 5, 9, 3]) == 16 >>> largestRectangleArea([3, 3, 3, 3]) == 12 >>> largestRectangleArea([1, 2, 3, 4, 5]) == 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) == 9","solution":"def largestRectangleArea(heights): Returns the largest possible rectangular area of the billboard that can be installed on top of the buildings. stack = [] max_area = 0 for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area"},{"question":"import heapq from typing import List def kthSmallest(matrix: List[List[int]], k: int) -> int: Returns the k-th smallest element in a sorted matrix. Args: matrix: List[List[int]] - a n x n matrix where rows and columns are sorted in ascending order k: int - an integer between 1 and the total number of elements in the matrix Returns: int - the k-th smallest element in the matrix >>> kthSmallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kthSmallest([ ... [1, 2], ... [3, 4] ... ], 2) 2 >>> kthSmallest([ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ], 5) 3 >>> kthSmallest([ ... [1, 3, 5], ... [6, 7, 12], ... [11, 14, 14] ... ], 6) 11 >>> kthSmallest([ ... [5, 9, 17], ... [10, 12, 14], ... [13, 14, 16] ... ], 9) 17","solution":"import heapq def kthSmallest(matrix, k): Returns the k-th smallest element in a sorted matrix. Args: matrix: List[List[int]] - a n x n matrix where rows and columns are sorted in ascending order k: int - an integer between 1 and the total number of elements in the matrix Returns: int - the k-th smallest element in the matrix n = len(matrix) min_heap = [(matrix[0][0], 0, 0)] # (value, row, col) visited = set((0, 0)) for _ in range(k): val, r, c = heapq.heappop(min_heap) if r + 1 < n and (r + 1, c) not in visited: heapq.heappush(min_heap, (matrix[r + 1][c], r + 1, c)) visited.add((r + 1, c)) if c + 1 < n and (r, c + 1) not in visited: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) visited.add((r, c + 1)) return val"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head: ListNode, x: int) -> ListNode: Partition a linked list such that all nodes less than x come before nodes greater than or equal to x. The original relative order of the nodes in each of the two partitions should be preserved. :param head: The head of the linked list. :param x: The partition value. :return: The head of the modified linked list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition(head, x): less_head = ListNode(0) less = less_head greater_head = ListNode(0) greater = greater_head current = head while current: if current.val < x: less.next = current less = less.next else: greater.next = current greater = greater.next current = current.next greater.next = None less.next = greater_head.next return less_head.next"},{"question":"def wordPattern(pattern: str, s: str) -> bool: Determine if the string s follows the pattern. Args: pattern (str): a string pattern. s (str): a string consisting of words separated by spaces. Returns: bool: True if s follows the pattern, False otherwise. Examples: >>> wordPattern(\\"abba\\", \\"dog cat cat dog\\") True >>> wordPattern(\\"abba\\", \\"dog cat cat fish\\") False >>> wordPattern(\\"aaaa\\", \\"dog cat cat dog\\") False >>> wordPattern(\\"abba\\", \\"dog dog dog dog\\") False >>> wordPattern(\\"abc\\", \\"dog cat\\") False >>> wordPattern(\\"\\", \\"\\") True >>> wordPattern(\\"a\\", \\"\\") False >>> wordPattern(\\"\\", \\"dog\\") False import pytest from solution import wordPattern def test_wordPattern_true_example1(): assert wordPattern(\\"abba\\", \\"dog cat cat dog\\") == True def test_wordPattern_false_example2(): assert wordPattern(\\"abba\\", \\"dog cat cat fish\\") == False def test_wordPattern_false_example3(): assert wordPattern(\\"aaaa\\", \\"dog cat cat dog\\") == False def test_wordPattern_true_example4(): assert wordPattern(\\"abba\\", \\"dog dog dog dog\\") == False def test_wordPattern_false_diff_length(): assert wordPattern(\\"abc\\", \\"dog cat\\") == False def test_wordPattern_empty_pattern_and_s(): assert wordPattern(\\"\\", \\"\\") == True def test_wordPattern_empty_s(): assert wordPattern(\\"a\\", \\"\\") == False def test_wordPattern_empty_pattern(): assert wordPattern(\\"\\", \\"dog\\") == False","solution":"def wordPattern(pattern, s): Determine if the string s follows the pattern. Args: pattern (str): a string pattern. s (str): a string consisting of words separated by spaces. Returns: bool: True if s follows the pattern, False otherwise. words = s.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"def min_operations_to_non_decreasing(heights: List[int]) -> int: Returns the minimum number of operations required to make the array of heights non-decreasing. >>> min_operations_to_non_decreasing([1, 2, 3, 4]) == 0 >>> min_operations_to_non_decreasing([4, 3, 2, 1]) == 6 >>> min_operations_to_non_decreasing([1, 3, 2, 4]) == 1 >>> min_operations_to_non_decreasing([1, 2, 2, 2]) == 0 >>> min_operations_to_non_decreasing([10, 1, 10]) == 9 >>> min_operations_to_non_decreasing([1, 10, 1, 10, 1]) == 18","solution":"def min_operations_to_non_decreasing(heights): Returns the minimum number of operations required to make the array of heights non-decreasing. operations = 0 for i in range(1, len(heights)): if heights[i] < heights[i - 1]: operations += heights[i - 1] - heights[i] heights[i] = heights[i - 1] # Adjust height to make non-decreasing return operations"},{"question":"class TreeNode: def __init__(self, value=0, char='', left=None, right=None): self.value = value self.char = char self.left = left self.right = right def longest_valid_path(root): Return the length of the longest valid path in a binary tree. A valid path is a sequence of nodes where each node has a character that is in non-decreasing alphabetical order. >>> root = TreeNode(1, 'a') >>> longest_valid_path(root) 1 >>> root = TreeNode(1, 'a', TreeNode(2, 'b')) >>> longest_valid_path(root) 2 >>> root = TreeNode(1, 'b', TreeNode(2, 'a')) >>> longest_valid_path(root) 1 >>> root = TreeNode(1, 'a', TreeNode(2, 'b', TreeNode(3, 'c'))) >>> longest_valid_path(root) 3 >>> root = TreeNode(1, 'a', TreeNode(2, 'b', TreeNode(4, 'd')), TreeNode(3, 'c', TreeNode(5, 'd'), TreeNode(6, 'e'))) >>> longest_valid_path(root) 3 >>> root = TreeNode(1, 'c', TreeNode(2, 'b', TreeNode(4, 'a')), TreeNode(3, 'a', TreeNode(5, 'd'), TreeNode(6, 'b'))) >>> longest_valid_path(root) 1","solution":"class TreeNode: def __init__(self, value=0, char='', left=None, right=None): self.value = value self.char = char self.left = left self.right = right def longest_valid_path(root): def dfs(node, prev_char, curr_length): if not node: return curr_length if node.char >= prev_char: left_length = dfs(node.left, node.char, curr_length + 1) right_length = dfs(node.right, node.char, curr_length + 1) return max(left_length, right_length) else: return curr_length return dfs(root, '', 0) # Example usage: # Constructing a binary tree # 1('a') # / # 2('b') 3('c') # / # 4('d') 5('b') root = TreeNode(1, 'a') root.left = TreeNode(2, 'b') root.right = TreeNode(3, 'c', TreeNode(4, 'd'), TreeNode(5, 'b')) print(longest_valid_path(root)) # Expected Output: 3 ('a' -> 'b' -> 'c')"},{"question":"def can_transform(str1: str, str2: str) -> bool: Returns True if str1 can be transformed into str2 using any number of character changes. Returns False otherwise. >>> can_transform(\\"abc\\", \\"xyz\\") True >>> can_transform(\\"abc\\", \\"xy\\") False >>> can_transform(\\"a\\", \\"xyz\\") False >>> can_transform(\\"abc\\", \\"abc\\") True >>> can_transform(\\"\\", \\"\\") True >>> can_transform(\\"a\\", \\"b\\") True","solution":"def can_transform(str1, str2): Returns True if str1 can be transformed into str2 using any number of character changes. Returns False otherwise. # Ensure both strings are of the same length if len(str1) != len(str2): return False # If both strings have the same length, they can always transform into each other return True"},{"question":"def longest_palindrome_with_one_move(s: str) -> int: Given a string s consisting of uppercase English letters, return the length of the longest palindrome that can be achieved by performing at most one move. >>> longest_palindrome_with_one_move(\\"AABB\\") 4 >>> longest_palindrome_with_one_move(\\"AAB\\") 3 >>> longest_palindrome_with_one_move(\\"AABC\\") 3 >>> longest_palindrome_with_one_move(\\"A\\") 1 >>> longest_palindrome_with_one_move(\\"\\") 0","solution":"def longest_palindrome_with_one_move(s): Returns the length of the longest palindrome that can be achieved by performing at most one move in the string s. from collections import Counter count = Counter(s) odd_count = sum(1 for v in count.values() if v % 2 != 0) if odd_count == 0: # If there are no odd counts, the whole string can form a palindrome return len(s) elif odd_count == 1: return len(s) # One odd, at most one move needed to make it a palindrome else: return len(s) - odd_count + 1 # Move one char to balance"},{"question":"def modify_sentence(s: str) -> str: Modifies the sentence \`s\` such that each word that starts with a lowercase letter is reversed, and each word that starts with an uppercase letter remains as is. >>> modify_sentence(\\"hello world\\") == \\"olleh dlrow\\" >>> modify_sentence(\\"HELLO WORLD\\") == \\"HELLO WORLD\\" >>> modify_sentence(\\"hello World\\") == \\"olleh World\\" >>> modify_sentence(\\"Hello world\\") == \\"Hello dlrow\\" >>> modify_sentence(\\"\\") == \\"\\" >>> modify_sentence(\\"hello\\") == \\"olleh\\" >>> modify_sentence(\\"HELLO\\") == \\"HELLO\\" >>> modify_sentence(\\"HeLLo WorLD\\") == \\"HeLLo WorLD\\" >>> modify_sentence(\\"123 456\\") == \\"123 456\\" >>> modify_sentence(\\"hello123 world456\\") == \\"321olleh 654dlrow\\" >>> modify_sentence(\\"HELLO123 WORLD456\\") == \\"HELLO123 WORLD456\\"","solution":"def modify_sentence(s): Modifies the sentence \`s\` such that each word that starts with a lowercase letter is reversed, and each word that starts with an uppercase letter remains as is. :param s: A string representing a sentence. :return: A modified string. words = s.split() modified_words = [ word[::-1] if word[0].islower() else word for word in words ] return ' '.join(modified_words)"},{"question":"class DeliveryTracker: A class to track the delivery times of various trucks and calculate average delivery times between locations. Methods: def startDelivery(self, truckId: int, location: str, startTime: int) -> None: A truck with ID truckId starts a delivery at location at time startTime. def endDelivery(self, truckId: int, location: str, endTime: int) -> None: The truck with ID truckId completes its delivery at location at time endTime. def getAverageDeliveryTime(self, startLocation: str, endLocation: str) -> float: Returns the average time it takes to complete deliveries from startLocation to endLocation. Usage: >>> dt = DeliveryTracker() >>> dt.startDelivery(1, \\"A\\", 10) >>> dt.endDelivery(1, \\"B\\", 20) >>> dt.getAverageDeliveryTime(\\"A\\", \\"B\\") 10.0 def startDelivery(self, truckId: int, location: str, startTime: int) -> None: pass def endDelivery(self, truckId: int, location: str, endTime: int) -> None: pass def getAverageDeliveryTime(self, startLocation: str, endLocation: str) -> float: pass def test_start_and_end_delivery(): dt = DeliveryTracker() dt.startDelivery(1, \\"A\\", 10) dt.endDelivery(1, \\"B\\", 20) assert dt.getAverageDeliveryTime(\\"A\\", \\"B\\") == 10.0 def test_multiple_deliveries_same_route(): dt = DeliveryTracker() dt.startDelivery(1, \\"A\\", 10) dt.endDelivery(1, \\"B\\", 20) dt.startDelivery(2, \\"A\\", 30) dt.endDelivery(2, \\"B\\", 50) assert dt.getAverageDeliveryTime(\\"A\\", \\"B\\") == 15.0 # (10 + 20) / 2 def test_multiple_routes(): dt = DeliveryTracker() dt.startDelivery(1, \\"A\\", 10) dt.endDelivery(1, \\"B\\", 20) dt.startDelivery(2, \\"A\\", 30) dt.endDelivery(2, \\"C\\", 50) dt.startDelivery(3, \\"B\\", 25) dt.endDelivery(3, \\"C\\", 35) assert dt.getAverageDeliveryTime(\\"A\\", \\"B\\") == 10.0 assert dt.getAverageDeliveryTime(\\"A\\", \\"C\\") == 20.0 assert dt.getAverageDeliveryTime(\\"B\\", \\"C\\") == 10.0 def test_no_direct_delivery(): dt = DeliveryTracker() dt.startDelivery(1, \\"A\\", 10) dt.endDelivery(1, \\"B\\", 20) dt.startDelivery(2, \\"B\\", 30) dt.endDelivery(2, \\"C\\", 50) assert dt.getAverageDeliveryTime(\\"A\\", \\"C\\") == 0.0 # No direct delivery from A to C def test_same_start_and_end_location(): dt = DeliveryTracker() dt.startDelivery(1, \\"A\\", 10) dt.endDelivery(1, \\"A\\", 20) assert dt.getAverageDeliveryTime(\\"A\\", \\"A\\") == 0.0 # Ignore this as delivery did not move","solution":"class DeliveryTracker: def __init__(self): self.deliveries = {} self.times = {} def startDelivery(self, truckId, location, startTime): self.deliveries[truckId] = (location, startTime) def endDelivery(self, truckId, location, endTime): if truckId in self.deliveries: start_location, start_time = self.deliveries.pop(truckId) if start_location == location: return route = (start_location, location) time_taken = endTime - start_time if route not in self.times: self.times[route] = [] self.times[route].append(time_taken) def getAverageDeliveryTime(self, startLocation, endLocation): route = (startLocation, endLocation) if route not in self.times or not self.times[route]: return 0.0 return sum(self.times[route]) / len(self.times[route])"},{"question":"from typing import List def word_ladder(beginWord: str, endWord: str, words: List[str]) -> int: Returns the minimum number of steps required to transform \`beginWord\` into \`endWord\`, transforming one letter at a time using words from the list. Returns -1 if not possible. >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_ladder(\\"hit\\", \\"hit\\", [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 1 >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) -1 >>> word_ladder(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) 2 >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hut\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) -1","solution":"from collections import deque def word_ladder(beginWord, endWord, words): Returns the minimum number of steps required to transform \`beginWord\` into \`endWord\`, transforming one letter at a time using words from the list. Returns -1 if not possible. if endWord not in words: return -1 word_set = set(words) queue = deque([(beginWord, 1)]) # initialize queue with (word, step count) while queue: current_word, steps = queue.popleft() if current_word == endWord: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, steps + 1)) return -1"},{"question":"def min_distance(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s into string t. Operations allowed are insert, delete, replace a character. >>> min_distance(\\"abc\\", \\"abc\\") 0 >>> min_distance(\\"\\", \\"abc\\") 3 >>> min_distance(\\"abc\\", \\"\\") 3 >>> min_distance(\\"a\\", \\"abcd\\") 3 >>> min_distance(\\"abcd\\", \\"a\\") 3 >>> min_distance(\\"abcdef\\", \\"azced\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5 pass","solution":"def min_distance(s, t): Returns the minimum number of operations required to convert string s into string t. Operations allowed are insert, delete, replace a character. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s is empty, inserting all characters from t elif j == 0: dp[i][j] = i # If t is empty, delete all characters in s elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete character from s dp[i][j - 1], # Insert character into s dp[i - 1][j - 1] # Replace character in s ) return dp[m][n]"},{"question":"def lexicographically_smallest_concatenation(words: List[str]) -> str: Given a list of strings \`words\`, return the string that can be obtained by concatenating all the strings in a way that forms the lexicographically smallest possible result. If there are multiple such results, return the one that appears first in the dictionary order. It is guaranteed that the length of all combined strings will not exceed 10^6. >>> lexicographically_smallest_concatenation([\\"a\\", \\"b\\", \\"c\\"]) == \\"abc\\" >>> lexicographically_smallest_concatenation([\\"aa\\", \\"ab\\", \\"ac\\"]) == \\"aaabac\\" >>> lexicographically_smallest_concatenation([\\"abc\\", \\"ab\\", \\"a\\"]) == \\"aababc\\" >>> lexicographically_smallest_concatenation([\\"Apple\\", \\"apple\\"]) == \\"Appleapple\\" >>> lexicographically_smallest_concatenation([\\"\\", \\"\\", \\"a\\"]) == \\"a\\"","solution":"def lexicographically_smallest_concatenation(words): Returns the lexicographically smallest concatenation of the given list of strings. # Sort the words with a custom key that compares concatenated results sorted_words = sorted(words, key=lambda x: x*len(words)) # Concatenate the sorted words return ''.join(sorted_words)"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_full_binary_tree(root): Determines if a binary tree is a full binary tree. A full binary tree is defined as a tree in which every node has either 0 or 2 children. :param TreeNode root: The root node of the binary tree. :return: True if the tree is a full binary tree, False otherwise. :rtype: bool >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> is_full_binary_tree(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> is_full_binary_tree(root) False >>> root = TreeNode(1) >>> is_full_binary_tree(root) True >>> root = None >>> is_full_binary_tree(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> is_full_binary_tree(root) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_full_binary_tree(root): Determines if a binary tree is a full binary tree. A full binary tree is defined as a tree in which every node has either 0 or 2 children. :param TreeNode root: The root node of the binary tree. :return: True if the tree is a full binary tree, False otherwise. :rtype: bool if root is None: return True if (root.left is None and root.right is not None) or (root.left is not None and root.right is None): return False return is_full_binary_tree(root.left) and is_full_binary_tree(root.right)"},{"question":"from typing import List def longest_subarray_with_two_distinct(arr: List[int]) -> int: Given an integer array 'arr', return the length of the longest subarray that contains at most two distinct integers. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 2, 1]) 4 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 pass def test_example(): assert longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 2, 1]) == 4 assert longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) == 2 def test_with_single_element(): assert longest_subarray_with_two_distinct([1]) == 1 def test_with_all_identical_elements(): assert longest_subarray_with_two_distinct([2, 2, 2, 2, 2]) == 5 def test_with_two_distinct_elements(): assert longest_subarray_with_two_distinct([1, 2, 1, 2, 1, 2]) == 6 def test_with_empty_array(): assert longest_subarray_with_two_distinct([]) == 0 def test_with_different_longest_subarray(): assert longest_subarray_with_two_distinct([1, 2, 3, 2, 2, 4, 5, 2, 2, 3, 4]) == 4","solution":"def longest_subarray_with_two_distinct(arr): from collections import defaultdict start = 0 max_len = 0 freq_map = defaultdict(int) for end in range(len(arr)): freq_map[arr[end]] += 1 while len(freq_map) > 2: freq_map[arr[start]] -= 1 if freq_map[arr[start]] == 0: del freq_map[arr[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def find_first_greater_or_equal(arr: List[int], target: int) -> int: Returns the index of the first integer in the array that is greater than or equal to the target. If no such integer exists, returns -1. :param arr: list of distinct integers sorted in increasing order :param target: integer target :return: index of the first integer >= target or -1 if none exists >>> find_first_greater_or_equal([1, 3, 5, 7], 4) 2 >>> find_first_greater_or_equal([1, 3, 5, 7], 5) 2 >>> find_first_greater_or_equal([1, 3, 5, 7], 8) -1 >>> find_first_greater_or_equal([], 3) -1 >>> find_first_greater_or_equal([1, 3, 5, 7], 0) 0 >>> find_first_greater_or_equal([2, 4, 6, 8, 10], 10) 4 >>> find_first_greater_or_equal([2, 4, 6, 8, 10], 11) -1","solution":"def find_first_greater_or_equal(arr, target): Returns the index of the first integer in the array that is greater than or equal to the target. If no such integer exists, returns -1. :param arr: list of distinct integers sorted in increasing order :param target: integer target :return: index of the first integer >= target or -1 if none exists low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] < target: low = mid + 1 else: high = mid - 1 if low < len(arr): return low else: return -1"},{"question":"def merge_strings(word1: str, word2: str) -> str: Merge two strings by alternating their characters, starting with the first character of word1. If one string is longer, append the additional characters to the end of the merged string. :param word1: First input string :param word2: Second input string :return: Merged string >>> merge_strings(\\"abc\\", \\"xyz\\") 'axbycz' >>> merge_strings(\\"abcd\\", \\"xy\\") 'axbycd' >>> merge_strings(\\"ab\\", \\"wxyz\\") 'awbxyz' >>> merge_strings(\\"\\", \\"xyz\\") 'xyz' >>> merge_strings(\\"abc\\", \\"\\") 'abc' >>> merge_strings(\\"\\", \\"\\") '' pass","solution":"def merge_strings(word1, word2): Merge two strings by alternating their characters, starting with the first character of word1. If one string is longer, append the additional characters to the end of the merged string. :param word1: First input string :param word2: Second input string :return: Merged string merged_string = [] len1, len2 = len(word1), len(word2) max_len = max(len1, len2) for i in range(max_len): if i < len1: merged_string.append(word1[i]) if i < len2: merged_string.append(word2[i]) return \\"\\".join(merged_string)"},{"question":"def min_final_digits(s: str) -> int: Given a string \`s\` of digits, reduces it by replacing substrings with their digit sum until the sum is a single digit. Returns the minimum number of digits remaining. >>> min_final_digits(\\"5\\") 1 >>> min_final_digits(\\"123456789\\") 1 >>> min_final_digits(\\"0000\\") 1 >>> min_final_digits(\\"18\\") 1 >>> min_final_digits(\\"1111111111111111111\\") 1","solution":"def min_final_digits(s): Reduce the number string \`s\` by replacing non-empty substrings with their digit sum until the sum is a single digit. Returns the minimum number of digits remaining. # Calculate the sum of all digits in the original string total_sum = sum(int(c) for c in s) # Return the sum of digits repeated until a single digit result is obtained def digit_root(n): while n > 9: n = sum(int(c) for c in str(n)) return n return 1 if digit_root(total_sum) < 10 else len(str(digit_root(total_sum)))"},{"question":"from typing import List def longest_palindrome(s: str) -> int: Returns the length of the longest palindrome that can be formed by rearranging the characters in the string. >>> longest_palindrome('aabbcc') == 6 >>> longest_palindrome('abc') == 1 >>> longest_palindrome('abccccdd') == 7 >>> longest_palindrome('a') == 1 >>> longest_palindrome('ab') == 1 >>> longest_palindrome('aaaa') == 4 >>> longest_palindrome('') == 0 >>> longest_palindrome('aabbcccdeefd') == 11","solution":"def longest_palindrome(s): Returns the length of the longest palindrome that can be formed by rearranging the characters in the string. from collections import Counter count = Counter(s) length = 0 odd_found = False for char_count in count.values(): if char_count % 2 == 0: length += char_count else: length += char_count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def rearrange_array(nums: List[int], pivot: int) -> List[int]: Rearrange elements in nums such that all elements less than pivot appear before all elements equal to pivot, and those appear before all elements greater than pivot. >>> rearrange_array([9, 12, 5, 10, 14, 3, 10], 10) [9, 5, 3, 10, 10, 12, 14] >>> rearrange_array([1, 2, 3, 4, 5], 3) [1, 2, 3, 4, 5] >>> rearrange_array([5, 4, 3, 2, 1], 3) [2, 1, 3, 5, 4] >>> rearrange_array([3, 3, 3, 3, 3], 3) [3, 3, 3, 3, 3] >>> rearrange_array([1, 2, 3, 4, 3, 5, 3], 3) [1, 2, 3, 3, 3, 4, 5] >>> rearrange_array([7, 8, 9, 1, 2, 3], 5) [1, 2, 3, 7, 8, 9]","solution":"def rearrange_array(nums, pivot): Rearrange elements in nums such that all elements less than pivot appear before all elements equal to pivot, and those appear before all elements greater than pivot. Parameters: nums (list of int): The list of integers to rearrange. pivot (int): The pivot integer for the rearrangement. Returns: list of int: The rearranged list. less_than_pivot = [x for x in nums if x < pivot] equal_to_pivot = [x for x in nums if x == pivot] greater_than_pivot = [x for x in nums if x > pivot] return less_than_pivot + equal_to_pivot + greater_than_pivot"},{"question":"def longest_valid_substring(s: str) -> int: Returns the length of the longest valid substring where no two adjacent characters are the same. >>> longest_valid_substring(\\"\\") == 0 >>> longest_valid_substring(\\"abcdef\\") == 6 >>> longest_valid_substring(\\"aaaaa\\") == 1 >>> longest_valid_substring(\\"abababab\\") == 8 >>> longest_valid_substring(\\"aabbaa\\") == 2 >>> longest_valid_substring(\\"a\\") == 1 >>> longest_valid_substring(\\"aabbccddeeffgg\\") == 2 >>> longest_valid_substring(\\"abcaaaccbba\\") == 4","solution":"def longest_valid_substring(s): Returns the length of the longest valid substring where no two adjacent characters are the same. if not s: # handle empty string return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] != s[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_unsorted(head: ListNode) -> ListNode: Given the head of a singly linked list, remove all the nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. >>> linked_list_to_list(remove_duplicates_unsorted(list_to_linked_list([1, 2, 3, 4, 5]))) [1, 2, 3, 4, 5] >>> linked_list_to_list(remove_duplicates_unsorted(list_to_linked_list([1, 1, 2, 2, 3, 3]))) [] >>> linked_list_to_list(remove_duplicates_unsorted(list_to_linked_list([1, 2, 2, 3, 4, 4, 5]))) [1, 3, 5] >>> linked_list_to_list(remove_duplicates_unsorted(list_to_linked_list([1]))) [1] >>> linked_list_to_list(remove_duplicates_unsorted(list_to_linked_list([]))) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates_unsorted(head: ListNode) -> ListNode: if not head: return None # Step 1: Collect all the values and their counts in a dictionary counts = {} current = head while current: counts[current.val] = counts.get(current.val, 0) + 1 current = current.next # Step 2: Remove nodes with values that have counts greater than 1 dummy = ListNode(0, head) prev, current = dummy, head while current: if counts[current.val] > 1: prev.next = current.next else: prev = current current = current.next # Step 3: Return the filtered list return dummy.next"},{"question":"def next_permutation(nums: List[int]) -> List[int]: Modifies the list \`nums\` to its next permutation in lexicographical order. If such permutation is not possible, rearranges it to the lowest possible order. >>> nums = [1, 2, 3] >>> next_permutation(nums) >>> nums [1, 3, 2] >>> nums = [3, 2, 1] >>> next_permutation(nums) >>> nums [1, 2, 3] >>> nums = [1, 1, 5] >>> next_permutation(nums) >>> nums [1, 5, 1] >>> nums = [1] >>> next_permutation(nums) >>> nums [1] >>> nums = [2, 2, 2] >>> next_permutation(nums) >>> nums [2, 2, 2] >>> nums = [1, 5, 1] >>> next_permutation(nums) >>> nums [5, 1, 1] # Implementation code here","solution":"def next_permutation(nums): Modifies the list \`nums\` to its next permutation in lexicographical order. If such permutation is not possible, rearranges it to the lowest possible order. n = len(nums) if n <= 1: return nums # Step 1: Find the first decreasing element from the end i = n - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Step 2: Find the element just larger than nums[i] j = n - 1 while nums[j] <= nums[i]: j -= 1 # Step 3: Swap elements nums[i] and nums[j] nums[i], nums[j] = nums[j], nums[i] # Step 4: Reverse the elements from i+1 to the end nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def max_legal_actions(heights): Returns the maximum number of legal actions you can perform on the sequence. >>> max_legal_actions([5]) 0 >>> max_legal_actions([3, 3]) 3 >>> max_legal_actions([5, 2]) 2 >>> max_legal_actions([4, 4, 4, 4]) 12 >>> max_legal_actions([5, 4, 3, 2, 1]) 10 >>> max_legal_actions([1, 2, 3, 4, 5]) 10 >>> max_legal_actions([3, 1, 4, 1, 2]) 4 >>> max_legal_actions([3, 3, 3, 3, 3]) 12 >>> max_legal_actions([]) 0","solution":"def max_legal_actions(heights): Returns the maximum number of legal actions you can perform on the sequence. max_actions = 0 for i in range(len(heights) - 1): max_actions += min(heights[i], heights[i + 1]) return max_actions"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_nodes(root: TreeNode) -> int: Returns the number of \\"good\\" nodes in the binary tree. A node is considered \\"good\\" if it is greater than or equal to the maximum value encountered along the path from the root to that node. >>> count_good_nodes(TreeNode(1)) 1 >>> root = TreeNode(3) root.left = TreeNode(3) root.right = TreeNode(4) root.left.left = TreeNode(3) root.right.left = TreeNode(1) root.right.right = TreeNode(5) count_good_nodes(root) 4 def test_count_good_nodes_single_node(): root = TreeNode(1) assert count_good_nodes(root) == 1 def test_count_good_nodes_all_good(): root = create_tree([3, 3, 4, 3, 5]) assert count_good_nodes(root) == 5 def test_count_good_nodes_mixed(): root = create_tree([3, 1, 4, 3, None, 1, 5]) assert count_good_nodes(root) == 4 def test_count_good_nodes_none(): assert count_good_nodes(None) == 0 def test_count_good_nodes_complex(): root = create_tree([3, 3, 4, None, None, 1, 5]) assert count_good_nodes(root) == 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_good_nodes(root: TreeNode) -> int: def dfs(node, max_value): if not node: return 0 total_good = 0 if node.val >= max_value: total_good += 1 max_value = node.val total_good += dfs(node.left, max_value) total_good += dfs(node.right, max_value) return total_good return dfs(root, float('-inf'))"},{"question":"class SubarrayOperations: def __init__(self, arr): Initializes the \`SubarrayOperations\` object with the integer array \`arr\`. Args: arr (List[int]): The input array of integers. def increment(self, l, r, val): Increments all elements of the subarray \`arr[l:r+1]\` by \`val\`. Args: l (int): The starting index of the subarray. r (int): The ending index of the subarray. val (int): The value to increment the subarray by. def maximum(self, l, r): Returns the maximum value in the subarray \`arr[l:r+1]\`. Args: l (int): The starting index of the subarray. r (int): The ending index of the subarray. Returns: int: The maximum value in the subarray. # Test cases def test_increment(): arr = [1, 2, 3, 4, 5] subarray_ops = SubarrayOperations(arr) subarray_ops.increment(1, 3, 2) assert subarray_ops.arr == [1, 4, 5, 6, 5] def test_maximum(): arr = [1, 2, 3, 4, 5] subarray_ops = SubarrayOperations(arr) assert subarray_ops.maximum(1, 3) == 4 assert subarray_ops.maximum(0, 4) == 5 def test_increment_and_maximum(): arr = [10, 5, 0, 3, 8] subarray_ops = SubarrayOperations(arr) subarray_ops.increment(1, 3, 4) assert subarray_ops.arr == [10, 9, 4, 7, 8] assert subarray_ops.maximum(1, 3) == 9 subarray_ops.increment(2, 4, 1) assert subarray_ops.arr == [10, 9, 5, 8, 9] assert subarray_ops.maximum(0, 4) == 10 def test_edge_cases(): arr = [5] subarray_ops = SubarrayOperations(arr) subarray_ops.increment(0, 0, 3) assert subarray_ops.arr == [8] assert subarray_ops.maximum(0, 0) == 8","solution":"class SubarrayOperations: def __init__(self, arr): self.arr = arr def increment(self, l, r, val): for i in range(l, r + 1): self.arr[i] += val def maximum(self, l, r): return max(self.arr[l:r + 1])"},{"question":"def can_transform(s1: str, s2: str) -> bool: Checks if it is possible to transform s1 into s2 by inserting characters. >>> can_transform(\\"abc\\", \\"aebc\\") True >>> can_transform(\\"abc\\", \\"aebdfc\\") True >>> can_transform(\\"abc\\", \\"abx\\") False >>> can_transform(\\"\\", \\"anything\\") True >>> can_transform(\\"anything\\", \\"\\") False >>> can_transform(\\"\\", \\"\\") True","solution":"def can_transform(s1, s2): Checks if it is possible to transform s1 into s2 by inserting characters. Parameters: s1 (str): The source string. s2 (str): The target string to be formed. Returns: bool: True if transformation is possible, otherwise False. # Start pointers for both strings i = 0 j = 0 while i < len(s1) and j < len(s2): if s1[i] == s2[j]: i += 1 j += 1 return i == len(s1)"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Given a grid of integers, find the minimum path sum from the top-left corner to the bottom-right corner, where you can only move either down or right at any point in time. Args: grid (List[List[int]]): 2D list of integer weights Returns: int: The minimum path sum Example: >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_path_sum([ ... [1, 2], ... ]) 3 >>> min_path_sum([ ... [1], ... [2] ... ]) 3 >>> min_path_sum([ ... [5] ... ]) 5 >>> min_path_sum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 5 # Your implementation here","solution":"def min_path_sum(grid): Given a grid of integers, returns the minimum path sum from the top-left corner to the bottom-right corner. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a 2D dp array with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"def rotateArray(nums: List[int], k: int) -> None: Rotates the array to the right by k steps. Modifies the array in-place. >>> nums = [1, 2, 3, 4, 5] >>> rotateArray(nums, 1) >>> nums [5, 1, 2, 3, 4] >>> nums = [1, 2, 3, 4, 5] >>> rotateArray(nums, 5) >>> nums [1, 2, 3, 4, 5] >>> nums = [1, 2, 3, 4, 5] >>> rotateArray(nums, 6) >>> nums [5, 1, 2, 3, 4] >>> nums = [1, 2, 3, 4, 5] >>> rotateArray(nums, 0) >>> nums [1, 2, 3, 4, 5] >>> nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> rotateArray(nums, 4) >>> nums [7, 8, 9, 10, 1, 2, 3, 4, 5, 6]","solution":"def rotateArray(nums, k): Rotates the array to the right by k steps. Modifies the array in-place. n = len(nums) k %= n # Handle the case where k is larger than the length of the array nums[:] = nums[-k:] + nums[:-k] # Rotate the array"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def sum_queries(head, queries): You are given a linked list, where the head node is at index 0 and each node contains an integer value and a reference to the next node. You are also given a list queries where each query contains two integers: the start index start and the end index end. For each query, you need to compute the sum of the values of the nodes from index start to end (inclusive). Return an array that contains the result of each query. Ensure your solution efficiently computes the sums without recalculating the sums for overlapping sublists. >>> head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> queries = [(0, 2), (1, 3), (0, 4)] >>> sum_queries(head, queries) [6, 9, 15] >>> head = ListNode(1, ListNode(-1, ListNode(2, ListNode(-2)))) >>> queries = [(0, 3), (1, 2)] >>> sum_queries(head, queries) [0, 1] import pytest def test_sum_queries_single_node(): head = ListNode(5) queries = [(0, 0)] assert sum_queries(head, queries) == [5] def test_sum_queries_multiple_nodes(): head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) queries = [(0, 2), (1, 3), (0, 4)] assert sum_queries(head, queries) == [6, 9, 15] def test_sum_queries_with_zero_sum(): head = ListNode(1, ListNode(-1, ListNode(2, ListNode(-2)))) queries = [(0, 3), (1, 2)] assert sum_queries(head, queries) == [0, 1] def test_sum_queries_complex(): head = ListNode(3, ListNode(7, ListNode(8, ListNode(10)))) queries = [(0, 1), (0, 3), (2, 3)] assert sum_queries(head, queries) == [10, 28, 18] def test_sum_queries_empty_list(): head = None queries = [(0, 0)] assert sum_queries(head, queries) == [0] @pytest.fixture def linked_list(): head = ListNode(1) current = head for val in [2, 3, 4, 5, 6]: current.next = ListNode(val) current = current.next return head def test_sum_queries_connected_list(linked_list): queries = [(0, 2), (2, 5), (0, 5), (3, 4)] assert sum_queries(linked_list, queries) == [6, 18, 21, 9]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def compute_prefix_sums(head): prefix_sums = [] current = head index = 0 current_sum = 0 while current is not None: current_sum += current.val prefix_sums.append(current_sum) current = current.next index += 1 return prefix_sums def sum_queries(head, queries): if not head: return [0] * len(queries) prefix_sums = compute_prefix_sums(head) results = [] for start, end in queries: if start == 0: results.append(prefix_sums[end]) else: results.append(prefix_sums[end] - prefix_sums[start - 1]) return results"},{"question":"def is_subsequence(word: str, dict_word: str) -> bool: Check if \`word\` is a subsequence of \`dict_word\`. it = iter(dict_word) return all(char in it for char in word) def find_subsequences(words: List[str], dictionary: str) -> List[str]: Given a list of strings \`words\` and a dictionary string \`dictionary\`, returns all the words from \`words\` that are subsequences of any word in the \`dictionary\`. >>> find_subsequences([\\"a\\", \\"ab\\", \\"abc\\"], \\"abc abc abc\\") [\\"a\\", \\"ab\\", \\"abc\\"] >>> find_subsequences([\\"a\\", \\"ax\\", \\"abc\\", \\"xyz\\"], \\"abc xyz\\") [\\"a\\", \\"abc\\", \\"xyz\\"] >>> find_subsequences([\\"a\\", \\"ax\\", \\"xyz\\"], \\"def ghi\\") [] >>> find_subsequences([], \\"\\") [] >>> find_subsequences([\\"a\\", \\"ab\\", \\"bca\\"], \\"abcd efgh ijkl\\") [\\"a\\", \\"ab\\"]","solution":"def is_subsequence(word, dict_word): Check if \`word\` is a subsequence of \`dict_word\`. it = iter(dict_word) return all(char in it for char in word) def find_subsequences(words, dictionary): Given a list of strings \`words\` and a dictionary string \`dictionary\`, returns all the words from \`words\` that are subsequences of any word in the \`dictionary\`. dict_words = dictionary.split() result = [] for word in words: if any(is_subsequence(word, dict_word) for dict_word in dict_words): result.append(word) return result"},{"question":"from typing import List def sum_at_max_depth(n: int, edges: List[List[int]]) -> int: Given a binary tree with \`n\` nodes, each node has a unique value from \`1\` to \`n\`, and each value represents the value of that particular node. The tree structure is given by a 2D integer array \`edges\`, where \`edges[i] = [ui, vi]\` indicates that there is an edge between nodes \`ui\` and \`vi\`. The function returns the sum of the values of the nodes at the maximum depth level of the binary tree. >>> sum_at_max_depth(1, []) 1 >>> sum_at_max_depth(3, [[1, 2], [1, 3]]) 5 >>> sum_at_max_depth(6, [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6]]) 15 >>> sum_at_max_depth(5, [[1, 2], [1, 3], [2, 4], [4, 5]]) 5 >>> sum_at_max_depth(2, [[1, 2]]) 2 >>> sum_at_max_depth(7, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7]]) 7","solution":"from collections import defaultdict, deque def sum_at_max_depth(n, edges): if not edges: return n # Only one node in the tree # Building graph using adjacency list representation graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Breadth-First Search (BFS) to find nodes at the maximum depth visited = set() queue = deque([(1, 0)]) # Starting BFS from node 1 at depth 0 max_depth = 0 max_depth_nodes = [] while queue: node, depth = queue.popleft() if depth > max_depth: max_depth = depth max_depth_nodes = [node] elif depth == max_depth: max_depth_nodes.append(node) visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append((neighbor, depth + 1)) return sum(max_depth_nodes)"},{"question":"class LibrarySystem: def __init__(self, books): Initializes the library system with a list of books. All books are available by default. def borrow(self, book): Sets the book status to 'borrowed' if it is available and returns True. If the book is already borrowed or reserved, returns False. def reserve(self, book): Sets the book status to 'reserved' if it is available and returns True. If the book is already borrowed or reserved, returns False. def returnBook(self, book): Changes the status of the book back to 'available' if it was borrowed or reserved. # Unit Tests def test_initialize_library(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) assert library.books == {\\"Book A\\": \\"available\\", \\"Book B\\": \\"available\\"} def test_borrow_available_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) assert library.borrow(\\"Book A\\") == True assert library.books[\\"Book A\\"] == \\"borrowed\\" def test_borrow_borrowed_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) library.borrow(\\"Book A\\") assert library.borrow(\\"Book A\\") == False def test_borrow_reserved_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) library.reserve(\\"Book A\\") assert library.borrow(\\"Book A\\") == False def test_reserve_available_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) assert library.reserve(\\"Book A\\") == True assert library.books[\\"Book A\\"] == \\"reserved\\" def test_reserve_reserved_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) library.reserve(\\"Book A\\") assert library.reserve(\\"Book A\\") == False def test_reserve_borrowed_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) library.borrow(\\"Book A\\") assert library.reserve(\\"Book A\\") == False def test_return_borrowed_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) library.borrow(\\"Book A\\") library.returnBook(\\"Book A\\") assert library.books[\\"Book A\\"] == \\"available\\" def test_return_reserved_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) library.reserve(\\"Book A\\") library.returnBook(\\"Book A\\") assert library.books[\\"Book A\\"] == \\"available\\" def test_return_available_book(): library = LibrarySystem([\\"Book A\\", \\"Book B\\"]) library.returnBook(\\"Book A\\") assert library.books[\\"Book A\\"] == \\"available\\"","solution":"class LibrarySystem: def __init__(self, books): Initializes the library system with a list of books. All books are available by default. self.books = {book: 'available' for book in books} def borrow(self, book): Sets the book status to 'borrowed' if it is available and returns True. If the book is already borrowed or reserved, returns False. if book in self.books and self.books[book] == 'available': self.books[book] = 'borrowed' return True return False def reserve(self, book): Sets the book status to 'reserved' if it is available and returns True. If the book is already borrowed or reserved, returns False. if book in self.books and self.books[book] == 'available': self.books[book] = 'reserved' return True return False def returnBook(self, book): Changes the status of the book back to 'available' if it was borrowed or reserved. if book in self.books and self.books[book] in ['borrowed', 'reserved']: self.books[book] = 'available'"},{"question":"def has_pair_with_sum(arr: List[int], k: int) -> bool: Checks if there exists a pair of distinct indices i and j such that arr[i] + arr[j] == k. :param arr: List[int] - list of integers :param k: int - target sum :return: bool - True if such a pair exists, otherwise False >>> has_pair_with_sum([1, 2, 3, 4], 5) True >>> has_pair_with_sum([1, 2, 3, 4], 7) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([1, 1, 1, 1], 3) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([1], 2) False >>> has_pair_with_sum([1, 3, 2, 4, 3], 6) True >>> has_pair_with_sum([1, 3, 2, 4, 3], 7) True >>> has_pair_with_sum([-1, -2, -3, -4], -5) True >>> has_pair_with_sum([-1, -2, -3, -4], -10) False","solution":"def has_pair_with_sum(arr, k): Checks if there exists a pair of distinct indices i and j such that arr[i] + arr[j] == k. :param arr: List[int] - list of integers :param k: int - target sum :return: bool - True if such a pair exists, otherwise False seen = set() for num in arr: if k - num in seen: return True seen.add(num) return False"},{"question":"from typing import List def maximalSquare(matrix: List[List[int]]) -> int: Returns the number of 1's in the largest square sub-matrix that contains only 1's. Args: matrix: List[List[int]] - binary matrix with m rows and n columns Returns: int - number of 1's in the largest square sub-matrix that contains only 1's >>> maximalSquare([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) == 4 >>> maximalSquare([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> maximalSquare([[1, 1], [1, 1]]) == 4 >>> maximalSquare([[0]]) == 0 >>> maximalSquare([[1]]) == 1 >>> maximalSquare([]) == 0 >>> maximalSquare([[1, 0], [0, 1]]) == 1 >>> maximalSquare([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 9","solution":"def maximalSquare(matrix): Returns the number of 1's in the largest square sub-matrix that contains only 1's. Args: matrix: List[List[int]] - binary matrix with m rows and n columns Returns: int - number of 1's in the largest square sub-matrix that contains only 1's if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if matrix[i-1][j-1] == 1: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def trap(heights: List[int]) -> int: Calculate the maximum volume of rainwater that can be trapped between the buildings. >>> trap([]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2]) 8 >>> trap([2, 0, 2]) 2 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([1, 1, 1, 1, 1, 1, 1]) 0 >>> trap([3, 3, 3, 3]) 0","solution":"def trap(heights): Calculate the maximum volume of rainwater that can be trapped between the buildings. :param heights: List[int] A list of integers representing the heights of buildings. :return: int Total amount of trapped rainwater. if not heights: return 0 left_max = [0] * len(heights) right_max = [0] * len(heights) water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, len(heights)): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[len(heights)-1] = heights[len(heights)-1] for i in range(len(heights)-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate total water trapped for i in range(len(heights)): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def maxSubArray(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given list. >>> maxSubArray([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> maxSubArray([-5, -4, -3, -2, -1]) == -1 >>> maxSubArray([1]) == 1 >>> maxSubArray([-1]) == -1 >>> maxSubArray([1, 2, 3, -2, 5]) == 9 >>> maxSubArray([0, -3, 1, 1, 0]) == 2 >>> maxSubArray([]) == 0","solution":"def maxSubArray(nums): Returns the maximum sum of any contiguous subarray within the given list. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_subsequence_length(s: str) -> int: Given a string, find the length of the longest subsequence that contains no two consecutive identical characters. >>> longest_subsequence_length(\\"\\") 0 >>> longest_subsequence_length(\\"a\\") 1 >>> longest_subsequence_length(\\"aaaa\\") 1 >>> longest_subsequence_length(\\"abcdef\\") 6 >>> longest_subsequence_length(\\"aabbcc\\") 3 >>> longest_subsequence_length(\\"ababab\\") 6 >>> longest_subsequence_length(\\"aaabbbcccddd\\") 4","solution":"def longest_subsequence_length(s): Return the length of the longest subsequence with no two consecutive identical characters. if not s: return 0 n = len(s) count = 1 # First character is always included for i in range(1, n): if s[i] != s[i-1]: count += 1 return count"},{"question":"def smallest_string_with_swaps(s: str, pairs: List[List[int]]) -> str: Given a string s and an array of pairs of indices pairs where each pair (i, j) represents a swap operation where substrings of length 1 at indices i and j can be swapped, return the lexicographically smallest string that s can be transformed into after any number of swap operations. >>> smallest_string_with_swaps(\\"dcab\\", [[0,3],[1,2]]) == \\"bacd\\" >>> smallest_string_with_swaps(\\"dcab\\", [[0, 1]]) == \\"cdab\\" >>> smallest_string_with_swaps(\\"cba\\", [[0, 1], [1, 2]]) == \\"abc\\" >>> smallest_string_with_swaps(\\"abc\\", []) == \\"abc\\" >>> smallest_string_with_swaps(\\"dcab\\", [[0, 1]]) == \\"cdab\\"","solution":"def smallest_string_with_swaps(s, pairs): from collections import defaultdict import heapq def dfs(i, indices, characters): visited[i] = True indices.append(i) characters.append(s[i]) for neighbor in graph[i]: if not visited[neighbor]: dfs(neighbor, indices, characters) n = len(s) graph = defaultdict(list) for i, j in pairs: graph[i].append(j) graph[j].append(i) visited = [False] * n result = list(s) for i in range(n): if not visited[i]: indices = [] characters = [] dfs(i, indices, characters) indices.sort() characters.sort() for idx, char in zip(indices, characters): result[idx] = char return ''.join(result)"},{"question":"from typing import List def longest_zero_subarray_start_index(nums: List[int]) -> int: Given an integer array nums, return the starting index of the longest subarray that contains only the value 0. If there are multiple such subarrays of equal length, return the starting index of the first one. If no such subarray exists, return -1. >>> longest_zero_subarray_start_index([0, 0, 0]) 0 >>> longest_zero_subarray_start_index([1, 2, 3, 4, 5]) -1 >>> longest_zero_subarray_start_index([1, 0, 2, 3, 4]) 1 >>> longest_zero_subarray_start_index([1, 0, 0, 1, 0, 0, 0]) 4 >>> longest_zero_subarray_start_index([0, 0, 1, 2, 0, 0, 0]) 4 >>> longest_zero_subarray_start_index([0, 0, 0, 1, 0, 0]) 0 >>> longest_zero_subarray_start_index([2, 3, 4, 1, 5, 6]) -1 >>> longest_zero_subarray_start_index([0]) 0 >>> longest_zero_subarray_start_index([1]) -1 # Write your code here","solution":"def longest_zero_subarray_start_index(nums): Given an integer array nums, return the starting index of the longest subarray that contains only the value 0. If there are multiple such subarrays of equal length, return the starting index of the first one. If no such subarray exists, return -1. max_length = 0 start_index = -1 current_length = 0 current_start = 0 for i, num in enumerate(nums): if num == 0: if current_length == 0: current_start = i current_length += 1 else: if current_length > max_length: max_length = current_length start_index = current_start current_length = 0 if current_length > max_length: start_index = current_start return start_index"},{"question":"def longest_subarray_with_two_distinct(nums: List[int]) -> int: Given an array of integers \`nums\`, find the length of the longest subarray that contains at most two distinct values. >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3, 1]) 4 >>> longest_subarray_with_two_distinct([1]) 1 >>> longest_subarray_with_two_distinct([1, 1, 1, 1]) 4 >>> longest_subarray_with_two_distinct([1, 2]) 2 >>> longest_subarray_with_two_distinct([]) 0 >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_two_distinct([1, 1, 3, 4, 3]) 3 >>> longest_subarray_with_two_distinct([2, 1, 3, 2, 2, 4, 4, 5, 5, 6]) 4 >>> longest_subarray_with_two_distinct([1, 2, 3, 2, 2]) 4 >>> longest_subarray_with_two_distinct([4, 1, 1, 2, 3, 3, 4, 4]) 4","solution":"def longest_subarray_with_two_distinct(nums): Finds the length of the longest subarray that contains at most two distinct values. if not nums: return 0 window_start = 0 max_length = 0 freq_map = {} for window_end in range(len(nums)): right_char = nums[window_end] if right_char not in freq_map: freq_map[right_char] = 0 freq_map[right_char] += 1 while len(freq_map) > 2: left_char = nums[window_start] freq_map[left_char] -= 1 if freq_map[left_char] == 0: del freq_map[left_char] window_start += 1 max_length = max(max_length, window_end - window_start + 1) return max_length"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if there are two distinct elements in the list \`nums\` whose sum equals \`target\`. Parameters: nums (list of int): The list of integers to check. target (int): The target sum value. Returns: bool: True if such a pair exists, False otherwise. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([], 5) False >>> has_pair_with_sum([3], 3) False >>> has_pair_with_sum([1, 2, 3, 4, 5], 6) True >>> has_pair_with_sum([3, 3, 4, 4], 6) True >>> has_pair_with_sum([-1, -2, -3, -4], -6) True >>> has_pair_with_sum([-2, 2, 0, 1], 0) True","solution":"def has_pair_with_sum(nums, target): Determines if there are two distinct elements in the list nums whose sum equals target. Parameters: nums (list of int): The list of integers to check. target (int): The target sum value. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"def min_window_with_all_unique_chars(s: str) -> str: Find the minimum window in a string which contains all the unique characters present in the string. If there is a tie, return the window which occurs first. Args: s (str): Input string containing only lowercase alphabets. Returns: str: The smallest contiguous substring that contains all characters of the input string at least once. >>> min_window_with_all_unique_chars(\\"a\\") 'a' >>> min_window_with_all_unique_chars(\\"aa\\") 'a' >>> min_window_with_all_unique_chars(\\"ab\\") 'ab' >>> min_window_with_all_unique_chars(\\"aaaabaaa\\") 'ab' >>> min_window_with_all_unique_chars(\\"dabbcab\\") 'dabbc' >>> min_window_with_all_unique_chars(\\"abcabcbb\\") 'abc' >>> min_window_with_all_unique_chars(\\"abcdefgh\\") 'abcdefgh' >>> min_window_with_all_unique_chars(\\"abcbca\\") 'abc'","solution":"def min_window_with_all_unique_chars(s): from collections import defaultdict # Get the set of all unique characters in the string unique_chars = set(s) required_len = len(unique_chars) # Dictionary to count character frequencies in the current window char_count = defaultdict(int) left = 0 unique_count = 0 min_len = float('inf') min_window = \\"\\" for right, char in enumerate(s): # Increase the character count for the character at the right pointer char_count[char] += 1 # If this character's count is exactly 1 in the window, increase the unique count if char_count[char] == 1: unique_count += 1 # When the window contains all unique characters, try to minimize it while unique_count == required_len: # Update the minimum window if the current window is smaller window_length = right - left + 1 if window_length < min_len: min_len = window_length min_window = s[left:right+1] # Try to reduce the window size from the left char_count[s[left]] -= 1 if char_count[s[left]] == 0: unique_count -= 1 left += 1 return min_window"},{"question":"import re def is_strong_password(password: str) -> bool: Returns True if the password meets all the criteria for a strong password, False otherwise. A strong password must have: - At least 8 characters - At least one lowercase letter - At least one uppercase letter - At least one digit - At least one special character from {\\"!@#%^&*()-+\\"} >>> is_strong_password('Aa1!aaaa') True >>> is_strong_password('Aa1!aaa') False >>> is_strong_password('A1!AAAAA') False >>> is_strong_password('a1!aaaaa') False >>> is_strong_password('Aa!aaaaa') False >>> is_strong_password('Aa1aaaaa') False >>> is_strong_password('') False >>> is_strong_password('aaaaaaa') False >>> is_strong_password('AAAAAAA') False >>> is_strong_password('1111111') False >>> is_strong_password('!!@@') False >>> is_strong_password('Aa1aaaaaaa') False","solution":"import re def is_strong_password(password): Returns True if the password meets all the criteria for a strong password, False otherwise. if len(password) < 8: return False if not re.search(r'[a-z]', password): return False if not re.search(r'[A-Z]', password): return False if not re.search(r'd', password): return False if not re.search(r'[!@#%^&*()-+]', password): return False return True"},{"question":"def longest_consecutive_ones(mat): Given a binary matrix \`mat\` of size \`m x n\`, find the longest sequence of consecutive ones in the matrix. A sequence of consecutive ones can be formed horizontally, vertically, or diagonally. Return the length of the longest sequence of consecutive ones in the matrix. >>> longest_consecutive_ones([]) == 0 >>> longest_consecutive_ones([[0]]) == 0 >>> longest_consecutive_ones([[1]]) == 1 >>> longest_consecutive_ones([[0, 0], [0, 0]]) == 0 >>> longest_consecutive_ones([[1, 1], [1, 1]]) == 2 >>> longest_consecutive_ones([ ... [0, 1, 1, 0], ... [1, 1, 0, 0], ... [0, 0, 1, 1], ... [0, 1, 1, 1] ... ]) == 3 >>> longest_consecutive_ones([ ... [0, 1, 1, 1, 0], ... [1, 0, 0, 0, 1], ... [0, 0, 1, 1, 1] ... ]) == 3 >>> longest_consecutive_ones([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 1], ... ]) == 3 >>> longest_consecutive_ones([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1], ... ]) == 3","solution":"def longest_consecutive_ones(mat): if not mat or not mat[0]: return 0 m = len(mat) n = len(mat[0]) max_len = 0 def check_direction(x, y, dx, dy): length = 0 while 0 <= x < m and 0 <= y < n and mat[x][y] == 1: length += 1 x += dx y += dy return length for i in range(m): for j in range(n): if mat[i][j] == 1: max_len = max(max_len, check_direction(i, j, 0, 1)) # Horizontal max_len = max(max_len, check_direction(i, j, 1, 0)) # Vertical max_len = max(max_len, check_direction(i, j, 1, 1)) # Diagonal down-right max_len = max(max_len, check_direction(i, j, -1, 1)) # Diagonal up-right return max_len"},{"question":"def rotate_back(nums: List[int], k: int) -> List[int]: Returns the original array before it was rotated k times to the right. Parameters: nums (list): Rotated array of integers. k (int): Number of rotations to the right. Returns: list: Original array before it was rotated. >>> rotate_back([4, 5, 6, 7, 0, 1, 2], 3) [0, 1, 2, 4, 5, 6, 7] >>> rotate_back([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_back([1], 5) [1] >>> rotate_back([1, 2, 3, 4, 5, 6, 7], 10) [5, 6, 7, 1, 2, 3, 4] >>> rotate_back([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5]","solution":"def rotate_back(nums, k): Returns the original array before it was rotated k times to the right. Parameters: nums (list): Rotated array of integers. k (int): Number of rotations to the right. Returns: list: Original array before it was rotated. n = len(nums) k = k % n # In case k is larger than the array length return nums[-k:] + nums[:-k]"},{"question":"from collections import deque from typing import List def findShortestSubarray(nums: List[int], k: int) -> int: Given an array of integers nums, find the shortest subarray with a sum of at least k. If there is no such subarray, return -1. >>> findShortestSubarray([1, 2, 3, 4, 5], 11) == 3 >>> findShortestSubarray([1], 1) == 1 >>> findShortestSubarray([1], 2) == -1 >>> findShortestSubarray([1, 2, 3], 10) == -1 >>> findShortestSubarray([1, 1, 1, 1, 1], 5) == 5 >>> findShortestSubarray([-1, 2, 3, -2, 4], 5) == 2 >>> findShortestSubarray([-1, -2, -3, -4], -4) == 1 >>> findShortestSubarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 55) == 10 >>> findShortestSubarray([1, 2, 3, 4], 6) == 2","solution":"from collections import deque from typing import List def findShortestSubarray(nums: List[int], k: int) -> int: Function to find the shortest subarray with a sum of at least k. If no such subarray exists, returns -1. n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] result = n + 1 deque_index = deque() for i in range(n + 1): while deque_index and prefix_sum[i] - prefix_sum[deque_index[0]] >= k: result = min(result, i - deque_index.popleft()) while deque_index and prefix_sum[i] <= prefix_sum[deque_index[-1]]: deque_index.pop() deque_index.append(i) return result if result <= n else -1"},{"question":"def largest_divisible_by_m(m: int, nums: List[str]) -> str: Returns the largest integer (as a string) that is divisible by m from the array nums. If no such number exists, returns an empty string. >>> largest_divisible_by_m(3, [\\"12\\", \\"15\\", \\"7\\", \\"9\\", \\"21\\"]) == \\"21\\" >>> largest_divisible_by_m(5, [\\"10\\", \\"25\\", \\"3\\", \\"50\\", \\"20\\"]) == \\"50\\" >>> largest_divisible_by_m(2, [\\"1\\", \\"3\\", \\"4\\", \\"6\\", \\"8\\"]) == \\"8\\" >>> largest_divisible_by_m(3, [\\"1\\", \\"2\\", \\"4\\", \\"5\\", \\"7\\"]) == \\"\\" >>> largest_divisible_by_m(3, [\\"3\\"]) == \\"3\\" >>> largest_divisible_by_m(3, [\\"2\\"]) == \\"\\"","solution":"def largest_divisible_by_m(m, nums): Returns the largest integer (as a string) that is divisible by m from the array nums. If no such number exists, returns an empty string. Args: m (int): The divisor. nums (list of str): The list of string representations of large integers. Returns: str: The largest integer divisible by m or an empty string. max_num = \\"\\" for num in nums: if int(num) % m == 0: if max_num == \\"\\" or int(num) > int(max_num): max_num = num return max_num"},{"question":"def canFormByRearranging(words, targetWord): Determines if the targetWord can be rearranged to form one of the words in the list. :param words: List of strings where each string represents a word. :param targetWord: A string representing the target word. :return: True if targetWord can be rearranged to form any word in the words list, False otherwise. >>> canFormByRearranging([\\"listen\\", \\"silent\\", \\"enlist\\"], \\"tinsel\\") True >>> canFormByRearranging([\\"hello\\", \\"world\\"], \\"house\\") False >>> canFormByRearranging([], \\"anything\\") False >>> canFormByRearranging([\\"eat\\", \\"tea\\", \\"ate\\"], \\"eat\\") True >>> canFormByRearranging([\\"tar\\"], \\"rat\\") True >>> canFormByRearranging([\\"bar\\", \\"baz\\"], \\"foo\\") False >>> canFormByRearranging([\\"target\\", \\"word\\"], \\"target\\") True >>> canFormByRearranging([\\"abcdefghij\\"] * 1000, \\"jihgfedcba\\") True >>> canFormByRearranging([\\"listen\\"], \\"list\\") False pass","solution":"def canFormByRearranging(words, targetWord): Determines if the targetWord can be rearranged to form one of the words in the list. :param words: List of strings where each string represents a word. :param targetWord: A string representing the target word. :return: True if targetWord can be rearranged to form any word in the words list, False otherwise. from collections import Counter targetWordCount = Counter(targetWord) for word in words: if Counter(word) == targetWordCount: return True return False"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the level order traversal of its nodes' values. >>> level_order_traversal(None) [] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[1], [2, 3], [4, 5, 6, 7]] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> level_order_traversal(root) [[1], [2], [3], [4]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> level_order_traversal(root) [[1], [2], [3], [4]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> level_order_traversal(root) [[1], [2, 3], [4, 5]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Returns the level order traversal of nodes' values in a binary tree. if not root: return [] queue = deque([root]) result = [] while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"def trap(height: List[int]) -> int: Compute how much water it is able to trap after raining. Parameters: height (List[int]): List representing the height of buildings. Returns: int: Total amount of trapped water. Examples: >>> trap([]) 0 >>> trap([1]) 0 >>> trap([1, 2]) 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([3, 3, 3, 3]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 1, 2]) 1 >>> trap([3, 0, 3, 0, 3]) 6 >>> trap([0, 2, 0, 2, 0, 2, 0, 2]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"def trap(height): Compute how much water it is able to trap after raining. :param height: List[int] representing the height of buildings :return: int representing the total amount of trapped water if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"class RangeProductQuery: A class to efficiently calculate the product of all elements in a given subarray. Example usage: >>> arr = [1, 2, 3, 4, 5] >>> r = RangeProductQuery(arr) >>> r.query(1, 3) 24 >>> r.query(0, 1) 2 >>> r.query(3, 4) 20 >>> arr2 = [1, -2, 0, 4, -1] >>> r2 = RangeProductQuery(arr2) >>> r2.query(1, 4) 0 >>> arr3 = [10**9, 10**9, 10**9] >>> r3 = RangeProductQuery(arr3) >>> r3.query(0, 2) 1000000000000000000000000000 def __init__(self, arr: List[int]): pass def query(self, left: int, right: int) -> int: pass","solution":"class RangeProductQuery: def __init__(self, arr): self.arr = arr self.prefix_products = self._compute_prefix_products() def _compute_prefix_products(self): prefix_products = [1] * len(self.arr) prefix_products[0] = self.arr[0] for i in range(1, len(self.arr)): prefix_products[i] = prefix_products[i - 1] * self.arr[i] return prefix_products def query(self, left, right): if left > 0: return self.prefix_products[right] // self.prefix_products[left - 1] else: return self.prefix_products[right]"},{"question":"from typing import List, Tuple def findShortestTime(flights: List[Tuple[int, int, int]], start: int, end: int) -> int: Find the shortest travel time from start to end using the provided flights. Parameters: flights (List[Tuple[int, int, int]]): List of flight routes represented as [src, dest, time]. start (int): The departure city. end (int): The arrival city. Returns: int: The shortest travel time, or -1 if there is no possible route from start to end. Examples: >>> findShortestTime([[0, 1, 10], [1, 2, 20]], 0, 3) -1 >>> findShortestTime([[0, 1, 10], [1, 2, 20]], 0, 1) 10 >>> findShortestTime([[0, 1, 10], [1, 2, 20]], 0, 2) 30 >>> findShortestTime([[0, 1, 10], [1, 2, 20], [0, 2, 30]], 0, 2) 30 >>> findShortestTime([[0, 1, 10], [1, 2, 5], [0, 2, 20]], 0, 2) 15 >>> findShortestTime([ [0, 1, 10], [1, 2, 10], [2, 3, 10], [0, 3, 40], [0, 2, 30], [1, 3, 20] ], 0, 3) 30","solution":"import heapq def findShortestTime(flights, start, end): Find the shortest travel time from start to end using the provided flights. Parameters: flights (List[List[int]]): List of flight routes represented as [src, dest, time]. start (int): The departure city. end (int): The arrival city. Returns: int: The shortest travel time, or -1 if there is no possible route from start to end. # Create a graph from the flights data graph = {} for src, dest, time in flights: if src not in graph: graph[src] = [] graph[src].append((dest, time)) # Priority queue to keep track of the shortest travel time to each city pq = [(0, start)] visited = set() while pq: curr_time, curr_city = heapq.heappop(pq) # If the current city is the destination, return the travel time if curr_city == end: return curr_time # If we have already visited this city, skip it if curr_city in visited: continue visited.add(curr_city) # Explore neighbors of the current city for neighbor, travel_time in graph.get(curr_city, []): if neighbor not in visited: heapq.heappush(pq, (curr_time + travel_time, neighbor)) # If no route from start to end, return -1 return -1"},{"question":"class Bank: A class to simulate a basic bank account system. Methods: - openAccount(int initialDeposit): Opens a new account with an initial deposit. - deposit(int accountNumber, int amount): Deposits the specified amount to the account. - withdraw(int accountNumber, int amount): Withdraws the specified amount from the account. - checkBalance(int accountNumber): Returns the current balance of the account. Examples: >>> bank = Bank() >>> account_number = bank.openAccount(100) >>> bank.checkBalance(account_number) 100 >>> bank.deposit(account_number, 50) >>> bank.checkBalance(account_number) 150 >>> bank.withdraw(account_number, 40) >>> bank.checkBalance(account_number) 110 def __init__(self): pass def openAccount(self, initialDeposit): pass def deposit(self, accountNumber, amount): pass def withdraw(self, accountNumber, amount): pass def checkBalance(self, accountNumber): pass","solution":"class Bank: def __init__(self): self.accounts = {} self.next_account_number = 1 def openAccount(self, initialDeposit): account_number = self.next_account_number self.accounts[account_number] = initialDeposit self.next_account_number += 1 return account_number def deposit(self, accountNumber, amount): if accountNumber in self.accounts: self.accounts[accountNumber] += amount def withdraw(self, accountNumber, amount): if accountNumber in self.accounts and self.accounts[accountNumber] >= amount: self.accounts[accountNumber] -= amount def checkBalance(self, accountNumber): if accountNumber in self.accounts: return self.accounts[accountNumber] return 0 # Assuming zero balance for non-existing accounts"},{"question":"def longest_palindromic_subsequence(s: str, k: int) -> int: Returns the length of the longest palindromic subsequence that can be obtained from string s after performing the operation. >>> longest_palindromic_subsequence(\\"ababb\\", 1) == 5 >>> longest_palindromic_subsequence(\\"abcde\\", 1) == 1 >>> longest_palindromic_subsequence(\\"aabbcc\\", 1) == 6 >>> longest_palindromic_subsequence(\\"racecar\\", 1) == 7 >>> longest_palindromic_subsequence(\\"aabbccc\\", 1) == 7 >>> longest_palindromic_subsequence(\\"radar\\", 1) == 5 >>> longest_palindromic_subsequence(\\"\\", 1) == 0 >>> longest_palindromic_subsequence(\\"a\\", 1) == 1 >>> longest_palindromic_subsequence(\\"abcdefg\\", 1) == 1 >>> longest_palindromic_subsequence(\\"aaaaaa\\", 1) == 6","solution":"def longest_palindromic_subsequence(s, k): Returns the length of the longest palindromic subsequence that can be obtained from string s after performing the operation. from collections import Counter # Count the frequency of each character freq = Counter(s) # Count pairs and single characters pairs = 0 single = 0 for count in freq.values(): pairs += count // 2 single += count % 2 # The length of longest palindromic subsequence # It includes all pairs (counted as twice) and at most one single character longest_length = pairs * 2 + (1 if single > 0 else 0) return longest_length"},{"question":"from typing import List, Dict def generate_followers(logs: List[str]) -> Dict[str, List[str]]: Generate the final list of followers for each user at the end of all the actions in the logs. >>> generate_followers([]) {} >>> generate_followers([\\"user1_user2 follows 1\\"]) {\\"user2\\": [\\"user1\\"]} >>> generate_followers([\\"user1_user2 follows 1\\", \\"user1_user2 unfollows 2\\"]) {\\"user2\\": []} >>> generate_followers([\\"user1_user2 follows 1\\", \\"user3_user2 follows 2\\"]) {\\"user2\\": [\\"user1\\", \\"user3\\"]} >>> generate_followers([\\"user1_user2 follows 1\\", \\"user3_user2 follows 2\\", \\"user1_user2 unfollows 3\\"]) {\\"user2\\": [\\"user3\\"]} >>> generate_followers([\\"user1_user2 follows 1\\", \\"user1_user2 follows 2\\", \\"user1_user2 unfollows 3\\", \\"user1_user2 follows 4\\"]) {\\"user2\\": [\\"user1\\"]} >>> generate_followers([\\"user1_user2 follows 1\\", \\"user3_user4 follows 2\\", \\"user2_user1 follows 3\\", \\"user1_user3 follows 4\\"]) { \\"user2\\": [\\"user1\\"], \\"user4\\": [\\"user3\\"], \\"user1\\": [\\"user2\\"], \\"user3\\": [\\"user1\\"] }","solution":"def generate_followers(logs): from collections import defaultdict followers = defaultdict(set) for log in logs: parts = log.split() ids = parts[0].split('_') id1, id2 = ids[0], ids[1] action = parts[1] if action == \\"follows\\": followers[id2].add(id1) elif action == \\"unfollows\\": followers[id2].discard(id1) # convert sets to sorted lists result = {user: sorted(list(follower_set)) for user, follower_set in followers.items()} return result"},{"question":"def magicalString(N: int) -> int: Construct a magical string and count the number of '1's in the first N numbers of the string. A magical string S consists of only '1' and '2' and follows these rules: 1. The string S is initially \\"1221121221221121122\\". 2. The number at sequence S[i] represents the frequency of '1' to be added after S[i] in the sequence. For example, S[6] = '1', so 1 '1' will be added after S[6], making the sequence S = \\"12211212211212...\\". Args: N (int): A positive integer indicating the length of the sequence to consider. Returns: int: The count of '1's in the first N numbers of the magical string S. Examples: >>> magicalString(0) 0 >>> magicalString(1) 1 >>> magicalString(2) 1 >>> magicalString(3) 1 >>> magicalString(4) 2 >>> magicalString(10) 5 >>> magicalString(20) 10","solution":"def magicalString(N): if N == 0: return 0 if N <= 3: return 1 s = [1, 2, 2] head = 2 tail = 3 num = 1 while tail < N: for _ in range(s[head]): s.append(num) tail += 1 if tail >= N: break num ^= 3 # switch between 1 and 2. 1^3=2, 2^3=1 head += 1 return s[:N].count(1)"},{"question":"def can_cross(nums: List[int]) -> bool: Determines if the frog can reach the last stone in the river. Parameters: nums (List[int]): List representing the positions of stones along a river. Returns: bool: True if frog can reach last stone, False otherwise. from solution import can_cross def test_example_case(): assert can_cross([0,1,3,5,6,8,12,17]) == True def test_single_stone(): assert can_cross([0]) == True def test_no_stones(): assert can_cross([]) == False def test_gap_too_large(): assert can_cross([0, 1, 3, 5, 10]) == False def test_direct_jumps(): assert can_cross([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == True def test_complex_case(): assert can_cross([0, 1, 3, 4, 5, 7, 9, 10, 12]) == True def test_isolated_stone(): assert can_cross([0, 2]) == False","solution":"def can_cross(nums): Determines if the frog can reach the last stone in the river. Parameters: nums (List[int]): List representing the positions of stones along a river. Returns: bool: True if frog can reach last stone, False otherwise. if not nums: return False stone_positions = {x: set() for x in nums} stone_positions[0].add(0) for stone in nums: for jump in stone_positions[stone]: for step in range(jump - 1, jump + 2): if step > 0 and (stone + step) in stone_positions: stone_positions[stone + step].add(step) return len(stone_positions[nums[-1]]) > 0"},{"question":"def integer_break(n: int) -> int: Break the integer n into the sum of at least two positive integers such that their product is maximized. Returns the maximum product possible. >>> integer_break(8) 18 >>> integer_break(10) 36 >>> integer_break(5) 6 >>> integer_break(6) 9 >>> integer_break(2) 1 >>> integer_break(3) 2 >>> integer_break(50) 86093442","solution":"def integer_break(n): Break the integer n into the sum of at least two positive integers such that their product is maximized. Returns the maximum product possible. if n <= 3: return n - 1 product = 1 while n > 4: product *= 3 n -= 3 product *= n return product"},{"question":"def search_insert(nums: List[int], target: int) -> int: Returns the index if target is found in nums, otherwise returns the index where it should be inserted to maintain the sorted order. >>> search_insert([1, 3, 5, 6], 5) == 2 >>> search_insert([1, 3, 5, 6], 2) == 1 >>> search_insert([1, 3, 5, 6], 7) == 4 >>> search_insert([1, 3, 5, 6], 0) == 0 >>> search_insert([1, 3, 5, 6], 1) == 0 >>> search_insert([1, 3, 5, 6], 6) == 3 >>> search_insert([], 5) == 0 >>> search_insert([4], 3) == 0 >>> search_insert([4], 4) == 0 >>> search_insert([4], 5) == 1","solution":"def search_insert(nums, target): Returns the index if target is found in nums, otherwise returns the index where it should be inserted. low, high = 0, len(nums) - 1 while low <= high: mid = (low + high) // 2 if nums[mid] == target: return mid elif nums[mid] < target: low = mid + 1 else: high = mid - 1 return low"},{"question":"def wordBreak(s: str, wordDict: Set[str]) -> List[str]: Given a string s and a dictionary of strings wordDict, return all possible sentences formed by concatenating words from the dictionary such that each character in the input string is used exactly once. Each word in the dictionary can be used multiple times. >>> sorted(wordBreak(\\"catsanddog\\", {\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"})) [\\"cats and dog\\", \\"cat sand dog\\"] >>> sorted(wordBreak(\\"pineapplepenapple\\", {\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"})) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] >>> wordBreak(\\"catsandog\\", {\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"}) [] >>> sorted(wordBreak(\\"aaaa\\", {\\"a\\", \\"aa\\"})) [\\"a a a a\\", \\"aa a a\\", \\"a aa a\\", \\"aa aa\\", \\"a a aa\\"] >>> sorted(wordBreak(\\"apple\\", {\\"apple\\"})) [\\"apple\\"] >>> wordBreak(\\"\\", {\\"a\\", \\"b\\"}) [\\"\\"]","solution":"def wordBreak(s, wordDict): Given a string s and a dictionary of strings wordDict, return all possible sentences by concatenating words from the dictionary such that each character in the input string is used exactly once. Each word in the dictionary can be used multiple times. def backtrack(start): if start == len(s): return [\\"\\"] if start in memo: return memo[start] results = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in wordDict: sub_sentences = backtrack(end) for sentence in sub_sentences: results.append(word + (\\"\\" if sentence == \\"\\" else \\" \\" + sentence)) memo[start] = results return results memo = {} return backtrack(0)"},{"question":"def find_triplet(arr, target): Determines if there are three distinct elements in \`arr\` that add up to exactly \`target\`. :param arr: List of non-negative integers. :param target: Target sum as an integer. :return: True if such a triplet exists, False otherwise. Examples: >>> find_triplet([1, 2, 3, 4, 5], 9) True >>> find_triplet([1, 2, 3, 4, 5], 20) False","solution":"def find_triplet(arr, target): Determines if there are three distinct elements in \`arr\` that add up to exactly \`target\`. :param arr: List of non-negative integers. :param target: Target sum as an integer. :return: True if such a triplet exists, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def smallest_subarray_with_sum(arr, x): Returns the length of the smallest subarray with sum greater than or equal to x. If no such subarray exists, returns -1. >>> smallest_subarray_with_sum([1, 1, 1, 1], 10) == -1 >>> smallest_subarray_with_sum([5, 1, 2, 3], 6) == 2 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 9) == 2 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 15) == 5 >>> smallest_subarray_with_sum([2, 1, 5, 2, 8], 7) == 1 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 11) == 3 >>> smallest_subarray_with_sum([1, 2, 3, 10], 10) == 1","solution":"def smallest_subarray_with_sum(arr, x): Returns the length of the smallest subarray with sum greater than or equal to x. If no such subarray exists, returns -1. n = len(arr) min_length = float('inf') start = 0 curr_sum = 0 for end in range(n): curr_sum += arr[end] while curr_sum >= x: min_length = min(min_length, end - start + 1) curr_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def four_sum(nums, target): Returns True if there exist four integers in \`nums\` whose sum equals \`target\`, False otherwise. >>> four_sum([1, 2, 3, 4, 5], 10) True >>> four_sum([1, 1, 1, 1], 6) False >>> four_sum([2, 1, 0, -1, -2, -1, -1], 0) True >>> four_sum([-3, -2, -1, 0, 1, 2, 3], 0) True >>> four_sum([2, 2, 2, 2, 2], 8) True >>> four_sum([1, 1, 3, 5, 3, 5], 25) False","solution":"def four_sum(nums, target): Returns True if there exist four integers in \`nums\` whose sum equals \`target\`, False otherwise. nums_sorted = sorted(nums) n = len(nums_sorted) for i in range(n - 3): for j in range(i + 1, n - 2): left, right = j + 1, n - 1 while left < right: total = nums_sorted[i] + nums_sorted[j] + nums_sorted[left] + nums_sorted[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"import random def kth_smallest_element(arr, k): Returns the k-th smallest element in the array after sorting it. If k is greater than len(arr), returns -1. >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7 >>> kth_smallest_element([7, 10, 4, 3, 20, 15], 4) == 10 >>> kth_smallest_element([1, 2, 3, 4, 5, 6], 1) == 1 >>> kth_smallest_element([1, 2, 3, 4, 5, 6], 6) == 6 >>> kth_smallest_element([5, 3, 1, 2, 4], 2) == 2 >>> kth_smallest_element([5, 3, 1, 2, 4], 5) == 5 >>> kth_smallest_element([], 1) == -1 >>> kth_smallest_element([1], 1) == 1 >>> kth_smallest_element([5, 4, 3, 2, 1], 6) == -1 >>> kth_smallest_element([5, 4, 4, 4, 3, 3, 2, 1], 3) == 3 >>> kth_smallest_element([5, 5, 5, 5, 5], 3) == 5 >>> kth_smallest_element([3, 1, 2, 3, 3], 4) == 3","solution":"import random def kth_smallest_element(arr, k): Returns the k-th smallest element in the array after sorting it. If k is greater than len(arr), returns -1. def quickselect(arr, left, right, k): if left == right: return arr[left] pivot_index = random.randint(left, right) pivot_index = partition(arr, left, right, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(arr, left, pivot_index - 1, k) else: return quickselect(arr, pivot_index + 1, right, k) def partition(arr, left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[store_index], arr[right] = arr[right], arr[store_index] return store_index if k > len(arr) or k <= 0: return -1 return quickselect(arr, 0, len(arr) - 1, k - 1)"},{"question":"def min_operations_to_alternate(s: str) -> int: Returns the minimum number of operations needed to make the string s such that no two adjacent characters are the same. Examples: >>> min_operations_to_alternate(\\"abab\\") 0 >>> min_operations_to_alternate(\\"aaaa\\") 2 >>> min_operations_to_alternate(\\"ababb\\") 1 >>> min_operations_to_alternate(\\"babaab\\") 1 from solution import min_operations_to_alternate def test_min_operations_to_alternate_no_operations_needed(): assert min_operations_to_alternate(\\"abab\\") == 0 assert min_operations_to_alternate(\\"baba\\") == 0 def test_min_operations_to_alternate_single_character(): assert min_operations_to_alternate(\\"a\\") == 0 assert min_operations_to_alternate(\\"b\\") == 0 def test_min_operations_to_alternate_operations_needed(): assert min_operations_to_alternate(\\"aaaa\\") == 2 assert min_operations_to_alternate(\\"bbbb\\") == 2 assert min_operations_to_alternate(\\"aabb\\") == 2 assert min_operations_to_alternate(\\"bbaa\\") == 2 def test_min_operations_to_alternate_mixed_patterns(): assert min_operations_to_alternate(\\"ababb\\") == 1 assert min_operations_to_alternate(\\"babab\\") == 0","solution":"def min_operations_to_alternate(s): Returns the minimum number of operations needed to make the string s such that no two adjacent characters are the same. # Initialize counters for both alternating patterns operations_1 = 0 # For pattern starting with 'a' operations_2 = 0 # For pattern starting with 'b' for i, char in enumerate(s): if i % 2 == 0: if char != 'a': operations_1 += 1 if char != 'b': operations_2 += 1 else: if char != 'b': operations_1 += 1 if char != 'a': operations_2 += 1 # Minimum of the operations needed for both patterns return min(operations_1, operations_2)"},{"question":"from typing import List def shortest_path(m: int, n: int, obstacles: List[List[int]]) -> int: Returns the length of the shortest path from (0,0) to (m-1,n-1) in a grid with obstacles represented as (xi, yi). If there is no such path, returns -1. >>> shortest_path(3, 3, []) == 4 >>> shortest_path(3, 3, [[1, 1]]) == 4 >>> shortest_path(3, 3, [[0, 1], [1, 1], [1, 0]]) == -1 >>> shortest_path(3, 3, [[2, 2]]) == -1 >>> shortest_path(1, 1, []) == 0 >>> shortest_path(5, 5, []) == 8 >>> shortest_path(5, 5, [[0, 1], [1, 1], [1, 3], [2, 3], [3, 3]]) == 8","solution":"from collections import deque def shortest_path(m, n, obstacles): Returns the length of the shortest path from (0,0) to (m-1,n-1) in a grid with obstacles represented as (xi, yi). If there is no such path, returns -1. directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] obstacle_set = set(map(tuple, obstacles)) if (0, 0) in obstacle_set or (m-1, n-1) in obstacle_set: return -1 queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (m-1, n-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and (nx, ny) not in obstacle_set: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def find_pairs_with_sum(arr, k): Returns all unique pairs of integers in the array that sum to k. Each pair and pairs themselves are sorted in ascending order. Params: arr (list of int): The list of integers. k (int): The target sum. Returns: list of tuples: A list of unique pairs that sum to k. >>> find_pairs_with_sum([1, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum([1, -1, 2, -2, 3], 1) [(-2, 3), (-1, 2)] >>> find_pairs_with_sum([1, 1, 1, 1], 2) [(1, 1)]","solution":"def find_pairs_with_sum(arr, k): Returns all unique pairs of integers in the array that sum to k. Each pair and pairs themselves are sorted in ascending order. Params: arr (list of int): The list of integers. k (int): The target sum. Returns: list of tuples: A list of unique pairs that sum to k. # Use a set to keep track of pairs to avoid duplicates seen = set() output = set() for num in arr: target = k - num if target in seen: # Add the pair in sorted order output.add(tuple(sorted((num, target)))) seen.add(num) # Convert the output set to a sorted list return sorted(output)"},{"question":"from typing import List def findWords(board: List[List[str]], words: List[str]) -> List[str]: Find all words that are present in the given m x n grid of characters. Each word must be constructed from sequentially adjacent cells (horizontally or vertically neighboring). The same letter cell may not be used more than once for constructing a word. Return all words found in the grid, without duplicates. >>> board = [[\\"o\\",\\"a\\",\\"a\\",\\"n\\"], [\\"e\\",\\"t\\",\\"a\\",\\"e\\"], [\\"i\\",\\"h\\",\\"k\\",\\"r\\"], [\\"i\\",\\"f\\",\\"l\\",\\"v\\"]] >>> words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] >>> set(findWords(board, words)) == {\\"oath\\", \\"eat\\"} True >>> board = [[\\"a\\",\\"b\\"], [\\"c\\",\\"d\\"]] >>> words = [\\"abcb\\"] >>> findWords(board, words) [] >>> board = [[\\"a\\"]] >>> words = [\\"a\\"] >>> findWords(board, words) [\\"a\\"] >>> board = [[]] >>> words = [\\"a\\"] >>> findWords(board, words) [] >>> board = [[\\"a\\",\\"b\\",\\"c\\",\\"e\\"], [\\"s\\",\\"f\\",\\"c\\",\\"s\\"], [\\"a\\",\\"d\\",\\"e\\",\\"e\\"]] >>> words = [\\"abcced\\", \\"see\\", \\"abcb\\"] >>> set(findWords(board, words)) == {\\"abcced\\", \\"see\\"} True","solution":"def findWords(board, words): def backtrack(r, c, parent): letter = board[r][c] curr_node = parent[letter] word_match = curr_node.pop('#', False) if word_match: result.add(word_match) # Mark the cell as visited board[r][c] = '#' for (dr, dc) in ((0, 1), (1, 0), (0, -1), (-1, 0)): nr, nc = r + dr, c + dc if 0 <= nr < len(board) and 0 <= nc < len(board[0]): if board[nr][nc] in curr_node: backtrack(nr, nc, curr_node) board[r][c] = letter if not curr_node: parent.pop(letter) def addWord(word): node = trie for letter in word: node = node.setdefault(letter, {}) node['#'] = word trie = {} for word in words: addWord(word) result = set() for row in range(len(board)): for col in range(len(board[0])): if board[row][col] in trie: backtrack(row, col, trie) return list(result)"},{"question":"def longest_contiguous_subarray(arr: List[int]) -> int: Given an array of integers \`arr\`, return the length of the longest contiguous subarray where the absolute difference between any two elements of the subarray is less than or equal to \`1\`. >>> longest_contiguous_subarray([1, 1, 1, 1]) == 4 >>> longest_contiguous_subarray([]) == 0 >>> longest_contiguous_subarray([5]) == 1 >>> longest_contiguous_subarray([1, 2, 1, 2, 1, 2]) == 6 >>> longest_contiguous_subarray([1, 2, 3, 4, 5, 2, 3, 4, 2, 1, 3]) == 2 # either [2, 3] or [3, 4] or [2, 1] >>> longest_contiguous_subarray([1, 3, 2, 3, 4, 1, 2, 5, 6]) == 3 # either [1, 2, 2] or [2, 3, 2]","solution":"def longest_contiguous_subarray(arr): Returns the length of the longest contiguous subarray where the absolute difference between any two elements of the subarray is less than or equal to 1. if not arr: return 0 n = len(arr) max_len = 1 start = 0 for end in range(1, n): while start <= end and (max(arr[start:end+1]) - min(arr[start:end+1]) > 1): start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"def count_important_pairs(nums: List[int]) -> int: Returns the number of important pairs in the array nums where i < j and nums[i] > 2 * nums[j]. >>> count_important_pairs([4, 1, 0]) 3 >>> count_important_pairs([1, 2, 3, 4]) 0 >>> count_important_pairs([2, 4, 3, 5, 1]) 3 >>> count_important_pairs([10]) 0 >>> count_important_pairs([10, 5]) 0 >>> count_important_pairs([10, 4]) 1 >>> count_important_pairs([]) 0 from typing import List","solution":"def count_important_pairs(nums): Returns the number of important pairs in the array nums where i < j and nums[i] > 2 * nums[j]. def merge_sort_and_count(arr, temp_arr, left, right): if left >= right: return 0 mid = (left + right) // 2 count = merge_sort_and_count(arr, temp_arr, left, mid) count += merge_sort_and_count(arr, temp_arr, mid + 1, right) count += merge_and_count(arr, temp_arr, left, mid, right) return count def merge_and_count(arr, temp_arr, left, mid, right): i = left # Initial index for left subarray j = mid + 1 # Initial index for right subarray k = left # Initial index to be sorted count = 0 # Count important pairs while i <= mid and j <= right: if arr[i] > 2 * arr[j]: count += (mid - i + 1) j += 1 else: i += 1 i = left j = mid + 1 # Merge the two subarrays into temp_arr while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return count n = len(nums) temp_arr = [0] * n return merge_sort_and_count(nums, temp_arr, 0, n - 1)"},{"question":"def max_total_profit(profits: List[int], k: int) -> int: Returns the maximum total profit by selecting at most k projects with non-overlapping indices. >>> max_total_profit([1, 2, 3, 4, 5], 3) == 12 >>> max_total_profit([1, 2, 3], 5) == 6 >>> max_total_profit([10], 1) == 10 >>> max_total_profit([1, 2, 3, 4, 5], 0) == 0 >>> max_total_profit([-1, -2, 3, 4, 5], 2) == 9 >>> max_total_profit([2, 2, 2, 2], 2) == 4","solution":"def max_total_profit(profits, k): Returns the maximum total profit by selecting at most k projects with non-overlapping indices. profits.sort(reverse=True) if k >= len(profits): return sum(profits) return sum(profits[:k])"},{"question":"from typing import List def min_elevation_difference(grid: List[List[int]]) -> int: Given a 2D grid representing elevations, finds the minimum value \`d\` such that one can travel from the top-left corner to the bottom-right corner without exceeding an elevation difference of \`d\`. :param grid: List[List[int]] - A 2D list representing the elevations at each point. :return: int - The minimum elevation difference \`d\`. >>> grid = [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ] >>> min_elevation_difference(grid) 2 >>> grid = [ ... [1, 4, 2, 1] ... ] >>> min_elevation_difference(grid) 3 >>> grid = [ ... [1], ... [4], ... [2], ... [1] ... ] >>> min_elevation_difference(grid) 3 >>> grid = [ ... [1, 9], ... [4, 9] ... ] >>> min_elevation_difference(grid) 5 >>> grid = [ ... [4, 4], ... [4, 4] ... ] >>> min_elevation_difference(grid) 0","solution":"from collections import deque def min_elevation_difference(grid): Given a 2D grid representing elevations, finds the minimum value \`d\` such that one can travel from the top-left corner to the bottom-right corner without exceeding an elevation difference of \`d\`. Uses binary search and BFS to determine the minimum \`d\`. def can_pass(grid, m, n, mid): # BFS to check if we can travel from (0, 0) to (m-1, n-1) with the given elevation difference \`mid\` directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * n for _ in range(m)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == m-1 and y == n-1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and abs(grid[nx][ny] - grid[x][y]) <= mid: visited[nx][ny] = True queue.append((nx, ny)) return False if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) low, high = 0, max(max(row) for row in grid) while low < high: mid = (low + high) // 2 if can_pass(grid, m, n, mid): high = mid else: low = mid + 1 return low"},{"question":"def minimum_possible_length(s: str) -> int: Determines the minimum possible length of the resulting string after performing all possible deletions of substrings \\"ab\\" and \\"ba\\". >>> minimum_possible_length(\\"abab\\") 0 >>> minimum_possible_length(\\"baba\\") 0 >>> minimum_possible_length(\\"aaa\\") 3 >>> minimum_possible_length(\\"bbb\\") 3 >>> minimum_possible_length(\\"aaaabbbbb\\") 1 >>> minimum_possible_length(\\"aabbab\\") 0 >>> minimum_possible_length(\\"a\\") 1 >>> minimum_possible_length(\\"b\\") 1 >>> minimum_possible_length(\\"\\") 0","solution":"def minimum_possible_length(s): Determines the minimum possible length of the resulting string after performing all possible deletions of substrings \\"ab\\" and \\"ba\\". a_count = s.count('a') b_count = s.count('b') # The remaining length is the difference in the count of 'a' and 'b' # if the counts are not equal, or 0 if they are equal return abs(a_count - b_count)"},{"question":"def findBuildingsWithOceanView(nums: List[int]) -> List[int]: Returns the indices of buildings that have an ocean view. A building has an ocean view if all buildings to its right have a smaller height. :param nums: List[int] - heights of the buildings :return: List[int] - indices of buildings that have ocean view pass # Unit Tests def test_example_case(): assert findBuildingsWithOceanView([4, 2, 3, 1]) == [0, 2, 3] def test_all_increasing(): assert findBuildingsWithOceanView([1, 2, 3, 4]) == [3] def test_all_decreasing(): assert findBuildingsWithOceanView([4, 3, 2, 1]) == [0, 1, 2, 3] def test_mixed_heights(): assert findBuildingsWithOceanView([2, 3, 1, 4]) == [3] def test_single_building(): assert findBuildingsWithOceanView([1]) == [0] def test_no_building_keeping_all_heights(): assert findBuildingsWithOceanView([]) == [] def test_equal_heights(): assert findBuildingsWithOceanView([2, 2, 2, 2]) == [3]","solution":"def findBuildingsWithOceanView(nums): Returns the indices of buildings that have an ocean view. A building has an ocean view if all buildings to its right have a smaller height. :param nums: List[int] - heights of the buildings :return: List[int] - indices of buildings that have ocean view if not nums: return [] n = len(nums) result = [] max_height_so_far = float('-inf') # Traverse from right to left to find ocean view buildings for i in range(n - 1, -1, -1): if nums[i] > max_height_so_far: result.append(i) max_height_so_far = nums[i] # The results need to be in ascending order of indices, so reverse the result return result[::-1]"},{"question":"def find_min_possible_value(nums: List[int]) -> int: Return the minimum possible value for the first element after rotations. >>> find_min_possible_value([3, 4, 5, 1, 2]) 1 >>> find_min_possible_value([1, 2, 3, 4, 5]) 1 >>> find_min_possible_value([2, 3, 4, 5, 1]) 1 >>> find_min_possible_value([5, 6, 7, 2, 3, 4]) 2 >>> find_min_possible_value([10, 9, 8, 7, 6, 5, 1]) 1 >>> find_min_possible_value([2]) 2 >>> find_min_possible_value([3, 3, 3, 3]) 3","solution":"def find_min_possible_value(nums): Returns the minimum possible value for the first element after rotations. return min(nums)"},{"question":"def assign_tasks_to_team(tasks, team_members): Assign tasks to team members based on their availability and skill level. Parameters: tasks (list of tuples): A list of tasks where each task is represented as (task_id, duration, required_skill). team_members (list of tuples): A list of team members where each member is represented as (member_id, availability_start, availability_end, skill_level). Returns: list of tuples: A list of assignments where each assignment is represented as (task_id, assigned_member_id). If no team member can be assigned to a task, the assigned_member_id is -1.","solution":"def assign_tasks_to_team(tasks, team_members): Assign tasks to team members based on their availability and skill level. Parameters: tasks (list of tuples): A list of tasks where each task is represented as (task_id, duration, required_skill). team_members (list of tuples): A list of team members where each member is represented as (member_id, availability_start, availability_end, skill_level). Returns: list of tuples: A list of assignments where each assignment is represented as (task_id, assigned_member_id). If no team member can be assigned to a task, the assigned_member_id is -1. assignments = [] for task_id, duration, required_skill in tasks: task_assigned = False for member_id, availability_start, availability_end, skill_level in team_members: if skill_level >= required_skill and availability_end - availability_start >= duration: assignments.append((task_id, member_id)) team_members = [(m_id, av_start, av_end, sk_lvl) for m_id, av_start, av_end, sk_lvl in team_members if m_id != member_id] task_assigned = True break if not task_assigned: assignments.append((task_id, -1)) return assignments"},{"question":"def tree_diameter(parents): Calculate the maximum distance between any two nodes in the tree represented by parents array. >>> tree_diameter([-1, 0, 1, 2, 3]) 4 >>> tree_diameter([-1, 0, 0, 1, 1, 2, 2]) 4 >>> tree_diameter([-1, 0, 0, 0, 0, 0]) 2 >>> tree_diameter([-1]) 0 >>> tree_diameter([-1, 0]) 1 >>> tree_diameter([-1, 0, 1, 2, 3, 4]) 5","solution":"def tree_diameter(parents): from collections import defaultdict, deque def bfs(start): Helper function to perform BFS and return the farthest node and its distance queue = deque([start]) visited = set([start]) distance = {start: 0} farthest_node = start while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) distance[neighbor] = distance[node] + 1 if distance[neighbor] > distance[farthest_node]: farthest_node = neighbor return farthest_node, distance[farthest_node] # Build the adjacency list for the tree n = len(parents) graph = defaultdict(list) for child, parent in enumerate(parents): if parent != -1: graph[parent].append(child) graph[child].append(parent) # Perform BFS from the root (node 0) to find the farthest node from it farthest_node, _ = bfs(0) # Perform BFS from the farthest node found in the previous step to find the maximum distance farthest_node, max_distance = bfs(farthest_node) return max_distance"},{"question":"def can_travel(routes: List[Tuple[str, str]], start: str, end: str) -> bool: Determines if you can travel from start city to end city using the available routes. :param routes: List[Tuple[str, str]] - List of available routes as (source, destination) pairs. :param start: str - The starting city. :param end: str - The destination city. :return: bool - True if there is a valid path from start to end, otherwise False. >>> can_travel([(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"E\\")], \\"A\\", \\"E\\") True >>> can_travel([(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\")], \\"A\\", \\"E\\") False","solution":"def can_travel(routes, start, end): Determines if you can travel from start city to end city using the available routes. :param routes: List[Tuple[str, str]] - List of available routes as (source, destination) pairs. :param start: str - The starting city. :param end: str - The destination city. :return: bool - True if there is a valid path from start to end, otherwise False. from collections import defaultdict, deque # Create a graph from the routes graph = defaultdict(list) for source, destination in routes: graph[source].append(destination) # Perform a BFS to find if there is a path from start to end queue = deque([start]) visited = set() while queue: current = queue.popleft() if current == end: return True if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return False"},{"question":"def makesquare(sticks): Determines whether we can form a square using all the given sticks. Parameters: sticks (List[int]): List of lengths of the sticks. Returns: bool: True if a square can be formed, False otherwise. >>> makesquare([1, 1, 2, 2, 2]) True >>> makesquare([3, 3, 3, 3, 4]) False >>> makesquare([1, 1, 1, 2, 2, 2]) False >>> makesquare([1]) False >>> makesquare([]) False >>> makesquare([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]) True >>> makesquare([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6]) False","solution":"def makesquare(sticks): Determines whether we can form a square using all the given sticks. Parameters: sticks (List[int]): List of lengths of the sticks. Returns: bool: True if a square can be formed, False otherwise. if not sticks: return False total_length = sum(sticks) if total_length % 4 != 0: return False side_length = total_length // 4 sticks.sort(reverse=True) sides = [0] * 4 def dfs(index): if index == len(sticks): return sides[0] == sides[1] == sides[2] == sides[3] == side_length for i in range(4): if sides[i] + sticks[index] <= side_length: sides[i] += sticks[index] if dfs(index + 1): return True sides[i] -= sticks[index] return False return dfs(0)"},{"question":"from typing import List def longest_concatenation(words: List[str]) -> str: Find the longest string s such that s is a concatenation of distinct words from words list. Each word can be used at most once. If there are multiple results, return the lexicographically smallest one. Return an empty string if there is no valid string that meets the conditions. >>> longest_concatenation(['hello']) == 'hello' >>> longest_concatenation(['a', 'bc', 'def']) == 'abcdef' >>> longest_concatenation(['cat', 'bat', 'rat']) == 'batcatrat' >>> longest_concatenation([]) == '' >>> longest_concatenation(['a', 'ab', 'abc']) == 'aababc'","solution":"def longest_concatenation(words): Returns the longest concatenation of distinct words from words list where each word can be used at most once. If there are multiple results, returns the lexicographically smallest one. from itertools import permutations longest_word = \\"\\" words_sorted = sorted(words) for i in range(1, len(words)+1): for perm in permutations(words_sorted, i): candidate = ''.join(perm) if len(candidate) > len(longest_word) or (len(candidate) == len(longest_word) and candidate < longest_word): longest_word = candidate return longest_word"},{"question":"def can_rearrange(s: str, k: int) -> bool: Determine whether it is possible to rearrange the characters in the string such that every character appears at least once every k positions. Arguments: s -- input string consisting of lowercase letters k -- integer value specifying the required distance Returns: True if such an arrangement is possible, otherwise False. Examples: >>> can_rearrange(\\"aabbcc\\", 3) True >>> can_rearrange(\\"aaabbcc\\", 2) True >>> can_rearrange(\\"aaadbbcc\\", 2) True >>> can_rearrange(\\"aabbcc\\", 4) False >>> can_rearrange(\\"aaaabc\\", 2) False >>> can_rearrange(\\"aaabc\\", 3) False >>> can_rearrange(\\"a\\", 1) True >>> can_rearrange(\\"abcdef\\", 1) True >>> can_rearrange(\\"\\", 0) True","solution":"from collections import Counter from heapq import heappush, heappop def can_rearrange(s, k): if k == 0: return True # With k = 0, we do not need any specific arrangement counter = Counter(s) max_heap = [] for char, freq in counter.items(): if freq > (len(s) + 1) // k: return False # If the frequency of a character is too high to be spaced by k positions heappush(max_heap, (-freq, char)) queue = [] while max_heap: freq, char = heappop(max_heap) freq = -freq s = s.replace(char, '', freq) if len(queue) == k: freq, char = queue.pop(0) if freq > 0: heappush(max_heap, (-freq, char)) freq -= 1 if freq > 0: queue.append((freq, char)) return not max_heap"},{"question":"def subarray_with_non_negative_sum(nums: List[int], k: int) -> bool: Determines if there exists a subarray of length at least k with a sum >= 0. :param nums: List[int] - The list of integers. :param k: int - The minimum length of the subarray. :return: bool - True if such a subarray exists, False otherwise. >>> subarray_with_non_negative_sum([1, -1, 2, -3, 4], 2) True >>> subarray_with_non_negative_sum([-1, -2, -3, -4], 2) False","solution":"def subarray_with_non_negative_sum(nums, k): Determines if there exists a subarray of length at least k with a sum >= 0. :param nums: List[int] - The list of integers. :param k: int - The minimum length of the subarray. :return: bool - True if such a subarray exists, False otherwise. n = len(nums) if n == 0 or k > n: return False # Compute the prefix sums prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1] # Find subarray of at least length k with non-negative sum for i in range(k, n + 1): for j in range(i - k, -1, -1): if prefix_sum[i] - prefix_sum[j] >= 0: return True return False"},{"question":"class ConsonantIterator: An iterator class that iterates over only the consonants in a given string. The iterator is case-insensitive and supports \`hasNext\` and \`next\` methods. Methods: 1. __init__(string s): Initializes the iterator with the given string \`s\`. 2. hasNext(): Returns True if there is another consonant in the string; otherwise, returns False. 3. next(): Returns the next consonant in the string. If there are no more consonants, throws a StopIteration exception. from typing import List def __init__(self, s: str): Accepts a string \`s\` and initializes the iterator. pass def hasNext(self) -> bool: Returns True if there is another consonant in the string; otherwise returns False. pass def next(self) -> str: Returns the next consonant in the string. If there are no more consonants, throws a StopIteration exception. pass # Unit tests import pytest def test_consonant_iterator_basic(): iterator = ConsonantIterator(\\"hello\\") assert iterator.hasNext() == True assert iterator.next() == 'h' assert iterator.hasNext() == True assert iterator.next() == 'l' assert iterator.hasNext() == True assert iterator.next() == 'l' assert iterator.hasNext() == False with pytest.raises(StopIteration): iterator.next() def test_consonant_iterator_no_consonants(): iterator = ConsonantIterator(\\"aeiou\\") assert iterator.hasNext() == False with pytest.raises(StopIteration): iterator.next() def test_consonant_iterator_mixed_case(): iterator = ConsonantIterator(\\"HeLLo\\") assert iterator.hasNext() == True assert iterator.next() == 'H' assert iterator.hasNext() == True assert iterator.next() == 'L' assert iterator.hasNext() == True assert iterator.next() == 'L' assert iterator.hasNext() == False with pytest.raises(StopIteration): iterator.next() def test_consonant_iterator_empty_string(): iterator = ConsonantIterator(\\"\\") assert iterator.hasNext() == False with pytest.raises(StopIteration): iterator.next() def test_consonant_iterator_only_consonants(): iterator = ConsonantIterator(\\"bcdfghjklmnpqrstvwxyz\\") assert iterator.hasNext() == True assert iterator.next() == 'b' assert iterator.next() == 'c' assert iterator.next() == 'd' assert iterator.next() == 'f' assert iterator.next() == 'g' assert iterator.next() == 'h' assert iterator.next() == 'j' assert iterator.next() == 'k' assert iterator.next() == 'l' assert iterator.next() == 'm' assert iterator.next() == 'n' assert iterator.next() == 'p' assert iterator.next() == 'q' assert iterator.next() == 'r' assert iterator.next() == 's' assert iterator.next() == 't' assert iterator.next() == 'v' assert iterator.next() == 'w' assert iterator.next() == 'x' assert iterator.next() == 'y' assert iterator.next() == 'z' assert iterator.hasNext() == False with pytest.raises(StopIteration): iterator.next()","solution":"class ConsonantIterator: def __init__(self, s): self.string = s self.current_index = 0 self.consonants = [] for char in self.string: if char.isalpha() and char.lower() not in 'aeiou': self.consonants.append(char) def hasNext(self): return self.current_index < len(self.consonants) def next(self): if not self.hasNext(): raise StopIteration(\\"No more consonants in the string.\\") next_consonant = self.consonants[self.current_index] self.current_index += 1 return next_consonant"},{"question":"def numIslands(grid): Returns the number of islands in the given grid. An island is defined as a group of connected '1's (land) surrounded by '0's (water). Parameters: grid (List[List[str]]): 2D grid of '1's and '0's Returns: int: Number of islands # Implementation goes here from solution import numIslands def test_num_islands_empty_grid(): assert numIslands([]) == 0 def test_num_islands_single_island(): grid = [ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '1', '1'], ['0', '0', '0', '1', '1'] ] assert numIslands(grid) == 2 def test_num_islands_all_water(): grid = [ ['0', '0', '0'], ['0', '0', '0'], ['0', '0', '0'] ] assert numIslands(grid) == 0 def test_num_islands_alternating_land_and_water(): grid = [ ['1', '0', '1', '0'], ['0', '1', '0', '1'], ['1', '0', '1', '0'], ['0', '1', '0', '1'] ] assert numIslands(grid) == 8 def test_num_islands_complex_grid(): grid = [ ['1', '1', '1', '1', '0'], ['1', '1', '0', '1', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '1'] ] assert numIslands(grid) == 2","solution":"def numIslands(grid): Returns the number of islands in the given grid. An island is defined as a group of connected '1's (land) surrounded by '0's (water). Parameters: grid (List[List[str]]): 2D grid of '1's and '0's Returns: int: Number of islands if not grid: return 0 def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' # Mark the land as visited by sinking it dfs(grid, i + 1, j) dfs(grid, i - 1, j) dfs(grid, i, j + 1) dfs(grid, i, j - 1) number_of_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': number_of_islands += 1 dfs(grid, i, j) return number_of_islands"},{"question":"def min_window(s: str, t: str) -> int: Given two strings \`s\` and \`t\`, return the length of the shortest in-between substring of \`s\` that contains all the characters of \`t\`. If there is no such substring, return \`-1\`. >>> min_window(\\"ADOBECODEBANC\\", \\"ABC\\") 4 >>> min_window(\\"a\\", \\"a\\") 1 >>> min_window(\\"a\\", \\"aa\\") -1","solution":"def min_window(s, t): Returns the length of the shortest substring of \`s\` that contains all the characters of \`t\`. If no such substring exists, returns \`-1\`. from collections import Counter if not s or not t: return -1 t_counter = Counter(t) current_counter = {} required_chars = len(t_counter) formed_chars = 0 left = 0 min_length = float(\\"inf\\") min_length_result = -1 for right, char in enumerate(s): current_counter[char] = current_counter.get(char, 0) + 1 if char in t_counter and current_counter[char] == t_counter[char]: formed_chars += 1 while left <= right and formed_chars == required_chars: if (right - left + 1) < min_length: min_length = right - left + 1 min_length_result = min_length current_counter[s[left]] -= 1 if s[left] in t_counter and current_counter[s[left]] < t_counter[s[left]]: formed_chars -= 1 left += 1 return min_length_result if min_length != float(\\"inf\\") else -1"},{"question":"def num_subarray_product_less_than_k(nums: List[int], k: int) -> int: Returns the number of contiguous subarrays where the product of all the elements in the subarray is less than k. :param nums: List[int] - list of positive integers :param k: int - the threshold product value :return: int - count of such subarrays # Unit tests def test_example_case(): assert num_subarray_product_less_than_k([10, 5, 2, 6], 100) == 8 def test_single_element_less_than_k(): assert num_subarray_product_less_than_k([5], 10) == 1 def test_single_element_greater_than_k(): assert num_subarray_product_less_than_k([10], 5) == 0 def test_all_elements_one(): assert num_subarray_product_less_than_k([1, 1, 1, 1], 2) == 10 def test_large_values(): assert num_subarray_product_less_than_k([1, 2, 3, 4], 50) == 10 def test_zeros_and_ones(): assert num_subarray_product_less_than_k([1, 2, 3, 4, 5], 1) == 0 def test_multiple_subarrays(): assert num_subarray_product_less_than_k([2, 3, 4], 10) == 4 def test_no_valid_subarrays(): assert num_subarray_product_less_than_k([6, 7, 8], 5) == 0","solution":"def num_subarray_product_less_than_k(nums, k): Returns the number of contiguous subarrays where the product of all the elements in the subarray is less than k. :param nums: List[int] - list of positive integers :param k: int - the threshold product value :return: int - count of such subarrays if k <= 1: return 0 left = 0 product = 1 count = 0 for right in range(len(nums)): product *= nums[right] while product >= k: product //= nums[left] left += 1 count += (right - left + 1) return count"},{"question":"def custom_sort_string(order: str, strs: str) -> str: Custom sorts the string \`strs\` according to the order defined in \`order\`. Characters not present in \`order\` appear at the end of \`strs\` in original relative order. Parameters: order (str): The string representing the desired order of characters. strs (str): The string to be sorted. Returns: str: The custom sorted string. >>> custom_sort_string(\\"cba\\", \\"abcd\\") \\"cbad\\" >>> custom_sort_string(\\"cba\\", \\"abcdxyz\\") \\"cbadxyz\\" >>> custom_sort_string(\\"abc\\", \\"xyz\\") \\"xyz\\" >>> custom_sort_string(\\"abc\\", \\"\\") \\"\\" >>> custom_sort_string(\\"\\", \\"abcd\\") \\"abcd\\" >>> custom_sort_string(\\"zyxwvutsrqponmlkjihgfedcba\\", \\"abcdefghijklmnopqrstuvwxyz\\") \\"zyxwvutsrqponmlkjihgfedcba\\" >>> custom_sort_string(\\"cba\\", \\"aabbcc\\") \\"ccbbaa\\"","solution":"def custom_sort_string(order, strs): Custom sorts the string \`strs\` according to the order defined in \`order\`. Characters not present in \`order\` appear at the end of \`strs\` in original relative order. Parameters: order (str): The string representing the desired order of characters. strs (str): The string to be sorted. Returns: str: The custom sorted string. order_map = {char: i for i, char in enumerate(order)} order_value = len(order_map) sorted_chars = sorted(strs, key=lambda x: (order_map.get(x, order_value), strs.index(x))) return ''.join(sorted_chars)"},{"question":"def can_convert(s: str, t: str) -> bool: Determines if string \`s\` can be converted to string \`t\` using the given operations. Parameters: s (str): The source string. t (str): The target string. Returns: bool: True if \`s\` can be converted to \`t\`, False otherwise. >>> can_convert(\\"abc\\", \\"abc\\") == True >>> can_convert(\\"aab\\", \\"bbc\\") == True >>> can_convert(\\"abc\\", \\"def\\") == True >>> can_convert(\\"ab\\", \\"cc\\") == False >>> can_convert(\\"aab\\", \\"bac\\") == False >>> can_convert(\\"abc\\", \\"abcd\\") == False","solution":"def can_convert(s, t): Determines if string \`s\` can be converted to string \`t\` using the given operations. Parameters: s (str): The source string. t (str): The target string. Returns: bool: True if \`s\` can be converted to \`t\`, False otherwise. if len(s) != len(t): return False if s == t: return True # Track character mappings from s to t s_to_t = {} t_mapped = set() for char_s, char_t in zip(s, t): if char_s in s_to_t: if s_to_t[char_s] != char_t: return False else: if char_t in t_mapped: return False s_to_t[char_s] = char_t t_mapped.add(char_t) return True"},{"question":"def find_three_sum(nums, target): Determine if there exist three integers in nums whose sum is equal to target. Return a tuple containing these three integers if such a triplet exists. If no such triplet exists, return an empty list. >>> find_three_sum([1, 2, 3, 4, 5], 9) (1, 3, 5) >>> find_three_sum([-1, 0, 1, 2, -1, -4], 0) (-1, -1, 2) >>> find_three_sum([1, 2, 3, 4, 5], 6) (1, 2, 3) >>> find_three_sum([1, 2, 3, 4, 5], 100) [] >>> find_three_sum([], 6) [] >>> find_three_sum([1, 1, 1], 10) [] >>> find_three_sum([1, 1, 2, 2, 3, 3], 6) (1, 2, 3) >>> find_three_sum([-5, 2, -1, -2, 3, 4, 0], 0) (-5, 2, 3)","solution":"def find_three_sum(nums, target): Determine if there exist three integers in nums whose sum is equal to target. Return a tuple containing these three integers if such a triplet exists. If no such triplet exists, return an empty list. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return (nums[i], nums[left], nums[right]) elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Determine if there are any three integers in nums whose sum is exactly equal to target. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([1, 2, 3, 4, 5], 12) True >>> three_sum([1, 2, 3, 4, 5], 20) False >>> three_sum([-1, -2, -3, -4, -5], -1) False >>> three_sum([0, 0, 0, 0, 0], 1) False >>> three_sum([1, 2, 3], 6) True >>> three_sum([1, 2], 3) False >>> three_sum([], 0) False >>> three_sum([-1, -2, 3, 4, 1, -2], -2) True","solution":"def three_sum(nums, target): Determine if there are any three integers in nums whose sum is exactly equal to target. :param nums: List[int] - List of distinct integers :param target: int - Target sum :return: bool - True if such a combination exists, False otherwise nums.sort() n = len(nums) for i in range(n): left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def can_see_board(heights): Given heights of students in a line, returns an array representing the number of students up to and including the ith student that can see the board. Args: heights (List[int]): An array of integers representing the heights of students. Returns: List[int]: An array where each element i represents the number of students up to and including the ith student that can see the board. >>> can_see_board([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] >>> can_see_board([5, 4, 3, 2, 1]) == [1, 1, 1, 1, 1] >>> can_see_board([1, 3, 2, 4]) == [1, 2, 2, 4] >>> can_see_board([2, 2, 2, 3, 3, 1]) == [1, 1, 1, 4, 4, 4] >>> can_see_board([5]) == [1] >>> can_see_board([]) == [] >>> can_see_board([1, 2, 3]) == [1, 2, 3] >>> can_see_board([1, 3, 2, 4, 3, 5]) == [1, 2, 2, 4, 4, 6]","solution":"def can_see_board(heights): Given heights of students in a line, returns an array representing the number of students up to and including the ith student that can see the board. Args: heights (List[int]): An array of integers representing the heights of students. Returns: List[int]: An array where each element i represents the number of students up to and including the ith student that can see the board. result = [] max_height_so_far = 0 for height in heights: if height > max_height_so_far: max_height_so_far = height result.append(max_height_so_far) return [result.index(h) + 1 for h in result] # Example usage: # heights = [1, 2, 3, 2, 1] # output: [1, 2, 3, 3, 3]"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Returns a list of all possible quadruplets [nums[i], nums[j], nums[k], nums[l]] such that: 1. i, j, k, and l are four distinct indices. 2. nums[i] + nums[j] + nums[k] + nums[l] = target. Args: nums: List of integers (unsorted). target: Target sum for the quadruplets. Returns: List of lists containing quadruplets. >>> sorted(four_sum([1, 0, -1, 0, -2, 2], 0)) == sorted([[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]) True >>> four_sum([1, 2, 3, 4], 50) [] >>> sorted(four_sum([-2, -2, 0, 0, 2, 2], 0)) == sorted([[-2, -2, 2, 2], [-2, 0, 0, 2]]) True >>> four_sum([0, 0, 0, 0], 0) [[0, 0, 0, 0]] >>> sorted(four_sum([2, 2, 2, 2, 2], 8)) == sorted([[2, 2, 2, 2]]) True","solution":"def four_sum(nums, target): Returns a list of all possible quadruplets [nums[i], nums[j], nums[k], nums[l]] such that: 1. i, j, k, and l are four distinct indices. 2. nums[i] + nums[j] + nums[k] + nums[l] = target. Args: nums: List of integers (unsorted). target: Target sum for the quadruplets. Returns: List of lists containing quadruplets. nums.sort() quadruplets = [] length = len(nums) for i in range(length-3): # Avoid duplicate if i > 0 and nums[i] == nums[i-1]: continue for j in range(i+1, length-2): # Avoid duplicate if j > i+1 and nums[j] == nums[j-1]: continue left, right = j+1, length-1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruplets.append([nums[i], nums[j], nums[left], nums[right]]) # Avoid duplicate while left < right and nums[left] == nums[left+1]: left += 1 while left < right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return quadruplets"},{"question":"def min_sessions(tasks: List[int], sessionTime: int) -> int: Organize the tasks into multiple work sessions such that the total duration of tasks in each session does not exceed sessionTime. Return the minimum number of work sessions required to complete all the tasks. >>> min_sessions([1, 2, 3], 3) 2 >>> min_sessions([3, 1, 3, 1, 1], 8) 2 >>> min_sessions([1, 2, 3, 4, 5], 15) 1 >>> min_sessions([10, 10, 10], 5) 3 >>> min_sessions([5, 5, 5], 5) 3","solution":"def min_sessions(tasks, sessionTime): def backtrack(i, current_sessions): if i == len(tasks): return len(current_sessions) min_sessions_needed = float('inf') for j in range(len(current_sessions)): if current_sessions[j] + tasks[i] <= sessionTime: current_sessions[j] += tasks[i] min_sessions_needed = min(min_sessions_needed, backtrack(i + 1, current_sessions)) current_sessions[j] -= tasks[i] current_sessions.append(tasks[i]) min_sessions_needed = min(min_sessions_needed, backtrack(i + 1, current_sessions)) current_sessions.pop() return min_sessions_needed tasks.sort(reverse=True) return backtrack(0, [])"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Given a list of integers \`nums\`, return a list containing all the integers that appear more than once in \`nums\`. Each integer in the result should appear only once. You must achieve this in O(n) time complexity, where n is the length of the input list. >>> find_duplicates([]) == [] >>> find_duplicates([1, 2, 3, 4, 5]) == [] >>> find_duplicates([2, 2, 2, 2]) == [2] >>> find_duplicates([1, 2, 3, 1, 2, 4]) == [1, 2] >>> find_duplicates(list(range(1000)) + list(range(500, 1500))) == list(range(500, 1000))","solution":"def find_duplicates(nums): Given a list of integers, return a list containing all the integers that appear more than once in the list. Each integer in the result should appear only once. Args: nums (List[int]): The input list of integers. Returns: List[int]: The list containing duplicates. count = {} result = [] for num in nums: if num in count: count[num] += 1 else: count[num] = 1 for num, cnt in count.items(): if cnt > 1: result.append(num) return result"},{"question":"from typing import List def max_length_to_share_wood(arr: List[int], k: int) -> int: Determines the maximum length of wood that can be evenly cut and distributed to all friends. :param arr: List of integers representing lengths of various pieces of wood. :param k: Integer representing the number of friends to share the wood with. :return: Maximum length of wood that can be evenly distributed. Returns 0 if not possible. pass def test_max_length_no_cut_possible(): assert max_length_to_share_wood([5, 7, 9], 30) == 0 def test_max_length_exact_length(): assert max_length_to_share_wood([5, 10, 15], 6) == 5 def test_max_length_different_lengths(): assert max_length_to_share_wood([4, 7, 8], 4) == 4 def test_max_length_large_input(): assert max_length_to_share_wood([1000000, 1000000, 1000000], 3) == 1000000 def test_max_length_small_pieces(): assert max_length_to_share_wood([1, 1, 1, 1, 1], 5) == 1","solution":"def max_length_to_share_wood(arr, k): Determines the maximum length of wood that can be evenly cut and distributed to all friends. :param arr: List of integers representing lengths of various pieces of wood. :param k: Integer representing the number of friends to share the wood with. :return: Maximum length of wood that can be evenly distributed. Returns 0 if not possible. def can_cut(length): Helper function to check if wood can be cut into pieces of 'length'. return sum(piece // length for piece in arr) >= k left, right = 1, max(arr) result = 0 while left <= right: mid = (left + right) // 2 if can_cut(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"def longest_mirror_sequence(nums): Given an integer array nums, return the length of the longest mirror sequence within the array. >>> longest_mirror_sequence([]) == 0 >>> longest_mirror_sequence([1]) == 1 >>> longest_mirror_sequence([1, 2]) == 1 >>> longest_mirror_sequence([1, 1]) == 2 >>> longest_mirror_sequence([1, 2, 3, 2, 1]) == 5 >>> longest_mirror_sequence([1, 2, 3, 4]) == 1 >>> longest_mirror_sequence([1, 3, 4, 3, 1, 2, 2]) == 5 >>> longest_mirror_sequence([1, 2, 1, 4, 1, 2, 1]) == 7","solution":"def longest_mirror_sequence(nums): Given an integer array nums, return the length of the longest mirror sequence within the array. n = len(nums) if n == 0: return 0 # Creating a table to store results of subproblems dp = [[0] * n for _ in range(n)] max_len = 1 # Every single element is a mirror sequence of length 1 for i in range(n): dp[i][i] = 1 # Build the table. Note that the lower diagonal values of the table are useless, # and not filled in the process. for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if nums[i] == nums[j] and cl == 2: dp[i][j] = 2 elif nums[i] == nums[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) max_len = max(max_len, dp[i][j]) return max_len"},{"question":"from typing import List, Tuple def shortest_path(n: int, edges: List[Tuple[int, int]], weights: List[int], queries: List[Tuple[int, int]]) -> List[int]: You are given a directed graph with \`n\` nodes and \`m\` edges, where each edge has a weight. The nodes are numbered from 1 to n. You need to find the length of the shortest path from a given source node \`s\` to a target node \`t\`. If there is no path from \`s\` to \`t\`, return -1. Note that the graph can contain negative weight edges, but will not contain negative weight cycles. The input is provided as three arrays: \`edges\`, \`weights\`, and \`queries\`. Each \`query\` in \`queries\` contains a source node and a target node where you should determine the shortest path length. Return an array \`answer\` where \`answer[i]\` is the length of the shortest path from the source to the target node for the i-th query. >>> shortest_path(4, [(1, 2), (2, 3), (3, 4), (1, 4)], [1, 2, 3, 10], [(1, 4), (1, 3)]) [6, 3] >>> shortest_path(3, [(1, 2), (2, 3)], [1, 1], [(3, 1), (1, 3)]) [-1, 2] >>> shortest_path(4, [(1, 2), (2, 3), (3, 4), (1, 3)], [1, -1, 2, 2], [(1, 4), (2, 4)]) [2, 1] >>> shortest_path(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)], [1, 1, 1, 1, 1], [(1, 5), (3, 1)]) [4, 3] >>> shortest_path(1, [], [], [(1, 1)]) [0]","solution":"import heapq def dijkstra(graph, start): # Implementation of Dijkstra's algorithm to find shortest paths from a single source n = len(graph) dist = [float('inf')] * n dist[start] = 0 pq = [(0, start)] while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > dist[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist def shortest_path(n, edges, weights, queries): # Create adjacency list for the graph graph = [[] for _ in range(n)] for (u, v), w in zip(edges, weights): graph[u-1].append((v-1, w)) answers = [] for s, t in queries: # Compute shortest paths from source s using Dijkstra's algorithm dist = dijkstra(graph, s-1) shortest_dist = dist[t-1] answers.append(shortest_dist if shortest_dist != float('inf') else -1) return answers"},{"question":"from typing import List def min_subarrays_with_sum_at_least_k(arr: List[int], k: int) -> int: You are given an array of \`n\` integers, \`arr\`, and an integer \`k\`. A **subarray** is any contiguous part of the original array. Return _the minimum number of subarrays with a sum of at least_ \`k\`. If it is not possible to find such subarrays, return \`-1\`. Note: A subarray should contain at least one element. >>> min_subarrays_with_sum_at_least_k([1, 2, 3, 4, 5], 11) == 3 >>> min_subarrays_with_sum_at_least_k([1, 2, 3, 4, 5], 15) == 5 >>> min_subarrays_with_sum_at_least_k([1, 2, 3, 4, 5], 16) == -1 >>> min_subarrays_with_sum_at_least_k([1, -1, 1, -1, 1, -1, 1, -1, 1, -1], 0) == 1 >>> min_subarrays_with_sum_at_least_k([100], 50) == 1","solution":"def min_subarrays_with_sum_at_least_k(arr, k): Returns the minimum number of subarrays with sum at least k. If it is not possible to find such subarrays, return -1. n = len(arr) min_count = float('inf') def find_min_count(start_index): current_sum = 0 for end_index in range(start_index, n): current_sum += arr[end_index] if current_sum >= k: return end_index - start_index + 1 return float('inf') for i in range(n): min_count = min(min_count, find_min_count(i)) return -1 if min_count == float('inf') else min_count"},{"question":"def partition_unique_substrings(s: str) -> (int, List[str]): Partition the string \`s\` into as few substrings as possible such that each substring contains unique characters only. Returns the number of substrings and the list of substrings. >>> partition_unique_substrings(\\"abac\\") (2, [\\"ab\\", \\"ac\\"]) >>> partition_unique_substrings(\\"aabc\\") (2, [\\"a\\", \\"abc\\"]) >>> partition_unique_substrings(\\"abcd\\") (1, [\\"abcd\\"]) from solution import partition_unique_substrings def test_partition_unique_substrings_example1(): result, substrings = partition_unique_substrings(\\"abac\\") assert result == 2 assert substrings == [\\"ab\\", \\"ac\\"] def test_partition_unique_substrings_example2(): result, substrings = partition_unique_substrings(\\"aabc\\") assert result == 2 assert substrings == [\\"a\\", \\"abc\\"] def test_partition_unique_substrings_example3(): result, substrings = partition_unique_substrings(\\"abcd\\") assert result == 1 assert substrings == [\\"abcd\\"] def test_partition_unique_substrings_single_char(): result, substrings = partition_unique_substrings(\\"a\\") assert result == 1 assert substrings == [\\"a\\"] def test_partition_unique_substrings_repeated_chars(): result, substrings = partition_unique_substrings(\\"aaaa\\") assert result == 4 assert substrings == [\\"a\\", \\"a\\", \\"a\\", \\"a\\"] def test_partition_unique_substrings_no_repeat(): result, substrings = partition_unique_substrings(\\"abcdefgh\\") assert result == 1 assert substrings == [\\"abcdefgh\\"] def test_partition_unique_substrings_mixed_case(): result, substrings = partition_unique_substrings(\\"abcabcbb\\") assert result == 4 assert substrings == [\\"abc\\", \\"abc\\", \\"b\\", \\"b\\"]","solution":"def partition_unique_substrings(s): Partition the string \`s\` into as few substrings as possible such that each substring contains unique characters only. Returns the number of substrings and the list of substrings. substrings = [] current_sub = \\"\\" seen_chars = set() for char in s: if char in seen_chars: substrings.append(current_sub) current_sub = char seen_chars = {char} else: current_sub += char seen_chars.add(char) if current_sub: substrings.append(current_sub) return len(substrings), substrings"},{"question":"def reverse_chunks(s: str) -> str: You are given a string \`s\` representing an alphanumeric sequence consisting of digits and lowercase English letters. Split the string into chunks of consecutive digits and chunks of consecutive letters. Then, reverse the order of the digits and letters respectively to form a new string. For example: >>> reverse_chunks(\\"abc123def456\\") \\"cba321fed654\\" >>> reverse_chunks(\\"abcdef\\") \\"fedcba\\" >>> reverse_chunks(\\"123456\\") \\"654321\\" >>> reverse_chunks(\\"a1b2c3\\") \\"a1b2c3\\" >>> reverse_chunks(\\"ab12cd34\\") \\"ba21dc43\\" >>> reverse_chunks(\\"\\") \\"\\" >>> reverse_chunks(\\"a\\") \\"a\\" >>> reverse_chunks(\\"1\\") \\"1\\" >>> reverse_chunks(\\"abcd123\\") \\"dcba321\\" >>> reverse_chunks(\\"123abcd\\") \\"321dcba\\" pass","solution":"import re def reverse_chunks(s): Returns a string where chunks of consecutive letters and digits are reversed. # Use regular expression to split the string into chunks of digits and letters chunks = re.findall(r'd+|D+', s) # Reverse each chunk reversed_chunks = [chunk[::-1] for chunk in chunks] # Join the reversed chunks to get the final string result = ''.join(reversed_chunks) return result"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Given a string \`s\` containing only lowercase English letters, return the length of the longest palindromic subsequence in \`s\`. Args: s (str): The input string Returns: int: The length of the longest palindromic subsequence Examples: >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"ab\\") 1 >>> longest_palindromic_subsequence(\\"aa\\") 2 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"abcdef\\") 1 >>> longest_palindromic_subsequence(\\"babadab\\") 5","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in the string s. n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = 2 + dp[i + 1][j - 1] if i + 1 <= j - 1 else 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n-1]"},{"question":"from collections import deque def min_steps_to_reach_dest(maze, start, end): Returns the minimum number of steps required to reach the destination from the start position in a given maze. If the destination is not reachable, returns -1. >>> maze1 = [ ... ['.', '#', '.'], ... ['.', '.', '.'], ... ['#', '#', '.'] ... ] >>> start1 = [0, 0] >>> end1 = [2, 2] >>> min_steps_to_reach_dest(maze1, start1, end1) 4 >>> maze2 = [ ... ['.', '#', '.'], ... ['#', '.', '#'], ... ['#', '#', '.'] ... ] >>> start2 = [0, 0] >>> end2 = [2, 2] >>> min_steps_to_reach_dest(maze2, start2, end2) -1 >>> maze3 = [ ... ['#', '#', '.'], ... ['.', '.', '.'], ... ['#', '#', '.'] ... ] >>> start3 = [0, 0] >>> end3 = [2, 2] >>> min_steps_to_reach_dest(maze3, start3, end3) -1 >>> maze4 = [ ... ['.', '#', '.'], ... ['.', '.', '.'], ... ['#', '#', '#'] ... ] >>> start4 = [0, 0] >>> end4 = [2, 2] >>> min_steps_to_reach_dest(maze4, start4, end4) -1 >>> maze5 = [ ... ['.', '#', '.'], ... ['.', '.', '.'], ... ['#', '#', '.'] ... ] >>> start5 = [1, 1] >>> end5 = [1, 1] >>> min_steps_to_reach_dest(maze5, start5, end5) 0","solution":"from collections import deque def min_steps_to_reach_dest(maze, start, end): Returns the minimum number of steps required to reach the destination from the start position in a given maze. If the destination is not reachable, returns -1. m, n = len(maze), len(maze[0]) startRow, startCol = start endRow, endCol = end if maze[startRow][startCol] == '#' or maze[endRow][endCol] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(startRow, startCol, 0)]) visited = set((startRow, startCol)) while queue: row, col, steps = queue.popleft() if (row, col) == (endRow, endCol): return steps for dr, dc in directions: newRow, newCol = row + dr, col + dc if 0 <= newRow < m and 0 <= newCol < n and maze[newRow][newCol] == '.' and (newRow, newCol) not in visited: visited.add((newRow, newCol)) queue.append((newRow, newCol, steps + 1)) return -1"},{"question":"def trap(height: List[int]) -> int: Calculate the total volume of water that can be trapped between buildings. Args: height (List[int]): A list of integers representing the height of the buildings. Returns: int: Total volume of water that can be trapped. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([]) 0 >>> trap([1,2,3,4,5]) 0 >>> trap([4,2,0,3,2,5]) 9 >>> trap([3,0,2,0,4]) 7 >>> trap([4]) 0 >>> trap([2,2]) 0 >>> trap([1,2,3,4,3,2,1]) 0 >>> trap([4,3,2,1,2,3,4]) 9","solution":"def trap(height): Calculate the total volume of water that can be trapped between buildings. Args: height (List[int]): A list of integers representing the height of the buildings. Returns: int: Total volume of water that can be trapped. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"def mostCommonElement(arr): Write a function \`mostCommonElement(arr)\` that takes a list of integers \`arr\` as input and returns the most common element in the list. If there are multiple elements with the same highest frequency, return the smallest one among them. >>> mostCommonElement([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) # returns 4 >>> mostCommonElement([1, 2, 2, 3, 3, 4, 4]) # returns 2 >>> mostCommonElement([1, 2, 3, 4, 5]) # returns 1 >>> mostCommonElement([2, 3, 2, 3, 4, 4]) # returns 2 >>> mostCommonElement([]) # returns None","solution":"def mostCommonElement(arr): Returns the most common element in the list. If there are multiple elements with the same highest frequency, returns the smallest one among them. from collections import Counter if not arr: return None count = Counter(arr) max_frequency = max(count.values()) most_common_elements = [key for key, value in count.items() if value == max_frequency] return min(most_common_elements)"},{"question":"def find_indices_with_sum(arr, x): Determines if there exist three distinct indices i, j, k in the array such that arr[i] + arr[j] + arr[k] = x. Return True if such indices exist, otherwise, return False. >>> find_indices_with_sum([1, 2, 3, 4, 5], 9) True >>> find_indices_with_sum([1, 2, 3, 4, 5], 50) False >>> find_indices_with_sum([2, 2, 2], 6) True >>> find_indices_with_sum([1, -2, 1, 0, 5], 0) True >>> find_indices_with_sum([5], 5) False >>> find_indices_with_sum([1, 2], 3) False >>> find_indices_with_sum([], 0) False","solution":"def find_indices_with_sum(arr, x): Returns True if there exist three distinct indices i, j, k in the array such that arr[i] + arr[j] + arr[k] = x. Otherwise, returns False. n = len(arr) if n < 3: return False arr.sort() for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == x: return True elif current_sum < x: left += 1 else: right -= 1 return False"},{"question":"def max_unique_substring(s: str, k: int) -> int: Returns the starting index of the k-length substring in s with the maximum number of unique characters. If multiple such substrings exist, returns the smallest starting index. >>> max_unique_substring(\\"abcabc\\", 3) 0 >>> max_unique_substring(\\"aaaa\\", 2) 0 >>> max_unique_substring(\\"abcd\\", 1) 0 >>> max_unique_substring(\\"abcde\\", 5) 0 >>> max_unique_substring(\\"abc\\", 5) -1 >>> max_unique_substring(\\"abc\\", 0) -1 >>> max_unique_substring(\\"abacddcbab\\", 4) 1 >>> max_unique_substring(\\"abcdeabcdeabcd\\", 5) 0","solution":"def max_unique_substring(s, k): Returns the starting index of the k-length substring in s with the maximum number of unique characters. If multiple such substrings exist, returns the smallest starting index. if k == 0 or k > len(s): return -1 max_unique_count = 0 max_unique_index = 0 current_unique_count = 0 count = {} for i in range(k): if s[i] not in count: count[s[i]] = 0 count[s[i]] += 1 if count[s[i]] == 1: current_unique_count += 1 max_unique_count = current_unique_count for i in range(k, len(s)): left_char = s[i - k] right_char = s[i] count[left_char] -= 1 if count[left_char] == 0: current_unique_count -= 1 if right_char not in count: count[right_char] = 0 count[right_char] += 1 if count[right_char] == 1: current_unique_count += 1 if current_unique_count > max_unique_count: max_unique_count = current_unique_count max_unique_index = i - k + 1 return max_unique_index"},{"question":"def can_sort_by_swaps(height: List[int], swaps: List[Tuple[int, int]]) -> bool: Determines if the array can be sorted using the allowed swaps. :param height: List[int] - list of heights :param swaps: List[Tuple[int, int]] - list of index pairs that can be swapped :return: bool - True if the array can be sorted using allowed swaps, otherwise False >>> can_sort_by_swaps([4, 3, 2, 1], [(0, 1), (1, 2), (2, 3)]) True >>> can_sort_by_swaps([1, 3, 2, 4], [(1, 2)]) True >>> can_sort_by_swaps([1, 2, 3, 4], []) True >>> can_sort_by_swaps([4, 3, 2, 1], [(0, 1), (2, 3)]) False >>> can_sort_by_swaps([1, 5, 3, 4, 2], [(0, 1), (1, 2), (3, 4)]) False","solution":"def can_sort_by_swaps(height, swaps): Determines if the array can be sorted using the allowed swaps. :param height: List[int] - list of heights :param swaps: List[Tuple[int, int]] - list of index pairs that can be swapped :return: bool - True if the array can be sorted using allowed swaps, otherwise False n = len(height) # Create an adjacency list for the swaps to represent the graph graph = {i: [] for i in range(n)} for i, j in swaps: graph[i].append(j) graph[j].append(i) def dfs(node, visited, group): stack = [node] while stack: cur = stack.pop() if cur not in visited: visited.add(cur) group.append(cur) for neighbor in graph[cur]: if neighbor not in visited: stack.append(neighbor) visited = set() for i in range(n): if i not in visited: group = [] dfs(i, visited, group) group_heights = sorted(height[j] for j in group) group_indices = sorted(group) for idx, value in zip(group_indices, group_heights): height[idx] = value return height == sorted(height)"},{"question":"def count_rectangles(grid: List[List[int]]) -> int: Count the number of distinct rectangles that can be formed using only fertile cells. Parameters: grid - list of list of int: The n x m grid representing the farm Returns: int - Number of distinct rectangles that can be formed using only fertile cells >>> count_rectangles([[1]]) 1 >>> count_rectangles([[0]]) 0 >>> count_rectangles([[1, 1], [1, 1]]) 9 >>> count_rectangles([[1, 0, 1], [1, 1, 0], [0, 1, 1]]) 10 >>> count_rectangles([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 36 >>> count_rectangles([[0, 1, 0, 1], [1, 0, 1, 0], [1, 1, 1, 1]]) 16 >>> count_rectangles([]) 0 >>> count_rectangles([[0, 0], [0, 0]]) 0","solution":"def count_rectangles(grid): Function to count the number of distinct rectangles that can be formed using only fertile cells. Parameters: grid - list of list of int: The n x m grid representing the farm Returns: int - Number of distinct rectangles that can be formed using only fertile cells if not grid: return 0 n, m = len(grid), len(grid[0]) count = 0 for top in range(n): for bottom in range(top, n): consecutive_ones = 0 for col in range(m): if all(grid[row][col] == 1 for row in range(top, bottom + 1)): consecutive_ones += 1 count += consecutive_ones else: consecutive_ones = 0 return count"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: Optional[TreeNode]) -> List[int]: Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom when looking at the tree from the right side. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> right_side_view(root) [1, 3, 4] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> right_side_view(root) [1, 2, 3] >>> right_side_view(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Given the root of a binary tree, return the values of the nodes you can see ordered from top to bottom when looking at the tree from the right side. if not root: return [] view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: # last node in the current level view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return view"},{"question":"from typing import List def word_transformation_length(start: str, end: str, word_list: List[str]) -> int: Returns the minimum number of transformations needed to convert start to end, where each transformation changes exactly one character at a time and each intermediate word must exist in word_list. >>> word_transformation_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_transformation_length(\\"hit\\", \\"hot\\", []) -1 >>> word_transformation_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) -1 >>> word_transformation_length(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) 2 >>> word_transformation_length(\\"abc\\", \\"def\\", []) -1 >>> word_transformation_length(\\"start\\", \\"end\\", [\\"stert\\", \\"stop\\", \\"stirp\\", \\"sand\\", \\"enld\\", \\"endl\\", \\"end\\"]) -1 >>> word_transformation_length(\\"a\\", \\"b\\", [\\"a\\", \\"b\\"]) 2","solution":"from collections import deque def word_transformation_length(start, end, word_list): Returns the minimum number of transformations needed to convert start to end, where each transformation changes exactly one character at a time and each intermediate word must exist in word_list. if end not in word_list: return -1 word_list = set(word_list) queue = deque([(start, 1)]) while queue: current_word, level = queue.popleft() if current_word == end: return level for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': intermediate_word = current_word[:i] + c + current_word[i+1:] if intermediate_word in word_list: queue.append((intermediate_word, level + 1)) word_list.remove(intermediate_word) # mark as visited return -1"},{"question":"def min_characters_to_form(words: List[str], target: str) -> int: Find the index of the string in 'words' which can be formed by removing the fewest number of characters from 'target'. If there is a tie, return the smallest index. If no such string exists, return -1. >>> min_characters_to_form([\\"a\\", \\"ab\\", \\"abc\\"], \\"abcd\\") == 2 >>> min_characters_to_form([\\"a\\", \\"ab\\", \\"ac\\"], \\"abc\\") == 1 >>> min_characters_to_form([\\"xyz\\", \\"pqr\\", \\"mno\\"], \\"abc\\") == -1 >>> min_characters_to_form([\\"a\\"], \\"\\") == -1 >>> min_characters_to_form([], \\"a\\") == -1 >>> min_characters_to_form([\\"abcd\\", \\"bc\\", \\"d\\"], \\"abcd\\") == 0 >>> min_characters_to_form([\\"abc\\", \\"adc\\", \\"bcd\\"], \\"abcd\\") == 0","solution":"def min_characters_to_form(words, target): def can_form_with_fewest_removals(word, target): it = iter(target) return all(char in it for char in word) best_index = -1 min_removals = float('inf') for i, word in enumerate(words): if can_form_with_fewest_removals(word, target): current_removals = len(target) - len(word) if current_removals < min_removals: min_removals = current_removals best_index = i return best_index"},{"question":"def longest_subsequence_length(arr): Returns the length of the longest subsequence that can be removed such that the remaining array has at least one increasing or one decreasing sequence of length at least 3. >>> longest_subsequence_length([1, 2, 3, 4, 5]) == 2 >>> longest_subsequence_length([5, 4, 3, 2, 1]) == 2 >>> longest_subsequence_length([1, 3, 5, 4, 2]) == 2 >>> longest_subsequence_length([1, 5, 2, 6, 3, 7]) == 3 >>> longest_subsequence_length([1, 2]) == 0 >>> longest_subsequence_length([3, 2, 1]) == 0 >>> longest_subsequence_length([2, 2, 2, 2, 2]) == 0 >>> longest_subsequence_length([1, 4, 2, 5, 3, 6]) == 3 >>> longest_subsequence_length([1, 8, 2, 9, 3, 6, 4, 5, 7]) == 6 >>> longest_subsequence_length([3]) == 0 >>> longest_subsequence_length([1, 2]) == 0","solution":"def longest_subsequence_length(arr): Returns the length of the longest subsequence that can be removed such that the remaining array has at least one increasing or one decreasing sequence of length at least 3. :param arr: List[int] - the input array of integers. :return: int - the length of the longest subsequence that can be removed. n = len(arr) if n < 3: return 0 def longest_increasing_subseq_length(arr): if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def longest_decreasing_subseq_length(arr): if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] < arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) longest_inc = longest_increasing_subseq_length(arr) longest_dec = longest_decreasing_subseq_length(arr) if longest_inc < 3 and longest_dec < 3: return 0 return n - 3"},{"question":"def count_greater_elements(nums): Given a 0-indexed integer array nums, return an array of the same length where each element at index i represents the number of elements in the array that are greater than nums[i]. >>> count_greater_elements([5]) == [0] >>> count_greater_elements([3, 3, 3]) == [0, 0, 0] >>> count_greater_elements([1, 2, 3]) == [2, 1, 0] >>> count_greater_elements([3, 2, 1]) == [0, 1, 2] >>> count_greater_elements([1, 3, 2, 4]) == [3, 1, 2, 0] >>> count_greater_elements([-1, -2, -3, 0]) == [1, 2, 3, 0] >>> count_greater_elements([1, 2, 2, 3]) == [3, 1, 1, 0]","solution":"def count_greater_elements(nums): Returns an array where each element at index i represents the number of elements in the array that are greater than nums[i]. result = [] for i in range(len(nums)): count = sum(1 for j in range(len(nums)) if nums[j] > nums[i]) result.append(count) return result"},{"question":"def check_distance(s: str, distance: int) -> bool: Determine if for each pair of equal letters in the string s, there are exactly 'distance' characters between them. >>> check_distance('abca', 2) True >>> check_distance('abcda', 3) True >>> check_distance('abca', 1) False >>> check_distance('abcd', 1) True >>> check_distance('', 2) True","solution":"def check_distance(s, distance): Returns True if for each pair of equal letters in the string s, there are exactly 'distance' characters between them. char_position = {} for i, c in enumerate(s): if c in char_position: if i - char_position[c] - 1 != distance: return False char_position[c] = i return True"},{"question":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length k in the list nums. :param nums: List[int] - The list of integers :param k: int - The length of the subarray :return: int - The maximum sum of a subarray of length k >>> max_sum_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 24 >>> max_sum_subarray([5], 1) 5 >>> max_sum_subarray([1, 2, 3, 4], 4) 10 >>> max_sum_subarray([1, 2], 3) 0 >>> max_sum_subarray([1, -2, 3, -1, 5, -7, 2], 2) 4 >>> max_sum_subarray([], 1) 0 >>> max_sum_subarray([1, 2, 3], 0) 0","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of length k in the list nums. :param nums: List[int] - The list of integers :param k: int - The length of the subarray :return: int - The maximum sum of a subarray of length k if not nums or k <= 0 or k > len(nums): return 0 current_sum = sum(nums[:k]) max_sum = current_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_buffer_block_duration(segments, k): Returns the maximum duration of a buffer block that can be created by merging at most \`k\` consecutive segments. Parameters: segments (List[int]): A list of integers where each element represents the length of a segment in seconds. k (int): The maximum number of segments that can be merged. Returns: int: The maximum duration of a buffer block that can be created. >>> max_buffer_block_duration([10, 20, 30, 40, 50], 2) 90 >>> max_buffer_block_duration([10, 20, 30], 3) 60 >>> max_buffer_block_duration([10, 20, 30], 1) 30 >>> max_buffer_block_duration([1, 2, 3, 4, 5], 2) 9 >>> max_buffer_block_duration([], 3) 0 >>> max_buffer_block_duration([15, 25, 35, 45], 0) 0 >>> max_buffer_block_duration([7], 2) 7 >>> max_buffer_block_duration([7, 7], 2) 14","solution":"def max_buffer_block_duration(segments, k): Returns the maximum duration of a buffer block that can be created by merging at most \`k\` consecutive segments. Parameters: segments (List[int]): A list of integers where each element represents the length of a segment in seconds. k (int): The maximum number of segments that can be merged. Returns: int: The maximum duration of a buffer block that can be created. if not segments or k <= 0: return 0 max_duration = 0 current_duration = 0 for i in range(len(segments)): current_duration = 0 for j in range(i, min(i + k, len(segments))): current_duration += segments[j] max_duration = max(max_duration, current_duration) return max_duration"},{"question":"def minSubstrings(s: str) -> int: Returns the minimum number of substrings in s such that each substring is either \\"0\\" or \\"1\\". >>> minSubstrings(\\"000\\") == 1 >>> minSubstrings(\\"11111\\") == 1 >>> minSubstrings(\\"010101\\") == 6 >>> minSubstrings(\\"101010\\") == 6 >>> minSubstrings(\\"00110011\\") == 4 >>> minSubstrings(\\"11001100\\") == 4 >>> minSubstrings(\\"0\\") == 1 >>> minSubstrings(\\"1\\") == 1 >>> minSubstrings(\\"\\") == 0","solution":"def minSubstrings(s): Returns the minimum number of substrings in s such that each substring is either \\"0\\" or \\"1\\". if not s: return 0 count = 1 for i in range(1, len(s)): if s[i] != s[i-1]: count += 1 return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root: TreeNode) -> int: Determines the depth of the shallowest leaf node in a full binary tree. :param root: TreeNode, the root of a binary tree :return: int, the depth of the shallowest leaf node >>> root = TreeNode(1) >>> minDepth(root) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> minDepth(root) 2 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> minDepth(root) 2 >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4, TreeNode(8), TreeNode(9)), TreeNode(5)), ... TreeNode(3, TreeNode(6), TreeNode(7)) ... ) >>> minDepth(root) 3 >>> minDepth(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepth(root): Determines the depth of the shallowest leaf node in a full binary tree. :param root: TreeNode, the root of a binary tree :return: int, the depth of the shallowest leaf node if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() # Check if it is a leaf node if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return 0"},{"question":"def max_k_subset_sum(arr: List[int], k: int) -> int: Find the k-subset with the maximum sum and return the sum of that k-subset. >>> max_k_subset_sum([1, 2, 3, 4, 5], 3) 12 >>> max_k_subset_sum([-10, -20, -30, -40, -50], 2) -30 >>> max_k_subset_sum([5, 5, 5, 5, 5], 3) 15 >>> max_k_subset_sum([1, 2, 3], 3) 6 >>> max_k_subset_sum([-1, -2, -3], 1) -1 >>> max_k_subset_sum([0, 0, 0], 2) 0 >>> max_k_subset_sum([10**6, 10**6, 10**6], 2) 2000000 >>> max_k_subset_sum([-10**6, 10**6, -10**6, 10**6], 2) 2000000 >>> max_k_subset_sum([1, 2, 3], 4) ValueError: k cannot be greater than the length of the array >>> max_k_subset_sum([1, 2, 3], 0) 0 >>> max_k_subset_sum([1, -2, 3, -4, 5], 3) 9","solution":"def max_k_subset_sum(arr, k): Find the k-subset with the maximum sum and return the sum of that k-subset. if k > len(arr): raise ValueError(\\"k cannot be greater than the length of the array\\") # Sort the array in descending order sorted_arr = sorted(arr, reverse=True) # Take the first k elements to form the k-subset with maximum sum max_k_subset = sorted_arr[:k] # Return the sum of the k-subset return sum(max_k_subset)"},{"question":"def lexicographically_smallest_subsequence(nums: List[int], k: int) -> List[int]: Given an integer array nums and an integer k, construct the lexicographically smallest subsequence of length k from the given array. A subsequence is derived by deleting some or none of the elements from the array without changing the order of the remaining elements. >>> lexicographically_smallest_subsequence([3, 5, 2, 6], 2) [2, 6] >>> lexicographically_smallest_subsequence([2, 4, 3, 3, 5, 4, 9, 6], 4) [2, 3, 3, 4] >>> lexicographically_smallest_subsequence([1, 2, 3], 1) [1] >>> lexicographically_smallest_subsequence([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> lexicographically_smallest_subsequence([1, 3, 2], 2) [1, 2] >>> lexicographically_smallest_subsequence([5, 4, 3, 2, 1], 3) [3, 2, 1] pass from typing import List # Here are the unit tests def test_simple_case(): assert lexicographically_smallest_subsequence([3, 5, 2, 6], 2) == [2, 6] def test_case_with_repeated_elements(): assert lexicographically_smallest_subsequence([2, 4, 3, 3, 5, 4, 9, 6], 4) == [2, 3, 3, 4] def test_case_with_single_element(): assert lexicographically_smallest_subsequence([1, 2, 3], 1) == [1] def test_case_with_all_elements_needed(): assert lexicographically_smallest_subsequence([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] def test_case_with_no_removal_needed(): assert lexicographically_smallest_subsequence([1, 3, 2], 2) == [1, 2] def test_case_with_descending_order(): assert lexicographically_smallest_subsequence([5, 4, 3, 2, 1], 3) == [3, 2, 1]","solution":"def lexicographically_smallest_subsequence(nums, k): Returns the lexicographically smallest subsequence of length k from the given array nums. stack = [] to_remove = len(nums) - k for num in nums: while stack and stack[-1] > num and to_remove > 0: stack.pop() to_remove -= 1 stack.append(num) # We need a subsequence of length k return stack[:k]"},{"question":"def can_form_palindrome(s: str, k: int) -> bool: Determines if it is possible to form a palindrome by reordering at most k characters in the string s. >>> can_form_palindrome(\\"aab\\", 0) == True >>> can_form_palindrome(\\"racecar\\", 0) == True >>> can_form_palindrome(\\"civic\\", 0) == True >>> can_form_palindrome(\\"aabb\\", 1) == True >>> can_form_palindrome(\\"abc\\", 2) == True >>> can_form_palindrome(\\"abcd\\", 1) == False >>> can_form_palindrome(\\"abcde\\", 0) == False >>> can_form_palindrome(\\"\\", 0) == True >>> can_form_palindrome(\\"a\\", 0) == True >>> can_form_palindrome(\\"aa\\", 0) == True","solution":"def can_form_palindrome(s, k): Determines if it is possible to form a palindrome by reordering at most k characters in the string s. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in freq.values() if count % 2 != 0) # To form a palindrome, we need at most one odd frequency character in the string # Every odd frequency character can be paired with some character by reordering return odd_count - 1 <= k"},{"question":"class MinStack: Design a class to implement a stack that supports retrieving the minimum element in constant time. >>> stack = MinStack() >>> stack.push(3) >>> stack.push(5) >>> stack.top() 5 >>> stack.getMin() 3 >>> stack.push(2) >>> stack.push(1) >>> stack.top() 1 >>> stack.getMin() 1 >>> stack.pop() >>> stack.top() 2 >>> stack.getMin() 2 >>> stack.pop() >>> stack.top() 5 >>> stack.getMin() 3 >>> stack.pop() >>> stack.top() 3 >>> stack.getMin() 3 >>> stack.pop() >>> stack.top() None >>> stack.getMin() None def __init__(self): pass def push(self, val: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def getMin(self) -> int: pass","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: popped = self.stack.pop() if popped == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def getMin(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"from typing import List def partition_labels(s: str) -> List[int]: Given a string s, partition the string into as many parts as possible such that each letter appears in at most one part. Return a list of integers representing the size of these parts. >>> partition_labels(\\"ababcbacadefegdehijhklij\\") [9, 7, 8] >>> partition_labels(\\"a\\") [1] >>> partition_labels(\\"aaaaaaa\\") [7] >>> partition_labels(\\"abcdefg\\") [1, 1, 1, 1, 1, 1, 1] >>> partition_labels(\\"abac\\") [3, 1] >>> partition_labels(\\"abcab\\") [5]","solution":"def partition_labels(s: str): last_occurrence = {ch: i for i, ch in enumerate(s)} partitions = [] start = end = 0 for i, ch in enumerate(s): end = max(end, last_occurrence[ch]) if i == end: partitions.append(i - start + 1) start = i + 1 return partitions"},{"question":"def min_max_task_duration(tasks: List[int]) -> int: Distribute tasks among two workers such that the maximum time any worker spends on tasks is minimized. Return the minimum possible value of the maximum task duration assigned to a single worker. >>> min_max_task_duration([3, 2, 3]) 5 >>> min_max_task_duration([7, 2, 5, 10, 8]) 18","solution":"def min_max_task_duration(tasks): Returns the minimum possible value of the maximum task duration assigned to a single worker. def can_distribute(mid): total = 0 workers = 1 for task in tasks: total += task if total > mid: workers += 1 total = task return workers <= 2 left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_distribute(mid): right = mid else: left = mid + 1 return left"},{"question":"def shortest_substring_length(s: str, c: str) -> int: Returns the length of the shortest substring starting and ending with character c. If there is no such substring, returns 0. Example: >>> shortest_substring_length(\\"abcdefgh\\", \\"x\\") 0 >>> shortest_substring_length(\\"abcdefgh\\", \\"a\\") 0 >>> shortest_substring_length(\\"abcbde\\", \\"b\\") 3 >>> shortest_substring_length(\\"abcdefa\\", \\"a\\") 7 >>> shortest_substring_length(\\"bccdef\\", \\"c\\") 2","solution":"def shortest_substring_length(s: str, c: str) -> int: Returns the length of the shortest substring starting and ending with character c. If there is no such substring, returns 0. positions = [i for i, char in enumerate(s) if char == c] if len(positions) < 2: return 0 min_length = float('inf') for i in range(len(positions) - 1): min_length = min(min_length, positions[i+1] - positions[i] + 1) return min_length"}]`),F={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const s=this.searchQuery.trim().toLowerCase();return s?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(s)||e.solution&&e.solution.toLowerCase().includes(s)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(s=>setTimeout(s,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},C={class:"card-container"},I={key:0,class:"empty-state"},z=["disabled"],D={key:0},P={key:1};function B(s,e,u,h,i,a){const c=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",C,[(r(!0),n(x,null,y(a.displayedPoems,(o,f)=>(r(),w(c,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",I,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(r(),n("span",P,"Loading...")):(r(),n("span",D,"See more"))],8,z)):l("",!0)])}const E=_(F,[["render",B],["__scopeId","data-v-70aabc59"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/25.md","filePath":"library/25.md"}'),M={name:"library/25.md"},W=Object.assign(M,{setup(s){return(e,u)=>(r(),n("div",null,[v(E)]))}});export{O as __pageData,W as default};
