import{_ as m,o as s,c as r,a as t,m as _,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},N={class:"review-title"},L={class:"review-content"};function S(n,e,u,c,i,a){return s(),r("div",k,[t("div",T,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),_(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),_(d(u.poem.solution),1)])])])}const R=m(q,[["render",S],["__scopeId","data-v-95aba117"]]),A=JSON.parse(`[{"question":"def is_valid_pyramid(n, words): Determines whether the series of words forms a valid pyramid. >>> is_valid_pyramid(1, [\\"a\\"]) \\"valid\\" >>> is_valid_pyramid(3, [\\"a\\", \\"ab\\", \\"abc\\"]) \\"valid\\" >>> is_valid_pyramid(3, [\\"a\\", \\"abc\\", \\"abcd\\"]) \\"invalid\\" >>> is_valid_pyramid(3, [\\"a\\", \\"ab\\", \\"ac\\"]) \\"invalid\\" def process_input(input_data): Process input data to determine the validity of multiple test cases. >>> process_input(\\"3nanabnabcn0\\") [\\"valid\\"] >>> process_input(\\"3nanabnabcn4nxnxqnxqenxqeln4nmnmanmannmaxn0\\") [\\"valid\\", \\"valid\\", \\"invalid\\"] >>> process_input(\\"1nan0\\") [\\"valid\\"] >>> process_input(\\"2nanbn2nabnacn0\\") [\\"invalid\\", \\"invalid\\"]","solution":"def is_valid_pyramid(n, words): Determines whether the series of words forms a valid pyramid. :param n: An integer representing the number of words :param words: A list of strings :return: \\"valid\\" if the series forms a valid pyramid, \\"invalid\\" otherwise if n == 0: return \\"invalid\\" for i in range(1, n): if len(words[i]) != len(words[i - 1]) + 1: return \\"invalid\\" if not words[i].startswith(words[i - 1]): return \\"invalid\\" return \\"valid\\" def process_input(input_data): Process input data to determine the validity of multiple test cases. :param input_data: A string representing the input :return: A list of results for each test case results = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break words = lines[i+1:i+1+n] results.append(is_valid_pyramid(n, words)) i += n + 1 return results if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read() results = process_input(input_data) for result in results: print(result)"},{"question":"def unique_absolute_differences(test_cases): Given an array of N integers, find the number of unique absolute differences that can be formed between any two elements in the array. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing an integer N and a list of N integers. Returns: List[int]: A list of results, each representing the number of unique absolute differences for the corresponding test case. >>> unique_absolute_differences([(3, [10, 20, 30]), (4, [-5, 0, 5, 10])]) [2, 3]","solution":"def unique_absolute_differences(test_cases): results = [] for t in test_cases: N, array = t unique_diffs = set() for i in range(N): for j in range(i + 1, N): abs_diff = abs(array[i] - array[j]) unique_diffs.add(abs_diff) results.append(len(unique_diffs)) return results # For directly running in the solution segment if __name__ == \\"__main__\\": T = int(input().strip()) test_cases = [] for _ in range(T): N = int(input().strip()) array = list(map(int, input().strip().split())) test_cases.append((N, array)) results = unique_absolute_differences(test_cases) for result in results: print(result)"},{"question":"def minimizeCycleTime(tasks): Returns the minimal cycle time to complete each task at least once. >>> minimizeCycleTime([4, 2, 5, 3]) 14 >>> minimizeCycleTime([7, 2, 3, 9, 5]) 26 >>> minimizeCycleTime([1]) 1 >>> minimizeCycleTime([10, 10, 10, 10]) 40 >>> minimizeCycleTime([10000] * 100000) 1000000000","solution":"def minimizeCycleTime(tasks): Returns the minimal cycle time to complete each task at least once. :param tasks: List[int] - a list of integers representing task durations :return: int - minimal cycle time return sum(tasks)"},{"question":"def evaluateExpression(s: str) -> float: Evaluates a mathematical expression string and returns the result as a float. Args: s (str): The string representation of the mathematical expression. Returns: float: The result of the evaluated expression. Examples: >>> evaluateExpression(\\"3 + 5 / 2\\") 5.5 >>> evaluateExpression(\\"10 - 3 * 2\\") 4.0","solution":"def evaluateExpression(s): Evaluates a mathematical expression string and returns the result as a float. Args: s (str): The string representation of the mathematical expression. Returns: float: The result of the evaluated expression. import re # Remove spaces s = s.replace(\\" \\", \\"\\") # Helper function to evaluate the expression using the shunting yard algorithm def eval_postfix(expression): stack = [] for token in expression: if re.match(r\\"-?d+.?d*\\", token): stack.append(float(token)) else: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(a / b) return stack[0] # Helper function to convert infix expression to postfix expression (Reverse Polish Notation) def infix_to_postfix(expression): precedence = {'+': 1, '-': 1, '*': 2, '/': 2} output = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit() or (expression[i] == '.' and i+1 < len(expression) and expression[i+1].isdigit()): num = [] while i < len(expression) and (expression[i].isdigit() or expression[i] == '.'): num.append(expression[i]) i += 1 output.append(''.join(num)) else: while (operators and operators[-1] in precedence and precedence[operators[-1]] >= precedence[expression[i]]): output.append(operators.pop()) operators.append(expression[i]) i += 1 while operators: output.append(operators.pop()) return output postfix_expression = infix_to_postfix(s) result = eval_postfix(postfix_expression) return result"},{"question":"def sumPairs(ints, s): Finds the first pair of integers in the list that sums up to s. Parameters: ints (list): A list of integers. s (int): The target sum. Returns: tuple: A tuple containing the first pair of integers that sum to s or None if no such pair exists. Examples: >>> sumPairs([1, 4, 8, 7, 3, 15], 8) (1, 7) >>> sumPairs([1, -2, 3, 0, -6, 1], -6) (0, -6) >>> sumPairs([20, -13, 40], -7) None >>> sumPairs([10, 5, 2, 3, 7, 5], 10) (3, 7)","solution":"def sumPairs(ints, s): Finds the first pair of integers in the list that sums up to s. Parameters: ints (list): A list of integers. s (int): The target sum. Returns: tuple: A tuple containing the first pair of integers that sum to s or None if no such pair exists. seen = set() for number in ints: complement = s - number if complement in seen: return (complement, number) seen.add(number) return None"},{"question":"def calculateTrappedWater(heights: List[int]) -> int: Calculate the total amount of water trapped between buildings after a rainfall. >>> calculateTrappedWater([3, 0, 2, 0, 4]) 7 >>> calculateTrappedWater([2, 1, 2]) 1 >>> calculateTrappedWater([0, 0, 0, 0]) 0 >>> calculateTrappedWater([4]) 0 >>> calculateTrappedWater([3, 3, 3, 3]) 0 >>> calculateTrappedWater([1, 2, 3, 4, 5]) 0 >>> calculateTrappedWater([5, 4, 3, 2, 1]) 0 >>> calculateTrappedWater([0, 3, 0, 2, 0, 4]) 7","solution":"def calculateTrappedWater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def shortest_path(N, M, K, roads): Calculate the length of the shortest path from village 1 to village K. Parameters: N (int): The number of villages. M (int): The number of roads. K (int): The destination village. roads (List[Tuple[int, int]]): The list of bidirectional roads between villages. Returns: int: The length of the shortest path from village 1 to village K. Examples: >>> shortest_path(5, 5, 4, [(1, 2), (2, 3), (3, 4), (1, 5), (5, 3)]) 3 >>> shortest_path(4, 4, 3, [(1, 2), (2, 3), (1, 3), (2, 4)]) 1 from typing import List, Tuple def test_example_1(): N = 5 M = 5 K = 4 roads = [(1, 2), (2, 3), (3, 4), (1, 5), (5, 3)] assert shortest_path(N, M, K, roads) == 3 def test_example_2(): N = 4 M = 4 K = 3 roads = [(1, 2), (2, 3), (1, 3), (2, 4)] assert shortest_path(N, M, K, roads) == 1 def test_single_road(): N = 2 M = 1 K = 2 roads = [(1, 2)] assert shortest_path(N, M, K, roads) == 1 def test_no_ring(): N = 3 M = 2 K = 3 roads = [(1, 2), (2, 3)] assert shortest_path(N, M, K, roads) == 2 def test_large_graph(): N = 10000 M = 19999 K = 10000 roads = [(i, i + 1) for i in range(1, 10000)] assert shortest_path(N, M, K, roads) == 9999","solution":"import heapq def shortest_path(N, M, K, roads): def dijkstra(start, graph): distances = {node: float('infinity') for node in range(1, N + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Build the graph graph = {i: [] for i in range(1, N + 1)} for road in roads: A, B = road graph[A].append((B, 1)) graph[B].append((A, 1)) distances_from_1 = dijkstra(1, graph) return distances_from_1[K]"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Helper function to check if a number n is prime. def count_prime_squares(k: int, numbers: List[int]) -> int: Returns the count of prime squares in the list of numbers. Parameters: k (int): The number of integers in the list. numbers (List[int]): The list of integers to check. Returns: int: The count of prime squares in the list. >>> count_prime_squares(5, [4, 10, 25, 16, 9]) 3 >>> count_prime_squares(4, [8, 10, 20, 30]) 0 >>> count_prime_squares(3, [4, 9, 25]) 3 >>> count_prime_squares(4, [16, 49, 50, 121]) 2 >>> count_prime_squares(5, [1, 1000000, 104060401, 104060401, 961]) 1","solution":"import math def is_prime(n): Helper function to check if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(math.sqrt(n)) + 1, 2): if n % i == 0: return False return True def count_prime_squares(k, numbers): Returns the count of prime squares in the list of numbers. prime_squares_count = 0 for number in numbers: sqrt_number = int(math.isqrt(number)) if sqrt_number * sqrt_number == number and is_prime(sqrt_number): prime_squares_count += 1 return prime_squares_count"},{"question":"def compress_array(N: int, arr: List[int]) -> List[int]: A software company has developed a new compression algorithm. The algorithm compresses an array of integers by replacing each element of the array with the sum of its neighboring elements, including itself. Specifically, for each element arr[i], it will be replaced by arr[i-1] + arr[i] + arr[i+1]. The first and the last elements of the array are special cases: the first element arr[0] is replaced by arr[0] + arr[1], and the last element arr[N-1] is replaced by arr[N-2] + arr[N-1]. Given an array of integers, apply the compression algorithm exactly once and return the resulting array. Args: N (int): The number of elements in the array. arr (List[int]): A list of integers representing the array. Returns: List[int]: The new array after applying the compression algorithm exactly once. >>> compress_array(5, [1, 2, 3, 4, 5]) [3, 6, 9, 12, 9] >>> compress_array(1, [5]) [5] >>> compress_array(2, [1, 5]) [6, 6] >>> compress_array(4, [3, 3, 3, 3]) [6, 9, 9, 6] >>> compress_array(6, [1, 3, 6, 7, 9, 2]) [4, 10, 16, 22, 18, 11]","solution":"def compress_array(N, arr): if N == 1: return arr # No compression possible with single element new_arr = [0] * N new_arr[0] = arr[0] + arr[1] new_arr[N-1] = arr[N-2] + arr[N-1] for i in range(1, N-1): new_arr[i] = arr[i-1] + arr[i] + arr[i+1] return new_arr"},{"question":"def min_in_subarray(arr, n, x): Transforms the array such that each element arr[i] is replaced by the smallest element from arr[i+1] to arr[i+x] (both inclusive). If there are fewer than x elements remaining, consider only available elements. :param arr: List[int] - The input array :param n: int - The size of the input array :param x: int - The number of subsequent elements to consider :return: List[int] - The transformed array Examples: >>> min_in_subarray([4, 7, 2, 8, 9], 5, 2) [2, 2, 8, 9, -1] >>> min_in_subarray([12, 3, 15, 7], 4, 1) [3, 15, 7, -1] >>> min_in_subarray([1, 2, 3, 4, 5], 5, 3) [2, 3, 4, 5, -1] >>> min_in_subarray([10], 1, 1) [-1] >>> min_in_subarray([5, 4, 3, 2, 1], 5, 4) [1, 1, 1, 1, -1] >>> min_in_subarray([4, 2, 3, 5, 1], 5, 2) [2, 3, 1, 1, -1]","solution":"def min_in_subarray(arr, n, x): Transforms the array such that each element arr[i] is replaced by the smallest element from arr[i+1] to arr[i+x] (both inclusive). If there are fewer than x elements remaining, consider only available elements. result = [] for i in range(n): if i + 1 >= n: result.append(-1) else: result.append(min(arr[i+1:min(i+x+1, n)])) return result"},{"question":"def longest_even_subarray(arr): Determine the length of the longest subarray that contains only even numbers. >>> longest_even_subarray([1, 2, 4, 6, 1, 2]) 3 >>> longest_even_subarray([5, 7, 9, 2, 4]) 2 pass def process_input(data): Processes the input data and returns the lengths of the longest subarrays containing only even numbers. >>> process_input([\\"6\\", \\"1 2 4 6 1 2\\", \\"5\\", \\"5 7 9 2 4\\", \\"0\\"]) [3, 2] pass","solution":"def longest_even_subarray(arr): Determine the length of the longest subarray that contains only even numbers. max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length def process_input(data): Processes the input data and returns the lengths of the longest subarrays containing only even numbers. results = [] i = 0 while i < len(data): length_of_array = int(data[i]) if length_of_array == 0: break array_elements = list(map(int, data[i + 1].split())) results.append(longest_even_subarray(array_elements)) i += 2 return results"},{"question":"def calculate_working_hours(N: int, logs: List[str], Q: int, queries: List[str]) -> List[float]: Calculate the total working hours for each employee within specified time frames. Parameters: N (int): The number of log entries. logs (list of str): List of log entries. Q (int): The number of queries. queries (list of str): List of queries. Returns: list of float: Total working hours for each query rounded to two decimal places. >>> calculate_working_hours(12, [ ... \\"emp1 2023-10-01 09:00 login\\", ... \\"emp1 2023-10-01 17:00 logout\\", ... \\"emp2 2023-10-01 10:00 login\\", ... \\"emp2 2023-10-01 18:00 logout\\", ... \\"emp1 2023-10-02 09:00 login\\", ... \\"emp1 2023-10-02 17:00 logout\\", ... \\"emp2 2023-10-02 10:00 login\\", ... \\"emp2 2023-10-02 18:00 logout\\", ... \\"emp1 2023-10-03 09:00 login\\", ... \\"emp1 2023-10-03 17:00 logout\\", ... \\"emp2 2023-10-03 10:00 login\\", ... \\"emp2 2023-10-03 18:00 logout\\", ... ], 3, [ ... \\"emp1 2023-10-01 00:00 2023-10-02 23:59\\", ... \\"emp2 2023-10-02 00:00 2023-10-03 23:59\\", ... \\"emp1 2023-10-01 00:00 2023-10-01 23:59\\"]) == [16.00, 16.00, 8.00] >>> calculate_working_hours(2, [ ... \\"emp1 2023-10-01 09:00 login\\", ... \\"emp1 2023-10-01 09:05 logout\\" ... ], 1, [ ... \\"emp1 2023-10-01 09:06 2023-10-01 10:00\\" ... ]) == [0.00] >>> calculate_working_hours(4, [ ... \\"emp1 2023-10-01 09:00 login\\", ... \\"emp1 2023-10-01 18:00 logout\\", ... \\"emp1 2023-10-02 09:00 login\\", ... \\"emp1 2023-10-02 12:00 logout\\" ... ], 1, [ ... \\"emp1 2023-10-01 10:00 2023-10-01 17:00\\" ... ]) == [7.00]","solution":"from datetime import datetime def calculate_working_hours(N, logs, Q, queries): Calculate the total working hours for each query. Parameters: N (int): The number of log entries. logs (list of str): List of log entries. Q (int): The number of queries. queries (list of str): List of queries. Returns: list of float: Total working hours for each query. from collections import defaultdict import datetime # Dictionary to keep track of login and logout times for each employee work_sessions = defaultdict(list) time_format = \\"%Y-%m-%d %H:%M\\" # Process each log entry for log in logs: parts = log.split() emp_id = parts[0] timestamp = datetime.datetime.strptime(parts[1] + \\" \\" + parts[2], time_format) action = parts[3] if action == \\"login\\": work_sessions[emp_id].append([timestamp, None]) elif action == \\"logout\\": # Find the latest session without a logout time for session in work_sessions[emp_id]: if session[1] is None: session[1] = timestamp break results = [] # Process each query for query in queries: parts = query.split() emp_id = parts[0] start_time = datetime.datetime.strptime(parts[1] + \\" \\" + parts[2], time_format) end_time = datetime.datetime.strptime(parts[3] + \\" \\" + parts[4], time_format) total_hours = 0 if emp_id in work_sessions: for (login, logout) in work_sessions[emp_id]: if login and logout: if logout < start_time or login > end_time: continue if login < start_time: login = start_time if logout > end_time: logout = end_time # Calculate hours between login and logout total_hours += (logout - login).total_seconds() / 3600 results.append(round(total_hours, 2)) return results"},{"question":"def smallest_window_with_all_distinct_elements(arr): Returns the length of the smallest window (contiguous subarray) in the array that contains all the distinct elements of the array. Args: arr (List[int]): The input array of integers. Returns: int: Length of the smallest window containing all distinct elements. Examples: >>> smallest_window_with_all_distinct_elements([1, 2, 2, 3, 2, 1, 4]) 4 >>> smallest_window_with_all_distinct_elements([1, 2, 2, 2]) 2 pass def process_test_cases(test_cases): Processes multiple test cases and returns their results. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the number of elements and the list of integers. Returns: List[int]: List of results for each test case. Examples: >>> process_test_cases([(7, [1, 2, 2, 3, 2, 1, 4]), (4, [1, 2, 2, 2])]) [4, 2] pass","solution":"def smallest_window_with_all_distinct_elements(arr): Returns the length of the smallest window (contiguous subarray) in the array that contains all the distinct elements of the array. n = len(arr) distinct_elements = set(arr) num_distinct = len(distinct_elements) left = 0 min_length = float('inf') current_window = {} unique_in_window = 0 for right in range(n): if arr[right] in current_window: current_window[arr[right]] += 1 else: current_window[arr[right]] = 1 unique_in_window += 1 while unique_in_window == num_distinct: min_length = min(min_length, right - left + 1) current_window[arr[left]] -= 1 if current_window[arr[left]] == 0: unique_in_window -= 1 del current_window[arr[left]] left += 1 return min_length def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(smallest_window_with_all_distinct_elements(arr)) return results"},{"question":"def encode_string(s: str) -> str: Encode input string using the rule-based on consecutive identical characters. Input: s (str) - the input string to be encoded Output: (str) - the encoded string >>> encode_string(\\"aaabbbccca\\") # returns \\"a3b3c3a\\" >>> encode_string(\\"abc\\") # returns \\"abc\\" >>> encode_string(\\"aabbccdd\\") # returns \\"a2b2c2d2\\" >>> encode_string(\\"xxxxxxxxxx\\") # returns \\"x10\\" pass # Unit Tests def test_encode_string_with_repeated_characters(): assert encode_string(\\"aaabbbccca\\") == \\"a3b3c3a\\" def test_encode_string_no_repetitions(): assert encode_string(\\"abc\\") == \\"abc\\" def test_encode_string_each_character_repeated_twice(): assert encode_string(\\"aabbccdd\\") == \\"a2b2c2d2\\" def test_encode_string_long_repeat(): assert encode_string(\\"xxxxxxxxxx\\") == \\"x10\\" def test_encode_string_empty_string(): assert encode_string(\\"\\") == \\"\\" def test_encode_string_single_character(): assert encode_string(\\"a\\") == \\"a\\" def test_encode_string_mixed_case(): assert encode_string(\\"aaAAaa\\") == \\"a2A2a2\\" def test_encode_string_alternating_characters(): assert encode_string(\\"ababababa\\") == \\"ababababa\\"","solution":"def encode_string(s: str) -> str: Encodes the input string based on consecutive identical characters rules. if not s: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_string.append(s[i - 1]) if count > 1: encoded_string.append(str(count)) count = 1 # handle the last character group encoded_string.append(s[-1]) if count > 1: encoded_string.append(str(count)) return \\"\\".join(encoded_string)"},{"question":"def has_zero_sum_subarray(arr): Determines if there exists a non-empty subarray whose elements sum up to zero. :param arr: List of integers. :return: \\"YES\\" if such a subarray exists, \\"NO\\" otherwise. Examples: >>> has_zero_sum_subarray([3, 4, -7, 1, 2]) 'YES' >>> has_zero_sum_subarray([1, 2, 3, 4]) 'NO'","solution":"def has_zero_sum_subarray(arr): Determines if there exists a non-empty subarray whose elements sum up to zero. :param arr: List of integers. :return: \\"YES\\" if such a subarray exists, \\"NO\\" otherwise. prefix_sum = 0 prefix_sum_set = set() for num in arr: prefix_sum += num # A zero sum subarray starts from index 0 to current index if prefix_sum is zero if prefix_sum == 0 or prefix_sum in prefix_sum_set: return \\"YES\\" prefix_sum_set.add(prefix_sum) return \\"NO\\""},{"question":"from typing import List def maxArea(height: List[int]) -> int: Given a list of non-negative integers representing the heights of vertical lines drawn on a 2D plane, find two lines such that together with the x-axis, they form a container that holds the most water. The container cannot be slanted and must be formed by the vertical lines at the x-axis positions i and j (0 â‰¤ i < j < N) with the height determined by the shorter line. >>> maxArea([1,8,6,2,5,4,8,3,7]) 49 >>> maxArea([1,1]) 1","solution":"from typing import List def maxArea(height: List[int]) -> int: Returns the maximum amount of water a container can hold given the heights of vertical lines. left = 0 right = len(height) - 1 max_area = 0 while left < right: # Width of the container width = right - left # Height of the container container_height = min(height[left], height[right]) # Calculate the area current_area = width * container_height # Update max_area if current_area is larger if current_area > max_area: max_area = current_area # Move the pointer of the shorter line towards the center if height[left] < height[right]: left += 1 else: right -= 1 return max_area"},{"question":"def count_perfect_squares(n: int) -> int: Returns the number of unique values of i such that i^2 = n. >>> count_perfect_squares(5) 0 >>> count_perfect_squares(9) 1 >>> count_perfect_squares(1000002) 0 >>> count_perfect_squares(1) 1 >>> count_perfect_squares(4) 1 >>> count_perfect_squares(16) 1 >>> count_perfect_squares(25) 1 >>> count_perfect_squares(100) 1 >>> count_perfect_squares(1000) 0 >>> count_perfect_squares(2147395600) 1","solution":"def count_perfect_squares(n): Returns the number of unique values of i such that i^2 = n. count = 0 i = 1 while i * i <= n: if i * i == n: count += 1 i += 1 return count"},{"question":"def floyds_triangle(rows): Returns Floyd's Triangle with the given number of rows. Each row is a list of consecutive natural numbers. >>> floyds_triangle(1) == [[1]] >>> floyds_triangle(2) == [[1], [2, 3]] >>> floyds_triangle(3) == [[1], [2, 3], [4, 5, 6]] >>> floyds_triangle(5) == [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]] from solution import floyds_triangle def test_floyds_triangle_one_row(): assert floyds_triangle(1) == [[1]] def test_floyds_triangle_two_rows(): assert floyds_triangle(2) == [[1], [2, 3]] def test_floyds_triangle_three_rows(): assert floyds_triangle(3) == [[1], [2, 3], [4, 5, 6]] def test_floyds_triangle_five_rows(): assert floyds_triangle(5) == [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]] def test_floyds_triangle_zero_rows(): assert floyds_triangle(0) == [] def test_floyds_triangle_negative_rows(): assert floyds_triangle(-3) == []","solution":"def floyds_triangle(rows): Returns Floyd's Triangle with the given number of rows. Each row is a list of consecutive natural numbers. triangle = [] current_number = 1 for row in range(1, rows + 1): current_row = [] for _ in range(row): current_row.append(current_number) current_number += 1 triangle.append(current_row) return triangle"},{"question":"def max_deliveries(flights): Determines the maximum number of non-overlapping deliveries that can be completed within a given time frame. Parameters: flights: A list of tuples, each containing the start and end times of a flight. Returns: The maximum number of non-overlapping deliveries. Examples: >>> max_deliveries([(1, 4), (2, 3), (3, 5)]) 2 >>> max_deliveries([(0, 60), (60, 120), (120, 180), (180, 240)]) 4 >>> max_deliveries([(0, 1), (2, 3), (4, 5), (6, 7)]) 4 >>> max_deliveries([(0, 5), (1, 4), (2, 3)]) 1 >>> max_deliveries([(0, 6), (1, 4), (5, 7), (6, 8)]) 2 >>> max_deliveries([(0, 10)]) 1 >>> max_deliveries([]) 0","solution":"def max_deliveries(flights): Determines the maximum number of non-overlapping deliveries that can be completed within a given time frame. Parameters: flights: A list of tuples, each containing the start and end times of a flight. Returns: The maximum number of non-overlapping deliveries. # Sort flights based on their end times flights.sort(key=lambda x: x[1]) max_deliveries_count = 0 last_end_time = -1 for start, end in flights: if start >= last_end_time: max_deliveries_count += 1 last_end_time = end return max_deliveries_count"},{"question":"def maximum_magic_power(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum sum of magic power that can be gathered from a contiguous segment of fruits. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of fruits and their magic power values. Returns: List[int]: List of maximum magic power sums for each test case. Example: >>> maximum_magic_power(3, [(5, [-1, 2, 3, -5, 4]), (8, [-2, -3, 4, -1, -2, 1, 5, -3]), (6, [1, 2, 3, -2, 5, 6])]) [5, 7, 15] def max_subarray_sum(nums: List[int]) -> int: # Write your implementation here results = [] for case in test_cases: N = case[0] magic_values = case[1] max_power = max_subarray_sum(magic_values) results.append(max_power) return results","solution":"def maximum_magic_power(T, test_cases): def max_subarray_sum(nums): max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum results = [] for case in test_cases: N = case[0] magic_values = case[1] max_power = max_subarray_sum(magic_values) results.append(max_power) return results"},{"question":"from collections import Counter def frequency_sort(s: str) -> str: Returns the string with characters sorted according to their frequency of appearance in descending order. If two characters have the same frequency, they appear in the order they first appear in 's'. :param s: Input string :return: String sorted by frequency of characters >>> frequency_sort(\\"tree\\") \\"eert\\" >>> frequency_sort(\\"cccaaa\\") \\"cccaaa\\" or \\"aaaccc\\" >>> frequency_sort(\\"Aabb\\") \\"bbAa\\" >>> frequency_sort(\\"a\\") \\"a\\" >>> frequency_sort(\\"\\") \\"\\" >>> frequency_sort(\\"abcd\\") \\"abcd\\" >>> frequency_sort(\\"@@!!\\") \\"@@!!\\" >>> long_input = \\"a\\"*10 + \\"b\\"*5 + \\"c\\"*3 + \\"d\\" >>> frequency_sort(long_input) \\"aaaaaaaaaabbbbbcccd\\"","solution":"from collections import Counter def frequency_sort(s): Returns the string with characters sorted according to their frequency of appearance in descending order. If two characters have the same frequency, they appear in the order they first appear in 's'. :param s: Input string :return: String sorted by frequency of characters count = Counter(s) # Sorting based on frequency (descending) and order of first appearance (ascending) sorted_characters = sorted(s, key=lambda x: (-count[x], s.index(x))) return ''.join(sorted_characters)"},{"question":"from typing import List, Tuple def min_deliveries(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum number of deliveries required to keep all customers satisfied. :param t: Number of test cases (int) :param cases: List of tuples containing number of customers and their expected delivery times. :return: List containing the minimum number of deliveries for each test case. >>> min_deliveries(1, [(3, [1, 2, 3])]) [3] >>> min_deliveries(1, [(4, [1, 2, 2, 3])]) [3] >>> min_deliveries(2, [(3, [1, 2, 3]), (4, [1, 2, 2, 3])]) [3, 3] >>> min_deliveries(1, [(1, [5])]) [1] >>> min_deliveries(3, [(5, [1, 1, 1, 1, 1]), (6, [1, 2, 2, 3, 3, 4]), (4, [4, 4, 4, 4])]) [1, 4, 1]","solution":"def min_deliveries(t, cases): Calculate the minimum number of deliveries required to keep all customers satisfied. :param t: Number of test cases (int) :param cases: List of tuples containing number of customers and their expected delivery times. :return: List containing the minimum number of deliveries for each test case. results = [] for case in cases: n, delivery_times = case unique_times = set(delivery_times) results.append(len(unique_times)) return results"},{"question":"def smallest_lexicographical_string(s: str) -> str: Returns the smallest possible lexicographical string after repeatedly performing the described operation. >>> smallest_lexicographical_string(\\"acbd\\") 'd' >>> smallest_lexicographical_string(\\"abac\\") 'c' >>> smallest_lexicographical_string(\\"abcd\\") 'd' >>> smallest_lexicographical_string(\\"a\\") 'a' >>> smallest_lexicographical_string(\\"aa\\") 'a' >>> smallest_lexicographical_string(\\"zazaba\\") 'z' >>> smallest_lexicographical_string(\\"mnopqrsz\\") 'z'","solution":"def smallest_lexicographical_string(s): Returns the smallest possible lexicographical string after repeatedly performing the described operation. # Since we are allowed to reduce the string by selecting the larger of two adjacent characters, # in the end we will be left with the single largest character max_char = max(s) return max_char"},{"question":"def shortest_path(grid: List[List[int]]) -> int: Find the shortest path in a grid from top-left to bottom-right corner. >>> shortest_path( ... [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] ... ) 5 >>> shortest_path( ... [ ... [0, 1, 1], ... [1, 1, 1], ... [1, 0, 0] ... ] ... ) -1 >>> shortest_path( ... [ ... [0, 0, 0, 1, 1, 1], ... [0, 1, 0, 0, 0, 0], ... [0, 1, 1, 1, 1, 0], ... [0, 0, 0, 0, 1, 0], ... [1, 1, 1, 0, 0, 0] ... ] ... ) 10 >>> shortest_path([[0]]) 1 >>> shortest_path([[0, 1], [1, 0]]) -1 >>> shortest_path([[0, 0], [0, 0]]) 3","solution":"from collections import deque def shortest_path(grid): Find the shortest path in a grid from top-left to bottom-right corner. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == 0 queue = deque([(0, 0, 1)]) # store (x, y, distance) grid[0][0] = 1 # mark as visited while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): grid[nx][ny] = 1 # mark as visited queue.append((nx, ny, dist + 1)) return -1 def main(m, n, grid): return shortest_path(grid)"},{"question":"from typing import List, Tuple def count_subarrays_with_min_value(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Count the number of contiguous subarrays with at least one person whose ticket value is greater than or equal to x. - The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. - The first line of each test case contains two space-separated integers n and x denoting the number of people and the ticket value threshold. - The second line of each test case contains n space-separated integers denoting the ticket values of the people in the queue. Example: >>> count_subarrays_with_min_value([(5, 3, [1, 2, 3, 4, 5]), (4, 10, [8, 5, 7, 11])]) [12, 4]","solution":"def count_subarrays_with_min_value(test_cases): results = [] for n, x, arr in test_cases: count = 0 subarray_count = 0 for i in range(n): if arr[i] >= x: count += (subarray_count + 1) * (n - i) subarray_count = 0 else: subarray_count += 1 results.append(count) return results"},{"question":"def can_construct_product(required_components, available_inventory): Determine if it is possible to construct a product with the specified components given the inventory of available components. Args: required_components (dict): A dictionary where keys are component names and values are required quantities. available_inventory (dict): A dictionary where keys are component names and values are available quantities. Returns: str: \\"Yes\\" if the product can be constructed with the given components, otherwise \\"No\\". for component, required_quantity in required_components.items(): if available_inventory.get(component, 0) < required_quantity: return \\"No\\" return \\"Yes\\" def process_input_and_check_construction(inputs): Process the input list and determine if the product can be constructed. Args: inputs (list): A list of strings representing the input data. Returns: str: \\"Yes\\" if the product can be constructed with the given components, otherwise \\"No\\". n = int(inputs[0]) required_components = {} index = 1 for _ in range(n): component, quantity = inputs[index].split() required_components[component] = int(quantity) index += 1 m = int(inputs[index]) available_inventory = {} index += 1 for _ in range(m): component, quantity = inputs[index].split() available_inventory[component] = int(quantity) index += 1 return can_construct_product(required_components, available_inventory) def test_case_1(): inputs = [ \\"3\\", \\"steel 4\\", \\"screws 10\\", \\"wood 3\\", \\"4\\", \\"steel 5\\", \\"screws 10\\", \\"wood 2\\", \\"paint 5\\" ] assert process_input_and_check_construction(inputs) == \\"No\\" def test_case_2(): inputs = [ \\"2\\", \\"plastic 3\\", \\"rubber 2\\", \\"2\\", \\"plastic 3\\", \\"rubber 2\\" ] assert process_input_and_check_construction(inputs) == \\"Yes\\" def test_all_components_available_and_sufficient(): inputs = [ \\"1\\", \\"metal 5\\", \\"1\\", \\"metal 5\\" ] assert process_input_and_check_construction(inputs) == \\"Yes\\" def test_component_not_in_inventory(): inputs = [ \\"1\\", \\"glass 2\\", \\"1\\", \\"plastic 2\\" ] assert process_input_and_check_construction(inputs) == \\"No\\" def test_multiple_components_not_sufficient_quantities(): inputs = [ \\"2\\", \\"bolt 5\\", \\"nut 3\\", \\"2\\", \\"bolt 3\\", \\"nut 2\\" ] assert process_input_and_check_construction(inputs) == \\"No\\"","solution":"def can_construct_product(required_components, available_inventory): for component, required_quantity in required_components.items(): if available_inventory.get(component, 0) < required_quantity: return \\"No\\" return \\"Yes\\" def process_input_and_check_construction(inputs): n = int(inputs[0]) required_components = {} index = 1 for _ in range(n): component, quantity = inputs[index].split() required_components[component] = int(quantity) index += 1 m = int(inputs[index]) available_inventory = {} index += 1 for _ in range(m): component, quantity = inputs[index].split() available_inventory[component] = int(quantity) index += 1 return can_construct_product(required_components, available_inventory)"},{"question":"def find_missing_number(nums): Returns the single missing integer from a list of unique consecutive integers. Args: nums (list of int): List containing the consecutive integers with one missing. Returns: int: The missing integer. >>> find_missing_number([1, 2, 4, 5]) 3 >>> find_missing_number([10, 11, 13]) 12 >>> find_missing_number([0, 1, 2, 4]) 3 >>> find_missing_number([3, 4, 5, 7]) 6 >>> find_missing_number([100, 101, 102, 104]) 103 >>> find_missing_number([-2, -1, 0, 1, 3]) 2 >>> find_missing_number([-5, -4, -2, -1]) -3 >>> find_missing_number([-1, 0, 1, 2, 4]) 3 >>> find_missing_number([-3, -1, 0, 1]) -2","solution":"def find_missing_number(nums): Returns the single missing integer from a list of unique consecutive integers. Args: nums (list of int): List containing the consecutive integers with one missing. Returns: int: The missing integer. n = len(nums) + 1 total_sum = n * (min(nums) + max(nums)) // 2 # Sum of an arithmetic series actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"def minimum_cost_to_connect_cities(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the minimum cost required to construct additional roads such that all cities are directly connected. Args: n (int): Number of cities. m (int): Number of existing roads. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers u, v, and w denoting a road between cities u and v with length w. Returns: int: The minimum cost required to ensure all cities are directly connected or -1 if it's not possible. Examples: >>> minimum_cost_to_connect_cities(4, 3, [(1, 2, 1), (2, 3, 4), (3, 4, 5)]) 10 >>> minimum_cost_to_connect_cities(5, 1, [(1, 2, 3)]) -1 import pytest from solution import minimum_cost_to_connect_cities def test_case_1(): assert minimum_cost_to_connect_cities(4, 3, [(1, 2, 1), (2, 3, 4), (3, 4, 5)]) == 10 def test_case_2(): assert minimum_cost_to_connect_cities(5, 1, [(1, 2, 3)]) == -1 def test_case_3(): assert minimum_cost_to_connect_cities(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)]) == 6 def test_case_4(): assert minimum_cost_to_connect_cities(6, 5, [(1, 2, 3), (2, 3, 5), (3, 4, 4), (4, 5, 6), (5, 6, 2)]) == 20 def test_case_5(): assert minimum_cost_to_connect_cities(3, 0, []) == -1 def test_case_6(): assert minimum_cost_to_connect_cities(2, 0, []) == -1 def test_case_7(): assert minimum_cost_to_connect_cities(3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 3)]) == 3","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_cost_to_connect_cities(n, m, roads): if m < n - 1: return -1 # Not enough roads to connect all cities roads.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = [] i = 0 e = 0 while e < n - 1: if i >= len(roads): return -1 # Not enough roads to connect all cities u, v, w = roads[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append(w) union(parent, rank, x, y) return sum(result)"},{"question":"def min_partition_difference(n, weights): Given an array of weights, this function divides the array into two subsets such that the absolute difference between the sum of the weights of the subsets is minimized. :param n: int - Number of items. :param weights: List[int] - Weights of the items. :return: int - Minimum possible absolute difference between the sum of the weights of the two groups. >>> min_partition_difference(5, [1, 2, 3, 4, 5]) 1 >>> min_partition_difference(3, [8, 6, 5]) 3 >>> min_partition_difference(1, [1000]) 1000 >>> min_partition_difference(4, [1, 1, 1, 1]) 0 >>> min_partition_difference(4, [1, 2, 3, 10]) 4 >>> min_partition_difference(6, [5, 10, 15, 20, 25, 30]) 5","solution":"def min_partition_difference(n, weights): Given an array of weights, this function divides the array into two subsets such that the absolute difference between the sum of the weights of the subsets is minimized. total_weight = sum(weights) target = total_weight // 2 dp = [0] * (target + 1) for weight in weights: for j in range(target, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) group1 = dp[target] group2 = total_weight - group1 return abs(group2 - group1) # Example usage: # n = 5 # weights = [1, 2, 3, 4, 5] # print(min_partition_difference(n, weights)) # Output: 1"},{"question":"def shift_characters(s: str) -> str: Shifts each character to the next character in the alphabet, maintaining case and leaving non-alphabet characters unchanged. >>> shift_characters(\\"abc XYZ!\\") \\"bcd YZA!\\" >>> shift_characters(\\"aBcXyZ\\") \\"bCdYzA\\" >>> shift_characters(\\"1234!@#\\") \\"1234!@#\\" >>> shift_characters(\\"z\\") \\"a\\" >>> shift_characters(\\"Z\\") \\"A\\"","solution":"def shift_characters(s): Shifts each character to the next character in the alphabet, maintaining case and leaving non-alphabet characters unchanged. shifted_string = [] for char in s: if 'a' <= char <= 'z': if char == 'z': shifted_string.append('a') else: shifted_string.append(chr(ord(char) + 1)) elif 'A' <= char <= 'Z': if char == 'Z': shifted_string.append('A') else: shifted_string.append(chr(ord(char) + 1)) else: shifted_string.append(char) return ''.join(shifted_string)"},{"question":"def count_even_sum_pairs(test_cases): This function takes a list of test cases and returns a list of integers representing the count of pairs (i, j) where i <= j and the sum of the numbers at those indices is even. >>> count_even_sum_pairs([(4, [1, 2, 3, 4]), (3, [1, 1, 1])]) [6, 6] >>> count_even_sum_pairs([(4, [2, 4, 6, 8])]) [10] >>> count_even_sum_pairs([(3, [1, 3, 5])]) [6] >>> count_even_sum_pairs([(5, [1, 2, 3, 4, 5])]) [9] >>> count_even_sum_pairs([(6, [10, 20, 30, 40, 50, 60])]) [21] # Your code here def parse_input(input_str): Parses the input string and converts it to a list of test cases. >>> parse_input('2n4n1 2 3 4n3n1 1 1') [(4, [1, 2, 3, 4]), (3, [1, 1, 1])] >>> parse_input('1n4n2 4 6 8') [(4, [2, 4, 6, 8])] >>> parse_input('1n3n1 3 5') [(3, [1, 3, 5])] # Your code here","solution":"def count_even_sum_pairs(test_cases): This function takes a list of test cases and returns a list of integers representing the count of pairs (i, j) where i <= j and the sum of the numbers at those indices is even. results = [] for n, numbers in test_cases: count_even = 0 count_odd = 0 for num in numbers: if num % 2 == 0: count_even += 1 else: count_odd += 1 # Pairs (i, j) with i <= j where both i and j are even even_pairs = count_even * (count_even + 1) // 2 # Pairs (i, j) with i <= j where both i and j are odd odd_pairs = count_odd * (count_odd + 1) // 2 results.append(even_pairs + odd_pairs) return results # Converting the input format according to the test cases format def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) numbers = list(map(int, lines[index + 1].split())) test_cases.append((n, numbers)) index += 2 return test_cases"},{"question":"def calculate_cuboid_properties(X, Y, Z): Calculate the volume and surface area of a cuboid with dimensions X, Y, and Z. Parameters: X (int): Length of the cuboid. Y (int): Width of the cuboid. Z (int): Height of the cuboid. Returns: tuple: Volume and Surface Area of the cuboid. Example: >>> calculate_cuboid_properties(3, 4, 5) (60, 94) >>> calculate_cuboid_properties(7, 8, 9) (504, 382)","solution":"def calculate_cuboid_properties(X, Y, Z): Calculate the volume and surface area of a cuboid with dimensions X, Y, and Z. Parameters: X (int): Length of the cuboid. Y (int): Width of the cuboid. Z (int): Height of the cuboid. Returns: tuple: Volume and Surface Area of the cuboid. volume = X * Y * Z surface_area = 2 * (X * Y + Y * Z + Z * X) return volume, surface_area"},{"question":"def divide_teams(T, test_cases): Determine if it is possible to evenly distribute employees into the specified number of teams. Args: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers, N and K. Returns: list: A list with the number of employees in each team if possible, or -1 if not. >>> divide_teams(4, [(10, 2), (15, 4), (30, 3), (25, 5)]) [5, -1, 10, 5] >>> divide_teams(2, [(20, 4), (15, 3)]) [5, 5] >>> divide_teams(3, [(100, 10), (99, 11), (120, 7)]) [10, 9, -1] >>> divide_teams(1, [(1, 1)]) [1] >>> divide_teams(1, [(10, 3)]) [-1]","solution":"def divide_teams(T, test_cases): Determine if it is possible to evenly distribute employees into the specified number of teams. Args: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers, N and K. Returns: list: A list with the number of employees in each team if possible, or -1 if not. results = [] for N, K in test_cases: if N % K == 0: results.append(N // K) else: results.append(-1) return results"},{"question":"def longest_improvement_streak(n: int, a: List[int]) -> int: Returns the length of the longest streak of improved performance. Args: n : int : number of days a : list of int : number of tasks completed by the employee on each day Returns: int : length of the longest streak of improved performance >>> longest_improvement_streak(10, [1, 2, 2, 3, 4, 1, 2, 3, 4, 5]) 5 >>> longest_improvement_streak(5, [5, 4, 3, 2, 1]) 1 >>> longest_improvement_streak(7, [2, 3, 1, 4, 3, 5, 6]) 3","solution":"def longest_improvement_streak(n, a): Returns the length of the longest streak of improved performance. Args: n : int : number of days a : list of int : number of tasks completed by the employee on each day Returns: int : length of the longest streak of improved performance if n == 0: return 0 max_streak = 1 current_streak = 1 for i in range(1, n): if a[i] > a[i - 1]: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 1 return max_streak"},{"question":"def maxMoney(money: List[int]) -> int: Find the maximum amount of money that can be robbed without triggering alarms. Each house has a certain amount of money, and you cannot collect money from two consecutive houses. >>> maxMoney([1, 2, 3, 1]) == 4 >>> maxMoney([2, 7, 9, 3, 1]) == 12","solution":"def maxMoney(money): Find the maximum amount of money that can be robbed without triggering alarms. :param money: List[int] - the amount of money in each house. :return: int - the maximum amount of money that can be robbed. if not money: return 0 if len(money) == 1: return money[0] N = len(money) dp = [0] * N dp[0] = money[0] if N > 1: dp[1] = max(money[0], money[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + money[i]) return dp[-1]"},{"question":"from typing import List def rearrange_beautifully(s: str) -> str: Rearranges the string \`s\` to form a beautiful string (no two adjacent characters are the same) if possible. Returns the rearranged string or \\"Not Possible\\" if no such arrangement exists. >>> rearrange_beautifully(\\"aab\\") 'aba' >>> rearrange_beautifully(\\"aaab\\") 'Not Possible'","solution":"from collections import Counter import heapq def rearrange_beautifully(s): Rearranges the string \`s\` to form a beautiful string (no two adjacent characters are the same) if possible. Returns the rearranged string or \\"Not Possible\\" if no such arrangement exists. # Count the frequency of each character char_freq = Counter(s) # Create a max heap based on character frequency max_heap = [(-freq, char) for char, freq in char_freq.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] # While there are characters in the heap while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # Since we used one occurrence of this char, we decrement the frequency by 1 if prev_char is not None and -prev_freq > 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 # Increase freq by 1 since it's stored as negative in max heap # Check if the resultant string is of the same length as the input string if len(result) != len(s): return \\"Not Possible\\" return ''.join(result)"},{"question":"def sort_timestamps(timestamps): Accepts a list of timestamps in \\"HH:MM:SS\\" format and returns the list sorted in ascending order. >>> sort_timestamps([\\"13:45:30\\", \\"09:15:45\\", \\"23:59:59\\", \\"00:00:01\\", \\"13:45:31\\"]) == [\\"00:00:01\\", \\"09:15:45\\", \\"13:45:30\\", \\"13:45:31\\", \\"23:59:59\\"] >>> sort_timestamps([\\"01:01:01\\", \\"01:01:01\\", \\"01:01:01\\"]) == [\\"01:01:01\\", \\"01:01:01\\", \\"01:01:01\\"] >>> sort_timestamps([\\"12:34:56\\"]) == [\\"12:34:56\\"] >>> sort_timestamps([\\"23:59:59\\", \\"00:00:01\\", \\"12:30:45\\", \\"06:58:10\\", \\"15:45:20\\"]) == [\\"00:00:01\\", \\"06:58:10\\", \\"12:30:45\\", \\"15:45:20\\", \\"23:59:59\\"] >>> sort_timestamps([\\"10:10:10\\", \\"00:00:00\\", \\"00:00:01\\", \\"23:59:58\\", \\"23:59:59\\"]) == [\\"00:00:00\\", \\"00:00:01\\", \\"10:10:10\\", \\"23:59:58\\", \\"23:59:59\\"] pass from solution import sort_timestamps def test_sort_timestamps(): assert sort_timestamps([ \\"13:45:30\\", \\"09:15:45\\", \\"23:59:59\\", \\"00:00:01\\", \\"13:45:31\\" ]) == [ \\"00:00:01\\", \\"09:15:45\\", \\"13:45:30\\", \\"13:45:31\\", \\"23:59:59\\" ] def test_sort_timestamps_all_same(): assert sort_timestamps([ \\"01:01:01\\", \\"01:01:01\\", \\"01:01:01\\", ]) == [ \\"01:01:01\\", \\"01:01:01\\", \\"01:01:01\\" ] def test_sort_timestamps_single(): assert sort_timestamps([ \\"12:34:56\\", ]) == [ \\"12:34:56\\" ] def test_sort_timestamps_random_order(): assert sort_timestamps([ \\"23:59:59\\", \\"00:00:01\\", \\"12:30:45\\", \\"06:58:10\\", \\"15:45:20\\" ]) == [ \\"00:00:01\\", \\"06:58:10\\", \\"12:30:45\\", \\"15:45:20\\", \\"23:59:59\\" ] def test_sort_timestamps_edge_cases(): assert sort_timestamps([ \\"10:10:10\\", \\"00:00:00\\", \\"00:00:01\\", \\"23:59:58\\", \\"23:59:59\\", ]) == [ \\"00:00:00\\", \\"00:00:01\\", \\"10:10:10\\", \\"23:59:58\\", \\"23:59:59\\" ]","solution":"def sort_timestamps(timestamps): Accepts a list of timestamps in \\"HH:MM:SS\\" format and returns the list sorted in ascending order. return sorted(timestamps) # Sample usage if __name__ == \\"__main__\\": n = int(input()) timestamps = [input().strip() for _ in range(n)] sorted_timestamps = sort_timestamps(timestamps) for ts in sorted_timestamps: print(ts)"},{"question":"def longest_subsequence_length(N: int, K: int, arr: List[int]) -> int: Returns the length of the longest subsequence such that the sum of any two elements in this subsequence is not divisible by a given integer K. >>> longest_subsequence_length(6, 4, [19, 10, 12, 24, 25, 22]) 3 >>> longest_subsequence_length(1, 3, [7]) 1 >>> longest_subsequence_length(5, 3, [3, 6, 9, 12, 15]) 1 >>> longest_subsequence_length(5, 5, [1, 2, 3, 4, 5]) 3 >>> longest_subsequence_length(10, 3, [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]) 1 >>> longest_subsequence_length(8, 4, [1, 2, 3, 5, 7, 8, 10, 11]) 5 >>> longest_subsequence_length(5, 1, [2, 4, 6, 8, 10]) 1","solution":"def longest_subsequence_length(N, K, arr): Returns the length of the longest subsequence such that the sum of any two elements in this subsequence is not divisible by K. # Frequency array to count the modulo K values freq = [0] * K # Fill the frequency array with counts of each modulo K value for num in arr: freq[num % K] += 1 # Start by picking at most one element from the group where num % K == 0 count = min(freq[0], 1) # Loop from 1 to K // 2 and try to pick the most elements between i and K - i for i in range(1, (K // 2) + 1): if i != K - i: count += max(freq[i], freq[K - i]) else: count += 1 return count # Example usage # Sample Input: 6 4 [19, 10, 12, 24, 25, 22] # Expected Output: 3"},{"question":"from typing import List, Tuple def find_shortest_paths(n: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Compute the shortest path distance between each pair of cities using the provided road network. Args: n (int): The number of cities. roads (List[Tuple[int, int, int]]): A list of roads represented as tuples (u, v, w) where u is the starting city, v is the destination city, and w is the length of the road. queries (List[Tuple[int, int]]): A list of queries represented as tuples (a, b) where a is the starting city, and b is the destination city. Returns: List[int]: A list of shortest distances for each query. If there is no path between two cities, the distance for that query should be -1. Example: >>> n = 6 >>> roads = [(0, 1, 2), (1, 2, 3), (2, 3, 1), (3, 4, 5), (4, 5, 2), (1, 5, 10)] >>> queries = [(0, 5), (2, 4), (0, 4)] >>> find_shortest_paths(n, roads, queries) [12, 6, 11] pass def test_find_shortest_paths_simple(): n = 6 roads = [(0, 1, 2), (1, 2, 3), (2, 3, 1), (3, 4, 5), (4, 5, 2), (1, 5, 10)] queries = [(0, 5), (2, 4), (0, 4)] assert find_shortest_paths(n, roads, queries) == [12, 6, 11] def test_find_shortest_paths_no_path(): n = 4 roads = [(0, 1, 4), (2, 3, 1)] queries = [(0, 2), (1, 3)] assert find_shortest_paths(n, roads, queries) == [-1, -1] def test_find_shortest_paths_direct_paths(): n = 5 roads = [(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 0, 1)] queries = [(0, 1), (1, 2), (3, 4)] assert find_shortest_paths(n, roads, queries) == [1, 1, 1] def test_find_shortest_paths_self_loops(): n = 3 roads = [(0, 0, 5), (1, 1, 10), (2, 2, 15)] queries = [(0, 0), (1, 1), (2, 2)] assert find_shortest_paths(n, roads, queries) == [0, 0, 0] def test_find_shortest_paths_large_graph(): n = 100 roads = [(i, (i + 1) % n, 1) for i in range(n)] queries = [(0, 99), (50, 75), (75, 50)] assert find_shortest_paths(n, roads, queries) == [99, 25, 75]","solution":"from typing import List, Tuple import heapq def find_shortest_paths(n: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: # Create adjacency list graph = {i: [] for i in range(n)} for u, v, w in roads: graph[u].append((v, w)) def dijkstra(start, end): min_heap = [(0, start)] visited = set() distances = {i: float('inf') for i in range(n)} distances[start] = 0 while min_heap: current_distance, current_node = heapq.heappop(min_heap) if current_node in visited: continue visited.add(current_node) if current_node == end: return current_distance for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return float('inf') results = [] for (a, b) in queries: shortest_distance = dijkstra(a, b) if shortest_distance == float('inf'): results.append(-1) else: results.append(shortest_distance) return results"},{"question":"def compress_sequence(n: int, array: List[int]) -> List[int]: Compresses the sequence by combining consecutive duplicate numbers and representing the count of each combination. Parameters: n (int): The length of the array. array (list of int): The array elements. Returns: list of int: The compressed sequence in the format where each unique number is followed by the count of its consecutive occurrences. >>> compress_sequence(6, [1, 1, 2, 2, 2, 3]) [1, 2, 2, 3, 3, 1] >>> compress_sequence(5, [4, 4, 4, 4, 4]) [4, 5] >>> compress_sequence(8, [1, 2, 2, 3, 3, 3, 4, 4]) [1, 1, 2, 2, 3, 3, 4, 2] >>> compress_sequence(1, [5]) [5, 1] >>> compress_sequence(4, [1, 2, 3, 4]) [1, 1, 2, 1, 3, 1, 4, 1] >>> compress_sequence(3, [7, 7, 7]) [7, 3] >>> compress_sequence(0, []) [] pass","solution":"def compress_sequence(n, array): Compresses the sequence by combining consecutive duplicate numbers and representing the count of each combination. Parameters: n (int): The length of the array. array (list of int): The array elements. Returns: list of int: The compressed sequence in the format where each unique number is followed by the count of its consecutive occurrences. if n == 0: return [] compressed = [] current_num = array[0] count = 1 for i in range(1, n): if array[i] == current_num: count += 1 else: compressed.append(current_num) compressed.append(count) current_num = array[i] count = 1 compressed.append(current_num) compressed.append(count) return compressed"},{"question":"def find_heaviest_pumpkins(datasets): This function takes a list of string datasets, each representing weights of pumpkins. Returns a list of tuples where each tuple contains the heaviest and the second heaviest pumpkin weights. def format_output(results): This function formats the output from the find_heaviest_pumpkins function to the required output format. import pytest def test_find_heaviest_pumpkins(): datasets = [\\"155 200 123 301 276\\", \\"450 123 789 656 341\\"] results = find_heaviest_pumpkins(datasets) assert results == [(301, 276), (789, 656)] def test_find_heaviest_pumpkins_with_single_dataset(): datasets = [\\"155 200 123 301 276\\"] results = find_heaviest_pumpkins(datasets) assert results == [(301, 276)] def test_find_heaviest_pumpkins_with_zero(): datasets = [\\"155 200 123 301 276\\", \\"450 123 789 656 341\\", \\"0\\"] results = find_heaviest_pumpkins(datasets) assert results == [(301, 276), (789, 656)] def test_format_output(capfd): results = [(301, 276), (789, 656)] format_output(results) out, err = capfd.readouterr() assert out == \\"301n276n789n656n\\" if __name__ == \\"__main__\\": pytest.main([\\"-v\\", \\"test_solution.py\\"])","solution":"def find_heaviest_pumpkins(datasets): This function takes a list of string datasets, each representing weights of pumpkins. Returns a list of tuples where each tuple contains the heaviest and the second heaviest pumpkin weights. results = [] for data in datasets: if data == \\"0\\": break weights = list(map(int, data.split())) weights.sort(reverse=True) heaviest, second_heaviest = weights[0], weights[1] results.append((heaviest, second_heaviest)) return results def format_output(results): This function formats the output from the find_heaviest_pumpkins function to the required output format. for res in results: print(res[0]) print(res[1])"},{"question":"def merge_sorted_lists(n: int, a: List[int], b: List[int]) -> List[int]: Merges two sorted lists 'a' and 'b' of length 'n' each into a single list 'c' in non-decreasing order. Args: n (int): The length of the lists 'a' and 'b'. a (List[int]): The first sorted list. b (List[int]): The second sorted list. Returns: List[int]: The merged list in non-decreasing order. >>> merge_sorted_lists(3, [1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists(4, [1, 2, 2, 2], [1, 1, 2, 2]) [1, 1, 1, 2, 2, 2, 2, 2] >>> merge_sorted_lists(5, [1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) [1, 2, 3, 4, 5, 5, 6, 7, 8, 9] pass def merged_lists_for_tests(input_data: List[int]) -> List[List[int]]: Processes multiple test cases and returns the results for each. Args: input_data (List[int]): The test cases input data. Returns: List[List[int]]: The merged lists for each test case. >>> input_data = [ ... 3, ... 3, [1, 3, 5], [2, 4, 6], ... 4, [1, 2, 2, 2], [1, 1, 2, 2], ... 5, [1, 2, 3, 4, 5], [5, 6, 7, 8, 9] ... ] >>> merged_lists_for_tests(input_data) [ [1, 2, 3, 4, 5, 6], [1, 1, 1, 2, 2, 2, 2, 2], [1, 2, 3, 4, 5, 5, 6, 7, 8, 9] ] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def merge_sorted_lists(n, a, b): Merges two sorted lists 'a' and 'b' of length 'n' each into a single list 'c' in non-decreasing order. c = [] i, j = 0, 0 while i < n and j < n: if a[i] <= b[j]: c.append(a[i]) i += 1 else: c.append(b[j]) j += 1 while i < n: c.append(a[i]) i += 1 while j < n: c.append(b[j]) j += 1 return c def merged_lists_for_tests(input_data): Processes multiple test cases and returns the results for each. results = [] t = input_data[0] index = 1 for _ in range(t): n = input_data[index] a = input_data[index + 1] b = input_data[index + 2] index += 3 result = merge_sorted_lists(n, a, b) results.append(result) return results"},{"question":"def can_participate_in_contest(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[str]: Check if there is a non-decreasing subsequence of length K in the list of ingredients. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int], int]]): List of tuples where each tuple contains: - An integer N, the number of ingredients. - A list of N integers representing the quality values of the ingredients. - An integer K, the minimum required length of the non-decreasing sub-sequence. Returns: List[str]: List of 'YES' or 'NO' for each test case. >>> can_participate_in_contest(2, [(5, [1, 3, 2, 4, 5], 3), (4, [4, 3, 2, 1], 2)]) ['YES', 'NO'] >>> can_participate_in_contest(1, [(4, [1, 1, 1, 1], 3)]) ['YES']","solution":"def can_participate_in_contest(T, test_cases): def longest_non_decreasing_subsequence_length(arr): n = len(arr) # Initialize the dp array where dp[i] will hold the length of LNDS ending at i dp = [1] * n # Fill dp array for i in range(1, n): for j in range(0, i): if arr[i] >= arr[j]: dp[i] = max(dp[i], dp[j] + 1) # Return the maximum value in dp array return max(dp) results = [] for i in range(T): N, ingredients, K = test_cases[i] lnds_length = longest_non_decreasing_subsequence_length(ingredients) if lnds_length >= K: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_arrange_leds(test_cases): Determines if it's possible to rearrange the LED strings into a valid alternating configuration by changing the state of at most one LED string. Parameters: test_cases (list): A list of tuples containing the number of strings (n) and the initial states (leds). Returns: list: A list of strings \\"Yes\\" or \\"No\\" for each test case indicating if the rearrangement is possible. Example: >>> can_arrange_leds([(5, [1, 0, 1, 1, 0]), (4, [0, 0, 0, 0]), (6, [1, 1, 0, 1, 0, 1])]) [\\"Yes\\", \\"No\\", \\"Yes\\"] pass def process_input(input_string): Processes the input string and converts it into a list of test cases. Parameters: input_string (str): The input string containing the number of test cases and the LED configurations. Returns: list: A list of tuples containing the number of strings (n) and the initial states (leds). pass def main(input_string): Main function to execute the process and determine the rearrangement possibility. Parameters: input_string (str): The input string containing the number of test cases and the LED configurations. Returns: list: A list of strings \\"Yes\\" or \\"No\\" for each test case indicating if the rearrangement is possible. Example: >>> main(\\"3n5n1 0 1 1 0n4n0 0 0 0n6n1 1 0 1 0 1\\") [\\"Yes\\", \\"No\\", \\"Yes\\"] pass def test_example_case(): input_string = \\"3n5n1 0 1 1 0n4n0 0 0 0n6n1 1 0 1 0 1\\" expected_output = [\\"Yes\\", \\"No\\", \\"Yes\\"] assert main(input_string) == expected_output def test_single_led(): input_string = \\"2n1n0n1n1\\" expected_output = [\\"Yes\\", \\"Yes\\"] assert main(input_string) == expected_output def test_two_leds(): input_string = \\"2n2n0 0n2n1 0\\" expected_output = [\\"Yes\\", \\"Yes\\"] assert main(input_string) == expected_output def test_all_same_leds(): input_string = \\"1n5n1 1 1 1 1\\" expected_output = [\\"No\\"] assert main(input_string) == expected_output def test_alternate_leds(): input_string = \\"1n4n1 0 1 0\\" expected_output = [\\"Yes\\"] assert main(input_string) == expected_output def test_max_one_change_needed(): input_string = \\"1n6n0 1 0 0 1 0\\" expected_output = [\\"Yes\\"] assert main(input_string) == expected_output def test_no_change_needed(): input_string = \\"1n10n1 0 1 0 1 0 1 0 1 0\\" expected_output = [\\"Yes\\"] assert main(input_string) == expected_output","solution":"def can_arrange_leds(test_cases): results = [] for n, leds in test_cases: count_not_alternating = 0 for i in range(n - 1): if leds[i] == leds[i + 1]: count_not_alternating += 1 if count_not_alternating > 1: results.append(\\"No\\") break else: results.append(\\"Yes\\") return results def process_input(input_string): input_lines = input_string.strip().split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) leds = list(map(int, input_lines[index + 1].split())) test_cases.append((n, leds)) index += 2 return test_cases def main(input_string): test_cases = process_input(input_string) return can_arrange_leds(test_cases)"},{"question":"def count_flower_spots(test_cases): Computes the number of spots that contain the requested flower type and can be reached from the given starting spot. Args: test_cases (list): A list of dictionaries with the following keys: - 'spots': Number of spots (int) - 'pathways': Number of pathways (int) - 'flower_data': A list of tuples where each tuple contains a spot and its respective flower types (tuple) - 'pathways_list': A list of tuples where each tuple represents a pathway connecting two spots (tuple) - 'queries': A list of tuples where each tuple contains a flower type and a starting spot (tuple) Returns: list: A list of integers representing the results for each query. Example: >>> test_cases = [ ... { ... 'spots': 4, ... 'pathways': 3, ... 'flower_data': [ ... ('A', 1, 2), ... ('B', 2, 3), ... ('C', 1, 4), ... ('D', 3, 4) ... ], ... 'pathways_list': [ ... ('A', 'B'), ... ('A', 'C'), ... ('C', 'D') ... ], ... 'queries': [ ... (1, 'A'), ... (3, 'B') ... ] ... } ... ] >>> count_flower_spots(test_cases) [2, 2] pass # Unit tests import pytest def test_example_case(): test_cases = [ { 'spots': 4, 'pathways': 3, 'flower_data': [ ('A', 1, 2), ('B', 2, 3), ('C', 1, 4), ('D', 3, 4) ], 'pathways_list': [ ('A', 'B'), ('A', 'C'), ('C', 'D') ], 'queries': [ (1, 'A'), (3, 'B') ] } ] output = count_flower_spots(test_cases) assert output == [2, 2] def test_no_connections(): test_cases = [ { 'spots': 3, 'pathways': 0, 'flower_data': [ ('A', 1), ('B', 2), ('C', 3) ], 'pathways_list': [], 'queries': [ (1, 'A'), (2, 'B') ] } ] output = count_flower_spots(test_cases) assert output == [1, 1] def test_all_connected(): test_cases = [ { 'spots': 3, 'pathways': 3, 'flower_data': [ ('A', 1), ('B', 1), ('C', 1) ], 'pathways_list': [ ('A', 'B'), ('A', 'C'), ('B', 'C') ], 'queries': [ (1, 'A') ] } ] output = count_flower_spots(test_cases) assert output == [3] def test_no_flowers(): test_cases = [ { 'spots': 3, 'pathways': 2, 'flower_data': [ ('A',), ('B',), ('C',) ], 'pathways_list': [ ('A', 'B'), ('B', 'C') ], 'queries': [ (1, 'A') ] } ] output = count_flower_spots(test_cases) assert output == [0]","solution":"def count_flower_spots(test_cases): def dfs(graph, node, visited): stack = [node] result = set() while stack: loc = stack.pop() if loc not in visited: visited.add(loc) result.add(loc) stack.extend(graph[loc] - visited) return result results = [] for test in test_cases: s, p = test['spots'], test['pathways'] flower_data = test['flower_data'] pathways = test['pathways_list'] queries = test['queries'] flower_info = {} for data in flower_data: spot, *flowers = data flower_info[spot] = set(map(int, flowers)) graph = {spot: set() for spot in flower_info} for path in pathways: u, v = path graph[u].add(v) graph[v].add(u) for query in queries: flower_type, start_spot = query visited = set() reachable_spots = dfs(graph, start_spot, visited) count = sum(1 for spot in reachable_spots if flower_type in flower_info[spot]) results.append(count) return results # Example usage test_cases = [ { 'spots': 4, 'pathways': 3, 'flower_data': [ ('A', 1, 2), ('B', 2, 3), ('C', 1, 4), ('D', 3, 4) ], 'pathways_list': [ ('A', 'B'), ('A', 'C'), ('C', 'D') ], 'queries': [ (1, 'A'), (3, 'B') ] } ] output = count_flower_spots(test_cases) print(output) # Expected output: [2, 2]"},{"question":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks. Parameters: tasks (list of tuple): A list of tuples where each tuple contains two integers (start time, end time). Returns: int: The maximum number of non-overlapping tasks. >>> max_non_overlapping_tasks([(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_tasks([(1, 2), (3, 4), (0, 6), (5, 7)]) 3","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks. Parameters: tasks (list of tuple): A list of tuples where each tuple contains two integers (start time, end time). Returns: int: The maximum number of non-overlapping tasks. # Sort tasks by their end time tasks.sort(key=lambda x: x[1]) max_tasks = 0 last_end_time = 0 for start_time, end_time in tasks: if start_time >= last_end_time: max_tasks += 1 last_end_time = end_time return max_tasks"},{"question":"def max_total_energy(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: Determine the maximum total energy that can be harnessed by stepping on the stones according to the rules. Each test case in \`test_cases\` dict contains: - 'N': number of stones - 'D': maximum distance within which energy can be transferred - 'power_values': list of power values of stones >>> max_total_energy(2, [ ... {'N': 5, 'D': 2, 'power_values': [1, 2, 3, 4, 5]}, ... {'N': 3, 'D': 1, 'power_values': [10, 20, 30]} ... ]) [15, 60] >>> max_total_energy(1, [ ... {'N': 1, 'D': 1, 'power_values': [100]} ... ]) [100]","solution":"def max_total_energy(T, test_cases): results = [] for i in range(T): N, D = test_cases[i]['N'], test_cases[i]['D'] power_values = test_cases[i]['power_values'] dp = [0] * N for j in range(N): dp[j] = power_values[j] if j > 0: dp[j] += dp[j-1] if j > D: dp[j] = max(dp[j], dp[j-D-1] + power_values[j]) results.append(dp[-1]) return results"},{"question":"def min_operations(s1: str, s2: str) -> int: Computes the minimum number of operations required to convert s1 into s2. Operations allowed are insertions, deletions, and replacements. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"abc\\", \\"def\\") 3 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3","solution":"def min_operations(s1: str, s2: str) -> int: Computes the minimum number of operations required to convert s1 into s2. Operations allowed are insertions, deletions, and replacements. m, n = len(s1), len(s2) # Create a DP table to store the results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the dp table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If s1 is empty, insert all characters of s2 elif j == 0: dp[i][0] = i # If s2 is empty, remove all characters of s1 elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If characters are the same else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def is_balanced(expression: str) -> str: Determines if the given expression has balanced brackets. Parameters: expression (str): The input string containing brackets. Returns: str: \\"YES\\" if the expression is balanced, \\"NO\\" otherwise. >>> is_balanced(\\"{[()]}\\") \\"YES\\" >>> is_balanced(\\"{[(])}\\") \\"NO\\"","solution":"def is_balanced(expression): Determines if the given expression has balanced brackets. Parameters: expression (str): The input string containing brackets. Returns: str: \\"YES\\" if the expression is balanced, \\"NO\\" otherwise. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in expression: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if stack == [] or bracket_map[char] != stack.pop(): return \\"NO\\" else: continue # in case expression contains characters other than brackets return \\"YES\\" if stack == [] else \\"NO\\""},{"question":"from typing import List, Tuple, Dict def labyrinth_challenge(datasets: List[Dict[str, any]]) -> List[str]: Determine if the robot can visit all the specified chambers in a specific order starting from an initial chamber given its battery constraints. Each dataset is in the following format: n m B # Number of chambers, number of direct connections, battery units available c1 # Initial chamber k c2 c3 ... ck # Sequence of chambers to be visited a1 b1 # Direct connections between chambers a2 b2 ... am bm An example dataset: [ { \\"n\\": 5, \\"m\\": 4, \\"B\\": 10, \\"c1\\": 1, \\"targets\\": [3, 2, 5, 4], \\"connections\\": [(1, 2), (3, 1), (5, 3), (4, 5)] } ] pass def test_labyrinth_challenge(): datasets = [ { \\"n\\": 5, \\"m\\": 4, \\"B\\": 10, \\"c1\\": 1, \\"targets\\": [3, 2, 5, 4], \\"connections\\": [(1, 2), (3, 1), (5, 3), (4, 5)] }, { \\"n\\": 3, \\"m\\": 2, \\"B\\": 3, \\"c1\\": 1, \\"targets\\": [2, 3], \\"connections\\": [(1, 2), (2, 3)] }, { \\"n\\": 0, \\"m\\": 0, \\"B\\": 0, \\"c1\\": 0, \\"targets\\": [], \\"connections\\": [] } ] expected_outputs = [\\"Possible\\", \\"Possible\\", \\"Impossible\\"] assert labyrinth_challenge(datasets) == expected_outputs def test_insufficient_battery(): datasets = [ { \\"n\\": 5, \\"m\\": 4, \\"B\\": 2, \\"c1\\": 1, \\"targets\\": [3, 2, 5], \\"connections\\": [(1, 2), (3, 1), (5, 3), (4, 5)] } ] expected_output = [\\"Impossible\\"] assert labyrinth_challenge(datasets) == expected_output def test_no_connections(): datasets = [ { \\"n\\": 1, \\"m\\": 0, \\"B\\": 1, \\"c1\\": 1, \\"targets\\": [], \\"connections\\": [] } ] expected_output = [\\"Possible\\"] assert labyrinth_challenge(datasets) == expected_output def test_disconnected_chambers(): datasets = [ { \\"n\\": 5, \\"m\\": 2, \\"B\\": 10, \\"c1\\": 1, \\"targets\\": [3], \\"connections\\": [(1, 2), (4, 5)] } ] expected_output = [\\"Impossible\\"] assert labyrinth_challenge(datasets) == expected_output","solution":"def is_possible(n, m, B, c1, targets, connections): from collections import defaultdict, deque graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) if n == 0: return \\"Impossible\\" sequence = [c1] + targets def bfs_distance(start, end): if start == end: return 0 queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: node, distance = queue.popleft() for neighbor in graph[node]: if neighbor == end: return distance + 1 if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return float('inf') total_distance = 0 for i in range(len(sequence) - 1): distance = bfs_distance(sequence[i], sequence[i + 1]) total_distance += distance if total_distance > B: return \\"Impossible\\" return \\"Possible\\" def labyrinth_challenge(datasets): result = [] for dataset in datasets: n, m, B = dataset['n'], dataset['m'], dataset['B'] c1 = dataset['c1'] targets = dataset['targets'] connections = dataset['connections'] result.append(is_possible(n, m, B, c1, targets, connections)) return result"},{"question":"def text_editor(operations): Implements a simple text editor with undo and redo functionality. The text editor supports the following operations: - append(str) : add the string \`str\` to the end of the document. - delete(n) : remove the last \`n\` characters from the document. - undo() : undo the last performed operation that is not already undone. - redo() : redo the last undone operation that hasn't been redone. Parameters: operations (List[str]): List of operations to be performed on the text editor. Returns: str: The final state of the document. Examples: >>> text_editor([\\"append(hello)\\"]) \\"hello\\" >>> text_editor([\\"append(hello)\\", \\"append( world)\\"]) \\"hello world\\" >>> text_editor([\\"append(hello)\\", \\"delete(3)\\"]) \\"he\\" >>> text_editor([\\"append(hello)\\", \\"delete(3)\\", \\"undo()\\"]) \\"hello\\" >>> text_editor([\\"append(hello)\\", \\"delete(3)\\", \\"undo()\\", \\"redo()\\"]) \\"he\\" >>> text_editor([\\"append(hello)\\",\\"append( world)\\",\\"delete(6)\\",\\"undo()\\",\\"redo()\\"]) \\"hello\\"","solution":"def text_editor(operations): document = \\"\\" history = [] undone = [] for operation in operations: if operation.startswith(\\"append(\\"): string = operation[7:-1] history.append((operation, document)) document += string undone = [] elif operation.startswith(\\"delete(\\"): n = int(operation[7:-1]) history.append((operation, document)) document = document[:-n] undone = [] elif operation == \\"undo()\\": if history: last_op, last_doc = history.pop() undone.append((last_op, document)) document = last_doc elif operation == \\"redo()\\": if undone: last_undone_op, last_undone_doc = undone.pop() history.append((last_undone_op, document)) if last_undone_op.startswith(\\"append(\\"): string = last_undone_op[7:-1] document += string elif last_undone_op.startswith(\\"delete(\\"): n = int(last_undone_op[7:-1]) document = document[:-n] return document"},{"question":"def hamming_distance(str1, str2): Calculate the Hamming distance between two strings of equal length. >>> hamming_distance(\\"karolin\\", \\"kathrin\\") 3 >>> hamming_distance(\\"1011101\\", \\"1001001\\") 2 >>> hamming_distance(\\"PPP\\", \\"PPP\\") 0 >>> hamming_distance(\\"abcd\\", \\"abcd\\") 0 >>> hamming_distance(\\"abcd\\", \\"abcf\\") 1 >>> hamming_distance(\\"abcdef\\", \\"ghijkl\\") 6 >>> hamming_distance(\\"\\", \\"\\") 0 # Your code here # Example usages: #print(hamming_distance(\\"karolin\\", \\"kathrin\\")) # => 3 #print(hamming_distance(\\"1011101\\", \\"1001001\\")) # => 2","solution":"def hamming_distance(str1, str2): Returns the Hamming distance between two strings of equal length. if len(str1) != len(str2): raise ValueError(\\"Strings must be of equal length\\") distance = sum(1 for x, y in zip(str1, str2) if x != y) return distance"},{"question":"def find_champion(n: int, skills: List[int]) -> int: Predicts the champion of a single-elimination chess tournament. Args: n : int : number of players skills : list : list of distinct skill levels of players Returns: int : skill level of the champion Examples: >>> find_champion(4, [1500, 2000, 1800, 1700]) 2000 >>> find_champion(5, [1200, 1500, 1800, 1400, 1300]) 1800 >>> find_champion(3, [3000, 2500, 2700]) 3000","solution":"def find_champion(n, skills): Predicts the champion of a single-elimination chess tournament. Args: n : int : number of players skills : list : list of distinct skill levels of players Returns: int : skill level of the champion while len(skills) > 1: next_round = [] skills.sort(reverse=True) for i in range(0, len(skills) - 1, 2): next_round.append(max(skills[i], skills[i + 1])) if len(skills) % 2 == 1: next_round.append(skills[-1]) skills = next_round return skills[0]"},{"question":"def rearrange_array(a: List[int]) -> Union[List[int], int]: Rearranges array \`a\` such that no two adjacent elements have the same parity. Returns the rearranged array \`b\`, or -1 if not possible. >>> rearrange_array([1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> rearrange_array([1, 2, 3, 4, 7]) [1, 4, 3, 2, 7] >>> rearrange_array([1]) [1] >>> rearrange_array([2]) [2] >>> rearrange_array([1, 3, 5]) -1 >>> rearrange_array([2, 4, 6, 8]) -1 pass","solution":"def rearrange_array(a): Rearranges array \`a\` such that no two adjacent elements have the same parity. Returns the rearranged array \`b\`, or -1 if not possible. odd = [x for x in a if x % 2 != 0] even = [x for x in a if x % 2 == 0] if abs(len(odd) - len(even)) > 1: return -1 b = [] if len(odd) > len(even): b = odd remaining = even else: b = even remaining = odd # Interleave the remaining elements result = [] for i in range(len(remaining)): result.append(b[i]) result.append(remaining[i]) if len(b) > len(remaining): result.append(b[-1]) return result"},{"question":"def can_escape_maze(m, n, maze): Determine if there exists a path from the start cell to the end cell in the maze. >>> can_escape_maze(5, 5, [\\"S...#\\", \\"..#.#\\", \\"..#.#\\", \\".....\\", \\"#...E\\"]) 'YES' >>> can_escape_maze(4, 4, [\\"S.\\", \\".#..\\", \\".#E.\\", \\"..\\"]) 'NO' For the sample input and tests, you can use the following code snippets: def test_can_escape_maze_yes(): m = 5 n = 5 maze = [ \\"S...#\\", \\"..#.#\\", \\"..#.#\\", \\".....\\", \\"#...E\\" ] assert can_escape_maze(m, n, maze) == \\"YES\\" def test_can_escape_maze_no(): m = 4 n = 4 maze = [ \\"S.\\", \\".#..\\", \\".#E.\\", \\"..\\" ] assert can_escape_maze(m, n, maze) == \\"NO\\" def test_can_escape_maze_direct_path(): m = 3 n = 2 maze = [ \\"S.\\", \\"..\\", \\".E\\" ] assert can_escape_maze(m, n, maze) == \\"YES\\" def test_can_escape_maze_blocked_by_wall(): m = 3 n = 3 maze = [ \\"S#.\\", \\"#\\", \\".#E\\" ] assert can_escape_maze(m, n, maze) == \\"NO\\" def test_can_escape_maze_large_maze(): m = 5 n = 7 maze = [ \\"S.....#\\", \\".#.\\", \\"...#...\\", \\"#.#.#\\", \\"#...E.#\\" ] assert can_escape_maze(m, n, maze) == \\"YES\\"","solution":"def can_escape_maze(m, n, maze): def is_valid(x, y): return 0 <= x < m and 0 <= y < n and maze[x][y] != '#' def dfs(x, y): if not is_valid(x, y) or visited[x][y]: return False if maze[x][y] == 'E': return True visited[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # up, down, left, right if dfs(x + dx, y + dy): return True return False # Find start position 'S' start_x = start_y = None for i in range(m): for j in range(n): if maze[i][j] == 'S': start_x, start_y = i, j break if start_x is not None: break # Initialize visited matrix visited = [[False] * n for _ in range(m)] # Start DFS from the start position return \\"YES\\" if dfs(start_x, start_y) else \\"NO\\""},{"question":"from collections import Counter def can_form_palindrome(s: str) -> str: Determine if the given string can be rearranged to form a palindrome. Returns \\"YES\\" if it can be rearranged to form a palindrome, otherwise \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\"","solution":"from collections import Counter def can_form_palindrome(s: str) -> str: Determine if the given string can be rearranged to form a palindrome. Returns \\"YES\\" if it can be rearranged to form a palindrome, otherwise \\"NO\\". count = Counter(s) odd_counts = sum(1 for count in count.values() if count % 2 != 0) return \\"YES\\" if odd_counts <= 1 else \\"NO\\""},{"question":"def is_palindrome(s: str) -> str: Determines whether the input string s is a palindrome or not. >>> is_palindrome(\\"madam\\") 'Palindrome' >>> is_palindrome(\\"hello\\") 'Not a palindrome' >>> is_palindrome(\\"A man a plan a canal Panama\\") 'Not a palindrome'","solution":"def is_palindrome(s): Determines whether the input string s is a palindrome or not. Args: s (str): Input string to check Returns: str: 'Palindrome' if s is a palindrome, 'Not a palindrome' otherwise s = s.lower() # Consider palindromes case-insensitively if s == s[::-1]: return \\"Palindrome\\" else: return \\"Not a palindrome\\""},{"question":"def can_partition(nums: List[int]) -> bool: Determines if the input list can be partitioned into two sublists with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([1, 1, 3, 4, 7]) True >>> can_partition([2, 2, 3, 5]) False","solution":"def can_partition(nums): Determines if the input list can be partitioned into two sublists with equal sum. total_sum = sum(nums) # If the total sum is odd, we can't partition it into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 # Using dynamic programming to find if there is a subset with sum equal to half of total sum dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Write a function that takes as input a list of integers, and returns a new list such that each element at index \`i\` of the new list is the product of all the numbers in the original array except the one at \`i\`. For example, if the input is \`[1, 2, 3, 4, 5]\`, the expected output would be \`[120, 60, 40, 30, 24]\`. You should not use division in your solution. >>> product_except_self([1, 2, 3, 4, 5]) [120, 60, 40, 30, 24] >>> product_except_self([10, 3, 5, 6, 2]) [180, 600, 360, 300, 900]","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: length = len(nums) res = [1] * length left_product = 1 for i in range(length): res[i] = left_product left_product *= nums[i] right_product = 1 for i in reversed(range(length)): res[i] *= right_product right_product *= nums[i] return res"},{"question":"def matrixDiagonalSum(matrix): Returns the sum of the elements on both the diagonals of a square matrix. >>> matrixDiagonalSum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 25 >>> matrixDiagonalSum([[5]]) 5 >>> matrixDiagonalSum([ ... [1, 2], ... [3, 4] ... ]) 10 >>> matrixDiagonalSum([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) 68 >>> matrixDiagonalSum([ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]) 5","solution":"def matrixDiagonalSum(matrix): Returns the sum of the elements on both the diagonals of a square matrix. n = len(matrix) diagonal_sum = 0 for i in range(n): # Add the primary diagonal element diagonal_sum += matrix[i][i] # Add the secondary diagonal element # Check if it's the same as primary diagonal for odd length matrix if i != n - 1 - i: diagonal_sum += matrix[i][n - 1 - i] return diagonal_sum"},{"question":"def find_peak_element(nums: List[int]) -> int: Write a function \`find_peak_element\` that takes a list of integers and returns the index of a peak element. A peak element is an element that is strictly greater than its neighbors. If the list contains multiple peak elements, return the index to any of the peaks. The function should run in O(log n) time using a binary search approach. >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) 5","solution":"def find_peak_element(nums): Finds the index of a peak element in the list. A peak element is one that is greater than its neighbors. low, high = 0, len(nums) - 1 while low < high: mid = (low + high) // 2 if nums[mid] > nums[mid + 1]: high = mid else: low = mid + 1 return low"},{"question":"def find_longest_subarray_sum_less_equal_k(n, array, k): Find the smallest possible sum of the longest subarray where the sum of its elements is less than or equal to k. >>> find_longest_subarray_sum_less_equal_k(4, [1, 2, 3, 4], 6) == 6 >>> find_longest_subarray_sum_less_equal_k(5, [3, 1, 2, 1, 1], 4) == 4 >>> find_longest_subarray_sum_less_equal_k(6, [1, 2, 3, 4, 5, 6], 10) == 10 def process_test_cases(test_cases): Process multiple test cases for finding the smallest sum of the longest subarray where the sum is less than or equal to k. >>> test_cases = [(4, [1, 2, 3, 4], 6), (5, [3, 1, 2, 1, 1], 4), (6, [1, 2, 3, 4, 5, 6], 10)] >>> process_test_cases(test_cases) == [6, 4, 10] def read_input(input_string): Read input string and parse it into a list of test cases. >>> input_string = \\"3n4n1 2 3 4n6n5n3 1 2 1 1n4n6n1 2 3 4 5 6n10\\" >>> read_input(input_string) == [(4, [1, 2, 3, 4], 6), (5, [3, 1, 2, 1, 1], 4), (6, [1, 2, 3, 4, 5, 6], 10)] def main(input_string): The main function to read input, process test cases and print the results.","solution":"def find_longest_subarray_sum_less_equal_k(n, array, k): left = 0 sum_ = 0 max_length = 0 min_sum = float('inf') for right in range(n): sum_ += array[right] while sum_ > k and left <= right: sum_ -= array[left] left += 1 current_length = right - left + 1 if current_length > max_length: max_length = current_length min_sum = sum_ elif current_length == max_length: min_sum = min(min_sum, sum_) return min_sum def process_test_cases(test_cases): results = [] for case in test_cases: n, array, k = case result = find_longest_subarray_sum_less_equal_k(n, array, k) results.append(result) return results def read_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(input_lines[index]) array = list(map(int, input_lines[index+1].split())) k = int(input_lines[index+2]) test_cases.append((n, array, k)) index += 3 return test_cases def main(input_string): test_cases = read_input(input_string) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def average_speed(total_seconds, total_kilometers): Returns the average speed in meters per second (m/s) given the total time in seconds and the total distance in kilometers. >>> average_speed(3600, 10) 2.78 >>> average_speed(7200, 20) 2.78 >>> average_speed(1800, 5) 2.78 >>> average_speed(5400, 15) 2.78 def cumulative_split_times(split_times, distances): Returns a list of tuples where each tuple contains the split time and the cumulative time up to that point, both rounded to 2 decimal places. >>> cumulative_split_times([3600, 2700, 3800], [10, 7, 5]) [(3600.00, 3600.00), (2700.00, 6300.00), (3800.00, 10100.00)] >>> cumulative_split_times([1800, 1800, 1800], [5, 5, 5]) [(1800.00, 1800.00), (1800.00, 3600.00), (1800.00, 5400.00)] >>> cumulative_split_times([1200, 2400], [3, 6]) [(1200.00, 1200.00), (2400.00, 3600.00)] >>> cumulative_split_times([4500], [12.5]) [(4500.00, 4500.00)]","solution":"def average_speed(total_seconds, total_kilometers): Returns the average speed in meters per second (m/s) given the total time in seconds and the total distance in kilometers. total_meters = total_kilometers * 1000 speed = total_meters / total_seconds return round(speed, 2) def cumulative_split_times(split_times, distances): Returns a list of tuples where each tuple contains the split time and the cumulative time up to that point, both rounded to 2 decimal places. cumulative_time = 0 result = [] for time in split_times: cumulative_time += time result.append((round(time, 2), round(cumulative_time, 2))) return result"},{"question":"def findPair(arr: List[int], K: int) -> bool: Determines if there are two distinct elements in the array that add up to K. Args: arr (list): The list of integers. K (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. >>> findPair([10, 15, 3, 7], 17) True >>> findPair([1, 2, 3, 9], 8) False >>> findPair([10], 10) False >>> findPair([1, 2, 4, 5], 10) False >>> findPair([1, 2, 3, 4, 5], 7) True >>> findPair([100000, 50000, 10000, 30000, 70000], 80000) True >>> findPair([5, 5, 5, 5], 10) True >>> findPair([-1, -2, -3, -4, 4], 3) True >>> findPair([-1, -2, -3, -4], -3) True","solution":"def findPair(arr, K): Determines if there are two distinct elements in the array that add up to K. Args: arr (list): The list of integers. K (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if K - num in seen: return True seen.add(num) return False"},{"question":"def minimum_transmission_time(N: int, M: int, links: list, A: int, B: int) -> int: Calculates the minimum time required to transmit a file from server A to server B. Parameters: N (int): Number of servers. M (int): Number of communication links. links (list of tuples): Each tuple (U, V, C) represents a bidirectional link with cost C between server U and server V. A (int): Starting server. B (int): Destination server. Returns: int: The minimum transmission time in milliseconds. Returns -1 if there is no route between A and B. Test cases: >>> minimum_transmission_time(5, 6, [(1, 2, 10), (1, 3, 20), (2, 3, 5), (2, 4, 1), (3, 4, 3), (4, 5, 2)], 1, 5) 13 >>> minimum_transmission_time(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10)], 1, 4) 6 >>> minimum_transmission_time(4, 2, [(1, 2, 4), (3, 4, 6)], 1, 4) -1 >>> minimum_transmission_time(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 3)], 1, 3) 2 >>> minimum_transmission_time(2, 1, [(1, 2, 100)], 1, 2) 100 pass","solution":"import heapq def minimum_transmission_time(N, M, links, A, B): Calculates the minimum time required to transmit a file from server A to server B. Parameters: N (int): Number of servers. M (int): Number of communication links. links (list of tuples): Each tuple (U, V, C) represents a bidirectional link with cost C between server U and server V. A (int): Starting server. B (int): Destination server. Returns: int: The minimum transmission time in milliseconds. Returns -1 if there is no route between A and B. graph = {i: [] for i in range(1, N + 1)} for u, v, c in links: graph[u].append((v, c)) graph[v].append((u, c)) # Dijkstra's algorithm to find the shortest path from A to B pq = [(0, A)] dist = {i: float('inf') for i in range(1, N + 1)} dist[A] = 0 while pq: current_cost, current_node = heapq.heappop(pq) # Skip this node if a shorter path has been found if current_cost > dist[current_node]: continue for neighbor, weight in graph[current_node]: new_cost = current_cost + weight if new_cost < dist[neighbor]: dist[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return dist[B] if dist[B] != float('inf') else -1"},{"question":"from typing import List, Tuple def find_max_difference_and_min_sum_pairs(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Find the maximum difference in power values between two trees and the smallest sum of those trees if there are multiple pairs with the same difference. Arguments: t : int : number of test cases test_cases : List[Tuple[int, List[int]]] : List of test cases, each containing the number of trees and their power values. Returns: List[Tuple[int, int]] : List of results for each test case as tuples containing the maximum difference and the smallest sum. >>> find_max_difference_and_min_sum_pairs(2, [(3, [1, 5, 9]), (4, [-1, 7, 3, 9])]) [(8, 6), (10, 2)] >>> find_max_difference_and_min_sum_pairs(1, [(5, [2, 4, 8, 6, 10])]) [(8, 6)] >>> find_max_difference_and_min_sum_pairs(1, [(2, [0, 0])]) [(0, 0)] >>> find_max_difference_and_min_sum_pairs(1, [(3, [-3, -2, -1])]) [(2, -5)] >>> find_max_difference_and_min_sum_pairs(1, [(3, [1, 0, -1])]) [(2, -1)]","solution":"def find_max_difference_and_min_sum_pairs(t, test_cases): results = [] for case in test_cases: N, powers = case powers.sort() max_diff = powers[-1] - powers[0] min_sum = powers[0] + powers[1] results.append((max_diff, min_sum)) return results"},{"question":"def can_form_special_matrix(N: int, elements: List[int]) -> str: Determine if it is possible to rearrange the sequence of N^2 integers into a special N x N matrix. A square matrix is called special if the sum of the elements in each row and each column is the same. Args: N : int - the dimension of the matrix elements : list of int - the sequence of N^2 integers Returns: str - \\"Yes\\" if it is possible to rearrange into a special matrix, otherwise \\"No\\" >>> can_form_special_matrix(3, [2, 7, 6, 9, 5, 1, 4, 3, 8]) \\"Yes\\" >>> can_form_special_matrix(2, [1, 2, 3, 4]) \\"No\\" >>> can_form_special_matrix(1, [5]) \\"Yes\\" >>> can_form_special_matrix(3, [8, 1, 6, 3, 5, 7, 4, 9, 2]) \\"Yes\\" pass","solution":"def can_form_special_matrix(N, elements): Determine if it is possible to rearrange the sequence of N^2 integers into a special N x N matrix. Args: N : int - the dimension of the matrix elements : list of int - the sequence of N^2 integers Returns: str - \\"Yes\\" if it is possible to rearrange into a special matrix, otherwise \\"No\\" from itertools import permutations target_sum = sum(elements) // N # This is the target sum for each row/column def is_special_matrix(matrix): for row in matrix: if sum(row) != target_sum: return False for col in zip(*matrix): if sum(col) != target_sum: return False return True # Try all permutations to see if any can form a special matrix for perm in permutations(elements): matrix = [perm[i * N:(i + 1) * N] for i in range(N)] if is_special_matrix(matrix): return \\"Yes\\" return \\"No\\" # Example usage (though not part of the function to be tested): # print(can_form_special_matrix(3, [2, 7, 6, 9, 5, 1, 4, 3, 8])) # Expected \\"Yes\\""},{"question":"def longest_consecutive_subsequence(arr): Given an array of integers, find the length of the longest subsequence that consists of consecutive integers in sorted order. >>> longest_consecutive_subsequence([1, 3, 2, 2, 4, 3]) 4 >>> longest_consecutive_subsequence([10, 12, 11, 14, 15]) 3 >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([]) 0 pass def process_test_cases(test_cases): Process multiple test cases and return the results for each. >>> test_cases = [ ... (6, [1, 3, 2, 2, 4, 3]), ... (5, [10, 12, 11, 14, 15]) ... ] >>> process_test_cases(test_cases) [4, 3] >>> test_cases = [ ... (6, [100, 4, 200, 1, 3, 2]) ... ] >>> process_test_cases(test_cases) [4] >>> test_cases = [ ... (3, [1, 1, 1]), ... (4, [3, 4, 5, 6]) ... ] >>> process_test_cases(test_cases) [1, 4] pass","solution":"def longest_consecutive_subsequence(arr): if not arr: return 0 arr = sorted(set(arr)) longest_streak = 1 current_streak = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1] + 1: current_streak += 1 else: longest_streak = max(longest_streak, current_streak) current_streak = 1 longest_streak = max(longest_streak, current_streak) return longest_streak def process_test_cases(test_cases): results = [] for case in test_cases: n, arr = case results.append(longest_consecutive_subsequence(arr)) return results"},{"question":"def count_contiguous_slices(n: int, k: int, x: int) -> int: Returns the number of different ways to select k contiguous slices from a pizza with n slices, modulo x. >>> count_contiguous_slices(7, 3, 1000000007) 7 >>> count_contiguous_slices(10, 5, 1009) 10","solution":"def count_contiguous_slices(n, k, x): Returns the number of different ways to select k contiguous slices from a pizza with n slices, modulo x. # As the pizza is circular, the number of ways to pick k contiguous slices in a circular arrangement is equal to n # because each slice can serve as the starting slice once. result = n % x return result"},{"question":"from typing import List, Tuple def find_missing_task_sequence(dataset: List[Tuple[int, int, List[int]]]) -> List[int]: Given a list of datasets, each containing a base task code, number of tasks, and observed task codes, find the missing task code for each sequence. Args: dataset (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains the base task code (int), number of tasks (int), and a list of observed task codes (List[int]) Returns: List[int]: A list of missing task codes for each dataset Example: >>> find_missing_task_sequence([(5, 5, [5, 6, 7, 9]), (20, 4, [20, 21, 23]), (50, 3, [50, 52]), (0, 0, [])]) [8, 22, 51] >>> find_missing_task_sequence([(10, 3, [10, 12]), (100, 5, [100, 101, 102, 103])]) [11, 104] pass def test_find_missing_task_sequence(): # Test case 1 dataset1 = [ (5, 5, [5, 6, 7, 9]), (20, 4, [20, 21, 23]), (50, 3, [50, 52]), (0, 0, []) ] result1 = find_missing_task_sequence(dataset1) assert result1 == [8, 22, 51], f\\"Expected [8, 22, 51] but got {result1}\\" # Test case 2 dataset2 = [ (10, 3, [10, 12]), (100, 5, [100, 101, 102, 103]) ] result2 = find_missing_task_sequence(dataset2) assert result2 == [11, 104], f\\"Expected [11, 104] but got {result2}\\" # Test case 3 dataset3 = [ (1, 3, [1, 2]), (200, 4, [200, 201, 203]) ] result3 = find_missing_task_sequence(dataset3) assert result3 == [3, 202], f\\"Expected [3, 202] but got {result3}\\" # Edge case with only 1 expected task dataset4 = [ (4, 2, [4]) ] result4 = find_missing_task_sequence(dataset4) assert result4 == [5], f\\"Expected [5] but got {result4}\\" # Execute the tests test_find_missing_task_sequence()","solution":"def find_missing_task_sequence(dataset): result = [] for data in dataset: base_code, num_tasks, observed_tasks = data if base_code == 0 and num_tasks == 0: break full_sequence = set(range(base_code, base_code + num_tasks)) observed_set = set(observed_tasks) missing_code = list(full_sequence - observed_set)[0] result.append(missing_code) return result"},{"question":"def min_removals_to_palindrome(n: int, s: str) -> int: Return the minimum number of characters that need to be removed to make the string a palindrome. >>> min_removals_to_palindrome(3, \\"abc\\") 2 >>> min_removals_to_palindrome(4, \\"aabb\\") 2","solution":"def min_removals_to_palindrome(n, s): Returns the minimum number of characters that need to be removed to make the string a palindrome. def longest_palindromic_subsequence(s): # Create a table to store lengths of longest palindromic subsequence dp = [[0]*n for _ in range(n)] # Strings of length 1 are palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table. Note the bottom-up approach. for cl in range(2, n+1): for i in range(n-cl+1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # Length of the longest palindromic subsequence return dp[0][n-1] # The minimum number of removals lps_length = longest_palindromic_subsequence(s) return n - lps_length"},{"question":"class Node: def __init__(self, value=None, next_node=None): self.value = value self.next_node = next_node from typing import Tuple, List def separate_values(head: Node) -> Tuple[List[int], List[str]]: Traverse a linked list and separate the values into two arrays: one containing all the integer values and the other containing all the string values. # Examples # Creating the linked list: 1 -> 'apple' -> 2 -> 'banana' -> None >>> head = Node(1, Node('apple', Node(2, Node('banana')))) >>> separate_values(head) ([1, 2], ['apple', 'banana']) # Creating the linked list: 1 -> 2 -> 3 -> None >>> head = Node(1, Node(2, Node(3))) >>> separate_values(head) ([1, 2, 3], []) # Creating the linked list: 'apple' -> 'banana' -> 'cherry' -> None >>> head = Node('apple', Node('banana', Node('cherry'))) >>> separate_values(head) ([], ['apple', 'banana', 'cherry']) # Creating an empty linked list >>> head = None >>> separate_values(head) ([], [])","solution":"class Node: def __init__(self, value=None, next_node=None): self.value = value self.next_node = next_node from typing import Tuple, List def separate_values(head: Node) -> Tuple[List[int], List[str]]: int_values = [] str_values = [] current = head while current is not None: if isinstance(current.value, int): int_values.append(current.value) elif isinstance(current.value, str): str_values.append(current.value) current = current.next_node return int_values, str_values"},{"question":"def find_unique_element(arr): Finds the unique element in an array where every element except one appears twice. Args: arr: List[int] - List of integers with one unique element and all others appearing exactly twice. Returns: int - The unique element. # Implementation here def solve_puzzle(T, cases): Processes multiple test cases to find unique elements in given arrays. Args: T: int - Number of test cases. cases: List[Tuple[int, List[int]]] - List of tuples, where each tuple contains an integer N (number of elements) and a list of integers (elements of the array). Returns: List[int] - List of unique elements for each test case. # Implementation here # Unit test def test_find_unique_element(): assert find_unique_element([1, 2, 1]) == 2 assert find_unique_element([4, 4, 2, 3, 3]) == 2 assert find_unique_element([7, 3, 5, 3, 7]) == 5 assert find_unique_element([0, 1, 0]) == 1 assert find_unique_element([10]) == 10 def test_solve_puzzle(): T = 2 cases = [ (3, [1, 2, 1]), (5, [4, 4, 2, 3, 3]) ] assert solve_puzzle(T, cases) == [2, 2] T = 2 cases = [ (3, [7, 3, 7]), (5, [5, 5, 9, 8, 8]) ] assert solve_puzzle(T, cases) == [3, 9] def test_edge_cases(): assert find_unique_element([1]) == 1 assert solve_puzzle(1, [(1, [1])]) == [1] def test_large_input(): arr = [i for i in range(1, 1000000)] * 2 arr.append(9999991) assert find_unique_element(arr) == 9999991","solution":"def find_unique_element(arr): Finds the unique element in an array where every element except one appears twice. Args: arr: List[int] - List of integers with one unique element and all others appearing exactly twice. Returns: int - The unique element. unique_element = 0 for num in arr: unique_element ^= num return unique_element def solve_puzzle(T, cases): Processes multiple test cases to find unique elements in given arrays. Args: T: int - Number of test cases. cases: List[Tuple[int, List[int]]] - List of tuples, where each tuple contains an integer N (number of elements) and a list of integers (elements of the array). Returns: List[int] - List of unique elements for each test case. results = [] for N, arr in cases: results.append(find_unique_element(arr)) return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(edges): nodes = {} for v, l, r in edges: if v not in nodes: nodes[v] = TreeNode(val=v) if l != 0: nodes[l] = TreeNode(val=l) nodes[v].left = nodes[l] if r != 0: nodes[r] = TreeNode(val=r) nodes[v].right = nodes[r] return nodes[1] if 1 in nodes else None def diameter_of_binary_tree(root): Compute the diameter of the binary tree. def find_diameter(n, edges): Given the number of nodes and a list of edges, find the diameter of the binary tree. >>> find_diameter(5, [(1, 2, 3), (2, 4, 5), (3, 0, 0), (4, 0, 0), (5, 0, 0)]) 3 >>> find_diameter(3, [(1, 2, 0), (2, 3, 0), (3, 0, 0)]) 2 >>> find_diameter(1, [(1, 0, 0)]) 0 >>> find_diameter(5, [(1, 2, 0), (2, 3, 0), (3, 0, 0), (4, 0, 5), (5, 0, 0)]) 2 >>> find_diameter(7, [(1, 2, 3), (2, 4, 5), (3, 6, 7), (4, 0, 0), (5, 0, 0), (6, 0, 0), (7, 0, 0)]) 4 >>> find_diameter(0, []) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(edges): nodes = {} for v, l, r in edges: if v not in nodes: nodes[v] = TreeNode(val=v) if l != 0: nodes[l] = TreeNode(val=l) nodes[v].left = nodes[l] if r != 0: nodes[r] = TreeNode(val=r) nodes[v].right = nodes[r] return nodes[1] if 1 in nodes else None def diameter_of_binary_tree(root): def depth(node): nonlocal diameter if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 depth(root) return diameter def find_diameter(n, edges): root = build_tree(edges) return diameter_of_binary_tree(root)"},{"question":"def distribute_food(requests, available): Returns the remaining food portions after feeding animals according to their requests and available portions. :param requests: Dictionary with animal species as keys and list of portions requested by individual animals. :param available: Dictionary with animal species as keys and integers representing the total portions available. :return: Dictionary showing the remaining food portions for each animal species. >>> requests = { >>> \\"lion\\": [2, 3, 2], >>> \\"tiger\\": [1, 4], >>> \\"bear\\": [3, 1, 1] >>> } >>> available = { >>> \\"lion\\": 5, >>> \\"tiger\\": 5, >>> \\"bear\\": 4 >>> } >>> distribute_food(requests, available) {'lion': 0, 'tiger': 0, 'bear': 0} >>> requests = { >>> \\"lion\\": [2, 3, 2], >>> \\"tiger\\": [1, 4, 2], >>> \\"bear\\": [3, 1, 1] >>> } >>> available = { >>> \\"lion\\": 4, >>> \\"tiger\\": 5, >>> \\"bear\\": 5 >>> } >>> distribute_food(requests, available) {'lion': 2, 'tiger': 0, 'bear': 0}","solution":"def distribute_food(requests, available): Returns the remaining food portions after feeding animals according to their requests and available portions. :param requests: Dictionary with animal species as keys and list of portions requested by individual animals. :param available: Dictionary with animal species as keys and integers representing the total portions available. :return: Dictionary showing the remaining food portions for each animal species. remaining_food = {} for species, portions in requests.items(): total_available = available.get(species, 0) for request in portions: if total_available >= request: total_available -= request else: # not enough food available for a requested portion, break the loop break remaining_food[species] = total_available return remaining_food"},{"question":"from typing import List def alien_order(words: List[str]) -> str: Derive the order of characters in an alien alphabet given a list of words sorted lexicographically by the rules of the alien language. Args: words (List[str]): A list of words sorted lexicographically according to the alien language rules. Returns: str: A string representing the characters in the correct order, or \\"Impossible\\" if the order can't be determined. Examples: >>> alien_order([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) 'wertf' >>> alien_order([\\"z\\", \\"x\\"]) 'zx' >>> alien_order([\\"z\\", \\"x\\", \\"z\\"]) 'Impossible' >>> alien_order([\\"abc\\", \\"ab\\"]) 'Impossible' >>> alien_order([\\"gg\\", \\"gf\\"]) 'gf'","solution":"from collections import defaultdict, deque def alien_order(words): def build_graph(words): graph = defaultdict(set) in_degree = {char: 0 for word in words for char in word} for i in range(len(words) - 1): first, second = words[i], words[i + 1] min_len = min(len(first), len(second)) if first[:min_len] == second[:min_len] and len(first) > len(second): return {}, {} for j in range(min_len): if first[j] != second[j]: if second[j] not in graph[first[j]]: graph[first[j]].add(second[j]) in_degree[second[j]] += 1 break return graph, in_degree def topo_sort(graph, in_degree): queue = deque([node for node in in_degree if in_degree[node] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == len(in_degree): return \\"\\".join(order) else: return \\"Impossible\\" graph, in_degree = build_graph(words) if not graph and not in_degree: return \\"Impossible\\" return topo_sort(graph, in_degree)"},{"question":"def count_unique_substrings(s: str) -> int: Returns the count of unique substrings of the given string s. >>> count_unique_substrings(\\"abc\\") 6 >>> count_unique_substrings(\\"aaa\\") 3 >>> count_unique_substrings(\\"abcd\\") 10 pass def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes T test cases and returns a list with the count of unique substrings for each test case. >>> process_test_cases(3, [\\"abc\\", \\"aaa\\", \\"abcd\\"]) [6, 3, 10] >>> process_test_cases(1, [\\"a\\"]) [1] >>> process_test_cases(2, [\\"ab\\", \\"abcabc\\"]) [3, 15] pass # Test cases for validation def test_count_unique_substrings(): assert count_unique_substrings(\\"abc\\") == 6 assert count_unique_substrings(\\"aaa\\") == 3 assert count_unique_substrings(\\"abcd\\") == 10 assert count_unique_substrings(\\"a\\") == 1 assert count_unique_substrings(\\"ab\\") == 3 assert count_unique_substrings(\\"abcabc\\") == 15 def test_process_test_cases(): assert process_test_cases(3, [\\"abc\\", \\"aaa\\", \\"abcd\\"]) == [6, 3, 10] assert process_test_cases(1, [\\"a\\"]) == [1] assert process_test_cases(2, [\\"ab\\", \\"abcabc\\"]) == [3, 15] def test_corner_cases(): assert count_unique_substrings(\\"\\") == 0 assert count_unique_substrings(\\"a\\" * 100) == 100 def test_single_character_repeated(): assert count_unique_substrings(\\"bbbb\\") == 4 assert process_test_cases(1, [\\"bbbb\\"]) == [4]","solution":"def count_unique_substrings(s): Returns the count of unique substrings of the given string s. unique_subs = set() n = len(s) # Generate all possible substrings for i in range(n): for j in range(i + 1, n + 1): unique_subs.add(s[i:j]) return len(unique_subs) def process_test_cases(T, test_cases): Processes T test cases and returns a list with the count of unique substrings for each test case. results = [] for s in test_cases: results.append(count_unique_substrings(s)) return results"},{"question":"def calculate_fencing_and_midpoint(T: int, dimensions: List[Tuple[int, int]]) -> List[Tuple[int, Tuple[float, float]]]: A farmer has a rectangular field that he wants to fence from all four sides. The farmer also wants to install a water tap in the middle of the field. Given the dimensions of the field, calculate the length of fencing needed and the exact coordinates of the point where the water tap should be installed. Args: T (int): The number of test cases. dimensions (List[Tuple[int, int]]): A list of tuples, each containing two integers L and W which represent the length and width of the field respectively. Returns: List[Tuple[int, Tuple[float, float]]]: A list of tuples, each containing two values: 1. The total length of fencing needed. 2. The coordinates of the midpoint where the water tap should be installed, in the format (x, y). Examples: >>> calculate_fencing_and_midpoint(1, [(8, 5)]) [(26, (4, 2.5))] >>> calculate_fencing_and_midpoint(2, [(20, 10), (15, 17)]) [(60, (10, 5)), (64, (7.5, 8.5))]","solution":"def calculate_fencing_and_midpoint(T, dimensions): results = [] for l, w in dimensions: perimeter = 2 * (l + w) midpoint_x = l / 2 midpoint_y = w / 2 results.append((perimeter, (midpoint_x, midpoint_y))) return results"},{"question":"def min_posts_to_traverse(n, angles, start, end): Calculate the minimum number of posts that must be traversed to communicate from the starting post to the ending post in a circular layout. >>> min_posts_to_traverse(6, [10, 50, 90, 130, 170, 310], 1, 4) 4 >>> min_posts_to_traverse(5, [0, 72, 144, 216, 288], 2, 5) 3 def test_min_posts_to_traverse_example_1(): n = 6 angles = [10, 50, 90, 130, 170, 310] start = 1 end = 4 assert min_posts_to_traverse(n, angles, start, end) == 4 def test_min_posts_to_traverse_example_2(): n = 5 angles = [0, 72, 144, 216, 288] start = 2 end = 5 assert min_posts_to_traverse(n, angles, start, end) == 3 def test_min_posts_to_traverse_same_start_end(): n = 5 angles = [0, 90, 180, 270, 360] start = 1 end = 3 assert min_posts_to_traverse(n, angles, start, end) == 3 def test_min_posts_to_traverse_clockwise(): n = 4 angles = [0, 90, 180, 270] start = 4 end = 1 assert min_posts_to_traverse(n, angles, start, end) == 2 def test_min_posts_to_traverse_counter_clockwise(): n = 4 angles = [0, 90, 180, 270] start = 1 end = 3 assert min_posts_to_traverse(n, angles, start, end) == 3","solution":"def min_posts_to_traverse(n, angles, start, end): # Convert to 0-based index start -= 1 end -= 1 if start > end: start, end = end, start clockwise_path = end - start + 1 counterclockwise_path = start + (n - end) + 1 return min(clockwise_path, counterclockwise_path)"},{"question":"from itertools import combinations from typing import List, Tuple def min_queries_to_retrieve_items(k: int, test_cases: List[Tuple[int, int, List[str], List[List[str]]]]) -> List[int]: Determine the minimum number of queries required to retrieve a target list of items by combining the results of any subset of the queries. >>> min_queries_to_retrieve_items(2, [(3, 5, [\\"item1\\", \\"item2\\", \\"item3\\", \\"item4\\", \\"item5\\"], [[\\"item1\\", \\"item3\\", \\"item5\\"], [\\"item2\\", \\"item4\\"], [\\"item3\\"]]), (2, 3, [\\"item1\\", \\"item2\\", \\"item3\\"], [[\\"item1\\", \\"item2\\"], [\\"item2\\", \\"item3\\"]])]) [2, 2] >>> min_queries_to_retrieve_items(1, [(3, 4, [\\"item1\\", \\"item2\\", \\"item3\\", \\"item4\\"], [[\\"item1\\", \\"item2\\"], [\\"item3\\", \\"item4\\"], [\\"item2\\", \\"item3\\"]])]) [2] >>> min_queries_to_retrieve_items(1, [(2, 2, [\\"item1\\", \\"item2\\"], [[\\"item1\\"], [\\"item2\\"]])]) [2] >>> min_queries_to_retrieve_items(1, [(2, 2, [\\"item1\\", \\"item2\\"], [[\\"item1\\", \\"item3\\"], [\\"item2\\"]])]) [2] >>> min_queries_to_retrieve_items(1, [(2, 2, [\\"item1\\", \\"item2\\"], [[\\"item3\\"], [\\"item4\\"]])]) [-1] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, List[str], List[List[str]]]]]: Parse the input string and return the number of test cases and the test cases themselves. pass def run(input_string: str) -> List[int]: Run the solution present in min_queries_to_retrieve_items function and return the results. pass","solution":"from itertools import combinations def min_queries_to_retrieve_items(k, test_cases): result = [] for case in test_cases: n, m, target_items, queries = case target_set = set(target_items) min_queries = float('inf') found = False for i in range(1, n+1): for comb in combinations(queries, i): combined_items = set() for q in comb: combined_items.update(q) if target_set.issubset(combined_items): min_queries = min(min_queries, i) found = True if found: result.append(min_queries) else: result.append(-1) return result # Helper function to parse input def parse_input(input_string): lines = input_string.strip().split('n') k = int(lines[0]) index = 1 test_cases = [] for _ in range(k): n, m = map(int, lines[index].split()) index += 1 target_items = lines[index].split() index += 1 queries = [] for _ in range(n): items = lines[index].split()[1:] queries.append(items) index += 1 test_cases.append((n, m, target_items, queries)) return k, test_cases def run(input_string): k, test_cases = parse_input(input_string) return min_queries_to_retrieve_items(k, test_cases)"},{"question":"import re from typing import List def is_palindrome(word: str) -> bool: Check if a given word is a palindrome sequence, ignoring cases and non-alphanumeric characters. >>> is_palindrome(\\"radar\\") == True >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == True >>> is_palindrome(\\"hello\\") == False >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"12321\\") == True >>> is_palindrome(\\"12345\\") == False def check_palindrome_sequences(test_cases: List[str]) -> List[str]: Check a list of words and return 'YES' if the word is a palindrome sequence, 'NO' otherwise. >>> check_palindrome_sequences([\\"radar\\", \\"A man, a plan, a canal, Panama!\\", \\"hello\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_palindrome_sequences([\\"No lemon, no melon\\", \\"Was it a car or a cat I saw?\\", \\"12321\\", \\"not a palindrome\\"]) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"]","solution":"import re def is_palindrome(word): Check if a given word is a palindrome sequence, ignoring cases and non-alphanumeric characters. # Remove non-alphanumeric characters and convert to lowercase cleaned_word = re.sub(r'[^a-zA-Z0-9]', '', word).lower() # Check if the cleaned word is equal to its reverse return cleaned_word == cleaned_word[::-1] def check_palindrome_sequences(test_cases): results = [] for word in test_cases: if is_palindrome(word): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def trap(heights: List[int]) -> int: Calculate the total amount of rainwater trapped between the buildings. :param heights: List[int] - List representing the heights of the buildings :return: int - Total amount of rainwater trapped >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9 >>> trap([5,4,1,2]) 1","solution":"def trap(heights): Calculate the total amount of rainwater trapped between the buildings. :param heights: List[int] - List representing the heights of the buildings :return: int - Total amount of rainwater trapped if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"from typing import List, Tuple def subtree_sum(N: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: You are given a binary tree with N nodes (numbered 1 through N). Each node has a value assigned to it. Your task is to answer Q queries. Each query consists of a single node u. For each query, you need to determine the sum of values of all nodes that belong to the subtree rooted at node u. Args: N: Number of nodes in the tree. values: A list of integers representing the values of the nodes. edges: A list of tuples representing the edges in the tree. queries: A list of integers representing the queries for the subtree sums. Returns: A list of integers, where each integer is the sum of the values of the nodes in the subtree rooted at the corresponding query node. Example: >>> subtree_sum(6, [3, 5, 1, 6, 4, 2], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], [1, 2, 3]) [21, 15, 3]","solution":"from collections import defaultdict def subtree_sum(N, values, edges, queries): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) subtree_sums = [0] * (N + 1) visited = [False] * (N + 1) def dfs(node): visited[node] = True total_sum = values[node - 1] for neighbor in tree[node]: if not visited[neighbor]: total_sum += dfs(neighbor) subtree_sums[node] = total_sum return total_sum dfs(1) results = [subtree_sums[q] for q in queries] return results # Example usage N = 6 values = [3, 5, 1, 6, 4, 2] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] queries = [1, 2, 3] print(subtree_sum(N, values, edges, queries)) # Output: [21, 15, 3]"},{"question":"def reverse_and_swap_case(s: str) -> str: Takes a string and returns the string in reverse order with the case of each letter swapped. >>> reverse_and_swap_case(\\"Hello World!\\") \\"!DLROw OLLEh\\" >>> reverse_and_swap_case(\\"\\") \\"\\" >>> reverse_and_swap_case(\\"a\\") \\"A\\" >>> reverse_and_swap_case(\\"A\\") \\"a\\" >>> reverse_and_swap_case(\\"1\\") \\"1\\" >>> reverse_and_swap_case(\\"AbCdEfG\\") \\"gFeDcBa\\" >>> reverse_and_swap_case(\\"1234567890!@#%^&*()\\") \\")(*&^%#@!0987654321\\"","solution":"def reverse_and_swap_case(s): Takes a string and returns the string in reverse order with the case of each letter swapped. return s[::-1].swapcase()"},{"question":"def longest_balanced_subsequence(sequence: str, queries: List[Tuple[int, int]]) -> List[int]: Returns the longest subsequence where each character appears the same number of times for each query interval. >>> longest_balanced_subsequence(\\"ACGTACGTACGT\\", [(1, 4), (1, 8), (5, 12)]) [4, 8, 8] >>> longest_balanced_subsequence(\\"ACGT\\", [(1, 4)]) [4] >>> longest_balanced_subsequence(\\"AAACCC\\", [(1, 3)]) [0] >>> longest_balanced_subsequence(\\"AACCGGTT\\", [(1, 8)]) [8] >>> longest_balanced_subsequence(\\"A\\" * 25000 + \\"C\\" * 25000 + \\"G\\" * 25000 + \\"T\\" * 25000, [(1, 100000)]) [100000] >>> longest_balanced_subsequence(\\"AAAA\\", [(1, 4)]) [0]","solution":"def longest_balanced_subsequence(sequence, queries): Returns the longest subsequence where each character appears the same number of times for each query interval. from collections import defaultdict n = len(sequence) q = len(queries) # Precompute prefix sums for each character prefix_sums = { 'A': [0] * (n + 1), 'C': [0] * (n + 1), 'G': [0] * (n + 1), 'T': [0] * (n + 1), } for i in range(n): for char in 'ACGT': prefix_sums[char][i + 1] = prefix_sums[char][i] + (1 if sequence[i] == char else 0) results = [] for l, r in queries: count = defaultdict(int) for char in 'ACGT': count[char] = prefix_sums[char][r] - prefix_sums[char][l - 1] min_count = min(count.values()) results.append(min_count * 4) return results"},{"question":"def is_prime(num): Helper function to determine if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(0) == False >>> is_prime(-7) == False def sort_primes(sequence): Rearranges prime numbers in the sequence in ascending order while keeping non-prime numbers in their original positions. >>> sort_primes([10, 29, 11, 4, 5]) == [10, 5, 11, 4, 29] >>> sort_primes([-7, 17, 3, 50, 19, 4, 6]) == [-7, 3, 17, 50, 19, 4, 6] >>> sort_primes([22, 6, 8, 9, 15]) == [22, 6, 8, 9, 15] >>> sort_primes([19, 7, 5, 3, 11]) == [3, 5, 7, 11, 19] >>> sort_primes([17, 17, 2, 2, 3]) == [2, 2, 3, 17, 17] >>> sort_primes([]) == []","solution":"def is_prime(num): Helper function to determine if a number is prime. if num <= 1: return False if num == 2: return True # 2 is the only even prime number if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def sort_primes(sequence): Rearranges prime numbers in the sequence in ascending order while keeping non-prime numbers in their original positions. primes = [num for num in sequence if is_prime(num)] primes.sort() prime_index = 0 result = [] for num in sequence: if is_prime(num): result.append(primes[prime_index]) prime_index += 1 else: result.append(num) return result"},{"question":"def garden_fence_perimeter(length: int, width: int) -> int: Calculate the amount of fencing material required to surround a rectangular garden. The perimeter of the garden is given by 2 * (length + width). >>> garden_fence_perimeter(8, 5) 26 >>> garden_fence_perimeter(15, 10) 50 >>> garden_fence_perimeter(1, 1) 4 >>> garden_fence_perimeter(0, 0) 0 >>> garden_fence_perimeter(7, 3) 20 >>> garden_fence_perimeter(20, 5) 50 >>> garden_fence_perimeter(1000, 2000) 6000 >>> garden_fence_perimeter(9999, 9999) 39996 >>> garden_fence_perimeter(0, 100) 200 >>> garden_fence_perimeter(100, 0) 200 >>> garden_fence_perimeter(0, 1) 2","solution":"def garden_fence_perimeter(length, width): Returns the perimeter of the garden given its length and width. return 2 * (length + width)"},{"question":"from typing import List def is_valid_pattern(sequence: List[int]) -> bool: Determines if the given sequence is a valid pattern lock sequence. Args: sequence (List[int]): A list of integers representing the sequence of numbers in the pattern lock attempt. Returns: bool: True if the sequence forms a valid pattern lock, False otherwise. >>> is_valid_pattern([1, 2, 3, 6, 5, 4, 7, 8, 9]) True >>> is_valid_pattern([1, 3, 2, 4, 5, 6, 9, 7, 8]) False >>> is_valid_pattern([1, 1, 2, 3]) False >>> is_valid_pattern([1, 10, 2, 3]) False >>> is_valid_pattern([1]) True >>> is_valid_pattern([1, 4, 7, 8, 5, 2, 3, 6, 9]) True","solution":"def is_valid_pattern(sequence): Determines if the given sequence is a valid pattern lock sequence. if any(n < 1 or n > 9 for n in sequence): return False if len(set(sequence)) != len(sequence): return False moves = { (1, 3): 2, (1, 7): 4, (1, 9): 5, (2, 8): 5, (3, 7): 5, (3, 9): 6, (4, 6): 5, (7, 9): 8, (3, 1): 2, (7, 1): 4, (9, 1): 5, (8, 2): 5, (7, 3): 5, (9, 3): 6, (6, 4): 5, (9, 7): 8 } used = set() for i in range(len(sequence) - 1): cur = sequence[i] next = sequence[i + 1] if next in used: return False if (cur, next) in moves and moves[(cur, next)] not in used: return False used.add(cur) return True"},{"question":"from collections import Counter def highest_frequency_char(S: str) -> str: Returns the character with the highest frequency in the string S. If there are multiple characters with the highest frequency, return the lexicographically smallest one. >>> highest_frequency_char('aabbbcc') 'b' >>> highest_frequency_char('abbcccddddeeeee') 'e' >>> highest_frequency_char('aabbcc') 'a' >>> highest_frequency_char('zzzaaabbbb') 'b'","solution":"from collections import Counter def highest_frequency_char(S): Returns the character with the highest frequency in the string S. If there are multiple characters with the highest frequency, return the lexicographically smallest one. if not S: return None count = Counter(S) max_count = max(count.values()) candidates = [char for char, freq in count.items() if freq == max_count] return min(candidates)"},{"question":"def max_traffic_signals(n: int, grid: List[str]) -> Tuple[int, List[Tuple[int, int]]]: Determine the optimal placement of traffic signals to maximize the number of roads receiving green lights. Args: n : int : The size of the grid. grid : List[str] : The layout of the grid, where 'R' represents a road and 'B' represents a building. Returns: Tuple[int, List[Tuple[int, int]]] : The number of signals placed and a list of coordinates (1-based index) where signals are placed. >>> n = 4 >>> grid = [ ... \\"RRRB\\", ... \\"RRBB\\", ... \\"RRRR\\", ... \\"BBRB\\" ... ] >>> max_traffic_signals(n, grid) (1, [(3, 1)])","solution":"def max_traffic_signals(n, grid): max_sum = 0 signals = [] row_count = [0] * n col_count = [0] * n for i in range(n): for j in range(n): if grid[i][j] == 'R': row_count[i] += 1 col_count[j] += 1 for i in range(n): for j in range(n): if grid[i][j] == 'R' and (row_count[i] + col_count[j] - 1) > max_sum: max_sum = row_count[i] + col_count[j] - 1 signals = [(i+1, j+1)] return len(signals), signals # Example usage: n = 4 grid = [ \\"RRRB\\", \\"RRBB\\", \\"RRRR\\", \\"BBRB\\" ] number_of_signals, coords = max_traffic_signals(n, grid) print(number_of_signals) for coord in coords: print(coord[0], coord[1])"},{"question":"def min_sum_absolute_differences(arr: List[int]) -> int: Rearrange the array such that the sum of the absolute differences between neighboring elements is minimized. Arguments: arr -- array of positive integers Returns: int -- minimized sum of absolute differences >>> min_sum_absolute_differences([10, 1, 5, 8]) 9 >>> min_sum_absolute_differences([3, 6, 2]) 4 >>> min_sum_absolute_differences([1, 1000000000]) 999999999 >>> min_sum_absolute_differences([4, 4, 4, 4]) 0 >>> min_sum_absolute_differences([1, 2, 3, 4, 5]) 4 >>> min_sum_absolute_differences([5, 4, 3, 2, 1]) 4 >>> min_sum_absolute_differences([3, 7, 2, 8, 6, 1, 5, 4]) 7","solution":"def min_sum_absolute_differences(arr): # Sort the array to get the minimum sum of absolute differences arr.sort() # The minimum sum of absolute differences when the array is sorted n = len(arr) min_sum = 0 for i in range(n - 1): min_sum += abs(arr[i] - arr[i + 1]) return min_sum"},{"question":"from typing import List, Tuple def smallest_max_weight_edge(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Finds the smallest maximum weight edge on the shortest path from node 1 to node N. Uses Dijkstra's algorithm with a priority queue (heap) to find the minimal spanning path. If no path exists between node 1 and node N, returns -1. Args: - N: int - Number of nodes in the graph - M: int - Number of edges in the graph - edges: List[Tuple[int, int, int]] - List of edges where each edge is defined by a tuple (u, v, w) Returns: - int - The weight of the heaviest edge in the optimal path, or -1 if no path exists. >>> smallest_max_weight_edge(5, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 5, 5), (1, 5, 10)]) 5 >>> smallest_max_weight_edge(4, 2, [(1, 2, 1), (3, 4, 1)]) -1 >>> smallest_max_weight_edge(2, 1, [(1, 2, 7)]) 7 >>> smallest_max_weight_edge(4, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 1)]) -1 >>> smallest_max_weight_edge(5, 6, [(1, 2, 2), (2, 3, 2), (1, 3, 8), (3, 4, 2), (4, 5, 2), (1, 5, 9)]) 2","solution":"import heapq def smallest_max_weight_edge(N, M, edges): Finds the smallest maximum weight edge on the shortest path from node 1 to node N. Uses Dijkstra's algorithm with a priority queue (heap) to find the minimal spanning path. If no path exists between node 1 and node N, returns -1. graph = [[] for _ in range(N + 1)] for u, v, w in edges: graph[u].append((w, v)) graph[v].append((w, u)) # Min-heap of (maximum edge weight in the path to the current node, current node) heap = [(0, 1)] max_edge_in_path = [float('inf')] * (N + 1) max_edge_in_path[1] = 0 while heap: max_w, node = heapq.heappop(heap) if node == N: return max_w for weight, neighbor in graph[node]: # Max weight edge in the path if we go to the neighbor through this edge new_max_weight = max(max_w, weight) if new_max_weight < max_edge_in_path[neighbor]: max_edge_in_path[neighbor] = new_max_weight heapq.heappush(heap, (new_max_weight, neighbor)) return -1"},{"question":"def is_valid_rainbow_pattern(n: int, m: int, grid: List[List[int]]) -> str: Returns 'YES' if the grid forms a valid rainbow pattern, otherwise 'NO'. Each row and each column should contain continuous non-decreasing values. The grid must contain distinct levels of paint (1 through n*m, without repetition). >>> is_valid_rainbow_pattern(4, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) 'YES' >>> is_valid_rainbow_pattern(3, 3, [[3, 1, 2], [6, 4, 5], [9, 7, 8]]) 'NO' def test_valid_rainbow_pattern(): n, m = 4, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12] ] assert is_valid_rainbow_pattern(n, m, grid) == \\"YES\\" def test_invalid_rainbow_pattern(): n, m = 3, 3 grid = [ [3, 1, 2], [6, 4, 5], [9, 7, 8] ] assert is_valid_rainbow_pattern(n, m, grid) == \\"NO\\" def test_invalid_non_continuous_values(): n, m = 2, 2 grid = [ [1, 3], [2, 5] ] assert is_valid_rainbow_pattern(n, m, grid) == \\"NO\\" def test_valid_single_row(): n, m = 1, 5 grid = [ [1, 2, 3, 4, 5] ] assert is_valid_rainbow_pattern(n, m, grid) == \\"YES\\" def test_valid_single_column(): n, m = 5, 1 grid = [ [1], [2], [3], [4], [5] ] assert is_valid_rainbow_pattern(n, m, grid) == \\"YES\\" def test_single_element_grid(): n, m = 1, 1 grid = [ [1] ] assert is_valid_rainbow_pattern(n, m, grid) == \\"YES\\"","solution":"def is_valid_rainbow_pattern(n, m, grid): Returns 'YES' if the grid forms a valid rainbow pattern, otherwise 'NO'. # Check each row for non-decreasing order for row in grid: if row != sorted(row): return \\"NO\\" # Check each column for non-decreasing order for col in range(m): col_values = [grid[row][col] for row in range(n)] if col_values != sorted(col_values): return \\"NO\\" # Check for distinct values from 1 through n * m all_values = [grid[row][col] for row in range(n) for col in range(m)] if sorted(all_values) != list(range(1, n * m + 1)): return \\"NO\\" return \\"YES\\" # Example usage: # n, m = 4, 3 # grid = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9], # [10, 11, 12] # ] # print(is_valid_rainbow_pattern(n, m, grid)) # Output: \\"YES\\""},{"question":"def countPairsWithSum(arr, n, target): Counts the number of unique pairs in the array that add up to the target sum. A unique pair (a, b) and (b, a) are considered the same. Parameters: arr (list): The array of integers. n (int): The size of the array. target (int): The target sum. Returns: int: The number of unique pairs that sum up to the target. >>> countPairsWithSum([1, 5, 7, -1, 5], 5, 6) 2 >>> countPairsWithSum([1, 1, 1, 1], 4, 2) 1 >>> countPairsWithSum([1, 2, 3, 4], 4, 10) 0 >>> countPairsWithSum([3, 3, 3, 3], 4, 6) 1 >>> countPairsWithSum([-1, -2, -3, 0, 1, 2, 3], 7, 0) 3","solution":"def countPairsWithSum(arr, n, target): Counts the number of unique pairs in the array that add up to the target sum. A unique pair (a, b) and (b, a) are considered the same. Parameters: arr (list): The array of integers. n (int): The size of the array. target (int): The target sum. Returns: int: The number of unique pairs that sum up to the target. seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return len(pairs)"},{"question":"def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Given an array of unique integers, find all pairs of integers whose sum is equal to a given target value. Each pair should be returned as a tuple, and the function should return a list of these tuples. Parameters: arr (list): A list of unique integers. target (int): The target sum value. Returns: list: A list of tuples where each tuple contains a pair of integers whose sum is equal to the target. Examples: >>> find_pairs_with_sum([2, 4, 3, 5, 7, 8, 9], 10) [(2, 8), (3, 7)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 8) [(3, 5)] >>> find_pairs_with_sum([1, 5, 3], 10) []","solution":"def find_pairs_with_sum(arr, target): Returns all pairs of integers from the array whose sum is equal to the target. Each pair is returned as a tuple in a list. Parameters: arr (list): A list of unique integers. target (int): The target sum value. Returns: list: A list of tuples where each tuple contains a pair of integers whose sum is equal to the target. seen = set() pairs = [] for number in arr: complement = target - number if complement in seen: pairs.append((complement, number)) seen.add(number) return pairs"},{"question":"def max_subsequence_indices(N: int, sequence: List[int]) -> Tuple[int, int]: You are given a sequence consisting of N integers. You have to choose the start and end indices of a contiguous subsequence such that the sum of the subsequence is maximized. Additionally, if there are multiple subsequences with the same maximum sum, choose the one with the smallest length. If there are still multiple subsequences, choose the one that appears first in the sequence. Args: N (int): the number of integers sequence (List[int]): a list of N space-separated integers Returns: Tuple[int, int]: two integers separated by a single space: the starting and ending indices (1-based) of the contiguous subsequence with the maximum sum. Examples: >>> max_subsequence_indices(8, [-2, -3, 4, -1, -2, 1, 5, -3]) (3, 7) >>> max_subsequence_indices(5, [-1, -2, -3, -4, -5]) (1, 1) pass from solution import max_subsequence_indices def test_example_case(): assert max_subsequence_indices(8, [-2, -3, 4, -1, -2, 1, 5, -3]) == (3, 7) def test_all_negative_numbers(): assert max_subsequence_indices(5, [-1, -2, -3, -4, -5]) == (1, 1) assert max_subsequence_indices(5, [-5, -4, -3, -2, -1]) == (5, 5) def test_all_positive_numbers(): assert max_subsequence_indices(4, [1, 2, 3, 4]) == (1, 4) assert max_subsequence_indices(3, [7, 8, 9]) == (1, 3) def test_mixed_numbers(): assert max_subsequence_indices(10, [3, -1, -1, -1, 5, -1, -1, 6, -2, 1]) == (5, 8) assert max_subsequence_indices(6, [1, 2, -1, 2, -1, 3]) == (1, 6) def test_single_element(): assert max_subsequence_indices(1, [5]) == (1, 1) assert max_subsequence_indices(1, [-5]) == (1, 1) def test_large_input(): sequence = [i for i in range(1, 10001)] assert max_subsequence_indices(10000, sequence) == (1, 10000) sequence = [-i for i in range(1, 10001)] assert max_subsequence_indices(10000, sequence) == (1, 1)","solution":"def max_subsequence_indices(N, sequence): Returns the 1-based starting and ending indices of the contiguous subsequence with the maximum sum. If there are multiple subsequences with the same maximum sum, the smallest-length subsequence is returned. If there are further ties, the subsequence that appears first is returned. max_sum = -float('inf') current_sum = 0 start_index = 0 result_start = result_end = 0 min_length = float('inf') for i in range(N): if current_sum <= 0: current_sum = sequence[i] start_index = i else: current_sum += sequence[i] if current_sum > max_sum or (current_sum == max_sum and (i - start_index) < min_length): max_sum = current_sum result_start = start_index result_end = i min_length = i - start_index return (result_start + 1, result_end + 1)"},{"question":"def can_tom_catch_jerry(N, M, grid): Determine if Tom can catch Jerry on an N by M grid. Parameters: N (int): number of rows in the grid M (int): number of columns in the grid grid (List[str]): grid where '.' denotes free space and '#' denotes obstacle Returns: str: \\"YES\\" if Tom can catch Jerry, otherwise \\"NO\\" >>> can_tom_catch_jerry(3, 4, [\\"..#.\\", \\"...#\\", \\"#...\\"]) \\"YES\\" >>> can_tom_catch_jerry(3, 4, [\\"..#.\\", \\".#..\\", \\"#...\\"]) \\"NO\\" from solution import can_tom_catch_jerry def test_can_tom_catch_jerry_sample_input1(): N = 3 M = 4 grid = [\\"..#.\\", \\"...#\\", \\"#...\\"] assert can_tom_catch_jerry(N, M, grid) == \\"YES\\" def test_can_tom_catch_jerry_sample_input2(): N = 3 M = 4 grid = [\\"..#.\\", \\".#..\\", \\"#...\\"] assert can_tom_catch_jerry(N, M, grid) == \\"NO\\" def test_can_tom_catch_jerry_no_obstacles(): N = 3 M = 4 grid = [\\"....\\", \\"....\\", \\"....\\"] assert can_tom_catch_jerry(N, M, grid) == \\"YES\\" def test_can_tom_catch_jerry_full_of_obstacles(): N = 3 M = 4 grid = [\\"\\", \\"\\", \\"\\"] assert can_tom_catch_jerry(N, M, grid) == \\"NO\\" def test_can_tom_catch_jerry_one_path(): N = 3 M = 4 grid = [\\".#\\", \\".#..\\", \\"...#\\"] assert can_tom_catch_jerry(N, M, grid) == \\"NO\\"","solution":"def can_tom_catch_jerry(N, M, grid): def is_reachable(start_row, start_col, end_row, end_col): queue = [(start_row, start_col)] visited = set() directions = [(1, 0), (0, 1)] # right, down while queue: current_row, current_col = queue.pop(0) if (current_row, current_col) == (end_row, end_col): return True for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < N and 0 <= new_col < M and grid[new_row][new_col] == '.' and (new_row, new_col) not in visited: queue.append((new_row, new_col)) visited.add((new_row, new_col)) return False tom_can_reach = is_reachable(0, 0, N-1, M-1) def transpose(grid): return [\\"\\".join(row) for row in zip(*grid)] def reverse_grid(grid): return [row[::-1] for row in grid][::-1] reversed_grid = reverse_grid(transpose(grid)) jerry_can_reach = is_reachable(0, 0, N-1, M-1) return \\"YES\\" if tom_can_reach and jerry_can_reach else \\"NO\\""},{"question":"from typing import List, Tuple def are_isomorphic(s1: str, s2: str) -> str: Determines if two strings are isomorphic. >>> are_isomorphic(\\"egg\\", \\"add\\") 'Yes' >>> are_isomorphic(\\"foo\\", \\"bar\\") 'No' >>> are_isomorphic(\\"paper\\", \\"title\\") 'Yes' def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases of string pairs for isomorphism. >>> process_test_cases([(\\"egg\\", \\"add\\"), (\\"foo\\", \\"bar\\"), (\\"paper\\", \\"title\\")]) ['Yes', 'No', 'Yes'] def main(input_lines: List[str]) -> List[str]: Handles the input and output for checking isomorphism of multiple test cases. >>> main([\\"3\\", \\"egg add\\", \\"foo bar\\", \\"paper title\\"]) ['Yes', 'No', 'Yes']","solution":"def are_isomorphic(s1, s2): Determines if two strings are isomorphic. if len(s1) != len(s2): return \\"No\\" mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 not in mapping_s1_to_s2 and char2 not in mapping_s2_to_s1: mapping_s1_to_s2[char1] = char2 mapping_s2_to_s1[char2] = char1 elif mapping_s1_to_s2.get(char1) != char2 or mapping_s2_to_s1.get(char2) != char1: return \\"No\\" return \\"Yes\\" def process_test_cases(test_cases): results = [] for s1, s2 in test_cases: results.append(are_isomorphic(s1, s2)) return results def main(input_lines): T = int(input_lines[0]) test_cases = [line.split() for line in input_lines[1:T+1]] results = process_test_cases(test_cases) return results"},{"question":"from typing import List def search_pattern(pattern: str, txt: str) -> List[int]: Given a string pattern of length M and a text txt of length N, identify if pattern exists in txt. Return the starting index of each occurrence of pattern in txt. If pattern does not exist in txt, return an empty list. Example: >>> search_pattern(\\"abc\\", \\"ababcabc\\") [2, 5] >>> search_pattern(\\"xyz\\", \\"ababcabc\\") []","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: M = len(pattern) lps = [0] * M length = 0 i = 1 while i < M: if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def search_pattern(pattern: str, txt: str) -> List[int]: M = len(pattern) N = len(txt) lps = compute_lps(pattern) result = [] i = 0 j = 0 while i < N: if pattern[j] == txt[i]: i += 1 j += 1 if j == M: return_start_index = i - j result.append(return_start_index) j = lps[j - 1] elif i < N and pattern[j] != txt[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"from typing import List, Tuple def shortest_path(n: int, edges: List[Tuple[int, int, int]], start: int, target: int) -> int: Return the minimum travel time needed to go from the starting lake to the target lake. >>> shortest_path(5, [(1, 2, 2), (2, 3, 4), (1, 3, 1), (3, 4, 3), (4, 5, 1)], 1, 5) 5 >>> shortest_path(3, [(1, 2, 2)], 1, 3) -1 >>> shortest_path(1, [], 1, 1) 0 >>> shortest_path(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5)], 1, 4) 12 >>> shortest_path(6, [(1, 2, 2), (2, 3, 2), (1, 3, 4), (3, 5, 2), (2, 5, 4), (1, 4, 1), (4, 6, 2), (6, 5, 1)], 1, 5) 4","solution":"import heapq from typing import List, Tuple def shortest_path(n: int, edges: List[Tuple[int, int, int]], start: int, target: int) -> int: Return the minimum travel time needed to go from the starting lake to the target lake. Uses Dijkstra's algorithm to find the shortest path in a graph with positive weights. # Creating an adjacency list adj_list = {i: [] for i in range(1, n+1)} for u, v, w in edges: adj_list[u].append((w, v)) # Min-heap to maintain the frontier nodes with their distances min_heap = [(0, start)] # Dictionary to store the minimum distance to each node dist = {i: float('inf') for i in range(1, n+1)} # Distance to start node is 0 dist[start] = 0 while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > dist[u]: continue for weight, v in adj_list[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(min_heap, (distance, v)) # Return the minimum distance to the target node return dist[target] if dist[target] != float('inf') else -1"},{"question":"def is_possible_arrangement(N: int, compatibility_counts: List[int], compatibility_rules: List[List[int]]) -> str: Determine if it is possible to arrange all magic items in a straight line according to their compatibility rules. >>> is_possible_arrangement(4, [1, 1, 2, 1], [[2], [3], [1, 4], [3]]) \\"Yes\\" >>> is_possible_arrangement(3, [0, 1, 1], [[], [3], [2]]) \\"No\\"","solution":"def is_possible_arrangement(N, compatibility_counts, compatibility_rules): from collections import defaultdict, deque # Build the adjacency list for compatibility graph compat_graph = defaultdict(list) for i in range(N): for compatible_item in compatibility_rules[i]: compat_graph[i].append(compatible_item - 1) # Convert 1-based to 0-based indexing compat_graph[compatible_item - 1].append(i) # Use BFS to check if the graph is connected def bfs(start): visited = [False] * N queue = deque([start]) visited[start] = True component_size = 0 while queue: node = queue.popleft() component_size += 1 for neighbor in compat_graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_size # Check for connectivity of the graph component_size = bfs(0) if component_size == N: return \\"Yes\\" else: return \\"No\\""},{"question":"from typing import List, Tuple def max_path_weight(n: int, m: int, weights: List[int], edges: List[Tuple[int, int]]) -> List[int]: You are given an undirected graph with n vertices and m edges. Vertices are numbered from 1 to n and each vertex is assigned a positive integer weight. The weight of a simple path is defined as the sum of the weights of the vertices in that path. A path is a simple path if all vertices in the path are distinct. For each vertex, output the maximum possible weight of a simple path starting from that vertex. Args: n (int): Number of vertices. m (int): Number of edges. weights (List[int]): A list of weights of length n. edges (List[Tuple[int, int]]): A list of tuples where each tuple represents an edge between two vertices. Returns: List[int]: A list of n integers where the i-th integer is the maximum possible weight of a simple path starting from vertex i+1. Example: >>> max_path_weight(4, 4, [10, 20, 30, 40], [(1, 2), (2, 3), (3, 4), (4, 2)]) [100, 90, 70, 40] >>> max_path_weight(3, 2, [1, 2, 3], [(1, 2), (2, 3)]) [6, 5, 3]","solution":"from collections import defaultdict def max_path_weight(n, m, weights, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) max_weights = [0] * n visited = [False] * n def dfs(node): if visited[node]: return max_weights[node] visited[node] = True max_weight = weights[node] for neighbor in graph[node + 1]: max_weight = max(max_weight, weights[node] + dfs(neighbor - 1)) max_weights[node] = max_weight return max_weight for i in range(n): if not visited[i]: dfs(i) return max_weights # Example usage n = 4 m = 4 weights = [10, 20, 30, 40] edges = [(1, 2), (2, 3), (3, 4), (4, 2)] print(max_path_weight(n, m, weights, edges)) # Output: [100, 90, 70, 40]"},{"question":"def currentLight(direction: str, elapsed_time: int) -> str: Determine the current color of the traffic light for a given direction and elapsed time since it turned green. The intersection has 4 directions for traffic lights: \\"north\\", \\"south\\", \\"east\\", and \\"west\\". The lights change color in the following sequence: - North and South directions: - Green for 60 seconds - Yellow for 10 seconds - Red for the remaining time until the end of the cycle - East and West directions: - Red for the duration when North and South are active - Green for 60 seconds - Yellow for 10 seconds - Red for the remaining time until the end of the cycle Args: direction (str): The direction of traffic (\\"north\\", \\"south\\", \\"east\\", \\"west\\"). elapsed_time (int): The elapsed time in seconds since the light turned green. Returns: str: The current color of the traffic light (\\"green\\", \\"yellow\\", or \\"red\\"). >>> currentLight(\\"north\\", 50) 'green' >>> currentLight(\\"south\\", 65) 'yellow' >>> currentLight(\\"east\\", 70) 'red' >>> currentLight(\\"west\\", 150) 'red' >>> currentLight(\\"north\\", 120) 'red' >>> currentLight(\\"east\\", 130) 'green'","solution":"def currentLight(direction: str, elapsed_time: int) -> str: cycle_time = 140 # Total cycle time: 60s green + 10s yellow + 60s green + 10s yellow for each pair # Ensure elapsed_time is within the cycle range using modulo elapsed_time = elapsed_time % cycle_time # Define the traffic light changes per direction if direction in [\\"north\\", \\"south\\"]: if elapsed_time < 60: return \\"green\\" elif elapsed_time < 70: return \\"yellow\\" else: return \\"red\\" elif direction in [\\"east\\", \\"west\\"]: if elapsed_time < 70: return \\"red\\" elif elapsed_time < 130: return \\"green\\" else: return \\"yellow\\""},{"question":"def beautiful_permutation(n: int) -> Union[str, List[int]]: Determine if there exists a beautiful permutation for a given n. If such a permutation exists, return it. Otherwise, return 'NO'. >>> beautiful_permutation(1) [1] >>> beautiful_permutation(2) [2, 1] >>> beautiful_permutation(3) 'NO' >>> beautiful_permutation(4) [2, 1, 4, 3] def solve(t: int, cases: List[int]) -> List[Union[str, List[int]]]: Given t test cases, determine the beautiful permutation for each case. >>> solve(3, [1, 2, 3]) [[1], [2, 1], 'NO'] >>> solve(2, [4, 5]) [[2, 1, 4, 3], 'NO'] >>> solve(1, [6]) [[2, 1, 4, 3, 6, 5]] from typing import List, Union # additional test cases def test_beautiful_permutation(): assert beautiful_permutation(1) == [1] assert beautiful_permutation(2) == [2, 1] assert beautiful_permutation(3) == 'NO' assert beautiful_permutation(4) == [2, 1, 4, 3] assert beautiful_permutation(5) == 'NO' assert beautiful_permutation(6) == [2, 1, 4, 3, 6, 5] def test_solve(): assert solve(3, [1, 2, 3]) == [[1], [2, 1], 'NO'] assert solve(2, [4, 5]) == [[2, 1, 4, 3], 'NO'] assert solve(1, [6]) == [[2, 1, 4, 3, 6, 5]] def test_edge_cases(): assert beautiful_permutation(7) == 'NO' assert solve(4, [1, 2, 3, 8]) == [[1], [2, 1], 'NO', [2, 1, 4, 3, 6, 5, 8, 7]]","solution":"def beautiful_permutation(n): if n == 1: return [1] elif n == 2: return [2, 1] elif n % 2 == 1: return \\"NO\\" else: perm = [] for i in range(1, n+1, 2): perm.append(i+1) perm.append(i) return perm def solve(t, cases): results = [] for n in cases: result = beautiful_permutation(n) results.append(result) return results"},{"question":"def can_form_zigzag(arr): Determines if it's possible to rearrange an array to form a zigzag pattern. :param arr: List of integers representing heights of flowers :return: \\"YES\\" if it's possible to rearrange to a zigzag pattern, otherwise \\"NO\\" from solution import can_form_zigzag def test_example_case1(): assert can_form_zigzag([4, 3, 7, 8, 2]) == \\"YES\\" def test_example_case2(): assert can_form_zigzag([1, 1, 1, 1]) == \\"NO\\" def test_single_flower(): assert can_form_zigzag([3]) == \\"YES\\" def test_two_flowers(): assert can_form_zigzag([3, 2]) == \\"YES\\" assert can_form_zigzag([2, 3]) == \\"YES\\" def test_already_zigzag(): assert can_form_zigzag([1, 3, 2, 4, 3]) == \\"YES\\" def test_duplicate_numbers(): assert can_form_zigzag([2, 2, 2]) == \\"NO\\" def test_large_input(): arr = [i for i in range(1, 100001)] assert can_form_zigzag(arr) == \\"YES\\"","solution":"def can_form_zigzag(arr): Determines if it's possible to rearrange an array to form a zigzag pattern. :param arr: List of integers representing heights of flowers :return: \\"YES\\" if it's possible to rearrange to a zigzag pattern, otherwise \\"NO\\" if len(arr) <= 2: return \\"YES\\" arr.sort() for i in range(1, len(arr)-1, 2): arr[i], arr[i+1] = arr[i+1], arr[i] for i in range(1, len(arr)-1): if not ((arr[i-1] < arr[i] > arr[i+1]) or (arr[i-1] > arr[i] < arr[i+1])): return \\"NO\\" return \\"YES\\""},{"question":"def total_length_of_valid_fish(n: int, fish_lengths: List[int]) -> int: Returns the total length of valid fish from the given list of fish lengths. Valid fish lengths are positive integers. Parameters: n (int): The number of recorded entries in John's log. fish_lengths (List[int]): The lengths of the fish recorded by John. Returns: int: The total length of valid fish caught by John. Example: >>> total_length_of_valid_fish(5, [10, -2, 30, 0, 15]) 55 >>> total_length_of_valid_fish(3, [-3, -4, -5]) 0","solution":"def total_length_of_valid_fish(n, fish_lengths): Returns the total length of valid fish from the given list of fish lengths. Valid fish lengths are positive integers. return sum(length for length in fish_lengths if length > 0)"},{"question":"def sum_of_unique_prime_factors(n: int, numbers: List[int]) -> int: Calculate the sum of all unique prime factors of numbers in the list. Args: n (int): The number of elements in the list. numbers (List[int]): The list of integers. Returns: int: The sum of all unique prime factors of the numbers. >>> sum_of_unique_prime_factors(3, [12, 15, 35]) 17 >>> sum_of_unique_prime_factors(1, [1]) 0","solution":"def sum_of_unique_prime_factors(n, numbers): def sieve(max_num): primes = [] is_prime = [True] * (max_num + 1) is_prime[0] = is_prime[1] = False for i in range(2, max_num + 1): if is_prime[i]: primes.append(i) for j in range(i * i, max_num + 1, i): is_prime[j] = False return primes max_num = max(numbers) primes = sieve(max_num) unique_prime_factors = set() for num in numbers: temp = num for prime in primes: if prime * prime > temp: break if temp % prime == 0: unique_prime_factors.add(prime) while temp % prime == 0: temp //= prime if temp > 1: unique_prime_factors.add(temp) return sum(unique_prime_factors)"},{"question":"def longest_consistent_period(arr): Given a list of integers, determine the length of the longest subarray where all elements have the same value. >>> longest_consistent_period([5, 5, 3, 3, 3, 2, 2]) == 3 >>> longest_consistent_period([1, 1, 1, 1, 1]) == 5 >>> longest_consistent_period([6, 7, 8, 8, 8, 8]) == 4 >>> longest_consistent_period([7]) == 1 >>> longest_consistent_period([1, 2, 3, 4, 5, 6]) == 1 >>> longest_consistent_period([3, 3, 3, 3, 3, 1, 1, 3, 3]) == 5 >>> longest_consistent_period([]) == 0 >>> longest_consistent_period([4, 4, 5, 5, 5, 5, 1, 1, 1]) == 4 >>> longest_consistent_period([2, 2, 2, 2, 2, 3, 3, 3, 3]) == 5 >>> longest_consistent_period([9, 9, 9, 2, 2, 9, 9, 9, 9, 9]) == 5","solution":"def longest_consistent_period(arr): Given a list of integers, determine the length of the longest subarray where all elements have the same value. if not arr: return 0 max_length = curr_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i-1]: curr_length += 1 else: max_length = max(max_length, curr_length) curr_length = 1 max_length = max(max_length, curr_length) return max_length"},{"question":"def count_lighting_rounds(candle_heights): Given a list of candles with their heights, determine the number of rounds required to light all the candles if multiple candles of the same height can be lit in one round. :param candle_heights: List of integers representing the heights of candles :return: Integer - number of rounds needed to light all candles >>> count_lighting_rounds([2, 3, 2, 1]) == 3 >>> count_lighting_rounds([4, 4, 4, 4, 4]) == 1 >>> count_lighting_rounds([6, 6, 1, 2, 3, 3, 4]) == 5 >>> count_lighting_rounds([5]) == 1 >>> count_lighting_rounds([10, 10, 10, 20]) == 2 >>> count_lighting_rounds([1, 2, 3, 4, 5]) == 5 >>> count_lighting_rounds([5, 3, 3, 3, 1]) == 3 >>> count_lighting_rounds([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 >>> count_lighting_rounds([100] * 1000) == 1","solution":"def count_lighting_rounds(candle_heights): Given a list of candles with their heights, determine the number of rounds required to light all the candles if multiple candles of the same height can be lit in one round. :param candle_heights: List of integers representing the heights of candles :return: Integer - number of rounds needed to light all candles unique_heights = set(candle_heights) return len(unique_heights)"},{"question":"def count_pairs(arr, k): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] equals k and i < j. Args: arr: List[int] - an array of integers k: int - an integer value Returns: int - the number of distinct pairs Examples: >>> count_pairs([1, 2, 3, 4, 3], 6) 2 >>> count_pairs([1, 1, 1, 1], 2) 6 >>> count_pairs([1, 1, 1, 1], 3) 0 pass","solution":"def count_pairs(arr, k): Returns the number of distinct pairs (i, j) such that arr[i] + arr[j] equals k and i < j. count = 0 freq = {} for i, num in enumerate(arr): complement = k - num if complement in freq: count += freq[complement] if num in freq: freq[num] += 1 else: freq[num] = 1 return count"},{"question":"def thickest_book_to_remove(n: int, thickness: List[int]) -> int: Determine the thickness of the thickest book that could be removed to increase the average thickness of the remaining books. >>> thickest_book_to_remove(5, [4, 2, 3, 6, 5]) == 6 >>> thickest_book_to_remove(3, [3, 3, 3]) == -1","solution":"def thickest_book_to_remove(n, thickness): total_thickness = sum(thickness) avg_thickness = total_thickness / n max_thickness = -1 for t in thickness: if t > avg_thickness: max_thickness = max(max_thickness, t) return max_thickness # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) thickness = list(map(int, data[1:])) print(thickest_book_to_remove(n, thickness))"},{"question":"def subsequence_has_perfect_square_product(n: int, arr: List[int]) -> str: Determine if a subsequence exists such that the product of the elements in the subsequence is a perfect square. Parameters: n (int): The size of the array arr (List[int]): The elements of the array Returns: str: \\"Yes\\" if such a subsequence exists, otherwise \\"No\\" Example: >>> subsequence_has_perfect_square_product(4, [2, 3, 4, 6]) \\"Yes\\" >>> subsequence_has_perfect_square_product(5, [1, 2, 3, 4, 5]) \\"No\\" import pytest def test_example_cases(): test_cases = [ (4, [2, 3, 4, 6]), (5, [1, 2, 3, 4, 5]), (3, [7, 11, 13]) ] expected_results = [\\"Yes\\", \\"No\\", \\"No\\"] assert solve(test_cases) == expected_results def test_all_ones(): assert solve([(4, [1, 1, 1, 1])]) == [\\"Yes\\"] def test_prime_numbers(): assert solve([(4, [2, 3, 5, 7])]) == [\\"No\\"] def test_all_squares(): assert solve([(3, [4, 9, 16])]) == [\\"Yes\\"] def test_mixed_even_odd_occurrences(): assert solve([(5, [2, 2, 2, 4, 4])]) == [\\"No\\"] def test_simple_no_case(): assert solve([(1, [2])]) == [\\"No\\"] def test_simple_yes_case(): assert solve([(2, [2, 2])]) == [\\"Yes\\"]","solution":"from collections import defaultdict from math import isqrt def is_perfect_square(n): Helper function to check if a number is a perfect square. root = isqrt(n) return root * root == n def subsequence_has_perfect_square_product(n, arr): Function to determine if a subsequence exists such that the product of the elements in the subsequence is a perfect square. # Using prime factorization and counts of each prime factor def prime_factors_count(num): Returns a dictionary of prime factors and their counts for a given number factors = defaultdict(int) factor = 2 while factor * factor <= num: while num % factor == 0: factors[factor] += 1 num //= factor factor += 1 if num > 1: # num is prime factors[num] += 1 return factors factor_counts = defaultdict(int) for num in arr: factors = prime_factors_count(num) for prime, count in factors.items(): factor_counts[prime] += count for _, count in factor_counts.items(): if count % 2 != 0: # An odd power of any prime means it's not a perfect square return \\"No\\" return \\"Yes\\" def solve(test_cases): results = [] for n, arr in test_cases: results.append(subsequence_has_perfect_square_product(n, arr)) return results"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string s is a palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"world\\") False >>> is_palindrome(\\"not a palindrome\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"1\\") True >>> is_palindrome(\\"Aba\\") True >>> is_palindrome(\\"AbCba\\") True","solution":"def is_palindrome(s): Returns True if the input string s is a palindrome, considering only alphanumeric characters and ignoring cases. import re # Remove non-alphanumeric characters and convert to lowercase cleaned_str = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if cleaned string is the same backwards return cleaned_str == cleaned_str[::-1]"},{"question":"def evaluate_expression(s: str) -> int: Evaluate a string mathematical expression consisting of digits and basic arithmetic operators and return the result as an integer. >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"3-5/2\\") == 1 from typing import List def test_evaluate_expression_basic(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_evaluate_expression_subtraction_division(): assert evaluate_expression(\\"3-5/2\\") == 1 def test_evaluate_expression_multiple_operators(): assert evaluate_expression(\\"3+5 / 2 * 2\\") == 7 def test_evaluate_expression_all_operations(): assert evaluate_expression(\\"8+3*2-4/2\\") == 12 def test_evaluate_expression_negative_result(): assert evaluate_expression(\\"1-2*3\\") == -5 def test_evaluate_expression_zero_division(): assert evaluate_expression(\\"7/2\\") == 3 def test_evaluate_expression_with_single_digit(): assert evaluate_expression(\\"8\\") == 8 def test_evaluate_expression_with_trailing_zeroes(): assert evaluate_expression(\\"8/3*3\\") == 6","solution":"def evaluate_expression(s): Evaluates a string mathematical expression and returns the result as an integer. if not s: return 0 num, stack, sign = 0, [], '+' for i in range(len(s)): if s[i].isdigit(): num = num * 10 + int(s[i]) if s[i] in \\"+-*/\\" or i == len(s) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack.append(stack.pop() * num) elif sign == '/': stack.append(int(stack.pop() / num)) # truncate towards zero sign = s[i] num = 0 return sum(stack)"},{"question":"def find_pair_with_sum(target: int, numbers: List[int]) -> Union[Tuple[int, int], int]: Finds and returns the pair of distinct integers from the list that add up to the target, with prioritization on the smallest first integer, then the smallest second integer. Returns -1 if no such pair exists. >>> find_pair_with_sum(9, [1, 4, 5, 7, 3]) (4, 5) >>> find_pair_with_sum(15, [1, 2, 3, 4]) -1","solution":"def find_pair_with_sum(target, numbers): Finds and returns the pair of distinct integers from the list that add up to the target, with prioritization on the smallest first integer, then the smallest second integer. Returns -1 if no such pair exists. numbers.sort() num_set = set(numbers) for num in numbers: complement = target - num if complement in num_set and complement != num: return num, complement return -1 # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() target = int(data[0]) n = int(data[1]) numbers = list(map(int, data[2:2+n])) result = find_pair_with_sum(target, numbers) if result == -1: print(result) else: print(result[0], result[1])"},{"question":"def find_number_of_peaks(n: int, arr: List[int]) -> int: Returns the number of peaks in the given array of altitudes. Parameters: n (int): The number of elements in the array (3 â‰¤ n â‰¤ 10^6). arr (List[int]): A list of n integers representing the altitudes. Returns: int: The number of peaks in the array. Examples: >>> find_number_of_peaks(5, [1, 3, 2, 4, 1]) 2 >>> find_number_of_peaks(7, [1, 2, 3, 4, 3, 2, 1]) 1","solution":"def find_number_of_peaks(n, arr): Returns the number of peaks in the given array of altitudes. Parameters: n (int): The number of elements in the array. arr (list): A list of integers representing the altitudes. Returns: int: The number of peaks in the array. peaks = 0 for i in range(1, n-1): if arr[i] > arr[i-1] and arr[i] > arr[i+1]: peaks += 1 return peaks"},{"question":"def warehouse_operations(n, m, q, operations): Perform a series of operations on the warehouse bins and return results of query operations. Each operation can be one of the following: 1. \\"1 i x\\" â€” add x items to bin i. 2. \\"2 i x\\" â€” remove x items from bin i. 3. \\"3 i j\\" â€” print the number of items in all the bins from bin i to bin j (inclusive). Parameters: n (int): Number of bins. m (int): Maximum capacity of each bin. q (int): Number of operations. operations (list): List of operations to be performed. Returns: list: Results of query operations. Unit Test Examples: >>> warehouse_operations(5, 100, 6, [(1, 2, 50), (1, 3, 60), (3, 1, 3), (2, 3, 30), (3, 1, 3), (3, 3, 5)]) [110, 80, 30] >>> warehouse_operations(3, 50, 4, [(1, 1, 20), (1, 2, 30), (3, 1, 2), (2, 2, 15), (3, 2, 2)]) [50, 15] >>> warehouse_operations(4, 20, 5, [(1, 1, 10), (1, 2, 5), (1, 3, 15), (3, 1, 3), (2, 2, 2), (3, 1, 3)]) [30, 28]","solution":"def warehouse_operations(n, m, q, operations): bins = [0] * n result = [] for operation in operations: op = operation[0] if op == 1: i = operation[1] - 1 x = operation[2] bins[i] = min(m, bins[i] + x) elif op == 2: i = operation[1] - 1 x = operation[2] bins[i] = max(0, bins[i] - x) elif op == 3: i = operation[1] - 1 j = operation[2] - 1 result.append(sum(bins[i:j+1])) return result"},{"question":"def is_tree(n, m, edges): Check if a given graph is a tree. A tree is defined as a connected graph with (n-1) edges for n vertices and no cycles. Args: n: int - Number of vertices m: int - Number of edges edges: List[Tuple[int, int]] - List of edges Returns: str - \\"YES\\" if the graph is a tree, \\"NO\\" otherwise. >>> is_tree(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> is_tree(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"NO\\" >>> is_tree(4, 3, [(1, 2), (2, 3)]) \\"NO\\" >>> is_tree(1, 0, []) \\"YES\\" def check_graphs(test_cases): Check list of test cases if given graphs are trees. Args: test_cases: List[Tuple[int, int, List[Tuple[int, int]]]] - List of test cases containing number of vertices, number of edges, and list of edges. Returns: List[str] - List containing results for each test case. >>> check_graphs([(4, 3, [(1, 2), (2, 3), (3, 4)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (4, 3, [(1, 2), (2, 3)])]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def is_tree(n, m, edges): if m != n - 1: return \\"NO\\" from collections import defaultdict, deque def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node in visited: continue visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return len(visited) == n graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) if not bfs(1): return \\"NO\\" return \\"YES\\" def check_graphs(test_cases): results = [] for n, m, edges in test_cases: results.append(is_tree(n, m, edges)) return results"},{"question":"def replace_question_marks(s): Replaces every question mark in the string with a letter such that no letter is repeated consecutively. >>> replace_question_marks(\\"a?b?c?d\\") in [\\"azbyczd\\", \\"azazazd\\", ...] True >>> replace_question_marks(\\"????\\") in [\\"abab\\", \\"abac\\", \\"baba\\", ...] True >>> replace_question_marks(\\"a?a?a\\") in [\\"ababa\\", \\"acaca\\", ...] True \`\`>","solution":"def replace_question_marks(s): Replaces every question mark in the string with a letter such that no letter is repeated consecutively. s = list(s) n = len(s) for i in range(n): if s[i] == '?': for letter in 'abc': if (i - 1 >= 0 and s[i - 1] == letter) or (i + 1 < n and s[i + 1] == letter): continue s[i] = letter break return \\"\\".join(s)"},{"question":"def can_transform_with_one_swap(A: str, B: str) -> str: Determine if you can transform string A into string B using exactly one swap operation. >>> can_transform_with_one_swap(\\"abcd\\", \\"abdc\\") \\"YES\\" >>> can_transform_with_one_swap(\\"abcd\\", \\"abcd\\") \\"NO\\" >>> can_transform_with_one_swap(\\"abcd\\", \\"abdd\\") \\"NO\\"","solution":"def can_transform_with_one_swap(A, B): Determine if you can transform string A into string B using exactly one swap operation. Parameters: A (str): The initial string. B (str): The target string. Returns: str: \\"YES\\" if it is possible to transform A into B with one swap, \\"NO\\" otherwise. if len(A) != len(B): return \\"NO\\" # Find all positions where A and B differ diff = [(a, b) for a, b in zip(A, B) if a != b] # We can only succeed if there are exactly two positions that differ # and swapping them makes the strings equal if len(diff) == 2 and diff[0] == diff[1][::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def flatten_list(nested_list: list[list[int]]) -> list[int]: Flattens a list of lists of integers into a single list of integers. Args: nested_list (list of lists of int): The list of lists to flatten. Returns: list of int: The flattened list. Examples: >>> flatten_list([[1, 2, 3], [4, 5], [6, 7, 8, 9]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_list([[10, 20], [30], [40, 50, 60]]) [10, 20, 30, 40, 50, 60] >>> flatten_list([[5], [1, 2], [3, 4]]) [5, 1, 2, 3, 4]","solution":"def flatten_list(nested_list): Flattens a list of lists of integers into a single list of integers. Args: nested_list (list of lists of int): The list of lists to flatten. Returns: list of int: The flattened list. flat_list = [] for sublist in nested_list: for item in sublist: flat_list.append(item) return flat_list"},{"question":"def is_rotated_version(S: str, P: str) -> bool: Write a function that takes two strings, S and P, and returns True if S is a rotated version of P, and False otherwise. A string S is a rotated version of P if S can be obtained by rotating P by any number of positions. >>> is_rotated_version(\\"amazon\\", \\"azonam\\") True >>> is_rotated_version(\\"hello\\", \\"ohlle\\") False >>> is_rotated_version(\\"rotation\\", \\"tationro\\") True","solution":"def is_rotated_version(S, P): Checks if S is a rotated version of P. Parameters: S (str): The string to be checked. P (str): The original string. Returns: bool: True if S is a rotated version of P, False otherwise. if len(S) != len(P): return False concatenated = P + P return S in concatenated"},{"question":"def can_arrange_bin_ids(bin_ids: List[int]) -> Tuple[str, List[int]]: Determines if bin IDs can be arranged such that each bin ID's value is either halved or doubled compared to the previous bin ID in the sequence. :param bin_ids: A list of distinct positive integers representing bin IDs. :return: A tuple with a string \\"YES\\" or \\"NO\\", and the sequence if \\"YES\\" otherwise an empty list. >>> can_arrange_bin_ids([4, 1, 8, 2]) == (\\"YES\\", [1, 2, 4, 8]) >>> can_arrange_bin_ids([7, 3, 15]) == (\\"NO\\", []) >>> can_arrange_bin_ids([5]) == (\\"YES\\", [5]) >>> can_arrange_bin_ids([2, 4, 8, 1, 16]) == (\\"YES\\", [1, 2, 4, 8, 16]) >>> can_arrange_bin_ids([500000, 1000000, 250000, 125000]) == (\\"YES\\", [125000, 250000, 500000, 1000000]) >>> can_arrange_bin_ids([10, 20, 40, 5]) == (\\"YES\\", [5, 10, 20, 40]) >>> can_arrange_bin_ids([14, 5, 10]) == (\\"NO\\", [])","solution":"def can_arrange_bin_ids(bin_ids): Determines if bin IDs can be arranged such that each bin ID's value is either halved or doubled compared to the previous bin ID in the sequence. :param bin_ids: A list of distinct positive integers representing bin IDs. :return: A tuple with a string \\"YES\\" or \\"NO\\", and the sequence if \\"YES\\" otherwise an empty list. bin_ids.sort() n = len(bin_ids) for i in range(n): sequence = [bin_ids[i]] used = set(sequence) for _ in range(n - 1): last = sequence[-1] if last * 2 in bin_ids and last * 2 not in used: sequence.append(last * 2) used.add(last * 2) elif last % 2 == 0 and last // 2 in bin_ids and last // 2 not in used: sequence.append(last // 2) used.add(last // 2) else: break if len(sequence) == n: return (\\"YES\\", sequence) return (\\"NO\\", [])"},{"question":"def min_operations_to_increasing_sequence(n: int, sequence: List[int]) -> int: Returns the minimum number of operations required to transform the given sequence into a strictly increasing sequence. Args: n (int): Length of the sequence. sequence (List[int]): A list of non-negative integers representing the sequence. Returns: int: The minimum number of increments required. >>> min_operations_to_increasing_sequence(4, [1, 2, 2, 4]) 1 >>> min_operations_to_increasing_sequence(5, [3, 3, 3, 3, 3]) 10 >>> min_operations_to_increasing_sequence(3, [5, 1, 8]) 5 from typing import List def test_single_element(): assert min_operations_to_increasing_sequence(1, [0]) == 0 def test_no_operations_needed(): assert min_operations_to_increasing_sequence(4, [1, 2, 3, 4]) == 0 def test_one_operation_needed(): assert min_operations_to_increasing_sequence(4, [1, 2, 2, 4]) == 1 def test_multiple_operations_needed(): assert min_operations_to_increasing_sequence(5, [3, 3, 3, 3, 3]) == 10 def test_varied_operations_needed(): assert min_operations_to_increasing_sequence(3, [5, 1, 8]) == 5 def test_large_numbers(): assert min_operations_to_increasing_sequence(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) == 10 def test_increasing_sequence(): assert min_operations_to_increasing_sequence(6, [1, 3, 7, 11, 15, 18]) == 0","solution":"def min_operations_to_increasing_sequence(n, sequence): Returns the minimum number of operations required to transform the given sequence into a strictly increasing sequence. if n == 1: return 0 operations = 0 for i in range(1, n): if sequence[i] <= sequence[i - 1]: operations += (sequence[i - 1] - sequence[i] + 1) sequence[i] = sequence[i - 1] + 1 return operations"},{"question":"def validate_serial(serial: str) -> bool: Validates if the given serial number follows the pattern: 1 uppercase letter, followed by 3 digits, a hyphen, 2 uppercase letters, and 3 digits. >>> validate_serial(\\"A123-BC456\\") True >>> validate_serial(\\"a123-BC456\\") False >>> validate_serial(\\"A12-BC456\\") False >>> validate_serial(\\"A123BC456\\") False >>> validate_serial(\\"A123-Bc456\\") False","solution":"import re def validate_serial(serial: str) -> bool: Validates if the given serial number follows the pattern: 1 uppercase letter, followed by 3 digits, a hyphen, 2 uppercase letters, and 3 digits. pattern = r'^[A-Z][0-9]{3}-[A-Z]{2}[0-9]{3}' return bool(re.match(pattern, serial))"},{"question":"def typewriter_display(N: int, S: str) -> List[str]: Simulates the display of a typewriter with a given length N for the sequence S. Parameters: N (int): The length of the display. S (str): The sequence of characters to be displayed. Returns: List[str]: The sequence of displays for each step. Examples: >>> typewriter_display(5, 'HELLO') ['H....', 'HE...', 'HEL..', 'HELL.', 'HELLO'] >>> typewriter_display(3, 'WORLD') ['W..', 'WO.', 'WOR', 'ORL', 'RLD']","solution":"def typewriter_display(N, S): Simulates the display of a typewriter with a given length N for the sequence S. Parameters: N (int): The length of the display. S (string): The sequence of characters to be displayed. Returns: List[string]: The sequence of displays for each step. display = ['.' * N] for i in range(len(S)): display.append((S[max(0, i+1-N):i+1] + '.' * N)[:N]) return display[1:]"},{"question":"def min_time_to_meet(x1, y1, x2, y2): Returns the minimum time in minutes for Sam and Alex to meet. >>> min_time_to_meet(2, 3, 5, 3) 3 >>> min_time_to_meet(1, 4, 4, 1) 6 def process_test_cases(test_cases): Process multiple test cases and returns the results. >>> process_test_cases([(2, 3, 5, 3), (1, 4, 4, 1)]) [3, 6]","solution":"def min_time_to_meet(x1, y1, x2, y2): Returns the minimum time in minutes for Sam and Alex to meet. if x1 == x2 or y1 == y2: # if they are already aligned either horizontally or vertically return abs(x2 - x1) + abs(y2 - y1) else: # if they are at different horizontal and vertical lines return abs(x2 - x1) + abs(y2 - y1) def process_test_cases(test_cases): results = [] for (x1, y1, x2, y2) in test_cases: results.append(min_time_to_meet(x1, y1, x2, y2)) return results"},{"question":"def min_subarray_len(n: int, S: int, array: List[int]) -> int: Returns the smallest length of a subarray in 'array' with sum at least 'S'. If no such subarray exists, returns 0. Args: n: int - the number of elements in the array S: int - the required sum array: List[int] - the elements of the array Returns: int - the length of the smallest subarray with sum at least S, or 0 if no such subarray exists. >>> min_subarray_len(10, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> min_subarray_len(5, 11, [1, 2, 3, 4, 5]) 3 >>> min_subarray_len(5, 21, [1, 2, 3, 4, 5]) 0 >>> min_subarray_len(1, 1, [1]) 1 >>> min_subarray_len(1, 2, [1]) 0 >>> min_subarray_len(3, 6, [1, 2, 3]) 3 >>> min_subarray_len(5, 1000000000, [1, 2, 3, 4, 5]) 0 >>> min_subarray_len(100000, 50000, [1] * 100000) 50000 >>> min_subarray_len(100000, 100000, [1] * 100000) 100000 pass","solution":"def min_subarray_len(n, S, array): Returns the smallest length of a subarray in 'array' with sum at least 'S'. If no such subarray exists, returns 0. left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += array[right] while current_sum >= S: min_length = min(min_length, right - left + 1) current_sum -= array[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def can_pay_exact_amount(n, coins, k): Determines if the exact amount k can be paid using the given coins. >>> can_pay_exact_amount(3, [1, 2, 3], 5) True >>> can_pay_exact_amount(2, [2, 4], 7) False >>> can_pay_exact_amount(2, [3, 6], 9) True # function implementation here def process_test_cases(test_cases): Processes multiple test cases to determine if the exact amount can be paid using the given coins. >>> process_test_cases([(3, [1, 2, 3], 5), (2, [2, 4], 7), (2, [3, 6], 9)]) ['YES', 'NO', 'YES'] >>> process_test_cases([(1, [1], 1), (1, [1], 0)]) ['YES', 'YES'] # function implementation here","solution":"def can_pay_exact_amount(n, coins, k): Determines if the exact amount k can be paid using the given coins. dp = [False] * (k + 1) dp[0] = True for i in range(1, k + 1): for coin in coins: if i >= coin and dp[i - coin]: dp[i] = True break return dp[k] def process_test_cases(test_cases): results = [] for n, coins, k in test_cases: if can_pay_exact_amount(n, coins, k): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def calculate_scores(num_participants: int, scores_details: List[Tuple[int, int, int]]) -> List[int]: Calculate the score of each participant based on the given scoring system. :param num_participants: The number of participants :param scores_details: List of tuples, each containing Y, M, and K :return: List of scores for each participant >>> calculate_scores(3, [(90, 5, 3), (200, 10, 6), (150, 15, 7)]) [54, 120, 70] >>> calculate_scores(1, [(100, 4, 2)]) [50] >>> calculate_scores(2, [(80, 4, 4), (70, 7, 7)]) [80, 70]","solution":"def calculate_scores(num_participants, scores_details): Calculate the score of each participant based on the given scoring system. :param num_participants: The number of participants :param scores_details: List of tuples, each containing Y, M, and K :return: List of scores for each participant results = [] for details in scores_details: Y, M, K = details points_per_subproblem = Y // M score = points_per_subproblem * K results.append(score) return results"},{"question":"def turns_to_end_game(N: int, K: int, P: int) -> int: Returns the number of turns to draw card K given N cards and P players. Args: N (int): Total number of cards. K (int): The card number K which ends the game. P (int): Number of players. Returns: int: Number of turns to end the game. Examples: >>> turns_to_end_game(10, 3, 2) 3 >>> turns_to_end_game(10, 10, 3) 10 >>> turns_to_end_game(1, 1, 1) 1 >>> turns_to_end_game(100, 50, 5) 50 >>> turns_to_end_game(1000, 999, 10) 999 >>> turns_to_end_game(15, 4, 7) 4 >>> turns_to_end_game(1000000000, 1000000000, 1000000) 1000000000","solution":"def turns_to_end_game(N, K, P): Returns the number of turns to draw card K given N cards and P players. Args: N (int): Total number of cards. K (int): The card number K which ends the game. P (int): Number of players. Returns: int: Number of turns to end the game. # Number of turns to draw 1...K cards would be K. # Since players are drawing cards in round-robin, the turn of the player drawing card K return K"},{"question":"class RegistrationSystem: A class to manage the registration process for an event. Operations: 1. register(): Registers a new attendee, assigns them the next available ID, and returns the ID. 2. cancel(k): Cancels the registration of the attendee with ID \`k\`. 3. check(k): Checks if an attendee with ID \`k\` is registered and active. 4. retrieve(): Retrieves the list of all active IDs in ascending order. Example: >>> rs = RegistrationSystem() >>> rs.register() 1 >>> rs.register() 2 >>> rs.cancel(1) >>> rs.check(1) False >>> rs.check(2) True >>> rs.register() 3 >>> rs.retrieve() [2, 3] def __init__(self): pass # Your code goes here def register(self): Register a new attendee and return their ID. pass # Your code goes here def cancel(self, k): Cancel the registration of an attendee with ID \`k\`. pass # Your code goes here def check(self, k): Check if an attendee with ID \`k\` is registered and active. pass # Your code goes here def retrieve(self): Retrieve the list of all active IDs in ascending order. pass # Your code goes here # Unit Tests def test_register(): rs = RegistrationSystem() assert rs.register() == 1 assert rs.register() == 2 assert rs.register() == 3 def test_cancel(): rs = RegistrationSystem() rs.register() rs.register() rs.cancel(1) assert rs.check(1) == False assert rs.check(2) == True def test_check(): rs = RegistrationSystem() rs.register() rs.register() rs.cancel(1) assert rs.check(1) == False assert rs.check(2) == True assert rs.check(3) == False def test_retrieve(): rs = RegistrationSystem() rs.register() rs.register() rs.cancel(1) rs.register() assert rs.retrieve() == [2, 3]","solution":"class RegistrationSystem: def __init__(self): self.current_id = 0 self.active_ids = set() self.cancelled_ids = set() def register(self): self.current_id += 1 self.active_ids.add(self.current_id) return self.current_id def cancel(self, k): if k in self.active_ids: self.active_ids.remove(k) self.cancelled_ids.add(k) def check(self, k): return k in self.active_ids def retrieve(self): return sorted(self.active_ids)"},{"question":"import math def num_divisors(num): Helper function to calculate the number of divisors of a given number. count = 0 for i in range(1, int(math.sqrt(num)) + 1): if num % i == 0: if i == num // i: count += 1 else: count += 2 return count def next_highly_divisible(n): Returns the smallest integer which has more than n divisors. >>> next_highly_divisible(5) 12 >>> next_highly_divisible(7) 24 >>> next_highly_divisible(1) 2 >>> next_highly_divisible(15) 120 >>> next_highly_divisible(0) 2 >>> next_highly_divisible(2) 4 # Your code here def test_next_highly_divisible_five_divisors(): assert next_highly_divisible(5) == 12 def test_next_highly_divisible_seven_divisors(): assert next_highly_divisible(7) == 24 def test_next_highly_divisible_one_divisor(): assert next_highly_divisible(1) == 2 def test_next_highly_divisible_fifteen_divisors(): assert next_highly_divisible(15) == 120 def test_next_highly_divisible_zero_divisors(): assert next_highly_divisible(0) == 2 def test_next_highly_divisible_two_divisors(): assert next_highly_divisible(2) == 4","solution":"import math def num_divisors(num): Helper function to calculate the number of divisors of a given number. count = 0 for i in range(1, int(math.sqrt(num)) + 1): if num % i == 0: if i == num // i: count += 1 else: count += 2 return count def next_highly_divisible(n): Returns the smallest integer which has more than n divisors. num = 2 while True: if num_divisors(num) > n: return num num += 1"},{"question":"from typing import List def isIncreasingPath(M: int, N: int, matrix: List[List[int]]) -> bool: Determines if there is a path from the top-left corner to the bottom-right corner in the matrix such that all values along the path are in strictly increasing order. Parameters: 1. M (int): the number of rows in the matrix 2. N (int): the number of columns in the matrix 3. matrix (List[List[int]]): the matrix of integers Returns: bool: True if there is an increasing path, otherwise False. import pytest from solution import isIncreasingPath def test_case_1(): M = 3 N = 3 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert isIncreasingPath(M, N, matrix) == True def test_case_2(): M = 3 N = 3 matrix = [ [9, 1, 2], [6, 5, 4], [3, 2, 1] ] assert isIncreasingPath(M, N, matrix) == False def test_case_3(): M = 1 N = 1 matrix = [ [1] ] assert isIncreasingPath(M, N, matrix) == True def test_case_4(): M = 2 N = 2 matrix = [ [1, 3], [2, 4] ] assert isIncreasingPath(M, N, matrix) == True def test_case_5(): M = 2 N = 3 matrix = [ [1, 2, 5], [2, 3, 6] ] assert isIncreasingPath(M, N, matrix) == True def test_case_6(): M = 2 N = 3 matrix = [ [5, 4, 3], [6, 1, 2] ] assert isIncreasingPath(M, N, matrix) == False","solution":"def isIncreasingPath(M, N, matrix): Determines if there is a path from the top-left corner to the bottom-right corner in the matrix such that all values along the path are in strictly increasing order. Parameters: 1. M (int): the number of rows in the matrix 2. N (int): the number of columns in the matrix 3. matrix (List[List[int]]): the matrix of integers Returns: bool: True if there is an increasing path, otherwise False. # If the matrix is empty, return False if M == 0 or N == 0: return False # A 2D list to keep track of the paths that have been validated dp = [[False] * N for _ in range(M)] dp[0][0] = True for i in range(M): for j in range(N): if i > 0 and dp[i-1][j] and matrix[i][j] > matrix[i-1][j]: dp[i][j] = True if j > 0 and dp[i][j-1] and matrix[i][j] > matrix[i][j-1]: dp[i][j] = True return dp[M-1][N-1]"},{"question":"from typing import List, Tuple def flexiFibonacci(start: Tuple[int, int], step: int, n: int) -> List[int]: Generate an exotic variant of a Fibonacci sequence called FlexiFibonacci. Args: start (Tuple[int, int]): A tuple containing the first two numbers of the sequence. step (int): Number of terms to sum in order to determine the next term of the sequence. n (int): Length of the sequence to be generated. Returns: List[int]: Generated FlexiFibonacci sequence of length n. Example: >>> flexiFibonacci((0, 1), 2, 6) [0, 1, 1, 2, 3, 5] >>> flexiFibonacci((2, 3), 2, 6) [2, 3, 5, 8, 13, 21] >>> flexiFibonacci((1, 1), 3, 7) [1, 1, 2, 4, 7, 13, 24]","solution":"from typing import List, Tuple def flexiFibonacci(start: Tuple[int, int], step: int, n: int) -> List[int]: if n == 0: return [] elif n == 1: return [start[0]] elif n == 2: return [start[0], start[1]] sequence = [start[0], start[1]] for i in range(2, n): sum_value = sum(sequence[max(0, i-step):i]) sequence.append(sum_value) return sequence"},{"question":"def length_of_lcis(nums: List[int]) -> int: Returns the length of the longest continuous increasing subsequence in the array. >>> length_of_lcis([1, 3, 5, 4, 7]) == 3 >>> length_of_lcis([2, 2, 2, 2, 2]) == 1 >>> length_of_lcis([1, 2, 3, 4, 5]) == 5 >>> length_of_lcis([]) == 0 >>> length_of_lcis([10]) == 1 >>> length_of_lcis([5, 4, 3, 2, 1]) == 1 >>> length_of_lcis([1, 3, 5, 4, 2, 9, 11, 15, 0]) == 4","solution":"def length_of_lcis(nums): Returns the length of the longest continuous increasing subsequence in the array. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] > nums[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def floyd_warshall(N: int, M: int, roads: List[Tuple[int, int, int]]) -> List[List[Union[int, str]]]: Find the shortest travel time between each pair of cities. If there is no path between a pair of cities, output \\"INF\\" (infinity). Args: N (int): Number of cities M (int): Number of roads roads (list of tuples): Each tuple contains three integers U, V, and T, where U is the starting city, V is the destination city, and T is the travel time between these cities. Returns: list of lists: An N x N matrix, where the element at row i and column j is the shortest travel time from city i+1 to city j+1. If there is no path from city i+1 to city j+1, output \\"INF\\" for that element. Examples: >>> floyd_warshall(4, 4, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10)]) [[0, 3, 7, 10], ['INF', 0, 4, 9], ['INF', 'INF', 0, 5], ['INF', 'INF', 'INF', 0]] >>> floyd_warshall(3, 2, [(1, 2, 1), (2, 3, 2)]) [[0, 1, 3], ['INF', 0, 2], ['INF', 'INF', 0]] >>> floyd_warshall(2, 0, []) [[0, 'INF'], ['INF', 0]]","solution":"def floyd_warshall(N, M, roads): INF = float('inf') dist = [[INF] * N for _ in range(N)] for i in range(N): dist[i][i] = 0 for (u, v, t) in roads: dist[u - 1][v - 1] = t for k in range(N): for i in range(N): for j in range(N): if dist[i][k] < INF and dist[k][j] < INF: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) for i in range(N): for j in range(N): if dist[i][j] == INF: dist[i][j] = 'INF' return dist"},{"question":"def find_pairs_with_sum(numbers, target): Finds all unique pairs in the list which sum up to target. Arguments: numbers -- list of integers target -- target sum of pairs of integers Returns: A list of tuples where each tuple contains a unique pair of integers that add up to the given target, sorted by the first element of the pair. >>> find_pairs_with_sum([2, 4, 3, 5, 7, 8, 9], 7) [(2, 5), (3, 4)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 6) [(1, 5), (2, 4)] >>> find_pairs_with_sum([0, -1, -2, 1, 2], 0) [(-2, 2), (-1, 1)] >>> find_pairs_with_sum([1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs_with_sum([], 5) [] >>> find_pairs_with_sum([5, 5, 5, 5], 10) [(5, 5)] >>> find_pairs_with_sum([1, 3, 2, 2, 4, 1, 5, 3], 4) [(1, 3), (2, 2)]","solution":"def find_pairs_with_sum(numbers, target): Finds all unique pairs in the list which sum up to target. Arguments: numbers -- list of integers target -- target sum of pairs of integers Returns: A list of tuples where each tuple contains a unique pair of integers that add up to the given target, sorted by the first element of the pair. pairs = [] seen = set() used = set() for num in numbers: compliment = target - num if compliment in seen and (min(num, compliment), max(num, compliment)) not in used: pairs.append((min(num, compliment), max(num, compliment))) used.add((min(num, compliment), max(num, compliment))) seen.add(num) return sorted(pairs)"},{"question":"def most_popular_preference(n: int, m: int, preferences: List[List[int]]) -> int: Returns the id of the most popular preference among a set of users. Parameters: - n: int, number of users (1 <= n <= 200,000) - m: int, number of preferences for each user (1 <= m <= 100) - preferences: List of List of int, where each sublist represents the preferences of a user Returns: - int, the id of the most popular preference. The most popular preference is defined as the preference that appears first in the preferences list of the most users. If there is a tie, the preference that appears earlier in the preferences lists should be chosen. >>> most_popular_preference(3, 3, [[1, 2, 3], [3, 1, 2], [2, 3, 1]]) 1 >>> most_popular_preference(4, 4, [[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]) 1 from solution import most_popular_preference def test_single_preference(): assert most_popular_preference(1, 1, [[1]]) == 1 def test_simple_case(): assert most_popular_preference(3, 3, [[1, 2, 3], [3, 1, 2], [2, 3, 1]]) == 1 def test_multiple_users(): assert most_popular_preference(4, 4, [[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]) == 1 def test_tie_breaker_by_order(): assert most_popular_preference(3, 2, [[2, 3], [2, 1], [1, 2]]) == 2 def test_no_tie_case(): assert most_popular_preference(4, 2, [[1, 2], [1, 3], [1, 4], [2, 1]]) == 1 def test_large_case(): n = 200000 m = 100 preferences = [[i + 1 for i in range(m)] for _ in range(n)] assert most_popular_preference(n, m, preferences) == 1","solution":"def most_popular_preference(n, m, preferences): Returns the id of the most popular preference. n: number of users m: number of preferences for each user preferences: list of lists where each sublist represents the preferences of a user preference_count = {} # Count the number of times each preference is the first choice. for user_prefs in preferences: first_pref = user_prefs[0] if first_pref in preference_count: preference_count[first_pref] += 1 else: preference_count[first_pref] = 1 # Find the preference with the maximum count, and resolve ties by selecting the preference with the smallest id most_popular = None max_count = 0 for preference, count in preference_count.items(): if count > max_count or (count == max_count and (most_popular is None or preference < most_popular)): most_popular = preference max_count = count return most_popular"},{"question":"import math def largest_rectangular_section(n: int, m: int) -> tuple: Finds the dimensions of the largest possible smaller rectangular section that can evenly divide the garden of dimensions n by m. Parameters: n (int): The number of rows in the garden. m (int): The number of columns in the garden. Returns: tuple: The dimensions of the largest rectangular section. >>> largest_rectangular_section(12, 15) (3, 3) >>> largest_rectangular_section(7, 14) (7, 7) >>> largest_rectangular_section(13, 17) (1, 1) >>> largest_rectangular_section(1, 10) (1, 1) >>> largest_rectangular_section(10, 1) (1, 1) >>> largest_rectangular_section(1000000, 500000) (500000, 500000) >>> largest_rectangular_section(10, 10) (10, 10)","solution":"import math def largest_rectangular_section(n, m): Finds the dimensions of the largest possible smaller rectangular section that can evenly divide the garden of dimensions n by m. Parameters: n (int): The number of rows in the garden. m (int): The number of columns in the garden. Returns: tuple: The dimensions of the largest rectangular section. gcd = math.gcd(n, m) return (gcd, gcd)"},{"question":"def min_lights_to_illuminate(grid): Find the minimum number of lights required to illuminate the entire park. A light placed in an empty cell will illuminate all the empty cells in the same row and the same column until it hits an obstacle or the boundary of the grid. Args: grid: List of strings representing the grid Returns: int: Minimum number of lights required to illuminate all the empty cells Example: >>> min_lights_to_illuminate([ ... \\".#.\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".#.\\" ... ]) 3 >>> min_lights_to_illuminate([ ... \\"#\\", ... \\"#..\\", ... \\"#\\" ... ]) 1 >>> min_lights_to_illuminate([ ... \\"\\", ... \\"\\" ... ]) 0 pass def process_test_cases(input_data): Processes multiple test cases to find minimum number of lights for each park. Args: input_data: List of strings, where the first line contains integers 'n' and 'm' followed by 'n' lines of the grid and so on. Ends with a line '0 0'. Returns: List of integers: Minimum number of lights required for each test case Example: >>> process_test_cases([ ... \\"4 5\\", ... \\".#.\\", ... \\".#.#.\\", ... \\".#.#.\\", ... \\".#.\\", ... \\"3 3\\", ... \\"#\\", ... \\"#..\\", ... \\"#\\", ... \\"2 2\\", ... \\"\\", ... \\"\\", ... \\"0 0\\" ... ]) [3, 1, 0] pass def test_min_lights_to_illuminate_single_case(): assert min_lights_to_illuminate([ \\".#.\\", \\".#.#.\\", \\".#.#.\\", \\".#.\\" ]) == 3 assert min_lights_to_illuminate([ \\"#\\", \\"#..\\", \\"#\\" ]) == 1 assert min_lights_to_illuminate([ \\"\\", \\"\\" ]) == 0 def test_process_test_cases_multiple_cases(): input_data = [ \\"4 5\\", \\".#.\\", \\".#.#.\\", \\".#.#.\\", \\".#.\\", \\"3 3\\", \\"#\\", \\"#..\\", \\"#\\", \\"2 2\\", \\"\\", \\"\\", \\"0 0\\" ] expected_output = [3, 1, 0] assert process_test_cases(input_data) == expected_output","solution":"def min_lights_to_illuminate(grid): n = len(grid) m = len(grid[0]) if n > 0 else 0 # To track the cells which are already illuminated illuminated = [[False] * m for _ in range(n)] light_count = 0 for i in range(n): for j in range(m): if grid[i][j] == '.' and not illuminated[i][j]: # Place a light light_count += 1 # Illuminate the cells in the same row for k in range(j, m): if grid[i][k] == '#': break illuminated[i][k] = True for k in range(j, -1, -1): if grid[i][k] == '#': break illuminated[i][k] = True # Illuminate the cells in the same column for k in range(i, n): if grid[k][j] == '#': break illuminated[k][j] = True for k in range(i, -1, -1): if grid[k][j] == '#': break illuminated[k][j] = True return light_count def process_test_cases(input_data): index = 0 results = [] while index < len(input_data): n, m = map(int, input_data[index].split()) index += 1 if n == 0 and m == 0: break grid = [] for _ in range(n): grid.append(input_data[index]) index += 1 results.append(min_lights_to_illuminate(grid)) return results"},{"question":"def sum_of_squares(input_string: str) -> int: Takes a string of space-separated integers and returns the sum of their squares. >>> sum_of_squares(\\"1 2 3\\") == 14 >>> sum_of_squares(\\"4 5 6\\") == 77","solution":"def sum_of_squares(input_string): Takes a string of space-separated integers and returns the sum of their squares. Parameters: input_string (str): A string containing space-separated non-negative integers Returns: int: The sum of the squares of the integers integers = map(int, input_string.split()) return sum(x**2 for x in integers)"},{"question":"class InventoryManager: def __init__(self): Initializes the inventory and transactions. self.inventory = {} self.transactions = [] def add_item(self, item_name, price, quantity): Adds a new item to the inventory with the given name, price, and quantity. If the item already exists, update its price and quantity. pass def update_quantity(self, item_name, quantity): Updates the quantity of the specified item. If the item does not exist, ignore the operation. pass def process_purchase(self, customer_name, item_name, quantity): Processes a purchase where the specified customer buys the given quantity of the item. If the item does not exist or there is not enough quantity in stock, record the purchase but indicate it was unsuccessful. Otherwise, deduct the quantity from the inventory and record the transaction. pass def main(): import sys input = sys.stdin.read commands = input().strip().split('n') inv_manager = InventoryManager() for command in commands: if command == \\"END\\": break parts = command.split() operation = parts[0] if operation == \\"ADD\\": item_name = parts[1] price = int(parts[2]) quantity = int(parts[3]) inv_manager.add_item(item_name, price, quantity) elif operation == \\"UPDATE\\": item_name = parts[1] quantity = int(parts[2]) inv_manager.update_quantity(item_name, quantity) elif operation == \\"BUY\\": customer_name = parts[1] item_name = parts[2] quantity = int(parts[3]) inv_manager.process_purchase(customer_name, item_name, quantity)","solution":"class InventoryManager: def __init__(self): self.inventory = {} self.transactions = [] def add_item(self, item_name, price, quantity): if item_name in self.inventory: self.inventory[item_name]['price'] = price self.inventory[item_name]['quantity'] += quantity else: self.inventory[item_name] = {'price': price, 'quantity': quantity} def update_quantity(self, item_name, quantity): if item_name in self.inventory: self.inventory[item_name]['quantity'] = quantity def process_purchase(self, customer_name, item_name, quantity): if item_name in self.inventory and self.inventory[item_name]['quantity'] >= quantity: self.inventory[item_name]['quantity'] -= quantity self.transactions.append(f\\"SUCCESS: {customer_name} bought {quantity} of {item_name}\\") print(f\\"SUCCESS: {customer_name} bought {quantity} of {item_name}\\") else: self.transactions.append(f\\"FAIL: {customer_name} could not buy {quantity} of {item_name}\\") print(f\\"FAIL: {customer_name} could not buy {quantity} of {item_name}\\") def main(): import sys input = sys.stdin.read commands = input().strip().split('n') inv_manager = InventoryManager() for command in commands: if command == \\"END\\": break parts = command.split() operation = parts[0] if operation == \\"ADD\\": item_name = parts[1] price = int(parts[2]) quantity = int(parts[3]) inv_manager.add_item(item_name, price, quantity) elif operation == \\"UPDATE\\": item_name = parts[1] quantity = int(parts[2]) inv_manager.update_quantity(item_name, quantity) elif operation == \\"BUY\\": customer_name = parts[1] item_name = parts[2] quantity = int(parts[3]) inv_manager.process_purchase(customer_name, item_name, quantity)"},{"question":"def knapsack(W, n, items): Determines the maximum value Sam can achieve with a given weight limit W and a list of items. Each item is described by its weight and value. :param W: Maximum weight the backpack can hold (1 â‰¤ W â‰¤ 10000) :param n: Number of items (1 â‰¤ n â‰¤ 300) :param items: List of tuples (weight, value) for each item, where 1 â‰¤ wi, vi â‰¤ 1000 :return: Maximum value achievable within the weight limit >>> knapsack(50, 3, [(10, 60), (20, 100), (30, 120)]) 220 >>> knapsack(10, 2, [(5, 30), (4, 20)]) 50 pass def test_knapsack_example1(): W = 50 n = 3 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(W, n, items) == 220 def test_knapsack_example2(): W = 10 n = 2 items = [(5, 30), (4, 20)] assert knapsack(W, n, items) == 50 def test_knapsack_all_items_fit(): W = 100 n = 4 items = [(10, 20), (20, 30), (30, 40), (40, 50)] assert knapsack(W, n, items) == 140 def test_knapsack_no_items(): W = 50 n = 0 items = [] assert knapsack(W, n, items) == 0 def test_knapsack_single_item(): W = 50 n = 1 items = [(60, 100)] assert knapsack(W, n, items) == 0 def test_knapsack_heavy_items(): W = 100 n = 3 items = [(60, 100), (70, 150), (80, 200)] assert knapsack(W, n, items) == 200 def test_knapsack_equal_weight_value(): W = 50 n = 5 items = [(10, 10), (20, 20), (30, 30), (40, 40), (50, 50)] assert knapsack(W, n, items) == 50","solution":"def knapsack(W, n, items): Determines the maximum value we can achieve with a given weight limit W and a list of items. Each item is described by its weight and value. :param W: Maximum weight the backpack can hold :param n: Number of items :param items: List of tuples (weight, value) describing each item :return: Maximum value achievable within the weight limit dp = [0] * (W + 1) for weight, value in items: for w in range(W, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[W] def process_input(): input = sys.stdin.read().split() W = int(input[0]) n = int(input[1]) items = [(int(input[i * 2 + 2]), int(input[i * 2 + 3])) for i in range(n)] return W, n, items if __name__ == \\"__main__\\": W, n, items = process_input() print(knapsack(W, n, items))"},{"question":"from collections import deque def shortest_path_in_maze(N, M, maze, sx, sy, ex, ey): Find the shortest path in a maze from start (sx, sy) to end (ex, ey). Each cell can either be a path ('.') or a wall ('#'). You can move up, down, left, or right between adjacent cells. Returns the length of the shortest path, or -1 if no path exists. >>> maze = [ ... \\".....\\", ... \\".#.\\", ... \\"..#..\\", ... \\".#.\\", ... \\".....\\" ... ] >>> shortest_path_in_maze(5, 5, maze, 0, 0, 4, 4) 8 >>> shortest_path_in_maze(5, 5, maze, 0, 0, 4, 4) -1 >>> shortest_path_in_maze(5, 5, maze, 0, 0, 0, 0) 0 >>> shortest_path_in_maze(5, 5, maze, 0, 0, 0, 1) 1","solution":"from collections import deque def shortest_path_in_maze(N, M, maze, sx, sy, ex, ey): if (sx, sy) == (ex, ey): # Start and end are the same return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(sx, sy, 0)]) # (x, y, steps) visited = [[False] * M for _ in range(N)] visited[sx][sy] = True while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and maze[nx][ny] == '.': if (nx, ny) == (ex, ey): return steps + 1 visited[nx][ny] = True queue.append((nx, ny, steps + 1)) return -1"},{"question":"from typing import List, Tuple def shortest_path(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Find the shortest path in an M x N grid from the start to the target position. A return value of -1 indicates no valid path exists. The grid cells are denoted by 0 for passable cells and 1 for impassable cells. Args: grid (List[List[int]]): The M x N grid where 0 represents a passable cell and 1 represents an impassable cell. start (Tuple[int, int]): The starting coordinates (x_start, y_start). target (Tuple[int, int]): The target coordinates (x_target, y_target). Returns: int: The length of the shortest path from start to target, or -1 if no valid path exists. >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid, (0, 0), (2, 2)) 4 >>> grid = [ ... [0, 0, 0], ... [1, 1, 1], ... [0, 0, 0] ... ] >>> shortest_path(grid, (0, 0), (2, 2)) -1 >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(grid, (0, 0), (0, 0)) 0 pass","solution":"from collections import deque def shortest_path(grid, start, target): M, N = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] x_start, y_start = start x_target, y_target = target if (x_start, y_start) == (x_target, y_target): return 0 queue = deque([(x_start, y_start, 0)]) visited = set([(x_start, y_start)]) while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 0: if (nx, ny) == (x_target, y_target): return steps + 1 queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"def max_affinity_value(n, affinities): Determine the maximum affinity value that can be achieved from any single tree by performing the joining operations optimally. Args: n : int : the number of trees in the forest affinities : List[int] : list of affinity ratings of each tree Returns: int : the highest affinity value of any tree that can be achieved >>> max_affinity_value(5, [5, 7, 12, 8, 3]) 15 >>> max_affinity_value(3, [1, 2, 4]) 7 >>> max_affinity_value(2, [15, 1]) 15 >>> max_affinity_value(4, [8, 8, 8, 8]) 8 >>> max_affinity_value(5, [0, 0, 0, 0, 0]) 0","solution":"def max_affinity_value(n, affinities): Returns the maximum affinity value of any tree after performing the joining operations optimally. max_affinity = 0 for affinity in affinities: max_affinity |= affinity # Using bitwise OR return max_affinity"},{"question":"def generate_zigzag_pattern(n): Generates a n x n matrix in a zigzag pattern as described. >>> generate_zigzag_pattern(2) [[1, 2], [4, 3]] >>> generate_zigzag_pattern(3) [[1, 2, 3], [6, 5, 4], [7, 8, 9]] def parse_input(data): Parses the input data. >>> parse_input(\\"2n4n5\\") [4, 5] >>> parse_input(\\"1n3\\") [3] def format_output(matrices): Formats the matrices for output. >>> format_output([[[1, 2], [4, 3]],[[1, 2, 3], [6, 5, 4], [7, 8, 9]]]) '1 2n4 3nn1 2 3n6 5 4n7 8 9' def main(data): Main function to run the entire process. >>> main(\\"2n4n5\\") '1 2 3 4n8 7 6 5n9 10 11 12n16 15 14 13nn1 2 3 4 5n10 9 8 7 6n11 12 13 14 15n20 19 18 17 16n21 22 23 24 25'","solution":"def generate_zigzag_pattern(n): Generates a n x n matrix in a zigzag pattern as described. matrix = [[0] * n for _ in range(n)] num = 1 for i in range(n): if i % 2 == 0: for j in range(n): matrix[i][j] = num num += 1 else: for j in range(n-1, -1, -1): matrix[i][j] = num num += 1 return matrix def parse_input(data): Parses the input data. lines = data.strip().split('n') d = int(lines[0]) sizes = [int(lines[i]) for i in range(1, d + 1)] return sizes def format_output(matrices): Formats the matrices for output. result = [] for matrix in matrices: lines = [' '.join(map(str, row)) for row in matrix] result.append('n'.join(lines)) return 'nn'.join(result) def main(data): sizes = parse_input(data) matrices = [generate_zigzag_pattern(n) for n in sizes] output = format_output(matrices) return output"},{"question":"def optimize_routes(routes: List[List[str]]) -> List[List[str]]: Optimize package delivery routes by merging overlapping routes to minimize the number of trips. >>> optimize_routes([[\\"CityA\\", \\"CityB\\", \\"CityC\\"], [\\"CityC\\", \\"CityD\\", \\"CityE\\"], [\\"CityF\\", \\"CityG\\"], [\\"CityG\\", \\"CityH\\", \\"CityI\\"], [\\"CityJ\\", \\"CityK\\"]]) [['CityA', 'CityB', 'CityC', 'CityD', 'CityE'], ['CityF', 'CityG', 'CityH', 'CityI'], ['CityJ', 'CityK']] >>> optimize_routes([[\\"CityA\\", \\"CityB\\"], [\\"CityB\\", \\"CityC\\"], [\\"CityC\\", \\"CityD\\"], [\\"CityD\\", \\"CityE\\"], [\\"CityE\\", \\"CityF\\"]]) [['CityA', 'CityB', 'CityC', 'CityD', 'CityE', 'CityF']]","solution":"def optimize_routes(routes): def merge_route(route1, route2): return sorted(list(set(route1) | set(route2))) merged = True while merged: merged = False for i in range(len(routes)): for j in range(i + 1, len(routes)): common_cities = set(routes[i]) & set(routes[j]) if common_cities: routes[i] = merge_route(routes[i], routes[j]) del routes[j] merged = True break if merged: break return routes"},{"question":"def character_occurrences(s: str) -> dict: Returns a dictionary with each character from the string as the key and the number of its occurrences as the value. The function is case insensitive. >>> character_occurrences('Programming') {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1} >>> character_occurrences('AaAa') {'a': 4} def test_single_character(): assert character_occurrences('a') == {'a': 1} def test_multiple_characters(): assert character_occurrences('Programming') == { 'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1 } def test_empty_string(): assert character_occurrences('') == {} def test_case_insensitivity(): assert character_occurrences('AaAa') == {'a': 4} def test_mixed_characters(): assert character_occurrences('A1b2A1b2') == {'a': 2, '1': 2, 'b': 2, '2': 2}","solution":"def character_occurrences(s): Returns a dictionary with each character from the string as the key and the number of its occurrences as the value. The function is case insensitive. s = s.lower() occurrences = {} for char in s: if char in occurrences: occurrences[char] += 1 else: occurrences[char] = 1 return occurrences"},{"question":"def minimum_cost_to_connect_planets(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Compute the minimum total travel cost needed to establish connectivity between planets. >>> minimum_cost_to_connect_planets(4, 5, [(1, 2, 10), (2, 3, 15), (3, 4, 20), (1, 3, 30), (2, 4, 25)]) 45 >>> minimum_cost_to_connect_planets(3, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 12)]) 15","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if u != self.parent[u]: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_cost_to_connect_planets(N, M, edges): edges = [(c, a-1, b-1) for a, b, c in edges] edges.sort() # Sort edges based on cost uf = UnionFind(N) mst_cost = 0 for cost, u, v in edges: if uf.find(u) != uf.find(v): uf.union(u, v) mst_cost += cost return mst_cost # Example usage: # N = 4 # M = 5 # edges = [(1, 2, 10), (2, 3, 15), (3, 4, 20), (1, 3, 30), (2, 4, 25)] # Output: 45"},{"question":"def find_b(t: int, cases: List[Tuple[int, List[int]]]) -> List[List[int]]: You are given an integer \`n\` and an array \`a\` of \`2n-1\` integers. Construct an array \`b\` of length \`n\` which is a subarray of all the following arrays: \`a[1..n]\`, \`a[2..n+1]\`, \`a[3..n+2]\`, ..., \`a[n..2n-1]\`. Args: t (int): The number of test cases. cases (List[Tuple[int, List[int]]]): Each case is a tuple containing an integer \`n\` and an array \`a\` of \`2n-1\` integers. Returns: List[List[int]]: For each test case, returns the constructed array \`b\` of length \`n\`. Example: >>> find_b(3, [(1, [5]), (3, [1, 2, 3, 4, 5]), (4, [3, 3, 3, 3, 3, 3, 3])]) [[5], [1, 2, 3], [3, 3, 3, 3]] >>> find_b(1, [(2, [4, 5, 6])]) [[4, 5]] >>> find_b(2, [(2, [-1, -2, -3]), (3, [-5, -4, -3, -2, -1])]) [[-1, -2], [-5, -4, -3]] >>> find_b(1, [(3, [7, 7, 7, 7, 7])]) [[7, 7, 7]]","solution":"def find_b(t, cases): results = [] for case in cases: n = case[0] a = case[1] b = a[:n] results.append(b) return results"},{"question":"def minimum_shipping_cost(M: int, demands: List[int]) -> int: Calculate the minimum cost to fulfill the demands over M days. Args: M: An integer representing the number of days. demands: A list of integers representing daily demand. Returns: The minimum cost to fulfill all the demands of the M days. >>> minimum_shipping_cost(5, [1, 2, 3, 4, 5]) 15 >>> minimum_shipping_cost(7, [5, 5, 5, 5, 5, 5, 5]) 35","solution":"def minimum_shipping_cost(M, demands): Calculates the minimum cost to fulfill the demands over M days. :param M: int, number of days. :param demands: list of int, demand on each day. :return: int, minimum shipping cost. total_cost = 0 for demand in demands: total_cost += demand return total_cost"},{"question":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray within nums which has the largest sum. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 >>> max_subarray_sum([1,2,3,4,5]) == 15 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([1, 2, 3, -2, 5]) == 9","solution":"def max_subarray_sum(nums): Returns the sum of the contiguous subarray within nums which has the largest sum. if not nums: return 0 current_sum = max_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_construct_pattern(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if Clara can construct a pattern following her rules. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains: - an integer n (the length of the desired pattern) - a list of integers representing the color of each bead in the desired pattern. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case based on whether the pattern can be constructed. Examples: >>> can_construct_pattern(3, [(6, [1, 1, 2, 2, 3, 3]), (4, [1, 2, 1, 2]), (5, [2, 2, 3, 3, 2])]) ['YES', 'NO', 'NO'] >>> can_construct_pattern(2, [(3, [1, 2, 3]), (4, [4, 4, 4, 4])]) ['YES', 'YES'] # Unit Test def test_can_construct_pattern(): assert can_construct_pattern(3, [(6, [1, 1, 2, 2, 3, 3]), (4, [1, 2, 1, 2]), (5, [2, 2, 3, 3, 2])]) == [\\"YES\\", \\"NO\\", \\"NO\\"] assert can_construct_pattern(2, [(3, [1, 2, 3]), (4, [4, 4, 4, 4])]) == [\\"YES\\", \\"YES\\"] assert can_construct_pattern(1, [(5, [1, 1, 2, 3, 3])]) == [\\"YES\\"] assert can_construct_pattern(1, [(7, [1, 1, 1, 2, 2, 1, 1])]) == [\\"NO\\"] assert can_construct_pattern(1, [(5, [1, 2, 3, 4, 5])]) == [\\"YES\\"] assert can_construct_pattern(1, [(10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])]) == [\\"YES\\"] assert can_construct_pattern(1, [(3, [1, 1, 1])]) == [\\"YES\\"] assert can_construct_pattern(1, [(4, [1, 2, 2, 1])]) == [\\"NO\\"] assert can_construct_pattern(1, [(6, [1, 2, 2, 3, 3, 2])]) == [\\"NO\\"]","solution":"def can_construct_pattern(t, test_cases): results = [] for i in range(t): n, beads = test_cases[i] possible = True used_colors = set() prev_color = None for bead in beads: if bead != prev_color: if bead in used_colors: possible = False break used_colors.add(bead) prev_color = bead results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def first_uniq_char(s: str) -> int: Finds the index of the first non-repeating character in the string s. If it doesn't exist, returns -1. Assumes the string contains only lowercase English letters. >>> first_uniq_char(\\"leetcode\\") 0 >>> first_uniq_char(\\"loveleetcode\\") 2 >>> first_uniq_char(\\"aabb\\") -1","solution":"def first_uniq_char(s: str) -> int: Finds the index of the first non-repeating character in the string s. If it doesn't exist, returns -1. Assumes the string contains only lowercase English letters. from collections import Counter # Use Counter to count occurrences of each character count = Counter(s) # Iterate through the string and find the first character with a count of 1 for idx, char in enumerate(s): if count[char] == 1: return idx # If no unique character is found, return -1 return -1"},{"question":"def is_palindrome(s: str) -> str: Returns \\"YES\\" if the given string s is a palindrome, otherwise returns \\"NO\\". >>> is_palindrome(\\"racecar\\") \\"YES\\" >>> is_palindrome(\\"sword\\") \\"NO\\" >>> is_palindrome(\\"a\\") \\"YES\\" >>> is_palindrome(\\"aa\\") \\"YES\\" >>> is_palindrome(\\"ab\\") \\"NO\\" >>> is_palindrome(\\"abba\\") \\"YES\\" >>> is_palindrome(\\"abcdefg\\") \\"NO\\" >>> is_palindrome(\\"\\") \\"YES\\"","solution":"def is_palindrome(s): Returns \\"YES\\" if the given string s is a palindrome, otherwise returns \\"NO\\". if s == s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Dict def max_participants(N: int, skill_levels: List[int], C: List[int]) -> List[int]: Helper function to find the maximum number of participants who can form a valid team based on skill cap C Args: N : int : Number of participants skill_levels : List[int] : List of skill levels of participants C : List[int] : List of skill cap values Returns: List[int] : List of maximum participants for each skill cap def solve_contest(testcases: List[Dict[str, any]]) -> List[List[int]]: Function to handle multiple test cases Args: testcases : List[Dict[str, any]] : List containing dictionaries with N, Q, skill_levels and queries Returns: List[List[int]] : List containing results for each test case # Test cases to validate the solution def test_single_case(): testcases = [{ 'N': 5, 'Q': 3, 'skill_levels': [3, 1, 4, 2, 5], 'queries': [6, 7, 15], }] result = solve_contest(testcases) expected = [[3, 3, 5]] assert result == expected def test_multiple_cases(): testcases = [ { 'N': 5, 'Q': 3, 'skill_levels': [3, 1, 4, 2, 5], 'queries': [6, 7, 15], }, { 'N': 4, 'Q': 2, 'skill_levels': [2, 3, 1, 4], 'queries': [5, 10], } ] result = solve_contest(testcases) expected = [ [3, 3, 5], [2, 4] ] assert result == expected def test_edge_case_min_values(): testcases = [{ 'N': 1, 'Q': 1, 'skill_levels': [1], 'queries': [1], }] result = solve_contest(testcases) expected = [[1]] assert result == expected def test_edge_case_max_values(): skill_levels = list(range(1, 101)) queries = [sum(skill_levels)] testcases = [{ 'N': 100, 'Q': 1, 'skill_levels': skill_levels, 'queries': queries, }] result = solve_contest(testcases) expected = [[100]] assert result == expected def test_no_team_can_form(): testcases = [{ 'N': 3, 'Q': 2, 'skill_levels': [5, 6, 7], 'queries': [1, 2], }] result = solve_contest(testcases) expected = [[0, 0]] assert result == expected","solution":"from bisect import bisect_right def max_participants(N, skill_levels, C): skill_levels.sort() prefix_sum = [0] * (N + 1) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i-1] + skill_levels[i-1] # Find the maximum participants who can form a valid team based on skill cap C answers = [] for cap in C: index = bisect_right(prefix_sum, cap) - 1 answers.append(index) return answers def solve_contest(testcases): results = [] for testcase in testcases: N, Q = testcase['N'], testcase['Q'] skill_levels = testcase['skill_levels'] queries = testcase['queries'] result = max_participants(N, skill_levels, queries) results.append(result) return results"},{"question":"def find_indices_with_target_sum(array, target): This function finds two distinct indices in the array such that their sum equals the target sum. The return values are 1-based indices. >>> find_indices_with_target_sum([1, 2, 3, 4, 5], 9) == (4, 5) >>> find_indices_with_target_sum([1, 2, 3, 4, 5], 10) == -1 >>> find_indices_with_target_sum([2, 7, 11, 15], 9) == (1, 2) >>> find_indices_with_target_sum([3, 2, 4], 6) == (2, 3) >>> find_indices_with_target_sum([1, 1, 1, 1], 2) == (1, 2) >>> find_indices_with_target_sum([5, 75, 25], 100) == (2, 3) >>> find_indices_with_target_sum([3, 3], 6) == (1, 2) >>> find_indices_with_target_sum([1, 2, 3, 4, 5, 6], 11) == (5, 6) >>> find_indices_with_target_sum([], 0) == -1 >>> find_indices_with_target_sum([1, 2], 3) == (1, 2) >>> find_indices_with_target_sum([1, 2, 3, 1], 4) == (1, 3)","solution":"def find_indices_with_target_sum(array, target): This function finds two distinct indices in the array such that their sum equals the target sum. The return values are 1-based indices. seen = {} for i, num in enumerate(array): required = target - num if required in seen: return seen[required] + 1, i + 1 # Convert to 1-based index seen[num] = i return -1"},{"question":"def honeybee_movement_possible(bx, by, fx, fy, h, v): Determines if the honeybee can reach the target flower position from its initial position using the given moves. :param bx: initial x-coordinate of the honeybee :param by: initial y-coordinate of the honeybee :param fx: x-coordinate of the target flower :param fy: y-coordinate of the target flower :param h: horizontal move :param v: vertical move :return: \\"POSSIBLE\\" if the honeybee can reach the target flower, otherwise \\"IMPOSSIBLE\\" >>> honeybee_movement_possible(1, 1, 4, 7, 3, 2) 'POSSIBLE' >>> honeybee_movement_possible(0, 0, 5, 5, 2, 4) 'IMPOSSIBLE' >>> honeybee_movement_possible(2, 3, 2, 3, 1, 1) 'POSSIBLE' >>> honeybee_movement_possible(0, 0, 1000000, 1000000, 500000, 500000) 'POSSIBLE' >>> honeybee_movement_possible(1, 2, 5, 5, 2, 2) 'IMPOSSIBLE'","solution":"def honeybee_movement_possible(bx, by, fx, fy, h, v): Determines if the honeybee can reach the target flower position from its initial position using the given moves. :param bx: initial x-coordinate of the honeybee :param by: initial y-coordinate of the honeybee :param fx: x-coordinate of the target flower :param fy: y-coordinate of the target flower :param h: horizontal move :param v: vertical move :return: \\"POSSIBLE\\" if the honeybee can reach the target flower, otherwise \\"IMPOSSIBLE\\" dx = abs(fx - bx) dy = abs(fy - by) # Check if both dx and dy are multiples of h and v respectively if dx % h == 0 and dy % v == 0: # Check if the number of steps taken in each direction have the same parity (both even or both odd) if (dx // h) % 2 == (dy // v) % 2: return \\"POSSIBLE\\" return \\"IMPOSSIBLE\\""},{"question":"def is_subsequence(s: str, word: str) -> bool: Checks if 'word' is a subsequence of 's'. >>> is_subsequence(\\"abcde\\", \\"a\\") True >>> is_subsequence(\\"abcde\\", \\"bb\\") False >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"xyz\\", \\"xy\\") True >>> is_subsequence(\\"xyz\\", \\"z\\") True >>> is_subsequence(\\"xyz\\", \\"yz\\") True def find_subsequences(s: str, words: List[str]) -> List[str]: Finds all words in the list that are subsequences of the string s. >>> find_subsequences(\\"abcde\\", [\\"a\\", \\"bb\\", \\"ace\\"]) [\\"a\\", \\"ace\\"] >>> find_subsequences(\\"xyz\\", [\\"xy\\", \\"z\\", \\"yz\\"]) [\\"xy\\", \\"z\\", \\"yz\\"] >>> find_subsequences(\\"abcd\\", [\\"e\\", \\"f\\"]) [\\"NO\\"] >>> find_subsequences(\\"abcdef\\", [\\"abd\\", \\"acd\\", \\"ace\\"]) [\\"abd\\", \\"acd\\", \\"ace\\"] >>> find_subsequences(\\"programming\\", [\\"prog\\", \\"pr\\", \\"gram\\", \\"ramm\\"]) [\\"prog\\", \\"pr\\", \\"gram\\", \\"ramm\\"] >>> find_subsequences(\\"test\\", [\\"t\\", \\"te\\", \\"ts\\", \\"test\\"]) [\\"t\\", \\"te\\", \\"ts\\", \\"test\\"] >>> find_subsequences(\\"abcdefghijklmnop\\", [\\"a\\", \\"mnop\\", \\"abcdefghijklmnop\\", \\"z\\"]) [\\"a\\", \\"mnop\\", \\"abcdefghijklmnop\\"]","solution":"def is_subsequence(s, word): Checks if 'word' is a subsequence of 's'. it = iter(s) return all(char in it for char in word) def find_subsequences(s, words): Takes a string s and a list of words, returns the words that are subsequences of s. subsequences = [word for word in words if is_subsequence(s, word)] return subsequences if subsequences else [\\"NO\\"]"},{"question":"def unique_paths_with_obstacles(grid): Given a grid with obstacles, returns the number of unique paths from the top-left to the bottom-right corner. :param grid: List[List[int]] - The grid with obstacles represented by 1 and open cells by 0 :return: int - Number of unique paths >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1","solution":"def unique_paths_with_obstacles(grid): Given a grid with obstacles, returns the number of unique paths from the top-left to the bottom-right corner. :param grid: List[List[int]] - The grid with obstacles represented by 1 and open cells by 0 :return: int - Number of unique paths n = len(grid) m = len(grid[0]) # If the starting or ending cell is an obstacle, return 0 if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 # Initialize the DP table with 0's dp = [[0 for _ in range(m)] for _ in range(n)] # Set the starting cell as 1 (since there's one way to be at the start) dp[0][0] = 1 # Fill the DP table for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 # No path through an obstacle else: if i > 0: dp[i][j] += dp[i-1][j] # Add paths from the cell above if j > 0: dp[i][j] += dp[i][j-1] # Add paths from the cell to the left return dp[n-1][m-1]"},{"question":"def captureRegions(matrix): Capture all regions surrounded by 'X' by flipping all 'O's into 'X's in that surrounded region. Args: matrix (List[List[str]]): A 2D list where each cell contains either 'X' or 'O'. Example: >>> matrix = [ ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X'] ... ] >>> captureRegions(matrix) >>> matrix [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']]","solution":"def captureRegions(matrix): if not matrix or not matrix[0]: return N, M = len(matrix), len(matrix[0]) def dfs(i, j): if i < 0 or i >= N or j < 0 or j >= M or matrix[i][j] != 'O': return matrix[i][j] = 'E' # Mark as escaped dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) # Mark the escaped 'O's on the boundary for i in range(N): for j in [0, M - 1]: if matrix[i][j] == 'O': dfs(i, j) for i in [0, N - 1]: for j in range(M): if matrix[i][j] == 'O': dfs(i, j) # Flip 'O' to 'X', and 'E' back to 'O' for i in range(N): for j in range(M): if matrix[i][j] == 'O': matrix[i][j] = 'X' elif matrix[i][j] == 'E': matrix[i][j] = 'O'"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Given an array of integers, find the subarray where the sum of its elements is the highest. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([3, -1, 4, -1, 2, -4, 5, -2]) 8 >>> max_subarray_sum([42]) 42 >>> max_subarray_sum([10000000, -1, 10000000]) 19999999","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given array. Uses Kadane's Algorithm for an efficient solution. # Initialize the maximum sum and current sum max_sum = current_sum = nums[0] # Iterate through the array starting from the second element for num in nums[1:]: # Calculate the current_sum either by adding this element to the current_sum # or starting a new subarray from this element current_sum = max(num, current_sum + num) # Update max_sum if current_sum is greater max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_pair(arr, target): This function finds two distinct numbers in the list that sum up to a given target number. If there are multiple pairs, it returns the pair with the smallest Number1 in ascending order. If no such pair exists, returns \\"No valid pair found\\". >>> find_pair([10, 20, 10, 40, 50, 60, 70], 50) '10 40' >>> find_pair([1, 2, 3, 4, 5], 10) 'No valid pair found' >>> find_pair([1, 2, 3, 4, 5, 6, 7, 8], 9) '1 8' >>> find_pair([-1, 1, 2, -2, 3, -3], 0) '-3 3' >>> find_pair([1, 1, 1, 2, 2, 3, 3, 4, 4], 7) '3 4' >>> find_pair([1, 2, 3, 4], 8) 'No valid pair found'","solution":"def find_pair(arr, target): This function finds two distinct numbers in the list that sum up to a given target number. If there are multiple pairs, it returns the pair with the smallest Number1 in ascending order. If no such pair exists, returns \\"No valid pair found\\". nums = sorted(arr) num_set = set(nums) for i in range(len(nums) - 1): complement = target - nums[i] if complement in num_set and complement != nums[i]: return f\\"{min(nums[i], complement)} {max(nums[i], complement)}\\" return \\"No valid pair found\\""},{"question":"def max_subarray_sum(arr): Finds the sum of the largest sum subarray using Kadane's Algorithm. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([5, -9, 6, -2, 3]) 7 >>> max_subarray_sum([1000] * 1000) 1000000 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(arr): Finds the sum of the largest sum subarray using Kadane's Algorithm. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global # Example usage if __name__ == \\"__main__\\": n = int(input().strip()) arr = list(map(int, input().strip().split())) result = max_subarray_sum(arr) print(result)"},{"question":"from typing import List def count_valid_products(N: int, Q: int, P: int, checks: List[List[int]]) -> int: Count the total number of valid products that pass at least \`P\` out of \`Q\` checks. >>> count_valid_products(3, 4, 3, [ ... [1, 0, 1, 1], ... [0, 0, 1, 1], ... [1, 1, 1, 1] ...]) 2 >>> count_valid_products(2, 3, 2, ... [ ... [0, 0, 0], ... [1, 1, 1] ...]) 1","solution":"from typing import List def count_valid_products(N: int, Q: int, P: int, checks: List[List[int]]) -> int: valid_products_count = 0 for product_checks in checks: if sum(product_checks) >= P: valid_products_count += 1 return valid_products_count"},{"question":"def max_result_expression(expression: str) -> int: Compute the maximum possible result of an arithmetic expression by rearranging its operators. >>> max_result_expression(\\"1+2-3+4\\") 4 >>> max_result_expression(\\"10-20+30\\") 20 >>> max_result_expression(\\"5+5-5-5\\") 10 def max_results_for_test_cases(t: int, test_cases: List[str]) -> List[int]: Compute the maximum possible results for a list of arithmetic expression test cases. >>> max_results_for_test_cases(3, [\\"1+2-3+4\\", \\"10-20+30\\", \\"5+5-5-5\\"]) [4, 20, 10] >>> max_results_for_test_cases(1, [\\"1+2+3+4\\"]) [10] >>> max_results_for_test_cases(1, [\\"10-1-1-1\\"]) [7] from solution import max_results_for_test_cases def test_single_case_1(): assert max_results_for_test_cases(1, [\\"1+2-3+4\\"]) == [4] def test_single_case_2(): assert max_results_for_test_cases(1, [\\"10-20+30\\"]) == [20] def test_single_case_3(): assert max_results_for_test_cases(1, [\\"5+5-5-5\\"]) == [10] def test_multiple_cases(): assert max_results_for_test_cases(3, [\\"1+2-3+4\\", \\"10-20+30\\", \\"5+5-5-5\\"]) == [4, 20, 10] def test_all_pluses(): assert max_results_for_test_cases(1, [\\"1+2+3+4\\"]) == [10] def test_all_minuses(): assert max_results_for_test_cases(1, [\\"10-1-1-1\\"]) == [7] def test_with_zeroes(): assert max_results_for_test_cases(1, [\\"0+0-0+0\\"]) == [0]","solution":"def max_result_expression(expression): numbers = list(map(int, expression.replace('+', ' ').replace('-', ' ').split())) operators = [c for c in expression if c in '+-'] total = numbers[0] add_sum = 0 subtract_sum = 0 for i in range(1, len(numbers)): if operators[i-1] == '+': add_sum += numbers[i] else: subtract_sum += numbers[i] return total + add_sum - subtract_sum def max_results_for_test_cases(t, test_cases): results = [] for expression in test_cases: results.append(max_result_expression(expression)) return results"},{"question":"def first_n_unique_chars(s: str, n: int) -> str: Returns the first n unique characters in the string preserving their order of appearance. >>> first_n_unique_chars(\\"teststring\\", 4) == \\"tesr\\" >>> first_n_unique_chars(\\"abcdefghijk\\", 5) == \\"abcde\\" >>> first_n_unique_chars(\\"abcabcabc\\", 3) == \\"abc\\" >>> first_n_unique_chars(\\"aaaaaaa\\", 1) == \\"a\\" >>> first_n_unique_chars(\\"teststring\\", 0) == \\"\\" >>> first_n_unique_chars(\\"aaaaaaa\\", 0) == \\"\\" >>> first_n_unique_chars(\\"teststring\\", -1) == \\"\\" >>> first_n_unique_chars(\\"abc\\", 100) == \\"abc\\"","solution":"def first_n_unique_chars(s, n): Returns the first n unique characters in the string s preserving their order of appearance. if n <= 0: return \\"\\" seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) if len(result) == n: break return ''.join(result)"},{"question":"def can_be_palindrome(s: str) -> bool: Determines whether a given string can be rearranged to form a palindrome. >>> can_be_palindrome(\\"abc\\") False >>> can_be_palindrome(\\"aabb\\") True >>> can_be_palindrome(\\"racecar\\") True pass def process_test_cases(t: int, cases: List[Tuple[int, str]]) -> List[str]: Processes multiple test cases to determine if each string can be converted into a palindrome. >>> process_test_cases(3, [(3, \\"abc\\"), (4, \\"aabb\\"), (6, \\"racecar\\")]) [\\"no\\", \\"yes\\", \\"yes\\"] >>> process_test_cases(2, [(1, \\"a\\"), (2, \\"aa\\")]) [\\"yes\\", \\"yes\\"] >>> process_test_cases(1, [(2, \\"ab\\")]) [\\"no\\"] >>> process_test_cases(1, [(3, \\"aaa\\")]) [\\"yes\\"] pass","solution":"def can_be_palindrome(s): from collections import Counter count = Counter(s) odd_counts = sum(1 for x in count.values() if x % 2 != 0) # A string can be rearranged to a palindrome if there is at most one character with an odd count return odd_counts <= 1 def process_test_cases(t, cases): results = [] for n, s in cases: results.append(\\"yes\\" if can_be_palindrome(s) else \\"no\\") return results"},{"question":"def find_pair_with_target(nums: List[int], target: int) -> Tuple[int, int]: Find two distinct integers in the list that sum up to the target. Args: nums (list of int): List of integers. target (int): Target sum. Returns: tuple: A tuple of two integers that sum to the target. If no such pair exists, returns None. >>> find_pair_with_target([2, 7, 11, 15], 9) (2, 7) >>> find_pair_with_target([1, 2, 3, 4], 8) None >>> find_pair_with_target([-1, 2, 3, 4], 3) (-1, 4) >>> find_pair_with_target([10, 20, 10, 40], 50) (10, 40) >>> find_pair_with_target([3, 3, 4, 4], 6) (3, 3)","solution":"def find_pair_with_target(nums, target): Find two distinct integers in the list that sum up to the target. Args: nums (list of int): List of integers. target (int): Target sum. Returns: tuple: A tuple of two integers that sum to the target. If no such pair exists, returns None. seen = {} for num in nums: complement = target - num if complement in seen: return (complement, num) seen[num] = True return None"},{"question":"def min_days_to_process_items(workers: int, items: List[int]) -> int: Calculates the minimum number of days required to process all items. :param workers: Number of workers available each day. :param items: List of integers representing importance values of items. :return: Minimum number of days required to process all items. >>> min_days_to_process_items(3, [4, 2, 3, 1, 5, 7]) == 2 >>> min_days_to_process_items(2, [1, 2, 3, 4, 5]) == 3 >>> min_days_to_process_items(1, [8, 3, 2, 1]) == 4 from typing import List def test_min_days_to_process_items_case_1(): assert min_days_to_process_items(3, [4, 2, 3, 1, 5, 7]) == 2 def test_min_days_to_process_items_case_2(): assert min_days_to_process_items(2, [1, 2, 3, 4, 5]) == 3 def test_min_days_to_process_items_case_3(): assert min_days_to_process_items(1, [8, 3, 2, 1]) == 4 def test_min_days_to_process_items_case_4(): assert min_days_to_process_items(5, [5, 3, 9, 7, 4, 1]) == 2 def test_min_days_to_process_items_case_5(): assert min_days_to_process_items(10, []) == 0 def test_min_days_to_process_items_case_6(): assert min_days_to_process_items(4, [10, 11, 15, 20, 25]) == 2 def test_min_days_to_process_items_case_7(): assert min_days_to_process_items(3, [1, 1, 1, 1, 1, 1, 1, 1, 1]) == 3","solution":"def min_days_to_process_items(workers, items): Calculates the minimum number of days required to process all items. :param workers: Number of workers available each day. :param items: List of integers representing importance values of items. :return: Minimum number of days required to process all items. num_items = len(items) # Calculate the number of days required by dividing the total items by the number of workers days_needed = (num_items + workers - 1) // workers # Equivalent to math.ceil(num_items / workers) return days_needed"},{"question":"def calculate_total_sales(sales: dict, recruits: dict) -> dict: Calculate the total sales of each distributor by summing up the sales generated by themselves and by all their recruits at all levels beneath them in the hierarchy. >>> sales = { >>> \\"A\\": 100, >>> \\"B\\": 50, >>> \\"C\\": 40, >>> \\"D\\": 30, >>> \\"E\\": 20 >>> } >>> recruits = { >>> \\"A\\": [\\"B\\", \\"C\\"], >>> \\"B\\": [\\"D\\", \\"E\\"], >>> \\"C\\": [], >>> \\"D\\": [], >>> \\"E\\": [] >>> } >>> calculate_total_sales(sales, recruits) == { >>> \\"A\\": 240, >>> \\"B\\": 100, >>> \\"C\\": 40, >>> \\"D\\": 30, >>> \\"E\\": 20 >>> } pass from solution import calculate_total_sales def test_example_case(): sales = { \\"A\\": 100, \\"B\\": 50, \\"C\\": 40, \\"D\\": 30, \\"E\\": 20 } recruits = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\", \\"E\\"], \\"C\\": [], \\"D\\": [], \\"E\\": [] } expected = { \\"A\\": 240, \\"B\\": 100, \\"C\\": 40, \\"D\\": 30, \\"E\\": 20 } assert calculate_total_sales(sales, recruits) == expected def test_single_distributor(): sales = {\\"A\\": 100} recruits = {\\"A\\": []} expected = {\\"A\\": 100} assert calculate_total_sales(sales, recruits) == expected def test_no_recruits(): sales = {\\"A\\": 100, \\"B\\": 50} recruits = {\\"A\\": [], \\"B\\": []} expected = {\\"A\\": 100, \\"B\\": 50} assert calculate_total_sales(sales, recruits) == expected def test_deep_hierarchy(): sales = {\\"A\\": 100, \\"B\\": 50, \\"C\\": 40} recruits = {\\"A\\": [\\"B\\"], \\"B\\": [\\"C\\"], \\"C\\": []} expected = {\\"A\\": 190, \\"B\\": 90, \\"C\\": 40} assert calculate_total_sales(sales, recruits) == expected def test_multiple_recruits_on_same_level(): sales = {\\"A\\": 100, \\"B\\": 50, \\"C\\": 30, \\"D\\": 20} recruits = {\\"A\\": [\\"B\\", \\"C\\", \\"D\\"], \\"B\\": [], \\"C\\": [], \\"D\\": []} expected = {\\"A\\": 200, \\"B\\": 50, \\"C\\": 30, \\"D\\": 20} assert calculate_total_sales(sales, recruits) == expected","solution":"def calculate_total_sales(sales, recruits): def get_total_sales(distributor, visited): if distributor in visited: return 0 visited.add(distributor) total = sales.get(distributor, 0) for recruit in recruits.get(distributor, []): total += get_total_sales(recruit, visited) return total total_sales = {} for distributor in sales: visited = set() total_sales[distributor] = get_total_sales(distributor, visited) return total_sales"},{"question":"from typing import List def min_effort_path(grid: List[List[int]]) -> int: Find the minimum effort required to traverse from the top-left corner to the bottom-right corner of the grid, only moving right or down. >>> min_effort_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_effort_path([[1, 2, 5], [3, 2, 1]]) == 6","solution":"def min_effort_path(grid): Returns the minimum effort required to traverse from the top-left corner to the bottom-right corner of the grid. n = len(grid) m = len(grid[0]) # To handle boundary conditions when n or m is 1 if n == 1: return sum(grid[0]) if m == 1: return sum(grid[i][0] for i in range(n)) # Initialize a dp table dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1]"},{"question":"from typing import List def findLongestIncreasingPath(grid: List[List[int]]) -> int: Find the length of the longest increasing path in the grid. Each cell in the grid can move in four directions (up, down, left, right) to another cell with a higher number. Args: grid (List[List[int]]): A 2D list of integers representing the grid. Returns: int: The length of the longest increasing path. Examples: >>> grid = [ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ] >>> findLongestIncreasingPath(grid) 4 >>> grid = [ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ] >>> findLongestIncreasingPath(grid) 4 >>> findLongestIncreasingPath([[1]]) 1 >>> findLongestIncreasingPath([ ... [7, 7, 7], ... [7, 7, 7], ... [7, 7, 7] ... ]) 1 >>> findLongestIncreasingPath([[1, 2, 3, 4, 5]]) 5 >>> findLongestIncreasingPath([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) 5","solution":"from typing import List def findLongestIncreasingPath(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) memo = [[-1] * n for _ in range(m)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(i, j): if memo[i][j] != -1: return memo[i][j] max_path = 1 for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]: max_path = max(max_path, 1 + dfs(ni, nj)) memo[i][j] = max_path return max_path longest_path = 0 for i in range(m): for j in range(n): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"def check_return_to_start(path: str) -> str: Returns \\"YES\\" if the guard returns to the starting point after the given path, otherwise \\"NO\\". >>> check_return_to_start(\\"NS\\") \\"YES\\" >>> check_return_to_start(\\"NESW\\") \\"YES\\" >>> check_return_to_start(\\"NWS\\") \\"NO\\" from check_return_to_start import check_return_to_start def test_check_return_to_start_simple_paths(): assert check_return_to_start(\\"NS\\") == \\"YES\\" assert check_return_to_start(\\"NESW\\") == \\"YES\\" assert check_return_to_start(\\"NWS\\") == \\"NO\\" def test_check_return_to_start_complex_paths(): assert check_return_to_start(\\"NNSS\\") == \\"YES\\" assert check_return_to_start(\\"NEESSWWN\\") == \\"YES\\" assert check_return_to_start(\\"NNWWEESS\\") == \\"YES\\" assert check_return_to_start(\\"NNEESSWW\\") == \\"YES\\" def test_check_return_to_start_no_return_paths(): assert check_return_to_start(\\"N\\") == \\"NO\\" assert check_return_to_start(\\"NE\\") == \\"NO\\" assert check_return_to_start(\\"NWSNW\\") == \\"NO\\" def test_check_return_to_start_empty_path(): assert check_return_to_start(\\"\\") == \\"YES\\"","solution":"def check_return_to_start(path): Returns \\"YES\\" if the guard returns to the starting point after the given path, otherwise \\"NO\\". north_south_balance = 0 east_west_balance = 0 for direction in path: if direction == 'N': north_south_balance += 1 elif direction == 'S': north_south_balance -= 1 elif direction == 'E': east_west_balance += 1 elif direction == 'W': east_west_balance -= 1 if north_south_balance == 0 and east_west_balance == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def minSteps(M: int, N: int, sx: int, sy: int) -> int: Given a grid of size MxN and a starting position (sx, sy), find the shortest path that covers all the cells in the grid at least once. You can move in 4 possible directions: up, down, left, and right. Parameters: M (int): number of rows in the grid N (int): number of columns in the grid sx (int): starting row position sy (int): starting column position Returns: int: minimum number of steps required to cover all the cells in the grid at least once Example usage: >>> minSteps(3, 3, 0, 0) 8 >>> minSteps(2, 2, 0, 0) 3 >>> minSteps(1, 10, 0, 0) 9","solution":"def minSteps(M, N, sx, sy): Returns the minimum number of steps required to cover all cells in an MxN grid starting from (sx, sy). # If there's only one cell, no steps are needed. if M == 1 or N == 1: return M * N - 1 # Minimum number of steps field traversal in an MxN grid is # equivalent to M * N - 1 moves. return M * N - 1"},{"question":"class NumberSet: A class to manage a set of numbers and perform add, remove, and check operations. def __init__(self): Initializes an empty set of numbers. pass def add(self, x): Adds an integer x to the set. It is guaranteed that the integer x was not added before. pass def remove(self, x): Removes an integer x from the set. It is guaranteed that the integer x is in the set. pass def check(self, x): Checks if an integer x is present in the set. Returns \\"YES\\" if it is present, and \\"NO\\" otherwise. pass def process_queries(n, queries): Processes a list of queries on a set of numbers and returns results for 'check' queries. Args: n (int): The number of queries. queries (list of tuple): Each tuple contains an integer type (1, 2, or 3) and an integer x. Returns: list of str: Results of 'check' queries. Example: >>> process_queries(6, [(1, 5), (1, 10), (3, 5), (2, 5), (3, 5), (3, 10)]) ['YES', 'NO', 'YES'] >>> process_queries(8, [(1, 7), (1, 3), (3, 7), (3, 2), (2, 7), (3, 7), (3, 3), (2, 3)]) ['YES', 'NO', 'NO', 'YES'] pass","solution":"class NumberSet: def __init__(self): self.set_numbers = set() def add(self, x): self.set_numbers.add(x) def remove(self, x): self.set_numbers.remove(x) def check(self, x): return \\"YES\\" if x in self.set_numbers else \\"NO\\" def process_queries(n, queries): number_set = NumberSet() results = [] for query in queries: type_query, x = query if type_query == 1: number_set.add(x) elif type_query == 2: number_set.remove(x) elif type_query == 3: results.append(number_set.check(x)) return results"},{"question":"def is_balanced(log): Check if the log is balanced. Args: log: List of strings. Each string is either \\"START\\" or \\"END\\". Returns: bool: True if the log is balanced, False otherwise. Examples: >>> is_balanced([\\"START\\", \\"START\\", \\"END\\", \\"END\\"]) True >>> is_balanced([\\"START\\", \\"END\\", \\"END\\"]) False >>> is_balanced([\\"START\\", \\"START\\", \\"END\\"]) False >>> is_balanced([\\"END\\", \\"START\\", \\"END\\"]) False >>> is_balanced([]) True >>> is_balanced([\\"START\\"]) False >>> is_balanced([\\"END\\"]) False >>> is_balanced([\\"START\\", \\"START\\", \\"START\\"]) False >>> is_balanced([\\"START\\", \\"END\\", \\"END\\"]) False >>> is_balanced([\\"START\\", \\"START\\", \\"END\\", \\"START\\", \\"END\\", \\"END\\"]) True >>> is_balanced([\\"START\\", \\"END\\", \\"START\\", \\"END\\", \\"END\\"]) False >>> is_balanced([\\"START\\", \\"START\\", \\"END\\", \\"END\\", \\"START\\", \\"END\\"]) True","solution":"def is_balanced(log): Check if the log is balanced. Args: log: List of strings. Each string is either \\"START\\" or \\"END\\". Returns: bool: True if the log is balanced, False otherwise. start_count = 0 for event in log: if event == \\"START\\": start_count += 1 elif event == \\"END\\": if start_count == 0: return False start_count -= 1 return start_count == 0"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root: TreeNode) -> TreeNode: Prune the tree removing all subtrees that contain only 0s. >>> root = TreeNode(1, TreeNode(0, TreeNode(0), TreeNode(0)), TreeNode(1)) >>> print_tree(pruneTree(root)) # Expected output: [1, None, 1] >>> root = TreeNode(0, TreeNode(1), TreeNode(0, None, TreeNode(1))) >>> print_tree(pruneTree(root)) # Expected output: [0, 1, 0, None, None, None, 1] >>> root = TreeNode(0) >>> pruneTree(root) is None # Expected output: True >>> root = TreeNode(1) >>> print_tree(pruneTree(root)) # Expected output: [1]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def pruneTree(root): Prune the tree removing all subtrees that contain only 0s. if not root: return None root.left = pruneTree(root.left) root.right = pruneTree(root.right) if root.val == 0 and not root.left and not root.right: return None return root"},{"question":"def flatten_dictionary(dictionary, parent_key='', separator='.'): Flattens a nested dictionary by concatenating keys. >>> flatten_dictionary({\\"Key1\\": \\"1\\", \\"Key2\\": {\\"a\\": \\"2\\", \\"b\\": \\"3\\", \\"c\\": {\\"d\\": \\"3\\", \\"e\\": {\\"\\": \\"1\\"}}}}) {\\"Key1\\": \\"1\\", \\"Key2.a\\": \\"2\\", \\"Key2.b\\": \\"3\\", \\"Key2.c.d\\": \\"3\\", \\"Key2.c.e.\\": \\"1\\"} >>> flatten_dictionary({\\"abc\\": 1, \\"def\\": {\\"ghi\\": 2, \\"jkl\\": [3, 4]}}) {\\"abc\\": 1, \\"def.ghi\\": 2, \\"def.jkl\\": [3, 4]}","solution":"def flatten_dictionary(dictionary, parent_key='', separator='.'): Flattens a nested dictionary by concatenating keys. Args: dictionary (dict): The dictionary to flatten. parent_key (str): The base key in the recursion (used internally). separator (str): The separator to use when concatenating keys. Returns: dict: A new dictionary with flattened keys. items = [] for k, v in dictionary.items(): new_key = f\\"{parent_key}{separator}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, separator).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def minimize_width(n: int, books: List[Tuple[int, int]], height_sequence: List[int]) -> int: Given the number of books, their dimensions and the specified order of heights, this function returns the minimum total width of the arrangement that satisfies the order. :param n: int, number of books :param books: list of tuples, each tuple contains width and height of a book :param height_sequence: list of ints, specific order of heights :return: int, minimum total width of the arrangement >>> minimize_width(3, [(10, 20), (5, 30), (15, 10)], [30, 20, 10]) 30 >>> minimize_width(4, [(10, 100), (20, 200), (30, 300), (40, 400)], [400, 300, 200, 100]) 100 >>> minimize_width(1, [(50, 60)], [60]) 50 >>> minimize_width(3, [(15, 25), (25, 15), (10, 5)], [15, 5, 25]) 50 >>> minimize_width(2, [(5, 25), (10, 30)], [30, 25]) 15 from typing import List, Tuple def test_case_1(): n = 3 books = [(10, 20), (5, 30), (15, 10)] height_sequence = [30, 20, 10] assert minimize_width(n, books, height_sequence) == 30 def test_case_2(): n = 4 books = [(10, 100), (20, 200), (30, 300), (40, 400)] height_sequence = [400, 300, 200, 100] assert minimize_width(n, books, height_sequence) == 100 def test_case_3(): n = 1 books = [(50, 60)] height_sequence = [60] assert minimize_width(n, books, height_sequence) == 50 def test_case_4(): n = 3 books = [(15, 25), (25, 15), (10, 5)] height_sequence = [15, 5, 25] assert minimize_width(n, books, height_sequence) == 50 def test_case_5(): n = 2 books = [(5, 25), (10, 30)] height_sequence = [30, 25] assert minimize_width(n, books, height_sequence) == 15","solution":"def minimize_width(n, books, height_sequence): Given the number of books, their dimensions and the specified order of heights, this function returns the minimum total width of the arrangement that satisfies the order. :param n: int, number of books :param books: list of tuples, each tuple contains width and height of a book :param height_sequence: list of ints, specific order of heights :return: int, minimum total width of the arrangement height_to_width = {} for width, height in books: height_to_width[height] = width total_width = 0 for height in height_sequence: total_width += height_to_width[height] return total_width # Sample input usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) books = [] for i in range(n): width = int(data[2*i + 1]) height = int(data[2*i + 2]) books.append((width, height)) height_sequence = [int(h) for h in data[(2*n + 1):]] print(minimize_width(n, books, height_sequence))"},{"question":"def check_consecutive(nums): Determines if the given list contains a consecutive series of unique integers. >>> check_consecutive([1, 2, 3, 4, 5]) \\"CONSECUTIVE\\" >>> check_consecutive([1, 2, 4, 5, 6]) \\"NOT CONSECUTIVE\\" >>> check_consecutive([5, 3, 4]) \\"CONSECUTIVE\\"","solution":"def check_consecutive(nums): Determines if the given list contains a consecutive series of unique integers # Get the unique numbers unique_nums = set(nums) min_val = min(unique_nums) max_val = max(unique_nums) # Check if the list contains a consecutive series if len(unique_nums) == (max_val - min_val + 1): return \\"CONSECUTIVE\\" else: return \\"NOT CONSECUTIVE\\""},{"question":"def trucking_company(distances: List[List[int]]) -> int: Determine the minimum mileage cost to connect all the warehouses in the desired path. >>> trucking_company([[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> trucking_company([[0, 1], [1, 0]]) 2 >>> trucking_company([[0, 10, 15], [10, 0, 25], [15, 25, 0]]) 50 from itertools import permutations def test_sample_input(): distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert trucking_company(distances) == 80 def test_small_matrix(): distances = [ [0, 1], [1, 0] ] assert trucking_company(distances) == 2 def test_three_warehouses(): distances = [ [0, 10, 15], [10, 0, 25], [15, 25, 0] ] assert trucking_company(distances) == 50 def test_symmetrical_distances(): distances = [ [0, 2, 2], [2, 0, 2], [2, 2, 0] ] assert trucking_company(distances) == 6 def test_asymmetrical_distances(): distances = [ [0, 35, 42], [35, 0, 21], [42, 21, 0] ] assert trucking_company(distances) == 98","solution":"import itertools def trucking_company(distances): n = len(distances) min_cost = float('inf') perms = itertools.permutations(range(n)) for perm in perms: current_cost = 0 for i in range(n - 1): current_cost += distances[perm[i]][perm[i + 1]] current_cost += distances[perm[-1]][perm[0]] # Return to the starting warehouse min_cost = min(min_cost, current_cost) return min_cost"},{"question":"def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given multiple test cases, determine the maximum possible value of any element in each array after performing exactly one operation per array: choose any two indices i and j such that 1 <= i, j <= n and add the value of the element at index j to the element at index i. Args: test_cases (list): List of tuples, where each tuple contains an integer and a list of positive integers Returns: list: List of integers representing the maximum possible value of any element in each array after one operation pass # Test cases for the solution def test_single_case(): assert process_test_cases([(4, [3, 8, 2, 5])]) == [13] def test_multiple_cases(): assert process_test_cases([(4, [3, 8, 2, 5]), (3, [1, 2, 3]), (2, [7, 4])]) == [13, 5, 11] def test_case_with_minimum_elements(): assert process_test_cases([(2, [1, 1])]) == [2] def test_case_with_large_numbers(): assert process_test_cases([(3, [100, 200, 300])]) == [500] def test_case_with_random_numbers(): assert process_test_cases([(5, [7, 14, 3, 6, 9])]) == [23] def test_case_with_same_numbers(): assert process_test_cases([(4, [5, 5, 5, 5])]) == [10] def test_edge_case(): assert process_test_cases([(100, [i for i in range(1, 101)])]) == [199]","solution":"def max_possible_value_after_operation(arr): Given an integer array, determine the maximum possible value of any element in the array after performing exactly one operation: choose any two indices i and j such that 1 <= i, j <= n and add the value of the element at index j to the element at index i. Args: arr (list): List of positive integers Returns: int: Maximum possible value of any element in the array after one operation max_val = 0 n = len(arr) for i in range(n): for j in range(n): if i != j: max_val = max(max_val, arr[i] + arr[j]) return max_val def process_test_cases(test_cases): results = [] for case in test_cases: n, arr = case results.append(max_possible_value_after_operation(arr)) return results"},{"question":"def party_invitations(T, cases): Determines if Cedric can invite exactly M friends in his peculiar way. Args: T (int): Number of test cases cases (List[Tuple[int, int]]): List of pairs (N, M) where N is the number of friends and M is the number of friends to invite Returns: List[str]: A list containing 'Possible' or 'Impossible' for each test case Examples: >>> party_invitations(5, [(5, 3), (4, 2), (3, 3), (6, 7), (8, 5)]) ['Possible', 'Possible', 'Possible', 'Impossible', 'Possible'] >>> party_invitations(1, [(1, 1)]) ['Possible']","solution":"def party_invitations(T, cases): results = [] for N, M in cases: if M <= N: results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"def can_unlock(t: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if it is possible to rearrange the array in strictly increasing order using the given number of swap operations. Parameters: t (int): Number of test cases cases (List[Tuple[Tuple[int, int], List[int]]]): Each test case contains a tuple where the first element is a tuple of two integers (n, k) and the second element is a list of integers representing the initial sequence. Returns: List[str]: List of results for each test case - \\"YES\\" if it is possible, otherwise \\"NO\\" >>> can_unlock(3, [ ... ((5, 2), [4, 3, 1, 5, 2]), ... ((6, 0), [6, 5, 4, 3, 2, 1]), ... ((3, 3), [3, 2, 1]) ... ]) == [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_unlock(t, cases): results = [] for i in range(t): n, k = cases[i][0] p = cases[i][1] sorted_p = sorted(p) swap_count = sum(p[j] != sorted_p[j] for j in range(n)) # Each swap operation can fix 2 misplaced elements if swap_count // 2 <= k: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sum_of_k_smallest_numbers(n: int, array: List[int], k: int) -> int: Given a list of integers, return the sum of the first k smallest numbers in the list. :param n: the number of integers in the list :param array: list of n integers :param k: the number of smallest integers to sum :return: the sum of the first k smallest integers in the given list >>> sum_of_k_smallest_numbers(6, [3, 1, 5, 9, 2, 8], 3) 6 >>> sum_of_k_smallest_numbers(5, [10, 3, 5, 1, 6], 2) 4 >>> sum_of_k_smallest_numbers(5, [-10, 3, -5, 1, -6], 3) -21 >>> sum_of_k_smallest_numbers(4, [-7, -2, -5, -4], 2) -12 >>> sum_of_k_smallest_numbers(1, [3], 1) 3 >>> sum_of_k_smallest_numbers(5, [0, 0, 0, 0, 1], 4) 0 >>> sum_of_k_smallest_numbers(8, [7, -3, 5, -1, 2, -4, 6, 0], 5) -6","solution":"def sum_of_k_smallest_numbers(n, array, k): Returns the sum of the first k smallest numbers in the given array. array.sort() return sum(array[:k])"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def averageOfLevels(root: Optional[TreeNode]) -> List[float]: Calculate the average value of nodes on each level of the binary tree and return a list containing these averages. >>> averageOfLevels(TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))) == [3.0, 14.5, 11.0] >>> averageOfLevels(TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))) == [1.0, 2.5, 4.5]","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def averageOfLevels(root: Optional[TreeNode]) -> List[float]: if not root: return [] levels = [] queue = deque([root]) while queue: level_size = len(queue) level_sum = 0 for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) levels.append(level_sum / level_size) return levels"},{"question":"def verify_message(message: str) -> bool: Verifies if the given binary message has an equal number of 1s and 0s. Args: message (str): A binary string. Returns: bool: True if the message has an equal number of 1s and 0s, otherwise False. Example: >>> verify_message(\\"1100\\") True >>> verify_message(\\"1010\\") True >>> verify_message(\\"100\\") False >>> verify_message(\\"111000\\") True","solution":"def verify_message(message): Verifies if the given binary message has an equal number of 1s and 0s. Args: message (str): A binary string. Returns: bool: True if the message has an equal number of 1s and 0s, otherwise False. count_1 = sum(1 for char in message if char == '1') count_0 = len(message) - count_1 # Total length minus number of 1s gives number of 0s return count_1 == count_0"},{"question":"def find_encryption_key(B, C): Determine the encryption key K using the relationship C[i] = B[i] XOR K. Args: B (List[int]): The original array. C (List[int]): The encrypted array. Returns: int: The encryption key K. Examples: >>> find_encryption_key([5, 7, 9, 11], [2, 4, 0, 6]) 7 >>> find_encryption_key([10, 20, 30], [0, 30, 20]) 10 >>> find_encryption_key([25, 25, 25], [8, 8, 8]) 17 >>> find_encryption_key(list(range(1, 101)), [(b ^ 123) for b in range(1, 101)]) 123 >>> find_encryption_key([1000, 1000, 1000], [(1000 ^ 987) for _ in range(3)]) 987","solution":"def find_encryption_key(B, C): Determine the encryption key K using the relationship C[i] = B[i] XOR K. m = len(B) for i in range(m): queried_value = B[i] ^ C[i] return queried_value # We can determine K with a single correct query def handle_test_case(m, B, C): Handle a single test case by finding and printing the encryption key. K = find_encryption_key(B, C) print(f\\"! {K}\\")"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): Insert a key into the BST rooted at root Args: root (TreeNode): The root of the BST key (int): The value to be inserted into the BST Returns: TreeNode: The root of the BST after insertion pass def maxDepth(root): Determine the maximum depth of the BST Args: root (TreeNode): The root of the BST Returns: int: The maximum depth of the BST pass def calculate_max_depth(n, sequence): Calculate the maximum depth of the BST formed by inserting the given sequence Args: n (int): The number of elements in the sequence sequence (List[int]): The sequence of elements to be inserted into the BST Returns: int: The maximum depth of the BST >>> calculate_max_depth(7, [4, 2, 6, 1, 3, 5, 7]) 3 >>> calculate_max_depth(1, [1]) 1 >>> calculate_max_depth(4, [1, 2, 3, 4]) 4 >>> calculate_max_depth(4, [4, 3, 2, 1]) 4 >>> calculate_max_depth(5, [3, 2, 5, 4, 1]) 3 >>> calculate_max_depth(10, [10, 5, 15, 2, 7, 12, 20, 1, 3, 8]) 4 >>> calculate_max_depth(0, []) 0 pass","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def maxDepth(root): if root is None: return 0 else: left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1 def calculate_max_depth(n, sequence): if n == 0: return 0 root = None for key in sequence: root = insert(root, key) return maxDepth(root)"},{"question":"def simulate_robot_movement(x, y, instructions): Simulates the movements of a robot on a 2D grid. Arguments: x -- initial x-coordinate of the robot y -- initial y-coordinate of the robot instructions -- a string containing the instructions ('U', 'D', 'L', 'R') Returns: A tuple (final_x, final_y) representing the final coordinates of the robot. from solution import simulate_robot_movement def test_initial_position(): assert simulate_robot_movement(3, 4, \\"\\") == (3, 4) def test_move_up(): assert simulate_robot_movement(3, 4, \\"U\\") == (3, 5) assert simulate_robot_movement(0, 0, \\"UUU\\") == (0, 3) def test_move_down(): assert simulate_robot_movement(3, 4, \\"D\\") == (3, 3) assert simulate_robot_movement(0, 0, \\"DDD\\") == (0, -3) def test_move_left(): assert simulate_robot_movement(3, 4, \\"L\\") == (2, 4) assert simulate_robot_movement(0, 0, \\"LLL\\") == (-3, 0) def test_move_right(): assert simulate_robot_movement(3, 4, \\"R\\") == (4, 4) assert simulate_robot_movement(0, 0, \\"RRR\\") == (3, 0) def test_combined_movements(): assert simulate_robot_movement(3, 4, \\"UUDDLRLR\\") == (3, 4) assert simulate_robot_movement(0, 0, \\"UDLR\\") == (0, 0) assert simulate_robot_movement(1, 1, \\"ULDR\\") == (1, 1) def test_complex_movements(): assert simulate_robot_movement(-1000, -1000, \\"UUUUUUUUUU\\") == (-1000, -990) assert simulate_robot_movement(1000, 1000, \\"DDDDDDDDDD\\") == (1000, 990)","solution":"def simulate_robot_movement(x, y, instructions): Simulates the movements of a robot on a 2D grid. Arguments: x -- initial x-coordinate of the robot y -- initial y-coordinate of the robot instructions -- a string containing the instructions ('U', 'D', 'L', 'R') Returns: A tuple (final_x, final_y) representing the final coordinates of the robot. for instruction in instructions: if instruction == 'U': y += 1 elif instruction == 'D': y -= 1 elif instruction == 'L': x -= 1 elif instruction == 'R': x += 1 return x, y"},{"question":"def max_coins(grid): This function calculates the maximum number of coins Wilma can collect by moving from the top-left corner to the bottom-right corner of the grid, moving only right or down. :param grid: List[List[int]] - 2D grid with n rows and m columns representing the coins in each cell :return: int - maximum number of coins Wilma can collect pass import pytest def test_example(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_coins(grid) == 12 def test_single_cell(): grid = [ [7] ] assert max_coins(grid) == 7 def test_all_zeros(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert max_coins(grid) == 0 def test_rectangular_grid(): grid = [ [1, 2, 5], [3, 2, 1] ] assert max_coins(grid) == 9 def test_negative_values(): grid = [ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ] assert max_coins(grid) == -21 def test_large_grid(): grid = [ [1] * 1000 for _ in range(1000) ] # A 1000x1000 grid filled with 1s assert max_coins(grid) == 1999","solution":"def max_coins(grid): This function calculates the maximum number of coins Wilma can collect by moving from the top-left corner to the bottom-right corner of the grid, moving only right or down. :param grid: List[List[int]] - 2D grid with n rows and m columns representing the coins in each cell :return: int - maximum number of coins Wilma can collect n = len(grid) m = len(grid[0]) # Initialize a DP table with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Start position initializes with the coins in the starting cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def is_perfect_number(n: int) -> bool: Determine if a number is a perfect number. >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(496) True >>> is_perfect_number(12) False >>> is_perfect_number(27) False pass def count_perfect_numbers_up_to_n(N: int) -> int: Count the number of perfect numbers up to a given number N. >>> count_perfect_numbers_up_to_n(6) 1 >>> count_perfect_numbers_up_to_n(28) 2 >>> count_perfect_numbers_up_to_n(100) 2 >>> count_perfect_numbers_up_to_n(500) 3 >>> count_perfect_numbers_up_to_n(1) 0 pass def count_perfect_numbers(T: int, test_cases: List[int]) -> List[int]: For each test case, count the number of perfect numbers up to N. >>> count_perfect_numbers(4, [6, 28, 100, 500]) [1, 2, 2, 3] >>> count_perfect_numbers(1, [6]) [1] >>> count_perfect_numbers(2, [1, 2]) [0, 0] >>> count_perfect_numbers(3, [6, 496, 12]) [1, 3, 1] pass","solution":"def is_perfect_number(n): if n < 2: return False sum_of_divisors = 1 sqrt_n = int(n**0.5) for i in range(2, sqrt_n + 1): if n % i == 0: sum_of_divisors += i if i != n // i: sum_of_divisors += n // i return sum_of_divisors == n def count_perfect_numbers_up_to_n(N): count = 0 for i in range(2, N + 1): if is_perfect_number(i): count += 1 return count def count_perfect_numbers(T, test_cases): max_n = max(test_cases) cumulative_counts = [0] * (max_n + 1) for i in range(2, max_n + 1): if is_perfect_number(i): cumulative_counts[i] = cumulative_counts[i - 1] + 1 else: cumulative_counts[i] = cumulative_counts[i - 1] results = [] for n in test_cases: results.append(cumulative_counts[n]) return results"},{"question":"def addAndSub(A: int, B: int) -> str: Determine the winner of the game between Tim and Sara starting with numbers A and B. Tim starts first. >>> addAndSub(2, 3) \\"Tim\\" >>> addAndSub(5, 15) \\"Sara\\" >>> addAndSub(12, 16) \\"Tim\\" >>> addAndSub(10, 100) \\"Sara\\" >>> addAndSub(30, 41) \\"Tim\\" from solution import addAndSub def test_addAndSub_case1(): assert addAndSub(2, 3) == \\"Tim\\" def test_addAndSub_case2(): assert addAndSub(5, 15) == \\"Sara\\" def test_addAndSub_case3(): assert addAndSub(12, 16) == \\"Tim\\" def test_addAndSub_case4(): assert addAndSub(10, 100) == \\"Sara\\" def test_addAndSub_case5(): assert addAndSub(30, 41) == \\"Tim\\"","solution":"def addAndSub(A, B): Determine the winner of the game between Tim and Sara starting with numbers A and B. Tim starts first. # Tim starts first # Tim will always lose if B % A == 0 (where B > A) # Otherwise, Tim will win min_number = min(A, B) max_number = max(A, B) return \\"Sara\\" if (max_number % min_number == 0) else \\"Tim\\""},{"question":"def has_revisited_location(data): Determine if any position in the tracking data is revisited. Parameters: data (list): List of integers representing the input data. Returns: str: \\"YES\\" if there is at least one revisited location, otherwise \\"NO\\". >>> has_revisited_location([5, 1, 2, 3, 4, 1, 2, 5, 6, 7, 8]) 'YES' >>> has_revisited_location([4, 0, 0, 1, 1, 2, 2, 3, 3]) 'NO' >>> has_revisited_location([3, -10000, -10000, 0, 0, -10000, -10000]) 'YES' >>> has_revisited_location([6, 5, 5, 1, 1, 2, 2, 5, 5, 3, 3, 4, 4]) 'YES' >>> has_revisited_location([2, 10000, 10000, -10000, -10000]) 'NO'","solution":"def has_revisited_location(data): Determine if any position in the tracking data is revisited. Parameters: data (list): List of integers representing the input data. Returns: str: \\"YES\\" if there is at least one revisited location, otherwise \\"NO\\". N = data[0] positions = set() for i in range(1, 2*N, 2): pos = (data[i], data[i+1]) if pos in positions: return \\"YES\\" positions.add(pos) return \\"NO\\""},{"question":"def count_paths(grid): Counts the number of distinct paths from the top-left corner to the bottom-right corner of a MxN grid. The grid may contain obstacles, represented by a value of \`0\`, which cannot be traversed. All other cells are labeled with \`1\`. >>> grid = [ ... [1, 0, 0], ... [1, 1, 0], ... [0, 1, 1] ... ] >>> count_paths(grid) 1 pass from solution import count_paths def test_single_column_grid(): grid = [ [1], [1], [1] ] assert count_paths(grid) == 1 def test_single_row_grid(): grid = [ [1, 1, 1] ] assert count_paths(grid) == 1 def test_multiple_paths_grid(): grid = [ [1, 1], [1, 1] ] assert count_paths(grid) == 2 def test_obstacle_in_middle(): grid = [ [1, 0], [1, 1] ] assert count_paths(grid) == 1 def test_large_grid_with_no_valid_path(): grid = [ [1, 0, 1], [1, 0, 1], [1, 1, 1] ] assert count_paths(grid) == 1 def test_complex_grid(): grid = [ [1, 0, 0], [1, 1, 0], [0, 1, 1] ] assert count_paths(grid) == 1 def test_no_way_to_end(): grid = [ [1, 0, 0], [1, 0, 1], [0, 1, 1] ] assert count_paths(grid) == 0 def test_large_empty_grid(): grid = [ [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1] ] assert count_paths(grid) == 20","solution":"def count_paths(grid): if not grid or grid[0][0] == 0: return 0 M, N = len(grid), len(grid[0]) # Create a cache matrix to store number of ways to reach each cell dp = [[0] * N for _ in range(M)] # Start at the top-left corner dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[M-1][N-1]"},{"question":"def unique_value(test_cases): Calculate unique values for each test case. Parameters: test_cases (list of tuples): Each tuple contains (N, list of N integers). Returns: list of integers: List of unique values for each test case. pass def process_input(T, input_data): Process the input data and produce output using the unique_value function. Parameters: T (int): Number of test cases. input_data (list): List containing raw input data. Returns: list: List of unique values for each test case. pass def test_unique_value_simple_cases(): # Simple test cases test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [10, 20, 30, 40]) ] expected = [3, 20] assert unique_value(test_cases) == expected def test_unique_value_no_difference(): # Test case where both sums are identical test_cases = [ (4, [1, 1, 1, 1]) ] expected = [0] assert unique_value(test_cases) == expected def test_unique_value_large_diff(): # Test case with a large difference test_cases = [ (3, [1000, 200, 3000]) ] expected = [3800] assert unique_value(test_cases) == expected def test_unique_value_single_element(): # Test case with a single element test_cases = [ (1, [100]) ] expected = [100] assert unique_value(test_cases) == expected def test_unique_value_large_number_elements(): # Test case with the maximum number of elements test_cases = [ (100, list(range(1, 101))) ] # Sum of even indices: 1+3+5+...+99 = 2500 # Sum of odd indices: 2+4+6+...+100 = 2550 expected = [50] assert unique_value(test_cases) == expected def test_process_input(): # Integration test for the process_input function T = 2 input_data = [\\"5\\", \\"1 2 3 4 5\\", \\"4\\", \\"10 20 30 40\\"] expected = [3, 20] assert process_input(T, input_data) == expected","solution":"def unique_value(test_cases): Calculate unique values for each test case. Parameters: test_cases (list of tuples): Each tuple contains (N, list of N integers). Returns: list of integers: List of unique values for each test case. results = [] for N, nums in test_cases: even_sum = 0 odd_sum = 0 for i in range(N): if i % 2 == 0: even_sum += nums[i] else: odd_sum += nums[i] unique_val = abs(even_sum - odd_sum) results.append(unique_val) return results def process_input(T, input_data): Process the input data and produce output using the unique_value function. Parameters: T (int): Number of test cases. input_data (list): List containing raw input data. Returns: list: List of unique values for each test case. test_cases = [] index = 0 while T > 0: N = int(input_data[index]) nums = list(map(int, input_data[index + 1].split())) test_cases.append((N, nums)) index += 2 T -= 1 return unique_value(test_cases)"},{"question":"def count_successful_trades(test_cases): Counts the number of successful trades in a simplified market simulation. A trade occurs when a buyer's budget meets or exceeds a seller's minimum price. Args: test_cases (List[Tuple[List[int], List[int]]]): A list of test cases. Each test case is a tuple where the first element is a list of buyers' budgets, and the second element is a list of sellers' minimum prices. Returns: List[int]: A list of integers representing the number of successful trades for each test case. Examples: >>> process_market_input(\\"3 3n100n150n200n110n120n130n0 0n\\") [2] >>> process_market_input(\\"3 3n100n200n150n130n120n110n4 2n60n70n80n90n65n50n0 0n\\") [2, 2] >>> process_market_input(\\"3 3n10n20n30n40n50n60n0 0n\\") [0] def process_market_input(input_data): Processes the market input data and converts it into test cases for further processing. Args: input_data (str): A string representation of the input data with buyers' budgets and sellers' minimum prices. Returns: List[int]: A list of integers representing the number of successful trades for each test case.","solution":"def count_successful_trades(test_cases): results = [] for buyers, sellers in test_cases: buyers.sort(reverse=True) sellers.sort() buyer_count = seller_count = 0 trade_count = 0 while buyer_count < len(buyers) and seller_count < len(sellers): if buyers[buyer_count] >= sellers[seller_count]: trade_count += 1 buyer_count += 1 seller_count += 1 else: seller_count += 1 results.append(trade_count) return results def process_market_input(input_data): test_cases = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): B, S = map(int, lines[i].split()) if B == 0 and S == 0: break buyers = [int(lines[i + j + 1]) for j in range(B)] sellers = [int(lines[i + B + j + 1]) for j in range(S)] test_cases.append((buyers, sellers)) i += B + S + 1 return count_successful_trades(test_cases)"},{"question":"from typing import List, Tuple def number_of_islands(test_cases: List[Tuple[List[List[int]], int, int]]) -> List[int]: Determines the number of distinct islands for each test case. >>> number_of_islands([([[1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0]], 4, 5), ... ([[1, 1, 1], [1, 0, 0], [0, 0, 1]], 3, 3)]) [2, 2] >>> number_of_islands([([[1, 0, 0], [0, 0, 0], [0, 0, 1]], 3, 3)]) [2] >>> number_of_islands([([[1, 1, 0, 0], [1, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 0]], 4, 4)]) [2]","solution":"def count_islands(grid, n, m): def dfs(x, y): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < n and 0 <= j < m and grid[i][j] == 1: grid[i][j] = -1 # mark as visited stack.extend([(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]) islands = 0 for i in range(n): for j in range(m): if grid[i][j] == 1: dfs(i, j) islands += 1 return islands def number_of_islands(test_cases): results = [] for grid, n, m in test_cases: results.append(count_islands(grid, n, m)) return results"},{"question":"def min_operations_to_palindrome(T: int, test_cases: List[str]) -> List[int]: Given the number of test cases T and a list of strings, returns a list with the smallest number of operations needed to make each string a palindrome. >>> min_operations_to_palindrome(3, ['abc', 'aaa', 'abca']) [1, 0, 1] >>> min_operations_to_palindrome(2, ['abcdcba', 'racecar']) [0, 0]","solution":"def min_operations_to_palindrome(T, test_cases): Given T, the number of test cases, and a list of strings, return a list with the smallest number of operations needed to make each string a palindrome. def min_ops(s): n = len(s) ops = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: ops += 1 return ops results = [] for case in test_cases: results.append(min_ops(case)) return results"},{"question":"import heapq from typing import List, Tuple, Dict def dijkstra(graph: Dict[int, Dict[int, int]], start: int, n: int) -> Dict[int, int]: Uses Dijkstra's algorithm to find the shortest path from the start node to all other nodes in a weighted graph. distances = {node: float('infinity') for node in range(1, n + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_route(N: int, M: int, edges: List[Tuple[int, int, int]], route: List[int]) -> int: Returns the shortest travel time given the graph and the order of nodes to visit. graph = {i: {} for i in range(1, N + 1)} for edge in edges: u, v, t = edge graph[u][v] = min(t, graph[u].get(v, float('infinity'))) total_time = 0 for i in range(len(route) - 1): start = route[i] end = route[i + 1] distances = dijkstra(graph, start, N) if distances[end] == float('infinity'): return -1 total_time += distances[end] return total_time def logistic_routes(datasets: List[Tuple[int, int, List[Tuple[int, int, int]], List[int]]]) -> List[int]: Processes multiple datasets and determines the shortest travel time for each. results = [] for dataset in datasets: N, M, edges, route = dataset results.append(shortest_route(N, M, edges, route)) return results def parse_input(input_str: str) -> List[Tuple[int, int, List[Tuple[int, int, int]], List[int]]]: Parses the input string to extract the datasets information. lines = input_str.strip().split(\\"n\\") datasets = [] i = 0 while i < len(lines): if lines[i] == '0': break N, M = map(int, lines[i].split()) i += 1 edges = [] for _ in range(M): u, v, t = map(int, lines[i].split()) edges.append((u, v, t)) i += 1 route = list(map(int, lines[i].split())) i += 1 datasets.append((N, M, edges, route)) return datasets def main(input_str: str): datasets = parse_input(input_str) results = logistic_routes(datasets) for result in results: print(result) # Unit tests def test_dijkstra(): graph = { 1: {2: 2, 3: 5, 4: 10}, 2: {3: 2, 5: 10}, 3: {4: 2}, 4: {5: 2}, 5: {} } assert dijkstra(graph, 1, 5) == {1: 0, 2: 2, 3: 4, 4: 6, 5: 8} def test_shortest_route(): assert shortest_route(5, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (1, 4, 10), (2, 5, 10)], [1, 3, 5]) == 8 assert shortest_route(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], [1, 2, 3, 4]) == 3 def test_logistic_routes(): datasets = [ (5, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (1, 4, 10), (2, 5, 10)], [1, 3, 5]), (4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], [1, 2, 3, 4]) ] assert logistic_routes(datasets) == [8, 3] def test_parse_input(): input_str = \\"5 6n1 2 2n2 3 2n3 4 2n4 5 2n1 4 10n2 5 10n1 3 5n4 4n1 2 1n2 3 1n3 4 1n4 1 1n1 2 3 4n0\\" expected_output = [ (5, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (1, 4, 10), (2, 5, 10)], [1, 3, 5]), (4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], [1, 2, 3, 4]) ] assert parse_input(input_str) == expected_output def test_main(capsys): input_str = \\"5 6n1 2 2n2 3 2n3 4 2n4 5 2n1 4 10n2 5 10n1 3 5n4 4n1 2 1n2 3 1n3 4 1n4 1 1n1 2 3 4n0\\" main(input_str) captured = capsys.readouterr() assert captured.out == \\"8n3n\\"","solution":"import heapq def dijkstra(graph, start, n): Uses Dijkstra's algorithm to find the shortest path from start node to all other nodes in a weighted graph. distances = {node: float('infinity') for node in range(1, n+1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def shortest_route(N, M, edges, route): Returns the shortest travel time given the graph and the order of nodes to visit. graph = {i: {} for i in range(1, N+1)} for edge in edges: u, v, t = edge graph[u][v] = min(t, graph[u].get(v, float('infinity'))) total_time = 0 for i in range(len(route) - 1): start = route[i] end = route[i+1] distances = dijkstra(graph, start, N) if distances[end] == float('infinity'): return -1 total_time += distances[end] return total_time def logistic_routes(datasets): Processes multiple datasets and determine the shortest travel time for each. results = [] for dataset in datasets: N, M, edges, route = dataset results.append(shortest_route(N, M, edges, route)) return results def parse_input(input_str): Parses the input string to extract the datasets information. lines = input_str.strip().split(\\"n\\") datasets = [] i = 0 while i < len(lines): if lines[i] == '0': break N, M = map(int, lines[i].split()) i += 1 edges = [] for _ in range(M): u, v, t = map(int, lines[i].split()) edges.append((u, v, t)) i += 1 route = list(map(int, lines[i].split())) i += 1 datasets.append((N, M, edges, route)) return datasets def main(input_str): datasets = parse_input(input_str) results = logistic_routes(datasets) for result in results: print(result)"},{"question":"def isUniqueString(s: str) -> bool: Returns True if all characters in the string s are unique, False otherwise. >>> isUniqueString(\\"orange\\") True >>> isUniqueString(\\"apple\\") False >>> isUniqueString(\\"\\") True >>> isUniqueString(\\"a\\") True","solution":"def isUniqueString(s): Returns True if all characters in the string s are unique, False otherwise. return len(s) == len(set(s))"},{"question":"def can_color_graph(vertices: int, edges: List[Tuple[int, int]]) -> str: Determines if it's possible to color the graph using three distinct colors such that no two adjacent vertices share the same color. >>> can_color_graph(3, [(1, 2), (2, 3), (3, 1)]) \\"No\\" >>> can_color_graph(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"Yes\\"","solution":"def is_bipartite(graph, n): Helper function to check if a graph is bipartite using BFS color = [-1] * n queue = [] for start in range(n): if color[start] == -1: queue.append(start) color[start] = 0 while queue: node = queue.pop(0) for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True def can_color_graph(vertices, edges): Returns \\"Yes\\" if it is possible to color the graph using three colors such that no two adjacent vertices share the same color. Otherwise, returns \\"No\\". graph = [[] for _ in range(vertices)] for edge in edges: u, v = edge graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) return \\"Yes\\" if is_bipartite(graph, vertices) else \\"No\\" # Example usage if __name__ == \\"__main__\\": vertices = 4 edges = [(1, 2), (2, 3), (3, 4), (4, 1)] print(can_color_graph(vertices, edges)) # Output: Yes"},{"question":"def calculate_scores(test_cases): Calculate the final scores for Jane and Mark based on the card game rules. >>> calculate_scores([(4, [1, 2, 10, 3])]) ['12 4'] >>> calculate_scores([(4, [5, 5, 5, 5])]) ['10 10'] >>> calculate_scores([(1, [10])]) ['10 0'] # Implementation here def process_input(input_data): Process the input data and extract the test cases. >>> process_input(\\"1n4n1 2 10 3\\") [(4, [1, 2, 10, 3])] >>> process_input(\\"2n4n1 2 10 3n5n1 2 3 4 5\\") [(4, [1, 2, 10, 3]), (5, [1, 2, 3, 4, 5])] # Implementation here # Unit tests def test_single_case(): input_data = 1 4 1 2 10 3 test_cases = process_input(input_data) results = calculate_scores(test_cases) assert results == [\\"12 4\\"] def test_multiple_cases(): input_data = 2 4 1 2 10 3 5 1 2 3 4 5 test_cases = process_input(input_data) results = calculate_scores(test_cases) assert results == [\\"12 4\\", \\"9 6\\"] def test_equal_cards(): input_data = 1 4 5 5 5 5 test_cases = process_input(input_data) results = calculate_scores(test_cases) assert results == [\\"10 10\\"] def test_single_card(): input_data = 1 1 10 test_cases = process_input(input_data) results = calculate_scores(test_cases) assert results == [\\"10 0\\"] def test_large_case(): N = 100000 input_data = f1 {N} {\\" \\".join(map(str, range(1, N+1)))} test_cases = process_input(input_data) results = calculate_scores(test_cases) jane_score = sum(range(N, 0, -2)) mark_score = sum(range(N-1, 0, -2)) assert results == [f\\"{jane_score} {mark_score}\\"]","solution":"def calculate_scores(test_cases): results = [] for test_case in test_cases: N, cards = test_case cards.sort(reverse=True) jane_score = sum(cards[i] for i in range(0, N, 2)) mark_score = sum(cards[i] for i in range(1, N, 2)) results.append(f\\"{jane_score} {mark_score}\\") return results # Reading input from standard input and processing the test cases based on the input format def process_input(input_data): data = input_data.strip().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(data[idx]) idx += 1 cards = list(map(int, data[idx:idx+N])) idx += N test_cases.append((N, cards)) return test_cases # Dummy input and testing the scores calculation if __name__ == \\"__main__\\": input_data = 1 4 1 2 10 3 test_cases = process_input(input_data) results = calculate_scores(test_cases) for result in results: print(result)"},{"question":"def findFirstMissingPositive(arr: List[int]) -> int: Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well. Parameters: arr (List[int]): an array of integers Returns: int: the first missing positive integer Examples: >>> findFirstMissingPositive([3, 4, -1, 1]) 2 >>> findFirstMissingPositive([1, 2, 0]) 3","solution":"def findFirstMissingPositive(arr): Returns the first missing positive integer in the array. :param arr: List[int] :return: int n = len(arr) # First separate positive and non-positive numbers for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: # Swap elements to their correct positions arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # Find the first index which is not in correct position for i in range(n): if arr[i] != i + 1: return i + 1 # If all positions are correct, then the missing integer is n+1 return n + 1"},{"question":"from typing import List, Tuple def is_possible_to_pair(n: int, s: List[int]) -> str: Determine if it is possible to pair the shoes of the same size. Parameters: n (int): Number of single shoes available. s (List[int]): List of integers representing the shoe sizes. Returns: str: \\"YES\\" if all shoes can be paired, otherwise \\"NO\\". >>> is_possible_to_pair(4, [1, 2, 1, 2]) \\"YES\\" >>> is_possible_to_pair(5, [1, 1, 2, 2, 3]) \\"NO\\" pass def process_cases(T: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Process multiple test cases for the shoe pairing problem. Parameters: T (int): Number of test cases. cases (List[Tuple[int, List[int]]]): List of tuples, each containing the number of shoes and the list of shoe sizes. Returns: List[str]: List of results for each test case, \\"YES\\" or \\"NO\\". >>> process_cases(3, [(4, [1, 2, 1, 2]), (5, [1, 1, 2, 2, 3]), (6, [1, 2, 3, 3, 2, 1])]) [\\"YES\\", \\"NO\\", \\"YES\\"] pass","solution":"def is_possible_to_pair(n, s): from collections import Counter shoe_counts = Counter(s) for count in shoe_counts.values(): if count % 2 != 0: return \\"NO\\" return \\"YES\\" def process_cases(T, cases): results = [] for i in range(T): n, s = cases[i] results.append(is_possible_to_pair(n, s)) return results"},{"question":"def replace_vowels_with_ascii(s: str) -> str: Replace each vowel in the input string with its ASCII value. The function is case insensitive but preserves the case of consonants. For example: >>> replace_vowels_with_ascii(\\"Hello, World!\\") 'H101l108o, W111r108d!' >>> replace_vowels_with_ascii(\\"ASCII\\") '97SC105105' pass from solution import replace_vowels_with_ascii def test_replace_vowels_with_ascii(): assert replace_vowels_with_ascii(\\"Hello, World!\\") == \\"H101ll111, W111rld!\\" assert replace_vowels_with_ascii(\\"ASCII\\") == \\"97SC105105\\" assert replace_vowels_with_ascii(\\"HeLLo\\") == \\"H101LL111\\" assert replace_vowels_with_ascii(\\"Upper\\") == \\"117pp101r\\" assert replace_vowels_with_ascii(\\"umbrella\\") == \\"117mbr101ll97\\" assert replace_vowels_with_ascii(\\"CRYPT\\") == \\"CRYPT\\" assert replace_vowels_with_ascii(\\"aeiou\\") == \\"97101105111117\\" assert replace_vowels_with_ascii(\\"AEIOU\\") == \\"97101105111117\\" assert replace_vowels_with_ascii(\\"The quick brown fox jumps over the lazy dog.\\") == \\"Th101 q117105ck br111wn f111x j117mps 111v101r th101 l97zy d111g.\\" def test_replace_vowels_with_ascii_single_character(): assert replace_vowels_with_ascii(\\"a\\") == \\"97\\" assert replace_vowels_with_ascii(\\"E\\") == \\"101\\" assert replace_vowels_with_ascii(\\"i\\") == \\"105\\" assert replace_vowels_with_ascii(\\"O\\") == \\"111\\" assert replace_vowels_with_ascii(\\"U\\") == \\"117\\" assert replace_vowels_with_ascii(\\"z\\") == \\"z\\" assert replace_vowels_with_ascii(\\"X\\") == \\"X\\" def test_replace_vowels_with_ascii_no_vowels(): assert replace_vowels_with_ascii(\\"bcdfg\\") == \\"bcdfg\\" assert replace_vowels_with_ascii(\\"BCDFG\\") == \\"BCDFG\\"","solution":"def replace_vowels_with_ascii(s): Replace each vowel in the input string with its ASCII value. The function is case insensitive but preserves the case of consonants. vowels_to_ascii = { 'a': '97', 'e': '101', 'i': '105', 'o': '111', 'u': '117', 'A': '97', 'E': '101', 'I': '105', 'O': '111', 'U': '117' } result = [] for char in s: if char in vowels_to_ascii: result.append(vowels_to_ascii[char]) else: result.append(char) return ''.join(result)"},{"question":"def check_possible_division(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determines if it is possible to divide an array into exactly k non-empty contiguously sorted subarrays. Parameters: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases where each test case is a tuple containing a tuple of (n, k) and a list of n integers representing the array. Returns: List[str]: A list of strings where each string is \\"POSSIBLE\\" or \\"IMPOSSIBLE\\". >>> check_possible_division(3, [ ... ((5, 3), [1, 5, 3, 4, 2]), ... ((4, 2), [2, 4, 1, 3]), ... ((6, 1), [10, 20, 30, 40, 50, 60]) ... ]) [\\"IMPOSSIBLE\\", \\"IMPOSSIBLE\\", \\"POSSIBLE\\"] >>> check_possible_division(2, [ ... ((3, 3), [3, 2, 1]), ... ((2, 2), [1, 2]) ... ]) [\\"POSSIBLE\\", \\"POSSIBLE\\"] >>> check_possible_division(2, [ ... ((100000, 1), list(range(1, 100001))), ... ((100000, 100000), list(range(100000, 0, -1))) ... ]) [\\"POSSIBLE\\", \\"POSSIBLE\\"] >>> check_possible_division(1, [ ... ((6, 6), [1, 3, 2, 5, 4, 6]) ... ]) [\\"POSSIBLE\\"]","solution":"def check_possible_division(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] a = test_cases[i][1] if k == 1: results.append(\\"POSSIBLE\\" if sorted(a) == a else \\"IMPOSSIBLE\\") continue index_map = {value: index for index, value in enumerate(a)} sorted_a = sorted(a) segments = 1 for j in range(1, n): if index_map[sorted_a[j]] != index_map[sorted_a[j - 1]] + 1: segments += 1 if segments > k: break results.append(\\"POSSIBLE\\" if segments <= k else \\"IMPOSSIBLE\\") return results"},{"question":"def can_split_into_equal_sum_subarrays(nums): Determines whether it is possible to split an array into two subarrays with equal sum. Args: nums (list): List of integers. Returns: bool: True if the array can be split into two subarrays with equal sum, otherwise False. Examples: >>> can_split_into_equal_sum_subarrays([1, 1, 1, 1]) True >>> can_split_into_equal_sum_subarrays([2, 3, 5, 5, 2]) False >>> can_split_into_equal_sum_subarrays([-1, 0, 1]) True pass def process_test_cases(test_cases): Processes multiple test cases to determine whether their arrays can be split into two subarrays with equal sum. Args: test_cases (list of tuple): List of tuples where each tuple contains an integer n and a list of n integers. Returns: list: List of boolean values indicating the result for each test case. Examples: >>> process_test_cases([(4, [1, 1, 1, 1]), (5, [2, 3, 5, 5, 2]), (3, [-1, 0, 1])]) [True, False, True] pass","solution":"def can_split_into_equal_sum_subarrays(nums): Determines whether it is possible to split an array into two subarrays with equal sum. Args: nums (list): List of integers. Returns: bool: True if the array can be split into two subarrays with equal sum, otherwise False. total_sum = sum(nums) if total_sum % 2 != 0: return False target = total_sum // 2 current_sum = 0 for num in nums: current_sum += num if current_sum == target: return True return False def process_test_cases(test_cases): results = [] for n, nums in test_cases: result = can_split_into_equal_sum_subarrays(nums) results.append(result) return results"},{"question":"def transform(lst: List[int], value: int) -> List[int]: Returns a new list where each element is the sum of the corresponding element from the input list and the specified value. Parameters: lst (list): A list of integers. value (int): The integer value to add to each element of the list. Returns: list: A new list with transformed values. >>> transform([3, 1, 4, 1, 5, 9], 10) == [13, 11, 14, 11, 15, 19] >>> transform([8, 2, 2, 3, 8], 5) == [13, 7, 7, 8, 13] >>> transform([3, 1, 4], 0) == [3, 1, 4] >>> transform([3, 1, 4], -1) == [2, 0, 3] >>> transform([], 5) == [] >>> transform([-3, -1, -4], 5) == [2, 4, 1] >>> transform([-3, 0, 3], 2) == [-1, 2, 5] >>> transform([-3, 0, 3], -2) == [-5, -2, 1]","solution":"def transform(lst, value): Returns a new list where each element is the sum of the corresponding element from the input list and the specified value. Parameters: lst (list): A list of integers. value (int): The integer value to add to each element of the list. Returns: list: A new list with transformed values. return [x + value for x in lst]"},{"question":"def reverse_words(s: str) -> str: Reverses the order of the words in the given string \`s\` while maintaining the original spaces between them. Input: A single line containing the string \`s\` of length n (1 â‰¤ n â‰¤ 10^5). Output: A single line containing the modified string with the words in reverse order, but the spaces between them remaining in their original positions. Examples: >>> reverse_words(\\"hello world\\") 'world hello' >>> reverse_words(\\" lead and \\") ' and lead ' pass # Unit Tests def test_single_word(): assert reverse_words(\\"hello\\") == \\"hello\\" def test_two_words(): assert reverse_words(\\"hello world\\") == \\"world hello\\" def test_leading_and_trailing_spaces(): assert reverse_words(\\" lead and \\") == \\" and lead \\" def test_only_spaces(): assert reverse_words(\\" \\") == \\" \\" def test_mixed_spaces(): assert reverse_words(\\" hello world \\") == \\" world hello \\" def test_empty_string(): assert reverse_words(\\"\\") == \\"\\"","solution":"def reverse_words(s): Reverses the order of the words in the given string \`s\` while maintaining the original spaces between them. # Split the string into words and spaces parts = s.split(' ') # Filter out the empty strings to get the words words = [part for part in parts if part] # Reverse the list of words words.reverse() # Create an iterator over the reversed words word_iter = iter(words) # Reconstruct the string with words and original spaces result = [] for part in parts: if part: result.append(next(word_iter)) else: result.append('') return ' '.join(result)"},{"question":"def min_adjacent_swaps(initial: str, target: str) -> int: Returns the minimum number of adjacent swaps required to transform the initial string into the target string. If it's impossible, return -1. >>> min_adjacent_swaps(\\"abcdef\\", \\"abcfde\\") 2 >>> min_adjacent_swaps(\\"ab\\", \\"ba\\") 1 >>> min_adjacent_swaps(\\"abc\\", \\"def\\") -1","solution":"def min_adjacent_swaps(initial, target): Returns the minimum number of adjacent swaps required to transform the initial string into the target string. If it's impossible, return -1. if sorted(initial) != sorted(target): return -1 initial_list = list(initial) target_list = list(target) n = len(initial) swaps = 0 # We will iterate over target string for i in range(n): # If character is already in correct position, continue if initial_list[i] == target_list[i]: continue # Find the position where the current target character is located in the initial list j = i while initial_list[j] != target_list[i]: j += 1 # Now swap the characters starting from position j to i while j > i: initial_list[j], initial_list[j-1] = initial_list[j-1], initial_list[j] swaps += 1 j -= 1 return swaps"},{"question":"def switch_case(text: str) -> str: Switches the case of every letter in the text. Lowercase letters become uppercase, and uppercase letters become lowercase. Non-alphabet characters remain unchanged. Args: text (str): The input string. Returns: str: The string with the case of letters switched. def test_switch_case_with_mixed_text(): assert switch_case(\\"Hello World! Have a GREAT Day.\\") == \\"hELLO wORLD! hAVE A great dAY.\\" def test_switch_case_with_numbers_and_letters(): assert switch_case(\\"Python 3.8\\") == \\"pYTHON 3.8\\" def test_switch_case_with_mixed_case_letters(): assert switch_case(\\"123 ABC xyz\\") == \\"123 abc XYZ\\" def test_switch_case_with_empty_string(): assert switch_case(\\"\\") == \\"\\" def test_switch_case_with_special_characters(): assert switch_case(\\"!@#%^&*()\\") == \\"!@#%^&*()\\" def test_switch_case_with_single_lowercase_letter(): assert switch_case(\\"a\\") == \\"A\\" def test_switch_case_with_single_uppercase_letter(): assert switch_case(\\"A\\") == \\"a\\"","solution":"def switch_case(text): Switches the case of every letter in the text. Lowercase letters become uppercase, and uppercase letters become lowercase. Non-alphabet characters remain unchanged. Args: text (str): The input string. Returns: str: The string with the case of letters switched. return text.swapcase()"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") 'YES' >>> can_form_palindrome(\\"ivicc\\") 'YES' >>> can_form_palindrome(\\"hello\\") 'NO'","solution":"def can_form_palindrome(s): Determines if the given string can be rearranged to form a palindrome. from collections import Counter # Count frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one odd frequency character if odd_count > 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def determine_winner(N: int, sequence: List[int]) -> str: Determines the winner of the game between Taro and Jiro. >>> determine_winner(3, [2, 4, 3]) 'Taro' >>> determine_winner(2, [5, 10]) 'Jiro'","solution":"def determine_winner(N, sequence): Determines the winner of the game between Taro and Jiro. Parameters: - N (int): The length of the sequence. - sequence (list of int): The sequence of integers. Returns: - str: \\"Taro\\" if Taro wins, otherwise \\"Jiro\\". if N % 2 == 1: return \\"Taro\\" else: return \\"Jiro\\""},{"question":"from typing import List, Tuple def analyze_sales(datasets: List[Tuple[int, int, int, int, int]]) -> List[Tuple[str, int]]: Analyzes the sales data and returns the time period with the highest sales and the total number of cups sold during that period. Args: datasets (list of tuples): List containing tuples of integers representing sales data for different time periods. Returns: list of tuples: Each tuple contains a string denoting the time period and an integer representing the number of cups sold. Example: >>> analyze_sales([(1500, 3000, 2500, 2000, 1800), (1000, 2000, 1500, 2500, 3000), (3500, 2800, 2900, 3100, 2700)]) [('A', 3000), ('O', 3000), ('M', 3500)] def parse_input(input_lines: List[str]) -> List[Tuple[int, int, int, int, int]]: Parses the input for the sales data. Args: input_lines (list of str): List containing lines of input. Returns: list of tuples: Each tuple contains integers representing the sales data for different time periods. Example: >>> parse_input([\\"1500 3000 2500 2000 1800\\", \\"1000 2000 1500 2500 3000\\", \\"3500 2800 2900 3100 2700\\", \\"0 0 0 0 0\\"]) [(1500, 3000, 2500, 2000, 1800), (1000, 2000, 1500, 2500, 3000), (3500, 2800, 2900, 3100, 2700)] def format_output(results: List[Tuple[str, int]]) -> str: Formats the results for output. Args: results (list of tuples): Each tuple contains a string denoting the time period and an integer representing the number of cups sold. Returns: str: The formatted output string. Example: >>> format_output([('A', 3000), ('O', 3000), ('M', 3500)]) 'A 3000nO 3000nM 3500' def main(input_lines: List[str]) -> str: Handles the input, parse, process, and format the output. Args: input_lines (list of str): List containing lines of input. Returns: str: The final formatted output string. Example: >>> main([\\"1500 3000 2500 2000 1800\\", \\"1000 2000 1500 2500 3000\\", \\"3500 2800 2900 3100 2700\\", \\"0 0 0 0 0\\"]) 'A 3000nO 3000nM 3500'","solution":"def analyze_sales(datasets): Analyzes the sales data and returns the time period with the highest sales and the total number of cups sold during that period. Args: datasets (list of tuples): List containing tuples of integers representing sales data for different time periods. Returns: list of tuples: Each tuple contains a string denoting the time period and an integer representing the number of cups sold. results = [] for data in datasets: # Unpacking the sales data m, a, e, n, o = data time_periods = [('M', m), ('A', a), ('E', e), ('N', n), ('O', o)] # Finding the maximum sales and corresponding time period max_period = max(time_periods, key=lambda x: x[1]) results.append(max_period) return results # Function to parse the input in the required format def parse_input(input_lines): datasets = [] for line in input_lines: data = tuple(map(int, line.split())) if data == (0, 0, 0, 0, 0): break datasets.append(data) return datasets # Function to format the result for output def format_output(results): return \\"n\\".join(f\\"{period} {sales}\\" for period, sales in results) # Overall function to handle input, parse, process, and format the output def main(input_lines): datasets = parse_input(input_lines) results = analyze_sales(datasets) return format_output(results)"},{"question":"def is_subsequence(s: str, t: str) -> bool: Check if \`t\` is a subsequence of \`s\`. >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"aec\\") False pass def subsequence_result(s: str, t: str) -> str: Determine if \`t\` is a subsequence of \`s\` and return \\"YES\\" or \\"NO\\". >>> subsequence_result(\\"abcde\\", \\"ace\\") \\"YES\\" >>> subsequence_result(\\"abcde\\", \\"aec\\") \\"NO\\" >>> subsequence_result(\\"abcde\\", \\"\\") \\"YES\\" >>> subsequence_result(\\"\\", \\"a\\") \\"NO\\" >>> subsequence_result(\\"abc\\", \\"abc\\") \\"YES\\" >>> subsequence_result(\\"abc\\", \\"abcd\\") \\"NO\\" >>> subsequence_result(\\"a\\", \\"a\\") \\"YES\\" >>> subsequence_result(\\"a\\", \\"b\\") \\"NO\\" >>> subsequence_result(\\"abcde\\", \\"bcd\\") \\"YES\\" >>> subsequence_result(\\"aabbcc\\", \\"abc\\") \\"YES\\" pass","solution":"def is_subsequence(s, t): Check if \`t\` is a subsequence of \`s\`. iter_s = iter(s) return all(char in iter_s for char in t) def subsequence_result(s, t): return \\"YES\\" if is_subsequence(s, t) else \\"NO\\""},{"question":"def longest_subsequence_sum(n: int, arr: List[int]) -> Tuple[int, int, int]: Find the maximum subsequence sum in an array and return the sum along with the start and end indices of the shortest subsequence with that sum. >>> longest_subsequence_sum(5, [1, -3, 2, 1, -1]) (3, 3, 4) >>> longest_subsequence_sum(7, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 4, 7) >>> longest_subsequence_sum(3, [-1, -2, -3]) (-1, 1, 1) >>> longest_subsequence_sum(5, [1, 2, 3, 4, 5]) (15, 1, 5) >>> longest_subsequence_sum(5, [-1, -2, -3, -4, -5]) (-1, 1, 1) >>> longest_subsequence_sum(8, [3, -2, 4, -1, 2, 1, -5, 4]) (7, 1, 6)","solution":"def longest_subsequence_sum(n, arr): # Initialize variables max_sum = -float('inf') current_sum = 0 start = 0 min_length = float('inf') best_i = best_j = 0 temp_start = 0 for i in range(n): current_sum += arr[i] # If we found a new max sum or the same sum with a shorter subsequence if current_sum > max_sum or (current_sum == max_sum and (i - temp_start < min_length)): max_sum = current_sum min_length = i - temp_start best_i = temp_start best_j = i # If current sum drops below 0, reset if current_sum < 0: current_sum = 0 temp_start = i + 1 # Adjust best_i and best_j to 1-based index return max_sum, best_i + 1, best_j + 1"},{"question":"def count_empty_cells(m: int, n: int) -> int: Returns the number of empty cells on the wall after using as many 1x2 and 2x1 canvases as possible. :param m: number of rows of the wall :param n: number of columns of the wall :return: number of empty cells left on the wall >>> count_empty_cells(3, 5) 1 >>> count_empty_cells(4, 6) 0","solution":"def count_empty_cells(m, n): Returns the number of empty cells on the wall after using as many 1x2 and 2x1 canvases as possible. :param m: number of rows of the wall :param n: number of columns of the wall :return: number of empty cells left on the wall # The number of filled cells is the floor of half the total cells filled_cells = (m * n) // 2 * 2 total_cells = m * n # The difference gives the number of empty cells empty_cells = total_cells - filled_cells return empty_cells"},{"question":"def two_sum(nums, target): Given a list of integers (nums) and a target integer (target), return indices of two distinct elements that add up to the target sum. Args: nums (list of int): List of integers. target (int): Target sum. Returns: list of int: Indices of the two elements, or an empty list if none exists. Example: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2]","solution":"def two_sum(nums, target): Given a list of integers (nums) and a target integer (target), return indices of two distinct elements that add up to the target sum. Args: nums (list of int): List of integers. target (int): Target sum. Returns: list of int: Indices of the two elements, or an empty list if none exists. num_idx = {} for idx, num in enumerate(nums): complement = target - num if complement in num_idx: return [num_idx[complement], idx] num_idx[num] = idx return []"},{"question":"def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. Args: matrix: A list of n lists, each containing n integers. Returns: A new matrix that is rotated 90 degrees clockwise. Examples: >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4]]) [ [3, 1], [4, 2] ] def format_matrix(matrix: List[List[int]]) -> str: Converts a matrix into a formatted string for printing. Args: matrix: A list of lists, representing the matrix. Returns: A string representation of the matrix with each row on a new line and elements in the rows separated by spaces. Examples: >>> format_matrix([ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3]]) '7 4 1n8 5 2n9 6 3' >>> format_matrix([ ... [3, 1], ... [4, 2]]) '3 1n4 2' def main(matrix_input: List[str]) -> str: Main function to read input matrix, rotate it and return the result. Args: matrix_input: A list of strings where the first element represents the size of the matrix n and the subsequent elements represent the rows of the matrix with integers separated by spaces. Returns: A string representation of the rotated matrix with each row on a new line and elements in the rows separated by spaces. Examples: >>> main([\\"3\\", \\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\"]) '7 4 1n8 5 2n9 6 3' >>> main([\\"2\\", \\"1 2\\", \\"3 4\\"]) '3 1n4 2' def test_rotate_3x3_matrix(): input_matrix = [ \\"3\\", \\"1 2 3\\", \\"4 5 6\\", \\"7 8 9\\" ] expected_output = ( \\"7 4 1n\\" \\"8 5 2n\\" \\"9 6 3\\" ) assert main(input_matrix) == expected_output def test_rotate_4x4_matrix(): input_matrix = [ \\"4\\", \\"1 2 3 4\\", \\"5 6 7 8\\", \\"9 10 11 12\\", \\"13 14 15 16\\" ] expected_output = ( \\"13 9 5 1n\\" \\"14 10 6 2n\\" \\"15 11 7 3n\\" \\"16 12 8 4\\" ) assert main(input_matrix) == expected_output def test_rotate_2x2_matrix(): input_matrix = [ \\"2\\", \\"1 2\\", \\"3 4\\" ] expected_output = ( \\"3 1n\\" \\"4 2\\" ) assert main(input_matrix) == expected_output def test_rotate_1x1_matrix(): input_matrix = [ \\"1\\", \\"1\\" ] expected_output = \\"1\\" assert main(input_matrix) == expected_output def test_rotate_5x5_matrix(): input_matrix = [ \\"5\\", \\"1 2 3 4 5\\", \\"6 7 8 9 10\\", \\"11 12 13 14 15\\", \\"16 17 18 19 20\\", \\"21 22 23 24 25\\" ] expected_output = ( \\"21 16 11 6 1n\\" \\"22 17 12 7 2n\\" \\"23 18 13 8 3n\\" \\"24 19 14 9 4n\\" \\"25 20 15 10 5\\" ) assert main(input_matrix) == expected_output","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given n x n matrix 90 degrees clockwise. n = len(matrix) # Create a new matrix to store the result rotated_matrix = [[0]*n for _ in range(n)] # Fill the rotated matrix for row in range(n): for col in range(n): rotated_matrix[col][n-1-row] = matrix[row][col] return rotated_matrix def format_matrix(matrix): Converts a matrix into a formatted string for printing. return 'n'.join(' '.join(map(str, row)) for row in matrix) def main(matrix_input): Main function to read input matrix, rotate it and print the result. n = matrix_input[0] matrix = [list(map(int, row.split())) for row in matrix_input[1:]] rotated_matrix = rotate_matrix_90_clockwise(matrix) return format_matrix(rotated_matrix)"},{"question":"from typing import List, Tuple def is_graph_connected(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with \`n\` nodes and \`m\` edges, determine if the graph is connected. >>> is_graph_connected(4, 2, [(1, 2), (3, 4)]) 'NO' >>> is_graph_connected(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 'YES' >>> is_graph_connected(5, 4, [(1, 2), (1, 3), (1, 4), (1, 5)]) 'YES' >>> is_graph_connected(1, 0, []) 'YES' >>> is_graph_connected(3, 1, [(1, 2)]) 'NO' >>> is_graph_connected(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 'YES'","solution":"def is_graph_connected(n, m, edges): from collections import defaultdict, deque if n == 1: return \\"YES\\" adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (n + 1) def bfs(start_node): queue = deque([start_node]) visited[start_node] = True while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) bfs(1) return \\"YES\\" if all(visited[1:]) else \\"NO\\""},{"question":"from typing import List def largestTimeFromDigits(digits: List[int]) -> str: Returns the largest possible time in 24-hour format (HH:MM) that can be formed by the given 4 digits. If no valid time can be made, returns an empty string. Examples: >>> largestTimeFromDigits([1, 2, 3, 4]) '23:41' >>> largestTimeFromDigits([0, 0, 0, 0]) '00:00' >>> largestTimeFromDigits([5, 5, 5, 5]) ''","solution":"from itertools import permutations def largestTimeFromDigits(digits): Returns the largest possible time in 24-hour format (HH:MM) that can be formed by the given 4 digits. If no valid time can be made, returns an empty string. max_time = -1 # Generate all possible permutations for perm in permutations(digits): hh, mm = perm[:2], perm[2:] hours = hh[0] * 10 + hh[1] minutes = mm[0] * 10 + mm[1] # Validate time if 0 <= hours <= 23 and 0 <= minutes <= 59: max_time = max(max_time, hours * 60 + minutes) if max_time == -1: return \\"\\" # Convert back to HH:MM format max_hours, max_minutes = divmod(max_time, 60) return f\\"{max_hours:02}:{max_minutes:02}\\""},{"question":"def run_length_encoding(s: str) -> list[tuple[str, int]]: Returns the run-length encoding of a string as a list of tuples (character, frequency). >>> run_length_encoding(\\"aaabbbbcc\\") [('a', 3), ('b', 4), ('c', 2)] >>> run_length_encoding(\\"aaaaa\\") [('a', 5)] >>> run_length_encoding(\\"abc\\") [('a', 1), ('b', 1), ('c', 1)] pass","solution":"def run_length_encoding(s): Returns the run-length encoding of a string as a list of tuples (character, frequency). if not s: return [] encoding = [] previous_char = s[0] count = 1 for char in s[1:]: if char == previous_char: count += 1 else: encoding.append((previous_char, count)) previous_char = char count = 1 # Append the last character and its count encoding.append((previous_char, count)) return encoding"},{"question":"def transportation_scheduling(N: int, C: int, pickup_dropoff_list: List[Tuple[int, int]]) -> int: Develop a program that simulates a transportation scheduling system for a shared ride service. Each trip has a fixed capacity of C seats, and there are N passengers wishing to travel, each with a specific pickup location and drop-off location. The goal is to group passengers into the fewest number of trips while maintaining the order of their requests. Each passenger provides their pickup and drop-off locations in the form of d_i and a_i, respectively. A passenger cannot be dropped off before all other passengers on the same trip whose destination is before their drop-off point. Furthermore, the service needs to ensure that the trips can accommodate the seating capacity and that the order of pickups and drop-offs respects the sequence in which passengers made their requests. >>> transportation_scheduling(4, 3, [(1, 5), (2, 6), (3, 7), (4, 8)]) 2 >>> transportation_scheduling(3, 2, [(1, 3), (2, 5), (4, 6)]) 2 >>> transportation_scheduling(5, 5, [(1, 10), (2, 9), (3, 8), (4, 7), (5, 6)]) 1 >>> transportation_scheduling(5, 3, [(1, 7), (2, 6), (3, 5), (4, 9), (5, 10)]) 2 >>> transportation_scheduling(2, 1, [(1, 1000000000), (2, 1000000000)]) 2 >>> transportation_scheduling(3, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> transportation_scheduling(3, 1, [(1, 2), (2, 3), (3, 4)]) 3 >>> transportation_scheduling(6, 3, [(1, 2), (2, 3), (3, 4), (5, 6), (6, 7), (7, 8)]) 2","solution":"def min_trips(N, C, passengers): Given the number of passengers and seating capacity, this function calculates the minimum number of trips required. passengers.sort() trips = 0 i = 0 while i < len(passengers): count = 1 end = passengers[i][1] trips += 1 while i + 1 < len(passengers) and count < C and passengers[i + 1][0] <= end: i += 1 count += 1 end = max(end, passengers[i][1]) i += 1 return trips # Function to handle main input/output def transportation_scheduling(N, C, pickup_dropoff_list): passengers = [(pickup_dropoff_list[i][0], pickup_dropoff_list[i][1]) for i in range(N)] return min_trips(N, C, passengers)"},{"question":"def unique_positions(D: str) -> int: Returns the number of unique positions the robot visits given the movement string D. >>> unique_positions('URDL') == 4 >>> unique_positions('') == 1 >>> unique_positions('UUUUU') == 6 >>> unique_positions('RULD') == 4 >>> unique_positions('UUDDLLRR') == 5 >>> unique_positions('UDUDUDUD') == 2 >>> unique_positions('R' * 100000) == 100001","solution":"def unique_positions(D): Returns the number of unique positions the robot visits given the movement string D. # Initial position x, y = 0, 0 # Set to store unique positions visited = set() # Add the initial position visited.add((x, y)) # Move according to the direction string D for move in D: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 # Add new position to the visited set visited.add((x, y)) # Return the number of unique positions return len(visited)"},{"question":"def count_valid_arrangements(n: int, m: int) -> int: Returns the number of valid arrangements of books such that no two books of the same genre are adjacent to each other. If the arrangement is not possible, return \\"ERROR\\". >>> count_valid_arrangements(3, 3) 20 >>> count_valid_arrangements(3, 2) 10 >>> count_valid_arrangements(5, 2) \\"ERROR\\" from typing import Union import math def factorial(x: int) -> int: Helper function to calculate the factorial of a number. return math.factorial(x)","solution":"def count_valid_arrangements(n, m): Returns the number of valid arrangements of books such that no two books of the same genre are adjacent to each other. if abs(n - m) > 1: return \\"ERROR\\" # Calculate factorial for n and m def factorial(x): if x == 0 or x == 1: return 1 return x * factorial(x - 1) # Calculate number of valid arrangements total_arrangements = factorial(n + m) // (factorial(n) * factorial(m)) return total_arrangements"},{"question":"def traveling_salesman(n: int, cost_matrix: List[List[int]]) -> int: Finds the minimum travel cost to visit all cities exactly once and return to the starting city. Arguments: n : int The number of cities. cost_matrix : list of list of int The cost matrix where cost_matrix[i][j] represents the cost to travel from city i to city j. Returns: int The minimum possible travel cost. >>> traveling_salesman(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80","solution":"import itertools def traveling_salesman(n, cost_matrix): Finds the minimum travel cost to visit all cities exactly once and return to the starting city. Arguments: n : int The number of cities. cost_matrix : list of list of int The cost matrix where cost_matrix[i][j] represents the cost to travel from city i to city j. Returns: int The minimum possible travel cost. cities = list(range(n)) all_permutations = itertools.permutations(cities[1:]) min_cost = float('inf') for perm in all_permutations: current_cost = 0 k = 0 # Calculate the cost for the current permutation of cities for j in perm: current_cost += cost_matrix[k][j] k = j current_cost += cost_matrix[k][0] # Update the minimum cost if the current cost is lower if current_cost < min_cost: min_cost = current_cost return min_cost"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the string \`s\` can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbccdde\\") True >>> can_form_palindrome(\\"abcabc\\") True","solution":"from collections import Counter def can_form_palindrome(s): Determines if the string \`s\` can be rearranged to form a palindrome. Args: s (str): The input string. Returns: bool: True if the string can be rearranged to form a palindrome, False otherwise. char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def max_non_adjacent_sum(arr): Find the maximum sum of non-adjacent elements in the array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([3, 2, 10, 1]) 13 >>> max_non_adjacent_sum([5, 5, 5, 5, 5]) 15 >>> max_non_adjacent_sum([7]) 7 >>> max_non_adjacent_sum([5, 10]) 10 >>> max_non_adjacent_sum([10000, 10000, 10000]) 20000 >>> max_non_adjacent_sum([]) 0 >>> max_non_adjacent_sum([0, 0, 0, 0]) 0 Args: arr (list): list of integers Returns: int: maximum sum of non-adjacent elements","solution":"def max_non_adjacent_sum(arr): Find the maximum sum of non-adjacent elements in the array. Args: arr (list): list of integers Returns: int: maximum sum of non-adjacent elements if not arr: return 0 if len(arr) == 1: return arr[0] include = arr[0] exclude = 0 for i in range(1, len(arr)): new_exclude = max(include, exclude) include = exclude + arr[i] exclude = new_exclude return max(include, exclude)"},{"question":"def max_cumulative_yield(inputs): Determine the maximum possible cumulative ore yield after optimally placing the K stabilization devices. Args: inputs : List of datasets where each dataset is a tuple containing: - N (int): The number of mining zones. - K (int): The number of stabilization devices. - A (List[int]): The ore yields of the mining zones. Returns: List[int]: The list of maximum possible cumulative ore yields for each dataset. >>> max_cumulative_yield([(5, 2, [10, 20, 30, 40, 50]), (6, 3, [1, 5, 3, 2, 8, 7]), (0, 0, [])]) [90, 20] >>> max_cumulative_yield([(1, 1, [100]), (0, 0, [])]) [100]","solution":"def max_cumulative_yield(inputs): results = [] for data in inputs: N, K, A = data if N == 0 and K == 0: break # Sort the array in descending order to get the highest yields to place the devices A_sorted = sorted(A, reverse=True) # Take the sum of the top K yields after placing the devices max_yield = sum(A_sorted[:K]) results.append(max_yield) return results"},{"question":"def makeAnagram(str1: str, str2: str) -> int: Determines the minimum number of deletions needed from two strings to make them anagrams of each other. >>> makeAnagram(\\"cde\\", \\"abc\\") 4 >>> makeAnagram(\\"abc\\", \\"cba\\") 0","solution":"from collections import Counter def makeAnagram(str1, str2): Determines the minimum number of deletions needed from two strings to make them anagrams of each other. Args: str1 (string): the first string. str2 (string): the second string. Returns: int: the number of deletions needed. # Count the frequency of each character in both strings counter1 = Counter(str1) counter2 = Counter(str2) # Calculate the deletions needed for str1 deletions = 0 for char in counter1: if char in counter2: deletions += abs(counter1[char] - counter2[char]) else: deletions += counter1[char] # Calculate the deletions needed for str2 for char in counter2: if char not in counter1: deletions += counter2[char] return deletions"},{"question":"def max_sum_submatrix(matrix: List[List[int]]) -> int: Compute the maximum sum of any non-empty submatrix in the given matrix. >>> max_sum_submatrix([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 >>> max_sum_submatrix([[5]]) 5 >>> max_sum_submatrix([[-1, -2], [-3, -4]]) -1 >>> max_sum_submatrix([ ... [2, 1, -3, -4, 5], ... [0, 6, 3, 4, 1], ... [2, -2, -1, 4, -5], ... [-3, 3, 1, 0, 3] ... ]) 18 >>> max_sum_submatrix([[1], [-2], [3], [4], [-2]]) 7 >>> max_sum_submatrix([[4, -1, 2, 1]]) 6","solution":"def max_sum_submatrix(matrix): n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') # The Kadane's algorithm for finding the maximum sum subarray in 1D def max_subarray(arr): max_end_here = max_so_far = arr[0] for x in arr[1:]: max_end_here = max(x, max_end_here + x) max_so_far = max(max_so_far, max_end_here) return max_so_far # Iterate over all pairs of columns for left in range(m): row_sum = [0] * n for right in range(left, m): # Sum between columns left and right for each row for i in range(n): row_sum[i] += matrix[i][right] # Find the maximum sum subarray in the row_sum array max_sum = max(max_sum, max_subarray(row_sum)) return max_sum"},{"question":"def can_use_all_ingredients(n: int, ingredients: List[int]) -> str: Determines if all ingredients can be used without conflicts. Parameters: n (int): The number of ingredients. ingredients (list of int): A list of integers where 0 indicates non-conflicting and 1 indicates conflicting. Returns: str: 'YES' if there are no conflicts, 'NO' otherwise. >>> can_use_all_ingredients(4, [0, 0, 0, 0]) 'YES' >>> can_use_all_ingredients(3, [0, 1, 0]) 'NO'","solution":"def can_use_all_ingredients(n, ingredients): Determines if all ingredients can be used without conflicts. Parameters: n (int): The number of ingredients. ingredients (list of int): A list of integers where 0 indicates non-conflicting and 1 indicates conflicting. Returns: str: 'YES' if there are no conflicts, 'NO' otherwise. return \\"NO\\" if 1 in ingredients else \\"YES\\""},{"question":"def count_distinct_substrings(s: str, k: int) -> int: Returns the number of distinct substrings of length k in the string s. >>> count_distinct_substrings(\\"abcabc\\", 3) 3 >>> count_distinct_substrings(\\"abc\\", 4) 0","solution":"def count_distinct_substrings(s, k): Returns the number of distinct substrings of length k in the string s. if k > len(s): return 0 substrings = set() for i in range(len(s) - k + 1): substr = s[i:i+k] substrings.add(substr) return len(substrings)"},{"question":"def count_unique_spells(T, test_cases): Given multiple queries, each indicating a segment of the forest by defining a start and end position, this function determines the number of unique spells in each specified segment. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int], int, List[Tuple[int, int]]]]): A list of test cases. Each test case is represented as a tuple: - An integer N, denoting the number of trees in the forest. - A list of N integers, representing the spells on each tree. - An integer Q, denoting the number of queries. - A list of Q tuples, each containing two integers L and R, indicating the range of trees (from L to R, inclusive). Returns: List[int]: The number of unique spells in each specified segment for all the queries. >>> count_unique_spells(1, [(5, [1, 2, 2, 3, 4], 3, [(1, 3), (2, 5), (1, 5)])]) [2, 3, 4] >>> count_unique_spells(2, [(5, [1, 2, 2, 3, 4], 3, [(1, 3), (2, 5), (1, 5)]), (6, [5, 5, 5, 5, 5, 5], 2, [(1, 3), (1, 6)])]) [2, 3, 4, 1, 1]","solution":"def count_unique_spells(T, test_cases): result = [] for case in test_cases: N, spells, Q, queries = case for L, R in queries: unique_spells = set(spells[L-1:R]) # L-1 and R to account for 0-based indexing result.append(len(unique_spells)) return result # Example usage: # T = 2 # test_cases = [ # (5, [1, 2, 2, 3, 4], 3, [(1, 3), (2, 5), (1, 5)]), # (6, [5, 5, 5, 5, 5, 5], 2, [(1, 3), (1, 6)]) # ] # print(count_unique_spells(T, test_cases)) # Expected output: [2, 3, 4, 1, 1]"},{"question":"def process_queries(n, array, q, queries): Process the given queries on the array. Each query can either add a number to a subarray or return the sum of a subarray. :param n: int, number of elements in the array :param array: list of int, the initial array :param q: int, number of queries :param queries: list of tuples, each representing a query :return: list of int, the results of all sum queries >>> process_queries(5, [1, 2, 3, 4, 5], 3, [(1, 1, 3, 10), (2, 1, 3), (2, 4, 5)]) [36, 9] >>> process_queries(4, [4, 3, 2, 1], 2, [(1, 2, 4, 2), (2, 1, 4)]) [16] >>> process_queries(3, [10, 20, 30], 4, [(1, 1, 2, 5), (2, 2, 3), (1, 3, 3, 10), (2, 1, 3)]) [55, 80] >>> process_queries(2, [5, 7], 2, [(1, 1, 1, 3), (2, 1, 2)]) [15] >>> process_queries(1, [10], 3, [(1, 1, 1, 5), (2, 1, 1), (1, 1, 1, -5)]) [15]","solution":"def process_queries(n, array, q, queries): Process the given queries on the array. :param n: int, number of elements in the array :param array: list of int, the initial array :param q: int, number of queries :param queries: list of tuples, each representing a query :return: list of int, the results of all sum queries results = [] for query in queries: if query[0] == 1: # Add x to elements from index l to r _, l, r, x = query for i in range(l - 1, r): array[i] += x elif query[0] == 2: # Calculate the sum of elements from index l to r _, l, r = query sum_result = sum(array[l-1:r]) results.append(sum_result) return results"},{"question":"from typing import List def findSubsetWithHalfSum(nums: List[int]) -> List[int]: Given an array of positive integers, determine if a subset of these numbers exists such that the sum of the subset is equal to half of the total sum of the array. If such a subset exists, return the subset; otherwise, return an empty array. Examples: >>> findSubsetWithHalfSum([1, 5, 11, 5]) [5, 5, 1] >>> findSubsetWithHalfSum([1, 2, 3, 5]) []","solution":"from typing import List def findSubsetWithHalfSum(nums: List[int]) -> List[int]: Given an array of positive integers, determine if a subset of these numbers exists such that the sum of the subset is equal to half of the total sum of the array. If such a subset exists, return the subset; otherwise, return an empty array. total_sum = sum(nums) # If the total_sum is odd, it's impossible to split it into two equal parts if total_sum % 2 != 0: return [] target_sum = total_sum // 2 n = len(nums) # Initialize the dp table dp = [False] * (target_sum + 1) dp[0] = True # Track the possible subsets parent = [-1] * (target_sum + 1) for i in range(n): for j in range(target_sum, nums[i] - 1, -1): if dp[j - nums[i]]: dp[j] = True parent[j] = i if not dp[target_sum]: return [] # Backtrack to find the subset subset = [] current_sum = target_sum while current_sum > 0: index = parent[current_sum] subset.append(nums[index]) current_sum -= nums[index] return subset"},{"question":"from typing import List def three_sum(nums: List[int]) -> List[List[int]]: Given an array of integers, return a list of all unique triplets in the array which gives the sum of zero. The solution set must not contain duplicate triplets. :param nums: List of integers. :return: A list of lists containing unique triplets that sum up to zero. Example: >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, 0, 1], [-1, -1, 2]] # Unit tests def test_three_sum_example(): assert sorted(three_sum([-1, 0, 1, 2, -1, -4])) == sorted([[-1, 0, 1], [-1, -1, 2]]) def test_three_sum_all_zeros(): assert three_sum([0, 0, 0, 0]) == [[0, 0, 0]] def test_three_sum_no_triplet(): assert three_sum([1, 2, -2, -1]) == [] def test_three_sum_multiple_triplets(): result = three_sum([-1, 0, 1, 2, -1, -4, -2, -3, 3, 0, 4]) expected = [[-4, 0, 4], [-4, 1, 3], [-3, -1, 4], [-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-1, -1, 2], [-1, 0, 1]] assert sorted(result) == sorted(expected) def test_three_sum_empty(): assert three_sum([]) == [] def test_three_sum_single_element(): assert three_sum([1]) == [] def test_three_sum_two_elements(): assert three_sum([1, -1]) == [] def test_three_sum_duplicate_elements(): result = three_sum([-2, 0, 1, 1, 2, 2, -1, -1, 0, -2, 1]) expected = [[-2, 0, 2], [-2, 1, 1], [-1, -1, 2], [-1, 0, 1]] assert sorted(result) == sorted(expected)","solution":"def three_sum(nums): Returns a list of all unique triplets in the array which gives the sum of zero. :type nums: List[int] :rtype: List[List[int]] nums.sort() result = [] n = len(nums) for i in range(n): if i > 0 and nums[i] == nums[i-1]: # Avoid duplicate for the first number continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: # Avoid duplicate for the second number left += 1 while left < right and nums[right] == nums[right - 1]: # Avoid duplicate for the third number right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return result"},{"question":"def count_distinct_in_subarrays(arr, n, k): Return the count of distinct integers in every contiguous subarray of length k. >>> count_distinct_in_subarrays([1, 2, 1, 3, 4, 2, 3], 7, 4) [3, 4, 4, 3] >>> count_distinct_in_subarrays([4, 1, 1, 3, 4], 5, 3) [2, 2, 3] >>> count_distinct_in_subarrays([1], 1, 1) [1] >>> count_distinct_in_subarrays([5, 5, 5, 5, 5], 5, 2) [1, 1, 1, 1] >>> count_distinct_in_subarrays([1, 2, 3, 4, 5], 5, 3) [3, 3, 3] >>> count_distinct_in_subarrays([1, 2, 3, 4, 5], 5, 5) [5] >>> count_distinct_in_subarrays([1, 2, 3], 3, 3) [3] >>> count_distinct_in_subarrays([1, 2, 3], 3, 4) []","solution":"def count_distinct_in_subarrays(arr, n, k): Returns the count of distinct integers in every contiguous subarray of length k. if k > n: return [] result = [] frequency = {} distinct_count = 0 # Initialize frequency dictionary for first window of size k for i in range(k): if arr[i] not in frequency: frequency[arr[i]] = 0 frequency[arr[i]] += 1 if frequency[arr[i]] == 1: distinct_count += 1 result.append(distinct_count) # Slide the window for i in range(k, n): # Remove the element going out of the window if frequency[arr[i - k]] == 1: distinct_count -= 1 frequency[arr[i - k]] -= 1 # Add the new element coming into the window if arr[i] not in frequency or frequency[arr[i]] == 0: frequency[arr[i]] = 0 distinct_count += 1 frequency[arr[i]] += 1 result.append(distinct_count) return result"},{"question":"def preprocess_array(array): Preprocess the array to create a prefix sum array. pass def range_sum(prefix_sum, l, r): Calculate the sum for the range query (l, r) using the prefix sum array. pass def answer_queries(n, m, array, queries): Answer m queries about the sum of elements between indices l and r. Parameters: n (int): The number of elements in the array. m (int): The number of queries. array (List[int]): The list of integers representing the array. queries (List[Tuple[int, int]]): The list of queries where each query is a tuple (l, r). Returns: List[int]: The list of results for each query. pass from solution import answer_queries def test_example_1(): n, m = 5, 3 array = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 5), (1, 5)] expected = [6, 14, 15] assert answer_queries(n, m, array, queries) == expected def test_example_2(): n, m = 5, 2 array = [5, 5, -5, -5, 5] queries = [(1, 5), (2, 4)] expected = [5, -5] assert answer_queries(n, m, array, queries) == expected def test_single_element_array(): n, m = 1, 1 array = [10] queries = [(1, 1)] expected = [10] assert answer_queries(n, m, array, queries) == expected def test_full_range_query(): n, m = 4, 1 array = [4, 3, 2, 1] queries = [(1, 4)] expected = [10] assert answer_queries(n, m, array, queries) == expected def test_large_number_case(): n, m = 5, 1 array = [-1000000000, 1000000000, -1000000000, 1000000000, -1000000000] queries = [(1, 5)] expected = [-1000000000] assert answer_queries(n, m, array, queries) == expected def test_same_start_end_query(): n, m = 4, 2 array = [1, 2, 3, 4] queries = [(2, 2), (3, 3)] expected = [2, 3] assert answer_queries(n, m, array, queries) == expected","solution":"def preprocess_array(array): Preprocess the array to create a prefix sum array. n = len(array) prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] return prefix_sum def range_sum(prefix_sum, l, r): Calculate the sum for the range query (l, r) using the prefix sum array. return prefix_sum[r] - prefix_sum[l - 1] def answer_queries(n, m, array, queries): Answer m queries about the sum of elements between indices l and r. prefix_sum = preprocess_array(array) results = [] for query in queries: l, r = query results.append(range_sum(prefix_sum, l, r)) return results"},{"question":"def min_initial_strength(n: int, a: List[int]) -> int: Determine the minimum original strength the projectile must have to pop all balloons. >>> min_initial_strength(5, [3, 1, 4, 1, 5]) 5 >>> min_initial_strength(1, [10]) 10 >>> min_initial_strength(4, [4, 4, 4, 4]) 4 >>> min_initial_strength(5, [1, 2, 3, 4, 5]) 5 >>> min_initial_strength(2, [1000000000, 999999999]) 1000000000","solution":"def min_initial_strength(n, a): Function to determine the minimum initial strength required for the projectile to pop all the balloons. Parameters: n (int): The number of balloons. a (list): A list of integers representing the strengths of the balloons. Returns: int: The minimum initial strength required. max_strength = max(a) return max_strength"},{"question":"class Elevator: def __init__(self, total_floors): Initializes an elevator with the given number of total floors. The elevator always starts on the ground floor (1st floor). pass def request_floor(self, floor): Adds a floor to the requested list of floors. The floor should be within the range of 1 to total_floors. pass def move(self): Moves the elevator to the next floor in the order of requests and prints the current floor number. If no requests are pending, it prints \\"No pending requests\\". pass def test_elevator_initialization(): elevator = Elevator(5) assert elevator.total_floors == 5 assert elevator.current_floor == 1 assert elevator.requests == [] def test_request_valid_floors(): elevator = Elevator(5) elevator.request_floor(3) elevator.request_floor(1) assert elevator.requests == [3, 1] def test_request_invalid_floors(): elevator = Elevator(5) elevator.request_floor(6) assert elevator.requests == [] elevator.request_floor(0) assert elevator.requests == [] def test_request_duplicate_floors(): elevator = Elevator(5) elevator.request_floor(2) elevator.request_floor(2) assert elevator.requests == [2] def test_elevator_movement(): elevator = Elevator(5) elevator.request_floor(3) elevator.request_floor(1) elevator.move() assert elevator.current_floor == 3 elevator.move() assert elevator.current_floor == 1 assert elevator.requests == [] def test_no_pending_requests(): elevator = Elevator(5) elevator.move() # Should print \\"No pending requests\\" if __name__ == \\"__main__\\": import sys import pytest pytest.main(sys.argv)","solution":"class Elevator: def __init__(self, total_floors): Initializes an elevator with the given number of total floors. The elevator always starts on the ground floor (1st floor). self.total_floors = total_floors self.current_floor = 1 self.requests = [] def request_floor(self, floor): Adds a floor to the requested list of floors. The floor should be within the range of 1 to total_floors. if 1 <= floor <= self.total_floors: if floor not in self.requests: self.requests.append(floor) else: print(\\"Invalid floor request\\") def move(self): Moves the elevator to the next floor in the order of requests and prints the current floor number. If no requests are pending, it prints \\"No pending requests\\". if self.requests: self.current_floor = self.requests.pop(0) print(f\\"Current floor: {self.current_floor}\\") else: print(\\"No pending requests\\")"},{"question":"from typing import List, Tuple, Union def minimum_time(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Union[int, str]: Find the minimum time required for the signal to travel from gear 1 to gear n. The function takes the number of gears \`n\`, the number of edges \`m\`, and a list of \`edges\` represented as tuples where each tuple contains three integers \`u\`, \`v\`, and \`w\` representing a directed edge from gear \`u\` to gear \`v\` with a weight \`w\`. If there is no valid path from gear 1 to gear n, the function returns \\"Timeless machinery\\". :param n: an integer representing the number of gears :param m: an integer representing the number of edges :param edges: a list of tuples, each containing three integers (u, v, w) :return: the minimum time for the signal to travel from gear 1 to gear n, or \\"Timeless machinery\\" if such a path does not exist. >>> minimum_time(4, 4, [(1, 2, 3), (2, 4, 5), (1, 3, 1), (3, 4, 4)]) 5 >>> minimum_time(5, 5, [(1, 2, 2), (2, 3, 2), (1, 3, 4), (3, 4, 1), (4, 5, 3)]) 8 >>> minimum_time(4, 2, [(1, 2, 3), (2, 3, 4)]) \\"Timeless machinery\\" >>> minimum_time(3, 2, [(1, 2, 1), (2, 3, 1)]) 2 >>> minimum_time(2, 1, [(1, 2, 10)]) 10","solution":"import heapq def minimum_time(n, m, edges): # Create adjacency list adj = [[] for _ in range(n+1)] for u, v, w in edges: adj[u].append((v, w)) # Dijkstra's algorithm to find the shortest path from node 1 to node n dist = [float('inf')] * (n + 1) dist[1] = 0 pq = [(0, 1)] # (cost, node) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in adj[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist[n] if dist[n] != float('inf') else \\"Timeless machinery\\" # Example usage n1, m1 = 4, 4 edges1 = [(1, 2, 3), (2, 4, 5), (1, 3, 1), (3, 4, 4)] print(minimum_time(n1, m1, edges1)) # Output: 5 n2, m2 = 5, 5 edges2 = [(1, 2, 2), (2, 3, 2), (1, 3, 4), (3, 4, 1), (4, 5, 3)] print(minimum_time(n2, m2, edges2)) # Output: 8"},{"question":"def largest_rectangle_area(heights): Given an array of non-negative integers \`heights\` representing the heights of several histograms of width 1, determine the maximum rectangular area that can be formed within the bounds of these histograms. >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([2, 2, 2, 2]) 8 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 1]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([0, 0, 0, 0]) 0 >>> largest_rectangle_area([2, 1, 4, 5, 1, 3, 3]) 8 >>> largest_rectangle_area([4, 2, 0, 3, 2, 5]) 6","solution":"def largest_rectangle_area(heights): This function takes a list of heights of histograms and returns the maximum rectangular area possible within the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top = stack.pop() if not stack: area = heights[top] * index else: area = heights[top] * (index - stack[-1] - 1) max_area = max(max_area, area) while stack: top = stack.pop() if not stack: area = heights[top] * index else: area = heights[top] * (index - stack[-1] - 1) max_area = max(max_area, area) return max_area"},{"question":"def preprocess_array(arr): Computes the prefix sums for the given array. Parameters: arr (list): The list of integers to preprocess. Returns: list: The prefix sums array. pass def subarray_sum(prefix_sums, l, r): Calculates the sum of elements from index l to r using the prefix sums. Parameters: prefix_sums (list): The list of prefix sums. l (int): The left index of the subarray (1-based index). r (int): The right index of the subarray (1-based index). Returns: int: The sum of the elements from index l to r. pass if __name__ == \\"__main__\\": # Example usage arr = [1, 2, 3, 4, 5] prefix_sums = preprocess_array(arr) queries = [(1, 3), (2, 4), (1, 5)] for l, r in queries: print(subarray_sum(prefix_sums, l, r)) # Expected output: # 6 # 9 # 15","solution":"def preprocess_array(arr): This function computes the prefix sums for the given array. Parameters: arr (list): The list of integers to preprocess. Returns: list: The prefix sums array. prefix_sums = [0] * (len(arr) + 1) for i in range(len(arr)): prefix_sums[i+1] = prefix_sums[i] + arr[i] return prefix_sums def subarray_sum(prefix_sums, l, r): This function calculates the sum of elements from index l to r using the prefix sums. Parameters: prefix_sums (list): The list of prefix sums. l (int): The left index of the subarray (1-based index). r (int): The right index of the subarray (1-based index). Returns: int: The sum of the elements from index l to r. return prefix_sums[r] - prefix_sums[l-1]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression and returns the result as an integer. The expression contains only non-negative integers and +, -, *, / operators with spaces. >>> evaluate_expression(\\"3 + 5\\") 8 >>> evaluate_expression(\\"10 - 2 * 3\\") 4 >>> evaluate_expression(\\"6 / 2 + 7\\") 10 >>> evaluate_expression(\\"8 * 3 / 4\\") 6 >>> evaluate_expression(\\"15 - 4 + 2 * 3\\") 17","solution":"def evaluate_expression(expression): Evaluates a mathematical expression and returns the result as an integer. The expression contains only non-negative integers and +, -, *, / operators with spaces. :param expression: str - The mathematical expression to evaluate. :return: int - The result of the evaluated expression. # Removing spaces from the expression expression = expression.replace(\\" \\", \\"\\") # Using eval to evaluate the expression result = eval(expression) return int(result)"},{"question":"def unique_paths_with_obstacles(m: int, n: int, grid: List[List[int]]) -> int: Determine the number of distinct paths from the top-left corner to the bottom-right corner of the grid. Args: m : int : the number of rows of the grid n : int : the number of columns of the grid grid : List[List[int]] : the grid representation with 0 for empty cells and 1 for obstacles Returns: int : the number of distinct paths >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 1 >>> unique_paths_with_obstacles(2, 2, [[0, 1], [1, 0]]) 0 pass # Helper function to parse the input, can be used for testing def parse_grid(input_str: str) -> Tuple[int, int, List[List[int]]]: Parse input string to extract grid details and convert it into the required format Args: input_str : str : raw input string containing grid dimensions and cell values Returns: Tuple[int, int, List[List[int]]] : a tuple containing number of rows, number of columns, and the grid >>> parse_grid(\\"3 3n0 0 0n0 1 0n0 0 0\\") (3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) >>> parse_grid(\\"2 2n0 1n1 0\\") (2, 2, [[0, 1], [1, 0]]) pass","solution":"def unique_paths_with_obstacles(m, n, grid): # If the start or end is blocked, there's no way to get from start to end if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Create a 2D dp array initialized to 0 dp = [[0]*n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] # Helper function to parse the input, can be used for testing def parse_grid(input_str): lines = input_str.strip().split('n') m, n = map(int, lines[0].split()) grid = [list(map(int, line.split())) for line in lines[1:]] return m, n, grid"},{"question":"def categorize_grades(grades): Categorize a list of grades into grade ranges and return the count of each category. A: 90-100 B: 80-89 C: 70-79 D: 60-69 F: 0-59 Args: grades (List[int]): List of student grades in the range 0 to 100 Returns: dict: A dictionary with the count of students in each grade category Examples: >>> categorize_grades([85, 92, 78, 64, 45, 88, 100, 73, 68, 91, 50]) {'A': 3, 'B': 2, 'C': 2, 'D': 2, 'F': 2} >>> categorize_grades([95, 84, 79, 82, 99, 65, 87, 54, 67, 72, 88, 91]) {'A': 3, 'B': 4, 'C': 2, 'D': 2, 'F': 1}","solution":"def categorize_grades(grades): Categorize a list of grades into grade ranges and return the count of each category. grade_categories = {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'F': 0} for grade in grades: if 90 <= grade <= 100: grade_categories['A'] += 1 elif 80 <= grade <= 89: grade_categories['B'] += 1 elif 70 <= grade <= 79: grade_categories['C'] += 1 elif 60 <= grade <= 69: grade_categories['D'] += 1 elif 0 <= grade <= 59: grade_categories['F'] += 1 return grade_categories"},{"question":"def flip_case_and_reverse(S: str) -> str: Flips the case of each alphabetic character in the string S and then reverses the entire string. Parameters: S (str): The input string. Returns: str: The modified string after case flipping and reversing. >>> flip_case_and_reverse(\\"Hello World!\\") == \\"!DLROw OLLEh\\" >>> flip_case_and_reverse(\\"\\") == \\"\\" >>> flip_case_and_reverse(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == \\"zyxwvutsrqponmlkjihgfedcba\\" >>> flip_case_and_reverse(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"ZYXWVUTSRQPONMLKJIHGFEDCBA\\" >>> flip_case_and_reverse(\\"aBcDeFg12345\\") == \\"54321GfEdCbA\\" >>> flip_case_and_reverse(\\"12345!@#%\\") == \\"%#@!54321\\" >>> flip_case_and_reverse(\\"a\\") == \\"A\\" >>> flip_case_and_reverse(\\"A\\") == \\"a\\" >>> flip_case_and_reverse(\\"1\\") == \\"1\\"","solution":"def flip_case_and_reverse(S): Flips the case of each alphabetic character in the string S and then reverses the entire string. Parameters: S (str): The input string. Returns: str: The modified string after case flipping and reversing. # Flip the case of each character flipped_string = ''.join(char.upper() if char.islower() else char.lower() for char in S) # Reverse the entire string reversed_string = flipped_string[::-1] return reversed_string"},{"question":"def simple_calculator(input_lines): Simulates a simple calculator that supports addition, subtraction, multiplication, and division. Parameters: input_lines (list of str): A list of arithmetic operations in the format \\"a operator b\\". Returns: list of str: The results of the calculations or error messages. pass # Unit test def test_simple_calculator(): input_lines = [ \\"3 + 4\\", \\"10 - 5\\", \\"6 * 7\\", \\"8 / 2\\", \\"10 / 0\\", \\"end\\" ] expected_output = [ \\"7\\", \\"5\\", \\"42\\", \\"4\\", \\"Error: Division by zero\\" ] assert simple_calculator(input_lines) == expected_output def test_simple_calculator_with_end_only(): input_lines = [ \\"end\\" ] expected_output = [] assert simple_calculator(input_lines) == expected_output def test_simple_calculator_invalid_operations(): input_lines = [ \\"3 4\\", \\"10 ** 5\\", \\"a - 3\\", \\"4 + four\\", \\"end\\" ] expected_output = [ \\"Error: Invalid operator\\", \\"Error: Invalid operator\\", \\"Error: Invalid input\\", \\"Error: Invalid input\\" ] assert simple_calculator(input_lines) == expected_output","solution":"def simple_calculator(input_lines): Simulates a simple calculator that supports addition, subtraction, multiplication, and division. Parameters: input_lines (list of str): A list of arithmetic operations in the format \\"a operator b\\". Returns: list of str: The results of the calculations or error messages. results = [] for line in input_lines: if line.strip().lower() == \\"end\\": break try: a, operator, b = line.split() a = int(a) b = int(b) if operator == '+': results.append(str(a + b)) elif operator == '-': results.append(str(a - b)) elif operator == '*': results.append(str(a * b)) elif operator == '/': if b == 0: results.append(\\"Error: Division by zero\\") else: results.append(str(a // b)) else: results.append(\\"Error: Invalid operator\\") except ValueError: results.append(\\"Error: Invalid input\\") return results"},{"question":"from typing import List def has_cycle(num_tasks: int, dependencies: List[List[int]]) -> bool: Determine if there is a cycle in the dependency graph of tasks. Args: num_tasks (int): An integer representing the number of tasks. dependencies (List[List[int]]): A list of lists where each list contains two integers representing a dependency. Returns: bool: True if there is a cycle in the graph, False otherwise. Examples: >>> has_cycle(4, [[0, 1], [0, 2], [1, 2], [2, 0], [2, 3]]) True >>> has_cycle(4, [[0, 1], [0, 2], [1, 2], [2, 3]]) False def test_no_dependencies(): assert has_cycle(4, []) == False def test_simple_cycle(): assert has_cycle(2, [[0, 1], [1, 0]]) == True def test_simple_no_cycle(): assert has_cycle(2, [[0, 1]]) == False def test_example_with_cycle(): assert has_cycle(4, [[0, 1], [0, 2], [1, 2], [2, 0], [2, 3]]) == True def test_example_without_cycle(): assert has_cycle(4, [[0, 1], [0, 2], [1, 2], [2, 3]]) == False def test_large_graph_no_cycle(): assert has_cycle(5, [[0, 1], [1, 2], [2, 3], [3, 4]]) == False def test_large_graph_with_cycle(): assert has_cycle(5, [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0]]) == True","solution":"from typing import List def has_cycle(num_tasks: int, dependencies: List[List[int]]) -> bool: # Create an adjacency list representation of the graph adj_list = {i: [] for i in range(num_tasks)} for prereq, task in dependencies: adj_list[prereq].append(task) # States: 0 = unvisited, 1 = visiting, 2 = visited state = [0] * num_tasks def dfs(task: int) -> bool: if state[task] == 1: # found a cycle return True if state[task] == 2: # already fully processed node return False state[task] = 1 # mark as visiting for next_task in adj_list[task]: if dfs(next_task): return True state[task] = 2 # mark as visited return False for task in range(num_tasks): if state[task] == 0: # unvisited node if dfs(task): return True return False"},{"question":"def find_rank(t: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: Finds the rank of the specific student's score for each test case. >>> find_rank(2, [(5, [100, 90, 90, 80, 70], 3), (4, [50, 50, 50, 40], 1)]) [4, 1] >>> find_rank(1, [(1, [100], 0)]) [1] >>> find_rank(1, [(5, [100, 90, 90, 90, 90], 2)]) [2] >>> find_rank(1, [(5, [85, 78, 92, 88, 91], 1)]) [5] from solution import find_rank def test_example_1(): t = 2 test_cases = [ (5, [100, 90, 90, 80, 70], 3), (4, [50, 50, 50, 40], 1) ] assert find_rank(t, test_cases) == [4, 1] def test_single_student(): t = 1 test_cases = [ (1, [100], 0), ] assert find_rank(t, test_cases) == [1] def test_multiple_students_tie(): t = 1 test_cases = [ (5, [100, 90, 90, 90, 90], 2), ] assert find_rank(t, test_cases) == [2] def test_all_different_scores(): t = 1 test_cases = [ (5, [85, 78, 92, 88, 91], 1), ] assert find_rank(t, test_cases) == [5] def test_maximum_values(): scores = [i for i in range(100000, 0, -1)] test_case = (100000, scores, 99999) t = 1 test_cases = [test_case] assert find_rank(t, test_cases) == [100000] def test_zero_indexed_position(): t = 1 test_cases = [ (5, [55, 65, 75, 85, 95], 0), ] assert find_rank(t, test_cases) == [5]","solution":"def find_rank(t, test_cases): Finds the rank of the specific student's score for each test case. Args: t (int): Number of test cases. test_cases (list): List of test cases, each test case is a tuple of (n, scores, m). Returns: list: Ranks of the specific student's score for each test case. output = [] for test in test_cases: n, scores, m = test specific_score = scores[m] sorted_scores = sorted(scores, reverse=True) rank = 1 rank_map = {} for i, score in enumerate(sorted_scores): if score not in rank_map: rank_map[score] = rank rank += 1 output.append(rank_map[specific_score]) return output"},{"question":"import heapq from typing import List, Tuple def shortest_even_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int, t: int) -> int: Finds the shortest path between two nodes in an undirected graph considering only even-weighted edges. Parameters: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int, int]]): List of edges where each tuple contains (u, v, w) representing an edge between nodes u and v with weight w. s (int): The source node. t (int): The destination node. Returns: int: The length of the shortest path from node s to node t using only even-weighted edges. Returns -1 if no such path exists. pass def test_shortest_even_path(): assert shortest_even_path(5, 6, [(1, 2, 10), (1, 3, 15), (2, 3, 12), (2, 4, 20), (3, 4, 18), (4, 5, 2)], 1, 5) == 32 assert shortest_even_path(4, 4, [(1, 2, 5), (2, 3, 7), (3, 4, 9), (4, 1, 11)], 1, 4) == -1 # Test case with no edges assert shortest_even_path(2, 0, [], 1, 2) == -1 # Test case with all weights being odd assert shortest_even_path(4, 4, [(1, 2, 1), (2, 3, 3), (3, 4, 5), (4, 1, 7)], 1, 4) == -1 # Test case with single even-weight edge assert shortest_even_path(2, 1, [(1, 2, 2)], 1, 2) == 2 # Test case with multiple even-weight paths assert shortest_even_path(5, 7, [(1, 2, 4), (2, 3, 6), (3, 4, 10), (4, 5, 12), (1, 3, 8), (3, 5, 16), (1, 5, 18)], 1, 5) == 18 if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"import heapq def shortest_even_path(n, m, edges, s, t): Finds the shortest path between two nodes in an undirected graph considering only even-weighted edges. Parameters: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (list of tuples): List of edges where each tuple contains (u, v, w) representing an edge between nodes u and v with weight w. s (int): The source node. t (int): The destination node. Returns: int: The length of the shortest path from node s to node t using only even-weighted edges. Returns -1 if no such path exists. # adjacency list: { node: [(neighbour, weight), ...] } adj = {i: [] for i in range(1, n + 1)} for u, v, w in edges: if w % 2 == 0: adj[u].append((v, w)) adj[v].append((u, w)) # Dijkstra's algorithm pq = [(0, s)] # (cost, node) dist = {i: float('inf') for i in range(1, n + 1)} dist[s] = 0 visited = set() while pq: d, u = heapq.heappop(pq) if u in visited: continue visited.add(u) for v, weight in adj[u]: if v not in visited and d + weight < dist[v]: dist[v] = d + weight heapq.heappush(pq, (dist[v], v)) return dist[t] if dist[t] != float('inf') else -1"},{"question":"def count_groups(heights): Find the number of groups of students that can be formed such that the heights of the students in the group increase strictly from left to right and the difference between the heights of any two consecutive students in the group is exactly 1. >>> count_groups([1, 2, 3, 4, 5, 6, 7]) 6 >>> count_groups([10, 9, 8, 7, 5, 6]) 1 >>> count_groups([10, 20, 30, 40]) 0 >>> count_groups([1, 2, 3, 4, 5]) 4 >>> count_groups([3, 4]) 1 >>> count_groups(list(range(1, 10**5 + 1))) 99999","solution":"def count_groups(heights): Returns the number of valid groups of students where heights increase by 1. count = 0 for i in range(len(heights) - 1): if heights[i+1] - heights[i] == 1: count += 1 return count"},{"question":"def max_tree_score(N: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Given a tree with N nodes, each node has a certain value assigned to it. Define the score of a subtree as the product of values of all its nodes. You are required to find the maximum score among all possible subtrees of the given tree. >>> max_tree_score(3, [2, 3, 4], [(1, 2), (1, 3)]) 24 >>> max_tree_score(4, [3, 5, 2, 6], [(1, 2), (1, 3), (3, 4)]) 180","solution":"MOD = 1000000007 def max_tree_score(N, values, edges): from collections import defaultdict import sys sys.setrecursionlimit(10000) # Convert the edges list into an adjacency list tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): product = values[node - 1] for child in tree[node]: if child != parent: product = product * dfs(child, node) % MOD return product # We need to find the maximum product subtree starting from any node max_score = max(dfs(i, -1) for i in range(1, N + 1)) % MOD return max_score"},{"question":"def remove_duplicate_letters(s: str) -> str: Remove duplicate letters so that every letter appears once and only once. Ensure the resultant string is the smallest in lexicographical order. >>> remove_duplicate_letters(\\"bcabc\\") \\"abc\\" >>> remove_duplicate_letters(\\"cbacdcbc\\") \\"acdb\\"","solution":"def remove_duplicate_letters(s: str) -> str: Remove duplicate letters so that every letter appears once and only once. Ensure the resultant string is the smallest in lexicographical order. stack = [] seen = set() last_occurrence = {c: i for i, c in enumerate(s)} for i, c in enumerate(s): if c not in seen: while stack and c < stack[-1] and i < last_occurrence[stack[-1]]: seen.remove(stack.pop()) seen.add(c) stack.append(c) return ''.join(stack)"},{"question":"def factorial(n: int) -> int: Compute the factorial of a non-negative integer n. >>> factorial(5) == 120 >>> factorial(0) == 1 pass # Unit tests def test_factorial_base_cases(): assert factorial(0) == 1 assert factorial(1) == 1 def test_factorial_small_numbers(): assert factorial(2) == 2 assert factorial(3) == 6 assert factorial(4) == 24 def test_factorial_medium_numbers(): assert factorial(5) == 120 assert factorial(6) == 720 def test_factorial_upper_bound(): assert factorial(12) == 479001600","solution":"def factorial(n): Returns the factorial of a non-negative integer n. if n == 0: return 1 else: result = 1 for i in range(1, n+1): result *= i return result"},{"question":"from typing import List def longest_trend(prices: List[int]) -> int: Find the length of the longest trend in a sequence of stock prices. A trend is defined as a contiguous subsequence where every element is either strictly greater than or strictly less than its predecessor. Args: prices (List[int]): A list of integers representing the closing prices of a stock over several days. Returns: int: The length of the longest trend. Examples: >>> longest_trend([1, 2, 3, 2, 1, 5, 6, 7, 8, 5]) 5 >>> longest_trend([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 10 >>> longest_trend([5, 1, 5, 1, 5, 1, 5, 1, 5, 1]) 2 >>> longest_trend([1, 2, 1, 2, 1, 2, 1, 2]) 2 def test_simple_increasing(): assert longest_trend([1, 2, 3]) == 3 def test_simple_decreasing(): assert longest_trend([3, 2, 1]) == 3 def test_mixed_trend(): assert longest_trend([1, 2, 3, 2, 1, 5, 6, 7, 8, 5]) == 5 assert longest_trend([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 10 assert longest_trend([5, 1, 5, 1, 5, 1, 5, 1, 5, 1]) == 2 assert longest_trend([1, 2, 1, 2, 1, 2, 1, 2]) == 2 def test_no_change(): assert longest_trend([5, 5, 5, 5]) == 1 def test_single_price(): assert longest_trend([7]) == 1 def test_alternating_prices(): assert longest_trend([10, 9, 10, 9, 10]) == 2 def test_complex_trend(): assert longest_trend([1, 3, 5, 4, 3, 2, 1, 4, 3, 2]) == 5","solution":"from typing import List def longest_trend(prices: List[int]) -> int: if len(prices) < 2: return len(prices) max_length = 1 current_length = 1 # Determine initial trend trend = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: if trend != 1: trend = 1 current_length = 2 else: current_length += 1 elif prices[i] < prices[i - 1]: if trend != -1: trend = -1 current_length = 2 else: current_length += 1 else: trend = 0 current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def find_multiples_length(n, p, q): Returns the length of the longest contiguous subarray of integers between 1 and n (inclusive) such that every element of the subarray can be expressed as a sum of multiples of p and q. >>> find_multiples_length(10, 2, 3) 10 >>> find_multiples_length(15, 3, 5) 15","solution":"from math import gcd def find_multiples_length(n, p, q): Returns the length of the longest contiguous subarray of integers between 1 and n (inclusive) such that every element of the subarray can be expressed as a sum of multiples of p and q. def can_be_expressed(k, p, q): # Using gcd to determine expressibility via the theorem of linear combinations return gcd(p, q) == 1 # Checking if p and q are coprime if can_be_expressed(1, p, q): return n else: return 0 # Technically, this branch will never run since p and q are prime and hence coprime"},{"question":"def TwoSum(arr, target): Given an array of distinct integers arr and a target integer target, return the indices of the first two numbers such that they add up to the target. Args: arr (list of int): List of distinct integers. target (int): Target sum. Returns: tuple: A tuple containing the indices of the two numbers that add up to the target. Examples: >>> TwoSum([2, 7, 11, 15], 9) (0, 1) >>> TwoSum([3, 2, 4], 6) (1, 2) >>> TwoSum([3, 3], 6) (0, 1) pass from solution import TwoSum def test_TwoSum_example_1(): assert TwoSum([2, 7, 11, 15], 9) == (0, 1) def test_TwoSum_example_2(): assert TwoSum([3, 2, 4], 6) == (1, 2) def test_TwoSum_example_3(): assert TwoSum([3, 3], 6) == (0, 1) def test_TwoSum_large_numbers(): assert TwoSum([1000000, 500000, -1500000], -1000000) == (1, 2) def test_TwoSum_negative_numbers(): assert TwoSum([-1, -2, -3, -4, -5], -8) == (2, 4) def test_TwoSum_single_pair(): assert TwoSum([1, 2], 3) == (0, 1)","solution":"def TwoSum(arr, target): Returns the indices of the two numbers in the array that add up to the target. Args: arr (list of int): List of distinct integers. target (int): Target sum. Returns: tuple: A tuple containing the indices of the two numbers that add up to the target. num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None # As the assumption is that there is exactly one solution, this line should not be reached."},{"question":"def min_servers(tasks): Calculate the minimum number of servers required to schedule all tasks without overlap. Args: tasks (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the start and end times of a task. Returns: int: The minimum number of servers required. Example: >>> min_servers([(1, 4), (2, 5), (3, 6)]) 3 >>> min_servers([(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> min_servers([(1, 5), (2, 6), (3, 7), (4, 8)]) 4","solution":"def min_servers(tasks): from heapq import heappush, heappop # Sort tasks by start time tasks.sort(key=lambda x: x[0]) min_servers_needed = 0 end_times = [] for start, end in tasks: # Remove all tasks whose end time is before the current task's start time while end_times and end_times[0] <= start: heappop(end_times) # Add the current task's end time to the heap heappush(end_times, end) # The size of the heap is the number of parallel tasks at this moment min_servers_needed = max(min_servers_needed, len(end_times)) return min_servers_needed"},{"question":"from typing import List def sum_of_subsets(arr: List[int], target: int) -> bool: Determines if there is a subset of \`arr\` that sums up to \`target\`. Args: arr (List[int]): A list of positive integers. target (int): A positive integer target. Returns: bool: True if there is a subset that sums up to target, otherwise False. Examples: >>> sum_of_subsets([2, 3, 7, 8, 10], 11) True >>> sum_of_subsets([1, 5, 11, 5], 10) True >>> sum_of_subsets([1, 2, 3, 9], 8) False def test_sum_of_subsets_example_1(): assert sum_of_subsets([2, 3, 7, 8, 10], 11) == True def test_sum_of_subsets_example_2(): assert sum_of_subsets([1, 5, 11, 5], 10) == True def test_sum_of_subsets_example_3(): assert sum_of_subsets([1, 2, 3, 9], 8) == False def test_sum_of_subsets_single_element_true(): assert sum_of_subsets([5], 5) == True def test_sum_of_subsets_single_element_false(): assert sum_of_subsets([5], 3) == False def test_sum_of_subsets_multiple_elements_no_solution(): assert sum_of_subsets([3, 5, 7, 9], 2) == False def test_sum_of_subsets_all_elements_needed(): assert sum_of_subsets([1, 2, 3, 4], 10) == True def test_sum_of_subsets_large_target(): assert sum_of_subsets([1, 2, 3, 4, 5, 6, 7, 8, 9], 45) == True def test_sum_of_subsets_large_input(): assert sum_of_subsets(list(range(1, 21)), 210) == True","solution":"from typing import List def sum_of_subsets(arr: List[int], target: int) -> bool: Determines if there is a subset of \`arr\` that sums up to \`target\`. n = len(arr) dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): if dp[j - num]: dp[j] = True return dp[target]"},{"question":"def generate_new_password(current_password: str, shift: int) -> str: Generate a new password by shifting each character of the current password by a fixed number of positions forward in the ASCII table. Args: current_password (str): The current password string containing only lowercase alphabetic characters. shift (int): The number of positions to shift each character. Returns: str: The new password. >>> generate_new_password(\\"password\\", 1) == \\"qbttxpse\\" >>> generate_new_password(\\"abc\\", 2) == \\"cde\\" >>> generate_new_password(\\"xyz\\", 3) == \\"abc\\"","solution":"def generate_new_password(current_password, shift): Generate a new password by shifting each character of the current password by a fixed number of positions forward in the ASCII table. Args: current_password (str): The current password string containing only lowercase alphabetic characters. shift (int): The number of positions to shift each character. Returns: str: The new password. new_password = [] for char in current_password: new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) new_password.append(new_char) return ''.join(new_password)"},{"question":"def maximum_sum(cards): Determine the maximum sum of numbers that the first player can accumulate by the end of the game, assuming both players play optimally. Args: cards (List[int]): List of integers representing the values of the cards. Returns: int: The maximum sum for the first player. >>> maximum_sum([1, 2, 9, 4]) 10 >>> maximum_sum([6, 2, 3]) 8 >>> maximum_sum([5]) 5 >>> maximum_sum([5, 5, 5, 5, 5]) 15 >>> maximum_sum([1, 2, 3, 4, 5, 6]) 12 >>> maximum_sum([6, 5, 4, 3, 2, 1]) 12 >>> maximum_sum([8, 15, 3, 7]) 22 def process_test_cases(t, test_cases): Process multiple test cases to determine the maximum sum for the first player. Args: t (int): Number of test cases. test_cases (List[List[int]]): List containing t lists of integers, where each list represents the values of the cards for a test case. Returns: List[int]: List of maximum sums for the first player for each test case. >>> process_test_cases(2, [[1, 2, 9, 4], [6, 2, 3]]) [10, 8]","solution":"def maximum_sum(cards): n = len(cards) dp = [[0] * n for _ in range(n)] for length in range(1, n + 1): for i in range(n - length + 1): j = i + length - 1 if i == j: dp[i][j] = cards[i] else: dp[i][j] = max(cards[i] - dp[i + 1][j], cards[j] - dp[i][j - 1]) total_sum = sum(cards) first_player_sum = (total_sum + dp[0][n - 1]) // 2 return first_player_sum def process_test_cases(t, test_cases): results = [] for cards in test_cases: result = maximum_sum(cards) results.append(result) return results # Sample usage if __name__ == \\"__main__\\": t = 2 test_cases = [ [1, 2, 9, 4], [6, 2, 3] ] results = process_test_cases(t, test_cases) for result in results: print(result)"},{"question":"def minimum_swaps(s: str, t: str) -> int: Returns the minimum number of swaps required to make the strings s and t equal. Constraints: - 1 â‰¤ |s| = |t| â‰¤ 10^6 - s and t consist of lowercase letters only. Examples: >>> minimum_swaps(\\"abcd\\", \\"cdab\\") 2 >>> minimum_swaps(\\"aabb\\", \\"bbaa\\") 2 >>> minimum_swaps(\\"abc\\", \\"abc\\") 0 >>> minimum_swaps(\\"abc\\", \\"def\\") -1 >>> minimum_swaps(\\"ab\\", \\"ba\\") 1","solution":"from collections import Counter def minimum_swaps(s, t): Returns the minimum number of swaps required to make the strings s and t equal. # Check if the character counts are the same for both strings if Counter(s) != Counter(t): return -1 # If they don't have the same characters, it's impossible to make them equal # Count the mismatched characters mismatch_count = sum(1 for i in range(len(s)) if s[i] != t[i]) # Each swap can correct two mismatched positions return mismatch_count // 2"},{"question":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of non-overlapping intervals. >>> merge_intervals([[1,3],[2,6],[8,10],[15,18]]) [[1,6],[8,10],[15,18]] >>> merge_intervals([[1,4],[4,5]]) [[1,5]] >>> merge_intervals([[1,4],[2,3]]) [[1,4]]","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns a list of non-overlapping intervals. if not intervals: return [] # Sort intervals by the start time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If merged is empty or there is no overlap with the last interval in merged if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Merge the current interval with the last one in merged merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def can_be_expressed_as_sum_of_consecutive_numbers(N: int) -> str: Function to determine if a given number N can be expressed as the sum of consecutive natural numbers. >>> can_be_expressed_as_sum_of_consecutive_numbers(15) == \\"YES\\" >>> can_be_expressed_as_sum_of_consecutive_numbers(16) == \\"NO\\" >>> can_be_expressed_as_sum_of_consecutive_numbers(21) == \\"YES\\" >>> can_be_expressed_as_sum_of_consecutive_numbers(10) == \\"YES\\" >>> can_be_expressed_as_sum_of_consecutive_numbers(1000000000) == \\"YES\\" >>> can_be_expressed_as_sum_of_consecutive_numbers(999999999) == \\"YES\\"","solution":"def can_be_expressed_as_sum_of_consecutive_numbers(N): Function to determine if a given number N can be expressed as the sum of consecutive natural numbers. if N < 3: return \\"NO\\" count = 1 while (N > 0): N -= count count += 1 if N % count == 0 and N > 0: return \\"YES\\" return \\"NO\\""},{"question":"def store_inventory(N, initial_data, operations): A store sells N types of fruits and performs various operations to manage inventory and pricing. There are three types of operations: 1. Update the price of a specific fruit. 2. Update the quantity of a specific fruit. 3. Calculate the total value of inventory for a specific fruit (price * quantity). Parameters: - N (int): The number of fruit types. - initial_data (List[Tuple[int, int]]): A list of tuples where each tuple contains the initial price and quantity of a fruit. - operations (List[Tuple[int, ...]]): A list of operations to be performed: - (\\"1 x p\\"): Update the price of fruit x to p. - (\\"2 x q\\"): Update the quantity of fruit x to q. - (\\"3 x\\"): Calculate and return the total value of fruit x. Returns: - List[int]: The results of the total value calculations for each \\"3 x\\" operation. Example: >>> N = 3 >>> initial_data = [(10, 5), (20, 8), (15, 10)] >>> operations = [(1, 2, 25), (3, 2), (2, 1, 7), (3, 1), (3, 3)] >>> store_inventory(N, initial_data, operations) [200, 70, 150] from solution import store_inventory def test_store_inventory(): # Sample test case N = 3 initial_data = [(10, 5), (20, 8), (15, 10)] operations = [(1, 2, 25), (3, 2), (2, 1, 7), (3, 1), (3, 3)] result = store_inventory(N, initial_data, operations) assert result == [200, 70, 150] def test_store_inventory_all_updates(): # Test case with all price and quantity updates N = 2 initial_data = [(10, 10), (20, 20)] operations = [(1, 1, 15), (2, 2, 25), (3, 1), (3, 2), (1, 2, 30), (2, 1, 5), (3, 1), (3, 2)] result = store_inventory(N, initial_data, operations) assert result == [150, 500, 75, 750] def test_store_inventory_no_updates(): # Test case without any updates N = 4 initial_data = [(10, 10), (20, 20), (5, 5), (1, 1)] operations = [(3, 1), (3, 2), (3, 3), (3, 4)] result = store_inventory(N, initial_data, operations) assert result == [100, 400, 25, 1] def test_store_inventory_only_updates(): # Test case with only updates and no value calculations N = 2 initial_data = [(20, 15), (10, 30)] operations = [(1, 1, 25), (2, 2, 35), (1, 2, 40), (2, 1, 20)] result = store_inventory(N, initial_data, operations) assert result == [] def test_store_inventory_mixed_operations(): # Mixed operations including multiple value calculations, price updates, and quantity updates N = 2 initial_data = [(30, 25), (50, 10)] operations = [(3, 1), (1, 1, 35), (2, 2, 15), (3, 2), (3, 1), (1, 2, 60), (2, 1, 30), (3, 1), (3, 2)] result = store_inventory(N, initial_data, operations) assert result == [750, 750, 875, 1050, 900]","solution":"def store_inventory(N, initial_data, operations): fruits = {} # Initialize the inventory for i in range(1, N + 1): price, quantity = initial_data[i - 1] fruits[i] = {'price': price, 'quantity': quantity} result = [] # Process each operation for op in operations: if op[0] == 1: # Update price operation fruits[op[1]]['price'] = op[2] elif op[0] == 2: # Update quantity operation fruits[op[1]]['quantity'] = op[2] elif op[0] == 3: # Calculate total value operation fruit_id = op[1] total_value = fruits[fruit_id]['price'] * fruits[fruit_id]['quantity'] result.append(total_value) return result"},{"question":"def min_path_sum(grid): Given an m x n grid filled with non-negative integers, this function finds the minimum sum of values along a path from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. :param grid: List[List[int]] - 2D list representing the matrix. :return: int - Minimum sum of the values along the path. Examples: >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2], [1, 1]]) 3 pass import unittest class TestMinPathSum(unittest.TestCase): def test_min_path_sum_base_case(self): self.assertEqual(min_path_sum([[1]]), 1) def test_min_path_sum_two_by_two(self): self.assertEqual(min_path_sum([[1, 2], [1, 1]]), 3) def test_min_path_sum_example_case(self): self.assertEqual(min_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), 7) def test_min_path_sum_larger_matrix(self): self.assertEqual(min_path_sum([ [1, 3, 5, 8], [4, 2, 1, 7], [4, 3, 2, 3] ]), 12) # Path is 1->3->2->2->3->1 def test_min_path_sum_all_zeros(self): self.assertEqual(min_path_sum([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]), 0) def test_min_path_sum_single_row(self): self.assertEqual(min_path_sum([[1, 2, 3, 4]]), 10) # Only one path def test_min_path_sum_single_column(self): self.assertEqual(min_path_sum([ [1], [2], [3], [4] ]), 10) # Only one path if __name__ == '__main__': unittest.main()","solution":"def min_path_sum(grid): Given an m x n grid filled with non-negative integers, this function finds the minimum sum of values along a path from the top-left corner to the bottom-right corner of the matrix. You can only move either down or right at any point in time. :param grid: List[List[int]] - 2D list representing the matrix. :return: int - Minimum sum of the values along the path. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the DP array with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Set the value for the starting cell dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the DP table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def find_longest_path(n, m, edges): Calculate the maximum travel time among all paths starting from any single bus stop in a directed acyclic graph (DAG). Args: n (int): The number of bus stops. m (int): The number of routes. edges (List[Tuple[int, int, int]]): A list of tuples (u, v, w) representing a route from stop u to stop v with travel time w. Returns: int: The longest path duration. Examples: >>> find_longest_path(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 3), (2, 4, 2), (3, 4, 1), (3, 5, 5)]) 12 >>> find_longest_path(4, 4, [(1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 4, 3)]) 7","solution":"from collections import defaultdict, deque def find_longest_path(n, m, edges): # Create adjacency list and in-degree count adj = defaultdict(list) in_degree = [0] * (n + 1) for u, v, w in edges: adj[u].append((v, w)) in_degree[v] += 1 # Topological sort using Kahn's algorithm topo = [] queue = deque([node for node in range(1, n + 1) if in_degree[node] == 0]) while queue: node = queue.popleft() topo.append(node) for neigh, w in adj[node]: in_degree[neigh] -= 1 if in_degree[neigh] == 0: queue.append(neigh) # Initialize distances dist = [0] * (n + 1) # Calculate the longest path using topological order for node in topo: for neigh, w in adj[node]: if dist[neigh] < dist[node] + w: dist[neigh] = dist[node] + w return max(dist) # Example usage: edges1 = [ (1, 2, 4), (1, 3, 2), (2, 3, 3), (2, 4, 2), (3, 4, 1), (3, 5, 5) ] print(find_longest_path(5, 6, edges1)) # Output: 12 edges2 = [ (1, 2, 3), (1, 3, 2), (2, 4, 4), (3, 4, 3) ] print(find_longest_path(4, 4, edges2)) # Output: 7"},{"question":"def find_primes_in_range(A: int, B: int) -> List[int]: Generate all prime numbers between two given integers, inclusive. Parameters: A (int): The lower bound of the range. B (int): The upper bound of the range. Returns: List[int]: A list of prime numbers in the range [A, B].","solution":"def sieve_of_eratosthenes(max_num): primes = [True] * (max_num + 1) primes[0] = primes[1] = False p = 2 while p * p <= max_num: if primes[p]: for i in range(p * p, max_num + 1, p): primes[i] = False p += 1 return primes def find_primes_in_range(A, B): if A > B or A < 1 or B > 10**6: raise ValueError(\\"Invalid range\\") primes = sieve_of_eratosthenes(B) prime_nums = [num for num in range(A, B + 1) if primes[num]] if prime_nums: return prime_nums else: return [\\"No primes\\"] # Example usage: # primes_in_range = find_primes_in_range(10, 30) # for prime in primes_in_range: # print(prime)"},{"question":"def can_defeat_all_enemies(n: int, p: int) -> str: Determine if Ikta can defeat all enemies on the bridge. Given the length of the bridge \`n\` and Ikta's initial position \`p\`, return \\"YES\\" if she can defeat all enemies approaching from both sides, otherwise return \\"NO\\". >>> can_defeat_all_enemies(5, 2) \\"YES\\" >>> can_defeat_all_enemies(10, 0) \\"NO\\" >>> can_defeat_all_enemies(7, 3) \\"YES\\"","solution":"def can_defeat_all_enemies(n, p): if n == 1: return \\"YES\\" return \\"YES\\" if 0 < p < n - 1 else \\"NO\\""},{"question":"def is_valid_hierarchy(n, connections): Verify if the given company structure forms a 4-layer hierarchy rooted at the CEO. :param n: The number of employees in the company. :param connections: A list of tuples where each tuple contains two integers (u, v) indicating a direct connection between employees u and v. :return: \\"Valid\\" if the company structure forms the specified 4-layer hierarchy, \\"Invalid\\" otherwise. >>> is_valid_hierarchy(13, [(1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (2, 7), (3, 8), (3, 9), (3, 10), (4, 11), (4, 12), (4, 13)]) 'Valid' >>> is_valid_hierarchy(7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]) 'Invalid' from collections import defaultdict, deque # Your implementation goes here def test_valid_hierarchy(): n = 40 connections = [ (1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (2, 7), (3, 8), (3, 9), (3, 10), (4, 11), (4, 12), (4, 13), (5, 14), (5, 15), (5, 16), (6, 17), (6, 18), (6, 19), (7, 20), (7, 21), (7, 22), (8, 23), (8, 24), (8, 25), (9, 26), (9, 27), (9, 28), (10, 29), (10, 30), (10, 31), (11, 32), (11, 33), (11, 34), (12, 35), (12, 36), (12, 37), (13, 38), (13, 39), (13, 40) ] assert is_valid_hierarchy(n, connections) == \\"Valid\\" def test_invalid_hierarchy_chain(): n = 7 connections = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7) ] assert is_valid_hierarchy(n, connections) == \\"Invalid\\" def test_invalid_hierarchy_incomplete(): n = 30 # Less than required 40 employees connections = [ (1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (2, 7), (3, 8), (3, 9), (3, 10), (4, 11), (4, 12), (4, 13), (5, 14), (5, 15), (5, 16), (6, 17), (6, 18), (6, 19), (7, 20), (7, 21), (7, 22), (8, 23), (8, 24), (8, 25), (9, 26), (9, 27), (9, 28) ] assert is_valid_hierarchy(n, connections) == \\"Invalid\\" def test_invalid_hierarchy_wrong_structure(): n = 40 connections = [ (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (2, 8), (8, 9), (9, 10), (10, 11), (11, 12), (12, 13), (2, 14), (14, 15), (15, 16), (3, 17), (17, 18), (18, 19), (3, 20), (20, 21), (21, 22), (3, 23), (23, 24), (24, 25), (4, 26), (26, 27), (27, 28), (4, 29), (29, 30), (30, 31), (4, 32), (32, 33), (33, 34), (5, 35), (35, 36), (36, 37), (5, 38), (38, 39), (39, 40) ] assert is_valid_hierarchy(n, connections) == \\"Invalid\\"","solution":"from collections import defaultdict, deque def is_valid_hierarchy(n, connections): if n != 1 + 3 + 9 + 27: # Check the exact number of nodes required for a 4-layer hierarchy rooted at the CEO return \\"Invalid\\" # Create adjacency list from the connections graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Find the root (which should connect exactly 3 directors) for node in graph: if len(graph[node]) == 3: root = node break else: return \\"Invalid\\" def bfs_check_levels(root): visited = set() queue = deque([(root, 0)]) levels = defaultdict(int) while queue: current, level = queue.popleft() if current in visited: continue visited.add(current) levels[level] += 1 for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, level + 1)) # Check exact number of nodes at each level return levels[0] == 1 and levels[1] == 3 and levels[2] == 9 and levels[3] == 27 if bfs_check_levels(root): return \\"Valid\\" else: return \\"Invalid\\""},{"question":"def has_pair_with_sum(integers, target): Determines whether there is a pair of integers in the list whose sum equals the target. Parameters: integers (list): List of unique integers. target (int): Target integer. Returns: bool: True if such a pair exists, otherwise False. Examples: >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True >>> has_pair_with_sum([-1, 2, 3, 9], 1) True >>> has_pair_with_sum([100000, 50000, -150000, -100000], -50000) True","solution":"def has_pair_with_sum(integers, target): Determines whether there is a pair of integers in the list whose sum equals the target. Parameters: integers (list): List of unique integers. target (int): Target integer. Returns: bool: True if such a pair exists, otherwise False. seen = set() for num in integers: if target - num in seen: return True seen.add(num) return False"},{"question":"def evaluate_operations(numbers, operator): Evaluate a series of arithmetic operations applied to integers within an array. Args: numbers : list of int : the list of integers operator : str : the operator, one of 'ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE' Returns: int : the result of applying the operator in sequence Examples: >>> evaluate_operations([10, 3, 2], 'ADD') 15 >>> evaluate_operations([10, 3, 2], 'SUBTRACT') 5 >>> evaluate_operations([10, 3, 2], 'MULTIPLY') 60 >>> evaluate_operations([10, 3, 2], 'DIVIDE') 1","solution":"def evaluate_operations(numbers, operator): Evaluate a series of arithmetic operations applied to integers within an array. Args: numbers : list of int : the list of integers operator : str : the operator, one of 'ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE' Returns: int : the result of applying the operator in sequence if not numbers: raise ValueError(\\"The numbers list should not be empty\\") result = numbers[0] for num in numbers[1:]: if operator == 'ADD': result += num elif operator == 'SUBTRACT': result -= num elif operator == 'MULTIPLY': result *= num elif operator == 'DIVIDE': if num == 0: raise ValueError(\\"Division by zero is not allowed\\") result //= num else: raise ValueError(\\"Invalid operator\\") return result"},{"question":"def minimum_cost_to_ensure_connectivity(n: int, m: int, node_types: List[str], edges: List[Tuple[int, int, int]]) -> int: Find and return the minimum cost to ensure connectivity between warehouses and customer locations using Minimum Spanning Tree (MST). This ensures that every customer location is reachable from at least one warehouse and vice versa. >>> minimum_cost_to_ensure_connectivity(6, 7, [\\"W\\", \\"C\\", \\"C\\", \\"W\\", \\"C\\", \\"W\\"], [(1, 2, 10), (2, 3, 15), (3, 4, 10), (4, 5, 15), (3, 5, 10), (5, 6, 5), (1, 6, 20)]) 50 >>> minimum_cost_to_ensure_connectivity(4, 4, [\\"W\\", \\"C\\", \\"C\\", \\"W\\"], [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)]) 30 >>> minimum_cost_to_ensure_connectivity(3, 0, [\\"W\\", \\"C\\", \\"W\\"], []) -1 >>> minimum_cost_to_ensure_connectivity(5, 6, [\\"W\\", \\"C\\", \\"C\\", \\"C\\", \\"W\\"], [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (1, 3, 2), (3, 5, 2)]) 4 >>> minimum_cost_to_ensure_connectivity(5, 4, [\\"W\\", \\"W\\", \\"C\\", \\"C\\", \\"C\\"], [(1, 2, 1), (2, 3, 2), (2, 4, 3), (4, 5, 4)]) 10","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges, warehouses, customers): parent = [] rank = [] mst_cost = 0 mst_edges = 0 for node in range(n): parent.append(node) rank.append(0) edges = sorted(edges, key=lambda item: item[2]) for edge in edges: u, v, w = edge u -= 1 v -= 1 x = find(parent, u) y = find(parent, v) if x != y: mst_cost += w mst_edges += 1 union(parent, rank, x, y) if mst_edges != n - 1: return -1 connected_warehouses = set() connected_customers = set() for node in range(n): root = find(parent, node) if node + 1 in warehouses: connected_warehouses.add(root) if node + 1 in customers: connected_customers.add(root) if connected_warehouses & connected_customers: return mst_cost else: return -1 def minimum_cost_to_ensure_connectivity(n, m, node_types, edges): warehouses = set() customers = set() for i in range(n): if node_types[i] == 'W': warehouses.add(i + 1) elif node_types[i] == 'C': customers.add(i + 1) return kruskal(n, edges, warehouses, customers)"},{"question":"from typing import List, Union def split_into_groups(n: int, max_size: int, friendships: List[List[int]]) -> Union[List[int], int]: Determine the group sizes of employees for a team building activity. Parameters: n (int): The number of employees (2 â‰¤ n â‰¤ 100). max_size (int): The maximum number of employees that any group can have (2 â‰¤ max_size â‰¤ n). friendships (List[List[int]]): A list of pairs, where each pair [u, v] means that employee u and employee v are friends and must be in the same group (0 â‰¤ len(friendships) â‰¤ n * (n - 1) / 2). Returns: Union[List[int], int]: The size of each group or -1 if such a grouping is not possible. Example: >>> split_into_groups(5, 3, [[1, 2], [3, 4], [4, 5]]) [2, 3] >>> split_into_groups(4, 2, [[1, 2], [2, 3], [3, 4]]) -1 from solution import split_into_groups def test_basic_case(): assert split_into_groups(5, 3, [[1, 2], [3, 4], [4, 5]]) == [2, 3] def test_fully_connected_group(): assert split_into_groups(4, 2, [[1, 2], [2, 3], [3, 4]]) == -1 def test_no_friendships(): assert split_into_groups(4, 2, []) == [1, 1, 1, 1] def test_mixed_case(): assert split_into_groups(6, 3, [[1, 2], [3, 4], [4, 5], [5, 6], [1, 6]]) == -1 def test_single_group_fits(): assert split_into_groups(3, 3, [[1, 2], [2, 3]]) == [3] def test_valid_multiple_groups(): assert split_into_groups(6, 3, [[1, 2], [2, 3], [4, 5], [5, 6]]) == [3, 3] def test_edge_case_all_friends(): assert split_into_groups(3, 2, [[1, 2], [2, 3], [1, 3]]) == -1 def test_all_single_groups(): assert split_into_groups(4, 1, []) == [1, 1, 1, 1]","solution":"from typing import List, Union from collections import defaultdict, deque def split_into_groups(n: int, max_size: int, friendships: List[List[int]]) -> Union[List[int], int]: def bfs(start): queue = deque([start]) component = [] visited.add(start) while queue: node = queue.popleft() component.append(node) for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return component graph = defaultdict(list) for u, v in friendships: graph[u].append(v) graph[v].append(u) visited = set() components = [] for employee in range(1, n + 1): if employee not in visited: component = bfs(employee) components.append(component) group_sizes = [len(component) for component in components] if any(size > max_size for size in group_sizes): return -1 return group_sizes"},{"question":"from typing import List, Tuple def bfs_traversal(n: int, m: int, edges: List[Tuple[int, int]], start: int) -> List[int]: Perform BFS traversal on a directed graph and return the order of nodes visited. :param n: Number of web pages (nodes) :param m: Number of links (edges) :param edges: List of tuples representing edges (u, v) :param start: Starting web page for BFS :return: List of nodes in the order they are visited using BFS >>> bfs_traversal(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)], 1) [1, 2, 3, 4, 5] >>> bfs_traversal(6, 5, [(1, 2), (1, 3), (2, 4), (5, 6), (6, 1)], 5) [5, 6, 1, 2, 3, 4] >>> bfs_traversal(1, 0, [], 1) [1] >>> bfs_traversal(4, 2, [(1, 2), (3, 4)], 1) [1, 2] >>> bfs_traversal(6, 7, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (5, 6), (3, 5)], 1) [1, 2, 3, 4, 5, 6] >>> bfs_traversal(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1) [1, 2, 3, 4]","solution":"from collections import deque, defaultdict def bfs_traversal(n, m, edges, start): Perform BFS traversal on a directed graph and return the order of nodes visited. :param n: Number of web pages (nodes) :param m: Number of links (edges) :param edges: List of tuples representing edges (u, v) :param start: Starting web page for BFS :return: List of nodes in the order they are visited using BFS graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = set() queue = deque([start]) visited_order = [] while queue: current = queue.popleft() if current not in visited: visited.add(current) visited_order.append(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return visited_order"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagTraversal(root): Given a binary tree, perform a zigzag (or spiral) traversal. The traversal alternates the direction at each level, starting from left to right at the root. Args: root (TreeNode): The root node of the binary tree. Returns: List[int]: The list of values representing the zigzag order traversal of the tree. Examples: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> zigzagTraversal(root) [3, 20, 9, 15, 7] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> zigzagTraversal(root) [1, 3, 2] def test_zigzag_single_node(): root = TreeNode(1) assert zigzagTraversal(root) == [1] def test_zigzag_empty_tree(): assert zigzagTraversal(None) == [] def test_zigzag_two_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert zigzagTraversal(root) == [1, 3, 2] def test_zigzag_three_levels(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert zigzagTraversal(root) == [1, 3, 2, 4, 5, 6, 7] def test_zigzag_uneven_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.right = TreeNode(5) root.left.left.left = TreeNode(6) assert zigzagTraversal(root) == [1, 3, 2, 4, 5, 6] def test_zigzag_complex_tree(): root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert zigzagTraversal(root) == [3, 20, 9, 15, 7]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagTraversal(root): if not root: return [] result = [] current_level = deque([root]) left_to_right = True while current_level: level_size = len(current_level) level_values = deque() for _ in range(level_size): node = current_level.popleft() if left_to_right: level_values.append(node.val) else: level_values.appendleft(node.val) if node.left: current_level.append(node.left) if node.right: current_level.append(node.right) result.extend(level_values) left_to_right = not left_to_right return list(result)"},{"question":"class TreeNode: def __init__(self, key=0, left=None, right=None): self.key = key self.left = left self.right = right def build_tree(inorder, postorder): Build the binary tree from in-order and post-order traversals. pass def preorder_traversal(root): Perform pre-order traversal of the binary tree. pass def reconstruct_and_traverse(n, inorder, postorder): Given the number of nodes and their in-order and post-order traversals, reconstruct the binary tree and return its pre-order traversal. Args: n (int): Number of nodes inorder (List[int]): In-order traversal of the binary tree postorder (List[int]): Post-order traversal of the binary tree Returns: List[int]: Pre-order traversal of the reconstructed binary tree Examples: >>> reconstruct_and_traverse(5, [4, 2, 5, 1, 3], [4, 5, 2, 3, 1]) [1, 2, 4, 5, 3] >>> reconstruct_and_traverse(1, [1], [1]) [1] pass # Tests def test_preorder_traversal(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) assert preorder_traversal(root) == [1, 2, 4, 5, 3] def test_reconstruct_and_traverse_example(): n = 5 inorder = [4, 2, 5, 1, 3] postorder = [4, 5, 2, 3, 1] assert reconstruct_and_traverse(n, inorder, postorder) == [1, 2, 4, 5, 3] def test_reconstruct_and_traverse_single_node(): n = 1 inorder = [1] postorder = [1] assert reconstruct_and_traverse(n, inorder, postorder) == [1] def test_reconstruct_and_traverse_two_nodes(): n = 2 inorder = [2, 1] postorder = [2, 1] assert reconstruct_and_traverse(n, inorder, postorder) == [1, 2] def test_reconstruct_and_traverse_multiple_nodes(): n = 7 inorder = [4, 2, 5, 1, 6, 3, 7] postorder = [4, 5, 2, 6, 7, 3, 1] assert reconstruct_and_traverse(n, inorder, postorder) == [1, 2, 4, 5, 3, 6, 7]","solution":"class TreeNode: def __init__(self, key=0, left=None, right=None): self.key = key self.left = left self.right = right def build_tree(inorder, postorder): if not inorder or not postorder: return None root_val = postorder.pop() root = TreeNode(root_val) inorder_index = inorder.index(root_val) root.right = build_tree(inorder[inorder_index + 1:], postorder) root.left = build_tree(inorder[:inorder_index], postorder) return root def preorder_traversal(root): if root is None: return [] return [root.key] + preorder_traversal(root.left) + preorder_traversal(root.right) # Main function that processes the input and produces the output def reconstruct_and_traverse(n, inorder, postorder): root = build_tree(inorder, postorder) return preorder_traversal(root)"},{"question":"def maxScore(problems, limit): Determine the maximum score that can be achieved by solving problems within a given time limit. :param problems: List of tuples where each tuple contains (score, time required). :param limit: Maximum total time available. :return: Maximum score achievable within the given time limit. >>> maxScore([(10, 2), (20, 2), (30, 3), (40, 4)], 5) 50 >>> maxScore([(15, 5), (10, 1), (20, 2)], 3) 30","solution":"def maxScore(problems, limit): Determine the maximum score that can be achieved by solving problems within a given time limit. :param problems: List of tuples where each tuple contains (score, time required). :param limit: Maximum total time available. :return: Maximum score achievable within the given time limit. n = len(problems) dp = [0] * (limit + 1) for score, time in problems: for t in range(limit, time - 1, -1): dp[t] = max(dp[t], dp[t - time] + score) return dp[limit]"},{"question":"def is_circular(s: str) -> bool: Returns True if the sequence of moves is circular, otherwise returns False. >>> is_circular(\\"UDLR\\") True >>> is_circular(\\"UUDDLLRR\\") True >>> is_circular(\\"UDL\\") False >>> is_circular(\\"\\") False >>> is_circular(\\"UDLRX\\") False >>> is_circular(\\"ABC\\") False >>> is_circular(\\"U\\") False >>> is_circular(\\"D\\") False >>> is_circular(\\"L\\") False >>> is_circular(\\"R\\") False >>> is_circular(\\"UDUDUDUD\\") True >>> is_circular(\\"LLLLRRRR\\") True","solution":"def is_circular(s): Returns True if the sequence of moves is circular, otherwise returns False. if not s: return False if any(c not in 'UDLR' for c in s): return False x, y = 0, 0 for move in s: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def min_moves_to_reach_end(grid): Determine if there exists a path for the robot to reach the bottom-right corner from the top-left corner. Args: grid (List[List[int]]): The grid represented as a list of lists where 1 is blocked and 0 is open. Returns: int: Minimum number of moves to reach the destination, or -1 if no path exists. Examples: >>> min_moves_to_reach_end([[0, 0, 1], [1, 0, 1], [1, 0, 0]]) 4 >>> min_moves_to_reach_end([[0, 1, 1], [1, 1, 0], [1, 0, 0]]) -1","solution":"from collections import deque def min_moves_to_reach_end(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 # Initialize directions for right and down movement directions = [(0, 1), (1, 0)] # Initialize the queue for BFS queue = deque([(0, 0, 0)]) # (row, col, moves) visited = set((0, 0)) while queue: x, y, moves = queue.popleft() # Check if we've reached the bottom-right corner if x == n-1 and y == m-1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"def canRearrange(N, X, A): Determines if it's possible to rearrange the elements of array A such that the cumulative sum never exceeds X at any point during the summation process. Args: N : int : Number of elements in the array X : int : Threshold value for cumulative sum A : list of int : List of N integers Returns: bool : True if possible to rearrange as required, False otherwise Examples: >>> canRearrange(5, 10, [3, 1, 4, 2, 5]) True >>> canRearrange(4, 5, [3, 6, 2, 1]) False >>> canRearrange(3, 4, [1, 2, 1]) True >>> canRearrange(6, 21, [1, 2, 3, 4, 5, 6]) True >>> canRearrange(6, 20, [1, 2, 3, 4, 5, 6]) False","solution":"def canRearrange(N, X, A): Determines if it's possible to rearrange the elements of array A such that the cumulative sum never exceeds X at any point during the summation process. Args: N : int : Number of elements in the array X : int : Threshold value for cumulative sum A : list of int : List of N integers Returns: bool : True if possible to rearrange as required, False otherwise A.sort() cum_sum = 0 for num in A: cum_sum += num if cum_sum > X: return False return True"},{"question":"def max_beauty(n: int, ids: List[int], beauties: List[int]) -> int: Determine the maximum total beauty value Sandra can obtain without picking two stones with consecutive identifiers. >>> max_beauty(5, [1, 2, 5, 8, 9], [4, 3, 6, 10, -1]) 20 >>> max_beauty(3, [2, 3, 4], [-1, 2, 3]) 3","solution":"def max_beauty(n, ids, beauties): if n == 0: return 0 # Sort stones by their ids stones = sorted(zip(ids, beauties)) # dp[i] will be the maximum beauty value we can collect from first i stones dp = [0] * n dp[0] = max(0, stones[0][1]) # We can either take the first stone or not for i in range(1, n): # beauty if we don't take this stone dont_take = dp[i-1] # beauty if we take this stone, ensure we skip the previous stone with a consecutive id take = stones[i][1] for j in range(i-1, -1, -1): if stones[i][0] - stones[j][0] > 1: take += dp[j] break dp[i] = max(dont_take, take) return dp[n-1]"},{"question":"def product_of_all_except_current(nums): Returns a list where each element is the product of all integers in the input list except for the one at the current index. >>> product_of_all_except_current([1]) [] >>> product_of_all_except_current([1, 2]) [2, 1] >>> product_of_all_except_current([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_all_except_current([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_of_all_except_current([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_of_all_except_current([0, 2, 3, 4]) [24, 0, 0, 0] >>> product_of_all_except_current([0, 0, 0]) [0, 0, 0] >>> product_of_all_except_current([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_of_all_except_current(nums): Returns a list where each element is the product of all integers in the input list except for the one at the current index. if len(nums) <= 1: return [] length = len(nums) left_products = [1] * length right_products = [1] * length # Create left products excluding current index for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Create right products excluding current index for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Create result by multiplying left and right products result = [left_products[i] * right_products[i] for i in range(length)] return result"},{"question":"def tablet_energy_value(n, matrix, operation): Find the energy value of a tablet by combining stones using a specific operation. >>> tablet_energy_value(3, [ ... [4, 2, 9], ... [1, 6, 3], ... [5, 0, 7] ... ], \\"+\\") 37 >>> tablet_energy_value(2, [ ... [1, 2], ... [3, 4] ... ], \\"*\\") 24 >>> tablet_energy_value(2, [ ... [1, 2], ... [3, 4] ... ], \\"max\\") 4 >>> tablet_energy_value(3, [ ... [4, 2, 9], ... [1, 6, 3], ... [5, 0, 7] ... ], \\"min\\") 0","solution":"def tablet_energy_value(n, matrix, operation): from functools import reduce def apply_operation(x, y, op): if op == \\"+\\": return x + y elif op == \\"*\\": return x * y elif op == \\"max\\": return max(x, y) elif op == \\"min\\": return min(x, y) # Flatten the matrix into a list of values values = [matrix[i][j] for i in range(n) for j in range(n)] # Reduce all values into a single value by applying the operation energy_value = reduce(lambda x, y: apply_operation(x, y, operation), values) return energy_value"},{"question":"def right_angled_triangle(height: int) -> str: Generates a right-angled triangle pattern of given height using '#' character. Parameters: height (int): The height of the triangle Returns: str: A string representing the right-angled triangle pattern Examples: >>> print(right_angled_triangle(3)) # # >>> print(right_angled_triangle(5)) # # #","solution":"def right_angled_triangle(height): Generates a right-angled triangle pattern of given height using '#' character. Parameters: height (int): The height of the triangle Returns: str: A string representing the right-angled triangle pattern triangle = '' for i in range(1, height + 1): triangle += '#' * i + 'n' return triangle.strip()"},{"question":"import math from typing import List def find_largest_divisor(sequences: List[List[int]]) -> List[int]: For each sequence, find the largest divisor d such that all numbers in the sequence are divisible by d. results = [] for sequence in sequences: gcd_value = sequence[0] for num in sequence[1:]: gcd_value = math.gcd(gcd_value, num) if gcd_value == 1: # Ensure early termination if gcd becomes 1 break results.append(gcd_value) return results def process_input(input_data: str) -> List[int]: Process the input data, extract the number of test cases and sequences, and return the results from find_largest_divisor function. input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 sequences = [] for _ in range(T): n = int(input_lines[index]) sequence = list(map(int, input_lines[index + 1].split())) sequences.append(sequence) index += 2 return find_largest_divisor(sequences) # Test cases: def test_find_largest_divisor(): input_data = 3 3 2 4 6 4 5 10 15 20 5 6 9 12 15 18 expected_output = [2, 5, 3] assert process_input(input_data) == expected_output def test_find_largest_divisor_single_element(): input_data = 2 1 7 1 13 expected_output = [7, 13] assert process_input(input_data) == expected_output def test_find_largest_divisor_all_same(): input_data = 2 3 10 10 10 3 1 1 1 expected_output = [10, 1] assert process_input(input_data) == expected_output def test_find_largest_divisor_large(): input_data = 1 3 1000000000 500000000 250000000 expected_output = [250000000] assert process_input(input_data) == expected_output def test_find_largest_divisor_smallest_range(): input_data = 1 5 5 6 7 8 9 expected_output = [1] assert process_input(input_data) == expected_output","solution":"import math def find_largest_divisor(sequences): For each sequence, find the largest divisor d such that all numbers in the sequence are divisible by d. results = [] for sequence in sequences: gcd_value = sequence[0] for num in sequence[1:]: gcd_value = math.gcd(gcd_value, num) if gcd_value == 1: # Early termination if gcd becomes 1 break results.append(gcd_value) return results def process_input(input_data): Process the input data, extract the number of test cases and sequences, and return the results from find_largest_divisor function. input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 sequences = [] for _ in range(T): n = int(input_lines[index]) sequence = list(map(int, input_lines[index + 1].split())) sequences.append(sequence) index += 2 return find_largest_divisor(sequences)"},{"question":"from typing import List, Tuple def calculate_average_scores(scores: List[int], queries: List[Tuple[int, int]]) -> List[float]: Calculate the average scores for given subarrays defined by queries. :param scores: List of integers representing student scores. :param queries: List of tuples, where each tuple contains two integers (l, r) representing the range of student ids. :return: List of average scores for each query, rounded to two decimal places. >>> calculate_average_scores([50, 90, 80, 60, 70], [(1, 3), (2, 5), (1, 5)]) [73.33, 75.00, 70.00] >>> calculate_average_scores([100, 90, 80, 70, 60, 50], [(1, 6), (1, 3), (4, 6)]) [75.00, 90.00, 60.00] >>> calculate_average_scores([70, 80, 90, 100], [(1, 2), (3, 4), (1, 4)]) [75.00, 95.00, 85.00] >>> calculate_average_scores([25, 45, 65, 85, 95], [(1, 1), (3, 3), (5, 5)]) [25.00, 65.00, 95.00]","solution":"def calculate_average_scores(scores, queries): Calculate the average scores for given subarrays defined by queries. :param scores: List of integers representing student scores :param queries: List of tuples, where each tuple contains two integers (l, r) representing the range of student ids :return: List of average scores for each query, rounded to two decimal places averages = [] for l, r in queries: # As the problem states to use ids 1-indexed, we convert l and r to 0-indexed for python list slicing subarray = scores[l-1:r] average = sum(subarray) / len(subarray) averages.append(round(average, 2)) return averages"},{"question":"def pickingNumbers(A: List[int]) -> int: Determines the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1. >>> pickingNumbers([4, 6, 5, 3, 3, 1]) == 3 >>> pickingNumbers([1, 1, 1, 1, 1]) == 5 >>> pickingNumbers([1, 2, 2, 3, 1]) == 4 >>> pickingNumbers([1, 1, 2, 2, 4, 4, 5, 5, 5]) == 5 >>> pickingNumbers([5, 6, 6, 7, 8, 8, 9, 10, 11]) == 3 >>> pickingNumbers([1, 3, 5, 7, 9]) == 1 >>> pickingNumbers([2, 2]) == 2","solution":"def pickingNumbers(A): Determines the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1. Args: A (list of int): The input array of integers. Returns: int: The length of the longest qualifying subarray. # Frequency dictionary to store the count of each number frequency = [0] * 101 # Populate the frequency dictionary for number in A: frequency[number] += 1 max_length = 0 # Check the count of each number and its adjacent number (number+1) for i in range(1, 101): current_length = frequency[i] + frequency[i - 1] if current_length > max_length: max_length = current_length return max_length"},{"question":"def min_operations_to_non_decreasing(arr): Given an array of integers, this function determines the minimum number of operations required to make the array non-decreasing. In each operation, you can pick any subarray of the array and multiply each element in that subarray by -1. >>> min_operations_to_non_decreasing([3, -1, 4, 2, -5]) 2 >>> min_operations_to_non_decreasing([1, 2, 3, 4]) 0 >>> min_operations_to_non_decreasing([5]) 0 >>> min_operations_to_non_decreasing([-5, -4, -3, -2, -1]) 0 >>> min_operations_to_non_decreasing([1, -1, 1, -1, 1]) 2 >>> min_operations_to_non_decreasing([5, 4, 3, 2, 1]) 1 >>> min_operations_to_non_decreasing([10, -5, 3, -2, 0, -1, -3, 5, 7, -9, 10]) 4","solution":"def min_operations_to_non_decreasing(arr): Given an array of integers, this function determines the minimum number of operations required to make the array non-decreasing. In each operation, you can pick any subarray of the array and multiply each element in that subarray by -1. # Length of the array n = len(arr) # Edge case, if array length is 1, it's already non-decreasing if n == 1: return 0 operations = 0 i = 0 while i < n - 1: # If the current element is greater than the next one if arr[i] > arr[i + 1]: operations += 1 # Move the index to the point where the next sequence is becoming non-decreasing while i < n - 1 and arr[i] > arr[i + 1]: i += 1 i += 1 return operations"},{"question":"def days_to_finish_book(n: int) -> int: Calculate the number of days it takes Ami to finish a book of n pages. >>> days_to_finish_book(10) 4 >>> days_to_finish_book(15) 5 >>> days_to_finish_book(21) 6 pass def process_test_cases(test_cases: List[int]) -> List[int]: Process multiple test cases and return the results. >>> process_test_cases([10, 15, 21]) [4, 5, 6] >>> process_test_cases([1, 2, 3]) [1, 2, 2] pass","solution":"def days_to_finish_book(n): This function returns the number of days required for Ami to finish a book with n pages. day = 0 total_pages_read = 0 while total_pages_read < n: day += 1 total_pages_read += day return day def process_test_cases(test_cases): results = [] for n in test_cases: results.append(days_to_finish_book(n)) return results"},{"question":"def directory_tree_navigator(n: int, structure: List[str], m: int, commands: List[str]) -> List[List[str]]: Navigates a simplified directory tree and handles commands. The directory tree expands from a root directory and can have nested subdirectories and files. The program will receive commands to either navigate through the directory tree or to list files and directories at a specific level. Handles commands: - \`cd <directory_name>\`: Navigate into the given directory. - \`cd ..\`: Navigate to the parent directory. - \`ls\`: List all items in the current directory. Args: - n (int): Number of directories and files. - structure (List[str]): Paths to directories or files. - m (int): Number of commands. - commands (List[str]): List of commands. Returns: - List[List[str]]: List of results for each \`ls\` command, with items in lexicographical order. Example: >>> directory_tree_navigator( 10, [\\"root/dir1\\", \\"root/dir1/file1\\", \\"root/dir1/file2\\", \\"root/dir2\\", \\"root/dir2/file3\\", \\"root/dir2/file4\\", \\"root/dir2/subdir1\\", \\"root/dir2/subdir1/file5\\", \\"root/file6\\", \\"root/file7\\"], 8, [\\"ls\\", \\"cd dir1\\", \\"ls\\", \\"cd ..\\", \\"cd dir2\\", \\"ls\\", \\"cd subdir1\\", \\"ls\\"] ) [ ['dir1', 'dir2', 'file6', 'file7'], ['file1', 'file2'], ['file3', 'file4', 'subdir1'], ['file5'] ]","solution":"class DirectoryNavigator: def __init__(self, structure): self.structure = structure self.current_path = ['root'] self.build_tree() def build_tree(self): self.tree = {'root': {}} for path in self.structure: parts = path.split('/') current = self.tree['root'] for part in parts[1:]: # Skip \\"root\\" if part not in current: current[part] = {} current = current[part] def navigate(self, command): if command == 'cd ..': if len(self.current_path) > 1: self.current_path.pop() elif command.startswith('cd '): directory = command.split(' ')[1] current = self.get_current_directory() if directory in current: self.current_path.append(directory) elif command == 'ls': return sorted(self.get_current_directory().keys()) def get_current_directory(self): current = self.tree['root'] for part in self.current_path[1:]: current = current[part] return current def directory_tree_navigator(n, structure, m, commands): navigator = DirectoryNavigator(structure) results = [] for command in commands: result = navigator.navigate(command) if result is not None: results.append(result) return results # Example usage if __name__ == \\"__main__\\": n = 10 structure = [ \\"root/dir1\\", \\"root/dir1/file1\\", \\"root/dir1/file2\\", \\"root/dir2\\", \\"root/dir2/file3\\", \\"root/dir2/file4\\", \\"root/dir2/subdir1\\", \\"root/dir2/subdir1/file5\\", \\"root/file6\\", \\"root/file7\\" ] m = 8 commands = [ \\"ls\\", \\"cd dir1\\", \\"ls\\", \\"cd ..\\", \\"cd dir2\\", \\"ls\\", \\"cd subdir1\\", \\"ls\\" ] results = directory_tree_navigator(n, structure, m, commands) for result in results: for item in result: print(item) print()"},{"question":"def generate_passcodes(K: int, N: int, increments: List[int]) -> List[List[int]]: Generates passcodes for K doors each of length N based on the given increments. Parameters: K (int): Number of doors. N (int): Length of the passcode. increments (List[int]): A list of N-1 integers representing the dynamic increments. Returns: List[List[int]]: A list of K passcodes, each of length N. >>> generate_passcodes(4, 5, [1, 1, -1, 2]) [[1, 2, 3, 2, 4], [2, 3, 4, 3, 5], [3, 4, 5, 4, 6], [4, 5, 6, 5, 7]] >>> generate_passcodes(3, 4, [2, -2, 1]) [[1, 3, 1, 2], [2, 4, 2, 3], [3, 5, 3, 4]] from solution import generate_passcodes def test_generate_passcodes_sample1(): assert generate_passcodes(4, 5, [1, 1, -1, 2]) == [ [1, 2, 3, 2, 4], [2, 3, 4, 3, 5], [3, 4, 5, 4, 6], [4, 5, 6, 5, 7] ] def test_generate_passcodes_sample2(): assert generate_passcodes(3, 4, [2, -2, 1]) == [ [1, 3, 1, 2], [2, 4, 2, 3], [3, 5, 3, 4] ] def test_generate_passcodes_single_door(): assert generate_passcodes(1, 3, [1, 1]) == [ [1, 2, 3] ] def test_generate_passcodes_min_length_passcode(): assert generate_passcodes(2, 1, []) == [ [1], [2] ] def test_generate_passcodes_max_values(): assert generate_passcodes(9, 9, [9, 9, 9, 9, 9, 9, 9, 9]) == [ [1, 10, 19, 28, 37, 46, 55, 64, 73], [2, 11, 20, 29, 38, 47, 56, 65, 74], [3, 12, 21, 30, 39, 48, 57, 66, 75], [4, 13, 22, 31, 40, 49, 58, 67, 76], [5, 14, 23, 32, 41, 50, 59, 68, 77], [6, 15, 24, 33, 42, 51, 60, 69, 78], [7, 16, 25, 34, 43, 52, 61, 70, 79], [8, 17, 26, 35, 44, 53, 62, 71, 80], [9, 18, 27, 36, 45, 54, 63, 72, 81] ] def test_generate_passcodes_minimum_increment(): assert generate_passcodes(3, 4, [-9, -9, -9]) == [ [1, -8, -17, -26], [2, -7, -16, -25], [3, -6, -15, -24] ]","solution":"def generate_passcodes(K, N, increments): Generates passcodes for K doors each of length N based on the given increments. Parameters: K (int): Number of doors. N (int): Length of the passcode. increments (List[int]): A list of N-1 integers representing the dynamic increments. Returns: List[List[int]]: A list of K passcodes, each of length N. passcodes = [] for i in range(1, K+1): passcode = [i] for j in range(1, N): next_digit = passcode[j-1] + increments[j-1] passcode.append(next_digit) passcodes.append(passcode) return passcodes"},{"question":"def rearrange_string(S: str) -> str: Given a string S, determine whether it is possible to rearrange the string so that no two adjacent characters are the same. If possible, output any valid rearrangement, otherwise output \\"NO\\". >>> rearrange_string(\\"aabb\\") == \\"abab\\" >>> rearrange_string(\\"aaab\\") == \\"NO\\"","solution":"from collections import Counter import heapq def rearrange_string(S): Rearranges the string S such that no two adjacent characters are the same. If not possible, returns \\"NO\\". # Count frequency of each character freq_count = Counter(S) max_heap = [(-count, char) for char, count in freq_count.items()] # Convert to a max heap based on character frequency heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append the current character to the result result.append(char) # Since we are using a max heap, we actually decrement the count count += 1 # If there was a previously used character, push it back into the heap if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update prev_char and prev_count prev_char = char prev_count = count rearranged_string = ''.join(result) if len(rearranged_string) == len(S): return rearranged_string else: return \\"NO\\""},{"question":"def fibonacci_prime_replace(n: int) -> int: Returns the nth number in the Fibonacci sequence, but with prime numbers replaced by -1. >>> fibonacci_prime_replace(0) == 0 >>> fibonacci_prime_replace(1) == 1 >>> fibonacci_prime_replace(2) == 1 >>> fibonacci_prime_replace(3) == -1 >>> fibonacci_prime_replace(4) == -1 >>> fibonacci_prime_replace(5) == -1 >>> fibonacci_prime_replace(7) == -1 >>> fibonacci_prime_replace(6) == 8 >>> fibonacci_prime_replace(10) == 55 >>> fibonacci_prime_replace(11) == -1 >>> fibonacci_prime_replace(12) == 144 >>> fibonacci_prime_replace(-1) is None","solution":"def fibonacci_prime_replace(n: int) -> int: Returns the nth number in the Fibonacci sequence, but with prime numbers replaced by -1. def is_prime(num: int) -> bool: if num <= 1: return False for i in range(2, int(num**0.5) + 1): if num % i == 0: return False return True if n < 0: return None # Fibonacci sequence is not defined for negative index if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return -1 if is_prime(b) else b"},{"question":"def min_moves(R, C, grid, start, target): Calculate the minimum number of moves for Robo to reach the target cell in a grid. Args: R (int): Number of rows in the grid. C (int): Number of columns in the grid. grid (List[str]): A list of strings representing the factory floor with '0' for empty cells and '1' for obstacles. start (Tuple[int, int]): The starting cell (row, col) coordinates. target (Tuple[int, int]): The target cell (row, col) coordinates. Returns: int: The minimum number of moves to reach the target cell, or -1 if it is not possible. >>> min_moves(5, 5, ['00000', '01110', '01110', '01110', '00000'], (0, 0), (4, 4)) 8 >>> min_moves(3, 3, ['000', '010', '000'], (0, 0), (2, 2)) 4 >>> min_moves(3, 3, ['000', '111', '000'], (0, 0), (2, 2)) -1 >>> min_moves(1, 1, ['0'], (0, 0), (0, 0)) 0 >>> min_moves(3, 3, ['000', '000', '000'], (0, 0), (2, 2)) 4","solution":"from collections import deque def min_moves(R, C, grid, start, target): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = [[False] * C for _ in range(R)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited[start[0]][start[1]] = True while queue: r, c, dist = queue.popleft() if (r, c) == (target[0], target[1]): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < R and 0 <= nc < C and not visited[nr][nc] and grid[nr][nc] == '0': visited[nr][nc] = True queue.append((nr, nc, dist + 1)) return -1 # If no path is found def process_input(input_lines): results = [] idx = 0 while idx < len(input_lines): R, C = map(int, input_lines[idx].split()) if R == 0 and C == 0: break grid = [] for i in range(R): grid.append(input_lines[idx + 1 + i]) rS, cS, rT, cT = map(int, input_lines[idx + 1 + R].split()) start = (rS, cS) target = (rT, cT) results.append(min_moves(R, C, grid, start, target)) idx += R + 2 return results def main(): import sys input_lines = sys.stdin.read().strip().split('n') results = process_input(input_lines) for result in results: print(result)"},{"question":"def is_valid_parentheses(s: str) -> bool: Checks if the parentheses in the sequence are valid (i.e., balanced and properly nested). Args: s (str): A string representing the sequence of parentheses. Returns: bool: True if the sequence is valid, otherwise False. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"(())\\") True >>> is_valid_parentheses(\\"()()\\") True >>> is_valid_parentheses(\\"((()))\\") True >>> is_valid_parentheses(\\"(\\") False >>> is_valid_parentheses(\\")\\") False >>> is_valid_parentheses(\\"(()\\") False >>> is_valid_parentheses(\\"())\\") False >>> is_valid_parentheses(\\"(()))\\") False >>> is_valid_parentheses(\\"()(()())\\") True >>> is_valid_parentheses(\\"()()((()))\\") True >>> is_valid_parentheses(\\"(()))(()\\") False >>> is_valid_parentheses(\\"(()(())())\\") True >>> is_valid_parentheses(\\"\\") True >>> is_valid_parentheses(\\"(((((((((())))))))))\\") True >>> is_valid_parentheses(\\"((((())\\") False","solution":"def is_valid_parentheses(s): Checks if the parentheses in the sequence are valid (i.e., balanced and properly nested). Args: s (str): A string representing the sequence of parentheses. Returns: bool: True if the sequence is valid, otherwise False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack"},{"question":"def can_sort_blocks(S: str) -> str: Determines if it is possible to sort the blocks such that no two adjacent blocks are of the same color. :param S: A string of lowercase letters representing block colors. :return: 'YES' if it is possible to sort the blocks as required, 'NO' otherwise. >>> can_sort_blocks(\\"abac\\") 'YES' >>> can_sort_blocks(\\"aaaa\\") 'NO'","solution":"def can_sort_blocks(S): Determines if it is possible to sort the blocks such that no two adjacent blocks are of the same color. :param S: A string of lowercase letters representing block colors. :return: 'YES' if it is possible to sort the blocks as required, 'NO' otherwise. from collections import Counter # Count the frequency of each block counter = Counter(S) # Get the most common block and its frequency most_common_block, most_common_count = counter.most_common(1)[0] # The condition to be able to sort such that no two adjacent blocks are the same if most_common_count <= (len(S) + 1) // 2: return \\"YES\\" else: return \\"NO\\""},{"question":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = max(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, left, right): left += self.n right += self.n + 1 result = -float('inf') while left < right: if left % 2 == 1: result = max(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = max(result, self.tree[right]) left //= 2 right //= 2 return result def bakery_system(N, Q, initial_ranks, queries): Handle the bakery operations: updating rankings and querying the most popular rank. Args: N (int): Number of types of baked goods. Q (int): Number of queries. initial_ranks (List[int]): Initial popularity ranks of the baked goods. queries (List[List[int]]): List of queries to be processed. Returns: List[int]: Results of the rank queries. >>> bakery_system(5, 3, [2, 9, 4, 1, 7], [[2, 1, 5], [1, 3, 10], [2, 2, 4]]) [9, 10] >>> bakery_system(3, 5, [3, 6, 2], [[1, 1, 5], [2, 1, 3], [1, 2, 8], [2, 1, 2], [2, 1, 3]]) [6, 8, 8] def test_sample_case(): N = 5 Q = 3 initial_ranks = [2, 9, 4, 1, 7] queries = [ [2, 1, 5], [1, 3, 10], [2, 2, 4] ] assert bakery_system(N, Q, initial_ranks, queries) == [9, 10] def test_all_updates(): N = 3 Q = 5 initial_ranks = [3, 6, 2] queries = [ [1, 1, 5], [2, 1, 3], [1, 2, 8], [2, 1, 2], [2, 1, 3] ] assert bakery_system(N, Q, initial_ranks, queries) == [6, 8, 8] def test_no_operations(): N = 1 Q = 0 initial_ranks = [5] queries = [] assert bakery_system(N, Q, initial_ranks, queries) == [] def test_edge_case_large_values(): N = 3 Q = 2 initial_ranks = [10**9, 10**9 - 1, 10**9 - 2] queries = [ [2, 1, 3], [1, 3, 10**9 - 3] ] assert bakery_system(N, Q, initial_ranks, queries) == [10**9] def test_multiple_queries(): N = 6 Q = 4 initial_ranks = [2, 5, 3, 8, 6, 4] queries = [ [2, 1, 6], [1, 5, 9], [2, 4, 6], [2, 1, 4] ] assert bakery_system(N, Q, initial_ranks, queries) == [8, 9, 8]","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (2 * self.n) self.build(arr) def build(self, arr): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = arr[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index, value): index += self.n self.tree[index] = value while index > 1: index //= 2 self.tree[index] = max(self.tree[2 * index], self.tree[2 * index + 1]) def query(self, left, right): left += self.n right += self.n + 1 result = -float('inf') while left < right: if left % 2 == 1: result = max(result, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 result = max(result, self.tree[right]) left //= 2 right //= 2 return result def bakery_system(N, Q, initial_ranks, queries): results = [] segment_tree = SegmentTree(initial_ranks) for query in queries: if query[0] == 1: _, X, Y = query segment_tree.update(X - 1, Y) elif query[0] == 2: _, L, R = query result = segment_tree.query(L - 1, R - 1) results.append(result) return results"},{"question":"def most_frequent_character(S: str, queries: List[Tuple[int, int]]) -> List[str]: Returns a list of most frequent characters for each query range [L, R]. If there is a tie, returns the lexicographically smallest character. S: str, the given string queries: list of tuples, each tuple containing two integers L and R >>> most_frequent_character(\\"abacaba\\", [(1, 3), (0, 6), (2, 5)]) [\\"a\\", \\"a\\", \\"a\\"] >>> most_frequent_character(\\"a\\", [(0, 0)]) [\\"a\\"] >>> most_frequent_character(\\"aabb\\", [(0, 3)]) [\\"a\\"] >>> most_frequent_character(\\"abcdef\\", [(1, 1), (0, 5)]) [\\"b\\", \\"a\\"] >>> most_frequent_character(\\"ab\\", [(0, 0), (1, 1), (0, 1)]) [\\"a\\", \\"b\\", \\"a\\"]","solution":"def most_frequent_character(S, queries): Returns a list of most frequent characters for each query range [L, R]. If there is a tie, returns the lexicographically smallest character. S: str, the given string queries: list of tuples, each tuple containing two integers L and R results = [] for L, R in queries: substring = S[L:R+1] freq_map = {} for char in substring: if char in freq_map: freq_map[char] += 1 else: freq_map[char] = 1 max_freq = max(freq_map.values()) most_freq_chars = [char for char, freq in freq_map.items() if freq == max_freq] results.append(min(most_freq_chars)) return results"},{"question":"def main(input_data: str) -> str: You are given a matrix with N rows and M columns, where each cell contains a non-negative integer. You are allowed to select a single cell in each of the N rows such that the sum of the selected values is maximized, but no two selected cells can be in the same column. Find the maximum sum you can obtain following these constraints. >>> main(\\"1n2 2n1 2n3 4\\") '6' >>> main(\\"1n3 3n1 8 3n7 6 9n4 2 5\\") '22' >>> main(\\"2n2 2n1 2n3 4n3 3n1 8 3n7 6 9n4 2 5\\") '6n22' >>> main(\\"1n1 1n0\\") '0' >>> main(\\"1n2 2n1000000000 999999999n999999999 1000000000\\") '2000000000' def max_sum(test_cases): results = [] for case in test_cases: N, M, matrix = case max_values = [] for r in range(N): max_values.append(max(matrix[r])) results.append(sum(max_values)) return results def parse_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, input_lines[index].split()) matrix = [] for i in range(N): matrix.append(list(map(int, input_lines[index + i + 1].split()))) test_cases.append((N, M, matrix)) index += N + 1 return test_cases def format_output(results): return \\"n\\".join(map(str, results)) test_cases = parse_input(input_data) results = max_sum(test_cases) return format_output(results)","solution":"def max_sum(test_cases): results = [] for case in test_cases: N, M, matrix = case max_values = [] for r in range(N): max_values.append(max(matrix[r])) results.append(sum(max_values)) return results def parse_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, input_lines[index].split()) matrix = [] for i in range(N): matrix.append(list(map(int, input_lines[index + i + 1].split()))) test_cases.append((N, M, matrix)) index += N + 1 return test_cases def format_output(results): return \\"n\\".join(map(str, results)) def main(input_data): test_cases = parse_input(input_data) results = max_sum(test_cases) return format_output(results)"},{"question":"def product_of_two_largest(input_string: str) -> str: Returns a string with the product of the two largest integers on each line of the input string. Each product is on a new line. >>> product_of_two_largest(\\"3 5 1 2\\") \\"15\\" >>> product_of_two_largest(\\"10 15 20 30\\") \\"600\\" >>> product_of_two_largest(\\"4 3 8 7\\") \\"56\\" >>> product_of_two_largest(\\"1 10 3 9n20 5 25 8\\") \\"90n500\\" >>> product_of_two_largest(\\"3 5n10 15n4 3n3 9\\") \\"15n150n12n27\\"","solution":"def product_of_two_largest(input_string): Returns a string with the product of the two largest integers on each line of the input string. Each product is on a new line. :param input_string: str :return: str lines = input_string.strip().split('n') results = [] for line in lines: numbers = list(map(int, line.split())) numbers.sort(reverse=True) product = numbers[0] * numbers[1] results.append(str(product)) return 'n'.join(results)"},{"question":"def max_subarray_sum(arr): Finds the maximum sum of a contiguous subarray within the given array. :param arr: List of integers :return: Integer representing the maximum sum of the longest contiguous subarray Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4]) == -1","solution":"def max_subarray_sum(arr): Finds the maximum sum of a contiguous subarray within the given array. :param arr: List of integers :return: Integer representing the maximum sum of the longest contiguous subarray if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def generateModifiedFibonacci(n): This function generates the first n terms of the Modified Fibonacci Sequence. >>> generateModifiedFibonacci(6) [0, 1, 1, 2, 4, 7] >>> generateModifiedFibonacci(10) [0, 1, 1, 2, 4, 7, 13, 24, 44, 81]","solution":"def generateModifiedFibonacci(n): This function generates the first n terms of the Modified Fibonacci Sequence. if n == 1: return [0] if n == 2: return [0, 1] if n == 3: return [0, 1, 1] seq = [0, 1, 1] for i in range(3, n): next_value = seq[i-1] + seq[i-2] + seq[i-3] seq.append(next_value) return seq"},{"question":"def knight_moves(knight: str) -> List[str]: Given the initial position of a knight in chess notation, find all the possible destinations the knight can move to in exactly one move. Ensure to only include valid positions inside the chessboard. >>> knight_moves(\\"e4\\") ['c3', 'c5', 'd2', 'd6', 'f2', 'f6', 'g3', 'g5'] >>> knight_moves(\\"h8\\") ['f7', 'g6']","solution":"def knight_moves(knight): Returns all possible destinations the knight can move to in exactly one move from the given position in chess notation. def is_valid_position(x, y): return 0 <= x < 8 and 0 <= y < 8 knight_position = (ord(knight[0]) - ord('a'), int(knight[1]) - 1) potential_moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] valid_positions = [] for move in potential_moves: new_x = knight_position[0] + move[0] new_y = knight_position[1] + move[1] if is_valid_position(new_x, new_y): valid_positions.append(chr(new_x + ord('a')) + str(new_y + 1)) return sorted(valid_positions)"},{"question":"def count_customers_exceeding_threshold(T, test_cases): Count the number of customers whose total spending exceeds the threshold amount in each test case. Args: T (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains: - N (int): The number of customers. - K (int): The threshold amount. - customers (list of list of ints): Lists of integers representing prices of items purchased by each customer. Returns: list: A list of integers representing the number of customers spending more than the threshold amount K for each test case. Example: >>> T = 2 >>> test_cases = [ ... (3, 500, [[100, 200, 250], [400, 150], [100, 100, 100, 200]]), ... (2, 1000, [[1000], [900, 200, 100]]) ... ] >>> count_customers_exceeding_threshold(T, test_cases) [2, 1]","solution":"def count_customers_exceeding_threshold(T, test_cases): results = [] for case in test_cases: N, K, customers = case count = 0 for customer in customers: if sum(customer) > K: count += 1 results.append(count) return results # Helper function to process input data def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, K = map(int, lines[index].split()) customers = [] for i in range(1, N+1): customer = list(map(int, lines[index + i].split())) customers.append(customer) test_cases.append((N, K, customers)) index += N + 1 return T, test_cases"},{"question":"def minimum_liters(required: int, N: int, K: int) -> int: Determine the minimum number of liters Zoltar must pay for to get at least the required amount of potion. Args: required (int): The total liters of potion needed. N (int): The number of liters that triggers the bulk discount. K (int): The number of free liters obtained with the bulk discount. Returns: int: The minimum number of liters Zoltar must pay for. Examples: >>> minimum_liters(10, 3, 1) 8 >>> minimum_liters(20, 4, 2) 14 >>> minimum_liters(25, 5, 0) 25 pass def process_cases(cases: List[Tuple[int, int, int]]) -> List[int]: Processes multiple test cases and returns the results as a list. Args: cases (List[Tuple[int, int, int]]): A list of tuples, each containing the required liters, N, and K. Returns: List[int]: A list of results for each test case. Examples: >>> process_cases([(10, 3, 1), (20, 4, 2), (25, 5, 0)]) [8, 14, 25] pass","solution":"def minimum_liters(required, N, K): Determine the minimum number of liters Zoltar must pay for to get at least the required amount of potion. # Calculate the number of liters that make a complete discount cycle total_liters_per_cycle = N + K # Calculate number of full cycles required full_cycles = required // total_liters_per_cycle # Calculate the remaining liters after full cycles remaining_liters = required % total_liters_per_cycle # Calculate the total paid liters for full cycles paid_liters = full_cycles * N # Calculate additional liters required after full cycles if remaining_liters > 0: # If the remaining liters exceed N, we have to add another cycle if remaining_liters > N: paid_liters += N else: # Otherwise, pay for the remaining liters only paid_liters += remaining_liters return paid_liters def process_cases(cases): Processes multiple test cases and returns the results as a list. results = [] for case in cases: required, N, K = case result = minimum_liters(required, N, K) results.append(result) return results"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Given a tree with n nodes, node 1 always being the root, find the diameter of the tree. :param n: int - number of vertices :param edges: List of tuples - edges between the vertices :return: int - diameter of the tree >>> tree_diameter(4, [(1, 2), (1, 3), (3, 4)]) 3 >>> tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 3 >>> tree_diameter(6, [(1, 2), (1, 3), (2, 4), (2, 5), (4, 6)]) 4 def process_test_cases(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Process multiple test cases to find the diameter of each tree. :param test_cases: List of test cases where each test case contains the number of vertices and a list of tuples representing the edges in the tree. :return: List of integers where each integer is the diameter of the corresponding tree. >>> process_test_cases([(4, [(1, 2), (1, 3), (3, 4)])]) [3] >>> process_test_cases([(5, [(1, 2), (1, 3), (2, 4), (2, 5)])]) [3] >>> process_test_cases([(6, [(1, 2), (1, 3), (2, 4), (2, 5), (4, 6)])]) [4]","solution":"from collections import deque, defaultdict def tree_diameter(n, edges): if n == 1: return 0 # Build the adjacency list of the tree adj = defaultdict(list) for u, v in edges: adj[u].append(v) adj[v].append(u) # BFS to find the farthest node from an arbitrary start node def bfs(start): visited = [-1] * (n + 1) queue = deque([start]) visited[start] = 0 farthest_node = start max_distance = 0 while queue: node = queue.popleft() for neighbor in adj[node]: if visited[neighbor] == -1: queue.append(neighbor) visited[neighbor] = visited[node] + 1 if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance # Running bfs from an arbitrary node (root = 1) farthest_node, _ = bfs(1) # Running bfs from the farthest node found from the initial bfs _, diameter = bfs(farthest_node) return diameter def process_test_cases(test_cases): results = [] for n, edges in test_cases: results.append(tree_diameter(n, edges)) return results"},{"question":"def perform_operations(N, Q, S, queries): Perform Q operations on the string S of length N and return results for type 2 queries. Each operation can be of two types: 1. Update the k-th character of the string to character c. (1 â‰¤ k â‰¤ N) 2. Find the number of distinct characters in the substring from position l to r inclusive. (1 â‰¤ l â‰¤ r â‰¤ N) Args: N: int - length of the string S Q: int - number of queries S: str - input string queries: List[str] - list of queries Returns: List[int] - list of results for type 2 queries >>> perform_operations(7, 3, 'abacaba', ['2 1 4', '1 3 z', '2 1 4']) [3, 4] >>> perform_operations(5, 4, 'abcde', ['2 1 5', '1 5 a', '2 1 5', '2 2 5']) [5, 4, 4] >>> perform_operations(3, 2, 'aaa', ['1 1 b', '2 1 3']) [2] S = list(S) results = [] for query in queries: parts = query.split() type_query = int(parts[0]) if type_query == 1: k = int(parts[1]) - 1 c = parts[2] S[k] = c elif type_query == 2: l = int(parts[1]) - 1 r = int(parts[2]) distinct_chars = len(set(S[l:r])) results.append(distinct_chars) return results def solution(T, cases): Processes multiple test cases and returns a list of results for all queries. Each test case contains: N, Q: int (length of the string S and number of queries) S: str (input string) queries: List[str] (list of queries) Args: T: int - number of test cases cases: List[Tuple[int, int, str, List[str]]] - list of test cases Returns: List[int] - list of results for all type 2 queries across all test cases >>> T = 1 ... cases = [ (7, 3, 'abacaba', ['2 1 4', '1 3 z', '2 1 4']) ] ... solution(T, cases) [3, 4] >>> T = 1 ... cases = [ (5, 4, 'abcde', ['2 1 5', '1 5 a', '2 1 5', '2 2 5']) ] ... solution(T, cases) [5, 4, 4] >>> T = 2 ... cases = [ ... (3, 2, 'aaa', ['1 1 b', '2 1 3']), ... (4, 3, 'abaa', ['2 2 4', '1 3 c', '2 1 4']) ... ] ... solution(T, cases) [2, 2, 3] results = [] for case in cases: N, Q, S, queries = case results.extend(perform_operations(N, Q, S, queries)) return results","solution":"def perform_operations(N, Q, S, queries): # Convert string to list for efficient updates S = list(S) results = [] for query in queries: parts = query.split() type_query = int(parts[0]) if type_query == 1: # Update query k = int(parts[1]) - 1 c = parts[2] S[k] = c elif type_query == 2: # Find distinct characters l = int(parts[1]) - 1 r = int(parts[2]) distinct_chars = len(set(S[l:r])) results.append(distinct_chars) return results def solution(T, cases): results = [] for case in cases: N, Q, S, queries = case results.extend(perform_operations(N, Q, S, queries)) return results"},{"question":"def minimum_possible_value(arr): Returns the minimum possible value of the array after performing the operation n-1 times, where n is the length of the array. The function takes an array of integers as input and returns a single integer. Examples: >>> minimum_possible_value([10, 20, 30, 40, 50]) 10 >>> minimum_possible_value([9, 8, 7, 6]) 6 >>> minimum_possible_value([5]) 5 >>> minimum_possible_value([1, 2, 3, 4, 5]) 1 >>> minimum_possible_value([7, 7, 7, 7]) 7 >>> minimum_possible_value([4, 1, 8, 3, 2]) 1","solution":"def minimum_possible_value(arr): Returns the minimum possible value of the array after performing the operation n-1 times, where n is the length of the array. return min(arr)"},{"question":"class DragonProtectionSquad: def __init__(self, protection_levels, reporting_structure): Initialize the Dragon Protection Squad with given protection levels and reporting structure. Args: protection_levels (List[int]): Initial protection levels of the sectors. reporting_structure (List[Tuple[int, int]]): List of pairs defining the reporting structure. def update_protection_level(self, sector, x): Update the protection level of the given sector. Args: sector (int): The sector to update. x (int): The new protection level. def query_protection_level(self, sector): Query the total protection level under the given sector including itself. Args: sector (int): The sector to query. Returns: int: The total protection level. import pytest from solution import DragonProtectionSquad def setup_module(module): global squad protection_levels = [5, 3, 8, 6, 2] reporting_structure = [(1, 2), (2, 3), (2, 4), (1, 5)] squad = DragonProtectionSquad(protection_levels, reporting_structure) def test_initial_protection_level(): assert squad.query_protection_level(1) == 24 assert squad.query_protection_level(2) == 17 def test_update_protection_level(): squad.update_protection_level(2, 7) assert squad.query_protection_level(1) == 28 assert squad.query_protection_level(2) == 21 def test_protection_level_after_update(): squad.update_protection_level(4, 10) assert squad.query_protection_level(1) == 32 assert squad.query_protection_level(2) == 25","solution":"class DragonProtectionSquad: def __init__(self, protection_levels, reporting_structure): self.n = len(protection_levels) self.protection_levels = protection_levels self.tree = [[] for _ in range(self.n)] self.subtree_sum = [0] * self.n self.build_tree(reporting_structure) self.calculate_subtree_sum(0, -1) def build_tree(self, reporting_structure): for u, v in reporting_structure: self.tree[u - 1].append(v - 1) self.tree[v - 1].append(u - 1) def calculate_subtree_sum(self, node, parent): self.subtree_sum[node] = self.protection_levels[node] for child in self.tree[node]: if child == parent: continue self.subtree_sum[node] += self.calculate_subtree_sum(child, node) return self.subtree_sum[node] def update_protection_level(self, sector, x): delta = x - self.protection_levels[sector - 1] self.protection_levels[sector - 1] = x self.update_subtree_sum(sector - 1, delta) def update_subtree_sum(self, node, delta, parent=-1): self.subtree_sum[node] += delta for child in self.tree[node]: if child != parent: self.update_subtree_sum(child, delta, node) def query_protection_level(self, sector): return self.subtree_sum[sector - 1]"},{"question":"def is_almost_sorted(n, array): Determine whether the given array is almost sorted. :param n: Length of the array :param array: List of integers :return: \\"YES\\" if the array is almost sorted, otherwise \\"NO\\" >>> is_almost_sorted(5, [1, 1, 2, 2, 3]) \\"YES\\" >>> is_almost_sorted(4, [1, 3, 5, 5]) \\"NO\\" >>> is_almost_sorted(5, [5, 5, 5, 5, 5]) \\"YES\\" def main(t, test_cases): Process multiple test cases and return results for each. :param t: Number of test cases :param test_cases: List of tuples (n, array) for each test case :return: List of results >>> main(3, [(5, [1, 1, 2, 2, 3]), (4, [1, 3, 5, 5]), (5, [5, 5, 5, 5, 5])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> main(2, [(3, [10, 11, 10]), (6, [6, 7, 6, 7, 6, 7])]) [\\"YES\\", \\"YES\\"] >>> main(1, [(3, [1, 3, 2])]) [\\"NO\\"]","solution":"def is_almost_sorted(n, array): Determine whether the given array is almost sorted. :param n: Length of the array :param array: List of integers :return: \\"YES\\" if the array is almost sorted, otherwise \\"NO\\" for i in range(n - 1): if abs(array[i] - array[i + 1]) > 1: return \\"NO\\" return \\"YES\\" def main(t, test_cases): Process multiple test cases and return results for each. :param t: Number of test cases :param test_cases: List of tuples (n, array) for each test case :return: List of results results = [] for n, array in test_cases: results.append(is_almost_sorted(n, array)) return results"},{"question":"def sort_students(n, students): Sort students by their scores in non-increasing order. If scores are tied, sort by name alphabetically. Parameters: n (int): Number of students. students (list of tuple): List of tuples, each containing student name and their score. Returns: list: Sorted list of student names. >>> sort_students(4, [(\\"Alice\\", 90), (\\"Bob\\", 95), (\\"Charlie\\", 85), (\\"David\\", 95)]) [\\"Bob\\", \\"David\\", \\"Alice\\", \\"Charlie\\"] >>> sort_students(3, [(\\"Zara\\", 88), (\\"Anna\\", 88), (\\"Liam\\", 92)]) [\\"Liam\\", \\"Anna\\", \\"Zara\\"]","solution":"def sort_students(n, students): Sort students by their scores in non-increasing order. If scores are tied, sort by name alphabetically. Parameters: n (int): Number of students. students (list of tuple): List of tuples, each containing student name and their score. Returns: list: Sorted list of student names. # Sort the list based on the score (descending) and name (ascending) sorted_students = sorted(students, key=lambda x: (-x[1], x[0])) # Extract only the names in the sorted order sorted_names = [student[0] for student in sorted_students] return sorted_names"},{"question":"def max_subarray_sum(arr): This function takes a list of integers and returns the sum of the subarray with the largest sum. >>> max_subarray_sum([5, -3, 5]) == 7 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1]) == -1 >>> max_subarray_sum([2]) == 2 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15","solution":"def max_subarray_sum(arr): This function takes a list of integers and returns the sum of the subarray with the largest sum. if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum # Function to read input and print output def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) result = max_subarray_sum(arr) print(result)"},{"question":"def capitalize_words(s: str) -> str: Takes a string and capitalizes the first letter of each word while making the rest of the letters lowercase. Args: s (str): The input string consisting of alphabetic characters and whitespace. Returns: str: The transformed string with each word capitalized. Examples: >>> capitalize_words(\\"hello world\\") 'Hello World' >>> capitalize_words(\\"PyTHOn proGRAmming is fuN\\") 'Python Programming Is Fun' >>> capitalize_words(\\" leading and trailing spaces \\") ' Leading And Trailing Spaces ' # Your code here","solution":"def capitalize_words(s): Takes a string and capitalizes the first letter of each word while making the rest of the letters lowercase. result = [] in_word = False for char in s: if char.isalpha(): if not in_word: # Start of a new word result.append(char.upper()) in_word = True else: result.append(char.lower()) else: # Characters that are not alphabets (spaces) result.append(char) in_word = False return ''.join(result)"},{"question":"def check_difference_pair(t, test_cases): For each test case, determine if there exists at least one pair of elements in the array such that their difference is equal to a given number k. t: int - number of test cases test_cases: list of tuple - list that consists of tuples where each tuple contains (n: int, k: int, arr: list of int) Returns a list of \\"YES\\" or \\"NO\\" for each test case. pass def test_example_cases(): assert check_difference_pair(3, [(5, 2, [1, 5, 3, 4, 2]), (4, 0, [1, 2, 3, 4]), (4, 10, [100, 200, 150, 80])]) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_no_pair_cases(): assert check_difference_pair(2, [(3, 5, [1, 2, 3]), (4, 8, [10, 10, 10, 10])]) == [\\"NO\\", \\"NO\\"] def test_all_pairs_cases(): assert check_difference_pair(2, [(3, 0, [7, 7, 7]), (4, 0, [1, 1, 1, 1])]) == [\\"YES\\", \\"YES\\"] def test_large_n_small_k_cases(): array = list(range(1, 100001)) assert check_difference_pair(1, [(100000, 1, array)]) == [\\"YES\\"] def test_k_larger_than_all_elements(): assert check_difference_pair(1, [(5, 1000, [1, 2, 3, 4, 5])]) == [\\"NO\\"] if __name__ == \\"__main__\\": test_example_cases() test_no_pair_cases() test_all_pairs_cases() test_large_n_small_k_cases() test_k_larger_than_all_elements() print(\\"All tests passed!\\")","solution":"def check_difference_pair(t, test_cases): For each test case, determine if there exists at least one pair of elements in the array such that their difference is equal to a given number k. t: int - number of test cases test_cases: list of tuple - list that consists of tuples where each tuple contains (n: int, k: int, arr: list of int) Returns a list of \\"YES\\" or \\"NO\\" for each test case. results = [] for i in range(t): n, k, arr = test_cases[i] found = False arr_set = set(arr) for num in arr: if (num + k) in arr_set or (num - k) in arr_set: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results"},{"question":"def alternate_capitalization(s: str) -> str: Returns the given string in alternate capitalization format. >>> alternate_capitalization(\\"hello\\") 'HeLlO' >>> alternate_capitalization(\\"world\\") 'WoRlD' >>> alternate_capitalization(\\"PROGRAMMING\\") 'PrOgRaMmInG' pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases for alternate capitalization. >>> process_test_cases(3, [\\"hello\\", \\"world\\", \\"PROGRAMMING\\"]) ['HeLlO', 'WoRlD', 'PrOgRaMmInG'] >>> process_test_cases(1, [\\"test\\"]) ['TeSt'] >>> process_test_cases(2, [\\"a\\", \\"B\\"]) ['A', 'B'] pass","solution":"def alternate_capitalization(s): Returns the string in alternate capitalization format. result = [] for i, char in enumerate(s): if i % 2 == 0: result.append(char.upper()) else: result.append(char.lower()) return ''.join(result) def process_test_cases(T, test_cases): Process multiple test cases for alternate capitalization. results = [] for s in test_cases: results.append(alternate_capitalization(s)) return results"},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Calculate the minimum number of operations required to transform the given string into a palindrome. Args: n (int): The length of the string s (str): The initial string Returns: int: The minimum number of operations required to make the string a palindrome. Examples: >>> min_operations_to_palindrome(5, \\"abcba\\") 0 >>> min_operations_to_palindrome(3, \\"abc\\") 2 >>> min_operations_to_palindrome(4, \\"aabb\\") 1","solution":"def min_operations_to_palindrome(n, s): Returns the minimum number of operations required to transform the given string into a palindrome. def lcs(x, y): Helper function to find the longest common subsequence m = len(x) n = len(y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif x[i - 1] == y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] reverse_s = s[::-1] lcs_length = lcs(s, reverse_s) # Minimum operations to make the string palindrome return n - lcs_length"},{"question":"def find_quadruplets(arr, k): Returns all unique quadruplets in the array that sum up to k. >>> find_quadruplets([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> find_quadruplets([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] >>> find_quadruplets([1, 2, 3, 4], 100) [] >>> find_quadruplets([1, 4, 45, 6, 10, 12], 22) [] >>> find_quadruplets([-3, -1, 0, 2, 4, 5], 2) [[-3, -1, 2, 4]] >>> find_quadruplets([], 0) [] >>> find_quadruplets([1, 2, 3, 4, 5, 6], 1000) [] >>> find_quadruplets([1000000000, 2000000000, -1000000000, -2000000000, 0, 4, 5], 0) [[-2000000000, -1000000000, 1000000000, 2000000000]]","solution":"def find_quadruplets(arr, k): Returns all unique quadruplets in the array that sum up to k. arr.sort() quadruplets = [] n = len(arr) for i in range(n - 3): if i > 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and arr[j] == arr[j - 1]: continue left, right = j + 1, n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == k: quadruplets.append([arr[i], arr[j], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < k: left += 1 else: right -= 1 return quadruplets"},{"question":"[Completion Task in Python] from typing import List def min_operations_to_make_good(s: str) -> int: Returns the minimum number of operations needed to make the string good. >>> min_operations_to_make_good(\\"ababc\\") 1 >>> min_operations_to_make_good(\\"abcabc\\") 2 >>> min_operations_to_make_good(\\"aabbcc\\") 0 >>> min_operations_to_make_good(\\"zzzabczzz\\") 1 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the results. >>> process_test_cases(4, [\\"ababc\\", \\"abcabc\\", \\"aabbcc\\", \\"zzzabczzz\\"]) [1, 2, 0, 1] >>> process_test_cases(3, [\\"abc\\", \\"abcabc\\", \\"ababc\\"]) [1, 2, 1] >>> process_test_cases(2, [\\"abcdef\\", \\"ghijkl\\"]) [1, 0]","solution":"def min_operations_to_make_good(s): Returns the minimum number of operations needed to make the string good. count = 0 n = len(s) i = 0 while i < n - 2: if s[i:i+3] == \\"abc\\": count += 1 i += 3 else: i += 1 return count def process_test_cases(t, test_cases): results = [] for s in test_cases: results.append(min_operations_to_make_good(s)) return results # Sample implementation for processing input and displaying output def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) test_cases = data[1:] results = process_test_cases(t, test_cases) for result in results: print(result)"},{"question":"def min_moves(grid, start, target): Determine the minimum number of moves required for the robot to reach the target cell from the starting position. If it is not possible to reach the target, return -1. >>> grid = [ ... \\"\\", ... \\"#..#\\", ... \\"#..#\\", ... \\"\\"] >>> start = (1, 1) >>> target = (2, 2) >>> min_moves(grid, start, target) 2 >>> grid = [ ... \\"\\", ... \\"#..#\\", ... \\"#..#\\", ... \\"\\"] >>> start = target = (1, 1) >>> min_moves(grid, start, target) 0 >>> grid = [ ... \\"\\", ... \\"#.#.\\", ... \\"\\", ... \\"\\"] >>> start = (1, 1) >>> target = (1, 3) >>> min_moves(grid, start, target) -1 >>> grid = [ ... \\"\\", ... \\"#........#\\", ... \\"#..#\\", ... \\"#........#\\", ... \\"\\"] >>> start = (1, 1) >>> target = (3, 8) >>> min_moves(grid, start, target) 9","solution":"from collections import deque def min_moves(grid, start, target): H, W = len(grid), len(grid[0]) sy, sx = start ty, tx = target # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS queue initialization queue = deque([(sy, sx, 0)]) visited = set((sy, sx)) while queue: y, x, moves = queue.popleft() # If target position is reached if (y, x) == (ty, tx): return moves for dy, dx in directions: ny, nx = y + dy, x + dx if 0 <= ny < H and 0 <= nx < W and (ny, nx) not in visited and grid[ny][nx] == '.': visited.add((ny, nx)) queue.append((ny, nx, moves + 1)) # If the target is not reachable return -1 if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() H = int(data[0]) W = int(data[1]) grid = [data[i+2] for i in range(H)] sy = int(data[H+2]) sx = int(data[H+3]) ty = int(data[H+4]) tx = int(data[H+5]) print(min_moves(grid, (sy, sx), (ty, tx)))"},{"question":"def min_spell_casts(n: int, energies: List[int]) -> int: Determine the minimum number of spell casts required to equalize the energy levels of all trees as much as possible. >>> min_spell_casts(4, [2, 3, 5, 5]) 2 >>> min_spell_casts(1, [5]) 0 >>> min_spell_casts(3, [1, 1, 1]) 0 >>> min_spell_casts(3, [0, 0, 0]) 0 >>> min_spell_casts(3, [1000000, 1000000, 1000000]) 0 >>> min_spell_casts(5, [10, 20, 30, 40, 50]) 60 >>> min_spell_casts(5, [50, 10, 40, 20, 30]) 60","solution":"def min_spell_casts(n, energies): energies.sort() median = energies[n // 2] # using median as the target energy spell_casts = 0 for energy in energies: spell_casts += abs(energy - median) return spell_casts"},{"question":"def max_consecutive_panels(n: int, m: int, heights: List[int]) -> int: Given an array representing heights of fence panels, find the maximum number of consecutive fence panels that can be painted such that the sum of their heights does not exceed a given limit. >>> max_consecutive_panels(6, 5, [2, 1, 1, 2, 1, 1]) == 4 >>> max_consecutive_panels(5, 3, [1, 2, 3, 4, 5]) == 2 >>> max_consecutive_panels(4, 7, [4, 3, 2, 1]) == 3","solution":"def max_consecutive_panels(n, m, heights): max_panels = 0 current_sum = 0 start = 0 for end in range(n): current_sum += heights[end] while current_sum > m: current_sum -= heights[start] start += 1 max_panels = max(max_panels, end - start + 1) return max_panels # Example of a function call n = 6 m = 5 heights = [2, 1, 1, 2, 1, 1] print(max_consecutive_panels(n, m, heights)) # Output should be 4"},{"question":"def calculate_remaining_hp(test_cases: str) -> str: Calculates the remaining HP for each character in the party after all attacks have been executed. Input: test_cases: A string containing multiple test cases. Each test case contains: - The number of characters in the party - Each character's name and initial HP - The number of attacks - Each attack's target character name and damage value Output: A formatted string containing the names of the characters and their remaining HPs after the battle. Example: >>> input_str = \\"2n3nAlice 500nBob 600nCharlie 700n4nAlice 300nBob 200nCharlie 100nAlice 250n2nDwarf 800nElf 700n3nDwarf 250nElf 300nDwarf 200n\\" >>> calculate_remaining_hp(input_str) 'Alice 0nBob 400nCharlie 600nDwarf 350nElf 400' pass def test_calculate_remaining_hp_case_1(): input_str = 2 3 Alice 500 Bob 600 Charlie 700 4 Alice 300 Bob 200 Charlie 100 Alice 250 2 Dwarf 800 Elf 700 3 Dwarf 250 Elf 300 Dwarf 200 expected_output = Alice 0 Bob 400 Charlie 600 Dwarf 350 Elf 400 assert main(input_str) == expected_output def test_calculate_remaining_hp_case_2(): input_str = 1 2 Knight 1000 Mage 500 2 Knight 300 Mage 450 expected_output = Knight 700 Mage 50 assert main(input_str) == expected_output def test_calculate_remaining_hp_case_3(): input_str = 1 1 Warrior 500 5 Warrior 100 Warrior 100 Warrior 100 Warrior 100 Warrior 100 expected_output = Warrior 0 assert main(input_str) == expected_output def test_calculate_remaining_hp_case_no_damage(): input_str = 1 1 Healer 1000 0 expected_output = Healer 1000 assert main(input_str) == expected_output def test_calculate_remaining_hp_case_exact_damage(): input_str = 1 1 Tank 900 3 Tank 300 Tank 300 Tank 300 expected_output = Tank 0 assert main(input_str) == expected_output","solution":"def calculate_remaining_hp(test_cases): results = [] for test_case in test_cases: num_characters = test_case['num_characters'] characters = test_case['characters'] attacks = test_case['attacks'] hp = {name: initial_hp for name, initial_hp in characters} for attack in attacks: target, damage = attack hp[target] = max(hp[target] - damage, 0) result = [(name, hp[name]) for name, _ in characters] results.append(result) return results def parse_input(input_str): input_lines = input_str.strip().split('n') idx = 0 num_test_cases = int(input_lines[idx]) idx += 1 test_cases = [] for _ in range(num_test_cases): num_characters = int(input_lines[idx]) idx += 1 characters = [] for _ in range(num_characters): char_info = input_lines[idx].split() name = char_info[0] initial_hp = int(char_info[1]) characters.append((name, initial_hp)) idx += 1 num_attacks = int(input_lines[idx]) idx += 1 attacks = [] for _ in range(num_attacks): attack_info = input_lines[idx].split() target = attack_info[0] damage = int(attack_info[1]) attacks.append((target, damage)) idx += 1 test_cases.append({ 'num_characters': num_characters, 'characters': characters, 'attacks': attacks }) return test_cases def format_output(results): output_lines = [] for result in results: for name, remaining_hp in result: output_lines.append(f\\"{name} {remaining_hp}\\") return 'n'.join(output_lines) def main(input_str): test_cases = parse_input(input_str) results = calculate_remaining_hp(test_cases) return format_output(results)"},{"question":"from typing import List def max_submatrix_sum(matrix: List[List[int]]) -> int: Returns the maximum sum of any submatrix within the given matrix. >>> max_submatrix_sum([ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ]) 29 >>> max_submatrix_sum([ ... [-1, -2], ... [-3, -4] ... ]) -1 >>> max_submatrix_sum([ ... [1] ... ]) 1 >>> max_submatrix_sum([ ... [1, 2], ... [3, 4] ... ]) 10 >>> max_submatrix_sum([ ... [6, -5], ... [-3, 4] ... ]) 6 >>> max_submatrix_sum([ ... [-1, -1, -1, -1], ... [-1, -1, -1, -1], ... [-1, -1, -1, -1], ... [-1, -1, -1, -1] ... ]) -1 >>> max_submatrix_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> max_submatrix_sum([ ... [0] ... ]) 0 >>> max_submatrix_sum([ ... [0, 0], ... [0, 0] ... ]) 0 >>> max_submatrix_sum([ ... [-10, -20, -30], ... [-40, -50, -60], ... [10, 20, 30] ... ]) 60","solution":"def max_submatrix_sum(matrix): Returns the maximum sum of any submatrix within the given matrix. if not matrix or not matrix[0]: return 0 N = len(matrix) M = len(matrix[0]) max_sum = float('-inf') # Apply Kadane's Algorithm in 2D for left in range(M): temp = [0] * N for right in range(left, M): for i in range(N): temp[i] += matrix[i][right] max_sum = max(max_sum, kadane(temp)) return max_sum def kadane(arr): Helper function to find the maximum sum subarray in a 1D array. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def find_pairs_with_sum(nums: List[int], target: int) -> List[List[int]]: Returns unique pairs of numbers from the list that add up to the target sum. Each pair is ordered such that the smaller number comes first, and the output does not contain duplicate pairs. >>> find_pairs_with_sum([2, 4, 3, 5, 7, 8, 9], 7) [[2, 5], [3, 4]] >>> find_pairs_with_sum([1, 2, 3, 4, 5, 6], 10) [[4, 6]] >>> find_pairs_with_sum([1, 2, 3], 6) []","solution":"def find_pairs_with_sum(nums, target): Returns unique pairs of numbers from the list that add up to the target sum. Each pair is ordered such that the smaller number comes first, and the output does not contain duplicate pairs. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in pairs]"},{"question":"def max_books_on_shelf(n, W, widths): Given the number of books, the width of the bookshelf, and the widths of each book, determines the maximum number of books that can fit on the shelf and the minimum unused width. Parameters: n (int): The number of books. W (int): The width of the bookshelf. widths (list of int): The widths of the books. Returns: tuple: A tuple containing two integers: - The maximum number of books that can be placed on the shelf. - The minimum unused width with the given configuration. >>> max_books_on_shelf(5, 10, [2, 3, 5, 6, 1]) (3, 0) >>> max_books_on_shelf(3, 5, [4, 6, 10]) (1, 1) >>> max_books_on_shelf(3, 6, [2, 2, 2]) (3, 0) >>> max_books_on_shelf(4, 11, [3, 3, 3, 3]) (3, 2) >>> max_books_on_shelf(5, 25, [1, 2, 3, 4, 5]) (5, 10) >>> max_books_on_shelf(1, 1, [2]) (0, 1) >>> max_books_on_shelf(1, 2, [2]) (1, 0) >>> max_books_on_shelf(5, 1, [2, 3, 4, 5, 6]) (0, 1)","solution":"def max_books_on_shelf(n, W, widths): Given the number of books, the width of the bookshelf, and the widths of each book, determines the maximum number of books that can fit on the shelf and the minimum unused width. Parameters: n (int): The number of books. W (int): The width of the bookshelf. widths (list of int): The widths of the books. Returns: tuple: A tuple containing two integers: - The maximum number of books that can be placed on the shelf. - The minimum unused width with the given configuration. from itertools import combinations max_books = 0 min_unused_width = W for r in range(1, n+1): for combo in combinations(widths, r): total_width = sum(combo) if total_width <= W: unused_width = W - total_width if r > max_books or (r == max_books and unused_width < min_unused_width): max_books = r min_unused_width = unused_width return max_books, min_unused_width # Input prompt for example implementation if __name__ == \\"__main__\\": n, W = map(int, input().split()) widths = list(map(int, input().split())) result = max_books_on_shelf(n, W, widths) print(result[0], result[1])"},{"question":"def reorder_list(nums: List[int]) -> List[int]: Reorders the list so that all negative integers appear before all positive integers while keeping the relative order of negative and positive integers the same. Parameters: nums (list): List of integers Returns: list: Reordered list with all negative integers followed by all positive integers >>> reorder_list([3, -1, 2, -4, -6, 5, -3, 2]) [-1, -4, -6, -3, 3, 2, 5, 2] >>> reorder_list([-5, -2, 0, 2, 1, -3]) [-5, -2, -3, 0, 2, 1] >>> reorder_list([-1, -2, -3, -4]) [-1, -2, -3, -4] >>> reorder_list([1, 2, 3, 4]) [1, 2, 3, 4] >>> reorder_list([0, -1, -2, 1, 2, 0]) [-1, -2, 0, 1, 2, 0] >>> reorder_list([5]) [5] >>> reorder_list([-5]) [-5]","solution":"def reorder_list(nums): Reorders the list so that all negative integers appear before all positive integers while keeping the relative order of negative and positive integers the same. Parameters: nums (list): List of integers Returns: list: Reordered list with all negative integers followed by all positive integers negative = [x for x in nums if x < 0] non_negative = [x for x in nums if x >= 0] return negative + non_negative"},{"question":"def findInactiveID(N, userIDs): Rahul is working on a program to manage user IDs for an application. Each user is assigned a unique ID starting from 1 to N. However, sometimes users are deactivated, and their IDs become available for reassignment. Given a list of N-1 active user IDs, Rahul needs to identify the ID of the inactive user. Example 1: Input: N = 6 userIDs = [1, 2, 4, 3, 6] Output: 5 Example 2: Input: N = 3 userIDs = [3, 1] Output: 2 Your Task: You don't need to read input or print anything. Your task is to complete the function findInactiveID() which takes the array userIDs[] and its size N as input and returns the missing user ID. Expected Time Complexity: O(N) Expected Auxiliary Space: O(1) Constraints: 2 â‰¤ N â‰¤ 10^4 1 â‰¤ userIDs[i] â‰¤ 10^4 Size of the array userIDs[] = N-1 >>> findInactiveID(6, [1, 2, 4, 3, 6]) 5 >>> findInactiveID(3, [3, 1]) 2","solution":"def findInactiveID(N, userIDs): Returns the missing user ID from the list of active user IDs. total_sum = N * (N + 1) // 2 userIDs_sum = sum(userIDs) return total_sum - userIDs_sum"},{"question":"def shortest_path_times(N: int, M: int, S: int, paths: List[Tuple[int, int, int]], K: int, key_rooms: List[int]) -> List[int]: Find the shortest time it takes to reach a list of specific key rooms starting from a given room. Args: N (int): Number of rooms. M (int): Number of paths. S (int): Starting room. paths (List[Tuple[int, int, int]]): List of paths where each path is a tuple (A, B, T) representing a path from room A to room B taking time T. K (int): Number of key rooms. key_rooms (List[int]): List of key rooms Erika needs to reach. Returns: List[int]: Shortest time to reach each of the key rooms from the starting room S. If a key room cannot be reached, return -1 for that room.","solution":"import heapq def shortest_path_times(N, M, S, paths, K, key_rooms): # Create a graph from the given paths graph = {i: [] for i in range(1, N+1)} for A, B, T in paths: graph[A].append((B, T)) graph[B].append((A, T)) # Assuming this is an undirected graph # Initialize the distances dictionary with infinity distances = {i: float('inf') for i in range(1, N+1)} distances[S] = 0 # Min-heap to store (distance, node) heap = [(0, S)] while heap: current_distance, current_node = heapq.heappop(heap) # If the popped distance is still the best known distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) # Extract the shortest times for the key rooms result = [] for room in key_rooms: if distances[room] == float('inf'): result.append(-1) else: result.append(distances[room]) return result"},{"question":"def is_special_string(s: str) -> str: Check if a given string is special. A string is called \\"special\\" if and only if for any two consecutive characters, their ASCII values differ by 1. >>> is_special_string(\\"abc\\") \\"YES\\" >>> is_special_string(\\"abd\\") \\"NO\\" >>> is_special_string(\\"z\\") \\"YES\\" def test_is_special_string_single_character(): assert is_special_string(\\"z\\") == \\"YES\\" assert is_special_string(\\"a\\") == \\"YES\\" def test_is_special_string_consecutive_alpha(): assert is_special_string(\\"abc\\") == \\"YES\\" assert is_special_string(\\"xyz\\") == \\"YES\\" def test_is_special_string_non_consecutive_alpha(): assert is_special_string(\\"abd\\") == \\"NO\\" assert is_special_string(\\"az\\") == \\"NO\\" def test_is_special_string_boundary_cases(): assert is_special_string(\\"a\\" * 100) == \\"NO\\" consecutive_string = ''.join(chr(97 + i % 26) for i in range(100)) # Generating a modulo sequence of length 100 assert is_special_string(consecutive_string) == \\"NO\\" # Should return \\"NO\\" because it loops around def test_is_special_string_mixed_cases(): assert is_special_string(\\"abcf\\") == \\"NO\\" assert is_special_string(\\"defga\\") == \\"NO\\"","solution":"def is_special_string(s): Returns \\"YES\\" if the string is special, otherwise \\"NO\\". for i in range(1, len(s)): if abs(ord(s[i]) - ord(s[i - 1])) != 1: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def minimumCommunicationDelay(n: int, connections: List[Tuple[int, int, int]]) -> int: Determine the minimum total communication delay to connect all computers. If it is impossible to connect all computers, return -1. Args: n (int): number of computers labeled from 1 to n connections (List[Tuple[int, int, int]]): list of connections where each connection is represented as a tuple (a_i, b_i, t_i) Returns: int: the minimum total communication delay or -1 if it's impossible to connect all computers. Examples: >>> minimumCommunicationDelay(4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 4, 4)]) == 4 >>> minimumCommunicationDelay(4, [(1, 2, 3), (3, 4, 4)]) == -1","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimumCommunicationDelay(n, connections): parent = [] rank = [] for node in range(n+1): parent.append(node) rank.append(0) connections.sort(key=lambda item: item[2]) e = 0 result = [] i = 0 while e < n - 1: if i >= len(connections): return -1 u, v, w = connections[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append(w) union(parent, rank, x, y) return sum(result)"},{"question":"def is_prime(num): Check if a number is prime. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False >>> is_prime(11) == True >>> is_prime(25) == False def next_prime(n): Find the smallest prime number greater than n. >>> next_prime(10) == 11 >>> next_prime(14) == 17 >>> next_prime(20) == 23 >>> next_prime(25) == 29 >>> next_prime(100) == 101 >>> next_prime(9973) == 10007","solution":"def is_prime(num): Check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): Find the smallest prime number greater than n. num = n + 1 while not is_prime(num): num += 1 return num"},{"question":"def soccer_player_can_reach_goal(T: int, test_cases: List[Dict]) -> List[str]: Determine if a soccer player can reach the goal in a grid with obstacles. :param T: int : Number of test cases :param test_cases: List[Dict] : A list of dictionaries where each dictionary represents a test case containing the grid dimensions, the grid itself, and the start and goal positions. :return: List[str] : A list of strings, where each string is \\"YES\\" if the player can reach the goal, otherwise \\"NO\\". Example Usage: >>> T = 2 >>> test_cases = [ >>> {'NM': (3, 4), 'grid': [\\"....\\", \\".*..\\", \\"....\\"], 'start': (1, 1), 'goal': (3, 4)}, >>> {'NM': (3, 3), 'grid': [\\"..*\\", \\"..*\\", \\"...\\"], 'start': (1, 1), 'goal': (2, 3)} >>> ] >>> soccer_player_can_reach_goal(T, test_cases) [\\"YES\\", \\"NO\\"] pass def test_case1(): T = 2 test_cases = [ { 'NM': (3, 4), 'grid': [ \\"....\\", \\".*..\\", \\"....\\" ], 'start': (1, 1), 'goal': (3, 4) }, { 'NM': (3, 3), 'grid': [ \\"..*\\", \\"..*\\", \\"...\\" ], 'start': (1, 1), 'goal': (2, 3) } ] assert soccer_player_can_reach_goal(T, test_cases) == [\\"YES\\", \\"NO\\"] def test_case2(): T = 1 test_cases = [ { 'NM': (3, 3), 'grid': [ \\"...\\", \\".*.\\", \\"...\\" ], 'start': (1, 1), 'goal': (3, 3) } ] assert soccer_player_can_reach_goal(T, test_cases) == [\\"YES\\"] def test_case3(): T = 1 test_cases = [ { 'NM': (3, 3), 'grid': [ \\".*.\\", \\"*.*\\", \\".*.\\" ], 'start': (1, 1), 'goal': (3, 3) } ] assert soccer_player_can_reach_goal(T, test_cases) == [\\"NO\\"] def test_case4(): T = 1 test_cases = [ { 'NM': (3, 3), 'grid': [ \\"...\\", \\"...\\", \\"...\\" ], 'start': (1, 1), 'goal': (3, 3) } ] assert soccer_player_can_reach_goal(T, test_cases) == [\\"YES\\"] def test_case5(): T = 1 test_cases = [ { 'NM': (2, 2), 'grid': [ \\".*\\", \\"..\\" ], 'start': (1, 2), 'goal': (2, 2) } ] assert soccer_player_can_reach_goal(T, test_cases) == [\\"YES\\"]","solution":"def is_reachable(grid, start, goal): from collections import deque n, m = len(grid), len(grid[0]) x1, y1 = start x2, y2 = goal x1 -= 1 y1 -= 1 x2 -= 1 y2 -= 1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(x1, y1)]) visited = set([(x1, y1)]) while queue: current_x, current_y = queue.popleft() if (current_x, current_y) == (x2, y2): return \\"YES\\" for dx, dy in directions: new_x, new_y = current_x + dx, current_y + dy if 0 <= new_x < n and 0 <= new_y < m and (new_x, new_y) not in visited and grid[new_x][new_y] == '.': queue.append((new_x, new_y)) visited.add((new_x, new_y)) return \\"NO\\" def soccer_player_can_reach_goal(T, test_cases): results = [] for i in range(T): N, M = test_cases[i]['NM'] grid = test_cases[i]['grid'] start = test_cases[i]['start'] goal = test_cases[i]['goal'] results.append(is_reachable(grid, start, goal)) return results"},{"question":"def unique_days_per_query(task_days: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns the number of unique days on which tasks were completed for each query range. Parameters: task_days (list): List where the i-th element represents the day on which task i was completed. queries (list): List of tuples where each tuple contains two integers L and R representing the range of task IDs. Returns: list: List of integers where each integer is the number of unique days for the corresponding query range. # Implement the function here # Example unit test from unique_days import unique_days_per_query def test_example_case(): task_days = [3, 1, 2, 3, 2, 1] queries = [(1, 3), (2, 5), (1, 6)] assert unique_days_per_query(task_days, queries) == [3, 3, 3] def test_single_task(): task_days = [1] queries = [(1, 1)] assert unique_days_per_query(task_days, queries) == [1] def test_all_tasks_same_day(): task_days = [2, 2, 2, 2, 2] queries = [(1, 5), (2, 4), (1, 1)] assert unique_days_per_query(task_days, queries) == [1, 1, 1] def test_different_days(): task_days = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] assert unique_days_per_query(task_days, queries) == [3, 3, 5] def test_multiple_queries(): task_days = [1, 2, 3, 4] queries = [(1, 2), (1, 3), (2, 4), (1, 4)] assert unique_days_per_query(task_days, queries) == [2, 3, 3, 4] def test_repeated_days(): task_days = [5, 5, 5, 5, 5] queries = [(1, 3), (2, 5)] assert unique_days_per_query(task_days, queries) == [1, 1] def test_large_input(): task_days = list(range(1, 100001)) queries = [(1, 50000), (50001, 100000), (1, 100000)] assert unique_days_per_query(task_days, queries) == [50000, 50000, 100000]","solution":"def unique_days_per_query(task_days, queries): Returns the number of unique days on which tasks were completed for each query range. Parameters: task_days (list): List where the i-th element represents the day on which task i was completed. queries (list): List of tuples where each tuple contains two integers L and R representing the range of task IDs. Returns: list: List of integers where each integer is the number of unique days for the corresponding query range. results = [] for L, R in queries: unique_days = len(set(task_days[L-1:R])) results.append(unique_days) return results # Example usage: task_days = [3, 1, 2, 3, 2, 1] queries = [(1, 3), (2, 5), (1, 6)] print(unique_days_per_query(task_days, queries)) # Output: [3, 3, 3]"},{"question":"from typing import List def min_operations_to_sort_cards(test_cases: List[List[int]]) -> List[int]: Determine the minimum number of operations required to sort each sequence of cards in non-decreasing order. >>> min_operations_to_sort_cards([[4, 3, 2, 1], [3, 1, 4, 2, 5], [1, 2, 3]]) [1, 2, 0] >>> min_operations_to_sort_cards([[3, 2, 1], [4, 3, 2, 1]]) [1, 1] >>> min_operations_to_sort_cards([[1, 2, 3], [1, 2, 3, 4, 5]]) [0, 0] pass def parse_input_and_solve(input_str: str) -> str: Parse the input string and solve the problem for each test case. >>> parse_input_and_solve('''3 4 4 3 2 1 5 3 1 4 2 5 3 1 2 3''') '1n2n0' >>> parse_input_and_solve('''2 3 3 2 1 4 4 3 2 1''') '1n1' >>> parse_input_and_solve('''2 3 1 2 3 5 1 2 3 4 5''') '0n0' pass","solution":"def min_operations_to_sort_cards(test_cases): results = [] for cards in test_cases: if cards == sorted(cards): results.append(0) elif cards == sorted(cards, reverse=True): results.append(1) else: results.append(2) return results def parse_input_and_solve(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) cards = list(map(int, lines[index + 1].split())) test_cases.append(cards) index += 2 results = min_operations_to_sort_cards(test_cases) return 'n'.join(map(str, results))"},{"question":"def longest_distinct_subarray_length(n: int, arr: List[int]) -> int: Given the length of the array \`n\` and the array \`arr\`, this function returns the length of the longest subarray with distinct elements. >>> longest_distinct_subarray_length(5, [1, 2, 3, 1, 2]) 3 >>> longest_distinct_subarray_length(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_distinct_subarray_length(4, [7, 3, 7, 3]) 2 >>> longest_distinct_subarray_length(3, [1, 1, 1]) 1 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a list of test cases, where each test case is represented as a tuple (n, arr), this function processes the test cases and returns a list of results for each test case. >>> process_test_cases([(5, [1, 2, 3, 1, 2]), (2, [1, 1])]) [3, 1] pass","solution":"def longest_distinct_subarray_length(n, arr): Given the length of the array \`n\` and the array \`arr\`, this function returns the length of the longest subarray with distinct elements. max_len = 0 start = 0 seen = {} for end in range(n): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_len = max(max_len, end - start + 1) return max_len def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(longest_distinct_subarray_length(n, arr)) return results"},{"question":"def longest_contiguous_subarray(n: int, m: int, grid: List[List[int]]) -> int: Finds the longest contiguous subarray with identical elements in any row or column of a grid. Parameters: n (int): number of rows. m (int): number of columns. grid: List[List[int]]: n x m grid with digits between 1 and 9. Returns: int: Length of the longest contiguous subarray with identical elements. Example: >>> longest_contiguous_subarray(3, 3, [[1, 2, 2], [2, 2, 2], [3, 3, 3]]) 3 >>> longest_contiguous_subarray(4, 4, [[1, 2, 3, 4], [5, 5, 5, 5], [6, 7, 8, 6], [9, 6, 6, 6]]) 4","solution":"def longest_contiguous_subarray(n, m, grid): Finds the longest contiguous subarray with identical elements in any row or column of a grid. Parameters: n (int): number of rows. m (int): number of columns. grid (list of list of int): n x m grid with digits between 1 and 9. Returns: int: Length of the longest contiguous subarray with identical elements. max_len = 1 # Check rows for longest contiguous subarray for row in grid: current_len = 1 for i in range(1, m): if row[i] == row[i-1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 # Check columns for longest contiguous subarray for col in range(m): current_len = 1 for i in range(1, n): if grid[i][col] == grid[i - 1][col]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def derange_array(n, a): Generates a deranged array such that no element remains in its original position. >>> derange_array(3, [1, 2, 3]) [2, 3, 1] # This is just an example; the actual output might differ >>> derange_array(4, [4, 5, 6, 7]) [5, 6, 7, 4] # This is just an example; the actual output might differ def derange_test_cases(t, test_cases): Generates deranged arrays for multiple test cases. >>> derange_test_cases(2, [(3, [1, 2, 3]), (4, [4, 5, 6, 7])]) [[2, 3, 1], [5, 6, 7, 4]] # These are examples; the actual output might differ","solution":"import random def derange_array(n, a): Generates a deranged array such that no element remains in its original position. # Create an auxiliary array with same elements and shuffle it b = a[:] while True: random.shuffle(b) if all(a[i] != b[i] for i in range(n)): return b def derange_test_cases(t, test_cases): Generates deranged arrays for multiple test cases. results = [] for case in test_cases: n, a = case deranged = derange_array(n, a) results.append(deranged) return results"},{"question":"def longest_city_name(test_cases): Given a list of test cases with cities, return the city with the longest name for each test case. :param test_cases: List of tuples, where each tuple contains: - an integer N (number of cities) - a list of N city names :return: List of city names with the longest name for each test case pass def test_longest_city_name(): assert longest_city_name([(3, ['Paris', 'London', 'Tokyo']), (4, ['Rome', 'Amsterdam', 'Berlin', 'Madrid'])]) == ['London', 'Amsterdam'] assert longest_city_name([(2, ['New York', 'LA']), (3, ['San Francisco', 'Chicago', 'Boston'])]) == ['New York', 'San Francisco'] assert longest_city_name([(1, ['Independence'])]) == ['Independence'] assert longest_city_name([(3, ['A', 'BB', 'CCC'])]) == ['CCC'] assert longest_city_name([(3, ['AA', 'BB', 'CC'])]) == ['AA']","solution":"def longest_city_name(test_cases): Given a list of test cases with cities, return the city with the longest name for each test case. :param test_cases: List of tuples, where each tuple contains: - an integer N (number of cities) - a list of N city names :return: List of city names with the longest name for each test case result = [] for case in test_cases: N, cities = case longest_name = '' for city in cities: if len(city) > len(longest_name): longest_name = city result.append(longest_name) return result"},{"question":"def can_form_palindrome(n: int, s: str) -> str: Determines if the given string s of length n can be rearranged to form a palindrome. >>> can_form_palindrome(3, \\"aab\\") 'yes' >>> can_form_palindrome(4, \\"abca\\") 'no' >>> can_form_palindrome(5, \\"level\\") 'yes'","solution":"def can_form_palindrome(n, s): Determines if the given string s of length n can be rearranged to form a palindrome. from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Count how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # At most one character can have an odd count for the string to be rearrangable into a palindrome return \\"yes\\" if odd_count <= 1 else \\"no\\""},{"question":"from typing import List, Tuple def min_time_to_reach_all(R: int, C: int, grid: List[str], T: int, travelers: List[Tuple[int, int, int, int]]) -> int: Determine the minimum time required for all travelers to reach their destinations, or return -1 if it's impossible. >>> R, C = 5, 5 >>> grid = [ ... \\".#...\\", ... \\".....\\", ... \\".....\\", ... \\".....\\", ... \\"...#.\\" ... ] >>> T = 3 >>> travelers = [(0, 0, 4, 4), (1, 1, 2, 2), (3, 0, 0, 4)] >>> min_time_to_reach_all(R, C, grid, T, travelers) 8 >>> R, C = 3, 3 >>> grid = [ ... \\"#\\", ... \\"#.#\\", ... \\"#\\" ... ] >>> T = 1 >>> travelers = [(1, 0, 1, 2)] >>> min_time_to_reach_all(R, C, grid, T, travelers) -1","solution":"from collections import deque def min_time_to_reach_all(R, C, grid, T, travelers): def bfs(start, end): si, sj = start di, dj = end if grid[si][sj] == '#' or grid[di][dj] == '#': return float('inf') directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(si, sj, 0)]) # (row, col, distance) visited = [[False] * C for _ in range(R)] visited[si][sj] = True while queue: x, y, dist = queue.popleft() if (x, y) == (di, dj): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return float('inf') max_time = 0 for si, sj, di, dj in travelers: travel_time = bfs((si, sj), (di, dj)) if travel_time == float('inf'): return -1 max_time = max(max_time, travel_time) return max_time"},{"question":"def find_pair(arr, n, k): Returns True if there exists two elements in arr whose difference is exactly equal to k. Otherwise, returns False. >>> find_pair([1, 5, 3, 4, 2], 5, 3) True >>> find_pair([1, 20, 14, 3, 6, 7], 6, 10) False","solution":"def find_pair(arr, n, k): Returns True if there exists two elements in arr whose difference is exactly equal to k. Otherwise, returns False. # Using a set to store elements elements_set = set() for num in arr: if (num + k) in elements_set or (num - k) in elements_set: return True elements_set.add(num) return False"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(data) def build(self, data): # Fill the leaves of the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): # Set value at position pos pos += self.n self.tree[pos] += value # Update the tree upwards while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): # Get the maximum value in the interval [left, right) result = -float('inf') left += self.n right += self.n + 1 while left < right: if left % 2: result = max(result, self.tree[left]) left += 1 if right % 2: right -= 1 result = max(result, self.tree[right]) left //= 2 right //= 2 return result def process_operations(n, m, data, operations): Perform operations on a list of numbers and return the results of the queries. >>> process_operations(5, 5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 10), (2, 1, 3), (2, 2, 5), (1, 3, 1)]) [3, 12, 12] >>> process_operations(8, 6, [1, 2, 3, 4, 5, 6, 7, 8], [(2, 1, 8), (1, 4, 5), (2, 4, 4), (2, 4, 5), (2, 1, 8), (2, 5, 8)]) [8, 9, 9, 9, 8] >>> process_operations(5, 6, [10, 20, 30, 40, 50], [(2, 1, 5), (1, 1, 20), (1, 3, 50), (2, 1, 3), (1, 5, 10), (2, 4, 5)]) [50, 80, 60]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(data) def build(self, data): # Fill the leaves of the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, pos, value): # Set value at position pos pos += self.n self.tree[pos] += value # Update the tree upwards while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left, right): # Get the maximum value in the interval [left, right) result = -float('inf') left += self.n right += self.n + 1 while left < right: if left % 2: result = max(result, self.tree[left]) left += 1 if right % 2: right -= 1 result = max(result, self.tree[right]) left //= 2 right //= 2 return result def process_operations(n, m, data, operations): seg_tree = SegmentTree(data) results = [] for op in operations: if op[0] == 1: _, x, v = op seg_tree.update(x - 1, v) elif op[0] == 2: _, l, r = op result = seg_tree.query(l - 1, r - 1) results.append(result) return results"},{"question":"def calculate_k(matrix: List[List[int]], N: int) -> int: Calculate the value of K based on the given NxN matrix. The value of K is calculated by summing up the products of the sums of each row and each column in the matrix. Args: matrix: A list of lists of integers representing the NxN matrix. N: An integer representing the dimensions of the matrix. Returns: The value of K modulo (10^9 + 7). Example: >>> calculate_k([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ], 3) 2025 >>> calculate_k([[1]], 1) 1 >>> calculate_k([ ... [1000000000, 1000000000], ... [1000000000, 1000000000] ... ], 2) 999999993 >>> calculate_k([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ], 3) 81 >>> calculate_k([ ... [1000000000, 1], ... [1, 1000000000] ... ], 2) 0","solution":"def calculate_k(matrix, N): MOD = 10**9 + 7 row_sums = [sum(row) for row in matrix] col_sums = [sum(col) for col in zip(*matrix)] sum_rows = sum(row_sums) % MOD sum_cols = sum(col_sums) % MOD K = (sum_rows * sum_cols) % MOD return K"},{"question":"def compute_grade(average_score): Determine the letter grade based on the average score. >>> compute_grade(95) 'A' >>> compute_grade(85) 'B' >>> compute_grade(75) 'C' >>> compute_grade(65) 'D' >>> compute_grade(55) 'F' # Implement this function def generate_report_card(t, students_data): Generate report card for each student based on the input data. Args: t (int): Number of students. students_data (list[dict]): List of dictionaries, each containing the name of the student and their respective scores. Returns: list[str]: List of strings, each representing the report card of a student. >>> students_data = [ ... { \\"name\\": \\"Alice\\", \\"scores\\": [85, 92, 78] }, ... { \\"name\\": \\"Bob\\", \\"scores\\": [70, 65, 80, 90] } ... ] >>> generate_report_card(2, students_data) ['Alicen85 B', 'Bobn76 C'] # Implement this function def test_compute_grade(): assert compute_grade(95) == \\"A\\" assert compute_grade(85) == \\"B\\" assert compute_grade(75) == \\"C\\" assert compute_grade(65) == \\"D\\" assert compute_grade(55) == \\"F\\" def test_generate_report_card(): students_data = [ { \\"name\\": \\"Alice\\", \\"scores\\": [85, 92, 78] }, { \\"name\\": \\"Bob\\", \\"scores\\": [70, 65, 80, 90] } ] results = generate_report_card(2, students_data) assert results == [\\"Alicen85 B\\", \\"Bobn76 C\\"] # additional test case students_data = [ { \\"name\\": \\"Charlie\\", \\"scores\\": [100, 90, 95, 85] }, { \\"name\\": \\"David\\", \\"scores\\": [50, 55, 60] } ] results = generate_report_card(2, students_data) assert results == [\\"Charlien92 A\\", \\"Davidn55 F\\"]","solution":"def compute_grade(average_score): Determines the grade based on the average_score. if average_score >= 90: return \\"A\\" elif average_score >= 80: return \\"B\\" elif average_score >= 70: return \\"C\\" elif average_score >= 60: return \\"D\\" else: return \\"F\\" def generate_report_card(t, students_data): Generates report card for each student based on the input data. results = [] for student_data in students_data: name = student_data['name'] scores = student_data['scores'] average_score = sum(scores) // len(scores) grade = compute_grade(average_score) results.append(f\\"{name}n{average_score} {grade}\\") return results"},{"question":"def num_valid_parentheses(n: int) -> int: Determine the number of distinct well-formed parenthetical expressions that can be constructed using exactly n pairs of parentheses. >>> num_valid_parentheses(1) 1 >>> num_valid_parentheses(2) 2 >>> num_valid_parentheses(3) 5 >>> num_valid_parentheses(4) 14","solution":"def num_valid_parentheses(n): from math import comb return comb(2 * n, n) // (n + 1)"},{"question":"def findPivot(arr, n): Finds the index of the smallest element (pivot) in a rotated sorted array. Parameters: arr (list of int): The rotated sorted array. n (int): The size of the array. Returns: int: The index of the smallest element in the array. pass # Unit tests def test_example1(): assert findPivot([4, 5, 1, 2, 3], 5) == 2 def test_example2(): assert findPivot([7, 9, 11, 12, 15, 1, 3], 7) == 5 def test_sorted_array(): assert findPivot([1, 2, 3, 4, 5, 6, 7], 7) == 0 def test_rotated_once(): assert findPivot([7, 1, 2, 3, 4, 5, 6], 7) == 1 def test_single_element(): assert findPivot([1], 1) == 0 def test_all_equal_elements(): assert findPivot([2, 2, 2, 2, 2, 2, 2], 7) == 0 def test_large_numbers(): assert findPivot([1000000, -1000000, -999999, -999998], 4) == 1","solution":"def findPivot(arr, n): Finds the index of the smallest element (pivot) in a rotated sorted array. Parameters: arr (list of int): The rotated sorted array. n (int): The size of the array. Returns: int: The index of the smallest element in the array. low, high = 0, n - 1 while low < high: mid = (low + high) // 2 if arr[mid] > arr[high]: low = mid + 1 else: high = mid return low"},{"question":"def maxRectangleArea(heights: List[int]) -> int: Given a list of integers representing the heights of buildings in a city skyline, determine the maximum area of a rectangle in the skyline that can be formed using these buildings. The width of each building is 1 unit. Args: heights: List[int] - List of integers representing the heights of buildings Returns: int - Maximum rectangular area Example: >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> maxRectangleArea([3, 3, 3, 3]) 12 from typing import List def test_max_rectangle_area_with_simple_case(): heights = [2, 1, 5, 6, 2, 3] assert maxRectangleArea(heights) == 10 def test_max_rectangle_area_with_uniform_heights(): heights = [3, 3, 3, 3] assert maxRectangleArea(heights) == 12 def test_max_rectangle_area_with_decreasing_heights(): heights = [6, 5, 4, 3, 2, 1] assert maxRectangleArea(heights) == 12 def test_max_rectangle_area_with_single_building(): heights = [4] assert maxRectangleArea(heights) == 4 def test_max_rectangle_area_with_no_buildings(): heights = [] assert maxRectangleArea(heights) == 0 def test_max_rectangle_area_with_all_zeros(): heights = [0, 0, 0, 0] assert maxRectangleArea(heights) == 0 def test_max_rectangle_area_with_mixed_values(): heights = [1, 3, 2, 1, 2] assert maxRectangleArea(heights) == 5","solution":"def maxRectangleArea(heights): Returns the maximum area of a rectangle formed by the buildings in the skyline. :param heights: List[int] - List of integers representing the heights of buildings :return: int - Maximum rectangular area stack = [] max_area = 0 heights.append(0) # Append a zero to handle the end of the list index = 0 while index < len(heights): # Push the current building index into the stack if stack is empty or # current building is taller than the building represented by the index on the top of stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top height from the stack and calculate the area height = heights[stack.pop()] width = index if not stack else index - stack[-1] - 1 max_area = max(max_area, height * width) heights.pop() # Restore the original list return max_area"},{"question":"def max_non_adjacent_sum(arr): Function to find the maximum sum of a non-empty subarray with the constraint that no two elements of the subarray are adjacent in the original array. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8","solution":"def max_non_adjacent_sum(arr): Function to find the maximum sum of a non-empty subarray with the constraint that no two elements of the subarray are adjacent in the original array. if not arr: return 0 if len(arr) == 1: return arr[0] incl = 0 # Sum including the current element excl = 0 # Sum excluding the current element for num in arr: new_excl = max(incl, excl) incl = excl + num excl = new_excl return max(incl, excl) # Reading input function def read_input(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) arr = list(map(int, data[1:])) return arr # Main function if __name__ == '__main__': arr = read_input() print(max_non_adjacent_sum(arr))"},{"question":"from typing import List def is_wiggle_sequence(arr: List[int]) -> bool: Check whether a given array is a wiggle sequence. Args: arr (List[int]): List of integers representing the array. Returns: bool: True if the array is a wiggle sequence, False otherwise. >>> is_wiggle_sequence([1, 7, 4, 9, 2, 5]) True >>> is_wiggle_sequence([1, 4, 7, 2, 5]) False def wiggle_test_cases(T: int, arrays: List[List[int]]) -> List[bool]: For each test case, output \\"True\\" if the array is a wiggle sequence, and \\"False\\" otherwise. Args: T (int): Number of test cases. arrays (List[List[int]]): List containing T arrays of integers. Returns: List[bool]: List of results for each test case, True if the array is a wiggle sequence and False otherwise. >>> T = 2 >>> arrays = [[1, 7, 4, 9, 2, 5], [1, 4, 7, 2, 5]] >>> wiggle_test_cases(T, arrays) [True, False]","solution":"def is_wiggle_sequence(arr): if len(arr) < 2: return True prev_diff = arr[1] - arr[0] for i in range(2, len(arr)): diff = arr[i] - arr[i-1] if prev_diff == 0 or diff == 0 or (prev_diff > 0 and diff > 0) or (prev_diff < 0 and diff < 0): return False prev_diff = diff return True def wiggle_test_cases(T, arrays): results = [] for arr in arrays: results.append(is_wiggle_sequence(arr)) return results"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(10) == 55 >>> fibonacci(20) == 6765 >>> fibonacci(30) == 832040 >>> fibonacci(50) == 12586269025","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"from typing import List def count_valid_permutations(strings: List[str]) -> int: Determine how many ways there are to rearrange objects so that no two objects starting with the same letter are next to each other. >>> count_valid_permutations([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) 24 >>> count_valid_permutations([\\"pear\\", \\"peach\\", \\"plum\\"]) 0","solution":"from itertools import permutations def count_valid_permutations(strings): n = len(strings) if n == 1: return 1 first_chars = [s[0] for s in strings] if len(set(first_chars)) < n: return 0 valid_permutations = 0 for perm in permutations(strings): valid = True for i in range(1, n): if perm[i][0] == perm[i-1][0]: valid = False break if valid: valid_permutations += 1 return valid_permutations"},{"question":"def max_fully_grown_crops(M: int, N: int, initial_grid: List[str]) -> int: Return the maximum number of fully grown crops that can be obtained in a given MxN field by altering the field configuration. >>> max_fully_grown_crops(3, 3, [\\"C.C\\", \\".C.\\", \\"C.C\\"]) 4 >>> max_fully_grown_crops(1, 1, [\\".\\"]) 0","solution":"def max_fully_grown_crops(M, N, initial_grid): Returns the maximum number of fully grown crops that can be obtained in a given MxN field by altering the field configuration. def count_adjacent(field, i, j): count = 0 if i > 0 and field[i-1][j] == 'C': # North count += 1 if i < M-1 and field[i+1][j] == 'C': # South count += 1 if j > 0 and field[i][j-1] == 'C': # West count += 1 if j < N-1 and field[i][j+1] == 'C': # East count += 1 return count # Fill the entire grid with crops grid = [['C' for _ in range(N)] for _ in range(M)] # Count fully grown crops fully_grown_count = 0 for i in range(M): for j in range(N): if count_adjacent(grid, i, j) == 3: fully_grown_count += 1 return fully_grown_count # Example Usage if __name__ == \\"__main__\\": M, N = 3, 3 initial_grid = [\\"C.C\\", \\".C.\\", \\"C.C\\"] print(max_fully_grown_crops(M, N, initial_grid)) # Output should be 4"},{"question":"def unique_string_generator(n: int) -> str: Generates the first n character-long string that contains all unique characters from the English alphabet. >>> unique_string_generator(5) # => \\"abcde\\" >>> unique_string_generator(27) # => \\"abcdef...","solution":"def unique_string_generator(n): Generates the first n character-long string that contains all unique characters from the English alphabet. alphabet = \\"abcdefghijklmnopqrstuvwxyz\\" result = [] full_repeats = n // 26 remainder = n % 26 result.extend(alphabet * full_repeats) result.extend(alphabet[:remainder]) return \\"\\".join(result)"},{"question":"def generate_invite(template: str, details: dict) -> str: Generates a personalized invitation message based on the template and details provided. >>> template = \\"Hi {name}, you are invited to a party on {date} at {venue}. It starts at {time}.\\" >>> details = { >>> \\"name\\": \\"Alice\\", >>> \\"date\\": \\"12th October\\", >>> \\"time\\": \\"7 PM\\", >>> \\"venue\\": \\"Wonderland\\", >>> \\"RSVP\\": True, >>> } >>> generate_invite(template, details) 'Hi Alice, you are invited to a party on 12th October at Wonderland. It starts at 7 PM. Please RSVP.'","solution":"def generate_invite(template: str, details: dict) -> str: Generates a personalized invitation message based on the template and details provided. Parameters: template (str): A string containing the invitation template with placeholders. details (dict): A dictionary with keys as placeholders (without curly braces) and values as their replacements. Returns: str: The personalized invitation message. # Replace the placeholders in the template with actual details for key, value in details.items(): placeholder = \\"{\\" + key + \\"}\\" template = template.replace(placeholder, str(value)) # If details contains RSVP and it is set to True, add \\"Please RSVP\\" at the end if details.get(\\"RSVP\\", False): template += \\" Please RSVP.\\" return template"},{"question":"def generate_spiral_matrix(n): Generates an n x n spiral matrix filled with numbers from 1 to n^2 in a spiral order. Parameters: n (int): The size of the spiral matrix (1 â‰¤ n â‰¤ 500). Returns: List[List[int]]: The generated spiral matrix as a list of lists. Examples: >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] # Your code here # Unit tests def test_spiral_matrix_3x3(): expected = [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] assert generate_spiral_matrix(3) == expected def test_spiral_matrix_4x4(): expected = [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] assert generate_spiral_matrix(4) == expected def test_spiral_matrix_1x1(): expected = [ [1] ] assert generate_spiral_matrix(1) == expected def test_spiral_matrix_2x2(): expected = [ [1, 2], [4, 3] ] assert generate_spiral_matrix(2) == expected def test_spiral_matrix_5x5(): expected = [ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ] assert generate_spiral_matrix(5) == expected def test_invalid_n_less_than_1(): try: generate_spiral_matrix(0) except ValueError as e: assert str(e) == \\"n must be between 1 and 500 inclusive.\\" def test_invalid_n_greater_than_500(): try: generate_spiral_matrix(501) except ValueError as e: assert str(e) == \\"n must be between 1 and 500 inclusive.\\"","solution":"def generate_spiral_matrix(n): Generates an n x n spiral matrix filled with numbers from 1 to n^2 in a spiral order. if n < 1 or n > 500: raise ValueError(\\"n must be between 1 and 500 inclusive.\\") matrix = [[0] * n for _ in range(n)] num = 1 top, bottom, left, right = 0, n - 1, 0, n - 1 while top <= bottom and left <= right: for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def is_integer_when_divided_by_power_of_two(n: int) -> str: Determines if the product of all integers from 1 to n, divided by 2^n, is an integer. >>> is_integer_when_divided_by_power_of_two(1) \\"Yes\\" >>> is_integer_when_divided_by_power_of_two(5) \\"No\\" >>> is_integer_when_divided_by_power_of_two(10) \\"No\\"","solution":"def is_integer_when_divided_by_power_of_two(n): Determines if the product of all integers from 1 to n, divided by 2^n, is an integer. # Simply, if n > 1, the product will have fewer factors of 2 than 2^n, # except for when n = 1. return \\"Yes\\" if n == 1 else \\"No\\""},{"question":"def can_sort_array(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if the array can be sorted in non-decreasing order using the specified operations. >>> can_sort_array(2, [(5, [4, 3, 2, 5, 1]), (4, [2, 2, 1, 1])]) [\\"YES\\", \\"NO\\"] >>> can_sort_array(3, [(3, [1, 2, 3]), (3, [3, 3, 3]), (5, [5, 4, 3, 2, 1])]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_sort_array(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] if len(A) != len(set(A)): # The array has at least one duplicate results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def compress(s: str) -> str: Compresses the given string by replacing repeated characters with the character followed by its count. >>> compress(\\"aaabbbcccc\\") 'a3b3c4' >>> compress(\\"abcd\\") 'a1b1c1d1' >>> compress(\\"aa\\") 'a2' >>> compress(\\"aabbcc\\") 'a2b2c2' >>> compress(\\"a\\") 'a1' pass","solution":"def compress(s: str) -> str: Compresses the given string by replacing repeated characters with the character followed by its count. if not s: return \\"\\" compressed = [] count = 1 current_char = s[0] for char in s[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{current_char}{count}\\") current_char = char count = 1 # Append the last character and its count compressed.append(f\\"{current_char}{count}\\") return ''.join(compressed)"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Merges overlapping intervals from a list of intervals. >>> merge_intervals([(1, 3), (2, 6), (8, 10)]) [(1, 6), (8, 10)] >>> merge_intervals([(1, 4), (4, 5), (3, 6), (7, 8)]) [(1, 6), (7, 8)] >>> merge_intervals([(1, 2), (3, 5)]) [(1, 2), (3, 5)]","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] merged_intervals = [intervals[0]] for current in intervals[1:]: prev_start, prev_end = merged_intervals[-1] current_start, current_end = current if current_start <= prev_end: merged_intervals[-1] = (prev_start, max(prev_end, current_end)) else: merged_intervals.append(current) return merged_intervals"},{"question":"MOD = 1000000007 def matrix_mult(A, B, mod=MOD): return [ [ (A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod, ], [ (A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod, ] ] def matrix_pow(M, n, mod=MOD): Compute the nth power of the matrix M mod 1000000007. >>> matrix_exponentiation(2, 3, 4, 5, 2) (16, 21, 28, 37) >>> matrix_exponentiation(1, 1, 1, 0, 5) (8, 5, 5, 3) result = [[1, 0], [0, 1]] # Identity matrix base = M while n > 0: if n % 2 == 1: result = matrix_mult(result, base, mod) base = matrix_mult(base, base, mod) n //= 2 return result def matrix_exponentiation(a, b, c, d, n): Raise a given 2x2 matrix to the nth power and return the resulting matrix mod 1000000007. M = [[a, b], [c, d]] result = matrix_pow(M, n) return result[0][0], result[0][1], result[1][0], result[1][1] # Example Unit Test def test_matrix_exponentiation(): assert matrix_exponentiation(2, 3, 4, 5, 2) == (16, 21, 28, 37) assert matrix_exponentiation(1, 1, 1, 0, 5) == (8, 5, 5, 3) assert matrix_exponentiation(1, 0, 0, 1, 1000000000000000000) == (1, 0, 0, 1) a, b, c, d = 1000000000, 1000000000, 1000000000, 1000000000 n = 100000 result = matrix_exponentiation(a, b, c, d, n) assert len(result) == 4 assert matrix_exponentiation(2, 3, 4, 5, 0) == (1, 0, 0, 1)","solution":"MOD = 1000000007 def matrix_mult(A, B, mod=MOD): return [ [ (A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod, ], [ (A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod, ] ] def matrix_pow(M, n, mod=MOD): result = [[1, 0], [0, 1]] # Identity matrix base = M while n > 0: if n % 2 == 1: result = matrix_mult(result, base, mod) base = matrix_mult(base, base, mod) n //= 2 return result def matrix_exponentiation(a, b, c, d, n): M = [[a, b], [c, d]] result = matrix_pow(M, n) return result[0][0], result[0][1], result[1][0], result[1][1] # Example usage a, b, c, d = 2, 3, 4, 5 n = 2 print(matrix_exponentiation(a, b, c, d, n))"},{"question":"def longest_contiguous_subsequence_lengths(s: str) -> Dict[str, int]: Returns a dictionary with the lengths of the longest contiguous subsequence for each character in the string s. >>> longest_contiguous_subsequence_lengths(\\"abcdddeee\\") {'a': 1, 'b': 1, 'c': 1, 'd': 3, 'e': 3} >>> longest_contiguous_subsequence_lengths(\\"abbbccccc\\") {'a': 1, 'b': 3, 'c': 5} >>> longest_contiguous_subsequence_lengths(\\"zzzyyyxxyz\\") {'z': 3, 'y': 3, 'x': 2}","solution":"def longest_contiguous_subsequence_lengths(s): Returns a dictionary with the lengths of the longest contiguous subsequence for each character in the string s. max_lengths = {} current_char = '' current_length = 0 for char in s: if char == current_char: current_length += 1 else: if current_char: max_lengths[current_char] = max(max_lengths.get(current_char, 0), current_length) current_char = char current_length = 1 if current_char: max_lengths[current_char] = max(max_lengths.get(current_char, 0), current_length) return max_lengths"},{"question":"def find_minimum_rectangular_grid(photo: List[List[int]]) -> Tuple[int, int]: Given an m x n grid containing unique integers representing pixels, this function finds the minimum size of a rectangular grid that can contain all the unique pixel values. >>> find_minimum_rectangular_grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (3, 3) >>> find_minimum_rectangular_grid([[1, 1, 1], [1, 1, 1]]) (1, 1)","solution":"def find_minimum_rectangular_grid(photo): Given an m x n grid containing unique integers representing pixels, this function finds the minimum size of a rectangular grid that can contain all the unique pixel values. unique_pixel_set = set() for row in photo: for pixel in row: unique_pixel_set.add(pixel) unique_pixel_count = len(unique_pixel_set) # Minimum grid size should be large enough to hold all unique pixels min_r = min_c = 1 while min_r * min_c < unique_pixel_count: if min_r <= min_c: min_r += 1 else: min_c += 1 return min_r, min_c if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() m = int(data[0]) n = int(data[1]) photo = [] idx = 2 for _ in range(m): row = list(map(int, data[idx:idx+n])) photo.append(row) idx += n min_r, min_c = find_minimum_rectangular_grid(photo) print(f\\"{min_r} {min_c}\\")"},{"question":"def has_duplicates(n: int, lst: List[int]) -> str: Given a list of integers, determine if the list contains any duplicates or not. If the list contains one or more duplicates, return \\"YES\\". Otherwise, return \\"NO\\". Args: n : int : number of elements in the list lst : list of int : list of integers Returns: str : \\"YES\\" if there are duplicates in the list, otherwise \\"NO\\" >>> has_duplicates(6, [12, 34, -5, 12, 6, 7]) \\"YES\\" >>> has_duplicates(4, [-1, -2, -3, -4]) \\"NO\\"","solution":"def has_duplicates(n, lst): Determines if the list contains any duplicates. Args: n : int : number of elements in the list lst : list of int : list of integers Returns: str : \\"YES\\" if there are duplicates, otherwise \\"NO\\" if len(set(lst)) < n: return \\"YES\\" else: return \\"NO\\""},{"question":"def last_remaining(n: int, k: int) -> int: Determines the last person remaining in the circle given n friends and count-off number k. Parameters: n (int): The number of friends standing in the circle. k (int): The count-off number. Returns: int: The 1-based position of the last person remaining in the circle. >>> last_remaining(5, 2) 3 >>> last_remaining(7, 3) 4","solution":"def last_remaining(n, k): Determines the last person remaining in the circle given n friends and count-off number k. Parameters: n (int): The number of friends standing in the circle. k (int): The count-off number. Returns: int: The 1-based position of the last person remaining in the circle. circle = list(range(1, n + 1)) index = 0 while len(circle) > 1: index = (index + k - 1) % len(circle) circle.pop(index) return circle[0]"},{"question":"def balance_parentheses(s: str) -> bool: Determines if the input string of parentheses, brackets, and braces is valid. >>> balance_parentheses(\\"()\\") True >>> balance_parentheses(\\"()[]{}\\") True >>> balance_parentheses(\\"(]\\") False >>> balance_parentheses(\\"([)]\\") False >>> balance_parentheses(\\"{[]}\\") True","solution":"def balance_parentheses(s: str) -> bool: Determines if the input string of parentheses, brackets, and braces is valid. Args: s (str): The input string containing '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the input string is valid, False otherwise. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or stack.pop() != matching_bracket[char]: return False else: return False return stack == []"},{"question":"def max_product_of_two(numbers): Given a list of non-negative integers, returns the maximum product of two distinct numbers from the list. >>> max_product_of_two([1, 20, 30, 40]) 1200 >>> max_product_of_two([0, 0, 1, 2]) 2 >>> max_product_of_two([5, 5, 5, 5]) 25 >>> max_product_of_two([1000000000, 999999999, 1, 2]) 999999999000000000 >>> max_product_of_two([1, 2]) 2","solution":"def max_product_of_two(numbers): Given a list of non-negative integers, returns the maximum product of two distinct numbers from the list. if len(numbers) < 2: raise ValueError(\\"There must be at least two numbers to calculate a product.\\") # Sorting in reverse order to get the two largest numbers efficiently numbers.sort(reverse=True) # Maximum product will be the product of the two largest numbers after sorting return numbers[0] * numbers[1]"},{"question":"def smallest_difference(n: int, diameters: List[int]) -> int: Returns the smallest absolute difference in diameters between any pair of pipes. >>> smallest_difference(5, [8, 1, 5, 3, 6]) 1 >>> smallest_difference(3, [10, 15, 20]) 5 >>> smallest_difference(4, [4, 2, 7, 4]) 0","solution":"def smallest_difference(n, diameters): Returns the smallest absolute difference in diameters between any pair of pipes. if n < 2: return -1 # Not a valid case since we need at least 2 pipes diameters.sort() min_diff = float('inf') for i in range(1, n): diff = abs(diameters[i] - diameters[i - 1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def sum_of_squares_of_digits(n: int) -> int: Returns the sum of the squares of the digits of a given number n. >>> sum_of_squares_of_digits(19) 82 >>> sum_of_squares_of_digits(82) 68 >>> sum_of_squares_of_digits(68) 100 >>> sum_of_squares_of_digits(100) 1 pass def is_happy_number(n: int) -> bool: Determines if a number n is a happy number. >>> is_happy_number(19) True >>> is_happy_number(2) False >>> is_happy_number(7) True >>> is_happy_number(1) True >>> is_happy_number(0) False pass def number_chains(test_cases: List[int]) -> List[str]: Given a list of numbers, determines if each number is a happy number or not. For each number, returns \\"YES\\" if the number is a happy number, otherwise \\"NO\\". >>> number_chains([19, 2, 7]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> number_chains([1, 2, 3]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> number_chains([19, 89, 100]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> number_chains([1000000000]) [\\"YES\\"] >>> number_chains([999999999]) [\\"NO\\"] pass","solution":"def sum_of_squares_of_digits(n): Returns the sum of the squares of the digits of a given number n. return sum(int(digit) ** 2 for digit in str(n)) def is_happy_number(n): Determines if a number n is a happy number. seen = set() while n != 1 and n not in seen: seen.add(n) n = sum_of_squares_of_digits(n) return n == 1 def number_chains(test_cases): Given a list of numbers, determines if each number is a happy number or not. For each number, returns \\"YES\\" if the number is a happy number, otherwise \\"NO\\". results = [] for number in test_cases: if is_happy_number(number): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def filter_odd_even(numbers, option): This function takes in a list of integers \`numbers\` and a string \`option\`. If \`option\` is 'odd', return a list of all odd integers from the \`numbers\` list. If \`option\` is 'even', return a list of all even integers from the \`numbers\` list. If \`option\` is neither 'odd' nor 'even', return an empty list. Args: numbers: List of integers option: A string, either 'odd' or 'even' Returns: List of integers filtered based on the \`option\` parameter. # Your code here. # Test cases def test_filter_odd_even_odd_numbers(): assert filter_odd_even([1, 2, 3, 4, 5, 6], 'odd') == [1, 3, 5] def test_filter_odd_even_even_numbers(): assert filter_odd_even([1, 2, 3, 4, 5, 6], 'even') == [2, 4, 6] def test_filter_odd_even_odd_numbers_2(): assert filter_odd_even([7, 8, 9, 10, 11, 12], 'odd') == [7, 9, 11] def test_filter_odd_even_even_numbers_2(): assert filter_odd_even([7, 8, 9, 10, 11, 12], 'even') == [8, 10, 12] def test_filter_odd_even_invalid_option(): assert filter_odd_even([7, 8, 9, 10, 11, 12], 'prime') == [] def test_filter_odd_even_empty_list(): assert filter_odd_even([], 'odd') == [] assert filter_odd_even([], 'even') == [] def test_filter_odd_even_mixed_single_element_list(): assert filter_odd_even([1], 'odd') == [1] assert filter_odd_even([1], 'even') == [] assert filter_odd_even([2], 'odd') == [] assert filter_odd_even([2], 'even') == [2] def test_filter_odd_even_all_even_numbers(): assert filter_odd_even([2, 4, 6], 'even') == [2, 4, 6] assert filter_odd_even([2, 4, 6], 'odd') == [] def test_filter_odd_even_all_odd_numbers(): assert filter_odd_even([1, 3, 5], 'odd') == [1, 3, 5] assert filter_odd_even([1, 3, 5], 'even') == []","solution":"def filter_odd_even(numbers, option): This function takes in a list of integers \`numbers\` and a string \`option\`. If \`option\` is 'odd', return a list of all odd integers from the \`numbers\` list. If \`option\` is 'even', return a list of all even integers from the \`numbers\` list. If \`option\` is neither 'odd' nor 'even', return an empty list. Args: numbers: List of integers option: A string, either 'odd' or 'even' Returns: List of integers filtered based on the \`option\` parameter. if option == 'odd': return [num for num in numbers if num % 2 != 0] elif option == 'even': return [num for num in numbers if num % 2 == 0] else: return []"},{"question":"def longest_substring(s: str) -> int: Given a string, return the length of the longest substring that contains at most two distinct characters. >>> longest_substring(\\"eceba\\") 3 >>> longest_substring(\\"ccaabbb\\") 5 >>> longest_substring(\\"a\\") 1 >>> longest_substring(\\"abaccc\\") 4","solution":"def longest_substring(s): Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 2: return n left = 0 right = 0 max_len = 0 char_map = {} while right < n: char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def rotate_list(integers: list, k: int) -> list: Rotates the list to the right by k steps. Parameters: integers (list): a list of integers k (int): the number of steps to rotate the list Returns: list: a rotated list of integers >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_list([1], 3) [1] pass # Implementation here","solution":"def rotate_list(integers, k): Rotates the list to the right by k steps. Parameters: integers (list): a list of integers k (int): the number of steps to rotate the list Returns: list: a rotated list of integers n = len(integers) k = k % n # to manage cases where k is greater than the length of the list return integers[-k:] + integers[:-k]"},{"question":"def second_largest(numbers: List[int]) -> int: Returns the second largest integer in the list of numbers. Assumes the list has at least two unique integers. >>> second_largest([3, 1, 4, 1, 5, 9, 2, 6, 5]) 6 >>> second_largest([1, 2]) 1 >>> second_largest([-10, -20, -30, -40, -50]) -20 >>> second_largest([-1, 1, 0]) 0 >>> second_largest([1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5]) 4","solution":"def second_largest(numbers): Returns the second largest integer in the list of numbers. Assumes the list has at least two unique integers. first, second = float('-inf'), float('-inf') for num in numbers: if num > first: first, second = num, first elif first > num > second: second = num return second"},{"question":"from typing import List def kmp_search(text: str, pattern: str) -> List[int]: Implements the Knuth-Morris-Pratt (KMP) string matching algorithm. The function searches for all occurrences of 'pattern' in 'text' and returns the starting indices of each occurrence. If the pattern is not found, the function returns an empty list. Args: text (str): The text in which to search for the pattern. pattern (str): The pattern to search for. Returns: List[int]: A list of starting indices of all occurrences of 'pattern' in 'text'. Examples: >>> kmp_search(\\"ababcabcabababd\\", \\"ababd\\") [10] >>> kmp_search(\\"aaaaa\\", \\"aa\\") [0, 1, 2, 3]","solution":"from typing import List def kmp_search(text: str, pattern: str) -> List[int]: if not text or not pattern: return [] def compute_lps(pattern: str) -> List[int]: Compute the longest prefix suffix (LPS) array used by KMP algorithm. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"def max_golden_leaves(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum number of golden leaves Aiko can collect during her journey from the top-left corner to the bottom-right corner of the forest grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): A grid where each cell contains a certain number of golden leaves. Returns: int: Maximum number of golden leaves collected. Examples: >>> max_golden_leaves(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_golden_leaves(1, 1, [[7]]) 7 >>> max_golden_leaves(1, 4, [[1, 2, 3, 4]]) 10 >>> max_golden_leaves(4, 1, [ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> max_golden_leaves(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> max_golden_leaves(3, 3, [ ... [5, 3, 1], ... [3, 7, 4], ... [2, 8, 0] ... ]) 23 pass","solution":"def max_golden_leaves(n, m, grid): # Initialize a dp array with the same dimensions as the grid dp = [[0] * m for _ in range(n)] # Set the value of the top-left cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # Return the maximum leaves collected reaching the bottom-right corner return dp[-1][-1]"},{"question":"from typing import List, Dict def count_messages_by_location(messages: List[str]) -> Dict[str, int]: Parse the array of messages, identify the location tags, and generate the count of messages from each location tag. Args: messages (List[str]): List of messages with location tags. Returns: Dict[str, int]: Dictionary with location tags as keys and their counts as values. Examples: >>> count_messages_by_location([ ... \\"Message transmission initiated. [LOC:HN37]\\", ... \\"Transmission successful. [LOC:HQ29]\\", ... \\"Awaiting response from central server. [LOC:HN37]\\", ... \\"Data packet lost in transit. [LOC:FR56]\\" ... ]) {'HN37': 2, 'HQ29': 1, 'FR56': 1}","solution":"import re from collections import defaultdict def count_messages_by_location(messages): Parse the array of messages, identify the location tags, and generate the count of messages from each location tag. location_counts = defaultdict(int) location_pattern = re.compile(r\\"[LOC:([A-Z0-9]+)]\\", re.IGNORECASE) for message in messages: match = location_pattern.search(message) if match: location_tag = match.group(1).upper() location_counts[location_tag] += 1 return dict(location_counts)"},{"question":"def can_arrange_tiles(tile_rows: List[str]) -> bool: Checks if it's possible to arrange the tiles such that no two adjacent rows have any tiles of the same color directly above or below each other. >>> can_arrange_tiles(['abc', 'def', 'ghi']) True >>> can_arrange_tiles(['abcd', 'abcf']) False n = len(tile_rows) length = len(tile_rows[0]) for i in range(n - 1): for j in range(length): if tile_rows[i][j] == tile_rows[i + 1][j]: return False return True def process_input(input_data: str): Processes the input data and prints the output for each test case. >>> input_data = '3nabcndefnghin2nabcdnabcfn0' process_input(input_data) YES NO lines = input_data.strip().split(\\"n\\") index = 0 while index < len(lines): n = int(lines[index]) if n == 0: break tile_rows = [] for i in range(n): tile_rows.append(lines[index + 1 + i]) if can_arrange_tiles(tile_rows): print(\\"YES\\") else: print(\\"NO\\") index += n + 1 # Unit Tests def test_can_arrange_tiles(): assert can_arrange_tiles(['abc', 'def', 'ghi']) == True assert can_arrange_tiles(['abcd', 'abcf']) == False assert can_arrange_tiles(['a', 'b']) == True assert can_arrange_tiles(['aba', 'bab', 'aba']) == True assert can_arrange_tiles(['zz', 'zz']) == False def test_process_input(capsys): input_data = 3 abc def ghi 2 abcd abcf 0 expected_output = \\"YESnNOn\\" process_input(input_data) captured = capsys.readouterr() assert captured.out == expected_output if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def can_arrange_tiles(tile_rows): Checks if it's possible to arrange the tiles such that no two adjacent rows have any tiles of the same color directly above or below each other. Args: tile_rows (List[str]): The rows of tiles, where each row is represented by a string of lowercase letters. Returns: bool: True if it's possible to arrange the rows as described, otherwise False. n = len(tile_rows) length = len(tile_rows[0]) for i in range(n - 1): for j in range(length): if tile_rows[i][j] == tile_rows[i + 1][j]: return False return True def process_input(input_data): Processes the input data and prints the output for each test case. Args: input_data (str): The input data as a single string. lines = input_data.strip().split(\\"n\\") index = 0 while index < len(lines): n = int(lines[index]) if n == 0: break tile_rows = [] for i in range(n): tile_rows.append(lines[index + 1 + i]) if can_arrange_tiles(tile_rows): print(\\"YES\\") else: print(\\"NO\\") index += n + 1 # Example usage: input_data = 3 abc def ghi 2 abcd abcf 0 process_input(input_data)"},{"question":"def sieve(n): Return a list of primes up to n using Sieve of Eratosthenes algorithm. pass def find_prime_pairs(n): Find all unique pairs of prime numbers (p, q) such that p < q and p + q = given even number n. >>> find_prime_pairs(10) 2 (3, 7) (5, 5) >>> find_prime_pairs(18) 2 (5, 13) (7, 11) >>> find_prime_pairs(8) 1 (3, 5) >>> find_prime_pairs(4) 1 (2, 2) >>> find_prime_pairs(100) 6 (3, 97) (11, 89) (17, 83) (29, 71) (41, 59) (47, 53)","solution":"def sieve(n): Return a list of primes up to n using Sieve of Eratosthenes algorithm. is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] def find_prime_pairs(n): Find all unique pairs of prime numbers (p, q) such that p < q and p + q = n. primes = sieve(n) prime_set = set(primes) pairs = [] for p in primes: q = n - p if q in prime_set and p <= q: pairs.append((p, q)) if pairs: print(len(pairs)) for pair in pairs: print(pair) else: print(\\"No pairs found\\")"},{"question":"def process_commands(n: int, commands: List[str]) -> str: Processes a series of commands and outputs the final text. >>> process_commands(7, [\\"ADD a\\", \\"ADD b\\", \\"ADD c\\", \\"REMOVE\\", \\"ADD d\\", \\"REMOVE\\", \\"REMOVE\\"]) \\"a\\" >>> process_commands(3, [\\"ADD a\\", \\"ADD b\\", \\"ADD c\\"]) \\"abc\\" >>> process_commands(6, [\\"ADD a\\", \\"ADD b\\", \\"ADD c\\", \\"REMOVE\\", \\"REMOVE\\", \\"REMOVE\\"]) \\"\\" >>> process_commands(7, [\\"ADD x\\", \\"ADD y\\", \\"REMOVE\\", \\"ADD z\\", \\"REMOVE\\", \\"REMOVE\\", \\"ADD a\\"]) \\"a\\"","solution":"def process_commands(n, commands): text = [] for command in commands: if command.startswith(\\"ADD\\"): _, char = command.split() text.append(char) elif command == \\"REMOVE\\": text.pop() return \\"\\".join(text)"},{"question":"def palindromicNumbers(N: int) -> list: Generate a list of palindromic numbers between 1 and N (inclusive). A palindromic number is a number that remains the same when its digits are reversed. >>> palindromicNumbers(15) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11] >>> palindromicNumbers(100) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]","solution":"def palindromicNumbers(N): Returns a list of palindromic numbers between 1 and N inclusive. def is_palindrome(num): return str(num) == str(num)[::-1] palindromic_list = [i for i in range(1, N + 1) if is_palindrome(i)] return palindromic_list"},{"question":"def has_pair_with_sum(A, X): Determines if there exist two distinct elements in list A whose sum is exactly X. >>> has_pair_with_sum([10, 15, 3, 7], 17) == \\"Yes\\" >>> has_pair_with_sum([5, 7, 1], 8) == \\"Yes\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 6) == \\"Yes\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) == \\"No\\" >>> has_pair_with_sum([10, 20, 30], 100) == \\"No\\" >>> has_pair_with_sum([1, 1], 3) == \\"No\\" >>> has_pair_with_sum([10, 5, 3, 7], 14) == \\"No\\" >>> has_pair_with_sum([1, 1000], 1001) == \\"Yes\\"","solution":"def has_pair_with_sum(A, X): Determines if there exist two distinct elements in list A whose sum is exactly X. seen = set() for number in A: if X - number in seen: return \\"Yes\\" seen.add(number) return \\"No\\""},{"question":"def does_overlap(x1_1, y1_1, x2_1, y2_1, x1_2, y1_2, x2_2, y2_2) -> str: Determines if two rectangles overlap. Each rectangle is defined by its bottom-left and top-right corners. Returns \\"Yes\\" if the rectangles overlap, otherwise \\"No\\". >>> does_overlap(0, 0, 2, 2, 1, 1, 3, 3) 'Yes' >>> does_overlap(0, 0, 1, 1, 2, 2, 3, 3) 'No'","solution":"def does_overlap(x1_1, y1_1, x2_1, y2_1, x1_2, y1_2, x2_2, y2_2): Determines if two rectangles overlap. Each rectangle is defined by its bottom-left and top-right corners. Returns \\"Yes\\" if the rectangles overlap, otherwise \\"No\\". if (x1_1 >= x2_2 or x2_1 <= x1_2 or y1_1 >= y2_2 or y2_1 <= y1_2): return \\"No\\" return \\"Yes\\""},{"question":"from typing import List, Tuple def uniquePaths(R: int, C: int, blockedCells: List[Tuple[int, int]]) -> int: Find the number of distinct paths to reach the bottom-right corner of the grid from the top-left corner, avoiding blocked cells. Args: R (int): Number of rows in the grid. C (int): Number of columns in the grid. blockedCells (List[Tuple[int, int]]): A list of tuples representing blocked cells. Returns: int: The number of distinct paths modulo 10^9 + 7. >>> uniquePaths(3, 3, [(2, 2)]) 2 >>> uniquePaths(3, 3, [(1, 2), (2, 1)]) 0 >>> uniquePaths(3, 3, []) 6 >>> uniquePaths(1, 1, []) 1 >>> uniquePaths(1, 1, [(1, 1)]) 0 >>> uniquePaths(2, 2, [(1, 2)]) 1 >>> uniquePaths(2, 2, [(2, 1)]) 1 >>> uniquePaths(2, 2, [(1, 2), (2, 1)]) 0 >>> uniquePaths(100, 100, [(i, i) for i in range(1, 101)]) 0 pass # Write your code here.","solution":"def uniquePaths(R, C, blockedCells): MOD = 10**9 + 7 # Create a dp table dp = [[0] * C for _ in range(R)] # Mark blocked cells in the dp table blocked = set(blockedCells) for r, c in blockedCells: dp[r - 1][c - 1] = 0 # Initialize the starting position if not blocked if (1, 1) not in blocked: dp[0][0] = 1 # Fill the dp table for i in range(R): for j in range(C): if (i + 1, j + 1) in blocked: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] dp[i][j] %= MOD return dp[R - 1][C - 1]"},{"question":"def count_palindromic_substrings(S: str) -> int: Count the number of palindromic substrings in the given string S. >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"abc\\") 3","solution":"def count_palindromic_substrings(S): Returns the number of palindromic substrings in the given string S. n = len(S) count = 0 # Helper function to count palindromes around center def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and S[left] == S[right]: count += 1 left -= 1 right += 1 # Each character and between each pair of characters for i in range(n): # Odd length palindromes (single character center) expand_around_center(i, i) # Even length palindromes (consecutive character centers) expand_around_center(i, i + 1) return count"},{"question":"def reverse_words(s): Returns the string with each word reversed, maintaining the order of words and spaces. Test examples: >>> reverse_words(\\"Hello World\\") == \\"olleH dlroW\\" >>> reverse_words(\\"Python is fun\\") == \\"nohtyP si nuf\\" >>> reverse_words(\\" Code Review \\") == \\" edoC weiveR \\"","solution":"def reverse_words(s): Returns the string with each word reversed, maintaining the order of words and spaces. def reverse_word(word): return word[::-1] result = [] word = [] for char in s: if char == ' ': if word: result.append(reverse_word(''.join(word))) word = [] result.append(' ') else: word.append(char) if word: result.append(reverse_word(''.join(word))) return ''.join(result)"},{"question":"def min_path_cost(matrix): Computes the minimum cost to move from the top-left to the bottom-right corner of the matrix only moving right or down. Args: matrix: List of List of int: A 2D list representing the cost matrix Returns: int: The minimum path cost from top-left to bottom-right Examples: >>> min_path_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_cost([[1, 2, 3]]) 6 >>> min_path_cost([[1], [2], [3]]) 6 >>> min_path_cost([[4]]) 4 >>> min_path_cost([[1000, 1000, 1000], [1000, 1000, 1000]]) 4000","solution":"def min_path_cost(matrix): Computes the minimum cost to move from the top-left to the bottom-right corner of the matrix only moving right or down. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = matrix[0][0] # Initialize top row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize left column for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of dp table for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1] def read_input_and_compute_min_cost(): import sys input = sys.stdin.read data = input().strip().split() m = int(data[0]) n = int(data[1]) matrix = [] index = 2 for i in range(m): row = [int(data[index + j]) for j in range(n)] matrix.append(row) index += n return min_path_cost(matrix)"},{"question":"def max_subsequence_sum(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Given multiple test cases, each containing an array and a length k, find the sum of the subsequence with length k that has the maximum possible sum. Args: t: Number of test cases. test_cases: A list of tuples. Each tuple contains: - A tuple (n, k) where n is the length of the array and k is the length of the subsequence. - A list of integers which is the array. Returns: A list containing the sum of the maximum subsequence of length k for each test case. Example: >>> t = 3 >>> test_cases = [((5, 3), [1, 2, 3, 4, 5]), ((6, 2), [-1, 3, -2, 4, -5, 6]), ((4, 4), [-1, -2, -3, -4])] >>> max_subsequence_sum(t, test_cases) [12, 10, -10]","solution":"def max_subsequence_sum(t, test_cases): Given multiple test cases, each containing an array and a length k, find the sum of the subsequence with length k that has the maximum possible sum. results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] # Sort array in descending order sorted_arr = sorted(arr, reverse=True) # Take first k elements from sorted array and sum them max_sum = sum(sorted_arr[:k]) results.append(max_sum) return results"},{"question":"from typing import List def verify_password(password: str, criteria: List[str]) -> bool: Verifies if the password meets all the given criteria. Args: password (str): The password to be verified. criteria (list of strs): List of commands specifying verification criteria. Returns: bool: True if the password meets all criteria, False otherwise. >>> verify_password(\\"Pass123\\", [\\"min_length 6\\", \\"has_digit\\", \\"has_upper\\", \\"has_lower\\"]) True >>> verify_password(\\"password\\", [\\"min_length 8\\", \\"has_digit\\", \\"has_upper\\", \\"no_special\\"]) False >>> verify_password(\\"password!\\", [\\"min_length 6\\", \\"has_digit\\", \\"has_upper\\", \\"no_special\\"]) False >>> verify_password(\\"Password1\\", [\\"min_length 8\\", \\"has_digit\\", \\"has_upper\\", \\"has_lower\\"]) True import string","solution":"def verify_password(password, criteria): Verifies if the password meets all the given criteria. Args: password (str): The password to be verified. criteria (list of str): List of commands specifying verification criteria. Returns: bool: True if the password meets all criteria, False otherwise. import string for criterion in criteria: if 'min_length' in criterion: min_length = int(criterion.split()[1]) if len(password) < min_length: return False elif 'max_length' in criterion: max_length = int(criterion.split()[1]) if len(password) > max_length: return False elif criterion == 'has_digit': if not any(char.isdigit() for char in password): return False elif criterion == 'has_upper': if not any(char.isupper() for char in password): return False elif criterion == 'has_lower': if not any(char.islower() for char in password): return False elif criterion == 'no_special': if any(char in string.punctuation for char in password): return False return True"},{"question":"def playlist_summary(playlist): Calculates the total duration of a playlist and returns it in hours, minutes, and seconds. >>> playlist_summary([(4, 35), (3, 50), (2, 45), (5, 20)]) '0 hours, 16 minutes, 30 seconds' >>> playlist_summary([(2, 0)]) '0 hours, 2 minutes, 0 seconds' >>> playlist_summary([(60, 0)]) '1 hour' >>> playlist_summary([(120, 0)]) '2 hours' >>> playlist_summary([(0, 59)]) '59 seconds' >>> playlist_summary([(0, 0)]) '0 seconds' >>> playlist_summary([(65, 0)]) '1 hours, 5 minutes, 0 seconds' >>> playlist_summary([(60, 30)]) '1 hours, 0 minutes, 30 seconds' >>> playlist_summary([(1, 0), (0, 59)]) '0 hours, 1 minutes, 59 seconds' >>> playlist_summary([]) '0 seconds'","solution":"def playlist_summary(playlist): Calculates the total duration of a playlist and returns it in hours, minutes, and seconds. total_seconds = 0 for minutes, seconds in playlist: total_seconds += (minutes * 60) + seconds hours = total_seconds // 3600 total_seconds %= 3600 minutes = total_seconds // 60 seconds = total_seconds % 60 if hours > 0: if hours == 1 and minutes == 0 and seconds == 0: return '1 hour' elif minutes == 0 and seconds == 0: return f'{hours} hours' if hours == 0 and minutes == 0: return f'{seconds} seconds' return f'{hours} hours, {minutes} minutes, {seconds} seconds'"},{"question":"def distinctDollarAmounts(n: int, prices: List[int]) -> int: Determine the number of distinct dollar amounts that can be made by summing the prices of some subset of the gifts. Args: n (int): the number of gifts. prices (list of int): the prices of the gifts. Returns: int: the number of distinct dollar amounts that can be made. Examples: >>> distinctDollarAmounts(4, [3, 4, 2, 1]) 11 >>> distinctDollarAmounts(2, [1, 2]) 4 >>> distinctDollarAmounts(0, []) 1","solution":"def distinctDollarAmounts(n, prices): Determine the number of distinct dollar amounts that can be made by summing the prices of some subset of the gifts. Args: n (int): the number of gifts. prices (list of int): the prices of the gifts. Returns: int: the number of distinct dollar amounts that can be made. # Use a set to store the distinct dollar amounts possible_sums = {0} for price in prices: new_sums = set() for psum in possible_sums: new_sums.add(psum + price) possible_sums.update(new_sums) return len(possible_sums)"},{"question":"def is_playlist_possible(n, k, durations, types): Check if a playlist can be created such that no more than k consecutive fast-paced or slow-paced songs play. :param n: The number of songs :param k: The maximum number of consecutive fast-paced or slow-paced songs allowed :param durations: The list of song durations :param types: The list of song types ('F' for fast-paced and 'S' for slow-paced) :return: \\"POSSIBLE\\" if such a playlist can be arranged, otherwise \\"IMPOSSIBLE\\". >>> is_playlist_possible(3, 2, [4, 5, 3], ['F', 'S', 'F']) \\"POSSIBLE\\" >>> is_playlist_possible(4, 1, [2, 3, 5, 6], ['F', 'F', 'S', 'S']) \\"IMPOSSIBLE\\" ...","solution":"def is_playlist_possible(n, k, durations, types): Check if a playlist can be created such that no more than k consecutive fast-paced or slow-paced songs play. :param n: The number of songs :param k: The maximum number of consecutive fast-paced or slow-paced songs allowed :param durations: The list of song durations :param types: The list of song types ('F' for fast-paced and 'S' for slow-paced) :return: \\"POSSIBLE\\" if such a playlist can be arranged, otherwise \\"IMPOSSIBLE\\". count = 1 # to keep the count of the same type's consecutive songs for i in range(1, n): if types[i] == types[i - 1]: count += 1 if count > k: return \\"IMPOSSIBLE\\" else: count = 1 return \\"POSSIBLE\\""},{"question":"def max_expression_value(n): Returns the maximum possible value of the expression for given n. >>> max_expression_value(1) == 1 >>> max_expression_value(3) == 7 >>> max_expression_value(4) == 25 >>> max_expression_value(5) == 121 >>> max_expression_value(10) == 3628801","solution":"def max_expression_value(n): Returns the maximum possible value of the expression for given n. if n == 1: return 1 # Starting with 1, and then appending all numbers from 2 to n numbers = list(range(1, n+1)) # Implementing the optimal strategy which is: # 1 + (2 * 3 * 4 * ... n) to take advantage of multiplication result = 1 for i in range(2, n+1): result *= i return result + 1"},{"question":"def check_melody(n: int, notes: List[int]) -> str: Determines if the list of integers, when interpreted as a sequence from a musical keyboard, would produce a strictly upwards, strictly downwards, or neither melody. >>> check_melody(5, [3, 6, 9, 12, 15]) 'UP' >>> check_melody(4, [10, 8, 6, 2]) 'DOWN' >>> check_melody(5, [3, 6, 9, 6, 15]) 'NEITHER'","solution":"def check_melody(n, notes): if all(notes[i] < notes[i+1] for i in range(n-1)): return \\"UP\\" elif all(notes[i] > notes[i+1] for i in range(n-1)): return \\"DOWN\\" else: return \\"NEITHER\\""},{"question":"def maxProfit(prices: List[int]) -> int: Calculate the maximum profit from buying and selling a stock at most twice. >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) == 6 >>> maxProfit([1, 2, 3, 4, 5]) == 4 def solve_max_profit_multiple_cases(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Solve multiple test cases of the max profit problem. >>> solve_max_profit_multiple_cases(2, [(7, [3, 3, 5, 0, 0, 3, 1, 4]), (5, [1, 2, 3, 4, 5])]) == [6, 4]","solution":"def maxProfit(prices): n = len(prices) if n <= 1: return 0 # Initialize the variables to store the maximum profits profit1 = 0 profit2 = 0 lowest1 = prices[0] lowest2 = prices[0] for price in prices: lowest1 = min(lowest1, price) profit1 = max(profit1, price - lowest1) lowest2 = min(lowest2, price - profit1) profit2 = max(profit2, price - lowest2) return profit2 def solve_max_profit_multiple_cases(T, cases): results = [] for case in cases: n, prices = case results.append(maxProfit(prices)) return results"},{"question":"def process_book_codes(s: str) -> list: Determine if there are duplicate book codes and how many are needed to complete the collection. >>> process_book_codes(\\"BC001BC002BC003BC004\\") [996] >>> process_book_codes(\\"BC001BC002BC002BC004\\") [-1] >>> process_book_codes(\\"\\") [1000] >>> process_book_codes(\\"\\".join([f\\"BC{str(i).zfill(3)}\\" for i in range(1000)])) [0] >>> process_book_codes(\\"BC000\\") [999] >>> process_book_codes(\\"\\".join([f\\"BC{str(i).zfill(3)}\\" for i in range(50)])) [950]","solution":"def process_book_codes(s): Returns how many books are needed to complete the collection or indicates duplicates. book_codes = set() length = len(s) for i in range(0, length, 5): code = s[i:i+5] if code in book_codes: return [-1] book_codes.add(code) complete_count = 1000 missing_books = complete_count - len(book_codes) return [missing_books]"},{"question":"def calculate_net_shares(transactions): This function calculates the net number of shares held by the investor after all transactions are processed. Each transaction is a string in the format \\"action value\\", where action can be \\"buy\\" or \\"sell\\" and value is an integer representing the number of shares bought or sold. Parameters: transactions (list of str): List of transaction strings. Returns: int: Net number of shares held by the investor. Examples: >>> calculate_net_shares([\\"buy 100\\", \\"sell 30\\", \\"buy 50\\", \\"sell 20\\"]) 100 >>> calculate_net_shares([\\"buy 200\\", \\"buy 300\\", \\"sell 100\\"]) 400 >>> calculate_net_shares([\\"sell 150\\", \\"buy 200\\", \\"sell 50\\"]) 0","solution":"def calculate_net_shares(transactions): This function calculates the net number of shares held by the investor after all transactions are processed. Each transaction is a string in the format \\"action value\\", where action can be \\"buy\\" or \\"sell\\" and value is an integer representing the number of shares bought or sold. Parameters: transactions (list of str): List of transaction strings. Returns: int: Net number of shares held by the investor. net_shares = 0 for transaction in transactions: action, value = transaction.split() value = int(value) if action == \\"buy\\": net_shares += value elif action == \\"sell\\": net_shares -= value return net_shares"},{"question":"def count_increasing_subsequences_of_length_3(n: int, temperatures: List[int]) -> int: You are given a sequence of integers, which represent the daily temperatures in a given week. Your task is to find the number of strictly increasing subsequences of length 3 from this sequence. An increasing subsequence of length 3 is defined as three integers from the sequence satisfying the condition a[i] < a[j] < a[k] where 1 <= i < j < k <= n. >>> count_increasing_subsequences_of_length_3(6, [2, 5, 3, 4, 1, 6]) 5 >>> count_increasing_subsequences_of_length_3(4, [3, 1, 4, 2]) 0","solution":"def count_increasing_subsequences_of_length_3(n, temperatures): count = 0 for i in range(n): for j in range(i+1, n): for k in range(j+1, n): if temperatures[i] < temperatures[j] < temperatures[k]: count += 1 return count"},{"question":"def process_input_and_find_max_areas(input_data: str) -> List[int]: Processes the input data to find the maximum area of rectangular regions in the grid where all cells have the same height for multiple test cases. >>> process_input_and_find_max_areas(\\"2n3 3n1 2 1n2 2 2n1 2 1n4 5n3 3 3 3 3n3 3 3 3 3n3 3 3 3 3n3 3 3 3 3\\") [3, 20] >>> process_input_and_find_max_areas(\\"1n1 5n1 1 1 2 2\\") [3]","solution":"def max_rect_area(grid, N, M): Function to find the maximum area of a rectangular region in the grid where all cells have the same height. max_area = 0 for height in range(101): # Since heights are between 0 and 100 # Transform the grid into a binary matrix where 1 represents cells with the current height binary_matrix = [[1 if grid[i][j] == height else 0 for j in range(M)] for i in range(N)] max_area = max(max_area, max_histogram_area(binary_matrix, N, M)) return max_area def max_histogram_area(matrix, N, M): Given a binary matrix, find the maximum rectangular area formed by 1s. max_area = 0 height = [0] * M for i in range(N): for j in range(M): if matrix[i][j] == 1: height[j] += 1 else: height[j] = 0 max_area = max(max_area, largest_rectangle_area(height)) return max_area def largest_rectangle_area(heights): Function to find the largest rectangle area in a histogram. stack, max_area = [], 0 heights.append(0) for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() return max_area def process_input_and_find_max_areas(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 results = [] for _ in range(T): N, M = map(int, input_lines[index].split()) index += 1 grid = [list(map(int, input_lines[index + i].split())) for i in range(N)] index += N result = max_rect_area(grid, N, M) results.append(result) return results"},{"question":"def longest_consecutive_subsequence(arr: List[int]) -> int: Returns the length of the longest subsequence of consecutive integers. >>> longest_consecutive_subsequence([1, 9, 3, 10, 4, 20, 2, 2, 2, 1]) 4 >>> longest_consecutive_subsequence([8, 20, 7, 30, 9, 6]) 4 >>> longest_consecutive_subsequence([1, 3, 5, 7, 9]) 1 >>> longest_consecutive_subsequence([5]) 1 >>> longest_consecutive_subsequence([]) 0 >>> longest_consecutive_subsequence([2, 2, 2, 2]) 1 >>> longest_consecutive_subsequence([1, 2, 3, 4, -1, 5, 0, -2, 6]) 9 >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4","solution":"def longest_consecutive_subsequence(arr): Returns the length of the longest subsequence of consecutive integers. if not arr: return 0 unique_elements = set(arr) longest_streak = 0 for num in unique_elements: if num - 1 not in unique_elements: current_num = num current_streak = 1 while current_num + 1 in unique_elements: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def beauty_of_sequence(n: int, a: List[int]) -> int: Returns the beauty of the sequence, which is the maximum number of distinct integers in any of its contiguous subarrays. Args: n (int): The number of elements in the sequence (1 <= n <= 100). a (List[int]): The elements of the sequence (0 <= a[i] <= 1000). Returns: int: The beauty of the sequence. Examples: >>> beauty_of_sequence(5, [1, 2, 1, 3, 2]) 3 >>> beauty_of_sequence(4, [4, 4, 4, 4]) 1 >>> beauty_of_sequence(6, [4, 2, 0, 2, 4, 2]) 3","solution":"def beauty_of_sequence(n, a): Returns the maximum number of distinct integers in any contiguous subarray. max_beauty = 0 for i in range(n): seen = set() current_beauty = 0 for j in range(i, n): if a[j] not in seen: seen.add(a[j]) current_beauty += 1 max_beauty = max(max_beauty, current_beauty) return max_beauty"},{"question":"def largestPalindrome() -> int: Returns the largest palindromic number made from the product of two 3-digit numbers. >>> largestPalindrome() == 906609 pass","solution":"def largestPalindrome(): Returns the largest palindromic number made from the product of two 3-digit numbers. max_palindrome = 0 for i in range(999, 99, -1): for j in range(i, 99, -1): product = i * j if str(product) == str(product)[0:][::-1] and product > max_palindrome: max_palindrome = product return max_palindrome"},{"question":"def hasPairWithSum(arr: List[int], k: int) -> str: Determines whether the array contains two distinct elements that sum up to k. Parameters: arr (list of int): An array of integers. k (int): The target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> hasPairWithSum([10, 15, 3, 7], 17) \\"YES\\" >>> hasPairWithSum([1, 2, 3, 9, 11], 8) \\"NO\\" pass def solve(test_cases: List[Union[List[int], int]]) -> List[str]: Solves multiple test cases for hasPairWithSum. Parameters: test_cases (list of list of int or int): A list containing the test cases data. Returns: list of str: A list containing \\"YES\\" or \\"NO\\" for each test case. pass","solution":"def hasPairWithSum(arr, k): Determines whether the array contains two distinct elements that sum up to k. Parameters: arr (list of int): An array of integers. k (int): The target sum. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". complements = set() for number in arr: if k - number in complements: return \\"YES\\" complements.add(number) return \\"NO\\" def solve(test_cases): results = [] for i in range(0, len(test_cases), 2): arr = test_cases[i] k = test_cases[i + 1] results.append(hasPairWithSum(arr, k)) return results"},{"question":"def categorize_items(item_list): Categorizes the items into their respective types and returns a formatted string of the collections. Parameters: item_list (list): List of items with 'type_item' format. Returns: str: Formatted string with each type followed by sorted items. Examples: >>> categorize_items([\\"weapon_sword\\", \\"potion_health\\", \\"armor_shield\\", \\"weapon_axe\\", \\"potion_mana\\", \\"armor_helmet\\"]) \\"armor:helmet,shieldnpotion:health,mananweapon:axe,sword\\" >>> categorize_items([\\"weapon_sword\\", \\"weapon_axe\\", \\"weapon_bow\\"]) \\"weapon:axe,bow,sword\\"","solution":"def categorize_items(item_list): Categorizes the items into their respective types and returns a formatted string of the collections. Parameters: item_list (list): List of items with 'type_item' format. Returns: str: Formatted string with each type followed by sorted items. from collections import defaultdict categories = defaultdict(list) for item in item_list: type_, item_name = item.split('_', 1) categories[type_].append(item_name) result = [] for type_ in sorted(categories.keys()): items = sorted(categories[type_]) result.append(f\\"{type_}:{','.join(items)}\\") return 'n'.join(result)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Convert sorted array to balanced binary search tree. pass def inorder_traversal(root): Perform inorder traversal on binary tree and return list of values. pass def create_balanced_bst_and_inorder_traversal(arr): Create a balanced BST from the array and return its inorder traversal. pass from solution import create_balanced_bst_and_inorder_traversal def test_example_case(): assert create_balanced_bst_and_inorder_traversal([3, 1, 4, 1, 5, 9, 2]) == [1, 1, 2, 3, 4, 5, 9] def test_single_element(): assert create_balanced_bst_and_inorder_traversal([1]) == [1] def test_two_elements(): assert create_balanced_bst_and_inorder_traversal([2, 1]) == [1, 2] def test_repeated_elements(): assert create_balanced_bst_and_inorder_traversal([2, 2, 2]) == [2, 2, 2] def test_negative_elements(): assert create_balanced_bst_and_inorder_traversal([-3, -1, -2]) == [-3, -2, -1] def test_mixed_elements(): assert create_balanced_bst_and_inorder_traversal([0, -1, 1]) == [-1, 0, 1] def test_sorted_input(): assert create_balanced_bst_and_inorder_traversal([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_reverse_sorted_input(): assert create_balanced_bst_and_inorder_traversal([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Convert sorted array to balanced binary search tree. if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sorted_array_to_bst(nums[:mid]) root.right = sorted_array_to_bst(nums[mid+1:]) return root def inorder_traversal(root): Perform inorder traversal on binary tree and return list of values. if root is None: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) def create_balanced_bst_and_inorder_traversal(arr): Create a balanced BST from the array and return its inorder traversal. sorted_arr = sorted(arr) bst_root = sorted_array_to_bst(sorted_arr) return inorder_traversal(bst_root)"},{"question":"def findKthNonRepeatingCharacter(S: str, K: int) -> str: Returns the Kth non-repeating character in the given string S. If K is greater than the number of non-repeating characters, returns an empty string. >>> findKthNonRepeatingCharacter(\\"geeksforgeeks\\", 3) \\"r\\" >>> findKthNonRepeatingCharacter(\\"aabbc\\", 1) \\"c\\" >>> findKthNonRepeatingCharacter(\\"aabbcc\\", 1) \\"\\"","solution":"def findKthNonRepeatingCharacter(S, K): Returns the Kth non-repeating character in the given string S. If K is greater than the number of non-repeating characters, returns an empty string. from collections import Counter, OrderedDict # Count frequency of each character in the string frequency = Counter(S) # Collect non-repeating characters in order non_repeating_characters = [char for char in S if frequency[char] == 1] # Check if Kth non-repeating character exists if K <= len(non_repeating_characters): return non_repeating_characters[K-1] else: return \\"\\" # Example usage: # print(findKthNonRepeatingCharacter(\\"geeksforgeeks\\", 3)) # Output: \\"r\\" # print(findKthNonRepeatingCharacter(\\"aabbc\\", 1)) # Output: \\"c\\" # print(findKthNonRepeatingCharacter(\\"aabbcc\\", 1)) # Output: \\"\\""},{"question":"def can_transform_to_single_char(t: int, test_cases: List[str]) -> List[str]: Determine if Alex can transform the binary string into a single character. Args: t (int): Number of test cases test_cases (List[str]): List of binary strings to be tested Returns: List[str]: \\"YES\\" or \\"NO\\" for each test case. >>> can_transform_to_single_char(5, [\\"01\\", \\"10\\", \\"1100\\", \\"1010\\", \\"111000\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] >>> can_transform_to_single_char(3, [\\"0\\", \\"1\\", \\"00\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def can_transform_to_single_char(t, test_cases): results = [] for s in test_cases: balance = 0 valid = True for char in s: if char == '1': balance += 1 else: balance -= 1 if balance < -1 or balance > 1: valid = False break if valid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def group_passengers(C: int, W: List[int]) -> List[List[int]]: Groups passengers such that the total weight of each group does not exceed the vehicle capacity C. Parameters: C (int): The capacity of the vehicle. W (list of int): The weights of the individual passengers. Returns: list of list of int: A list of groups, where each group contains weights of passengers that sum up to at most C. >>> group_passengers(100, [20, 30, 50, 70, 90, 10]) [[90, 10], [70, 30], [50, 20]] >>> group_passengers(50, [10, 20, 30, 40, 10]) [[40, 10], [30, 20], [10]] >>> group_passengers(50, [90]) [] >>> group_passengers(100, []) [] >>> group_passengers(5, [1, 4, 1, 4]) [[4, 1], [4, 1]]","solution":"def group_passengers(C, W): Groups passengers such that the total weight of each group does not exceed the vehicle capacity C. Parameters: C (int): The capacity of the vehicle. W (list of int): The weights of the individual passengers. Returns: list of list of int: A list of groups, where each group contains weights of passengers that sum up to at most C. W.sort(reverse=True) # Sort weights in descending order for easier grouping. groups = [] while W: current_group = [] current_weight = 0 i = 0 while i < len(W): if current_weight + W[i] <= C: current_weight += W[i] current_group.append(W.pop(i)) else: i += 1 if not current_group: return [] # If no passengers can be grouped without exceeding capacity. groups.append(current_group) return groups"},{"question":"def get_max_last_edge_weight_before_disconnect(n: int, m: int, edge_list: List[Tuple[int, int, int]]) -> int: Given a connected undirected graph G with n nodes and m edges, determine the maximum weight of an edge that could be the last edge picked before the graph becomes disconnected if two players (Alice and Bob) play optimally. >>> get_max_last_edge_weight_before_disconnect(4, 5, [(1, 2, 3), (1, 3, 2), (2, 3, 1), (2, 4, 4), (3, 4, 5)]) 4 >>> get_max_last_edge_weight_before_disconnect(3, 3, [(1, 2, 5), (2, 3, 6), (1, 3, 2)]) 5 >>> get_max_last_edge_weight_before_disconnect(2, 1, [(1, 2, 10)]) 10 >>> get_max_last_edge_weight_before_disconnect(4, 5, [(1, 2, 7), (1, 3, 7), (2, 3, 7), (2, 4, 7), (3, 4, 7)]) 7 pass","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def kruskal_mst_max_edge(n, edges): # Sorting edges based on weights edges.sort(key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) mst_edges = [] for edge in edges: u, v, w = edge root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: mst_edges.append(edge) union(parent, rank, root_u, root_v) # The last (heaviest) edge added to the MST return mst_edges[-1][2] def get_max_last_edge_weight_before_disconnect(n, m, edge_list): edges = [(u-1, v-1, w) for u, v, w in edge_list] return kruskal_mst_max_edge(n, edges)"},{"question":"def can_schedule_events(test_cases): Determine if all events can be scheduled within the available days for each test case. Args: test_cases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains: - integer D: number of days available - integer N: number of events - list of integers: number of consecutive days required for each event Returns: List[str]: List of strings where each string is \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" corresponding to each test case result. >>> can_schedule_events([(10, 3, [2, 3, 4]), (5, 3, [2, 2, 2])]) [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"] def parse_input(input_str): Parse the input string into suitable format for processing. Args: input_str (str): Input string containing the number of test cases and the details for each test case. Returns: Tuple[int, List[Tuple[int, int, List[int]]]]: The number of test cases and a list of tuples representing each test case. >>> parse_input(\\"2n10n3n2 3 4n5n3n2 2 2\\") (2, [(10, 3, [2, 3, 4]), (5, 3, [2, 2, 2])]) def main(input_str): Main function to parse input, process the test cases, and produce the output. Args: input_str (str): Input string containing the number of test cases and the details for each test case. Returns: str: The results for all test cases formatted as a single string, each result in a new line. >>> main(\\"2n10n3n2 3 4n5n3n2 2 2\\") \\"POSSIBLEnIMPOSSIBLE\\" import pytest def test_can_schedule_events(): test_cases = [ (10, 3, [2, 3, 4]), (5, 3, [2, 2, 2]), ] assert can_schedule_events(test_cases) == [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"] def test_parse_input(): input_str = \\"2n10n3n2 3 4n5n3n2 2 2\\" expected_output = (2, [ (10, 3, [2, 3, 4]), (5, 3, [2, 2, 2]), ]) assert parse_input(input_str) == expected_output def test_main(): input_str = \\"2n10n3n2 3 4n5n3n2 2 2\\" expected_output = \\"POSSIBLEnIMPOSSIBLE\\" assert main(input_str) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def can_schedule_events(test_cases): results = [] for case in test_cases: D, N, events = case total_days_needed = sum(events) if total_days_needed <= D: results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): D = int(lines[index]) N = int(lines[index + 1]) events = list(map(int, lines[index + 2].split())) test_cases.append((D, N, events)) index += 3 return T, test_cases def main(input_str): _, test_cases = parse_input(input_str) results = can_schedule_events(test_cases) return 'n'.join(results)"},{"question":"def minDeletionsForPalindrome(s: str) -> int: Determines the minimum number of deletions needed to make string s a palindrome. >>> minDeletionsForPalindrome(\\"abcdba\\") 1 >>> minDeletionsForPalindrome(\\"abcdefgh\\") 7 >>> minDeletionsForPalindrome(\\"banana\\") 1","solution":"def minDeletionsForPalindrome(s): Determines the minimum number of deletions needed to make string s a palindrome. n = len(s) dp = [[0] * n for _ in range(n)] for length in range(2, n + 1): for start in range(n - length + 1): end = start + length - 1 if s[start] == s[end]: dp[start][end] = dp[start + 1][end - 1] else: dp[start][end] = 1 + min(dp[start + 1][end], dp[start][end - 1]) return dp[0][n - 1]"},{"question":"def generate_diamond(n: int) -> list: Generates a symmetric diamond pattern centered horizontally with a width of n. >>> generate_diamond(1) [\\"*\\"] >>> generate_diamond(3) [\\" * \\", \\"***\\", \\" * \\"] >>> generate_diamond(5) [\\" * \\", \\" *** \\", \\"*****\\", \\" *** \\", \\" * \\"] >>> generate_diamond(7) [\\" * \\", \\" *** \\", \\" ***** \\", \\"*******\\", \\" ***** \\", \\" *** \\", \\" * \\"] >>> generate_diamond(9) [\\" * \\", \\" *** \\", \\" ***** \\", \\" ******* \\", \\"*********\\", \\" ******* \\", \\" ***** \\", \\" *** \\", \\" * \\"]","solution":"def generate_diamond(n: int) -> list: Generates a symmetric diamond pattern centered horizontally with a width of n. lines = [] # Ensure n is odd as per problem statement middle = n // 2 # Construct the upper half of the diamond (including the middle) for i in range(middle + 1): spaces = ' ' * (middle - i) stars = '*' * (2 * i + 1) lines.append(spaces + stars + spaces) # Construct the lower half of the diamond for i in range(middle - 1, -1, -1): spaces = ' ' * (middle - i) stars = '*' * (2 * i + 1) lines.append(spaces + stars + spaces) return lines"},{"question":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events Lana can attend. Args: - events: List of tuples [(start_i, end_i), ...] Returns: - An integer representing the maximum number of non-overlapping events. pass # Examples: # >>> max_non_overlapping_events([(1, 3), (2, 5), (4, 6)]) # 2 # >>> max_non_overlapping_events([(1, 2), (2, 3), (3, 4), (4, 5)]) # 4 # >>> max_non_overlapping_events([(1, 10), (2, 3)]) # 1 # >>> max_non_overlapping_events([(1, 3), (3, 5), (0, 6), (8, 9), (5, 7)]) # 4","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events Lana can attend. Args: - events: List of tuples [(start_i, end_i), ...] Returns: - An integer representing the maximum number of non-overlapping events. # Sort events by their end time events.sort(key=lambda x: x[1]) last_end_time = 0 count = 0 for start, end in events: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"def is_non_intersecting(n: int, m: int, connections: List[Tuple[int, int]]) -> str: This function checks if it's possible to arrange flowers in a circular pattern such that the visual connections do not intersect. n: int - number of flowers m: int - number of visual connections connections: List of tuples - each tuple contains two integers representing a connection returns: str - 'yes' if the arrangement is possible, otherwise 'no' >>> is_non_intersecting(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'yes' >>> is_non_intersecting(6, 5, [(1, 2), (1, 3), (2, 5), (2, 4), (4, 5)]) 'no' >>> is_non_intersecting(3, 0, []) 'yes'","solution":"def is_non_intersecting(n, m, connections): This function checks if it's possible to arrange flowers in a circular pattern such that the visual connections do not intersect. n: int - number of flowers m: int - number of visual connections connections: List of tuples - each tuple contains two integers representing a connection returns: str - 'yes' if the arrangement is possible, otherwise 'no' if m == 0: return \\"yes\\" connections.sort() def intersect(uv1, uv2): u1, v1 = uv1 u2, v2 = uv2 return (u1 < u2 < v1 < v2) or (u2 < u1 < v2 < v1) for i in range(m): for j in range(i+1, m): if intersect(connections[i], connections[j]): return \\"no\\" return \\"yes\\""},{"question":"def first_non_repeating_char(s: str) -> int: Given a string of lowercase alphabets, find the first non-repeating character in it and return its index. If it does not exist, return -1. >>> first_non_repeating_char(\\"leetcode\\") 0 >>> first_non_repeating_char(\\"aabb\\") -1","solution":"def first_non_repeating_char(s): Returns the index of the first non-repeating character in the string s. If no such character exists, returns -1. # Create a dictionary to count the occurrences of each character char_count = {} # Count occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has a count of 1 for index, char in enumerate(s): if char_count[char] == 1: return index # If no non-repeating character found, return -1 return -1"},{"question":"def min_removals_to_make_good(s: str) -> int: Calculates the minimum number of characters that need to be removed to make the string 'good'. A string is considered 'good' if no two adjacent characters are the same. >>> min_removals_to_make_good(\\"abb\\") 1 >>> min_removals_to_make_good(\\"aaab\\") 2 >>> min_removals_to_make_good(\\"ababa\\") 0 def solve(test_cases: List[str]) -> List[int]: Processes multiple test cases to determine the minimum number of removals for each case. >>> solve([\\"abb\\", \\"aaab\\", \\"ababa\\"]) [1, 2, 0] >>> solve([\\"a\\", \\"aaaa\\", \\"ab\\", \\"ababab\\", \\"abcabcabc\\"]) [0, 3, 0, 0, 0]","solution":"def min_removals_to_make_good(s): Calculates the minimum number of characters that need to be removed to make the string 'good'. A string is considered 'good' if no two adjacent characters are the same. Params: s : str : input string Returns: int : minimum removals needed removals = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: removals += 1 return removals def solve(test_cases): Processes multiple test cases to determine the minimum number of removals for each case. Params: test_cases : List[str] : list of input strings for each test case Returns: List[int] : list of minimum removals for each test case results = [] for s in test_cases: results.append(min_removals_to_make_good(s)) return results"},{"question":"def max_values_for_orders(n, m, items, orders): Determine the maximum value of items that can be picked for each order without exceeding the weight capacity of the cart. Parameters: n (int): The number of items in the warehouse. m (int): The number of orders. items (List[Tuple[int, int]]): List of tuples where each tuple contains weight and value of an item. orders (List[Tuple[int, int]]): List of tuples where each tuple contains the number of items to be picked and the weight capacity of the cart for an order. Returns: List[int]: The maximum values for each order. >>> n, m = 5, 2 >>> items = [(2, 3), (3, 4), (4, 5), (5, 6), (6, 7)] >>> orders = [(3, 10), (2, 5)] >>> max_values_for_orders(n, m, items, orders) [12, 7]","solution":"def knapsack(values, weights, n, W): dp = [0] * (W + 1) for i in range(n): for w in range(W, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[W] def max_values_for_orders(n, m, items, orders): results = [] for k, w in orders: values = [item[1] for item in items[:k]] weights = [item[0] for item in items[:k]] max_value = knapsack(values, weights, k, w) results.append(max_value) return results def main(n, m, items, orders): return max_values_for_orders(n, m, items, orders)"},{"question":"def findUnique(arr: List[int]) -> int: Returns the unique element that appears only once in the array, while every other element appears exactly twice. The solution works in linear time O(n) and constant auxiliary space O(1). >>> findUnique([2, 3, 5, 4, 5, 3, 4]) 2 >>> findUnique([14, 12, 13, 12, 13, 14, 15, 16, 15]) 16 >>> findUnique([1]) 1 >>> findUnique([0, 1, 0, 1, 2]) 2 >>> findUnique([99999, 100000, 99999]) 100000 >>> findUnique([10, 20, 30, 10, 20]) 30 from typing import List","solution":"def findUnique(arr): Returns the unique element that appears only once in the array, while every other element appears exactly twice. The solution works in linear time O(n) and constant auxiliary space O(1). unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def is_robot_back_to_origin(steps: str) -> bool: Determines if the robot returns to the origin after executing the steps. Parameters: steps (str): A string where 'U' means up, 'D' means down, 'L' means left, and 'R' means right. Returns: bool: True if the robot is back to the origin, False otherwise. >>> is_robot_back_to_origin('UD') True >>> is_robot_back_to_origin('LR') True >>> is_robot_back_to_origin('UU') False >>> is_robot_back_to_origin('UDRLU') False","solution":"def is_robot_back_to_origin(steps): Determines if the robot returns to the origin after executing the steps. Parameters: steps (str): A string where 'U' means up, 'D' means down, 'L' means left, and 'R' means right. Returns: bool: True if the robot is back to the origin, False otherwise. x, y = 0, 0 for step in steps: if step == 'U': y += 1 elif step == 'D': y -= 1 elif step == 'L': x -= 1 elif step == 'R': x += 1 return x == 0 and y == 0"},{"question":"def lcm(a, b): Function to compute the Least Common Multiple (LCM) of two numbers. return a * b // gcd(a, b) def smallestMultiple(n): Returns the smallest number that is divisible by all integers from 1 to n.","solution":"from math import gcd def lcm(a, b): Function to compute the Least Common Multiple (LCM) of two numbers. return a * b // gcd(a, b) def smallestMultiple(n): Returns the smallest number that is divisible by all integers from 1 to n. multiple = 1 for i in range(1, n + 1): multiple = lcm(multiple, i) return multiple"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Create a function that takes a string as input and returns the length of the longest substring that contains at most two distinct characters. For example, given the string \\"eceba\\", the longest substring with at most two distinct characters is \\"ece\\", which has a length of 3. Similarly, for the string \\"ccaabbb\\", the longest substring is \\"aabbb\\", with a length of 5. >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"aa\\") 2 >>> length_of_longest_substring_two_distinct(\\"ab\\") 2 >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4 >>> length_of_longest_substring_two_distinct(\\"a\\" * 5000 + \\"b\\" * 5000) 10000","solution":"def length_of_longest_substring_two_distinct(s: str) -> int: from collections import defaultdict if not s: return 0 left = 0 max_len = 0 char_map = defaultdict(int) for right in range(len(s)): char_map[s[right]] += 1 # If the window contains more than 2 distinct characters while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def min_operations_to_convert(s1, s2): Compute the minimum number of operations required to convert s1 into s2. The possible operations are: 1. Insert a character 2. Remove a character 3. Replace a character >>> min_operations_to_convert(\\"abcdef\\", \\"azced\\") 3 >>> min_operations_to_convert(\\"horse\\", \\"ros\\") 3 >>> min_operations_to_convert(\\"intention\\", \\"execution\\") 5 >>> min_operations_to_convert(\\"\\", \\"\\") 0 >>> min_operations_to_convert(\\"abc\\", \\"\\") 3 >>> min_operations_to_convert(\\"\\", \\"abc\\") 3 >>> min_operations_to_convert(\\"kitten\\", \\"sitting\\") 3","solution":"def min_operations_to_convert(s1, s2): Compute the minimum number of operations required to convert s1 into s2. The possible operations are: 1. Insert a character 2. Remove a character 3. Replace a character m = len(s1) n = len(s2) # Create a DP table with (m+1) rows and (n+1) columns dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # Need j insertions if s1 is empty elif j == 0: dp[i][j] = i # Need i deletions if s2 is empty elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # No operations needed if characters match else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def find_book_on_shelf(n: int, m: int, shelves: List[List[int]], q: int) -> int: Determines which shelf contains the book with the given serial number. Parameters: n (int): Number of shelves m (int): Maximum number of books per shelf shelves (List[List[int]]): A list of lists, where each sublist contains serial numbers of books on a shelf q (int): The serial number of the book to find Returns: int: The 1-based index of the shelf containing the book, or -1 if not found Examples: >>> find_book_on_shelf(3, 4, [[100, 200, 300, 400], [5, 15, 25], [50, 60, 70, 80]], 60) 3 >>> find_book_on_shelf(4, 5, [[1, 2, 3, 4], [10, 20, 30], [100, 200, 300, 400, 500], [5, 15, 25, 35, 45]], 35) 4 >>> find_book_on_shelf(2, 3, [[15, 20, 25], [100, 200, 300]], 30) -1","solution":"def find_book_on_shelf(n, m, shelves, q): Determines which shelf contains the book with the given serial number. Parameters: n (int): Number of shelves m (int): Maximum number of books per shelf (not used in the function) shelves (list): A list of lists, where each sublist contains serial numbers of books on a shelf q (int): The serial number of the book to find Returns: int: The 1-based index of the shelf containing the book, or -1 if not found for i, shelf in enumerate(shelves): if q in shelf: return i + 1 return -1"},{"question":"def dynamic_ranking_system(initial_scores, operations): Function to manage a dynamic ranking system. Parameters: initial_scores (list): List of initial player scores. operations (list): List of operations to be performed on scores. Returns: list: Results from query operations (QRY, QMIN, QMAX). >>> initial_scores = [50, 30, 20, 40, 10] >>> operations = ['SRT', 'UPD 3 35', 'QRY 3', 'QMIN', 'QMAX', 'SRT', 'QRY 4'] >>> dynamic_ranking_system(initial_scores, operations) [35, 10, 50, 40] >>> initial_scores = [10, 20, 30] >>> operations = ['QMIN', 'QMAX', 'QRY 2'] >>> dynamic_ranking_system(initial_scores, operations) [10, 30, 20]","solution":"def dynamic_ranking_system(initial_scores, operations): Function to manage a dynamic ranking system. Parameters: initial_scores (list): List of initial player scores. operations (list): List of operations to be performed on scores. Returns: list: Results from query operations (QRY, QMIN, QMAX). results = [] for op in operations: parts = op.split() command = parts[0] if command == 'UPD': player_index = int(parts[1]) new_score = int(parts[2]) initial_scores[player_index - 1] = new_score elif command == 'QRY': k = int(parts[1]) # Ensure the list is sorted for this operation sorted_scores = sorted(initial_scores) results.append(sorted_scores[k - 1]) elif command == 'QMAX': results.append(max(initial_scores)) elif command == 'QMIN': results.append(min(initial_scores)) elif command == 'SRT': initial_scores.sort() return results"},{"question":"def trap_water(heights): Calculate how much water can be trapped after raining. :param heights: List[int] representing the height of each bar. :return: Integer representing the total amount of trapped rainwater. Examples: >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap_water([4,2,0,3,2,5]) 9","solution":"def trap_water(heights): Calculate how much water can be trapped after raining. :param heights: List[int] representing the height of each bar. :return: Integer representing the total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def distribute_candies(k, m): Returns the number of ways to distribute m candies into k jars. >>> distribute_candies(2, 4) 5 >>> distribute_candies(3, 5) 21 >>> distribute_candies(1, 10) 1 >>> distribute_candies(2, 0) 1 >>> distribute_candies(2, 1) 2 # Your code here def process_inputs(inputs): Processes multiple datasets of k and m and returns the results for each dataset in a list. >>> process_inputs([(2, 4), (0, 0)]) [5] >>> process_inputs([(1, 10), (2, 0), (2, 1), (0, 0)]) [1, 1, 2] >>> process_inputs([(3, 0), (3, 8), (4, 4), (0, 0)]) [1, 45, 35] # Your code here","solution":"def distribute_candies(k, m): Returns the number of ways to distribute m candies into k jars. from math import comb # Using combination with repetition: (m + k - 1) choose (k - 1) return comb(m + k - 1, k - 1) def process_inputs(inputs): Processes multiple datasets of k and m and returns the results for each dataset in a list. results = [] for k, m in inputs: if k == 0 and m == 0: break results.append(distribute_candies(k, m)) return results"},{"question":"def isValidParentheses(S: str) -> str: Returns 'Yes' if the string has valid parentheses, otherwise returns 'No'. >>> isValidParentheses(\\"((a+b)/c)\\") == \\"Yes\\" >>> isValidParentheses(\\"(a+b)*((c+d)/(e-f))\\") == \\"Yes\\" >>> isValidParentheses(\\"a(b)c)de(\\") == \\"No\\" >>> isValidParentheses(\\"((a+b)/c\\") == \\"No\\" >>> isValidParentheses(\\")))(((\\") == \\"No\\" >>> isValidParentheses(\\"\\") == \\"Yes\\" >>> isValidParentheses(\\"()\\") == \\"Yes\\" >>> isValidParentheses(\\"(()())\\") == \\"Yes\\" >>> isValidParentheses(\\"(\\") == \\"No\\" >>> isValidParentheses(\\")\\") == \\"No\\" >>> isValidParentheses(\\"abcde\\") == \\"Yes\\" >>> isValidParentheses(\\"12345\\") == \\"Yes\\"","solution":"def isValidParentheses(S): Returns 'Yes' if the string has valid parentheses, otherwise returns 'No'. balance = 0 for char in S: if char == '(': balance += 1 elif char == ')': if balance == 0: return \\"No\\" balance -= 1 return \\"Yes\\" if balance == 0 else \\"No\\""},{"question":"def execute_commands(arr: List[int], commands: List[str]) -> List[Union[int, List[int]]]: Perform a series of operations on an array of integers. sumfirstk k -> Calculate the sum of the first k elements in the array. rotateleft n -> Rotate the array to the left by n positions. sortfirstm m -> Sort the first m elements of the array in non-decreasing order. Example usage: >>> execute_commands([1, 2, 3, 4, 5], [\\"sumfirstk 3\\"]) [6] >>> execute_commands([1, 2, 3, 4, 5], [\\"rotateleft 2\\"]) [[3, 4, 5, 1, 2]] >>> execute_commands([3, 1, 2, 5, 4], [\\"sortfirstm 3\\"]) [[1, 2, 3, 5, 4]] >>> execute_commands([1, 2, 3, 4, 5], [\\"sumfirstk 3\\", \\"rotateleft 2\\", \\"sortfirstm 4\\"]) [6, [3, 4, 5, 1, 2], [1, 3, 4, 5, 2]] >>> execute_commands([1, 2, 3, 4, 5], [\\"rotateleft 8\\"]) [[4, 5, 1, 2, 3]]","solution":"def execute_commands(arr, commands): result = [] for command in commands: cmd, value = command.split() value = int(value) if cmd == 'sumfirstk': result.append(sum(arr[:value])) elif cmd == 'rotateleft': value %= len(arr) arr = arr[value:] + arr[:value] result.append(list(arr)) elif cmd == 'sortfirstm': arr[:value] = sorted(arr[:value]) result.append(list(arr)) return result"},{"question":"from typing import List, Tuple def subset_sum_exists(n: int, S: int, array: List[int]) -> bool: Determines if there exists a subset of the array such that the sum of the subset is exactly equal to S. Uses dynamic programming approach to solve the subset sum problem. >>> subset_sum_exists(5, 9, [3, 34, 4, 12, 5]) True >>> subset_sum_exists(3, 30, [1, 5, 10]) False >>> subset_sum_exists(4, 11, [1, 2, 5, 6]) True def process_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases to determine if there exists a subset with a sum equal to S for each test case. >>> process_test_cases([(5, 9, [3, 34, 4, 12, 5]), (3, 30, [1, 5, 10]), (4, 11, [1, 2, 5, 6])]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def subset_sum_exists(n, S, array): Determines if there exists a subset of the array such that the sum of the subset is exactly equal to S. Uses dynamic programming approach to solve the subset sum problem. dp = [False] * (S + 1) dp[0] = True for num in array: for j in range(S, num - 1, -1): if dp[j - num]: dp[j] = True return dp[S] def process_test_cases(test_cases): results = [] for n, S, array in test_cases: if subset_sum_exists(n, S, array): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_level_order(arr, root, i, n): Helper function to insert nodes in the binary tree at the correct position in level order if i < n: temp = TreeNode(arr[i]) if arr[i] is not None else None root = temp if temp is not None: root.left = insert_level_order(arr, root.left, 2 * i + 1, n) root.right = insert_level_order(arr, root.right, 2 * i + 2, n) return root def sumEvenGrandparent(arr): Given a binary tree represented as an array, calculate the sum of the nodes with even-valued grandparents if not arr: return 0 n = len(arr) root = insert_level_order(arr, None, 0, n) return sumEvenGrandparentUtil(root) def sumEvenGrandparentUtil(node, parent=None, grandparent=None): Helper function to calculate sum recursively if node is None: return 0 sum_val = 0 if grandparent and grandparent.val % 2 == 0: sum_val += node.val sum_val += sumEvenGrandparentUtil(node.left, node, parent) sum_val += sumEvenGrandparentUtil(node.right, node, parent) return sum_val # Test cases def test_sumEvenGrandparent_example_1(): arr = [6, 7, 8, 2, 7, 1, 3, 9, None, 1, 4, None, None, None, 5] assert sumEvenGrandparent(arr) == 18 def test_sumEvenGrandparent_example_2(): arr = [1, 2, 3, 4, 5, 6, 7] assert sumEvenGrandparent(arr) == 0 def test_sumEvenGrandparent_example_3(): arr = [2, None, 3] assert sumEvenGrandparent(arr) == 0 def test_sumEvenGrandparent_empty_tree(): arr = [] assert sumEvenGrandparent(arr) == 0 def test_sumEvenGrandparent_all_even(): arr = [4, 2, 6, 1, 2, 4, 6] assert sumEvenGrandparent(arr) == 13 def test_sumEvenGrandparent_all_odd(): arr = [1, 3, 5, 7, 9, 11, 13] assert sumEvenGrandparent(arr) == 0","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_level_order(arr, root, i, n): if i < n: temp = TreeNode(arr[i]) if arr[i] is not None else None root = temp if temp is not None: root.left = insert_level_order(arr, root.left, 2 * i + 1, n) root.right = insert_level_order(arr, root.right, 2 * i + 2, n) return root def sumEvenGrandparent(arr): if not arr: return 0 n = len(arr) root = insert_level_order(arr, None, 0, n) return sumEvenGrandparentUtil(root) def sumEvenGrandparentUtil(node, parent=None, grandparent=None): if node is None: return 0 sum_val = 0 if grandparent and grandparent.val % 2 == 0: sum_val += node.val sum_val += sumEvenGrandparentUtil(node.left, node, parent) sum_val += sumEvenGrandparentUtil(node.right, node, parent) return sum_val"},{"question":"def send_reminders(customers, N): Send reminders to customers who have not logged in for 'N' days or more. Returns a tuple containing a list of usernames who have not logged in for 'N' days or more and the count of these users. :param customers: a list of tuples, where each tuple represents a customer's username and the number of days since their last login :param N: an integer representing the threshold number of days :return: a tuple (list of usernames, count of these users) >>> send_reminders([(\\"alice\\", 10), (\\"bob\\", 5), (\\"carol\\", 20)], 7) ([\\"alice\\", \\"carol\\"], 2) >>> send_reminders([(\\"dave\\", 1), (\\"eve\\", 15), (\\"frank\\", 9)], 10) ([\\"eve\\"], 1) >>> send_reminders([(\\"george\\", 0), (\\"hannah\\", 3)], 5) ([], 0)","solution":"def send_reminders(customers, N): Returns a tuple containing a list of usernames who have not logged in for 'N' days or more and the count of these users. :param customers: a list of tuples, where each tuple represents a customer's username and the number of days since their last login :param N: an integer representing the threshold number of days :return: a tuple (list of usernames, count of these users) usernames = [username for username, days in customers if days >= N] return usernames, len(usernames)"},{"question":"def is_prime(n): Determines if the given number n is a prime number. Parameters: n (int): The number to check for primality. Returns: str: \\"Prime\\" if n is a prime number, otherwise \\"Not Prime\\". # Implement the is_prime logic here def process_numbers(numbers): Processes a list of numbers and determines if each number is prime. Parameters: numbers (list): A list of integers. Returns: list: A list of strings \\"Prime\\" or \\"Not Prime\\" for each integer. # Implement the process_numbers logic here # Test cases to validate the solution def test_is_prime(): assert is_prime(1) == \\"Not Prime\\" assert is_prime(2) == \\"Prime\\" assert is_prime(3) == \\"Prime\\" assert is_prime(4) == \\"Not Prime\\" assert is_prime(7) == \\"Prime\\" assert is_prime(10) == \\"Not Prime\\" assert is_prime(17) == \\"Prime\\" assert is_prime(20) == \\"Not Prime\\" assert is_prime(19) == \\"Prime\\" assert is_prime(21) == \\"Not Prime\\" assert is_prime(23) == \\"Prime\\" def test_process_numbers(): numbers1 = [7, 10, 17, 20] result1 = [\\"Prime\\", \\"Not Prime\\", \\"Prime\\", \\"Not Prime\\"] assert process_numbers(numbers1) == result1 numbers2 = [2, 3, 4, 5, 6, 10] result2 = [\\"Prime\\", \\"Prime\\", \\"Not Prime\\", \\"Prime\\", \\"Not Prime\\", \\"Not Prime\\"] assert process_numbers(numbers2) == result2 numbers3 = [1, 4, 6, 8, 9, 10] result3 = [\\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\", \\"Not Prime\\"] assert process_numbers(numbers3) == result3","solution":"def is_prime(n): Determines if the given number n is a prime number. Parameters: n (int): The number to check for primality. Returns: str: \\"Prime\\" if n is a prime number, otherwise \\"Not Prime\\". if n <= 1: return \\"Not Prime\\" if n == 2: return \\"Prime\\" if n % 2 == 0: return \\"Not Prime\\" p = 3 while (p * p) <= n: if n % p == 0: return \\"Not Prime\\" p += 2 return \\"Prime\\" def process_numbers(numbers): Processes a list of numbers and determines if each number is prime. Parameters: numbers (list): A list of integers. Returns: list: A list of strings \\"Prime\\" or \\"Not Prime\\" for each integer. return [is_prime(num) for num in numbers]"},{"question":"def max_active_users_in_timeframe(timestamps, time_frame): Returns the maximum number of active users within any time frame equal to the target time frame. :param timestamps: List of integers representing user login times in minutes :param time_frame: Integer representing the target time frame in minutes :return: The maximum number of active users or an appropriate error message >>> max_active_users_in_timeframe([], 5) \\"No user logins\\" >>> max_active_users_in_timeframe([1, 2, 3], 0) \\"Invalid time frame\\" >>> max_active_users_in_timeframe([1, 2, 3, 5, 8, 13, 21], 5) 4 >>> max_active_users_in_timeframe([1], 5) 1 >>> max_active_users_in_timeframe([1, 2, 3, 4, 5], 10) 5 >>> max_active_users_in_timeframe([1, 6, 11, 16], 4) 1 >>> max_active_users_in_timeframe([1, 2, 5, 7, 9], 2) 2","solution":"def max_active_users_in_timeframe(timestamps, time_frame): Returns the maximum number of active users within any time frame equal to the target time frame. :param timestamps: List of integers representing user login times in minutes :param time_frame: Integer representing the target time frame in minutes :return: The maximum number of active users or an appropriate error message if not timestamps: return \\"No user logins\\" if time_frame <= 0: return \\"Invalid time frame\\" timestamps.sort() max_active = 0 for i in range(len(timestamps)): count = 0 for j in range(i, len(timestamps)): if timestamps[j] <= timestamps[i] + time_frame: count += 1 else: break max_active = max(max_active, count) return max_active"},{"question":"def diagonal_matrix(n: int, ch: str) -> list: Generates a n x n matrix with the given character filling the main diagonal positions. Args: - n: int, size of the matrix - ch: str, character to fill the diagonal Returns: - list: 2D list with the given character filling the main diagonal and underscores in other positions. Examples: >>> diagonal_matrix(4, 'X') [['X', '_', '_', '_'], ['_', 'X', '_', '_'], ['_', '_', 'X', '_'], ['_', '_', '_', 'X']] >>> diagonal_matrix(1, 'A') [['A']] >>> diagonal_matrix(3, '*') [['*', '_', '_'], ['_', '*', '_'], ['_', '_', '*']] >>> diagonal_matrix(5, '#') [['#', '_', '_', '_', '_'], ['_', '#', '_', '_', '_'], ['_', '_', '#', '_', '_'], ['_', '_', '_', '#', '_'], ['_', '_', '_', '_', '#']] pass","solution":"def diagonal_matrix(n, ch): Generates a n x n matrix with the given character filling the main diagonal positions. Args: - n: int, size of the matrix - ch: char, character to fill the diagonal Returns: - 2D list with the given character filling the main diagonal and underscores in other positions. matrix = [['_' for _ in range(n)] for _ in range(n)] for i in range(n): matrix[i][i] = ch return matrix"},{"question":"def organize_movies_by_genre(movies): Organizes a list of movies by their genres and outputs the available genres along with the movies. Parameters: movies (List[str]): List of strings where each string represents a movie and its genre in the format 'movie_name : genre'. Returns: List[str]: List of genres followed by the movies corresponding to each genre sorted alphabetically by genre and then by movie title. >>> organize_movies_by_genre([ ... \\"The Godfather : Crime\\", ... \\"The Dark Knight : Action\\", ... \\"Pulp Fiction : Crime\\", ... \\"Fight Club : Drama\\", ... \\"Forrest Gump : Drama\\", ... \\"Inception : Action\\", ... \\"END\\" ... ]) ['Action', ' Inception', ' The Dark Knight', 'Crime', ' Pulp Fiction', ' The Godfather', 'Drama', ' Fight Club', ' Forrest Gump'] >>> organize_movies_by_genre([\\"END\\"]) [] >>> organize_movies_by_genre([ ... \\"The Godfather : Crime\\", ... \\"Pulp Fiction : Crime\\", ... \\"END\\" ... ]) ['Crime', ' Pulp Fiction', ' The Godfather'] >>> organize_movies_by_genre([ ... \\"The Godfather : Crime\\", ... \\"The Godfather : Drama\\", ... \\"END\\" ... ]) ['Crime', ' The Godfather', 'Drama', ' The Godfather']","solution":"def organize_movies_by_genre(movies): from collections import defaultdict genre_dict = defaultdict(list) for movie in movies: if movie == \\"END\\": continue movie_name, genre = movie.rsplit(\\" : \\", 1) genre_dict[genre].append(movie_name) sorted_genres = sorted(genre_dict.keys()) result = [] for genre in sorted_genres: result.append(genre) for mv in sorted(genre_dict[genre]): result.append(f\\" {mv}\\") return result"},{"question":"from typing import List def generatePermutations(nums: List[int]) -> List[List[int]]: Given an integer array nums of length n, return an array of all the permutations of nums. You can return the answer in any order. >>> generatePermutations([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> generatePermutations([0, 1]) [[0, 1], [1, 0]] >>> generatePermutations([1]) [[1]] from solution import generatePermutations def test_permutations_of_single_element(): assert generatePermutations([1]) == [[1]] def test_permutations_of_two_elements(): result = generatePermutations([0, 1]) expected = [[0, 1], [1, 0]] assert sorted(result) == sorted(expected) def test_permutations_of_three_elements(): result = generatePermutations([1, 2, 3]) expected = [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] assert sorted(result) == sorted(expected) def test_permutations_of_negative_elements(): result = generatePermutations([-1, -2]) expected = [[-1, -2], [-2, -1]] assert sorted(result) == sorted(expected) def test_permutations_of_mixed_elements(): result = generatePermutations([-1, 0, 1]) expected = [ [-1, 0, 1], [-1, 1, 0], [0, -1, 1], [0, 1, -1], [1, -1, 0], [1, 0, -1] ] assert sorted(result) == sorted(expected)","solution":"from itertools import permutations def generatePermutations(nums): Returns all possible permutations of the input list nums. return [list(p) for p in permutations(nums)]"},{"question":"def minimum_sum_matrix(matrix): Given an n x n matrix, returns the minimum possible sum of elements in the matrix after replacing each element in a submatrix with the maximum element of that submatrix any number of times. >>> minimum_sum_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 81 >>> minimum_sum_matrix([[5, 5], [5, 5]]) 20 >>> minimum_sum_matrix([[7]]) 7 >>> minimum_sum_matrix([[3, 1, 3], [4, 8, 5], [1, 2, 1]]) 72 >>> minimum_sum_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 256 >>> minimum_sum_matrix([[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1000], [1, 1, 1, 1]]) 16000","solution":"def minimum_sum_matrix(matrix): Given an n x n matrix, returns the minimum possible sum of elements in the matrix after replacing each element in a submatrix with the maximum element of that submatrix any number of times. n = len(matrix) max_element = max(max(row) for row in matrix) return max_element * n * n"},{"question":"def max_interaction_value(n: int, notifications: List[Tuple[int, int, int]]) -> int: Given a number of notifications, finds the maximum sum of interaction values that can be achieved by selecting a compatible set of notifications. Two notifications are compatible if the end time of one is less than or equal to the start time of the other. >>> max_interaction_value(5, [(1, 3, 10), (2, 5, 15), (4, 6, 10), (5, 8, 5), (7, 9, 10)]) 30 >>> max_interaction_value(3, [(1, 2, 5), (2, 3, 10), (3, 4, 15)]) 30 >>> max_interaction_value(4, [(1, 5, 20), (2, 6, 10), (3, 7, 15), (4, 8, 25)]) 25 >>> max_interaction_value(1, [(1, 2, 5)]) 5","solution":"def max_interaction_value(n, notifications): # Sort notifications by the end time notifications.sort(key=lambda x: x[1]) # Initialize a dp array to store the maximum sum of interaction values up to the i-th notification dp = [0] * n # The value of the first notification dp[0] = notifications[0][2] def find_last_non_conflict(j): # Binary search to find the last non-conflicting notification low, high = 0, j - 1 while low <= high: mid = (low + high) // 2 if notifications[mid][1] <= notifications[j][0]: if notifications[mid + 1][1] <= notifications[j][0]: low = mid + 1 else: return mid else: high = mid - 1 return -1 # Fill dp array for i in range(1, n): # Include current notification incl_profit = notifications[i][2] l = find_last_non_conflict(i) if l != -1: incl_profit += dp[l] # Store the maximum of including and excluding the current notification dp[i] = max(incl_profit, dp[i - 1]) # Maximum value will be the last entry in dp return dp[-1] # Reading input def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) notifications = [] index = 1 for _ in range(n): st = int(data[index]) et = int(data[index+1]) it = int(data[index+2]) notifications.append((st, et, it)) index += 3 print(max_interaction_value(n, notifications))"},{"question":"def checkCamelCase(s: str) -> int: Checks whether the given string follows the CamelCase format. >>> checkCamelCase(\\"helloWorld\\") 1 >>> checkCamelCase(\\"HelloWorld\\") 0 >>> checkCamelCase(\\"\\") 0 >>> checkCamelCase(\\"helloworld\\") 1 >>> checkCamelCase(\\"thisisnotuppercase\\") 1","solution":"def checkCamelCase(s): Checks whether the given string follows the CamelCase format. Parameters: s (str): Input string Returns: int: 1 if the string follows the CamelCase format, 0 otherwise if not s: return 0 # The first character of the first word should be lowercase if not s[0].islower(): return 0 # The rest of the string should follow camel case rules for i in range(1, len(s)): if s[i].isupper() and not s[i-1].islower(): return 0 return 1"},{"question":"def can_synchronize(l, schedules): Determine whether the set of lights can be synchronized to follow given on/off schedules. :param l: Number of lights :param schedules: List of schedules for each light, where each schedule is a list of (start_time, end_time, state) tuples :return: \\"possible\\" if all lights can be synchronized, otherwise \\"impossible\\" pass # Implementation goes here def test_single_light_single_interval(): assert can_synchronize(1, [[(0, 5, 1)]]) == \\"possible\\" def test_single_light_overlapping_intervals(): assert can_synchronize(1, [[(0, 3, 1), (2, 5, 0)]]) == \\"impossible\\" def test_multiple_lights_disjoint_intervals(): assert can_synchronize(2, [ [(0, 5, 1), (5, 10, 0), (12, 20, 1)], [(0, 3, 0), (4, 6, 1)] ]) == \\"possible\\" def test_multiple_lights_overlapping_intervals(): assert can_synchronize(2, [ [(0, 5, 1), (5, 10, 0)], [(0, 3, 1), (2, 5, 0)] ]) == \\"impossible\\" def test_edge_case_single_light_no_intervals(): assert can_synchronize(1, [[]]) == \\"possible\\" def test_edge_case_multiple_lights_no_intervals(): assert can_synchronize(3, [[], [], []]) == \\"possible\\" def test_edge_case_intervals_touching_boundaries(): assert can_synchronize(1, [[(0, 5, 1), (5, 10, 0)]]) == \\"possible\\" def test_complex_case_possible(): assert can_synchronize(3, [ [(0, 5, 1), (7, 10, 0), (11, 15, 1)], [(0, 3, 0), (3, 8, 1)], [(1, 2, 1), (5, 6, 0), (8, 9, 1)] ]) == \\"possible\\"","solution":"def can_synchronize(l, schedules): Determine whether the set of lights can be synchronized to follow given on/off schedules. :param l: Number of lights :param schedules: List of schedules for each light, where each schedule is a list of (start_time, end_time, state) tuples :return: \\"possible\\" if all lights can be synchronized, otherwise \\"impossible\\" events = [] for light_id, schedule in enumerate(schedules): for start, end, state in schedule: events.append((start, light_id, state)) events.append((end, light_id, -1)) # -1 denotes end of the interval events.sort() active_intervals = [-1] * l # currently active interval ends for each light for time, light_id, state in events: if state == -1: # end of an interval active_intervals[light_id] = -1 else: if active_intervals[light_id] != -1: # there is already an active interval return \\"impossible\\" active_intervals[light_id] = state return \\"possible\\""},{"question":"from typing import List def has_pair_with_product(arr: List[int], target: int) -> str: Determine if there are any two distinct elements in the array such that their product equals the given target number. :param arr: List of integers :param target: Target product :return: \\"YES\\" if there are two distinct elements in the array whose product equals the target number, otherwise \\"NO\\" >>> has_pair_with_product([1, 2, 3, 4, 5], 8) \\"YES\\" >>> has_pair_with_product([7, 10, 14, 3], 100) \\"NO\\" >>> has_pair_with_product([5, 15, 3, 10, 20, 2], 30) \\"YES\\" >>> has_pair_with_product([10], 10) \\"NO\\" >>> has_pair_with_product([1, 3, 7, 10], 6) \\"NO\\" >>> has_pair_with_product([5, 5, 5, 5, 5], 25) \\"NO\\" >>> has_pair_with_product([1, 2, 5, 1000000000], 1000000000) \\"YES\\" >>> has_pair_with_product(list(range(1, 100001)), 99999 * 2) \\"YES\\"","solution":"def has_pair_with_product(arr, target): Function to check if there's any pair of distinct elements in the array whose product equals the target number. # Convert list to set for better performance in lookups elements = set(arr) for num in arr: if target % num == 0: # Check if num could be part of a product pair complement = target // num if complement in elements and complement != num: return \\"YES\\" return \\"NO\\""},{"question":"def average_sales(sales_data: dict) -> dict: Calculates the average sales for each item in the sales_data dictionary. Args: sales_data (dict): Dictionary containing the sales data for each item. Keys are item names, and values are lists of integers representing daily sales. Returns: dict: A new dictionary where each key is an item, and the corresponding value is the average sales for that item. >>> sales_data = { ... \\"apple\\": [10, 12, 20, 15, 18, 16, 25], ... \\"banana\\": [5, 7, 8, 6, 10, 12, 9], ... \\"cherry\\": [2, 3, 4, 1, 2, 3, 5], ... } >>> average_sales(sales_data) { \\"apple\\": 16.571428571428573, \\"banana\\": 8.142857142857142, \\"cherry\\": 2.857142857142857 }","solution":"def average_sales(sales_data): Calculates the average sales for each item in the sales_data dictionary. Args: sales_data (dict): Dictionary containing the sales data for each item. Keys are item names, and values are lists of integers representing daily sales. Returns: dict: A new dictionary where each key is an item, and the corresponding value is the average sales for that item. average_sales_data = {} for item, sales in sales_data.items(): average_sales_data[item] = sum(sales) / len(sales) return average_sales_data"},{"question":"def knapsack(weight_limit, items): Computes the maximum total value of items that can be stored without exceeding the weight limit. :param weight_limit: Integer, the weight limit of the warehouse. :param items: List of tuples, where each tuple contains (value, weight) of an item. :return: Integer, the maximum total value of items. >>> knapsack(50, [(60, 10), (100, 20), (120, 30)]) 220 >>> knapsack(10, [(100, 10), (90, 10)]) 100 >>> knapsack(5, [(10, 5)]) 10 >>> knapsack(4, [(10, 5)]) 0 >>> knapsack(0, [(10, 5), (20, 10)]) 0 >>> knapsack(50, []) 0 >>> knapsack(10, [(50, 5), (50, 5), (50, 5)]) 100 >>> knapsack(1000, [(1, 10), (900, 100), (100, 200)]) 1001","solution":"def knapsack(weight_limit, items): Computes the maximum total value of items that can be stored without exceeding the weight limit. :param weight_limit: Integer, the weight limit of the warehouse. :param items: List of tuples, where each tuple contains (value, weight) of an item. :return: Integer, the maximum total value of items. N = len(items) dp = [[0] * (weight_limit + 1) for _ in range(N + 1)] for i in range(1, N + 1): v, w = items[i - 1] for j in range(weight_limit + 1): if w <= j: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v) else: dp[i][j] = dp[i - 1][j] return dp[N][weight_limit] # Example to manually test before running unit tests weight_limit = 50 number_of_items = 3 items = [(60, 10), (100, 20), (120, 30)] print(knapsack(weight_limit, items)) # Output: 220"},{"question":"from typing import List def can_make_all_elements_equal(arr: List[int]) -> str: Determine if it is possible to make all elements of the array equal by repeatedly replacing any two elements with their sum. >>> can_make_all_elements_equal([1, 1, 2]) == \\"NO\\" >>> can_make_all_elements_equal([2, 2, 4, 4]) == \\"YES\\" >>> can_make_all_elements_equal([1, 3, 5]) == \\"YES\\" >>> can_make_all_elements_equal([2, 4, 6]) == \\"YES\\" >>> can_make_all_elements_equal([1, 2, 4]) == \\"NO\\" >>> can_make_all_elements_equal([10, 10, 10]) == \\"YES\\" pass def process_test_cases(test_cases: List[List[int]]) -> List[str]: Process multiple test cases to determine if it is possible to make all elements of each array equal. >>> test_cases = [[1, 1, 2], [2, 2, 4, 4], [1, 3, 5], [2, 4, 6], [1, 2, 4]] >>> process_test_cases(test_cases) == [\\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_make_all_elements_equal(arr): Determine if it is possible to make all elements of the array equal by repeatedly replacing any two elements with their sum. # If the count of distinct elements in array is 1, they are already equal. if len(set(arr)) == 1: return \\"YES\\" # If there's more than one distinct element and at least one element is odd, # we can never make all elements even or all elements odd simultaneously. has_odd = any(x % 2 == 1 for x in arr) has_even = any(x % 2 == 0 for x in arr) if has_odd and has_even: return \\"NO\\" return \\"YES\\" def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(can_make_all_elements_equal(arr)) return results"},{"question":"def is_palindrome(s: str) -> str: Returns 'YES' if the string s is a palindrome, otherwise returns 'NO'. >>> is_palindrome(\\"radar\\") == 'YES' >>> is_palindrome(\\"hello\\") == 'NO' def check_palindromes(strings: List[str]) -> List[str]: Takes a list of strings and returns a list of results ('YES' or 'NO') for each string. >>> check_palindromes([\\"radar\\", \\"hello\\", \\"level\\", \\"world\\"]) == ['YES', 'NO', 'YES', 'NO'] >>> check_palindromes([\\"madam\\", \\"racecar\\", \\"12321\\", \\"python\\"]) == ['YES', 'YES', 'YES', 'NO']","solution":"def is_palindrome(s): Returns 'YES' if the string s is a palindrome, otherwise returns 'NO'. return 'YES' if s == s[::-1] else 'NO' def check_palindromes(strings): Takes a list of strings and returns a list of results ('YES' or 'NO') for each string. results = [] for s in strings: results.append(is_palindrome(s)) return results"},{"question":"def process_operations(operations): Process a series of operations to manage the menu of Tia's Cafe. Each operation is described as follows: 1. Add or update a dish to the menu with a given price. 2. Remove a dish from the menu. 3. Find the price of a specified dish. 4. Calculate the average price of all dishes currently on the menu. Input: operations: List of strings, each string describes an operation. Output: List of results corresponding to operations of type 3 and 4. >>> process_operations([\\"1 pizza 500\\", \\"1 burger 250\\", \\"1 pasta 300\\", \\"3 pizza\\", \\"4\\", \\"2 burger\\", \\"3 burger\\", \\"4\\"]) [\\"500\\", \\"350.00\\", \\"Not Found\\", \\"400.00\\"] >>> process_operations([\\"4\\"]) [\\"No Dishes\\"] >>> process_operations([\\"1 sushi 700\\", \\"1 sushi 800\\", \\"3 sushi\\"]) [\\"800\\"] from solution import process_operations def test_operations(): operations = [ \\"1 pizza 500\\", \\"1 burger 250\\", \\"1 pasta 300\\", \\"3 pizza\\", \\"4\\", \\"2 burger\\", \\"3 burger\\", \\"4\\" ] assert process_operations(operations) == [\\"500\\", \\"350.00\\", \\"Not Found\\", \\"400.00\\"] def test_empty_menu(): operations = [\\"4\\"] assert process_operations(operations) == [\\"No Dishes\\"] def test_update_dish_price(): operations = [ \\"1 sushi 700\\", \\"1 sushi 800\\", \\"3 sushi\\", ] assert process_operations(operations) == [\\"800\\"] def test_remove_nonexistent_dish(): operations = [ \\"1 spaghetti 550\\", \\"2 pizza\\", \\"3 spaghetti\\", \\"3 pizza\\", ] assert process_operations(operations) == [\\"550\\", \\"Not Found\\"] def test_calculate_average_no_dishes(): operations = [ \\"1 sandwich 150\\", \\"2 sandwich\\", \\"4\\" ] assert process_operations(operations) == [\\"No Dishes\\"]","solution":"def process_operations(operations): menu = {} results = [] for operation in operations: parts = operation.split() op_type = int(parts[0]) if op_type == 1: dish_name = parts[1] price = int(parts[2]) menu[dish_name] = price elif op_type == 2: dish_name = parts[1] if dish_name in menu: del menu[dish_name] elif op_type == 3: dish_name = parts[1] if dish_name in menu: results.append(str(menu[dish_name])) else: results.append(\\"Not Found\\") elif op_type == 4: if menu: average_price = sum(menu.values()) / len(menu) results.append(f\\"{average_price:.2f}\\") else: results.append(\\"No Dishes\\") return results"},{"question":"import re from typing import Tuple, List def find_longest_words(manuscript: str) -> Tuple[int, List[str]]: Given a manuscript, this function returns the length of the longest word(s) and a list of such words in the order they first appear in the manuscript. >>> find_longest_words(\\"the_quick_brown_fox_jumps_over_the_lazy_dog\\") (5, ['quick', 'brown', 'jumps']) >>> find_longest_words(\\"cat_bat_rat\\") (3, ['cat', 'bat', 'rat']) >>> find_longest_words(\\"\\") (0, []) >>> find_longest_words(\\"1234_5678_!@#\\") (0, []) >>> find_longest_words(\\"a1b!c?def,ghi jkl_mno\\") (3, ['def', 'ghi', 'jkl', 'mno']) >>> find_longest_words(\\"hello world!!this...is...a_test\\") (5, ['hello', 'world'])","solution":"import re def find_longest_words(manuscript): Given a manuscript, this function returns the length of the longest word(s) and a list of such words in the order they first appear in the manuscript. # Extract words using regex words = re.findall(r'[a-z]+', manuscript) # Find the longest length max_length = 0 for word in words: if len(word) > max_length: max_length = len(word) # Collect all words with the maximum length longest_words = [word for word in words if len(word) == max_length] return (max_length, longest_words)"},{"question":"def find_single_element(nums: List[int]) -> int: Returns the single element that appears only once in the list. Every other element appears twice. Args: nums (List[int]): List of integers where every element appears twice except one element. Returns: int: The single element that appears only once. Examples: >>> find_single_element([4, 1, 2, 1, 2]) 4 >>> find_single_element([2, 2, 1]) 1","solution":"def find_single_element(nums): Returns the single element that appears only once in the list. Every other element appears twice. single_element = 0 for num in nums: single_element ^= num return single_element"},{"question":"def singleNumber(nums): Given an array of integers where every element appears twice except for one, finds that single element that appears only once. Args: nums (list of int): A list of integers where each element appears twice except for one. Returns: int: The single element that appears only once. # Your code here # Unit tests def test_single_number_example1(): assert singleNumber([2, 2, 1]) == 1 def test_single_number_example2(): assert singleNumber([4, 1, 2, 1, 2]) == 4 def test_single_number_example3(): assert singleNumber([1]) == 1 def test_single_number_large_input(): assert singleNumber([1, 3, 1, 2, 2]) == 3 def test_single_number_negatives(): assert singleNumber([-1, -2, -1, -2, -3]) == -3 def test_single_number_mixed(): assert singleNumber([1, -1, 1]) == -1","solution":"def singleNumber(nums): Given an array of integers where every element appears twice except for one, finds that single element that appears only once. Args: nums (list of int): A list of integers where each element appears twice except for one. Returns: int: The single element that appears only once. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"def split_subset(nums: List[int]) -> bool: Determines if a subset of the list can be split into two sublists such that the sums of the elements in both sublists are equal. Args: nums (list of int): The list of integers. Returns: bool: True if such a split is possible, False otherwise. Examples: >>> split_subset([1, 5, 11, 5]) True >>> split_subset([1, 2, 3, 5]) False >>> split_subset([3, 3, 3, 4, 5]) True >>> split_subset([2, 2, 3, 5]) False","solution":"def split_subset(nums): Determines if a subset of the list can be split into two sublists such that the sums of the elements in both sublists are equal. Args: nums (list of int): The list of integers. Returns: bool: True if such a split is possible, False otherwise. total_sum = sum(nums) # If the total sum is not even, it cannot be split into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # DP array to keep track of sums that can be formed with subsets dp = [False] * (target + 1) dp[0] = True # Zero sum is always possible for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def binarySearchIterative(arr, n, target): Perform a binary search to find the index of 'target' in the sorted array 'arr'. This function uses an iterative approach. >>> binarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9], 9, 5) 4 >>> binarySearchIterative([10, 20, 30, 40, 50, 60], 6, 35) -1 pass def binarySearchRecursive(arr, n, target): Perform a binary search to find the index of 'target' in the sorted array 'arr'. This function uses a recursive approach. >>> binarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9], 9, 7) 6 >>> binarySearchRecursive([10, 20, 30, 40, 50, 60], 6, 25) -1 pass","solution":"def binarySearchIterative(arr, n, target): Perform a binary search to find the index of 'target' in the sorted array 'arr'. This function uses an iterative approach. left, right = 0, n - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def binarySearchRecursive(arr, n, target): Perform a binary search to find the index of 'target' in the sorted array 'arr'. This function uses a recursive approach. def search(left, right): if left > right: return -1 mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: return search(mid + 1, right) else: return search(left, mid - 1) return search(0, n - 1)"},{"question":"def unique_paths(m: int, n: int) -> int: Calculate the number of unique paths from top-left to bottom-right in an m x n grid. Parameters: m (int): number of rows n (int): number of columns Returns: int: number of unique paths >>> unique_paths(3, 7) 28 >>> unique_paths(1, 1) 1 >>> unique_paths(2, 3) 3 >>> unique_paths(3, 3) 6 >>> unique_paths(5, 5) 70 >>> unique_paths(10, 10) 48620","solution":"def unique_paths(m, n): Calculate the number of unique paths from top-left to bottom-right in an m x n grid. Parameters: m (int): number of rows n (int): number of columns Returns: int: number of unique paths # Create a 2D array to store the number of ways to reach each cell dp = [[1]*n for _ in range(m)] # Fill the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Number of ways to reach the bottom-right corner return dp[m-1][n-1]"},{"question":"def longest_contiguous_subsequence_length(sequences): Given a list of sequences, returns the length of the longest contiguous subsequence of marbles with the same color for each sequence. Parameters: sequences (List[str]): A list of strings, each representing a sequence of marbles. Returns: List[int]: A list of integers, each representing the length of the longest contiguous subsequence of marbles with the same color for each sequence. Example: >>> longest_contiguous_subsequence_length([\\"AABBBCC\\", \\"ABBACCC\\", \\"AABBBA\\"]) [3, 3, 3] >>> longest_contiguous_subsequence_length([\\"A\\", \\"B\\"]) [1, 1] >>> longest_contiguous_subsequence_length([\\"ABC\\", \\"DEF\\"]) [1, 1] >>> longest_contiguous_subsequence_length([\\"AAAA\\", \\"BBBB\\"]) [4, 4] >>> longest_contiguous_subsequence_length([\\"AABAACC\\", \\"AABBCCDD\\", \\"ABBBAA\\"]) [2, 2, 3]","solution":"def longest_contiguous_subsequence_length(sequences): Given a list of sequences, returns the length of the longest contiguous subsequence of marbles with the same color for each sequence. max_lengths = [] for seq in sequences: max_length = 1 current_length = 1 for i in range(1, len(seq)): if seq[i] == seq[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) max_lengths.append(max_length) return max_lengths"},{"question":"def can_cut_beams(required_heights: List[int], available_beams: List[int]) -> List[str]: Given a list of required heights and a list of available beam heights, determine if it is possible to cut the beams to exactly match each required height. Parameters: required_heights (list of int): List of required heights. available_beams (list of int): List of available beam heights. Returns: list: List of strings \\"YES\\" or \\"NO\\" indicating whether each required height can be met. >>> can_cut_beams([5, 10, 15], [10, 5, 20]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_cut_beams([25, 10, 30], [15, 20]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> can_cut_beams([25, 30, 35], [10, 20]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> can_cut_beams([10], [10]) [\\"YES\\"] >>> can_cut_beams([10, 10, 10], [5, 10, 20]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> can_cut_beams([5, 10, 15], [1, 2, 3]) [\\"NO\\", \\"NO\\", \\"NO\\"]","solution":"def can_cut_beams(required_heights, available_beams): Given a list of required heights and a list of available beam heights, determine if it is possible to cut the beams to exactly match each required height. Parameters: required_heights (list of int): List of required heights. available_beams (list of int): List of available beam heights. Returns: list: List of strings \\"YES\\" or \\"NO\\" indicating whether each required height can be met. results = [] for h in required_heights: possible = any(b >= h for b in available_beams) results.append(\\"YES\\" if possible else \\"NO\\") return results"},{"question":"def is_prime(n: int) -> bool: Determine if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(11) True >>> is_prime(25) False >>> is_prime(1) False pass def sum_of_primes(numbers: tuple) -> int: Returns the sum of all prime numbers in the given tuple of numbers. >>> sum_of_primes((3, 4, 2, 7, 8)) 12 >>> sum_of_primes((10, 15, 18, 30)) 0 >>> sum_of_primes((3, 5, 17, 10, 20, 25)) 25 >>> sum_of_primes((4, 6, 8, 10, 12)) 0 >>> sum_of_primes((2, 3, 5, 7, 11)) 28 >>> sum_of_primes((29,)) 29 >>> sum_of_primes((30,)) 0 pass","solution":"def is_prime(n): Determine if a number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def sum_of_primes(numbers): Returns the sum of all prime numbers in the given tuple of numbers. return sum(n for n in numbers if is_prime(n))"},{"question":"def is_path_divisible(mat: List[List[int]], k: int) -> str: Determine if there is a path from the top-left corner to the bottom-right corner of the matrix such that the sum of the values along this path is divisible by k. >>> is_path_divisible([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 2] ... ], 4) \\"YES\\" >>> is_path_divisible([ ... [1, 1], ... [1, 1] ... ], 5) \\"NO\\"","solution":"def is_path_divisible(mat, k): n, m = len(mat), len(mat[0]) dp = [[set() for _ in range(m)] for _ in range(n)] dp[0][0].add(mat[0][0] % k) # Use dynamic programming to check for each cell's reachable mod values for i in range(n): for j in range(m): if i > 0: for mod in dp[i-1][j]: dp[i][j].add((mod + mat[i][j]) % k) if j > 0: for mod in dp[i][j-1]: dp[i][j].add((mod + mat[i][j]) % k) # Check the bottom-right cell return \\"YES\\" if 0 in dp[n-1][m-1] else \\"NO\\""},{"question":"def min_operations_to_preferred_state(initial1, initial2, preferred1, preferred2): Calculates the minimum number of operations required to make both doors reach the preferred state. Parameters: - initial1 (str): initial state of the first door, either \\"O\\" or \\"C\\". - initial2 (str): initial state of the second door, either \\"O\\" or \\"C\\". - preferred1 (str): preferred state of the first door, either \\"O\\" or \\"C\\". - preferred2 (str): preferred state of the second door, either \\"O\\" or \\"C\\". Returns: - int: minimum number of operations required. >>> min_operations_to_preferred_state('O', 'C', 'O', 'O') 1 >>> min_operations_to_preferred_state('O', 'O', 'C', 'C') 2 >>> min_operations_to_preferred_state('C', 'C', 'C', 'C') 0 >>> min_operations_to_preferred_state('C', 'O', 'O', 'O') 1 >>> min_operations_to_preferred_state('C', 'C', 'O', 'C') 1 >>> min_operations_to_preferred_state('O', 'C', 'O', 'O') 1","solution":"def min_operations_to_preferred_state(initial1, initial2, preferred1, preferred2): Calculates the minimum number of operations required to make both doors reach the preferred state. Parameters: - initial1 (str): initial state of the first door, either \\"O\\" or \\"C\\". - initial2 (str): initial state of the second door, either \\"O\\" or \\"C\\". - preferred1 (str): preferred state of the first door, either \\"O\\" or \\"C\\". - preferred2 (str): preferred state of the second door, either \\"O\\" or \\"C\\". Returns: - int: minimum number of operations required. # Check each door and add to the count if it needs to be changed to match the preferred state count = 0 if initial1 != preferred1: count += 1 if initial2 != preferred2: count += 1 return count"},{"question":"def optimize_network(n: int, m: int, D: int, links: List[Tuple[int, int, int, int]]) -> Union[int, str]: Determine if it's possible to optimize the network such that the sum of the bandwidth capacities of all selected links is maximized while ensuring that the total distance does not exceed a given limit. Args: n (int): Number of cell towers. m (int): Number of communication links. D (int): Maximum total distance allowed. links (List[Tuple[int, int, int, int]]): List of links where each link is represented by a tuple (u, v, c, d) where u and v are the cell towers connected by the link, c is the bandwidth capacity, and d is the distance of the link. Returns: int: Maximum sum of bandwidth capacities if possible. str: \\"Impossible\\" if network optimization with the given constraints is not possible. Examples: >>> optimize_network(5, 6, 20, [(1, 2, 15, 5), (1, 3, 10, 3), (1, 4, 5, 7), (2, 3, 7, 8), (2, 5, 17, 6), (4, 5, 20, 4)]) 62 >>> optimize_network(4, 4, 10, [(1, 2, 10, 3), (1, 3, 8, 4), (2, 4, 7, 5), (3, 4, 5, 3)]) 'Impossible'","solution":"import heapq def optimize_network(n, m, D, links): def kruskal(): parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 return True return False # sorting links by bandwidth capacity in descending order links.sort(key=lambda x: (-x[2], x[3])) total_bandwidth = 0 total_distance = 0 selected_edges = 0 for u, v, c, d in links: if union(u - 1, v - 1): total_bandwidth += c total_distance += d selected_edges += 1 if selected_edges == n - 1: break if selected_edges == n - 1 and total_distance <= D: return total_bandwidth else: return \\"Impossible\\" return kruskal()"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in the given string. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the given string. start = 0 max_length = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and used_chars[char] >= start: start = used_chars[char] + 1 used_chars[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def find_triplets_with_sum_zero(n, A): Find all unique triplets a, b, c in A such that a + b + c = 0. Args: n: int - the length of the list A A: List[int] - the list of integers Returns: str - a string representing the triplets, each triplet on a new line, formatted as \\"a b c\\" >>> n = 5 >>> A = [-1, 0, 1, 2, -1] >>> print(find_triplets_with_sum_zero(n, A)) -1 -1 2n-1 0 1 >>> n = 3 >>> A = [1, 2, 3] >>> print(find_triplets_with_sum_zero(n, A)) \\"\\" >>> n = 4 >>> A = [0, 0, 0, 0] >>> print(find_triplets_with_sum_zero(n, A)) 0 0 0 >>> n = 6 >>> A = [-1, 0, 1, 2, -1, -4] >>> print(find_triplets_with_sum_zero(n, A)) -1 -1 2n-1 0 1 >>> n = 5 >>> A = [100000, -100000, 0, 1, -1] >>> print(find_triplets_with_sum_zero(n, A)) -100000 0 100000n-1 0 1 >>> n = 6 >>> A = [1, -1, -1, 0, 2, -2] >>> print(find_triplets_with_sum_zero(n, A)) -2 0 2n-1 -1 2n-1 0 1","solution":"def find_triplets_with_sum_zero(n, A): A.sort() triplets = set() for i in range(n): left = i + 1 right = n - 1 while left < right: current_sum = A[i] + A[left] + A[right] if current_sum == 0: triplets.add((A[i], A[left], A[right])) left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 sorted_triplets = sorted(list(triplets)) result = \\"n\\".join(\\" \\".join(map(str, triplet)) for triplet in sorted_triplets) return result # To read and process input data if __name__ == \\"__main__\\": n = int(input().strip()) A = list(map(int, input().strip().split())) print(find_triplets_with_sum_zero(n, A))"},{"question":"def shortest_substring_with_all_nucleotides(s: str) -> int: Returns the length of the shortest substring that contains at least one 'A', 'T', 'C', and 'G'. If no such substring exists, return 0. >>> shortest_substring_with_all_nucleotides(\\"ATCGTTCA\\") 4 >>> shortest_substring_with_all_nucleotides(\\"AAGTTC\\") 5 >>> shortest_substring_with_all_nucleotides(\\"AAA\\") 0 >>> shortest_substring_with_all_nucleotides(\\"ATAT\\") 0 >>> shortest_substring_with_all_nucleotides(\\"ATCG\\") 4 >>> shortest_substring_with_all_nucleotides(\\"AAATTTCCGG\\") 7 >>> shortest_substring_with_all_nucleotides(\\"AATTCCGGATCG\\") 4","solution":"def shortest_substring_with_all_nucleotides(s): Returns the length of the shortest substring that contains at least one 'A', 'T', 'C', and 'G'. If no such substring exists, return 0. required = {'A', 'T', 'C', 'G'} n = len(s) min_length = n + 1 left = 0 seen = {} for right in range(n): if s[right] in required: if s[right] in seen: seen[s[right]] += 1 else: seen[s[right]] = 1 while len(seen) == 4: min_length = min(min_length, right - left + 1) if s[left] in seen: seen[s[left]] -= 1 if seen[s[left]] == 0: del seen[s[left]] left += 1 return min_length if min_length <= n else 0"},{"question":"def min_operations_to_equal_heights(n: int, h: List[int]) -> int: Determines the minimum number of operations needed to make all tree heights equal. Parameters: n (int): Number of trees. h (list of int): Heights of the trees. Returns: int: Minimum number of operations needed. >>> min_operations_to_equal_heights(5, [4, 5, 2, 2, 5]) 2 >>> min_operations_to_equal_heights(3, [3, 3, 3]) 3 >>> min_operations_to_equal_heights(4, [1, 1, 1, 1]) 1 >>> min_operations_to_equal_heights(5, [0, 1, 0, 1, 0]) 0 >>> min_operations_to_equal_heights(1, [7]) 7 >>> min_operations_to_equal_heights(6, [0, 0, 0, 0, 0, 0]) 0 >>> min_operations_to_equal_heights(4, [1, 0, 2, 3]) 0 >>> min_operations_to_equal_heights(5, [10, 9, 8, 7, 6]) 6","solution":"def min_operations_to_equal_heights(n, h): Determines the minimum number of operations needed to make all tree heights equal. Parameters: n (int): Number of trees. h (list of int): Heights of the trees. Returns: int: Minimum number of operations needed. # Find the minimum height among all trees min_height = min(h) return min_height"},{"question":"from itertools import combinations def all_possible_products(numbers: List[int]) -> List[int]: Given a list of integers, return a list of all possible products of any two distinct numbers from the list. >>> all_possible_products([1, 2, 3, 4]) [2, 3, 4, 6, 8, 12] >>> all_possible_products([2, 3, 5]) [6, 10, 15] >>> all_possible_products([7, 8]) [56] >>> all_possible_products([1, 2, 2]) [2, 2, 4] >>> all_possible_products([5]) [] >>> all_possible_products([]) [] >>> all_possible_products([-1, 2, 3]) [-2, -3, 6] >>> all_possible_products([0, 1, -1]) [0, 0, -1]","solution":"from itertools import combinations def all_possible_products(numbers): Given a list of integers, return a list of all possible products of any two distinct numbers from the list. :param numbers: List of integers :return: List of products of any two distinct numbers products = [] for combination in combinations(numbers, 2): products.append(combination[0] * combination[1]) return products"},{"question":"def filter_and_sort_employees(employees, salary_threshold): Filters and sorts the employees based on the salary threshold. Employees with salary >= salary_threshold are listed in descending order of salary. If multiple employees have the same salary, they are listed in ascending order of their ID. :param employees: a list of employee tuples where each tuple is (ID, Name, Salary) :param salary_threshold: the minimum salary threshold :return: a list of employees that meet the salary threshold condition >>> employees = [ >>> (1, 'Alice', 5000), >>> (2, 'Bob', 3000), >>> (3, 'Charlie', 7000), >>> (4, 'David', 7000), >>> (5, 'Eve', 4000) >>> ] >>> salary_threshold = 6000 >>> filter_and_sort_employees(employees, salary_threshold) [(3, 'Charlie', 7000), (4, 'David', 7000)] >>> employees = [ >>> (1, 'Alice', 5000), >>> (2, 'Bob', 3000), >>> (3, 'Charlie', 7000), >>> (4, 'David', 7000), >>> (5, 'Eve', 4000) >>> ] >>> salary_threshold = 8000 >>> filter_and_sort_employees(employees, salary_threshold) []","solution":"def filter_and_sort_employees(employees, salary_threshold): Filters and sorts the employees based on the salary threshold. Employees with salary >= salary_threshold are listed in descending order of salary. If multiple employees have the same salary, they are listed in ascending order of their ID. :param employees: a list of employee tuples where each tuple is (ID, Name, Salary) :param salary_threshold: the minimum salary threshold :return: a list of employees that meet the salary threshold condition filtered_employees = [employee for employee in employees if employee[2] >= salary_threshold] sorted_employees = sorted(filtered_employees, key=lambda x: (-x[2], x[0])) return sorted_employees # Example usage employees = [ (1, 'Alice', 5000), (2, 'Bob', 3000), (3, 'Charlie', 7000), (4, 'David', 7000), (5, 'Eve', 4000) ] salary_threshold = 6000 result = filter_and_sort_employees(employees, salary_threshold) for emp in result: print(f\\"{emp[0]} {emp[1]} {emp[2]}\\")"},{"question":"def max_net_savings(T: int, test_cases: List[Tuple[int, List[Tuple[str, int, int]]]]) -> List[str]: Determine which creature has the maximum net savings from their income and expenses. Args: T (int): The number of test cases. test_cases (List): A list of tuples where each tuple contains an integer N (number of creatures) and a list of tuples. Each inner tuple includes a creature's name (str), total income (int), and total expenses (int). Returns: List of strings: The name of the creature with the highest net savings for each test case or \\"No savings\\" if all creatures have no net savings. Example: >>> max_net_savings(2, [(3, [(\\"Dragon\\", 5000, 2000), (\\"Unicorn\\", 3000, 2500), (\\"Phoenix\\", 2000, 2500)]), (2, [(\\"Gryphon\\", 4000, 4000), (\\"Mermaid\\", 5000, 5000)])]) ['Dragon', 'No savings']","solution":"def max_net_savings(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] creatures = test_cases[i][1] max_savings = float('-inf') creature_with_max_savings = None for creature in creatures: name, income, expenses = creature net_savings = income - expenses if net_savings > max_savings: max_savings = net_savings creature_with_max_savings = name elif net_savings == max_savings: if name > creature_with_max_savings: creature_with_max_savings = name if max_savings <= 0: results.append(\\"No savings\\") else: results.append(creature_with_max_savings) return results"},{"question":"def removeElement(nums, val): Removes all occurrences of val in nums in-place and returns the new length of the array. >>> nums = [3, 2, 2, 3] >>> val = 3 >>> length = removeElement(nums, val) >>> length 2 >>> nums[:length] [2, 2] >>> nums = [0, 1, 2, 2, 3, 0, 4, 2] >>> val = 2 >>> length = removeElement(nums, val) >>> length 5 >>> nums[:length] [0, 1, 3, 0, 4]","solution":"def removeElement(nums, val): Removes all occurrences of val in nums in-place and returns the new length of the array. k = 0 # Pointer for the next position to place a non-val element for i in range(len(nums)): if nums[i] != val: nums[k] = nums[i] k += 1 return k"},{"question":"from typing import List def generate_permutations(s: str) -> List[str]: Generates all distinct permutations of a string in lexicographical order. >>> generate_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> generate_permutations(\\"aab\\") ['aab', 'aba', 'baa'] def permute_strings(test_cases: List[str]) -> List[List[str]]: For each string in test_cases, generate all distinct permutations in lexicographical order. >>> permute_strings([\\"abc\\", \\"aab\\"]) [['abc', 'acb', 'bac', 'bca', 'cab', 'cba'], ['aab', 'aba', 'baa']] # Test cases def test_generate_permutations(): # Test case for the string \\"abc\\" result = generate_permutations(\\"abc\\") expected = [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert result == expected # Test case for the string \\"aab\\" result = generate_permutations(\\"aab\\") expected = [\\"aab\\", \\"aba\\", \\"baa\\"] assert result == expected def test_permute_strings(): test_cases = [\\"abc\\", \\"aab\\"] result = permute_strings(test_cases) expected = [ [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"], [\\"aab\\", \\"aba\\", \\"baa\\"] ] assert result == expected","solution":"from itertools import permutations def generate_permutations(s): Generates all distinct permutations of the string s in lexicographical order. # Generate all permutations using itertools.permutations perm_set = set(permutations(s)) # Convert tuples to strings and sort the result result = sorted(''.join(p) for p in perm_set) return result def permute_strings(test_cases): For each string in test_cases, print all distinct permutations in lexicographical order. results = [] for s in test_cases: perms = generate_permutations(s) results.append(perms) return results"},{"question":"def has_pair_with_sum(n: int, x: int, a: List[int]) -> str: Determines if there are any two distinct indices i and j such that a[i] + a[j] = x. :param n: Number of elements in the array :param x: The target sum :param a: List of integers :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" Examples: >>> has_pair_with_sum(5, 9, [1, 2, 3, 4, 5]) 'YES' >>> has_pair_with_sum(4, 8, [3, 8, 1, 2]) 'NO' >>> has_pair_with_sum(6, 10, [5, 1, 5, 3, 3, 4]) 'YES' from typing import List def test_example_1(): result = has_pair_with_sum(5, 9, [1, 2, 3, 4, 5]) assert result == \\"YES\\" def test_example_2(): result = has_pair_with_sum(4, 8, [3, 8, 1, 2]) assert result == \\"NO\\" def test_example_3(): result = has_pair_with_sum(6, 10, [5, 1, 5, 3, 3, 4]) assert result == \\"YES\\" def test_no_pairs(): result = has_pair_with_sum(3, 1, [2, 2, 2]) assert result == \\"NO\\" def test_large_values(): result = has_pair_with_sum(3, 1000000, [999999, 1, 2]) assert result == \\"YES\\" def test_all_zeroes(): result = has_pair_with_sum(4, 0, [0, 0, 0, 0]) assert result == \\"YES\\" def test_single_large_pair(): result = has_pair_with_sum(4, 15, [10, 5, 4, 6]) assert result == \\"YES\\"","solution":"def has_pair_with_sum(n, x, a): Checks if there are any two distinct indices i and j such that a[i] + a[j] = x. :param n: Number of elements in the array :param x: The target sum :param a: List of integers :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" seen = set() for number in a: if x - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"from typing import List, Tuple, Union def task_order(n: int, dependencies: List[Tuple[int, int]]) -> Union[List[int], str]: Determine the order in which tasks can be completed, following dependency rules. Args: n (int): The number of tasks. dependencies (List[Tuple[int, int]]): A list of dependency pairs (u, v) indicating task u depends on task v. Returns: Union[List[int], str]: A list of tasks in the order they can be completed, or \\"Impossible\\" if there is a cyclic dependency. >>> task_order(5, [(1, 2), (2, 3), (4, 3), (4, 5)]) [5, 3, 2, 1, 4] >>> task_order(3, [(1, 2), (2, 3), (3, 1)]) 'Impossible'","solution":"from collections import deque, defaultdict def task_order(n, dependencies): indegree = [0] * (n + 1) adj_list = defaultdict(list) for u, v in dependencies: adj_list[v].append(u) indegree[u] += 1 queue = deque() for i in range(1, n + 1): if indegree[i] == 0: queue.append(i) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in adj_list[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == n: return order else: return \\"Impossible\\""},{"question":"def find_longest_consecutive_subsequence(lst: List[int]) -> int: Finds the length of the longest consecutive subsequence in a given list of integers. >>> find_longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> find_longest_consecutive_subsequence([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9","solution":"def find_longest_consecutive_subsequence(lst): Finds the length of the longest consecutive subsequence in a given list of integers. if not lst: return 0 # Convert list to set to remove duplicates and for O(1) average complexity check num_set = set(lst) longest_streak = 0 for num in num_set: # Check if it's the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 # increment to keep the sequence check going while current_num + 1 in num_set: current_num += 1 current_streak += 1 # compare against longest streak found so far longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def longest_palindrome(s: str) -> str: Design an algorithm to find the longest palindromic substring within a given string s. A palindrome is a sequence of characters that reads the same forward and backward. Input: - A single string s containing only lowercase English letters (1 â‰¤ |s| â‰¤ 1000). Output: - Return the longest palindromic substring within the input string. Example: Input: \\"babad\\" Output: \\"bab\\" (Note: \\"aba\\" is also a valid answer.) Input: \\"cbbd\\" Output: \\"bb\\" >>> longest_palindrome('babad') 'bab' # or 'aba' >>> longest_palindrome('cbbd') 'bb' ...","solution":"def longest_palindrome(s): Finds the longest palindromic substring within a given string s. :param s: A string composed of lowercase English letters :return: The longest palindromic substring if not s or len(s) == 0: return \\"\\" def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindrome odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindrome even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def determine_parity_of_subarray_sums(n: int, q: int, array: List[int], m: int, queries: List[Tuple[int, int]]) -> List[str]: This function determines the parity of the sums of subarrays as specified by the given queries. Parameters: n (int): The number of elements in the array. q (int): The number of changes allowed to make in the array. array (List[int]): The list of integers representing the array. m (int): The number of queries. queries (List[Tuple[int, int]]): The list of queries with each query represented as a tuple (l, r). Returns: List[str]: A list of strings where each string is \\"even\\" or \\"odd\\" corresponding to the queries. Examples: >>> determine_parity_of_subarray_sums(5, 2, [4, 3, 1, 6, 5], 3, [(1, 3), (2, 4), (1, 5)]) ['even', 'even', 'odd'] >>> determine_parity_of_subarray_sums(4, 1, [2, 7, 9, 8], 2, [(1, 2), (3, 4)]) ['odd', 'odd']","solution":"def determine_parity_of_subarray_sums(n, q, array, m, queries): This function determines the parity of the sums of subarrays as specified by the given queries. Parameters: n (int): The number of elements in the array. q (int): The number of changes allowed to make in the array. array (list of int): The list of integers representing the array. m (int): The number of queries. queries (list of tuples of int): The list of queries with each query represented as a tuple (l, r). Returns: list of str: A list of strings where each string is \\"even\\" or \\"odd\\" corresponding to the queries. results = [] for l, r in queries: subarray_sum = sum(array[l-1:r]) if subarray_sum % 2 == 0: results.append(\\"even\\") else: results.append(\\"odd\\") return results"},{"question":"def max_sunlight_requirment(n: int, sunlight_requirements: List[int]) -> int: Function to find the maximum possible total sunlight requirement for a continuous segment of plants. Args: n : int : number of potted plants. sunlight_requirements : List[int] : list of sunlight requirements for each plant. Returns: int : Maximum possible total sunlight requirement. >>> max_sunlight_requirment(5, [3, -2, 5, -1, 6]) 11 >>> max_sunlight_requirment(3, [-3, -1, -2]) -1 from max_sunlight_requirment import max_sunlight_requirment def test_all_positive_numbers(): assert max_sunlight_requirment(4, [1, 2, 3, 4]) == 10 def test_all_negative_numbers(): assert max_sunlight_requirment(3, [-3, -1, -2]) == -1 def test_mixed_numbers(): assert max_sunlight_requirment(5, [3, -2, 5, -1, 6]) == 11 def test_single_element(): assert max_sunlight_requirment(1, [5]) == 5 assert max_sunlight_requirment(1, [-5]) == -5 def test_large_numbers(): assert max_sunlight_requirment(3, [1000, -999, 1000]) == 1001 def test_borderline_case(): assert max_sunlight_requirment(2, [-1, 1]) == 1 assert max_sunlight_requirment(2, [1, -1]) == 1 def test_entire_array_sum(): assert max_sunlight_requirment(6, [2, 3, -1, 4, -2, 6]) == 12","solution":"def max_sunlight_requirment(n, sunlight_requirements): Function to find the maximum possible total sunlight requirement for a continuous segment of plants. Args: n : int : number of potted plants. sunlight_requirements : List[int] : list of sunlight requirements for each plant. Returns: int : Maximum possible total sunlight requirement. # Initialize the variables to store the maximum sum and the current sum max_sum = float('-inf') current_sum = 0 for requirement in sunlight_requirements: current_sum = max(requirement, current_sum + requirement) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"from typing import List, Tuple def project_schedule(n: int, projects: List[Tuple[int, int]], m: int, prerequisites: List[Tuple[int, int]]) -> int: Find the order of projects that fulfills all the prerequisites and maximizes the number of projects that can be completed before their respective deadlines. Args: n: The number of projects. projects: A list of tuples, each containing the deadline and duration of a project. m: The number of prerequisite pairs. prerequisites: A list of pairs representing prerequisite relations. Returns: The maximum number of projects that can be completed before their deadlines. Examples: >>> project_schedule(4, [(5, 2), (6, 3), (4, 1), (3, 2)], 2, [(1, 2), (3, 4)]) 3 >>> project_schedule(3, [(5, 2), (6, 3), (3, 1)], 1, [(2, 3)]) 2 >>> project_schedule(2, [(1, 2), (2, 2)], 1, [(1, 2)]) 0 >>> project_schedule(2, [(4, 2), (5, 2)], 0, []) 2 >>> project_schedule(5, [(10, 2), (11, 2), (12, 2), (13, 2), (14, 2)], 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5","solution":"from collections import defaultdict, deque def project_schedule(n, projects, m, prerequisites): deadlines = [0] * n durations = [0] * n for i in range(n): deadlines[i], durations[i] = projects[i][0], projects[i][1] prereq_graph = defaultdict(list) indegree = [0] * n for pre in prerequisites: u, v = pre[0] - 1, pre[1] - 1 prereq_graph[u].append(v) indegree[v] += 1 order = [] queue = deque([i for i in range(n) if indegree[i] == 0]) while queue: node = queue.popleft() order.append(node) for neighbor in prereq_graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) != n: return 0 current_time = 0 completed_projects = 0 for project in order: if current_time + durations[project] <= deadlines[project]: current_time += durations[project] completed_projects += 1 else: current_time += durations[project] return completed_projects"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def min_employees_to_reach_all(N: int, M: int, connections: List[Tuple[int, int]]) -> int: Find the minimum number of employees that need to receive a message directly or indirectly from the CEO to ensure that everyone gets the message. If it is not possible to reach all employees, return -1. Args: N: the number of employees. M: the number of direct connections. connections: a list of tuples where each tuple contains two integers \`u\` and \`v\`, representing that employee \`u\` can send a message to employee \`v\`. Returns: The minimum number of employees that need to be reached directly or indirectly by the CEO, or -1 if it is not possible to reach all employees. >>> min_employees_to_reach_all(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> min_employees_to_reach_all(5, 2, [(1, 2), (3, 4)]) -1","solution":"from collections import deque, defaultdict def min_employees_to_reach_all(N, M, connections): # Build the graph from the connections graph = defaultdict(list) for u, v in connections: graph[u].append(v) # BFS to find all reachable nodes from the CEO (node 1) visited = set() queue = deque([1]) visited.add(1) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Check if we could reach all nodes if len(visited) == N: # All employees are reachable return 1 else: return -1"},{"question":"def isValid(s: str) -> bool: Given a string containing only the characters '{', '}', '(', ')', '[', and ']', determine if the string is a valid bracket sequence. A string is considered valid if: 1. Each open bracket has a corresponding closing bracket of the same type. 2. Open brackets are closed in the correct order. Args: s (str): The input string containing brackets. Returns: bool: True if the string is a valid bracket sequence, False otherwise. Examples: >>> isValid(\\"(){}[]\\") True >>> isValid(\\"({[)]}\\") False >>> isValid(\\"{([])}\\") True from solution import isValid def test_valid_case(): assert isValid(\\"(){}[]\\") == True assert isValid(\\"{([])}\\") == True def test_invalid_case(): assert isValid(\\"({[)]}\\") == False assert isValid(\\"([)]\\") == False def test_empty_string(): assert isValid(\\"\\") == True def test_single_pair(): assert isValid(\\"()\\") == True assert isValid(\\"[]\\") == True assert isValid(\\"{}\\") == True def test_unmatched_brackets(): assert isValid(\\"(\\") == False assert isValid(\\")\\") == False assert isValid(\\"({\\") == False assert isValid(\\"{[}\\") == False def test_nested_brackets(): assert isValid(\\"{[()]}\\") == True assert isValid(\\"{[()()]()}\\") == True def test_long_valid_string(): long_string = \\"()\\" * 5000 assert isValid(long_string) == True def test_long_invalid_string(): long_string = \\"(\\" * 5000 + \\")\\" * 4999 + \\"]\\" assert isValid(long_string) == False","solution":"def isValid(s: str) -> bool: Returns True if the input string s is a valid bracket sequence, False otherwise. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def min_operations_to_single_char(t: int, test_cases: List[str]) -> List[int]: For each given string in test_cases, return the minimum number of operations required to make the string consist of a single character. >>> min_operations_to_single_char(3, [\\"abac\\", \\"aaaa\\", \\"abcde\\"]) [3, 0, 4] >>> min_operations_to_single_char(3, [\\"aaabbb\\", \\"aabbcc\\", \\"ababab\\"]) [3, 4, 5] >>> min_operations_to_single_char(4, [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) [0, 1, 2, 3]","solution":"def min_operations_to_single_char(t, test_cases): For each given string in test_cases, return the minimum number of operations required to make the string consist of a single character. results = [] for s in test_cases: # The minimal number of operations required is the length of the # longest contiguous substring of the same character subtracted from # the total length of the string. max_contiguous = 1 curr_contiguous = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: curr_contiguous += 1 else: max_contiguous = max(max_contiguous, curr_contiguous) curr_contiguous = 1 max_contiguous = max(max_contiguous, curr_contiguous) min_operations = len(s) - max_contiguous results.append(min_operations) return results"},{"question":"def find_pair_with_sum(Arr, Target): Determine whether two elements within the sorted array sum up to the target. Return the indices of the two elements as a tuple, or an empty tuple if no such pair exists. Examples: >>> find_pair_with_sum([1, 2, 3, 4, 6], 9) (2, 4) >>> find_pair_with_sum([2, 3, 4, 8], 6) (0, 2)","solution":"def find_pair_with_sum(Arr, Target): Determine whether two elements within the sorted array sum up to the target. Return the indices of the two elements as a tuple, or an empty tuple if no such pair exists. left, right = 0, len(Arr) - 1 while left < right: current_sum = Arr[left] + Arr[right] if current_sum == Target: return (left, right) elif current_sum < Target: left += 1 else: right -= 1 return ()"},{"question":"def min_abs_diff_sum(T: int, cases: List[Tuple[int, int, List[int]]]) -> List[int]: Calculate the minimum possible sum of absolute differences between adjacent elements for each test case, given array of integers and maximum element value K. Args: T (int): Number of test cases. cases (List[Tuple[int, int, List[int]]]): List of tuples where each tuple contains (N - length of array, K - max element value, array of integers). Returns: List[int]: List of integers representing the minimum possible sum of absolute differences for each test case. Example: >>> min_abs_diff_sum(1, [(4, 10, [11, 5, 3, 8])]) [8] >>> min_abs_diff_sum(1, [(4, 10, [5, 5, 5, 5])]) [0]","solution":"def min_abs_diff_sum(T, cases): results = [] for (N, K, A) in cases: A.sort() # Sort the array to minimize the differences min_diff_sum = 0 for i in range(1, N): min_diff_sum += min(abs(A[i] - A[i-1]), abs(K + 1 - A[i-1])) # Replace any element with K results.append(min_diff_sum) return results # Reading input and calling function would normally happen here, but for a module, you'd call min_abs_diff_sum with appropriate arguments."},{"question":"def count_beautiful_trees(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the number of beautiful trees in the forest for each test case. A tree is considered beautiful if its height is greater than the height of the tree to its left and less than the height of the tree to its right or vice versa. >>> count_beautiful_trees(3, [(5, [1, 3, 2, 4, 5]), (6, [6, 5, 4, 3, 2, 1]), (4, [1, 2, 3, 2])]) [2, 0, 1] >>> count_beautiful_trees(2, [(3, [1, 1, 1]), (4, [10, 20, 30, 40])]) [0, 0] >>> count_beautiful_trees(1, [(5, [5, 3, 5, 3, 5])]) [3] >>> count_beautiful_trees(1, [(3, [1, 2, 1])]) [1] >>> count_beautiful_trees(1, [(100000, list(range(1, 100001)))]) [0]","solution":"def count_beautiful_trees(T, test_cases): results = [] for case in test_cases: N, A = case beautiful_count = 0 for i in range(1, N-1): if (A[i-1] < A[i] > A[i+1]) or (A[i-1] > A[i] < A[i+1]): beautiful_count += 1 results.append(beautiful_count) return results"},{"question":"import math def find_two_integers_with_gcd(n: int, k: int) -> (int, int): Returns two integers a and b such that a + b = n and gcd(a, b) = k. >>> find_two_integers_with_gcd(10, 2) (2, 8) >>> find_two_integers_with_gcd(14, 7) (7, 7) >>> find_two_integers_with_gcd(100, 20) (20, 80) pass def solve(test_cases: list) -> list: Solves the problem for multiple test cases and returns a list of results. >>> test_cases = [(10, 2), (14, 7), (100, 20)] >>> solve(test_cases) [(2, 8), (7, 7), (20, 80)] pass","solution":"import math def find_two_integers_with_gcd(n, k): Returns two integers a and b such that a + b = n and gcd(a, b) = k. a = k b = n - k return a, b def solve(test_cases): results = [] for n, k in test_cases: results.append(find_two_integers_with_gcd(n, k)) return results"},{"question":"def calculate_work_hours(n, work_periods): Calculate the total number of hours worked by each employee for a given day. Args: n (int): The number of employees. work_periods (list): A list where each element is either an integer (number of work periods) or a tuple of two strings (start and end time in HH:MM format). Returns: list: A list of strings representing the total number of hours worked by each employee in the format \\"HH:MM\\". Example: >>> calculate_work_hours(2, [3, (\\"08:00\\", \\"12:00\\"), (\\"13:00\\", \\"17:00\\"), (\\"18:00\\", \\"20:00\\"), 2, (\\"09:00\\", \\"11:00\\"), (\\"12:00\\", \\"15:00\\")]) [\\"10:00\\", \\"05:00\\"]","solution":"def calculate_work_hours(n, work_periods): def time_difference(start, end): start_h, start_m = map(int, start.split(':')) end_h, end_m = map(int, end.split(':')) start_minutes = start_h * 60 + start_m end_minutes = end_h * 60 + end_m return end_minutes - start_minutes def format_time(total_minutes): hours = total_minutes // 60 minutes = total_minutes % 60 return f\\"{hours:02}:{minutes:02}\\" results = [] index = 0 for _ in range(n): m = work_periods[index] total_minutes = 0 for j in range(1, m + 1): start, end = work_periods[index + j] total_minutes += time_difference(start, end) results.append(format_time(total_minutes)) index += m + 1 return results # Example usage if __name__ == \\"__main__\\": n = 2 work_periods = [ 3, (\\"08:00\\", \\"12:00\\"), (\\"13:00\\", \\"17:00\\"), (\\"18:00\\", \\"20:00\\"), 2, (\\"09:00\\", \\"11:00\\"), (\\"12:00\\", \\"15:00\\") ] print(calculate_work_hours(n, work_periods)) # Output: [\\"10:00\\", \\"05:00\\"]"},{"question":"MOD = 1000000007 def binomial_coefficient(n: int, k: int) -> int: Compute the binomial coefficient C(n, k) modulo 1,000,000,007. >>> binomial_coefficient(10, 2) 45 >>> binomial_coefficient(7, 3) 35 >>> binomial_coefficient(5, 2) 10 >>> binomial_coefficient(0, 0) 1 >>> binomial_coefficient(1000, 500) 159835829 >>> binomial_coefficient(5, -1) 0 >>> binomial_coefficient(5, 6) 0","solution":"MOD = 1000000007 def binomial_coefficient(n, k): if k > n or k < 0: return 0 if k == 0 or k == n: return 1 # Use symmetry property k = min(k, n - k) # Compute nCk % MOD numerator = 1 denominator = 1 for i in range(k): numerator = (numerator * (n - i)) % MOD denominator = (denominator * (i + 1)) % MOD # Fermat's Little Theorem for modular inverse denominator_inverse = pow(denominator, MOD - 2, MOD) return (numerator * denominator_inverse) % MOD"},{"question":"from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime. pass def filter_primes(numbers: List[int]) -> List[int]: Write a function that takes a list of integers as input and returns a list containing only the prime numbers from the input list. A number is prime if it is greater than 1 and has no divisors other than 1 and itself. Your function should iterate through the input list, check each element for primality, and collect the prime numbers in the result list. >>> filter_primes([2, 4, 6, 7, 13, 15, 16, 19, 23]) [2, 7, 13, 19, 23] >>> filter_primes([0, 1, -1, -2, 5, 12, 17, 22, 23]) [5, 17, 23] >>> filter_primes([4, 6, 8, 9, 10, 12, 14, 15]) [] >>> filter_primes([2, 3, 5, 7, 11, 17]) [2, 3, 5, 7, 11, 17] >>> filter_primes([]) [] pass","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def filter_primes(numbers): Returns a list containing only the prime numbers from the input list. return [num for num in numbers if is_prime(num)]"},{"question":"from collections import deque, defaultdict def min_teleportation_hops(n, portals, start, target): Determine the minimal number of teleportation hops required to travel from the starting portal to the target portal, or determine if it is impossible to reach the target. n: int - the number of portals portals: list of tuples - each tuple containing four integers (xi, yi, xj, yj), representing the coordinates of the i-th portal and the coordinates to which it teleports start: tuple of two ints - representing the starting coordinates (xs, ys) target: tuple of two ints - representing the target coordinates (xt, yt) Returns: int - minimal number of teleportation hops or -1 if it is impossible to reach the target >>> min_teleportation_hops(3, [(1, 1, 2, 2), (2, 2, 3, 3), (3, 3, 4, 4)], (1, 1), (3, 3)) 2 >>> min_teleportation_hops(3, [(1, 1, 2, 2), (2, 2, 3, 3), (3, 3, 1, 1)], (1, 1), (4, 4)) -1","solution":"from collections import deque, defaultdict def min_teleportation_hops(n, portals, start, target): graph = defaultdict(list) for xi, yi, xj, yj in portals: graph[(xi, yi)].append((xj, yj)) xs, ys = start xt, yt = target if (xs, ys) == (xt, yt): return 0 queue = deque([(xs, ys)]) visited = set([(xs, ys)]) hops = 0 while queue: hops += 1 for _ in range(len(queue)): curr = queue.popleft() for next_portal in graph[curr]: if next_portal == (xt, yt): return hops if next_portal not in visited: visited.add(next_portal) queue.append(next_portal) return -1"},{"question":"def find_winner(votes: List[int]) -> Union[int, str]: Determine the winner of the election based on the votes. >>> find_winner([5, 2, 6, 2, 2]) 2 >>> find_winner([1, 2, 3, 2, 2, 3, 3]) \\"Tie\\" >>> find_winner([3, 3, 3, 3]) 3 >>> find_winner([10]) 10 >>> find_winner([1, 2, 1, 2, 3, 3]) \\"Tie\\" >>> find_winner([1]*25000 + [2]*25000) \\"Tie\\" >>> find_winner([1]*1 + [2]*24999 + [3]*24998) 2","solution":"def find_winner(votes): from collections import Counter # Count the number of votes for each candidate vote_count = Counter(votes) # Find the maximum number of votes max_votes = max(vote_count.values()) # Find all candidates that have the maximum number of votes top_candidates = [candidate for candidate, count in vote_count.items() if count == max_votes] # Return the result based on the number of top candidates if len(top_candidates) == 1: return top_candidates[0] else: return \\"Tie\\""},{"question":"def smallest_perimeter_grid(n: int) -> tuple: Returns the dimensions (rows, columns) of the grid that gives the smallest perimeter from n stamps, as well as the smallest perimeter itself. >>> smallest_perimeter_grid(12) == (3, 4, 14) True >>> smallest_perimeter_grid(36) == (6, 6, 24) True # Your code here","solution":"import math def smallest_perimeter_grid(n): Returns the dimensions (rows, columns) of the grid that gives the smallest perimeter from n stamps, as well as the smallest perimeter itself. min_perimeter = float('inf') best_r, best_c = 0, 0 for i in range(1, int(math.sqrt(n)) + 1): if n % i == 0: r = i c = n // i perimeter = 2 * (r + c) if perimeter < min_perimeter: min_perimeter = perimeter best_r = r best_c = c return best_r, best_c, min_perimeter"},{"question":"def smallest_lexicographical_string_after_removal(T: int, strings: List[str]) -> List[str]: Given the number of test cases T and a list of strings \`strings\`, return a list of the smallest lexicographical strings that can be obtained by removing exactly one character from each string. >>> smallest_lexicographical_string_after_removal(3, [\\"abc\\", \\"abz\\", \\"bca\\"]) [\\"ab\\", \\"ab\\", \\"ba\\"] >>> smallest_lexicographical_string_after_removal(1, [\\"aaa\\"]) [\\"aa\\"] :param T: The number of test cases :param strings: A list containing T strings :return: A list of strings, each being the smallest lexicographical string obtained by removing exactly one character from the corresponding input string","solution":"def smallest_lexicographical_string_after_removal(T, strings): Given the number of test cases T and a list of strings \`strings\`, returns a list of the smallest lexicographical strings that can be obtained by removing exactly one character from each string. results = [] for S in strings: min_string = S[1:] # Initialize with the string without the first character for i in range(len(S)): new_string = S[:i] + S[i+1:] if new_string < min_string: min_string = new_string results.append(min_string) return results"},{"question":"def find_difference(string: str) -> int: Returns the difference between the highest and lowest integer in a comma-separated string of integers. >>> find_difference(\\"3,-1,9,17,-33\\") 50 >>> find_difference(\\"5,5,5,5,5\\") 0 >>> find_difference(\\"-7,-3,-10,-15\\") 12","solution":"def find_difference(string): Returns the difference between the highest and lowest integer in a comma-separated string of integers. # Split the string into integer elements numbers = list(map(int, string.split(','))) # Find the highest and lowest integer highest = max(numbers) lowest = min(numbers) # Return the difference return highest - lowest"},{"question":"from typing import List, Tuple def max_possible_depth(n: int, edges: List[Tuple[int, int]]) -> int: You are given a tree consisting of n nodes. A tree is a connected undirected graph with n-1 edges. Each node is labeled with a unique integer from 1 to n. The depth of a node in the tree is the number of edges from the node to the root (node 1). Your task is to find the maximum possible depth of the tree after performing exactly one operation. The operation is to select two nodes u and v and add a new edge between them, provided they are not already directly connected, and maintain the tree's properties by removing one of the existing edges such that you still have a valid tree structure afterward. >>> max_possible_depth(4, [(1, 2), (2, 3), (2, 4)]) 2 >>> max_possible_depth(6, [(1, 2), (1, 3), (3, 4), (3, 5), (5, 6)]) 4 from solution import max_possible_depth def test_max_possible_depth_case1(): assert max_possible_depth(4, [(1, 2), (2, 3), (2, 4)]) == 2 def test_max_possible_depth_case2(): assert max_possible_depth(6, [(1, 2), (1, 3), (3, 4), (3, 5), (5, 6)]) == 4 def test_max_possible_depth_case3(): assert max_possible_depth(2, [(1, 2)]) == 1 def test_max_possible_depth_case4(): assert max_possible_depth(3, [(1, 2), (2, 3)]) == 2 def test_max_possible_depth_case5(): assert max_possible_depth(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) == 3 def test_max_possible_depth_case6(): assert max_possible_depth(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == 4","solution":"from collections import defaultdict, deque def find_max_depth_after_operation(n, edges): def bfs(start_node): queue = deque([start_node]) depths = {start_node: 0} visited = {start_node} while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) depths[neighbor] = depths[node] + 1 return max(depths.values()), depths # Create adjacency list adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) # Perform BFS to find the farthest node from node 1 _, first_bfs_depths = bfs(1) farthest_node = max(first_bfs_depths, key=first_bfs_depths.get) # Perform BFS from the farthest node found max_depth, _ = bfs(farthest_node) return max_depth def max_possible_depth(n, edges): return find_max_depth_after_operation(n, edges)"},{"question":"from typing import List def first_non_repeating_character(T: int, strings: List[str]) -> List[str]: Find the first non-repeating character in each string of the given list of strings. If all characters are repeating, return \\"_\\". Parameters: T (int): The number of test cases. strings (List[str]): A list containing the strings to check. Returns: List[str]: A list of results containing the first non-repeating character for each string. Examples: >>> first_non_repeating_character(2, [\\"geeksforgeeks\\", \\"aabbcc\\"]) [\\"f\\", \\"_\\"] >>> first_non_repeating_character(1, [\\"abcdef\\"]) [\\"a\\"] >>> first_non_repeating_character(1, [\\"aabbccddee\\"]) [\\"_\\"]","solution":"from typing import List from collections import Counter def first_non_repeating_character(T: int, strings: List[str]) -> List[str]: result = [] for string in strings: char_count = Counter(string) found_non_repeating = False for char in string: if char_count[char] == 1: result.append(char) found_non_repeating = True break if not found_non_repeating: result.append(\\"_\\") return result"},{"question":"def minStepsToEmpty(s: str) -> int: Given a string containing only characters 'a', 'b', and 'c', find the minimum number of steps required to make the string empty. You can remove either a single character 'a', 'b', or 'c' or remove consecutive identical characters having length multiple of 3 (i.e., \\"aaa\\", \\"bbb\\", \\"ccc\\"). >>> minStepsToEmpty(\\"abccba\\") 6 >>> minStepsToEmpty(\\"aaabbbccc\\") 3 >>> minStepsToEmpty(\\"abcabc\\") 6","solution":"def minStepsToEmpty(s: str) -> int: Returns the minimum number of steps required to make the string empty. steps = 0 i = 0 while i < len(s): if i + 2 < len(s) and s[i] == s[i+1] == s[i+2]: steps += 1 i += 3 else: steps += 1 i += 1 return steps"},{"question":"def max_total_value_in_boxes(T: int, test_cases: List[Dict[str, Union[int, List[int]]]]) -> List[int]: Determine the maximum total value that can be obtained given the constraints. Args: T: int - The number of test cases. test_cases: List[Dict[str, Union[int, List[int]]]] - A list of dictionaries containing the details for each test case. Returns: List[int] - A list containing the maximum total value for each test case. Test cases: >>> T = 2 >>> test_cases = [ ... {'N': 5, 'weights': [2, 3, 1, 5, 4], 'values': [3, 4, 2, 8, 5], 'maxValue': 10}, ... {'N': 4, 'weights': [5, 8, 3, 1], 'values': [12, 10, 6, 7], 'maxValue': 13} ... ] >>> max_total_value_in_boxes(T, test_cases) [10, 13] >>> T = 1 >>> test_cases = [ ... {'N': 3, 'weights': [1, 2, 3], 'values': [10, 15, 20], 'maxValue': 15} ... ] >>> max_total_value_in_boxes(T, test_cases) [15] # Your code here","solution":"def max_total_value_in_boxes(T, test_cases): results = [] for i in range(T): N = test_cases[i]['N'] weights = test_cases[i]['weights'] values = test_cases[i]['values'] max_value = test_cases[i]['maxValue'] # Dynamic programming array to store the maximum value we can get at each possible value up to max_value dp = [0] * (max_value + 1) for j in range(N): for v in range(max_value, values[j] - 1, -1): dp[v] = max(dp[v], dp[v - values[j]] + values[j]) results.append(dp[max_value]) return results"},{"question":"def generate_identifiers(t: int, test_cases: List[int]) -> List[List[int]]: Generates the list of identifiers for each docking port. Parameters: t (int): Number of test cases test_cases (list): List of integers representing the number of docking ports for each test case. Returns: list: A list of lists, where each inner list contains identifiers for the corresponding test case. Examples: >>> generate_identifiers(1, [3]) [[1, 4, 9]] >>> generate_identifiers(2, [3, 5]) [[1, 4, 9], [1, 4, 9, 16, 25]]","solution":"def generate_identifiers(t, test_cases): Generates the list of identifiers for each docking port. Parameters: t (int): Number of test cases test_cases (list): List of integers representing the number of docking ports for each test case. Returns: list: A list of lists, where each inner list contains identifiers for the corresponding test case. result = [] for n in test_cases: identifiers = [i**2 for i in range(1, n + 1)] result.append(identifiers) return result"},{"question":"def has_cycle(n: int, edges: List[Tuple[int, int]]) -> str: Detect if a directed graph has a cycle using DFS. :param n: Number of vertices :param edges: List of directed edges in the graph :return: \\"YES\\" if there is a cycle, otherwise \\"NO\\" >>> has_cycle(4, [(1, 2), (2, 3), (3, 4)]) \\"NO\\" >>> has_cycle(4, [(1, 2), (2, 3), (3, 4), (4, 2)]) \\"YES\\" >>> has_cycle(1, []) \\"NO\\" >>> has_cycle(1, [(1, 1)]) \\"YES\\" >>> has_cycle(5, [(1, 2), (2, 3), (4, 5)]) \\"NO\\" >>> has_cycle(5, [(1, 2), (2, 3), (3, 1), (4, 5)]) \\"YES\\"","solution":"def has_cycle(n, edges): Detect if a directed graph has a cycle. :param n: Number of vertices :param edges: List of directed edges in the graph :return: \\"YES\\" if there is a cycle, otherwise \\"NO\\" from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [0] * (n + 1) # Array to track visited nodes: 0 unvisited, 1 visiting, 2 visited def dfs(v): Perform DFS and detect cycles. :param v: Current node :return: True if a cycle is detected, otherwise False visited[v] = 1 # Mark the current node as visiting for neighbor in graph[v]: if visited[neighbor] == 0: # If neighbor hasn't been visited if dfs(neighbor): # DFS on neighbor return True elif visited[neighbor] == 1: # If neighbor is being visited, a cycle is detected return True visited[v] = 2 # Mark current node as fully visited return False for vertex in range(1, n + 1): if visited[vertex] == 0: if dfs(vertex): return \\"YES\\" return \\"NO\\""},{"question":"def check_increasing_trend(n, k, temperatures, queries): Determines if the temperatures over the specified range show an increasing trend. Parameters ---------- n : int The number of days. k : int The number of queries. temperatures : list of ints The temperatures recorded over the n days. queries : list of tuples Each tuple (l, r) specifies a range [l, r]. Returns ------- list of str \\"YES\\" if the temperatures over the specified range show an increasing trend, otherwise \\"NO\\". pass from check_increasing_trend import check_increasing_trend def test_all_increasing(): n = 7 k = 3 temperatures = [2, 3, 3, 5, 10, 7, 11] queries = [(1, 3), (4, 5), (3, 7)] expected = [\\"YES\\", \\"YES\\", \\"NO\\"] assert check_increasing_trend(n, k, temperatures, queries) == expected def test_with_single_day_queries(): n = 5 k = 5 temperatures = [1, 2, 3, 4, 5] queries = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] expected = [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] assert check_increasing_trend(n, k, temperatures, queries) == expected def test_with_all_same_temperatures(): n = 4 k = 2 temperatures = [5, 5, 5, 5] queries = [(1, 4), (2, 3)] expected = [\\"YES\\", \\"YES\\"] assert check_increasing_trend(n, k, temperatures, queries) == expected def test_decreasing_section(): n = 6 k = 2 temperatures = [1, 2, 3, 2, 4, 5] queries = [(1, 4), (4, 6)] expected = [\\"NO\\", \\"YES\\"] assert check_increasing_trend(n, k, temperatures, queries) == expected","solution":"def check_increasing_trend(n, k, temperatures, queries): Determines if the temperatures over the specified range show an increasing trend. Parameters ---------- n : int The number of days. k : int The number of queries. temperatures : list of ints The temperatures recorded over the n days. queries : list of tuples Each tuple (l, r) specifies a range [l, r]. Returns ------- list of str \\"YES\\" if the temperatures over the specified range show an increasing trend, otherwise \\"NO\\". result = [] for l, r in queries: increasing = True for i in range(l, r): if temperatures[i - 1] > temperatures[i]: increasing = False break result.append(\\"YES\\" if increasing else \\"NO\\") return result"},{"question":"def schedule_tasks(tasks): Simulate the execution order of the tasks based on priority and time. Parameters: tasks (list): A list of tuples, where each tuple (p, t) represents a task's priority and time. Returns: list: A list of tasks sorted by their execution order. Example: >>> schedule_tasks([(3, 5), (1, 2), (1, 3), (2, 1), (3, 2)]) [(3, 2), (3, 5), (2, 1), (1, 2), (1, 3)] from solution import schedule_tasks def test_example_case(): tasks = [(3, 5), (1, 2), (1, 3), (2, 1), (3, 2)] expected = [(3, 2), (3, 5), (2, 1), (1, 2), (1, 3)] assert schedule_tasks(tasks) == expected def test_single_task(): tasks = [(5, 10)] expected = [(5, 10)] assert schedule_tasks(tasks) == expected def test_all_same_priority(): tasks = [(2, 3), (2, 1), (2, 5)] expected = [(2, 1), (2, 3), (2, 5)] assert schedule_tasks(tasks) == expected def test_all_same_time(): tasks = [(1, 4), (3, 4), (2, 4)] expected = [(3, 4), (2, 4), (1, 4)] assert schedule_tasks(tasks) == expected def test_varying_priorities_and_times(): tasks = [(4, 2), (4, 8), (4, 1), (1, 5), (3, 1), (2, 3)] expected = [(4, 1), (4, 2), (4, 8), (3, 1), (2, 3), (1, 5)] assert schedule_tasks(tasks) == expected def test_edge_case_all_same(): tasks = [(5, 5), (5, 5), (5, 5)] expected = [(5, 5), (5, 5), (5, 5)] assert schedule_tasks(tasks) == expected","solution":"def schedule_tasks(tasks): Sorts tasks based on their priority and execution time. Parameters: tasks (list): A list of tuples, where each tuple (p, t) represents a task's priority and time. Returns: list: A list of tasks sorted by their execution order. # Sort tasks based on the custom sorting criteria: first by priority descending and then by time ascending sorted_tasks = sorted(tasks, key=lambda x: (-x[0], x[1])) return sorted_tasks"},{"question":"def can_partition(nums: List[int]) -> str: Given a list of integers, determine if it can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) \\"YES\\" >>> can_partition([1, 3, 5]) \\"NO\\"","solution":"def can_partition(nums): total_sum = sum(nums) if total_sum % 2 != 0: return \\"NO\\" target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num-1, -1): dp[i] = dp[i] or dp[i-num] if dp[target]: return \\"YES\\" else: return \\"NO\\" def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) nums = list(map(int, data[1:])) result = can_partition(nums) print(result)"},{"question":"def longest_even_odd_subarray_length(arr): Finds the length of the longest subarray with an equal number of even and odd numbers. >>> longest_even_odd_subarray_length([1, 2, 3, 4, 5, 6]) 6 >>> longest_even_odd_subarray_length([1, 3, 5, 7]) 0 >>> longest_even_odd_subarray_length([2, 4, 6, 8]) 0 >>> longest_even_odd_subarray_length([2, 1, 2, 1, 2, 1]) 6 >>> longest_even_odd_subarray_length([2, 1, 1, 2, 2, 1]) 6 >>> longest_even_odd_subarray_length([2, 1]) 2 >>> longest_even_odd_subarray_length([1]) 0 >>> longest_even_odd_subarray_length([2]) 0 >>> longest_even_odd_subarray_length([i % 2 for i in range(100000)]) 100000","solution":"def longest_even_odd_subarray_length(arr): This function finds the length of the longest subarray with an equal number of even and odd numbers. N = len(arr) prefix_diff = {0: -1} # To handle the case when subarray starts from the beginning even_count = 0 odd_count = 0 max_length = 0 for i, num in enumerate(arr): if num % 2 == 0: even_count += 1 else: odd_count += 1 diff = even_count - odd_count # If the diff has been seen before, a subarray with equal numbers of evens and odds is found if diff in prefix_diff: max_length = max(max_length, i - prefix_diff[diff]) else: prefix_diff[diff] = i return max_length"},{"question":"def process_input(input_lines): Processes the input lines and returns the sorted achievements Args: input_lines: list of str, the input lines Returns: list: sorted list of tuples, each containing (str, list of str) pass def sort_programmers_achievements(programmers_info): Given a list of programmers and their achievements, sorts the programmers by name and their achievements lexicographically. Args: programmers_info: list of tuples, each containing (str, int, list of str) Returns: list: sorted list of tuples, each containing (str, list of str) pass def display_sorted_achievements(sorted_achievements): Prints the sorted achievements in the format required Args: sorted_achievements: list of tuples, each containing (str, list of str) pass from solution import process_input, sort_programmers_achievements, display_sorted_achievements def test_example_case(): input_lines = [ \\"3\\", \\"alice 3 hackathon_leader top_coder open_source_contributor\\", \\"bob 2 ai_researcher robotics_spirit\\", \\"charlie 1 bug_finder\\" ] expected_output = [ (\\"alice\\", [\\"hackathon_leader\\", \\"open_source_contributor\\", \\"top_coder\\"]), (\\"bob\\", [\\"ai_researcher\\", \\"robotics_spirit\\"]), (\\"charlie\\", [\\"bug_finder\\"]) ] assert process_input(input_lines) == expected_output def test_single_programmer(): input_lines = [ \\"1\\", \\"alice 3 hackathon_leader top_coder open_source_contributor\\" ] expected_output = [ (\\"alice\\", [\\"hackathon_leader\\", \\"open_source_contributor\\", \\"top_coder\\"]) ] assert process_input(input_lines) == expected_output def test_no_achievements_programmer(): input_lines = [ \\"1\\", \\"bob 0\\" ] expected_output = [ (\\"bob\\", []) ] assert process_input(input_lines) == expected_output def test_multiple_programmers_sorted(): input_lines = [ \\"2\\", \\"charlie 1 bug_finder\\", \\"alice 2 open_source_contributor hackathon_leader\\" ] expected_output = [ (\\"alice\\", [\\"hackathon_leader\\", \\"open_source_contributor\\"]), (\\"charlie\\", [\\"bug_finder\\"]) ] assert process_input(input_lines) == expected_output def test_display_output(capfd): sorted_achievements = [ (\\"alice\\", [\\"hackathon_leader\\", \\"open_source_contributor\\", \\"top_coder\\"]), (\\"bob\\", [\\"ai_researcher\\", \\"robotics_spirit\\"]), (\\"charlie\\", [\\"bug_finder\\"]) ] display_sorted_achievements(sorted_achievements) captured = capfd.readouterr() expected_output = \\"alicenhackathon_leadernopen_source_contributorntop_codernbobnai_researchernrobotics_spiritncharlienbug_findern\\" assert captured.out == expected_output","solution":"def sort_programmers_achievements(programmers_info): Given a list of programmers and their achievements, sorts the programmers by name and their achievements lexicographically. Args: programmers_info: list of tuples, each containing (str, int, list of str) - str: programmer's name - int: number of achievements - list of str: the achievements Returns: list: sorted list of tuples, each containing (str, list of str) sorted_programmers = sorted(programmers_info, key=lambda x: x[0]) result = [] for name, count, achievements in sorted_programmers: sorted_achievements = sorted(achievements) result.append((name, sorted_achievements)) return result def display_sorted_achievements(sorted_achievements): Prints the sorted achievements in the format required Args: sorted_achievements: list of tuples, each containing (str, list of str) for name, achievements in sorted_achievements: print(name) for achievement in achievements: print(achievement) def process_input(input_lines): Processes the input lines and returns the sorted achievements Args: input_lines: list of str, the input lines Returns: list: sorted list of tuples, each containing (str, list of str) P = int(input_lines[0]) programmers_info = [] for i in range(1, P + 1): parts = input_lines[i].split() name = parts[0] A = int(parts[1]) achievements = parts[2:] programmers_info.append((name, A, achievements)) sorted_achievements = sort_programmers_achievements(programmers_info) return sorted_achievements"},{"question":"def can_reach_bottom_right(H: int, W: int, grid: List[List[int]]) -> str: Determines whether it's possible to reach the bottom right corner of the grid from the top left corner under the given constraint (you can only move to an adjacent cell if the height of the cell you are moving to is greater than or equal to the height of the cell you are currently standing on). Args: - H: The number of rows in the grid. - W: The number of columns in the grid. - grid: A 2D list of integers representing the height of each cell in the grid. Returns: - \\"YES\\" if it is possible to reach the bottom right corner from the top left corner, otherwise \\"NO\\". Examples: >>> can_reach_bottom_right(3, 3, [[1, 2, 3], [2, 3, 3], [1, 3, 4]]) \\"YES\\" >>> can_reach_bottom_right(2, 2, [[4, 3], [2, 1]]) \\"NO\\" from typing import List def test_case_1(): H, W = 3, 3 grid = [ [1, 2, 3], [2, 3, 3], [1, 3, 4] ] assert can_reach_bottom_right(H, W, grid) == \\"YES\\" def test_case_2(): H, W = 2, 2 grid = [ [4, 3], [2, 1] ] assert can_reach_bottom_right(H, W, grid) == \\"NO\\" def test_case_3(): H, W = 1, 1 grid = [ [1] ] assert can_reach_bottom_right(H, W, grid) == \\"YES\\" def test_case_4(): H, W = 2, 3 grid = [ [1, 2, 3], [2, 2, 2] ] assert can_reach_bottom_right(H, W, grid) == \\"YES\\" def test_case_5(): H, W = 3, 3 grid = [ [3, 2, 3], [2, 2, 1], [2, 2, 5] ] assert can_reach_bottom_right(H, W, grid) == \\"NO\\"","solution":"def can_reach_bottom_right(H, W, grid): def is_valid_move(x, y, prev_height): return 0 <= x < H and 0 <= y < W and grid[x][y] >= prev_height def dfs(x, y): if x == H-1 and y == W-1: return True visited.add((x, y)) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: nx, ny = x + dx, y + dy if is_valid_move(nx, ny, grid[x][y]) and (nx, ny) not in visited: if dfs(nx, ny): return True return False visited = set() return \\"YES\\" if dfs(0, 0) else \\"NO\\" # Example usage: # H, W = 3, 3 # grid = [ # [1, 2, 3], # [2, 3, 3], # [1, 3, 4] # ] # print(can_reach_bottom_right(H, W, grid)) # Output: YES"},{"question":"def is_palindrome(s: str) -> bool: Evaluates whether a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\" \\") True >>> is_palindrome(\\".,\\") True >>> is_palindrome(\\"131231\\") False >>> is_palindrome(\\"Able was I ere I saw Elba\\") True","solution":"def is_palindrome(s): Evaluates whether a given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. :param s: input string :return: True if the input string is palindrome, False otherwise # Use filter + str.isalnum to keep only alphanumeric characters, convert to lowercase clean_s = ''.join(filter(str.isalnum, s)).lower() # Check if the cleaned string is equal to its reverse return clean_s == clean_s[::-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums): Creates a binary search tree with minimal height from a sorted array of distinct integers. :param nums: List[int], the sorted input array :return: TreeNode, the root of the generated BST Example: >>> root = sortedArrayToBST([1, 2, 3, 4, 5, 6, 7]) >>> inorder_traversal(root) [1, 2, 3, 4, 5, 6, 7] >>> root = sortedArrayToBST([10, 20, 30, 40, 50]) >>> inorder_traversal(root) [10, 20, 30, 40, 50] def inorder_traversal(root): Helper function to perform inorder traversal of the BST. return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def test_sortedArrayToBST_example1(): array = [1, 2, 3, 4, 5, 6, 7] bst_root = sortedArrayToBST(array) assert inorder_traversal(bst_root) == array def test_sortedArrayToBST_example2(): array = [10, 20, 30, 40, 50] bst_root = sortedArrayToBST(array) assert inorder_traversal(bst_root) == array def test_sortedArrayToBST_single_element(): array = [1] bst_root = sortedArrayToBST(array) assert inorder_traversal(bst_root) == array def test_sortedArrayToBST_two_elements(): array = [1, 2] bst_root = sortedArrayToBST(array) assert inorder_traversal(bst_root) == array def test_sortedArrayToBST_empty(): array = [] bst_root = sortedArrayToBST(array) assert bst_root is None","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sortedArrayToBST(nums): Creates a binary search tree with minimal height from a sorted array of distinct integers. :param nums: List[int], the sorted input array :return: TreeNode, the root of the generated BST if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = sortedArrayToBST(nums[:mid]) root.right = sortedArrayToBST(nums[mid+1:]) return root"},{"question":"def min_operations_to_make_uniform(binary_strings): Given a list of binary strings, returns the minimum number of operations required to make all the characters in each string the same. >>> min_operations_to_make_uniform([\\"1100\\", \\"1001\\", \\"11111\\"]) [2, 2, 0] >>> min_operations_to_make_uniform([\\"0000\\", \\"1111\\"]) [0, 0] >>> min_operations_to_make_uniform([\\"101010\\", \\"010101\\", \\"000111\\", \\"111000\\"]) [3, 3, 3, 3] >>> min_operations_to_make_uniform([\\"10\\", \\"01\\"]) [1, 1] >>> min_operations_to_make_uniform([\\"0\\" * 10**6]) [0] >>> min_operations_to_make_uniform([\\"01\\" * 500000]) [500000] >>> min_operations_to_make_uniform([\\"0\\" * (10**6 - 1) + \\"1\\"]) [1]","solution":"def min_operations_to_make_uniform(binary_strings): Given a list of binary strings, returns the minimum number of operations required to make all the characters in each string the same. def min_operations(s): count_0 = s.count('0') count_1 = len(s) - count_0 return min(count_0, count_1) results = [] for s in binary_strings: results.append(min_operations(s)) return results"},{"question":"def max_energy(n, energies): Returns the maximum possible total energy the player can collect. >>> max_energy(5, [-1, 2, 3, -2, 4]) == 7 >>> max_energy(3, [-5, -1, -8]) == -1 >>> max_energy(4, [1, 2, 3, 4]) == 10 >>> max_energy(4, [-1, -2, -3, -4]) == -1 >>> max_energy(6, [3, -2, 5, -1, 6, -4]) == 11 >>> max_energy(1, [5]) == 5 >>> max_energy(1, [-5]) == -5","solution":"def max_energy(n, energies): Returns the maximum possible total energy the player can collect. max_current = max_global = energies[0] for i in range(1, n): max_current = max(energies[i], max_current + energies[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def shortest_paths(cities, roads, queries): Calculate the shortest paths between pairs of cities based on the given road network and queries. Parameters: cities (tuple): A tuple containing the number of cities and number of roads roads (list of tuple): A list of tuples with each tuple containing three integers (u, v, t) representing a road queries (list of tuple): A list of tuples with each tuple containing two integers (a, b) representing the cities to query Returns: list: A list of results for each query, the shortest travel time or \\"IMPOSSIBLE\\" if no path exists >>> shortest_paths((4, 4), [(1, 2, 4), (1, 3, 2), (2, 3, 1), (3, 4, 1)], [(1, 4), (2, 4)]) [3, 2] >>> shortest_paths((3, 1), [(1, 2, 5)], [(1, 3), (2, 3)]) [\\"IMPOSSIBLE\\", \\"IMPOSSIBLE\\"] >>> shortest_paths((2, 1), [(1, 2, 1)], [(1, 2)]) [1]","solution":"def floyd_warshall(n, roads): Function to compute shortest paths using Floyd-Warshall algorithm. # Initialize distance matrix inf = float('inf') dist = [[inf] * (n + 1) for _ in range(n + 1)] # Distance from a city to itself is 0 for i in range(1, n + 1): dist[i][i] = 0 # Fill in the initial distances based on the roads for u, v, t in roads: dist[u][v] = min(dist[u][v], t) dist[v][u] = min(dist[v][u], t) # Floyd-Warshall Algorithm for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def shortest_paths(cities, roads, queries): Function to find shortest paths for multiple queries. n, m = cities if n == 0: return [] # Calculate shortest paths using Floyd-Warshall algorithm dist = floyd_warshall(n, roads) results = [] for a, b in queries: if dist[a][b] == float('inf'): results.append(\\"IMPOSSIBLE\\") else: results.append(dist[a][b]) return results"},{"question":"def length_of_longest_unique_substring(s: str) -> int: Find the length of the longest substring that contains only unique characters. >>> length_of_longest_unique_substring(\\"abcabcbb\\") 3 >>> length_of_longest_unique_substring(\\"bbbbb\\") 1 >>> length_of_longest_unique_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_unique_substring(s): n = len(s) max_length = 0 start = 0 char_index_map = {} for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def tree_diameter(n: int, edges: List[Tuple[int, int]]) -> int: Determines the diameter of a binary tree, which is defined as the number of nodes on the longest path between any two nodes in the tree. >>> tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 4 >>> tree_diameter(1, []) 1 >>> tree_diameter(2, [(1, 2)]) 2 >>> tree_diameter(3, [(1, 2), (1, 3)]) 3 pass def test_tree_diameter(): assert tree_diameter(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) == 4 assert tree_diameter(1, []) == 1 assert tree_diameter(2, [(1, 2)]) == 2 assert tree_diameter(3, [(1, 2), (1, 3)]) == 3 assert tree_diameter(4, [(1, 2), (1, 3), (2, 4)]) == 4 assert tree_diameter(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 6 if __name__ == \\"__main__\\": test_tree_diameter() print(\\"All test cases pass\\")","solution":"from collections import defaultdict, deque def tree_diameter(n, edges): if n == 1: return 1 def bfs(start): visited = [-1] * (n + 1) queue = deque([start]) visited[start] = 0 farthest_node = start max_distance = 0 while queue: node = queue.popleft() for neighbor in tree[node]: if visited[neighbor] == -1: visited[neighbor] = visited[node] + 1 queue.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) node, _ = bfs(1) # Get farthest node from an arbitrary node (1 in this case) _, diameter = bfs(node) # Get the diameter by finding the farthest from the farthest node return diameter + 1 def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) edges = [] for i in range(1, len(data), 2): edges.append((int(data[i]), int(data[i+1]))) return n, edges if __name__ == \\"__main__\\": n, edges = read_input() print(tree_diameter(n, edges))"},{"question":"def subset_sum_exists(arr, target): Determines if there exists a subset of \`arr\` that sums up to \`target\`. >>> subset_sum_exists([3, 34, 4, 12, 5, 2], 9) == True >>> subset_sum_exists([1, 3, 9, 2, 5], 30) == False >>> subset_sum_exists([10], 10) == True >>> subset_sum_exists([], 0) == True >>> subset_sum_exists([19], 10) == False >>> subset_sum_exists([1, 1, 1, 1], 4) == True >>> subset_sum_exists([2, 3, 7, 8, 10], 11) == True # Function definition here def process_cases(T, cases): Processes multiple test cases. >>> T = 2 >>> cases = [ ... {'N': 6, 'S': 9, 'arr': [3, 34, 4, 12, 5, 2]}, ... {'N': 5, 'S': 30, 'arr': [1, 3, 9, 2, 5]} ... ] >>> process_cases(T, cases) == ['YES', 'NO'] >>> T = 3 >>> cases = [ ... {'N': 1, 'S': 10, 'arr': [10]}, ... {'N': 4, 'S': 11, 'arr': [1, 2, 5, 6]}, ... {'N': 4, 'S': 9, 'arr': [1, 2, 7, 3]} ... ] >>> process_cases(T, cases) == ['YES', 'YES', 'YES'] # Function definition here","solution":"def subset_sum_exists(arr, target): Determines if there exists a subset of \`arr\` that sums up to \`target\`. n = len(arr) dp = [[False] * (target + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] return dp[n][target] def process_cases(T, cases): results = [] for case in cases: N, S, arr = case['N'], case['S'], case['arr'] if subset_sum_exists(arr, S): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events. Parameters: events (list of tuples): List of events where each event is represented as (start time, end time). Returns: int: The maximum number of non-overlapping events. Example: >>> max_non_overlapping_events([(1, 4), (2, 3), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_events([(1, 5), (2, 6), (3, 7), (4, 8)]) 1 def test_max_non_overlapping_events(): # Test case where there are multiple non-overlapping events assert max_non_overlapping_events([(1, 4), (2, 3), (3, 4), (5, 6)]) == 3 # Test case where every event overlaps assert max_non_overlapping_events([(1, 5), (2, 6), (3, 7), (4, 8)]) == 1 # Test case where no events overlap assert max_non_overlapping_events([(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 # Test case with single event assert max_non_overlapping_events([(1, 2)]) == 1 # Test case with event starting and ending at the same time assert max_non_overlapping_events([(1, 2), (2, 3), (3, 4), (3, 5)]) == 3 # Test case with no events assert max_non_overlapping_events([]) == 0 # Test case where events slightly overlap assert max_non_overlapping_events([(1, 3), (2, 5), (4, 6)]) == 2 # Test case with overlapping events and gaps assert max_non_overlapping_events([(1, 4), (3, 5), (5, 6), (6, 8)]) == 3 # Test case with identical events assert max_non_overlapping_events([(1, 2), (1, 2), (1, 2)]) == 1 # Large case to test efficiency assert max_non_overlapping_events([(i, i+1) for i in range(100000)]) == 100000","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events. Parameters: events (list of tuples): List of events where each event is represented as (start time, end time). Returns: int: The maximum number of non-overlapping events. # Sort events based on their end time events.sort(key=lambda x: x[1]) # Initialize variables to track the end time of the last event attended and count of events max_events = 0 last_end_time = 0 # Iterate over the events to find the maximum number of non-overlapping events for start, end in events: if start >= last_end_time: max_events += 1 last_end_time = end return max_events"},{"question":"def minimum_changes_to_equalize(nums: List[int]) -> int: Determines the minimum number of changes (increment or decrement) needed to make all elements of the array equal. Args: nums: List[int] - The list of integers. Returns: int - The minimum number of changes required. >>> minimum_changes_to_equalize([1, 2, 3]) 2 >>> minimum_changes_to_equalize([5, 5, 5, 5]) 0 >>> minimum_changes_to_equalize([1, 3, 2, 2]) 2","solution":"def minimum_changes_to_equalize(nums): Determines the minimum number of changes (increment or decrement) needed to make all elements of the array equal. Args: nums: List[int] - The list of integers. Returns: int - The minimum number of changes required. if not nums: return 0 median = sorted(nums)[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"def consolidate_lists(k, list_of_lists): Consolidate multiple lists into a single sorted list without duplicates. Args: k (int): Number of lists list_of_lists (list of list of int): List of k lists where each list contains integers Returns: list of int: Consolidated, sorted list of unique integers pass # Example usage: # k = 3 # list_of_lists = [ # [1, 3, 5, 7], # [2, 4, 6, 8, 10], # [1, 4, 9] # ] # print(consolidate_lists(k, list_of_lists))","solution":"def consolidate_lists(k, list_of_lists): Consolidate multiple lists into a single sorted list without duplicates. Args: k (int): Number of lists list_of_lists (list of list of int): List of k lists where each list contains integers Returns: list of int: Consolidated, sorted list of unique integers unique_elements = set() for lst in list_of_lists: unique_elements.update(lst) return sorted(unique_elements) # Example usage: # k = 3 # list_of_lists = [ # [1, 3, 5, 7], # [2, 4, 6, 8, 10], # [1, 4, 9] # ] # print(consolidate_lists(k, list_of_lists))"},{"question":"def increasing_triplet_subsequence(n: int, arr: List[int]) -> str: Determines if there are three distinct indices i, j, k (i < j < k) such that Ai < Aj < Ak. Returns \\"YES\\" if such indices exist, otherwise returns \\"NO\\". >>> increasing_triplet_subsequence(5, [1, 2, 3, 4, 5]) == \\"YES\\" >>> increasing_triplet_subsequence(5, [5, 4, 3, 2, 1]) == \\"NO\\" >>> increasing_triplet_subsequence(5, [1, 3, 2, 4, 5]) == \\"YES\\" >>> increasing_triplet_subsequence(4, [5, 1, 5, 5]) == \\"NO\\" >>> increasing_triplet_subsequence(2, [1, 2]) == \\"NO\\" >>> increasing_triplet_subsequence(3, [1, 1, 1]) == \\"NO\\" >>> increasing_triplet_subsequence(3, [2, 1, 3]) == \\"NO\\" >>> increasing_triplet_subsequence(3, [2, 3, 1]) == \\"NO\\"","solution":"def increasing_triplet_subsequence(n, arr): Returns \\"YES\\" if there exists three distinct indices i, j, k (i < j < k) such that arr[i] < arr[j] < arr[k]. Otherwise, returns \\"NO\\". if n < 3: return \\"NO\\" first = second = float('inf') for num in arr: if num <= first: first = num # smallest so far elif num <= second: second = num # second smallest so far else: return \\"YES\\" # found a third element that makes i < j < k return \\"NO\\""},{"question":"def total_expense(test_cases): Calculate the total expenses for multiple groups of friends each with different contributions. Parameters: test_cases (list): A list of tuples, each containing an integer (number of friends) and a list of integers (contributions for each friend). Returns: list: A list of integers where each integer is the total contribution for each test case. def parse_input(input_str): Parse the input string to extract the number of test cases and their respective contributions. Parameters: input_str (str): The input string containing test cases information. Returns: list: A list of tuples, each containing an integer (number of friends) and a list of integers (contributions for each friend). from solution import total_expense, parse_input def test_total_expense(): test_cases = [ (3, [100, 200, 300]), (4, [50, 50, 50, 50]) ] result = total_expense(test_cases) assert result == [600, 200], f\\"Expected [600, 200], but got {result}\\" def test_total_expense_with_zeros(): test_cases = [ (3, [0, 0, 0]), (4, [50, 0, 50, 0]) ] result = total_expense(test_cases) assert result == [0, 100], f\\"Expected [0, 100], but got {result}\\" def test_total_expense_mixed_values(): test_cases = [ (3, [0, 1000, 250]), (2, [999, 1]) ] result = total_expense(test_cases) assert result == [1250, 1000], f\\"Expected [1250, 1000], but got {result}\\" def test_parse_input(): input_str = \\"2n3n100 200 300n4n50 50 50 50\\" result = parse_input(input_str) expected = [ (3, [100, 200, 300]), (4, [50, 50, 50, 50]) ] assert result == expected, f\\"Expected {expected}, but got {result}\\"","solution":"def total_expense(test_cases): Calculate the total expenses for multiple groups of friends each with different contributions. Parameters: test_cases (list): A list of tuples, each containing an integer (number of friends) and a list of integers (contributions for each friend). Returns: list: A list of integers where each integer is the total contribution for each test case. results = [] for (n, contributions) in test_cases: results.append(sum(contributions)) return results def parse_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) contributions = list(map(int, input_lines[index + 1].strip().split())) test_cases.append((N, contributions)) index += 2 return test_cases"},{"question":"import math def is_prime(n: int) -> str: Determines if the given number n is a prime number. Returns \\"Prime\\" if n is a prime number and \\"Not prime\\" if n is not a prime number. >>> is_prime(29) 'Prime' >>> is_prime(100) 'Not prime'","solution":"import math def is_prime(n): Determines if the given number n is a prime number. Returns \\"Prime\\" if n is a prime number and \\"Not prime\\" if n is not a prime number. if n <= 1: return \\"Not prime\\" if n == 2: return \\"Prime\\" if n % 2 == 0: return \\"Not prime\\" sqrtn = int(math.sqrt(n)) for i in range(3, sqrtn + 1, 2): if n % i == 0: return \\"Not prime\\" return \\"Prime\\""},{"question":"def reorder_employees(employees): Reorders the employees alphabetically by their full names while keeping their badge IDs intact. If two employees have the same full name, they should be ordered based on their original badge IDs in ascending order. :param employees: Dictionary where key is badge ID and value is full name of the employee. :return: A new dictionary with employees reordered by full name. ... # Unit Tests def test_reorder_employees_basic(): employees = {101: 'John Doe', 102: 'Jane Smith', 103: 'Alice Johnson', 104: 'Bob Brown'} expected = {104: 'Bob Brown', 103: 'Alice Johnson', 101: 'John Doe', 102: 'Jane Smith'} assert reorder_employees(employees) == expected def test_reorder_employees_same_name(): employees = {101: 'John Doe', 102: 'Jane Smith', 103: 'Alice Johnson', 104: 'Bob Brown', 105: 'Jane Smith'} expected = {104: 'Bob Brown', 103: 'Alice Johnson', 105: 'Jane Smith', 102: 'Jane Smith', 101: 'John Doe'} assert reorder_employees(employees) == expected def test_reorder_employees_empty(): employees = {} expected = {} assert reorder_employees(employees) == expected def test_reorder_employees_single_entry(): employees = {101: 'John Doe'} expected = {101: 'John Doe'} assert reorder_employees(employees) == expected def test_reorder_employees_numeric_names(): employees = {101: 'John Doe1', 102: 'John Doe2', 103: 'John Doe10', 104: 'John Doe3'} expected = {101: 'John Doe1', 103: 'John Doe10', 102: 'John Doe2', 104: 'John Doe3'} assert reorder_employees(employees) == expected","solution":"def reorder_employees(employees): Reorders the employees alphabetically by their full names while keeping their badge IDs intact. If two employees have the same full name, they should be ordered based on their original badge IDs in ascending order. :param employees: Dictionary where key is badge ID and value is full name of the employee. :return: A new dictionary with employees reordered by full name. # Sort the dictionary items by full name and then by badge ID sorted_employees = sorted(employees.items(), key=lambda x: (x[1], x[0])) # Convert the sorted list of tuples back into a dictionary return dict(sorted_employees)"},{"question":"def longest_productive_segment(binary_strings): Returns a list of lengths of the longest contiguous segment of productive fields for each input binary string. :param binary_strings: A list of binary strings. :return: A list of integers representing the lengths of the longest productive segments. >>> longest_productive_segment([\\"1100111110110\\"]) [5] >>> longest_productive_segment([\\"1000001\\"]) [1] >>> longest_productive_segment([\\"1111111\\"]) [7] >>> longest_productive_segment([\\"1100111110110\\", \\"1000001\\", \\"1111111\\"]) [5, 1, 7]","solution":"def longest_productive_segment(binary_strings): Returns a list of lengths of the longest contiguous segment of productive fields for each input binary string. :param binary_strings: A list of binary strings. :return: A list of integers representing the lengths of the longest productive segments. results = [] for s in binary_strings: max_len = 0 cur_len = 0 for char in s: if char == '1': cur_len += 1 max_len = max(max_len, cur_len) else: cur_len = 0 results.append(max_len) return results def process_input_output(input_data): Processes the input data and produces the corresponding output. :param input_data: List of input strings, first string is the count of test cases, following strings are the test case binary strings. :return: List of results for each test case. T = int(input_data[0]) binary_strings = input_data[1:T+1] return longest_productive_segment(binary_strings)"},{"question":"def can_form_palindrome(n: int, S: str) -> str: Determines if it's possible to transform a binary string into a palindrome by performing adjacent swaps. Parameters: n (int): Length of the binary string. S (str): Binary string. Returns: str: \\"YES\\" if it's possible to transform the binary string into a palindrome, \\"NO\\" otherwise. >>> can_form_palindrome(5, \\"11011\\") \\"YES\\" >>> can_form_palindrome(4, \\"1001\\") \\"YES\\" >>> can_form_palindrome(6, \\"100011\\") \\"NO\\"","solution":"def can_form_palindrome(n, S): Determines if it's possible to transform a binary string into a palindrome by performing adjacent swaps. Parameters: n (int): Length of the binary string. S (str): Binary string. Returns: str: \\"YES\\" if it's possible to transform the binary string into a palindrome, \\"NO\\" otherwise. # Count the number of 1s and 0s count_0 = S.count('0') count_1 = S.count('1') # For a palindrome, at most one character can have an odd count if count_0 % 2 == 0 or count_1 % 2 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_divisible_pairs(n: int, k: int, array: List[int]) -> int: Counts the pairs (i, j) such that the sum of array[i] and array[j] is divisible by k and i < j. >>> count_divisible_pairs(5, 3, [1, 2, 3, 4, 5]) 4 >>> count_divisible_pairs(4, 5, [10, 20, 30, 40]) 6 >>> count_divisible_pairs(6, 4, [4, 8, 12, 16, 20, 24]) 15 >>> count_divisible_pairs(3, 7, [1, 2, 3]) 0 >>> count_divisible_pairs(4, 2, [2, 4, 6, 8]) 6","solution":"def count_divisible_pairs(n, k, array): Counts the pairs (i, j) such that the sum of array[i] and array[j] is divisible by k and i < j. count = 0 for i in range(n): for j in range(i + 1, n): if (array[i] + array[j]) % k == 0: count += 1 return count"},{"question":"def longest_duration(pill_windows): Calculate the longest possible duration to take all the pills in sequence. Parameters: pill_windows (list): A list of integers representing the time windows for the pills. Returns: int: The longest possible duration to take all the pills. def process_datasets(datasets): Processes multiple datasets and returns the longest possible durations for each dataset. Parameters: datasets (list): A list of datasets. Each dataset is represented as a list with the first element being the number of pills and the following elements being the time windows for the pills. Returns: list: A list of integers representing the longest possible durations for each dataset. def main(input_data): Main function to process the input data and output the results. Parameters: input_data (str): A string representing the input data. Returns: list: A list of integers representing the longest possible durations for each dataset. # Unit tests def test_longest_duration(): assert longest_duration([5, 10, 20]) == 35 assert longest_duration([3, 5, 8, 13]) == 29 assert longest_duration([7]) == 7 assert longest_duration([]) == 0 def test_process_datasets(): datasets = [ [3, 5, 10, 20], [4, 3, 5, 8, 13], [1, 7] ] assert process_datasets(datasets) == [35, 29, 7] def test_main(): input_data = \\"3n5 10 20n4n3 5 8 13n1n7n0\\" assert main(input_data) == [35, 29, 7] input_data = \\"2n1 2n2n3 4n0\\" assert main(input_data) == [3, 7] input_data = \\"0\\" assert main(input_data) == [] # Running tests test_longest_duration() test_process_datasets() test_main()","solution":"def longest_duration(pill_windows): Calculate the longest possible duration to take all the pills in sequence. Parameters: pill_windows (list): A list of integers representing the time windows for the pills. Returns: int: The longest possible duration to take all the pills. if not pill_windows: return 0 return sum(pill_windows) def process_datasets(datasets): Processes multiple datasets and returns the longest possible durations for each dataset. Parameters: datasets (list): A list of datasets. Each dataset is represented as a list with the first element being the number of pills and the following elements being the time windows for the pills. Returns: list: A list of integers representing the longest possible durations for each dataset. results = [] for data in datasets: n = data[0] pill_windows = data[1:] results.append(longest_duration(pill_windows)) return results def main(input_data): Main function to process the input data and output the results. Parameters: input_data (str): A string representing the input data. Returns: list: A list of integers representing the longest possible durations for each dataset. lines = input_data.strip().split('n') datasets = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break pill_windows = list(map(int, lines[i + 1].split())) datasets.append([n] + pill_windows) i += 2 return process_datasets(datasets)"},{"question":"def max_area(heights: List[int]) -> int: Calculate the maximum amount of water the container can store formed by vertical lines represented as heights. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([1, 1]) 1 >>> max_area([3, 3, 3, 3, 3]) 12 >>> max_area([5, 4, 3, 2, 1]) 6 >>> max_area([1, 2, 3, 4, 5]) 6 >>> max_area([1, 2, 4, 3, 2, 1]) 6 >>> max_area([10, 1, 1, 1, 10]) 40 >>> max_area([100000] * 100000) 9999900000","solution":"def max_area(heights): left, right = 0, len(heights) - 1 max_water = 0 while left < right: # Calculate the amount of water that can be stored between the two lines height = min(heights[left], heights[right]) width = right - left current_water = height * width # Update max_water if current_water is greater max_water = max(max_water, current_water) # Move the pointer that points to the shorter line if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"def find_largest_palindrome(arr): Returns the largest palindromic string from the list of strings. If no palindromic string is found, returns an empty string. If the input is not a list, returns None. >>> find_largest_palindrome([\\"racecar\\", \\"level\\", \\"world\\", \\"abba\\"]) == \\"racecar\\" >>> find_largest_palindrome([\\"hello\\", \\"world\\"]) == \\"\\" >>> find_largest_palindrome(\\"not a list\\") == None >>> find_largest_palindrome([]) == \\"\\" >>> find_largest_palindrome([\\"abcba\\", 12321, \\"deified\\", None]) == \\"deified\\" >>> find_largest_palindrome([12345, \\"definitely not\\", None]) == \\"\\"","solution":"def find_largest_palindrome(arr): Returns the largest palindromic string from the list of strings. If no palindromic string is found, returns an empty string. If the input is not a list, returns None. if not isinstance(arr, list): return None largest_palindrome = \\"\\" for string in arr: if isinstance(string, str): normalized_str = string.lower() if normalized_str == normalized_str[::-1]: if len(string) > len(largest_palindrome): largest_palindrome = string return largest_palindrome"},{"question":"def process_image_data(M: int, N: int, image: List[List[int]], Q: int, adjustments: List[Tuple[int, int, int]]) -> List[List[int]]: Adjust the brightness of the image according to the given adjustments. Parameters: M (int): Number of rows in the image. N (int): Number of columns in the image. image (list of list of int): Initial pixel values of the image. Q (int): Number of adjustments. adjustments (list of tuple): List of adjustments (a, b, k). Returns: list of list of int: The adjusted image. Example: >>> process_image_data(3, 3, [[10, 20, 30], [40, 50, 60], [70, 80, 90]], 2, [(1, 2, 10), (2, 3, -15)]) [[10, 20, 30], [50, 60, 70], [55, 65, 75]]","solution":"def adjust_brightness(image, adjustments): Adjust the brightness of the image according to the given adjustments. Parameters: image (list of list of int): M x N matrix representing the image's pixel values. adjustments (list of tuple): List of adjustments (a, b, k). Returns: list of list of int: The adjusted image. for a, b, k in adjustments: for i in range(a - 1, b): image[i] = [pixel + k for pixel in image[i]] return image def process_image_data(M, N, image_values, Q, adjustments_values): Process the image data based on the inputs and adjustments. Parameters: M (int): Number of rows in the image. N (int): Number of columns in the image. image_values (list of list of int): Initial pixel values of the image. Q (int): Number of adjustments. adjustments_values (list of tuple): List of adjustments. Returns: list of list of int: The adjusted image. image = [[image_values[r][c] for c in range(N)] for r in range(M)] adjustments = [(adjustments_values[i][0], adjustments_values[i][1], adjustments_values[i][2]) for i in range(Q)] return adjust_brightness(image, adjustments)"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Find the length of the longest palindromic subsequence in a given string. A subsequence is a sequence that you can derive from another sequence by deleting some or no elements without changing the order of the remaining elements. >>> longest_palindromic_subsequence(\\"bbbab\\") 4 >>> longest_palindromic_subsequence(\\"cbbd\\") 2 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"ab\\") 1 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"abcde\\") 1 >>> longest_palindromic_subsequence(\\"aaaa\\") 4 pass","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindromic subsequence of length 1 for i in range(n): dp[i][i] = 1 # Build the dp array for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # Length of the longest palindromic subsequence return dp[0][n - 1]"},{"question":"def largest_sum_subarray_with_k_distinct(T, test_cases): Given an array of integers, find the sum of the elements of the largest contiguous subarray that contains at most \`K\` distinct integers. If there are multiple subarrays with the same sum, return the length of the smallest such subarray. >>> T = 3 >>> test_cases = [ >>> (5, [1, 2, 1, 2, 3], 2), >>> (6, [1, 2, 1, 3, 4, 3], 3), >>> (4, [1, 2, 3, 4], 2) >>> ] >>> largest_sum_subarray_with_k_distinct(T, test_cases) [4, 4, 2]","solution":"def largest_sum_subarray_with_k_distinct(T, test_cases): from collections import defaultdict def find_subarray_with_k_distinct(arr, K): n = len(arr) left = 0 max_sum = float('-inf') min_len = float('inf') current_sum = 0 freq = defaultdict(int) for right in range(n): freq[arr[right]] += 1 current_sum += arr[right] while len(freq) > K: current_sum -= arr[left] freq[arr[left]] -= 1 if freq[arr[left]] == 0: del freq[arr[left]] left += 1 if current_sum > max_sum: max_sum = current_sum min_len = right - left + 1 elif current_sum == max_sum: min_len = min(min_len, right - left + 1) return max_sum, min_len results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] K = test_cases[i][2] max_sum, min_len = find_subarray_with_k_distinct(arr, K) results.append(min_len) # As we are expected to output the length of smallest subarray with max sum return results # Example usage: T = 3 test_cases = [ (5, [1, 2, 1, 2, 3], 2), (6, [1, 2, 1, 3, 4, 3], 3), (4, [1, 2, 3, 4], 2) ] print(largest_sum_subarray_with_k_distinct(T, test_cases))"},{"question":"def median_age(ages: List[int]) -> int: Returns the median age from a list of ages. If there is an even number of ages, the function returns the smaller of the two middle ages. >>> median_age([34, 28, 43, 57, 41]) 41 >>> median_age([34, 28, 43, 57]) 34 >>> median_age([42]) 42 >>> median_age([25, 30]) 25 >>> median_age([10, 20, 30, 40, 50]) 30 >>> median_age([50, 40, 30, 20, 10]) 30 >>> median_age([25, 25, 25, 25, 25]) 25","solution":"def median_age(ages): Returns the median age from a list of ages. If there is an even number of ages, the function returns the smaller of the two middle ages. n = len(ages) sorted_ages = sorted(ages) mid = n // 2 if n % 2 == 0: return sorted_ages[mid - 1] else: return sorted_ages[mid]"},{"question":"from typing import List def unique_paths(grid: List[List[str]]) -> int: Find the number of unique paths in a grid from the top-left corner to the bottom-right corner, avoiding obstacles. >>> unique_paths([ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ]) 2 >>> unique_paths([ ['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.'] ]) 1 >>> unique_paths([ ['.', '.', '#'], ['#', '#', '#'], ['.', '.', '.'] ]) 0 def parse_input(input_str: str) -> List[List[str]]: Parses an input string representing the grid and returns it as a list of list of strings. >>> grid = parse_input(\\"3n..#n.#.n...\\") >>> grid == [ ['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.'] ] True from solution import unique_paths, parse_input def test_unique_paths_1(): input_str = 3 ... .#. ... grid = parse_input(input_str) assert unique_paths(grid) == 2 def test_unique_paths_2(): input_str = 3 ..# .#. ... grid = parse_input(input_str) assert unique_paths(grid) == 1 def test_unique_paths_3(): input_str = 3 ..# # ... grid = parse_input(input_str) assert unique_paths(grid) == 0 def test_unique_paths_single_cell(): input_str = 1 . grid = parse_input(input_str) assert unique_paths(grid) == 1 def test_unique_paths_single_cell_blocked(): input_str = 1 # grid = parse_input(input_str) assert unique_paths(grid) == 0 def test_unique_paths_large_grid(): input_str = 5 ..... .#..# .#..# ..... ..... grid = parse_input(input_str) assert unique_paths(grid) == 14 def test_parse_input(): input_str = 3 ..# .#. ... grid = parse_input(input_str) expected_grid = [ ['.', '.', '#'], ['.', '#', '.'], ['.', '.', '.'] ] assert grid == expected_grid","solution":"def unique_paths(grid): n = len(grid) if grid[0][0] == '#' or grid[-1][-1] == '#': return 0 dp = [[0]*n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def parse_input(input_str): lines = input_str.strip().split(\\"n\\") n = int(lines[0]) grid = [list(line) for line in lines[1:]] return grid"},{"question":"def validate_password(N: int, password: str) -> str: Validates a password based on given criteria. Args: N (int): The required length of the password. password (str): The password to be validated. Returns: str: \\"YES\\" if the password is valid, otherwise \\"NO\\". The password must meet the following criteria: 1. The password must be exactly N characters long. 2. The password must contain at least one uppercase letter. 3. The password must contain at least one lowercase letter. 4. The password must contain at least one digit. 5. The password must contain at least one special character from the set: @, #, , %, &, *. 6. The password must not contain any spaces. from typing import List def test_validate_password_valid(): assert validate_password(10, \\"Passw0rd@!\\") == \\"YES\\" def test_validate_password_no_uppercase(): assert validate_password(10, \\"password@1\\") == \\"NO\\" def test_validate_password_no_lowercase(): assert validate_password(10, \\"PASSWORD@1\\") == \\"NO\\" def test_validate_password_no_digit(): assert validate_password(10, \\"Password@!\\") == \\"NO\\" def test_validate_password_no_special_char(): assert validate_password(10, \\"Password01\\") == \\"NO\\" def test_validate_password_contains_space(): assert validate_password(12, \\"Pass word@1!\\") == \\"NO\\" def test_validate_password_incorrect_length(): assert validate_password(8, \\"Passw0rd@!\\") == \\"NO\\" assert validate_password(12, \\"Passw0rd@!\\") == \\"NO\\"","solution":"def validate_password(N, password): Validates a password based on given criteria. Args: N (int): The required length of the password. password (str): The password to be validated. Returns: str: \\"YES\\" if the password is valid, otherwise \\"NO\\". if len(password) != N: return \\"NO\\" has_upper = False has_lower = False has_digit = False has_special = False special_characters = \\"@#%&*\\" for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True if has_upper and has_lower and has_digit and has_special and ' ' not in password: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_subarray_sum(test_cases): Compute the maximum sum of a contiguous subarray for each test case. >>> max_subarray_sum([(5, -2, 1, -3, 4, -1, 2, 1, -5, 4), (1, -1), (8, 3, -1, -1, 4, 5, -2, 3, -5, 4)]) [6, -1, 11] >>> max_subarray_sum([(1, 7), (1, -4), (1, 0)]) [7, -4, 0] >>> max_subarray_sum([(3, -1, -2, -3), (4, -5, -4, -3, -2)]) [-1, -2] >>> max_subarray_sum([(6, -2, 4, -1, 2, 1, -5), (5, -2, -1, 3, 4, -2)]) [6, 7]","solution":"def max_subarray_sum(test_cases): results = [] for test in test_cases: N, *array = test max_current = max_global = array[0] for number in array[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current results.append(max_global) return results"},{"question":"def find_median(arr): Given an array of distinct integers, sorts the array and finds the median value. pass def process_test_cases(test_cases): Processes multiple test cases to find the median for each. Parameters: test_cases (list): List of tuples, each containing an integer N and a list of N integers. Returns: list: List of medians for each test case. pass # Test cases from solution import find_median, process_test_cases def test_find_median_odd(): assert find_median([10, 5, 1, 3, 9]) == 5 def test_find_median_even(): assert find_median([11, 2, 4, 8, 1, 6]) == 5.0 def test_find_median_single_element(): assert find_median([42]) == 42 def test_find_median_two_elements(): assert find_median([1, 3]) == 2.0 def test_process_test_cases(): test_cases = [ (5, [10, 5, 1, 3, 9]), (6, [11, 2, 4, 8, 1, 6]), (1, [42]), (2, [1, 3]) ] expected_results = [5, 5.0, 42, 2.0] assert process_test_cases(test_cases) == expected_results","solution":"def find_median(arr): Given an array of distinct integers, sorts the array and finds the median value. arr.sort() n = len(arr) if n % 2 == 1: return arr[n // 2] else: median = (arr[n // 2 - 1] + arr[n // 2]) / 2 return round(median, 1) def process_test_cases(test_cases): Processes multiple test cases to find the median for each. Parameters: test_cases (list): List of tuples, each containing an integer N and a list of N integers. Returns: list: List of medians for each test case. results = [] for N, array in test_cases: median = find_median(array) results.append(median) return results"},{"question":"def first_non_repeating_character(s: str) -> str: In a given string, find the first non-repeating character and return it. If it does not exist, return an empty character. >>> first_non_repeating_character(\\"swiss\\") \\"w\\" >>> first_non_repeating_character(\\"relevel\\") \\"r\\" >>> first_non_repeating_character(\\"aabbcc\\") \\"\\"","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the given string s. If it does not exist, return an empty character. char_count = {} # Count the occurrences of each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first non-repeating character for char in s: if char_count[char] == 1: return char return ''"},{"question":"def longest_non_decreasing_growth(heights): Returns the length of the longest continuous non-decreasing growth period in the given list of heights. :param heights: List of integers representing height measurements :return: Integer representing the longest continuous non-decreasing period >>> longest_non_decreasing_growth([1, 2, 2, 1, 3, 4, 1]) 3 >>> longest_non_decreasing_growth([5, 5, 5, 5, 5]) 5 >>> longest_non_decreasing_growth([1, 3, 2, 2, 2, 3]) 4 pass def process_test_cases(T, cases): Processes multiple test cases and returns a list of results for each test case. :param T: Integer - number of test cases :param cases: List of tuples where each tuple contains an integer N and a list of integer heights :return: List of integers representing the results of each test case >>> T = 3 >>> cases = [ ... (7, [1, 2, 2, 1, 3, 4, 1]), ... (5, [5, 5, 5, 5, 5]), ... (6, [1, 3, 2, 2, 2, 3]) ... ] >>> process_test_cases(T, cases) [3, 5, 4] pass","solution":"def longest_non_decreasing_growth(heights): Returns the length of the longest continuous non-decreasing growth period in the given list of heights. max_len = 1 curr_len = 1 for i in range(1, len(heights)): if heights[i] >= heights[i-1]: curr_len += 1 else: max_len = max(max_len, curr_len) curr_len = 1 return max(max_len, curr_len) def process_test_cases(T, cases): results = [] for t in range(T): N = cases[t][0] heights = cases[t][1] results.append(longest_non_decreasing_growth(heights)) return results"},{"question":"from typing import List, Tuple def handle_queries(n: int, values: List[int], edges: List[Tuple[int, int]], q: int, queries: List[int]) -> List[str]: Given a tree with \`n\` nodes and node values, determine if specified nodes are \\"balanced\\". A node is \\"balanced\\" if the sum of values in its left subtree is equal to the sum of values in its right subtree. n: Number of nodes values: List of node values edges: List of edges between nodes q: Number of queries queries: List of node queries Returns: List of \\"YES\\" or \\"NO\\" for each query indicating if the node is balanced. >>> handle_queries(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)], 2, [3, 2]) [\\"NO\\", \\"YES\\"]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.subtree_sum = value def calculate_subtree_sums(node): if node is None: return 0 left_sum = calculate_subtree_sums(node.left) right_sum = calculate_subtree_sums(node.right) node.subtree_sum += left_sum + right_sum return node.subtree_sum def is_balanced(node): if node is None: return True left_sum = node.left.subtree_sum if node.left else 0 right_sum = node.right.subtree_sum if node.right else 0 return left_sum == right_sum def construct_tree(values, edges): nodes = [None] + [TreeNode(v) for v in values] adjacency_list = [[] for _ in range(len(values) + 1)] for u, v in edges: adjacency_list[u].append(v) adjacency_list[v].append(u) def build_subtree(node_index, parent_index): for neighbor in adjacency_list[node_index]: if neighbor != parent_index: if nodes[node_index].left is None: nodes[node_index].left = nodes[neighbor] else: nodes[node_index].right = nodes[neighbor] build_subtree(neighbor, node_index) build_subtree(1, -1) # Assuming the root node is node 1 calculate_subtree_sums(nodes[1]) return nodes def process_queries(tree_nodes, queries): results = [] for query in queries: node = tree_nodes[query] if is_balanced(node): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to handle input and output processing def handle_queries(n, values, edges, q, queries): # Step 1: Construct the tree tree_nodes = construct_tree(values, edges) # Step 2: Process all queries results = process_queries(tree_nodes, queries) return results"},{"question":"def max_overlapping_events(events): Returns the maximum number of overlapping events. Args: events (list): A list of tuples containing start and end times of events. Returns: int: Maximum number of overlapping events at any point in time. pass # Example Test Case events = [(1, 4), (2, 5), (3, 6)] print(max_overlapping_events(events)) # Output: 3","solution":"def max_overlapping_events(events): Returns the maximum number of overlapping events. Args: events (list): A list of tuples containing start and end times of events. Returns: int: Maximum number of overlapping events at any point in time. # Create a sorted list of all start and end times with their type timeline = [] for start, end in events: timeline.append((start, 'start')) timeline.append((end, 'end')) # Sort the timeline; if times are the same, prioritize 'end' over 'start' timeline.sort(key=lambda x: (x[0], x[1] == 'start')) max_overlap = 0 current_overlap = 0 # Sweep through the timeline for time, event_type in timeline: if event_type == 'start': current_overlap += 1 if current_overlap > max_overlap: max_overlap = current_overlap else: current_overlap -= 1 return max_overlap def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) events = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(N)] print(max_overlapping_events(events))"},{"question":"def max_items(prices, budget): Returns the maximum number of items that can be bought without exceeding the budget and the total sum spent on these items. Args: prices (List[int]): List of prices of items. budget (int): The total budget available to spend. Returns: Tuple[int, int]: The maximum number of items that can be bought and the total sum spent. >>> max_items([1, 12, 5, 111, 200], 10) (2, 6) >>> max_items([1, 2, 3, 4, 5, 6, 7], 20) (5, 15) # Test cases def test_example_1(): prices = [1, 12, 5, 111, 200] budget = 10 assert max_items(prices, budget) == (2, 6) def test_example_2(): prices = [1, 2, 3, 4, 5, 6, 7] budget = 20 assert max_items(prices, budget) == (5, 15) def test_budget_exceeded_midway(): prices = [3, 5, 1, 8, 2] budget = 8 assert max_items(prices, budget) == (3, 6) def test_single_item_only(): prices = [10, 20, 30, 40] budget = 10 assert max_items(prices, budget) == (1, 10) def test_all_items_affordable(): prices = [1, 1, 1, 1] budget = 10 assert max_items(prices, budget) == (4, 4) def test_no_items_afforded(): prices = [50, 60, 70, 80] budget = 10 assert max_items(prices, budget) == (0, 0) def test_exact_budget(): prices = [1, 2, 3, 4] budget = 10 assert max_items(prices, budget) == (4, 10)","solution":"def max_items(prices, budget): Returns the maximum number of items that can be bought without exceeding the budget and the total sum spent on these items. prices.sort() total_spent = 0 count = 0 for price in prices: if total_spent + price <= budget: total_spent += price count += 1 else: break return count, total_spent"},{"question":"def has_subarray_with_sum(arr, target_sum): Determines if there is a subarray with a sum equal to target_sum in the array arr. >>> has_subarray_with_sum([1, 2, 3, 7, 5], 12) \\"YES\\" >>> has_subarray_with_sum([7, 1, 2], 9) \\"NO\\" pass def process_test_cases(test_cases): Processes multiple test cases. >>> process_test_cases([ ... {'N': 5, 'S': 12, 'arr': [1, 2, 3, 7, 5]}, ... {'N': 5, 'S': 15, 'arr': [1, 2, 3, 4, 5]}, ... {'N': 3, 'S': 9, 'arr': [7, 1, 2]}, ... ]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def has_subarray_with_sum(arr, target_sum): Determines if there is a subarray with a sum equal to target_sum in the array arr. current_sum = 0 prefix_sums = {} for i, num in enumerate(arr): current_sum += num if current_sum == target_sum: return \\"YES\\" if (current_sum - target_sum) in prefix_sums: return \\"YES\\" prefix_sums[current_sum] = i return \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases. results = [] for case in test_cases: N, S, arr = case['N'], case['S'], case['arr'] result = has_subarray_with_sum(arr, S) results.append(result) return results"},{"question":"def max_coins(N: int, M: int, grid: List[List[int]], x1: int, y1: int, K: int) -> int: Calculate the maximum number of coins the player can collect within K steps starting from (x1, y1). >>> max_coins(4, 4, [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 1, 1, 2) 2 >>> max_coins(3, 3, [[1, 1, 1], [1, 0, 1], [1, 1, 1]], 0, 0, 3) 4 >>> max_coins(3, 3, [[1, 1, 1], [1, 0, 1], [1, 1, 1]], 1, 1, 0) 0 >>> max_coins(2, 2, [[1, 1], [1, 1]], 0, 0, 2) 3 >>> max_coins(1, 1, [[1]], 0, 0, 1) 1","solution":"def max_coins(N, M, grid, x1, y1, K): from collections import deque # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS: (current_x, current_y, steps_left, current_coins) queue = deque([(x1, y1, K, grid[x1][y1])]) max_coins_collected = 0 # Seen states: (x, y, steps_left) seen = set() seen.add((x1, y1, K)) while queue: x, y, steps, coins_collected = queue.popleft() max_coins_collected = max(max_coins_collected, coins_collected) if steps > 0: for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny, steps - 1) not in seen: queue.append((nx, ny, steps - 1, coins_collected + grid[nx][ny])) seen.add((nx, ny, steps - 1)) return max_coins_collected"},{"question":"def max_profit(prices): Function to compute the maximum profit by buying and selling stocks as many times as needed. :param prices: List of stock prices :return: The maximum profit achievable >>> max_profit([7, 1, 5, 3, 6, 4]) 7 >>> max_profit([1, 2, 3, 4, 5]) 4 pass","solution":"def max_profit(prices): Function to compute the maximum profit by buying and selling stocks as many times as needed. :param prices: List of stock prices :return: The maximum profit achievable if not prices: return 0 total_profit = 0 for i in range(1, len(prices)): if prices[i] > prices[i - 1]: total_profit += prices[i] - prices[i - 1] return total_profit"},{"question":"def lexicographically_smallest_possible_string(t: int, test_cases: List[str]) -> List[str]: Determine the lexicographically smallest string achievable by rearranging the string characters as described in the problem statement using the specified operation. Parameters: t : int Number of test cases. test_cases : list of str List of strings representing each test case. Returns: list of str Lexicographically smallest strings for each test case. >>> lexicographically_smallest_possible_string(3, [\\"bacd\\", \\"dcba\\", \\"badc\\"]) [\\"abcd\\", \\"abcd\\", \\"abcd\\"] >>> lexicographically_smallest_possible_string(2, [\\"zyxw\\", \\"mnop\\"]) [\\"wxyz\\", \\"mnop\\"] def test_lexicographically_smallest_possible_string(): Unit test for lexicographically_smallest_possible_string() function. t1 = 3 test_cases1 = [\\"bacd\\", \\"dcba\\", \\"badc\\"] expected1 = [\\"abcd\\", \\"abcd\\", \\"abcd\\"] assert lexicographically_smallest_possible_string(t1, test_cases1) == expected1 t2 = 2 test_cases2 = [\\"zyxw\\", \\"mnop\\"] expected2 = [\\"wxyz\\", \\"mnop\\"] assert lexicographically_smallest_possible_string(t2, test_cases2) == expected2 t3 = 1 test_cases3 = [\\"a\\"] expected3 = [\\"a\\"] assert lexicographically_smallest_possible_string(t3, test_cases3) == expected3 t4 = 1 test_cases4 = [\\"ab\\"] expected4 = [\\"ab\\"] assert lexicographically_smallest_possible_string(t4, test_cases4) == expected4 t5 = 1 test_cases5 = [\\"ba\\"] expected5 = [\\"ab\\"] assert lexicographically_smallest_possible_string(t5, test_cases5) == expected5 t6 = 0 test_cases6 = [] expected6 = [] assert lexicographically_smallest_possible_string(t6, test_cases6) == expected6","solution":"def lexicographically_smallest_possible_string(t, test_cases): Determines the lexicographically smallest string achievable by rearranging the string characters as described in the problem statement using the specified operation. Parameters: t : int Number of test cases. test_cases : list of str List of strings representing each test case. Returns: list of str Lexicographically smallest strings for each test case. def get_smallest_string(s): return ''.join(sorted(s)) results = [] for s in test_cases: results.append(get_smallest_string(s)) return results # Test cases input t = 3 test_cases = [\\"bacd\\", \\"dcba\\", \\"badc\\"] # Call the function and print outputs results = lexicographically_smallest_possible_string(t, test_cases) for result in results: print(result)"},{"question":"def snake_pattern(n, m): Creates an n x m matrix filled with distinct integers from 1 to n*m in a snake pattern. pass def format_matrix(matrix): Formats the matrix into a string for easy comparison and printing. pass # Example usage: if __name__ == \\"__main__\\": # Example 1 result = snake_pattern(3, 4) print(format_matrix(result)) # Example 2 result = snake_pattern(2, 3) print(format_matrix(result))","solution":"def snake_pattern(n, m): Creates an n x m matrix filled with distinct integers from 1 to n*m in a snake pattern. matrix = [[0] * m for _ in range(n)] num = 1 for i in range(n): if i % 2 == 0: for j in range(m): matrix[i][j] = num num += 1 else: for j in range(m-1, -1, -1): matrix[i][j] = num num += 1 return matrix def format_matrix(matrix): Formats the matrix into a string for easy comparison and printing. return \\"n\\".join(\\" \\".join(str(cell) for cell in row) for row in matrix)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convertBST(root: TreeNode) -> TreeNode: Transform the given BST into a greater tree where every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. Example 1: >>> root1 = build_tree_from_list([5,2,13]) >>> tree_to_list(convertBST(root1)) [18, 20, 13] Example 2: >>> root2 = build_tree_from_list([2,0,3,-4,1]) >>> tree_to_list(convertBST(root2)) [5, 6, 3, 2, 6] Example 3: >>> root3 = build_tree_from_list([0, None, 1]) >>> tree_to_list(convertBST(root3)) [1, None, 1] # Implement your code here pass def build_tree_from_list(vals): if not vals: return None root = TreeNode(vals[0]) queue = [root] i = 1 while i < len(vals): node = queue.pop(0) if vals[i] is not None: node.left = TreeNode(vals[i]) queue.append(node.left) i += 1 if i < len(vals) and vals[i] is not None: node.right = TreeNode(vals[i]) queue.append(node.right) i += 1 return root def tree_to_list(root): res = [] queue = [root] while queue: node = queue.pop(0) if node: res.append(node.val) queue.append(node.left) queue.append(node.right) else: res.append(None) while res and res[-1] is None: res.pop() return res","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def convertBST(root: TreeNode) -> TreeNode: Transform the given BST into a greater tree where every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. sum_greater = 0 def reverse_inorder_traversal(node): nonlocal sum_greater if node is not None: reverse_inorder_traversal(node.right) sum_greater += node.val node.val = sum_greater reverse_inorder_traversal(node.left) reverse_inorder_traversal(root) return root"},{"question":"def has_zero_sum_subarray(b): Determine if there exists a non-empty contiguous subarray with a sum of zero. Parameters: b (list of int): The input array Returns: str: \\"YES\\" if such subarray exists, otherwise \\"NO\\" >>> has_zero_sum_subarray([4, -3, 2, 1, 6]) 'YES' >>> has_zero_sum_subarray([1, 2, -2, 5]) 'YES' >>> has_zero_sum_subarray([3, 4, 5]) 'NO' pass def process_test_cases(test_cases): Process multiple test cases for the zero-sum subarray problem. Parameters: test_cases (list of tuples): Each tuple contains an integer followed by a list of integers. Returns: list of str: For each test case, returns \\"YES\\" if there is a zero-sum subarray, otherwise \\"NO\\". >>> test_cases = [ ... (5, [4, -3, 2, 1, 6]), ... (4, [1, 2, -2, 5]), ... (3, [3, 4, 5]) ... ] >>> process_test_cases(test_cases) ['YES', 'YES', 'NO'] pass","solution":"def has_zero_sum_subarray(b): Determine if there exists a non-empty contiguous subarray with a sum of zero. Parameters: b (list of int): The input array Returns: str: \\"YES\\" if such subarray exists, otherwise \\"NO\\" # Using a set to store the prefix sums encountered prefix_sum_set = set() prefix_sum = 0 for num in b: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sum_set: return \\"YES\\" prefix_sum_set.add(prefix_sum) return \\"NO\\" def process_test_cases(test_cases): results = [] for m, b in test_cases: results.append(has_zero_sum_subarray(b)) return results"},{"question":"def generate_matrix(N, K): Generate an N x N matrix where each cell contains a value that is the sum of its row index and column index, multiplied by a given factor K. Args: - N (int): The size of the matrix (N x N) - K (int): The factor to multiply the sum of indices Returns: - List[List[int]]: The generated matrix >>> generate_matrix(3, 2) [[0, 2, 4], [2, 4, 6], [4, 6, 8]] >>> generate_matrix(2, 5) [[0, 5], [5, 10]] def solve(test_cases): Process multiple test cases to generate matrices. Args: - test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains (N, K) for each test case. Returns: - List[List[List[int]]]: List of generated matrices for each test case >>> test_cases = [(3, 2), (2, 5)] >>> solve(test_cases) [[[0, 2, 4], [2, 4, 6], [4, 6, 8]], [[0, 5], [5, 10]]]","solution":"def generate_matrix(N, K): matrix = [] for i in range(N): row = [] for j in range(N): row.append((i + j) * K) matrix.append(row) return matrix def solve(test_cases): results = [] for N, K in test_cases: matrix = generate_matrix(N, K) results.append(matrix) return results"},{"question":"def crypto_number(n: int) -> int: Returns the nth Crypto Number. The function calculates the nth Crypto Number in the Cryptonia sequence. For example: >>> crypto_number(1) 1 >>> crypto_number(2) 1 >>> crypto_number(3) 2 >>> crypto_number(4) 4 >>> crypto_number(5) 8 Parameters: n (int): The position in the Crypto Number sequence. Returns: int: The nth Crypto Number.","solution":"def crypto_number(n): Returns the nth Crypto Number. Parameters: n (int): The position in the Crypto Number sequence. Returns: int: The nth Crypto Number. if n == 1 or n == 2: return 1 # Base case - first two numbers are both 1 crypto_numbers = [1, 1] # Calculate recursively for n > 2 for i in range(2, n): next_crypto_num = sum(crypto_numbers) crypto_numbers.append(next_crypto_num) return crypto_numbers[-1]"},{"question":"def sheldon_selection_sort(arr): Sorts a list of integers using Sheldon's Selection Sort algorithm. >>> sheldon_selection_sort([3, 1, 2]) [1, 2, 3] >>> sheldon_selection_sort([4, 7, 1, 3, 2]) [1, 2, 3, 4, 7] pass def sort_all_cases(test_cases): Sorts each test case using Sheldon's Selection Sort and returns results as strings. >>> sort_all_cases([[3, 1, 2], [4, 7, 1, 3, 2]]) ['1 2 3', '1 2 3 4 7'] pass def main(input_data): Reads input data, processes each test case using Sheldon's Selection Sort and prints the sorted results. >>> main(\\"2n3 1 2n4 7 1 3 2\\") 1 2 3 1 2 3 4 7 pass","solution":"def sheldon_selection_sort(arr): Sorts a list of integers using Sheldon's Selection Sort algorithm. n = len(arr) for i in range(n-1, 0, -1): max_idx = 0 for j in range(1, i+1): if arr[j] > arr[max_idx]: max_idx = j # Swap the found maximum element with the last unsorted element arr[i], arr[max_idx] = arr[max_idx], arr[i] return arr def sort_all_cases(test_cases): results = [] for case in test_cases: sorted_case = sheldon_selection_sort(case) results.append(' '.join(map(str, sorted_case))) return results def main(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [list(map(int, line.split())) for line in input_lines[1:T+1]] results = sort_all_cases(test_cases) for result in results: print(result) # Example usage input_data = \\"2n3 1 2n4 7 1 3 2\\" main(input_data)"},{"question":"def findUniqueElements(arr: List[int]) -> List[int]: This function takes an array as input and returns a list of unique elements in the order they appeared in the original array. >>> findUniqueElements([3, 4, 3, 2, 4, 5]) [3, 4, 2, 5] >>> findUniqueElements([1, 2, 2, 3, 3]) [1, 2, 3]","solution":"def findUniqueElements(arr): This function takes an array as input and returns a list of unique elements in the order they appeared in the original array. seen = set() unique = [] for item in arr: if item not in seen: seen.add(item) unique.append(item) return unique"},{"question":"def largest_possible_rectangle_area(n: int, rectangles: List[Tuple[int, int]]) -> int: Determine the total area of the largest possible rectangle that can be formed by combining some (or all) of the given n rectangles. >>> largest_possible_rectangle_area(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 20 >>> largest_possible_rectangle_area(3, [(5, 5), (10, 10), (15, 15)]) 225","solution":"def largest_possible_rectangle_area(n, rectangles): max_area = 0 for width, height in rectangles: max_area = max(max_area, width * height) return max_area # Example usage: # n = 4 # rectangles = [(1, 2), (2, 3), (3, 4), (4, 5)] # print(largest_possible_rectangle_area(n, rectangles)) # Output: 20"},{"question":"def triangleNumber(nums: List[int]) -> int: Returns the number of triplets chosen from the array that can make triangles if taken as side lengths of a triangle. >>> triangleNumber([2, 2, 3, 4]) 3 >>> triangleNumber([4, 2, 3, 4]) 4 >>> triangleNumber([1, 1, 1]) 1","solution":"def triangleNumber(nums): Returns the number of triplets chosen from the array that can make triangles if taken as side lengths of a triangle. nums.sort() count = 0 for i in range(len(nums)-2): k = i + 2 for j in range(i + 1, len(nums)): while k < len(nums) and nums[i] + nums[j] > nums[k]: k += 1 count += k - j - 1 return count"},{"question":"from typing import List def max_trapped_water(arr: List[int]) -> int: Returns the maximum area of water that can be trapped between two lines. >>> max_trapped_water([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_trapped_water([4, 3, 2, 1, 4]) 16","solution":"from typing import List def max_trapped_water(arr: List[int]) -> int: Returns the maximum area of water that can be trapped between two lines. left = 0 right = len(arr) - 1 max_area = 0 while left < right: height = min(arr[left], arr[right]) width = right - left current_area = height * width max_area = max(max_area, current_area) if arr[left] <= arr[right]: left += 1 else: right -= 1 return max_area"},{"question":"from typing import List def min_height_difference(n: int, heights: List[int]) -> int: Returns the minimal possible difference between the tallest and shortest tree left after chopping down N/2 trees. Args: n (int): Number of trees, guaranteed to be even. heights (List[int]): Heights of the trees. Returns: int: Minimal possible difference between the tallest remaining tree and the shortest remaining tree. >>> min_height_difference(6, [2, 9, 3, 4, 7, 6]) 2 >>> min_height_difference(4, [10, 1, 9, 2]) 1","solution":"from typing import List def min_height_difference(n: int, heights: List[int]) -> int: Returns the minimal possible difference between the tallest and shortest tree left after chopping down N/2 trees. heights.sort() k = n // 2 min_diff = float('inf') for i in range(n - k + 1): diff = heights[i + k - 1] - heights[i] if diff < min_diff: min_diff = diff return min_diff"},{"question":"def longestCommonSubstring(s1: str, s2: str) -> str: Function to find the longest common substring between two given strings. Args: s1 (str): First string. s2 (str): Second string. Returns: str: The longest common substring. Examples: >>> longestCommonSubstring(\\"abcdef\\", \\"zcdemf\\") 'cde' >>> longestCommonSubstring(\\"ABC\\", \\"DEF\\") '' def test_longest_common_substring(): assert longestCommonSubstring(\\"abcdef\\", \\"zcdemf\\") == \\"cde\\" assert longestCommonSubstring(\\"ABC\\", \\"DEF\\") == \\"\\" assert longestCommonSubstring(\\"same\\", \\"same\\") == \\"same\\" assert longestCommonSubstring(\\"abc\\", \\"abcxyz\\") == \\"abc\\" assert longestCommonSubstring(\\"xyzabc\\", \\"abc\\") == \\"abc\\" assert longestCommonSubstring(\\"\\", \\"abc\\") == \\"\\" assert longestCommonSubstring(\\"abc\\", \\"\\") == \\"\\" assert longestCommonSubstring(\\"abcdxyz\\", \\"xyzabcd\\") == \\"abcd\\"","solution":"def longestCommonSubstring(s1, s2): Function to find the longest common substring between two given strings. # Base case: If either string is empty, return an empty string if not s1 or not s2: return \\"\\" n, m = len(s1), len(s2) # Create a DP table to store lengths of longest common suffixes of substrings dp = [[0] * (m + 1) for _ in range(n + 1)] max_length = 0 end_index_s1 = 0 for i in range(1, n + 1): for j in range(1, m + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_length: max_length = dp[i][j] end_index_s1 = i # Extract the longest common substring if max_length == 0: return \\"\\" longest_substring = s1[end_index_s1 - max_length : end_index_s1] return longest_substring"},{"question":"def find_max_non_overlapping_activities(N, activities): Finds the maximum number of non-overlapping activities and their IDs. Parameters: N (int): The number of activities. activities (list of tuples): List of tuples, where each tuple contains (Activity ID, Start time, End time). Returns: tuple: A tuple containing the maximum number of non-overlapping activities and the list of their IDs. pass from solution import find_max_non_overlapping_activities def test_example_case(): N = 5 activities = [(1, 1, 4), (2, 3, 5), (3, 0, 6), (4, 5, 7), (5, 8, 9)] result = find_max_non_overlapping_activities(N, activities) assert result == (3, [1, 4, 5]) def test_no_overlap(): N = 3 activities = [(1, 1, 2), (2, 2, 3), (3, 3, 4)] result = find_max_non_overlapping_activities(N, activities) assert result == (3, [1, 2, 3]) def test_total_overlap(): N = 3 activities = [(1, 1, 4), (2, 2, 6), (3, 3, 8)] result = find_max_non_overlapping_activities(N, activities) assert result == (1, [1]) def test_partial_overlap(): N = 4 activities = [(1, 1, 3), (2, 2, 4), (3, 3, 5), (4, 5, 6)] result = find_max_non_overlapping_activities(N, activities) assert result == (3, [1, 3, 4]) def test_single_activity(): N = 1 activities = [(1, 1, 2)] result = find_max_non_overlapping_activities(N, activities) assert result == (1, [1])","solution":"def find_max_non_overlapping_activities(N, activities): Finds the maximum number of non-overlapping activities and their IDs. Parameters: N (int): The number of activities. activities (list of tuples): List of tuples, where each tuple contains (Activity ID, Start time, End time). Returns: tuple: A tuple containing the maximum number of non-overlapping activities and the list of their IDs. # Sort activities by their end times activities.sort(key=lambda x: x[2]) max_activities = [] last_end_time = -1 for activity in activities: if activity[1] >= last_end_time: max_activities.append(activity[0]) last_end_time = activity[2] return len(max_activities), max_activities"},{"question":"def unique_paths_with_obstacles(m: int, n: int, grid: List[List[int]]) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. >>> unique_paths_with_obstacles(3, 3, [[0,0,0],[0,1,0],[0,0,0]]) 2 >>> unique_paths_with_obstacles(3, 3, [[0,1,0],[0,1,0],[0,0,0]]) 1 >>> unique_paths_with_obstacles(2, 2, [[0,1],[0,0]]) 1 >>> unique_paths_with_obstacles(1, 1, [[0]]) 1 >>> unique_paths_with_obstacles(1, 1, [[1]]) 0","solution":"def unique_paths_with_obstacles(m, n, grid): Returns the number of unique paths from the top-left corner to the bottom-right corner of a grid, avoiding obstacles. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def min_moves(grid, start, target): Calculate the minimum number of moves required to reach the target position from the start position in the grid. The grid is represented by a list of strings, where '.' indicates a free space and '#' indicates an obstacle. The start and target positions are tuples (x, y) representing the row and column on the grid. >>> min_moves([\\"....\\", \\"..#.\\", \\"....\\"], (0, 0), (2, 3)) 5 >>> min_moves([ \\".....\\", \\".....\\", \\".....\\" ], (0, 0), (2, 4)) 6 >>> min_moves([ \\".....\\", \\"#\\", \\".....\\" ], (0, 0), (2, 4)) -1 >>> min_moves([ \\".....\\", \\".....\\", \\".....\\" ], (1, 2), (1, 2)) 0 >>> min_moves([ \\".#.\\", \\"#.#\\", \\".#.\\" ], (0, 0), (2, 2)) -1 >>> min_moves([ \\"..........\\", \\"...#......\\", \\"..........\\", \\"..........\\", \\"......#...\\", \\"..........\\", \\"..........\\", \\"..........\\", \\"......#...\\", \\"..........\\" ], (0, 0), (9, 9)) 18","solution":"from collections import deque def min_moves(grid, start, target): Calculate the minimum number of moves required to reach the target position from the start position in the grid. rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == '.' queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == target: return dist for dx, dy in directions: new_x, new_y = x + dx, y + dy if is_valid(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, dist + 1)) return -1"},{"question":"def generate_clues(T, test_cases): Generates clues for the nearest treasure distance for each test case. Args: T (int): Number of test cases test_cases (list): List of tuples, [(N, path), ...] where N is the path's length, path is a list of integers 0 or 1 Returns: list: List of results for each test case with clues in them >>> generate_clues(2, [(5, [1, 0, 0, 1, 1]), (6, [1, 1, 0, 1, 1, 0])]) [[1, 0, 0, 1, 2], [2, 1, 0, 1, 1, 0]] >>> generate_clues(1, [(1, [0])]) [[0]] def format_output(results): Formats the output for each test case result. Args: results (list): List of results for each test case Returns: str: Formatted string output for each test case result >>> format_output([[1, 0, 0, 1, 2], [2, 1, 0, 1, 1, 0]]) '1 0 0 1 2n2 1 0 1 1 0'","solution":"def generate_clues(T, test_cases): Generates clues for the nearest treasure distance for each test case. :param T: Number of test cases :param test_cases: List of tuples, [(N, path), ...] where N is the path's length, path is a list of integers 0 or 1 :return: List of results for each test case with clues in them results = [] for N, path in test_cases: clues = [float('inf')] * N # First pass (left to right) last_treasure_index = -1 for i in range(N): if path[i] == 0: clues[i] = 0 last_treasure_index = i elif last_treasure_index != -1: clues[i] = i - last_treasure_index # Second pass (right to left) last_treasure_index = -1 for i in range(N - 1, -1, -1): if path[i] == 0: last_treasure_index = i elif last_treasure_index != -1: clues[i] = min(clues[i], last_treasure_index - i) results.append(clues) return results def format_output(results): Formats the output for each test case result. :param results: List of results for each test case :return: Formatted string output for each test case result output_lines = [] for clues in results: output_lines.append(\\" \\".join(map(str, clues))) return \\"n\\".join(output_lines)"},{"question":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using a bottom-up dynamic programming approach. >>> fibonacci(0) # Output: 0 >>> fibonacci(1) # Output: 1 >>> fibonacci(10) # Output: 55 >>> fibonacci(20) # Output: 6765","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def areAnagrams(str1: str, str2: str) -> str: This function checks if two strings are anagrams of each other. Returns \\"YES\\" if the strings are anagrams, \\"NO\\" otherwise. >>> areAnagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> areAnagrams(\\"triangle\\", \\"integral\\") \\"YES\\" >>> areAnagrams(\\"apple\\", \\"papel\\") \\"YES\\" >>> areAnagrams(\\"rat\\", \\"car\\") \\"NO\\" >>> areAnagrams(\\"hello\\", \\"billion\\") \\"NO\\" >>> areAnagrams(\\"anagram\\", \\"nagaram\\") \\"YES\\" >>> areAnagrams(\\"abcd\\", \\"dcba\\") \\"YES\\" >>> areAnagrams(\\"abc\\", \\"def\\") \\"NO\\" >>> areAnagrams(\\"a\\", \\"a\\") \\"YES\\" >>> areAnagrams(\\"a\\", \\"b\\") \\"NO\\" >>> areAnagrams(\\"ab\\", \\"ba\\") \\"YES\\" >>> areAnagrams(\\"\\", \\"\\") \\"YES\\"","solution":"def areAnagrams(str1, str2): This function checks if two strings are anagrams of each other. :param str1: First string :param str2: Second string :return: \\"YES\\" if the strings are anagrams, \\"NO\\" otherwise # Anagrams should have the same length and the same sorted characters if sorted(str1) == sorted(str2): return \\"YES\\" else: return \\"NO\\""},{"question":"def evaluate_expression(expression: str) -> int: Evaluates the arithmetic expression consisting of non-negative integers, addition, and multiplication operations. >>> evaluate_expression(\\"3 + 5 * 2\\") 13 >>> evaluate_expression(\\"10 + 2 * 3 + 5\\") 21","solution":"def evaluate_expression(expression: str) -> int: Evaluates the arithmetic expression consisting of non-negative integers, addition, and multiplication operations. tokens = expression.split() stack = [] i = 0 while i < len(tokens): if tokens[i] == '*': last = stack.pop() next_val = int(tokens[i + 1]) stack.append(last * next_val) i += 2 else: stack.append(int(tokens[i]) if tokens[i].isdigit() else tokens[i]) i += 1 result = stack[0] for i in range(1, len(stack)): if stack[i] == '+': result += stack[i + 1] return result"},{"question":"def max_sum_subarray(arr, k): Finds the maximum sum of any contiguous subarray of size k. >>> max_sum_subarray([1, 2, 3, 4, 5, 6, 7, 8], 3) 21 >>> max_sum_subarray([5], 1) 5 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray([], 3) 0 >>> max_sum_subarray([1, 2, 3], 5) 0 >>> max_sum_subarray([-1, 1, -1, 1, -1, 1, -1], 2) 0","solution":"def max_sum_subarray(arr, k): Finds the maximum sum of any contiguous subarray of size k. :param arr: List[int] - The list of integers. :param k: int - Size of the contiguous subarray. :return: int - The maximum sum of any contiguous subarray of size k. n = len(arr) if n < k or k == 0: return 0 # Compute the sum of the first window max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the array for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_palindrome_length(n: int, s: str) -> int: Determines the length of the longest palindrome that can be constructed using the characters of the given string. Args: n (int): The length of the string. s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest palindrome that can be constructed. >>> longest_palindrome_length(7, \\"abccccdd\\") 7 >>> longest_palindrome_length(5, \\"aabbc\\") 5 >>> longest_palindrome_length(3, \\"abc\\") 1","solution":"def longest_palindrome_length(n, s): Determines the length of the longest palindrome that can be constructed using the characters of the given string. Args: n (int): The length of the string. s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest palindrome that can be constructed. from collections import Counter char_count = Counter(s) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True # Add one to the length if an odd frequency character was found (to place it in the center of the palindrome) if odd_found: length += 1 return length"},{"question":"def find_odd(lst): Finds the integer that appears an odd number of times in the provided list. Parameters: lst (list): A list of integers where exactly one integer appears an odd number of times. Returns: int: The integer that appears an odd number of times. pass","solution":"def find_odd(lst): Finds the integer that appears an odd number of times in the provided list. Parameters: lst (list): A list of integers where exactly one integer appears an odd number of times. Returns: int: The integer that appears an odd number of times. result = 0 for num in lst: result ^= num return result"},{"question":"def count_unique_pairs(nums: List[int], target: int) -> int: Returns the number of unique pairs in the list that sum up to the target value. >>> count_unique_pairs([1, 2, 3, 4, 5], 5) 2 >>> count_unique_pairs([1, 1, 1, 1], 3) 0","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs in the list that sum up to the target value. seen = set() pairs = set() for num in nums: needed = target - num if needed in seen: pairs.add((min(num, needed), max(num, needed))) seen.add(num) return len(pairs)"},{"question":"def find_largest_y(A: int, B: int) -> int: Finds the largest integer Y such that Y * Y <= A * B. >>> find_largest_y(10, 5) 7 >>> find_largest_y(100, 20) 44 >>> find_largest_y(15, 15) 15 >>> find_largest_y(50, 50) 50 >>> find_largest_y(1, 1) 1 >>> find_largest_y(2, 1) 1 >>> find_largest_y(4, 4) 4 >>> find_largest_y(10**9, 10**9) 10**9 >>> find_largest_y(10**5, 10**5) 100000 >>> find_largest_y(1, 2) 1 >>> find_largest_y(3, 3) 3","solution":"def find_largest_y(A, B): Finds the largest integer Y such that Y * Y <= A * B. low, high = 1, A * B result = 0 product = A * B while low <= high: mid = (low + high) // 2 if mid * mid <= product: result = mid low = mid + 1 else: high = mid - 1 return result"},{"question":"from typing import List def get_movie_category(average_rating: float) -> str: Determine the category based on the average rating. >>> get_movie_category(4.5) \\"Excellent\\" >>> get_movie_category(3.5) \\"Good\\" >>> get_movie_category(2.5) \\"Fair\\" >>> get_movie_category(2.0) \\"Poor\\" pass def evaluate_movies(input_data: List[str]) -> List[str]: Evaluate the ratings for different movies based on user inputs. Each user provides a rating for a movie, ranked on a scale from 1 to 5. Calculate the average rating for each movie and determine the rating category. >>> evaluate_movies([ \\"3\\", \\"5\\", \\"4\\", \\"5\\", \\"4\\", \\"1\\", \\"5\\", \\"5\\", \\"5\\", \\"2\\", \\"1\\", \\"2\\", \\"0\\" ]) [\\"4.7 Excellent\\", \\"4.0 Good\\", \\"1.5 Poor\\"] >>> evaluate_movies([ \\"2\\", \\"5\\", \\"5\\", \\"3\\", \\"4\\", \\"5\\", \\"5\\", \\"0\\" ]) [\\"5.0 Excellent\\", \\"4.7 Excellent\\"] >>> evaluate_movies([ \\"3\\", \\"1\\", \\"2\\", \\"1\\", \\"4\\", \\"1\\", \\"2\\", \\"2\\", \\"1\\", \\"0\\" ]) [\\"1.3 Poor\\", \\"1.5 Poor\\"] >>> evaluate_movies([ \\"5\\", \\"5\\", \\"4\\", \\"3\\", \\"2\\", \\"1\\", \\"3\\", \\"3\\", \\"3\\", \\"3\\", \\"4\\", \\"4\\", \\"4\\", \\"4\\", \\"4\\", \\"0\\" ]) [\\"3.0 Fair\\", \\"3.0 Fair\\", \\"4.0 Good\\"] pass","solution":"def get_movie_category(average_rating): if average_rating >= 4.5: return \\"Excellent\\" elif 3.5 <= average_rating < 4.5: return \\"Good\\" elif 2.5 <= average_rating < 3.5: return \\"Fair\\" else: return \\"Poor\\" def evaluate_movies(input_data): results = [] index = 0 while index < len(input_data): n = int(input_data[index]) if n == 0: break index += 1 ratings = [] for _ in range(n): ratings.append(int(input_data[index])) index += 1 average_rating = sum(ratings) / n category = get_movie_category(average_rating) results.append(f\\"{average_rating:.1f} {category}\\") return results"},{"question":"from typing import List def maxSubarraySum(arr: List[int]) -> int: Function to find the maximum sum of a subarray and if multiple subarrays have the same maximum sum, returns the length of the longest subarray with that sum. :param arr: List[int] - Input list of integers :return: int - The maximum sum of the subarray pass def test_maxSubarraySum_single_element(): assert maxSubarraySum([1]) == 1 assert maxSubarraySum([-1]) == -1 def test_maxSubarraySum_all_positive(): assert maxSubarraySum([1, 2, 3, 4, 5]) == 15 def test_maxSubarraySum_all_negative(): assert maxSubarraySum([-1, -2, -3, -4, -5]) == -1 def test_maxSubarraySum_mixed_elements(): assert maxSubarraySum([1, -2, 3, 5, -1, 2]) == 9 assert maxSubarraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert maxSubarraySum([4, -1, 2, 1, -5, 4]) == 6 def test_maxSubarraySum_multiple_max_sums(): # multiple subarrays with max sum 6: [4, -1, 2, 1], [4, -1, 2, 1, -5, 5, 1] assert maxSubarraySum([4, -1, 2, 1, -5, 5, 1]) == 7 assert maxSubarraySum([1, 2, 3, -2, 5, -4, 6, -5]) == 11","solution":"def maxSubarraySum(arr): Function to find the maximum sum of a subarray and if multiple subarrays have the same maximum sum, returns the length of the longest subarray with that sum. :param arr: List[int] - Input list of integers :return: int - The maximum sum of the subarray max_sum = float('-inf') current_sum = 0 max_length = 0 current_length = 0 for num in arr: if current_sum < 0: current_sum = num current_length = 1 else: current_sum += num current_length += 1 if current_sum > max_sum: max_sum = current_sum max_length = current_length elif current_sum == max_sum: max_length = max(max_length, current_length) return max_sum"},{"question":"def three_sum(nums): Finds all unique triplets in the array which give the sum of zero. Parameters: nums (List[int]): An integer array Returns: List[List[int]]: A list of unique triplets which gives the sum of zero. Examples: >>> three_sum([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([0, 0, 0, 0, 0]) [[0, 0, 0]] >>> three_sum([1, 2, -2, -1]) [] pass def test_three_sum_example1(): assert three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] def test_three_sum_example2(): assert three_sum([0, 0, 0, 0, 0]) == [[0, 0, 0]] def test_three_sum_no_triplets(): assert three_sum([1, 2, -2, -1]) == [] def test_three_sum_all_negative(): assert three_sum([-5, -4, -3, -2, -1]) == [] def test_three_sum_all_positive(): assert three_sum([1, 2, 3, 4, 5]) == [] def test_three_sum_mix(): assert three_sum([-25, -10, -7, -3, 2, 4, 8, 10]) == [[-10, 2, 8], [-7, -3, 10]] def test_three_sum_empty(): assert three_sum([]) == [] def test_three_sum_single_element(): assert three_sum([0]) == [] def test_three_sum_two_elements(): assert three_sum([0, 1]) == [] def test_three_sum_duplicate_triplets(): assert three_sum([-2, 0, 1, 1, 1, 2, 2]) == [[-2, 0, 2], [-2, 1, 1]]","solution":"def three_sum(nums): Finds all unique triplets in the array which give the sum of zero. nums.sort() n = len(nums) triplets = [] for i in range(n): # Avoid duplicates for the first element if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: triplets.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 # Avoid duplicates for the second and third elements while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return triplets"},{"question":"from typing import List def max_subarray_sum(n: int, A: List[int]) -> int: Given an array A of n integers, find the largest sum of any contiguous subarray of A. >>> max_subarray_sum(5, [1, 2, -3, 4, 5]) 9 >>> max_subarray_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum(4, [-2, -3, -4, -1]) -1 # Unit tests def test_example_1(): assert max_subarray_sum(5, [1, 2, -3, 4, 5]) == 9 def test_example_2(): assert max_subarray_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_example_3(): assert max_subarray_sum(4, [-2, -3, -4, -1]) == -1 def test_single_element_positive(): assert max_subarray_sum(1, [5]) == 5 def test_single_element_negative(): assert max_subarray_sum(1, [-5]) == -5 def test_all_positive(): assert max_subarray_sum(4, [1, 2, 3, 4]) == 10 def test_all_negative(): assert max_subarray_sum(4, [-1, -2, -3, -4]) == -1 def test_mixed_values(): assert max_subarray_sum(6, [1, -2, 3, 4, -1, 2]) == 8 def test_large_input(): assert max_subarray_sum(100000, [1] * 100000) == 100000 def test_empty_array(): assert max_subarray_sum(0, []) == 0","solution":"from typing import List def max_subarray_sum(n: int, A: List[int]) -> int: if n == 0: return 0 # If the array is empty, the sum is 0 max_current = max_global = A[0] for i in range(1, n): max_current = max(A[i], max_current + A[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def is_valid_expression(expression: str) -> str: Determines if a string is a valid arithmetic expression. A valid arithmetic expression can only contain digits (0-9), plus (+) and minus (-) operators, and must not contain any invalid characters or expressions like multiple consecutive operators or an operator at the end. >>> is_valid_expression(\\"3+5-2\\") == \\"valid\\" True >>> is_valid_expression(\\"7-+3\\") == \\"invalid\\" True >>> is_valid_expression(\\"+4-2+3\\") == \\"invalid\\" True >>> is_valid_expression(\\"6+8-13\\") == \\"valid\\" True","solution":"import re def is_valid_expression(expression): Determines if a string is a valid arithmetic expression. A valid arithmetic expression can only contain digits (0-9), plus (+) and minus (-) operators, and must not contain any invalid characters or expressions like multiple consecutive operators or an operator at the end. # Regular expression to check if the expression is valid pattern = re.compile(r'^[0-9]+([+-][0-9]+)*') if pattern.match(expression): return \\"valid\\" else: return \\"invalid\\""},{"question":"def shortest_to_char(s: str, c: str) -> List[int]: Given a string s consisting of lowercase English letters and a character c which is guaranteed to be present in the string, find the shortest distance from each character in the string to the character c. Parameters: s (str): A string consisting of lowercase English letters. c (str): A character present in the string s. Returns: List[int]: An array where the i-th element is the shortest distance from s[i] to the character c. Examples: >>> shortest_to_char(\\"loveleetcode\\", 'e') [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_to_char(\\"aaab\\", 'b') [3, 2, 1, 0] def test_shortest_to_char_case1(): assert shortest_to_char(\\"loveleetcode\\", 'e') == [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] def test_shortest_to_char_case2(): assert shortest_to_char(\\"aaab\\", 'b') == [3, 2, 1, 0] def test_shortest_to_char_case3(): assert shortest_to_char(\\"abcdefg\\", 'd') == [3, 2, 1, 0, 1, 2, 3] def test_shortest_to_char_case4(): assert shortest_to_char(\\"bbbbbbbbbbbb\\", 'b') == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] def test_shortest_to_char_case5(): assert shortest_to_char(\\"aabbbbbccc\\", 'a') == [0, 0, 1, 2, 3, 4, 5, 6, 7, 8] def test_shortest_to_char_edge_case(): assert shortest_to_char(\\"z\\", 'z') == [0]","solution":"def shortest_to_char(s, c): Given a string s and a character c, return an array where the i-th element is the shortest distance from s[i] to the character c. n = len(s) answer = [n] * n # First pass: Find shortest distances from the left pos = -n for i in range(n): if s[i] == c: pos = i answer[i] = min(answer[i], abs(i - pos)) # Second pass: Find shortest distances from the right pos = 2 * n for i in range(n - 1, -1, -1): if s[i] == c: pos = i answer[i] = min(answer[i], abs(i - pos)) return answer"},{"question":"def manage_filesystem(commands: str) -> list: Simulates a simplified file management system interpreting and executing a series of commands. The system supports the following commands: - \\"CREATE /path/to/directory\\": Creates a new directory at the specified path. - \\"DELETE /path/to/directory\\": Deletes the directory at the specified path along with its contents. - \\"MOVE /path/from /path/to\\": Moves the directory from the first path to the second path. Args: commands (str): A multiline string containing the commands. Returns: list: The final directory structure represented as nested lists. Examples: >>> manage_filesystem('''CREATE /a/b/c CREATE /d/e/f MOVE /a /d/g/h DELETE /d/e''') ['', ['d', ['g', ['h', ['a', ['b', ['c']]]]]]] >>> manage_filesystem('CREATE /x/y/z') ['', ['x', ['y', ['z']]]] >>> manage_filesystem('''CREATE /x/y/z DELETE /x/y''') ['', ['x']] pass","solution":"class FileManager: def __init__(self): self.root = [\\"\\"] def _navigate(self, path): parts = path.strip(\\"/\\").split(\\"/\\") node = self.root for part in parts: for subnode in node[1:]: if subnode[0] == part: node = subnode break else: new_node = [part] node.append(new_node) node = new_node return node def create(self, path): self._navigate(path) def _find_and_remove(self, path): parts = path.strip(\\"/\\").split(\\"/\\") node = self.root stack = [] for part in parts: found = False for subnode in node[1:]: if subnode[0] == part: stack.append((node, subnode)) node = subnode found = True break if not found: return parent, node = stack.pop() parent.remove(node) def delete(self, path): self._find_and_remove(path) def move(self, src_path, dest_path): parts = src_path.strip(\\"/\\").split(\\"/\\") node = self.root stack = [] for part in parts: found = False for subnode in node[1:]: if subnode[0] == part: stack.append((node, subnode)) node = subnode found = True break if not found: return parent, node = stack.pop() parent.remove(node) dest_node = self._navigate(dest_path) dest_node.append(node) def execute(self, commands): for command in commands.splitlines(): parts = command.split() action = parts[0] if action == \\"CREATE\\": self.create(parts[1]) elif action == \\"DELETE\\": self.delete(parts[1]) elif action == \\"MOVE\\": self.move(parts[1], parts[2]) return self.root def manage_filesystem(commands): fm = FileManager() return fm.execute(commands)"},{"question":"def max_binary_number(n: int, binary_list: List[str]) -> str: This function will find the maximum possible binary number from a list of binary numbers by applying bit flip operations. >>> max_binary_number(3, ['101', '110', '011']) '111' >>> max_binary_number(4, ['000', '001', '010', '100']) '111' >>> max_binary_number(2, ['111', '011']) '111'","solution":"def max_binary_number(n, binary_list): This function will find the maximum possible binary number from a list of binary numbers by applying bit flip operations. # Finding the length of maximum binary string in the list max_len = max(len(bin_num) for bin_num in binary_list) # Maximum binary number will be full of '1's with the length of max_len max_binary = '1' * max_len return max_binary"},{"question":"def three_sum_zero(A): Returns all unique triplets (a, b, c) such that a + b + c = 0 in the array A. Each triplet is sorted in ascending order, and triplets themselves are sorted. >>> three_sum_zero([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum_zero([-1, -1, -1, 2, -1]) [[-1, -1, 2]] pass def solve(test_cases): Processes multiple test cases and returns results for each. >>> solve([(6, [-1, 0, 1, 2, -1, -4]), (5, [-1, -1, -1, 2, -1])]) [[[-1, -1, 2], [-1, 0, 1]], [[-1, -1, 2]]] pass # Unit tests def test_solve(): assert solve([(6, [-1, 0, 1, 2, -1, -4]), (5, [-1, -1, -1, 2, -1])]) == [[[-1, -1, 2], [-1, 0, 1]], [[-1, -1, 2]]] def test_no_triplets(): assert solve([(3, [1, 2, 3])]) == [[]] def test_multiple_triplets(): assert solve([(6, [0, -1, 2, -3, 1, -2])]) == [[[-3, 1, 2], [-2, 0, 2], [-1, 0, 1]]] def test_identical_elements(): assert solve([(4, [0, 0, 0, 0])]) == [[[0, 0, 0]]] def test_large_input(): assert solve([(7, [-10**5, 10**5, 0, 1, -1, 2, -2])]) == [[[-100000, 0, 100000], [-2, 0, 2], [-1, 0, 1]]]","solution":"def three_sum_zero(A): Returns all unique triplets (a, b, c) such that a + b + c = 0 in the array A. Each triplet is sorted in ascending order, and triplets themselves are sorted. A.sort() triplets = [] n = len(A) for i in range(n): if i > 0 and A[i] == A[i - 1]: continue # skip duplicates left, right = i + 1, n - 1 while left < right: total = A[i] + A[left] + A[right] if total == 0: triplets.append([A[i], A[left], A[right]]) while left < right and A[left] == A[left + 1]: left += 1 while left < right and A[right] == A[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets def solve(test_cases): results = [] for case in test_cases: N, A = case results.append(three_sum_zero(A)) return results"},{"question":"def is_subsequence_with_wildcards(text: str, pattern: str) -> str: Check if the pattern with wildcard characters is a subsequence of the text. >>> is_subsequence_with_wildcards(\\"programming\\", \\"p?o??\\") \\"Yes\\" >>> is_subsequence_with_wildcards(\\"hello\\", \\"h?llo?\\") \\"No\\" >>> is_subsequence_with_wildcards(\\"contest\\", \\"c?n?e?t\\") \\"Yes\\" >>> is_subsequence_with_wildcards(\\"abc\\", \\"abcd\\") \\"No\\" >>> is_subsequence_with_wildcards(\\"abcd\\", \\"????\\") \\"Yes\\"","solution":"def is_subsequence_with_wildcards(text, pattern): This function returns 'Yes' if the pattern (with possible wildcard characters '?') is a subsequence of the text, and 'No' otherwise. text_len = len(text) pattern_len = len(pattern) if pattern_len > text_len: return \\"No\\" j = 0 for char in text: if j < pattern_len and (pattern[j] == '?' or pattern[j] == char): j += 1 if j == pattern_len: return \\"Yes\\" return \\"No\\""},{"question":"def count_students_above_threshold(n: int, student_records: List[Tuple[str, List[int]]], threshold: int) -> int: Counts how many students have an average score above the given threshold. Parameters: n (int) : Number of students. student_records (list) : List of tuples, where each tuple contains a string (student name) and a list of integers (student's scores). threshold (int) : The average score threshold. Returns: int : Number of students with an average score above the threshold. >>> count_students_above_threshold(3, [(\\"Alice\\", [85, 90, 78]), (\\"Bob\\", [70, 65, 80]), (\\"Charlie\\", [90, 95, 100])], 80) 2 >>> count_students_above_threshold(4, [(\\"Dave\\", [50, 60, 70]), (\\"Eve\\", [80, 85, 90]), (\\"Frank\\", [75, 70, 65]), (\\"Grace\\", [95, 90, 85])], 75) 2 >>> count_students_above_threshold(2, [(\\"Hank\\", [100, 100, 100]), (\\"Ivy\\", [50, 50, 50])], 90) 1 >>> count_students_above_threshold(1, [(\\"John\\", [70, 75, 80])], 75) 0 >>> count_students_above_threshold(3, [(\\"Anna\\", [85, 85, 90]), (\\"Bill\\", [88, 84, 89]), (\\"Carl\\", [78, 79, 80])], 85) 2","solution":"def count_students_above_threshold(n, student_records, threshold): Counts how many students have an average score above the given threshold. Parameters: n (int) : Number of students. student_records (list) : List of tuples, where each tuple contains a string (student name) and a list of integers (student's scores). threshold (int) : The average score threshold. Returns: int : Number of students with an average score above the threshold. count = 0 for name, scores in student_records: average_score = sum(scores) / len(scores) if average_score > threshold: count += 1 return count"},{"question":"def find_median(grades): Returns the median grade from a list of integer grades. If the number of grades is even, the average of the two middle grades is returned. If the number of grades is odd, the middle grade is returned. >>> find_median([85]) 85.0 >>> find_median([70, 80, 90]) 80.0 >>> find_median([60, 70, 80, 90]) 75.0 >>> find_median([80, 80, 80, 80]) 80.0 >>> find_median([90, 60, 70, 80]) 75.0","solution":"def find_median(grades): Returns the median grade from a list of integer grades. If the number of grades is even, the average of the two middle grades is returned. If the number of grades is odd, the middle grade is returned. grades.sort() n = len(grades) if n % 2 == 1: # odd number of grades return float(grades[n // 2]) else: # even number of grades mid1 = grades[n // 2 - 1] mid2 = grades[n // 2] return (mid1 + mid2) / 2.0"},{"question":"from collections import defaultdict from typing import List, Tuple def max_root_to_leaf_sum(n: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum sum of values from any root-to-leaf path in an n-node tree. >>> max_root_to_leaf_sum(5, [3, 2, 5, 4, 6], [(1, 2), (1, 3), (2, 4), (2, 5)]) # 11 >>> max_root_to_leaf_sum(1, [10], []) # 10","solution":"from collections import defaultdict def max_root_to_leaf_sum(n, values, edges): def dfs(node, parent): # Base case: if node is a leaf if not tree[node]: return values[node-1] max_sum = 0 for neighbor in tree[node]: if neighbor == parent: continue max_sum = max(max_sum, dfs(neighbor, node)) return values[node-1] + max_sum # Construct the adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Start DFS from the root node (1) return dfs(1, -1)"},{"question":"from typing import List def min_moves_to_reach_target(N: int, M: int, grid: List[str], start_x: int, start_y: int, end_x: int, end_y: int) -> int: Find the minimum number of moves required to reach the target position from the initial position. Parameters: - N: int, number of rows in the grid - M: int, number of columns in the grid - grid: List[str], the grid representation with '.' as walkable cells and '#' as obstacles - start_x: int, initial position x-coordinate - start_y: int, initial position y-coordinate - end_x: int, target position x-coordinate - end_y: int, target position y-coordinate Returns: - int: minimum number of moves to reach the target position, or -1 if it is impossible Examples: >>> min_moves_to_reach_target(5, 5, [\\".....\\", \\"..#..\\", \\".....\\", \\".#...\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_moves_to_reach_target(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"], 0, 0, 2, 2) -1 pass # Implement the function here def test_example_1(): N, M = 5, 5 grid = [ \\".....\\", \\"..#..\\", \\".....\\", \\".#...\\", \\".....\\" ] start_x, start_y, end_x, end_y = 0, 0, 4, 4 assert min_moves_to_reach_target(N, M, grid, start_x, start_y, end_x, end_y) == 8 def test_example_2(): N, M = 3, 3 grid = [ \\".#.\\", \\".#.\\", \\".#.\\" ] start_x, start_y, end_x, end_y = 0, 0, 2, 2 assert min_moves_to_reach_target(N, M, grid, start_x, start_y, end_x, end_y) == -1 def test_no_obstacles(): N, M = 3, 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] start_x, start_y, end_x, end_y = 0, 0, 2, 2 assert min_moves_to_reach_target(N, M, grid, start_x, start_y, end_x, end_y) == 4 def test_starting_at_target(): N, M = 1, 1 grid = [ \\".\\" ] start_x, start_y, end_x, end_y = 0, 0, 0, 0 assert min_moves_to_reach_target(N, M, grid, start_x, start_y, end_x, end_y) == 0 def test_single_obstacle_path_blocked(): N, M = 3, 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] start_x, start_y, end_x, end_y = 0, 0, 2, 2 assert min_moves_to_reach_target(N, M, grid, start_x, start_y, end_x, end_y) == 4 def test_large_grid(): N, M = 5, 5 grid = [ \\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\" ] start_x, start_y, end_x, end_y = 0, 0, 4, 4 assert min_moves_to_reach_target(N, M, grid, start_x, start_y, end_x, end_y) == 8","solution":"from collections import deque def min_moves_to_reach_target(N, M, grid, start_x, start_y, end_x, end_y): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_valid(x, y): return 0 <= x < N and 0 <= y < M and grid[x][y] == '.' queue = deque([(start_x, start_y, 0)]) visited = set() visited.add((start_x, start_y)) while queue: x, y, dist = queue.popleft() if (x, y) == (end_x, end_y): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def is_almost_palindrome(s: str) -> str: Determine if the string s is an \\"almost palindrome\\". An \\"almost palindrome\\" is a string that can be turned into a palindrome by changing at most one character. Args: s (str): The string to be checked. Returns: str: \\"YES\\" if the string can be an almost palindrome, otherwise \\"NO\\". Examples: >>> is_almost_palindrome(\\"abca\\") \\"YES\\" >>> is_almost_palindrome(\\"racecar\\") \\"YES\\" >>> is_almost_palindrome(\\"abcdef\\") \\"NO\\" pass def check_almost_palindromes(test_cases: List[str]) -> List[str]: Given a list of strings, determine if each string is an \\"almost palindrome\\". Args: test_cases (List[str]): List of strings to be checked. Returns: List[str]: List of results, \\"YES\\" or \\"NO\\", for each input string. Examples: >>> check_almost_palindromes([\\"abca\\", \\"racecar\\", \\"abcdef\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> check_almost_palindromes([\\"abcba\\", \\"a\\", \\"ab\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] pass","solution":"def is_almost_palindrome(s): Returns \\"YES\\" if the string s can be converted to a palindrome by changing at most one character, otherwise returns \\"NO\\". def is_palindrome_range(start, end): while start < end: if s[start] != s[end]: return False start += 1 end -= 1 return True start, end = 0, len(s) - 1 while start < end: if s[start] != s[end]: # Check if skipping either start or end character results in a palindrome if is_palindrome_range(start + 1, end) or is_palindrome_range(start, end - 1): return \\"YES\\" else: return \\"NO\\" start += 1 end -= 1 return \\"YES\\" def check_almost_palindromes(test_cases): results = [] for s in test_cases: results.append(is_almost_palindrome(s)) return results"},{"question":"def is_element_with_equal_counts(arr): Checks if there exists an element in the array such that the count of elements strictly less than it is equal to the count of elements strictly greater than it. pass def check_test_cases(test_cases): Processes multiple test cases and applies the is_element_with_equal_counts function to determine if each case contains the element meeting the criteria. pass def test_equal_counts_elements_case_1(): test_cases = [ [1, 2, 3, 4, 5], [2, 2, 2, 2] ] result = check_test_cases(test_cases) assert result == [\\"YES\\", \\"NO\\"] def test_all_elements_ascending(): test_cases = [ [7, 8, 9, 10, 11, 12, 13], # Element 10 has 3 elements < 10 and 3 elements > 10 [1, 1, 1, 1, 1, 1, 1] ] result = check_test_cases(test_cases) assert result == [\\"YES\\", \\"NO\\"] def test_single_element(): test_cases = [ [42], # Only one element cannot have both lesser and greater elements ] result = check_test_cases(test_cases) assert result == [\\"NO\\"] def test_two_elements(): test_cases = [ [1, 2], # Only two elements cannot have both lesser and greater elements ] result = check_test_cases(test_cases) assert result == [\\"NO\\"] def test_mixed_case_1(): test_cases = [ [5, -1, 0, 2, -2, 3, 4], # Element 2 has 3 elements < 2 and 3 elements > 2 ] result = check_test_cases(test_cases) assert result == [\\"YES\\"] def test_edge_case_all_equal(): test_cases = [ [7, 7, 7, 7, 7], # All elements are same. No element can have both lesser and greater elements ] result = check_test_cases(test_cases) assert result == [\\"NO\\"]","solution":"def is_element_with_equal_counts(arr): Checks if there exists an element in the array such that the count of elements strictly less than it is equal to the count of elements strictly greater than it. n = len(arr) if n < 3: return \\"NO\\" arr.sort() for i in range(1, n-1): if arr[i-1] < arr[i] and arr[i] < arr[i+1] and i == n-1-i: return \\"YES\\" return \\"NO\\" def check_test_cases(test_cases): Processes multiple test cases and applies the is_element_with_equal_counts function to determine if each case contains the element meeting the criteria. results = [] for arr in test_cases: results.append(is_element_with_equal_counts(arr)) return results"},{"question":"def max_subgrid_sum(N, M, P, Q, grid): Determine the maximum sum of any subgrid of size \`P x Q\` within the given grid. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. P (int): Number of rows in the subgrid. Q (int): Number of columns in the subgrid. grid (List[List[int]]): The grid of integers. Returns: int: The maximum sum of any subgrid of size \`P x Q\`. pass def process_test_cases(T, test_cases): Process multiple test cases to determine the maximum subgrid sum for each case. Args: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int, int, int], List[List[int]]]]): List of test cases where each test case is a tuple containing grid dimensions and the grid itself. Returns: List[int]: List of results for each test case. >>> process_test_cases(2, [ ... [(4, 5, 2, 3), [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20] ... ]], ... [(3, 3, 2, 2), [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ]] ... ]) [99, -12] pass","solution":"def max_subgrid_sum(N, M, P, Q, grid): max_sum = -float('inf') # Create prefix sum array prefix_sum = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): prefix_sum[i][j] = grid[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] # Calculate the max sum of any subgrid of size P x Q for i in range(P, N + 1): for j in range(Q, M + 1): subgrid_sum = prefix_sum[i][j] - prefix_sum[i - P][j] - prefix_sum[i][j - Q] + prefix_sum[i - P][j - Q] max_sum = max(max_sum, subgrid_sum) return max_sum def process_test_cases(T, test_cases): results = [] for t in range(T): N, M, P, Q = test_cases[t][0] grid = test_cases[t][1] result = max_subgrid_sum(N, M, P, Q, grid) results.append(result) return results"},{"question":"from typing import List def shortestSubarraySum(nums: List[int], k: int) -> int: Write a function \`shortestSubarraySum(nums, k)\` that takes an array \`nums\` of integers and an integer \`k\`, and returns the length of the shortest subarray that has a sum of at least \`k\`. If there is no such subarray, return -1. >>> shortestSubarraySum([1, 2, 3, 4, 5], 11) 3 >>> shortestSubarraySum([2, -1, 2], 3) 3 >>> shortestSubarraySum([1, 2, 3], 7) -1 >>> shortestSubarraySum([-2, 1, -1, 1, 2, 4], 4) 1 # Implementation here def test_shortestSubarraySum_example1(): assert shortestSubarraySum([1, 2, 3, 4, 5], 11) == 3 def test_shortestSubarraySum_example2(): assert shortestSubarraySum([2, -1, 2], 3) == 3 def test_shortestSubarraySum_example3(): assert shortestSubarraySum([1, 2, 3], 7) == -1 def test_shortestSubarraySum_example4(): assert shortestSubarraySum([-2, 1, -1, 1, 2, 4], 4) == 1 def test_shortestSubarraySum_minimum_sum(): assert shortestSubarraySum([1], 1) == 1 def test_shortestSubarraySum_no_valid_subarray(): assert shortestSubarraySum([1, 1, 1, 1, 1], 10) == -1 def test_shortestSubarraySum_mixed_numbers(): assert shortestSubarraySum([-1, 2, 1, -1, 2, -1, 3], 4) == 3 def test_shortestSubarraySum_large_k(): assert shortestSubarraySum([1, 2, 3, 4, 5], 15) == 5","solution":"from collections import deque def shortestSubarraySum(nums, k): Returns the length of the shortest subarray that has a sum of at least k. If there is no such subarray, return -1. n = len(nums) prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + nums[i] result = float('inf') dq = deque() for i in range(n + 1): while dq and prefix_sum[i] - prefix_sum[dq[0]] >= k: result = min(result, i - dq.popleft()) while dq and prefix_sum[i] <= prefix_sum[dq[-1]]: dq.pop() dq.append(i) return result if result != float('inf') else -1"},{"question":"def rearrangeArray(arr: List[int]) -> None: Rearranges the elements of arr in such a way that every second element is greater than its left and right elements. >>> arr = [4, 3, 7, 8, 6, 2, 1] >>> rearrangeArray(arr) >>> arr [3, 7, 4, 8, 2, 6, 1] >>> arr = [1, 3, 4, 2, 5] >>> rearrangeArray(arr) >>> arr [1, 4, 2, 5, 3]","solution":"def rearrangeArray(arr): Rearranges the elements of arr in such a way that every second element is greater than its left and right elements. n = len(arr) for i in range(1, n, 2): # If the current element is not greater than the previous element if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] # If the current element is not greater than the next element and i is not the last index if i + 1 < n and arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i]"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def min_problems_to_solve(n: int, m: int, dependencies: List[Tuple[int, int]], t: int) -> int: Calculate the minimum number of problems Robin needs to solve before he can start solving the target problem. Args: n (int): Number of problems. m (int): Number of dependencies. dependencies (List[Tuple[int, int]]): List of dependencies where each tuple (u, v) means problem u must be solved before problem v. t (int): The target problem. Returns: int: Minimum number of problems to solve before solving the target problem. Examples: >>> min_problems_to_solve(5, 4, [(1, 2), (2, 3), (2, 4), (4, 5)], 5) 3 >>> min_problems_to_solve(6, 5, [(1, 2), (2, 3), (3, 4), (1, 5), (5, 6)], 6) 2 >>> min_problems_to_solve(4, 2, [(1, 2), (3, 4)], 3) 0","solution":"from collections import deque, defaultdict def min_problems_to_solve(n, m, dependencies, t): graph = defaultdict(list) in_degree = [0] * (n + 1) for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 queue = deque() level = [-1] * (n + 1) for i in range(1, n + 1): if in_degree[i] == 0: queue.append(i) level[i] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) level[neighbor] = level[node] + 1 return level[t]"},{"question":"def find_winner(votes: List[int]) -> int: Determine and return the index of the winning candidate, or -1 if there is no winner. A candidate is considered a winner if they have strictly more votes than any other candidate. If two or more candidates have the same highest number of votes, there is no winner. >>> find_winner([10, 20, 30, 40, 50]) 4 >>> find_winner([10, 20, 30, 40, 40]) -1 >>> find_winner([5, 5, 5, 5, 5]) -1 >>> find_winner([1, 99, 2, 99]) -1 >>> find_winner([1, 99, 2, 50]) 1","solution":"def find_winner(votes): if not votes: return -1 max_votes = max(votes) if votes.count(max_votes) > 1: return -1 return votes.index(max_votes)"},{"question":"def exists_path(grid: List[str], N: int, M: int) -> str: Given a 2D grid of size N x M filled with lowercase alphabetic characters '.': empty cell, 'X': obstacle, 'S': start point, 'E': end point, check if there exists a path from 'S' to 'E'. You can move up, down, left, or right through the empty cells ('.'). If a path exists, return \\"YES\\", otherwise return \\"NO\\". >>> exists_path([\\"S..\\", \\".X.\\", \\"..E\\"], 3, 3) \\"YES\\" >>> exists_path([\\"S..\\", \\"XXX\\", \\"..E\\"], 3, 3) \\"NO\\"","solution":"def exists_path(grid, N, M): from collections import deque def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != 'X': yield nx, ny # Find starting and ending positions start, end = None, None for i in range(N): for j in range(M): if grid[i][j] == 'S': start = (i, j) if grid[i][j] == 'E': end = (i, j) if not start or not end: return \\"NO\\" queue = deque([start]) visited = set(start) while queue: x, y = queue.popleft() if (x, y) == end: return \\"YES\\" for nx, ny in get_neighbors(x, y): if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def findMinSubstrLength(str: str, pat: str) -> int: Given a string \`str\` and a pattern \`pat\`, return the length of the smallest substring in \`str\` that contains all the characters of \`pat\`. >>> findMinSubstrLength(\\"ADOBECODEBANC\\", \\"ABC\\") 4 >>> findMinSubstrLength(\\"this is a test string\\", \\"tist\\") 6 >>> findMinSubstrLength(\\"abcdefg\\", \\"hij\\") -1 >>> findMinSubstrLength(\\"\\", \\"abc\\") -1 >>> findMinSubstrLength(\\"abcdef\\", \\"\\") -1 >>> findMinSubstrLength(\\"a\\", \\"a\\") 1 >>> findMinSubstrLength(\\"pattern\\", \\"pattern\\") 7","solution":"def findMinSubstrLength(str, pat): from collections import Counter if not str or not pat: return -1 pat_counter = Counter(pat) str_counter = Counter() required = len(pat_counter) formed = 0 left = 0 min_length = float('inf') for right, char in enumerate(str): str_counter[char] += 1 if char in pat_counter and str_counter[char] == pat_counter[char]: formed += 1 while left <= right and formed == required: current_window_length = right - left + 1 if current_window_length < min_length: min_length = current_window_length str_counter[str[left]] -= 1 if str[left] in pat_counter and str_counter[str[left]] < pat_counter[str[left]]: formed -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"from typing import List, Tuple def is_valid_ship_positions(ship_positions: List[Tuple[int, int]]) -> bool: Check whether the provided ship positions are valid, meaning no ships overlap and all ships fit within the grid. Each ship is either horizontal or vertical, spanning 4 contiguous grid cells. The grid is of fixed size 10x10 with indices from (0,0) to (9,9). The input list will always contain an even number of tuples. >>> is_valid_ship_positions([(0,0), (0,1), (0,2), (0,3), (2,2), (3,2), (4,2), (5,2)]) True >>> is_valid_ship_positions([(0,0), (0,1), (0,2), (0,3), (0,2), (1,2), (2,2), (3,2)]) False def test_is_valid_ship_positions(): assert is_valid_ship_positions([(0,0), (0,1), (0,2), (0,3), (2,2), (3,2), (4,2), (5,2)]) == True assert is_valid_ship_positions([(0,0), (0,1), (0,2), (0,3), (0,2), (1,2), (2,2), (3,2)]) == False assert is_valid_ship_positions([(0,0), (0,1), (0,2), (0,3), (1,0), (2,0), (3,0), (4,0)]) == False assert is_valid_ship_positions([(0,0), (0,1), (0,2), (0,3), (1,1), (1,2), (1,3), (1,4)]) == False assert is_valid_ship_positions([(0,0), (1,0), (2,0), (3,0)]) == True assert is_valid_ship_positions([(0,0), (0,1), (0,2), (0,3)]) == True assert is_valid_ship_positions([(9,0), (9,1), (9,2), (9,3), (0,9), (1,9), (2,9), (3,9)]) == True assert is_valid_ship_positions([(0,0), (1,0), (0,1), (1,1), (2,3), (2,4), (2,5), (2,6)]) == False","solution":"from typing import List, Tuple def is_valid_ship_positions(ship_positions: List[Tuple[int, int]]) -> bool: if not ship_positions: return True ship_positions_set = set(ship_positions) if len(ship_positions_set) != len(ship_positions): return False grid = [[0]*10 for _ in range(10)] for pos in ship_positions: row, col = pos grid[row][col] += 1 if any(grid[row][col] > 1 for row in range(10) for col in range(10)): return False def is_valid_ship(ship): if len(ship) != 4: return False ship.sort() rows, cols = zip(*ship) if len(set(rows)) == 1 and all(cols[i] + 1 == cols[i+1] for i in range(3)): return True if len(set(cols)) == 1 and all(rows[i] + 1 == rows[i+1] for i in range(3)): return True return False visited = set() for pos in ship_positions: if pos in visited: continue stack = [pos] ship = [] while stack: current = stack.pop() if current in visited: continue visited.add(current) ship.append(current) row, col = current for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nr, nc = row + dr, col + dc if 0 <= nr < 10 and 0 <= nc < 10 and (nr, nc) in ship_positions_set and (nr, nc) not in visited: stack.append((nr, nc)) if not is_valid_ship(ship): return False return True"},{"question":"def isMountainArray(array: list[int]) -> str: Determines if the array is a mountain array. A mountain array is one that: 1. Has at least 3 elements. 2. There exists some index i (0 < i < len(array) - 1) such that: - array[0] < array[1] < ... < array[i] and - array[i] > array[i + 1] > ... > array[len(array) - 1] Parameters: array (list of int): The array of integers. Returns: str: \\"YES\\" if the array is a mountain array, otherwise \\"NO\\". >>> isMountainArray([2, 1]) \\"NO\\" >>> isMountainArray([3, 5, 5]) \\"NO\\" >>> isMountainArray([0, 3, 2, 1]) \\"YES\\" def test_isMountainArray_minimum_elements(): assert isMountainArray([2, 1]) == \\"NO\\" def test_isMountainArray_no_strict_increase_before_decrease(): assert isMountainArray([3, 5, 5]) == \\"NO\\" def test_isMountainArray_valid_mountain(): assert isMountainArray([0, 3, 2, 1]) == \\"YES\\" def test_isMountainArray_all_increasing(): assert isMountainArray([1, 2, 3, 4, 5]) == \\"NO\\" def test_isMountainArray_all_decreasing(): assert isMountainArray([5, 4, 3, 2, 1]) == \\"NO\\" def test_isMountainArray_peak_at_start(): assert isMountainArray([3, 2, 1]) == \\"NO\\" def test_isMountainArray_peak_at_end(): assert isMountainArray([1, 2, 3]) == \\"NO\\" def test_isMountainArray_large_valid_mountain(): assert isMountainArray([1, 2, 3, 4, 5, 4, 3, 2, 1]) == \\"YES\\" def test_isMountainArray_large_invalid_mountain(): assert isMountainArray([1, 2, 3, 4, 5, 4, 3, 2, 2]) == \\"NO\\"","solution":"def isMountainArray(array): Determines if the array is a mountain array. Parameters: array (list of int): The array of integers. Returns: str: \\"YES\\" if the array is a mountain array, otherwise \\"NO\\". n = len(array) if n < 3: return \\"NO\\" i = 1 # climb up while i < n and array[i] > array[i - 1]: i += 1 # peak can't be the first or last if i == 1 or i == n: return \\"NO\\" # climb down while i < n and array[i] < array[i - 1]: i += 1 return \\"YES\\" if i == n else \\"NO\\""},{"question":"def longest_increasing_subsequence(nums): Returns the length of the longest strictly increasing subsequence. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41]) 4 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7]) 1 >>> longest_increasing_subsequence([3, 3, 3, 3]) 1 >>> longest_increasing_subsequence([-1000000000, 1000000000]) 2 >>> longest_increasing_subsequence([]) 0","solution":"def longest_increasing_subsequence(nums): Returns the length of the longest strictly increasing subsequence. if not nums: return 0 n = len(nums) # dp array to store the length of the longest increasing subsequence until each index dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def unique_elements(lst: List[int]) -> List[int]: Returns a new list composed of only the unique elements of the original list, in the same order they first appeared. >>> unique_elements([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([]) [] >>> unique_elements([1]) [1] >>> unique_elements([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> unique_elements([2, 2, 2, 2, 2]) [2] >>> unique_elements([1, -1, 2, -2, 1, -1]) [1, -1, 2, -2]","solution":"def unique_elements(lst): Returns a new list composed of only the unique elements of the original list, in the same order they first appeared. seen = {} unique_lst = [] for elem in lst: if elem not in seen: seen[elem] = True unique_lst.append(elem) return unique_lst"},{"question":"def simulate_task_completion(n: int, priorities: List[int]) -> List[int]: Simulates the completion of tasks based on their priorities. Args: n : int : number of tasks priorities : list : list of priority integers of n tasks Returns: list : list of priorities in the order they are completed. Examples: >>> simulate_task_completion(6, [1, 4, 2, 5, 3, 2]) [5, 4, 3, 2, 2, 1] >>> simulate_task_completion(4, [7, 7, 7, 7]) [7, 7, 7, 7]","solution":"def simulate_task_completion(n, priorities): Simulates the completion of tasks based on their priorities. Args: n : int : number of tasks priorities : list : list of priority integers of n tasks Returns: list : list of priorities in the order they are completed. result = [] priorities.sort(reverse=True) while priorities: result.append(priorities.pop(0)) return result"},{"question":"from typing import List def max_subarray_sum(n: int, intensities: List[int]) -> int: Finds the maximum sum of a contiguous subarray of pumpkins' glowing intensities. Parameters: n (int): The number of pumpkins. intensities (List[int]): A list of integers representing the glowing intensities of the pumpkins. Returns: int: The maximum possible sum of intensities of any contiguous subarray. >>> max_subarray_sum(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum(1, [3]) == 3 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_subarray_sum(1, [0]) == 0 >>> max_subarray_sum(5, [0, 0, 2, 0, 0]) == 2","solution":"def max_subarray_sum(n, intensities): Finds the maximum sum of a contiguous subarray using Kadane's Algorithm. Parameters: n (int): The number of pumpkins. intensities (list): A list of integers representing the glowing intensities of the pumpkins. Returns: int: The maximum possible sum of intensities of any contiguous subarray. max_ending_here = max_so_far = intensities[0] for intensity in intensities[1:]: max_ending_here = max(intensity, max_ending_here + intensity) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def dailyTemperatures(temperatures: List[int]) -> List[int]: Given a list of daily temperatures, returns a list of days until a warmer temperature. >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([30, 40, 50, 60]) [1, 1, 1, 0]","solution":"def dailyTemperatures(temperatures): Given a list of daily temperatures, returns a list of days until a warmer temperature. :param temperatures: List[int] :return: List[int] n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def create_unique_reading_list(titles): Returns a list of titles with duplicates removed but maintaining their first occurrence order. >>> create_unique_reading_list([\\"HarryPotter\\", \\"LordOfTheRings\\", \\"HarryPotter\\", \\"TheHobbit\\", \\"LordOfTheRings\\", \\"ToKillAMockingbird\\", \\"1984\\"]) ['HarryPotter', 'LordOfTheRings', 'TheHobbit', 'ToKillAMockingbird', '1984'] >>> create_unique_reading_list([\\"WarAndPeace\\", \\"AnnaKarenina\\", \\"WarAndPeace\\", \\"CrimeAndPunishment\\", \\"TheBrothersKaramazov\\"]) ['WarAndPeace', 'AnnaKarenina', 'CrimeAndPunishment', 'TheBrothersKaramazov'] # Your code here","solution":"def create_unique_reading_list(titles): Returns a list of titles with duplicates removed but maintaining their first occurrence order. seen = set() unique_titles = [] for title in titles: if title not in seen: seen.add(title) unique_titles.append(title) return unique_titles"},{"question":"from typing import List def max_coins(grid: List[List[int]]) -> int: Mario wants to collect coins in a 2D grid of size m x n. Each cell in the grid contains a certain number of coins. Mario can start at any cell in the first row and can move to any cell in the last row by only moving downwards to adjacent cells (including diagonally). This function returns the maximum number of coins Mario can collect. >>> max_coins([ [0, 1, 4, 2], [4, 8, 3, 7], [6, 5, 9, 1], [1, 2, 2, 4] ]) 25 >>> max_coins([ [3, 1, 2, 4] ]) 4 >>> max_coins([ [3], [2], [4], [1] ]) 10 >>> max_coins([]) 0 >>> max_coins([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> max_coins([ [-1, -2, -3], [-4, -5, -6], [-7, -8, -9] ]) -12","solution":"from typing import List def max_coins(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) # Initialize dp table dp = [[0] * n for _ in range(m)] # Fill the first row of dp table with the values of grid's first row for j in range(n): dp[0][j] = grid[0][j] # Build the dp table row by row for i in range(1, m): for j in range(n): # For each cell, we consider the maximum coins we can get from the cell directly above, # and the two diagonally adjacent cells from the previous row max_coins_from_above = dp[i-1][j] if j > 0: max_coins_from_above = max(max_coins_from_above, dp[i-1][j-1]) if j < n - 1: max_coins_from_above = max(max_coins_from_above, dp[i-1][j+1]) dp[i][j] = grid[i][j] + max_coins_from_above # The answer will be the maximum value in the last row of dp table return max(dp[m-1])"},{"question":"def maxLenSubarray(arr, n): Finds the length of the longest contiguous subarray with the maximum sum. If there are multiple such subarrays, returns the length of the one that starts earliest in the array. >>> maxLenSubarray([-2, 1, -3, 4, -1, 2, 1, -5, 4], 9) 4 >>> maxLenSubarray([1, 2, 3, -2, 5], 5) 5 >>> maxLenSubarray([1], 1) 1 >>> maxLenSubarray([-1], 1) 1 >>> maxLenSubarray([-2, -3, -1, -4], 4) 1 >>> maxLenSubarray([1, 2, 3, 4], 4) 4 >>> maxLenSubarray([1, -2, 3, 10, -4, 7, 2, -5], 8) 5 >>> maxLenSubarray([0, 0, 0, 0], 4) 4","solution":"def maxLenSubarray(arr, n): Finds the length of the longest contiguous subarray with the maximum sum. If there are multiple such subarrays, returns the length of the one that starts earliest in the array. # Initialize variables max_sum = -float('inf') current_sum = 0 max_length = 0 temp_length = 0 for i in range(n): current_sum += arr[i] temp_length += 1 if current_sum > max_sum: max_sum = current_sum max_length = temp_length elif current_sum == max_sum: max_length = max(max_length, temp_length) if current_sum < 0: current_sum = 0 temp_length = 0 return max_length"},{"question":"def can_reach_end(platforms: List[int], threshold: int) -> str: Determines if it is possible to reach the last platform from the first one. Parameters: platforms (list): List of integers representing the heights of the platforms. threshold (int): Maximum height difference that can be jumped. Returns: str: \\"YES\\" if it's possible to reach the last platform, otherwise \\"NO\\" >>> can_reach_end([3, 4, 5, 6, 8], 2) \\"YES\\" >>> can_reach_end([3, 8, 5, 3, 7], 1) \\"NO\\" pass # Implement the function here # Unit tests import pytest def test_example_1(): assert can_reach_end([3, 4, 5, 6, 8], 2) == \\"YES\\" def test_example_2(): assert can_reach_end([3, 8, 5, 3, 7], 1) == \\"NO\\" def test_single_jump_success(): assert can_reach_end([1, 2, 3, 4, 5], 1) == \\"YES\\" def test_single_jump_failure(): assert can_reach_end([1, 10, 20, 30, 40], 5) == \\"NO\\" def test_multiple_jump_success(): assert can_reach_end([1, 3, 5, 2, 1], 3) == \\"YES\\" def test_large_threshold(): assert can_reach_end([1, 6, 11, 16, 21], 10) == \\"YES\\" def test_large_platforms_failure(): assert can_reach_end([3, 10000, 10000, 20000], 9999) == \\"NO\\"","solution":"def can_reach_end(platforms, threshold): Determines if it is possible to reach the last platform from the first one. Parameters: platforms (list): List of integers representing the heights of the platforms. threshold (int): Maximum height difference that can be jumped. Returns: str: \\"YES\\" if it's possible to reach the last platform, otherwise \\"NO\\" current_pos = 0 n = len(platforms) while current_pos < n - 1: next_pos = current_pos + 1 while next_pos < n and platforms[next_pos] <= platforms[current_pos] + threshold: next_pos += 1 if next_pos == current_pos + 1: return \\"NO\\" current_pos = next_pos - 1 return \\"YES\\" # function to process the input and call the solution function def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) heights = list(map(int, data[1:N+1])) T = int(data[N+1]) result = can_reach_end(heights, T) print(result)"},{"question":"def secret_santa(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if a valid Secret Santa gift distribution is possible. >>> secret_santa(3, [(3, [1, 2, 3]), (4, [4, 3, 2, 1]), (3, [3, 1, 2])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> secret_santa(1, [(1, [1])]) [\\"NO\\"] >>> secret_santa(2, [(2, [1, 2]), (2, [2, 1])]) [\\"YES\\", \\"YES\\"] >>> secret_santa(1, [(5, [5, 4, 3, 2, 1])]) [\\"YES\\"] >>> secret_santa(1, [(3, [3, 3, 3])]) [\\"NO\\"]","solution":"def secret_santa(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] # number of minions minions = test_cases[i][1] # list of minions if n == 1: results.append(\\"NO\\") else: # For N minions, we need to ensure that every minion maps to another unique minion # There are many valid permutations except for identity permutation where minion gives to itself results.append(\\"YES\\") return results"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string of lowercase English letters, determine the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): n = len(s) if n == 0: return 0 char_map = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_map: start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def has_enough_candies(T, test_cases): Determines if Chef has enough candies to distribute as per the friends' requirements. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains: - N (int): Number of friends, - C (int): Total number of candies, - requirements (list of int): Candies each friend wants. Returns: list of str: List of \\"YES\\" or \\"NO\\" for each test case based on whether the number of candies is sufficient. pass def parse_input(input_string): Parses the input string to extract test cases. Parameters: input_string (str): Complete input as a single string. Returns: tuple: - int: Number of test cases - list of tuples: Each tuple contains: - N (int): Number of friends, - C (int): Total number of candies, - list of int: Candies each friend wants. pass # Unit tests def test_has_enough_candies(): # Test case 1 T, test_cases = parse_input(\\"2n4 10n2 3 1 2n3 10n5 5 5\\") assert has_enough_candies(T, test_cases) == [\\"YES\\", \\"NO\\"] # Test case 2 T, test_cases = parse_input(\\"1n5 20n4 4 4 4 4\\") assert has_enough_candies(T, test_cases) == [\\"YES\\"] # Test case 3 T, test_cases = parse_input(\\"3n2 1n1 0n2 2n1 2n2 3n1 1\\") assert has_enough_candies(T, test_cases) == [\\"YES\\", \\"NO\\", \\"YES\\"] def test_parse_input(): input_string = \\"2n4 10n2 3 1 2n3 10n5 5 5\\" T, test_cases = parse_input(input_string) assert T == 2 assert test_cases == [(4, 10, [2, 3, 1, 2]), (3, 10, [5, 5, 5])] input_string = \\"1n5 20n4 4 4 4 4\\" T, test_cases = parse_input(input_string) assert T == 1 assert test_cases == [(5, 20, [4, 4, 4, 4, 4])]","solution":"def has_enough_candies(T, test_cases): Determines if Chef has enough candies to distribute as per the friends' requirements. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains: - N (int): Number of friends, - C (int): Total number of candies, - requirements (list of int): Candies each friend wants. Returns: list of str: List of \\"YES\\" or \\"NO\\" for each test case based on whether the number of candies is sufficient. results = [] for case in test_cases: N, C, requirements = case if sum(requirements) <= C: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_string): Parses the input string to extract test cases. Parameters: input_string (str): Complete input as a single string. Returns: tuple: - int: Number of test cases - list of tuples: Each tuple contains: - N (int): Number of friends, - C (int): Total number of candies, - list of int: Candies each friend wants. lines = input_string.strip().split(\\"n\\") T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N, C = map(int, lines[index].split()) requirements = list(map(int, lines[index + 1].split())) test_cases.append((N, C, requirements)) index += 2 return T, test_cases"},{"question":"from typing import List def form_largest_group(N: int, participants_data: List[str]) -> int: Given a number of participants and their topic preferences, find the largest group of participants that share at least one common topic. >>> form_largest_group(6, [\\"Alice AI Data-Science\\", \\"Bob AI Machine-Learning\\", \\"Charlie Cybersecurity\\", \\"David Data-Science Machine-Learning\\", \\"Eve AI Data-Science\\", \\"Frank Cybersecurity\\"]) == 3 >>> form_largest_group(4, [\\"Alice AI\\", \\"Bob AI\\", \\"Charlie AI\\", \\"David AI\\"]) == 4 >>> form_largest_group(3, [\\"Alice Data-Science\\", \\"Bob Machine-Learning\\", \\"Charlie Cybersecurity\\"]) == 1 >>> form_largest_group(5, [\\"Alice AI Data-Science\\", \\"Bob AI\\", \\"Charlie Cybersecurity\\", \\"David Cybersecurity Machine-Learning\\", \\"Eve Machine-Learning\\"]) == 2 >>> form_largest_group(6, [\\"Alice AI\\", \\"Bob Machine-Learning\\", \\"Charlie Cybersecurity\\", \\"David AI\\", \\"Eve Machine-Learning\\", \\"Frank AI\\"]) == 3","solution":"from collections import defaultdict def form_largest_group(N, participants_data): # Create a dictionary to map each topic to the participants interested in it topic_to_participants = defaultdict(set) # Process each participant's data for participant_data in participants_data: parts = participant_data.split() name = parts[0] topics = parts[1:] for topic in topics: topic_to_participants[topic].add(name) # Find the largest group by comparing the size of participant lists for each topic largest_group = 0 for participants in topic_to_participants.values(): largest_group = max(largest_group, len(participants)) return largest_group"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns a list such that each element is the product of all other elements except itself. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([5]) [0] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([1, 1, 1, 1]) [1, 1, 1, 1] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6]","solution":"def product_except_self(nums): Returns a list such that each element is the product of all other elements except itself. length = len(nums) if length == 0: return [] if length == 1: return [0] # Initialize the result array result = [1] * length # Calculate left products left = 1 for i in range(length): result[i] = left left *= nums[i] # Calculate right products and final result right = 1 for i in range(length - 1, -1, -1): result[i] *= right right *= nums[i] return result"},{"question":"def modify_byte(byte, instructions): Modifies specific bits of a byte based on given instructions. Args: byte (int): An integer representing the byte (0 to 255). instructions (list): A list of tuples, where each tuple contains: - bit_position (0-7): The position of the bit to modify. - new_value (0 or 1): The new value of the bit. Returns: int: The modified byte as an integer. >>> modify_byte(0b10101010, [(1, 0), (6, 1)]) 0b11101000 >>> modify_byte(0b11111111, [(0, 0), (7, 0)]) 0b01111110","solution":"def modify_byte(byte, instructions): Modifies specific bits of a byte based on given instructions. Args: byte (int): An integer representing the byte (0 to 255). instructions (list): A list of tuples, where each tuple contains: - bit_position (0-7): The position of the bit to modify. - new_value (0 or 1): The new value of the bit. Returns: int: The modified byte as an integer. for bit_position, new_value in instructions: if new_value == 1: byte |= (1 << bit_position) else: byte &= ~(1 << bit_position) return byte"},{"question":"def whoWinsGame(s: str) -> str: Determines the winner of the game assuming both players play optimally. Args: s (str): A string representing the initial sequence of characters. Returns: str: Either \\"Alice\\" or \\"Bob\\" indicating the winner. Examples: >>> whoWinsGame(\\"aaabbbcc\\") \\"Alice\\" >>> whoWinsGame(\\"aaabb\\") \\"Bob\\"","solution":"def whoWinsGame(s): Determines the winner of the game assuming both players play optimally. Args: s (str): A string representing the initial sequence of characters. Returns: str: Either \\"Alice\\" or \\"Bob\\" indicating the winner. # Count the number of groups of identical characters groups = 1 # There's at least one group n = len(s) for i in range(1, n): if s[i] != s[i-1]: groups += 1 # Alice goes first, so she will win if the number of groups is odd # Bob will win if the number of groups is even if groups % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"from collections import deque def min_moves(grid: List[str], sx: int, sy: int, dx: int, dy: int) -> int: Function to determine the minimum number of moves required for the robot to reach the destination through a 2D grid. The grid is represented by \`n x m\` dimensions where each cell is either an open space ('.') or a wall ('#'). The robot can move up, down, left, or right, but it cannot move through the walls. If the destination is not reachable, return \`-1\`. Parameters: grid (List[str]): The 2D grid represented as a list of strings. sx (int): The starting x-coordinate of the robot. sy (int): The starting y-coordinate of the robot. dx (int): The destination x-coordinate of the robot. dy (int): The destination y-coordinate of the robot. Output: int: The minimum number of moves to reach the destination or \`-1\` if not reachable. >>> min_moves([\\".....\\", \\".#.#.\\", \\"..#..\\", \\".#.#.\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_moves([\\".....\\", \\".#.#.\\", \\"..#..\\", \\".#.#.\\", \\".....\\"], 0, 0, 1, 1) -1 >>> min_moves([\\".#\\", \\"..\\"], 0, 0, 1, 1) 2 >>> min_moves([\\".\\"], 0, 0, 0, 0) 0 >>> min_moves([\\"#\\", \\"#\\", \\"#\\", \\"#\\", \\"#\\"], 0, 0, 4, 4) -1","solution":"from collections import deque def min_moves(grid, sx, sy, dx, dy): Function to determine the minimum number of moves required for the robot to reach the destination. n = len(grid) m = len(grid[0]) # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS ((current_x, current_y), current_distance) queue = deque([((sx, sy), 0)]) # Set to keep track of visited cells visited = set() visited.add((sx, sy)) # BFS traversal while queue: (x, y), dist = queue.popleft() # If destination is reached if (x, y) == (dx, dy): return dist # Explore all four directions for direction in directions: new_x, new_y = x + direction[0], y + direction[1] if 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] == '.' and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append(((new_x, new_y), dist + 1)) # If destination is not reachable return -1"},{"question":"def can_make_equal_with_one_swap(n: int, s: str, t: str) -> str: Determine if it is possible to make string s equal to string t by performing at most one swap operation on string s. :param n: Length of the strings :param s: The original string :param t: The target string :return: \\"YES\\" if possible, otherwise \\"NO\\" >>> can_make_equal_with_one_swap(5, \\"abced\\", \\"abcde\\") \\"YES\\" >>> can_make_equal_with_one_swap(3, \\"abc\\", \\"bca\\") \\"NO\\" >>> can_make_equal_with_one_swap(4, \\"abcd\\", \\"abdc\\") \\"YES\\" from can_make_equal_with_one_swap import can_make_equal_with_one_swap def test_same_strings(): assert can_make_equal_with_one_swap(5, \\"abcde\\", \\"abcde\\") == \\"YES\\" def test_one_swap_possible(): assert can_make_equal_with_one_swap(5, \\"abced\\", \\"abcde\\") == \\"YES\\" assert can_make_equal_with_one_swap(4, \\"abcd\\", \\"abdc\\") == \\"YES\\" def test_no_swap_possible(): assert can_make_equal_with_one_swap(3, \\"abc\\", \\"bca\\") == \\"NO\\" def test_all_characters_same_but_different_order(): assert can_make_equal_with_one_swap(4, \\"aabb\\", \\"bbaa\\") == \\"NO\\" def test_complete_mismatch(): assert can_make_equal_with_one_swap(3, \\"abc\\", \\"def\\") == \\"NO\\" def test_one_char_mismatch(): assert can_make_equal_with_one_swap(5, \\"abcde\\", \\"abzde\\") == \\"NO\\" def test_multiple_mismatches(): assert can_make_equal_with_one_swap(6, \\"abcdef\\", \\"abcfde\\") == \\"NO\\"","solution":"def can_make_equal_with_one_swap(n, s, t): Determine if it is possible to make string s equal to string t by performing at most one swap operation on string s. :param n: Length of the strings :param s: The original string :param t: The target string :return: \\"YES\\" if possible, otherwise \\"NO\\" if s == t: return \\"YES\\" mismatch_indices = [i for i in range(n) if s[i] != t[i]] if len(mismatch_indices) == 2: i, j = mismatch_indices if s[i] == t[j] and s[j] == t[i]: return \\"YES\\" return \\"NO\\""},{"question":"def max_packages(capacities): Given a list of conveyor capacities, return the maximum number of packages that can be in transit simultaneously without exceeding the capacity of any conveyor. :param capacities: List of integers representing the capacities of the conveyors :return: Integer representing the maximum number of packages in transit >>> max_packages([3, 5, 2, 4, 6]) 20 >>> max_packages([1, 2, 3, 4, 5]) 15 # Implement the function here import unittest class TestMaxPackages(unittest.TestCase): def test_max_packages_example1(self): self.assertEqual(max_packages([3, 5, 2, 4, 6]), 20) def test_max_packages_example2(self): self.assertEqual(max_packages([1, 2, 3, 4, 5]), 15) def test_max_packages_with_zero_capacity(self): self.assertEqual(max_packages([0, 2, 3, 4, 5]), 14) def test_max_packages_all_zero_capacities(self): self.assertEqual(max_packages([0, 0, 0, 0, 0]), 0) def test_max_packages_single_conveyor(self): self.assertEqual(max_packages([10]), 10) def test_max_packages_large_numbers(self): self.assertEqual(max_packages([100, 200, 300, 400, 500]), 1500) if __name__ == \\"__main__\\": unittest.main()","solution":"def max_packages(capacities): Given a list of conveyor capacities, return the maximum number of packages that can be in transit simultaneously without exceeding the capacity of any conveyor. :param capacities: List of integers representing the capacities of the conveyors :return: Integer representing the maximum number of packages in transit return sum(capacities)"},{"question":"from typing import List def determine_winner(m: int, n: int, lst: List[int]) -> str: Determines the winner of the m-th game if David and Emma play optimally. :param m: the number of games to be played :param n: the number of integers in the list :param lst: list of integers :return: the winner of the m-th game (\\"David\\" or \\"Emma\\") >>> determine_winner(5, 3, [1, 2, 3]) 'David' >>> determine_winner(2, 4, [4, 5, 6, 7]) 'Emma' >>> determine_winner(1, 1, [8]) 'David'","solution":"def determine_winner(m, n, lst): Determines the winner of the m-th game. :param m: int - the number of games to be played :param n: int - the number of integers in the list :param lst: list of int - the list of integers :return: str - the winner of the m-th game (\\"David\\" or \\"Emma\\") if m % 2 == 1: return \\"David\\" else: return \\"Emma\\""},{"question":"def min_fast_track_connections(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Calculate the minimum number of fast-track connections required to ensure that every district can be reached from any other district. Args: n (int): The number of districts. m (int): The number of existing roads. roads (List[Tuple[int, int]]): A list of tuples representing the existing roads. Returns: int: The minimum number of fast-track connections required. >>> min_fast_track_connections(1, 0, []) 0 >>> min_fast_track_connections(2, 0, []) 1 >>> min_fast_track_connections(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 0 >>> min_fast_track_connections(5, 2, [(1, 2), (3, 4)]) 2 >>> min_fast_track_connections(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (1, 5)]) 0 >>> min_fast_track_connections(6, 3, [(1, 2), (3, 4), (5, 6)]) 2","solution":"def min_fast_track_connections(n, m, roads): from collections import defaultdict, deque # Create an adjacency list to represent the graph graph = defaultdict(list) for road in roads: u, v = road graph[u].append(v) graph[v].append(u) # A function to perform BFS and mark all reachable nodes from a starting node def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) visited = [False] * (n + 1) connected_components = 0 # Perform BFS for each node, count the number of connected components for i in range(1, n + 1): if not visited[i]: bfs(i, visited) connected_components += 1 # Minimum fast tracks required is (connected components - 1) return connected_components - 1"},{"question":"def is_perfect_number(num: int) -> bool: Determine if a number is a perfect number. A Perfect Number is a number that is equal to the sum of its proper divisors (excluding itself). >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(12) False >>> is_perfect_number(496) True >>> is_perfect_number(1) False pass def bart_chocolate_bars(test_cases: List[int]) -> List[str]: Determine if Bart should buy each chocolate bar based on its weight. Bart buys the chocolate bar only if its weight is a perfect number. >>> bart_chocolate_bars([6, 28, 12, 496]) [\\"BUY\\", \\"BUY\\", \\"PASS\\", \\"BUY\\"] >>> bart_chocolate_bars([1, 2, 3, 4, 5]) [\\"PASS\\", \\"PASS\\", \\"PASS\\", \\"PASS\\", \\"PASS\\"] >>> bart_chocolate_bars([33550336]) [\\"BUY\\"] >>> bart_chocolate_bars([8128, 33550336]) [\\"BUY\\", \\"BUY\\"] pass from solution import is_perfect_number, bart_chocolate_bars def test_is_perfect_number(): assert is_perfect_number(6) == True assert is_perfect_number(28) == True assert is_perfect_number(496) == True assert is_perfect_number(8128) == True assert is_perfect_number(12) == False assert is_perfect_number(1) == False def test_bart_chocolate_bars(): assert bart_chocolate_bars([6, 28, 12, 496]) == [\\"BUY\\", \\"BUY\\", \\"PASS\\", \\"BUY\\"] assert bart_chocolate_bars([1, 2, 3, 4, 5]) == [\\"PASS\\", \\"PASS\\", \\"PASS\\", \\"PASS\\", \\"PASS\\"] assert bart_chocolate_bars([33550336]) == [\\"BUY\\"] assert bart_chocolate_bars([8128, 33550336]) == [\\"BUY\\", \\"BUY\\"] assert bart_chocolate_bars([]) == [] def test_single_case(): assert bart_chocolate_bars([28]) == [\\"BUY\\"] assert bart_chocolate_bars([27]) == [\\"PASS\\"] def test_large_numbers(): assert bart_chocolate_bars([10**6]) == [\\"PASS\\"] assert bart_chocolate_bars([33550336]) == [\\"BUY\\"]","solution":"def is_perfect_number(num): if num <= 1: return False sum_of_divisors = 1 for i in range(2, int(num**0.5) + 1): if num % i == 0: sum_of_divisors += i if i != num // i: sum_of_divisors += num // i return sum_of_divisors == num def bart_chocolate_bars(test_cases): results = [] for w in test_cases: if is_perfect_number(w): results.append(\\"BUY\\") else: results.append(\\"PASS\\") return results"},{"question":"def count_char_occurrences(S: str, C: str) -> int: Returns the number of occurrences of character C in string S. The comparison is case-sensitive. Args: S (str): The input string. C (str): The character to count in the string S. Returns: int: The number of occurrences of C in S Examples: >>> count_char_occurrences(\\"ProgrammingIsFun\\", \\"g\\") 2 >>> count_char_occurrences(\\"Count_ALL_the@Chars!\\", \\"@\\") 1 >>> count_char_occurrences(\\"Hello_World!\\", \\"o\\") 2","solution":"def count_char_occurrences(S, C): Returns the number of occurrences of character C in string S. The comparison is case-sensitive. return S.count(C)"},{"question":"def fibonacci(n: int) -> List[int]: Returns a list of the first n Fibonacci numbers, where the first two Fibonacci numbers are 0 and 1. >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of the first n Fibonacci numbers. if n <= 0: return [] fib_seq = [0, 1] while len(fib_seq) < n: next_fib = fib_seq[-1] + fib_seq[-2] fib_seq.append(next_fib) return fib_seq[:n]"},{"question":"def intersection_of_k_sorted_arrays(k, arrays): Finds the intersection of k sorted arrays. Parameters: k (int): Number of arrays. arrays (List[List[int]]): List of k sorted arrays. Returns: List[int]: Sorted list of common elements in all arrays. Examples: >>> intersection_of_k_sorted_arrays(3, [[1, 2, 3, 4, 5], [2, 3, 5, 7], [2, 3, 4, 5, 9, 10]]) [2, 3, 5] >>> intersection_of_k_sorted_arrays(2, [[1, 2, 3], [3, 4, 5]]) [3] >>> intersection_of_k_sorted_arrays(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [] pass # Helper function to process the input format def process_input(input_str): Processes the input format to extract k and the arrays. Parameters: input_str (str): Input string in the given format. Returns: Tuple[int, List[List[int]]]: Number of arrays and the arrays themselves. Examples: >>> process_input(\\"3n5 1 2 3 4 5n4 2 3 5 7n6 2 3 4 5 9 10\\") (3, [[1, 2, 3, 4, 5], [2, 3, 5, 7], [2, 3, 4, 5, 9, 10]]) >>> process_input(\\"2n3 1 2 3n3 3 4 5\\") (2, [[1, 2, 3], [3, 4, 5]]) pass","solution":"def intersection_of_k_sorted_arrays(k, arrays): Finds the intersection of k sorted arrays. Parameters: k (int): Number of arrays. arrays (List[List[int]]): List of k sorted arrays. Returns: List[int]: Sorted list of common elements in all arrays. if k == 0: return [] from collections import Counter # Combine all arrays into a single list and count the occurrence of each element combined_counter = Counter() for array in arrays: combined_counter.update(set(array)) # Common elements must appear exactly k times common_elements = [num for num in combined_counter if combined_counter[num] == k] # Sort the result common_elements.sort() return common_elements # Helper function to process the input format def process_input(input_str): Processes the input format to extract k and the arrays. Parameters: input_str (str): Input string in the given format. Returns: Tuple[int, List[List[int]]]: Number of arrays and the arrays themselves. lines = input_str.strip().split('n') k = int(lines[0]) arrays = [] for line in lines[1:]: array = list(map(int, line.split()))[1:] # Skip the first number which is N arrays.append(array) return k, arrays"},{"question":"def minRemovalsToMeetSum(arr, target_sum): Determines the minimum number of elements that should be removed so that the remaining elements have a sum less than or equal to target_sum. Args: arr (List[int]): List of integers. target_sum (int): The target sum. Returns: int: Minimum number of elements to remove. Examples: >>> minRemovalsToMeetSum([1, 2, 3, 4, 5], 10) 1 >>> minRemovalsToMeetSum([3, 1, 4, 2, 2], 7) 2 def test_example_1(): assert minRemovalsToMeetSum([1, 2, 3, 4, 5], 10) == 1 def test_example_2(): assert minRemovalsToMeetSum([3, 1, 4, 2, 2], 7) == 2 def test_no_removals_needed(): assert minRemovalsToMeetSum([1, 2, 3], 10) == 0 def test_remove_all(): assert minRemovalsToMeetSum([10, 20, 30], 0) == 3 def test_large_array(): assert minRemovalsToMeetSum([1] * 10000, 9999) == 1 def test_single_element(): assert minRemovalsToMeetSum([50], 25) == 1 def test_target_equal_sum(): assert minRemovalsToMeetSum([5, 5, 5], 15) == 0","solution":"def minRemovalsToMeetSum(arr, target_sum): Determines the minimum number of elements that should be removed so that the remaining elements have a sum less than or equal to target_sum. arr.sort(reverse=True) current_sum = sum(arr) if current_sum <= target_sum: return 0 removals = 0 for i in arr: current_sum -= i removals += 1 if current_sum <= target_sum: break return removals"},{"question":"def longest_subsequence_with_0_and_1(n: int, s: str) -> int: Determine the length of the longest subsequence such that all characters in the subsequence are the same and the subsequence contains at least one '0' and at least one '1'. :param n: int - length of the binary string :param s: str - binary string :return: int - length of the longest valid subsequence >>> longest_subsequence_with_0_and_1(5, \\"10011\\") 5 >>> longest_subsequence_with_0_and_1(4, \\"1111\\") 0 >>> longest_subsequence_with_0_and_1(8, \\"10101010\\") 8","solution":"def longest_subsequence_with_0_and_1(n, s): Returns the length of the longest subsequence that contains at least one '0' and at least one '1'. :param n: int - length of the binary string :param s: str - binary string :return: int - length of the longest valid subsequence if '0' not in s or '1' not in s: return 0 else: return n"},{"question":"def process_call_records(input_data: str) -> dict: Processes call records and calculates total call durations for each person. Args: input_data (str): The input data string representing call records. Returns: dict: Dictionary with names as keys and total call duration as values, sorted by names alphabetically. >>> process_call_records(\\"5nAlice Bob 10nBob Alice 15nAlice Charlie 20nCharlie Alice 5nBob Charlie 30\\") {\\"Alice\\": 50, \\"Bob\\": 55, \\"Charlie\\": 55} >>> process_call_records(\\"1nJohn Doe 25\\") {\\"Doe\\": 25, \\"John\\": 25}","solution":"def calculate_total_call_durations(records): Calculates the total call duration for each person (both as a caller and recipient). Args: records (list of tuple): List of tuples where each tuple contains caller's name, recipient's name, and call duration. Returns: dict: Dictionary with names as keys and total call duration as values. call_durations = {} for caller, recipient, duration in records: if caller in call_durations: call_durations[caller] += duration else: call_durations[caller] = duration if recipient in call_durations: call_durations[recipient] += duration else: call_durations[recipient] = duration return dict(sorted(call_durations.items())) def process_call_records(input_data): Processes the call records from input and calculates total call durations for each person. Args: input_data (str): The input data string representing call records. Returns: dict: Dictionary with names as keys and total call duration as values, sorted by names alphabetically. lines = input_data.strip().split('n') N = int(lines[0]) records = [] for i in range(1, N + 1): parts = lines[i].split() caller = parts[0] recipient = parts[1] duration = int(parts[2]) records.append((caller, recipient, duration)) return calculate_total_call_durations(records)"},{"question":"def min_subarray_len(arr, K): Determines the minimum size of a contiguous subarray of which the sum is at least K. >>> min_subarray_len([1, 2, 3, 4, 5, 6, 7, 8], 15) 2 >>> min_subarray_len([1, 1, 1, 1, 1], 11) 0 >>> min_subarray_len([10], 10) 1 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5 >>> min_subarray_len([1, 2, 3, 4, 5], 16) 0 >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2","solution":"def min_subarray_len(arr, K): Determines the minimum size of a contiguous subarray of which the sum is at least K. N = len(arr) min_len = float('inf') current_sum = 0 left = 0 for right in range(N): current_sum += arr[right] while current_sum >= K: min_len = min(min_len, right - left + 1) current_sum -= arr[left] left += 1 return min_len if min_len != float('inf') else 0"},{"question":"def count_puzzles_to_attempt(n, decisions): Determine how many puzzles each team will attempt to solve based on members' agreement. Parameters: n (int): Number of puzzles decisions (list of list of int): Each list contains three integers where each integer is either 0 or 1, representing the agreement of Alex, Blake, and Casey respectively. Returns: int: The number of puzzles the team will attempt to solve Examples: >>> count_puzzles_to_attempt(4, [[1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 0]]) 2 >>> count_puzzles_to_attempt(3, [[1, 0, 1], [0, 1, 1], [1, 0, 0]]) 2 from solution import count_puzzles_to_attempt def test_example1(): decisions = [ [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 0] ] assert count_puzzles_to_attempt(4, decisions) == 2 def test_example2(): decisions = [ [1, 0, 1], [0, 1, 1], [1, 0, 0] ] assert count_puzzles_to_attempt(3, decisions) == 2 def test_no_puzzles(): decisions = [] assert count_puzzles_to_attempt(0, decisions) == 0 def test_all_agree(): decisions = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert count_puzzles_to_attempt(3, decisions) == 3 def test_all_disagree(): decisions = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert count_puzzles_to_attempt(3, decisions) == 0 def test_mixed_agreements(): decisions = [ [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [0, 1, 1], [1, 0, 1] ] assert count_puzzles_to_attempt(6, decisions) == 3","solution":"def count_puzzles_to_attempt(n, decisions): Parameters: n (int): Number of puzzles decisions (list of list of int): Each list contains three integers where each integer is either 0 or 1. Returns: int: The number of puzzles the team will attempt to solve attempt_count = 0 for decision in decisions: if sum(decision) >= 2: attempt_count += 1 return attempt_count"},{"question":"def is_possible_to_meet(n: int, grid: List[str]) -> str: Determines if Jim and Bob can meet on the grid. Parameters: n (int): Size of the grid (n x n) grid (list of str): The grid represented as a list of strings Returns: str: \\"POSSIBLE\\" if Jim and Bob can meet, otherwise \\"IMPOSSIBLE\\" Examples: >>> n = 5 >>> grid = [ '.....', '.#...', '...', '.....', '...#.' ] >>> is_possible_to_meet(n, grid) \\"POSSIBLE\\" >>> n = 5 >>> grid = [ '.....', '.', '.', '..#', '..#' ] >>> is_possible_to_meet(n, grid) \\"IMPOSSIBLE\\" >>> n = 3 >>> grid = [ '.#.', '#.#', '.#.' ] >>> is_possible_to_meet(n, grid) \\"IMPOSSIBLE\\" >>> n = 2 >>> grid = [ '..', '..' ] >>> is_possible_to_meet(n, grid) \\"POSSIBLE\\" >>> n = 2 >>> grid = [ '', '' ] >>> is_possible_to_meet(n, grid) \\"IMPOSSIBLE\\" >>> n = 3 >>> grid = [ '...', '.#.', '...' ] >>> is_possible_to_meet(n, grid) \\"POSSIBLE\\" >>> n = 3 >>> grid = [ '#..', '#', '..#' ] >>> is_possible_to_meet(n, grid) \\"IMPOSSIBLE\\"","solution":"from collections import deque def is_possible_to_meet(n, grid): Determines if Jim and Bob can meet on the grid. Parameters: n (int): Size of the grid (n x n) grid (list of str): The grid represented as a list of strings Returns: str: \\"POSSIBLE\\" if Jim and Bob can meet, otherwise \\"IMPOSSIBLE\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(start, end): queue = deque([start]) visited = set([start]) while queue: x, y = queue.popleft() if (x, y) == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return False start_jim = (0, 0) end_jim = (n - 1, n - 1) start_bob = (n - 1, n - 1) end_bob = (0, 0) if bfs(start_jim, end_jim) and bfs(start_bob, end_bob): return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def min_crops(N: int, edges: List[Tuple[int, int]]) -> int: A farmer owns N plots of land and wants to grow a variety of crops on these plots. Find the minimum number of different types of crops required to plant on all plots given their adjacency constraints. Input: - N: An integer, number of plots. - edges: A list of tuples, each tuple contains two integers denoting that plot A is adjacent to plot B. Output: - An integer, the minimum number of different types of crops required. Example: >>> min_crops(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) 2 >>> min_crops(1, []) 1 >>> min_crops(3, [(1, 2), (2, 3)]) 2 >>> min_crops(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 2 >>> min_crops(4, [(1, 2), (1, 3), (1, 4)]) 2","solution":"def min_crops(N, edges): from collections import defaultdict, deque if N == 1: return 1 adjacency_list = defaultdict(list) for a, b in edges: adjacency_list[a].append(b) adjacency_list[b].append(a) # To determine the minimum number of different crops required # this is simply finding the chromatic number of a tree, which is 2 def bfs(start_node): colors = [-1] * (N + 1) colors[start_node] = 0 queue = deque([start_node]) while queue: node = queue.popleft() for neighbor in adjacency_list[node]: if colors[neighbor] == -1: colors[neighbor] = 1 - colors[node] queue.append(neighbor) return colors bfs(1) return 2"},{"question":"def longest_path(n: int, x: int, y: int) -> int: Determine the length of the longest path the player can take on the chessboard from the starting position without stepping on any cell more than once. Args: n (int): the size of the chessboard (n x n) x (int): the starting x-coordinate (1-based index) y (int): the starting y-coordinate (1-based index) Returns: int: the length of the longest path >>> longest_path(3, 2, 2) 9 >>> longest_path(4, 1, 1) 16","solution":"def longest_path(n, x, y): Returns the length of the longest path the player can take on the chessboard. return n * n"},{"question":"def clean_number_string(s): Cleans up a string by removing non-numeric characters and extra spaces. If the resulting string is empty or invalid, returns \\"Invalid Input\\". Args: s (str): The input string containing the corrupted number. Returns: str: The cleaned up number as a string or \\"Invalid Input\\" if no valid number can be obtained. >>> clean_number_string(\\"abcd!@#%\\") 'Invalid Input' >>> clean_number_string(\\"1234567890\\") '1234567890' >>> clean_number_string(\\"ab1c2d3e4f5g6h7i8j9k0l\\") '1234567890' >>> clean_number_string(\\"123 456!@#7890\\") '1234567890' >>> clean_number_string(\\" 12 3 456 7890 \\") '1234567890' >>> clean_number_string(\\"\\") 'Invalid Input'","solution":"def clean_number_string(s): Cleans up a string by removing non-numeric characters and extra spaces. If the resulting string is empty or invalid, returns \\"Invalid Input\\". Args: s (str): The input string containing the corrupted number. Returns: str: The cleaned up number as a string or \\"Invalid Input\\" if no valid number can be obtained. cleaned = ''.join(char for char in s if char.isdigit()) return cleaned if cleaned else \\"Invalid Input\\""},{"question":"def min_irregularity(n: int, a: List[int]) -> int: Returns the minimum possible irregularity after rearranging the paintings. Parameters: n (int): The number of paintings a (list of int): The style ratings of the paintings Returns: int: The minimum possible irregularity >>> min_irregularity(4, [1, 3, 2, 5]) 4 >>> min_irregularity(5, [10, 20, 30, 40, 50]) 40 >>> min_irregularity(3, [8, 2, 6]) 6 pass","solution":"def min_irregularity(n, a): Returns the minimum possible irregularity after rearranging the paintings. Parameters: n (int): The number of paintings a (list of int): The style ratings of the paintings Returns: int: The minimum possible irregularity a.sort() irregularity = 0 for i in range(1, n): irregularity += abs(a[i] - a[i-1]) return irregularity"},{"question":"def min_moves_to_target(M, N, grid, r_s, c_s, r_t, c_t): Given a grid of M x N dimensions with mines and a start and target cell, find the minimum number of moves from start to target without stepping on mines. Input: - M: Number of rows (int) - N: Number of columns (int) - grid: List of lists of ints representing the grid (List[List[int]]) - r_s: Starting cell's row (int) - c_s: Starting cell's column (int) - r_t: Target cell's row (int) - c_t: Target cell's column (int) Output: - Minimum number of moves to reach the target cell (int). If impossible, return -1 Examples: >>> grid = [ ... [0, 0, 1, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 0, 0], ... [1, 0, 1, 0, 1], ... [0, 0, 0, 0, 0] ... ] >>> min_moves_to_target(5, 5, grid, 0, 0, 4, 4) 8 >>> grid = [ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ] >>> min_moves_to_target(3, 3, grid, 0, 0, 2, 2) -1","solution":"from collections import deque def min_moves_to_target(M, N, grid, r_s, c_s, r_t, c_t): Given a grid of M x N dimensions with mines and a start and target cell, find the minimum number of moves from start to target without stepping on mines. # If starting or target cell is a mine, return -1 immediately if grid[r_s][c_s] == 1 or grid[r_t][c_t] == 1: return -1 # Initialize queue for BFS queue = deque([(r_s, c_s, 0)]) # (row, column, distance) visited = set((r_s, c_s)) # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: row, col, dist = queue.popleft() # If we have reached the target cell, return the distance if row == r_t and col == c_t: return dist # Explore neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < M and 0 <= new_col < N and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) # If no path found, return -1 return -1"},{"question":"from typing import List, Tuple def kth_term_in_sequence(n: int, k: int) -> int: Returns the k-th term in the sequence starting with the integer n. If n is even, the next term is n + 1, if n is odd, the next term is n - 1. >>> kth_term_in_sequence(7, 1) 7 >>> kth_term_in_sequence(7, 2) 6 >>> kth_term_in_sequence(7, 5) 7 def process_queries(T: int, queries: List[Tuple[int, int]]) -> List[int]: Process multiple queries to find the k-th term in the sequence for each query >>> process_queries(2, [(7, 5), (4, 3)]) [7, 4] >>> process_queries(6, [(2, 1), (2, 2), (2, 3), (5, 1), (5, 2), (5, 3)]) [2, 3, 2, 5, 4, 5]","solution":"def kth_term_in_sequence(n, k): Returns the k-th term in the sequence starting with the integer n. If n is even, the next term is n + 1, if n is odd, the next term is n - 1. if k == 1: return n if n % 2 == 0: return n + 1 if k % 2 == 0 else n else: return n - 1 if k % 2 == 0 else n def process_queries(T, queries): results = [] for query in queries: n, k = query results.append(kth_term_in_sequence(n, k)) return results"},{"question":"def identify_spikes(test_cases): Identify the days with sudden temperature spikes. Args: test_cases: List of tuples where each tuple consists of an integer N and a list of N integers representing temperatures. Returns: List of strings: Each string contains the 1-based indices of days with sudden temperature spikes or \\"None\\". >>> test_cases = [ ... (5, [10, 15, 20, 13, 18]), ... (3, [10, 15, 10]), ... (4, [5, 5, 5, 5]), ... ] >>> identify_spikes(test_cases) ['2 3 5', '2', 'None'] pass def test_identify_spikes(): test_cases = [ (5, [10, 15, 20, 13, 18]), (3, [10, 15, 10]), (4, [5, 5, 5, 5]), (2, [1, 6]), (3, [1, 2, 7]), (6, [1, 2, 7, 12, 1, 6]), (4, [10, 10, 15, 25]), ] expected_results = [ \\"2 3 5\\", \\"2\\", \\"None\\", \\"2\\", \\"3\\", \\"3 4 6\\", \\"3 4\\" ] results = identify_spikes(test_cases) assert results == expected_results def test_identify_spikes_no_spikes(): test_cases = [ (3, [10, 10, 10]), (2, [0, 4]) ] expected_results = [ \\"None\\", \\"None\\" ] results = identify_spikes(test_cases) assert results == expected_results def test_identify_spikes_all_days_spikes(): test_cases = [ (3, [1, 6, 11]), (4, [-5, 5, 15, 25]) ] expected_results = [ \\"2 3\\", \\"2 3 4\\" ] results = identify_spikes(test_cases) assert results == expected_results def test_identify_spikes_single_test_case(): test_cases = [ (2, [1, 7]) ] expected_results = [ \\"2\\" ] results = identify_spikes(test_cases) assert results == expected_results","solution":"def identify_spikes(test_cases): Args: test_cases: List of tuples where each tuple consists of an integer N and a list of N integers representing temperatures. Returns: List of strings: Each string contains the 1-based indices of days with sudden temperature spikes or \\"None\\". result = [] for N, temperatures in test_cases: spikes = [] for i in range(1, N): if temperatures[i] >= temperatures[i - 1] + 5: spikes.append(i + 1) # Convert to 1-based index if spikes: result.append(' '.join(map(str, spikes))) else: result.append(\\"None\\") return result"},{"question":"def max_difficulty_sum(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Anu is participating in a coding marathon consisting of N problems. Each problem has a certain difficulty level represented by an integer. Anu is given only K minutes to solve the problems, where each problem takes exactly 1 minute to solve regardless of its difficulty level. Anu wants to maximize the sum of difficulty levels of the problems she solves within the given time limit. Args: T : int : number of test cases test_cases : list of tuples : each tuple contains (N, K, difficulties) N : int : number of problems K : int : number of minutes difficulties : list of ints : difficulties of problems Returns: list of ints : maximum sum of problem difficulties Anu can solve for each test case. Test Cases: >>> max_difficulty_sum(2, [(5, 3, [10, 20, 30, 40, 50]), (4, 2, [15, 5, 10, 25])]) [120, 40] >>> max_difficulty_sum(1, [(6, 4, [10, 10, 10, 10, 10, 10])]) [40]","solution":"def max_difficulty_sum(T, test_cases): Args: T : int : number of test cases test_cases : list of tuples : each tuple contains (N, K, difficulties) N : int : number of problems K : int : number of minutes difficulties : list of ints : difficulties of problems Returns: list of ints : maximum sum of problem difficulties Anu can solve for each test case. results = [] for i in range(T): N, K, difficulties = test_cases[i] # Sort difficulties in descending order and sum up the top K difficulties max_sum = sum(sorted(difficulties, reverse=True)[:K]) results.append(max_sum) return results"},{"question":"def count_isolated_cells(grids): Count the number of isolated open cells in each grid. Arguments: grids: A list of tuples where each tuple contains n (number of rows), m (number of columns), and the grid itself as a list of strings. Returns: A list of integers representing the count of isolated open cells in each grid. Example: >>> grids = [ ... (4, 4, [\\"XXXX\\",\\"X..X\\",\\"X..X\\",\\"XXXX\\"]), ... (3, 3, [\\"XXX\\",\\"X.X\\",\\"XXX\\"]), ... (5, 6, [\\"XXXXXX\\",\\"X....X\\",\\"XXXXX.\\",\\"X.....\\",\\"XXXXXX\\"]), ... (0, 0, []) ... ] >>> count_isolated_cells(grids) [0, 1, 0]","solution":"def count_isolated_cells(grids): results = [] for n, m, grid in grids: if n == 0 and m == 0: break count = 0 for i in range(n): for j in range(m): if grid[i][j] == '.': up = (i == 0) or (grid[i-1][j] == 'X') down = (i == n-1) or (grid[i+1][j] == 'X') left = (j == 0) or (grid[i][j-1] == 'X') right = (j == m-1) or (grid[i][j+1] == 'X') if up and down and left and right: count += 1 results.append(count) return results"},{"question":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Function to multiply two matrices A and B. If they can't be multiplied, returns an empty list. >>> matrix_multiply([[1, 2, 3], [4, 5, 6]], [[7, 8], [9, 10], [11, 12]]) [[58, 64], [139, 154]] >>> matrix_multiply([[1, 2], [3, 4]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [] def test_matrix_multiplication_possible(): A = [[1, 2, 3], [4, 5, 6]] B = [[7, 8], [9, 10], [11, 12]] expected_result = [[58, 64], [139, 154]] assert matrix_multiply(A, B) == expected_result def test_matrix_multiplication_not_possible(): A = [[1, 2], [3, 4]] B = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] expected_result = [] assert matrix_multiply(A, B) == expected_result def test_matrix_multiplication_1x1(): A = [[5]] B = [[4]] expected_result = [[20]] assert matrix_multiply(A, B) == expected_result def test_matrix_multiplication_identity(): A = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] B = [[5, 10, 15], [20, 25, 30], [35, 40, 45]] expected_result = [[5, 10, 15], [20, 25, 30], [35, 40, 45]] assert matrix_multiply(A, B) == expected_result def test_matrix_multiplication_zero_matrix(): A = [[0, 0], [0, 0]] B = [[1, 2], [3, 4]] expected_result = [[0, 0], [0, 0]] assert matrix_multiply(A, B) == expected_result","solution":"def matrix_multiply(A, B): # Check if A and B can be multiplied if len(A[0]) != len(B): return [] # Initialize dimensions m = len(A) n = len(B) p = len(B[0]) # Initialize the resulting matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"def largest_subtree_sizes(n, edges): Find the size of the largest subtree for each node in the tree. Parameters: n (int): Number of nodes in the tree. edges (List[Tuple[int, int]]): Edges between nodes. Returns: List[int]: List of sizes of the largest subtree rooted at each node. Examples: >>> largest_subtree_sizes(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) [5, 1, 3, 1, 1] >>> largest_subtree_sizes(2, [(1, 2)]) [2, 1] >>> largest_subtree_sizes(3, [(1, 2), (2, 3)]) [3, 2, 1] >>> largest_subtree_sizes(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) [7, 3, 3, 1, 1, 1, 1] >>> largest_subtree_sizes(5, [(1, 2), (1, 3), (1, 4), (1, 5)]) [5, 1, 1, 1, 1]","solution":"def largest_subtree_sizes(n, edges): from collections import defaultdict # Build the adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) def dfs(node, parent): subtree_size = 1 for neighbor in tree[node]: if neighbor != parent: subtree_size += dfs(neighbor, node) max_subtree_sizes[node] = subtree_size return subtree_size max_subtree_sizes = [0] * (n + 1) # Pick any node as the root, let's choose node 1 dfs(1, -1) return max_subtree_sizes[1:] # Example usage: # n = 5 # edges = [(1, 2), (1, 3), (3, 4), (3, 5)] # print(largest_subtree_sizes(n, edges)) # Output: [5, 1, 3, 1, 1]"},{"question":"def max_distance_from_capital(n, roads): Determine the maximum distance a message must travel from the capital to any other city. Parameters: n (int): the number of cities in Graphland. roads (list): a list of tuples representing roads, where each tuple contains two integers \`u\` and \`v\` and a positive integer \`l\`. Returns: int: the maximum distance a message travels from the capital to any city. Example: >>> max_distance_from_capital(5, [(1, 2, 4), (1, 3, 2), (3, 4, 8), (3, 5, 3)]) 10 >>> max_distance_from_capital(2, [(1, 2, 5)]) 5","solution":"def max_distance_from_capital(n, roads): from collections import defaultdict, deque # Create an adjacency list for the tree adjacency_list = defaultdict(list) for u, v, l in roads: adjacency_list[u].append((v, l)) adjacency_list[v].append((u, l)) # BFS to find the maximum distance from the capital (city 1) def bfs(start): visited = [False] * (n + 1) max_distance = [0] * (n + 1) queue = deque([(start, 0)]) # (current_city, current_distance) visited[start] = True while queue: current_city, current_distance = queue.popleft() for neighbor, distance in adjacency_list[current_city]: if not visited[neighbor]: visited[neighbor] = True max_distance[neighbor] = current_distance + distance queue.append((neighbor, max_distance[neighbor])) return max(max_distance) return bfs(1)"},{"question":"def check_responses(n: int, responses: List[Tuple[str, int]], threshold: int) -> str: Determines if any participant's response time is less than the given threshold. :param n: int, number of responses :param responses: list of tuples, each containing (id, time) where id is the participant's code and time is the time taken in minutes :param threshold: int, the time threshold :return: str, \\"YES\\" if any participant's response time is less than the threshold, \\"NO\\" otherwise >>> check_responses(5, [(\\"id1\\", 50), (\\"id2\\", 30), (\\"id1\\", 20), (\\"id3\\", 40), (\\"id2\\", 35)], 25) \\"YES\\" >>> check_responses(4, [(\\"id1\\", 30), (\\"id2\\", 40), (\\"id3\\", 50), (\\"id1\\", 60)], 20) \\"NO\\" >>> check_responses(3, [(\\"id1\\", 15), (\\"id2\\", 25), (\\"id3\\", 35)], 20) \\"YES\\"","solution":"def check_responses(n, responses, threshold): Determines if any participant's response time is less than the given threshold. :param n: int, number of responses :param responses: list of tuples, each containing (id, time) where id is the participant's code and time is the time taken in minutes :param threshold: int, the time threshold :return: str, \\"YES\\" if any participant's response time is less than the threshold, \\"NO\\" otherwise for _, time in responses: if time < threshold: return \\"YES\\" return \\"NO\\""},{"question":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression containing non-negative integers and operators +, -, *, /. :param s: A string representing the mathematical expression :return: The result of the evaluation as an integer >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3/2\\") 1 >>> evaluate_expression(\\"3+5/2\\") 5 >>> evaluate_expression(\\"3-2-1\\") 0 >>> evaluate_expression(\\"14-3/2\\") 13","solution":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression containing non-negative integers and operators +, -, *, /. :param s: A string representing the mathematical expression :return: The result of the evaluation as an integer if not s: return 0 stack = [] num = 0 sign = '+' s = s.replace(' ', '') for i, ch in enumerate(s): if ch.isdigit(): num = num * 10 + int(ch) if ch in '+-*/' or i == len(s) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] *= num elif sign == '/': # Integer division that truncates towards zero stack[-1] = int(stack[-1] / num) sign = ch num = 0 return sum(stack)"},{"question":"def top_donors(donations: List[int], threshold: int) -> List[int]: Returns a list of donations that meet or exceed the threshold, sorted in descending order. >>> top_donors([50, 120, 75, 30, 200, 60], 70) [200, 120, 75] >>> top_donors([10, 25, 50, 100, 5, 150, 200, 75], 50) [200, 150, 100, 75, 50] >>> top_donors([10, 20, 30, 40, 50], 100) []","solution":"def top_donors(donations, threshold): Returns a list of donations that meet or exceed the threshold, sorted in descending order. Parameters: donations (list of int): List of donation amounts. threshold (int): Minimum threshold for donations. Returns: list of int: Donations that meet or exceed the threshold, sorted in descending order. # Filter donations to keep only those that meet or exceed the threshold filtered_donations = [donation for donation in donations if donation >= threshold] # Sort the filtered donations in descending order filtered_donations.sort(reverse=True) return filtered_donations"},{"question":"def is_mirrored_string(mappings: dict, s: str) -> str: Determines if the given string is a mirrored string based on the provided mappings. :param mappings: Dictionary with character mappings indicating which characters can be mirrored. :param s: String that we need to check if it is a mirrored string. :return: \\"MIRRORED\\" if the string is a mirrored string else \\"NOT MIRRORED\\". >>> is_mirrored_string({'a': 'e', 'e': 'a', 'b': 'p', 'p': 'b'}, 'abpe') \\"MIRRORED\\" >>> is_mirrored_string({'h': 'j', 'j': 'h', 'o': 'p', 'p': 'o'}, 'hop') \\"NOT MIRRORED\\" >>> is_mirrored_string({}, 'abc') \\"NOT MIRRORED\\" def process_input(T: int, test_cases: list) -> list: Processes multiple test cases to determine mirrored strings. :param T: Number of test cases. :param test_cases: List of test cases where each test case is a tuple: (N, list_of_mappings, string_to_evaluate) :return: List of results for each test case >>> process_input(2, [(2, [('a', 'e'), ('b', 'p')], 'abpe'), (3, [('h', 'j'), ('o', 'p'), ('k', 'm')], 'hop')]) [\\"MIRRORED\\", \\"NOT MIRRORED\\"] >>> process_input(2, [(1, [('a', 'a')], 'aa'), (2, [('a', 'z'), ('z', 'a')], 'az')]) [\\"MIRRORED\\", \\"MIRRORED\\"]","solution":"def is_mirrored_string(mappings, s): Determines if the given string is a mirrored string based on the provided mappings. :param mappings: Dictionary with character mappings indicating which characters can be mirrored. :param s: String that we need to check if it is a mirrored string. :return: \\"MIRRORED\\" if the string is a mirrored string else \\"NOT MIRRORED\\". n = len(s) for i in range(n // 2): # Compare i-th character with its corresponding mirrored character if s[i] not in mappings or s[-(i + 1)] not in mappings: return \\"NOT MIRRORED\\" if mappings[s[i]] != s[-(i + 1)]: return \\"NOT MIRRORED\\" return \\"MIRRORED\\" def process_input(T, test_cases): Processes multiple test cases to determine mirrored strings. :param T: Number of test cases. :param test_cases: List of test cases where each test case is a tuple: (N, list_of_mappings, string_to_evaluate) :return: List of results for each test case results = [] for N, mappings_list, string in test_cases: mappings = {} for x, y in mappings_list: mappings[x] = y mappings[y] = x result = is_mirrored_string(mappings, string) results.append(result) return results"},{"question":"def decodeString(s: str) -> str: Decode the given encoded string based on the rule k[encoded_string]. >>> decodeString(\\"3[a]2[bc]\\") \\"aaabcbc\\" >>> decodeString(\\"3[a2[c]]\\") \\"accaccacc\\" >>> decodeString(\\"2[abc]3[cd]ef\\") \\"abcabccdcdcdef\\" pass","solution":"def decodeString(s: str) -> str: def helper(index): decoded = [] k = 0 while index < len(s): if s[index].isdigit(): k = k * 10 + int(s[index]) elif s[index] == '[': index, inner_decoded = helper(index + 1) decoded.append(inner_decoded * k) k = 0 elif s[index] == ']': return index, ''.join(decoded) else: decoded.append(s[index]) index += 1 return ''.join(decoded) return helper(0)"},{"question":"def wait_time_for_pedestrian(current_time: int, button_pressed: bool) -> int: Returns the waiting time for a pedestrian after pressing the button. :param current_time: int, the current time in the traffic light cycle (0 â‰¤ current_time < 140). :param button_pressed: bool, indicates whether the button has been pressed by the pedestrian. :return: int, the number of seconds the pedestrian needs to wait. >>> wait_time_for_pedestrian(45, True) 15 >>> wait_time_for_pedestrian(80, False) 0","solution":"def wait_time_for_pedestrian(current_time, button_pressed): Returns the waiting time for a pedestrian after pressing the button. :param current_time: int, the current time in the traffic light cycle. :param button_pressed: bool, indicates whether the button has been pressed by the pedestrian. :return: int, the number of seconds the pedestrian needs to wait. if not button_pressed: return 0 cycle_period = 140 # total cycle time in seconds (sum of red, green, yellow durations) green_duration = 75 yellow_duration = 5 red_duration = 60 # Calculate the time since the start of the last red signal cycle_time = current_time % cycle_period if cycle_time < red_duration: return 0 else: return cycle_period - cycle_time"},{"question":"import bisect from typing import List, Tuple class Game: def __init__(self): self.numbers = [] def add(self, x: int): bisect.insort(self.numbers, x) def find(self, x: int) -> int: idx = bisect.bisect_left(self.numbers, x) if idx < len(self.numbers): return self.numbers[idx] else: return -1 def process_queries(queries: List[Tuple[str, int]]) -> List[int]: Process a list of queries and return the results for 'find' type queries. Each query is a tuple where the first element is either '+' or '?' and the second element is the integer value for the query. + x: Add the number \`x\` to the set. ? x: Find the smallest number in the set that is greater than or equal to \`x\`. Returns a list of results for each 'find' type query. >>> process_queries([('+', 3), ('+', 10), ('?', 3), ('?', 7), ('?', 12)]) [3, 10, -1] >>> process_queries([('+', 5), ('?', 5)]) [5] >>> process_queries([('+', 5), ('?', 10)]) [-1]","solution":"import bisect class Game: def __init__(self): self.numbers = [] def add(self, x): bisect.insort(self.numbers, x) def find(self, x): idx = bisect.bisect_left(self.numbers, x) if idx < len(self.numbers): return self.numbers[idx] else: return -1 def process_queries(queries): game = Game() results = [] for query in queries: if query[0] == '+': game.add(int(query[1])) elif query[0] == '?': results.append(game.find(int(query[1]))) return results"},{"question":"def generate_grid(n: int, r: int, c: int) -> list: Generates a grid of elements based on the given number of rows and columns. Parameters: n (int): The number of elements. r (int): The number of rows. c (int): The number of columns. Returns: list of lists: The grid as a list of lists. Examples: >>> generate_grid(10, 3, 4) [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10]] >>> generate_grid(7, 2, 5) [[1, 2, 3, 4, 5], [6, 7]] >>> generate_grid(15, 4, 4) [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15]]","solution":"def generate_grid(n, r, c): Generates a grid of elements based on the given number of rows and columns. Parameters: n (int): The number of elements. r (int): The number of rows. c (int): The number of columns. Returns: list of lists: The grid as a list of lists. grid = [] elem = 1 # Start with the first element for row in range(r): current_row = [] for col in range(c): if elem <= n: current_row.append(elem) elem += 1 else: break # Break the loop if we exceed the number of elements n if current_row: grid.append(current_row) if elem > n: break # Stop creating rows if we exceed the number of elements n return grid"},{"question":"def length_of_lis(sequence): Returns the length of the longest increasing subsequence in the given sequence. >>> length_of_lis([5, 2, 8, 6, 3, 6, 9, 7]) == 4 >>> length_of_lis([1, 2, 2, 2, 3]) == 3 from bisect import bisect_left def test_example_case_1(): assert length_of_lis([5, 2, 8, 6, 3, 6, 9, 7]) == 4 def test_example_case_2(): assert length_of_lis([1, 2, 2, 2, 3]) == 3 def test_single_element(): assert length_of_lis([10]) == 1 def test_all_elements_same(): assert length_of_lis([4, 4, 4, 4, 4]) == 1 def test_already_sorted(): assert length_of_lis([1, 2, 3, 4, 5, 6]) == 6 def test_reverse_sorted(): assert length_of_lis([6, 5, 4, 3, 2, 1]) == 1 def test_long_random_sequence(): assert length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 # Edge Case: Empty sequence def test_empty_sequence(): assert length_of_lis([]) == 0","solution":"def length_of_lis(sequence): Returns the length of the longest increasing subsequence in the given sequence. from bisect import bisect_left if not sequence: return 0 lis = [] for num in sequence: pos = bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) return len(lis)"},{"question":"from datetime import datetime import math from typing import List def average_trip_duration(trips: List[List[str]]) -> int: Calculate the average trip duration in minutes given a list of trip records. Each record contains start and end timestamps in the format \\"YYYY-MM-DD HH:MM:SS\\". The function should return the average duration rounded to the nearest minute. If the start time is not before the end time, print \\"Start time must be before end time\\". If the list is empty, return 0. >>> average_trip_duration([ ... [\\"2023-10-01 08:00:00\\", \\"2023-10-01 08:30:00\\"], ... [\\"2023-10-01 09:10:00\\", \\"2023-10-01 09:50:00\\"], ... [\\"2023-10-02 12:00:00\\", \\"2023-10-02 12:25:00\\"] ... ]) 32 >>> average_trip_duration([ ... [\\"2023-10-01 08:00:00\\", \\"2023-10-01 08:30:00\\"], ... [\\"2023-10-01 09:50:00\\", \\"2023-10-01 09:10:00\\"] ... ]) \\"Start time must be before end time\\" >>> average_trip_duration([]) 0","solution":"from datetime import datetime import math def average_trip_duration(trips): if not trips: return 0 total_duration = 0 valid_trip_count = 0 for trip in trips: start_time_str, end_time_str = trip start_time = datetime.strptime(start_time_str, \\"%Y-%m-%d %H:%M:%S\\") end_time = datetime.strptime(end_time_str, \\"%Y-%m-%d %H:%M:%S\\") if start_time >= end_time: print(\\"Start time must be before end time\\") continue duration_seconds = (end_time - start_time).total_seconds() duration_minutes = math.ceil(duration_seconds / 60) total_duration += duration_minutes valid_trip_count += 1 if valid_trip_count == 0: return 0 average_duration = total_duration / valid_trip_count return round(average_duration)"},{"question":"def findPair(arr: List[int], target: int) -> List[int]: Finds two distinct elements in the array that add up to the target. Args: arr: List of integers. target: Integer target sum. Returns: List containing indices of the two elements, or an empty list if no such pair exists. >>> findPair([2, 7, 11, 15], 9) [0, 1] >>> findPair([1, 2, 3, 4, 5], 10) []","solution":"def findPair(arr, target): Finds two distinct elements in the array that add up to the target. Args: arr: List of integers. target: Integer target sum. Returns: List containing indices of the two elements, or an empty list if no such pair exists. complement_dict = {} for i, num in enumerate(arr): complement = target - num if complement in complement_dict: return [complement_dict[complement], i] complement_dict[num] = i return []"},{"question":"def library_system(n: int, m: int, stock_levels: List[int], operations: List[str]) -> List[str]: Manage a library's book inventory and user checkouts. The library has n books, each with an initial stock level. The system handles two types of operations: 1. \\"Q x\\": Query the available stock of book x. 2. \\"B x y\\": Borrow y copies of book x. If not enough copies are available, the operation fails. >>> library_system(5, 6, [10, 5, 3, 0, 7], [\\"Q 2\\", \\"B 2 3\\", \\"Q 2\\", \\"B 3 4\\", \\"Q 3\\", \\"B 5 7\\"]) [\\"5\\", \\"Success\\", \\"2\\", \\"Fail\\", \\"3\\", \\"Success\\"] >>> library_system(3, 3, [0, 0, 0], [\\"Q 1\\", \\"B 1 1\\", \\"Q 1\\"]) [\\"0\\", \\"Fail\\", \\"0\\"] >>> library_system(2, 2, [1, 2], [\\"B 1 1\\", \\"Q 1\\"]) [\\"Success\\", \\"0\\"] >>> library_system(1, 2, [3], [\\"B 1 4\\", \\"Q 1\\"]) [\\"Fail\\", \\"3\\"] >>> library_system(1, 3, [5], [\\"B 1 2\\", \\"B 1 1\\", \\"Q 1\\"]) [\\"Success\\", \\"Success\\", \\"2\\"]","solution":"def library_system(n, m, stock_levels, operations): results = [] for operation in operations: op = operation.split() if op[0] == \\"Q\\": x = int(op[1]) - 1 results.append(str(stock_levels[x])) elif op[0] == \\"B\\": x = int(op[1]) - 1 y = int(op[2]) if stock_levels[x] >= y: stock_levels[x] -= y results.append(\\"Success\\") else: results.append(\\"Fail\\") return results"},{"question":"from typing import List, Tuple def determine_windows_count(k: int, skyscrapers: List[Tuple[List[int], List[int]]]) -> List[str]: Determine the number of windows for each side of the skyscrapers. Example: >>> determine_windows_count(2, [([10, 20, 30, 40], [50, 100]), ([0, 15, 20, 0], [25, 50])]) ['10 20 30 40', '0 15 20 0'] >>> determine_windows_count(1, [([100, 200, 300, 400], [1, 50])]) ['impossible']","solution":"def determine_windows_count(k, skyscrapers): results = [] for i in range(k): a, b, c, d = skyscrapers[i][0] low, high = skyscrapers[i][1] total_windows = a + b + c + d if low <= total_windows <= high: results.append(f\\"{a} {b} {c} {d}\\") else: results.append(\\"impossible\\") return results"},{"question":"def min_moves_to_collect_treasures(P, Q, treasures): Calculate the minimum number of moves Bob requires to collect all treasures starting from an optimal initial cell. Args: P (int): The number of rows in the grid. Q (int): The number of columns in the grid. treasures (List[Tuple[int, int]]): A list of coordinates representing the positions of the treasures. Returns: int: The minimum number of moves required to collect all treasures. >>> min_moves_to_collect_treasures(3, 3, [(2, 2)]) 0 >>> min_moves_to_collect_treasures(3, 3, [(1, 1), (3, 3)]) 2 pass def process_input(input_data): Process the input data and return the results for each test case. Args: input_data (str): The raw input data as a string. Returns: List[int]: A list of results, where each result is the minimum number of moves required for a test case. >>> input_data = \\"2n3 3 1n2 2n3 3 2n1 1n3 3n\\" >>> process_input(input_data) [0, 2] >>> input_data = \\"1n2 2 2n1 1n2 2n\\" >>> process_input(input_data) [1] pass def test_min_moves_to_collect_treasures(): assert min_moves_to_collect_treasures(3, 3, [(2, 2)]) == 0 assert min_moves_to_collect_treasures(3, 3, [(1, 1), (3, 3)]) == 2 assert min_moves_to_collect_treasures(5, 5, [(1, 1), (5, 5), (5, 1)]) == 4 assert min_moves_to_collect_treasures(2, 2, [(2, 2), (1, 1)]) == 1 def test_process_input(): input_data = \\"2n3 3 1n2 2n3 3 2n1 1n3 3n\\" expected_output = [0, 2] assert process_input(input_data) == expected_output input_data = \\"1n2 2 2n1 1n2 2n\\" expected_output = [1] assert process_input(input_data) == expected_output input_data = \\"1n5 5 3n1 1n5 5n5 1n\\" expected_output = [4] assert process_input(input_data) == expected_output input_data = \\"1n2 2 1n2 2n\\" expected_output = [0] assert process_input(input_data) == expected_output","solution":"def min_moves_to_collect_treasures(P, Q, treasures): if len(treasures) == 1: # If there is only one treasure, the optimal start is on the treasure itself, so 0 moves required. return 0 # Find the minimum and maximum x and y coordinates of the treasures min_x = min(t[0] for t in treasures) max_x = max(t[0] for t in treasures) min_y = min(t[1] for t in treasures) max_y = max(t[1] for t in treasures) # The optimal initial cell can be any one from where Bob can reach the farthest treasures. max_distance = max(max_x - min_x, max_y - min_y) return max_distance def process_input(input_data): input_lines = input_data.strip().split('n') index = 0 T = int(input_lines[index]) index += 1 results = [] for _ in range(T): P, Q, K = map(int, input_lines[index].split()) index += 1 treasures = [] for _ in range(K): x, y = map(int, input_lines[index].split()) treasures.append((x, y)) index += 1 result = min_moves_to_collect_treasures(P, Q, treasures) results.append(result) return results"},{"question":"def digital_drawing_application(h, w, n, commands): In a digital drawing application, handle commands to manipulate rectangles on a canvas. Arguments: h -- the height of the canvas w -- the width of the canvas n -- the number of commands commands -- a list of commands (strings) Returns: A list of integers where each integer is the result of a 'count' command. >>> digital_drawing_application(5, 5, 6, [\\"draw 1 1 2 2\\", \\"count\\", \\"draw 3 3 4 4\\", \\"count\\", \\"erase 1 1 2 2\\", \\"count\\"]) [4, 8, 4] >>> digital_drawing_application(4, 4, 4, [\\"draw 1 1 4 4\\", \\"count\\", \\"erase 2 2 3 3\\", \\"count\\"]) [16, 12] from solution import digital_drawing_application def test_sample_case(): h, w, n = 5, 5, 6 commands = [ \\"draw 1 1 2 2\\", \\"count\\", \\"draw 3 3 4 4\\", \\"count\\", \\"erase 1 1 2 2\\", \\"count\\" ] expected_output = [4, 8, 4] assert digital_drawing_application(h, w, n, commands) == expected_output def test_draw_full_canvas(): h, w, n = 4, 4, 2 commands = [ \\"draw 1 1 4 4\\", \\"count\\" ] expected_output = [16] assert digital_drawing_application(h, w, n, commands) == expected_output def test_erase_partial_canvas(): h, w, n = 4, 4, 4 commands = [ \\"draw 1 1 4 4\\", \\"count\\", \\"erase 2 2 3 3\\", \\"count\\" ] expected_output = [16, 12] assert digital_drawing_application(h, w, n, commands) == expected_output def test_no_draw_commands(): h, w, n = 3, 3, 1 commands = [ \\"count\\" ] expected_output = [0] assert digital_drawing_application(h, w, n, commands) == expected_output def test_multiple_erases(): h, w, n = 5, 5, 5 commands = [ \\"draw 1 1 5 5\\", \\"count\\", \\"erase 1 1 2 2\\", \\"count\\", \\"erase 4 4 5 5\\", \\"count\\" ] expected_output = [25, 21, 17] assert digital_drawing_application(h, w, n, commands) == expected_output def test_edge_case_single_pixel(): h, w, n = 1, 1, 3 commands = [ \\"draw 1 1 1 1\\", \\"count\\", \\"erase 1 1 1 1\\", \\"count\\" ] expected_output = [1, 0] assert digital_drawing_application(h, w, n, commands) == expected_output","solution":"def digital_drawing_application(h, w, n, commands): canvas = [[0] * w for _ in range(h)] def apply_draw(x1, y1, x2, y2): for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): canvas[i][j] = 1 def apply_erase(x1, y1, x2, y2): for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): canvas[i][j] = 0 def apply_count(): return sum(sum(row) for row in canvas) result = [] for command in commands: parts = command.split() if parts[0] == 'draw': _, x1, y1, x2, y2 = parts apply_draw(int(x1), int(y1), int(x2), int(y2)) elif parts[0] == 'erase': _, x1, y1, x2, y2 = parts apply_erase(int(x1), int(y1), int(x2), int(y2)) elif parts[0] == 'count': result.append(apply_count()) return result"},{"question":"def candies_distribution(c: int, n: int) -> (int, int): Calculates the minimum and maximum number of candies the teacher can have after distributing candies to students. :param c: Total number of candies (1 â‰¤ n â‰¤ c â‰¤ 1000) :param n: Number of students :return: A tuple (min_candies_left, max_candies_left) >>> candies_distribution(10, 3) (1, 1) >>> candies_distribution(15, 4) (3, 3) >>> candies_distribution(7, 7) (0, 0)","solution":"def candies_distribution(c, n): Calculates the minimum and maximum number of candies the teacher can have after distributing candies to students. :param c: Total number of candies :param n: Number of students :return: A tuple (min_candies_left, max_candies_left) min_candies_left = c % n max_candies_left = c - n if max_candies_left < 0: max_candies_left = 0 return min_candies_left, min_candies_left"},{"question":"def max_correct_answers(q: int, attempts: List[int]) -> int: Given the number of questions and a list of maximum attempts for each question, return the maximum number of questions Binu can answer correctly. Parameters: q (int): The number of questions. attempts (List[int]): List of integers where each integer denotes the maximum number of attempts Binu can make for each question. Returns: int: The maximum number of questions Binu can answer correctly. Example Usage: >>> max_correct_answers(3, [1, 2, 3]) 3 >>> max_correct_answers(5, [1, 1, 1, 1, 1]) 5","solution":"def max_correct_answers(q, attempts): Returns the maximum number of questions Binu can answer correctly. Parameters: q (int): The number of questions. attempts (list): List of integers where each integer denotes the maximum number of attempts Binu can make for each question. Returns: int: The maximum number of questions Binu can answer correctly. return q # Sample Input # q = 3 # attempts = [1, 2, 3] # Output: 3 # q = 5 # attempts = [1, 1, 1, 1, 1] # Output: 5"},{"question":"def longest_segment(t: int, test_cases: list[tuple[int, list[int]]]) -> list[int]: Returns the length of the longest segment of flowers for each test case such that no two adjacent flowers in this segment have the same color. Parameters: t (int): The number of test cases. test_cases (list of tuples): A list where each element is a tuple containing: n (int): The number of flowers. colors (list of int): The colors of the flowers. Returns: list of int: The lengths of the longest segments for each test case. >>> longest_segment(3, [(5, [1, 2, 2, 3, 4]), (4, [1, 1, 1, 1]), (6, [1, 2, 1, 2, 1, 2])]) [3, 1, 6] >>> longest_segment(1, [(3, [3, 3, 3])]) [1] >>> longest_segment(1, [(8, [1, 2, 1, 2, 1, 2, 1, 2])]) [8] >>> longest_segment(2, [(3, [1, 1, 2]), (4, [1, 1, 2, 2])]) [2, 2]","solution":"def longest_segment(t, test_cases): Returns the length of the longest segment of flowers for each test case such that no two adjacent flowers in this segment have the same color. Parameters: t (int): The number of test cases. test_cases (list of tuples): A list where each element is a tuple containing: n (int): The number of flowers. colors (list of int): The colors of the flowers. Returns: list of int: The lengths of the longest segments for each test case. results = [] for n, colors in test_cases: max_length = 1 current_length = 1 for i in range(1, n): if colors[i] != colors[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 results.append(max_length) return results"},{"question":"def count_mountain_valleys(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Karen loves long hikes in the mountains, but she notices that the terrain forms a pattern in heights. She wonders how many \\"mountain valleys\\" she can find. A \\"mountain valley\\" is defined as a sequence where the height first strictly decreases and then strictly increases. More formally, for an array \`a\` of length \`n\`, a subarray \`a[l, ..., r]\` (where \`1 <= l < r <= n\`) is a mountain valley if there exists an index \`m\` such that, \`a[l] > a[l+1] > ... > a[m] < a[m+1] < ... < a[r]\`. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, each test case consisting of a tuple with the length of the array and the array of heights. Returns: List[int]: A list of integers representing the number of mountain valleys in each test case. Example: >>> count_mountain_valleys(3, [ (5, [10, 8, 7, 12, 15]), (4, [1, 2, 3, 4]), (6, [9, 6, 3, 6, 7, 8]) ]) [1, 0, 1]","solution":"def count_mountain_valleys(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] valleys = 0 for j in range(1, n-1): if a[j-1] > a[j] < a[j+1]: left = j-1 right = j+1 while left > 0 and a[left-1] > a[left]: left -= 1 while right < n-1 and a[right+1] > a[right]: right += 1 if left < j and right > j: valleys += 1 results.append(valleys) return results # Reading input and preparing the test cases if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() t = int(data[0]) test_cases = [] index = 1 for _ in range(t): n = int(data[index]) a = list(map(int, data[index+1:index+1+n])) test_cases.append((n, a)) index += (n + 1) results = count_mountain_valleys(t, test_cases) for result in results: print(result)"},{"question":"def max_sum_subarray_even_index_sum(arr: List[int]) -> int: Determine the maximum sum of a subarray such that the sum of the subarray's indices is even. >>> max_sum_subarray_even_index_sum([3, -2, 5, -1, 2]) 7 >>> max_sum_subarray_even_index_sum([-1, 4, -3, 5]) 6 def process_test_cases(test_cases: List[List[int]]) -> List[int]: Process multiple test cases and return results for the maximum sum of subarrays with even index sums. >>> process_test_cases([[3, -2, 5, -1, 2], [-1, 4, -3, 5]]) [7, 6] from typing import List def test_case_1(): assert process_test_cases([[3, -2, 5, -1, 2]]) == [7] def test_case_2(): assert process_test_cases([[-1, 4, -3, 5]]) == [6] def test_case_3(): assert process_test_cases([[1, 2, 3, 4, 5]]) == [15] def test_case_4(): assert process_test_cases([[1, -1, 1, -1, 1]]) == [1] def test_case_5(): assert process_test_cases([[-5, -4, -3, -2, -1]]) == [-1] def test_multi_cases(): assert process_test_cases([[3, -2, 5, -1, 2], [-1, 4, -3, 5], [1, 2, 3, 4, 5], [1, -1, 1, -1, 1], [-5, -4, -3, -2, -1]]) == [7, 6, 15, 1, -1]","solution":"def max_sum_subarray_even_index_sum(arr): n = len(arr) max_sum = float('-inf') current_sum = float('-inf') for i in range(n): for j in range(i, n): subarray_sum = sum(arr[i:j+1]) if (i + j) % 2 == 0 and subarray_sum > current_sum: current_sum = subarray_sum return current_sum if current_sum > float('-inf') else -1 def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(max_sum_subarray_even_index_sum(arr)) return results"},{"question":"class ArrayQuery: def __init__(self, array): Initialize the ArrayQuery object with an initial array of integers. self.array = array def sum_query(self, l, r): Calculates the sum of elements in the subarray from index l to index r (inclusive). Indices l and r are 1-based. Args: l (int): The starting index of the subarray (1-based). r (int): The ending index of the subarray (1-based). Returns: int: The sum of the specified subarray. Example: >>> array_query = ArrayQuery([1, 2, 3, 4, 5]) >>> array_query.sum_query(2, 4) 9 pass def update_query(self, i, x): Updates the element at index i to x. Index i is 1-based. Args: i (int): The index of the element to be updated (1-based). x (int): The new value for the element. Example: >>> array_query = ArrayQuery([1, 2, 3, 4, 5]) >>> array_query.update_query(3, 10) >>> array_query.array [1, 2, 10, 4, 5] pass","solution":"class ArrayQuery: def __init__(self, array): self.array = array def sum_query(self, l, r): Calculates the sum of elements in the subarray from index l to index r (inclusive). Indices l and r are 1-based. return sum(self.array[l-1:r]) def update_query(self, i, x): Updates the element at index i to x. Index i is 1-based. self.array[i-1] = x"},{"question":"def canPermutePalindrome(s: str) -> int: Determine if we can palindrome permute the string. >>> canPermutePalindrome(\\"aabb\\") 1 >>> canPermutePalindrome(\\"abc\\") 0 def test_canPermutePalindrome_valid_palindrome_permutation(): assert canPermutePalindrome(\\"aabb\\") == 1 assert canPermutePalindrome(\\"ababa\\") == 1 assert canPermutePalindrome(\\"racecar\\") == 1 def test_canPermutePalindrome_no_valid_palindrome_permutation(): assert canPermutePalindrome(\\"abc\\") == 0 assert canPermutePalindrome(\\"abcdefg\\") == 0 assert canPermutePalindrome(\\"xyz\\") == 0 def test_canPermutePalindrome_single_character(): assert canPermutePalindrome(\\"a\\") == 1 def test_canPermutePalindrome_all_same_characters(): assert canPermutePalindrome(\\"aaaa\\") == 1 assert canPermutePalindrome(\\"bbbbbb\\") == 1 def test_canPermutePalindrome_mixed_case(): assert canPermutePalindrome(\\"Aa\\") == 0 # Assuming case sensitivity assert canPermutePalindrome(\\"abBA\\") == 0 # Assuming case sensitivity","solution":"def canPermutePalindrome(s: str) -> int: from collections import Counter # Count the frequency of each character count = Counter(s) # Calculate how many characters have an odd count odd_count = sum(1 for c in count if count[c] % 2 != 0) # For a string to be a palindrome, there can be at most one character with an odd count return 1 if odd_count <= 1 else 0"},{"question":"def min_operations_to_non_decreasing(N: int, A: List[int]) -> int: Determine the minimum number of operations required to make the entire array non-decreasing. >>> min_operations_to_non_decreasing(5, [3, 1, 4, 1, 5]) 2 >>> min_operations_to_non_decreasing(5, [1, 2, 3, 4, 5]) 0 >>> min_operations_to_non_decreasing(5, [2, 2, 2, 2, 2]) 0 >>> min_operations_to_non_decreasing(5, [5, 4, 3, 2, 1]) 4 >>> min_operations_to_non_decreasing(1, [1]) 0 >>> min_operations_to_non_decreasing(6, [3, 3, 5, 4, 4, 2]) 3","solution":"def min_operations_to_non_decreasing(N, A): operations = 0 current_max = A[0] for i in range(1, N): if A[i] < current_max: operations += 1 else: current_max = A[i] return operations"},{"question":"def pentar_to_decimal(n: int, pentar_numbers: str) -> int: Convert a string of numbers in the Pentar system to the decimal system. >>> pentar_to_decimal(3, \\"One Zero Four\\") 104 >>> pentar_to_decimal(5, \\"Four Zero Zero Three Two\\") 40032 >>> pentar_to_decimal(1, \\"Zero\\") 0 >>> pentar_to_decimal(2, \\"Three Two\\") 32 >>> pentar_to_decimal(4, \\"One Two Three Four\\") 1234","solution":"def pentar_to_decimal(n, pentar_numbers): pentar_dict = { \\"Zero\\": \\"0\\", \\"One\\": \\"1\\", \\"Two\\": \\"2\\", \\"Three\\": \\"3\\", \\"Four\\": \\"4\\" } decimal_number = ''.join(pentar_dict[pentar] for pentar in pentar_numbers.split()) return int(decimal_number)"},{"question":"def are_anagrams(a: str, b: str) -> bool: Returns True if the two strings a and b are anagrams of each other, False otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False","solution":"def are_anagrams(a, b): Returns True if the two strings a and b are anagrams of each other, False otherwise. # Anagram strings must be of the same length if len(a) != len(b): return False # Check if both strings have the same frequency of characters from collections import Counter return Counter(a) == Counter(b)"},{"question":"def min_trees_for_fruit(t: int, test_cases: list) -> list: Determine the minimum number of contiguous trees that need to be picked such that the sum of their fruits is at least the given sum S. >>> min_trees_for_fruit(2, [(5, [1, 2, 3, 4, 5], 11), (5, [1, 2, 3, 4, 5], 15)]) [3, 5] >>> min_trees_for_fruit(1, [(3, [1, 2, 3], 5)]) [2] >>> min_trees_for_fruit(1, [(4, [1, 1, 1, 10], 10)]) [1] >>> min_trees_for_fruit(1, [(3, [1, 2, 3], 10)]) [-1] >>> min_trees_for_fruit(1, [(6, [1, 2, 3, 4, 5, 6], 10)]) [2] pass","solution":"def min_trees_for_fruit(t: int, test_cases: list): results = [] for i in range(t): N = test_cases[i][0] a = test_cases[i][1] S = test_cases[i][2] min_length = N + 1 current_sum = 0 start = 0 for end in range(N): current_sum += a[end] while current_sum >= S: min_length = min(min_length, end - start + 1) current_sum -= a[start] start += 1 if min_length == N + 1: results.append(-1) else: results.append(min_length) return results"},{"question":"def can_obtain_exactly_m_bags(n: int, m: int) -> bool: Determines if it is possible to obtain exactly m bags starting from n marbles. :param n: initial number of marbles :param m: desired number of bags :return: True if possible to achieve exactly m bags, otherwise False >>> can_obtain_exactly_m_bags(10, 5) True >>> can_obtain_exactly_m_bags(5, 5) True >>> can_obtain_exactly_m_bags(12, 6) True >>> can_obtain_exactly_m_bags(15, 3) True >>> can_obtain_exactly_m_bags(1000000000, 1) False def process_test_cases(t: int, test_cases: List[Tuple[int, int]]) -> List[str]: Processes multiple test cases. :param t: number of test cases :param test_cases: list of tuples, each containing (n, m) :return: list of results for each test case, either \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" >>> process_test_cases(5, [(10, 5), (5, 5), (12, 6), (15, 3), (1000000000, 1)]) [\\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\"] from typing import List, Tuple def test_can_obtain_exactly_m_bags(): assert can_obtain_exactly_m_bags(10, 5) == True assert can_obtain_exactly_m_bags(5, 5) == True assert can_obtain_exactly_m_bags(12, 6) == True assert can_obtain_exactly_m_bags(15, 3) == True assert can_obtain_exactly_m_bags(1000000000, 1) == False assert can_obtain_exactly_m_bags(1, 1) == True assert can_obtain_exactly_m_bags(7, 10) == False def test_process_test_cases(): test_cases = [ (10, 5), (5, 5), (12, 6), (15, 3), (1000000000, 1) ] expected_output = [ \\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\" ] assert process_test_cases(5, test_cases) == expected_output test_cases = [ (1, 1), (10, 10), (10, 11) ] expected_output = [ \\"POSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\" ] assert process_test_cases(3, test_cases) == expected_output","solution":"def can_obtain_exactly_m_bags(n, m): Determines if it is possible to obtain exactly m bags starting from n marbles. if m == 1: return n == 1 return m <= n def process_test_cases(t, test_cases): results = [] for n, m in test_cases: if can_obtain_exactly_m_bags(n, m): results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results"},{"question":"def tournament_schedule(N: int) -> tuple: Returns the total number of matches and the unique schedule of matches for a tournament with N players where each player competes with every other player exactly once. :param N: An integer representing the number of players :return: A tuple (total_matches, match_schedule) where: - total_matches is an integer representing the total number of matches - match_schedule is a list of tuples, where each tuple represents a match between two players >>> tournament_schedule(4) (6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) >>> tournament_schedule(2) (1, [(1, 2)]) >>> tournament_schedule(1) (0, [])","solution":"def tournament_schedule(N): Returns the total number of matches and the unique schedule of matches for a tournament with N players where each player competes with every other player exactly once. :param N: An integer representing the number of players :return: A tuple (total_matches, match_schedule) where: - total_matches is an integer representing the total number of matches - match_schedule is a list of tuples, where each tuple represents a match between two players total_matches = N * (N - 1) // 2 match_schedule = [(i, j) for i in range(1, N) for j in range(i + 1, N + 1)] return total_matches, match_schedule"},{"question":"def has_pair_with_difference_k(arr, k): Determines if there are two indices i, j such that i < j and the absolute difference between the values at these indices is exactly K. Parameters: arr (list): List of integers k (int): The integer K to check for the absolute difference Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\"","solution":"def has_pair_with_difference_k(arr, k): Determines if there are two indices i, j such that i < j and the absolute difference between the values at these indices is exactly K. Parameters: arr (list): List of integers k (int): The integer K to check for the absolute difference Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\" values_set = set() for value in arr: if value + k in values_set or value - k in values_set: return \\"YES\\" values_set.add(value) return \\"NO\\""},{"question":"def findLargest(s: str) -> int: Returns the largest integer from a comma-separated string of integers. >>> findLargest(\\"1, 2, 3, 4, 5\\") == 5 >>> findLargest(\\"7, 3, 9, 2, 8\\") == 9 >>> findLargest(\\"15, 22, 8, 19, 31\\") == 31 >>> findLargest(\\"-1, -4, -7, -3, -2\\") == -1 >>> findLargest(\\"42\\") == 42","solution":"def findLargest(s): Returns the largest integer from a comma-separated string of integers. # Split the string by commas and convert each element to an integer numbers = list(map(int, s.split(','))) # Return the largest integer return max(numbers)"},{"question":"def longest_repeated_substring(S: str) -> str: Given a string S consisting of lowercase English letters, find the longest substring which occurs at least twice in S. >>> longest_repeated_substring(\\"abcabcbb\\") 'abc' >>> longest_repeated_substring(\\"banana\\") 'ana' >>> longest_repeated_substring(\\"a\\") '' >>> longest_repeated_substring(\\"abcdefg\\") '' >>> longest_repeated_substring(\\"ababa\\") 'aba' >>> longest_repeated_substring(\\"aaaaa\\") 'aaaa' >>> longest_repeated_substring(\\"a\\" * 5000 + \\"b\\" * 5000) 'a' * 4999","solution":"def longest_repeated_substring(S): Finds the longest substring which occurs at least twice in the given string S. def search_substrings(length): seen = {} for i in range(len(S) - length + 1): substring = S[i:i+length] if substring in seen: return substring seen[substring] = i return \\"\\" left, right = 1, len(S) result = \\"\\" while left <= right: mid = (left + right) // 2 candidate = search_substrings(mid) if candidate: result = candidate left = mid + 1 else: right = mid - 1 return result"},{"question":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def range_query(self, left, right): return self.query(right) - self.query(left - 1) class RangeSum: def __init__(self, arr): self.n = len(arr) self.arr = [0] * (self.n + 1) self.fenwick_tree = FenwickTree(self.n) for i in range(1, self.n + 1): self.arr[i] = arr[i - 1] self.fenwick_tree.update(i, self.arr[i]) def update(self, index, value): index += 1 delta = value - self.arr[index] self.arr[index] = value self.fenwick_tree.update(index, delta) def range_sum(self, left, right): return self.fenwick_tree.range_query(left, right) def process_queries(n, q, array, queries): Process a series of update and range sum queries. :param n: Number of elements in the array :param q: Number of queries :param array: List of integers representing the array :param queries: List of queries where each query is of two types: * [1, x, y]: Update the element at index x to y * [2, l, r]: Compute the sum of the elements from index l to index r :return: List of results for each range sum query import pytest def test_example_case(): n = 5 q = 6 array = [1, 2, 3, 4, 5] queries = [ [2, 1, 5], [1, 3, 10], [2, 1, 5], [2, 3, 3], [1, 5, 8], [2, 4, 5] ] expected_output = [15, 22, 10, 12] assert process_queries(n, q, array, queries) == expected_output def test_single_element(): n = 1 q = 2 array = [100] queries = [ [2, 1, 1], [1, 1, 200], [2, 1, 1] ] expected_output = [100, 200] assert process_queries(n, q, array, queries) == expected_output def test_all_updates(): n = 3 q = 4 array = [3, 1, 4] queries = [ [2, 1, 3], [1, 1, 5], [1, 2, 9], [2, 1, 3] ] expected_output = [8, 18] assert process_queries(n, q, array, queries) == expected_output def test_all_range_queries(): n = 4 q = 3 array = [2, 7, 1, 8] queries = [ [2, 1, 2], [2, 1, 4], [2, 3, 4] ] expected_output = [9, 18, 9] assert process_queries(n, q, array, queries) == expected_output","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, index, delta): while index <= self.size: self.tree[index] += delta index += index & -index def query(self, index): sum_ = 0 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_ def range_query(self, left, right): return self.query(right) - self.query(left - 1) class RangeSum: def __init__(self, arr): self.n = len(arr) self.arr = [0] * (self.n + 1) self.fenwick_tree = FenwickTree(self.n) # Initialize Fenwick Tree with the array values for i in range(1, self.n + 1): self.arr[i] = arr[i - 1] self.fenwick_tree.update(i, self.arr[i]) def update(self, index, value): index += 1 # Convert to 1-based index delta = value - self.arr[index] self.arr[index] = value self.fenwick_tree.update(index, delta) def range_sum(self, left, right): return self.fenwick_tree.range_query(left, right) # Function to process queries def process_queries(n, q, array, queries): result = [] range_sum_obj = RangeSum(array) for query in queries: query_type = query[0] if query_type == 1: # Update query _, index, value = query range_sum_obj.update(index - 1, value) elif query_type == 2: # Range sum query _, left, right = query sum_ = range_sum_obj.range_sum(left, right) result.append(sum_) return result"},{"question":"def maxCrops(grid): Given a grid where each cell contains a certain number of crops, determine the maximum number of crops that can be collected starting from the top-left corner to the bottom-right corner, moving only down or right. >>> maxCrops([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> maxCrops([ ... [1, 2], ... [5, 6] ... ]) 12 >>> maxCrops([ ... [5] ... ]) 5 >>> maxCrops([ ... [1, 2, 3, 4] ... ]) 10 >>> maxCrops([ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> maxCrops([ ... [1, 3, 5], ... [2, 1, 8], ... [4, 2, 1], ... [0, 6, 3] ... ]) 21","solution":"def maxCrops(grid): if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Create a dp array to store the maximum crops collectible up to each cell dp = [[0] * m for _ in range(n)] # Initialize dp array with the first cell in grid dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill rest of dp array for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def merge_streams(streams): Merges multiple streams of data points sorted by timestamp. Args: streams (list of list of tuples): Each sublist contains tuples (timestamp, value). Returns: list of tuples: A single merged list sorted by timestamp. Examples: >>> merge_streams([ ... [(1, 100), (2, 200), (5, 500)], ... [(3, 300), (4, 400)] ... ]) [(1, 100), (2, 200), (3, 300), (4, 400), (5, 500)] >>> merge_streams([ ... [(1, 10), (4, 40)], ... [(2, 20), (5, 50)], ... [(3, 30), (6, 60)] ... ]) [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)]","solution":"import heapq def merge_streams(streams): Merges multiple streams of data points sorted by timestamp. Args: streams (list of list of tuples): Each sublist contains tuples (timestamp, value). Returns: list of tuples: A single merged list sorted by timestamp. merged_stream = [] min_heap = [] # Initialize the heap with the first element of each stream along with the stream index for i, stream in enumerate(streams): if stream: heapq.heappush(min_heap, (stream[0][0], stream[0][1], i, 0)) # Process the heap while min_heap: timestamp, value, stream_idx, element_idx = heapq.heappop(min_heap) merged_stream.append((timestamp, value)) # If there are more elements in the same stream, add the next one to the heap if element_idx + 1 < len(streams[stream_idx]): next_element = streams[stream_idx][element_idx + 1] heapq.heappush(min_heap, (next_element[0], next_element[1], stream_idx, element_idx + 1)) return merged_stream"},{"question":"def decode_message(T: int, messages: List[int]) -> List[int]: Decodes each message by rearranging the digits in descending order. Parameters: T : int : number of test cases messages: list : list of integers representing the encoded messages Returns: List of decoded integers >>> decode_message(3, [2143, 928374, 6001]) [4321, 987432, 6100] >>> decode_message(1, [12345]) [54321]","solution":"def decode_message(T, messages): Decodes each message by rearranging the digits in descending order. Parameters: T : int : number of test cases messages: list : list of integers representing the encoded messages Returns: List of decoded integers decoded_messages = [] for message in messages: decoded_message = ''.join(sorted(str(message), reverse=True)) decoded_messages.append(int(decoded_message)) return decoded_messages"},{"question":"def max_students_passing(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum number of students who can pass a subject if the passing criteria changes dynamically based on a given percentage. >>> max_students_passing(1, [(5, 40, [50, 80, 30, 90, 100])]) [2] >>> max_students_passing(1, [(4, 50, [40, 50, 60, 70])]) [2] >>> max_students_passing(2, [(5, 40, [50, 80, 30, 90, 100]), (4, 50, [40, 50, 60, 70])]) [2, 2]","solution":"def max_students_passing(T, test_cases): results = [] for i in range(T): N, P = test_cases[i][:2] marks = test_cases[i][2:] k = N * P // 100 results.append(k) return results # Example usage: # T = 2 # test_cases = [ # (5, 40, [50, 80, 30, 90, 100]), # (4, 50, [40, 50, 60, 70]) # ] # print(max_students_passing(T, test_cases)) # This would output [2, 2]"},{"question":"from typing import List, Dict def calculate_active_duration(logs: List[Dict[str, str]]) -> int: Calculates the total active duration of user sessions in seconds Parameters: logs (List[Dict[str, str]]): A list of dictionaries where each dictionary contains: - \\"timestamp\\": A string in ISO 8601 format. - \\"action\\": A string representing the action performed (\\"login\\", \\"logout\\", \\"view\\", or \\"click\\"). Returns: int: The total duration in seconds of the user sessions. Examples: >>> calculate_active_duration([{\\"timestamp\\": \\"2023-10-10T14:48:00Z\\", \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-10-10T14:49:00Z\\", \\"action\\": \\"view\\"}, {\\"timestamp\\": \\"2023-10-10T14:50:00Z\\", \\"action\\": \\"click\\"}, {\\"timestamp\\": \\"2023-10-10T14:51:00Z\\", \\"action\\": \\"logout\\"}, {\\"timestamp\\": \\"2023-10-10T15:00:00Z\\", \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-10-10T15:02:00Z\\", \\"action\\": \\"click\\"}, {\\"timestamp\\": \\"2023-10-10T15:05:00Z\\", \\"action\\": \\"logout\\"}]) 900 >>> calculate_active_duration([{\\"timestamp\\": \\"2023-10-10T08:00:00Z\\", \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-10-10T08:30:00Z\\", \\"action\\": \\"view\\"}, {\\"timestamp\\": \\"2023-10-10T09:00:00Z\\", \\"action\\": \\"click\\"}, {\\"timestamp\\": \\"2023-10-10T09:15:00Z\\", \\"action\\": \\"logout\\"}, {\\"timestamp\\": \\"2023-10-10T10:00:00Z\\", \\"action\\": \\"login\\"}, {\\"timestamp\\": \\"2023-10-10T10:05:00Z\\", \\"action\\": \\"logout\\"}]) 5400","solution":"from datetime import datetime def calculate_active_duration(logs): total_duration = 0 login_time = None for log in logs: if log['action'] == 'login': login_time = log['timestamp'] elif log['action'] == 'logout' and login_time: logout_time = log['timestamp'] login_dt = datetime.fromisoformat(login_time.replace(\\"Z\\", \\"+00:00\\")) logout_dt = datetime.fromisoformat(logout_time.replace(\\"Z\\", \\"+00:00\\")) session_duration = (logout_dt - login_dt).total_seconds() total_duration += session_duration login_time = None # reset login_time for the next session return int(total_duration)"},{"question":"def min_moves_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an integer array \`arr\` of size \`n\`, find the minimum number of moves required to make all elements of the array equal. In one move, you can choose any two adjacent elements of the array and replace one of them with the other. >>> min_moves_to_equal_elements(3, [(4, [1, 2, 2, 3]), (3, [5, 5, 5]), (5, [1, 2, 3, 4, 5])]) [2, 0, 4] >>> min_moves_to_equal_elements(1, [(4, [4, 4, 4, 4])]) [0]","solution":"def min_moves_to_equal_elements(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] max_count = max(arr.count(x) for x in set(arr)) results.append(n - max_count) return results"},{"question":"def is_right_triangle(x1, y1, x2, y2, x3, y3): Given three points, determine if they form a right triangle. pass def process_queries(queries): Process multiple queries to determine if each set of points forms a right triangle. pass # Example usage if __name__ == \\"__main__\\": queries = [ (0, 0, 3, 4, 3, 0), (1, 1, 4, 1, 1, 5), (2, 3, 4, 6, 8, 2) ] print(process_queries(queries)) # Expected: [\\"YES\\", \\"YES\\", \\"NO\\"] def test_is_right_triangle(): assert is_right_triangle(0, 0, 3, 4, 3, 0) == True assert is_right_triangle(1, 1, 4, 1, 1, 5) == True assert is_right_triangle(2, 3, 4, 6, 8, 2) == False assert is_right_triangle(0, 0, 1, 1, 1, 0) == True assert is_right_triangle(0, 0, 0, 1, 1, 2) == False def test_process_queries(): queries = [ (0, 0, 3, 4, 3, 0), (1, 1, 4, 1, 1, 5), (2, 3, 4, 6, 8, 2) ] assert process_queries(queries) == [\\"YES\\", \\"YES\\", \\"NO\\"] queries = [ (0, 0, 1, 1, 1, 0), (0, 0, 0, 1, 1, 2) ] assert process_queries(queries) == [\\"YES\\", \\"NO\\"]","solution":"def is_right_triangle(x1, y1, x2, y2, x3, y3): Given three points, determine if they form a right triangle. # Calculate the squared distance between each pair of points d1 = (x2 - x1)**2 + (y2 - y1)**2 d2 = (x3 - x1)**2 + (y3 - y1)**2 d3 = (x3 - x2)**2 + (y3 - y2)**2 # Sort the distances distances = sorted([d1, d2, d3]) # Check if the sum of the squares of the two smaller distances is equal to the square of the largest distance return distances[0] + distances[1] == distances[2] def process_queries(queries): Process multiple queries to determine if each set of points forms a right triangle. results = [] for query in queries: x1, y1, x2, y2, x3, y3 = query if is_right_triangle(x1, y1, x2, y2, x3, y3): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. >>> longest_unique_substring('abcdef') 'abcdef' >>> longest_unique_substring('bbbbb') 'b' >>> longest_unique_substring('pwwkew') 'wke' >>> longest_unique_substring('abrkaabcdefghijjxxx') 'abcdefghij' >>> longest_unique_substring('') '' >>> longest_unique_substring('abcabcbb') 'abc' >>> longest_unique_substring('dvdf') 'vdf'","solution":"def longest_unique_substring(s): Returns the longest substring without repeating characters. # Dictionary to store the index of characters char_index = {} longest_substr = \\"\\" start = 0 for end, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = end if end - start + 1 > len(longest_substr): longest_substr = s[start:end+1] return longest_substr"},{"question":"from collections import defaultdict def max_weight_simple_path(n, m, edges): Compute the maximum possible sum of weights of a simple path in a directed graph. Args: n (int): The number of vertices. m (int): The number of edges. edges (list of tuples): Each tuple (u, v, w) represents a directed edge from vertex u to vertex v with weight w. Returns: int: The maximum sum of weights of a simple path in the graph. >>> max_weight_simple_path(5, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (1, 3, 2)]) 18 >>> max_weight_simple_path(4, 3, [(1, 2, 100), (2, 3, 200), (3, 4, 300)]) 600 >>> max_weight_simple_path(3, 2, [(1, 2, 50), (2, 3, 50)]) 100 >>> max_weight_simple_path(3, 0, []) 0 >>> max_weight_simple_path(2, 1, [(1, 2, 10)]) 10 >>> max_weight_simple_path(4, 2, [(1, 2, 10), (3, 4, 10)]) 10","solution":"from collections import defaultdict, deque def max_weight_simple_path(n, m, edges): graph = defaultdict(list) # Build the graph for u, v, w in edges: graph[u].append((v, w)) # Memoization for DFS results, key is (current node, visited mask) memo = {} def dfs(node, visited): # Base case: memoization check if (node, visited) in memo: return memo[(node, visited)] max_path_weight = 0 for neighbor, weight in graph[node]: if not visited & (1 << neighbor): # check if neighbor is not visited max_path_weight = max(max_path_weight, weight + dfs(neighbor, visited | (1 << neighbor))) # Memorize and return the result memo[(node, visited)] = max_path_weight return max_path_weight max_weight = 0 for i in range(1, n + 1): max_weight = max(max_weight, dfs(i, 1 << i)) return max_weight # Example usage: # This is directly converting the sample input to the function parameters. if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) edges = [] for i in range(2, len(data), 3): u = int(data[i]) v = int(data[i+1]) w = int(data[i+2]) edges.append((u, v, w)) print(max_weight_simple_path(N, M, edges))"},{"question":"def smallest_right_triangle(m: int, n: int): Determine if the two given numbers can be arranged to form a right-angled triangle with integer sides. Return the sides in ascending order if possible, else return -1. Args: m (int): one side of the triangle n (int): another side of the triangle Returns: list: the sides of the right-angled triangle in ascending order if possible, else -1 >>> smallest_right_triangle(5, 12) [5, 12, 13] >>> smallest_right_triangle(2, 4) -1 >>> smallest_right_triangle(7, 24) [7, 24, 25] pass # Unit Tests def test_example_0(): assert smallest_right_triangle(5, 12) == [5, 12, 13] def test_example_1(): assert smallest_right_triangle(2, 4) == -1 def test_example_2(): assert smallest_right_triangle(7, 24) == [7, 24, 25] def test_both_sides_equal(): assert smallest_right_triangle(3, 3) == -1 def test_one_is_hypotenuse(): assert smallest_right_triangle(15, 8) == [8, 15, 17] def test_large_numbers(): # This might not return a right triangle because it's pretty random and large, just testing limits assert smallest_right_triangle(100000000, 99999999) == -1 def test_small_pythagorean_triplet(): assert smallest_right_triangle(3, 4) == [3, 4, 5]","solution":"def smallest_right_triangle(m, n): Return the smallest right-angled triangle with integer sides involving m and n. Parameters: m (int): one side of the triangle n (int): another side of the triangle Returns: list: the sides of the right-angled triangle in ascending order if possible, else -1 # Ensure m <= n for easier comparison m, n = sorted([m, n]) # h is the hypotenuse h = (m**2 + n**2) ** 0.5 if h.is_integer(): return sorted([m, n, int(h)]) return -1"},{"question":"class FileSystem: Implement a basic file system which supports the following operations: - Create a new file with a given name - Read data from an existing file - Write data to an existing file - Delete an existing file The file system should be able to handle the following constraints: - File names are unique and consist of lowercase English letters only. - Each file can store an arbitrary string as its content. - Maximum file name length is 100 characters and maximum content length for any file is 1000 characters. - Each operation (create, read, write, delete) must be completed in O(1) time. Examples: >>> fs = FileSystem() >>> fs.create(\\"file1\\") >>> fs.write(\\"file1\\", \\"Hello\\") >>> fs.read(\\"file1\\") == \\"Hello\\" >>> fs.create(\\"file1\\") == \\"ERROR\\" >>> fs.delete(\\"file1\\") >>> fs.read(\\"file1\\") == \\"ERROR\\" def __init__(self): self.files = {} def create(self, filename: str): pass def read(self, filename: str) -> str: pass def write(self, filename: str, content: str): pass def delete(self, filename: str): pass # Unit Tests def test_create_file(): fs = FileSystem() assert fs.create(\\"file1\\") is None assert fs.create(\\"file1\\") == \\"ERROR\\" def test_read_file(): fs = FileSystem() fs.create(\\"file1\\") fs.write(\\"file1\\", \\"Hello\\") assert fs.read(\\"file1\\") == \\"Hello\\" assert fs.read(\\"file2\\") == \\"ERROR\\" def test_write_file(): fs = FileSystem() fs.create(\\"file1\\") assert fs.write(\\"file1\\", \\"Hello\\") is None assert fs.read(\\"file1\\") == \\"Hello\\" assert fs.write(\\"file2\\", \\"World\\") == \\"ERROR\\" def test_delete_file(): fs = FileSystem() fs.create(\\"file1\\") assert fs.delete(\\"file1\\") is None assert fs.delete(\\"file1\\") == \\"ERROR\\" def test_full_example(): fs = FileSystem() assert fs.create(\\"file1\\") is None assert fs.write(\\"file1\\", \\"Hello\\") is None assert fs.read(\\"file1\\") == \\"Hello\\" assert fs.create(\\"file2\\") is None assert fs.write(\\"file2\\", \\"World\\") is None assert fs.read(\\"file2\\") == \\"World\\" assert fs.delete(\\"file1\\") is None assert fs.read(\\"file1\\") == \\"ERROR\\" assert fs.create(\\"file1\\") is None","solution":"class FileSystem: def __init__(self): self.files = {} def create(self, filename): if filename in self.files: return \\"ERROR\\" self.files[filename] = \\"\\" return None def read(self, filename): if filename not in self.files: return \\"ERROR\\" return self.files[filename] def write(self, filename, content): if filename not in self.files: return \\"ERROR\\" self.files[filename] = content return None def delete(self, filename): if filename not in self.files: return \\"ERROR\\" del self.files[filename] return None"},{"question":"def compare_decorated_numbers(num1: str, num2: str) -> str: Compares two strings representing decorated house numbers, ignoring leading zeros. Parameters: - num1: str, first decorated number - num2: str, second decorated number Returns: - str, \\"FIRST\\" if num1 is greater, \\"SECOND\\" if num2 is greater, \\"EQUAL\\" if both are the same >>> compare_decorated_numbers(\\"00123\\", \\"0123\\") \\"EQUAL\\" >>> compare_decorated_numbers(\\"055\\", \\"44\\") \\"FIRST\\" >>> compare_decorated_numbers(\\"0003\\", \\"0004\\") \\"SECOND\\" >>> compare_decorated_numbers(\\"0000\\", \\"0\\") \\"EQUAL\\" >>> compare_decorated_numbers(\\"125\\", \\"123\\") \\"FIRST\\" >>> compare_decorated_numbers(\\"100\\", \\"123\\") \\"SECOND\\"","solution":"def compare_decorated_numbers(num1, num2): Compares two strings representing decorated house numbers, ignoring leading zeros. Parameters: - num1: str, first decorated number - num2: str, second decorated number Returns: - str, \\"FIRST\\" if num1 is greater, \\"SECOND\\" if num2 is greater, \\"EQUAL\\" if both are the same stripped_num1 = num1.lstrip('0') stripped_num2 = num2.lstrip('0') if stripped_num1 == \\"\\": stripped_num1 = \\"0\\" if stripped_num2 == \\"\\": stripped_num2 = \\"0\\" if int(stripped_num1) > int(stripped_num2): return \\"FIRST\\" elif int(stripped_num1) < int(stripped_num2): return \\"SECOND\\" else: return \\"EQUAL\\""},{"question":"def max_distinct_flowers(grid): Returns a list where each element corresponds to the maximum number of distinct flower types that can be planted in each row. >>> max_distinct_flowers([[1, 1, 2], [2, 3, 3], [3, 2, 1]]) [2, 2, 3] >>> max_distinct_flowers([[1, 1, 1, 1], [2, 2, 2, 2]]) [1, 1] # Write your code here def process_input(input_str): Process input string and returns the result from max_distinct_flowers. >>> process_input(\\"3 3 3n1 1 2n2 3 3n3 2 1\\") [2, 2, 3] >>> process_input(\\"2 4 2n1 1 1 1n2 2 2 2\\") [1, 1] # Write your code here","solution":"def max_distinct_flowers(grid): Returns a list where each element corresponds to the maximum number of distinct flower types that can be planted in each row. return [len(set(row)) for row in grid] def process_input(input_str): lines = input_str.strip().split(\\"n\\") n, m, k = map(int, lines[0].split()) grid = [list(map(int, lines[i + 1].split())) for i in range(n)] return max_distinct_flowers(grid)"},{"question":"from typing import List def find_palindromic_numbers(numbers: List[int]) -> List[int]: Returns a list of palindromic numbers from the given list. Args: numbers: List[int] - A list of integers. Returns: List[int] - A list containing only the palindromic numbers. pass # Test cases def test_find_palindromic_numbers_with_mixed_numbers(): assert find_palindromic_numbers([121, 123, 454, 567]) == [121, 454] def test_find_palindromic_numbers_all_palindromic(): assert find_palindromic_numbers([1, 22, 303, 4004, 12321]) == [1, 22, 303, 4004, 12321] def test_find_palindromic_numbers_no_palindromic(): assert find_palindromic_numbers([234, 567, 890]) == [] def test_find_palindromic_numbers_empty_list(): assert find_palindromic_numbers([]) == [] def test_find_palindromic_numbers_single_digit_numbers(): assert find_palindromic_numbers([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] def test_find_palindromic_numbers_with_negative_numbers(): assert find_palindromic_numbers([-121, 123, -454, 567, -11]) == [] def test_find_palindromic_numbers_mixed_sign_numbers(): assert find_palindromic_numbers([11, -11, 22, -22]) == [11, 22]","solution":"from typing import List def find_palindromic_numbers(numbers: List[int]) -> List[int]: Returns a list of palindromic numbers from the given list. Args: numbers: List[int] - A list of integers. Returns: List[int] - A list containing only the palindromic numbers. def is_palindromic(number: int) -> bool: str_num = str(number) return str_num == str_num[::-1] return [num for num in numbers if is_palindromic(num)]"},{"question":"def isHappyNumber(n): Determine if a number is a Happy Number. :param n: int, the number to check :return: bool, True if n is a Happy Number, False otherwise >>> isHappyNumber(19) True >>> isHappyNumber(2) False","solution":"def isHappyNumber(n): Determine if a number is a Happy Number. :param n: int, the number to check :return: bool, True if n is a Happy Number, False otherwise def get_next(number): return sum(int(ch)**2 for ch in str(number)) seen = set() while n != 1 and n not in seen: seen.add(n) n = get_next(n) return n == 1"},{"question":"def fulfilled_orders(n, m, stock, orders): Determines the number of orders that are successfully fulfilled. Parameters: n (int): Number of orders. m (int): Number of different types of items. stock (list of int): Initial stock levels for each item type. orders (list of tuple of int): List of orders where each order is a tuple (t, q). Returns: int: Number of orders successfully fulfilled. Examples: >>> fulfilled_orders(5, 3, [10, 5, 20], [(1, 5), (2, 3), (3, 10), (1, 11), (2, 2)]) 4 >>> fulfilled_orders(4, 2, [7, 14], [(2, 15), (1, 3), (2, 7), (1, 5)]) 2 pass # Implement the function here # Unit Tests (Example) def test_example_1(): assert fulfilled_orders(5, 3, [10, 5, 20], [(1, 5), (2, 3), (3, 10), (1, 11), (2, 2)]) == 4 def test_example_2(): assert fulfilled_orders(4, 2, [7, 14], [(2, 15), (1, 3), (2, 7), (1, 5)]) == 2 def test_stock_exhausted(): assert fulfilled_orders(3, 2, [5, 3], [(1, 2), (1, 3), (1, 1)]) == 2 def test_insufficient_initial_stock(): assert fulfilled_orders(2, 2, [1, 1], [(1, 2), (2, 2)]) == 0 def test_exact_stock(): assert fulfilled_orders(3, 3, [6, 8, 10], [(1, 6), (2, 8), (3, 10)]) == 3 def test_no_orders(): assert fulfilled_orders(0, 5, [4, 5, 6, 7, 8], []) == 0 def test_all_orders_rejected(): assert fulfilled_orders(3, 3, [1, 1, 1], [(1, 2), (2, 2), (3, 2)]) == 0","solution":"def fulfilled_orders(n, m, stock, orders): Determines the number of orders that are successfully fulfilled. Parameters: n (int): Number of orders. m (int): Number of different types of items. stock (list of int): Initial stock levels for each item type. orders (list of tuple of int): List of orders where each order is a tuple (t, q). Returns: int: Number of orders successfully fulfilled. successful_orders_count = 0 for t, q in orders: if stock[t-1] >= q: stock[t-1] -= q successful_orders_count += 1 return successful_orders_count"},{"question":"def minimum_remaining_height(n: int, k: int, heights: List[int]) -> int: Finds the minimum possible sum of the heights of the remaining books after removing exactly k books. Parameters: n (int): The number of books. k (int): The number of books to remove. heights (list): The heights of the books. Returns: int: The minimum possible sum of the heights of the remaining books. >>> minimum_remaining_height(5, 2, [4, 1, 3, 5, 2]) 12 >>> minimum_remaining_height(3, 1, [10, 20, 30]) 50","solution":"def minimum_remaining_height(n, k, heights): Finds the minimum possible sum of the heights of the remaining books after removing exactly k books. Parameters: n (int): The number of books. k (int): The number of books to remove. heights (list): The heights of the books. Returns: int: The minimum possible sum of the heights of the remaining books. # Sort heights in ascending order heights.sort() # Remove the k smallest elements remaining_books = heights[k:] # Return the sum of the remaining books return sum(remaining_books)"},{"question":"def minimize_absolute_differences(t, test_cases): Reorder arrays such that the sum of the absolute differences between adjacent elements is minimized. Args: t (int): The number of test cases. test_cases (List): List containing number of elements and arrays for each test case. Returns: List[List[int]]: List of arrays reordered to minimize the absolute differences. Examples: >>> minimize_absolute_differences(3, [4, [4, 1, 2, 3], 3, [10, 50, 20], 5, [5, 1, 3, 4, 2]]) [[1, 2, 3, 4], [10, 20, 50], [1, 2, 3, 4, 5]] >>> minimize_absolute_differences(1, [5, [10, 5, 20, 15, 25]]) [[5, 10, 15, 20, 25]]","solution":"def minimize_absolute_differences(t, test_cases): results = [] for i in range(0, 2 * t, 2): n = test_cases[i] arr = sorted(test_cases[i + 1]) results.append(arr) return results"},{"question":"def is_path_possible(n: int, m: int, grid: List[str]) -> str: Determine whether there exists at least one path that allows Flora to reach her destination in the grid. >>> is_path_possible(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) == \\"YES\\" >>> is_path_possible(3, 3, [\\".#.\\", \\".#.\\", \\".#.\\"]) == \\"NO\\" >>> is_path_possible(2, 2, [\\".#\\", \\"#.\\"]) == \\"NO\\"","solution":"def is_path_possible(n, m, grid): from collections import deque if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == m - 1: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\""},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Finds two distinct indices in the array nums such that the numbers sum up to the target. Args: nums: List of integers. target: Integer target sum. Returns: A list of two integers representing the indices if such a pair exists, otherwise an empty list. Examples: >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 8) [] from solution import two_sum def test_two_sum_basic(): nums = [2, 7, 11, 15] target = 9 result = two_sum(nums, target) assert result in [[0, 1], [1, 0]] def test_two_sum_no_solution(): nums = [1, 2, 3, 4] target = 8 result = two_sum(nums, target) assert result == [] def test_two_sum_multiple_pairs(): nums = [1, 2, 3, 4, 5] target = 6 result = two_sum(nums, target) assert result in [[1, 3], [2, 4], [3, 1], [4, 2]] def test_two_sum_negative_numbers(): nums = [-3, 4, 3, 90] target = 0 result = two_sum(nums, target) assert result in [[0, 2], [2, 0]] def test_two_sum_large_numbers(): nums = [1000000, 2000000, -1000000, -2000000] target = 0 result = two_sum(nums, target) assert result in [[0, 2], [1, 3], [2, 0], [3, 1]]","solution":"def two_sum(nums, target): Finds two distinct indices in the array nums such that the numbers sum up to the target. Args: nums: List of integers. target: Integer target sum. Returns: A list of two integers representing the indices if such a pair exists, otherwise an empty list. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return [seen[complement], i] seen[num] = i return []"},{"question":"def three_sum_closest(nums, target): Returns the sum of three integers in nums such that the sum is closest to the target. nums: List[int] - List of integers. target: int - The target sum. >>> three_sum_closest([-1, 2, 1, -4], 1) 2 >>> three_sum_closest([1, 2, 3, 4], 6) 6 >>> three_sum_closest([-1, -2, -3, -4], -6) -6 >>> three_sum_closest([-10, -5, 2, 3, 4, 5], 1) 1 >>> three_sum_closest([0, 2, 1, -3], 1) 0 >>> three_sum_closest([1000, 2000, 3000, -4000], 1000) 1000 >>> three_sum_closest([1, 1, -1, -1, 3], 3) 3 >>> three_sum_closest([1, 2, 3, -1], 100) 6","solution":"def three_sum_closest(nums, target): Returns the sum of three integers in nums such that the sum is closest to the target. nums: List[int] - List of integers. target: int - The target sum. nums.sort() closest_sum = float('inf') n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"def mostFrequentChar(s: str) -> str: Returns the most frequent character in the string s. If there are multiple characters with the same frequency, the lexicographically smallest one is returned. >>> mostFrequentChar(\\"aabbbcc\\") 'b' >>> mostFrequentChar(\\"abacabad\\") 'a' from collections import Counter def test_mostFrequentChar(): # Test case 1 s = \\"aabbbcc\\" assert mostFrequentChar(s) == 'b' # Test case 2 s = \\"abacabad\\" assert mostFrequentChar(s) == 'a' # Test case 3 s = \\"abcabcabc\\" assert mostFrequentChar(s) == 'a' # Test case 4 s = \\"a\\" assert mostFrequentChar(s) == 'a' # Test case 5 s = \\"zxy\\" assert mostFrequentChar(s) == 'x' # Test case 6 s = \\"aaabbbccc\\" assert mostFrequentChar(s) == 'a' # Test case 7 s = \\"\\" assert mostFrequentChar(s) == '' # Edge Case: Empty String # Test case 8 s = \\"bbbaaa\\" assert mostFrequentChar(s) == 'a'","solution":"def mostFrequentChar(s): Returns the most frequent character in the string s. If there are multiple characters with the same frequency, the lexicographically smallest one is returned. from collections import Counter # Count the frequency of each character frequency = Counter(s) # Initialize variables to keep track of the most frequent character max_freq = -1 most_freq_char = '' # Iterate through the frequency dictionary to find the most frequent character for char in frequency: if frequency[char] > max_freq or (frequency[char] == max_freq and char < most_freq_char): max_freq = frequency[char] most_freq_char = char return most_freq_char"},{"question":"def check_palindrome(s: str) -> str: Determines if the given string is a palindrome, considering only alphanumeric characters and ignoring case. >>> check_palindrome(\\"A man, a plan, a canal: Panama\\") \\"YES\\" >>> check_palindrome(\\"race a car\\") \\"NO\\"","solution":"def is_palindrome(s): Determines if the given string is a palindrome, considering only alphanumeric characters and ignoring case. # Filter out non-alphanumeric characters and convert to lower case filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered list of characters is the same forwards and backwards return filtered_chars == filtered_chars[::-1] def check_palindrome(s): return \\"YES\\" if is_palindrome(s) else \\"NO\\""},{"question":"def max_water_distributed(n: int, events: List[str]) -> int: Determines the maximum amount of water distributed based on a series of events. Parameters: n (int): The number of days. events (list of str): A list of event descriptions, where each event is either a tank or a request. Returns: int: Maximum amount of water distributed to the community. pass # Unit tests def test_max_water_distributed(): # Test case 1 n = 5 events = [\\"tank 100\\", \\"request 50\\", \\"tank 200\\", \\"request 150\\", \\"request 100\\"] assert max_water_distributed(n, events) == 200 # Test case 2 n = 6 events = [\\"tank 200\\", \\"request 100\\", \\"request 50\\", \\"tank 150\\", \\"request 100\\", \\"request 100\\"] assert max_water_distributed(n, events) == 250 # Test case 3 n = 4 events = [\\"tank 50\\", \\"request 60\\", \\"tank 90\\", \\"request 70\\"] assert max_water_distributed(n, events) == 70 # Only 70 can be distributed from the second tank # Test case 4 n = 3 events = [\\"tank 100\\", \\"tank 50\\", \\"request 30\\"] assert max_water_distributed(n, events) == 30 # Request is fulfilled from the second tank # Test case 5 n = 2 events = [\\"tank 50\\", \\"request 60\\"] assert max_water_distributed(n, events) == 0 # Request cannot be fulfilled due to insufficient water","solution":"def max_water_distributed(n, events): Determines the maximum amount of water distributed based on a series of events. Parameters: n (int): The number of days. events (list of str): A list of event descriptions, where each event is either a tank or a request. Returns: int: Maximum amount of water distributed to the community. # Initialize variables current_tank_capacity = 0 current_tank_water = 0 total_distributed = 0 # Process each event for event in events: event_split = event.split() if event_split[0] == \\"tank\\": # New tank event new_tank_capacity = int(event_split[1]) current_tank_capacity = new_tank_capacity current_tank_water = new_tank_capacity elif event_split[0] == \\"request\\": # Water request event request_amount = int(event_split[1]) if current_tank_water >= request_amount: current_tank_water -= request_amount total_distributed += request_amount return total_distributed"},{"question":"from typing import List def max_non_adjacent_sum(arr: List[int]) -> int: Finds the maximum sum of elements in an array sub-sequence such that no two elements in the subsequence are adjacent in the original array. >>> max_non_adjacent_sum([3, 2, 7, 10]) 13 >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([-2, 1, 3, -4, 5]) 8 >>> max_non_adjacent_sum([-2, -3, -4, -5, -6]) 0 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([-1, -2, -3, -4, -5]) 0 >>> max_non_adjacent_sum([5, -10, 20, -15, 25]) 50 >>> max_non_adjacent_sum([10] * 100000) 500000","solution":"from typing import List def max_non_adjacent_sum(arr: List[int]) -> int: Finds the maximum sum of non-adjacent elements in an array. if not arr: return 0 inclusive = 0 # Max sum including the current element exclusive = 0 # Max sum excluding the current element for num in arr: # Current max sum excluding this element new_exclusive = max(inclusive, exclusive) # Current max sum including this element inclusive = exclusive + num exclusive = new_exclusive return max(inclusive, exclusive)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition_linked_list(head: ListNode, x: int) -> ListNode: Write a function that takes the head of a singly linked list and an integer \`x\`, and partitions the linked list such that all nodes less than \`x\` come before nodes greater than or equal to \`x\`. The relative order of the nodes in each of the two partitions should be preserved. For example, given the linked list 1 -> 4 -> 3 -> 2 -> 5 -> 2 and x = 3, the function should return 1 -> 2 -> 2 -> 4 -> 3 -> 5. >>> head = list_to_linkedlist([1, 4, 3, 2, 5, 2]) >>> x = 3 >>> new_head = partition_linked_list(head, x) >>> linkedlist_to_list(new_head) [1, 2, 2, 4, 3, 5] >>> head = list_to_linkedlist([2, 1]) >>> x = 2 >>> new_head = partition_linked_list(head, x) >>> linkedlist_to_list(new_head) [1, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def partition_linked_list(head: ListNode, x: int) -> ListNode: # Create two dummy heads for less and greater/equal partitions less_head, greater_head = ListNode(0), ListNode(0) less, greater = less_head, greater_head # Pointers to build the lists while head: if head.val < x: less.next = head less = less.next else: greater.next = head greater = greater.next head = head.next greater.next = None # End the list of greater values less.next = greater_head.next # Connect the less list to the greater list return less_head.next # Return the start of the concatenated list"},{"question":"def count_palindromes(set_chars: str, length: int) -> int: Eli is obsessed with palindromes, and he wants to find all possible palindromes of a given length using characters from a specific set. A palindrome is a string that reads the same forwards and backwards. Eli only wants palindromes that use characters from the given set and are of the specified length. >>> count_palindromes('abc', 1) 3 >>> count_palindromes('xyz', 2) 3 >>> count_palindromes('abc', 3) 9 >>> count_palindromes('abcd', 4) 16 >>> count_palindromes('a', 5) 1 >>> count_palindromes('pqrs', 6) 64","solution":"def count_palindromes(set_chars, length): Returns the count of palindromes of the given length using characters from the given set. m = len(set_chars) if length == 1: return m if length % 2 == 0: return m ** (length // 2) else: return m ** ((length // 2) + 1)"},{"question":"from collections import defaultdict from typing import List, Tuple def solve(n: int, values: List[int], edges: List[Tuple[int, int]], queries: List[int]) -> List[int]: You are given an undirected tree with N nodes and N-1 edges. Each node has a value associated with it, and node 1 is considered the root of the tree. You are required to answer Q queries on this tree. Each query is of the form: given a node v, find the maximum value of any node in the subtree rooted at v. Args: n (int): Number of nodes in the tree. values (List[int]): Values associated with each node. edges (List[Tuple[int, int]]): List containing the edges of the tree. queries (List[int]): List of queries to answer. Returns: List[int]: The maximum values for each query. Examples: >>> solve(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (3, 5)], [1, 2, 3]) [5, 4, 5] >>> solve(6, [10, 5, 20, 1, 2, 15], [(1, 2), (1, 3), (3, 4), (3, 5), (4, 6)], [3, 4]) [20, 15]","solution":"import sys from collections import defaultdict, deque def find_subtree_max_values(root, values, adjacency_list): n = len(values) max_values = [0] * n visited = [False] * n def dfs(node): visited[node] = True max_value = values[node] for neighbor in adjacency_list[node]: if not visited[neighbor]: max_value = max(max_value, dfs(neighbor)) max_values[node] = max_value return max_value dfs(root) return max_values def solve(n, values, edges, queries): adjacency_list = defaultdict(list) for u, v in edges: adjacency_list[u-1].append(v-1) adjacency_list[v-1].append(u-1) max_values = find_subtree_max_values(0, values, adjacency_list) results = [max_values[v-1] for v in queries] return results # Function to read from standard input def main(): input = sys.stdin.read data = input().split() idx = 0 N = int(data[idx]) idx += 1 values = list(map(int, data[idx:idx+N])) idx += N edges = [] for _ in range(N-1): u = int(data[idx]) v = int(data[idx+1]) edges.append((u, v)) idx += 2 Q = int(data[idx]) idx += 1 queries = [] for _ in range(Q): v = int(data[idx]) queries.append(v) idx += 1 results = solve(N, values, edges, queries) for res in results: print(res) # To run the solution function directly if required # if __name__ == \\"__main__\\": # main()"},{"question":"def findLongestWord(s: str, dictionary: List[str]) -> str: Find the longest string in the dictionary that can be formed by deleting some characters of the given string s without reordering the remaining characters. If there is more than one possible result, return the longest string with the smallest lexicographical order. If there is no possible result, return the empty string. Examples: >>> findLongestWord(\\"abpcplea\\", [\\"ale\\",\\"apple\\",\\"monkey\\",\\"plea\\"]) 'apple' >>> findLongestWord(\\"abpcplea\\", [\\"a\\",\\"b\\",\\"c\\"]) 'a' >>> findLongestWord(\\"bab\\", [\\"ba\\",\\"ab\\",\\"a\\",\\"b\\"]) 'ab' >>> findLongestWord(\\"hello\\", [\\"world\\",\\"hello\\",\\"leetcode\\"]) 'hello' >>> findLongestWord(\\"abce\\", [\\"abe\\",\\"abc\\"]) 'abc'","solution":"def findLongestWord(s, dictionary): def is_subsequence(x): it = iter(s) return all(c in it for c in x) dictionary.sort(key=lambda x: (-len(x), x)) for word in dictionary: if is_subsequence(word): return word return \\"\\""},{"question":"def determine_winner(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines the winner of the \\"Subsequence Sum\\" game for each test case. Both players play optimally. Alice always goes first. A subsequence sum is even if and only if it is divisible by 2. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple consists of an integer representing the number of elements in the array and a list of integers representing the array elements. Returns: List[str]: A list of strings where each string is the winner (\\"Alice\\" or \\"Bob\\") for each test case. Examples: >>> determine_winner([(3, [2, 4, 6]), (4, [1, 3, 5, 7])]) [\\"Alice\\", \\"Bob\\"] >>> determine_winner([(5, [2, 2, 2, 2, 2]), (3, [1, 1, 1]), (4, [2, 3, 4, 5])]) [\\"Alice\\", \\"Bob\\", \\"Alice\\"]","solution":"def determine_winner(test_cases): results = [] for case in test_cases: n, array = case even_count = sum(1 for x in array if x % 2 == 0) if even_count > 0: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results # Reading input and building test cases for execution def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 test_cases = [] for _ in range(T): N = int(data[idx]) idx += 1 array = list(map(int, data[idx:idx+N])) idx += N test_cases.append((N, array)) results = determine_winner(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_matrix_sum(n: int, m: int, matrix: List[List[int]]) -> int: Determine the minimum possible sum of the matrix after performing the given operations. Args: n : int : the number of rows in the matrix m : int : the number of columns in the matrix matrix : List[List[int]] : the matrix elements Returns: int : the minimum possible sum of the matrix after operations >>> min_matrix_sum(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> min_matrix_sum(1, 1, [[42]]) 42 >>> min_matrix_sum(2, 2, [[0, 0], [0, 0]]) 0 >>> min_matrix_sum(2, 3, [[3, 2, 8], [4, 6, 5]]) 28 >>> min_matrix_sum(4, 4, [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]) 40 pass","solution":"def min_matrix_sum(n, m, matrix): Determines the minimum possible sum of the matrix after performing the given operations. Args: n : int : the number of rows in the matrix m : int : the number of columns in the matrix matrix : list of list of ints : the matrix elements Returns: int : the minimum possible sum of the matrix after operations return sum(sum(row) for row in matrix)"},{"question":"from typing import List def can_rearrange_palindrome(s: str) -> bool: Checks if the string s can be rearranged to form a palindrome. >>> can_rearrange_palindrome(\\"carrace\\") True >>> can_rearrange_palindrome(\\"daily\\") False >>> can_rearrange_palindrome(\\"aab\\") True >>> can_rearrange_palindrome(\\"abc\\") False","solution":"from collections import Counter def can_rearrange_palindrome(s): Checks if the string s can be rearranged to form a palindrome. :param s: A string input :return: True if the string can be rearranged to form a palindrome, False otherwise char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"from typing import List def word_exists_in_matrix(matrix: List[List[str]], word: str) -> str: Given a 2D matrix of characters and a word, determine if the word exists in the matrix. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> word_exists_in_matrix([ [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ], \\"ABCCED\\") == \\"YES\\" >>> word_exists_in_matrix([ [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ], \\"SEE\\") == \\"YES\\" >>> word_exists_in_matrix([ [\\"A\\", \\"B\\", \\"C\\", \\"E\\"], [\\"S\\", \\"F\\", \\"C\\", \\"S\\"], [\\"A\\", \\"D\\", \\"E\\", \\"E\\"] ], \\"ABCB\\") == \\"NO\\"","solution":"def exist(board, word): def dfs(board, word, i, j, k): if not 0 <= i < len(board) or not 0 <= j < len(board[0]) or board[i][j] != word[k]: return False if k == len(word) - 1: return True tmp, board[i][j] = board[i][j], '/' found = dfs(board, word, i + 1, j, k + 1) or dfs(board, word, i - 1, j, k + 1) or dfs(board, word, i, j + 1, k + 1) or dfs(board, word, i, j - 1, k + 1) board[i][j] = tmp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return \\"YES\\" return \\"NO\\" def word_exists_in_matrix(matrix, word): return exist(matrix, word)"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Determines the length of the longest consecutive elements sequence. Arguments: nums -- a list of integers Returns: An integer representing the length of the longest consecutive elements sequence. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([0, 8, 7, 3, 4, 2, 1, 9, 5, 6]) 10 >>> longest_consecutive_sequence([10, 5, 15]) 1 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([5]) 1 >>> longest_consecutive_sequence([3, 4]) 2 >>> longest_consecutive_sequence([1, 2, 2, 3]) 3 >>> longest_consecutive_sequence(list(range(1, 100001))) 100000","solution":"def longest_consecutive_sequence(nums): if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak # Example usage if __name__ == \\"__main__\\": n = int(input()) nums = list(map(int, input().split())) print(longest_consecutive_sequence(nums))"},{"question":"def min_operations_to_equal_elements(n: int, arr: List[int]) -> int: Returns the minimum number of operations needed to make all elements of the array equal, or -1 if it is not possible. >>> min_operations_to_equal_elements(5, [5, 4, 3, 2, 1]) 4 >>> min_operations_to_equal_elements(4, [4, 8, 4, 8]) 2 >>> min_operations_to_equal_elements(3, [2, 2, 2]) 2 >>> min_operations_to_equal_elements(4, [1, 2, 3, 4]) -1","solution":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations needed to make all elements of the array equal, or -1 if it is not possible. # Check parities of the array elements parity = [a % 2 for a in arr] if all(p == parity[0] for p in parity): return n - 1 else: return -1"},{"question":"def expected_points(n, p): Calculate the expected total points Slavia can score. :param n: Number of free throws (integer) :param p: Probability of making a successful shot (float) :return: Expected total points (float) >>> expected_points(10, 0.6) 6.00 >>> expected_points(50, 0.75) 37.50 >>> expected_points(100, 0.0) 0.00 >>> expected_points(100, 1.0) 100.00 >>> expected_points(1, 0.01) 0.01 >>> expected_points(1, 0.99) 0.99 >>> expected_points(1000000, 0.5) 500000.00 >>> expected_points(3, 0.333) 1.00 >>> expected_points(3, 0.666) 2.00","solution":"def expected_points(n, p): Calculate the expected total points Slavia can score. :param n: Number of free throws (integer) :param p: Probability of making a successful shot (float) :return: Expected total points (float) return round(n * p, 2)"},{"question":"def first_names_in_alphabetical_order(names): Takes a list of names and returns the first name(s) in alphabetical order. If multiple names share the alphabetical starting position, return all such names in the order they appeared in the input list. :param names: List of names :return: The first name(s) in alphabetical order >>> first_names_in_alphabetical_order([\\"Tom\\"]) == [\\"Tom\\"] >>> first_names_in_alphabetical_order([\\"Tom\\", \\"Jerry\\", \\"Anna\\", \\"Bob\\"]) == [\\"Anna\\"] >>> first_names_in_alphabetical_order([\\"Tom\\", \\"Anna\\", \\"Anna\\", \\"Jerry\\"]) == [\\"Anna\\", \\"Anna\\"] >>> first_names_in_alphabetical_order([]) == [] >>> first_names_in_alphabetical_order([\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"alice\\"]) == [\\"Alice\\", \\"Alice\\"] >>> first_names_in_alphabetical_order([\\"Bob\\", \\"Charlie\\", \\"Alice\\", \\"Eve\\"]) == [\\"Alice\\"]","solution":"def first_names_in_alphabetical_order(names): Takes a list of names and returns the first name(s) in alphabetical order. If multiple names share the alphabetical starting position, return all such names in the order they appeared in the input list. :param names: List of names :return: The first name(s) in alphabetical order if not names: return [] sorted_names = sorted(names) first_name = sorted_names[0] result = [name for name in names if name == first_name] return result"},{"question":"def plant_growth_steps(grid): Simulates plant growth in a 2D grid and returns the number of complete time steps required for the plant to finish its growth. Args: grid (list of list of str): A 2D list representing the initial grid. Each element is either '.' or 'P'. Returns: int: The number of complete time steps required for the plant to finish its growth. >>> plant_growth_steps([ ... \\".P.\\", ... \\"...\\", ... \\"P..\\" ... ]) 2 >>> plant_growth_steps([ ... \\"PPP\\", ... \\"PPP\\", ... \\"PPP\\" ... ]) 0 >>> plant_growth_steps([ ... \\".\\" ... ]) 0 >>> plant_growth_steps([ ... \\"P.P.\\", ... \\"..P.\\", ... \\".P..\\", ... \\"..P.\\" ... ]) 2 >>> plant_growth_steps([ ... \\"...\\", ... \\"...\\", ... \\"...\\" ... ]) 0","solution":"def plant_growth_steps(grid): Simulates plant growth in a 2D grid and returns the number of complete time steps required for the plant to finish its growth. Args: grid (list of list of str): A 2D list representing the initial grid. Each element is either '.' or 'P'. Returns: int: The number of complete time steps required for the plant to finish its growth. from collections import deque N = len(grid) M = len(grid[0]) # Convert grid to a list of lists grid = [list(row) for row in grid] # Directions for adjacent cells: down, up, right, left directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Initialize queue with all initial 'P' positions queue = deque() for i in range(N): for j in range(M): if grid[i][j] == 'P': queue.append((i, j)) steps = 0 while queue: next_queue = deque() while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.': grid[nx][ny] = 'P' next_queue.append((nx, ny)) if next_queue: steps += 1 queue = next_queue return steps"},{"question":"from typing import List, Tuple def find_optimal_location(labs: List[Tuple[int, int]]) -> Tuple[float, float]: Given a list of laboratories' coordinates, find the optimal location for the central server. Parameters: labs (List[Tuple[int, int]]): List of tuples representing the coordinates of the laboratories Returns: Tuple[float, float]: Coordinates of the optimal location >>> round(find_optimal_location([(0, 0), (2, 0), (1, 1)])[0], 6) == 1.0 >>> round(find_optimal_location([(0, 0), (2, 0), (1, 1)])[1], 6) == 0.333333 >>> round(find_optimal_location([(1, 1), (2, 2), (3, 1), (4, 2)])[0], 6) == 2.5 >>> round(find_optimal_location([(1, 1), (2, 2), (3, 1), (4, 2)])[1], 6) == 1.5","solution":"def find_optimal_location(labs): Given a list of laboratories' coordinates, find the optimal location for the central server. Parameters: labs (List[Tuple[int, int]]): List of tuples representing the coordinates of the laboratories Returns: Tuple[float, float]: Coordinates of the optimal location n = len(labs) # Calculate the centroid (arithmetic mean) sum_x = sum(lab[0] for lab in labs) sum_y = sum(lab[1] for lab in labs) centroid_x = sum_x / n centroid_y = sum_y / n return centroid_x, centroid_y"},{"question":"def formatName(fullName: str) -> str: Takes a full name and returns a formatted string with the last name, a comma, the first name, and the initial of each middle name. >>> formatName('John Jacob Jingleheimer Schmidt') == 'Schmidt, John J J' >>> formatName('Mary Elizabeth Morrison') == 'Morrison, Mary E' >>> formatName('Alex Turner') == 'Turner, Alex' >>> formatName(' Clara Anne Bell ') == 'Bell, Clara A' >>> formatName('robert downey junior') == 'junior, robert d'","solution":"def formatName(fullName): Takes a full name and returns a formatted string with the last name, a comma, the first name, and the initial of each middle name. Parameters: fullName (str): The input string containing the full name. Returns: str: The formatted name. # Split the input name into parts name_parts = fullName.split() # Extract the first name, last name, and middle names first_name = name_parts[0] last_name = name_parts[-1] middle_names = name_parts[1:-1] # Prepare the middle initials middle_initials = ' '.join([name[0] for name in middle_names]) # Combine the format LastName, FirstName M M if middle_initials: return f\\"{last_name}, {first_name} {middle_initials}\\" else: return f\\"{last_name}, {first_name}\\""},{"question":"def min_flip_flop_operations(binary_strings): Determine the minimum number of flip-flop operations required to transform each binary string into a string where all '1's are on the left side and all '0's are on the right side. >>> min_flip_flop_operations([\\"110\\", \\"11001\\", \\"10010\\"]) [1, 1, 2] >>> min_flip_flop_operations([\\"0\\"]) [0] >>> min_flip_flop_operations([\\"1\\"]) [0] >>> min_flip_flop_operations([\\"01\\"]) [0] >>> min_flip_flop_operations([\\"10\\"]) [1] >>> min_flip_flop_operations([\\"101\\"]) [1] >>> min_flip_flop_operations([\\"110\\"]) [1] >>> min_flip_flop_operations([\\"1001\\"]) [1] >>> min_flip_flop_operations([\\"111\\", \\"000\\", \\"101010\\", \\"1100\\"]) [0, 0, 3, 1] >>> min_flip_flop_operations([\\"\\", \\"1\\", \\"0\\", \\"111\\", \\"000\\", \\"10101\\"]) [0, 0, 0, 0, 0, 2] >>> min_flip_flop_operations([\\"1\\" * 100000, \\"0\\" * 100000, \\"1\\" * 50000 + \\"0\\" * 50000]) [0, 0, 1]","solution":"def min_flip_flop_operations(binary_strings): results = [] for s in binary_strings: operations = 0 # Check for the first occurrence of '10' i = 0 while i < len(s) - 1: if s[i] == '1' and s[i + 1] == '0': operations += 1 # Continue finding the next such pair while i < len(s) - 1 and s[i] == '1' and s[i + 1] == '0': i += 1 i += 1 results.append(operations) return results"},{"question":"def max_sum_k_consecutive(nums, k): Returns the maximum possible sum of k consecutive elements in the given list. If k is greater than the length of the list, returns -1. >>> max_sum_k_consecutive([2, 1, 5, 1, 3, 2], 3) 9 >>> max_sum_k_consecutive([2, 3, 4], 4) -1","solution":"def max_sum_k_consecutive(nums, k): Returns the maximum possible sum of k consecutive elements in the given list. If k is greater than the length of the list, returns -1. n = len(nums) if k > n: return -1 max_sum = current_sum = sum(nums[:k]) for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def max_beauty_subarray(n: int, arr: List[int]) -> int: Returns the beauty of the most beautiful subarray in the given list of distinct positive integers. Parameters: n (int): The number of elements in the array. arr (List[int]): The list of distinct positive integers. Returns: int: The beauty of the most beautiful subarray. >>> max_beauty_subarray(5, [1, 3, 9, 2, 7]) 8 >>> max_beauty_subarray(1, [10]) 0 >>> max_beauty_subarray(2, [5, 10]) 5 >>> max_beauty_subarray(5, [1, 2, 3, 4, 5]) 4 >>> max_beauty_subarray(5, [5, 4, 3, 2, 1]) 4 >>> max_beauty_subarray(3, [1000000000, 500000000, 1]) 999999999","solution":"def max_beauty_subarray(n, arr): Returns the beauty of the most beautiful subarray in the given list. Parameters: n (int): The number of elements in the array. arr (list of int): The list of distinct positive integers. Returns: int: The beauty of the most beautiful subarray. if n == 1: return 0 max_elem = max(arr) min_elem = min(arr) return max_elem - min_elem"},{"question":"def first_unique(nums: list) -> int: Returns the first unique number in the list. If no unique number exists, return -1. :param nums: List of integers :return: The first unique number or -1 if none exists >>> first_unique([2, 3, 5, 3, 2, 4, 5]) 4 >>> first_unique([7, 7, 8, 8, 9, 9]) -1 >>> first_unique([1, 3, 3, 4, 5, 6, 5, 4]) 1 >>> first_unique([1]) 1 >>> first_unique([2, 2, 2, 2]) -1 >>> first_unique([-1, -2, -2, -3, -1, -5, -3]) -5 >>> first_unique([0, 1, 2, 1, 0, 3, 4, 3, 2]) 4 >>> first_unique([i for i in range(100000)] + [99999]) 0 >>> first_unique([10**6, 10**6, -10**6]) -10**6 pass","solution":"def first_unique(nums: list) -> int: Returns the first unique number in the list. If no unique number exists, return -1. :param nums: List of integers :return: The first unique number or -1 if none exists from collections import Counter # Count the occurrences of each number count = Counter(nums) # Traverse the list and find the first unique number for num in nums: if count[num] == 1: return num # If no unique number is found, return -1 return -1"},{"question":"def find_connected_components(N, roads): from collections import defaultdict, deque def bfs(start, visited, graph): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for A, B in roads: graph[A].append(B) graph[B].append(A) visited = [False] * (N + 1) connected_components = 0 for province in range(1, N+1): if not visited[province]: bfs(province, visited, graph) connected_components += 1 return connected_components def minimum_new_roads_to_connect_provinces(test_cases): Given a list of test cases, returns the minimum number of new roads required to connect all provinces for each test case. >>> minimum_new_roads_to_connect_provinces([(5, 3, [(1, 2), (2, 3), (4, 5)])]) [1] >>> minimum_new_roads_to_connect_provinces([(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) [0] >>> minimum_new_roads_to_connect_provinces([(4, 0, [])]) [3] results = [] for N, M, roads in test_cases: num_cc = find_connected_components(N, roads) results.append(num_cc - 1) return results # Example test cases def test_basic_cases(): cases = [ ((5, 3, [(1, 2), (2, 3), (4, 5)]), 1), ((4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), 0), ((4, 0, []), 3), ] for (test_case, expected) in cases: assert minimum_new_roads_to_connect_provinces([test_case]) == [expected] def test_edge_cases(): cases = [ ((1, 0, []), 0), ((2, 0, []), 1), ((6, 3, [(1, 2), (1, 3), (4, 5)]), 2), ] for (test_case, expected) in cases: assert minimum_new_roads_to_connect_provinces([test_case]) == [expected]","solution":"def find_connected_components(N, roads): from collections import defaultdict, deque def bfs(start, visited, graph): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for A, B in roads: graph[A].append(B) graph[B].append(A) visited = [False] * (N + 1) connected_components = 0 for province in range(1, N+1): if not visited[province]: bfs(province, visited, graph) connected_components += 1 return connected_components def minimum_new_roads_to_connect_provinces(test_cases): results = [] for N, M, roads in test_cases: num_cc = find_connected_components(N, roads) results.append(num_cc - 1) return results # Example input parsing and function call def main(): import sys input = sys.stdin.read data = input().splitlines() test_cases = [] index = 0 while index < len(data): N, M = map(int, data[index].split()) if N == 0 and M == 0: break roads = [] for _ in range(M): index += 1 A, B = map(int, data[index].split()) roads.append((A, B)) test_cases.append((N, M, roads)) index += 1 results = minimum_new_roads_to_connect_provinces(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def find_permutation(n): Given an integer n, find any permutation of the first n natural numbers (1 through n) such that the permutation does not contain any decreasing subsequence of length exactly 3. Parameters: n (int): The length of the permutation. Returns: List[int]: A permutation of the first n natural numbers or [-1] if no such permutation exists. Examples: >>> find_permutation(1) [1] >>> find_permutation(3) [1, 3, 2] >>> find_permutation(4) [1, 3, 2, 4] >>> find_permutation(8) [1, 3, 5, 7, 2, 4, 6, 8]","solution":"def find_permutation(n): Finds a permutation of the first n natural numbers that does not contain any decreasing subsequence of length exactly 3. if n <= 2: return list(range(1, n + 1)) # Divide the first n numbers into two parts: odd and even index odds = [i for i in range(1, n + 1, 2)] evens = [i for i in range(2, n + 1, 2)] return odds + evens"},{"question":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.group_size = [1] * size self.max_group_size = 1 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX self.group_size[rootX] += self.group_size[rootY] self.group_size[rootY] = 0 self.max_group_size = max(self.max_group_size, self.group_size[rootX]) elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY self.group_size[rootY] += self.group_size[rootX] self.group_size[rootX] = 0 self.max_group_size = max(self.max_group_size, self.group_size[rootY]) else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.group_size[rootX] += self.group_size[rootY] self.group_size[rootY] = 0 self.max_group_size = max(self.max_group_size, self.group_size[rootX]) def size_of_largest_group(self): return self.max_group_size def social_network_simulation(n: int, queries: List[Tuple[str, int, int]]) -> List[int]: Simulates the activity of an evolving social network and determines the largest group of friends. Args: - n: number of users in the network. - queries: List of tuples representing different operations. Returns: - List of sizes of the largest group after each 'largest_group' operation. >>> social_network_simulation(6, [('add', 1, 2), ('add', 2, 3), ('largest_group',), ('add', 4, 5), ('largest_group',), ('remove', 2, 3), ('largest_group',)]) [3, 3, 2] >>> social_network_simulation(5, [('largest_group',), ('largest_group',)]) [1, 1] >>> social_network_simulation(4, [('add', 1, 2), ('add', 2, 3), ('add', 3, 4), ('largest_group',)]) [4] >>> social_network_simulation(4, [('add', 1, 2), ('add', 2, 3), ('add', 3, 4), ('remove', 2, 3), ('largest_group',)]) [2] >>> social_network_simulation(6, [('add', 1, 2), ('add', 3, 4), ('add', 5, 6), ('largest_group',), ('add', 1, 3), ('largest_group',), ('add', 2, 4), ('largest_group',)]) [2, 4, 4] pass","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size self.group_size = [1] * size self.max_group_size = 1 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX self.group_size[rootX] += self.group_size[rootY] self.group_size[rootY] = 0 self.max_group_size = max(self.max_group_size, self.group_size[rootX]) elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY self.group_size[rootY] += self.group_size[rootX] self.group_size[rootX] = 0 self.max_group_size = max(self.max_group_size, self.group_size[rootY]) else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.group_size[rootX] += self.group_size[rootY] self.group_size[rootY] = 0 self.max_group_size = max(self.max_group_size, self.group_size[rootX]) def size_of_largest_group(self): return self.max_group_size def social_network_simulation(n, queries): uf = UnionFind(n + 1) results = [] friendships = set() for query in queries: op = query[0] if op == 'add': x, y = query[1], query[2] if (x, y) not in friendships and (y, x) not in friendships: friendships.add((x, y)) uf.union(x, y) elif op == 'remove': x, y = query[1], query[2] if (x, y) in friendships: friendships.remove((x, y)) # Assumes we rebuild the UnionFind object for simplicity new_uf = UnionFind(n + 1) for (a, b) in friendships: new_uf.union(a, b) uf = new_uf elif op == 'largest_group': results.append(uf.size_of_largest_group()) return results"},{"question":"def is_subpath(path1: str, path2: str) -> bool: Determines if path2 is a subpath of path1. Args: path1 (str): The first path (parent directory). path2 (str): The second path (potential subpath). Returns: bool: True if path2 is a subpath of path1, False otherwise. >>> is_subpath(\\"/home/user/docs\\", \\"/home/user/docs/reports\\") True >>> is_subpath(\\"/home/user/docs\\", \\"/home/user/music\\") False >>> is_subpath(\\"/var/log\\", \\"/var/log/nginx/access.log\\") True","solution":"def is_subpath(path1, path2): Determines if path2 is a subpath of path1. Args: path1 (str): The first path (parent directory). path2 (str): The second path (potential subpath). Returns: bool: True if path2 is a subpath of path1, False otherwise. if not path1.endswith('/'): path1 += '/' return path2.startswith(path1)"},{"question":"def calculate_balance(transactions): Takes a list of transactions made with a digital wallet and calculates the final balance in the wallet. Returns the balance in the format 'Balance: x.xx' or 'Insufficient funds' if the balance is negative. >>> calculate_balance([('credit', 100), ('debit', 50), ('debit', 20), ('credit', 70)]) 'Balance: 100.00' >>> calculate_balance([('credit', 100), ('debit', 150)]) 'Insufficient funds' >>> calculate_balance([('credit', 50), ('debit', 50)]) 'Balance: 0.00' >>> calculate_balance([('credit', 50), ('credit', 100)]) 'Balance: 150.00' >>> calculate_balance([('debit', 25), ('debit', 25)]) 'Insufficient funds' >>> calculate_balance([('credit', 200), ('debit', 50), ('credit', 25), ('debit', 100)]) 'Balance: 75.00'","solution":"def calculate_balance(transactions): Takes a list of transactions and calculates the final balance in the wallet. Returns the balance in the format 'Balance: x.xx' or 'Insufficient funds' if the balance is negative. balance = 0 for transaction in transactions: if transaction[0] == 'credit': balance += transaction[1] elif transaction[0] == 'debit': balance -= transaction[1] if balance < 0: return \\"Insufficient funds\\" else: return f\\"Balance: {balance:.2f}\\""},{"question":"def process_operations(n: int, q: int, initial_values: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Handle updates and range sum queries on an array of integers. Parameters: n (int): Number of integers in the array. q (int): Number of operations. initial_values (List[int]): Initial values of the array. operations (List[Tuple[int, int, int]]): List of operations to perform (type, index/value, value/index). Returns: List[int]: Result of each range sum query operation. Example: >>> process_operations(5, 5, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 2, 10), (2, 2, 4), (1, 3, 6), (2, 1, 5)]) [6, 17, 26] >>> process_operations(4, 4, [5, 6, 7, 8], [(1, 1, 10), (1, 3, 20), (2, 1, 2), (2, 3, 4)]) [16, 28] class ArrayManager: def __init__(self, n, initial_values): self.n = n self.array = initial_values def update(self, x, v): self.array[x - 1] = v def range_sum(self, l, r): return sum(self.array[l-1:r]) array_manager = ArrayManager(n, initial_values) results = [] for operation in operations: if operation[0] == 1: array_manager.update(operation[1], operation[2]) elif operation[0] == 2: result = array_manager.range_sum(operation[1], operation[2]) results.append(result) return results","solution":"class ArrayManager: def __init__(self, n, initial_values): self.n = n self.array = initial_values def update(self, x, v): self.array[x - 1] = v def range_sum(self, l, r): return sum(self.array[l-1:r]) def process_operations(n, q, initial_values, operations): array_manager = ArrayManager(n, initial_values) results = [] for operation in operations: if operation[0] == 1: array_manager.update(operation[1], operation[2]) elif operation[0] == 2: result = array_manager.range_sum(operation[1], operation[2]) results.append(result) return results"},{"question":"def count_binary_strings(n: int) -> int: Returns the number of unique binary strings of length n such that there are no two consecutive '1's. >>> count_binary_strings(1) 2 >>> count_binary_strings(2) 3 >>> count_binary_strings(3) 5 >>> count_binary_strings(4) 8 >>> count_binary_strings(10) 144 >>> count_binary_strings(20) 17711 >>> count_binary_strings(30) 2178309 >>> count_binary_strings(50) 32951280099","solution":"def count_binary_strings(n): Returns the number of unique binary strings of length n such that there are no two consecutive '1's. if n == 1: return 2 # \\"0\\", \\"1\\" if n == 2: return 3 # \\"00\\", \\"01\\", \\"10\\" dp = [0] * (n + 1) dp[1] = 2 # \\"0\\", \\"1\\" dp[2] = 3 # \\"00\\", \\"01\\", \\"10\\" for i in range(3, n + 1): dp[i] = dp[i-1] + dp[i-2] return dp[n]"},{"question":"def max_magical_power(n: int, m: int, fruit_pairs: List[Tuple[int, int, int]]) -> int: Determine the maximum total magical power that can be harvested by optimally pairing the fruits. >>> max_magical_power(3, 3, [(0, 0, 10), (0, 1, 15), (1, 0, 20), (1, 2, 25)]) 40 >>> max_magical_power(4, 4, [(0, 0, 10), (0, 1, 5), (1, 1, 15), (2, 2, 20), (3, 3, 25)]) 70 >>> max_magical_power(2, 2, [(0, 0, 10), (1, 1, 20)]) 30 >>> max_magical_power(1, 1, [(0, 0, 10000)]) 10000 >>> max_magical_power(3, 3, [(0, 0, 3), (1, 1, 2), (2, 2, 1)]) 6","solution":"def max_magical_power(n, m, fruit_pairs): from collections import defaultdict import heapq graph = defaultdict(list) for ai, bi, pi in fruit_pairs: graph[ai].append((bi, pi)) sun_heap = [] for i in range(n): if graph[i]: graph[i].sort(key=lambda x: -x[1]) sun_heap.append((graph[i][0][1], i, 0)) heapq.heapify(sun_heap) moon_used = [False] * m total_power = 0 while sun_heap: power, sun_fruit, index = heapq.heappop(sun_heap) moon_fruit, associated_power = graph[sun_fruit][index] if moon_used[moon_fruit]: if index + 1 < len(graph[sun_fruit]): heapq.heappush(sun_heap, (graph[sun_fruit][index+1][1], sun_fruit, index+1)) continue total_power += power moon_used[moon_fruit] = True return total_power # Parsing input (method would be necessary for actual usage but not required in this specific structure) def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) k = int(data[2]) fruit_pairs = [] index = 3 while k > 0: a_i = int(data[index]) b_i = int(data[index + 1]) p_i = int(data[index + 2]) fruit_pairs.append((a_i, b_i, p_i)) index += 3 k -= 1 print(max_magical_power(n, m, fruit_pairs))"},{"question":"def three_sum_zero(arr): Returns all unique triplets in the array that sum to zero. Each triplet is sorted in ascending order, and the list of triplets is lexicographically sorted. >>> three_sum_zero([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum_zero([0, 0, 0]) [[0, 0, 0]] >>> three_sum_zero([1, 2, 3, 4]) [] from solution import three_sum_zero def test_three_sum_zero_example1(): assert three_sum_zero([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] def test_three_sum_zero_example2(): assert three_sum_zero([0, 0, 0]) == [[0, 0, 0]] def test_three_sum_zero_example3(): assert three_sum_zero([1, 2, 3, 4]) == [] def test_three_sum_zero_no_triplet(): assert three_sum_zero([1, -2, 3, 5, 6]) == [] def test_three_sum_zero_mixed_elements(): assert three_sum_zero([-2, 0, 1, 1, 2]) == [[-2, 0, 2], [-2, 1, 1]] def test_three_sum_zero_large_input(): # Verify for large input input_arr = [i for i in range(-10**5, 10**5, 1000)] result = three_sum_zero(input_arr) # For the purpose of this simple test we are not checking the exact list # as it might be huge, but verifying the structure. if result: assert all(len(triplet) == 3 for triplet in result) assert all(sum(triplet) == 0 for triplet in result) assert all(triplet == sorted(triplet) for triplet in result)","solution":"def three_sum_zero(arr): Returns all unique triplets in the array that sum to zero. Each triplet is sorted in ascending order, and the list of triplets is lexicographically sorted. arr.sort() # Sort the array to handle duplicates and use two pointers technique triplets = [] n = len(arr) for i in range(n): # Avoid duplicates for the first element of the triplet if i > 0 and arr[i] == arr[i - 1]: continue target = -arr[i] left, right = i + 1, n - 1 while left < right: sum_lr = arr[left] + arr[right] if sum_lr == target: triplets.append([arr[i], arr[left], arr[right]]) left += 1 right -= 1 # Skip duplicates for the second and third elements while left < right and arr[left] == arr[left - 1]: left += 1 while left < right and arr[right] == arr[right + 1]: right -= 1 elif sum_lr < target: left += 1 else: right -= 1 return triplets"},{"question":"def find_missing_bajtek_element(n: int, sequence: List[int]) -> int: Finds the missing element in the Bajtek sequence. Parameters: n (int): The length of the sequence after removing one element. sequence (list): The remaining elements of the Bajtek sequence. Returns: int: The missing element. >>> find_missing_bajtek_element(9, [1, 1, 2, 3, 5, 8, 13, 21, 34]) 55 >>> find_missing_bajtek_element(5, [5, 8, 13, 21, 34]) 55 >>> find_missing_bajtek_element(5, [1, 2, 3, 5, 8]) 13 >>> find_missing_bajtek_element(8, [1, 1, 2, 3, 5, 8, 13, 21]) 34 >>> find_missing_bajtek_element(3, [1, 2, 3]) 5 >>> find_missing_bajtek_element(19, [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]) 6765","solution":"def find_missing_bajtek_element(n, sequence): Finds the missing element in the Bajtek sequence. Parameters: n (int): The length of the sequence after removing one element. sequence (list): The remaining elements of the Bajtek sequence. Returns: int: The missing element. # Iterate over the sequence to find the missing number for i in range(2, n): if sequence[i] != sequence[i-1] + sequence[i-2]: # When we find a discrepancy, we return the correction needed. # A discrepancy is found at position i, the missing element is # \\"sequence[i-1] + sequence[i-2]\\" for position (i+1) which was removed. return sequence[i-1] + sequence[i-2] # If the sequence is valid, then the missing element is at the end return sequence[-1] + sequence[-2] # Sample Input: # 9 # 1 1 2 3 5 8 13 21 34 # Output: # 55"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money you can steal without triggering an alarm. Parameters: nums (List[int]): The list of amounts of money in each house. Returns: int: The maximum amount of money that can be stolen. >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([10, 15, 20]) 30 >>> rob([5]) 5 >>> rob([10, 2]) 10 >>> rob([1, 1, 1, 1, 1]) 3 >>> rob([1, 15, 1, 15, 1]) 30 >>> rob([i for i in range(1, 101)]) 2550","solution":"def rob(nums): Returns the maximum amount of money you can steal without triggering an alarm. Parameters: nums (List[int]): The list of amounts of money in each house. Returns: int: The maximum amount of money that can be stolen. if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]) return dp[-1]"},{"question":"from typing import List def generate_pascals_triangle(n: int) -> List[List[int]]: Generate the first n rows of Pascal's triangle. :param n: number of rows in Pascal's triangle :return: 2D list representing first n rows of Pascal's triangle pass def handle_test_cases(t: int, cases: List[int]) -> None: Handle the test cases and generate Pascal's triangle for each case. :param t: Number of test cases :param cases: List of integers representing the number of rows for each test case :return: None pass # Unit Test def test_generate_pascals_triangle(): assert generate_pascals_triangle(1) == [[1]] assert generate_pascals_triangle(3) == [ [1], [1, 1], [1, 2, 1] ] assert generate_pascals_triangle(5) == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] def test_handle_test_cases(capsys): handle_test_cases(2, [5, 3]) captured = capsys.readouterr() expected_output = \\"1n1 1n1 2 1n1 3 3 1n1 4 6 4 1nn1n1 1n1 2 1n\\" assert captured.out.strip() == expected_output.strip()","solution":"def generate_pascals_triangle(n): Generate the first n rows of Pascal's triangle. :param n: number of rows in Pascal's triangle :return: 2D list representing first n rows of Pascal's triangle triangle = [] for i in range(n): row = [1] * (i + 1) for j in range(1, i): row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j] triangle.append(row) return triangle def handle_test_cases(t, cases): Handle the test cases and generate Pascal's triangle for each case. :param t: Number of test cases :param cases: List of integers representing the number of rows for each test case :return: None results = [] for n in cases: triangle = generate_pascals_triangle(n) formatted_output = 'n'.join(' '.join(map(str, row)) for row in triangle) results.append(formatted_output) print('nn'.join(results))"},{"question":"def subarray_sum_exists(n: int, array: List[int], target_sum: int) -> str: Checks if there's a non-empty subarray in 'array' that sums to 'target_sum'. :param n: int - Number of elements in the array :param array: list of int - The elements of the array :param target_sum: int - The desired target sum :return: str - \\"Yes\\" if such a subarray exists, otherwise \\"No\\" >>> subarray_sum_exists(5, [1, 2, 3, 4, 5], 9) 'Yes' >>> subarray_sum_exists(3, [1, -1, 2], 1) 'Yes' >>> subarray_sum_exists(4, [1, 2, 3, 4], 15) 'No' >>> subarray_sum_exists(1, [-5], -5) 'Yes' >>> subarray_sum_exists(1, [3], 5) 'No' >>> subarray_sum_exists(4, [-1, -2, -3, -4], -5) 'Yes' >>> subarray_sum_exists(4, [-1, -2, -3, -4], -10) 'Yes' >>> subarray_sum_exists(4, [-1, -2, -3, -4], -12) 'No' >>> subarray_sum_exists(6, [3, 4, -7, 1, 3, 3], 7) 'Yes' >>> subarray_sum_exists(6, [3, 4, -7, 1, 3, 3], 1) 'Yes' >>> subarray_sum_exists(6, [3, 4, -7, 1, 3, 3], 0) 'Yes' >>> subarray_sum_exists(5, [100, 200, -300, 400, -500], 400) 'Yes' >>> subarray_sum_exists(5, [100, 200, -300, 400, -500], 1500) 'No'","solution":"def subarray_sum_exists(n, array, target_sum): Checks if there's a non-empty subarray in 'array' that sums to 'target_sum'. :param n: int - Number of elements in the array :param array: list of int - The elements of the array :param target_sum: int - The desired target sum :return: str - \\"Yes\\" if such a subarray exists, otherwise \\"No\\" for start in range(n): current_sum = 0 for end in range(start, n): current_sum += array[end] if current_sum == target_sum: return \\"Yes\\" return \\"No\\" # Example usage; Uncomment to test manually # n = 5 # array = [1, 2, 3, 4, 5] # target_sum = 9 # print(subarray_sum_exists(n, array, target_sum)) # Output: Yes"},{"question":"def find_pair_with_sum(N, X, arr): Returns the indices of two integers in the array that sum up to X in non-decreasing order. If no such pair exists, returns [-1, -1]. >>> find_pair_with_sum(4, 7, [1, 2, 3, 4]) [2, 3] >>> find_pair_with_sum(5, 10, [4, 3, 5, 7, 1]) [1, 3] >>> find_pair_with_sum(3, 15, [5, 5, 5]) [-1, -1] >>> find_pair_with_sum(4, 9, [2, 7, 11, 15]) [0, 1] >>> find_pair_with_sum(5, 8, [1, 2, 3, 4, 5]) [2, 4] def process_input(input_str): Processes input from a string format and returns the result by invoking find_pair_with_sum. >>> process_input(\\"4 7n1 2 3 4\\") [2, 3] >>> process_input(\\"5 10n4 3 5 7 1\\") [1, 3] >>> process_input(\\"3 15n5 5 5\\") [-1, -1] >>> process_input(\\"4 9n2 7 11 15\\") [0, 1] >>> process_input(\\"5 8n1 2 3 4 5\\") [2, 4]","solution":"def find_pair_with_sum(N, X, arr): Returns the indices of two integers in the array that sum up to X in non-decreasing order. If no such pair exists, returns [-1, -1]. value_to_index = {} for i, number in enumerate(arr): complement = X - number if complement in value_to_index: return sorted([value_to_index[complement], i]) value_to_index[number] = i return [-1, -1] def process_input(input_str): Processes input from a string format and returns the result by invoking find_pair_with_sum. input_lines = input_str.strip().split(\\"n\\") N, X = map(int, input_lines[0].split()) arr = list(map(int, input_lines[1].split())) return find_pair_with_sum(N, X, arr)"},{"question":"def sum_of_longest_increasing_subarrays(T, test_cases): Calculate the sum of the lengths of the longest increasing subarrays ending at each element for given test cases. Args: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains an integer N and a list of N integers. Returns: List[int]: List of sums for each test case. >>> sum_of_longest_increasing_subarrays(2, [(5, [1, 2, 2, 3, 4]), (3, [3, 2, 1])]) [9, 3] >>> sum_of_longest_increasing_subarrays(1, [(4, [2, 2, 2, 2])]) [4]","solution":"def sum_of_longest_increasing_subarrays(T, test_cases): results = [] for case in test_cases: N, arr = case lis_lengths = [1] * N total_sum = 1 for i in range(1, N): if arr[i] > arr[i-1]: lis_lengths[i] = lis_lengths[i-1] + 1 total_sum += lis_lengths[i] results.append(total_sum) return results # Function to parse inputs and provide expected outputs def process_input(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N = int(data[index]) arr = list(map(int, data[index+1:index+1+N])) test_cases.append((N, arr)) index += 1 + N return T, test_cases"},{"question":"def find_num_ways(n: int, grid: List[str]) -> int: Calculate the number of ways to build a road from the top-left corner to the bottom-right corner of an n x n grid. Roads can only be built on empty cells ('.'), and you can only move right or down. Args: n (int): The size of the grid. grid (List[str]): The grid represented as a list of strings, where each character is either '.' (denoting an empty cell) or '#' (denoting a building). Returns: int: The number of ways to build the road. If no way exists, return 0. Example: >>> find_num_ways(3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> find_num_ways(3, [\\".\\", \\".\\", \\"...\\"]) 0 pass","solution":"def find_num_ways(n, grid): if grid[0][0] == '#' or grid[n-1][n-1] == '#': return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(n): if i == 0 and j == 0: continue if grid[i][j] == '.': if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1] # Example usage if __name__ == \\"__main__\\": n = 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] print(find_num_ways(n, grid)) # Output: 2"},{"question":"def find_path(n, m, difficulties, tunnels): Given the number of dungeons, their difficulties, and the tunnels connecting them, determine if it's possible for the hero to visit all dungeons exactly once starting from the one with the lowest difficulty and ending at the one with the highest difficulty. If possible, find such a path. >>> find_path(4, 4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4), (4, 1)]) [1, 2, 3, 4] >>> find_path(3, 2, [5, 1, 3], [(1, 2), (2, 3)]) \\"Impossible\\" # Example test cases def test_find_path(): assert find_path(4, 4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4), (4, 1)]) == [1, 2, 3, 4] assert find_path(3, 2, [5, 1, 3], [(1, 2), (2, 3)]) == \\"Impossible\\" assert find_path(5, 6, [1, 3, 2, 5, 4], [(1, 2), (2, 3), (3, 4), (4, 5), (1, 4), (3, 5)]) == [1, 2, 3, 5, 4] assert find_path(2, 1, [902, 1], [(1, 2)]) == [2, 1] assert find_path(6, 6, [1, 5, 2, 6, 3, 4], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 6)]) == \\"Impossible\\" test_find_path()","solution":"def find_path(n, m, difficulties, tunnels): from collections import defaultdict, deque graph = defaultdict(list) for u, v in tunnels: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) # Sort dungeons by difficulty sorted_dungeons = sorted(range(n), key=lambda x: difficulties[x]) # Helper function to check if Hamiltonian path exists def backtrack(path): if len(path) == n: return True last_node = path[-1] for neighbor in graph[last_node]: if neighbor in path: continue if backtrack(path + [neighbor]): return True return False start = sorted_dungeons[0] end = sorted_dungeons[-1] visited_paths = set() def is_hamiltonian_path(node, path): if len(path) == n: return path[-1] == end for neighbor in graph[node]: if neighbor not in path: path.append(neighbor) if tuple(path) not in visited_paths: visited_paths.add(tuple(path)) if is_hamiltonian_path(neighbor, path): return path path.pop() return False path = is_hamiltonian_path(start, [start]) if path: return [x + 1 for x in path] return \\"Impossible\\" # Example Usage n = 4 m = 4 difficulties = [1, 2, 3, 4] tunnels = [(1, 2), (2, 3), (3, 4), (4, 1)] print(find_path(n, m, difficulties, tunnels)) # Output: [1, 2, 3, 4] n = 3 m = 2 difficulties = [5, 1, 3] tunnels = [(1, 2), (2, 3)] print(find_path(n, m, difficulties, tunnels)) # Output: \\"Impossible\\""},{"question":"from typing import List, Dict def top_k_frequent_words(words_frequency: Dict[str, int], k: int) -> List[str]: Returns the k most frequent words from the dictionary 'words_frequency'. If two words have the same frequency, the one that is lexicographically smaller should come first. Args: words_frequency (Dict[str, int]): A dictionary where keys are words and values are their frequencies. k (int): The number of top frequent words to return. Returns: List[str]: A list of the top k frequent words sorted by their frequency in descending order, and by lexicographic order if frequencies are the same. Examples: >>> top_k_frequent_words({'apple': 5, 'banana': 3, 'orange': 5, 'grape': 3, 'fig': 2}, 3) ['apple', 'orange', 'banana'] >>> top_k_frequent_words({'dog': 4, 'cat': 2, 'elephant': 6, 'bird': 4}, 2) ['elephant', 'bird'] Unit Test: from solution import top_k_frequent_words def test_example_1(): words_frequency = {'apple': 5, 'banana': 3, 'orange': 5, 'grape': 3, 'fig': 2} k = 3 result = top_k_frequent_words(words_frequency, k) assert result == ['apple', 'orange', 'banana'] def test_example_2(): words_frequency = {'dog': 4, 'cat': 2, 'elephant': 6, 'bird': 4} k = 2 result = top_k_frequent_words(words_frequency, k) assert result == ['elephant', 'bird'] def test_multiple_same_frequency(): words_frequency = {'pear': 2, 'apple': 2, 'banana': 2, 'grapefruit': 2} k = 2 result = top_k_frequent_words(words_frequency, k) assert result == ['apple', 'banana'] def test_all_unique_frequencies(): words_frequency = {'apple': 1, 'banana': 2, 'cherry': 3, 'date': 4, 'fig': 5} k = 3 result = top_k_frequent_words(words_frequency, k) assert result == ['fig', 'date', 'cherry'] def test_k_equals_length(): words_frequency = {'apple': 1, 'banana': 2, 'cherry': 3} k = 3 result = top_k_frequent_words(words_frequency, k) assert result == ['cherry', 'banana', 'apple'] def test_single_word(): words_frequency = {'apple': 10} k = 1 result = top_k_frequent_words(words_frequency, k) assert result == ['apple']","solution":"def top_k_frequent_words(words_frequency, k): Returns the k most frequent words from the dictionary 'words_frequency'. If two words have the same frequency, the one that is lexicographically smaller should come first. # Sort the words first lexicographically, then by frequency in descending order sorted_words = sorted(words_frequency.items(), key=lambda item: (-item[1], item[0])) return [word for word, freq in sorted_words[:k]]"},{"question":"def can_form_perfect_jigsaw(n: int, pieces: List[int]) -> str: Determines if the pieces can form a perfect jigsaw puzzle. A perfect jigsaw puzzle means each piece fits exactly once into a unique position, and no piece is repeated or missing. The pieces should be a consecutive sequence starting from 1 to n. Parameters: n (int): The total number of pieces. pieces (list of int): The numbers on the pieces Alice has. Returns: str: \\"YES\\" if the pieces can form a perfect jigsaw puzzle, otherwise \\"NO\\". >>> can_form_perfect_jigsaw(4, [1, 2, 3, 4]) \\"YES\\" >>> can_form_perfect_jigsaw(5, [5, 3, 1, 4, 2]) \\"YES\\" >>> can_form_perfect_jigsaw(4, [1, 2, 3, 5]) \\"NO\\"","solution":"def can_form_perfect_jigsaw(n, pieces): Determines if the pieces can form a perfect jigsaw puzzle. A perfect jigsaw puzzle means each piece fits exactly once into a unique position, and no piece is repeated or missing. The pieces should be a consecutive sequence starting from 1 to n. Parameters: n (int): The total number of pieces. pieces (list of int): The numbers on the pieces Alice has. Returns: str: \\"YES\\" if the pieces can form a perfect jigsaw puzzle, otherwise \\"NO\\". if sorted(pieces) == list(range(1, n+1)): return \\"YES\\" else: return \\"NO\\""},{"question":"def gear_color(n: int, coordinates: List[Tuple[int, int]]) -> List[str]: Determine the color of the gear at given coordinates based on the specified rules. - If both i and j are even, the gear is red. - If both i and j are odd, the gear is red. - If one of them is even and the other is odd, the gear is blue. Args: n (int): The number of given coordinates. coordinates (List[Tuple[int, int]]): A list of tuples where each tuple represents the coordinates (i, j) of a gear. Returns: List[str]: A list of strings where each string is either \\"Red\\" or \\"Blue\\". Example: >>> gear_color(3, [(2, 3), (4, 4), (1, 2)]) [\\"Blue\\", \\"Red\\", \\"Blue\\"] >>> gear_color(2, [(1, 1), (7, 8)]) [\\"Red\\", \\"Blue\\"]","solution":"def gear_color(n, coordinates): colors = [] for i, j in coordinates: if (i % 2 == j % 2): colors.append(\\"Red\\") else: colors.append(\\"Blue\\") return colors"},{"question":"def min_prize_difference(n: int, m: int, prizes: List[int]) -> int: Find the minimum possible difference between the highest and lowest prize values awarded to any participants. Parameters: n (int): The number of prizes. m (int): The number of participants. prizes (list of int): The values of the prizes. Returns: int: The minimum possible difference between the highest and lowest prize values awarded to any participants. >>> min_prize_difference(6, 4, [8, 12, 5, 7, 9, 10]) 3 >>> min_prize_difference(1, 1, [10]) 0","solution":"def min_prize_difference(n, m, prizes): Find the minimum possible difference between the highest and lowest prize values awarded to any participants. Parameters: n (int): The number of prizes. m (int): The number of participants. prizes (list of int): The values of the prizes. Returns: int: The minimum possible difference between the highest and lowest prize values awarded to any participants. prizes.sort() min_difference = float('inf') for i in range(n - m + 1): difference = prizes[i + m - 1] - prizes[i] if difference < min_difference: min_difference = difference return min_difference"},{"question":"def maxRectangleArea(heights: list[int]) -> int: Find the maximum area of a rectangle formed by any number of contiguous buildings. >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> maxRectangleArea([1, 2, 3, 4, 5, 3, 3]) 15","solution":"def maxRectangleArea(heights): Find the maximum area of a rectangle formed by any number of contiguous buildings. Parameters: heights (list of int): An array of integers representing the heights of the buildings. Returns: int: The area of the largest rectangle that can be formed by the buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def process_operations(N, M, array, operations, Q, queries): Processes the operations on the array and answers the queries. :param N: The size of the array :param M: The number of operations :param array: List of N integers representing the initial array :param operations: List of tuples, each containing two integers L and R representing an operation :param Q: The number of queries :param queries: List of tuples, each containing two integers L and R representing a query :return: List of results for each query Example: >>> N = 5 >>> M = 3 >>> array = [1, 2, 3, 4, 5] >>> operations = [(1, 3), (2, 5), (1, 4)] >>> Q = 2 >>> queries = [(1, 3), (2, 5)] >>> process_operations(N, M, array, operations, Q, queries) [6, 6] pass # Test cases from solution import process_operations def test_process_operations_example(): N = 5 M = 3 array = [1, 2, 3, 4, 5] operations = [(1, 3), (2, 5), (1, 4)] Q = 2 queries = [(1, 3), (2, 5)] assert process_operations(N, M, array, operations, Q, queries) == [6, 6] def test_process_operations_single_element(): N = 1 M = 1 array = [1] operations = [(1, 1)] Q = 1 queries = [(1, 1)] assert process_operations(N, M, array, operations, Q, queries) == [2] def test_process_operations_all_same_operations(): N = 5 M = 2 array = [1, 2, 3, 4, 5] operations = [(1, 5), (1, 5)] Q = 1 queries = [(1, 5)] assert process_operations(N, M, array, operations, Q, queries) == [7] def test_process_operations_no_operations(): N = 3 M = 0 array = [3, 1, 4] operations = [] Q = 1 queries = [(1, 3)] assert process_operations(N, M, array, operations, Q, queries) == [4] def test_process_operations_edge_case(): N = 5 M = 5 array = [5, 4, 3, 2, 1] operations = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] Q = 1 queries = [(1, 5)] assert process_operations(N, M, array, operations, Q, queries) == [6]","solution":"def process_operations(N, M, array, operations, Q, queries): Processes the operations on the array and answers the queries. :param N: The size of the array :param M: The number of operations :param array: List of N integers representing the initial array :param operations: List of tuples, each containing two integers L and R representing an operation :param Q: The number of queries :param queries: List of tuples, each containing two integers L and R representing a query :return: List of results for each query # Create a difference array diff = [0] * (N + 1) for L, R in operations: diff[L - 1] += 1 if R < N: diff[R] -= 1 # Apply the difference array to the initial array increment = 0 modified_array = [] for i in range(N): increment += diff[i] modified_array.append(array[i] + increment) # Process each query to find the maximum in the specified subarray results = [] for L, R in queries: subarray_max = max(modified_array[L - 1:R]) results.append(subarray_max) return results # Example usage: # N = 5, M = 3 # array = [1, 2, 3, 4, 5] # operations = [(1, 3), (2, 5), (1, 4)] # Q = 2 # queries = [(1, 3), (2, 5)] # The expected result is [6, 6] # print(process_operations(N, M, array, operations, Q, queries))"},{"question":"def single_occurrence_number(arr): Given an array of integers where each integer appears three times except for one, this function finds and returns the integer that appears only once. >>> single_occurrence_number([2, 2, 3, 2]) 3 >>> single_occurrence_number([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def single_occurrence_number(arr): Given an array of integers where each integer appears three times except for one, this function finds and returns the integer that appears only once. ones, twos = 0, 0 for num in arr: twos |= ones & num ones ^= num common_mask = ~(ones & twos) ones &= common_mask twos &= common_mask return ones"},{"question":"def sum_prime_CSV(csv_content: str) -> int: Takes a string representing CSV file content and returns the sum of all prime numbers found in the CSV file. >>> sum_prime_CSV(\\"23,10n17,19,20n4,5,6\\") 64 >>> sum_prime_CSV(\\"8,10n12,20,24n4,6,8\\") 0 >>> sum_prime_CSV(\\"\\") 0 >>> sum_prime_CSV(\\"23,10nabc,19,20n4,5,xyz\\") -1","solution":"import csv from math import isqrt def is_prime(n): Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_prime_CSV(csv_content): Takes a string representing CSV file content and returns the sum of all prime numbers found in the CSV file. try: total = 0 reader = csv.reader(csv_content.strip().split('n')) for row in reader: for value in row: num = int(value) if is_prime(num): total += num return total except ValueError: return -1"},{"question":"def find_optimal_track(test_cases): Find the track with the lowest sum of expected finish times. Args: test_cases (List[Tuple[int, List[List[int]]]]): List of test cases, where each test case is a tuple containing number of runners and a list of runners' preferences. Returns: List[str]: List of strings for each test case in the format \\"Case #X: Y\\" where X is the case number and Y is the track ID with the lowest sum of expected finish times. >>> test_cases_input = [ ... (3, [[2, 1, 20, 3, 50], [1, 2, 30], [2, 1, 15, 2, 25]]), ... (2, [[1, 1, 50], [1, 2, 40]]) ... ] >>> find_optimal_track(test_cases_input) [\\"Case #1: 1\\", \\"Case #2: 2\\"] pass def parse_input(input_text): Parse the input text into structured data. Args: input_text (str): Multiline string representing the input. Returns: List[Tuple[int, List[List[int]]]]: Structured data parsed from the input. >>> input_text = \\"2n3n2 1 20 3 50n1 2 30n2 1 15 2 25n2n1 1 50n1 2 40n\\" >>> parse_input(input_text) [(3, [[2, 1, 20, 3, 50], [1, 2, 30], [2, 1, 15, 2, 25]]), (2, [[1, 1, 50], [1, 2, 40]])] pass","solution":"def find_optimal_track(test_cases): results = [] for idx, case in enumerate(test_cases): n = case[0] runners = case[1] track_times = {} for runner in runners: k = runner[0] preferred_tracks = runner[1:] for i in range(0, len(preferred_tracks), 2): track_id = preferred_tracks[i] finish_time = preferred_tracks[i + 1] if track_id in track_times: track_times[track_id] += finish_time else: track_times[track_id] = finish_time optimal_track = min(track_times, key=lambda x: (track_times[x], x)) results.append(f\\"Case #{idx + 1}: {optimal_track}\\") return results def parse_input(input_text): lines = input_text.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) runners = [] for i in range(n): runner_data = list(map(int, lines[index + i + 1].split())) runners.append(runner_data) test_cases.append((n, runners)) index += n + 1 return test_cases"},{"question":"def max_total_sweetness(n: int, k: int, sweetness_values: List[int]) -> int: Returns the maximum total sweetness achievable by selecting exactly k different types of fruits. >>> max_total_sweetness(5, 3, [2, 5, 3, 8, 6]) 19 >>> max_total_sweetness(4, 2, [1, 3, 2, 4]) 7 >>> max_total_sweetness(6, 4, [1, 10, 3, 7, 2, 5]) 25 def test_max_total_sweetness(): assert max_total_sweetness(5, 3, [2, 5, 3, 8, 6]) == 19 assert max_total_sweetness(4, 2, [1, 3, 2, 4]) == 7 assert max_total_sweetness(6, 4, [1, 10, 3, 7, 2, 5]) == 25 assert max_total_sweetness(1, 1, [7]) == 7 assert max_total_sweetness(10, 5, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == 400 assert max_total_sweetness(6, 3, [4, 4, 4, 4, 4, 4]) == 12 assert max_total_sweetness(3, 2, [5, 9, 14]) == 23 assert max_total_sweetness(3, 1, [5, 9, 14]) == 14 assert max_total_sweetness(2, 2, [1, 8]) == 9 # Run tests test_max_total_sweetness()","solution":"def max_total_sweetness(n, k, sweetness_values): Returns the maximum total sweetness achievable by selecting exactly k different types of fruits. # Sort sweetness values in descending order sweetness_values.sort(reverse=True) # Sum the top k sweetness values return sum(sweetness_values[:k])"},{"question":"def min_diff_teams(nums): Given an array of integers nums where the ith element represents the score of the ith player in a game, divide all the players into two teams such that the absolute difference between the total scores of the two teams is minimized. Return the minimum absolute difference. Example 1: >>> min_diff_teams([1,2,3,4,5]) 1 Example 2: >>> min_diff_teams([10,20,15,5,25]) 5 Example 3: >>> min_diff_teams([1,1,1,1,1]) 1 Constraints: 1 <= nums.length <= 100 1 <= nums[i] <= 100","solution":"def min_diff_teams(nums): Returns the minimum absolute difference between the total scores of two teams. total_sum = sum(nums) n = len(nums) # DP array where dp[i] will be True if a subset with sum i can be formed dp = [False] * (total_sum // 2 + 1) dp[0] = True for num in nums: for i in range(total_sum // 2, num - 1, -1): if dp[i - num]: dp[i] = True for i in range(total_sum // 2, -1, -1): if dp[i]: other_team_sum = total_sum - i return abs(i - other_team_sum)"},{"question":"def is_palindrome_num(n: int) -> str: Determines if the given integer number is a palindrome. Negative numbers are not considered palindromes. Parameters: n (int): The input integer. Returns: str: \\"YES\\" if the number is a palindrome, \\"NO\\" otherwise. # Given an integer n, determine if it is a palindrome number. def check_palindromes(test_cases: List[int]) -> List[str]: For each number in the test cases, determines if the number is a palindrome and returns the results. Parameters: test_cases (list of int): List of integers to check. Returns: list of str: List of results, \\"YES\\" if the number is a palindrome and \\"NO\\" otherwise. # Given a list of integers, test if each number is a palindrome and return the results. from typing import List def test_is_palindrome_num(): assert is_palindrome_num(121) == \\"YES\\" assert is_palindrome_num(-121) == \\"NO\\" assert is_palindrome_num(12321) == \\"YES\\" assert is_palindrome_num(123) == \\"NO\\" assert is_palindrome_num(1) == \\"YES\\" assert is_palindrome_num(-1) == \\"NO\\" def test_check_palindromes(): input_values = [121, -121, 12321, 123, 1] expected_results = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\", \\"YES\\"] assert check_palindromes(input_values) == expected_results","solution":"def is_palindrome_num(n): Determines if the given integer number is a palindrome. Negative numbers are not considered palindromes. Parameters: n (int): The input integer. Returns: str: \\"YES\\" if the number is a palindrome, \\"NO\\" otherwise. if n < 0: return \\"NO\\" original_str = str(n) reversed_str = original_str[::-1] if original_str == reversed_str: return \\"YES\\" else: return \\"NO\\" def check_palindromes(test_cases): For each number in the test cases, determines if the number is a palindrome and returns the results. Parameters: test_cases (list of int): List of integers to check. Returns: list of str: List of results, \\"YES\\" if the number is a palindrome and \\"NO\\" otherwise. results = [] for n in test_cases: results.append(is_palindrome_num(n)) return results"},{"question":"def max_sum_segment(arr: List[int]) -> Tuple[int, int]: Returns the start and end indices (1-based) of the segment with the maximum sum. >>> max_sum_segment([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (4, 7) >>> max_sum_segment([1, -1, 1, -1, 1, -1]) (1, 1) >>> max_sum_segment([2, 2, -3]) (1, 2)","solution":"def max_sum_segment(arr): Returns the start and end indices (1-based) of the segment with the maximum sum. n = len(arr) max_sum = float('-inf') current_sum = 0 start, end = 0, 0 temp_start = 0 for i in range(n): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i elif current_sum == max_sum: if (i - temp_start) < (end - start): start = temp_start end = i if current_sum < 0: current_sum = 0 temp_start = i + 1 return start + 1, end + 1"},{"question":"from typing import List def shortest_path_same_color(grid: List[str]) -> int: Determine the shortest path from the top-left corner to the bottom-right corner of the grid. You can only pass through cells that have the same color. If no path exists, return -1. Parameters: grid (List[str]): A list of strings representing the grid. Returns: int: The length of the shortest path or -1 if no path exists. >>> shortest_path_same_color([\\"a.a\\", \\"aaa\\", \\"a.a\\"]) 4 >>> shortest_path_same_color([\\"a.a\\", \\"a.a\\", \\"a.a\\"]) -1 >>> shortest_path_same_color([\\"aaaaa\\"]) 4","solution":"from collections import deque def shortest_path_same_color(grid): n = len(grid) m = len(grid[0]) if grid[0][0] == \\".\\" or grid[n-1][m-1] == \\".\\": return -1 def get_neighbors(x, y): for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == grid[x][y]: yield nx, ny queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for nx, ny in get_neighbors(x, y): if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_sum_path_in_forest(T: int, test_cases: List[Tuple[int, List[int], List[Tuple[int, int]]]]) -> List[int]: Find the maximum sum of node values in any simple path in the tree. Args: T: Number of test cases. test_cases: A list of test cases, where each test case is a tuple containing: - N: Number of nodes. - values: A list of N integers representing the values of the nodes. - edges: A list of (N-1) tuples representing the edges between nodes. Returns: A list of integers where each integer is the maximum sum of node values in any simple path for the corresponding test case. Examples: >>> max_sum_path_in_forest(2, [(3, [1, 2, 3], [(1, 2), (2, 3)]), (4, [-1, 2, 3, -4], [(1, 2), (2, 3), (2, 4)])]) [6, 5] from solution import max_sum_path_in_forest def test_single_test_case(): T = 1 test_cases = [ (3, [1, 2, 3], [(1, 2), (2, 3)]) ] assert max_sum_path_in_forest(T, test_cases) == [6] def test_multiple_test_cases(): T = 2 test_cases = [ (3, [1, 2, 3], [(1, 2), (2, 3)]), (4, [-1, 2, 3, -4], [(1, 2), (2, 3), (2, 4)]) ] assert max_sum_path_in_forest(T, test_cases) == [6, 5] def test_negative_values(): T = 1 test_cases = [ (4, [-1, -2, -3, -4], [(1, 2), (2, 3), (2, 4)]) ] assert max_sum_path_in_forest(T, test_cases) == [-1] def test_single_node_tree(): T = 1 test_cases = [ (2, [10, -10], [(1, 2)]) ] assert max_sum_path_in_forest(T, test_cases) == [10] def test_all_zero_values(): T = 1 test_cases = [ (3, [0, 0, 0], [(1, 2), (2, 3)]) ] assert max_sum_path_in_forest(T, test_cases) == [0]","solution":"def dfs_max_sum(node, parent, adj, values): max1, max2 = 0, 0 # top two longest paths from this node for child in adj[node]: if child == parent: continue max_child_sum = dfs_max_sum(child, node, adj, values) if max_child_sum > max1: max1, max2 = max_child_sum, max1 elif max_child_sum > max2: max2 = max_child_sum dfs_max_sum.max_path = max(dfs_max_sum.max_path, max1 + max2 + values[node]) return max1 + values[node] def max_sum_path_in_tree(N, values, edges): adj = {i: [] for i in range(N)} for u, v in edges: adj[u-1].append(v-1) adj[v-1].append(u-1) dfs_max_sum.max_path = float('-inf') dfs_max_sum(0, -1, adj, values) return dfs_max_sum.max_path def max_sum_path_in_forest(T, test_cases): results = [] for N, values, edges in test_cases: results.append(max_sum_path_in_tree(N, values, edges)) return results"},{"question":"from typing import List, Tuple def can_all_elements_become_equal(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine whether it is possible to reduce the array to an array that contains only one unique element after some number of GCD operations. >>> can_all_elements_become_equal(1, [(2, [2, 4])]) [\\"YES\\"] >>> can_all_elements_become_equal(3, [(2, [2, 4]), (4, [5, 10, 20, 25]), (3, [7, 11, 13])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_all_elements_become_equal(1, [(3, [2, 3, 5])]) [\\"NO\\"] >>> can_all_elements_become_equal(2, [(4, [6, 12, 18, 24]), (3, [4, 4, 4])]) [\\"YES\\", \\"YES\\"] >>> can_all_elements_become_equal(1, [(3, [6, 9, 15])]) [\\"NO\\"]","solution":"from math import gcd from functools import reduce def can_all_elements_become_equal(t, test_cases): results = [] for n, arr in test_cases: overall_gcd = reduce(gcd, arr) if overall_gcd in arr: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def median_of_three_quick_sort(arr: list) -> None: Sort the list in ascending order using the Median-of-Three QuickSort algorithm. >>> arr = [3, 6, 8, 10, 1, 2, 1] >>> median_of_three_quick_sort(arr) >>> arr [1, 1, 2, 3, 6, 8, 10] >>> arr = [1, 2, 3, 4, 5] >>> median_of_three_quick_sort(arr) >>> arr [1, 2, 3, 4, 5] >>> arr = [5, 4, 3, 2, 1] >>> median_of_three_quick_sort(arr) >>> arr [1, 2, 3, 4, 5] >>> arr = [3, 3, 3, 3, 3] >>> median_of_three_quick_sort(arr) >>> arr [3, 3, 3, 3, 3] >>> arr = [3, -1000000, 1000000, 0, -1, 1] >>> median_of_three_quick_sort(arr) >>> arr [-1000000, -1, 0, 1, 3, 1000000] pass","solution":"def median_of_three_quick_sort(arr: list) -> None: def median_of_three(a, b, c): if (a - b) * (c - a) >= 0: return a elif (b - a) * (c - b) >= 0: return b else: return c def partition(low, high): mid = (low + high) // 2 pivot_index = arr.index(median_of_three(arr[low], arr[mid], arr[high])) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort(low, high): if low < high: pi = partition(low, high) quick_sort(low, pi - 1) quick_sort(pi + 1, high) quick_sort(0, len(arr) - 1)"},{"question":"def min_changes_to_form_path(test_cases): Given the initial state of all crossroads, determine the minimum number of crossroad states that need to be changed from red to green in order to ensure there is at least one path from the first crossroad to the last crossroad. Args: test_cases: List of tuples, where each tuple contains: - an integer N representing the number of crossroads - a string of length N consisting of characters 'G' (Green) and 'R' (Red) representing the initial state of each crossroad. Returns: List of integers, each representing the minimum number of changes required for the corresponding test case. def process_input(input_string): Process the input format. Args: input_string: The input as a string. Returns: A list of tuples where each tuple contains: - an integer N representing the number of crossroads - a string representing the state of each crossroad. def process_output(output_list): Process the output format. Args: output_list: List of integers representing the number of changes needed for each test case. Returns: A string with each result on a new line. def main(input_string): Main function to integrate input processing, solution, and output processing. Args: input_string: The input as a string. Returns: The formatted output as a string. # Example Usage if __name__ == \\"__main__\\": input_string = \\"3n5nGRGRGn4nGGGGn6nGRRGRGn\\" print(main(input_string))","solution":"def min_changes_to_form_path(test_cases): results = [] for test in test_cases: _, crossroads = test tokens = crossroads.split('G') changes_needed = sum(len(token) > 0 for token in tokens) results.append(changes_needed - 1 if changes_needed > 1 else 0) return results # Handling the input format def process_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] for i in range(1, T*2, 2): N = int(input_lines[i]) crossroads = input_lines[i+1] test_cases.append((N, crossroads)) return test_cases # Handling the output format def process_output(output_list): return 'n'.join(map(str, output_list)) # Main function to integrate input, solution and output processing def main(input_string): test_cases = process_input(input_string) results = min_changes_to_form_path(test_cases) return process_output(results)"},{"question":"def find_winner(n, scores): Determines the winner of the game based on the points scored. Args: n: int - The number of players. scores: List[List[int]] - A 2D list containing the points each player scored in each round. Returns: int - The index of the winning player. Examples: >>> find_winner(3, [[10, 20, 30], [20, 30, 10], [30, 10, 20]]) 0 >>> find_winner(4, [[40, 50], [30, 60], [50, 50], [60, 30]]) 2 >>> find_winner(2, [[10, 20, 15], [25, 15, 10]]) 1","solution":"def find_winner(n, scores): Determines the winner of the game based on the points scored. Args: n: int - The number of players. scores: List[List[int]] - A 2D list containing the points each player scored in each round. Returns: int - The index of the winning player. max_total_points = -1 max_single_round_points = -1 winner_index = -1 for i in range(n): total_points = sum(scores[i]) single_round_points = max(scores[i]) # First decide based on max total points if total_points > max_total_points: max_total_points = total_points max_single_round_points = single_round_points winner_index = i elif total_points == max_total_points: # If the total points are the same, find based on highest single round points if single_round_points > max_single_round_points: max_single_round_points = single_round_points winner_index = i elif single_round_points == max_single_round_points: # In case still tied, choose the player with the lowest index if i < winner_index: winner_index = i return winner_index"},{"question":"def maxSalesSum(N, K, sales): Returns the maximum sum of sales over K consecutive days. :param N: Integer, the total number of days :param K: Integer, the number of consecutive days :param sales: List of integers representing sales :return: Integer, the maximum sum of sales over K consecutive days >>> maxSalesSum(7, 3, [2, 1, 5, 1, 3, 2, 1]) == 9 >>> maxSalesSum(5, 2, [4, 2, 1, 3, 4]) == 7","solution":"def maxSalesSum(N, K, sales): Returns the maximum sum of sales over K consecutive days. :param N: Integer, the total number of days :param K: Integer, the number of consecutive days :param sales: List of integers representing sales :return: Integer, the maximum sum of sales over K consecutive days # Initial window sum window_sum = sum(sales[:K]) max_sum = window_sum # Slide the window through the array for i in range(K, N): window_sum = window_sum + sales[i] - sales[i - K] if window_sum > max_sum: max_sum = window_sum return max_sum"},{"question":"def manage_exhibition(n: int, notices: List[Tuple[int, int, int]]) -> List[List[int]]: Manages artworks in multiple galleries based on addition and removal notices. :param n: int - number of notices :param notices: list of tuples - each tuple contains three integers g, r, and v :return: list - the state of the galleries after processing all notices >>> manage_exhibition(1, [(1, 1, 5)]) == [ [5, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] >>> manage_exhibition(4, [(1, 2, 5), (2, 1, 10), (3, 3, -2), (2, 1, 8)]) == [ [0, 5, 0, 0, 0], [18, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] >>> manage_exhibition(3, [(1, 1, 5), (1, 1, 15), (1, 1, 2)]) == [ [20, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] >>> manage_exhibition(3, [(1, 1, 5), (1, 1, -3), (1, 1, 10)]) == [ [12, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0] ] >>> manage_exhibition(2, [(3, 5, 18), (3, 5, 5)]) == [ [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 20] ] def print_galleries(galleries: List[List[int]]): Prints the state of galleries. :param galleries: list - the state of the galleries","solution":"def manage_exhibition(n, notices): Manages artworks in multiple galleries based on addition and removal notices. :param n: int - number of notices :param notices: list of tuples - each tuple contains three integers g, r, and v :return: list - the state of the galleries after processing all notices # Initialize the galleries - 3 galleries, each with 5 rooms galleries = [[0 for _ in range(5)] for _ in range(3)] # Process each notice for notice in notices: g, r, v = notice galleries[g-1][r-1] = max(0, min(20, galleries[g-1][r-1] + v)) return galleries def print_galleries(galleries): Prints the state of galleries. :param galleries: list - the state of the galleries for idx, gallery in enumerate(galleries): for room in gallery: print(f\\"{room} \\", end='') print() if idx < len(galleries) - 1: print(\\"--------------------\\") # Example usage if __name__ == \\"__main__\\": n = 4 notices = [(1, 2, 5), (2, 1, 10), (3, 3, -2), (2, 1, 8)] galleries = manage_exhibition(n, notices) print_galleries(galleries)"},{"question":"def can_allocate_rooms(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determines if it is possible to allocate students to rooms under given conditions. :param test_cases: List of test cases where each test case is a tuple of (n, s, capacities) n: number of rooms s: number of students capacities: list of room capacities :returns: List of \\"yes\\" or \\"no\\" for each test case >>> can_allocate_rooms([(3, 150, [60, 70, 90])]) [\\"yes\\"] >>> can_allocate_rooms([(2, 50, [60, 40])]) [\\"no\\"] >>> can_allocate_rooms([(4, 200, [50, 100, 70, 80])]) [\\"yes\\"]","solution":"def can_allocate_rooms(test_cases): Determines if it is possible to allocate students to rooms under given conditions. :param test_cases: List of test cases where each test case is a tuple of (n, s, capacities) n: number of rooms s: number of students capacities: list of room capacities :returns: List of \\"yes\\" or \\"no\\" for each test case results = [] for n, s, capacities in test_cases: if sum(capacities) < s or any(s // len(capacities) < capacity // 2 for capacity in capacities): results.append(\\"no\\") else: results.append(\\"yes\\") return results"},{"question":"def silhouette_perimeter(heights: List[int]) -> int: Calculate the total perimeter of the silhouette viewed from a distance. Parameters: heights (list of int): List of heights of the buildings. Returns: int: Total perimeter of the silhouette. >>> silhouette_perimeter([2, 3, 2, 4]) 14 >>> silhouette_perimeter([]) 0 >>> silhouette_perimeter([4]) 12 >>> silhouette_perimeter([1, 2, 3, 4, 5]) 20","solution":"def silhouette_perimeter(heights): Calculate the total perimeter of the silhouette viewed from a distance. Parameters: heights (list of int): List of heights of the buildings. Returns: int: Total perimeter of the silhouette. if not heights: return 0 n = len(heights) # Initial perimeter includes leftmost and rightmost sides, and tops of all buildings perimeter = heights[0] + heights[-1] + sum(heights) # Add vertical differences between adjacent buildings for i in range(1, n): perimeter += abs(heights[i] - heights[i - 1]) return perimeter"},{"question":"def find_sequence(N: int) -> List[int]: Given an integer N, find a combination of integers A_1, A_2, A_3, ..., A_N that satisfies the following conditions: - All integers A_i (1 â‰¤ i â‰¤ N) are distinct. - The sum of all integers A_i is equal to (N * (N + 1)) / 2. - The product of all integers A_i is equal to (N!). Example: >>> find_sequence(1) [1] >>> find_sequence(3) [1, 2, 3] >>> find_sequence(5) [1, 2, 3, 4, 5]","solution":"def find_sequence(N): Returns a sequence of N distinct integers such that: - The sum of the integers is (N * (N + 1)) / 2. - The product of the integers is N!. return list(range(1, N + 1))"},{"question":"def calculate_bonus_points(N, fixed_points, total_scores): Calculate the series of bonus points a player earned in each round. The bonus points for each round must be a non-negative even integer. Args: - N (int): number of rounds. - fixed_points (list of int): fixed points for each round. - total_scores (list of int): total scores for each round. Returns: - list of int: representing the bonus points for each round. >>> calculate_bonus_points(3, [10, 20, 30], [14, 26, 40]) [4, 6, 10] >>> calculate_bonus_points(3, [10, 20, 30], [10, 20, 30]) [0, 0, 0]","solution":"def calculate_bonus_points(N, fixed_points, total_scores): Calculate the bonus points for each round. Args: - N: int, number of rounds. - fixed_points: list of int, fixed points for each round. - total_scores: list of int, total scores for each round. Returns: - List of int, representing the bonus points for each round. bonus_points = [] for i in range(N): bonus_points.append(total_scores[i] - fixed_points[i]) return bonus_points"},{"question":"def minPlatforms(arrival, departure): This function returns the minimum number of platforms required to accommodate all the trains without any collision. >>> minPlatforms([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000]) 3 >>> minPlatforms([100, 300, 500], [200, 400, 600]) 1","solution":"def minPlatforms(arrival, departure): This function returns minimum number of platforms required to accommodate all the trains without any collision. n = len(arrival) arrival.sort() departure.sort() platform_needed = 1 result = 1 i = 1 j = 0 while i < n and j < n: if arrival[i] <= departure[j]: platform_needed += 1 i += 1 if platform_needed > result: result = platform_needed else: platform_needed -= 1 j += 1 return result"},{"question":"def find_minimum_transit_time(n: int, m: int, shipments: List[Tuple[int, int, int]], x: int, y: int) -> int: Calculate the minimum transit time to deliver shipments from node x to node y, considering only the shipments with the least transit time for each pair of nodes. Return -1 if delivery is not possible. >>> find_minimum_transit_time(5, 7, [(1, 2, 10), (1, 3, 5), (2, 4, 1), (3, 2, 2), (4, 5, 4), (3, 4, 9), (2, 5, 6)], 1, 5) 12 >>> find_minimum_transit_time(4, 3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)], 1, 4) 12 >>> find_minimum_transit_time(3, 2, [(1, 2, 3), (1, 3, 4)], 2, 3) -1 >>> find_minimum_transit_time(3, 2, [(1, 2, 3), (2, 3, 4)], 1, 1) 0 >>> find_minimum_transit_time(4, 5, [(1, 2, 5), (1, 2, 3), (2, 3, 4), (3, 4, 1), (1, 4, 10)], 1, 4) 8 pass # Required imports from typing import List, Tuple # Example unit test cases import pytest def test_example_case_1(): n, m = 5, 7 shipments = [ (1, 2, 10), (1, 3, 5), (2, 4, 1), (3, 2, 2), (4, 5, 4), (3, 4, 9), (2, 5, 6) ] x, y = 1, 5 assert find_minimum_transit_time(n, m, shipments, x, y) == 12 def test_example_case_2(): n, m = 4, 3 shipments = [ (1, 2, 3), (2, 3, 4), (3, 4, 5) ] x, y = 1, 4 assert find_minimum_transit_time(n, m, shipments, x, y) == 12 def test_no_possible_delivery(): n, m = 3, 2 shipments = [ (1, 2, 3), (1, 3, 4) ] x, y = 2, 3 assert find_minimum_transit_time(n, m, shipments, x, y) == -1 def test_same_node(): n, m = 3, 2 shipments = [ (1, 2, 3), (2, 3, 4) ] x, y = 1, 1 assert find_minimum_transit_time(n, m, shipments, x, y) == 0 def test_redundant_shipments_with_higher_cost(): n, m = 4, 5 shipments = [ (1, 2, 5), (1, 2, 3), (2, 3, 4), (3, 4, 1), (1, 4, 10) ] x, y = 1, 4 assert find_minimum_transit_time(n, m, shipments, x, y) == 8","solution":"import heapq def find_minimum_transit_time(n, m, shipments, x, y): # Create a graph with the minimum transit times for each pair of nodes graph = {i: {} for i in range(1, n + 1)} for u, v, t in shipments: if v not in graph[u] or t < graph[u][v]: graph[u][v] = t # Dijkstra's algorithm to find the shortest path priority_queue = [(0, x)] shortest_times = {i: float('inf') for i in range(1, n + 1)} shortest_times[x] = 0 while priority_queue: current_time, current_node = heapq.heappop(priority_queue) if current_node == y: return current_time if current_time > shortest_times[current_node]: continue for neighbor, travel_time in graph[current_node].items(): time = current_time + travel_time if time < shortest_times[neighbor]: shortest_times[neighbor] = time heapq.heappush(priority_queue, (time, neighbor)) return -1 if shortest_times[y] == float('inf') else shortest_times[y]"},{"question":"def can_have_highest_score(nums, extraPoints): Returns a list of booleans indicating whether, after adding extraPoints to the corresponding player's score, that player could have the highest score among all players. Parameters: nums (list of int): the current scores of various players. extraPoints (int): the extra points a player can gain. Returns: list of bool: whether each player could have the highest score after adding the extra points. Examples: >>> can_have_highest_score([2, 3, 5, 1, 3], 3) [True, True, True, False, True] >>> can_have_highest_score([4, 2, 1, 1, 2], 1) [True, False, False, False, False] >>> can_have_highest_score([12, 1, 12], 10) [True, False, True]","solution":"def can_have_highest_score(nums, extraPoints): Returns a list of booleans indicating whether, after adding extraPoints to the corresponding player's score, that player could have the highest score among all players. Parameters: nums (list of int): the current scores of various players. extraPoints (int): the extra points a player can gain. Returns: list of bool: whether each player could have the highest score after adding the extra points. max_score = max(nums) return [(score + extraPoints >= max_score) for score in nums]"},{"question":"def has_pair_with_difference(arr, k): Determine if there are two numbers in the list whose difference is exactly k. Parameters: arr (list): A list of unique integers. k (int): The target difference. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_difference([5, 20, 3, 2, 50, 80], 78) 'YES' >>> has_pair_with_difference([90, 70, 20, 80, 30], 45) 'NO'","solution":"def has_pair_with_difference(arr, k): Determine if there are two numbers in the list whose difference is exactly k. Parameters: arr (list): A list of unique integers. k (int): The target difference. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in arr: if (num + k) in seen or (num - k) in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def is_self_descriptive_number(n: int) -> bool: Checks if a number is self-descriptive. A self-descriptive number is an integer n in which each digit at position i (counting from 0) describes how many times the digit i appears in n. Parameters: n (int): The input number Returns: bool: True if n is a self-descriptive number, otherwise False Examples: >>> is_self_descriptive_number(2020) True >>> is_self_descriptive_number(6210001000) True >>> is_self_descriptive_number(1234) False >>> is_self_descriptive_number(1210) True >>> is_self_descriptive_number(2222) False","solution":"def is_self_descriptive_number(n): Checks if a number is self-descriptive. A self-descriptive number is an integer n in which each digit at position i (counting from 0) describes how many times the digit i appears in n. Parameters: n (int): The input number Returns: bool: True if n is a self-descriptive number, otherwise False n_str = str(n) length = len(n_str) for i in range(length): expected_count = int(n_str[i]) actual_count = n_str.count(str(i)) if actual_count != expected_count: return False return True"},{"question":"def isSubsequence(str1: str, str2: str) -> bool: Check if str1 is a subsequence of str2. Parameters: str1 (str): the subsequence to check. str2 (str): the main string to check against. Returns: bool: True if str1 is a subsequence of str2, False otherwise. >>> isSubsequence(\\"abc\\", \\"ahbgdc\\") True >>> isSubsequence(\\"axc\\", \\"ahbgdc\\") False","solution":"def isSubsequence(str1, str2): Check if str1 is a subsequence of str2. Parameters: str1 (str): the subsequence to check. str2 (str): the main string to check against. Returns: bool: True if str1 is a subsequence of str2, False otherwise. str1_index = 0 str2_index = 0 while str1_index < len(str1) and str2_index < len(str2): if str1[str1_index] == str2[str2_index]: str1_index += 1 str2_index += 1 return str1_index == len(str1)"},{"question":"def format_date(date_str): Converts a date string from \\"YYYY-MM-DD\\" format to \\"DD/MM/YYYY\\" format. Args: date_str (str): The date string in \\"YYYY-MM-DD\\" format. Returns: str: The date string in \\"DD/MM/YYYY\\" format. pass # Test cases def test_format_date(): assert format_date(\\"2023-07-19\\") == \\"19/07/2023\\" assert format_date(\\"2000-01-01\\") == \\"01/01/2000\\" assert format_date(\\"2015-12-31\\") == \\"31/12/2015\\" assert format_date(\\"1999-11-11\\") == \\"11/11/1999\\" # Test for leap year date assert format_date(\\"2020-02-29\\") == \\"29/02/2020\\" def test_format_date_with_leading_zeros(): assert format_date(\\"0012-04-04\\") == \\"04/04/0012\\"","solution":"def format_date(date_str): Converts a date string from \\"YYYY-MM-DD\\" format to \\"DD/MM/YYYY\\" format. Args: date_str (str): The date string in \\"YYYY-MM-DD\\" format. Returns: str: The date string in \\"DD/MM/YYYY\\" format. year, month, day = date_str.split('-') return f\\"{day}/{month}/{year}\\""},{"question":"def PerfectSquareCube(N): Function to find the smallest number greater than or equal to N that is both a perfect square and a perfect cube. Parameters: N (int): The positive integer Returns: int: The smallest number greater than or equal to N that is both a perfect square and a perfect cube. from typing import List def test_perfect_square_cube_case_1(): assert PerfectSquareCube(35) == 64 def test_perfect_square_cube_case_2(): assert PerfectSquareCube(10) == 64 def test_perfect_square_cube_case_3(): assert PerfectSquareCube(1) == 1 def test_perfect_square_cube_case_4(): assert PerfectSquareCube(64) == 64 def test_perfect_square_cube_case_5(): assert PerfectSquareCube(65) == 729 def test_perfect_square_cube_case_6(): assert PerfectSquareCube(729) == 729","solution":"def PerfectSquareCube(N): Function to find the smallest number greater than or equal to N that is both a perfect square and a perfect cube. Parameters: N (int): The positive integer Returns: int: The smallest number greater than or equal to N that is both a perfect square and a perfect cube. i = 1 while True: candidate = i ** 6 # A number that is both a perfect square and cube is 6th power. if candidate >= N: return candidate i += 1"},{"question":"def rle_encode(input_string: str) -> str: Returns the run-length encoded form of the input string. >>> rle_encode(\\"aaabbbbcc\\") 'a3b4c2' >>> rle_encode(\\"abcd\\") 'a1b1c1d1' >>> rle_encode(\\"aabbcc\\") 'a2b2c2'","solution":"def rle_encode(input_string: str) -> str: Returns the run-length encoded form of the input string. :param input_string: String consisting of lowercase letters :return: Run-length encoded string if not input_string: return \\"\\" encoded = [] count = 1 prev_char = input_string[0] for char in input_string[1:]: if char == prev_char: count += 1 else: encoded.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 # Append the last set of characters encoded.append(f\\"{prev_char}{count}\\") return ''.join(encoded)"},{"question":"def shiftString(s: str, k: int) -> str: Modifies the input string by replacing each character with the k-th next character in the alphabet. If the replacement exceeds 'z', it wraps around to start from 'a'. :param s: str, input string of lowercase alphabets :param k: int, the number of positions to shift each character :return: str, the resulting modified string >>> shiftString(\\"xyz\\", 3) 'abc' >>> shiftString(\\"hello\\", 4) 'lipps'","solution":"def shiftString(s, k): Modifies the input string by replacing each character with the k-th next character in the alphabet. If the replacement exceeds 'z', it wraps around to start from 'a'. :param s: str, input string of lowercase alphabets :param k: int, the number of positions to shift each character :return: str, the resulting modified string # Calculate the new character for each character in the string shifted = [(chr(((ord(char) - ord('a') + k) % 26) + ord('a'))) for char in s] # Join the list into a string and return return ''.join(shifted)"},{"question":"def tribonacci(n: int) -> int: Calculate the n-th Tribonacci number. >>> tribonacci(0) == 0 >>> tribonacci(1) == 1 >>> tribonacci(2) == 1 >>> tribonacci(3) == 2 >>> tribonacci(4) == 4 >>> tribonacci(5) == 7 >>> tribonacci(6) == 13 >>> tribonacci(37) == 2082876103","solution":"def tribonacci(n): Calculate the n-th Tribonacci number. if n == 0: return 0 elif n == 1 or n == 2: return 1 tribonacci_numbers = [0, 1, 1] for i in range(3, n + 1): next_tribonacci = tribonacci_numbers[-1] + tribonacci_numbers[-2] + tribonacci_numbers[-3] tribonacci_numbers.append(next_tribonacci) return tribonacci_numbers[n]"},{"question":"from typing import List def canSortDescending(n: int, weights: List[int]) -> bool: Determine if it is possible to sort the balls in descending order using the allowed operations. :param n: Number of balls :param weights: List of integers representing the weights of the balls :return: Boolean value indicating if it is possible to sort the balls in descending order. Example: >>> canSortDescending(5, [1, 2, 3, 4, 5]) True >>> canSortDescending(4, [3, 1, 2, 4]) True >>> canSortDescending(3, [3, 2, 1]) True >>> canSortDescending(3, [2, 1, 3]) False","solution":"from typing import List def canSortDescending(n: int, weights: List[int]) -> bool: Determine if it is possible to sort the balls in descending order using the allowed operations. :param n: Number of balls :param weights: List of integers representing the weights of the balls :return: Boolean value indicating if it is possible to sort the balls in descending order # If we reverse the whole row, we get the reversed list reversed_weights = weights[::-1] # Create a sorted list in descending order sorted_weights = sorted(weights, reverse=True) # If reversing the entire row results in the sorted list, return True if reversed_weights == sorted_weights: return True # Otherwise, check if we can sort it using adjacent swaps # We can transform any permutation to another by adjacent swaps return True"},{"question":"def search_books(books, queries): This function searches for books by specified author and year range. Args: books: list of tuples, where each tuple contains (title, author, year) queries: list of tuples, where each tuple contains (author, start_year, end_year) Returns: list of list of strings, where each list contains the books for each query. # Unit test def test_single_query_found(): books = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925), (\\"Tender Is the Night\\", \\"F. Scott Fitzgerald\\", 1934), (\\"1984\\", \\"George Orwell\\", 1949), (\\"Animal Farm\\", \\"George Orwell\\", 1945) ] queries = [(\\"George Orwell\\", 1940, 1950)] expected_output = [[\\"Animal Farm, 1945\\", \\"1984, 1949\\"]] assert search_books(books, queries) == expected_output def test_single_query_not_found(): books = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925), (\\"Tender Is the Night\\", \\"F. Scott Fitzgerald\\", 1934), (\\"1984\\", \\"George Orwell\\", 1949), (\\"Animal Farm\\", \\"George Orwell\\", 1945) ] queries = [(\\"George Orwell\\", 1950, 1960)] expected_output = [[\\"No books found\\"]] assert search_books(books, queries) == expected_output def test_multiple_queries(): books = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925), (\\"Tender Is the Night\\", \\"F. Scott Fitzgerald\\", 1934), (\\"1984\\", \\"George Orwell\\", 1949), (\\"Animal Farm\\", \\"George Orwell\\", 1945) ] queries = [ (\\"George Orwell\\", 1940, 1950), (\\"F. Scott Fitzgerald\\", 1920, 1930) ] expected_output = [ [\\"Animal Farm, 1945\\", \\"1984, 1949\\"], [\\"The Great Gatsby, 1925\\"] ] assert search_books(books, queries) == expected_output def test_no_books(): books = [] queries = [(\\"George Orwell\\", 1940, 1950)] expected_output = [[\\"No books found\\"]] assert search_books(books, queries) == expected_output def test_no_queries(): books = [ (\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925), (\\"Tender Is the Night\\", \\"F. Scott Fitzgerald\\", 1934), (\\"1984\\", \\"George Orwell\\", 1949), (\\"Animal Farm\\", \\"George Orwell\\", 1945) ] queries = [] expected_output = [] assert search_books(books, queries) == expected_output","solution":"def search_books(books, queries): This function searches for books by specified author and year range. Args: books: list of tuples, where each tuple contains (title, author, year) queries: list of tuples, where each tuple contains (author, start_year, end_year) Returns: list of list of strings, where each list contains the books for each query. results = [] for author, start_year, end_year in queries: filtered_books = [ (title, year) for title, book_author, year in books if book_author == author and start_year <= year <= end_year ] filtered_books.sort(key=lambda x: x[1]) if filtered_books: results.append([f\\"{title}, {year}\\" for title, year in filtered_books]) else: results.append([\\"No books found\\"]) return results"},{"question":"def find_maximum(arr): Returns the maximum value in the array using a limited number of comparisons. Assumes N, the length of the array, is an even number. >>> find_maximum([1, 2, 3, 4, 5, 6]) 6 >>> find_maximum([10, 20, 30, 40, 50, 60]) 60 >>> find_maximum([4, 4, 4, 4, 4, 4]) 4 >>> find_maximum([-1, -2, -3, -4, -5, -6]) -1 >>> find_maximum([-1, 0, 1, -2, 2, -3, 3, -4, 4, -5, 5, -6, 6]) 6 >>> find_maximum([5, 10]) 10 >>> find_maximum([]) None","solution":"def find_maximum(arr): Returns the maximum value in the array using a limited number of comparisons. Assumes N, the length of the array, is an even number. if len(arr) == 0: return None # Standard linear search to find the maximum value max_value = arr[0] for i in range(1, len(arr)): if arr[i] > max_value: max_value = arr[i] return max_value"},{"question":"def can_obtain_by_rotation(s: str, t: str) -> str: Determine if it's possible to obtain string t by rotating string s any number of times. Args: s (str): the string to be rotated t (str): the target string Returns: str: \\"Yes\\" if t can be obtained by rotating s, otherwise \\"No\\" Examples: >>> can_obtain_by_rotation(\\"abcde\\", \\"cdeab\\") \\"Yes\\" >>> can_obtain_by_rotation(\\"abcde\\", \\"abced\\") \\"No\\"","solution":"def can_obtain_by_rotation(s, t): Returns \\"Yes\\" if the string t can be obtained by rotating string s any number of times, otherwise returns \\"No\\". if len(s) != len(t): return \\"No\\" # Check if t is a substring of s concatenated with itself doubled_s = s + s if t in doubled_s: return \\"Yes\\" else: return \\"No\\""},{"question":"def validate_username(username: str) -> str: Determines if the username is valid based on the specified criteria: - It must be between 5 and 15 characters long (inclusive). - It must start with an English alphabet character (a-z, A-Z). - It can only contain English alphabet characters (a-z, A-Z) and digits (0-9). Returns: - \\"VALID\\" if the username is valid, otherwise \\"INVALID\\" >>> validate_username(\\"user123\\") == \\"VALID\\" >>> validate_username(\\"4usr\\") == \\"INVALID\\"","solution":"def validate_username(username): Determines if the username is valid based on the specified criteria. Parameters: - username: str Returns: - \\"VALID\\" if the username is valid, otherwise \\"INVALID\\" if len(username) < 5 or len(username) > 15: return \\"INVALID\\" if not username[0].isalpha(): return \\"INVALID\\" if not username.isalnum(): return \\"INVALID\\" return \\"VALID\\""},{"question":"def filter_books(inventory, genres, max_pages): Filters the books based on the provided genres and max_pages. Parameters: - inventory (list of dict): List of dictionaries where each dictionary represents a book. - genres (list of str): List of genres to filter by. - max_pages (int or None): Maximum number of pages; None means no page limit. Returns: - List of book titles that match the filters, sorted alphabetically. >>> inventory = [ ... {\\"id\\": 1, \\"title\\": \\"Book A\\", \\"author\\": \\"Author A\\", \\"genre\\": \\"Fantasy\\", \\"pages\\": 300}, ... {\\"id\\": 2, \\"title\\": \\"Book B\\", \\"author\\": \\"Author B\\", \\"genre\\": \\"Sci-Fi\\", \\"pages\\": 250}, ... {\\"id\\": 3, \\"title\\": \\"Book C\\", \\"author\\": \\"Author C\\", \\"genre\\": \\"Fantasy\\", \\"pages\\": 400}, ... ] >>> filter_books(inventory, [\\"Fantasy\\"], None) ['Book A', 'Book C'] >>> filter_books(inventory, [], 300) ['Book A', 'Book B'] >>> filter_books(inventory, [\\"Fantasy\\"], 300) ['Book A'] >>> filter_books(inventory, [], None) ['Book A', 'Book B', 'Book C'] >>> filter_books([], [\\"Fantasy\\"], 300) []","solution":"def filter_books(inventory, genres, max_pages): Filters the books based on the provided genres and max_pages. Parameters: - inventory (list of dict): List of dictionaries where each dictionary represents a book. - genres (list of str): List of genres to filter by. - max_pages (int or None): Maximum number of pages; None means no page limit. Returns: - List of book titles that match the filters, sorted alphabetically. filtered_books = [] for book in inventory: if (not genres or book['genre'] in genres) and (max_pages is None or book['pages'] <= max_pages): filtered_books.append(book['title']) return sorted(filtered_books)"},{"question":"def min_time_to_destination(N, M, T, vehicles): Computes the minimum time required for each vehicle to reach its destination under the given traffic signal rules. :param N: Number of rows in the grid :param M: Number of columns in the grid :param T: Duration traffic signals remain in one state before switching to the other :param vehicles: A list of tuples where each tuple contains four integers (sx, sy, dx, dy) for each vehicle's start and destination :return: A list of integers where each integer is the minimum time required for the corresponding vehicle to reach its destination pass def traffic_simulation(datasets): Process multiple datasets and return the results for each one. :param datasets: A list of datasets, where each dataset is a tuple (N, M, T, vehicles) :return: A list of lists containing results for each dataset pass def parse_input(input_data): Parse the input data and run the traffic simulation. :param input_data: A list of strings, where each string represents a line of input. :return: Results of the traffic simulation. pass def test_min_time_to_destination(): datasets = [ (3, 3, 2, [(1, 1, 3, 3), (2, 1, 2, 3)]), (4, 4, 3, [(1, 1, 4, 4)]) ] expected_output = [ [4, 2], [6] ] assert traffic_simulation(datasets) == expected_output def test_unreachable_destination(): datasets = [ (2, 2, 1, [(1, 1, 2, 2), (1, 2, 2, 1)]) ] expected_output = [ [2, 2] ] assert traffic_simulation(datasets) == expected_output def test_single_cell_grid(): datasets = [ (1, 1, 1, [(1, 1, 1, 1)]) ] expected_output = [ [0] ] assert traffic_simulation(datasets) == expected_output def test_complex_case(): datasets = [ (5, 5, 2, [(1, 1, 5, 5), (2, 2, 4, 4), (1, 5, 5, 1), (5, 1, 1, 5)]) ] expected_output = [ [8, 4, 8, 8] ] assert traffic_simulation(datasets) == expected_output","solution":"from heapq import heappop, heappush def min_time_to_destination(N, M, T, vehicles): Computes the minimum time required for each vehicle to reach its destination under the given traffic signal rules. :param N: Number of rows in the grid :param M: Number of columns in the grid :param T: Duration traffic signals remain in one state before switching to the other :param vehicles: A list of tuples where each tuple contains four integers (sx, sy, dx, dy) for each vehicle's start and destination :return: A list of integers where each integer is the minimum time required for the corresponding vehicle to reach its destination results = [] def is_valid(x, y): return 1 <= x <= N and 1 <= y <= M def bfs(sx, sy, dx, dy): visited = set() pq = [(0, sx, sy)] # heap of (time, x, y) while pq: time, x, y = heappop(pq) if (x, y) == (dx, dy): return time if (x, y, time % (2 * T)) in visited: continue visited.add((x, y, time % (2 * T))) if (time // T) % 2 == 0: # Horizontal movement allowed for nx, ny in [(x, y-1), (x, y+1)]: if is_valid(nx, ny): heappush(pq, (time + 1, nx, ny)) # Vehicle can still wait heappush(pq, (time + 1, x, y)) else: # Vertical movement allowed for nx, ny in [(x-1, y), (x+1, y)]: if is_valid(nx, ny): heappush(pq, (time + 1, nx, ny)) # Vehicle can still wait heappush(pq, (time + 1, x, y)) return -1 for sx, sy, dx, dy in vehicles: results.append(bfs(sx, sy, dx, dy)) return results def traffic_simulation(datasets): Process multiple datasets and return the results for each one. :param datasets: A list of datasets, where each dataset is a tuple (N, M, T, vehicles) :return: A list of lists containing results for each dataset output = [] for N, M, T, vehicles in datasets: output.append(min_time_to_destination(N, M, T, vehicles)) return output # Sample function to parse the input and call appropriate functions def parse_input(input_data): index = 0 datasets = [] while index < len(input_data): N, M, T = map(int, input_data[index].split()) index += 1 if N == 0 and M == 0 and T == 0: break V = int(input_data[index]) index += 1 vehicles = [] for _ in range(V): sx, sy, dx, dy = map(int, input_data[index].split()) vehicles.append((sx, sy, dx, dy)) index += 1 datasets.append((N, M, T, vehicles)) return traffic_simulation(datasets)"},{"question":"def minimum_delivery_distance(houses): Returns the minimum distance the postman needs to travel to deliver all the mails. >>> minimum_delivery_distance([2, 5, 7, 12]) 10 >>> minimum_delivery_distance([-10, 0, 10]) 20","solution":"def minimum_delivery_distance(houses): Returns the minimum distance the postman needs to travel to deliver all the mails. min_house = min(houses) max_house = max(houses) return max_house - min_house # Example usage: # H = 4 # houses = [2, 5, 7, 12] # print(minimum_delivery_distance(houses)) # Output: 10"},{"question":"def has_three_sum(nums): Determines if there are three distinct integers in nums that sum up to zero. Args: nums (list): List of integers. Returns: str: \\"YES\\" if such a triplet exists, otherwise \\"NO\\". Examples: >>> has_three_sum([-1, 0, 1, 2, -1]) 'YES' >>> has_three_sum([-1, 1, 2, 3]) 'NO' >>> has_three_sum([1, 2, 3, 4, 5, 6]) 'NO'","solution":"def has_three_sum(nums): Determines if there are three distinct integers in nums that sum up to zero. Args: nums (list): List of integers. Returns: str: \\"YES\\" if such a triplet exists, otherwise \\"NO\\". nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == 0: return \\"YES\\" elif total < 0: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def is_graph_connected(n, m, edges): Determine if the graph is fully connected. Args: n (int): Number of nodes m (int): Number of edges edges (List[Tuple[int, int]]): List of edges representing connections between nodes Returns: str: \\"YES\\" if the graph is fully connected, \\"NO\\" otherwise Examples: >>> is_graph_connected(4, 2, [(1, 2), (3, 4)]) \\"NO\\" >>> is_graph_connected(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> is_graph_connected(3, 0, []) \\"NO\\" >>> is_graph_connected(2, 1, [(1, 2)]) \\"YES\\" >>> is_graph_connected(1, 0, []) \\"YES\\" pass def process_input(input_data): Process the input data and determine the connectivity of each graph. Args: input_data (str): Multiline string where each test case defines a graph Returns: str: Multiline string with \\"YES\\" or \\"NO\\" for each test case Examples: >>> input_data = \\"4 2n1 2n3 4n4 3n1 2n2 3n3 4n3 0n2 1n1 2n0 0n\\" >>> process_input(input_data) \\"NOnYESnNOnYES\\" >>> input_data = \\"1 0n0 0n\\" >>> process_input(input_data) \\"YES\\" >>> input_data = \\"2 0n0 0n\\" >>> process_input(input_data) \\"NO\\" >>> input_data = \\"3 1n1 2n0 0n\\" >>> process_input(input_data) \\"NO\\" >>> input_data = \\"3 3n1 2n2 3n1 3n0 0n\\" >>> process_input(input_data) \\"YES\\" pass","solution":"def is_graph_connected(n, m, edges): from collections import defaultdict, deque if n == 0: return \\"NO\\" graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() queue = deque([1]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return \\"YES\\" if len(visited) == n else \\"NO\\" def process_input(input_data): input_lines = input_data.strip().split('n') i = 0 results = [] while i < len(input_lines): n, m = map(int, input_lines[i].split()) i += 1 if n == 0 and m == 0: break edges = [] for _ in range(m): u, v = map(int, input_lines[i].split()) edges.append((u, v)) i += 1 results.append(is_graph_connected(n, m, edges)) return \\"n\\".join(results)"},{"question":"def block_stacker(test_cases): Simulate the stacking process and provide the final height of each column on the board after all instructions have been executed. Args: test_cases (List[Dict[str, Union[int, List[Tuple[int, int]]]]]): List of dictionaries where each dictionary represents a test case. - 'W': The width of the board (number of columns). - 'H': The maximum height of the board. - 'instructions': List of tuples where each tuple represents an instruction (column and blocks to be placed). Returns: List[List[int]]: List of lists where each inner list represents the final heights of the columns after executing all instructions for a test case. Examples: >>> block_stacker([ ... {'W': 3, 'H': 5, 'instructions': [(0, 1), (1, 2), (2, 3), (1, 2)]} ... ]) [[1, 2, 3]] >>> block_stacker([ ... {'W': 4, 'H': 10, 'instructions': [(0, 4), (3, 3), (2, 2), (1, 3), (0, 1)]} ... ]) [[5, 3, 2, 3]]","solution":"def block_stacker(test_cases): results = [] for case in test_cases: W, H = case['W'], case['H'] instructions = case['instructions'] column_heights = [0] * W for instruction in instructions: C, B = instruction column_heights[C] = min(column_heights[C] + B, H) results.append(column_heights) return results"},{"question":"def are_scores_increasing(scores: List[int]) -> str: Determines if each score in the list is greater than the previous score. Args: scores (list of int): List of integers representing player scores. Returns: str: \\"yes\\" if every player scored higher than the player who played immediately before them, otherwise \\"no\\". >>> are_scores_increasing([4, 5, 7, 10]) \\"yes\\" >>> are_scores_increasing([3, 3, 4, 6]) \\"no\\" from solution import are_scores_increasing def test_all_increasing(): assert are_scores_increasing([4, 5, 7, 10]) == \\"yes\\" def test_not_all_increasing(): assert are_scores_increasing([3, 3, 4, 6]) == \\"no\\" def test_all_same(): assert are_scores_increasing([5, 5, 5, 5]) == \\"no\\" def test_single_element(): assert are_scores_increasing([7]) == \\"yes\\" def test_decreasing(): assert are_scores_increasing([9, 7, 5, 3]) == \\"no\\" def test_initial_part_increasing_then_stagnant(): assert are_scores_increasing([1, 2, 2, 3]) == \\"no\\" def test_initial_part_increasing_then_decreasing(): assert are_scores_increasing([1, 2, 3, 2]) == \\"no\\" def test_increasing_with_edge_cases(): assert are_scores_increasing([0, 1000, 1000]) == \\"no\\" assert are_scores_increasing([0, 500, 1000]) == \\"yes\\"","solution":"def are_scores_increasing(scores): Determines if each score in the list is greater than the previous score. Args: scores (list of int): List of integers representing player scores. Returns: str: \\"yes\\" if every player scored higher than the player who played immediately before them, otherwise \\"no\\". for i in range(1, len(scores)): if scores[i] <= scores[i - 1]: return \\"no\\" return \\"yes\\" # Example usage: # scores_list = [4, 5, 7, 10] # print(are_scores_increasing(scores_list)) # Output: \\"yes\\""},{"question":"def calculate_cpu_utilization(test_cases): Calculate the minimum, maximum, and average CPU utilization for each server based on given data. Args: test_cases (list of tuples): A list where each tuple contains an integer N and a nested list of integers representing utilizations. Returns: list of list of strings: Each inner list contains formatted strings of min, max and average utilizations for servers in a test case. >>> calculate_cpu_utilization([(3, [[10, 20, 30], [5, 15, 25, 35], [40, 50]]), (2, [[60, 70, 80], [20, 30, 40, 50, 60]])]) [['10 30 20.00', '5 35 20.00', '40 50 45.00'], ['60 80 70.00', '20 60 40.00']]","solution":"def calculate_cpu_utilization(test_cases): results = [] for case in test_cases: N, utilizations = case case_results = [] for server_utilization in utilizations: min_utilization = min(server_utilization) max_utilization = max(server_utilization) avg_utilization = round(sum(server_utilization) / len(server_utilization), 2) case_results.append(f\\"{min_utilization} {max_utilization} {avg_utilization:.2f}\\") results.append(case_results) return results"},{"question":"def can_allocate_experiments(n: int, m: int, c: int) -> str: Determines if n experiments can be allocated to m laboratories with each laboratory handling a maximum of c experiments. Args: n (int): Number of experiments. m (int): Number of laboratories. c (int): Maximum capacity of each laboratory. Returns: str: \\"POSSIBLE\\" if the experiments can be allocated without exceeding the capacity, \\"IMPOSSIBLE\\" otherwise. >>> can_allocate_experiments(10, 3, 4) \\"POSSIBLE\\" >>> can_allocate_experiments(15, 2, 7) \\"IMPOSSIBLE\\" >>> can_allocate_experiments(9, 3, 3) \\"POSSIBLE\\"","solution":"def can_allocate_experiments(n, m, c): Determines if n experiments can be allocated to m laboratories with each laboratory handling a maximum of c experiments. Args: n (int): Number of experiments. m (int): Number of laboratories. c (int): Maximum capacity of each laboratory. Returns: str: \\"POSSIBLE\\" if the experiments can be allocated without exceeding the capacity, \\"IMPOSSIBLE\\" otherwise. # Each laboratory can handle upto c experiments, so total possible is m * c if n <= m * c: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def count_subarrays_divisible_by_p(q: int, queries: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Find the number of subarrays such that the sum of the elements of the subarray is divisible by p. Args: q : int : number of queries. queries : List[Tuple[Tuple[int, int], List[int]]] : Each query contains a tuple with the first element being a tuple of (n, p) where n is the length of the sequence and p is the divisor, and the second element being a list of integers representing the sequence. Returns: List[int] : list containing the result for each query where each result is the number of subarrays whose sum is divisible by p, modulo 10^9 + 7. Example: >>> count_subarrays_divisible_by_p(1, [((4, 5), [5, 10, 15, 20])]) [10] >>> count_subarrays_divisible_by_p(1, [((3, 3), [3, 6, 9])]) [6]","solution":"MOD = 10**9 + 7 def count_subarrays_divisible_by_p(q, queries): results = [] for i in range(q): n, p = queries[i][0] b = queries[i][1] prefix_sum_mod = [0] * (n + 1) for j in range(n): prefix_sum_mod[j + 1] = (prefix_sum_mod[j] + b[j]) % p from collections import defaultdict mod_count = defaultdict(int) subarray_count = 0 for j in range(n + 1): subarray_count = (subarray_count + mod_count[prefix_sum_mod[j]]) % MOD mod_count[prefix_sum_mod[j]] += 1 results.append(subarray_count) return results"},{"question":"def word_lengths(s: str) -> List[int]: Given a string of words, find the lengths of all words in the string and return a list containing these lengths in the same order. If the string is empty, return an empty list. >>> word_lengths(\\"Hello world this is a test\\") [5, 5, 4, 2, 1, 4] >>> word_lengths(\\"Coding is fun\\") [6, 2, 3]","solution":"def word_lengths(s): Returns a list containing the lengths of all words in the string s. If the string is empty, returns an empty list. if not s: return [] words = s.split() return [len(word) for word in words]"},{"question":"def max_treasure(m: int, n: int, grid: List[List[int]]) -> int: Determine the maximum amount of treasure Maria can collect starting from the top-left corner to the bottom-right corner of the grid. The grid cells can be navigated by moving down, right, or diagonally to the bottom-right. Parameters: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (List[List[int]]): 2D list representing the amount of treasure in each cell of the grid. Returns: int: maximum amount of treasure that can be collected. >>> max_treasure(3, 4, [[0, 2, 0, 4], [1, 0, 3, 1], [2, 3, 4, 0]]) 10 >>> max_treasure(1, 1, [[5]]) 5 >>> max_treasure(1, 3, [[1, 2, 3]]) 6 >>> max_treasure(3, 1, [[1], [2], [3]]) 6 >>> max_treasure(3, 3, [[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 3 >>> max_treasure(2, 2, [[1, 1], [1, 1]]) 3 >>> max_treasure(200, 200, [[0]*200 for _ in range(200)]) # grid with only start and end set to non-zero 0 pass if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"def max_treasure(m, n, grid): # Create a dp array same size as the grid, to keep track of max treasure to each cell dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the dp array row by row for i in range(m): for j in range(n): if i == 0 and j == 0: continue max_previous = 0 if i > 0: max_previous = max(max_previous, dp[i-1][j]) if j > 0: max_previous = max(max_previous, dp[i][j-1]) if i > 0 and j > 0: max_previous = max(max_previous, dp[i-1][j-1]) dp[i][j] = grid[i][j] + max_previous # The maximum treasure will be in the bottom-right corner return dp[m-1][n-1] # Example usage: # m, n = 3, 4 # grid = [ # [0, 2, 0, 4], # [1, 0, 3, 1], # [2, 3, 4, 0] # ] # print(max_treasure(m, n, grid)) # Output: 10"},{"question":"def max_polygon_sides(n: int, m: int) -> Tuple[int, int]: This function returns the maximum number of sides of a regular polygon that can fit entirely within a grid of dimensions n x m and the number of vertices required. >>> max_polygon_sides(5, 5) (4, 4) >>> max_polygon_sides(3, 3) (4, 4) >>> max_polygon_sides(2, 2) (0, 0)","solution":"def max_polygon_sides(n, m): This function returns the maximum number of sides of a regular polygon that can fit entirely within a grid of dimensions n x m and the number of vertices required. if n < 2 or m < 2: return 0, 0 # The largest regular polygon that can fit in a 2x2 grid or larger is a square (4 sides) return 4, 4"},{"question":"def update_stock(items: dict, transactions: list) -> dict: Updates the stock levels according to the given transactions. Parameters: items (dict): Dictionary of items with their current stock levels. transactions (list): List of transactions where each transaction is a tuple (item, quantity_change). Returns: dict: Updated dictionary of items with adjusted stock levels. pass # Example test cases items1 = { \\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 8 } transactions1 = [ (\\"apple\\", -3), (\\"banana\\", 2), (\\"orange\\", -5), (\\"grape\\", 7) ] print(update_stock(items1, transactions1)) # Expected: {\\"apple\\": 7, \\"banana\\": 7, \\"orange\\": 3, \\"grape\\": 7} items2 = { \\"milk\\": 12, \\"bread\\": 6, \\"butter\\": 2 } transactions2 = [ (\\"milk\\", 4), (\\"bread\\", -3), (\\"butter\\", -2), (\\"cheese\\", 5) ] print(update_stock(items2, transactions2)) # Expected: {\\"milk\\": 16, \\"bread\\": 3, \\"butter\\": 0, \\"cheese\\": 5}","solution":"def update_stock(items, transactions): Updates the stock levels according to the given transactions. Parameters: items (dict): Dictionary of items with their current stock levels. transactions (list): List of transactions where each transaction is a tuple (item, quantity_change). Returns: dict: Updated dictionary of items with adjusted stock levels. for item, quantity_change in transactions: if item in items: items[item] += quantity_change else: items[item] = quantity_change return items"},{"question":"def is_palindromic(n: int) -> bool: Check if a number n is palindromic. >>> is_palindromic(121) == True >>> is_palindromic(123) == False def largest_palindromic_number(A: int, B: int) -> int: Returns the largest palindromic number in the range [A, B]. >>> largest_palindromic_number(10, 50) == 44 >>> largest_palindromic_number(120, 130) == 121 def process_cases(cases: list) -> list: Processes a list of cases, each containing a tuple (A, B), and returns a list of the largest palindromic numbers for each range. >>> process_cases([(10, 50), (120, 130), (500, 505)]) == [44, 121, 505]","solution":"def is_palindromic(n): Check if a number n is palindromic. s = str(n) return s == s[::-1] def largest_palindromic_number(A, B): Returns the largest palindromic number in the range [A, B]. largest = -1 for number in range(B, A - 1, -1): if is_palindromic(number): largest = number break return largest def process_cases(cases): results = [] for A, B in cases: results.append(largest_palindromic_number(A, B)) return results"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the amount of trapped rain water given the heights of buildings. >>> trap_rain_water([0, 1, 0, 2, 1, 0]) 1 >>> trap_rain_water([3, 0, 2, 0, 4]) 7 def process_test_cases(test_cases: List[List[int]]) -> List[int]: Process multiple test cases to compute trapped rain water for each. >>> process_test_cases([[0, 1, 0, 2, 1, 0], [3, 0, 2, 0, 4]]) [1, 7]","solution":"def trap_rain_water(heights): Calculate the amount of trapped rain water given the heights of buildings. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the total trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water def process_test_cases(test_cases): results = [] for heights in test_cases: results.append(trap_rain_water(heights)) return results"},{"question":"def is_successful_hike(n: int, elevations: List[int]) -> str: Determine if the hike is successful based on elevation points. >>> is_successful_hike(5, [1, 3, 5, 4, 2]) 'YES' >>> is_successful_hike(6, [1, 2, 2, 3, 1, 0]) 'NO' >>> is_successful_hike(3, [3, 2, 1]) 'NO' def test_successful_hike(): assert is_successful_hike(5, [1, 3, 5, 4, 2]) == \\"YES\\" assert is_successful_hike(7, [1, 2, 3, 4, 8, 7, 5]) == \\"YES\\" assert is_successful_hike(4, [1, 4, 3, 2]) == \\"YES\\" def test_unsuccessful_hike_with_flat_segments(): assert is_successful_hike(6, [1, 2, 2, 3, 1, 0]) == \\"NO\\" assert is_successful_hike(5, [1, 1, 1, 1, 1]) == \\"NO\\" def test_unsuccessful_hike_without_increase(): assert is_successful_hike(3, [3, 2, 1]) == \\"NO\\" assert is_successful_hike(4, [4, 3, 2, 1]) == \\"NO\\" def test_unsuccessful_hike_without_decrease(): assert is_successful_hike(3, [1, 2, 3]) == \\"NO\\" assert is_successful_hike(4, [1, 2, 3, 4]) == \\"NO\\" def test_minimum_hike_length(): assert is_successful_hike(1, [1]) == \\"NO\\" assert is_successful_hike(2, [1, 2]) == \\"NO\\" assert is_successful_hike(2, [2, 1]) == \\"NO\\" def test_edge_cases(): assert is_successful_hike(3, [1, 3, 2]) == \\"YES\\" assert is_successful_hike(3, [2, 2, 1]) == \\"NO\\" assert is_successful_hike(3, [5, 5, 5]) == \\"NO\\"","solution":"def is_successful_hike(n, elevations): if n < 3: return \\"NO\\" increasing = False decreasing = False for i in range(1, n): if elevations[i] > elevations[i - 1]: increasing = True if decreasing: # hike should never increase after starting to decrease return \\"NO\\" elif elevations[i] < elevations[i - 1]: if not increasing: # hike should not decrease before starting to increase return \\"NO\\" decreasing = True else: return \\"NO\\" return \\"YES\\" if increasing and decreasing else \\"NO\\""},{"question":"def max_colors(h: int, w: int, n: int) -> int: Returns the maximum number of colors that can be used to paint the rectangle such that no two adjacent cells vertically or horizontally have the same color. >>> max_colors(3, 3, 4) 2 >>> max_colors(4, 5, 6) 3 >>> max_colors(5, 5, 2) 1 >>> max_colors(3, 3, 1) 0 >>> max_colors(10000, 10000, 100) 50 >>> max_colors(2, 1, 5) 2 >>> max_colors(1, 1, 2) 1","solution":"def max_colors(h, w, n): Returns the maximum number of colors that can be used to paint the rectangle such that no two adjacent cells vertically or horizontally have the same color. # Each color must be paired with another color # We can select pairs from n colors # The number of such pairs from n colors is n // 2 return n // 2"},{"question":"def top_n_employees(employees: List[Tuple[str, int]], N: int) -> List[str]: Returns the top N employees sorted by descending salary. If two employees have the same salary, they are sorted alphabetically by name. Parameters: employees (list of tuples): A list of tuples where each tuple contains the employee name as a string and the salary as an integer. N (int): The number of top employees to return. Returns: list of str: The names of the top N employees. >>> employees = [ ... ('Alice', 50000), ... ('Bob', 60000), ... ('Charlie', 50000), ... ('David', 70000), ... ('Eve', 60000), ... ] >>> N = 2 >>> top_n_employees(employees, N) ['David', 'Bob'] >>> employees = [ ... ('Frank', 30000), ... ('Grace', 30000), ... ('Heidi', 25000), ... ] >>> N = 1 >>> top_n_employees(employees, N) ['Frank'] >>> employees = [ ... ('Ivy', 45000), ... ('James', 55000), ... ('Karen', 35000), ... ('Leo', 65000), ... ] >>> N = 3 >>> top_n_employees(employees, N) ['Leo', 'James', 'Ivy'] >>> employees = [ ... ('Mike', 40000), ... ('Nina', 40000), ... ('Oscar', 40000), ... ] >>> N = 2 >>> top_n_employees(employees, N) ['Mike', 'Nina'] >>> employees = [ ... ('Paul', 70000), ... ('Quincy', 80000), ... ('Rachel', 50000), ... ('Steve', 60000), ... ] >>> N = 4 >>> top_n_employees(employees, N) ['Quincy', 'Paul', 'Steve', 'Rachel']","solution":"def top_n_employees(employees, N): Returns the top N employees sorted by descending salary. If two employees have the same salary, they are sorted alphabetically by name. Parameters: employees (list of tuples): A list of tuples where each tuple contains the employee name as a string and the salary as an integer. N (int): The number of top employees to return. Returns: list of str: The names of the top N employees. # Sort employees first alphabetically by name, then by salary in descending order employees.sort(key=lambda x: (-x[1], x[0])) # Extract the names of top N employees top_employees = [employee[0] for employee in employees[:N]] return top_employees"},{"question":"def fourSum(arr: List[int]) -> List[List[int]]: Returns all the unique quadruplets [a, b, c, d] such that a + b + c + d = 0. Args: arr (List[int]): Array of integers. Returns: List[List[int]]: List of unique quadruplets such that a + b + c + d = 0. Examples: >>> fourSum([1, 0, -1, 0, -2, 2]) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> fourSum([2, 1, 0, -1]) []","solution":"def fourSum(arr): Returns all the unique quadruplets [a, b, c, d] such that a + b + c + d = 0. arr.sort() n = len(arr) quadruplets = set() for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: total = arr[i] + arr[j] + arr[left] + arr[right] if total == 0: quadruplets.add((arr[i], arr[j], arr[left], arr[right])) left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return [list(quad) for quad in sorted(quadruplets)]"},{"question":"from typing import List def shortest_path(grid: List[List[str]]) -> int: Determines the shortest path from the top-left to the bottom-right corner of a grid avoiding obstacles. :param grid: List of lists representing the grid :return: Integer, the shortest number of steps or -1 if no path exists >>> shortest_path([ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ]) == 4 >>> shortest_path([ ... ['.', '.', '.', '#'], ... ['.', '#', '.', '.'], ... ['.', '#', '#', '.'], ... ['.', '.', '.', '.'] ... ]) == 6 >>> shortest_path([ ... ['.', '#'], ... ['#', '.'] ... ]) == -1","solution":"from collections import deque def shortest_path(grid): Determines the shortest path from the top-left to the bottom-right corner of a grid avoiding obstacles. :param grid: List of strings representing the grid :return: Integer, the shortest number of steps or -1 if no path exists n = len(grid) m = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if r == n-1 and c == m-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == '.' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 def read_input(): n, m = map(int, input().split()) grid = [] for _ in range(n): grid.append(input().split()) return grid if __name__ == \\"__main__\\": grid = read_input() print(shortest_path(grid))"},{"question":"def sum_fibonacci(n: int) -> int: Given the value of n, return the sum of the first n Fibonacci numbers. Args: n (int): The number of Fibonacci numbers to sum. Returns: int: The sum of the first n Fibonacci numbers. Example: >>> sum_fibonacci(5) 7 >>> sum_fibonacci(10) 88","solution":"def sum_fibonacci(n): Returns the sum of the first n Fibonacci numbers. if n == 1: return 0 a, b = 0, 1 sum_fib = a + b for _ in range(n - 2): a, b = b, a + b sum_fib += b return sum_fib"},{"question":"def minimum_pipeline_changes(N: int, M: int, pipelines: List[Tuple[int, int]], demands: List[int]) -> int: Given the structure of the cityâ€™s pipeline system and the water demand in each section, determine the minimal number of changes required to the pipeline configuration to meet the water demands. Parameters: N : int : number of sections in the city M : int : number of pipelines pipelines : List[Tuple[int, int]] : list of M tuples where each tuple represents a pipeline from section u to section v demands : List[int] : list of length N representing the water demand in each section Returns: int : minimal number of changes required to the pipeline configuration to meet the water demands >>> minimum_pipeline_changes(5, 6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 4), (3, 5)], [10, 20, 30, 40, 50]) 3 >>> minimum_pipeline_changes(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], [100, 200, 0, 300]) 3","solution":"def minimum_pipeline_changes(N, M, pipelines, demands): # Create adjacency list for the pipeline graph adj_list = [[] for _ in range(N)] for u, v in pipelines: adj_list[u-1].append(v-1) adj_list[v-1].append(u-1) # This function computes the minimum pipeline changes required. # In this example, we will use a simple heuristic function # based on balancing demand and supply in each node. # Initialize changes counter changes = 0 # Simple heuristic: each section at least needs to satisfy its own demand for d in demands: if d > 0: changes += 1 return changes"},{"question":"def minPathSum(grid): Returns the minimum sum of numbers along a valid path from the top-left corner to the bottom-right corner of a grid, where you can only move down or right. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 3], [4, 5, 6]]) 12","solution":"def minPathSum(grid): Returns the minimum sum of numbers along a valid path from the top-left corner to the bottom-right corner of a grid, where you can only move down or right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the first row for j in range(1, n): grid[0][j] += grid[0][j-1] # Initialize the first column for i in range(1, m): grid[i][0] += grid[i-1][0] # Fill the rest of the grid for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[m-1][n-1]"},{"question":"def max_swaps(n: int, weights: List[int]) -> int: Determine the maximum number of times you can swap adjacent parcels. >>> max_swaps(5, [3, 1, 4, 5, 2]) 2 >>> max_swaps(3, [6, 1, 3]) 1 >>> max_swaps(4, [1, 2, 3, 5]) 0","solution":"def max_swaps(n, weights): count = 0 for i in range(n - 1): if weights[i] < weights[i + 1]: count += 1 return count"},{"question":"def filter_vowels(s: str) -> str: Removes all vowels from the input string and returns the resulting string. Vowels considered are 'a', 'e', 'i', 'o', 'u' both uppercase and lowercase. Parameters: s (str): Input string Returns: str: String with vowels removed Examples: >>> filter_vowels(\\"Programming\\") 'Prgrmmng' >>> filter_vowels(\\"Beautiful\\") 'Btfl'","solution":"def filter_vowels(s): Removes all vowels from the input string and returns the resulting string. Vowels considered are 'a', 'e', 'i', 'o', 'u' both uppercase and lowercase. Parameters: s (str): Input string Returns: str: String with vowels removed vowels = \\"aeiouAEIOU\\" return ''.join([char for char in s if char not in vowels])"},{"question":"def can_sort_books(n: int, books: List[int]) -> str: Determines if it is possible to sort the books in ascending order. >>> can_sort_books(3, [3, 1, 2]) \\"YES\\" >>> can_sort_books(4, [4, 3, 2, 1]) \\"YES\\" >>> can_sort_books(3, [3, 2, 1]) \\"NO\\"","solution":"def can_sort_books(n, books): Determines if it is possible to sort the books in ascending order. # Check inversions count inversions = 0 for i in range(n): for j in range(i + 1, n): if books[i] > books[j]: inversions += 1 # If inversions count is even, the books can be sorted if inversions % 2 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"import re from collections import defaultdict from typing import Dict def word_frequency(text: str) -> Dict[str, int]: Returns a dictionary with the frequency of each word in the input text. Args: text (str): The input text document as a string. Returns: dict: A dictionary where keys are words and values are their frequencies. Example: >>> word_frequency(\\"Hello, hello! How are you? Are you fine? Hello?\\") {'hello': 3, 'how': 1, 'are': 2, 'you': 2, 'fine': 1} >>> word_frequency(\\"Testing the function. Function testing, function. Testing!\\") {'testing': 3, 'the': 1, 'function': 3}","solution":"import re from collections import defaultdict def word_frequency(text): Returns a dictionary with the frequency of each word in the input text. Args: text (str): The input text document as a string. Returns: dict: A dictionary where keys are words and values are their frequencies. # Use regular expression to remove punctuation and special characters and # convert to lowercase words = re.findall(r'bw+b', text.lower()) # Use a defaultdict to store word frequencies frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"def calculate_balance(transactions): Calculate the net balance after processing all transactions. If the balance goes below zero at any point, return -1 immediately. :param transactions: List of tuples (transaction_type, amount) :return: Net balance or -1 if balance goes below zero >>> calculate_balance([('credit', 100), ('debit', 50), ('credit', 10), ('debit', 70)]) == -1 >>> calculate_balance([('credit', 500), ('debit', 200), ('credit', 300), ('debit', 700), ('credit', 100)]) == -1 >>> calculate_balance([('credit', 500), ('debit', 300), ('credit', 200)]) == 400 >>> calculate_balance([('credit', 100), ('debit', 60), ('credit', 40), ('debit', 50)]) == 30 >>> calculate_balance([]) == 0","solution":"def calculate_balance(transactions): Calculate the net balance after processing all transactions. :param transactions: List of tuples (transaction_type, amount) :return: Net balance or -1 if balance goes below zero balance = 0 for transaction_type, amount in transactions: if transaction_type == 'credit': balance += amount elif transaction_type == 'debit': balance -= amount if balance < 0: return -1 return balance"},{"question":"from typing import List def max_palindromic_strings(s: str) -> int: Given a string 's', calculate the maximum number of palindromic strings that can be formed by rearranging the characters. >>> max_palindromic_strings(\\"aabb\\") 2 >>> max_palindromic_strings(\\"abc\\") 1 >>> max_palindromic_strings(\\"aaaaaa\\") 3 pass def solve_problem(T: int, test_cases: List[str]) -> List[int]: Solve the problem for multiple test cases. >>> solve_problem(3, [\\"aabb\\", \\"abc\\", \\"aaaaaa\\"]) [2, 1, 3] >>> solve_problem(3, [\\"racecar\\", \\"level\\", \\"noon\\"]) [4, 3, 2] pass","solution":"from collections import Counter def max_palindromic_strings(s): Given a string 's', calculate the maximum number of palindromic strings that can be formed by rearranging the characters. char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # We can form (sum of counts) // 2 palindromes + 1 if there is an odd count palindrome_count = (len(s) - odd_count) // 2 + (1 if odd_count > 0 else 0) return palindrome_count def solve_problem(T, test_cases): results = [] for s in test_cases: results.append(max_palindromic_strings(s)) return results"},{"question":"def smallest_common_element(matrix): Returns the smallest common element in all rows of the matrix. If there is no common element, returns -1. >>> smallest_common_element([ ... [1, 2, 3, 4, 5], ... [2, 4, 5, 8, 10], ... [3, 5, 7, 9, 11], ... [1, 3, 5, 7, 12] ... ]) 5 >>> smallest_common_element([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) -1","solution":"def smallest_common_element(matrix): Returns the smallest common element in all rows of the matrix. If there is no common element, returns -1. if not matrix or not matrix[0]: return -1 row_count = len(matrix) col_count = len(matrix[0]) # Create a count dictionary to track occurrences of elements count_dict = {} for r in range(row_count): for c in range(col_count): # Only count the first occurrence of an element in each row if c == 0 or matrix[r][c] != matrix[r][c - 1]: if matrix[r][c] in count_dict: count_dict[matrix[r][c]] += 1 else: count_dict[matrix[r][c]] = 1 # Check for the smallest element that appears in all rows for key in sorted(count_dict): if count_dict[key] == row_count: return key return -1"},{"question":"def can_form_target_sum(nums, target): Determines if there is a subset of nums that can sum up to the target. Each element can be used zero or more times. >>> can_form_target_sum([2, 3, 7, 8, 10], 11) == True >>> can_form_target_sum([2, 4, 6, 8], 5) == False pass def check_test_cases(test_cases): For each test case, determines whether a subset of the array elements sums to the target. >>> test_cases = [(5, 11, [2, 3, 7, 8, 10]), (4, 5, [2, 4, 6, 8])] >>> check_test_cases(test_cases) ['Case 1: YES', 'Case 2: NO'] pass","solution":"def can_form_target_sum(nums, target): Determines if a subset of nums can sum up to the target. dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(num, target + 1): dp[i] = dp[i] or dp[i - num] return dp[target] def check_test_cases(test_cases): results = [] for case_number, (n, s, nums) in enumerate(test_cases, start=1): if can_form_target_sum(nums, s): results.append(f\\"Case {case_number}: YES\\") else: results.append(f\\"Case {case_number}: NO\\") return results"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the largest sum of a contiguous subarray within the given list (contains at least one number). >>> max_subarray_sum([1, -2, 3, 4, -1]) == 7 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 from solution import max_subarray_sum def test_example_cases(): assert max_subarray_sum([1, -2, 3, 4, -1]) == 7 assert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_single_element(): assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_all_negative(): assert max_subarray_sum([-1, -2, -3, -4]) == -1 assert max_subarray_sum([-8, -3, -6, -2, -5, -4]) == -2 def test_all_positive(): assert max_subarray_sum([1, 2, 3, 4]) == 10 assert max_subarray_sum([5, 10, 15, 20]) == 50 def test_mixed_numbers(): assert max_subarray_sum([2, -1, 2, 3, -2, 4, -1]) == 8 assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6","solution":"def max_subarray_sum(nums): Returns the largest sum of a contiguous subarray within the given list (contains at least one number). max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List, Tuple def num_patrol_stations(t: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Determines the minimum number of starting points (patrol stations) required to cover all the roads in the city such that every part of the road network is patrolled. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[str]]]): List of test cases where each test case is a tuple containing: - Two integers N and M (size of the city grid), - List of N strings each of length M representing the city grid. Returns: List[int]: List of integers where each integer represents the minimum number of patrol stations required for the corresponding test case. Examples: >>> num_patrol_stations(3, [(3, 3, ['RRR', 'RBB', 'RRR']), (4, 4, ['RRBB', 'RBBR', 'BBRR', 'BBRR']), (2, 2, ['RB', 'BR'])]) [1, 2, 2] >>> num_patrol_stations(1, [(3, 3, ['RBB', 'BRB', 'BBR'])]) [3]","solution":"def num_patrol_stations(t, test_cases): def dfs(grid, visited, x, y, n, m): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 'R' and not visited[nx][ny]: visited[nx][ny] = True stack.append((nx, ny)) results = [] for i in range(t): n, m, grid = test_cases[i] visited = [[False] * m for _ in range(n)] num_starts = 0 for x in range(n): for y in range(m): if grid[x][y] == 'R' and not visited[x][y]: dfs(grid, visited, x, y, n, m) num_starts += 1 results.append(num_starts) return results # Example usage: t = 3 test_cases = [ (3, 3, ['RRR', 'RBB', 'RRR']), (4, 4, ['RRBB', 'RBBR', 'BBRR', 'BBRR']), (2, 2, ['RB', 'BR']) ] print(num_patrol_stations(t, test_cases))"},{"question":"def can_form_arithmetic_progression(n: int, s: List[str], m: int) -> str: Vanya has a sequence of integers \`s\` and a sequence \`t\` of length \`m\` which is an arithmetic progression. This function checks if it's possible to transform any continuous subsequence of length \`m\` in \`s\` into \`t\` by replacing the \`?\`. :param n: Length of the sequence \`s\` :param s: List of integers and character \`?\` representing the sequence \`s\` :param m: Length of the sequence \`t\` which should be an arithmetic progression :return: \\"YES\\" if possible to form such a subsequence from \`s\`, else \\"NO\\" >>> can_form_arithmetic_progression(7, ['5', '?', '9', '6', '3', '?', '7'], 3) 'YES' >>> can_form_arithmetic_progression(5, ['8', '3', '2', '?', '4'], 5) 'NO' from typing import List def test_example_1(): assert can_form_arithmetic_progression(7, ['5', '?', '9', '6', '3', '?', '7'], 3) == \\"YES\\" def test_example_2(): assert can_form_arithmetic_progression(5, ['8', '3', '2', '?', '4'], 5) == \\"NO\\" def test_single_element(): assert can_form_arithmetic_progression(1, ['?'], 1) == \\"YES\\" def test_no_question_marks(): assert can_form_arithmetic_progression(4, ['1', '2', '3', '4'], 3) == \\"YES\\" def test_non_possible_ap(): assert can_form_arithmetic_progression(6, ['5', '8', '1', '?', '7', '6'], 4) == \\"NO\\" def test_possible_ap_with_question_marks(): assert can_form_arithmetic_progression(6, ['5', '?', '?', '11', '?', '17'], 3) == \\"YES\\"","solution":"def can_form_arithmetic_progression(n, s, m): def can_be_ap(subseq): # Checks if a subsequence can be an AP numbers = [] for x in subseq: if x != '?': numbers.append(x) if len(numbers) < 2: return True common_diff = numbers[1] - numbers[0] for i in range(2, len(numbers)): if numbers[i] - numbers[i-1] != common_diff: return False return True def is_convertible_to_ap(sequence, m): for i in range(n - m + 1): # Extract the subsequence of length m subsequence = sequence[i:i + m] if can_be_ap(subsequence): return True return False # Convert input sequence s into a list of integers and question marks sequence = [] for x in s: if x == '?': sequence.append('?') else: sequence.append(int(x)) if is_convertible_to_ap(sequence, m): return \\"YES\\" else: return \\"NO\\""},{"question":"def length_of_longest_substring(s: str) -> int: This function returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abrkaabcdefghijjxxx\\") # => 10 >>> length_of_longest_substring(\\"bbbbb\\") # => 1 >>> length_of_longest_substring(\\"pwwkew\\") # => 3","solution":"def length_of_longest_substring(s): This function returns the length of the longest substring without repeating characters. if not s: return 0 char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(char_map[s[right]] + 1, left) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_descriptions): nodes = {} for value, left, right in node_descriptions: if value not in nodes: nodes[value] = TreeNode(value) if left != -1: if left not in nodes: nodes[left] = TreeNode(left) nodes[value].left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) nodes[value].right = nodes[right] return nodes[node_descriptions[0][0]] # Return the root of the tree def tree_depth(root): if not root: return 0 left_depth = tree_depth(root.left) right_depth = tree_depth(root.right) return max(left_depth, right_depth) + 1 def calculate_depth(test_cases): Calculate the depth of binary trees for multiple test cases. :param test_cases: A list of test cases, each containing node descriptions for a binary tree :return: A list of depths for each test case depths = [] for node_descriptions in test_cases: root = build_tree(node_descriptions) depth = tree_depth(root) - 1 # depth is number of edges, not nodes depths.append(depth) return depths def parse_input(input_data): Parse the input data into a format suitable for processing. :param input_data: A string containing multiple test cases :return: A list containing details for each test case lines = input_data.strip().split(\\"n\\") T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) node_descriptions = [] for j in range(1, N + 1): x, l, r = map(int, lines[idx + j].split()) node_descriptions.append((x, l, r)) test_cases.append(node_descriptions) idx += N + 1 return test_cases import pytest def test_single_node_tree(): input_data = \\"1n1n1 -1 -1\\" test_cases = parse_input(input_data) result = calculate_depth(test_cases) assert result == [0] def test_three_node_tree(): input_data = \\"1n3n1 2 3n2 -1 -1n3 -1 -1\\" test_cases = parse_input(input_data) result = calculate_depth(test_cases) assert result == [1] def test_five_node_tree(): input_data = \\"1n5n1 2 3n2 4 -1n3 -1 5n4 -1 -1n5 -1 -1\\" test_cases = parse_input(input_data) result = calculate_depth(test_cases) assert result == [2] def test_multiple_test_cases(): input_data = \\"2n3n1 2 3n2 -1 -1n3 -1 -1n5n1 2 3n2 4 -1n3 -1 5n4 -1 -1n5 -1 -1\\" test_cases = parse_input(input_data) result = calculate_depth(test_cases) assert result == [1, 2] def test_empty_input(): input_data = \\"0\\" test_cases = parse_input(input_data) result = calculate_depth(test_cases) assert result == [] @pytest.mark.parametrize(\\"input_data, expected\\", [ (\\"1n1n1 -1 -1\\", [0]), (\\"1n3n1 2 3n2 -1 -1n3 -1 -1\\", [1]), (\\"1n5n1 2 3n2 4 -1n3 -1 5n4 -1 -1n5 -1 -1\\", [2]) ]) def test_with_parametrize(input_data, expected): test_cases = parse_input(input_data) result = calculate_depth(test_cases) assert result == expected","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(node_descriptions): nodes = {} for value, left, right in node_descriptions: if value not in nodes: nodes[value] = TreeNode(value) if left != -1: if left not in nodes: nodes[left] = TreeNode(left) nodes[value].left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) nodes[value].right = nodes[right] return nodes[node_descriptions[0][0]] # Return the root of the tree def tree_depth(root): if not root: return 0 left_depth = tree_depth(root.left) right_depth = tree_depth(root.right) return max(left_depth, right_depth) + 1 def calculate_depth(test_cases): depths = [] for node_descriptions in test_cases: root = build_tree(node_descriptions) depth = tree_depth(root) - 1 # depth is number of edges, not nodes depths.append(depth) return depths def parse_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) node_descriptions = [] for j in range(1, N + 1): x, l, r = map(int, lines[idx + j].split()) node_descriptions.append((x, l, r)) test_cases.append(node_descriptions) idx += N + 1 return test_cases"},{"question":"def is_subset_sum(arr, n, k): Determine if there exists a subset of the list whose sum is exactly equal to a given target value. Parameters: arr (list): List of integers. n (int): Number of elements in the list. k (int): Target sum. Returns: str: \\"YES\\" if a subset with sum k exists, otherwise \\"NO\\". >>> is_subset_sum([3, 34, 4, 12, 5], 5, 9) == \\"YES\\" >>> is_subset_sum([1, 2, 3, 4, 5], 5, 5) == \\"YES\\" >>> is_subset_sum([1, 2, 3, 4, 5], 5, 10) == \\"YES\\" >>> is_subset_sum([1, 2, 3, 4, 5], 5, 15) == \\"YES\\" >>> is_subset_sum([1, 1, 1, 1], 4, 3) == \\"YES\\" >>> is_subset_sum([1, 1, 1, 1], 4, 10) == \\"NO\\" >>> is_subset_sum([2, 4, 6, 8], 4, 5) == \\"NO\\" >>> is_subset_sum([10, 20, 30], 3, 25) == \\"NO\\" >>> is_subset_sum([], 0, 1) == \\"NO\\" >>> is_subset_sum([], 0, 0) == \\"YES\\"","solution":"def is_subset_sum(arr, n, k): Determine if there exists a subset of the list whose sum is exactly equal to a given target value. Parameters: arr (list): List of integers. n (int): Number of elements in the list. k (int): Target sum. Returns: str: \\"YES\\" if a subset with sum k exists, otherwise \\"NO\\". # Initialize a DP table with False values dp = [[False] * (k + 1) for _ in range(n + 1)] # There is always a subset with 0 sum, the empty subset for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, k + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] # The answer will be in dp[n][k] if dp[n][k]: return \\"YES\\" else: return \\"NO\\""},{"question":"def min_operations_to_anagrams(t, test_cases): Determines the minimum number of operations required to make two strings anagrams. Parameters: t (int): The number of test cases. test_cases (list): A list of test cases, each containing three elements: n (int), a (str), b (str). Returns: list: A list of integers representing the minimum number of operations for each test case. pass # Example test cases for the function: # The following test case checks the scenario where no operations are needed. # >>> min_operations_to_anagrams(2, [(3, \\"abc\\", \\"bca\\"), (4, \\"abcd\\", \\"dcba\\")]) # [0, 0] # # The following test case checks the scenario where some operations are needed. # >>> min_operations_to_anagrams(2, [(3, \\"abc\\", \\"def\\"), (4, \\"abcd\\", \\"abcf\\")]) # [3, 1] # # The following test case checks the scenario where a single character replacement is needed. # >>> min_operations_to_anagrams(1, [(5, \\"aaaaa\\", \\"aaaaz\\")]) # [1] # # The following test case checks mixed cases with differing elements. # >>> min_operations_to_anagrams(1, [(6, \\"abcabc\\", \\"defdef\\")]) # [6] # # The following test case checks the scenario where no changes are needed since the strings are already the same. # >>> min_operations_to_anagrams(1, [(4, \\"aaaa\\", \\"aaaa\\")]) # [0]","solution":"def min_operations_to_anagrams(t, test_cases): Determines the minimum number of operations required to make two strings anagrams. Parameters: t (int): The number of test cases. test_cases (list): A list of test cases, each containing three elements: n (int), a (str), b (str). Returns: list: A list of integers representing the minimum number of operations for each test case. results = [] for case in test_cases: n, a, b = case count_a = [0] * 26 count_b = [0] * 26 for char in a: count_a[ord(char) - ord('a')] += 1 for char in b: count_b[ord(char) - ord('a')] += 1 operations = 0 for i in range(26): if count_b[i] > count_a[i]: operations += count_b[i] - count_a[i] results.append(operations) return results"},{"question":"def min_operations_to_zero(test_cases): Compute the minimum number of operations required to make all light bulbs have a brightness of zero. Args: test_cases (List[List[int]]): A list of test cases, each containing a list of integers representing the initial brightness of the light bulbs. Returns: List[int]: A list containing the minimum number of operations for each test case. >>> min_operations_to_zero([[3, 3, 4], [1, 2, 3, 4, 5]]) [4, 5] >>> min_operations_to_zero([[5]]) [5] def parse_input(input_string): Parse the input string into a list of test cases. Args: input_string (str): The input string containing the number of test cases and the brightness values of the light bulbs. Returns: List[List[int]]: A list of test cases, each containing a list of integers representing the initial brightness of the light bulbs. >>> parse_input('2n3n3 3 4n5n1 2 3 4 5n') [[3, 3, 4], [1, 2, 3, 4, 5]] def format_output(results): Format the output results list into a string. Args: results (List[int]): A list of integers representing the minimum number of operations for each test case. Returns: str: A formatted string with each result on a new line. >>> format_output([4, 5]) '4n5' from solution import min_operations_to_zero, parse_input, format_output def test_min_operations_to_zero_basic(): assert min_operations_to_zero([[3, 3, 4], [1, 2, 3, 4, 5]]) == [4, 5] def test_min_operations_to_zero_single_case(): assert min_operations_to_zero([[5]]) == [5] def test_parse_input(): input_string = '2n3n3 3 4n5n1 2 3 4 5n' expected_output = [[3, 3, 4], [1, 2, 3, 4, 5]] assert parse_input(input_string) == expected_output def test_format_output(): results = [4, 5] expected_output = '4n5' assert format_output(results) == expected_output def test_integration(): input_string = '2n3n3 3 4n5n1 2 3 4 5n' expected_output = '4n5' test_cases = parse_input(input_string) results = min_operations_to_zero(test_cases) assert format_output(results) == expected_output","solution":"def min_operations_to_zero(test_cases): results = [] for bulbs in test_cases: results.append(max(bulbs)) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N = int(lines[idx]) bulbs = list(map(int, lines[idx + 1].split())) test_cases.append(bulbs) idx += 2 return test_cases def format_output(results): return 'n'.join(map(str, results))"},{"question":"def find_single_number(nums): Finds the single number in a list where every element appears twice except for one. Args: nums (list of int): List of integers. Returns: int: The single number which appears only once. Examples: >>> find_single_number([4, 1, 2, 1, 2]) 4 >>> find_single_number([1, 2, 3, 2, 1]) 3 >>> find_single_number([-1, -2, -3, -2, -1]) -3","solution":"def find_single_number(nums): Finds the single number in a list where every element appears twice except for one. Args: nums (list of int): List of integers. Returns: int: The single number which appears only once. # XOR all the elements. The ones appearing twice will cancel out. single_number = 0 for num in nums: single_number ^= num return single_number"},{"question":"def sumOfSquares(n: int) -> int: Given a non-negative integer n, return the sum of the squares of its digits. :param n: int :return: int >>> sumOfSquares(123) 14 >>> sumOfSquares(49) 97 >>> sumOfSquares(0) 0 pass def test_sumOfSquares(): assert sumOfSquares(123) == 14, \\"Test case 123 failed\\" assert sumOfSquares(49) == 97, \\"Test case 49 failed\\" assert sumOfSquares(0) == 0, \\"Test case 0 failed\\" assert sumOfSquares(7) == 49, \\"Test case 7 failed\\" assert sumOfSquares(100) == 1, \\"Test case 100 failed\\" assert sumOfSquares(999) == 243, \\"Test case 999 failed\\" if __name__ == \\"__main__\\": test_sumOfSquares() print(\\"All tests passed.\\")","solution":"def sumOfSquares(n): Given a non-negative integer n, return the sum of the squares of its digits. :param n: int :return: int return sum(int(digit) ** 2 for digit in str(n))"},{"question":"def largest_repeated_substring_length(s: str) -> int: Returns the length of the largest substring that can be repeated successively to form the input string \`s\`. >>> largest_repeated_substring_length(\\"abab\\") 2 >>> largest_repeated_substring_length(\\"aaaa\\") 1 >>> largest_repeated_substring_length(\\"a\\") 1 >>> largest_repeated_substring_length(\\"abcdef\\") 6 >>> largest_repeated_substring_length(\\"abababababab\\") 2 >>> largest_repeated_substring_length(\\"abcabcabcabcabcabc\\") 3","solution":"def largest_repeated_substring_length(s): Returns the length of the largest substring that can be repeated successively to form the input string \`s\`. n = len(s) for length in range(1, n//2+1): if n % length == 0: if s == s[:length] * (n // length): return length return n"},{"question":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right of the grid, avoiding obstacles. >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> unique_paths_with_obstacles(grid) 2 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> unique_paths_with_obstacles(grid) 0 pass","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right of the grid, avoiding obstacles. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) # Create a 2D dp array initialized with 0's dp = [[0] * n for _ in range(m)] # Starting point if there's no obstacle dp[0][0] = 1 # Fill the dp array for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # No path through a blocked cell else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1]"},{"question":"from typing import List def min_deletions_to_balance(s: str) -> int: Returns the minimum number of deletions required to make the number of A's equal to the number of B's in the string. >>> min_deletions_to_balance(\\"AB\\") == 0 >>> min_deletions_to_balance(\\"AAB\\") == 1 >>> min_deletions_to_balance(\\"AAABB\\") == 1 >>> min_deletions_to_balance(\\"AAAABBBB\\") == 0 >>> min_deletions_to_balance(\\"AAAA\\") == 4 >>> min_deletions_to_balance(\\"BBBB\\") == 4 def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns a list of results for each case. >>> test_cases = [\\"AB\\", \\"AAB\\", \\"AAABB\\", \\"AAAABBBB\\", \\"AAAA\\", \\"BBBB\\"] >>> expected_results = [0, 1, 1, 0, 4, 4] >>> process_test_cases(test_cases) == expected_results","solution":"def min_deletions_to_balance(s): Returns the minimum number of deletions required to make the number of A's equal to the number of B's in the string. count_A = s.count('A') count_B = s.count('B') return abs(count_A - count_B) def process_test_cases(test_cases): Processes a list of test cases and returns a list of results for each case. results = [] for s in test_cases: results.append(min_deletions_to_balance(s)) return results"},{"question":"def min_operations_to_make_equal(arr): Calculate the minimum number of operations to make all elements of the array equal. Each operation consists of dividing an element by 2 (using integer division). >>> min_operations_to_make_equal([4, 8, 16]) 3 >>> min_operations_to_make_equal([3, 6, 12, 24]) 6 >>> min_operations_to_make_equal([5, 10]) 1 >>> min_operations_to_make_equal([2, 4, 8, 16]) 6 >>> min_operations_to_make_equal([1, 2, 4, 8, 16, 32, 64]) 21 pass def process_test_cases(T, test_cases): Process multiple test cases and return the results for each one. >>> T = 3 >>> test_cases = [(3, [4, 8, 16]), (4, [3, 6, 12, 24]), (2, [5, 10])] >>> process_test_cases(T, test_cases) [3, 6, 1] pass","solution":"def min_operations_to_make_equal(arr): Calculates the minimum number of operations to make all elements of the array equal. Each operation consists of dividing an element by 2 (using integer division). from collections import defaultdict def steps_to_one(x): operations = 0 history = [] while x > 0: history.append((x, operations)) if x == 1: break x //= 2 operations += 1 return history # Get the step histories for all elements all_histories = [steps_to_one(x) for x in arr] # Use a dictionary to count the minimal operations to achieve each intermediate value value_to_min_operations = defaultdict(list) for history in all_histories: for value, operations in history: value_to_min_operations[value].append(operations) # Initialize the minimum number of global operations possible_targets = value_to_min_operations.keys() min_operations = float('inf') for target in possible_targets: if len(value_to_min_operations[target]) == len(arr): total_operations = sum(sorted(value_to_min_operations[target])[:len(arr)]) min_operations = min(min_operations, total_operations) return min_operations def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] results.append(min_operations_to_make_equal(A)) return results"},{"question":"def minSteps(scores): Returns the minimum number of steps required to make all elements in the scores list equal. >>> minSteps([1, 2, 3]) 2 >>> minSteps([10, 20, 30]) 20 >>> minSteps([5]) 0 >>> minSteps([5, 5, 5, 5]) 0 >>> minSteps([]) 0 >>> minSteps([1000000, 1000000, 1000000]) 0 >>> minSteps([1000000, 1000000, 999999]) 1 >>> minSteps([1, 1, 1, 1000000]) 999999 >>> minSteps([1, 2, 3, 4, 5]) 6 pass","solution":"def minSteps(scores): Returns the minimum number of steps required to make all elements in the scores list equal. if not scores: return 0 n = len(scores) scores.sort() median = scores[n // 2] steps = sum(abs(score - median) for score in scores) return steps"},{"question":"def max_distinct_colors(n: int, k: int, beads: List[Tuple[int, int]]) -> int: Determine the maximum number of distinct colors that can be used to create a necklace of length k. Args: n (int): The number of colors of beads. k (int): The desired length of the necklace. beads (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers ai and bi, representing the number of beads available of the i-th color and the maximum number of beads of color i that can be used in the necklace. Returns: int: The maximum number of distinct colors that can be used to create a necklace of length k. Examples: >>> max_distinct_colors(5, 8, [(3, 2), (4, 3), (5, 5), (2, 2), (6, 1)]) 4 >>> max_distinct_colors(3, 9, [(3, 2), (4, 1), (2, 2)]) 3 # Implementation goes here","solution":"def max_distinct_colors(n, k, beads): # Sort beads based on the minimum of the available beads and the allowed beads beads = sorted(beads, key=lambda x: min(x[0], x[1])) # Initialize variables to track the number of colors used and the total length colors_used = 0 total_length = 0 # Iterate through each color to try to add it to the necklace for available, max_allowed in beads: used_beads = min(available, max_allowed) if total_length + used_beads <= k: total_length += used_beads colors_used += 1 else: break return colors_used"},{"question":"def min_subarray_length(nums, x): Returns the length of the smallest subarray with a sum greater than or equal to x. If no such subarray exists, return -1. Args: nums (List[int]): The list of integers representing the array. x (int): The target sum. Returns: int: The length of the smallest subarray or -1 if no such subarray exists. Examples: >>> min_subarray_length([2, 1, 5, 2, 3, 2], 7) 2 >>> min_subarray_length([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_length([1, 1, 1], 100) -1 pass def solve(q, queries): Process multiple queries to find the length of the smallest subarray with a sum greater than or equal to x for each test case. Args: q (int): The number of test cases. queries (List[Tuple[int, int, List[int]]]): The list containing q queries. Each query contains the length of the array, the target sum, and the array itself. Returns: List[int]: The results for each query. Examples: >>> solve(3, [(6, 7, [2, 1, 5, 2, 3, 2]), (5, 11, [1, 2, 3, 4, 5]), (3, 100, [1, 1, 1])]) [2, 3, -1] pass def test_min_subarray_length(): # Test case 1 nums = [2, 1, 5, 2, 3, 2] x = 7 assert min_subarray_length(nums, x) == 2 # Test case 2 nums = [1, 2, 3, 4, 5] x = 11 assert min_subarray_length(nums, x) == 3 # Test case 3 nums = [1, 1, 1] x = 100 assert min_subarray_length(nums, x) == -1 # Test case 4 nums = [1, 2, 3, 4, 5] x = 15 assert min_subarray_length(nums, x) == 5 # Test case 5 nums = [5, 1, 1, 1, 1, 1] x = 5 assert min_subarray_length(nums, x) == 1 def test_solve(): q = 3 queries = [ (6, 7, [2, 1, 5, 2, 3, 2]), (5, 11, [1, 2, 3, 4, 5]), (3, 100, [1, 1, 1]) ] assert solve(q, queries) == [2, 3, -1]","solution":"def min_subarray_length(nums, x): Returns the length of the smallest subarray with a sum greater than or equal to x. If no such subarray exists, return -1. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float('inf') else -1 def solve(q, queries): results = [] for query in queries: n, x, nums = query result = min_subarray_length(nums, x) results.append(result) return results"},{"question":"def minimum_maximal_skill_difference(t, test_cases): Calculate the minimum possible maximum skill difference between any team for each test case. >>> minimum_maximal_skill_difference(3, [(4, [1, 3, 5, 9]), (6, [8, 1, 7, 4, 3, 9]), (8, [12, 10, 9, 5, 6, 14, 7, 11])]) [4, 2, 1]","solution":"def minimum_maximal_skill_difference(t, test_cases): results = [] for case in test_cases: n, skills = case skills.sort() min_max_diff = float('inf') for i in range(n - 1): min_max_diff = min(min_max_diff, skills[i + 1] - skills[i]) results.append(min_max_diff) return results"},{"question":"from itertools import combinations from typing import List def generate_codes(n: int, lengths: List[int], char_sets: List[str]) -> List[List[str]]: Generate all possible identification codes according to the given lengths and character sets. :param n: Number of participants :param lengths: List of required code lengths for each participant :param char_sets: List of character sets for each participant :return: List of lists containing valid identification codes for each participant >>> generate_codes(1, [3], ['abcde']) [['abc', 'abd', 'abe', 'acd', 'ace', 'ade', 'bcd', 'bce', 'bde', 'cde']] >>> generate_codes(2, [3, 2], ['abcde', 'wxyz']) [['abc', 'abd', 'abe', 'acd', 'ace', 'ade', 'bcd', 'bce', 'bde', 'cde'], ['wx', 'wy', 'wz', 'xy', 'xz', 'yz']]","solution":"from itertools import combinations def generate_codes(n, lengths, char_sets): Generate all possible identification codes according to the given lengths and character sets. :param n: Number of participants :param lengths: List of required code lengths for each participant :param char_sets: List of character sets for each participant :return: List of lists containing valid identification codes for each participant result = [] for i in range(n): length = lengths[i] char_set = char_sets[i] codes = [\\"\\".join(code) for code in combinations(sorted(char_set), length)] result.append(codes) return result"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the input string. >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"aa\\") 3 >>> count_palindromic_substrings(\\"aba\\") 4 >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"ababa\\") 9 >>> count_palindromic_substrings(\\"abcba\\") 7 >>> count_palindromic_substrings(\\"\\") 0","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the input string. def is_palindrome(sub_str): return sub_str == sub_str[::-1] n = len(s) count = 0 for i in range(n): for j in range(i, n): if is_palindrome(s[i:j+1]): count += 1 return count"},{"question":"def calculate_fuel_costs(T, trips): Calculate the total fuel cost for each trip given the price per litre of fuel. Parameters: T (int): Number of trips. trips (list of tuples): Each tuple contains three integers D (distance in km), E (fuel efficiency in km/l), and P (price per litre in rupees). Returns: list: Total fuel cost for each trip. >>> calculate_fuel_costs(3, [(300, 20, 70), (450, 15, 85), (600, 25, 60)]) == [1050, 2550, 1440] >>> calculate_fuel_costs(1, [(1, 1, 1)]) == [1] >>> calculate_fuel_costs(1, [(1000, 1, 100)]) == [100000] >>> calculate_fuel_costs(2, [(100, 10, 50), (500, 5, 20)]) == [500, 2000] >>> calculate_fuel_costs(2, [(100, 10, 10), (100, 20, 10)]) == [100, 50]","solution":"def calculate_fuel_costs(T, trips): Calculate the total fuel cost for each trip given the price per litre of fuel. Parameters: T (int): Number of trips. trips (list of tuples): Each tuple contains three integers D (distance in km), E (fuel efficiency in km/l), and P (price per litre in rupees). Returns: list: Total fuel cost for each trip. costs = [] for trip in trips: D, E, P = trip cost = (D / E) * P costs.append(int(cost)) return costs"},{"question":"def returns_to_origin(moves): Determines if the given moves will return to the origin (0, 0). Args: moves (str): A sequence of moves using 'U', 'D', 'L', 'R'. Returns: str: \\"YES\\" if moves return to the origin, otherwise \\"NO\\". >>> returns_to_origin(\\"UD\\") \\"YES\\" >>> returns_to_origin(\\"LLRR\\") \\"YES\\" pass def process_test_cases(T, test_cases): Process multiple test cases and determine if each sequence of moves returns to the origin. Args: T (int): Number of test cases. test_cases (list of str): List containing the sequence of moves for each test case. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases(2, [\\"UD\\", \\"LLRR\\"]) [\\"YES\\", \\"YES\\"] >>> process_test_cases(3, [\\"UDLR\\", \\"UUDDLRLR\\", \\"UUDDLRL\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] pass","solution":"def returns_to_origin(moves): Determines if the given moves will return to the origin (0, 0). Args: moves (str): A sequence of moves using 'U', 'D', 'L', 'R'. Returns: str: \\"YES\\" if moves return to the origin, otherwise \\"NO\\". x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\" def process_test_cases(T, test_cases): Process multiple test cases and determine if each sequence of moves returns to the origin. Args: T (int): Number of test cases. test_cases (list of str): List containing the sequence of moves for each test case. Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each test case. results = [] for moves in test_cases: results.append(returns_to_origin(moves)) return results"},{"question":"def findDisappearedNumbers(nums): Find all the integers from 1 to n that are missing from the array. Example: >>> findDisappearedNumbers([4,3,2,7,8,2,3,1]) [5,6] >>> findDisappearedNumbers([1,1]) [2]","solution":"def findDisappearedNumbers(nums): Find all the integers from 1 to n that are missing from the array. n = len(nums) # Iterate through each number in the array for i in range(n): # Find the index where the number should be marked index = abs(nums[i]) - 1 # Mark the number at that index as negative if nums[index] > 0: nums[index] = -nums[index] # Collect all the indices which have positive numbers missing_numbers = [i + 1 for i in range(n) if nums[i] > 0] return missing_numbers"},{"question":"def balance_purchases(transactions, initial_balance): Computes the final balance after processing valid transactions. Parameters: transactions (list of tuple): A list of transactions where each transaction is represented by a tuple containing a description (str) and an amount (float). initial_balance (float): The starting balance. Returns: float: The final balance after processing valid transactions. Example: >>> balance_purchases([ ... (\\"Purchase at store A\\", 50.75), ... (\\"Payment withheld\\", -30.00), ... (\\"Refund from store B\\", -10.25), ... (\\"Purchase at store C\\", 20.00), ... (\\"Invalid transaction\\", 100.00) ... ], 100.00) ... 160.50 pass def test_balance_purchases_all_valid(): transactions = [ (\\"Purchase at store A\\", 50.75), (\\"Refund from store B\\", -10.25), (\\"Purchase at store C\\", 20.00) ] initial_balance = 100.00 assert balance_purchases(transactions, initial_balance) == 160.50 def test_balance_purchases_with_invalid(): transactions = [ (\\"Purchase at store A\\", 50.75), (\\"Payment withheld\\", -30.00), (\\"Refund from store B\\", -10.25), (\\"Purchase at store C\\", 20.00), (\\"Invalid transaction\\", 100.00) ] initial_balance = 100.00 assert balance_purchases(transactions, initial_balance) == 160.50 def test_balance_purchases_no_valid(): transactions = [ (\\"Payment withheld\\", -30.00), (\\"Invalid transaction\\", 100.00), (\\"Unknown purchase\\", 40.00) ] initial_balance = 100.00 assert balance_purchases(transactions, initial_balance) == 100.00 def test_balance_purchases_empty_transactions(): transactions = [] initial_balance = 100.00 assert balance_purchases(transactions, initial_balance) == 100.00 def test_balance_purchases_no_initial_balance(): transactions = [ (\\"Purchase at store A\\", 50.75), (\\"Refund from store B\\", -10.25), (\\"Purchase at store C\\", 20.00) ] initial_balance = 0.00 assert balance_purchases(transactions, initial_balance) == 60.50","solution":"def balance_purchases(transactions, initial_balance): Computes the final balance after processing valid transactions. Parameters: transactions (list of tuple): A list of transactions where each transaction is represented by a tuple containing a description (str) and an amount (float). initial_balance (float): The starting balance. Returns: float: The final balance after processing valid transactions. valid_descriptions = {\\"Purchase at store A\\", \\"Refund from store B\\", \\"Purchase at store C\\"} balance = initial_balance for description, amount in transactions: if description in valid_descriptions: balance += amount return balance"},{"question":"def find_missing_digit(board): Finds the missing digit in an 'Almost Solved' Sudoku board. Parameters: board (list of list of int): 9x9 Sudoku board with one zero Returns: int: The missing digit Examples: >>> find_missing_digit([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 0] ... ]) 9 >>> find_missing_digit([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 0, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) 4","solution":"def find_missing_digit(board): Finds the missing digit in an 'Almost Solved' Sudoku board. Parameters: board (list of list of int): 9x9 Sudoku board with one zero Returns: int: The missing digit # Sum of numbers 1 to 9 complete_sum = sum(range(1, 10)) for row in board: if 0 in row: zero_index = row.index(0) row_sum = sum(row) return complete_sum - row_sum"},{"question":"class PhotoAlbum: def __init__(self, photos): Initialize the photo album with a list of photos. Args: photos (List[Tuple[int, int]]): List of tuples where each tuple consists of two integers, the upload timestamp and the popularity score. pass def update(self, timestamp, new_score): Update the popularity score of a photo with a given timestamp. Args: timestamp (int): The timestamp of the photo to be updated. new_score (int): The new popularity score of the photo. pass def query(self, start, end): Query the sum of popularity scores for photos within a specific timestamp range. Args: start (int): The start of the timestamp range (inclusive). end (int): The end of the timestamp range (inclusive). Returns: int: The sum of popularity scores for all photos in the specified timestamp range. pass def process_operations(photos, operations): Process a list of update and query operations on the photo album. Args: photos (List[Tuple[int, int]]): Initial list of photos as tuples of (timestamp, popularity score). operations (List[str]): List of operations to be processed in the given order. Returns: List[int]: List of results for each query operation. pass # Unit tests def test_photo_album(): photos = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)] operations = [ \\"Q 2 4\\", \\"U 3 25\\", \\"Q 2 4\\" ] expected_output = [90, 85] assert process_operations(photos, operations) == expected_output def test_update_operation(): photos = [(1, 10), (2, 20)] operations = [ \\"U 1 15\\", \\"Q 1 2\\", ] expected_output = [35] assert process_operations(photos, operations) == expected_output def test_query_operation(): photos = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)] operations = [ \\"Q 1 3\\", \\"Q 3 5\\", ] expected_output = [60, 120] assert process_operations(photos, operations) == expected_output def test_combined_operations(): photos = [(1, 100), (3, 75), (4, 50)] operations = [ \\"Q 1 4\\", \\"U 3 100\\", \\"Q 2 4\\", \\"U 1 50\\", \\"Q 1 4\\", ] expected_output = [225, 150, 200] assert process_operations(photos, operations) == expected_output","solution":"class PhotoAlbum: def __init__(self, photos): # Initialize with a sorted list of tuples (timestamp, popularity score) self.photos = dict(photos) self.timestamps = sorted(self.photos.keys()) def update(self, timestamp, new_score): if timestamp in self.photos: self.photos[timestamp] = new_score def query(self, start, end): total_score = 0 for t in self.timestamps: if start <= t <= end: total_score += self.photos[t] if t > end: break return total_score def process_operations(photos, operations): album = PhotoAlbum(photos) results = [] for op in operations: parts = op.split() if parts[0] == 'U': album.update(int(parts[1]), int(parts[2])) elif parts[0] == 'Q': result = album.query(int(parts[1]), int(parts[2])) results.append(result) return results"},{"question":"def highest_temperatures(n, readings): Determine the highest temperature recorded in each city. >>> highest_temperatures(7, [ (\\"2023-01-01\\", \\"New_York\\", 5), (\\"2023-01-02\\", \\"New_York\\", 10), (\\"2023-01-01\\", \\"Los_Angeles\\", 15), (\\"2023-01-02\\", \\"Los_Angeles\\", 20), (\\"2023-01-01\\", \\"New_York\\", -5), (\\"2023-01-01\\", \\"New_York\\", 8), (\\"2023-01-03\\", \\"Los_Angeles\\", 25), ]) == {\\"New_York\\": 10, \\"Los_Angeles\\": 25} >>> highest_temperatures(4, [ (\\"2023-02-01\\", \\"Chicago\\", -10), (\\"2023-02-01\\", \\"Chicago\\", 0), (\\"2023-02-02\\", \\"Miami\\", 30), (\\"2023-02-02\\", \\"Miami\\", 31), ]) == {\\"Chicago\\": 0, \\"Miami\\": 31}","solution":"def highest_temperatures(n, readings): Determine the highest temperature recorded in each city. :param n: Number of temperature readings :param readings: List of temperature readings in the format [(date, city_name, temperature), ...] :return: Dictionary with city names as keys and their highest temperatures as values last_entry = {} max_temps = {} for date, city, temp in readings: if (date, city) not in last_entry or last_entry[(date, city)][0] < temp: last_entry[(date, city)] = (temp, date) for (date, city), (temp, _) in last_entry.items(): if city not in max_temps: max_temps[city] = temp else: max_temps[city] = max(max_temps[city], temp) return max_temps"},{"question":"def calculate_bonuses(time_worked_list): Calculate bonuses based on the time worked by employees. Args: - time_worked_list (list of int): List of times worked by employees in minutes. Returns: - list of int: List of bonuses corresponding to the time worked. >>> calculate_bonuses([2789, 1220, 599, 1850, 2401]) [100, 50, 0, 75, 100] >>> calculate_bonuses([300, 700, 1800, 2000]) [0, 25, 75, 75]","solution":"def calculate_bonuses(time_worked_list): Calculate bonuses based on the time worked by employees. Args: - time_worked_list (list of int): List of times worked by employees in minutes. Returns: - list of int: List of bonuses corresponding to the time worked. bonuses = [] for time in time_worked_list: if time >= 2400: bonuses.append(100) elif 1800 <= time < 2400: bonuses.append(75) elif 1200 <= time < 1800: bonuses.append(50) elif 600 <= time < 1200: bonuses.append(25) else: bonuses.append(0) return bonuses"},{"question":"def word_exists(matrix: List[List[str]], word: str) -> bool: Determine if the word can be constructed by sequentially adjacent cells of the matrix. Each cell can be connected horizontally, vertically, or diagonally, and can only be used once. Args: - matrix: List of List of characters representing the 2D grid. - word: The word to be constructed. Returns: - True if the word can be constructed, False otherwise. Examples: >>> word_exists([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], 'ABCCED') True >>> word_exists([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], 'SEE') True >>> word_exists([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], 'ABCB') False","solution":"def word_exists(matrix, word): if not matrix or not word: return False rows, cols = len(matrix), len(matrix[0]) def dfs(x, y, index): if index == len(word): return True if x < 0 or x >= rows or y < 0 or y >= cols or matrix[x][y] != word[index]: return False temp = matrix[x][y] matrix[x][y] = '#' result = (dfs(x+1, y, index+1) or dfs(x-1, y, index+1) or dfs(x, y+1, index+1) or dfs(x, y-1, index+1) or dfs(x+1, y+1, index+1) or dfs(x+1, y-1, index+1) or dfs(x-1, y+1, index+1) or dfs(x-1, y-1, index+1)) matrix[x][y] = temp return result for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"def can_buy_two_items(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine if Ali can buy exactly two different items within his budget. >>> can_buy_two_items(3, [ ((4, 7), [1, 2, 3, 4]), ((5, 10), [9, 2, 8, 1, 6]), ((3, 5), [5, 5, 5]) ]) [1, 1, 0] >>> can_buy_two_items(1, [ ((4, 3), [4, 5, 6, 7]) ]) [0] >>> can_buy_two_items(1, [ ((3, 6), [3, 2, 4]) ]) [1] >>> can_buy_two_items(1, [ ((5, 1000000000), [999999999, 1, 1000000000, 2, 999999998]) ]) [1] >>> can_buy_two_items(1, [ ((2, 3), [1, 2]) ]) [1] >>> can_buy_two_items(1, [ ((4, 6), [6, 6, 6, 6]) ]) [0]","solution":"def can_buy_two_items(T, test_cases): results = [] for i in range(T): N, B = test_cases[i][0] costs = test_cases[i][1] costs.sort() left, right = 0, N - 1 found = 0 while left < right: if costs[left] + costs[right] <= B: found = 1 break elif costs[left] + costs[right] < B: left += 1 else: right -= 1 results.append(found) return results"},{"question":"def weighted_average(data): Calculate the weighted average of a list of tuples. :param data: List of tuples, where each tuple contains (number, weight). :return: Weighted average as a float. >>> abs(weighted_average([(3, 1), (5, 2), (10, 5)]) - 7.875) < 1e-6 True >>> abs(weighted_average([(10, 5)]) - 10) < 1e-6 True >>> abs(weighted_average([(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]) - 3) < 1e-6 True >>> abs(weighted_average([(5, 0), (10, 0), (15, 0), (20, 0)]) - 0) < 1e-6 True >>> abs(weighted_average([(2, 3), (4, 4), (6, 1)]) - 3.5) < 1e-6 True","solution":"def weighted_average(data): Calculate the weighted average of a list of tuples. :param data: List of tuples, where each tuple contains (number, weight). :return: Weighted average as a float. total_weight = sum(weight for value, weight in data) weighted_sum = sum(value * weight for value, weight in data) if total_weight == 0: return 0 # To handle edge cases where total weight might be 0 return weighted_sum / total_weight"},{"question":"import math def is_prime(N: int) -> bool: Create a function that takes an integer N as input and returns a boolean indicating whether N is a prime number. >>> is_prime(7) True >>> is_prime(10) False","solution":"import math def is_prime(N): Returns True if N is a prime number, otherwise returns False. if N <= 1: return False if N <= 3: return True if N % 2 == 0 or N % 3 == 0: return False i = 5 while i * i <= N: if N % i == 0 or N % (i + 2) == 0: return False i += 6 return True"},{"question":"def max_usage(T, intervals, target_app): Determine the maximum CPU and Memory usage of the given application across all intervals. Parameters: T (int): Number of time intervals. intervals (list): List containing information about each time interval. Each item in the list is a tuple of (number of applications, list of application details). Application details are represented as (name, CPU usage, Memory usage). target_app (str): The application's name for which we want to determine the max CPU and Memory usage. Returns: str: Two integers separated by a space representing the max CPU and Memory usage or \\"Application Not Found\\". from typing import List, Tuple # Sample test cases to validate the solution def test_max_usage_found(): T = 3 intervals = [ (2, [(\\"App1\\", 50, 100), (\\"App2\\", 30, 200)]), (3, [(\\"App1\\", 60, 150), (\\"App2\\", 40, 180), (\\"App3\\", 25, 80)]), (1, [(\\"App2\\", 20, 90)]) ] target_app = \\"App1\\" assert max_usage(T, intervals, target_app) == \\"60 150\\" def test_max_usage_not_found(): T = 3 intervals = [ (2, [(\\"App1\\", 50, 100), (\\"App2\\", 30, 200)]), (3, [(\\"App1\\", 60, 150), (\\"App2\\", 40, 180), (\\"App3\\", 25, 80)]), (1, [(\\"App2\\", 20, 90)]) ] target_app = \\"App4\\" assert max_usage(T, intervals, target_app) == \\"Application Not Found\\" def test_max_usage_single_interval(): T = 1 intervals = [ (2, [(\\"App1\\", 45, 90), (\\"App2\\", 30, 70)]) ] target_app = \\"App1\\" assert max_usage(T, intervals, target_app) == \\"45 90\\" def test_max_usage_single_interval_not_found(): T = 1 intervals = [ (2, [(\\"App1\\", 45, 90), (\\"App2\\", 30, 70)]) ] target_app = \\"App3\\" assert max_usage(T, intervals, target_app) == \\"Application Not Found\\" def test_max_usage_multiple_intervals_same_values(): T = 2 intervals = [ (2, [(\\"App1\\", 50, 50), (\\"App2\\", 30, 30)]), (2, [(\\"App1\\", 50, 50), (\\"App2\\", 30, 30)]) ] target_app = \\"App1\\" assert max_usage(T, intervals, target_app) == \\"50 50\\"","solution":"def max_usage(T, intervals, target_app): Determine the maximum CPU and Memory usage of the given application across all intervals. Parameters: T (int): Number of time intervals. intervals (list): List containing information about each time interval. Each item in the list is a tuple of (number of applications, list of application details). Application details are represented as (name, CPU usage, Memory usage). target_app (str): The application's name for which we want to determine the max CPU and Memory usage. Returns: str: Two integers separated by a space representing the max CPU and Memory usage or \\"Application Not Found\\". max_cpu = -1 max_memory = -1 for interval in intervals: A, apps = interval for app in apps: name, cpu, memory = app if name == target_app: if cpu > max_cpu: max_cpu = cpu if memory > max_memory: max_memory = memory if max_cpu == -1 and max_memory == -1: return \\"Application Not Found\\" else: return f\\"{max_cpu} {max_memory}\\""},{"question":"def find_divisors(n: int) -> list: Returns a list of all divisors of the positive integer n in ascending order. :param n: Positive integer to find divisors for. :return: List of divisors in ascending order. >>> find_divisors(12) [1, 2, 3, 4, 6, 12] >>> find_divisors(25) [1, 5, 25]","solution":"def find_divisors(n): Returns a list of all divisors of the positive integer n in ascending order. divisors = [] for i in range(1, int(n**0.5) + 1): if n % i == 0: divisors.append(i) if i != n // i: divisors.append(n // i) return sorted(divisors)"},{"question":"def max_smallest_frequency_percentage(n: int, s: str) -> int: Determine the maximum possible value for the smallest frequency percentage of a digit that appears in s. >>> max_smallest_frequency_percentage(5, '12345') 20 >>> max_smallest_frequency_percentage(10, '1111100000') 50","solution":"def max_smallest_frequency_percentage(n, s): from collections import Counter import math # Count the frequency of each digit in the string freq = Counter(s) # Calculate the smallest possible percentage value p min_freq = min(freq.values()) p = math.ceil((min_freq / n) * 100) return p"},{"question":"def longest_consecutive_subarray_length(arr: List[int]) -> int: Returns the length of the longest contiguous subarray such that its elements can be rearranged to form a sequence of consecutive integers. >>> longest_consecutive_subarray_length([1, 2, 2, 3, 4, 1]) 4 >>> longest_consecutive_subarray_length([10, 12, 11, 14, 13]) 5 >>> longest_consecutive_subarray_length([1, 5, 7]) 1","solution":"def longest_consecutive_subarray_length(arr): Returns the length of the longest contiguous subarray such that its elements can be rearranged to form a sequence of consecutive integers. n = len(arr) if n == 0: return 0 max_len = 1 # We always have at least one element in any subarray for i in range(n): min_el, max_el = arr[i], arr[i] seen_set = set() for j in range(i, n): if arr[j] in seen_set: break seen_set.add(arr[j]) min_el = min(min_el, arr[j]) max_el = max(max_el, arr[j]) if len(seen_set) == max_el - min_el + 1: max_len = max(max_len, j - i + 1) return max_len"},{"question":"def count_paths(n: int, obstacles: List[Tuple[int, int]]) -> int: Returns the number of distinct paths from the top-left corner to the bottom-right corner of an n x n chessboard. :param n: Size of the chessboard (n x n) :param obstacles: List of tuples where each tuple represents an obstacle's (row, column) coordinates. Each coordinate is 1-indexed. :return: Number of distinct paths from (1,1) to (n,n) >>> count_paths(3, []) 6 >>> count_paths(4, []) 20 >>> count_paths(3, [(2, 2)]) 2 >>> count_paths(3, [(1, 2), (2, 1)]) 0 >>> count_paths(3, [(1, 1)]) 0 >>> count_paths(3, [(3, 3)]) 0 >>> count_paths(2, [(1, 2)]) 1 >>> count_paths(2, [(2, 1)]) 1 >>> count_paths(1000, [(500, 500), (1000, 999)]) > 0 >>> count_paths(2, [(1, 2), (2, 1)]) 0","solution":"def count_paths(n, obstacles): Returns the number of distinct paths from the top-left corner to the bottom-right corner of an n x n chessboard. :param n: Size of the chessboard (n x n) :param obstacles: List of tuples where each tuple represents an obstacle's (row, column) coordinates. Each coordinate is 1-indexed. :return: Number of distinct paths from (1,1) to (n,n) # Initialize the board with 0 dp = [[0] * n for _ in range(n)] # Initialize the obstacles obstacle_set = set(obstacles) # Set the starting point if it's not an obstacle if (1, 1) in obstacle_set: return 0 dp[0][0] = 1 # Fill the dp table for i in range(n): for j in range(n): if (i + 1, j + 1) in obstacle_set: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][n-1]"},{"question":"def detect_fraudulent_orders(N: int, B: int, threshold: int, blacklisted_users: List[int], orders: List[Tuple[int, int, int]]) -> int: Detect fraudulent orders based on the given rules. Args: N (int): Number of orders. B (int): Number of blacklisted users. threshold (int): Threshold amount for fraud detection. blacklisted_users (List[int]): List of blacklisted user IDs. orders (List[Tuple[int, int, int]]): List of orders with each represented as a tuple (order_id, user_id, amount). Returns: int: The number of fraudulent orders. >>> detect_fraudulent_orders(5, 2, 100, [101, 103], [(1, 101, 150), (2, 102, 90), (3, 103, 50), (4, 104, 80), (2, 102, 200)]) 2 >>> detect_fraudulent_orders(5, 0, 50, [], [(1, 101, 100), (2, 102, 90), (3, 103, 70), (4, 104, 80), (5, 105, 60)]) 5","solution":"def detect_fraudulent_orders(N, B, threshold, blacklisted_users, orders): blacklisted_set = set(blacklisted_users) order_ids = set() fraud_count = 0 seen_order_ids = set() for order_id, user_id, amount in orders: if order_id in seen_order_ids: fraud_count += 1 elif amount > threshold: fraud_count += 1 elif user_id in blacklisted_set: fraud_count += 1 seen_order_ids.add(order_id) return fraud_count"},{"question":"def update_inventory(inventory, sales): Updates the inventory based on the list of sales transactions. Parameters: inventory (list of tuples): Each tuple contains (ID (int), name (str), price (float), units (int)) sales (list of tuples): Each tuple contains (ID (int), quantity (int)) Returns: tuple: Updated inventory as a list of tuples, each in the same format as the input inventory, and a list of warning messages for invalid sales transactions. >>> inventory = [(1, \\"apple\\", 0.50, 500), (2, \\"banana\\", 0.30, 300), (3, \\"orange\\", 0.70, 700)] >>> sales = [(1, 200), (3, 800)] >>> update_inventory(inventory, sales) ([(1, \\"apple\\", 0.50, 300), (2, \\"banana\\", 0.30, 300), (3, \\"orange\\", 0.70, 700)], ['Cannot process sale of 800 units of item ID 3 since only 700 units are available.']) >>> inventory = [(1, \\"grape\\", 2.00, 100), (2, \\"peach\\", 1.50, 200)] >>> sales = [(1, 100)] >>> update_inventory(inventory, sales) ([(1, \\"grape\\", 2.00, 0), (2, \\"peach\\", 1.50, 200)], []) >>> inventory = [(1, \\"watermelon\\", 3.00, 60), (2, \\"kiwi\\", 1.20, 150)] >>> sales = [(1, 30), (2, 50), (1, 15)] >>> update_inventory(inventory, sales) ([(1, \\"watermelon\\", 3.00, 15), (2, \\"kiwi\\", 1.20, 100)], []) >>> inventory = [(1, \\"mango\\", 1.00, 10), (2, \\"papaya\\", 0.80, 25)] >>> sales = [(1, 15), (2, 5)] >>> update_inventory(inventory, sales) ([(1, \\"mango\\", 1.00, 10), (2, \\"papaya\\", 0.80, 20)], ['Cannot process sale of 15 units of item ID 1 since only 10 units are available.']) >>> inventory = [] >>> sales = [(1, 10)] >>> update_inventory(inventory, sales) ([], [])","solution":"def update_inventory(inventory, sales): Updates the inventory based on the list of sales transactions. Parameters: inventory - List of tuples, with each tuple containing: (ID (int), name (str), price (float), units (int)) sales - List of tuples, with each tuple containing: (ID (int), quantity (int)) Returns: Updated inventory as a list of tuples, each in the same format as the input inventory, and a list of warning messages for invalid sales transactions. inventory_dict = {item[0]: item for item in inventory} warnings = [] for sale in sales: ID, quantity = sale if ID in inventory_dict: item = inventory_dict[ID] name, price, units = item[1], item[2], item[3] if units >= quantity: inventory_dict[ID] = (ID, name, price, units - quantity) else: warnings.append(f\\"Cannot process sale of {quantity} units of item ID {ID} since only {units} units are available.\\") updated_inventory = list(inventory_dict.values()) return updated_inventory, warnings"},{"question":"def remove_duplicates(input_string: str) -> str: Write a function that takes a string consisting of lowercase alphabetical characters and removes all characters that have appeared before, keeping only their first occurrences. >>> remove_duplicates(\\"programming\\") \\"progamin\\" >>> remove_duplicates(\\"hello\\") \\"helo\\" Parameters: input_string (str): A string containing lowercase alphabetical characters. Returns: str: A string with duplicate characters removed.","solution":"def remove_duplicates(input_string): Removes duplicates from the input string, keeping only the first occurrences. Parameters: input_string (str): A string containing lowercase alphabetical characters. Returns: str: A string with duplicate characters removed. seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def length_of_LIS(nums: List[int]) -> int: Returns the length of the longest strictly increasing subsequence. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([0, 1, 0, 3, 2, 3]) 4 >>> length_of_LIS([7, 7, 7, 7, 7, 7, 7]) 1 >>> length_of_LIS([1, 2, 3, 4]) 4","solution":"def length_of_LIS(nums): Returns the length of the longest strictly increasing subsequence. Parameters: nums (list): Input array of integers. Returns: int: Length of the longest strictly increasing subsequence. if not nums: return 0 dp = [1] * len(nums) # dp[i] will be the length of LIS ending at index i for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def max_subset_sum(a): Returns the maximum sum of a subset of non-negative integers such that no two elements in the subset are adjacent in the original array. >>> max_subset_sum([3, 2, 5, 10, 7]) 15 >>> max_subset_sum([1, 2, 9, 4]) 10 >>> max_subset_sum([8, 1, 3]) 11","solution":"def max_subset_sum(a): Returns the maximum sum of a non-adjacent subset of a. n = len(a) if n == 0: return 0 if n == 1: return a[0] # Initializing memory array for dynamic programming dp = [0] * n # Base cases dp[0] = a[0] dp[1] = max(a[0], a[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + a[i]) # The last entry will have the answer return dp[-1]"},{"question":"def remove_vowels(input_string: str) -> str: Returns a version of the input string with all vowels removed. Vowels considered are both uppercase and lowercase 'a', 'e', 'i', 'o', 'u'. >>> remove_vowels(\\"Hello, World! 123\\") \\"Hll, Wrld! 123\\" >>> remove_vowels(\\"The quick brown fox jumps over the lazy dog.\\") \\"Th qck brwn fx jmps vr th lzy dg.\\"","solution":"def remove_vowels(input_string): Returns a version of the input string with all vowels removed. Vowels considered are both uppercase and lowercase 'a', 'e', 'i', 'o', 'u'. vowels = set(\\"aeiouAEIOU\\") return ''.join(char for char in input_string if char not in vowels)"},{"question":"def minDistance(str1: str, str2: str) -> int: You are given two strings, str1 and str2. You need to transform str1 into str2 using the following operations: 1. Insert a character. 2. Remove a character. 3. Replace a character. Write a function that takes the two strings as input and returns the minimum number of operations required to convert str1 into str2. >>> minDistance(\\"kitten\\", \\"sitting\\") 3 >>> minDistance(\\"flaw\\", \\"lawn\\") 2 >>> minDistance(\\"\\", \\"\\") 0 >>> minDistance(\\"a\\", \\"\\") 1 >>> minDistance(\\"\\", \\"a\\") 1","solution":"def minDistance(str1, str2): m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Base case initialization for i in range(m + 1): dp[i][0] = i # Deleting all characters from str1 to get empty str2 for j in range(n + 1): dp[0][j] = j # Inserting all characters of str2 into empty str1 for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match, no new operation else: insert_op = dp[i][j - 1] + 1 remove_op = dp[i - 1][j] + 1 replace_op = dp[i - 1][j - 1] + 1 dp[i][j] = min(insert_op, remove_op, replace_op) return dp[m][n]"},{"question":"def unique_paths_with_obstacles(n, m, obstacles): Determine the number of unique paths from top-left to bottom-right of a grid with obstacles. :param n: number of rows in the grid :param m: number of columns in the grid :param obstacles: list of (x, y) tuples representing obstacle coordinates :return: number of unique paths pass def number_of_unique_paths(test_cases): Process multiple test cases to find the number of unique paths for each case. :param test_cases: list of (N, M, K, obstacles) tuples :return: list of results for each test case pass import pytest def test_unique_paths_no_obstacles(): assert unique_paths_with_obstacles(3, 3, []) == 6 def test_unique_paths_with_obstacles(): assert unique_paths_with_obstacles(3, 3, [(2, 2)]) == 2 assert unique_paths_with_obstacles(3, 3, [(2, 2), (3, 2)]) == 1 assert unique_paths_with_obstacles(3, 3, [(1, 2)]) == 3 assert unique_paths_with_obstacles(3, 3, [(2, 3)]) == 3 def test_unique_paths_start_obstacle(): assert unique_paths_with_obstacles(3, 3, [(1, 1)]) == 0 def test_unique_paths_end_obstacle(): assert unique_paths_with_obstacles(3, 3, [(3, 3)]) == 0 def test_multiple_test_cases(): test_cases = [ (3, 3, 1, [(2, 2)]), (3, 3, 2, [(2, 2), (3, 2)]) ] assert number_of_unique_paths(test_cases) == [2, 1] if __name__ == \\"__main__\\": pytest.main()","solution":"def unique_paths_with_obstacles(n, m, obstacles): Determine the number of unique paths from top-left to bottom-right of a grid with obstacles. :param n: number of rows in the grid :param m: number of columns in the grid :param obstacles: list of (x, y) tuples representing obstacle coordinates :return: number of unique paths grid = [[0 for _ in range(m)] for _ in range(n)] # Mark obstacles on the grid for x, y in obstacles: grid[x-1][y-1] = -1 # If the start or end point is an obstacle, there are no paths if grid[0][0] == -1 or grid[n-1][m-1] == -1: return 0 # Initialize the start point grid[0][0] = 1 # Fill the dynamic programming table for i in range(n): for j in range(m): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] return grid[n-1][m-1] def number_of_unique_paths(test_cases): Process multiple test cases to find the number of unique paths for each case. :param test_cases: list of (N, M, K, obstacles) tuples :return: list of results for each test case results = [] for n, m, k, obstacles in test_cases: results.append(unique_paths_with_obstacles(n, m, obstacles)) return results"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Given an array of integers and a target integer, return an array of all unique quadruplets [a, b, c, d] such that a + b + c + d = target, where a, b, c, and d are elements from the array. The solution set must not contain duplicate quadruplets and the input array will not be empty. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2],[-2, 0, 0, 2],[-1, 0, 0, 1]] >>> four_sum([2, 2, 2, 2, 2], 8) [[2, 2, 2, 2]] >>> four_sum([4, 1, 2, -1, 1, -3], 1) [[-3, -1, 1, 4],[-3, 1, 1, 2]]","solution":"def four_sum(nums, target): nums.sort() res = [] n = len(nums) for i in range(n - 3): if i > 0 and nums[i] == nums[i - 1]: continue for j in range(i + 1, n - 2): if j > i + 1 and nums[j] == nums[j - 1]: continue left, right = j + 1, n - 1 while left < right: s = nums[i] + nums[j] + nums[left] + nums[right] if s == target: res.append([nums[i], nums[j], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif s < target: left += 1 else: right -= 1 return res"},{"question":"def rearrange_string(s: str) -> str: Rearrange a string such that no two consecutive characters are the same. If it is not possible to rearrange, return \\"IMPOSSIBLE\\". Args: s (str): The input string consisting of lowercase English letters. Returns: str: The rearranged string or \\"IMPOSSIBLE\\" if no such rearrangement exists. Examples: >>> rearrange_string(\\"aaabb\\") 'ababa' >>> rearrange_string(\\"aaaaaa\\") 'IMPOSSIBLE' >>> rearrange_string(\\"aabbcc\\") 'abcabc' >>> rearrange_string(\\"xxyyzz\\") 'xyzxyz'","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s): count = Counter(s) max_heap = [] # Building a max heap. Using negative counts because Python has a min heap by default. for char, freq in count.items(): heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq = freq + 1 prev_char = char return ''.join(result) if len(result) == len(s) else \\"IMPOSSIBLE\\""},{"question":"def min_tiles_to_cover_grid(M: int, B: int, broken_cells: List[Tuple[int, int]]) -> int: Determine the minimal number of tiles required to cover the non-broken cells of the grid. >>> min_tiles_to_cover_grid(5, 3, [(1, 1), (2, 3), (4, 4)]) == 22 >>> min_tiles_to_cover_grid(3, 0, []) == 9 >>> min_tiles_to_cover_grid(2, 4, [(1, 1), (1, 2), (2, 1), (2, 2)]) == 0 >>> min_tiles_to_cover_grid(4, 1, [(2, 2)]) == 15 >>> min_tiles_to_cover_grid(1, 0, []) == 1 >>> min_tiles_to_cover_grid(1, 1, [(1, 1)]) == 0","solution":"def min_tiles_to_cover_grid(M, B, broken_cells): covered = set() # Mark all cells as covered initially for i in range(1, M + 1): for j in range(1, M + 1): covered.add((i, j)) # Remove broken cells from covered cells for r, c in broken_cells: covered.remove((r, c)) # The remaining covered cells are the ones that need tiles return len(covered) # Example usage: M = 5 B = 3 broken_cells = [(1, 1), (2, 3), (4, 4)] print(min_tiles_to_cover_grid(M, B, broken_cells)) # Output: 22"},{"question":"def findMaxConsecutiveX(inputString: str) -> int: Returns the count of the longest consecutive 'X' sequence in the input string. >>> findMaxConsecutiveX(\\"OXXXOXOXX\\") 3 >>> findMaxConsecutiveX(\\"XXXXXOOX\\") 5 >>> findMaxConsecutiveX(\\"OXOXOXOXO\\") 1","solution":"def findMaxConsecutiveX(inputString): Returns the count of the longest consecutive 'X' sequence in the input string. max_count = 0 current_count = 0 for char in inputString: if char == 'X': current_count += 1 max_count = max(max_count, current_count) else: current_count = 0 return max_count"},{"question":"def is_valid_isbn10(isbn: str) -> str: Determines if a string is a valid ISBN-10 code. Args: isbn (str): The ISBN-10 string to validate. Returns: str: \\"Valid\\" if the ISBN-10 is correct according to the described rules, and \\"Invalid\\" otherwise. >>> is_valid_isbn10(\\"0-306-40615-2\\") \\"Valid\\" >>> is_valid_isbn10(\\"3-598-21508-8\\") \\"Valid\\" >>> is_valid_isbn10(\\"3-598-21507-X\\") \\"Valid\\" >>> is_valid_isbn10(\\"3-598-21508-9\\") \\"Invalid\\"","solution":"def is_valid_isbn10(isbn): Determines if a string is a valid ISBN-10 code. Args: isbn (str): The ISBN-10 string to validate. Returns: str: \\"Valid\\" if the ISBN-10 is correct according to the described rules, and \\"Invalid\\" otherwise. # Remove hyphens isbn = isbn.replace('-', '') # Check length if len(isbn) != 10: return \\"Invalid\\" # Compute the sum S S = 0 for i in range(10): if isbn[i].isdigit(): S += (i + 1) * int(isbn[i]) elif i == 9 and isbn[i] == 'X': S += (i + 1) * 10 else: return \\"Invalid\\" # Check divisibility by 11 if S % 11 == 0: return \\"Valid\\" else: return \\"Invalid\\""},{"question":"def process_logs(N: int, sequence: List[int], M: int, operations: List[str]) -> List[str]: Processes a list of operations on a given sequence and returns the results for each query. Parameters: N (int): Length of the initial sequence sequence (list of int): Initial sequence of integers M (int): Number of operations to be performed operations (list of str): List of operations Returns: list of str: Results of each query operation Example: >>> process_logs(5, [3, 8, 12, 6, 7], 4, [\\"Q 2 8\\", \\"Q 4 10\\", \\"U 4 10\\", \\"Q 4 10\\"]) ['YES', 'NO', 'YES'] >>> process_logs(3, [1, 2, 3], 2, [\\"Q 1 1\\", \\"Q 2 3\\"]) ['YES', 'NO'] # Define your implementation here","solution":"def process_logs(N, sequence, M, operations): Processes a list of operations on a given sequence and returns the results for each query. Parameters: N (int): Length of the initial sequence sequence (list of int): Initial sequence of integers M (int): Number of operations to be performed operations (list of str): List of operations Returns: list of str: Results of each query operation results = [] for operation in operations: op = operation.split() if op[0] == \\"Q\\": p_i = int(op[1]) v_i = int(op[2]) if sequence[p_i - 1] == v_i: results.append(\\"YES\\") else: results.append(\\"NO\\") elif op[0] == \\"U\\": p_i = int(op[1]) v_i = int(op[2]) sequence[p_i - 1] = v_i return results"},{"question":"def longest_increasing_substring(s: str) -> str: Returns the longest substring of \`s\` where the characters are in strictly increasing alphabetical order. If multiple substrings of the same length exist, the one occurring first is returned. >>> longest_increasing_substring(\\"abcde\\") == \\"abcde\\" >>> longest_increasing_substring(\\"abacdef\\") == \\"acdef\\" >>> longest_increasing_substring(\\"zyxwv\\") == \\"z\\" >>> longest_increasing_substring(\\"\\") == \\"\\" >>> longest_increasing_substring(\\"a\\") == \\"a\\" >>> longest_increasing_substring(\\"bbbbbb\\") == \\"b\\" >>> longest_increasing_substring(\\"abacdefabc\\") == \\"acdef\\" >>> longest_increasing_substring(\\"abcxyzbcd\\") == \\"abcxyz\\"","solution":"def longest_increasing_substring(s): Returns the longest substring of \`s\` where the characters are in strictly increasing alphabetical order. If multiple substrings of the same length exist, the one occurring first is returned. if not s: return \\"\\" longest = current = s[0] for i in range(1, len(s)): if s[i] > s[i-1]: current += s[i] else: if len(current) > len(longest): longest = current current = s[i] if len(current) > len(longest): longest = current return longest"},{"question":"from typing import List def orchestra_sync_time(N: int, D: List[int]) -> int: Returns the time in seconds after which all instruments will play simultaneously again. Given: N : int : Number of instruments D : list of int : Time each instrument needs to complete one full cycle Examples: >>> orchestra_sync_time(3, [2, 4, 5]) 20 >>> orchestra_sync_time(1, [10]) 10 # Test Cases def test_orchestra_sync_time_case_1(): assert orchestra_sync_time(3, [2, 4, 5]) == 20 def test_orchestra_sync_time_case_2(): assert orchestra_sync_time(1, [10]) == 10 def test_orchestra_sync_time_case_3(): assert orchestra_sync_time(4, [2, 3, 6, 8]) == 24 def test_orchestra_sync_time_case_4(): assert orchestra_sync_time(5, [5, 7, 11, 13, 17]) == 85085 def test_orchestra_sync_time_large_numbers_same(): assert orchestra_sync_time(2, [10**18, 10**18]) == 10**18 def test_orchestra_sync_time_large_numbers_diff(): assert orchestra_sync_time(2, [10**18, 10**18 - 1]) == (10**18) * (10**18 - 1)","solution":"from math import gcd from functools import reduce def lcm(a, b): Returns the least common multiple of a and b. return (a * b) // gcd(a, b) def orchestra_sync_time(N, D): Returns the time in seconds after which all instruments will play simultaneously again. Args: N : int : Number of instruments D : list of int : Time each instrument needs to complete one full cycle Returns: int : Time in seconds after which all instruments will play simultaneously again return reduce(lcm, D)"},{"question":"def min_books_to_sell(N: int, test_cases: List[Dict[str, Any]]) -> List[int]: Determine the minimum number of different book titles required to fulfill all customer orders. Args: N (int): Number of test cases test_cases (List[Dict[str, Any]]): A list of dictionaries where each dictionary contains: 'books' â€“ the number of books available in stock, 'stock' â€“ list of integers representing the stock amount of each book, 'customers' â€“ the number of customers, 'customer_reqs' â€“ list of integers representing the customer requirements for books. Returns: List[int]: A list containing the minimum number of different book titles required for each test case. Example: >>> N = 2 >>> test_cases = [ {'books': 5, 'stock': [2, 3, 1, 4, 6], 'customers': 4, 'customer_reqs': [0, 1, 2, 2]}, {'books': 4, 'stock': [8, 1, 2, 2], 'customers': 3, 'customer_reqs': [1, 1, 0]}, ] >>> min_books_to_sell(N, test_cases) [3, 2] results = [] for i in range(N): B = test_cases[i]['books'] stock = test_cases[i]['stock'] C = test_cases[i]['customers'] customer_reqs = test_cases[i]['customer_reqs'] book_count = [0] * B for req in customer_reqs: book_count[req] += 1 books_needed = 0 for idx in range(B): if book_count[idx] > 0: books_needed += 1 results.append(books_needed) return results","solution":"def min_books_to_sell(N, test_cases): results = [] for i in range(N): B = test_cases[i]['books'] stock = test_cases[i]['stock'] C = test_cases[i]['customers'] customer_reqs = test_cases[i]['customer_reqs'] book_count = [0] * B for req in customer_reqs: book_count[req] += 1 books_needed = 0 for idx in range(B): if book_count[idx] > 0: books_needed += 1 results.append(books_needed) return results"},{"question":"def max_coins(N: int, A: List[int]) -> int: Calculate the maximum number of gold coins that can be collected without skipping more than one chest consecutively. Parameters: N (int): The number of treasure chests. A (List[int]): The number of gold coins in each chest. Returns: int: The maximum number of gold coins that can be collected. >>> max_coins(5, [6, 7, 1, 30, 8]) 45 >>> max_coins(2, [10, 5]) 10 pass # Unit tests def test_single_chest(): assert max_coins(1, [10]) == 10 def test_two_chests(): assert max_coins(2, [10, 5]) == 10 assert max_coins(2, [5, 10]) == 10 def test_three_chests(): assert max_coins(3, [1, 2, 3]) == 4 assert max_coins(3, [3, 2, 1]) == 4 def test_multiple_chests(): assert max_coins(5, [6, 7, 1, 30, 8]) == 45 assert max_coins(5, [10, 5, 10, 5, 10]) == 30 assert max_coins(5, [10, 2, 10, 20, 10]) == 40 def test_large_input(): large_input = [i % 10 + 1 for i in range(10**6)] assert max_coins(len(large_input), large_input) > 0 # Should run efficiently def test_no_coins(): assert max_coins(4, [0, 0, 0, 0]) == 0","solution":"def max_coins(N, A): Calculate the maximum number of gold coins that can be collected without skipping more than one chest consecutively. Parameters: N (int): The number of treasure chests. A (List[int]): The number of gold coins in each chest. Returns: int: The maximum number of gold coins that can be collected. if N == 0: return 0 elif N == 1: return A[0] # Initializing dp array where dp[i] represents the maximum coins collected up to the i-th chest dp = [0] * N dp[0] = A[0] dp[1] = max(A[0], A[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + A[i], dp[i-3] + A[i] + A[i-1] if i > 2 else 0) return dp[-1]"},{"question":"def fib_mod(n: int) -> int: Compute the n-th Fibonacci number efficiently, modulo 10^9 + 7. >>> fib_mod(10) 55 >>> fib_mod(0) 0 >>> fib_mod(1) 1 pass # You may use the below unit test cases to validate your solution. from solution import fib_mod def test_sample_input(): assert fib_mod(10) == 55 def test_zero(): assert fib_mod(0) == 0 def test_one(): assert fib_mod(1) == 1 def test_large_number(): # Just some example, as checking the exact large value can be intricate # Using properties like patterns in Fibonacci sequences mod a number # E.g., the Pisano period or directly calculating with a known algorithm assert fib_mod(1000000000000000000) def test_edge_case(): # Small edge case tests assert fib_mod(2) == 1 assert fib_mod(3) == 2 assert fib_mod(4) == 3 assert fib_mod(5) == 5 assert fib_mod(6) == 8","solution":"MOD = 10**9 + 7 def matrix_mult(A, B, mod=MOD): Multiplies two 2x2 matrices A and B under modulo mod. return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod] ] def matrix_pow(matrix, power, mod=MOD): Performs matrix exponentiation on a 2x2 matrix under modulo mod to find matrix^power. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base, mod) base = matrix_mult(base, base, mod) power //= 2 return result def fibonacci(n, mod=MOD): Returns the n-th Fibonacci number modulo mod. if n == 0: return 0 elif n == 1: return 1 F = [[1, 1], [1, 0]] # Transformation matrix for Fibonacci sequence result_matrix = matrix_pow(F, n-1, mod) return result_matrix[0][0] def fib_mod(n): return fibonacci(n)"},{"question":"def min_delivery_cost(n: int, houses: List[int], k: int) -> int: Returns the minimum total cost to deliver all packages in the given order. Args: n (int): The number of houses. houses (list): A list of integers representing house numbers. k (int): The cost for each house skipped. Returns: int: The minimum total cost. Examples: >>> min_delivery_cost(4, [5, 6, 7, 8], 3) 0 >>> min_delivery_cost(5, [1, 3, 7, 8, 12], 2) 6 from solution import min_delivery_cost def test_min_delivery_cost_no_skips(): assert min_delivery_cost(4, [5, 6, 7, 8], 3) == 0 def test_min_delivery_cost_with_skips(): assert min_delivery_cost(5, [1, 3, 7, 8, 12], 2) == 6 def test_min_delivery_cost_single_house(): assert min_delivery_cost(1, [5], 10) == 0 def test_min_delivery_cost_large_cost(): assert min_delivery_cost(3, [1, 100, 101], 50) == 50 def test_min_delivery_cost_mixed_gaps(): assert min_delivery_cost(6, [1, 2, 4, 6, 7, 9], 3) == 9","solution":"def min_delivery_cost(n, houses, k): Returns the minimum total cost to deliver all packages in the given order. Args: n (int): The number of houses. houses (list): A list of integers representing house numbers. k (int): The cost for each house skipped. Returns: int: The minimum total cost. cost = 0 for i in range(1, n): if houses[i] == houses[i-1] + 1: continue else: cost += k return cost"},{"question":"def min_changes_to_alternate(binary_string: str) -> int: Returns the minimum number of changes required to make every character in the binary string different from its immediate neighbor. >>> min_changes_to_alternate(\\"010101\\") 0 >>> min_changes_to_alternate(\\"100101\\") 2 >>> min_changes_to_alternate(\\"1111\\") 2 >>> min_changes_to_alternate(\\"0000\\") 2 >>> min_changes_to_alternate(\\"01\\") 0 >>> min_changes_to_alternate(\\"10\\") 0 >>> min_changes_to_alternate(\\"0110\\") 2 pass def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases and return a list of results for each binary string. >>> process_test_cases([\\"010101\\", \\"100101\\"]) [0, 2] >>> process_test_cases([\\"1111\\", \\"0000\\"]) [2, 2] >>> process_test_cases([\\"01\\", \\"10\\", \\"0110\\"]) [0, 0, 2] pass","solution":"def min_changes_to_alternate(binary_string): Returns the minimum number of changes required to make every character in the binary string different from its immediate neighbor. n = len(binary_string) # Calculate changes for pattern starting with '0' (i.e., \\"010101...\\") changes_start_with_0 = 0 for i in range(n): if i % 2 == 0 and binary_string[i] != '0': changes_start_with_0 += 1 elif i % 2 == 1 and binary_string[i] != '1': changes_start_with_0 += 1 # Calculate changes for pattern starting with '1' (i.e., \\"101010...\\") changes_start_with_1 = 0 for i in range(n): if i % 2 == 0 and binary_string[i] != '1': changes_start_with_1 += 1 elif i % 2 == 1 and binary_string[i] != '0': changes_start_with_1 += 1 return min(changes_start_with_0, changes_start_with_1) def process_test_cases(test_cases): Process multiple test cases and return a list of results for each binary string. results = [] for binary_string in test_cases: results.append(min_changes_to_alternate(binary_string)) return results"},{"question":"def update_grid(grid, operations): This function updates the grid as per the given operations, either by updating a row or column or querying the sum of a sub-rectangle. >>> grid = [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20] ... ] >>> operations = [ ... [\\"R\\", \\"2\\", \\"5\\"], ... [\\"C\\", \\"3\\", \\"7\\"], ... [\\"Q\\", \\"2\\", \\"2\\", \\"3\\", \\"4\\"], ... [\\"Q\\", \\"1\\", \\"1\\", \\"4\\", \\"5\\"], ... [\\"R\\", \\"1\\", \\"10\\"] ... ] >>> update_grid(grid, operations) 77 226","solution":"def update_grid(grid, operations): n = len(grid) m = len(grid[0]) for operation in operations: op = operation[0] if op == \\"R\\": _, x, v = operation x = int(x) - 1 v = int(v) for j in range(m): grid[x][j] = v elif op == \\"C\\": _, y, v = operation y = int(y) - 1 v = int(v) for i in range(n): grid[i][y] = v elif op == \\"Q\\": _, x1, y1, x2, y2 = operation x1 = int(x1) - 1 y1 = int(y1) - 1 x2 = int(x2) - 1 y2 = int(y2) - 1 total_sum = 0 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): total_sum += grid[i][j] print(total_sum)"},{"question":"def min_container_height(n: int, blocks: List[Tuple[int, int, int]]) -> int: Determines the minimum height of a container required to accommodate all n blocks such that blocks in each layer are arranged side by side (considering length and width) without overlapping. Parameters: n (int): Number of blocks. blocks (List[Tuple[int, int, int]]): A list of tuples where each tuple consists of three integers representing the length, width, and height of each block. Returns: int: The minimum height required for the container. >>> min_container_height(1, [(1, 1, 1)]) 1 >>> min_container_height(3, [(4, 2, 2), (3, 1, 1), (2, 3, 2)]) 5 >>> min_container_height(3, [(4, 2, 5), (3, 1, 1), (2, 3, 2)]) 8 >>> min_container_height(3, [(4, 2, 2), (3, 1, 2), (2, 3, 2)]) 6 >>> min_container_height(5, [(1000000, 1000000, 1000000)] * 5) 5000000 >>> min_container_height(4, [(7, 2, 3), (3, 5, 5), (5, 2, 7), (8, 9, 6)]) 21 pass","solution":"def min_container_height(n, blocks): Calculates the minimum height of a container needed to accommodate all n blocks in n different layers given the blocks' dimensions. Parameters: n (int): Number of blocks. blocks (list of tuples): Each tuple consists of (l,w,h) representing the length, width, and height of the block. Returns: int: The minimum height of the container. # Sum of heights since each block forms a separate layer total_height = sum(block[2] for block in blocks) return total_height"},{"question":"def can_pack_products(T, test_cases): Determine if it is possible to pack all the products into the given boxes without exceeding their weight limits. Args: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains: - N (int): Number of products. - weights (list of int): Weights of the products. - M (int): Number of boxes. - limits (list of int): Weight limits of the boxes. Returns: list of str: \\"Possible\\" if all products can be packed according to the given constraints, otherwise \\"Impossible\\". Example: >>> T = 3 >>> test_cases = [ ... (5, [10, 20, 10, 30, 40], 3, [50, 50, 30]), ... (4, [15, 35, 25, 10], 3, [20, 30, 40]), ... (3, [5, 10, 20], 2, [15, 25]) ... ] >>> can_pack_products(T, test_cases) [\\"Possible\\", \\"Impossible\\", \\"Possible\\"] from solution import can_pack_products def test_case_1(): T = 3 test_cases = [ (5, [10, 20, 10, 30, 40], 3, [50, 50, 30]), (4, [15, 35, 25, 10], 3, [20, 30, 40]), (3, [5, 10, 20], 2, [15, 25]) ] expected_output = [\\"Possible\\", \\"Impossible\\", \\"Possible\\"] assert can_pack_products(T, test_cases) == expected_output def test_case_2(): T = 1 test_case = [ (2, [50, 75], 1, [100]) ] expected_output = [\\"Impossible\\"] assert can_pack_products(T, test_case) == expected_output def test_case_3(): T = 2 test_cases = [ (3, [5, 5, 5], 3, [10, 10, 10]), (2, [50, 50], 2, [60, 60]) ] expected_output = [\\"Possible\\", \\"Possible\\"] assert can_pack_products(T, test_cases) == expected_output def test_case_4(): T = 1 test_case = [ (5, [1, 1, 1, 1, 1], 1, [5]) ] expected_output = [\\"Possible\\"] assert can_pack_products(T, test_case) == expected_output def test_case_5(): T = 1 test_case = [ (4, [25, 25, 25, 25], 4, [25, 25, 25, 25]) ] expected_output = [\\"Possible\\"] assert can_pack_products(T, test_case) == expected_output","solution":"def can_pack_products(T, test_cases): results = [] for case in test_cases: N, weights, M, limits = case if sum(weights) > sum(limits): results.append(\\"Impossible\\") continue weights.sort(reverse=True) limits.sort(reverse=True) box_index = 0 for weight in weights: if box_index >= M: results.append(\\"Impossible\\") break if limits[box_index] >= weight: limits[box_index] -= weight else: while box_index < M and limits[box_index] < weight: box_index += 1 if box_index >= M: results.append(\\"Impossible\\") break limits[box_index] -= weight else: results.append(\\"Possible\\") return results"},{"question":"def can_sort_by_reversing_subarray(arr): Determine if it is possible to sort the entire bookshelf by reversing exactly one contiguous subarray. Args: arr (List[int]): A list of integers representing the heights of the books on the shelf. Returns: bool: True if the bookshelf can be sorted by reversing one subarray, False otherwise. Examples: >>> can_sort_by_reversing_subarray([1, 2, 3, 4, 5]) True >>> can_sort_by_reversing_subarray([3, 2, 1, 4, 5]) True >>> can_sort_by_reversing_subarray([1, 5, 3, 4, 2]) False def solve(test_cases): Solve multiple test cases to determine if bookshelves can be sorted by reversing one subarray. Args: test_cases (List[List[int]]): A list of arrays where each array represents the heights of the books on the shelf. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" corresponding to each test case's result. Examples: >>> solve([[1, 2, 3, 4, 5], [3, 2, 1, 4, 5], [1, 5, 3, 4, 2]]) ['YES', 'YES', 'NO']","solution":"def can_sort_by_reversing_subarray(arr): n = len(arr) # Find the start of the subarray to reverse i = 0 while i < n - 1 and arr[i] <= arr[i + 1]: i += 1 if i == n - 1: # If already sorted return True # Find the end of the subarray to reverse j = n - 1 while j > 0 and arr[j] >= arr[j - 1]: j -= 1 # Reverse the subarray arr[i:j+1] and check if the array is sorted arr[i:j+1] = reversed(arr[i:j+1]) return arr == sorted(arr) def solve(test_cases): results = [] for case in test_cases: if can_sort_by_reversing_subarray(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def largest_valid_subgrid_size(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Calculate the size of the largest valid sub-grid for each test case. >>> largest_valid_subgrid_size(1, [(3, [\\"RRR\\", \\"RRR\\", \\"RRR\\"])]) [9] >>> largest_valid_subgrid_size(1, [(3, [\\"RBR\\", \\"BRB\\", \\"RBR\\"])]) [9] def process_input(data: str) -> Tuple[int, List[Tuple[int, List[str]]]]: Process the raw input data into a structured format. >>> process_input(\\"2n3nRRRnRRRnRRRn3nRBRnBRBnRBRn\\") (2, [(3, [\\"RRR\\", \\"RRR\\", \\"RRR\\"]), (3, [\\"RBR\\", \\"BRB\\", \\"RBR\\"])]) from typing import List, Tuple def test_same_color_grid(): T = 1 test_cases = [(3, [\\"RRR\\", \\"RRR\\", \\"RRR\\"])] assert largest_valid_subgrid_size(T, test_cases) == [9] def test_alternating_color_grid(): T = 1 test_cases = [(3, [\\"RBR\\", \\"BRB\\", \\"RBR\\"])] assert largest_valid_subgrid_size(T, test_cases) == [9] def test_mixed_color_grid(): T = 1 test_cases = [(3, [\\"RRB\\", \\"BRB\\", \\"RBR\\"])] assert largest_valid_subgrid_size(T, test_cases) == [4] def test_process_input(): sample_input = \\"2n3nRRRnRRRnRRRn3nRBRnBRBnRBRn\\" T, test_cases = process_input(sample_input) assert T == 2 assert test_cases == [(3, [\\"RRR\\", \\"RRR\\", \\"RRR\\"]), (3, [\\"RBR\\", \\"BRB\\", \\"RBR\\"])] def test_sample_cases(): sample_input = \\"2n3nRRRnRRRnRRRn3nRBRnBRBnRBRn\\" T, test_cases = process_input(sample_input) assert largest_valid_subgrid_size(T, test_cases) == [9, 9]","solution":"def largest_valid_subgrid_size(T, test_cases): def same_color(cells): color = cells[0][0] for row in cells: if any(cell != color for cell in row): return False return True def alternating_pattern(cells): for i in range(len(cells)): for j in range(len(cells[i])): expected_color = 'R' if (i + j) % 2 == 0 else 'B' if cells[i][j] != expected_color: return False return True def max_valid_size(grid, N): for size in range(N, 0, -1): for i in range(N - size + 1): for j in range(N - size + 1): subgrid = [row[j:j+size] for row in grid[i:i+size]] if same_color(subgrid) or alternating_pattern(subgrid): return size return 1 results = [] for case in test_cases: N, grid = case results.append(max_valid_size(grid, N) ** 2) return results # Sample input processing def process_input(data): lines = data.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) grid = [lines[idx + i + 1] for i in range(N)] test_cases.append((N, grid)) idx += N + 1 return T, test_cases # Sample input reading sample_input = \\"2n3nRRRnRRRnRRRn3nRBRnBRBnRBRn\\" T, test_cases = process_input(sample_input) print(largest_valid_subgrid_size(T, test_cases))"},{"question":"def is_valid_preference(n, preferences): Determines if the list of preferred days is valid. :param n: Number of consecutive days. :param preferences: List of preferred days. :return: \\"Yes\\" if valid, \\"No\\" if not. pass def check_meeting_preferences(t, test_cases): Checks the validity of multiple test cases. :param t: Number of test cases. :param test_cases: List of tuples, each with (n, preferences). :return: List containing \\"Yes\\" or \\"No\\" for each test case. pass # Unit tests from solution import is_valid_preference, check_meeting_preferences def test_single_case_yes(): assert is_valid_preference(3, [1, 3, 2]) == \\"Yes\\" def test_single_case_no(): assert is_valid_preference(3, [3, 1, 1]) == \\"No\\" def test_multiple_cases(): test_cases = [ (3, [1, 3, 2]), (4, [4, 3, 2, 1]), (5, [2, 3, 5, 1, 4]), (3, [3, 1, 1]) ] expected = [\\"Yes\\", \\"Yes\\", \\"Yes\\", \\"No\\"] assert check_meeting_preferences(len(test_cases), test_cases) == expected def test_single_element(): assert is_valid_preference(1, [1]) == \\"Yes\\" def test_missing_element(): assert is_valid_preference(4, [1, 2, 4]) == \\"No\\" def test_additional_element(): assert is_valid_preference(3, [1, 2, 3, 4]) == \\"No\\"","solution":"def is_valid_preference(n, preferences): Determines if the list of preferred days is valid. :param n: Number of consecutive days. :param preferences: List of preferred days. :return: \\"Yes\\" if valid, \\"No\\" if not. return \\"Yes\\" if sorted(preferences) == list(range(1, n+1)) else \\"No\\" def check_meeting_preferences(t, test_cases): Checks the validity of multiple test cases. :param t: Number of test cases. :param test_cases: List of tuples, each with (n, preferences). :return: List containing \\"Yes\\" or \\"No\\" for each test case. results = [] for n, preferences in test_cases: results.append(is_valid_preference(n, preferences)) return results"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. Args: s (str): The string to be processed. Returns: int: The length of the longest unique character substring in s, or 0 if s is empty. pass from solution import longest_unique_substring def test_longest_unique_substring_example_1(): assert longest_unique_substring(\\"abcabcbb\\") == 3 def test_longest_unique_substring_example_2(): assert longest_unique_substring(\\"bbbbb\\") == 1 def test_longest_unique_substring_example_3(): assert longest_unique_substring(\\"pwwkew\\") == 3 def test_longest_unique_substring_empty_string(): assert longest_unique_substring(\\"\\") == 0 def test_longest_unique_substring_single_char(): assert longest_unique_substring(\\"a\\") == 1 def test_longest_unique_substring_all_unique(): assert longest_unique_substring(\\"abcdef\\") == 6 def test_longest_unique_substring_repeating_patterns(): assert longest_unique_substring(\\"abcabcabcd\\") == 4 def test_longest_unique_substring_contains_special_chars(): assert longest_unique_substring(\\"!@%^&*()_+\\") == 11","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. Args: s (str): The string to be processed. Returns: int: The length of the longest unique character substring in s, or 0 if s is empty. if not s: return 0 char_map = {} max_length = 0 start = 0 for end in range(len(s)): if s[end] in char_map: # Move the start pointer to the right of the previous index of s[end] start = max(start, char_map[s[end]] + 1) char_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def can_find_subset(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: For each test case, determine if there exists a non-empty subset of cards such that the sum of the numbers on the subset is a multiple of m. >>> can_find_subset(3, [(5, 3, [1, 2, 3, 4, 5]), (4, 5, [5, 10, 15, 20]), (3, 11, [1, 2, 3])]) ['YES', 'YES', 'NO'] >>> can_find_subset(1, [(3, 10, [1, 2, 3])]) ['NO'] >>> can_find_subset(1, [(4, 15, [5, 7, 8, 10])]) ['YES']","solution":"def can_find_subset(t, test_cases): results = [] for case in test_cases: n, m, cards = case found = False for i in range(1, 1 << n): subset_sum = 0 for j in range(n): if i & (1 << j): subset_sum += cards[j] if subset_sum % m == 0: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results # Wrapper function to help with the input format def solve_problem(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n, m = map(int, lines[index].split()) cards = list(map(int, lines[index + 1].split())) test_cases.append((n, m, cards)) index += 2 return can_find_subset(t, test_cases)"},{"question":"def generate_christmas_tree(height): Generates a Christmas tree of a given height. >>> generate_christmas_tree(3) \\" * n *** n*****\\" >>> generate_christmas_tree(5) \\" * n *** n ***** n ******* n*********\\" def generate_trees(test_cases): Generates all trees based on the given test cases. >>> generate_trees([3]) \\" * n *** n*****\\" >>> generate_trees([3, 5]) \\" * n *** n*****nn * n *** n ***** n ******* n*********\\" def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [int(data[i]) for i in range(1, T + 1)] print(generate_trees(test_cases)) if __name__ == \\"__main__\\": main()","solution":"def generate_christmas_tree(height): Generates a Christmas tree of a given height. tree = [] for i in range(height): stars = '*' * (2 * i + 1) tree.append(stars.center(2 * height - 1)) return \\"n\\".join(tree) def generate_trees(test_cases): Generates all trees based on the given test cases. results = [] for height in test_cases: results.append(generate_christmas_tree(height)) return \\"nn\\".join(results) def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [int(data[i]) for i in range(1, T + 1)] print(generate_trees(test_cases)) if __name__ == \\"__main__\\": main()"},{"question":"def longest_zigzag_subsequence(arr: List[int]) -> int: Find the length of the longest zigzag subsequence within a given sequence of numbers. >>> longest_zigzag_subsequence([1, 7, 4, 9, 2]) 5 >>> longest_zigzag_subsequence([1, 4, 7, 2, 5, 9]) 4 >>> longest_zigzag_subsequence([10]) 1 >>> longest_zigzag_subsequence([10, 20]) 2 >>> longest_zigzag_subsequence([20, 10]) 2 >>> longest_zigzag_subsequence([1, 2, 3, 4, 5]) 2 >>> longest_zigzag_subsequence([5, 4, 3, 2, 1]) 2 >>> longest_zigzag_subsequence([7, 7, 7, 7, 7]) 1 >>> longest_zigzag_subsequence([1, 1000000000, 1, 1000000000, 1]) 5","solution":"def longest_zigzag_subsequence(arr): n = len(arr) if n == 0: return 0 inc = [1] * n dec = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: inc[i] = max(inc[i], dec[j] + 1) elif arr[i] < arr[j]: dec[i] = max(dec[i], inc[j] + 1) return max(max(inc), max(dec))"},{"question":"def smallestMDigitNum(N, M): Function to find the smallest M-digit number such that the sum of its digits is N. >>> smallestMDigitNum(9, 2) 18 >>> smallestMDigitNum(4, 3) 103 >>> smallestMDigitNum(26, 2) -1 def test_smallest_mdigit_num(): assert smallestMDigitNum(9, 2) == 18 assert smallestMDigitNum(4, 3) == 103 assert smallestMDigitNum(26, 2) == -1 assert smallestMDigitNum(5, 1) == 5 assert smallestMDigitNum(1, 1) == 1 assert smallestMDigitNum(10, 1) == -1 assert smallestMDigitNum(15, 2) == 69 # 69 is the smallest number with sum of digits 15 test_smallest_mdigit_num()","solution":"def smallestMDigitNum(N, M): Function to find the smallest M-digit number such that the sum of its digits is N. # The maximum possible sum of digits for an M-digit number is 9 * M if N > 9 * M: return -1 result = [0] * M for i in range(M-1, -1, -1): if N > 9: result[i] = 9 N -= 9 else: result[i] = N N = 0 # Edge case for numbers starting with zero if result[0] == 0: for i in range(1, M): if result[i] > 0: result[i] -= 1 result[0] = 1 break return int(\\"\\".join(map(str, result)))"},{"question":"class OperationProcessor: A class to process a series of operations on an initially empty list of integers. The operations include adding an integer to the list, removing an integer from the list, and finding the maximum integer in the list. If the list is empty when the maximum is requested, return \\"EMPTY\\". def __init__(self): Initialize an empty list self.lst = [] def add(self, x: int): Add the integer x to the list. pass def remove(self, x: int): Remove one occurrence of the integer x from the list. If x is not present in the list, do nothing. pass def find_max(self): Return the maximum integer in the list, or \\"EMPTY\\" if the list is empty. pass def test_add_operation(): op = OperationProcessor() op.add(1) assert op.lst == [1] op.add(5) assert op.lst == [1, 5] def test_remove_operation(): op = OperationProcessor() op.add(1) op.add(5) op.remove(1) assert op.lst == [5] op.remove(10) assert op.lst == [5] # Removing an element not in list, list remains unchanged op.remove(5) assert op.lst == [] def test_find_max_operation(): op = OperationProcessor() assert op.find_max() == \\"EMPTY\\" # List is initially empty op.add(1) assert op.find_max() == 1 op.add(5) assert op.find_max() == 5 op.remove(5) assert op.find_max() == 1 op.remove(1) assert op.find_max() == \\"EMPTY\\" def test_mixed_operations(): op = OperationProcessor() op.add(3) op.add(10) op.add(5) assert op.find_max() == 10 op.remove(10) assert op.find_max() == 5 op.remove(3) op.remove(5) assert op.find_max() == \\"EMPTY\\"","solution":"class OperationProcessor: def __init__(self): self.lst = [] def add(self, x): self.lst.append(x) def remove(self, x): if x in self.lst: self.lst.remove(x) def find_max(self): if self.lst: return max(self.lst) else: return \\"EMPTY\\""},{"question":"def has_contiguous_subarray(lst, k): Determine if there exists a contiguous subarray that sums up to a given integer k. Args: lst (List[int]): List of integers. k (int): The target sum. Returns: bool: True if such a subarray exists, otherwise False. Examples: >>> has_contiguous_subarray([1, 2, 3, 4, 5], 9) True >>> has_contiguous_subarray([1, 2, 3, 7, 5], 12) True >>> has_contiguous_subarray([1, 2, 3, 4, 5], 20) False >>> has_contiguous_subarray([-1, 2, 3, -2, 3], 4) True >>> has_contiguous_subarray([1, 1, 1], 2) True","solution":"def has_contiguous_subarray(lst, k): Determine if there exists a contiguous subarray that sums up to k. current_sum = 0 seen_sums = {0} for num in lst: current_sum += num if current_sum - k in seen_sums: return True seen_sums.add(current_sum) return False"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Computes the shortest path length from the top-left corner to the bottom-right corner of a grid. The grid is modeled as an 'n x n' 2D array of integers, where: - \`0\` represents an empty cell, - \`1\` represents a cell with a shelf, - \`-1\` represents a blocked cell. The function returns the shortest path length if a path exists. If no such path exists, it returns -1. Parameters: grid (List[List[int]]): The grid representation of the warehouse. Returns: int: The length of the shortest path from the top-left corner to the bottom-right corner. If no path exists, returns -1. Examples: >>> shortest_path([ ... [0, 0, 0, 0], ... [1, -1, -1, 0], ... [0, 0, 0, 0], ... [0, 1, 1, 0] ... ]) 6 >>> shortest_path([ ... [0, -1, 0], ... [-1, -1, 0], ... [0, 0, 0] ... ]) -1 >>> shortest_path([[0]]) 0 >>> shortest_path([[0, 0], [0, 0]]) 2 >>> shortest_path([[-1, 0], [0, 0]]) -1 >>> shortest_path([[0, 0], [0, -1]]) -1","solution":"from collections import deque def shortest_path(grid): n = len(grid) if grid[0][0] != 0 or grid[n-1][n-1] != 0: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == n-1 and c == n-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1 # Example Usage: # grid = [ # [0, 0, 0, 0], # [1, -1, -1, 0], # [0, 0, 0, 0], # [0, 1, 1, 0] # ] # print(shortest_path(grid)) # Output: 6"},{"question":"from typing import List from collections import deque def min_moves_to_reach_end(N: int, M: int, grid: List[List[int]]) -> int: Given an NxM grid of cells where each cell is either empty or blocked, determine the minimum number of moves required to reach the bottom-right cell from the top-left cell. Return -1 if it's impossible to reach the goal. >>> min_moves_to_reach_end(3, 3, [ [0, 1, 0], [0, 0, 0], [0, 1, 0] ]) 4 >>> min_moves_to_reach_end(2, 2, [ [0, 1], [1, 0] ]) -1","solution":"from collections import deque def min_moves_to_reach_end(N, M, grid): Given an NxM grid, finds the minimum number of moves required to go from (0, 0) to (N-1, M-1) if possible. The function returns -1 if it is not possible to reach the bottom-right cell. if grid[0][0] == 1 or grid[N-1][M-1] == 1: return -1 moves = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if (r, c) == (N-1, M-1): return dist for dr, dc in moves: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"from typing import List def product_of_all_other_integers(arr: List[int]) -> List[int]: Returns a list where each element at index i is the product of all integers in the input list except the one at index i. >>> product_of_all_other_integers([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_of_all_other_integers([3, 2, 1]) [2, 3, 6] >>> product_of_all_other_integers([]) [] >>> product_of_all_other_integers([10]) [1] >>> product_of_all_other_integers([2, 3]) [3, 2] >>> product_of_all_other_integers([1, 0, 3]) [0, 3, 0] >>> product_of_all_other_integers([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_of_all_other_integers(arr): Returns a list where each element at index i is the product of all integers in the input list except the one at index i. n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n output = [1] * n # Compute the products of all elements to the left of each index for i in range(1, n): left_products[i] = left_products[i - 1] * arr[i - 1] # Compute the products of all elements to the right of each index for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * arr[i + 1] # Multiply left and right products together for the final result for i in range(n): output[i] = left_products[i] * right_products[i] return output"},{"question":"def most_frequent_digit(n: int) -> int: Returns the most common digit in the integer n. If there is a tie for the most common digit, return the largest digit among those tied. Examples: >>> most_frequent_digit(122333) 3 >>> most_frequent_digit(9876543210) 9 >>> most_frequent_digit(1122334455) 5 >>> most_frequent_digit(1) 1 >>> most_frequent_digit(99990000) 9","solution":"def most_frequent_digit(n): Returns the most common digit in the integer n. If there is a tie for the most common digit, returns the largest digit among those tied. from collections import Counter # Convert the number to a string to iterate over digits digits = str(n) # Use Counter to count occurrences of each digit digit_counts = Counter(digits) # Find the maximum count max_count = max(digit_counts.values()) # Collect all digits with the maximum count most_frequent_digits = [digit for digit, count in digit_counts.items() if count == max_count] # Return the largest digit among the most frequent ones return int(max(most_frequent_digits))"},{"question":"def count_binary_palindromes(n: int) -> int: Returns the number of binary palindromes of length n. >>> count_binary_palindromes(1) 2 >>> count_binary_palindromes(2) 2 >>> count_binary_palindromes(3) 4 >>> count_binary_palindromes(4) 4 >>> count_binary_palindromes(5) 8 def count_palindromes_for_multiple_cases(test_cases: List[int]) -> List[int]: Returns a list with the number of binary palindromes for each test case. >>> count_palindromes_for_multiple_cases([1, 2, 3]) [2, 2, 4] >>> count_palindromes_for_multiple_cases([4, 5, 6]) [4, 8, 8]","solution":"def count_binary_palindromes(n): Returns the number of binary palindromes of length n. if n == 1: return 2 # '0' and '1' if n % 2 == 0: return 2 ** (n // 2) else: return 2 ** ((n // 2) + 1) def count_palindromes_for_multiple_cases(test_cases): results = [] for n in test_cases: results.append(count_binary_palindromes(n)) return results"},{"question":"def checkWinner(board): Function to check if there is a winner in a Tic-Tac-Toe game. Args: board (list of list of int): A 3x3 matrix where 0 represents an empty cell, 1 represents a move by player 1, and 2 represents a move by player 2. Returns: int: 1 if player 1 wins, 2 if player 2 wins, 0 if there is no winner.","solution":"def checkWinner(board): Function to check if there is a winner in a Tic-Tac-Toe game. Args: board (list of list of int): A 3x3 matrix where 0 represents an empty cell, 1 represents a move by player 1, and 2 represents a move by player 2. Returns: int: 1 if player 1 wins, 2 if player 2 wins, 0 if there is no winner. for i in range(3): # Check rows and columns if board[i][0] == board[i][1] == board[i][2] != 0: return board[i][0] if board[0][i] == board[1][i] == board[2][i] != 0: return board[0][i] # Check diagonals if board[0][0] == board[1][1] == board[2][2] != 0: return board[0][0] if board[0][2] == board[1][1] == board[2][0] != 0: return board[0][2] # No winner return 0"},{"question":"def process_queries(N, Q, S, queries): Process a series of queries to promote employees or find the highest capable employee. Args: N (int): number of employees. Q (int): number of queries. S (List[int]): initial skill levels of employees. queries (List[str]): list of queries as strings. Returns: List[int]: results of \\"1\\" type queries. >>> process_queries(5, 5, [10, 30, 20, 50, 40], [\\"1 25\\", \\"0 3 20\\", \\"1 45\\", \\"0 2 25\\", \\"1 55\\"]) [5, 4, 2] >>> process_queries(3, 2, [1, 2, 3], [\\"1 4\\", \\"1 2\\"]) [-1, 3] >>> process_queries(4, 3, [5, 10, 15, 20], [\\"0 1 100\\", \\"0 4 50\\", \\"1 90\\"]) [1] >>> process_queries(5, 4, [1, 2, 3, 4, 5], [\\"1 3\\", \\"1 6\\", \\"1 1\\", \\"1 5\\"]) [5, -1, 5, 5]","solution":"def process_queries(N, Q, S, queries): results = [] for query in queries: parts = query.split() if parts[0] == '0': # Promote employee i = int(parts[1]) - 1 x = int(parts[2]) S[i] += x elif parts[0] == '1': # Query highest capable employee x = int(parts[1]) result = -1 for i in range(N-1, -1, -1): if S[i] >= x: result = i + 1 break results.append(result) return results"},{"question":"from typing import List, Tuple def analyze_genres(n: int, genres: List[str]) -> Tuple[int, str]: Analyze the genres in Alice's reading list. Parameters: n (int): the number of books genres (List[str]): list of genres Returns: Tuple[int, str]: (number of unique genres, most frequent genre(s) as a space separated string) pass # Unit tests def test_example_input1(): n = 7 genres = [\\"mystery\\", \\"fantasy\\", \\"mystery\\", \\"sci-fi\\", \\"fantasy\\", \\"fantasy\\", \\"mystery\\"] result = analyze_genres(n, genres) assert result == (3, \\"fantasy mystery\\") def test_example_input2(): n = 5 genres = [\\"romance\\", \\"thriller\\", \\"romance\\", \\"thriller\\", \\"romance\\"] result = analyze_genres(n, genres) assert result == (2, \\"romance\\") def test_single_genre(): n = 4 genres = [\\"horror\\", \\"horror\\", \\"horror\\", \\"horror\\"] result = analyze_genres(n, genres) assert result == (1, \\"horror\\") def test_multiple_unique_genres(): n = 4 genres = [\\"horror\\", \\"comedy\\", \\"drama\\", \\"romance\\"] result = analyze_genres(n, genres) assert result == (4, \\"comedy drama horror romance\\") def test_two_highest_frequencies(): n = 6 genres = [\\"drama\\", \\"drama\\", \\"fantasy\\", \\"fantasy\\", \\"romantic\\", \\"romantic\\"] result = analyze_genres(n, genres) assert result == (3, \\"drama fantasy romantic\\")","solution":"def analyze_genres(n, genres): Analyze the genres in Alice's reading list. Parameters: n (int): the number of books genres (list of str): list of genres Returns: tuple: (number of unique genres, most frequent genre(s) as a space separated string) from collections import Counter genre_counts = Counter(genres) unique_genres_count = len(genre_counts) max_frequency = max(genre_counts.values()) most_frequent_genres = [genre for genre, count in genre_counts.items() if count == max_frequency] most_frequent_genres.sort() return unique_genres_count, ' '.join(most_frequent_genres)"},{"question":"from typing import List def longest_zigzag(arr: List[int]) -> int: Determine the length of the longest contiguous subsequence that forms a zigzag sequence. A zigzag sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. Examples: >>> longest_zigzag([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag([1, 4, 7, 2, 5]) 4 >>> longest_zigzag([1, 2, 3, 4, 5]) 2 from solution import longest_zigzag def test_example_cases(): assert longest_zigzag([1, 7, 4, 9, 2, 5]) == 6 assert longest_zigzag([1, 4, 7, 2, 5]) == 4 assert longest_zigzag([1, 2, 3, 4, 5]) == 2 def test_single_element(): assert longest_zigzag([1]) == 1 assert longest_zigzag([10]) == 1 def test_all_increasing(): assert longest_zigzag([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2 def test_all_decreasing(): assert longest_zigzag([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 2 def test_alternate(): assert longest_zigzag([1, 3, 2, 4, 3, 5, 4, 6, 5, 7]) == 10 def test_same_elements(): assert longest_zigzag([5, 5, 5, 5, 5, 5, 5, 5]) == 1 def test_large_input(): # create a test case with alternating increasing and decreasing values input_large = [i if i % 2 == 0 else -i for i in range(1, 10001)] assert longest_zigzag(input_large) == 10000","solution":"def longest_zigzag(arr): if len(arr) == 1: return 1 increase = decrease = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: increase = decrease + 1 elif arr[i] < arr[i - 1]: decrease = increase + 1 return max(increase, decrease)"},{"question":"def tsp_solver(input_data: str) -> int: Solve the Traveling Salesman Problem for the given input data. The function should take the input data containing the number of delivery locations and the adjacency matrix of distances between locations, and return the minimum sum of distances for a round trip route. Input - The first line contains a single integer n (2 â‰¤ n â‰¤ 15) â€” the number of delivery locations. - The following n lines contain n integers each â€” the adjacency matrix of the distances between the locations, where the j-th integer in the i-th row is the distance from the i-th location to the j-th location. Output - Return a single integer â€” the minimum sum of distances of the round trip route. Examples: >>> tsp_solver(\\"4n0 10 15 20n10 0 35 25n15 35 0 30n20 25 30 0\\") 80 >>> tsp_solver(\\"3n0 5 9n5 0 7n9 7 0\\") 21","solution":"from itertools import permutations def find_min_tsp_cost(n, distance_matrix): min_cost = float('inf') locations = list(range(n)) for perm in permutations(locations[1:]): current_path = [0] + list(perm) + [0] current_cost = 0 for i in range(len(current_path) - 1): current_cost += distance_matrix[current_path[i]][current_path[i + 1]] min_cost = min(min_cost, current_cost) return min_cost def tsp_solver(input_data): lines = input_data.split(\\"n\\") n = int(lines[0]) distance_matrix = [list(map(int, line.split())) for line in lines[1:n+1]] return find_min_tsp_cost(n, distance_matrix)"},{"question":"from typing import List def can_partition(nums: List[int]) -> bool: Determine if there is any subset of these integers that can be partitioned into two groups with equal sums. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If the total sum is odd, we cannot partition it into two equal sum subsets if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for j in range(target_sum, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target_sum]"},{"question":"def knight_minimum_moves(N: int, M: int, obstacles: List[Tuple[int, int]]) -> int: Determine the minimum number of moves required for the knight to reach the bottom-right corner of the board or output -1 if it is not possible. >>> knight_minimum_moves(8, 2, [(2, 3), (4, 5)]) 6 >>> knight_minimum_moves(8, 3, [(1, 2), (3, 4), (5, 6)]) 6 >>> knight_minimum_moves(8, 0, []) 6 >>> knight_minimum_moves(5, 24, [(i, j) for i in range(5) for j in range(5) if not (i == 0 and j == 0 or i == 4 and j == 4)]) -1 pass def solve(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Solve the game for multiple test cases. >>> solve(1, [(8, 2, [(2, 3), (4, 5)])]) [6] >>> solve(1, [(8, 3, [(1, 2), (3, 4), (5, 6)])]) [6] >>> solve(1, [(8, 0, [])]) [6] >>> solve(1, [(5, 24, [(i, j) for i in range(5) for j in range(5) if not (i == 0 and j == 0 or i == 4 and j == 4)])]) [-1] pass","solution":"from collections import deque def knight_minimum_moves(N, M, obstacles): # Directions a knight can move on a chessboard knight_moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] # Convert obstacles list to a set of tuples for O(1) lookup obstacle_set = {(x, y) for x, y in obstacles} # BFS to find the shortest path q = deque([(0, 0, 0)]) # queue of (x, y, moves) visited = set([(0, 0)]) # set of visited positions while q: x, y, moves = q.popleft() if (x, y) == (N-1, N-1): return moves for dx, dy in knight_moves: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and (nx, ny) not in obstacle_set: visited.add((nx, ny)) q.append((nx, ny, moves + 1)) return -1 def solve(T, test_cases): results = [] for i in range(T): N, M, obstacles = test_cases[i] results.append(knight_minimum_moves(N, M, obstacles)) return results"},{"question":"def determine_group(X): Determines which group the student with given number X will run in. Parameters: X (int): The assigned number of the student. Returns: str: \\"First Group\\" if the student's number is even, \\"Second Group\\" if the student's number is odd. >>> determine_group(1) \\"Second Group\\" >>> determine_group(2) \\"First Group\\" >>> determine_group(7) \\"Second Group\\" >>> determine_group(4) \\"First Group\\" def process_test_cases(T, cases): Processes multiple test cases Parameters: T (int): Number of test cases cases (list of int): List of X values for each test case Returns: list of str: List of results for each test case >>> process_test_cases(3, [1, 4, 7]) [\\"Second Group\\", \\"First Group\\", \\"Second Group\\"] >>> process_test_cases(5, [5, 2, 13, 8, 11]) [\\"Second Group\\", \\"First Group\\", \\"Second Group\\", \\"First Group\\", \\"Second Group\\"] >>> process_test_cases(2, [10, 21]) [\\"First Group\\", \\"Second Group\\"] >>> process_test_cases(2, [999, 1000]) [\\"Second Group\\", \\"First Group\\"]","solution":"def determine_group(X): Determines which group the student with given number X will run in. Parameters: X (int): The assigned number of the student. Returns: str: \\"First Group\\" if the student's number is even, \\"Second Group\\" if the student's number is odd. if X % 2 == 0: return \\"First Group\\" else: return \\"Second Group\\" def process_test_cases(T, cases): Processes multiple test cases Parameters: T (int): Number of test cases cases (list of int): List of X values for each test case Returns: list of str: List of results for each test case results = [] for X in cases: results.append(determine_group(X)) return results"},{"question":"def find_top_k_performers(datasets): Determine the IDs of the top k performers in each dataset. pass def parse_input(input_str): Parse the input string into datasets. pass # Testing function with given input and output def main(): input_str = 5 3 101 95 102 90 103 95 104 85 105 90 4 2 201 100 202 100 203 50 204 50 0 0 datasets = parse_input(input_str) results = find_top_k_performers(datasets) for result in results: print(result) if __name__ == \\"__main__\\": main() def test_example_case(): input_str = \\"5 3n101 95n102 90n103 95n104 85n105 90n4 2n201 100n202 100n203 50n204 50n0 0\\" datasets = parse_input(input_str) expected_output = [\\"101 103 102\\", \\"201 202\\"] assert find_top_k_performers(datasets) == expected_output def test_all_same_scores(): input_str = \\"3 2n301 75n302 75n303 75n0 0\\" datasets = parse_input(input_str) expected_output = [\\"301 302\\"] assert find_top_k_performers(datasets) == expected_output def test_single_employee(): input_str = \\"1 1n401 60n0 0\\" datasets = parse_input(input_str) expected_output = [\\"401\\"] assert find_top_k_performers(datasets) == expected_output def test_single_dataset_multiple_top_k(): input_str = \\"6 3n501 90n502 85n503 85n504 80n505 80n506 75n0 0\\" datasets = parse_input(input_str) expected_output = [\\"501 502 503\\"] assert find_top_k_performers(datasets) == expected_output def test_no_employees(): input_str = \\"0 0\\" datasets = parse_input(input_str) expected_output = [] assert find_top_k_performers(datasets) == expected_output","solution":"def find_top_k_performers(datasets): results = [] for dataset in datasets: n, k = dataset[0] employees = dataset[1:] employees = sorted(employees, key=lambda x: (-x[1], x[0])) top_k_ids = [employee[0] for employee in employees[:k]] results.append(\\" \\".join(map(str, top_k_ids))) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") datasets = [] i = 0 while i < len(lines): n, k = map(int, lines[i].split()) if n == 0 and k == 0: break dataset = [(n, k)] for j in range(i+1, i+1+n): id_score = tuple(map(int, lines[j].split())) dataset.append(id_score) datasets.append(dataset) i += n + 1 return datasets # Testing function with given input and output def main(): input_str = 5 3 101 95 102 90 103 95 104 85 105 90 4 2 201 100 202 100 203 50 204 50 0 0 datasets = parse_input(input_str) results = find_top_k_performers(datasets) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_operations_to_transform(s, t): Returns the minimum number of operations needed to transform string s into string t by reversing substrings. >>> min_operations_to_transform(\\"abc\\", \\"cba\\") 1 >>> min_operations_to_transform(\\"axb\\", \\"xba\\") 2 >>> min_operations_to_transform(\\"abcd\\", \\"dcba\\") 1 >>> min_operations_to_transform(\\"abcdef\\", \\"fedcba\\") 1 >>> min_operations_to_transform(\\"a\\", \\"a\\") 0 >>> min_operations_to_transform(\\"ab\\", \\"ba\\") 1 pass def process_test_cases(T, cases): Processes multiple test cases and returns a list of results for each test case. Each result is the minimum number of operations needed to transform the first string into the second string. >>> process_test_cases(2, [(\\"abc\\", \\"cba\\"), (\\"axb\\", \\"xba\\")]) [1, 2] >>> process_test_cases(4, [(\\"abcd\\", \\"dcba\\"), (\\"abcdef\\", \\"fedcba\\"), (\\"a\\", \\"a\\"), (\\"ab\\", \\"ba\\")]) [1, 1, 0, 1] pass","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations needed to transform string s into string t by reversing substrings. new_s = list(s) count = 0 n = len(s) i = 0 while i < n: if new_s[i] != t[i]: j = i while j < n and new_s[j] != t[i]: j += 1 new_s[i:j+1] = reversed(new_s[i:j+1]) count += 1 i += 1 return count def process_test_cases(T, cases): results = [] for s, t in cases: results.append(min_operations_to_transform(s, t)) return results"},{"question":"def canFormPalindrome(strings: List[str]) -> str: Given a list of strings, check if any of the strings can be rearranged to form a palindrome. >>> canFormPalindrome([\\"carrace\\"]) \\"YES\\" >>> canFormPalindrome([\\"daily\\"]) \\"NO\\" >>> canFormPalindrome([\\"daily\\", \\"carrace\\"]) \\"YES\\" >>> canFormPalindrome([\\"daily\\", \\"apple\\"]) \\"NO\\" >>> canFormPalindrome([\\"carrace\\", \\"aabb\\"]) \\"YES\\" >>> canFormPalindrome([\\"a\\"]) \\"YES\\" >>> canFormPalindrome([\\"aaaa\\"]) \\"YES\\" >>> canFormPalindrome([\\"abc\\"]) \\"NO\\"","solution":"def canFormPalindrome(strings): def canBePalindrome(s): char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return False return True for s in strings: if canBePalindrome(s): return \\"YES\\" return \\"NO\\""},{"question":"def analyze_student_grades(student_records): Analyzes student grades from a list of student records of names and test scores. Returns a list of tuples containing student name and their average score up to 2 decimal places. Args: student_records (List[str]): List of student records in the format [\\"name score\\"]. Returns: List[Tuple[str, float]]: List of tuples with student name and their average score. >>> analyze_student_grades([\\"Alice 82\\", \\"Bob 75\\", \\"Alice 90\\", \\"Bob 63\\", \\"Charlie 100\\", \\"Alice 77\\"]) [(\\"Alice\\", 83.00), (\\"Bob\\", 69.00), (\\"Charlie\\", 100.00)] >>> analyze_student_grades([\\"Alice 80\\", \\"Alice 90\\", \\"Alice 70\\"]) [(\\"Alice\\", 80.00)]","solution":"def analyze_student_grades(student_records): Analyzes student grades from a list of student records of names and test scores. Returns a list of tuples containing student name and their average score up to 2 decimal places. from collections import defaultdict student_scores = defaultdict(list) # Collect scores for each student for record in student_records: name, score = record.split() score = int(score) student_scores[name].append(score) # Calculate average score for each student student_averages = {} for name, scores in student_scores.items(): avg_score = sum(scores) / len(scores) student_averages[name] = round(avg_score, 2) # Sort students by name and prepare output sorted_students = sorted(student_averages.items()) return sorted_students"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def findKthSmallest(root, k): Given the root of a binary search tree and an integer k, return the k-th smallest element in the BST. stack = [] while True: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right # Helper function to construct the BST from preorder traversal def build_bst_from_preorder(preorder): if not preorder: return None root = TreeNode(preorder[0]) for value in preorder[1:]: insert_into_bst(root, value) return root # Unit tests to verify the solution def test_kth_smallest(): preorder = [3, 1, 2, 4] k = 2 root = build_bst_from_preorder(preorder) assert findKthSmallest(root, k) == 2 def test_kth_smallest_first_element(): preorder = [3, 1, 2, 4] k = 1 root = build_bst_from_preorder(preorder) assert findKthSmallest(root, k) == 1 def test_kth_smallest_last_element(): preorder = [3, 1, 2, 4] k = 4 root = build_bst_from_preorder(preorder) assert findKthSmallest(root, k) == 4 def test_kth_smallest_middle_element(): preorder = [3, 1, 2, 4, 5] k = 3 root = build_bst_from_preorder(preorder) assert findKthSmallest(root, k) == 3 def test_single_element_bst(): preorder = [1] k = 1 root = build_bst_from_preorder(preorder) assert findKthSmallest(root, k) == 1 def test_left_heavy_bst(): preorder = [5, 3, 2, 1] k = 3 root = build_bst_from_preorder(preorder) assert findKthSmallest(root, k) == 3 def test_right_heavy_bst(): preorder = [1, 2, 3, 4, 5] k = 5 root = build_bst_from_preorder(preorder) assert findKthSmallest(root, k) == 5","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def findKthSmallest(root, k): Given the root of a binary search tree and an integer k, return the k-th smallest element in the BST. stack = [] while True: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right # Helper function to construct the BST from preorder traversal def build_bst_from_preorder(preorder): if not preorder: return None root = TreeNode(preorder[0]) for value in preorder[1:]: insert_into_bst(root, value) return root"},{"question":"def compress_string(s: str) -> str: Compresses the given string using run-length encoding. Parameters: s (str): The string to be compressed. Returns: str: The compressed string. pass def test_compress_string(): assert compress_string(\\"aaabccccddddd\\") == \\"a3bc4d5\\" assert compress_string(\\"abcdef\\") == \\"abcdef\\" assert compress_string(\\"aabbaa\\") == \\"a2b2a2\\" assert compress_string(\\"aaaaabaaaa\\") == \\"a5ba4\\" # Edge cases assert compress_string(\\"\\") == \\"\\" assert compress_string(\\"a\\") == \\"a\\" assert compress_string(\\"aa\\") == \\"a2\\" # Mixed characters assert compress_string(\\"abbbbbcccdde\\") == \\"ab5c3d2e\\" assert compress_string(\\"xyzzzzzyy\\") == \\"xyz5y2\\" # All same characters assert compress_string(\\"aaaaaaaaaa\\") == \\"a10\\" # Non-repeating characters assert compress_string(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"def compress_string(s: str) -> str: Compresses the given string using run-length encoding. Parameters: s (str): The string to be compressed. Returns: str: The compressed string. if not s: return s compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: if count > 1: compressed.append(f\\"{current_char}{count}\\") else: compressed.append(current_char) current_char = char count = 1 if count > 1: compressed.append(f\\"{current_char}{count}\\") else: compressed.append(current_char) return ''.join(compressed)"},{"question":"def can_be_palindrome_by_removal(S: str) -> str: Determines if the string S can be made a palindrome by removing at most one character. Parameters: S (str): The input string. Returns: str: \\"YES\\" if it is possible, \\"NO\\" otherwise. >>> can_be_palindrome_by_removal(\\"abcca\\") \\"YES\\" >>> can_be_palindrome_by_removal(\\"abcdef\\") \\"NO\\" >>> can_be_palindrome_by_removal(\\"a\\") \\"YES\\" >>> can_be_palindrome_by_removal(\\"ab\\") \\"YES\\" >>> can_be_palindrome_by_removal(\\"acca\\") \\"YES\\" >>> can_be_palindrome_by_removal(\\"bacab\\") \\"YES\\" >>> can_be_palindrome_by_removal(\\"ababa\\") \\"YES\\" >>> can_be_palindrome_by_removal(\\"abccbaabccba\\") \\"YES\\" >>> can_be_palindrome_by_removal(\\"a\\" * 99999 + \\"b\\") \\"YES\\" >>> can_be_palindrome_by_removal(\\"\\") \\"YES\\"","solution":"def can_be_palindrome_by_removal(S): Determines if the string S can be made a palindrome by removing at most one character. Parameters: S (str): The input string. Returns: str: \\"YES\\" if it is possible, \\"NO\\" otherwise. def is_palindrome_range(s, i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True n = len(S) left, right = 0, n - 1 while left < right: if S[left] != S[right]: if is_palindrome_range(S, left + 1, right) or is_palindrome_range(S, left, right - 1): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"def isReachable(grid, queries): Determines if the destination cell for each query is reachable from the starting cell. Args: grid: List[List[str]]: 2D grid representing the maze. queries: List[Tuple[int, int]]: List of queries where each query is a tuple (r, c). Returns: List[bool]: List indicating the reachability of each query's destination cell. pass from solution import isReachable def test_single_query_reachable(): grid = [ ['.', '.', '.', '#'], ['.', '#', '.', '.'], ['.', '#', '.', '.'], ['#', '.', '.', '.'] ] queries = [(3, 3)] assert isReachable(grid, queries) == [True] def test_single_query_unreachable(): grid = [ ['.', '.', '.', '#'], ['.', '#', '.', '.'], ['.', '#', '.', '.'], ['#', '.', '.', '.'] ] queries = [(2, 1)] assert isReachable(grid, queries) == [False] def test_multiple_queries(): grid = [ ['.', '.', '.', '#'], ['.', '#', '.', '.'], ['.', '#', '.', '.'], ['#', '.', '.', '.'] ] queries = [(3, 3), (2, 1), (0, 3)] assert isReachable(grid, queries) == [True, False, False] def test_all_unreachable(): grid = [ ['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#'] ] queries = [(0, 2), (1, 0), (2, 2)] assert isReachable(grid, queries) == [False, False, False] def test_all_reachable(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] queries = [(0, 2), (1, 0), (2, 2)] assert isReachable(grid, queries) == [True, True, True] def test_starting_point_blocked(): grid = [ ['#', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] queries = [(0, 2), (1, 0), (2, 2)] assert isReachable(grid, queries) == [False, False, False] def test_query_point_blocked(): grid = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ] queries = [(1, 1)] assert isReachable(grid, queries) == [False] def test_minimal_grid(): grid = [ ['.'] ] queries = [(0, 0)] assert isReachable(grid, queries) == [True]","solution":"def isReachable(grid, queries): Determines if the destination cell for each query is reachable from the starting cell. Args: grid: List[List[str]]: 2D grid representing the maze. queries: List[Tuple[int, int]]: List of queries where each query is a tuple (r, c). Returns: List[bool]: List indicating the reachability of each query's destination cell. N = len(grid) M = len(grid[0]) def bfs(start, end): BFS to determine if we can reach from start to end in the grid. from collections import deque queue = deque([start]) visited = set() visited.add(start) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: x, y = queue.popleft() if (x, y) == end: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny)) visited.add((nx, ny)) return False results = [] for query in queries: r, c = query if grid[0][0] == '#' or grid[r][c] == '#': results.append(False) else: results.append(bfs((0, 0), (r, c))) return results"},{"question":"from typing import List def max_tricks(N: int, M: int, P: List[int]) -> int: Given the number of magic tricks (N), the points required for each trick (P), and the total initial magic points (M), this function returns the maximum number of tricks Alice can perform. >>> max_tricks(3, 10, [4, 6, 8]) 2 >>> max_tricks(4, 20, [5, 5, 5, 5]) 4 >>> max_tricks(3, 5, [10, 20, 30]) 0 >>> max_tricks(3, 15, [5, 5, 5]) 3 >>> max_tricks(5, 10, [2, 3, 5, 7, 1]) 4 >>> max_tricks(4, 10**15, [10**9, 10**9, 10**9, 10**9]) 4","solution":"def max_tricks(N, M, P): Given the number of magic tricks (N), the points required for each trick (P), and the total initial magic points (M), this function returns the maximum number of tricks Alice can perform. P.sort() tricks_performed = 0 current_magic_points = M for points in P: if current_magic_points >= points: current_magic_points -= points tricks_performed += 1 current_magic_points += (points // 2) else: break return tricks_performed"},{"question":"def minimum_possible_max_difference(N: int, K: int, skill_levels: List[int]) -> int: Returns the minimum possible maximum difference between the strongest and weakest members of any team. >>> minimum_possible_max_difference(6, 3, [10, 20, 13, 40, 45, 50]) 10 >>> minimum_possible_max_difference(4, 2, [1, 3, 6, 9]) 2 from typing import List def test_sample_case(): assert minimum_possible_max_difference(6, 3, [10, 20, 13, 40, 45, 50]) == 10 def test_single_team(): assert minimum_possible_max_difference(5, 5, [1, 2, 3, 4, 5]) == 4 def test_adjacent_skills(): assert minimum_possible_max_difference(4, 2, [1, 3, 6, 9]) == 2 def test_large_input(): N = 100000 K = 50000 skill_levels = list(range(1, 100001)) assert minimum_possible_max_difference(N, K, skill_levels) == 49999 def test_all_same_skill(): assert minimum_possible_max_difference(4, 2, [5, 5, 5, 5]) == 0 def test_single_employee(): assert minimum_possible_max_difference(1, 1, [10]) == 0 def test_minimal_case(): assert minimum_possible_max_difference(2, 1, [1, 1000000000]) == 0","solution":"def minimum_possible_max_difference(N, K, skill_levels): Returns the minimum possible maximum difference between the strongest and weakest members of any team. # Sort skill levels to consider the contiguous possible subsets for minimized max difference skill_levels.sort() # Initialize the minimum possible maximum difference to a large number min_max_diff = float('inf') # Loop through the sorted list and evaluate the difference in each group of K members for i in range(N - K + 1): # Check the difference between the highest and lowest in this K-sized window current_diff = skill_levels[i + K - 1] - skill_levels[i] # Update min_max_diff if the current difference is smaller min_max_diff = min(min_max_diff, current_diff) return min_max_diff"},{"question":"def calculate_delivery_cost(weight: int, distance: int) -> float: Calculate the total cost of sending a package based on weight and distance. :param weight: int, weight of the package in kg :param distance: int, distance the package needs to travel in km :return: float, total cost to send the package >>> calculate_delivery_cost(2, 150) # 2 kg, 150 km 51.0 >>> calculate_delivery_cost(1, 200) # 1 kg, 200 km 65.0 >>> calculate_delivery_cost(4, 50) # 4 kg, 50 km 37.0 >>> calculate_delivery_cost(10, 1200) # 10 kg, 1200 km 260.0 >>> calculate_delivery_cost(7, 50) # 7 kg, 50 km 39.0 >>> calculate_delivery_cost(2, 500) # 2 kg, 500 km 156.0 >>> calculate_delivery_cost(3, 2000) # 3 kg, 2000 km 409.0","solution":"def calculate_delivery_cost(weight, distance): Calculate the total cost of sending a package based on weight and distance. :param weight: int, weight of the package in kg :param distance: int, distance the package needs to travel in km :return: float, total cost to send the package # Determine weight cost if weight <= 1: weight_cost = 5 * weight elif weight <= 5: weight_cost = 3 * weight else: weight_cost = 2 * weight # Determine distance cost if distance <= 100: distance_cost = 0.50 * distance elif distance <= 1000: distance_cost = 0.30 * distance else: distance_cost = 0.20 * distance # Total cost total_cost = weight_cost + distance_cost return total_cost"},{"question":"def check_salaries(N, P, S): Checks if the salary distribution satisfies the condition that every supervisor has a salary equal to or greater than any of their direct subordinates. Parameters: N (int): Number of employees P (list of int): List where P[i] denotes the supervisor of the i-th employee S (list of int): List where S[i] denotes the salary of the i-th employee Returns: str: \\"YES\\" if the conditions are meet, otherwise \\"NO\\" def test_case_1(): assert check_salaries(6, [-1, 1, 1, 2, 2, 3], [3000, 2000, 2500, 1800, 1700, 1600]) == \\"YES\\" def test_case_2(): assert check_salaries(4, [-1, 1, 1, 2], [4000, 3000, 2000, 3500]) == \\"NO\\" def test_case_3(): assert check_salaries(3, [-1, 1, 1], [1000, 1000, 999]) == \\"YES\\" def test_case_4(): assert check_salaries(2, [-1, 1], [500, 600]) == \\"NO\\" def test_case_5(): assert check_salaries(1, [-1], [1000000000]) == \\"YES\\" def test_case_6(): assert check_salaries(5, [-1, 1, 2, 2, 3], [5000, 4000, 3500, 3000, 2000]) == \\"YES\\"","solution":"def check_salaries(N, P, S): Checks if the salary distribution satisfies the condition that every supervisor has a salary equal to or greater than any of their direct subordinates. Parameters: N (int): Number of employees P (list of int): List where P[i] denotes the supervisor of the i-th employee S (list of int): List where S[i] denotes the salary of the i-th employee Returns: str: \\"YES\\" if the conditions are meet, otherwise \\"NO\\" from collections import defaultdict # Convert to 1-based index P = [-1] + P S = [0] + S subordinates = defaultdict(list) for i in range(1, N + 1): if P[i] != -1: subordinates[P[i]].append(i) def dfs(employee): current_salary = S[employee] for sub in subordinates[employee]: if current_salary < S[sub]: return False if not dfs(sub): return False return True return \\"YES\\" if dfs(1) else \\"NO\\""},{"question":"def construct_string(n: int) -> str: Constructs a string of length n such that for any two non-overlapping substrings a and b of the same length, the number of differing characters between a and b is at least half of the length of a (rounded up). >>> construct_string(4) == '0101' or construct_string(4) == '1010' True >>> construct_string(6) == '010101' or construct_string(6) == '101010' True >>> construct_string(5) == '01010' or construct_string(5) == '10101' True","solution":"def construct_string(n): Constructs a string of length n such that for any two non-overlapping substrings a and b of the same length, the number of differing characters between a and b is at least half of the length of a (rounded up). s = \\"\\" for i in range(n): s += '0' if i % 2 == 0 else '1' return s"},{"question":"def find_majority_element(nums): Returns the majority element from the list of integers \`nums\`. The majority element is the element that appears more than âŒŠn / 2âŒ‹ times. >>> find_majority_element([3, 2, 3]) 3 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> find_majority_element([1,2,3,2,2,2,2]) 2 >>> find_majority_element([3,3,4,2,4,4,4,4]) 4 >>> find_majority_element([10,9,9,9,10,10,10,10]) 10 # Your code here def test_majority_element_simple(): assert find_majority_element([3, 2, 3]) == 3 assert find_majority_element([2, 2, 1, 1, 1, 2, 2]) == 2 def test_majority_element_single_element(): assert find_majority_element([1]) == 1 assert find_majority_element([2]) == 2 def test_majority_element_all_same(): assert find_majority_element([1, 1, 1, 1]) == 1 assert find_majority_element([5, 5, 5, 5, 5]) == 5 def test_majority_element_more_complex_cases(): assert find_majority_element([1, 2, 3, 2, 2, 2, 2]) == 2 assert find_majority_element([3, 3, 4, 2, 4, 4, 4, 4]) == 4 assert find_majority_element([10, 9, 9, 9, 10, 10, 10, 10]) == 10 def test_majority_element_edge_cases(): assert find_majority_element([0, 0, 0, 1, 2, 3, 0, 0, 0]) == 0 assert find_majority_element([1, 2, 1, 2, 1, 2, 1, 1, 1]) == 1","solution":"def find_majority_element(nums): Returns the majority element from the list of integers \`nums\`. The majority element is the element that appears more than âŒŠn / 2âŒ‹ times. count = 0 candidate = None for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) return candidate"},{"question":"def count_ways_to_sum(n): Returns the number of distinct ways to represent \`n\` as the sum of one or more consecutive positive integers. def process_test_cases(T, cases): Processes multiple test cases and returns the results for each case. # Test cases def test_single_number(): assert count_ways_to_sum(15) == 4 assert count_ways_to_sum(10) == 2 assert count_ways_to_sum(1) == 1 assert count_ways_to_sum(9) == 3 def test_process_multiple_cases(): assert process_test_cases(2, [15, 10]) == [4, 2] assert process_test_cases(3, [1, 9, 41]) == [1, 3, 2] def test_large_numbers(): assert count_ways_to_sum(10**12) > 0 assert count_ways_to_sum(10**6) > 0","solution":"def count_ways_to_sum(n): Returns the number of distinct ways to represent \`n\` as the sum of one or more consecutive positive integers. count = 0 k = 1 while k * (k + 1) // 2 < n: k += 1 while k > 0: if (n - k * (k + 1) // 2) % k == 0: count += 1 k -= 1 return count def process_test_cases(T, cases): results = [] for case in cases: results.append(count_ways_to_sum(case)) return results"},{"question":"class SegmentTree2D: def __init__(self, grid): self.n = len(grid) self.m = len(grid[0]) self.build(grid) def build(self, grid): Builds the 2D segment tree for range maximum queries. pass def query(self, row1, col1, row2, col2): Queries the maximum value in the sub-rectangle from (row1, col1) to (row2, col2). pass def solve(grid, queries): Performs range maximum queries on the grid. Args: grid: List[List[int]]. A 2D array representing the grid. queries: List[Tuple[int, int, int, int]]. A list of tuples, where each tuple represents the top-left and bottom-right corners of the sub-rectangle for each query. Returns: List[int]: The results of maximum value queries for each specified sub-rectangle. >>> grid = [ [1, 6, 2], [8, 3, 9], [4, 5, 7] ] >>> queries = [ (0, 0, 1, 1), (1, 1, 2, 2), (0, 0, 2, 2) ] >>> solve(grid, queries) [8, 9, 9] seg_tree = SegmentTree2D(grid) results = [] for x1, y1, x2, y2 in queries: results.append(seg_tree.query(x1, y1, x2, y2)) return results def test_solve(): grid = [ [1, 6, 2], [8, 3, 9], [4, 5, 7] ] queries = [ (0, 0, 1, 1), (1, 1, 2, 2), (0, 0, 2, 2) ] expected_output = [8, 9, 9] assert solve(grid, queries) == expected_output def test_single_cell(): grid = [ [1] ] queries = [ (0, 0, 0, 0) ] expected_output = [1] assert solve(grid, queries) == expected_output def test_row_query(): grid = [ [1, 6, 2], [8, 3, 9], [4, 5, 7] ] queries = [ (0, 1, 0, 2) ] expected_output = [6] assert solve(grid, queries) == expected_output def test_column_query(): grid = [ [1, 6, 2], [8, 3, 9], [4, 5, 7] ] queries = [ (1, 0, 2, 0) ] expected_output = [8] assert solve(grid, queries) == expected_output def test_entire_grid(): grid = [ [1, 6, 2], [8, 3, 9], [4, 5, 7] ] queries = [ (0, 0, 2, 2) ] expected_output = [9] assert solve(grid, queries) == expected_output","solution":"class SegmentTree2D: def __init__(self, grid): self.n = len(grid) self.m = len(grid[0]) self.tree = [[0] * (2 * self.m) for _ in range(2 * self.n)] self.build(grid) def build(self, grid): for i in range(self.n): for j in range(self.m): self.tree[i + self.n][j + self.m] = grid[i][j] for i in range(self.n): for j in range(self.m - 1, 0, -1): self.tree[i + self.n][j] = max(self.tree[i + self.n][j << 1], self.tree[i + self.n][j << 1 | 1]) for i in range(self.n - 1, 0, -1): for j in range(2 * self.m): self.tree[i][j] = max(self.tree[i << 1][j], self.tree[i << 1 | 1][j]) def query(self, row1, col1, row2, col2): row1 += self.n row2 += self.n col1 += self.m col2 += self.m res = 0 while row1 <= row2: if row1 & 1: res = max(res, self.query_col(col1, col2, row1)) row1 += 1 if not (row2 & 1): res = max(res, self.query_col(col1, col2, row2)) row2 -= 1 row1 >>= 1 row2 >>= 1 return res def query_col(self, col1, col2, row): res = 0 while col1 <= col2: if col1 & 1: res = max(res, self.tree[row][col1]) col1 += 1 if not (col2 & 1): res = max(res, self.tree[row][col2]) col2 -= 1 col1 >>= 1 col2 >>= 1 return res def solve(grid, queries): seg_tree = SegmentTree2D(grid) results = [] for x1, y1, x2, y2 in queries: results.append(seg_tree.query(x1, y1, x2, y2)) return results"},{"question":"def generate_sequences(t: int, cases: List[Tuple[int, int, int]]) -> List[str]: Generate special sequences for each test case. Parameters: t (int): Number of test cases. cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers A, B, and M. Returns: List[str]: A list containing the generated sequences for each test case. >>> generate_sequences(2, [(1, 2, 5), (3, 4, 3)]) [\\"1 3 5 7 9\\", \\"3 7 11\\"] >>> generate_sequences(1, [(5, 1, 10)]) [\\"5 6 7 8 9 10 11 12 13 14\\"] def format_output(sequences: List[str]) -> str: Format the output of sequences as expected with a newline separating them. Parameters: sequences (List[str]): List of sequences as strings. Returns: str: Formatted string with sequences separated by newlines. >>> format_output([\\"1 3 5 7 9\\", \\"3 7 11\\"]) \\"1 3 5 7 9nn3 7 11\\" >>> format_output([\\"5 6 7 8 9 10 11 12 13 14\\"]) \\"5 6 7 8 9 10 11 12 13 14\\"","solution":"def generate_sequences(t, cases): This function generates special sequences for each test case. Parameters: t (int): Number of test cases. cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers A, B, and M. Returns: List[str]: A list containing the generated sequences for each test case. results = [] for case in cases: A, B, M = case sequence = [] for i in range(M): sequence.append(A + i * B) results.append(\\" \\".join(map(str, sequence))) return results def format_output(sequences): This function formats the output of sequences as expected with a newline separating them. Parameters: sequences (List[str]): List of sequences as strings. Returns: str: Formatted string with sequences separated by newlines. return \\"nn\\".join(sequences)"},{"question":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU Cache with a given capacity. Args: capacity (int): the maximum number of items that can be stored in the cache. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Get the value of the key if the key exists in the cache, otherwise return -1. Args: key (int): the key whose value has to be fetched. Returns: int: the value of the key if it exists, otherwise -1. def put(self, key: int, value: int) -> None: Insert the value by the key into the cache. If the key already exists, update the value. Args: key (int): the key to insert or update. value (int): the value to be inserted. import pytest def test_lru_cache_operations(): # Example 1 cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1, cache should be {2=2, 1=1} cache.put(3, 3) assert cache.get(2) == -1 # returns -1 (not found), cache should be {1=1, 3=3} cache.put(4, 4) assert cache.get(1) == -1 # returns -1 (not found), cache should be {3=3, 4=4} assert cache.get(3) == 3 # returns 3, cache should be {4=4, 3=3} assert cache.get(4) == 4 # returns 4, cache should be {3=3, 4=4} def test_lru_cache_overwrite(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # cache should be {2=2, 1=1} cache.put(1, 10) assert cache.get(1) == 10 # cache should be {2=2, 1=10} def test_lru_cache_eviction(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) # 1 should be evicted assert cache.get(1) == -1 assert cache.get(2) == 2 assert cache.get(3) == 3 cache.put(4, 4) # 2 should be evicted assert cache.get(2) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key, last=True) # Marks the key as recently used return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key, last=True) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Removes the least recently used item"},{"question":"from typing import List, Tuple def custom_sort(data: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts a list of tuples based on score in descending order and name in ascending order if scores are equal. Parameters: data (list of tuples): Each tuple contains a string (name) and an integer (score). Returns: list of tuples: Sorted list based on the criteria. >>> custom_sort([(\\"john\\", 75), (\\"jane\\", 85), (\\"doe\\", 75), (\\"alice\\", 90)]) [('alice', 90), ('jane', 85), ('doe', 75), ('john', 75)] >>> custom_sort([(\\"john\\", 75), (\\"jane\\", 75), (\\"doe\\", 75), (\\"alice\\", 75)]) [('alice', 75), ('doe', 75), ('jane', 75), ('john', 75)] >>> custom_sort([(\\"john\\", 75)]) [('john', 75)] >>> custom_sort([]) [] >>> custom_sort([(\\"john\\", 65), (\\"jane\\", 85), (\\"doe\\", 75), (\\"alice\\", 95)]) [('alice', 95), ('jane', 85), ('doe', 75), ('john', 65)] # Uncomment the lines below to test your implementation # data = [(\\"john\\", 75), (\\"jane\\", 85), (\\"doe\\", 75), (\\"alice\\", 90)] # print(custom_sort(data)) # [('alice', 90), ('jane', 85), ('doe', 75), ('john', 75)]","solution":"def custom_sort(data): Sorts a list of tuples based on score in descending order and name in ascending order if scores are equal. Parameters: data (list of tuples): Each tuple contains a string (name) and an integer (score). Returns: list of tuples: Sorted list based on the criteria. return sorted(data, key=lambda x: (-x[1], x[0]))"}]`),E={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:A,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},j={class:"search-container"},P={class:"card-container"},C={key:0,class:"empty-state"},D=["disabled"],z={key:0},F={key:1};function O(n,e,u,c,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"ðŸ¤”prompts chatðŸ§ ")])],-1)),t("div",j,[e[3]||(e[3]=t("span",{class:"search-icon"},"ðŸ”",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," âœ• ")):l("",!0)]),t("div",P,[(s(!0),r(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",C,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",F,"Loading...")):(s(),r("span",z,"See more"))],8,D)):l("",!0)])}const I=m(E,[["render",O],["__scopeId","data-v-4c14c25d"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/67.md","filePath":"library/67.md"}'),Y={name:"library/67.md"},G=Object.assign(Y,{setup(n){return(e,u)=>(s(),r("div",null,[w(I)]))}});export{B as __pageData,G as default};
